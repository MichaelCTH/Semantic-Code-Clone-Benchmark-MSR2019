$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29928547_29928821_5_33
29928547_29929875_1_31
Title: Java text file remove doubles from four column text file 
----------------------------------------

public static void main (String [] args) throws FileNotFoundException {
    PrintWriter writerInt = new PrintWriter (new File ("sortedInt.txt"));
    PrintWriter writerDou = new PrintWriter (new File ("sortedDou.txt"));
    Scanner reader = new Scanner (new File ("raw.txt"));
    int temp = 0, countInt = 1, countDou = 1;
    while (reader.hasNext ()) {
        String next = reader.next ();
        try {
            temp = Integer.parseInt (next);
            writerInt.print (temp + " ");
            if (countInt % 4 == 0) writerInt.println ();

            countInt ++;
        } catch (NumberFormatException e) {
            try {
                writerDou.print (Double.parseDouble (next) + " ");
                if (countDou % 4 == 0) writerDou.println ();

                countDou ++;
            } catch (NumberFormatException f) {
                System.out.println ("Not a number");
            }
        }
    }
    writerInt.close ();
    writerDou.close ();
    reader.close ();
}
----------------------------------------

public static void main (String [] args) throws IOException {
    List < String > rawLines = Files.readAllLines (Paths.get ("raw.txt"));
    try (Writer intWriter = Files.newBufferedWriter (Paths.get ("int_values.txt"), StandardOpenOption.CREATE_NEW); Writer doubleWriter = Files.newBufferedWriter (Paths.get ("double_values.txt"), StandardOpenOption.CREATE_NEW)) {
        for (String line : rawLines) {
            String [] values = line.split (" ");
            if (values.length != 4) {
                continue;
            }
            doubleWriter.write (values [0]);
            doubleWriter.write (System.lineSeparator ());
            intWriter.write (values [1]);
            intWriter.write (' ');
            intWriter.write (values [2]);
            intWriter.write (' ');
            intWriter.write (values [3]);
            intWriter.write (' ');
            intWriter.write (System.lineSeparator ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29930567_29931688_147_157
29930567_29931688_161_171
Title: Trying to implement JComboBox into program - Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    getText ();
    setText ();
    ExamGrades save = new ExamGrades ();
    save.fileOpen ();
    save.addRecords (firstName, lastName, subjectUnit, examMark);
    JOptionPane.showMessageDialog (null, "Entry Saved!");
    save.fileClose ();
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    try {
        JOptionPane.showMessageDialog (null, "'GradeEnter.txt' opening in Java!");
        Thread.sleep (2);
        Runtime.getRuntime ().exec ("eclipse GradeEnter.txt");
    } catch (Exception NoFileFound) {
        System.out.println ("Couldn't open or find the file.");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29932643_29932743_3_14
29932643_29934099_2_15
Title: What happens when wait() is called on an object not extending Thread or implements Runnable? 
----------------------------------------

public static void main (String [] args) {
    try {
        String str = new String ();
        str.wait ();
    } catch (InterruptedException e) {
        System.out.println (e);
    } catch (IllegalMonitorStateException e) {
        System.out.println (e);
    }
    System.out.println ("Hello World");
}
----------------------------------------

public static void main (String [] args) {
    try {
        Test t = new Test ();
        synchronized (t) {
            System.out.println ("Will wait for 10 secs");
            t.wait (10000);
            System.out.println ("Wait over");
        }
    } catch (Exception e) {
        System.out.println (e);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29932870_29933222_1_18
29932870_41402892_17_37
Title: Optimizing the largest palindrome from product of two three digit numbers? 
----------------------------------------

public static void main (String [] args) {
    int value = 0;
    for (int i = 999;
    i >= 100; i --) {
        int r = value / i;
        if (r >= i) {
            System.out.println ("We broke at i = " + i);
            break;
        }
        for (int j = i;
        j > r; j --) {
            int value1 = i * j;
            if (isPalindrome (value1)) {
                value = value1;
                break;
            }
        }
    }
    System.out.println (value);
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int t = in.nextInt ();
    for (int a0 = 0;
    a0 < t; a0 ++) {
        int n = in.nextInt ();
        int r = 0, m = n;
        int i, j;
        for (i = 999; i >= 100; i --) {
            for (j = 999; j >= m / 999; j --) {
                if (i * j < n && i * j > 100000 && isPalindrome (i * j)) {
                    r = Math.max (i * j, r);
                    m = r;
                }
            }
        }
        System.out.println (r);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2993874_2994098_17_28
2993874_41782398_1_11
Title: Android Broadcast Address 
----------------------------------------

public static String getBroadcast () throws SocketException {
    System.setProperty ("java.net.preferIPv4Stack", "true");
    for (Enumeration < NetworkInterface > niEnum = NetworkInterface.getNetworkInterfaces ();
    niEnum.hasMoreElements ();) {
        NetworkInterface ni = niEnum.nextElement ();
        if (! ni.isLoopback ()) {
            for (InterfaceAddress interfaceAddress : ni.getInterfaceAddresses ()) {
                return interfaceAddress.getBroadcast ().toString ().substring (1);
            }
        }
    }
    return null;
}
----------------------------------------

public static String getBroadcast () throws Exception {
    System.setProperty ("java.net.preferIPv4Stack", "true");
    InetAddress inet = InetAddress.getLocalHost ();
    NetworkInterface net = NetworkInterface.getByInetAddress (inet);
    InterfaceAddress [] interfaceAddresses = net.getInterfaceAddresses ().toArray (new InterfaceAddress [0]);
    if (interfaceAddresses.length > 0) {
        return interfaceAddresses [0].getBroadcast ().toString ().substring (1);
    } else {
        return "255.255.255";
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2993874_2994098_17_28
2993874_9912504_1_27
Title: Android Broadcast Address 
----------------------------------------

public static String getBroadcast () throws SocketException {
    System.setProperty ("java.net.preferIPv4Stack", "true");
    for (Enumeration < NetworkInterface > niEnum = NetworkInterface.getNetworkInterfaces ();
    niEnum.hasMoreElements ();) {
        NetworkInterface ni = niEnum.nextElement ();
        if (! ni.isLoopback ()) {
            for (InterfaceAddress interfaceAddress : ni.getInterfaceAddresses ()) {
                return interfaceAddress.getBroadcast ().toString ().substring (1);
            }
        }
    }
    return null;
}
----------------------------------------

public static String getBroadcast () {
    String found_bcast_address = null;
    System.setProperty ("java.net.preferIPv4Stack", "true");
    try {
        Enumeration < NetworkInterface > niEnum = NetworkInterface.getNetworkInterfaces ();
        while (niEnum.hasMoreElements ()) {
            NetworkInterface ni = niEnum.nextElement ();
            if (! ni.isLoopback ()) {
                for (InterfaceAddress interfaceAddress : ni.getInterfaceAddresses ()) {
                    found_bcast_address = interfaceAddress.getBroadcast ().toString ();
                    found_bcast_address = found_bcast_address.substring (1);
                }
            }
        }
    } catch (SocketException e) {
        e.printStackTrace ();
    }
    return found_bcast_address;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2993874_41782398_1_11
2993874_9912504_1_27
Title: Android Broadcast Address 
----------------------------------------

public static String getBroadcast () throws Exception {
    System.setProperty ("java.net.preferIPv4Stack", "true");
    InetAddress inet = InetAddress.getLocalHost ();
    NetworkInterface net = NetworkInterface.getByInetAddress (inet);
    InterfaceAddress [] interfaceAddresses = net.getInterfaceAddresses ().toArray (new InterfaceAddress [0]);
    if (interfaceAddresses.length > 0) {
        return interfaceAddresses [0].getBroadcast ().toString ().substring (1);
    } else {
        return "255.255.255";
    }
}
----------------------------------------

public static String getBroadcast () {
    String found_bcast_address = null;
    System.setProperty ("java.net.preferIPv4Stack", "true");
    try {
        Enumeration < NetworkInterface > niEnum = NetworkInterface.getNetworkInterfaces ();
        while (niEnum.hasMoreElements ()) {
            NetworkInterface ni = niEnum.nextElement ();
            if (! ni.isLoopback ()) {
                for (InterfaceAddress interfaceAddress : ni.getInterfaceAddresses ()) {
                    found_bcast_address = interfaceAddress.getBroadcast ().toString ();
                    found_bcast_address = found_bcast_address.substring (1);
                }
            }
        }
    } catch (SocketException e) {
        e.printStackTrace ();
    }
    return found_bcast_address;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29945721_29947629_14_23
29945721_29947629_29_43
Title: multithreading and JDBC 
----------------------------------------

public void run () {
    try {
        int l = reader.read ();
        while (l > 0) {
            System.out.println (l);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    try {
        Class.forName ("com.mysql.jdbc.Driver");
        Connection conn = DriverManager.getConnection ("jdbc:mysql://localhost:3306/stage", "root", "");
        Statement s = conn.createStatement ();
        String sql = "select idetudiant from etudiant";
        ResultSet rs = s.executeQuery (sql);
        while (rs.next ()) {
            int k = rs.getInt ("idetudiant");
            writer.write (k);
        }
    } catch (ClassNotFoundException | SQLException | IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29948645_29950158_25_35
29948645_29952496_38_67
Title: Finding the Number of Times an Expression Occurs in a String Continuously and Non Continuously 
----------------------------------------

public static boolean parse (String input, int searchFromIndex, List < String > tokensToSeach, int currentTokenIndex) {
    if (currentTokenIndex >= tokensToSeach.size ()) return true;

    String token = tokensToSeach.get (currentTokenIndex);
    int found = input.indexOf (token, searchFromIndex);
    if (found >= 0) {
        System.out.println ("Found at Index " + found + " Token " + token);
        return parse (input, searchFromIndex + 1, tokensToSeach, currentTokenIndex + 1);
    }
    return false;
}
----------------------------------------

private static String [] parse (String expression) {
    List < String > searchTokens = new ArrayList < String > ();
    char lastChar = 0;
    for (int i = 0;
    i < expression.length (); i ++) {
        char c = expression.charAt (i);
        char [] chars;
        switch (c) {
            case '+' :
                chars = new char [2];
                Arrays.fill (chars, lastChar);
                searchTokens.add (String.valueOf (chars));
                lastChar = 0;
                break;
            case '-' :
                chars = new char [4];
                Arrays.fill (chars, lastChar);
                searchTokens.add (String.valueOf (chars));
                lastChar = 0;
                break;
            default :
                if (lastChar != 0) {
                    searchTokens.add (String.valueOf (lastChar));
                }
                lastChar = c;
        }
    }
    return searchTokens.toArray (new String [searchTokens.size ()]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29948645_29950158_5_23
29948645_29952496_7_15
Title: Finding the Number of Times an Expression Occurs in a String Continuously and Non Continuously 
----------------------------------------

public static void main (String [] args) {
    String input = "aksdbaalaskdhfbblajdfhacccc aoudgalsaa bblisdfhcccc";
    System.out.println (input);
    for (int i = 0;
    i < input.length (); i ++) {
        System.out.print (i / 10);
    }
    System.out.println ();
    for (int i = 0;
    i < input.length (); i ++) {
        System.out.print (i % 10);
    }
    System.out.println ();
    List < String > tokenisedSearch = parseExp ("a+b+c-");
    System.out.println (tokenisedSearch);
    parse (input, 0, tokenisedSearch, 0);
}
----------------------------------------

public static void main (String [] args) {
    String haystack = "aksdbaalaskdhfbblajdfhacccc aoudgalsaa bblisdfhcccc";
    String [] needles = parse ("a+b+c-");
    System.out.println ("Needles: " + Arrays.toString (needles));
    System.out.println ("Found: " + find (haystack, needles, 0));
    needles = parse ("ab+c-");
    System.out.println ("Needles: " + Arrays.toString (needles));
    System.out.println ("Found: " + find (haystack, needles, 0));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29950160_29950946_6_24
29950160_29950962_38_55
Title: Merge Sort count number of swaps and compares 
----------------------------------------

public void mergeSort (int [] a, int howMany) {
    swapCount = 0;
    compCount = 0;
    if (a.length >= 2) {
        int [] left = Arrays.copyOfRange (a, 0, a.length / 2);
        int [] right = Arrays.copyOfRange (a, a.length / 2, a.length);
        mergeSort (left, howMany);
        mergeSort (right, howMany);
        merge (a, left, right);
    }
}
----------------------------------------

public void mergeSort (int [] a, IntWrapper compares, IntWrapper swaps) {
    if (a.length >= 2) {
        int [] left = Arrays.copyOfRange (a, 0, a.length / 2);
        int [] right = Arrays.copyOfRange (a, a.length / 2, a.length);
        mergeSort (left, compares, swaps);
        mergeSort (right, compares, swaps);
        merge (a, left, right, compares, swaps);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29953862_29956699_13_39
29953862_36069100_41_126
Title: Java : How do I group all java Dates in their corresponding week? 
----------------------------------------

public static void main (String [] args) {
    SimpleDateFormat sdf = new SimpleDateFormat ("MM/dd/yyyy");
    DateTimeFormatter dtf = DateTimeFormatter.ofPattern ("MM/dd/yyyy");
    List < LocalDate > dates = new ArrayList < LocalDate > (25);
    dates.add (LocalDate.parse ("04/01/2015", dtf));
    dates.add (LocalDate.parse ("04/02/2015", dtf));
    dates.add (LocalDate.parse ("04/03/2015", dtf));
    dates.add (LocalDate.parse ("04/04/2015", dtf));
    dates.add (LocalDate.parse ("04/05/2015", dtf));
    dates.add (LocalDate.parse ("04/06/2015", dtf));
    dates.add (LocalDate.parse ("04/07/2015", dtf));
    dates.add (LocalDate.parse ("04/08/2015", dtf));
    dates.add (LocalDate.parse ("04/09/2015", dtf));
    int week = 0;
    int woy = - 1;
    Collections.sort (dates, new WeekComparator ());
    for (LocalDate date : dates) {
        if (woy != getWeekOfYear (date)) {
            woy = getWeekOfYear (date);
            week ++;
            System.out.println ("Week " + week + ":");
        }
        System.out.println (date);
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        List < Date > datesToGroup = new ArrayList < Date > ();
        SimpleDateFormat sdf = new SimpleDateFormat ("MM/dd/yyyy");
        datesToGroup.add (sdf.parse ("04/01/2015"));
        datesToGroup.add (sdf.parse ("04/02/2015"));
        datesToGroup.add (sdf.parse ("04/03/2015"));
        datesToGroup.add (sdf.parse ("04/04/2015"));
        datesToGroup.add (sdf.parse ("04/05/2015"));
        datesToGroup.add (sdf.parse ("04/06/2015"));
        datesToGroup.add (sdf.parse ("04/07/2015"));
        datesToGroup.add (sdf.parse ("04/08/2015"));
        datesToGroup.add (sdf.parse ("04/09/2015"));
        datesToGroup.add (sdf.parse ("12/27/2015"));
        datesToGroup.add (sdf.parse ("12/28/2015"));
        datesToGroup.add (sdf.parse ("12/29/2015"));
        datesToGroup.add (sdf.parse ("12/30/2015"));
        datesToGroup.add (sdf.parse ("12/31/2015"));
        datesToGroup.add (sdf.parse ("01/01/2016"));
        datesToGroup.add (sdf.parse ("01/02/2016"));
        datesToGroup.add (sdf.parse ("01/03/2016"));
        datesToGroup.add (sdf.parse ("01/04/2016"));
        final Map < Integer, List < Date > > groupedDatesByWeekOfYear = new HashMap < Integer, List < Date > > () {
            private static final long serialVersionUID = 1L;
            @Override
            public List < Date > get (Object key) {
                List < Date > list = super.get (key);
                if (list == null) {
                    list = new ArrayList < Date > ();
                    super.put ((Integer) key, list);
                }
                return list;
            }}

        ;
        for (Date date : datesToGroup) {
            Calendar cal = Calendar.getInstance ();
            cal.setTime (date);
            Calendar previousYearLastDate = Calendar.getInstance ();
            previousYearLastDate.set (Calendar.YEAR, cal.get (Calendar.YEAR) - 1);
            previousYearLastDate.set (Calendar.MONTH, 11);
            previousYearLastDate.set (Calendar.DAY_OF_MONTH, previousYearLastDate.getActualMaximum (Calendar.DAY_OF_MONTH));
            int yearWeekOfYearHashCode = 0;
            if (cal.get (Calendar.MONTH) == 0 && cal.get (Calendar.WEEK_OF_YEAR) == previousYearLastDate.get (Calendar.WEEK_OF_YEAR)) {
                yearWeekOfYearHashCode = getYearWeekOfYearHashCode (previousYearLastDate.get (Calendar.YEAR), previousYearLastDate.get (Calendar.WEEK_OF_YEAR));
            } else {
                yearWeekOfYearHashCode = getYearWeekOfYearHashCode (cal.get (Calendar.YEAR), cal.get (Calendar.WEEK_OF_YEAR));
            }
            groupedDatesByWeekOfYear.get (yearWeekOfYearHashCode).add (date);
        }
        for (Integer yearWeekOfYearHashCode : groupedDatesByWeekOfYear.keySet ()) {
            System.out.println ("year=" + getYearFromHashCode (yearWeekOfYearHashCode) + ", weekOfYear=" + getWeekOfYearFromHashCode (yearWeekOfYearHashCode) + ", dates under this week ");
            List < Date > datesInThisWeek = groupedDatesByWeekOfYear.get (yearWeekOfYearHashCode);
            for (Date date : datesInThisWeek) {
                System.out.println (date);
                Calendar cal = Calendar.getInstance ();
                cal.setTime (date);
            }
            System.out.println ();
        }
    } catch (ParseException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29956919_29957178_1_16
29956919_43360794_5_21
Title: "How to do fizzBuzz in Java Recursively And Efficiently at the same time" 
----------------------------------------

private static String [] recurFizzBuzz (String [] result, int index, int start, int end) {
    if (index > result.length) {
        return result;
    }
    if (index % 15 == 0) {
        result [index - 1] = "FizzBuzz";
    } else if (index % 3 == 0) {
        result [index - 1] = "Fizz";
    } else if (index % 5 == 0) {
        result [index - 1] = "Buzz";
    } else {
        result [index - 1] = Integer.toString (index);
    }

    return recurFizzBuzz (result, index + 1, start, end);
}
----------------------------------------

public String [] recurFizzBuzz (String [] result, int index, int start, int end) {
    if (index == (end - start)) {
        return result;
    }
    result [index] = "";
    if ((index + start) % 3 == 0) {
        result [index] += "Fizz";
    }
    if ((index + start) % 5 == 0) {
        result [index] += "Buzz";
    }
    if (result [index] == "") {
        result [index] = String.valueOf (index + start);
    }
    return recurFizzBuzz (result, index + 1, start, end);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29956919_29957220_1_26
29956919_39087281_1_28
Title: "How to do fizzBuzz in Java Recursively And Efficiently at the same time" 
----------------------------------------

public void fizzBuzz (int [] array, String [] output, int start, int end, int i) {
    if (array [i] % 3 == 0 && array [i] % 5 == 0) {
        output [i] = "FizzBuzz";
    } else if (array [i] % 3 == 0) {
        output [i] = "Fizz";
    } else if (array [i] % 5 == 0) {
        output [i] = "Buzz";
    } else {
        output [i] = array [i];
    }

    i ++;
    if (i >= end) {
        return output;
    } else fizzBuzz (array, output, end, i);

}
----------------------------------------

public String [] fizzBuzz (int start, int end) {
    String [] a = new String [end - start];
    for (int i = start, j = 0;
    i <= end && j < a.length; i ++, j ++) {
        if (i % 15 == 0) {
            a [j] = String.valueOf ("FizzBuzz");
        } else if (i % 3 == 0) {
            a [j] = String.valueOf ("Fizz");
        } else if (i % 5 == 0) {
            a [j] = String.valueOf ("Buzz");
        } else {
            a [j] = String.valueOf (i);
        }

    }
    return a;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29958344_29959005_1_21
29958344_29967983_1_18
Title: Iterating through arrays 
----------------------------------------

public static void main (String [] args) {
    String inp = "hsaadhiewhuwccwecwec";
    HashMap < Character, Integer > countcharact = new HashMap < > ();
    int j = 0;
    for (int i = 0;
    i < inp.length (); i ++) {
        if (countcharact.containsKey (inp.charAt (i)) == true) {
            j = countcharact.get (inp.charAt (i));
            countcharact.put (inp.charAt (i), j + 1);
        } else countcharact.put (inp.charAt (i), 1);

    }
    Set < Character > s = countcharact.keySet ();
    for (Character c : s) {
        System.out.println (c + " " + countcharact.get (c) + " times");
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] input = {1, 2, 4, 5, 2, 9, 2};
    int p = 0, maximum = 0, start = 0;
    while (p < input.length - 3) {
        if (input [p] + input [p + 1] + input [p + 2] > maximum) {
            start = p;
            maximum = input [p] + input [p + 1] + input [p + 2];
        }
        p ++;
    }
    for (int i = start;
    i < start + 3; i ++) System.out.print (input [i] + "+");

    System.out.print ("=" + maximum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29958597_29958657_1_22
29958597_29958668_16_36
Title: How to reduce image without losing quality and preserving the aspect ratio? 
----------------------------------------

public static int calculateInSampleSize (BitmapFactory.Options options, int reqWidth, int reqHeight) {
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;
    if (height > reqHeight || width > reqWidth) {
        final int halfHeight = height / 2;
        final int halfWidth = width / 2;
        while ((halfHeight / inSampleSize) > reqHeight && (halfWidth / inSampleSize) > reqWidth) {
            inSampleSize *= 2;
        }
    }
    return inSampleSize;
}
----------------------------------------

public static int calculateInSampleSize (BitmapFactory.Options options, int reqWidth, int reqHeight) {
    final int height = options.outHeight;
    final int width = options.outWidth;
    int inSampleSize = 1;
    if (height > reqHeight || width > reqWidth) {
        final int halfHeight = height / 2;
        final int halfWidth = width / 2;
        while ((halfHeight / inSampleSize) > reqHeight && (halfWidth / inSampleSize) > reqWidth) {
            inSampleSize *= 2;
        }
    }
    return inSampleSize;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29966721_29967829_1_10
29966721_29979143_18_36
Title: Comparing two attributes values using SAX and Java 
----------------------------------------

public void endElement (String uri, String localName, String qName) {
    if (builder.toString ().equals ("temperature")) temprature_label = builder1.toString ();
    else if (builder.toString ().equals ("t")) {
        if (builder1.toString ().equals (temprature_label)) System.out.println ("okkk");
        else System.out.println ("not ok");

    }

}
----------------------------------------

@Override
public void endElement (String uri, String localName, String qName) throws SAXException {
    if (temp != null) {
        if (temp.equalsIgnoreCase ("temperature")) {
            label = lab;
        } else if (temp.equalsIgnoreCase ("t")) {
            System.out.println ("temp " + temp + " lab " + lab);
            if (lab.equals (label)) {
                System.out.println ("okk");
            } else {
                System.out.println ("not ok");
            }
        }

        blabel = false;
        bnameatt = false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29975787_29976444_4_37
29975787_29977624_1_27
Title: How do you read/write and combine the output of multiple .text files and create a single .txt file? 
----------------------------------------

public static void main (String [] args) throws IOException {
    String target_dir = "C:\\Files";
    String output = "C:\\Files\\output.txt";
    File dir = new File (target_dir);
    File [] files = dir.listFiles ();
    for (File textfiles : files) {
        if (textfiles.isFile () && textfiles.getName ().endsWith (".txt")) {
            BufferedReader inputStream = null;
            try {
                inputStream = new BufferedReader (new FileReader (textfiles));
                String line;
                PrintWriter outputStream = new PrintWriter (output);
                while ((line = inputStream.readLine ()) != null) {
                    System.out.println (line);
                    outputStream.println (line);
                }
                outputStream.close ();
            } finally {
                if (inputStream != null) {
                    inputStream.close ();
                }
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    String targetDir = "Path to your directory of input files";
    String outputFile = "Path to your output file";
    File dir = new File (targetDir);
    File [] files = dir.listFiles (new FilenameFilter () {
        @Override
        public boolean accept (File dir, String name) {
            return name.toLowerCase ().endsWith (".txt");
        }}

    );
    List < String > inputFileLines = new ArrayList < > ();
    for (File file : files) {
        inputFileLines.addAll (Files.readAllLines (Paths.get (file.getAbsolutePath ())));
    }
    for (String line : inputFileLines) {
        System.out.println (line);
    }
    Files.write (Paths.get (outputFile), inputFileLines, StandardOpenOption.CREATE);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29975830_32635152_1_13
29975830_32635527_3_20
Title: Perfect Number program java 
----------------------------------------

public static void main (String [] args) {
    int min = 2;
    int max = 1000000;
    int sum = 0;
    for (; min <= max; min ++, sum = 0) {
        for (int e = 1;
        e < min; e ++) sum += ((min % e) == 0) ? e : 0;

        if (sum == min) {
            System.out.println (sum);
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int n, i, j, count = 0;
    for (i = 2; i <= 25; i ++) {
        for (j = 1; j <= i; j ++) {
            if (i % j == 0) {
                count ++;
            }
        }
        if (count == 2) System.out.println (i);

        count = 0;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29975900_29976115_1_31
29975900_29976214_17_37
Title: How to create item objects from reading a text file? 
----------------------------------------

public void open () {
    try {
        ArrayList < Item > list = new ArrayList < Item > ();
        FileReader fileReader = new FileReader (file);
        BufferedReader bufferedReader = new BufferedReader (fileReader);
        StringBuffer stringBuffer = new StringBuffer ();
        String line;
        while ((line = bufferedReader.readLine ()) != null) {
            Item itm = new Item ();
            String [] splitLine = line.split ("\\$");
            item.title = splitLine [0];
            item.format = splitLine [1];
            item.onLoan = Boolean.parseBoolean (splitLine [2]);
            item.loanedTo = splitLine [3];
            item.dateLoaned = splitLine [4];
            list.add (itm);
            stringBuffer.append (line);
            stringBuffer.append ("\n");
        }
        fileReader.close ();
        System.out.println ("Contents of file:");
        System.out.println (stringBuffer.toString ());
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void open () {
    try {
        FileReader fileReader = new FileReader (file);
        BufferedReader bufferedReader = new BufferedReader (fileReader);
        StringBuffer stringBuffer = new StringBuffer ();
        int arraySize = Integer.parseInt (stringBuffer.readLine ());
        Object [] array = new Object [arraySize];
        int index = 0;
        String line;
        while ((line = bufferedReader.readLine ()) != null) {
            Object o = array [index ++] = o;
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29981828_29981860_5_63
29981828_29981940_8_45
Title: JAVA - store letters and number of letters in string 
----------------------------------------

public static void main (String [] args) {
    int i;
    String [] upper = new String [25];
    String [] lowerChar = new String [25];
    int [] lowerCharNum = new int [25];
    Scanner input = new Scanner (System.in);
    System.out.println ("Please enter a phrase");
    String phrase = "abccddee";
    String [] letters = new String [phrase.length ()];
    System.out.println ("letters length: " + letters.length);
    letters = phrase.split ("");
    for (i = 0; i < letters.length; i ++) {
        lowerChar [i] = letters [i];
        switch (letters [i]) {
            case "a" :
                lowerCharNum [0] += 1;
                break;
            case "b" :
                lowerCharNum [1] += 1;
                break;
            case "c" :
                lowerCharNum [2] += 1;
                break;
            case "d" :
                lowerCharNum [3] += 1;
                break;
            case "e" :
                lowerCharNum [4] += 1;
                break;
            case "f" :
                lowerCharNum [5] += 1;
                break;
        }
    }
    for (i = 0; i < 5; i ++) System.out.println (lowerChar [i] + ": " + lowerCharNum [i]);

}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Please enter a phrase");
    String phrase = "abccddee";
    char [] letters = phrase.toCharArray ();
    System.out.println ("letters length: " + letters.length);
    Map < Character, Integer > characterCounts = new HashMap < > ();
    for (int i = 0;
    i < letters.length; i ++) {
        Character character = letters [i];
        if (characterCounts.containsKey (character)) {
            characterCounts.put (character, characterCounts.get (character) + 1);
        } else {
            characterCounts.put (lowerChar, 1);
        }
    }
    for (Map.Entry < Character, Integer > entry : characterCounts.entrySet ()) {
        System.out.println (entry.getKey () + ": " + entry.getValue ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29984399_29984470_1_13
29984399_29984773_1_19
Title: Designing a method to return a boolean value 
----------------------------------------

public boolean isSongString (String s) {
    if (s == null) return true;

    char [] allowedChars = new char [] {'d', 'r', 'm', 'f', 's', 'l', 't'};
    for (int i = 0;
    i < s.length (); i ++) {
        if (Arrays.asList (allowedChars).contains (s.charAt (i))) continue;
        else return false;

    }
    return true;
}
----------------------------------------

public boolean isSongString (String s) {
    int i = 0;
    int j = 0;
    while (i < s.length () - 1) {
        char a = s.charAt (i);
        if (a == 'd' | a == 'r' | a == 'm' | a == 'f' | a == 's' | a == 'l' | a == 't') j ++;
        else break;

        i ++;
    }
    if (j == s.length ()) return true;
    else return false;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29988826_29989818_5_21
29988826_29989856_2_31
Title: "Transferring data from input to output File getting Exception" 
----------------------------------------

public static void main (String [] args) {
    String path1 = "E:\\IO\\Input.txt";
    String path2 = "E:\\IO\\Output.txt";
    int data;
    System.out.println ("Transfering started...");
    try (FileInputStream fis = new FileInputStream (path1); FileOutputStream fos = new FileOutputStream (path2)) {
        while ((data = fis.read ()) != - 1) {
            fos.write (data);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    String path1 = "E:\\IO\\Input.txt";
    String path2 = "E:\\IO\\Output.txt";
    int data;
    System.out.println ("Transfering started...");
    FileInputStream fis = null;
    FileOutputStream fos = null;
    try {
        fis = new FileInputStream (path1);
        fos = new FileOutputStream (path2);
        while ((data = fis.read ()) != - 1) {
            fos.write (data);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        try {
            if (fis != null) {
                fis.close ();
            }
            if (fos != null) {
                fos.close ();
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }
    System.out.println ("Completed...");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29996070_29996205_1_14
29996070_43875118_1_12
Title: "Using int double and long in calculation of powers" 
----------------------------------------

public static long powerN (int number, int power) {
    if (power == 0) return 1;

    int result = number;
    while (power > 1) {
        result *= number;
        power --;
    }
    return (long) result;
}
----------------------------------------

long powerN (long number, int power) {
    long res = 1;
    long sq = number;
    while (power > 0) {
        if (power % 2 == 1) {
            res *= sq;
        }
        sq = sq * sq;
        power /= 2;
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29999958_30000031_1_18
29999958_30000087_1_17
Title: Execution with If statements 
----------------------------------------

public static void parseFile (String s) throws FileNotFoundException {
    File file = new File ("data.txt");
    Scanner scanner = new Scanner (file);
    int flag_found = 0;
    while (scanner.hasNextLine ()) {
        final String lineFromFile = scanner.nextLine ();
        if (lineFromFile.contains (s)) {
            System.out.println (lineFromFile);
            flag_found = 1;
        }
    }
    if (flag_found == 0) {
        Writer ();
    }
}
----------------------------------------

public static void parseFile (String s) throws FileNotFoundException {
    File file = new File ("data.txt");
    Scanner scanner = new Scanner (file);
    while (scanner.hasNextLine ()) {
        final String lineFromFile = scanner.nextLine ();
        if (lineFromFile.contains (s)) {
            System.out.println (lineFromFile);
            break;
        } else {
            Writer ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29999958_30000031_1_18
29999958_30000094_1_20
Title: Execution with If statements 
----------------------------------------

public static void parseFile (String s) throws FileNotFoundException {
    File file = new File ("data.txt");
    Scanner scanner = new Scanner (file);
    int flag_found = 0;
    while (scanner.hasNextLine ()) {
        final String lineFromFile = scanner.nextLine ();
        if (lineFromFile.contains (s)) {
            System.out.println (lineFromFile);
            flag_found = 1;
        }
    }
    if (flag_found == 0) {
        Writer ();
    }
}
----------------------------------------

public static String parseFile (String s) throws FileNotFoundException {
    File file = new File ("data.txt");
    boolean inputFound = false;
    Scanner scanner = new Scanner (file);
    String lineFromFile;
    while (scanner.hasNextLine ()) {
        lineFromFile = scanner.nextLine ();
        if (lineFromFile.contains (s)) {
            inputFound = true;
            break;
        }
    }
    if (! inputFound) {
        writer ();
        return "";
    } else {
        return lineFromFile;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29999958_30000087_1_17
29999958_30000094_1_20
Title: Execution with If statements 
----------------------------------------

public static void parseFile (String s) throws FileNotFoundException {
    File file = new File ("data.txt");
    Scanner scanner = new Scanner (file);
    while (scanner.hasNextLine ()) {
        final String lineFromFile = scanner.nextLine ();
        if (lineFromFile.contains (s)) {
            System.out.println (lineFromFile);
            break;
        } else {
            Writer ();
        }
    }
}
----------------------------------------

public static String parseFile (String s) throws FileNotFoundException {
    File file = new File ("data.txt");
    boolean inputFound = false;
    Scanner scanner = new Scanner (file);
    String lineFromFile;
    while (scanner.hasNextLine ()) {
        lineFromFile = scanner.nextLine ();
        if (lineFromFile.contains (s)) {
            inputFound = true;
            break;
        }
    }
    if (! inputFound) {
        writer ();
        return "";
    } else {
        return lineFromFile;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30006634_30006684_1_12
30006634_30006691_2_13
Title: Errors in Program which seem to be beyond my understanding 
----------------------------------------

public static void main (String [] args) {
    char upperCase, lowerCase;
    int i;
    upperCase = 'A';
    lowerCase = 'a';
    for (i = 1; i <= 26; i ++) {
        System.out.println (upperCase + "\t" + lowerCase);
        upperCase ++;
        lowerCase ++;
    }
}
----------------------------------------

public static void main (String [] args) {
    char upperCase, lowerCase;
    int i;
    upperCase = 'A';
    lowerCase = 'a';
    for (i = 1; i <= 26; i ++) {
        System.out.println (upperCase + "\t" + lowerCase);
        upperCase ++;
        lowerCase ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30006677_30006749_1_11
30006677_50763742_80_96
Title: Concurrent checking if collection is empty 
----------------------------------------

public void run () {
    while (! intervals.isEmpty ()) {
        Thread t = new Thread (new Runnable () {
        }

        );
        t.run ();
    }
}
----------------------------------------

public void run () {
    System.out.println ("taking element " + element);
    for (Long l = (long) 0;
    l < 500000000L; l ++) {
    }
    for (Long l = (long) 0;
    l < 500000000L; l ++) {
    }
    for (Long l = (long) 0;
    l < 500000000L; l ++) {
    }
    if (element < 7) {
        this.queue.add (element + 1);
        System.out.println ("Inserted element" + (element + 1));
    } else {
        System.out.println ("no insertion");
    }
    this.availableThreadsTokens.offer (1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30009462_30009503_2_16
30009462_30009540_1_12
Title: How do I modify the code so it only prints cells E and F? 
----------------------------------------

public static void main (String [] args) throws Exception {
    File f = new File ("/users/Me/Documents/Test.xls");
    Workbook wb = Workbook.getWorkbook (f);
    Sheet s = wb.getSheet (0);
    int row = s.getRows ();
    int col = s.getColumns ();
    for (int i = 0;
    i < row; i ++) for (int j = 0;
    j < col; j ++) {
        Cell c = s.getCell (j, i);
        if (! doesCellMeetMyCondition (c)) continue;

        System.out.print (c.getContents () + "\t");
    }

    System.out.println ("");
}
----------------------------------------

public static void main (String [] args) throws Exception {
    File f = new File ("/users/Me/Documents/Test.xls");
    Workbook wb = Workbook.getWorkbook (f);
    Sheet s = wb.getSheet (0);
    int row = s.getRows ();
    int col = s.getColumns ();
    for (int i = 0;
    i < row; i ++) {
        Cell c = s.getCell (4, i);
        System.out.print (c.getContents () + "\t");
    }
    System.out.println ("");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30009488_30009660_15_38
30009488_30205035_23_46
Title: parsing a quadratic equation in java 
----------------------------------------

public static String [] quadParse (String arg) {
    String str = ("+" + arg).replaceAll ("\\s", "");
    double a1 = coeff (str, "([+-][0-9]*)x\\^2");
    double b1 = coeff (str, "([+-][0-9]*)x(?!\\^)");
    double c1 = coeff (str, "([+-][0-9]+)(?!x)");
    System.out.println ("Values are a: " + a1 + " b: " + b1 + " c: " + c1);
    double dis = (Math.pow (b1, 2.0)) - (4 * a1 * c1);
    double d = Math.sqrt (dis);
    double X = 0, Y = 0;
    if (dis > 0.0 || dis < 0.0) {
        X = (- b1 + d) / (2.0 * a1);
        Y = (- b1 - d) / (2.0 * a1);
        String root1 = Double.toString (X);
        String root2 = Double.toString (Y);
        return new String [] {root1, root2};
    } else if (dis == 0.0) {
        X = (- b1 + 0.0) / (2.0 * a1);
        String root2 = Double.toString (X);
        return new String [] {root2};
    }

    return new String [- 1];
}
----------------------------------------

public static String [] quadParse (String arg) {
    String str = ("+" + arg).replaceAll ("\\s", "");
    double a1 = Double.parseDouble (coeff (str, "([+-][0-9]*)([a-z]\\^2)"));
    double b1 = Double.parseDouble (coeff (str, "([+-][0-9]*)([a-z](?!\\^))"));
    double c1 = Double.parseDouble (coeff (str, "([+-][0-9]+)(?![a-z])"));
    System.out.println ("Values are a: " + a1 + " b: " + b1 + " c: " + c1);
    double dis = (Math.pow (b1, 2.0)) - (4 * a1 * c1);
    double d = Math.sqrt (dis);
    double X = 0, Y = 0;
    if (dis > 0.0 || dis < 0.0) {
        X = (- b1 + d) / (2.0 * a1);
        Y = (- b1 - d) / (2.0 * a1);
        String root1 = Double.toString (X);
        String root2 = Double.toString (Y);
        return new String [] {root1, root2};
    } else if (dis == 0.0) {
        X = (- b1 + 0.0) / (2.0 * a1);
        String root2 = Double.toString (X);
        return new String [] {root2};
    }

    return new String [- 1];
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30009488_30009660_2_14
30009488_30205035_2_22
Title: parsing a quadratic equation in java 
----------------------------------------

public static double coeff (String str, String regex) {
    Pattern patt = Pattern.compile (regex);
    Matcher match = patt.matcher (str);
    String coeff = "+0";
    double value = 0;
    while (match.find ()) {
        coeff = match.group (1);
        value = value + Double.parseDouble (coeff);
    }
    return (coeff.length () == 1) ? (value + 1) : value;
}
----------------------------------------

public static String coeff (String str, String regex) {
    Pattern patt = Pattern.compile (regex);
    Matcher match = patt.matcher (str);
    String coeff = "+0";
    double value = 0;
    if (match.find ()) coeff = match.group (1);

    value = Double.parseDouble ((coeff.length () == 1) ? coeff + "1" : coeff);
    while (match.find ()) {
        coeff = match.group (1);
        value = value + Double.parseDouble (coeff);
    }
    String value2 = String.valueOf (value);
    return (value2.length () == 1) ? (value2 + "1") : value2;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30021160_30021190_1_16
30021160_43806888_20_47
Title: NullPointerException (Java) 
----------------------------------------

private void run () {
    switch (userInput) {
        case 1 :
            songDatabase.addNewSong ();
            break;
        case 2 :
            songDatabase.removeSong ();
            break;
        case 3 :
            songDatabase.sortSongs ();
            break;
        default :
            System.out.println ("Please enter a valid number.");
            break;
    }
}
----------------------------------------

private void run () {
    System.out.println ("1. Add Song");
    System.out.println ("2. Remove Song");
    System.out.println ("3. Sort Song");
    System.out.print ("Please Enter Choice: ");
    int userInput = console.nextInt ();
    switch (userInput) {
        case 1 :
            this.songDatabase.addNewSong ();
            break;
        case 2 :
            this.songDatabase.removeSong ();
            break;
        case 3 :
            this.songDatabase.sortSongs ();
            break;
        default :
            System.out.println ("Please enter a valid number.");
            break;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30022032_30022437_1_26
30022032_30025325_1_17
Title: How to make program quicker [Keypad_Sticky_Note] 
----------------------------------------

public static int answer (int s, int x) {
    HashSet < Integer > num = new HashSet < > ();
    int a;
    int b;
    int sum;
    int finalans;
    for (int i = 0;
    i <= s; i ++) {
        for (int e = 0;
        e <= s; e ++) {
            sum = i + e;
            if (sum == s) {
                if ((i ^ e) == x) {
                    num.add (i);
                    num.add (e);
                }
            }
        }
    }
    finalans = num.size ();
    if ((finalans % 2) == 0) {
        return finalans * 2;
    } else {
        return finalans;
    }
}
----------------------------------------

public static int answer (int s, int x) {
    int result = 0;
    if (s % 2 == x % 2) {
        for (int a = 0;
        a <= s / 2; a ++) {
            int b = s - a;
            if ((a ^ b) == x) {
                result += 2;
            }
        }
        if (s % 2 == 0 && ((s / 2) ^ (s / 2)) == x) {
            result --;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30022032_30022437_1_26
30022032_30146749_15_25
Title: How to make program quicker [Keypad_Sticky_Note] 
----------------------------------------

public static int answer (int s, int x) {
    HashSet < Integer > num = new HashSet < > ();
    int a;
    int b;
    int sum;
    int finalans;
    for (int i = 0;
    i <= s; i ++) {
        for (int e = 0;
        e <= s; e ++) {
            sum = i + e;
            if (sum == s) {
                if ((i ^ e) == x) {
                    num.add (i);
                    num.add (e);
                }
            }
        }
    }
    finalans = num.size ();
    if ((finalans % 2) == 0) {
        return finalans * 2;
    } else {
        return finalans;
    }
}
----------------------------------------

public static int answer (int sum, int xor) {
    int numBitsPerInt = Integer.toBinaryString (Integer.MAX_VALUE).length () + 1;
    int [] [] cache = new int [numBitsPerInt] [2];
    for (int i = 0;
    i < numBitsPerInt; ++ i) {
        cache [i] [0] = NOT_SET;
        cache [i] [1] = NOT_SET;
    }
    return answer (sum, xor, 0, 0, cache);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30022032_30022437_1_26
30022032_30146749_28_95
Title: How to make program quicker [Keypad_Sticky_Note] 
----------------------------------------

public static int answer (int s, int x) {
    HashSet < Integer > num = new HashSet < > ();
    int a;
    int b;
    int sum;
    int finalans;
    for (int i = 0;
    i <= s; i ++) {
        for (int e = 0;
        e <= s; e ++) {
            sum = i + e;
            if (sum == s) {
                if ((i ^ e) == x) {
                    num.add (i);
                    num.add (e);
                }
            }
        }
    }
    finalans = num.size ();
    if ((finalans % 2) == 0) {
        return finalans * 2;
    } else {
        return finalans;
    }
}
----------------------------------------

public static int answer (int sum, int xor, int carry, int index, int [] [] cache) {
    if (cache [index] [carry] != NOT_SET) {
        return cache [index] [carry];
    }
    if ((sum>> index) == 0 && (xor>> index) == 0 && carry == 0) {
        return 1;
    }
    int sumLSB = (sum>> index) & 1;
    int xorLSB = (xor>> index) & 1;
    int result = 0;
    if (carry == 0) {
        if (xorLSB == 0 && sumLSB == 0) {
            result = answer (sum, xor, 0, index + 1, cache) + answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 0 && sumLSB == 1) {
            result = 0;
        } else if (xorLSB == 1 && sumLSB == 0) {
            result = 0;
        } else if (xorLSB == 1 && sumLSB == 1) {
            result = 2 * answer (sum, xor, 0, index + 1, cache);
        }

    } else {
        if (xorLSB == 0 && sumLSB == 0) {
            result = 0;
        } else if (xorLSB == 0 && sumLSB == 1) {
            result = answer (sum, xor, 0, index + 1, cache) + answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 1 && sumLSB == 0) {
            result = 2 * answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 1 && sumLSB == 1) {
            result = 0;
        }

    }
    cache [index] [carry] = result;
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30022032_30025325_1_17
30022032_30146749_15_25
Title: How to make program quicker [Keypad_Sticky_Note] 
----------------------------------------

public static int answer (int s, int x) {
    int result = 0;
    if (s % 2 == x % 2) {
        for (int a = 0;
        a <= s / 2; a ++) {
            int b = s - a;
            if ((a ^ b) == x) {
                result += 2;
            }
        }
        if (s % 2 == 0 && ((s / 2) ^ (s / 2)) == x) {
            result --;
        }
    }
    return result;
}
----------------------------------------

public static int answer (int sum, int xor) {
    int numBitsPerInt = Integer.toBinaryString (Integer.MAX_VALUE).length () + 1;
    int [] [] cache = new int [numBitsPerInt] [2];
    for (int i = 0;
    i < numBitsPerInt; ++ i) {
        cache [i] [0] = NOT_SET;
        cache [i] [1] = NOT_SET;
    }
    return answer (sum, xor, 0, 0, cache);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30022032_30025325_1_17
30022032_30146749_28_95
Title: How to make program quicker [Keypad_Sticky_Note] 
----------------------------------------

public static int answer (int s, int x) {
    int result = 0;
    if (s % 2 == x % 2) {
        for (int a = 0;
        a <= s / 2; a ++) {
            int b = s - a;
            if ((a ^ b) == x) {
                result += 2;
            }
        }
        if (s % 2 == 0 && ((s / 2) ^ (s / 2)) == x) {
            result --;
        }
    }
    return result;
}
----------------------------------------

public static int answer (int sum, int xor, int carry, int index, int [] [] cache) {
    if (cache [index] [carry] != NOT_SET) {
        return cache [index] [carry];
    }
    if ((sum>> index) == 0 && (xor>> index) == 0 && carry == 0) {
        return 1;
    }
    int sumLSB = (sum>> index) & 1;
    int xorLSB = (xor>> index) & 1;
    int result = 0;
    if (carry == 0) {
        if (xorLSB == 0 && sumLSB == 0) {
            result = answer (sum, xor, 0, index + 1, cache) + answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 0 && sumLSB == 1) {
            result = 0;
        } else if (xorLSB == 1 && sumLSB == 0) {
            result = 0;
        } else if (xorLSB == 1 && sumLSB == 1) {
            result = 2 * answer (sum, xor, 0, index + 1, cache);
        }

    } else {
        if (xorLSB == 0 && sumLSB == 0) {
            result = 0;
        } else if (xorLSB == 0 && sumLSB == 1) {
            result = answer (sum, xor, 0, index + 1, cache) + answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 1 && sumLSB == 0) {
            result = 2 * answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 1 && sumLSB == 1) {
            result = 0;
        }

    }
    cache [index] [carry] = result;
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30022032_30146749_15_25
30022032_30146749_28_95
Title: How to make program quicker [Keypad_Sticky_Note] 
----------------------------------------

public static int answer (int sum, int xor) {
    int numBitsPerInt = Integer.toBinaryString (Integer.MAX_VALUE).length () + 1;
    int [] [] cache = new int [numBitsPerInt] [2];
    for (int i = 0;
    i < numBitsPerInt; ++ i) {
        cache [i] [0] = NOT_SET;
        cache [i] [1] = NOT_SET;
    }
    return answer (sum, xor, 0, 0, cache);
}
----------------------------------------

public static int answer (int sum, int xor, int carry, int index, int [] [] cache) {
    if (cache [index] [carry] != NOT_SET) {
        return cache [index] [carry];
    }
    if ((sum>> index) == 0 && (xor>> index) == 0 && carry == 0) {
        return 1;
    }
    int sumLSB = (sum>> index) & 1;
    int xorLSB = (xor>> index) & 1;
    int result = 0;
    if (carry == 0) {
        if (xorLSB == 0 && sumLSB == 0) {
            result = answer (sum, xor, 0, index + 1, cache) + answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 0 && sumLSB == 1) {
            result = 0;
        } else if (xorLSB == 1 && sumLSB == 0) {
            result = 0;
        } else if (xorLSB == 1 && sumLSB == 1) {
            result = 2 * answer (sum, xor, 0, index + 1, cache);
        }

    } else {
        if (xorLSB == 0 && sumLSB == 0) {
            result = 0;
        } else if (xorLSB == 0 && sumLSB == 1) {
            result = answer (sum, xor, 0, index + 1, cache) + answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 1 && sumLSB == 0) {
            result = 2 * answer (sum, xor, 1, index + 1, cache);
        } else if (xorLSB == 1 && sumLSB == 1) {
            result = 0;
        }

    }
    cache [index] [carry] = result;
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30023276_30023380_19_45
30023276_30023734_1_22
Title: ArrayList combination to one String 
----------------------------------------

public static void main (String [] args) {
    ArrayList < Packet > list = new ArrayList < > ();
    list.add (new Packet (1, "Mee"));
    list.add (new Packet (3, "e a"));
    list.add (new Packet (6, "clo"));
    list.add (new Packet (5, "o\'"));
    list.add (new Packet (4, "t 6 "));
    list.add (new Packet (2, "t m"));
    list.add (new Packet (11, "ion"));
    list.add (new Packet (7, "ck "));
    list.add (new Packet (8, "in "));
    list.add (new Packet (10, "un"));
    list.add (new Packet (9, "the "));
    Collections.shuffle (list);
    TreeSet < Packet > set = new TreeSet < > (list);
    StringBuilder builder = new StringBuilder ();
    for (Packet p : set) {
        builder.append (p.getMessage ());
    }
    System.out.println (builder.toString ());
}
----------------------------------------

public static void main (String [] args) {
    List < Packet > dividedMessage = new ArrayList < > ();
    dividedMessage.add (new Packet (1, "Mee"));
    dividedMessage.add (new Packet (2, "t m"));
    dividedMessage.add (new Packet (3, "e a"));
    dividedMessage.add (new Packet (6, "clo"));
    dividedMessage.add (new Packet (5, "o'"));
    dividedMessage.add (new Packet (4, "t 6 "));
    dividedMessage.add (new Packet (11, "ion"));
    dividedMessage.add (new Packet (7, "ck"));
    dividedMessage.add (new Packet (8, " in"));
    dividedMessage.add (new Packet (10, " un"));
    dividedMessage.add (new Packet (9, " the"));
    Collections.sort (dividedMessage);
    String originalMessage = "";
    for (Packet packet : dividedMessage) {
        originalMessage += packet.getMessage ();
    }
    System.out.println (originalMessage);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30040487_30057983_114_124
30040487_30057983_57_66
Title: Java sending object with ArrayList via sockets 
----------------------------------------

public boolean equals (Object o) {
    if (this == o) return true;

    if (o == null || getClass () != o.getClass ()) return false;

    PlayerData that = (PlayerData) o;
    if (ID != that.ID) return false;

    if (! playersPosition.equals (that.playersPosition)) return false;

    return username.equals (that.username);
}
----------------------------------------

public boolean equals (Object o) {
    if (this == o) return true;

    if (o == null || getClass () != o.getClass ()) return false;

    PlayersPosition that = (PlayersPosition) o;
    if (Double.compare (that.x, x) != 0) return false;

    return Double.compare (that.y, y) == 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30041393_30041493_2_11
30041393_30041639_4_41
Title: Find matching string occurrence in an ArrayList<String> 
----------------------------------------

public static void main (String [] args) {
    java.util.ArrayList < String > dates = new java.util.ArrayList < > ();
    dates.add ("1991-02-28");
    dates.add ("1991-02-28");
    dates.add ("1994-02-21");
    java.util.Set < String > uniqueDates = new java.util.HashSet < String > (dates);
    for (String date : uniqueDates) {
        System.out.println (date + ", " + java.util.Collections.frequency (dates, date));
    }
}
----------------------------------------

public static void main (String [] args) {
    ArrayList < String > dates = new ArrayList < > ();
    dates.add ("1991-02-28");
    dates.add ("1991-02-28");
    dates.add ("1994-02-21");
    HashMap < String, Integer > dateCount = new HashMap < String, Integer > ();
    for (int i = 0;
    i < dates.size (); i ++) {
        if (dateCount.containsKey (dates.get (i))) {
            dateCount.put (dates.get (i), dateCount.get (dates.get (i)) + 1);
        } else dateCount.put (dates.get (i), 1);

    }
    for (String date : dates) {
        int occ = dateCount.get (date);
        System.out.println (date + ", " + occ);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30042254_30043658_16_56
30042254_30043706_7_31
Title: How to add a vector as values in Java 
----------------------------------------

public static void main (String [] args) throws Exception {
    int i;
    FastVector attributes;
    Instances dataSet;
    double [] values;
    attributes = new FastVector ();
    for (i = 0; i < 64; i ++) attributes.addElement (new Attribute ("bin" + (i + 1)));

    dataSet = new Instances ("NormalizedHistogram_512bins", attributes, 0);
    NonSparseToSparse nonSparseToSparseInstance = new NonSparseToSparse ();
    nonSparseToSparseInstance.setInputFormat (dataSet);
    Instances sparseDataset = Filter.useFilter (dataSet, nonSparseToSparseInstance);
    System.out.println (sparseDataset);
    ArffSaver arffSaverInstance = new ArffSaver ();
    arffSaverInstance.setInstances (sparseDataset);
    arffSaverInstance.setFile (new File ("ESDN.arff"));
    arffSaverInstance.writeBatch ();
    Histogram ();
}
----------------------------------------

public static void main (String [] args) {
    Vector < Integer > vec = new Vector < Integer > (4);
    vec.add (0, 4);
    vec.add (1, 3);
    vec.add (2, 2);
    vec.add (3, 1);
    System.out.println ("Added numbers are :- ");
    for (Integer number : vec) {
        System.out.println ("Index :" + vec.indexOf (number) + " Number: " + number);
    }
    vec.add (3, 10);
    System.out.println ("Added numbers after insertion are :- ");
    for (Integer number : vec) {
        System.out.println ("Index :" + vec.indexOf (number) + " Number: " + number);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30049511_30050247_4_33
30049511_48306091_4_53
Title: How to export to Excel from Spring MVC 
----------------------------------------

protected void buildExcelDocument (Map < String, Object > input, HSSFWorkbook workbook, HttpServletRequest arg2, HttpServletResponse response) throws Exception {
    response.setHeader ("Content-Disposition", "attachment; filename=\"sample.xls\"");
    HSSFSheet sheet = workbook.createSheet ("Test");
    sheet.setDefaultColumnWidth (30);
    CellStyle style = workbook.createCellStyle ();
    Font font = workbook.createFont ();
    font.setFontName ("Arial");
    style.setFillForegroundColor (HSSFColor.BLUE.index);
    style.setFillPattern (CellStyle.SOLID_FOREGROUND);
    font.setBoldweight (HSSFFont.BOLDWEIGHT_BOLD);
    font.setColor (HSSFColor.WHITE.index);
    style.setFont (font);
    HSSFRow header = sheet.createRow (0);
    header.createCell (0).setCellValue ("Title");
    header.getCell (0).setCellStyle (style);
    header.createCell (1).setCellValue ("col2");
    header.getCell (1).setCellStyle (style);
    header.createCell (2).setCellValue ("col3");
    header.getCell (2).setCellStyle (style);
    header.createCell (3).setCellValue ("col4");
    header.getCell (3).setCellStyle (style);
    header.createCell (4).setCellValue ("col 5");
    header.getCell (4).setCellStyle (style);
}
----------------------------------------

public void buildExcelDocument (Map < String, Object > model, Workbook workbook, HttpServletRequest request, HttpServletResponse response) throws Exception {
    response.setHeader ("Content-Disposition", "attachment; filename=\"my-exported-file.xls\"");
    @SuppressWarnings ("unchecked")
    List < User > users = (List < GatewayManage >) model.get ("users");
    Sheet sheet = workbook.createSheet ("Users Detail");
    sheet.setDefaultColumnWidth (30);
    CellStyle style = workbook.createCellStyle ();
    Font font = workbook.createFont ();
    font.setFontName ("Arial");
    style.setFillForegroundColor (HSSFColor.BLUE.index);
    font.setColor (HSSFColor.BLACK.index);
    style.setFont (font);
    Row header = sheet.createRow (0);
    header.createCell (0).setCellValue ("First Name");
    header.getCell (0).setCellStyle (style);
    header.createCell (1).setCellValue ("Last Name");
    header.getCell (1).setCellStyle (style);
    header.createCell (2).setCellValue ("Number");
    header.getCell (2).setCellStyle (style);
    header.createCell (3).setCellValue ("Age");
    header.getCell (3).setCellStyle (style);
    int rowCount = 1;
    for (User user : users) {
        Row userRow = sheet.createRow (rowCount ++);
        gatewayRow.createCell (0).setCellValue (user.getFirstName ());
        gatewayRow.createCell (1).setCellValue (gateway.getLastName ());
        gatewayRow.createCell (2).setCellValue (gateway.getNumber ());
        gatewayRow.createCell (3).setCellValue (gateway.getAge ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30053354_30053686_1_13
30053354_30053783_1_14
Title: How to check if an array of numbers has gaps? 
----------------------------------------

public boolean hasGaps (long [] array) {
    if (array == null || array.length == 0) {
        return false;
    }
    long start = array [0];
    for (int i = 0;
    i < array.length; i ++) {
        if (array [i] != i + start) {
            return true;
        }
    }
    return false;
}
----------------------------------------

public static boolean hasGaps (long [] array) {
    if (array == null || array.length == 0) {
        return false;
    }
    if (array [array.length - 1] - array [0] + 1 != array.length) {
        return true;
    }
    for (int i = 1;
    i < array.length; i ++) {
        if (array [i] != array [i - 1] + 1) {
            return true;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30058295_30059433_107_133
30058295_30059433_181_210
Title: Following this tutorial but I'm stuck on the asyncTask 
----------------------------------------

protected String doInBackground (String...params) {
    int success;
    try {
        List < NameValuePair > params = new ArrayList < NameValuePair > ();
        params.add (new BasicNameValuePair ("pid", pid));
        JSONObject json = jsonParser.makeHttpRequest (url_product_details, "GET", params);
        Log.d ("Single Product Details", json.toString ());
        success = json.getInt (TAG_SUCCESS);
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------

protected String doInBackground (String...args) {
    String name = txtName.getText ().toString ();
    String price = txtPrice.getText ().toString ();
    String description = txtDesc.getText ().toString ();
    List < NameValuePair > params = new ArrayList < NameValuePair > ();
    params.add (new BasicNameValuePair (TAG_PID, pid));
    params.add (new BasicNameValuePair (TAG_NAME, name));
    params.add (new BasicNameValuePair (TAG_PRICE, price));
    params.add (new BasicNameValuePair (TAG_DESCRIPTION, description));
    JSONObject json = jsonParser.makeHttpRequest (url_update_product, "POST", params);
    try {
        int success = json.getInt (TAG_SUCCESS);
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30058295_30059433_107_133
30058295_30059819_15_49
Title: Following this tutorial but I'm stuck on the asyncTask 
----------------------------------------

protected String doInBackground (String...params) {
    int success;
    try {
        List < NameValuePair > params = new ArrayList < NameValuePair > ();
        params.add (new BasicNameValuePair ("pid", pid));
        JSONObject json = jsonParser.makeHttpRequest (url_product_details, "GET", params);
        Log.d ("Single Product Details", json.toString ());
        success = json.getInt (TAG_SUCCESS);
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------

protected JSONObject doInBackground (String...params) {
    int success;
    try {
        List < NameValuePair > params = new ArrayList < NameValuePair > ();
        params.add (new BasicNameValuePair ("pid", pid));
        JSONObject json = jsonParser.makeHttpRequest (url_product_details, "GET", params);
        Log.d ("Single Product Details", json.toString ());
        success = json.getInt (TAG_SUCCESS);
        if (success == 1) {
            JSONArray productObj = json.getJSONArray (TAG_PRODUCT);
            JSONObject product = productObj.getJSONObject (0);
            return product;
        } else {
        }
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30058295_30059433_136_162
30058295_30059433_213_225
Title: Following this tutorial but I'm stuck on the asyncTask 
----------------------------------------

protected void onPostExecute (String file_url) {
    pDialog.dismiss ();
    if (success == 1) {
        JSONArray productObj = json.getJSONArray (TAG_PRODUCT);
        JSONObject product = productObj.getJSONObject (0);
        txtName = (EditText) findViewById (R.id.inputName);
        txtPrice = (EditText) findViewById (R.id.inputPrice);
        txtDesc = (EditText) findViewById (R.id.inputDesc);
        txtName.setText (product.getString (TAG_NAME));
        txtPrice.setText (product.getString (TAG_PRICE));
        txtDesc.setText (product.getString (TAG_DESCRIPTION));
    } else {
    }
}
----------------------------------------

protected void onPostExecute (String file_url) {
    pDialog.dismiss ();
    if (success == 1) {
        Intent i = getIntent ();
        setResult (100, i);
        finish ();
    } else {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30058295_30059433_136_162
30058295_30059819_52_65
Title: Following this tutorial but I'm stuck on the asyncTask 
----------------------------------------

protected void onPostExecute (String file_url) {
    pDialog.dismiss ();
    if (success == 1) {
        JSONArray productObj = json.getJSONArray (TAG_PRODUCT);
        JSONObject product = productObj.getJSONObject (0);
        txtName = (EditText) findViewById (R.id.inputName);
        txtPrice = (EditText) findViewById (R.id.inputPrice);
        txtDesc = (EditText) findViewById (R.id.inputDesc);
        txtName.setText (product.getString (TAG_NAME));
        txtPrice.setText (product.getString (TAG_PRICE));
        txtDesc.setText (product.getString (TAG_DESCRIPTION));
    } else {
    }
}
----------------------------------------

protected void onPostExecute (JSONObject product) {
    txtName = (EditText) findViewById (R.id.inputName);
    txtPrice = (EditText) findViewById (R.id.inputPrice);
    txtDesc = (EditText) findViewById (R.id.inputDesc);
    txtName.setText (product.getString (TAG_NAME));
    txtPrice.setText (product.getString (TAG_PRICE));
    txtDesc.setText (product.getString (TAG_DESCRIPTION));
    pDialog.dismiss ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30058295_30059433_181_210
30058295_30059433_243_268
Title: Following this tutorial but I'm stuck on the asyncTask 
----------------------------------------

protected String doInBackground (String...args) {
    String name = txtName.getText ().toString ();
    String price = txtPrice.getText ().toString ();
    String description = txtDesc.getText ().toString ();
    List < NameValuePair > params = new ArrayList < NameValuePair > ();
    params.add (new BasicNameValuePair (TAG_PID, pid));
    params.add (new BasicNameValuePair (TAG_NAME, name));
    params.add (new BasicNameValuePair (TAG_PRICE, price));
    params.add (new BasicNameValuePair (TAG_DESCRIPTION, description));
    JSONObject json = jsonParser.makeHttpRequest (url_update_product, "POST", params);
    try {
        int success = json.getInt (TAG_SUCCESS);
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------

protected String doInBackground (String...args) {
    int success;
    try {
        List < NameValuePair > params = new ArrayList < NameValuePair > ();
        params.add (new BasicNameValuePair ("pid", pid));
        JSONObject json = jsonParser.makeHttpRequest (url_delete_product, "POST", params);
        Log.d ("Delete product", json.toString ());
        success = json.getInt (TAG_SUCCESS);
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30058295_30059433_181_210
30058295_30059819_15_49
Title: Following this tutorial but I'm stuck on the asyncTask 
----------------------------------------

protected String doInBackground (String...args) {
    String name = txtName.getText ().toString ();
    String price = txtPrice.getText ().toString ();
    String description = txtDesc.getText ().toString ();
    List < NameValuePair > params = new ArrayList < NameValuePair > ();
    params.add (new BasicNameValuePair (TAG_PID, pid));
    params.add (new BasicNameValuePair (TAG_NAME, name));
    params.add (new BasicNameValuePair (TAG_PRICE, price));
    params.add (new BasicNameValuePair (TAG_DESCRIPTION, description));
    JSONObject json = jsonParser.makeHttpRequest (url_update_product, "POST", params);
    try {
        int success = json.getInt (TAG_SUCCESS);
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------

protected JSONObject doInBackground (String...params) {
    int success;
    try {
        List < NameValuePair > params = new ArrayList < NameValuePair > ();
        params.add (new BasicNameValuePair ("pid", pid));
        JSONObject json = jsonParser.makeHttpRequest (url_product_details, "GET", params);
        Log.d ("Single Product Details", json.toString ());
        success = json.getInt (TAG_SUCCESS);
        if (success == 1) {
            JSONArray productObj = json.getJSONArray (TAG_PRODUCT);
            JSONObject product = productObj.getJSONObject (0);
            return product;
        } else {
        }
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30058295_30059433_213_225
30058295_30059819_52_65
Title: Following this tutorial but I'm stuck on the asyncTask 
----------------------------------------

protected void onPostExecute (String file_url) {
    pDialog.dismiss ();
    if (success == 1) {
        Intent i = getIntent ();
        setResult (100, i);
        finish ();
    } else {
    }
}
----------------------------------------

protected void onPostExecute (JSONObject product) {
    txtName = (EditText) findViewById (R.id.inputName);
    txtPrice = (EditText) findViewById (R.id.inputPrice);
    txtDesc = (EditText) findViewById (R.id.inputDesc);
    txtName.setText (product.getString (TAG_NAME));
    txtPrice.setText (product.getString (TAG_PRICE));
    txtDesc.setText (product.getString (TAG_DESCRIPTION));
    pDialog.dismiss ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30058295_30059433_243_268
30058295_30059819_15_49
Title: Following this tutorial but I'm stuck on the asyncTask 
----------------------------------------

protected String doInBackground (String...args) {
    int success;
    try {
        List < NameValuePair > params = new ArrayList < NameValuePair > ();
        params.add (new BasicNameValuePair ("pid", pid));
        JSONObject json = jsonParser.makeHttpRequest (url_delete_product, "POST", params);
        Log.d ("Delete product", json.toString ());
        success = json.getInt (TAG_SUCCESS);
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------

protected JSONObject doInBackground (String...params) {
    int success;
    try {
        List < NameValuePair > params = new ArrayList < NameValuePair > ();
        params.add (new BasicNameValuePair ("pid", pid));
        JSONObject json = jsonParser.makeHttpRequest (url_product_details, "GET", params);
        Log.d ("Single Product Details", json.toString ());
        success = json.getInt (TAG_SUCCESS);
        if (success == 1) {
            JSONArray productObj = json.getJSONArray (TAG_PRODUCT);
            JSONObject product = productObj.getJSONObject (0);
            return product;
        } else {
        }
    } catch (JSONException e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30060071_30060657_1_21
30060071_30075541_1_12
Title: How to do two ifs at once 
----------------------------------------

public void moveRight () {
    if (HeroX < 730) {
        if (HeroX >= 520 && HeroY >= 260) {
            System.out.println ("X = " + HeroX + " , Y = " + HeroY);
        } else {
            System.out.println ("X = " + HeroX + " , Y = " + HeroY);
            HeroX = HeroX + HeroSpeed;
        }
    } else {
        System.out.println ("Da kann ich nicht weiter gehen!");
    }
}
----------------------------------------

public void moveRight () {
    if (HeroX < 730) {
        if (house.intersects (HeroX, HeroY, 38, 55)) {
            System.out.println ("X = " + HeroX + " , Y = " + HeroY);
        } else {
            System.out.println ("X = " + HeroX + " , Y = " + HeroY);
            HeroX = HeroX + HeroSpeed;
        }
    } else {
        System.out.println ("Da kann ich nicht weiter gehen!");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30062157_30062362_1_11
30062157_30062708_1_22
Title: Java Input & Output Array 
----------------------------------------

public boolean isValid (int number) {
    try (Scanner scanner = new Scanner (new File ("src/Accounts.txt"))) {
        while (scanner.hasNextInt ()) {
            if (scanner.nextInt () == number) {
                return true;
            }
        }
    }
    return false;
}
----------------------------------------

public boolean isValid (long number) {
    long accountNumber;
    File file = new File ("src/Accounts.txt");
    Scanner inputFile = null;
    try {
        inputFile = new Scanner (file);
        while (inputFile.hasNext ()) {
            accountNumber = inputFile.nextLong ();
            if (accountNumber == number) {
                return true;
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } finally {
        if (inputFile != null) {
            inputFile.close ();
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30066020_30066053_1_11
30066020_30066152_1_14
Title: Creating a method to return an integer based on user string input 
----------------------------------------

public int getDifficulty () {
    int difficulty = 0;
    if (chosenDifficulty.equals ("HUMAN")) {
        difficulty = 1;
    } else if (chosenDifficulty.equals ("RANDOM")) {
        difficulty = 2;
    } else {
        difficulty = 3;
    }

    return difficulty;
}
----------------------------------------

public int getDifficulty () {
    int difficulty;
    switch (chosenDifficulty) {
        case "HUMAN" :
            difficulty = 1;
            break;
        case "RANDOM" :
            difficulty = 2;
            break;
        default :
            difficulty = 3;
    }
    return difficulty;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30066020_30066053_1_11
30066020_30066243_1_10
Title: Creating a method to return an integer based on user string input 
----------------------------------------

public int getDifficulty () {
    int difficulty = 0;
    if (chosenDifficulty.equals ("HUMAN")) {
        difficulty = 1;
    } else if (chosenDifficulty.equals ("RANDOM")) {
        difficulty = 2;
    } else {
        difficulty = 3;
    }

    return difficulty;
}
----------------------------------------

public int getDifficulty () {
    int difficulty = 3;
    if (chosenDifficulty.equals ("HUMAN")) {
        difficulty = 1;
    }
    if (chosenDifficulty.equals ("RANDOM")) {
        difficulty = 2;
    }
    return difficulty;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30066020_30066152_1_14
30066020_30066243_1_10
Title: Creating a method to return an integer based on user string input 
----------------------------------------

public int getDifficulty () {
    int difficulty;
    switch (chosenDifficulty) {
        case "HUMAN" :
            difficulty = 1;
            break;
        case "RANDOM" :
            difficulty = 2;
            break;
        default :
            difficulty = 3;
    }
    return difficulty;
}
----------------------------------------

public int getDifficulty () {
    int difficulty = 3;
    if (chosenDifficulty.equals ("HUMAN")) {
        difficulty = 1;
    }
    if (chosenDifficulty.equals ("RANDOM")) {
        difficulty = 2;
    }
    return difficulty;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30067319_30067443_1_20
30067319_30067538_1_10
Title: String word reverse in Java giving wrong result? 
----------------------------------------

public static void main (String args []) {
    String input = "I am test";
    String result = "";
    int start = input.length () - 1;
    for (int i = input.length () - 1;
    i >= 0; i --) {
        Character c = input.charAt (i);
        if (c == ' ') {
            for (int j = i + 1;
            j <= start; j ++) result += input.charAt (j);

            result += " ";
            start = i - 1;
        } else if (i == 0) {
            for (int j = 0;
            j <= start; j ++) result += input.charAt (j);

        }

    }
    System.out.println (result);
}
----------------------------------------

public static void main (String args []) {
    String input = "I am test";
    String result = "";
    String [] frags = input.split (" ");
    for (int i = frags.length - 1;
    i >= 0; i --) {
        System.out.print (frags [i] + " ");
    }
    System.out.println ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30075486_30075937_16_24
30075486_30075937_26_34
Title: Java String Builder append computation 
----------------------------------------

public AbstractStringBuilder append (StringBuffer sb) {
    if (sb == null) return appendNull ();

    int len = sb.length ();
    ensureCapacityInternal (count + len);
    sb.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------

AbstractStringBuilder append (AbstractStringBuilder asb) {
    if (asb == null) return appendNull ();

    int len = asb.length ();
    ensureCapacityInternal (count + len);
    asb.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30075486_30075937_16_24
30075486_30075937_36_46
Title: Java String Builder append computation 
----------------------------------------

public AbstractStringBuilder append (StringBuffer sb) {
    if (sb == null) return appendNull ();

    int len = sb.length ();
    ensureCapacityInternal (count + len);
    sb.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------

@Override
public AbstractStringBuilder append (CharSequence s) {
    if (s == null) return appendNull ();

    if (s instanceof String) return this.append ((String) s);

    if (s instanceof AbstractStringBuilder) return this.append ((AbstractStringBuilder) s);

    return this.append (s, 0, s.length ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30075486_30075937_16_24
30075486_30075937_5_13
Title: Java String Builder append computation 
----------------------------------------

public AbstractStringBuilder append (StringBuffer sb) {
    if (sb == null) return appendNull ();

    int len = sb.length ();
    ensureCapacityInternal (count + len);
    sb.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------

public AbstractStringBuilder append (String str) {
    if (str == null) return appendNull ();

    int len = str.length ();
    ensureCapacityInternal (count + len);
    str.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30075486_30075937_26_34
30075486_30075937_36_46
Title: Java String Builder append computation 
----------------------------------------

AbstractStringBuilder append (AbstractStringBuilder asb) {
    if (asb == null) return appendNull ();

    int len = asb.length ();
    ensureCapacityInternal (count + len);
    asb.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------

@Override
public AbstractStringBuilder append (CharSequence s) {
    if (s == null) return appendNull ();

    if (s instanceof String) return this.append ((String) s);

    if (s instanceof AbstractStringBuilder) return this.append ((AbstractStringBuilder) s);

    return this.append (s, 0, s.length ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30075486_30075937_26_34
30075486_30075937_5_13
Title: Java String Builder append computation 
----------------------------------------

AbstractStringBuilder append (AbstractStringBuilder asb) {
    if (asb == null) return appendNull ();

    int len = asb.length ();
    ensureCapacityInternal (count + len);
    asb.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------

public AbstractStringBuilder append (String str) {
    if (str == null) return appendNull ();

    int len = str.length ();
    ensureCapacityInternal (count + len);
    str.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30075486_30075937_36_46
30075486_30075937_5_13
Title: Java String Builder append computation 
----------------------------------------

@Override
public AbstractStringBuilder append (CharSequence s) {
    if (s == null) return appendNull ();

    if (s instanceof String) return this.append ((String) s);

    if (s instanceof AbstractStringBuilder) return this.append ((AbstractStringBuilder) s);

    return this.append (s, 0, s.length ());
}
----------------------------------------

public AbstractStringBuilder append (String str) {
    if (str == null) return appendNull ();

    int len = str.length ();
    ensureCapacityInternal (count + len);
    str.getChars (0, len, value, count);
    count += len;
    return this;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30076242_30098243_1_12
30076242_40008413_1_18
Title: Changing request parameter value in Struts2 interceptor 
----------------------------------------

public String intercept (ActionInvocation invocation) throws Exception {
    final ActionContext context = invocation.getInvocationContext ();
    Map < String, Object > parameters = (Map < String, Object >) context.get (ActionContext.PARAMETERS);
    Map < String, Object > parametersCopy = new HashMap < String, Object > ();
    parametersCopy.putAll (parameters);
    parametersCopy.put ("myParam", "changedValue");
    context.put (ActionContext.PARAMETERS, parametersCopy);
    return invocation.invoke ();
}
----------------------------------------

@Override
public String intercept (ActionInvocation ai) throws Exception {
    ValueStack stack = ai.getStack ();
    Iterator it = stack.getRoot ().iterator ();
    while (it.hasNext ()) {
        Object objecto = it.next ();
        if (objecto instanceof LoginUsuario) {
            LoginUsuario usuario = (LoginUsuario) objecto;
            usuario.setUsername (usuario.getUsername ().toUpperCase ());
            usuario.setPassword (usuario.getPassword ().toUpperCase ());
        }
    }
    return ai.invoke ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3007975_3008122_6_28
3007975_3008239_4_15
Title: java random percentages 
----------------------------------------

public static void main (String [] args) {
    Random rnd = new Random ();
    SortedSet < Integer > set = new TreeSet < Integer > ();
    for (int i = 0;
    i < 9; ++ i) {
        set.add (rnd.nextInt (101));
    }
    if (set.last () < 100) {
        set.add (100);
    }
    int prev = 0;
    int total = 0;
    int output;
    for (int j : set) {
        output = j - prev;
        total += output;
        System.err.println (String.format ("Value: %d, Output: %d, Total So Far: %d", j, output, total));
        prev = j;
    }
}
----------------------------------------

public static void main (String [] args) {
    Random rnd = new Random ();
    int percents [] = new int [7];
    for (int i = 0;
    i < 100; i ++) {
        int bucket = rnd.nextInt (7);
        percents [bucket] = percents [bucket] + 1;
    }
    for (int i = 0;
    i < 7; i ++) {
        System.out.println ("bucket " + i + ": " + percents [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30082177_30082468_1_11
30082177_30082485_21_37
Title: "How to make a random array generator that consists of 1's and 0's with length taken from user" 
----------------------------------------

public static void main (String [] args) {
    Random r = new Random ();
    int [] values = new int [10];
    for (int i = 0;
    i < values.length; i ++) {
        values [i] = r.nextInt (2);
    }
    System.out.println (Arrays.toString (values));
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    int [] anArray;
    anArray = new int [sc.nextInt ()];
    for (int i = 0;
    i < anArray.length; i ++) {
        anArray [i] = randInt (0, 1);
    }
    for (int i = 0;
    i < anArray.length; i ++) {
        System.out.println (anArray [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30098685_30099274_2_19
30098685_30101932_1_19
Title: How do I make these two threads run togeather? 
----------------------------------------

@Override
public void run () {
    newTime = startTime;
    System.out.println ("Timer Running\n");
    System.out.println ("TimeOut is:" + timeOut + "\n");
    while (true) {
        if (newTime < startTime + timeOut) {
            newTime = startTime + System.currentTimeMillis ();
        } else {
            break;
        }
    }
    if (finder != null) finder.interrupt ();

    System.err.println ("Cannot find");
    System.exit (- 1);
}
----------------------------------------

@Override
public void run () {
    System.out.println ("Running find");
    File searchDir = new File (this.searchLocation);
    UserFilter filter = new UserFilter (searchKeyword, searchType, pathOfSearchedFiles);
    searchDir.list (filter);
    for (String f : pathOfSearchedFiles) {
        if (System.currentTimeMillis () >= stopTime) {
            break;
        }
        System.out.println (f);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30109972_30110713_5_23
30109972_30111006_5_31
Title: How should I loop this program? 
----------------------------------------

public static void Gamer (Scanner s) {
    Game g = new Game ();
    String buf = null;
    for (int i = 0;
    i < 4; i ++) {
        System.out.print (g.askQuestion ());
        buf = s.nextLine ();
        if (g.confirm (buf)) System.out.println ("You're Right!");
        else System.out.println ("You're Wrong...");

    }
    System.out.println ("You got a " + g.getScore ());
}
----------------------------------------

public static void Gamer (Scanner s) {
    Game g = new Game ();
    String buf = null;
    for (int i = 0;
    i < 4; i ++) {
        System.out.print (g.askQuestion ());
        buf = s.nextLine ();
        if (g.confirm (buf)) System.out.println ("You're Right!");
        else System.out.println ("You're Wrong...");

    }
    System.out.println ("You got a " + g.getScore ());
    System.out.print ("Press Enter to continue; Type Exit to quit");
    if (s.nextLine ().equalsIgnoreCase ("exit")) {
        s.close ();
        System.exit (0);
    }
    Gamer (s);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30113069_30113102_7_19
30113069_30113131_1_13
Title: why isn't this if then satement working? 
----------------------------------------

private boolean search (Node node, int value) {
    if (node == null) {
        return false;
    } else if (node.getValue () == value) {
        return true;
    } else if (node.getValue () > value) {
        System.out.println ("searching left" + node.getValue () + '>' + value);
        return search (node.left, value);
    } else {
        System.out.println ("searching right" + node.getValue () + '<' + value);
        return search (node.right, value);
    }

}
----------------------------------------

private boolean search (Node node, int value) {
    if (node == null) {
        return false;
    } else if (node.getValue () == value) {
        return true;
    } else if (node.getValue () > value) {
        System.out.println ("searching left" + node.getValue () + '>' + value);
        return search (node.left, value);
    } else if (node.getValue () < value) {
        System.out.println ("searching right" + node.getValue () + '<' + value);
        return search (node.right, value);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30114027_30114870_1_26
30114027_30115431_2_22
Title: How to get a 2d array to print from 1 to 80 
----------------------------------------

public static void main (String arg []) {
    int array [] = new int [80];
    for (int i = 0;
    i <= 79; i ++) array [i] = i + 1;

    int counter = 0;
    for (int i = 0;
    i <= 79; i ++) {
        counter ++;
        System.out.print (array [i] + " ");
        if (counter == 10) {
            System.out.println ();
            counter = 0;
        }
    }
}
----------------------------------------

public static void main (String args []) {
    int r = 8, c = 10;
    int [] [] toArray = new int [r] [c];
    for (int i = 0;
    i < r; i ++) {
        for (int j = 0;
        j < c; j ++) {
            toArray [i] [j] = i * 10 + j + 1;
            System.out.print (toArray [i] [j] + "\t");
        }
        System.out.println ();
    }
    System.out.println ("\n\n\n");
    int a [] = new int [r * c];
    for (int i = 0;
    i < r * c; i ++) {
        a [i] = (i + 1);
        System.out.print (a [i] + "\t");
        if (a [i] % 10 == 0) System.out.println ();

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30119414_30119555_1_21
30119414_30120358_13_48
Title: Intro Java Fencepost/While loops Conitional Tests 
----------------------------------------

public static boolean highLow (int n) {
    boolean isLastHigh = n % 10 >= 5;
    n = n / 10;
    while (n > 0) {
        if (n % 10 >= 5) {
            if (isLastHigh) return false;

            isLastHigh = true;
        } else {
            if (! isLastHigh) return false;

            isLastHigh = false;
        }
        n = n / 10;
    }
    return true;
}
----------------------------------------

public static boolean highLow (int n) {
    boolean high = false;
    boolean low = false;
    while (n > 0) {
        if (n % 10 >= 5) {
            if (high) {
                return false;
            } else {
                low = false;
                high = true;
            }
        } else {
            if (low) {
                return false;
            } else {
                high = false;
                low = true;
            }
        }
        n = n / 10;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30120702_30120797_1_13
30120702_30120936_3_14
Title: How to divide a series of values in one array by a series of values in another array 
----------------------------------------

public static void main (String [] args) {
    int arr1 [] = {8, 4, 6, 8, 4};
    int arr2 [] = {2, 4, 2, 1, 2};
    for (int i = 0;
    i < arr1.length; i ++) {
        for (int j = 0;
        j < arr2.length; j ++) {
            int result = arr1 [i] / arr2 [j];
            System.out.println (result);
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int arr1 [] = {8, 4, 6, 8, 4};
    int arr2 [] = {2, 4, 2, 1, 2};
    for (int x = 0;
    x < arr1.length; x ++) {
        int result = arr1 [x] / arr2 [x];
        System.out.println (result);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30126516_30127161_1_21
30126516_45897859_1_15
Title: How to get results from the CompletableFuture 
----------------------------------------

public static void main (String [] args) throws ExecutionException, InterruptedException {
    ExecutorService orintMapExe = Executors.newFixedThreadPool (4);
    List < Future < List < Integer > > > futures = new ArrayList < > ();
    futures.add (orintMapExe.submit (new OrintMapRun (10, 10)));
    futures.add (orintMapExe.submit (new OrintMapRun (20, 20)));
    futures.add (orintMapExe.submit (new OrintMapRun (30, 30)));
    futures.add (orintMapExe.submit (new OrintMapRun (40, 40)));
    orintMapExe.shutdown ();
    try {
        orintMapExe.awaitTermination (1, TimeUnit.DAYS);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    for (Future < List < Integer > > future : futures) {
        List < Integer > result = future.get ();
        System.out.println (result);
    }
}
----------------------------------------

public static void main (String [] args) throws ExecutionException, InterruptedException {
    ExecutorService orintMapExe = Executors.newFixedThreadPool (4);
    CompletionService service = new ExecutorCompletionService (orintMapExe);
    List < Future < List < Integer > > > futures = new ArrayList < > ();
    futures.add (orintMapExe.submit (new OrintMapRun (10, 10)));
    futures.add (orintMapExe.submit (new OrintMapRun (20, 20)));
    futures.add (orintMapExe.submit (new OrintMapRun (30, 30)));
    futures.add (orintMapExe.submit (new OrintMapRun (40, 40)));
    for (int i = 0;
    I < futures.size (); i ++) {
        List < Integer > result = service.take ().get ();
        System.out.println (result);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30135871_30135901_1_18
30135871_30136003_1_23
Title: move item to the front of the LinkedList 
----------------------------------------

public boolean findMove (E e) {
    Node previous = head;
    Node current = head;
    while (current != null) {
        if (e.equals (current.item)) {
            previous.next = current.next;
            current.next = head;
            head = current;
            System.out.println ("True");
            return true;
        }
        previous = current;
        current = current.next;
    }
    System.out.println ("False");
    return false;
}
----------------------------------------

public boolean findMove (E e) {
    Node previous = null;
    Node current = head;
    Node headerNode = head;
    while (current != null) {
        if (e.equals (current.item) && previous != null) {
            previous.next = current.next;
            current.next = headerNode;
            headerNode = current;
            System.out.println ("True");
            return true;
        }
        previous = current;
        current = current.next;
    }
    System.out.println ("False");
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30138332_30138421_1_27
30138332_30138524_3_30
Title: "BufferedReader found specific word in line take the data from that line" 
----------------------------------------

public static void main (String [] args) {
    BufferedReader reader = null;
    String line;
    String name, pwd, contactNo, email;
    try {
        reader = new BufferedReader (new FileReader ("src/files/temp2.txt"));
        String foundWord = "dod";
        while ((line = reader.readLine ()) != null) {
            String [] words = line.split (",");
            for (String word : words) {
                if (word.equals (foundWord)) {
                    name = words [0];
                    pwd = words [1];
                    contactNo = words [2];
                    email = words [3];
                    System.out.println ("Details: " + name + "-" + pwd + "-" + contactNo + "-" + email);
                }
            }
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        reader.close ()
    }
}
----------------------------------------

public static void main (String [] args) throws FileNotFoundException {
    boolean found = false;
    Scanner line = new Scanner (new File ("E:/temp.txt"));
    String foundWord = "dod";
    while (line.hasNextLine ()) {
        String [] reader = line.nextLine ().split (",");
        for (String word : reader) {
            if (word.equals (foundWord)) {
                found = true;
                String NAME = reader [0];
                String PASSWORD = reader [1];
                String CONTACT_NO = reader [2];
                String EMAIL_ADDRESS = reader [3];
                System.out.println (NAME + "\t" + PASSWORD + "\t" + CONTACT_NO + "\t" + EMAIL_ADDRESS);
            }
        }
    }
    if (! found) {
        System.out.println (foundWord + " not found");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30143848_30144247_28_41
30143848_30144271_13_27
Title: Simpler way to split String from .txt file in Java 
----------------------------------------

public static void main (String [] args) {
    Map < String, Integer > map = new HashMap < > ();
    String file = "";
    try (Stream < String > stream = Files.lines (Paths.get ("test.txt"))) {
        stream.forEach (s -> {
            String [] split = s.split (":");
            map.put (split [0], Integer.parseInt (split [1]));
        });
    } catch (IOException ex) {
        Logger.getLogger (JavaApplication2.class.getName ()).log (Level.SEVERE, null, ex);
    }
    map.keySet ().stream ().forEach (s -> System.out.println (s + ": " + map.get (s)));
}
----------------------------------------

public static void main (String [] args) throws IOException {
    List < Integer > numbers = new ArrayList < Integer > ();
    List < String > names = new ArrayList < String > ();
    try (Stream < String > stream = Files.lines (Paths.get ("test.txt"))) {
        stream.forEach (s -> {
            names.add (s.split (":") [0]);
            numbers.add (Integer.parseInt ((s.split (":")) [1].trim ()));
        });
    }
    IntStream.range (0, Math.min (names.size (), numbers.size ())).mapToObj (i -> names.get (i) + ":" + numbers.get (i)).forEach (System.out :: println);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30145837_30146404_6_17
30145837_30146586_1_16
Title: Print the String that match the number in Array 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter a number from 0-7 >> ");
    int inputNumber = in.nextInt ();
    if (inputNumber >= 0 && inputNumber < someArray.length) {
        System.out.printf ("The Number %d corresponds to String %s\n", inputNumber, someArray [inputNumber]);
    } else {
    }
}
----------------------------------------

public static void main (String [] args) {
    String [] someArray = {"20", "30", "40", "50", "60", "70", "80", "90"};
    int inputNumber;
    boolean foundIt = false;
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter a number from 0-7 >> ");
    inputNumber = in.nextInt ();
    in.close ();
    LinkedList < String > list = new LinkedList (Arrays.asList (someArray));
    list.remove (inputNumber);
    String [] newArray = list.toArray (new String [list.size ()]);
    System.out.println ("The Number " + inputNumber + " corresponds to String  " + someArray [inputNumber]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30145837_30146404_6_17
30145837_30147596_1_17
Title: Print the String that match the number in Array 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter a number from 0-7 >> ");
    int inputNumber = in.nextInt ();
    if (inputNumber >= 0 && inputNumber < someArray.length) {
        System.out.printf ("The Number %d corresponds to String %s\n", inputNumber, someArray [inputNumber]);
    } else {
    }
}
----------------------------------------

public static void main (String [] args) {
    List < String > numbers = Arrays.asList ("20", "30", "40", "50", "60", "70", "80", "90");
    int inputNumber;
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter a number from 0-7 >> ");
    inputNumber = in.nextInt ();
    in.close ();
    if (inputNumber < numbers.size ()) {
        System.out.println ("The Number " + inputNumber + " corresponds to String  " + numbers.get (inputNumber));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30145837_30146586_1_16
30145837_30147596_1_17
Title: Print the String that match the number in Array 
----------------------------------------

public static void main (String [] args) {
    String [] someArray = {"20", "30", "40", "50", "60", "70", "80", "90"};
    int inputNumber;
    boolean foundIt = false;
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter a number from 0-7 >> ");
    inputNumber = in.nextInt ();
    in.close ();
    LinkedList < String > list = new LinkedList (Arrays.asList (someArray));
    list.remove (inputNumber);
    String [] newArray = list.toArray (new String [list.size ()]);
    System.out.println ("The Number " + inputNumber + " corresponds to String  " + someArray [inputNumber]);
}
----------------------------------------

public static void main (String [] args) {
    List < String > numbers = Arrays.asList ("20", "30", "40", "50", "60", "70", "80", "90");
    int inputNumber;
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter a number from 0-7 >> ");
    inputNumber = in.nextInt ();
    in.close ();
    if (inputNumber < numbers.size ()) {
        System.out.println ("The Number " + inputNumber + " corresponds to String  " + numbers.get (inputNumber));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30146843_30146917_8_28
30146843_30146937_10_20
Title: remove item from comparable array 
----------------------------------------

public T removeMin () {
    Iterator < T > iterator = iterator ();
    T min = iterator.hasNext () ? iterator.next () : null;
    while (iterator.hasNext ()) {
        T next = iterator.next ();
        if (min.compareTo (next) > 0) {
            min = next;
        }
    }
    if (min != null) {
        iterator = iterator ();
        while (iterator.hasNext ()) {
            T next = iterator.next ();
            if (min.compareTo (next) == 0) {
                iterator.remove ();
                break;
            }
        }
    }
    return min;
}
----------------------------------------

public Comparable removeMin () {
    Iterator < T > iterator = iterator ();
    T min = iterator.next ();
    while (iterator.hasNext ()) {
        T next = iterator.next ();
        if (min.compareTo (next) > 0) min = next;

        data.remove (min);
    }
    return min;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30146865_30146938_3_30
30146865_30146996_8_18
Title: Modification of reverse array 
----------------------------------------

public static void main (String [] args) {
    int [] list = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int temp;
    int sizeOfArray;
    Scanner input = new Scanner (System.in);
    int lastIndex = list.length - 1;
    for (int i = 0, j = lastIndex;
    i < j; i ++, j --) {
        temp = list [j];
        list [j] = list [i];
        list [i] = temp;
    }
    System.out.println ("Now the reverse is:");
    for (int i = 0;
    i <= lastIndex; i ++) {
        System.out.print (list [i] + " ");
    }
    System.out.println ();
}
----------------------------------------

public static void main (String [] args) {
    List < Integer > list = new ArrayList < Integer > ();
    list.add (1);
    list.add (2);
    list.add (3);
    list.add (4);
    list.add (5);
    Collections.reverse (list);
    System.out.println ("After Reverse Order, ArrayList Contains : " + list);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30146865_30146938_3_30
30146865_30147017_1_19
Title: Modification of reverse array 
----------------------------------------

public static void main (String [] args) {
    int [] list = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int temp;
    int sizeOfArray;
    Scanner input = new Scanner (System.in);
    int lastIndex = list.length - 1;
    for (int i = 0, j = lastIndex;
    i < j; i ++, j --) {
        temp = list [j];
        list [j] = list [i];
        list [i] = temp;
    }
    System.out.println ("Now the reverse is:");
    for (int i = 0;
    i <= lastIndex; i ++) {
        System.out.print (list [i] + " ");
    }
    System.out.println ();
}
----------------------------------------

public static void main (String [] args) {
    int [] list = null;
    int temp;
    Scanner input = new Scanner (System.in);
    System.out.print ("Enter Size");
    int size = input.nextInt ();
    list = new int [size];
    for (int i = 0;
    i < size; i ++) {
        list [i] = i + 1;
    }
    System.out.println ("Original:");
    printArray (list);
    int [] reversed = new int [size];
    for (int i = 0;
    i < list.length; i ++) {
        reversed [i] = list [list.length - 1 - i];
    }
    System.out.println ("Now the reverse is:");
    printArray (reversed);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30146865_30146996_8_18
30146865_30147017_1_19
Title: Modification of reverse array 
----------------------------------------

public static void main (String [] args) {
    List < Integer > list = new ArrayList < Integer > ();
    list.add (1);
    list.add (2);
    list.add (3);
    list.add (4);
    list.add (5);
    Collections.reverse (list);
    System.out.println ("After Reverse Order, ArrayList Contains : " + list);
}
----------------------------------------

public static void main (String [] args) {
    int [] list = null;
    int temp;
    Scanner input = new Scanner (System.in);
    System.out.print ("Enter Size");
    int size = input.nextInt ();
    list = new int [size];
    for (int i = 0;
    i < size; i ++) {
        list [i] = i + 1;
    }
    System.out.println ("Original:");
    printArray (list);
    int [] reversed = new int [size];
    for (int i = 0;
    i < list.length; i ++) {
        reversed [i] = list [list.length - 1 - i];
    }
    System.out.println ("Now the reverse is:");
    printArray (reversed);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30150278_30150455_11_25
30150278_30150455_1_9
Title: converting to decimal but without using integer.parseInt() method 
----------------------------------------

public static int convertBinaryToDecimal (long numberInBinary) {
    int decimal = 0;
    int power = 0;
    while (true) {
        if (numberInBinary == 0) {
            break;
        } else {
            long temp = numberInBinary % 10;
            decimal += temp * Math.pow (2, power);
            numberInBinary = numberInBinary / 10;
            power ++;
        }
    }
    return decimal;
}
----------------------------------------

public static int convertBinaryToDecimal (String binary) {
    double decimal = 0;
    for (int i = 0;
    i < binary.length (); i ++) {
        if (binary.charAt (i) == '1') {
            decimal = decimal + Math.pow (2, binary.length () - 1 - i);
        }
    }
    return (int) decimal;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30152831_30152880_4_14
30152831_30152959_5_13
Title: Java Syntax error? 
----------------------------------------

public static void main (String [] args) {
    for (int i = 0;
    i < cities.length; i ++) {
        for (int j = 0;
        j < cities [i].length; j ++) {
            if (cities [i] [j].charAt (0) == 'S') System.out.println (cities [i] [j]);

        }
    }
}
----------------------------------------

public static void main (String [] args) {
    for (int i = 0;
    i < cities.length; i ++) {
        for (int j = 0;
        j < cities [i].length; j ++) {
            if (cities [i] [j].startsWith ("S")) {
                System.out.println (cities [i] [j]);
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30154648_30154759_1_13
30154648_30155151_1_13
Title: "Get numbers that have only 23 and 5 as prime factors" 
----------------------------------------

public static void main (String [] args) {
    int array [] = new int [100];
    {
        int index = 1;
        for (int i = 1;
        i < 100; i ++) {
            int m;
            m = search (i);
            if (m == 1 || m == 2 || m == 3 || m == 5) {
                array [++ index] = i;
            }
        }
    }}
----------------------------------------

public static void main (String [] args) {
    int array [] = new int [100];
    {
        int index = 0;
        for (int i = 0;
        i < 100; i ++) {
            int m;
            m = search (i);
            if (m == 1 || m == 2 || m == 3 || m == 5) {
                array [index ++] = i;
            }
        }
    }}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30158060_30158135_6_26
30158060_30158187_7_35
Title: I don't know when the user has to stop guessing? 
----------------------------------------

public static void main (String [] args) {
    Scanner scan = new Scanner (System.in);
    Random random = new Random ();
    int computerGuess = 100 + random.nextInt (200 - 100 + 1);
    int guesses = 0;
    System.out.println ("Enter a number from 100 to 200: ");
    int guess = Integer.parseInt (scan.nextLine ());
    scan.close ();
    while (computerGuess != guess) {
        computerGuess = 100 + random.nextInt (200 - 100 + 1);
        guesses ++;
        System.out.println ("Guesses: " + guesses + ", Computer Guess: " + computerGuess + ", Your Guess: " + guess);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner scan = new Scanner (System.in);
    Random random = new Random ();
    int start = 100;
    int end = 200;
    int seed = (end - start + 1);
    int randomNumber = (random.nextInt (seed) + start);
    int guessedNumber = 0;
    int tries = 0;
    System.out.printf ("The number is between %d and %d.\n", start, end);
    do {
        tries ++;
        System.out.print ("Guess what the number is: ");
        guessedNumber = scan.nextInt ();
        if (guessedNumber > randomNumber) System.out.println ("Your guess is too high!");
        else if (guessedNumber < randomNumber) System.out.println ("Your guess is too low!");
        else {
            System.out.println ("You got it!");
            System.out.println ("You guessed: " + tries + " times");
        }

    } while (guessedNumber != randomNumber);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30159180_30159249_1_21
30159180_30159652_1_39
Title: Trying to Get Integer Separated by Space in Java 
----------------------------------------

public static void main (String [] args) {
    int amountofnumbers;
    int [] actualnumbers;
    Scanner myinput = new Scanner (System.in);
    System.out.println ("How many numbers do you want to enter?");
    amountofnumbers = myinput.nextInt ();
    actualnumbers = new int [amountofnumbers];
    for (int index = 0;
    index < amountofnumbers; index ++) {
        System.out.println ("Please enter");
        actualnumbers [index] = myinput.nextInt ();
    }
    myinput.close ();
    System.out.println ("You entered:");
    for (int enteredNumber : actualnumbers) {
        System.out.println (enteredNumber);
    }
}
----------------------------------------

public static void main (String [] argv) throws Exception {
    int amountofnumbers;
    Scanner myinput = new Scanner (System.in);
    Scanner myinput2 = new Scanner (System.in);
    System.out.println ("How many numbers do you want to enter?");
    amountofnumbers = myinput.nextInt ();
    try {
        int [] numbers = new int [amountofnumbers];
        System.out.println ("Please enter " + amountofnumbers + " integer(s) seperated by a space");
        String actualnumbers = myinput2.nextLine ();
        String [] amounts = actualnumbers.split (" ", amountofnumbers);
        if (amounts.length != amountofnumbers) {
            System.err.println ("No of input should be: " + amountofnumbers);
            return;
        }
        for (int i = 0;
        i < amounts.length; i ++) {
            numbers [i] = Integer.parseInt (amounts [i]);
        }
        System.out.println ("You entered:- ");
        for (int i = 0;
        i < numbers.length; i ++) {
            System.out.println (numbers [i]);
        }
    } catch (NumberFormatException e) {
        System.err.println ("Only integer can be input");
    } catch (ArrayIndexOutOfBoundsException e) {
        System.err.println ("No of input should be: " + amountofnumbers);
    }
    myinput.close ();
    myinput2.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30161341_30161497_5_49
30161341_30161795_1_43
Title: Trouble with basic calculator using switch 
----------------------------------------

public static void main (String args []) {
    int result = 0;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter number");
    result = sc.nextInt ();
    System.out.println ("Enter operation");
    System.out.println ("1.+");
    System.out.println ("2.-");
    System.out.println ("3.*");
    System.out.println ("4./");
    System.out.println ("5.=");
    int operation = sc.nextInt ();
    while (operation != 5) {
        System.out.println ("Enter next number");
        int number = sc.nextInt ();
        switch (operation) {
            case 1 :
                result += number;
                System.out.println ("result= " + result);
                break;
            case 2 :
                result -= number;
                System.out.println ("result= " + result);
                break;
            case 3 :
                result *= number;
                System.out.println ("result= " + result);
                break;
            case 4 :
                result /= number;
                System.out.println ("result= " + result);
                break;
        }
        System.out.println (result);
        System.out.println ("Enter operation");
        operation = sc.nextInt ();
    }
}
----------------------------------------

public static void main (String [] args) {
    int result = 0;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter number");
    result = sc.nextInt ();
    System.out.println ("Enter operation");
    System.out.println ("1.+");
    System.out.println ("2.-");
    System.out.println ("3.*");
    System.out.println ("4./");
    System.out.println ("5.=");
    int operation = sc.nextInt ();
    while (operation != 5) {
        System.out.println ("Enter next number");
        int operand2 = sc.nextInt ();
        switch (operation) {
            case 1 :
                result += operand2;
                System.out.println ("result= " + result);
                break;
            case 2 :
                result -= operand2;
                System.out.println ("result= " + result);
                break;
            case 3 :
                result *= operand2;
                System.out.println ("result= " + result);
                break;
            case 4 :
                result /= operand2;
                System.out.println ("result= " + result);
                break;
        }
        System.out.println ("Enter operation");
        operation = sc.nextInt ();
    }
    System.out.println ("Global result = " + result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30161341_30161497_5_49
30161341_30161824_1_49
Title: Trouble with basic calculator using switch 
----------------------------------------

public static void main (String args []) {
    int result = 0;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter number");
    result = sc.nextInt ();
    System.out.println ("Enter operation");
    System.out.println ("1.+");
    System.out.println ("2.-");
    System.out.println ("3.*");
    System.out.println ("4./");
    System.out.println ("5.=");
    int operation = sc.nextInt ();
    while (operation != 5) {
        System.out.println ("Enter next number");
        int number = sc.nextInt ();
        switch (operation) {
            case 1 :
                result += number;
                System.out.println ("result= " + result);
                break;
            case 2 :
                result -= number;
                System.out.println ("result= " + result);
                break;
            case 3 :
                result *= number;
                System.out.println ("result= " + result);
                break;
            case 4 :
                result /= number;
                System.out.println ("result= " + result);
                break;
        }
        System.out.println (result);
        System.out.println ("Enter operation");
        operation = sc.nextInt ();
    }
}
----------------------------------------

public static void main (String [] args) throws java.lang.Exception {
    int result = 0;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter number");
    int number = sc.nextInt ();
    System.out.println ("Enter operation");
    System.out.println ("1.+");
    System.out.println ("2.-");
    System.out.println ("3.*");
    System.out.println ("4./");
    System.out.println ("5.=");
    int operation = sc.nextInt ();
    try {
        while (operation != 5) {
            switch (operation) {
                case 1 :
                    result += number;
                    System.out.println ("result= " + result);
                    break;
                case 2 :
                    result -= number;
                    System.out.println ("result= " + result);
                    break;
                case 3 :
                    result *= number;
                    System.out.println ("result= " + result);
                    break;
                case 4 :
                    result /= number;
                    System.out.println ("result= " + result);
                    break;
            }
            System.out.println ("Enter next number");
            number = sc.nextInt ();
            System.out.println ("Enter operation");
            operation = sc.nextInt ();
        }
        System.out.println ("Final esult is " + result);
    } catch (Exception e) {
        System.out.println (e);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30161341_30161795_1_43
30161341_30161824_1_49
Title: Trouble with basic calculator using switch 
----------------------------------------

public static void main (String [] args) {
    int result = 0;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter number");
    result = sc.nextInt ();
    System.out.println ("Enter operation");
    System.out.println ("1.+");
    System.out.println ("2.-");
    System.out.println ("3.*");
    System.out.println ("4./");
    System.out.println ("5.=");
    int operation = sc.nextInt ();
    while (operation != 5) {
        System.out.println ("Enter next number");
        int operand2 = sc.nextInt ();
        switch (operation) {
            case 1 :
                result += operand2;
                System.out.println ("result= " + result);
                break;
            case 2 :
                result -= operand2;
                System.out.println ("result= " + result);
                break;
            case 3 :
                result *= operand2;
                System.out.println ("result= " + result);
                break;
            case 4 :
                result /= operand2;
                System.out.println ("result= " + result);
                break;
        }
        System.out.println ("Enter operation");
        operation = sc.nextInt ();
    }
    System.out.println ("Global result = " + result);
}
----------------------------------------

public static void main (String [] args) throws java.lang.Exception {
    int result = 0;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter number");
    int number = sc.nextInt ();
    System.out.println ("Enter operation");
    System.out.println ("1.+");
    System.out.println ("2.-");
    System.out.println ("3.*");
    System.out.println ("4./");
    System.out.println ("5.=");
    int operation = sc.nextInt ();
    try {
        while (operation != 5) {
            switch (operation) {
                case 1 :
                    result += number;
                    System.out.println ("result= " + result);
                    break;
                case 2 :
                    result -= number;
                    System.out.println ("result= " + result);
                    break;
                case 3 :
                    result *= number;
                    System.out.println ("result= " + result);
                    break;
                case 4 :
                    result /= number;
                    System.out.println ("result= " + result);
                    break;
            }
            System.out.println ("Enter next number");
            number = sc.nextInt ();
            System.out.println ("Enter operation");
            operation = sc.nextInt ();
        }
        System.out.println ("Final esult is " + result);
    } catch (Exception e) {
        System.out.println (e);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30162645_30162741_1_20
30162645_30162776_6_22
Title: Calling methods for my java class 
----------------------------------------

public static String minValue () {
    Scanner input = new Scanner (System.in);
    System.out.print ("How many first names are there?");
    int numOfNames = input.nextInt ();
    String [] names = new String [numOfNames];
    double [] values = new double [numOfNames];
    for (int number = 0;
    number < numOfNames; number ++) {
        System.out.print ("Enter name: ");
        names [number] = input.next ();
        System.out.print ("Enter the value: ");
        values [number] = input.nextDouble ();
    }
    int i = 0;
    return names [i];
}
----------------------------------------

public static String minValue () {
    String name = "none";
    Scanner input = new Scanner (System.in);
    System.out.print ("How many first names are there?");
    int numOfNames = input.nextInt ();
    for (int number = 0;
    number < numOfNames; number ++) {
        System.out.print ("Enter name: ");
        name = input.next ();
    }
    System.out.print ("How many values are there?");
    int numOfValues = input.nextInt ();
    for (int count = 0;
    count < numOfValues; count ++) {
        System.out.print ("Enter the value: ");
        double value = input.nextDouble ();
    }
    return name;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30169587_30169815_1_26
30169587_30170303_1_27
Title: Find all the combination of substrings that add up to the given string 
----------------------------------------

static List < List < String > > substrings (String input) {
    if (input.length () == 1) return Collections.singletonList (Collections.singletonList (input));

    List < List < String > > result = new ArrayList < > ();
    for (List < String > subresult : substrings (input.substring (1))) {
        List < String > l2 = new ArrayList < > (subresult);
        l2.set (0, input.charAt (0) + l2.get (0));
        result.add (l2);
        List < String > l = new ArrayList < > (subresult);
        l.add (0, input.substring (0, 1));
        result.add (l);
    }
    return result;
}
----------------------------------------

public static List < List < String > > substrings (final String input) {
    if (input.isEmpty ()) return Collections.emptyList ();

    final int size = 1 << (input.length () - 1);
    return new AbstractList < List < String > > () {
        @Override
        public List < String > get (int index) {
            List < String > entry = new ArrayList < > ();
            int last = 0;
            while (true) {
                int next = Integer.numberOfTrailingZeros (index>> last) + last + 1;
                if (next == last + 33) break;

                entry.add (input.substring (last, next));
                last = next;
            }
            entry.add (input.substring (last));
            return entry;
        }@Override
        public int size () {
            return size;
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30169587_30169815_1_26
30169587_53035312_1_22
Title: Find all the combination of substrings that add up to the given string 
----------------------------------------

static List < List < String > > substrings (String input) {
    if (input.length () == 1) return Collections.singletonList (Collections.singletonList (input));

    List < List < String > > result = new ArrayList < > ();
    for (List < String > subresult : substrings (input.substring (1))) {
        List < String > l2 = new ArrayList < > (subresult);
        l2.set (0, input.charAt (0) + l2.get (0));
        result.add (l2);
        List < String > l = new ArrayList < > (subresult);
        l.add (0, input.substring (0, 1));
        result.add (l);
    }
    return result;
}
----------------------------------------

static List < List < String > > substrings (String input) {
    List < List < String > > result = new ArrayList < > ();
    if (input.length () == 1) {
        result.add (Arrays.asList (new String [] {input}));
    } else {
        for (int i = 0;
        i < input.length () - 1; i ++) {
            String root = input.substring (0, i + 1);
            String leaf = input.substring (i + 1);
            for (List < String > strings : substrings (leaf)) {
                ArrayList < String > current = new ArrayList < String > ();
                current.add (root);
                current.addAll (strings);
                result.add (current);
            }
        }
        result.add (Arrays.asList (new String [] {input}));
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30169587_30170303_1_27
30169587_53035312_1_22
Title: Find all the combination of substrings that add up to the given string 
----------------------------------------

public static List < List < String > > substrings (final String input) {
    if (input.isEmpty ()) return Collections.emptyList ();

    final int size = 1 << (input.length () - 1);
    return new AbstractList < List < String > > () {
        @Override
        public List < String > get (int index) {
            List < String > entry = new ArrayList < > ();
            int last = 0;
            while (true) {
                int next = Integer.numberOfTrailingZeros (index>> last) + last + 1;
                if (next == last + 33) break;

                entry.add (input.substring (last, next));
                last = next;
            }
            entry.add (input.substring (last));
            return entry;
        }@Override
        public int size () {
            return size;
        }}

    ;
}
----------------------------------------

static List < List < String > > substrings (String input) {
    List < List < String > > result = new ArrayList < > ();
    if (input.length () == 1) {
        result.add (Arrays.asList (new String [] {input}));
    } else {
        for (int i = 0;
        i < input.length () - 1; i ++) {
            String root = input.substring (0, i + 1);
            String leaf = input.substring (i + 1);
            for (List < String > strings : substrings (leaf)) {
                ArrayList < String > current = new ArrayList < String > ();
                current.add (root);
                current.addAll (strings);
                result.add (current);
            }
        }
        result.add (Arrays.asList (new String [] {input}));
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30174290_30175659_12_32
30174290_30176280_12_30
Title: Converting String to Integer in Android application 
----------------------------------------

public void ViewaNumber (View V1) {
    txtval = (EditText) findViewById (R.id.Stringvalue);
    number = (EditText) findViewById (R.id.Numbers_text);
    int ed;
    ed = 0;
    try {
        ed = Integer.parseInt (number.getText ().toString ());
    } catch (Exception e) {
        e.printStackTrace ();
    }
    if (txtval.length () != 0) {
        Toast.makeText (getBaseContext (), "String " + txtval.getText ().toString (), Toast.LENGTH_LONG).show ();
    } else if (number.length () != 0) {
        Toast.makeText (getBaseContext (), ed, Toast.LENGTH_LONG).show ();
    }

}
----------------------------------------

public void ViewaNumber (View V1) {
    txtval = (EditText) findViewById (R.id.Stringvalue);
    number = (EditText) findViewById (R.id.Numbers_text);
    if (txtval.length () != 0) {
        Toast.makeText (getBaseContext (), "String " + txtval.getText ().toString (), Toast.LENGTH_LONG).show ();
    } else if (number.length () != 0) {
        ed = Integer.parseInt (number.getText ().toString ());
        Toast.makeText (getBaseContext (), "Number " + ed, Toast.LENGTH_LONG).show ();
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30189253_30189302_1_17
30189253_49372700_1_32
Title: Need help to explain seats at a cinema program made in java 
----------------------------------------

public void findAvailable () {
    boolean found = false;
    int row = 0;
    while (! found && row < seats.length) {
        int col = 0;
        while (! found && col < seats [row].length) {
            if (seats [row] [col]) {
                found = true;
                System.out.println ("Row = " + row + " Seat = " + seat);
            }
            col ++;
        }
        row ++;
    }
}
----------------------------------------

public void findAvailable () {
    boolean found = false;
    int row = 0;
    while (! found && row < seats.length) {
        int seat = 0;
        while (! found && seat < seats [row].length) {
            if (seats [row] [seat]) {
                found = true;
                System.out.println ("Row = " + row + " Seat = " + seat);
            }
            seat ++;
        }
        row ++;
    }
    if (! found) System.out.println ("There are no seats available this time...");

}
----------------------------------------
