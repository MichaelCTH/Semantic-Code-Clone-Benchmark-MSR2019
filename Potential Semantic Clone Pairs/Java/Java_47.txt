$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30420473_1_19
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int output = 0;
    int noOfZero = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            noOfZero += 1;
            continue;
        }
        if (A [i] == 1 && noOfZero > 0) {
            output += noOfZero * A [i];
        }
    }
    if (output > 1000000000 || output < 0) {
        return - 1;
    }
    return output;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30420473_1_19
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int output = 0;
    int noOfZero = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            noOfZero += 1;
            continue;
        }
        if (A [i] == 1 && noOfZero > 0) {
            output += noOfZero * A [i];
        }
    }
    if (output > 1000000000 || output < 0) {
        return - 1;
    }
    return output;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30420473_1_19
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int output = 0;
    int noOfZero = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            noOfZero += 1;
            continue;
        }
        if (A [i] == 1 && noOfZero > 0) {
            output += noOfZero * A [i];
        }
    }
    if (output > 1000000000 || output < 0) {
        return - 1;
    }
    return output;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_31222875_1_47
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_31644557_13_49
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_32138195_9_20
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_33650673_2_17
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_33759174_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_35704440_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_37336768_2_21
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_46779804_1_14
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_30931456_1_15
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int carsEast = 0;
    int carPairs = 0;
    for (int i = 0;
    i < A.Length; i ++) {
        carsEast = A [i] == 0 ? carsEast += 1 : carsEast;
        carPairs = A [i] == 1 && carsEast > 0 ? carPairs + carsEast : carPairs;
        if (carPairs > 1000000000) {
            return - 1;
        }
    }
    return carPairs;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_31644557_13_49
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_32138195_9_20
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_33650673_2_17
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_33759174_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_35704440_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_37336768_2_21
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_46779804_1_14
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31222875_1_47
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int west = 0;
    int east = 0;
    int pairsCounter = 0;
    if (A.Length < 0 || A.Length > 100000) return 0;

    if (A.Length == 2 && A [0] == 0 && A [1] == 1) return 1;

    for (int i = 0;
    i < A.Length; i ++) {
        if (A [i] == 1) west ++;

    }
    east = A.Length - west;
    if (east == 0 || west == 0) return 0;

    for (int i = 0;
    (i < A.Length && west > 0); i ++) {
        if (A [i] == 0 && west > 0) {
            pairsCounter = pairsCounter + west;
        } else {
            west --;
        }
        if (pairsCounter > 1000000000) return - 1;

    }
    return pairsCounter;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_32138195_9_20
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_33650673_2_17
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_33759174_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_35704440_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_37336768_2_21
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_46779804_1_14
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_31644557_13_49
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    if (N < 2) {
        return 0;
    }
    int onesCount = 0;
    boolean zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (zeroHappenedBefore && A [i] == 1) {
            ++ onesCount;
        } else if (A [i] == 0) {
            zeroHappenedBefore = true;
        }

    }
    if (onesCount == 0) {
        return 0;
    }
    long combinations = 0;
    int conditionReturnFail = 1000000000;
    zeroHappenedBefore = false;
    for (int i = 0;
    i < N; ++ i) {
        if (A [i] == 0) {
            combinations += onesCount;
            if (conditionReturnFail < combinations) {
                return FAIL;
            }
            zeroHappenedBefore = true;
        } else {
            if (zeroHappenedBefore) {
                -- onesCount;
            }
        }
    }
    return (int) combinations;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_32138195_9_20
23774985_33650673_2_17
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_32138195_9_20
23774985_33759174_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_32138195_9_20
23774985_35704440_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_32138195_9_20
23774985_37336768_2_21
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_32138195_9_20
23774985_46779804_1_14
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_32138195_9_20
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_32138195_9_20
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_32138195_9_20
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int N = A.length;
    int [] sum = new int [N];
    calculateOnes (A, sum);
    int counter = 0;
    for (int i = 0;
    i < N; i ++) {
        if (A [i] == 0) {
            counter += sum [i];
        }
    }
    return counter;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33650673_2_17
23774985_33759174_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33650673_2_17
23774985_35704440_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33650673_2_17
23774985_37336768_2_21
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33650673_2_17
23774985_46779804_1_14
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33650673_2_17
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33650673_2_17
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33650673_2_17
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    final int MAX_RESULT = 1000000000;
    int result = 0, one_counter = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            one_counter ++;
        } else {
            if (result > MAX_RESULT) {
                return - 1;
            }
            result += one_counter;
        }
    }
    return result;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33759174_1_19
23774985_35704440_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33759174_1_19
23774985_37336768_2_21
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33759174_1_19
23774985_46779804_1_14
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33759174_1_19
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33759174_1_19
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_33759174_1_19
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    boolean isZero = false;
    long pairCount = 0;
    int zeroCount = 0;
    long LIMIT_CAR_COUNT = 1000000000;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            isZero = true;
            zeroCount ++;
        }
        if (A [i] == 1 && isZero) pairCount = pairCount + zeroCount;

    }
    if (pairCount > LIMIT_CAR_COUNT) return - 1;
    else return (int) pairCount;

}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_35704440_1_19
23774985_37336768_2_21
Title: Codility passing car 
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_35704440_1_19
23774985_46779804_1_14
Title: Codility passing car 
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_35704440_1_19
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_35704440_1_19
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_35704440_1_19
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

int solution (int A [], int N) {
    int X = 0, count = 0, i;
    for (i = 0; i < N; i ++) {
        if (A [i] == 0) X ++;
        else {
            count += X;
        }
        if (count > 1000000000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_37336768_2_21
23774985_46779804_1_14
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_37336768_2_21
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_37336768_2_21
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_37336768_2_21
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int countZeros = 0;
    int sumOfValidPairs = 0;
    int i = 0;
    while (i < A.length) {
        if (A [i] == 0) {
            countZeros ++;
        } else {
            sumOfValidPairs += countZeros;
        }
        i ++;
    }
    if (sumOfValidPairs <= 1000000000 && sumOfValidPairs >= 0) {
        return sumOfValidPairs;
    }
    return - 1;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_46779804_1_14
23774985_46798022_1_19
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_46779804_1_14
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    int ones = 0, count = 0;
    for (int j = A.length - 1;
    j >= 0; j --) {
        if (A [j] == 1) {
            ones ++;
        } else if (A [j] == 0) {
            count += ones;
        }

        if (count > 1_000_000_000) {
            return - 1;
        }
    }
    return count;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_46798022_1_19
23774985_47966424_1_33
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_46798022_1_19
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public int solution (int [] A) {
    if (A.length < 2) {
        return 0;
    }
    long passingPairs = 0;
    long eastBound = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0) {
            eastBound ++;
        } else {
            if (eastBound > 0) {
                passingPairs += eastBound;
            }
        }
    }
    return passingPairs > 1000000000 ? - 1 : (int) passingPairs;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23774985_47966424_1_33
23774985_49591865_1_15
Title: Codility passing car 
----------------------------------------

public static int solution (int [] A) {
    if (A.length == 1) return 0;

    if (A.length == 2) {
        if (A [0] == 0 && A [1] == 1) return 1;
        else return 0;

    }
    int count = 0;
    int zeroCount = 0;
    boolean zeroFlag = false;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] == 0 && ! zeroFlag) zeroFlag = true;
        else if (A [i] == 0 && zeroFlag) zeroCount ++;

        if (zeroFlag && A [i] == 1) count = (count + 1) + zeroCount;

        if (count > 1000000000) return - 1;

    }
    return count;
}
----------------------------------------

public int solution (int [] A) {
    int A1 = 0;
    int pair = 0;
    for (int i = A.length - 1;
    i >= 0; i --) {
        if (A [i] == 1) {
            A1 ++;
        } else {
            pair += A1;
        }
        if (pair > 1000000000) {
            return - 1;
        }
    }
    return pair;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23780821_23780989_3_15
23780821_23781040_2_11
Title: java-Printing Reversed Triangle containing numbers 9-0 
----------------------------------------

public static void main (String [] args) {
    int start = 6;
    int diff = 3;
    for (int z = start;
    diff >= 0; z = start) {
        for (int i = z;
        i <= start + diff; i ++) {
            System.out.print (i);
        }
        System.out.println ();
        start -= diff;
        diff --;
    }
}
----------------------------------------

public static void main (String [] args) {
    int z = 9;
    for (int x = 1;
    x <= 4; x ++) {
        for (int y = 4;
        y >= x; y --) {
            System.out.print (z - y + 1);
        }
        z = z - (4 - x);
        System.out.print ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23785804_23795304_238_258
23785804_23795304_260_354
Title: Java sliding JPanels 
----------------------------------------

private void slide (final int slideType) {
    if (! isSlideInProgress) {
        isSlideInProgress = true;
        final Thread t0 = new Thread (new Runnable () {
            @Override
            public void run () {
                parent.setCursor (Cursor.getPredefinedCursor (Cursor.WAIT_CURSOR));
                disableUserInput (parent);
                slide (true, slideType);
                enableUserInput (parent);
                parent.setCursor (Cursor.getPredefinedCursor (Cursor.DEFAULT_CURSOR));
                isSlideInProgress = false;
            }}

        );
        t0.setDaemon (true);
        t0.start ();
    } else {
        Toolkit.getDefaultToolkit ().beep ();
    }
}
----------------------------------------

private void slide (final boolean useLoop, final int slideType) {
    if (jPanels.size () < 2) {
        System.err.println ("Not enough panels");
        return;
    }
    synchronized (lock) {
        Component componentOld = null;
        Component componentNew = null;
        if ((slideType == LEFT) || (slideType == TOP)) {
            componentNew = jPanels.remove (jPanels.size () - 1);
            componentOld = jPanels.get (0);
            jPanels.add (0, componentNew);
        }
        if ((slideType == RIGHT) || (slideType == BOTTOM)) {
            componentOld = jPanels.remove (0);
            jPanels.add (componentOld);
            componentNew = jPanels.get (0);
        }
        final int w = componentOld.getWidth ();
        final int h = componentOld.getHeight ();
        final Point p1 = componentOld.getLocation ();
        final Point p2 = new Point (0, 0);
        if (slideType == LEFT) {
            p2.x += w;
        }
        if (slideType == RIGHT) {
            p2.x -= w;
        }
        if (slideType == TOP) {
            p2.y += h;
        }
        if (slideType == BOTTOM) {
            p2.y -= h;
        }
        componentNew.setLocation (p2);
        int step = 0;
        if ((slideType == LEFT) || (slideType == RIGHT)) {
            step = (int) (((float) parent.getWidth () / (float) Toolkit.getDefaultToolkit ().getScreenSize ().width) * 40.f);
        } else {
            step = (int) (((float) parent.getHeight () / (float) Toolkit.getDefaultToolkit ().getScreenSize ().height) * 20.f);
        }
        step = step < 5 ? 5 : step;
        basePanel.add (componentNew);
        basePanel.revalidate ();
        if (useLoop) {
            final int max = (slideType == LEFT) || (slideType == RIGHT) ? w : h;
            final long t0 = System.currentTimeMillis ();
            for (int i = 0;
            i != (max / step); i ++) {
                switch (slideType) {
                    case LEFT :
                        {
                            p1.x -= step;
                            componentOld.setLocation (p1);
                            p2.x -= step;
                            componentNew.setLocation (p2);
                            break;
                        } case RIGHT :
                        {
                            p1.x += step;
                            componentOld.setLocation (p1);
                            p2.x += step;
                            componentNew.setLocation (p2);
                            break;
                        } case TOP :
                        {
                            p1.y -= step;
                            componentOld.setLocation (p1);
                            p2.y -= step;
                            componentNew.setLocation (p2);
                            break;
                        } case BOTTOM :
                        {
                            p1.y += step;
                            componentOld.setLocation (p1);
                            p2.y += step;
                            componentNew.setLocation (p2);
                            break;
                        } default :
                        new RuntimeException ("ProgramCheck").printStackTrace ();
                        break;
                }
                try {
                    Thread.sleep (500 / (max / step));
                } catch (final Exception e) {
                    e.printStackTrace ();
                }
            }
            final long t1 = System.currentTimeMillis ();
        }
        componentOld.setLocation (- 10000, - 10000);
        componentNew.setLocation (0, 0);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23798167_23798268_1_36
23798167_23798316_96_123
Title: How to open the camera with more than one button click in Android? 
----------------------------------------

@Override
protected void onActivityResult (int requestCode, int resultCode, Intent data) {
    super.onActivityResult (requestCode, resultCode, data);
    if (requestCode == 0) {
        if (resultCode == RESULT_OK && data != null) {
            switch (requestCode) {
                case 0 :
                    bp = (Bitmap) data.getExtras ().get ("data");
                    imgPersonalSnap.setImageBitmap (bp);
                    BitmapDrawable drawable = (BitmapDrawable) imgHideBitmap.getDrawable ();
                    bitmap = drawable.getBitmap ();
                    break;
                case 1 :
                    bp = (Bitmap) data.getExtras ().get ("data");
                    imgAddressProofSnap.setImageBitmap (bp);
                    BitmapDrawable drawable = (BitmapDrawable) imgHideBitmap.getDrawable ();
                    bitmap = drawable.getBitmap ();
                    break;
                case 2 :
                    bp = (Bitmap) data.getExtras ().get ("data");
                    imgPanCardProofSnap.setImageBitmap (bp);
                    BitmapDrawable drawable = (BitmapDrawable) imgHideBitmap.getDrawable ();
                    bitmap = drawable.getBitmap ();
                    break;
            }
        }
    }
}
----------------------------------------

protected void onActivityResult (int requestCode, int resultCode, Intent data) {
    super.onActivityResult (requestCode, resultCode, data);
    if (requestCode == FIRSTCLICK) {
        if (resultCode == RESULT_OK && data != null) {
            imgPersonalSnap.setImageBitmap (decodeFile (getAbsolutePath (data.getData ())));
        }
    } else if (requestCode == FIRSTCLICK) {
        if (resultCode == RESULT_OK && data != null) {
            imgAddressProofSnap.setImageBitmap (decodeFile (getAbsolutePath (data.getData ())));
        }
    } else if (requestCode == FIRSTCLICK) {
        if (resultCode == RESULT_OK && data != null) {
            imgPanCardProofSnap.setImageBitmap (decodeFile (getAbsolutePath (data.getData ())));
        }
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23799498_23799611_1_15
23799498_23799783_3_18
Title: Why does my program produce no output while it's compiling fine? 
----------------------------------------

public static void main (String [] args) {
    int i, j, k = 0;
    int test [] [] = new int [4] [5];
    for (i = 0; i < 4; i ++) {
        for (j = 0; j < 5; j ++) {
            test [i] [j] = k;
            k ++;
        }
    }
    for (i = 0; i < 4; i ++) {
        for (j = 0; j < 5; j ++) System.out.print (test [i] [j] + " ");

        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    int i, j, k = 0;
    int test [] [] = new int [4] [5];
    for (i = 0; i < 4; i ++) {
        for (j = 0; j < 5; j ++) {
            test [i] [j] = k;
            k ++;
        }
    }
    for (i = 0; i < 4; i ++) {
        for (j = 0; j < 5; j ++) {
            System.out.print (test [i] [j] + " ");
            System.out.println ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23814579_23830935_1_32
23814579_45341652_1_18
Title: Apache POI to read excel file with many worksheets and write single sheet to new file 
----------------------------------------

public static void main (String [] args) {
    try {
        FileInputStream file = new FileInputStream (new File ("FileLotOfSheets.xlsx"));
        XSSFWorkbook workbook = new XSSFWorkbook (file);
        String sheetName = "mySheet";
        for (int i = workbook.getNumberOfSheets () - 1;
        i >= 0; i --) {
            XSSFSheet tmpSheet = workbook.getSheetAt (i);
            if (! tmpSheet.getSheetName ().equals (sheetName)) {
                workbook.removeSheetAt (i);
            }
        }
        file.close ();
        FileOutputStream out = new FileOutputStream ("FileOnlyOneSheetFromLots.xlsx");
        workbook.write (out);
        out.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        InputStream input = POIExample.class.getResourceAsStream ("qa.xls");
        POIFSFileSystem fs = new POIFSFileSystem (input);
        HSSFWorkbook wb = new HSSFWorkbook (fs);
        for (int i = 0;
        i < wb.getNumberOfSheets (); i ++) {
            HSSFSheet sheet = wb.getSheetAt (i);
        }
    } catch (IOException ex) {
        ex.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23815472_23815846_18_46
23815472_23817255_53_81
Title: How to animate Rectangle in JPanel? 
----------------------------------------

public BallControl () {
    JPanel panel = new JPanel ();
    panel.add (Suspend);
    panel.add (Resume);
    panel.add (Add);
    panel.add (Subtract);
    ballPanel.setBorder (new javax.swing.border.LineBorder (Color.red));
    Delay.setOrientation (JScrollBar.HORIZONTAL);
    ballPanel.setDelay (Delay.getMaximum ());
    setLayout (new BorderLayout ());
    add (Delay, BorderLayout.NORTH);
    add (ballPanel, BorderLayout.CENTER);
    add (panel, BorderLayout.SOUTH);
    Suspend.addActionListener (new Listener ());
    Resume.addActionListener (new Listener ());
    Add.addActionListener (new Listener ());
    Subtract.addActionListener (new Listener ());
    Delay.addAdjustmentListener (new AdjustmentListener () {
        public void adjustmentValueChanged (AdjustmentEvent e) {
            ballPanel.setDelay (Delay.getMaximum () - e.getValue ());
        }}

    );
}
----------------------------------------

public BallControl () {
    JPanel panel = new JPanel ();
    panel.add (Suspend);
    panel.add (Resume);
    panel.add (Add);
    panel.add (Subtract);
    ballPanel.setBorder (new javax.swing.border.LineBorder (Color.red));
    Delay.setOrientation (JScrollBar.HORIZONTAL);
    ballPanel.setDelay (Delay.getMaximum ());
    setLayout (new BorderLayout ());
    add (Delay, BorderLayout.NORTH);
    add (ballPanel, BorderLayout.CENTER);
    add (panel, BorderLayout.SOUTH);
    Suspend.addActionListener (new Listener ());
    Resume.addActionListener (new Listener ());
    Add.addActionListener (new Listener ());
    Subtract.addActionListener (new Listener ());
    Delay.addAdjustmentListener (new AdjustmentListener () {
        public void adjustmentValueChanged (AdjustmentEvent e) {
            ballPanel.setDelay (Delay.getMaximum () - e.getValue ());
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23815676_23816029_186_235
23815676_23816029_243_265
Title: Loading Wavefont .obj files from relative path error 
----------------------------------------

public void parseLine (String line) throws IOException, NumberFormatException, NoSuchElementException {
    StringTokenizer tokenizer = new StringTokenizer (line);
    String command = tokenizer.nextToken ();
    if (command.equals ("v")) {
        vertices.add (new Vector3D (Float.parseFloat (tokenizer.nextToken ()), Float.parseFloat (tokenizer.nextToken ()), Float.parseFloat (tokenizer.nextToken ())));
    } else if (command.equals ("f")) {
        List currVertices = new ArrayList ();
        while (tokenizer.hasMoreTokens ()) {
            String indexStr = tokenizer.nextToken ();
            int endIndex = indexStr.indexOf ('/');
            if (endIndex != - 1) {
                indexStr = indexStr.substring (0, endIndex);
            }
            currVertices.add (getVector (indexStr));
        }
        Vector3D [] array = new Vector3D [currVertices.size ()];
        currVertices.toArray (array);
    } else if (command.equals ("g")) {
        if (tokenizer.hasMoreTokens ()) {
            String name = tokenizer.nextToken ();
            currentGroup = new PolygonGroup (name);
        } else {
            currentGroup = new PolygonGroup ();
        }
        object.addPolygonGroup (currentGroup);
    } else if (command.equals ("mtllib")) {
        String name = tokenizer.nextToken ();
        parseFile (name);
    } else if (command.equals ("usemtl")) {
        String name = tokenizer.nextToken ();
        currentMaterial = (Material) materials.get (name);
        if (currentMaterial == null) {
            System.out.println ("no material: " + name);
        }
    } else {
    }

}
----------------------------------------

public void parseLine (String line) throws NoSuchElementException {
    StringTokenizer tokenizer = new StringTokenizer (line);
    String command = tokenizer.nextToken ();
    if (command.equals ("newmtl")) {
        String name = tokenizer.nextToken ();
        currentMaterial = (Material) materials.get (name);
        if (currentMaterial == null) {
            currentMaterial = new Material ();
            materials.put (name, currentMaterial);
        }
    } else if (command.equals ("map_Kd")) {
        String name = tokenizer.nextToken ();
        File file = new File (path, name);
        if (! file.equals (currentMaterial.sourceFile)) {
            currentMaterial.sourceFile = file;
        }
    } else {
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23832922_23833048_1_12
23832922_50832234_1_23
Title: Print all values in a 3d array 
----------------------------------------

public static void main (String [] args) {
    String [] [] [] array3d = new String [10] [10] [10];
    for (String [] [] array2d : array3d) {
        for (String [] array : array2d) {
            Arrays.fill (array, "hello");
        }
    }
    System.out.println (Arrays.deepToString (array3d));
}
----------------------------------------

public static void main (String [] args) {
    int [] [] [] firstInt3D = {{{1, 2}}, {{3, 4}}, {{5, 6, 7, 8}, {9, 10}}, {{11}, {12, 13, 14}},};
    int x = 0;
    for (int [] [] accessPage : firstInt3D) {
        System.out.println ("page:" + x);
        if (x < firstInt3D.length) x ++;

        for (int [] accessRow : accessPage) {
            System.out.println (Arrays.toString (accessRow));
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23838985_23838995_1_24
23838985_23838998_1_17
Title: Compiler says missing return statement but I already have 3 
----------------------------------------

public int tortoiseMoves () {
    int i = tGen ();
    if (i >= 1 && i <= 5) {
        int fastplod = 3;
        return fastplod;
    } else if (i >= 6 && i <= 8) {
        int slowplod = 1;
        return slowplod;
    } else if (i >= 9 && i <= 10) {
        int slip = - 6;
        return slip;
    } else {
        return 0;
    }

}
----------------------------------------

public int tortoiseMoves () {
    switch (tGen ()) {
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
            return 3;
        case 6 :
        case 7 :
        case 8 :
            return 1;
        case 9 :
        case 10 :
            return - 6;
        default :
            return 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23838985_23838995_1_24
23838985_23839025_1_27
Title: Compiler says missing return statement but I already have 3 
----------------------------------------

public int tortoiseMoves () {
    int i = tGen ();
    if (i >= 1 && i <= 5) {
        int fastplod = 3;
        return fastplod;
    } else if (i >= 6 && i <= 8) {
        int slowplod = 1;
        return slowplod;
    } else if (i >= 9 && i <= 10) {
        int slip = - 6;
        return slip;
    } else {
        return 0;
    }

}
----------------------------------------

public int tortoiseMoves () {
    int i = tGen ();
    if (i >= 1 && i <= 5) {
        int fastplod = 3;
        return fastplod;
    }
    if (i >= 6 && i <= 8) {
        int slowplod = 1;
        return slowplod;
    }
    if (i >= 9 && i <= 10) {
        int slip = - 6;
        return slip;
    }
    return someDefaultValue;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23838985_23838998_1_17
23838985_23839025_1_27
Title: Compiler says missing return statement but I already have 3 
----------------------------------------

public int tortoiseMoves () {
    switch (tGen ()) {
        case 1 :
        case 2 :
        case 3 :
        case 4 :
        case 5 :
            return 3;
        case 6 :
        case 7 :
        case 8 :
            return 1;
        case 9 :
        case 10 :
            return - 6;
        default :
            return 0;
    }
}
----------------------------------------

public int tortoiseMoves () {
    int i = tGen ();
    if (i >= 1 && i <= 5) {
        int fastplod = 3;
        return fastplod;
    }
    if (i >= 6 && i <= 8) {
        int slowplod = 1;
        return slowplod;
    }
    if (i >= 9 && i <= 10) {
        int slip = - 6;
        return slip;
    }
    return someDefaultValue;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23841518_23841643_136_153
23841518_23841643_87_101
Title: How to pop up a text box(or tooltip) via script in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    long now = System.currentTimeMillis ();
    long lapsed = now - startTime;
    float opacity = startAt;
    if (lapsed >= duration) {
        opacity = endAt;
        ((Timer) e.getSource ()).stop ();
        if (endListener != null) {
            endListener.actionPerformed (new ActionEvent (this, ActionEvent.ACTION_PERFORMED, "stopped"));
        }
    } else {
        float progress = (float) lapsed / (float) duration;
        float distance = endAt - startAt;
        opacity = (float) (distance * progress);
        opacity += startAt;
    }
    window.setOpacity (opacity);
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    Timer timer = new Timer (delay, new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            new FadeTimer (frame, 1000, 1f, 0f, new ActionListener () {
                @Override
                public void actionPerformed (ActionEvent e) {
                    frame.dispose ();
                }}

            ).start ();
        }}

    );
    timer.setRepeats (false);
    timer.start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23841518_23841643_136_153
23841518_23841643_90_97
Title: How to pop up a text box(or tooltip) via script in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    long now = System.currentTimeMillis ();
    long lapsed = now - startTime;
    float opacity = startAt;
    if (lapsed >= duration) {
        opacity = endAt;
        ((Timer) e.getSource ()).stop ();
        if (endListener != null) {
            endListener.actionPerformed (new ActionEvent (this, ActionEvent.ACTION_PERFORMED, "stopped"));
        }
    } else {
        float progress = (float) lapsed / (float) duration;
        float distance = endAt - startAt;
        opacity = (float) (distance * progress);
        opacity += startAt;
    }
    window.setOpacity (opacity);
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    new FadeTimer (frame, 1000, 1f, 0f, new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            frame.dispose ();
        }}

    ).start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23841518_23841643_87_101
23841518_23841643_90_97
Title: How to pop up a text box(or tooltip) via script in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    Timer timer = new Timer (delay, new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            new FadeTimer (frame, 1000, 1f, 0f, new ActionListener () {
                @Override
                public void actionPerformed (ActionEvent e) {
                    frame.dispose ();
                }}

            ).start ();
        }}

    );
    timer.setRepeats (false);
    timer.start ();
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    new FadeTimer (frame, 1000, 1f, 0f, new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            frame.dispose ();
        }}

    ).start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23843726_23843742_34_50
23843726_23843762_1_10
Title: Code not working(android) 
----------------------------------------

public void onClick (View v) {
    switch (v.getId ()) {
        case R.id.b1 :
            str1 = et1.getText ().toString ();
            str2 = et2.getText ().toString ();
            tv2.setText (str1);
            break;
    }
}
----------------------------------------

@Override
public void onClick (View v) {
    switch (v.getId ()) {
        case R.id.b1 :
            str1 = et1.getText ().toString ();
            str2 = et2.getText ().toString ();
            tv2.setText (str1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23847905_23852754_120_140
23847905_23852754_147_161
Title: Send audio over UDP 
----------------------------------------

public void run () {
    byteOutputStream = new ByteArrayOutputStream ();
    stopaudioCapture = false;
    try {
        DatagramSocket clientSocket = new DatagramSocket (8786);
        InetAddress IPAddress = InetAddress.getByName ("127.0.0.1");
        while (! stopaudioCapture) {
            int cnt = targetDataLine.read (tempBuffer, 0, tempBuffer.length);
            if (cnt > 0) {
                DatagramPacket sendPacket = new DatagramPacket (tempBuffer, tempBuffer.length, IPAddress, 9786);
                clientSocket.send (sendPacket);
                byteOutputStream.write (tempBuffer, 0, cnt);
            }
        }
        byteOutputStream.close ();
    } catch (Exception e) {
        System.out.println ("CaptureThread::run()" + e);
        System.exit (0);
    }
}
----------------------------------------

public void run () {
    try {
        int cnt;
        while ((cnt = InputStream.read (tempBuffer, 0, tempBuffer.length)) != - 1) {
            if (cnt > 0) {
                sourceLine.write (tempBuffer, 0, cnt);
            }
        }
    } catch (Exception e) {
        System.out.println (e);
        System.exit (0);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23848271_23848320_1_22
23848271_23848394_3_13
Title: How to remove an array from a collection? 
----------------------------------------

public static void main (String args []) {
    List < Integer [] > subSet = new ArrayList < Integer [] > ();
    subSet.add (new Integer [] {0, 1, 2, 3, 4});
    subSet.add (new Integer [] {0, 1, 2, 3, 5});
    subSet.add (new Integer [] {0, 0, 0, 0, 0});
    Integer [] elementToRemove = {0, 0, 0, 0, 0};
    System.out.println ("Before " + subSet.size ());
    Iterator < Integer [] > it = subSet.iterator ();
    while (it.hasNext ()) {
        if (Arrays.equals (it.next (), elementToRemove)) {
            it.remove ();
        }
    }
    System.out.println ("After " + subSet.size ());
}
----------------------------------------

public static void main (String args []) {
    List < IntegerArray > subSet = new ArrayList < IntegerArray > ();
    subSet.add (new IntegerArray (0, 1, 2, 3, 4));
    subSet.add (new IntegerArray (0, 1, 2, 3, 5));
    subSet.add (new IntegerArray (0, 0, 0, 0, 0));
    IntegerArray elementToRemove = new IntegerArray (0, 0, 0, 0, 0);
    System.out.println ("Before " + subSet.size ());
    subSet.remove (elementToRemove);
    System.out.println ("After " + subSet.size ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23850693_23850767_1_11
23850693_23850818_1_16
Title: An instantiable Java generic for <E extends Comparable<E>> 
----------------------------------------

public static void main (String args) {
    boolean numeric = false;
    if (numeric) {
        Trolley < Integer > trolley = new Trolley < > ();
        trolley.addItem (42);
    } else {
        Trolley < String > trolley = new Trolley < > ();
        trolley.addItem ("42");
    }
}
----------------------------------------

public static void main (String args) {
    boolean numeric = false;
    Trolley < ? extends Comparable < ? > > trolley = null;
    if (numeric) {
        Trolley < Integer > trolleyN = new Trolley < Integer > ();
        trolleyN.addItem (42);
        trolley = trolleyN;
    } else {
        Trolley < String > trolleyS = new Trolley < String > ();
        trolleyS.addItem ("42");
        trolley = trolleyS;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23867836_23868077_1_21
23867836_23868215_1_10
Title: CodingBat : LoneSum optimization 
----------------------------------------

public static int loneSum (int a, int b, int c) {
    if (a == b && b == c) {
        a = 0;
        b = 0;
        c = 0;
    }
    if (a == b) {
        a = 0;
        b = 0;
    }
    if (a == c) {
        a = 0;
        c = 0;
    }
    if (b == c) {
        b = 0;
        c = 0;
    }
    return a + b + c;
}
----------------------------------------

public int loneSum (int a, int b, int c) {
    int sum = 0;
    boolean ab = a != b;
    boolean ac = a != c;
    boolean bc = b != c;
    if (ab && ac) sum += a;

    if (ab && bc) sum += b;

    if (bc && ac) sum += c;

    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23867836_23868077_1_21
23867836_25373470_1_10
Title: CodingBat : LoneSum optimization 
----------------------------------------

public static int loneSum (int a, int b, int c) {
    if (a == b && b == c) {
        a = 0;
        b = 0;
        c = 0;
    }
    if (a == b) {
        a = 0;
        b = 0;
    }
    if (a == c) {
        a = 0;
        c = 0;
    }
    if (b == c) {
        b = 0;
        c = 0;
    }
    return a + b + c;
}
----------------------------------------

public int loneSum (int a, int b, int c) {
    if ((a == b) && (b == c) && (c == a)) return 0;
    else {
        if (a == b) return c;

        if (b == c) return a;

        if (a == c) return b;
        else return a + b + c;

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23867836_23868077_1_21
23867836_26647443_1_11
Title: CodingBat : LoneSum optimization 
----------------------------------------

public static int loneSum (int a, int b, int c) {
    if (a == b && b == c) {
        a = 0;
        b = 0;
        c = 0;
    }
    if (a == b) {
        a = 0;
        b = 0;
    }
    if (a == c) {
        a = 0;
        c = 0;
    }
    if (b == c) {
        b = 0;
        c = 0;
    }
    return a + b + c;
}
----------------------------------------

public int loneSum (int a, int b, int c) {
    int sum = a + b + c;
    if (a == b) sum -= a * 2;

    if (b == c) sum -= b * 2;

    if (c == a) sum -= c * 2;

    if (sum < 0) sum = 0;

    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23867836_23868215_1_10
23867836_25373470_1_10
Title: CodingBat : LoneSum optimization 
----------------------------------------

public int loneSum (int a, int b, int c) {
    int sum = 0;
    boolean ab = a != b;
    boolean ac = a != c;
    boolean bc = b != c;
    if (ab && ac) sum += a;

    if (ab && bc) sum += b;

    if (bc && ac) sum += c;

    return sum;
}
----------------------------------------

public int loneSum (int a, int b, int c) {
    if ((a == b) && (b == c) && (c == a)) return 0;
    else {
        if (a == b) return c;

        if (b == c) return a;

        if (a == c) return b;
        else return a + b + c;

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23867836_23868215_1_10
23867836_26647443_1_11
Title: CodingBat : LoneSum optimization 
----------------------------------------

public int loneSum (int a, int b, int c) {
    int sum = 0;
    boolean ab = a != b;
    boolean ac = a != c;
    boolean bc = b != c;
    if (ab && ac) sum += a;

    if (ab && bc) sum += b;

    if (bc && ac) sum += c;

    return sum;
}
----------------------------------------

public int loneSum (int a, int b, int c) {
    int sum = a + b + c;
    if (a == b) sum -= a * 2;

    if (b == c) sum -= b * 2;

    if (c == a) sum -= c * 2;

    if (sum < 0) sum = 0;

    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23867836_25373470_1_10
23867836_26647443_1_11
Title: CodingBat : LoneSum optimization 
----------------------------------------

public int loneSum (int a, int b, int c) {
    if ((a == b) && (b == c) && (c == a)) return 0;
    else {
        if (a == b) return c;

        if (b == c) return a;

        if (a == c) return b;
        else return a + b + c;

    }
}
----------------------------------------

public int loneSum (int a, int b, int c) {
    int sum = a + b + c;
    if (a == b) sum -= a * 2;

    if (b == c) sum -= b * 2;

    if (c == a) sum -= c * 2;

    if (sum < 0) sum = 0;

    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23876368_23876589_14_26
23876368_23876589_1_11
Title: Closing a file after writing recursively 
----------------------------------------

public void guardar (NodoAgenda nodo, PrintWriter salida) throws IOException {
    if (nodo != null) {
        Parser p = new Parser ();
        guardar (nodo.left);
        p.ponerPersona (nodo.info);
        String linea = p.obtainLine ();
        salida.println (linea);
        guardar (nodo.right, salida);
        this.numNodes --;
    }
}
----------------------------------------

public void guardar (NodoAgenda nodo) throws IOException {
    FileWriter fich_s = new FileWriter ("archivo.txt");
    BufferedWriter be = new BufferedWriter (fich_s);
    PrintWriter salida = new PrintWriter (be);
    if (nodo != null) {
        guardar (nodo.left, salida);
    }
    output.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23876422_23876505_1_22
23876422_23876621_1_19
Title: Java object returns null outside of for loop 
----------------------------------------

public Account [] search (double bal) {
    int flag = 0;
    Account [] tmp = new Account [account.length];
    for (int i = 0;
    i < account.length && account [i] != null; i ++) {
        tmp [i] = account [i];
        if (account [i].getBal () == bal) {
            System.out.println (tmp [i]);
            flag = i;
        }
    }
    System.out.println (tmp [flag]);
    return tmp;
}
----------------------------------------

public Account [] search (double bal) {
    ArrayList < Account > tmp = new ArrayList < Account > ();
    for (int i = 0;
    i < account.length && account [i] != null; i ++) {
        if (account [i].getBal () == bal) {
            tmp.add (account [i]);
            System.out.println (tmp [i]);
        }
    }
    Account resultArray [] = new Account [tmp.size ()];
    resultArray = tmp.toArray (resultArray);
    return resultArray;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2389448_2389496_1_10
2389448_2389508_1_12
Title: Optimize this ArrayList join method 
----------------------------------------

public String join (List < ? > list, char delimiter) {
    StringBuilder result = new StringBuilder ();
    for (Iterator < ? > i = list.iterator ();
    i.hasNext ();) {
        result.append (i.next ());
        if (i.hasNext ()) {
            result.append (delimiter);
        }
    }
    return result.toString ();
}
----------------------------------------

public static String join (List < String > list, char delim) {
    StringBuffer buf = new StringBuffer (512);
    first = true;
    for (String item : list) {
        if (first) {
            first = false;
        } else {
            buf.append (delim);
        }
        buf.append (item);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23895478_23895703_46_63
23895478_23895915_2_19
Title: Can Java Generics replace multiple similar classes? 
----------------------------------------

public static void main (String args []) {
    hasPrintableChildren parent;
    switch (args [0]) {
        case "foo" :
            parent = new FooParent ();
            break;
        case "bar" :
            parent = new BarParent ();
            break;
    }
    parent.getChild ().print ();
}
----------------------------------------

public static void main (String args []) {
    AbstractParent parent;
    switch (args [0]) {
        case "foo" :
            parent = new FooParent ();
            break;
        default :
            parent = new BarParent ();
            break;
    }
    parent.getChild ().print ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23902280_23902323_1_17
23902280_23902327_1_19
Title: Why is my constructor called twice 
----------------------------------------

void start (int numofplayer_int) {
    JLayeredPane lpane = new JLayeredPane ();
    lpane.setBounds (0, 0, 1200, 750);
    JPanel background = new WallPaper ();
    background.setOpaque (true);
    this.setBounds (0, 0, 1200, 750);
    this.setOpaque (false);
    lpane.add (background, new Integer (0), 0);
    lpane.add (this, new Integer (1), 0);
    Utility.ChangeJLPanel (lpane);
}
----------------------------------------

void start () {
    JLayeredPane lpane = new JLayeredPane ();
    lpane.setBounds (0, 0, 1200, 750);
    JPanel background = new WallPaper ();
    background.setOpaque (true);
    this.setBounds (0, 0, 1200, 750);
    this.setOpaque (false);
    lpane.add (background, new Integer (0), 0);
    lpane.add (this, new Integer (1), 0);
    Utility.ChangeJLPanel (lpane);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23904731_23904845_103_113
23904731_23905408_104_118
Title: How to make a Round Rectangle JTextField? 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            JTextField o = new JTextField ("The quick brown fox jumps over the lazy dog!");
            o.setBorder (new TextBubbleBorder (Color.MAGENTA.darker (), 2, 4, 0));
            JOptionPane.showMessageDialog (null, o);
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    EventQueue.invokeLater (new Runnable () {
        public void run () {
            try {
                DBconnection frame = new DBconnection ();
                frame.setVisible (true);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23906755_23906989_9_24
23906755_23907230_6_22
Title: "equals(Object obj)"" should be overridden along with the ""compareTo(T obj)"" method" 
----------------------------------------

@Override
public boolean equals (Object obj) {
    if (this == obj) return true;

    if (obj == null) return false;

    if (getClass () != obj.getClass ()) return false;

    Snippet other = (Snippet) obj;
    if (joinDate == null) {
        if (other.joinDate != null) return false;

    } else if (! joinDate.equals (other.joinDate)) return false;

    return true;
}
----------------------------------------

@Override
public boolean equals (Object obj) {
    if (! (obj instanceof Employee)) {
        return false;
    }
    if (obj == null) {
        return false;
    }
    Employee other = (Employee) obj;
    if (this.getJoinDate () == null) {
        return other.getJoinDate () == null;
    }
    return this.getJoinDate ().equals (other.getJoinDate ());
}
----------------------------------------
