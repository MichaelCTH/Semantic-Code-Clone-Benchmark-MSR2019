$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35472838_35472958_1_27
35472838_35472968_2_26
Title: Review of beginner java code 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    while (totalTickets > 0) {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > totalTickets) {
            System.out.println ("Not enough tickets available. Please reduce and re-enter the amount");
        } else if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
            totalTickets = (totalTickets - ticketsSold);
            System.out.println ("There are " + totalTickets + " left");
        }

    }
    if (totalTickets == 0) System.out.println ("There are no tickets left. ");

    in.close ();
}
----------------------------------------

static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    int ticketsPerPerson = 4;
    int ticketsLeft = 0;
    do {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
            ticketsLeft = (totalTickets - ticketsSold);
            totalTickets = ticketsLeft;
            System.out.println ("There are " + ticketsLeft + " left");
        }
    } while (ticketsLeft > 0);
    {
        if (ticketsLeft == 0) System.out.println ("There are no tickets left. ");

    }}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35472838_35472958_1_27
35472838_35472973_4_28
Title: Review of beginner java code 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    while (totalTickets > 0) {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > totalTickets) {
            System.out.println ("Not enough tickets available. Please reduce and re-enter the amount");
        } else if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
            totalTickets = (totalTickets - ticketsSold);
            System.out.println ("There are " + totalTickets + " left");
        }

    }
    if (totalTickets == 0) System.out.println ("There are no tickets left. ");

    in.close ();
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    int ticketsPerPerson = 4;
    int ticketsLeft = totalTickets;
    do {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
            ticketsLeft = (totalTickets - ticketsSold);
            System.out.println ("There are " + ticketsLeft + " left");
        }
    } while (ticketsLeft > 0);
    if (ticketsLeft == 0) {
        System.out.println ("There are no tickets left. ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35472838_35472958_1_27
35472838_35473396_4_35
Title: Review of beginner java code 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    while (totalTickets > 0) {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > totalTickets) {
            System.out.println ("Not enough tickets available. Please reduce and re-enter the amount");
        } else if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
            totalTickets = (totalTickets - ticketsSold);
            System.out.println ("There are " + totalTickets + " left");
        }

    }
    if (totalTickets == 0) System.out.println ("There are no tickets left. ");

    in.close ();
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    int ticketsPerPerson = 4;
    int ticketsLeft = totalTickets;
    do {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            if (ticketsLeft >= ticketsSold) {
                System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
                ticketsLeft = (ticketsLeft - ticketsSold);
                System.out.println ("There are " + ticketsLeft + " left");
            } else {
                System.out.println ("You have been allocated only " + ticketsLeft + " tickets.");
                ticketsLeft = 0;
            }
        }
    } while (ticketsLeft > 0);
    if (ticketsLeft == 0) {
        System.out.println ("There are no tickets left. ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35472838_35472968_2_26
35472838_35473064_5_31
Title: Review of beginner java code 
----------------------------------------

static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    int ticketsPerPerson = 4;
    int ticketsLeft = 0;
    do {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
            ticketsLeft = (totalTickets - ticketsSold);
            totalTickets = ticketsLeft;
            System.out.println ("There are " + ticketsLeft + " left");
        }
    } while (ticketsLeft > 0);
    {
        if (ticketsLeft == 0) System.out.println ("There are no tickets left. ");

    }}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    int ticketsPerPerson = 4;
    int ticketsLeft = totalTickets;
    do {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > ticketsPerPerson) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
            ticketsLeft = (ticketsLeft - ticketsSold);
            System.out.println ("There are " + ticketsLeft + " left");
        }
        if (ticketsLeft == 0) {
            System.out.println ("There are no tickets left. ");
        }
    } while (ticketsLeft > 0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35472838_35472968_2_26
35472838_35473396_4_35
Title: Review of beginner java code 
----------------------------------------

static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    int ticketsPerPerson = 4;
    int ticketsLeft = 0;
    do {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
            ticketsLeft = (totalTickets - ticketsSold);
            totalTickets = ticketsLeft;
            System.out.println ("There are " + ticketsLeft + " left");
        }
    } while (ticketsLeft > 0);
    {
        if (ticketsLeft == 0) System.out.println ("There are no tickets left. ");

    }}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int totalTickets = 100;
    int ticketsPerPerson = 4;
    int ticketsLeft = totalTickets;
    do {
        System.out.println ("Please enter the total amount of tickets you wish to purchase: (No more than 4) ");
        int ticketsSold = in.nextInt ();
        if (ticketsSold > 4) {
            System.out.println ("Max of 4 ticket.  Please reenter the amount of tickets you want to purchase: ");
        } else {
            if (ticketsLeft >= ticketsSold) {
                System.out.println ("You have chosen to purchase " + ticketsSold + " tickets.");
                ticketsLeft = (ticketsLeft - ticketsSold);
                System.out.println ("There are " + ticketsLeft + " left");
            } else {
                System.out.println ("You have been allocated only " + ticketsLeft + " tickets.");
                ticketsLeft = 0;
            }
        }
    } while (ticketsLeft > 0);
    if (ticketsLeft == 0) {
        System.out.println ("There are no tickets left. ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35474583_35475065_1_31
35474583_35475132_3_44
Title: How to calculate the average of each row and column in array 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter number of rows");
    int r = sc.nextInt ();
    System.out.println ("Enter number of columns");
    int c = sc.nextInt ();
    System.out.println ("Enter values");
    int [] [] matrix = new int [r] [c];
    for (int i = 0;
    i < r; i ++) {
        float rowSum = 0f;
        for (int j = 0;
        j < c; j ++) {
            matrix [i] [j] = sc.nextInt ();
            rowSum += matrix [i] [j];
        }
        System.out.println ("Average of row " + i + " " + rowSum / c);
    }
    for (int i = 0;
    i < c; i ++) {
        float columnSum = 0f;
        for (int j = 0;
        j < r; j ++) {
            columnSum += matrix [j] [i];
        }
        System.out.println ("Average of column " + i + " " + columnSum / r);
    }
    sc.close ();
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.print ("Enter a number for rows: ");
    int rows = input.nextInt ();
    System.out.print ("Enter a number for columns: ");
    int columns = input.nextInt ();
    int [] [] array = new int [rows] [columns];
    System.out.println ("Enter the numbers in array: ");
    for (int i = 0;
    i < rows; i ++) {
        for (int j = 0;
        j < columns; j ++) {
            array [i] [j] = input.nextInt ();
        }
    }
    int rowSum = 0;
    int colSumArr [] = new int [columns];
    for (int i = 0;
    i < rows; i ++) {
        for (int j = 0;
        j < columns; j ++) {
            rowSum = rowSum + array [i] [j];
            colSumArr [j] = colSumArr [j] + array [i] [j];
            System.out.print (array [i] [j] + " , ");
        }
        System.out.println (" ave=" + (double) rowSum / columns);
        rowSum = 0;
    }
    System.out.printf ("aver=");
    for (int i = 0;
    i < columns; i ++) {
        if (i != columns - 1) System.out.print ((double) colSumArr [i] / rows + ", ");
        else System.out.print ((double) colSumArr [i] / rows);

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35479681_35479915_2_21
35479681_35480273_5_21
Title: Pyramid number sequence using for loop 
----------------------------------------

public static void main (String [] args) {
    int n, i = 0, k;
    int maxN = 5;
    for (n = 1; n <= maxN; n ++) {
        for (k = n; k < maxN; k ++) {
            System.out.print ("\t");
        }
        for (i = n; i > 1; i --) {
            System.out.print (i + "\t");
        }
        for (i = 1; i <= n; i ++) {
            System.out.print (i + "\t");
        }
        System.out.print ("\n");
    }
}
----------------------------------------

public static void main (String [] args) {
    for (int j = MIN;
    j <= MAX; j ++) {
        for (int i = MIN, k = MAX;
        i <= MIN + 2 * (MAX - MIN); i ++) {
            if (k <= j) {
                System.out.print ("" + k + " ");
            } else {
                System.out.print ("  ");
            }
            if (i < MAX) {
                k --;
            } else {
                k ++;
            }
        }
        System.out.println ("");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35482997_35483157_1_12
35482997_35485269_1_16
Title: "I'm trying to iterate through an array list find the first item in the array in which the boolean is false set it to true and return it" 
----------------------------------------

public Taxi bookTaxi () {
    for (int i = 0;
    i < TaxiList.size (); i ++) {
        Taxi taxi = TaxiList.get (i);
        if (! taxi.isBooked ()) {
            taxi.setBooked (true);
            return taxi;
        }
    }
    throw new IllegalStateException ("Unexpected situation");
}
----------------------------------------

public void bookTaxi (String isTaxi) {
    Taxi getTaxi;
    String nowGetTaxi;
    for (int i = 0;
    i < taxiList.size (); i ++) {
        getTaxi = taxiList.get (i);
        nowGetTaxi = getTaxi.getNo ();
        if (isTaxi.equals (nowGetTaxi)) {
            getTaxi.setbooked (true);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35487030_35489893_1_13
35487030_35494503_3_12
Title: Java: fast way to check if digits in int are in ascending order 
----------------------------------------

static boolean isOK (int x) {
    if (x < 10) {
        return true;
    }
    String xs = Integer.toString (x);
    for (int i = 1;
    i < xs.length (); i ++) {
        if (xs.charAt (i) < xs.charAt (i - 1)) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isOK (int x) {
    int prev = 0;
    while (x > 0) {
        int digit = x % 10;
        if (prev != 0 && (digit > prev || digit == 0)) return false;

        x /= 10;
        prev = digit;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_19603170_10_19
354875_24122015_1_16
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

private Node < T > reverse (Node < T > node, Node < T > revHead) {
    if (node.next == null) {
        revHead.next = node;
        return node;
    }
    Node < T > reverse = this.reverse (node.next, revHead);
    reverse.next = node;
    node.next = null;
    return node;
}
----------------------------------------

public static Node reverse (Node root) {
    if (root == null || root.next == null) {
        return root;
    }
    Node curr, prev, next;
    curr = root;
    prev = next = null;
    while (curr != null) {
        next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_19603170_10_19
354875_3079734_1_15
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

private Node < T > reverse (Node < T > node, Node < T > revHead) {
    if (node.next == null) {
        revHead.next = node;
        return node;
    }
    Node < T > reverse = this.reverse (node.next, revHead);
    reverse.next = node;
    node.next = null;
    return node;
}
----------------------------------------

public Node reverse (Node previous, Node current) {
    if (previous == null) return null;

    if (previous.equals (head)) previous.setNext (null);

    if (current == null) {
        head = previous;
        return head;
    } else {
        Node temp = current.getNext ();
        current.setNext (previous);
        reverse (current, temp);
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_19603170_10_19
354875_356071_1_12
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

private Node < T > reverse (Node < T > node, Node < T > revHead) {
    if (node.next == null) {
        revHead.next = node;
        return node;
    }
    Node < T > reverse = this.reverse (node.next, revHead);
    reverse.next = node;
    node.next = null;
    return node;
}
----------------------------------------

public ListNode reverse (ListNode toBeNextNode, ListNode currentNode) {
    ListNode currentHead = currentNode;
    if ((currentNode == null || currentNode.next == null) && toBeNextNode == null) return currentHead;

    if (currentNode.next != null) currentHead = reverse (currentNode, currentNode.next);

    currentNode.next = toBeNextNode;
    return currentHead;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_24122015_1_16
354875_3079734_1_15
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

public static Node reverse (Node root) {
    if (root == null || root.next == null) {
        return root;
    }
    Node curr, prev, next;
    curr = root;
    prev = next = null;
    while (curr != null) {
        next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
----------------------------------------

public Node reverse (Node previous, Node current) {
    if (previous == null) return null;

    if (previous.equals (head)) previous.setNext (null);

    if (current == null) {
        head = previous;
        return head;
    } else {
        Node temp = current.getNext ();
        current.setNext (previous);
        reverse (current, temp);
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_24122015_1_16
354875_354906_3_13
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

public static Node reverse (Node root) {
    if (root == null || root.next == null) {
        return root;
    }
    Node curr, prev, next;
    curr = root;
    prev = next = null;
    while (curr != null) {
        next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
----------------------------------------

Node reverse (Node n, Node p) {
    if (n == null) return null;

    if (n.next == null) {
        n.next = p;
        return n;
    }
    Node r = reverse (n.next, n);
    n.next = p;
    return r;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_24122015_1_16
354875_356071_1_12
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

public static Node reverse (Node root) {
    if (root == null || root.next == null) {
        return root;
    }
    Node curr, prev, next;
    curr = root;
    prev = next = null;
    while (curr != null) {
        next = curr.next;
        curr.next = prev;
        prev = curr;
        curr = next;
    }
    return prev;
}
----------------------------------------

public ListNode reverse (ListNode toBeNextNode, ListNode currentNode) {
    ListNode currentHead = currentNode;
    if ((currentNode == null || currentNode.next == null) && toBeNextNode == null) return currentHead;

    if (currentNode.next != null) currentHead = reverse (currentNode, currentNode.next);

    currentNode.next = toBeNextNode;
    return currentHead;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_26292646_1_17
354875_37694481_1_19
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

static ListNode reverseR (ListNode head) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode first = head;
    ListNode rest = head.next;
    head = reverseR (rest);
    first.next.next = first;
    first.next = null;
    return head;
}
----------------------------------------

public ListNode reverseR (ListNode p) {
    if (p == null || p.next == null) {
        return p;
    }
    ListNode head = reverseR (p.next);
    ListNode q = p.next;
    q.next = p;
    p.next = null;
    return head;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_3079734_1_15
354875_354906_3_13
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

public Node reverse (Node previous, Node current) {
    if (previous == null) return null;

    if (previous.equals (head)) previous.setNext (null);

    if (current == null) {
        head = previous;
        return head;
    } else {
        Node temp = current.getNext ();
        current.setNext (previous);
        reverse (current, temp);
    }
    return null;
}
----------------------------------------

Node reverse (Node n, Node p) {
    if (n == null) return null;

    if (n.next == null) {
        n.next = p;
        return n;
    }
    Node r = reverse (n.next, n);
    n.next = p;
    return r;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_3079734_1_15
354875_356071_1_12
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

public Node reverse (Node previous, Node current) {
    if (previous == null) return null;

    if (previous.equals (head)) previous.setNext (null);

    if (current == null) {
        head = previous;
        return head;
    } else {
        Node temp = current.getNext ();
        current.setNext (previous);
        reverse (current, temp);
    }
    return null;
}
----------------------------------------

public ListNode reverse (ListNode toBeNextNode, ListNode currentNode) {
    ListNode currentHead = currentNode;
    if ((currentNode == null || currentNode.next == null) && toBeNextNode == null) return currentHead;

    if (currentNode.next != null) currentHead = reverse (currentNode, currentNode.next);

    currentNode.next = toBeNextNode;
    return currentHead;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_354906_3_13
354875_356071_1_12
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

Node reverse (Node n, Node p) {
    if (n == null) return null;

    if (n.next == null) {
        n.next = p;
        return n;
    }
    Node r = reverse (n.next, n);
    n.next = p;
    return r;
}
----------------------------------------

public ListNode reverse (ListNode toBeNextNode, ListNode currentNode) {
    ListNode currentHead = currentNode;
    if ((currentNode == null || currentNode.next == null) && toBeNextNode == null) return currentHead;

    if (currentNode.next != null) currentHead = reverse (currentNode, currentNode.next);

    currentNode.next = toBeNextNode;
    return currentHead;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
354875_354937_1_22
354875_39070902_1_13
Title: "Reversing a linked list in Java recursively" 
----------------------------------------

public ListNode Reverse (ListNode list) {
    if (list == null) return null;

    if (list.next == null) return list;

    ListNode secondElem = list.next;
    list.next = null;
    ListNode reverseRest = Reverse (secondElem);
    secondElem.Next = list;
    return reverseRest;
}
----------------------------------------

public void Reverse () {
    Node currentNode, nextNode = null, prevNode = null;
    currentNode = head;
    while (currentNode != null) {
        nextNode = currentNode.next;
        currentNode.next = prevNode;
        prevNode = currentNode;
        currentNode = nextNode;
    }
    head = prevNode;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35499385_35499568_22_31
35499385_35499670_4_14
Title: How can I compare two strings and return the lexicographical ordered result using the compareTo method? 
----------------------------------------

public static void main (String [] args) {
    Name n = new Name ("jennifer");
    n.getName ();
    Name n2 = new Name ("paul");
    n2.getName ();
    System.out.println (n.getName ());
    System.out.println (n2.getName ());
    System.out.println (n2.compareTo (n));
}
----------------------------------------

public static void main (String [] args) {
    String n = new String ("jennifer");
    String n2 = new String ("paul");
    if (n.compareTo (n2) < 0) {
        System.out.println (n + " is before than " + n2);
    } else if (n.compareTo (n2) > 0) {
        System.out.println (n + " is after than " + n2);
    } else if (n.compareTo (n2) == 0) {
        System.out.println (n + " is equals to " + n);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35499764_35500306_1_41
35499764_35523866_5_19
Title: How to get similar elements from two streams and collect the pairs thus formed without losing the order? 
----------------------------------------

public static void main (String [] args) {
    List < String > list1 = new ArrayList < String > ();
    list1.add ("a1_5");
    list1.add ("c1_91");
    list1.add ("b1_43");
    list1.add ("b1_76");
    list1.add ("a1_68");
    list1.add ("a2");
    List < String > list2 = new ArrayList < String > ();
    list2.add ("c2_3");
    list2.add ("b2_19");
    list2.add ("c2_29");
    list2.add ("a2_45");
    list2.add ("b2_53");
    List < String > result = new ArrayList < String > ();
    int aux = 0;
    if (list1.size () >= list2.size ()) {
        aux = list1.size ();
    } else {
        aux = list2.size ();
    }
    for (int i = 0;
    i < aux; i ++) {
        if (i == list1.size ()) {
            result.add (null + "," + list2.get (i));
        } else if (i == list2.size ()) {
            result.add (list1.get (i) + "," + null);
        } else {
            result.add (list1.get (i) + "," + list2.get (i));
        }

    }
    for (String a : result) {
        System.out.println (a);
    }
}
----------------------------------------

public static void main (String [] args) {
    Channel ch1 = new Channel (list_channel1);
    Channel ch2 = new Channel (list_channel2);
    Integer count1 = new Integer (ch1.getQ ().size ());
    Integer count2 = new Integer (ch2.getQ ().size ());
    while ((ch1.getQ ().size () > 0 && count1 > 0) && (ch2.getQ ().size () > 0 && count2 > 0)) {
        ch1.match (ch2, output_string_builder);
        count1 --;
        count2 --;
    }
    System.out.println (output_string_builder.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35507559_44899857_16_27
35507559_44899857_56_82
Title: How to start a thread at creation time of a class and (re)use it to execute a method multiple times 
----------------------------------------

public void run () {
    for (int i = 0;
    i < 10; i ++) {
        Message msg = new Message ("Thread " + this.name + " | i: " + i);
        try {
            System.out.println ("[T] Thread " + this.name + " Adding " + i);
            this.msgBatcher.enqueue (msg);
            System.out.println ("[T] Thread " + this.name + " Added " + i);
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (this) {
            try {
                System.out.println ("[MS] Starting run.");
                while (this.toSend.size () == 0) {
                    System.out.println ("[MS] Waiting for messages." + this.toSend.size ());
                    wait ();
                }
                System.out.println ("[MS] Messages ready to be sent.");
                for (Message msg : this.toSend) {
                    msg.send ();
                }
                this.toSend.clear ();
                System.out.println ("[MS] Messages sent.");
                notifyAll ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35516191_35516500_26_43
35516191_35516500_94_121
Title: What is the correct way to use createBufferStrategy()? 
----------------------------------------

public void run () {
    try {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
        ex.printStackTrace ();
    }
    TestPane testPane = new TestPane ();
    JFrame frame = new JFrame ("Testing");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.add (testPane);
    frame.pack ();
    frame.setLocationRelativeTo (null);
    frame.setVisible (true);
    testPane.startPainting ();
}
----------------------------------------

public void run () {
    System.out.println ("Painting has started");
    int x = (int) (Math.random () * (getWidth () - 40));
    int y = (int) (Math.random () * (getHeight () - 40));
    do {
        xDelta = (int) (Math.random () * 8) - 4;
    } while (xDelta == 0);
    do {
        yDelta = (int) (Math.random () * 8) - 4;
    } while (yDelta == 0);
    clickBounds = new Rectangle (x, y, 40, 40);
    strategy = getBufferStrategy ();
    while (painting.get ()) {
        update ();
        paint ();
        try {
            Thread.sleep (40);
        } catch (InterruptedException ex) {
        }
    }
    System.out.println ("Painting has stopped");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35524394_35524700_21_38
35524394_35526302_9_36
Title: "Draw ring with given thickness position and radius. (Java2D)" 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g.create ();
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    for (Ring ring : rings) {
        gg.setColor (Color.BLACK);
        String str = "Hello!";
        gg.drawString (str, ring.getX () + (ring.getWidth () - gg.getFontMetrics ().stringWidth (str)) / 2, ring.getY () + ring.getHeight () / 2 + gg.getFontMetrics ().getAscent ());
        ring.draw (gg);
    }
    gg.dispose ();
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2d = (Graphics2D) g.create ();
    g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    int size = 100;
    int thickness = 10;
    int innerSize = size - (2 * thickness);
    Shape outer = new Ellipse2D.Double (0, 0, size, size);
    Shape inner = new Ellipse2D.Double (thickness, thickness, innerSize, innerSize);
    Area circle = new Area (outer);
    circle.subtract (new Area (inner));
    int x = (getSize ().width - size) / 2;
    int y = (getSize ().height - size) / 2;
    g2d.translate (x, y);
    g2d.setColor (Color.CYAN);
    g2d.fill (circle);
    g2d.setColor (Color.BLACK);
    g2d.draw (circle);
    g2d.dispose ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35524394_35524700_21_38
35524394_35526341_45_72
Title: "Draw ring with given thickness position and radius. (Java2D)" 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D gg = (Graphics2D) g.create ();
    gg.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    for (Ring ring : rings) {
        gg.setColor (Color.BLACK);
        String str = "Hello!";
        gg.drawString (str, ring.getX () + (ring.getWidth () - gg.getFontMetrics ().stringWidth (str)) / 2, ring.getY () + ring.getHeight () / 2 + gg.getFontMetrics ().getAscent ());
        ring.draw (gg);
    }
    gg.dispose ();
}
----------------------------------------

protected void paintComponent (Graphics gr) {
    super.paintComponent (gr);
    Graphics2D g = (Graphics2D) gr;
    g.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.setColor (Color.RED);
    g.drawString ("Text", 100, 100);
    g.drawString ("Text", 300, 100);
    Shape ring = createRingShape (100, 100, 80, 20);
    g.setColor (Color.CYAN);
    g.fill (ring);
    g.setColor (Color.BLACK);
    g.draw (ring);
    Shape otherRing = createRingShape (300, 100, 80, 20);
    g.setPaint (new GradientPaint (new Point (250, 40), Color.RED, new Point (350, 200), Color.GREEN));
    g.fill (otherRing);
    g.setColor (Color.BLACK);
    g.draw (otherRing);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35524394_35524700_49_56
35524394_35526341_17_27
Title: "Draw ring with given thickness position and radius. (Java2D)" 
----------------------------------------

public static void main (String [] args) {
    EventQueue.invokeLater (new Runnable () {
        @Override
        public void run () {
            new Example ();
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            createAndShowGUI ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35524394_35526302_9_36
35524394_35526341_45_72
Title: "Draw ring with given thickness position and radius. (Java2D)" 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2d = (Graphics2D) g.create ();
    g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    int size = 100;
    int thickness = 10;
    int innerSize = size - (2 * thickness);
    Shape outer = new Ellipse2D.Double (0, 0, size, size);
    Shape inner = new Ellipse2D.Double (thickness, thickness, innerSize, innerSize);
    Area circle = new Area (outer);
    circle.subtract (new Area (inner));
    int x = (getSize ().width - size) / 2;
    int y = (getSize ().height - size) / 2;
    g2d.translate (x, y);
    g2d.setColor (Color.CYAN);
    g2d.fill (circle);
    g2d.setColor (Color.BLACK);
    g2d.draw (circle);
    g2d.dispose ();
}
----------------------------------------

protected void paintComponent (Graphics gr) {
    super.paintComponent (gr);
    Graphics2D g = (Graphics2D) gr;
    g.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.setColor (Color.RED);
    g.drawString ("Text", 100, 100);
    g.drawString ("Text", 300, 100);
    Shape ring = createRingShape (100, 100, 80, 20);
    g.setColor (Color.CYAN);
    g.fill (ring);
    g.setColor (Color.BLACK);
    g.draw (ring);
    Shape otherRing = createRingShape (300, 100, 80, 20);
    g.setPaint (new GradientPaint (new Point (250, 40), Color.RED, new Point (350, 200), Color.GREEN));
    g.fill (otherRing);
    g.setColor (Color.BLACK);
    g.draw (otherRing);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35526676_35526763_10_20
35526676_35526764_3_11
Title: Convert x and y array to Point 
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < 2; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < x.length; i ++) {
        objectPoints [i] = new Point ((int) x [i], (int) y [i]);
    }
    System.out.println (objectPoints [0].x);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35526676_35526763_10_20
35526676_35526780_10_18
Title: Convert x and y array to Point 
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < 2; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------

public static void main (String [] args) {
    Point [] objectPoints = new Point [3];
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    for (int i = 0;
    i < objectPoints.length; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35526676_35526763_10_20
35526676_35526836_11_24
Title: Convert x and y array to Point 
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < 2; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    if (x.length != y.length) {
        throw new Exception ("points x array is not equal to points y array");
    }
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < objectPoints.length; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35526676_35526764_3_11
35526676_35526780_10_18
Title: Convert x and y array to Point 
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < x.length; i ++) {
        objectPoints [i] = new Point ((int) x [i], (int) y [i]);
    }
    System.out.println (objectPoints [0].x);
}
----------------------------------------

public static void main (String [] args) {
    Point [] objectPoints = new Point [3];
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    for (int i = 0;
    i < objectPoints.length; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35526676_35526764_3_11
35526676_35526836_11_24
Title: Convert x and y array to Point 
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < x.length; i ++) {
        objectPoints [i] = new Point ((int) x [i], (int) y [i]);
    }
    System.out.println (objectPoints [0].x);
}
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    if (x.length != y.length) {
        throw new Exception ("points x array is not equal to points y array");
    }
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < objectPoints.length; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35526676_35526780_10_18
35526676_35526836_11_24
Title: Convert x and y array to Point 
----------------------------------------

public static void main (String [] args) {
    Point [] objectPoints = new Point [3];
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    for (int i = 0;
    i < objectPoints.length; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    double x [] = {3, 4, 5};
    double y [] = {4, 5, 6};
    if (x.length != y.length) {
        throw new Exception ("points x array is not equal to points y array");
    }
    Point [] objectPoints = new Point [x.length];
    for (int i = 0;
    i < objectPoints.length; i ++) {
        objectPoints [i] = new Point (x [i], y [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527670_1_22
35527471_35527717_1_16
Title: CodingBat sumNumbers 
----------------------------------------

public int sumNumbers (String str) {
    int y = 0, z = 0, f4, f5 = 0;
    for (f4 = 0; f4 < str.length (); f4 ++) {
        if (Character.isDigit (str.charAt (f4))) {
            for (f5 = f4; f5 < str.length (); f5 ++) {
                if (! Character.isDigit (str.charAt (f5))) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y = y + z;
                    f4 = f5;
                    break;
                }
            }
            if (f4 != f5) {
                z = (Integer.parseInt (str.substring (f4, str.length ())));
                y = y + z;
                break;
            }
        }
    }
    return y;
}
----------------------------------------

public static int sumNumbers (String str) {
    int sum = 0;
    for (int start = 0;
    start < str.length (); start ++) {
        if (Character.isDigit (str.charAt (start))) {
            int end;
            for (end = start; end < str.length (); end ++) {
                if (! Character.isDigit (str.charAt (end))) {
                    break;
                }
            }
            sum += (Integer.parseInt (str.substring (start, end)));
            start = end - 1;
        }
    }
    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527670_1_22
35527471_35527867_1_27
Title: CodingBat sumNumbers 
----------------------------------------

public int sumNumbers (String str) {
    int y = 0, z = 0, f4, f5 = 0;
    for (f4 = 0; f4 < str.length (); f4 ++) {
        if (Character.isDigit (str.charAt (f4))) {
            for (f5 = f4; f5 < str.length (); f5 ++) {
                if (! Character.isDigit (str.charAt (f5))) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y = y + z;
                    f4 = f5;
                    break;
                }
            }
            if (f4 != f5) {
                z = (Integer.parseInt (str.substring (f4, str.length ())));
                y = y + z;
                break;
            }
        }
    }
    return y;
}
----------------------------------------

public int sumNumbers (String str) {
    int y = 0;
    int z = 0;
    for (int f4 = 0;
    f4 < str.length (); f4 ++) {
        Character c = str.charAt (f4);
        if (Character.isDigit (c)) {
            for (int f5 = f4;
            f5 < str.length (); f5 ++) {
                Character c2 = str.charAt (f5);
                if (! Character.isDigit (c2)) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y += z;
                    f4 = f5 - 1;
                    break;
                } else if (Character.isDigit (c2) && f5 == str.length () - 1) {
                    z = Integer.parseInt (str.substring (f4, str.length ()));
                    y += z;
                    f4 = f5;
                    break;
                }

            }
        }
    }
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527670_1_22
35527471_35528235_1_25
Title: CodingBat sumNumbers 
----------------------------------------

public int sumNumbers (String str) {
    int y = 0, z = 0, f4, f5 = 0;
    for (f4 = 0; f4 < str.length (); f4 ++) {
        if (Character.isDigit (str.charAt (f4))) {
            for (f5 = f4; f5 < str.length (); f5 ++) {
                if (! Character.isDigit (str.charAt (f5))) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y = y + z;
                    f4 = f5;
                    break;
                }
            }
            if (f4 != f5) {
                z = (Integer.parseInt (str.substring (f4, str.length ())));
                y = y + z;
                break;
            }
        }
    }
    return y;
}
----------------------------------------

public int sumNumbers (String str) {
    int y = 0;
    int z = 0;
    for (int f4 = 0;
    f4 < str.length (); f4 ++) {
        if (Character.isDigit (str.charAt (f4))) {
            for (int f5 = f4;
            f5 < str.length (); f5 ++) {
                if (! Character.isDigit (str.charAt (f5))) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y = y + z;
                    z = 0;
                    f4 = f5;
                    break;
                }
                if (! Character.isDigit (str.charAt (f5)) || f5 == (str.length () - 1)) {
                    z = (Integer.parseInt (str.substring (f4, f5 + 1)));
                    y = y + z;
                    z = 0;
                    f4 = f5;
                    break;
                }
            }
        }
    }
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527670_1_22
35527471_36112032_1_20
Title: CodingBat sumNumbers 
----------------------------------------

public int sumNumbers (String str) {
    int y = 0, z = 0, f4, f5 = 0;
    for (f4 = 0; f4 < str.length (); f4 ++) {
        if (Character.isDigit (str.charAt (f4))) {
            for (f5 = f4; f5 < str.length (); f5 ++) {
                if (! Character.isDigit (str.charAt (f5))) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y = y + z;
                    f4 = f5;
                    break;
                }
            }
            if (f4 != f5) {
                z = (Integer.parseInt (str.substring (f4, str.length ())));
                y = y + z;
                break;
            }
        }
    }
    return y;
}
----------------------------------------

public int sumNumbers (String str) {
    int result = 0;
    int firstPosOfDig = 0;
    int LastPosOfDig = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isDigit (str.charAt (i))) {
            if (i == 0 || ! Character.isDigit (str.charAt (i - 1))) firstPosOfDig = i;

            if (i == str.length () - 1 || ! Character.isDigit (str.charAt (i + 1))) {
                LastPosOfDig = i;
                result += Integer.parseInt (str.substring (firstPosOfDig, LastPosOfDig + 1));
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527717_1_16
35527471_35527867_1_27
Title: CodingBat sumNumbers 
----------------------------------------

public static int sumNumbers (String str) {
    int sum = 0;
    for (int start = 0;
    start < str.length (); start ++) {
        if (Character.isDigit (str.charAt (start))) {
            int end;
            for (end = start; end < str.length (); end ++) {
                if (! Character.isDigit (str.charAt (end))) {
                    break;
                }
            }
            sum += (Integer.parseInt (str.substring (start, end)));
            start = end - 1;
        }
    }
    return sum;
}
----------------------------------------

public int sumNumbers (String str) {
    int y = 0;
    int z = 0;
    for (int f4 = 0;
    f4 < str.length (); f4 ++) {
        Character c = str.charAt (f4);
        if (Character.isDigit (c)) {
            for (int f5 = f4;
            f5 < str.length (); f5 ++) {
                Character c2 = str.charAt (f5);
                if (! Character.isDigit (c2)) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y += z;
                    f4 = f5 - 1;
                    break;
                } else if (Character.isDigit (c2) && f5 == str.length () - 1) {
                    z = Integer.parseInt (str.substring (f4, str.length ()));
                    y += z;
                    f4 = f5;
                    break;
                }

            }
        }
    }
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527717_1_16
35527471_35528235_1_25
Title: CodingBat sumNumbers 
----------------------------------------

public static int sumNumbers (String str) {
    int sum = 0;
    for (int start = 0;
    start < str.length (); start ++) {
        if (Character.isDigit (str.charAt (start))) {
            int end;
            for (end = start; end < str.length (); end ++) {
                if (! Character.isDigit (str.charAt (end))) {
                    break;
                }
            }
            sum += (Integer.parseInt (str.substring (start, end)));
            start = end - 1;
        }
    }
    return sum;
}
----------------------------------------

public int sumNumbers (String str) {
    int y = 0;
    int z = 0;
    for (int f4 = 0;
    f4 < str.length (); f4 ++) {
        if (Character.isDigit (str.charAt (f4))) {
            for (int f5 = f4;
            f5 < str.length (); f5 ++) {
                if (! Character.isDigit (str.charAt (f5))) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y = y + z;
                    z = 0;
                    f4 = f5;
                    break;
                }
                if (! Character.isDigit (str.charAt (f5)) || f5 == (str.length () - 1)) {
                    z = (Integer.parseInt (str.substring (f4, f5 + 1)));
                    y = y + z;
                    z = 0;
                    f4 = f5;
                    break;
                }
            }
        }
    }
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527717_1_16
35527471_36112032_1_20
Title: CodingBat sumNumbers 
----------------------------------------

public static int sumNumbers (String str) {
    int sum = 0;
    for (int start = 0;
    start < str.length (); start ++) {
        if (Character.isDigit (str.charAt (start))) {
            int end;
            for (end = start; end < str.length (); end ++) {
                if (! Character.isDigit (str.charAt (end))) {
                    break;
                }
            }
            sum += (Integer.parseInt (str.substring (start, end)));
            start = end - 1;
        }
    }
    return sum;
}
----------------------------------------

public int sumNumbers (String str) {
    int result = 0;
    int firstPosOfDig = 0;
    int LastPosOfDig = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isDigit (str.charAt (i))) {
            if (i == 0 || ! Character.isDigit (str.charAt (i - 1))) firstPosOfDig = i;

            if (i == str.length () - 1 || ! Character.isDigit (str.charAt (i + 1))) {
                LastPosOfDig = i;
                result += Integer.parseInt (str.substring (firstPosOfDig, LastPosOfDig + 1));
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527867_1_27
35527471_35528235_1_25
Title: CodingBat sumNumbers 
----------------------------------------

public int sumNumbers (String str) {
    int y = 0;
    int z = 0;
    for (int f4 = 0;
    f4 < str.length (); f4 ++) {
        Character c = str.charAt (f4);
        if (Character.isDigit (c)) {
            for (int f5 = f4;
            f5 < str.length (); f5 ++) {
                Character c2 = str.charAt (f5);
                if (! Character.isDigit (c2)) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y += z;
                    f4 = f5 - 1;
                    break;
                } else if (Character.isDigit (c2) && f5 == str.length () - 1) {
                    z = Integer.parseInt (str.substring (f4, str.length ()));
                    y += z;
                    f4 = f5;
                    break;
                }

            }
        }
    }
    return y;
}
----------------------------------------

public int sumNumbers (String str) {
    int y = 0;
    int z = 0;
    for (int f4 = 0;
    f4 < str.length (); f4 ++) {
        if (Character.isDigit (str.charAt (f4))) {
            for (int f5 = f4;
            f5 < str.length (); f5 ++) {
                if (! Character.isDigit (str.charAt (f5))) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y = y + z;
                    z = 0;
                    f4 = f5;
                    break;
                }
                if (! Character.isDigit (str.charAt (f5)) || f5 == (str.length () - 1)) {
                    z = (Integer.parseInt (str.substring (f4, f5 + 1)));
                    y = y + z;
                    z = 0;
                    f4 = f5;
                    break;
                }
            }
        }
    }
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35527867_1_27
35527471_36112032_1_20
Title: CodingBat sumNumbers 
----------------------------------------

public int sumNumbers (String str) {
    int y = 0;
    int z = 0;
    for (int f4 = 0;
    f4 < str.length (); f4 ++) {
        Character c = str.charAt (f4);
        if (Character.isDigit (c)) {
            for (int f5 = f4;
            f5 < str.length (); f5 ++) {
                Character c2 = str.charAt (f5);
                if (! Character.isDigit (c2)) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y += z;
                    f4 = f5 - 1;
                    break;
                } else if (Character.isDigit (c2) && f5 == str.length () - 1) {
                    z = Integer.parseInt (str.substring (f4, str.length ()));
                    y += z;
                    f4 = f5;
                    break;
                }

            }
        }
    }
    return y;
}
----------------------------------------

public int sumNumbers (String str) {
    int result = 0;
    int firstPosOfDig = 0;
    int LastPosOfDig = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isDigit (str.charAt (i))) {
            if (i == 0 || ! Character.isDigit (str.charAt (i - 1))) firstPosOfDig = i;

            if (i == str.length () - 1 || ! Character.isDigit (str.charAt (i + 1))) {
                LastPosOfDig = i;
                result += Integer.parseInt (str.substring (firstPosOfDig, LastPosOfDig + 1));
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35527471_35528235_1_25
35527471_36112032_1_20
Title: CodingBat sumNumbers 
----------------------------------------

public int sumNumbers (String str) {
    int y = 0;
    int z = 0;
    for (int f4 = 0;
    f4 < str.length (); f4 ++) {
        if (Character.isDigit (str.charAt (f4))) {
            for (int f5 = f4;
            f5 < str.length (); f5 ++) {
                if (! Character.isDigit (str.charAt (f5))) {
                    z = (Integer.parseInt (str.substring (f4, f5)));
                    y = y + z;
                    z = 0;
                    f4 = f5;
                    break;
                }
                if (! Character.isDigit (str.charAt (f5)) || f5 == (str.length () - 1)) {
                    z = (Integer.parseInt (str.substring (f4, f5 + 1)));
                    y = y + z;
                    z = 0;
                    f4 = f5;
                    break;
                }
            }
        }
    }
    return y;
}
----------------------------------------

public int sumNumbers (String str) {
    int result = 0;
    int firstPosOfDig = 0;
    int LastPosOfDig = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isDigit (str.charAt (i))) {
            if (i == 0 || ! Character.isDigit (str.charAt (i - 1))) firstPosOfDig = i;

            if (i == str.length () - 1 || ! Character.isDigit (str.charAt (i + 1))) {
                LastPosOfDig = i;
                result += Integer.parseInt (str.substring (firstPosOfDig, LastPosOfDig + 1));
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35528807_35529056_8_25
35528807_35529073_1_23
Title: How to write a Loop that replaces occurrence of characters from a String? 
----------------------------------------

public static String replaceWith (String parentString, String occurrence, String replaceWith) {
    String newString = "";
    for (int i = 0;
    i <= parentString.length () - occurrence.length (); ++ i) {
        boolean add = false;
        for (int j = 0;
        j < occurrence.length (); ++ j) {
            if (parentString.charAt (i + j) != occurrence.charAt (j)) add = true;

        }
        if (add) {
            newString += parentString.charAt (i);
        } else {
            i += occurrence.length () - 1;
            newString += replaceWith;
        }
    }
    return newString;
}
----------------------------------------

public static String replaceWith (String s, String find, String replace) {
    StringBuilder sb = new StringBuilder ();
    int findLength = find.length ();
    int sourceLength = s.length ();
    for (int i = 0;
    i < sourceLength; i ++) {
        String nextSubstring;
        if (i + findLength >= sourceLength) {
            nextSubstring = s.substring (i);
        } else {
            nextSubstring = s.substring (i, i + findLength);
        }
        if (nextSubstring.equals (find)) {
            sb.append (replace);
            i += findLength - 1;
        } else {
            sb.append (s.charAt (i));
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35530871_35531113_3_31
35530871_35531119_1_31
Title: arrange array with condition in java 
----------------------------------------

public static void main (String [] args) {
    String [] a = {"true", "false", "false", "false", "true", "CC", "true", "false", "false", "CC", "true", "false", "false", "false"};
    int [] b = {0, 1, 2, 3, 5, 99, 0, 5, 4, 99, 0, 89, 6, 5};
    ArrayList ar = new ArrayList ();
    int sum = 0;
    boolean isFalse = false;
    for (int i = 0;
    i < a.length; i ++) {
        isFalse = false;
        if (a [i].equals ("true") || a [i].equals ("CC")) {
            if (sum != 0) ar.add (sum);

            ar.add (b [i]);
            sum = 0;
        } else if (a [i].equals ("false")) {
            sum = sum + b [i];
            isFalse = true;
        }

    }
    if (isFalse) ar.add (sum);

    System.out.println (ar);
}
----------------------------------------

public static void main (String [] args) {
    String [] a = {"true", "false", "false", "false", "true", "CC", "true", "false", "false", "CC", "true", "false", "false", "false"};
    int [] b = {0, 1, 2, 3, 5, 99, 0, 5, 4, 99, 0, 89, 6, 5};
    List < Integer > output = new ArrayList < Integer > ();
    boolean moveNext = true;
    int sum = 0;
    for (i = 0; i < a.length; i ++) {
        if (a [i].equals ("true") || a [i].equals ("CC")) {
            if (! moveNext) {
                output.add (sum);
                sum = 0;
                moveNext = true;
            }
            output.add (b [i]);
        }
        if (a [i].equals ("false")) {
            sum += b [i];
            moveNext = false;
        }
    }
    if (! moveNext) output.add (sum);

    for (i = 0; i < output.size (); i ++) {
        System.out.println (output.get (i));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_41500484_1_11
35531747_42847119_1_18
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    System.out.println (Arrays.toString (zeroArrays));
    for (String zeroArray : zeroArrays) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    String [] zeroTruncated = new String [0];
    System.out.println (Arrays.toString (zeroArrays));
    if (Integer.lowestOneBit (N) != 1) {
        zeroTruncated = Arrays.copyOf (zeroArrays, zeroArrays.length - 1);
    }
    for (String zeroArray : zeroTruncated) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_41500484_1_11
35531747_45500660_1_28
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    System.out.println (Arrays.toString (zeroArrays));
    for (String zeroArray : zeroArrays) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

int solution (int N) {
    if (N == 0) {
        return 0;
    }
    int maximumGap = - 1;
    int currentGap = 0;
    while (N > 0) {
        if (N % 2 == 1) {
            if (currentGap > 0) {
                maximumGap = maximumGap > currentGap ? maximumGap : currentGap;
            } else {
                maximumGap = 0;
            }
            currentGap = 0;
        } else if (maximumGap > - 1) {
            currentGap ++;
        }

        N = N / 2;
    }
    return maximumGap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_41500484_1_11
35531747_46290176_2_18
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    System.out.println (Arrays.toString (zeroArrays));
    for (String zeroArray : zeroArrays) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

public int solution (int N) {
    String binary = Integer.toString (N, 2);
    int largestGap = 0;
    for (int i = 1, gap = 0;
    i < binary.length (); i ++) {
        while (i < binary.length () && binary.charAt (i) == '0') {
            i ++;
            gap ++;
        }
        if (gap > largestGap && i < binary.length ()) {
            largestGap = gap;
        }
        gap = 0;
    }
    return largestGap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_41500484_1_11
35531747_47372900_4_32
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    System.out.println (Arrays.toString (zeroArrays));
    for (String zeroArray : zeroArrays) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

int solution (int N) {
    int b;
    int zeroCounter = 0;
    int prev = 0;
    int c = - 1;
    while (N) {
        b = N % 2;
        N = N / 2;
        if ((b == 1) || (c == 0)) {
            c = 0;
            if (b == 1) {
                if (prev < zeroCounter) {
                    prev = zeroCounter;
                }
                zeroCounter = 0;
            } else {
                zeroCounter ++;
            }
        }
    }
    return prev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_41500484_1_11
35531747_49321523_1_16
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    System.out.println (Arrays.toString (zeroArrays));
    for (String zeroArray : zeroArrays) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

public static int solution (Integer number) {
    String binary = Integer.toBinaryString (number);
    String [] gaps = binary.split ("1");
    String biggestGap = "";
    for (int i = 0;
    i < (binary.endsWith ("1") ? gaps.length : gaps.length - 1); i ++) {
        if (gaps [i].contains ("0") && gaps [i].length () > biggestGap.length ()) biggestGap = gaps [i];

    }
    return biggestGap.length ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_41500484_1_11
35531747_49394608_2_19
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    System.out.println (Arrays.toString (zeroArrays));
    for (String zeroArray : zeroArrays) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

public int solution (int N) {
    int gap = 0;
    int current = - 1;
    while (N > 0) {
        if (N % 2 != 0) {
            if (current > gap) gap = current;

            current = 0;
        } else if (current >= 0) {
            current ++;
        }

        N = N>> 1;
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_41500484_1_11
35531747_50056609_1_27
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    System.out.println (Arrays.toString (zeroArrays));
    for (String zeroArray : zeroArrays) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

int solution (int N) {
    int tempGap = 0, gap = 0;
    String binaryString = Integer.toBinaryString (N);
    int i = 0;
    while (i < binaryString.length ()) {
        if (binaryString.charAt (i) == '1') {
            ++ i;
            tempGap = 0;
            while (i < binaryString.length () && binaryString.charAt (i) != '1') {
                ++ i;
                tempGap ++;
            }
            if (i >= binaryString.length ()) {
                tempGap = 0;
            }
        } else {
            ++ i;
        }
        if (tempGap > gap) {
            gap = tempGap;
        }
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_41500484_1_11
35531747_53008866_1_15
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    System.out.println (Arrays.toString (zeroArrays));
    for (String zeroArray : zeroArrays) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

public int solution (int N) {
    int result = 0;
    while (N > 0) {
        if ((N & 1) == 1) {
            int temp = 0;
            while ((N>>= 1) > 0 && ((N & 1) != 1)) {
                temp ++;
            }
            result = Math.max (result, temp);
        } else {
            N>>= 1;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_42847119_1_18
35531747_45500660_1_28
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    String [] zeroTruncated = new String [0];
    System.out.println (Arrays.toString (zeroArrays));
    if (Integer.lowestOneBit (N) != 1) {
        zeroTruncated = Arrays.copyOf (zeroArrays, zeroArrays.length - 1);
    }
    for (String zeroArray : zeroTruncated) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

int solution (int N) {
    if (N == 0) {
        return 0;
    }
    int maximumGap = - 1;
    int currentGap = 0;
    while (N > 0) {
        if (N % 2 == 1) {
            if (currentGap > 0) {
                maximumGap = maximumGap > currentGap ? maximumGap : currentGap;
            } else {
                maximumGap = 0;
            }
            currentGap = 0;
        } else if (maximumGap > - 1) {
            currentGap ++;
        }

        N = N / 2;
    }
    return maximumGap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_42847119_1_18
35531747_46290176_2_18
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    String [] zeroTruncated = new String [0];
    System.out.println (Arrays.toString (zeroArrays));
    if (Integer.lowestOneBit (N) != 1) {
        zeroTruncated = Arrays.copyOf (zeroArrays, zeroArrays.length - 1);
    }
    for (String zeroArray : zeroTruncated) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

public int solution (int N) {
    String binary = Integer.toString (N, 2);
    int largestGap = 0;
    for (int i = 1, gap = 0;
    i < binary.length (); i ++) {
        while (i < binary.length () && binary.charAt (i) == '0') {
            i ++;
            gap ++;
        }
        if (gap > largestGap && i < binary.length ()) {
            largestGap = gap;
        }
        gap = 0;
    }
    return largestGap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_42847119_1_18
35531747_47372900_4_32
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    String [] zeroTruncated = new String [0];
    System.out.println (Arrays.toString (zeroArrays));
    if (Integer.lowestOneBit (N) != 1) {
        zeroTruncated = Arrays.copyOf (zeroArrays, zeroArrays.length - 1);
    }
    for (String zeroArray : zeroTruncated) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

int solution (int N) {
    int b;
    int zeroCounter = 0;
    int prev = 0;
    int c = - 1;
    while (N) {
        b = N % 2;
        N = N / 2;
        if ((b == 1) || (c == 0)) {
            c = 0;
            if (b == 1) {
                if (prev < zeroCounter) {
                    prev = zeroCounter;
                }
                zeroCounter = 0;
            } else {
                zeroCounter ++;
            }
        }
    }
    return prev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_42847119_1_18
35531747_49321523_1_16
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    String [] zeroTruncated = new String [0];
    System.out.println (Arrays.toString (zeroArrays));
    if (Integer.lowestOneBit (N) != 1) {
        zeroTruncated = Arrays.copyOf (zeroArrays, zeroArrays.length - 1);
    }
    for (String zeroArray : zeroTruncated) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

public static int solution (Integer number) {
    String binary = Integer.toBinaryString (number);
    String [] gaps = binary.split ("1");
    String biggestGap = "";
    for (int i = 0;
    i < (binary.endsWith ("1") ? gaps.length : gaps.length - 1); i ++) {
        if (gaps [i].contains ("0") && gaps [i].length () > biggestGap.length ()) biggestGap = gaps [i];

    }
    return biggestGap.length ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_42847119_1_18
35531747_49394608_2_19
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    String [] zeroTruncated = new String [0];
    System.out.println (Arrays.toString (zeroArrays));
    if (Integer.lowestOneBit (N) != 1) {
        zeroTruncated = Arrays.copyOf (zeroArrays, zeroArrays.length - 1);
    }
    for (String zeroArray : zeroTruncated) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

public int solution (int N) {
    int gap = 0;
    int current = - 1;
    while (N > 0) {
        if (N % 2 != 0) {
            if (current > gap) gap = current;

            current = 0;
        } else if (current >= 0) {
            current ++;
        }

        N = N>> 1;
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_42847119_1_18
35531747_50056609_1_27
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    String [] zeroTruncated = new String [0];
    System.out.println (Arrays.toString (zeroArrays));
    if (Integer.lowestOneBit (N) != 1) {
        zeroTruncated = Arrays.copyOf (zeroArrays, zeroArrays.length - 1);
    }
    for (String zeroArray : zeroTruncated) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

int solution (int N) {
    int tempGap = 0, gap = 0;
    String binaryString = Integer.toBinaryString (N);
    int i = 0;
    while (i < binaryString.length ()) {
        if (binaryString.charAt (i) == '1') {
            ++ i;
            tempGap = 0;
            while (i < binaryString.length () && binaryString.charAt (i) != '1') {
                ++ i;
                tempGap ++;
            }
            if (i >= binaryString.length ()) {
                tempGap = 0;
            }
        } else {
            ++ i;
        }
        if (tempGap > gap) {
            gap = tempGap;
        }
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_42847119_1_18
35531747_53008866_1_15
Title: Solving Binary Gap using Recursion 
----------------------------------------

private static int solution (int N) {
    int gap = 0;
    String binaryStr = Integer.toBinaryString (N);
    String [] zeroArrays = binaryStr.split ("1");
    String [] zeroTruncated = new String [0];
    System.out.println (Arrays.toString (zeroArrays));
    if (Integer.lowestOneBit (N) != 1) {
        zeroTruncated = Arrays.copyOf (zeroArrays, zeroArrays.length - 1);
    }
    for (String zeroArray : zeroTruncated) {
        gap = zeroArray.length () > gap ? zeroArray.length () : gap;
    }
    return gap;
}
----------------------------------------

public int solution (int N) {
    int result = 0;
    while (N > 0) {
        if ((N & 1) == 1) {
            int temp = 0;
            while ((N>>= 1) > 0 && ((N & 1) != 1)) {
                temp ++;
            }
            result = Math.max (result, temp);
        } else {
            N>>= 1;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_43830604_6_23
35531747_46784319_1_23
Title: Solving Binary Gap using Recursion 
----------------------------------------

public int binaryGap (int n, int counter, int max, int index) {
    if (n == 0) return max;

    if (n % 2 == 0 && index == 0) index = 0;
    else if (n % 2 == 0) counter ++;
    else {
        max = Math.max (counter, max);
        index ++;
        counter = 0;
    }

    n = n / 2;
    return binaryGap (n, counter, max, index);
}
----------------------------------------

private static int binaryGap (int N) {
    int gap1 = 0, gap2 = 0, gapCounter = 0;
    for (int i = N;
    i >= 0; i --) {
        if (N < 1) break;

        if (N % 2 == 0) {
            gap1 ++;
        } else {
            gap2 = gap2 > gap1 ? gap2 : gap1;
            gap1 = 0;
            gapCounter ++;
        }
        if (gapCounter == 1) gap2 = 0;

        N = N / 2;
    }
    return gap2;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_45500660_1_28
35531747_46290176_2_18
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    if (N == 0) {
        return 0;
    }
    int maximumGap = - 1;
    int currentGap = 0;
    while (N > 0) {
        if (N % 2 == 1) {
            if (currentGap > 0) {
                maximumGap = maximumGap > currentGap ? maximumGap : currentGap;
            } else {
                maximumGap = 0;
            }
            currentGap = 0;
        } else if (maximumGap > - 1) {
            currentGap ++;
        }

        N = N / 2;
    }
    return maximumGap;
}
----------------------------------------

public int solution (int N) {
    String binary = Integer.toString (N, 2);
    int largestGap = 0;
    for (int i = 1, gap = 0;
    i < binary.length (); i ++) {
        while (i < binary.length () && binary.charAt (i) == '0') {
            i ++;
            gap ++;
        }
        if (gap > largestGap && i < binary.length ()) {
            largestGap = gap;
        }
        gap = 0;
    }
    return largestGap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_45500660_1_28
35531747_47372900_4_32
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    if (N == 0) {
        return 0;
    }
    int maximumGap = - 1;
    int currentGap = 0;
    while (N > 0) {
        if (N % 2 == 1) {
            if (currentGap > 0) {
                maximumGap = maximumGap > currentGap ? maximumGap : currentGap;
            } else {
                maximumGap = 0;
            }
            currentGap = 0;
        } else if (maximumGap > - 1) {
            currentGap ++;
        }

        N = N / 2;
    }
    return maximumGap;
}
----------------------------------------

int solution (int N) {
    int b;
    int zeroCounter = 0;
    int prev = 0;
    int c = - 1;
    while (N) {
        b = N % 2;
        N = N / 2;
        if ((b == 1) || (c == 0)) {
            c = 0;
            if (b == 1) {
                if (prev < zeroCounter) {
                    prev = zeroCounter;
                }
                zeroCounter = 0;
            } else {
                zeroCounter ++;
            }
        }
    }
    return prev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_45500660_1_28
35531747_49321523_1_16
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    if (N == 0) {
        return 0;
    }
    int maximumGap = - 1;
    int currentGap = 0;
    while (N > 0) {
        if (N % 2 == 1) {
            if (currentGap > 0) {
                maximumGap = maximumGap > currentGap ? maximumGap : currentGap;
            } else {
                maximumGap = 0;
            }
            currentGap = 0;
        } else if (maximumGap > - 1) {
            currentGap ++;
        }

        N = N / 2;
    }
    return maximumGap;
}
----------------------------------------

public static int solution (Integer number) {
    String binary = Integer.toBinaryString (number);
    String [] gaps = binary.split ("1");
    String biggestGap = "";
    for (int i = 0;
    i < (binary.endsWith ("1") ? gaps.length : gaps.length - 1); i ++) {
        if (gaps [i].contains ("0") && gaps [i].length () > biggestGap.length ()) biggestGap = gaps [i];

    }
    return biggestGap.length ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_45500660_1_28
35531747_49394608_2_19
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    if (N == 0) {
        return 0;
    }
    int maximumGap = - 1;
    int currentGap = 0;
    while (N > 0) {
        if (N % 2 == 1) {
            if (currentGap > 0) {
                maximumGap = maximumGap > currentGap ? maximumGap : currentGap;
            } else {
                maximumGap = 0;
            }
            currentGap = 0;
        } else if (maximumGap > - 1) {
            currentGap ++;
        }

        N = N / 2;
    }
    return maximumGap;
}
----------------------------------------

public int solution (int N) {
    int gap = 0;
    int current = - 1;
    while (N > 0) {
        if (N % 2 != 0) {
            if (current > gap) gap = current;

            current = 0;
        } else if (current >= 0) {
            current ++;
        }

        N = N>> 1;
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_45500660_1_28
35531747_50056609_1_27
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    if (N == 0) {
        return 0;
    }
    int maximumGap = - 1;
    int currentGap = 0;
    while (N > 0) {
        if (N % 2 == 1) {
            if (currentGap > 0) {
                maximumGap = maximumGap > currentGap ? maximumGap : currentGap;
            } else {
                maximumGap = 0;
            }
            currentGap = 0;
        } else if (maximumGap > - 1) {
            currentGap ++;
        }

        N = N / 2;
    }
    return maximumGap;
}
----------------------------------------

int solution (int N) {
    int tempGap = 0, gap = 0;
    String binaryString = Integer.toBinaryString (N);
    int i = 0;
    while (i < binaryString.length ()) {
        if (binaryString.charAt (i) == '1') {
            ++ i;
            tempGap = 0;
            while (i < binaryString.length () && binaryString.charAt (i) != '1') {
                ++ i;
                tempGap ++;
            }
            if (i >= binaryString.length ()) {
                tempGap = 0;
            }
        } else {
            ++ i;
        }
        if (tempGap > gap) {
            gap = tempGap;
        }
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_45500660_1_28
35531747_53008866_1_15
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    if (N == 0) {
        return 0;
    }
    int maximumGap = - 1;
    int currentGap = 0;
    while (N > 0) {
        if (N % 2 == 1) {
            if (currentGap > 0) {
                maximumGap = maximumGap > currentGap ? maximumGap : currentGap;
            } else {
                maximumGap = 0;
            }
            currentGap = 0;
        } else if (maximumGap > - 1) {
            currentGap ++;
        }

        N = N / 2;
    }
    return maximumGap;
}
----------------------------------------

public int solution (int N) {
    int result = 0;
    while (N > 0) {
        if ((N & 1) == 1) {
            int temp = 0;
            while ((N>>= 1) > 0 && ((N & 1) != 1)) {
                temp ++;
            }
            result = Math.max (result, temp);
        } else {
            N>>= 1;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_46290176_2_18
35531747_47372900_4_32
Title: Solving Binary Gap using Recursion 
----------------------------------------

public int solution (int N) {
    String binary = Integer.toString (N, 2);
    int largestGap = 0;
    for (int i = 1, gap = 0;
    i < binary.length (); i ++) {
        while (i < binary.length () && binary.charAt (i) == '0') {
            i ++;
            gap ++;
        }
        if (gap > largestGap && i < binary.length ()) {
            largestGap = gap;
        }
        gap = 0;
    }
    return largestGap;
}
----------------------------------------

int solution (int N) {
    int b;
    int zeroCounter = 0;
    int prev = 0;
    int c = - 1;
    while (N) {
        b = N % 2;
        N = N / 2;
        if ((b == 1) || (c == 0)) {
            c = 0;
            if (b == 1) {
                if (prev < zeroCounter) {
                    prev = zeroCounter;
                }
                zeroCounter = 0;
            } else {
                zeroCounter ++;
            }
        }
    }
    return prev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_46290176_2_18
35531747_49321523_1_16
Title: Solving Binary Gap using Recursion 
----------------------------------------

public int solution (int N) {
    String binary = Integer.toString (N, 2);
    int largestGap = 0;
    for (int i = 1, gap = 0;
    i < binary.length (); i ++) {
        while (i < binary.length () && binary.charAt (i) == '0') {
            i ++;
            gap ++;
        }
        if (gap > largestGap && i < binary.length ()) {
            largestGap = gap;
        }
        gap = 0;
    }
    return largestGap;
}
----------------------------------------

public static int solution (Integer number) {
    String binary = Integer.toBinaryString (number);
    String [] gaps = binary.split ("1");
    String biggestGap = "";
    for (int i = 0;
    i < (binary.endsWith ("1") ? gaps.length : gaps.length - 1); i ++) {
        if (gaps [i].contains ("0") && gaps [i].length () > biggestGap.length ()) biggestGap = gaps [i];

    }
    return biggestGap.length ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_46290176_2_18
35531747_49394608_2_19
Title: Solving Binary Gap using Recursion 
----------------------------------------

public int solution (int N) {
    String binary = Integer.toString (N, 2);
    int largestGap = 0;
    for (int i = 1, gap = 0;
    i < binary.length (); i ++) {
        while (i < binary.length () && binary.charAt (i) == '0') {
            i ++;
            gap ++;
        }
        if (gap > largestGap && i < binary.length ()) {
            largestGap = gap;
        }
        gap = 0;
    }
    return largestGap;
}
----------------------------------------

public int solution (int N) {
    int gap = 0;
    int current = - 1;
    while (N > 0) {
        if (N % 2 != 0) {
            if (current > gap) gap = current;

            current = 0;
        } else if (current >= 0) {
            current ++;
        }

        N = N>> 1;
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_46290176_2_18
35531747_50056609_1_27
Title: Solving Binary Gap using Recursion 
----------------------------------------

public int solution (int N) {
    String binary = Integer.toString (N, 2);
    int largestGap = 0;
    for (int i = 1, gap = 0;
    i < binary.length (); i ++) {
        while (i < binary.length () && binary.charAt (i) == '0') {
            i ++;
            gap ++;
        }
        if (gap > largestGap && i < binary.length ()) {
            largestGap = gap;
        }
        gap = 0;
    }
    return largestGap;
}
----------------------------------------

int solution (int N) {
    int tempGap = 0, gap = 0;
    String binaryString = Integer.toBinaryString (N);
    int i = 0;
    while (i < binaryString.length ()) {
        if (binaryString.charAt (i) == '1') {
            ++ i;
            tempGap = 0;
            while (i < binaryString.length () && binaryString.charAt (i) != '1') {
                ++ i;
                tempGap ++;
            }
            if (i >= binaryString.length ()) {
                tempGap = 0;
            }
        } else {
            ++ i;
        }
        if (tempGap > gap) {
            gap = tempGap;
        }
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_46290176_2_18
35531747_53008866_1_15
Title: Solving Binary Gap using Recursion 
----------------------------------------

public int solution (int N) {
    String binary = Integer.toString (N, 2);
    int largestGap = 0;
    for (int i = 1, gap = 0;
    i < binary.length (); i ++) {
        while (i < binary.length () && binary.charAt (i) == '0') {
            i ++;
            gap ++;
        }
        if (gap > largestGap && i < binary.length ()) {
            largestGap = gap;
        }
        gap = 0;
    }
    return largestGap;
}
----------------------------------------

public int solution (int N) {
    int result = 0;
    while (N > 0) {
        if ((N & 1) == 1) {
            int temp = 0;
            while ((N>>= 1) > 0 && ((N & 1) != 1)) {
                temp ++;
            }
            result = Math.max (result, temp);
        } else {
            N>>= 1;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_47372900_4_32
35531747_49321523_1_16
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    int b;
    int zeroCounter = 0;
    int prev = 0;
    int c = - 1;
    while (N) {
        b = N % 2;
        N = N / 2;
        if ((b == 1) || (c == 0)) {
            c = 0;
            if (b == 1) {
                if (prev < zeroCounter) {
                    prev = zeroCounter;
                }
                zeroCounter = 0;
            } else {
                zeroCounter ++;
            }
        }
    }
    return prev;
}
----------------------------------------

public static int solution (Integer number) {
    String binary = Integer.toBinaryString (number);
    String [] gaps = binary.split ("1");
    String biggestGap = "";
    for (int i = 0;
    i < (binary.endsWith ("1") ? gaps.length : gaps.length - 1); i ++) {
        if (gaps [i].contains ("0") && gaps [i].length () > biggestGap.length ()) biggestGap = gaps [i];

    }
    return biggestGap.length ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_47372900_4_32
35531747_49394608_2_19
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    int b;
    int zeroCounter = 0;
    int prev = 0;
    int c = - 1;
    while (N) {
        b = N % 2;
        N = N / 2;
        if ((b == 1) || (c == 0)) {
            c = 0;
            if (b == 1) {
                if (prev < zeroCounter) {
                    prev = zeroCounter;
                }
                zeroCounter = 0;
            } else {
                zeroCounter ++;
            }
        }
    }
    return prev;
}
----------------------------------------

public int solution (int N) {
    int gap = 0;
    int current = - 1;
    while (N > 0) {
        if (N % 2 != 0) {
            if (current > gap) gap = current;

            current = 0;
        } else if (current >= 0) {
            current ++;
        }

        N = N>> 1;
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_47372900_4_32
35531747_50056609_1_27
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    int b;
    int zeroCounter = 0;
    int prev = 0;
    int c = - 1;
    while (N) {
        b = N % 2;
        N = N / 2;
        if ((b == 1) || (c == 0)) {
            c = 0;
            if (b == 1) {
                if (prev < zeroCounter) {
                    prev = zeroCounter;
                }
                zeroCounter = 0;
            } else {
                zeroCounter ++;
            }
        }
    }
    return prev;
}
----------------------------------------

int solution (int N) {
    int tempGap = 0, gap = 0;
    String binaryString = Integer.toBinaryString (N);
    int i = 0;
    while (i < binaryString.length ()) {
        if (binaryString.charAt (i) == '1') {
            ++ i;
            tempGap = 0;
            while (i < binaryString.length () && binaryString.charAt (i) != '1') {
                ++ i;
                tempGap ++;
            }
            if (i >= binaryString.length ()) {
                tempGap = 0;
            }
        } else {
            ++ i;
        }
        if (tempGap > gap) {
            gap = tempGap;
        }
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_47372900_4_32
35531747_53008866_1_15
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    int b;
    int zeroCounter = 0;
    int prev = 0;
    int c = - 1;
    while (N) {
        b = N % 2;
        N = N / 2;
        if ((b == 1) || (c == 0)) {
            c = 0;
            if (b == 1) {
                if (prev < zeroCounter) {
                    prev = zeroCounter;
                }
                zeroCounter = 0;
            } else {
                zeroCounter ++;
            }
        }
    }
    return prev;
}
----------------------------------------

public int solution (int N) {
    int result = 0;
    while (N > 0) {
        if ((N & 1) == 1) {
            int temp = 0;
            while ((N>>= 1) > 0 && ((N & 1) != 1)) {
                temp ++;
            }
            result = Math.max (result, temp);
        } else {
            N>>= 1;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_49321523_1_16
35531747_49394608_2_19
Title: Solving Binary Gap using Recursion 
----------------------------------------

public static int solution (Integer number) {
    String binary = Integer.toBinaryString (number);
    String [] gaps = binary.split ("1");
    String biggestGap = "";
    for (int i = 0;
    i < (binary.endsWith ("1") ? gaps.length : gaps.length - 1); i ++) {
        if (gaps [i].contains ("0") && gaps [i].length () > biggestGap.length ()) biggestGap = gaps [i];

    }
    return biggestGap.length ();
}
----------------------------------------

public int solution (int N) {
    int gap = 0;
    int current = - 1;
    while (N > 0) {
        if (N % 2 != 0) {
            if (current > gap) gap = current;

            current = 0;
        } else if (current >= 0) {
            current ++;
        }

        N = N>> 1;
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_49321523_1_16
35531747_50056609_1_27
Title: Solving Binary Gap using Recursion 
----------------------------------------

public static int solution (Integer number) {
    String binary = Integer.toBinaryString (number);
    String [] gaps = binary.split ("1");
    String biggestGap = "";
    for (int i = 0;
    i < (binary.endsWith ("1") ? gaps.length : gaps.length - 1); i ++) {
        if (gaps [i].contains ("0") && gaps [i].length () > biggestGap.length ()) biggestGap = gaps [i];

    }
    return biggestGap.length ();
}
----------------------------------------

int solution (int N) {
    int tempGap = 0, gap = 0;
    String binaryString = Integer.toBinaryString (N);
    int i = 0;
    while (i < binaryString.length ()) {
        if (binaryString.charAt (i) == '1') {
            ++ i;
            tempGap = 0;
            while (i < binaryString.length () && binaryString.charAt (i) != '1') {
                ++ i;
                tempGap ++;
            }
            if (i >= binaryString.length ()) {
                tempGap = 0;
            }
        } else {
            ++ i;
        }
        if (tempGap > gap) {
            gap = tempGap;
        }
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_49321523_1_16
35531747_53008866_1_15
Title: Solving Binary Gap using Recursion 
----------------------------------------

public static int solution (Integer number) {
    String binary = Integer.toBinaryString (number);
    String [] gaps = binary.split ("1");
    String biggestGap = "";
    for (int i = 0;
    i < (binary.endsWith ("1") ? gaps.length : gaps.length - 1); i ++) {
        if (gaps [i].contains ("0") && gaps [i].length () > biggestGap.length ()) biggestGap = gaps [i];

    }
    return biggestGap.length ();
}
----------------------------------------

public int solution (int N) {
    int result = 0;
    while (N > 0) {
        if ((N & 1) == 1) {
            int temp = 0;
            while ((N>>= 1) > 0 && ((N & 1) != 1)) {
                temp ++;
            }
            result = Math.max (result, temp);
        } else {
            N>>= 1;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_49394608_2_19
35531747_50056609_1_27
Title: Solving Binary Gap using Recursion 
----------------------------------------

public int solution (int N) {
    int gap = 0;
    int current = - 1;
    while (N > 0) {
        if (N % 2 != 0) {
            if (current > gap) gap = current;

            current = 0;
        } else if (current >= 0) {
            current ++;
        }

        N = N>> 1;
    }
    return gap;
}
----------------------------------------

int solution (int N) {
    int tempGap = 0, gap = 0;
    String binaryString = Integer.toBinaryString (N);
    int i = 0;
    while (i < binaryString.length ()) {
        if (binaryString.charAt (i) == '1') {
            ++ i;
            tempGap = 0;
            while (i < binaryString.length () && binaryString.charAt (i) != '1') {
                ++ i;
                tempGap ++;
            }
            if (i >= binaryString.length ()) {
                tempGap = 0;
            }
        } else {
            ++ i;
        }
        if (tempGap > gap) {
            gap = tempGap;
        }
    }
    return gap;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_49394608_2_19
35531747_53008866_1_15
Title: Solving Binary Gap using Recursion 
----------------------------------------

public int solution (int N) {
    int gap = 0;
    int current = - 1;
    while (N > 0) {
        if (N % 2 != 0) {
            if (current > gap) gap = current;

            current = 0;
        } else if (current >= 0) {
            current ++;
        }

        N = N>> 1;
    }
    return gap;
}
----------------------------------------

public int solution (int N) {
    int result = 0;
    while (N > 0) {
        if ((N & 1) == 1) {
            int temp = 0;
            while ((N>>= 1) > 0 && ((N & 1) != 1)) {
                temp ++;
            }
            result = Math.max (result, temp);
        } else {
            N>>= 1;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35531747_50056609_1_27
35531747_53008866_1_15
Title: Solving Binary Gap using Recursion 
----------------------------------------

int solution (int N) {
    int tempGap = 0, gap = 0;
    String binaryString = Integer.toBinaryString (N);
    int i = 0;
    while (i < binaryString.length ()) {
        if (binaryString.charAt (i) == '1') {
            ++ i;
            tempGap = 0;
            while (i < binaryString.length () && binaryString.charAt (i) != '1') {
                ++ i;
                tempGap ++;
            }
            if (i >= binaryString.length ()) {
                tempGap = 0;
            }
        } else {
            ++ i;
        }
        if (tempGap > gap) {
            gap = tempGap;
        }
    }
    return gap;
}
----------------------------------------

public int solution (int N) {
    int result = 0;
    while (N > 0) {
        if ((N & 1) == 1) {
            int temp = 0;
            while ((N>>= 1) > 0 && ((N & 1) != 1)) {
                temp ++;
            }
            result = Math.max (result, temp);
        } else {
            N>>= 1;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35542487_35542927_2_16
35542487_35543083_3_39
Title: How to combine Switch statements? 
----------------------------------------

public static void main (String [] args) {
    if (args [0].equals ("-n")) {
        if (args [1].equals ("-e")) {
        }
    } else if (args [0].equals ("-e")) {
        if (args [1].equals ("-n")) {
        }
    } else {
    }

}
----------------------------------------

public static void main (String [] args) {
    boolean isTrailingActive = false;
    boolean isEscapingActive = false;
    String inputStr;
    int index = 0;
    if (args.length == 0 || args.length > 3) {
        return;
    }
    while (index < args.length - 1) {
        if (args [index].equals ("-n")) {
            isTrailingActive = true;
            index ++;
        }
        if (args [index].equals ("-e")) {
            isEscapingActive = true;
            index ++;
        }
    }
    inputStr = args [index];
    if (isEscapingActive) {
        inputStr = inputStr.replace ("\\t", "\t").replace ("\\n", "\n");
    }
    if (isTrailingActive) {
        System.out.print (inputStr);
    } else {
        System.out.println (inputStr);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35542487_35542927_2_16
35542487_35543631_3_23
Title: How to combine Switch statements? 
----------------------------------------

public static void main (String [] args) {
    if (args [0].equals ("-n")) {
        if (args [1].equals ("-e")) {
        }
    } else if (args [0].equals ("-e")) {
        if (args [1].equals ("-n")) {
        }
    } else {
    }

}
----------------------------------------

public static void main (String [] args) {
    boolean hasE = false;
    boolean hasN = false;
    String message = args [args.length - 1];
    for (int i = args.length - 2;
    i >= 0; i --) {
        switch (args [i]) {
            case "-n" :
                hasN = true;
                break;
            case "-e" :
                hasE = true;
                break;
        }
    }
    if (hasE) message = message.replace ("\\n", "\n").replace ("\\t", "\t");

    if (hasN) System.out.print (message);
    else System.out.println (message);

    System.out.println ("Test");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35542487_35543083_3_39
35542487_35543631_3_23
Title: How to combine Switch statements? 
----------------------------------------

public static void main (String [] args) {
    boolean isTrailingActive = false;
    boolean isEscapingActive = false;
    String inputStr;
    int index = 0;
    if (args.length == 0 || args.length > 3) {
        return;
    }
    while (index < args.length - 1) {
        if (args [index].equals ("-n")) {
            isTrailingActive = true;
            index ++;
        }
        if (args [index].equals ("-e")) {
            isEscapingActive = true;
            index ++;
        }
    }
    inputStr = args [index];
    if (isEscapingActive) {
        inputStr = inputStr.replace ("\\t", "\t").replace ("\\n", "\n");
    }
    if (isTrailingActive) {
        System.out.print (inputStr);
    } else {
        System.out.println (inputStr);
    }
}
----------------------------------------

public static void main (String [] args) {
    boolean hasE = false;
    boolean hasN = false;
    String message = args [args.length - 1];
    for (int i = args.length - 2;
    i >= 0; i --) {
        switch (args [i]) {
            case "-n" :
                hasN = true;
                break;
            case "-e" :
                hasE = true;
                break;
        }
    }
    if (hasE) message = message.replace ("\\n", "\n").replace ("\\t", "\t");

    if (hasN) System.out.print (message);
    else System.out.println (message);

    System.out.println ("Test");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35548009_35548218_1_35
35548009_35548710_7_40
Title: "Count and Display UpperCase LowerCase and Numbers" 
----------------------------------------

public static void main (String [] args) {
    String input = (String) JOptionPane.showInputDialog (null, "Input a sentence.", "Dialogue", JOptionPane.PLAIN_MESSAGE, null, null, null);
    System.out.println ("Input word was: " + input);
    int length = input.length ();
    char [] charAnalysis = input.toCharArray ();
    int whitespace = 0;
    int lowercase = 0;
    int uppercase = 0;
    int numberCount = 0;
    for (char element : charAnalysis) {
        if (Character.isWhitespace (element)) {
            whitespace ++;
        } else if (Character.isUpperCase (element)) {
            uppercase ++;
        } else if (Character.isLowerCase (element)) {
            lowercase ++;
        } else if (Character.isDigit (element)) {
            numberCount ++;
        }

    }
    System.out.println ("Length: " + length);
    System.out.println ("Uppercase letters: " + uppercase);
    System.out.println ("Lowercase letters: " + lowercase);
    System.out.println ("Digit count: " + numberCount);
    System.out.println ("Whitespaces: " + whitespace);
}
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Input a word.");
    Scanner scan = new Scanner (System.in);
    String input = scan.nextLine ();
    System.out.println ("Entered Word: " + input);
    int length = input.length ();
    char [] chars = input.toCharArray ();
    int whitespaceLength = 0;
    String upercase = "";
    String lowercase = "";
    String numbers = "";
    for (char element : chars) {
        if (Character.isWhitespace (element)) {
            whitespaceLength ++;
        } else if (Character.isUpperCase (element)) {
            upercase += element;
        } else if (Character.isLowerCase (element)) {
            lowercase += element;
        } else if (Character.isDigit (element)) {
            numbers += element;
        }

    }
    System.out.println ("Uppercase: " + upercase);
    System.out.println ("total number of uppercase letters: " + upercase.length ());
    System.out.println ("Lowercase: " + lowercase);
    System.out.println ("total number of lowercase letters: " + lowercase.length ());
    System.out.println ("Numbers: " + numbers);
    System.out.println ("total number of Numbers: " + numbers.length ());
    System.out.println ("Number of Whitespaces: " + whitespaceLength);
    System.out.println ("Total number of characters found: " + input.length ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35549032_35555123_14_40
35549032_35572973_326_335
Title: "Keybinding not working for Some Keys like InsertDelete" 
----------------------------------------

public static void main (String args []) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels ()) {
            if ("Windows".equals (info.getName ())) {
                javax.swing.UIManager.setLookAndFeel (info.getClassName ());
                break;
            }
        }
    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger (NewClass.class.getName ()).log (java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater (new Runnable () {
        @Override
        public void run () {
            JFrame frame = new JFrame ();
            frame.setLayout (new BorderLayout ());
            frame.add (new JScrollPane (createTable ()), BorderLayout.CENTER);
            frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
            frame.setSize (400, 500);
            frame.setLocationRelativeTo (null);
            frame.setVisible (true);
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            createAndShowGUI ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35549032_35555123_42_60
35549032_35572875_53_88
Title: "Keybinding not working for Some Keys like InsertDelete" 
----------------------------------------

public static JTable createTable () {
    DefaultTableModel tmodel = new DefaultTableModel (3, 5);
    JTable table = new JTable (tmodel);
    table.getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put (KeyStroke.getKeyStroke (KeyEvent.VK_DELETE, KeyEvent.CTRL_MASK), "Insert");
    table.getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put (KeyStroke.getKeyStroke (KeyEvent.VK_INSERT, KeyEvent.CTRL_MASK), "Insert");
    table.getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put (KeyStroke.getKeyStroke (KeyEvent.VK_SPACE, KeyEvent.CTRL_MASK), "Insert");
    table.getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put (KeyStroke.getKeyStroke (KeyEvent.VK_I, KeyEvent.CTRL_MASK), "Insert");
    table.getActionMap ().put ("Insert", new AbstractAction () {
        @Override
        public void actionPerformed (ActionEvent e) {
            System.out.println ("Action from JTable");
        }}

    );
    return table;
}
----------------------------------------

public JTable createTable () {
    table.setPreferredScrollableViewportSize (table.getPreferredSize ());
    table.getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put (KeyStroke.getKeyStroke (KeyEvent.VK_DELETE, KeyEvent.CTRL_MASK), "Delete");
    table.getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put (KeyStroke.getKeyStroke (KeyEvent.VK_INSERT, KeyEvent.CTRL_MASK), "Insert");
    table.getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put (KeyStroke.getKeyStroke (KeyEvent.VK_SPACE, KeyEvent.CTRL_MASK), "Space");
    table.getInputMap (JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put (KeyStroke.getKeyStroke (KeyEvent.VK_I, KeyEvent.CTRL_MASK), "I");
    table.getActionMap ().put ("Delete", new AbstractAction () {
        @Override
        public void actionPerformed (ActionEvent e) {
            System.out.println ("Delete Action from JTable");
        }}

    );
    table.getActionMap ().put ("Insert", new AbstractAction () {
        @Override
        public void actionPerformed (ActionEvent e) {
            System.out.println ("Insert Action from JTable");
        }}

    );
    table.getActionMap ().put ("Space", new AbstractAction () {
        @Override
        public void actionPerformed (ActionEvent e) {
            System.out.println ("Space Action from JTable");
        }}

    );
    table.getActionMap ().put ("I", new AbstractAction () {
        @Override
        public void actionPerformed (ActionEvent e) {
            System.out.println ("I Action from JTable");
        }}

    );
    return table;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35549032_35572875_90_112
35549032_35572973_326_335
Title: "Keybinding not working for Some Keys like InsertDelete" 
----------------------------------------

public static void main (String args []) {
    try {
        for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels ()) {
            if ("Windows".equals (info.getName ())) {
                javax.swing.UIManager.setLookAndFeel (info.getClassName ());
                break;
            }
        }
    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
        java.util.logging.Logger.getLogger (NewClass.class.getName ()).log (java.util.logging.Level.SEVERE, null, ex);
    }
    java.awt.EventQueue.invokeLater (new Runnable () {
        @Override
        public void run () {
            new NewClass ();
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            createAndShowGUI ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35554796_37048987_12_27
35554796_39569076_11_22
Title: Rotate Marker and Move Animation on Map like Uber Android 
----------------------------------------

public void run () {
    isMarkerRotating = true;
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    float rot = t * toRotation + (1 - t) * startRotation;
    marker.setRotation (- rot > 180 ? rot / 2 : rot);
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    } else {
        isMarkerRotating = false;
    }
}
----------------------------------------

public void run () {
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    float rot = t * toRotation + (1 - t) * startRotation;
    marker.setRotation (- rot > 180 ? rot / 2 : rot);
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35554796_37048987_12_27
35554796_39569076_39_59
Title: Rotate Marker and Move Animation on Map like Uber Android 
----------------------------------------

public void run () {
    isMarkerRotating = true;
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    float rot = t * toRotation + (1 - t) * startRotation;
    marker.setRotation (- rot > 180 ? rot / 2 : rot);
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    } else {
        isMarkerRotating = false;
    }
}
----------------------------------------

public void run () {
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    double lng = t * toPosition.longitude + (1 - t) * startLatLng.longitude;
    double lat = t * toPosition.latitude + (1 - t) * startLatLng.latitude;
    m.setPosition (new LatLng (lat, lng));
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    } else {
        if (hideMarke) {
            m.setVisible (false);
        } else {
            m.setVisible (true);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35554796_37048987_12_27
35554796_44367734_116_148
Title: Rotate Marker and Move Animation on Map like Uber Android 
----------------------------------------

public void run () {
    isMarkerRotating = true;
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    float rot = t * toRotation + (1 - t) * startRotation;
    marker.setRotation (- rot > 180 ? rot / 2 : rot);
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    } else {
        isMarkerRotating = false;
    }
}
----------------------------------------

public void run () {
    LoopjHttpClient.post (getString (R.string.default_upload_website), params, new AsyncHttpResponseHandler () {
        @Override
        public void onSuccess (int statusCode, Header [] headers, byte [] responseBody) {
            try {
                JSONObject jsonObject = new JSONObject (new String (responseBody));
                String status = jsonObject.getString ("status");
                String text = jsonObject.getString ("text");
                JSONArray jsonArray = jsonObject.getJSONArray ("result");
                String source = jsonArray.getJSONObject (0).getString ("source");
                String [] latLong = source.split (",");
                Location location = new Location (LocationManager.GPS_PROVIDER);
                location.setLatitude (Double.parseDouble (latLong [0]));
                location.setLongitude (Double.parseDouble (latLong [1]));
                animateMarkerNew (location, mMarker);
            } catch (JSONException e) {
                e.printStackTrace ();
            }
        }@Override
        public void onFailure (int statusCode, Header [] headers, byte [] responseBody, Throwable error) {
            Log.d ("onFailure", "onFailure");
        }}

    );
    handler.postDelayed (this, 3000);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35554796_37048987_1_30
35554796_39569076_1_24
Title: Rotate Marker and Move Animation on Map like Uber Android 
----------------------------------------

private void rotateMarker (final Marker marker, final float toRotation) {
    if (! isMarkerRotating) {
        final Handler handler = new Handler ();
        final long start = SystemClock.uptimeMillis ();
        final float startRotation = marker.getRotation ();
        final long duration = 1000;
        final Interpolator interpolator = new LinearInterpolator ();
        handler.post (new Runnable () {
            @Override
            public void run () {
                isMarkerRotating = true;
                long elapsed = SystemClock.uptimeMillis () - start;
                float t = interpolator.getInterpolation ((float) elapsed / duration);
                float rot = t * toRotation + (1 - t) * startRotation;
                marker.setRotation (- rot > 180 ? rot / 2 : rot);
                if (t < 1.0) {
                    handler.postDelayed (this, 16);
                } else {
                    isMarkerRotating = false;
                }
            }}

        );
    }
}
----------------------------------------

public void rotateMarker (final Marker marker, final float toRotation, final float st) {
    final Handler handler = new Handler ();
    final long start = SystemClock.uptimeMillis ();
    final float startRotation = st;
    final long duration = 1555;
    final Interpolator interpolator = new LinearInterpolator ();
    handler.post (new Runnable () {
        @Override
        public void run () {
            long elapsed = SystemClock.uptimeMillis () - start;
            float t = interpolator.getInterpolation ((float) elapsed / duration);
            float rot = t * toRotation + (1 - t) * startRotation;
            marker.setRotation (- rot > 180 ? rot / 2 : rot);
            if (t < 1.0) {
                handler.postDelayed (this, 16);
            }
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35554796_39569076_11_22
35554796_39569076_39_59
Title: Rotate Marker and Move Animation on Map like Uber Android 
----------------------------------------

public void run () {
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    float rot = t * toRotation + (1 - t) * startRotation;
    marker.setRotation (- rot > 180 ? rot / 2 : rot);
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    }
}
----------------------------------------

public void run () {
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    double lng = t * toPosition.longitude + (1 - t) * startLatLng.longitude;
    double lat = t * toPosition.latitude + (1 - t) * startLatLng.latitude;
    m.setPosition (new LatLng (lat, lng));
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    } else {
        if (hideMarke) {
            m.setVisible (false);
        } else {
            m.setVisible (true);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35554796_39569076_11_22
35554796_44367734_116_148
Title: Rotate Marker and Move Animation on Map like Uber Android 
----------------------------------------

public void run () {
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    float rot = t * toRotation + (1 - t) * startRotation;
    marker.setRotation (- rot > 180 ? rot / 2 : rot);
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    }
}
----------------------------------------

public void run () {
    LoopjHttpClient.post (getString (R.string.default_upload_website), params, new AsyncHttpResponseHandler () {
        @Override
        public void onSuccess (int statusCode, Header [] headers, byte [] responseBody) {
            try {
                JSONObject jsonObject = new JSONObject (new String (responseBody));
                String status = jsonObject.getString ("status");
                String text = jsonObject.getString ("text");
                JSONArray jsonArray = jsonObject.getJSONArray ("result");
                String source = jsonArray.getJSONObject (0).getString ("source");
                String [] latLong = source.split (",");
                Location location = new Location (LocationManager.GPS_PROVIDER);
                location.setLatitude (Double.parseDouble (latLong [0]));
                location.setLongitude (Double.parseDouble (latLong [1]));
                animateMarkerNew (location, mMarker);
            } catch (JSONException e) {
                e.printStackTrace ();
            }
        }@Override
        public void onFailure (int statusCode, Header [] headers, byte [] responseBody, Throwable error) {
            Log.d ("onFailure", "onFailure");
        }}

    );
    handler.postDelayed (this, 3000);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35554796_39569076_39_59
35554796_44367734_116_148
Title: Rotate Marker and Move Animation on Map like Uber Android 
----------------------------------------

public void run () {
    long elapsed = SystemClock.uptimeMillis () - start;
    float t = interpolator.getInterpolation ((float) elapsed / duration);
    double lng = t * toPosition.longitude + (1 - t) * startLatLng.longitude;
    double lat = t * toPosition.latitude + (1 - t) * startLatLng.latitude;
    m.setPosition (new LatLng (lat, lng));
    if (t < 1.0) {
        handler.postDelayed (this, 16);
    } else {
        if (hideMarke) {
            m.setVisible (false);
        } else {
            m.setVisible (true);
        }
    }
}
----------------------------------------

public void run () {
    LoopjHttpClient.post (getString (R.string.default_upload_website), params, new AsyncHttpResponseHandler () {
        @Override
        public void onSuccess (int statusCode, Header [] headers, byte [] responseBody) {
            try {
                JSONObject jsonObject = new JSONObject (new String (responseBody));
                String status = jsonObject.getString ("status");
                String text = jsonObject.getString ("text");
                JSONArray jsonArray = jsonObject.getJSONArray ("result");
                String source = jsonArray.getJSONObject (0).getString ("source");
                String [] latLong = source.split (",");
                Location location = new Location (LocationManager.GPS_PROVIDER);
                location.setLatitude (Double.parseDouble (latLong [0]));
                location.setLongitude (Double.parseDouble (latLong [1]));
                animateMarkerNew (location, mMarker);
            } catch (JSONException e) {
                e.printStackTrace ();
            }
        }@Override
        public void onFailure (int statusCode, Header [] headers, byte [] responseBody, Throwable error) {
            Log.d ("onFailure", "onFailure");
        }}

    );
    handler.postDelayed (this, 3000);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35560429_35560771_1_19
35560429_35561063_23_31
Title: Thread waiting logic 
----------------------------------------

@Override
public void run () {
    boolean EndThread = false;
    int WaitingRuns = 0;
    while (! EndThread) {
        while (! group.HasSomethingNew && WaitingRuns < 3) {
            try {
                Thread.sleep (5000);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            WaitingRuns ++;
        }
        if (group.HasSomethingNew) {
            group.displayFamilyMembers ();
            WaitingRuns = 0;
        } else EndThread = true;

    }
}
----------------------------------------

public void run () {
    try {
        Thread.sleep (MAX_WAITING_TIME);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    group.displayFamilyMembers ();
    second.start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35560429_35560771_1_19
35560429_35561063_6_15
Title: Thread waiting logic 
----------------------------------------

@Override
public void run () {
    boolean EndThread = false;
    int WaitingRuns = 0;
    while (! EndThread) {
        while (! group.HasSomethingNew && WaitingRuns < 3) {
            try {
                Thread.sleep (5000);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
            WaitingRuns ++;
        }
        if (group.HasSomethingNew) {
            group.displayFamilyMembers ();
            WaitingRuns = 0;
        } else EndThread = true;

    }
}
----------------------------------------

public void run () {
    try {
        Thread.sleep (5000);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    System.out.println ("Before adding");
    group.displayFamilyMembers ();
}
----------------------------------------
