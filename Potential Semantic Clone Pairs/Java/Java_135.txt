$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8561018_8561052_9_19
8561018_8561566_12_21
Title: Java Closure Scope 
----------------------------------------

public static void main (String [] args) {
    final String lastName = "Brad's last name";
    Timer time = new Timer ();
    time.schedule (new TimerTask () {
        @Override
        public void run () {
            System.out.println ("Name: " + name + " " + lastName);
        }}

    , 0, 10000);
}
----------------------------------------

public static void main (String [] args) {
    Timer time = new Timer ();
    final Application application = new Application ();
    time.schedule (new TimerTask () {
        public void run () {
            System.out.println ("Name: " + application.getName ());
            application.privateMethod ();
        }}

    , 0, 10000);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8563376_8563448_9_46
8563376_8563468_17_43
Title: exporting sql query result to a csv or excel 
----------------------------------------

public static void main (String [] args) {
    try {
        Class.forName ("com.mysql.jdbc.Driver").newInstance ();
        Connection connection = DriverManager.getConnection ("jdbc:mysql://localhost:3306/test", "root", "root");
        PreparedStatement psmnt = null;
        Statement st = connection.createStatement ();
        ResultSet rs = st.executeQuery ("Select * from student");
        HSSFWorkbook wb = new HSSFWorkbook ();
        HSSFSheet sheet = wb.createSheet ("Excel Sheet");
        HSSFRow rowhead = sheet.createRow ((short) 0);
        rowhead.createCell ((short) 0).setCellValue ("Roll No");
        rowhead.createCell ((short) 1).setCellValue ("Name");
        rowhead.createCell ((short) 2).setCellValue ("Class");
        rowhead.createCell ((short) 3).setCellValue ("Marks");
        rowhead.createCell ((short) 4).setCellValue ("Grade");
        int index = 1;
        while (rs.next ()) {
            HSSFRow row = sheet.createRow ((short) index);
            row.createCell ((short) 0).setCellValue (rs.getInt (1));
            row.createCell ((short) 1).setCellValue (rs.getString (2));
            row.createCell ((short) 2).setCellValue (rs.getString (3));
            row.createCell ((short) 3).setCellValue (rs.getInt (4));
            row.createCell ((short) 4).setCellValue (rs.getString (5));
            index ++;
        }
        FileOutputStream fileOut = new FileOutputStream ("c:\\excelFile.xls");
        wb.write (fileOut);
        fileOut.close ();
        System.out.println ("Data is saved in excel file.");
        rs.close ();
        connection.close ();
    } catch (Exception e) {
    }
}
----------------------------------------

public static void main (String args []) {
    Connection conn = null;
    Statement stmt = null;
    ResultSet rs = null;
    try {
        conn = getConnection ();
        stmt = conn.createStatement ();
        String excelQuery = "select * from [Sheet1$]";
        rs = stmt.executeQuery (excelQuery);
        while (rs.next ()) {
            System.out.println (rs.getString ("BadgeNumber") + " " + rs.getString ("FirstName") + " " + rs.getString ("LastName"));
        }
    } catch (Exception e) {
        System.err.println (e.getMessage ());
    } finally {
        try {
            rs.close ();
            stmt.close ();
            conn.close ();
        } catch (SQLException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8582925_8583037_39_50
8582925_8583037_59_69
Title: Fading Images - Swing 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    float newAlpha = softButton1.getAlpha () + incrementer;
    if (newAlpha < 0) {
        newAlpha = 0;
        incrementer = - incrementer;
    } else if (newAlpha > 1f) {
        newAlpha = 1f;
        incrementer = - incrementer;
    }

    softButton1.setAlpha (newAlpha);
    softButton2.setAlpha (newAlpha);
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    try {
        UIManager.setLookAndFeel (laf [index].getClassName ());
        SwingUtilities.updateComponentTreeUI (frame);
        opaqueButton1.setText (laf [index].getClassName ());
        softButton1.setText (laf [index].getClassName ());
    } catch (Exception exc) {
        exc.printStackTrace ();
    }
    index = (index + 1) % laf.length;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8587107_8587389_13_33
8587107_8587487_8_31
Title: Java: How to get assigned numeric values for String input 
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
    String userInput = (in.readLine ()).toLowerCase ();
    HashMap < Character, Integer > hm = new HashMap < Character, Integer > ();
    hm.put ('a', 1);
    hm.put ('b', 2);
    hm.put ('c', 3);
    hm.put ('d', 4);
    hm.put ('e', 5);
    hm.put ('f', 8);
    hm.put ('g', 3);
    hm.put ('h', 5);
    hm.put ('i', 1);
    hm.put ('j', 1);
    hm.put ('k', 2);
    hm.put ('l', 3);
    hm.put ('m', 4);
    hm.put ('n', 5);
    hm.put ('o', 7);
    hm.put ('p', 8);
    hm.put ('q', 1);
    hm.put ('r', 2);
    hm.put ('s', 3);
    hm.put ('t', 4);
    hm.put ('u', 6);
    hm.put ('v', 6);
    hm.put ('w', 6);
    hm.put ('x', 5);
    hm.put ('y', 1);
    hm.put ('z', 7);
    int total = 0;
    for (int ai = 0;
    ai < userInput.length (); ai ++) {
        total += hm.get (userInput.charAt (ai));
    }
    System.out.println (total);
}
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
    String userInput = in.readLine ();
    String input;
    int adder = 0;
    System.out.println (" userInput " + userInput);
    for (int i = 0;
    i < userInput.length (); i ++) {
        input = userInput.charAt (i) + "";
        System.out.println (" input " + input);
        if (input.equals ("k")) adder += k;

        if (input.equals ("a")) adder += a;

        if (input.equals ("m")) adder += m;

        if (input.equals ("r")) adder += r;

        if (input.equals ("b")) adder += b;

        if (input.equals ("n")) adder += n;

    }
    System.out.println (" adder " + adder);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8591386_8591528_8_24
8591386_8594171_1_31
Title: Make a Panel open when i click a button 
----------------------------------------

public static void main (final String [] args) {
    JFrame parent = new JFrame ();
    JButton button = new JButton ();
    button.setText ("Click me to show dialog!");
    parent.add (button);
    parent.pack ();
    parent.setVisible (true);
    button.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            JOptionPane optionPane = new JOptionPane ("Is this what you need?", JOptionPane.QUESTION_MESSAGE, JOptionPane.YES_NO_OPTION);
            JDialog dialog = optionPane.createDialog ("Dialog");
            dialog.setVisible (true);
        }}

    );
}
----------------------------------------

public static void main (String args []) {
    final JDialog bwin = new JDialog ();
    bwin.addWindowFocusListener (new WindowFocusListener () {
        @Override
        public void windowLostFocus (WindowEvent e) {
            bwin.setVisible (false);
            bwin.dispose ();
        }@Override
        public void windowGainedFocus (WindowEvent e) {
        }}

    );
    bwin.setUndecorated (true);
    JLabel label = new JLabel ("About");
    JPanel panel = new JPanel ();
    panel.setLayout (new BorderLayout ());
    panel.add (label);
    panel.setPreferredSize (new Dimension (200, 200));
    bwin.add (panel);
    bwin.pack ();
    bwin.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
859562_34866995_5_14
859562_859608_1_12
Title: Whats the best way to recursively reverse a string in Java? 
----------------------------------------

private static String reverseString (String result, String original) {
    if (original.length () == 0) {
        return result;
    } else {
        int length = original.length ();
        String lastLetter = original.substring (length - 1, length);
        original = original.substring (0, length - 1);
        return reverseString (result + lastLetter, original);
    }
}
----------------------------------------

public String reverseString (String s) {
    int len = s.length ();
    if (len <= 1) {
        return s;
    }
    char fst = s.charAt (0);
    char lst = s.charAt (len - 1);
    return lst + reverseString (s.substring (1, len - 2)) + fst;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8596161_8596864_20_32
8596161_8596864_34_52
Title: JSON String tidy/formatter for Java 
----------------------------------------

private void visit (final JSONArray array, final int indent) throws JSONException {
    final int length = array.length ();
    if (length == 0) {
        write ("[]", indent);
    } else {
        write ("[", indent);
        for (int i = 0;
        i < length; i ++) {
            visit (array.get (i), indent + 1);
        }
        write ("]", indent);
    }
}
----------------------------------------

private void visit (final JSONObject obj, final int indent) throws JSONException {
    final int length = obj.length ();
    if (length == 0) {
        write ("{}", indent);
    } else {
        write ("{", indent);
        final Iterator < String > keys = obj.keys ();
        while (keys.hasNext ()) {
            final String key = keys.next ();
            write (key + " :", indent + 1);
            visit (obj.get (key), indent + 1);
            if (keys.hasNext ()) {
                write (",", indent + 1);
            }
        }
        write ("}", indent);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8596161_8596864_20_32
8596161_8596864_54_67
Title: JSON String tidy/formatter for Java 
----------------------------------------

private void visit (final JSONArray array, final int indent) throws JSONException {
    final int length = array.length ();
    if (length == 0) {
        write ("[]", indent);
    } else {
        write ("[", indent);
        for (int i = 0;
        i < length; i ++) {
            visit (array.get (i), indent + 1);
        }
        write ("]", indent);
    }
}
----------------------------------------

private void visit (final Object object, final int indent) throws JSONException {
    if (object instanceof JSONArray) {
        visit ((JSONArray) object, indent);
    } else if (object instanceof JSONObject) {
        visit ((JSONObject) object, indent);
    } else {
        if (object instanceof String) {
            write ("\"" + (String) object + "\"", indent);
        } else {
            write (String.valueOf (object), indent);
        }
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8596161_8596864_34_52
8596161_8596864_54_67
Title: JSON String tidy/formatter for Java 
----------------------------------------

private void visit (final JSONObject obj, final int indent) throws JSONException {
    final int length = obj.length ();
    if (length == 0) {
        write ("{}", indent);
    } else {
        write ("{", indent);
        final Iterator < String > keys = obj.keys ();
        while (keys.hasNext ()) {
            final String key = keys.next ();
            write (key + " :", indent + 1);
            visit (obj.get (key), indent + 1);
            if (keys.hasNext ()) {
                write (",", indent + 1);
            }
        }
        write ("}", indent);
    }
}
----------------------------------------

private void visit (final Object object, final int indent) throws JSONException {
    if (object instanceof JSONArray) {
        visit ((JSONArray) object, indent);
    } else if (object instanceof JSONObject) {
        visit ((JSONObject) object, indent);
    } else {
        if (object instanceof String) {
            write ("\"" + (String) object + "\"", indent);
        } else {
            write (String.valueOf (object), indent);
        }
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8617790_8617828_1_10
8617790_8617850_1_13
Title: Recursive search for a node in non-binary tree 
----------------------------------------

private nNode recursiveSearch (data gi, nNode node) {
    if (node.getdata () == gi) return node;

    nNode [] children = node.getChildren ();
    nNode res = null;
    for (int i = 0;
    res == null && i < children.length; i ++) {
        res = recursiveSearch (gi, children [i]);
    }
    return res;
}
----------------------------------------

private nNode recursiveSearch (data gi, nNode node) {
    if (node.getdata () == gi) return node;

    nNode [] children = node.getChildren ();
    nNode temp;
    if (children.length > 0) for (int i = 0;
    i < children.length; i ++) {
        temp = recursiveSearch (gi, children [i]);
        if (temp != null) return temp;

    }

    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8620158_8620652_28_59
8620158_8620680_17_44
Title: Electing a thread for barrier action execution - Java CyclicBarrier 
----------------------------------------

public void run () {
    int columns = matrix [row].length;
    int sum = 0;
    for (int i = 0;
    i < columns; i ++) {
        sum += matrix [row] [i];
    }
    results [row] = sum;
    System.out.println ("Results for row " + row + " are : " + sum);
    try {
        int w = barrier.await ();
        if (w == 0) {
            System.out.println ("merging now !");
            int fullSum = 0;
            for (int i = 0;
            i < rows; i ++) {
                fullSum += results [i];
            }
            System.out.println ("Results are: " + fullSum);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    final String threadName = Thread.currentThread ().getName ();
    System.out.printf ("%s:  You better work!%n", threadName);
    Random rnd = new Random ();
    int secondsToWorkIt = rnd.nextInt (10) + 1;
    try {
        TimeUnit.SECONDS.sleep (secondsToWorkIt);
    } catch (InterruptedException ex) {
    }
    System.out.printf ("%s worked it, girl!%n", threadName);
    try {
        int n = barrier.await ();
        final int myOrder = barrier.getParties () - n;
        System.out.printf ("Turn number: %s was %s%n", myOrder, threadName);
        if (myOrder == 3) {
            System.out.printf ("%s: Sashay Chante!%n", myOrder);
        }
    } catch (BrokenBarrierException ex) {
    } catch (InterruptedException ex) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8621560_8621729_36_47
8621560_8621729_7_15
Title: Sending multiple variables through a socket? 
----------------------------------------

public void run () {
    try {
        oos.writeObject (new Data ());
        oos.flush ();
        ois.close ();
        oos.close ();
        client.close ();
    } catch (Exception e) {
        System.out.println (e.getMessage ());
    }
    System.out.println ("done");
}
----------------------------------------

public void run () {
    while (true) {
        try {
            Socket client = serverSocket.accept ();
            Connect c = new Connect (client);
            c.start ();
        } catch (Exception e) {
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8629876_47831827_98_152
8629876_49255456_49_71
Title: Stack implementation 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    LinkedStack linkedStack = new LinkedStack ();
    boolean yes = true;
    do {
        System.out.println ("1. Push");
        System.out.println ("2. Pop");
        System.out.println ("3. Peek");
        System.out.println ("4. Check Empty");
        System.out.println ("5. Size");
        System.out.println ("6. Delete Middle Element");
        int choice = scanner.nextInt ();
        switch (choice) {
            case 1 :
                System.out.println ("Enter the element :- ");
                linkedStack.push (scanner.nextInt ());
                break;
            case 2 :
                try {
                    System.out.println ("Popped Element = " + linkedStack.pop ());
                } catch (Exception e) {
                    System.out.println (e.getMessage ());
                }
                break;
            case 3 :
                try {
                    System.out.println ("Peek Element = " + linkedStack.peek ());
                } catch (Exception e) {
                    System.out.println (e.getMessage ());
                }
                break;
            case 4 :
                System.out.println (linkedStack.isEmpty ());
                break;
            case 5 :
                System.out.println (linkedStack.size ());
                break;
            case 6 :
                try {
                    System.out.println (linkedStack.deleteMiddle ());
                } catch (Exception e) {
                    System.out.println (e.getMessage ());
                }
                break;
            default :
                break;
        }
    } while (yes);
}
----------------------------------------

public static void main (String [] args) {
    ArrayStack < Integer > arrayStack = new ArrayStack < Integer > ();
    arrayStack.push (1);
    arrayStack.push (2);
    arrayStack.push (3);
    arrayStack.push (4);
    arrayStack.push (5);
    arrayStack.push (6);
    arrayStack.push (7);
    arrayStack.push (8);
    arrayStack.push (9);
    arrayStack.push (10);
    arrayStack.push (11);
    System.out.println ("Size: " + arrayStack.size ());
    System.out.println (arrayStack.pop ());
    System.out.println (arrayStack.pop ());
    System.out.println (arrayStack.pop ());
    System.out.println (arrayStack.pop ());
    System.out.println (arrayStack.peek ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8629876_47831827_98_152
8629876_49256070_42_64
Title: Stack implementation 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    LinkedStack linkedStack = new LinkedStack ();
    boolean yes = true;
    do {
        System.out.println ("1. Push");
        System.out.println ("2. Pop");
        System.out.println ("3. Peek");
        System.out.println ("4. Check Empty");
        System.out.println ("5. Size");
        System.out.println ("6. Delete Middle Element");
        int choice = scanner.nextInt ();
        switch (choice) {
            case 1 :
                System.out.println ("Enter the element :- ");
                linkedStack.push (scanner.nextInt ());
                break;
            case 2 :
                try {
                    System.out.println ("Popped Element = " + linkedStack.pop ());
                } catch (Exception e) {
                    System.out.println (e.getMessage ());
                }
                break;
            case 3 :
                try {
                    System.out.println ("Peek Element = " + linkedStack.peek ());
                } catch (Exception e) {
                    System.out.println (e.getMessage ());
                }
                break;
            case 4 :
                System.out.println (linkedStack.isEmpty ());
                break;
            case 5 :
                System.out.println (linkedStack.size ());
                break;
            case 6 :
                try {
                    System.out.println (linkedStack.deleteMiddle ());
                } catch (Exception e) {
                    System.out.println (e.getMessage ());
                }
                break;
            default :
                break;
        }
    } while (yes);
}
----------------------------------------

public static void main (String [] args) {
    LinkedlistStack < Integer > linkedlistStack = new LinkedlistStack < Integer > ();
    linkedlistStack.push (1);
    linkedlistStack.push (2);
    linkedlistStack.push (3);
    linkedlistStack.push (4);
    linkedlistStack.push (5);
    linkedlistStack.push (6);
    linkedlistStack.push (7);
    linkedlistStack.push (8);
    linkedlistStack.push (9);
    linkedlistStack.push (10);
    linkedlistStack.push (11);
    System.out.println ("Size: " + linkedlistStack.size ());
    System.out.println (linkedlistStack.pop ());
    System.out.println (linkedlistStack.pop ());
    System.out.println (linkedlistStack.pop ());
    System.out.println (linkedlistStack.pop ());
    System.out.println (linkedlistStack.peek ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8637202_8637235_1_12
8637202_8637244_1_27
Title: Java - Check for empty String without if statement 
----------------------------------------

private void addPersonButtonActionPerformed (java.awt.event.ActionEvent evt) {
    String firstName = firstNameTextField.getText ();
    String lastName = lastNameTextField.getText ();
    String emailAddress = emailTextField.getText ();
    if (isNameValid (firstName, "First name") && isNameValid (lastName, "Last name") && isEmailValid (emailAddress, "Email address")) {
        personArrayList.add (new Person (firstName, lastName, emailAddress));
        System.out.println ("Person added!");
    }
}
----------------------------------------

private void addPersonButtonActionPerformed (java.awt.event.ActionEvent evt) {
    String firstName = firstNameTextField.getText ();
    String lastName = lastNameTextField.getText ();
    String emailAddress = emailTextField.getText ();
    boolean valid = true;
    if (firstName.equals ("")) {
        System.out.println ("First Name is missing");
        valid = false;
    }
    if (lastName.equals ("")) {
        System.out.println ("Last Name is missing");
        valid = false;
    }
    if (emailAddress.equals ("")) {
        System.out.println ("E-Mail address is missing");
        valid = false;
    }
    if (! Email.isValid (emailAddress)) {
        System.out.println ("E-Mail address is invalid");
        valid = false;
    }
    if (valid) {
        personArrayList.add (new Person (firstName, lastName, emailAddress));
        System.out.println ("Person added!");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8638882_8639081_8_22
8638882_8639119_2_11
Title: Refund FOR loop not working properly 
----------------------------------------

public void refund (float balance) {
    System.out.println ("You have selected the refund option:");
    for (int counter = (int) balance;
    counter >= 10; counter -= 10) {
        System.out.println ("Balance: £" + balance);
        balance -= 10;
    }
    for (int counter = (int) balance;
    counter > 0; counter -= 1) {
        System.out.println ("Balance: £" + balance);
        balance -= 1;
    }
    System.out.println ("Balance: £" + balance);
}
----------------------------------------

public void refund (int balance) {
    while (balance >= 10) {
        System.out.println ("Balance: £" + balance);
        balance -= 10;
    }
    while (balance >= 0) {
        System.out.println ("Balance: £" + balance);
        balance -= 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8651427_8651450_3_23
8651427_8651748_14_23
Title: How to make a thread limit in Java 
----------------------------------------

public static void main (String [] args) {
    File f = null;
    final BlockingQueue < File > queue = new ArrayBlockingQueue < File > (1000);
    for (File kid : f.listFiles ()) {
        queue.add (kid);
    }
    ExecutorService pool = Executors.newFixedThreadPool (5);
    for (int i = 1;
    i <= 5; i ++) {
        Runnable r = new Runnable () {
            public void run () {
                File workFile = null;
                while ((workFile = queue.poll ()) != null) {
                }
            }}

        ;
        pool.execute (r);
    }
}
----------------------------------------

public static void main (String [] args) {
    for (final File filename : folder.listFiles ()) {
        Object lock1 = new Object ();
        new MyThread (filename, lock1).start ();
        counter ++;
        while (counter > 5);

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8654449_8654777_9_26
8654449_8655274_1_43
Title: Display data in decimal format while editing cell value 
----------------------------------------

private static JTable makeSampleTable () {
    String [] columnNames = {"String", "Integer", "Boolean", "Double"};
    Object [] [] data = {{"AAA", 12, true, 111111111111.15}, {"BBB", 1, false, 11199999111.15}, {"CCC", 2, true, 1155555511111.15},};
    DefaultTableModel m = new DefaultTableModel (data, columnNames) {
        private static final long serialVersionUID = 1L;
        @Override
        public Class < ? > getColumnClass (int column) {
            return getValueAt (0, column).getClass ();
        }}

    ;
    JTable table = new JTable (m);
    TableColumnModel tm = table.getColumnModel ();
    tm.getColumn (3).setCellRenderer (new Double2DecimalRenderer ());
    return table;
}
----------------------------------------

private static JTable makeSampleTable () {
    String [] columnNames = {"String", "Integer", "Boolean", "Double"};
    Object [] [] data = {{"AAA", 12, true, 111111111111.15}, {"BBB", 1, false, 11199999111.15}, {"CCC", 2, true, 1155555511111.15},};
    DefaultTableModel m = new DefaultTableModel (data, columnNames) {
        private static final long serialVersionUID = 1L;
        @Override
        public Class < ? > getColumnClass (int column) {
            return getValueAt (0, column).getClass ();
        }}

    ;
    JTable table = new JTable (m);
    TableColumnModel tm = table.getColumnModel ();
    tm.getColumn (3).setCellRenderer (new Double2DecimalRenderer ());
    table.setDefaultEditor (Double.class, new DefaultCellEditor (new JTextField ()) {
        public Component getTableCellEditorComponent (JTable table, Object value, boolean isSelected, int row, int column) {
            NumberFormat nf;
            nf = NumberFormat.getNumberInstance ();
            nf.setMinimumFractionDigits (2);
            nf.setMaximumFractionDigits (2);
            if ((value != null) && (value instanceof Number)) {
                Number numberValue = (Number) value;
                delegate.setValue (nf.format (numberValue.doubleValue ()));
            } else {
                delegate.setValue (value);
            }
            return editorComponent;
        }}

    );
    return table;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8667870_42449222_20_30
8667870_42449222_2_14
Title: Is it possible to use poison pill approach with bounded queues? 
----------------------------------------

public void run () {
    try {
        while (true) {
            File file = queue.take ();
            if (file == POISON) break;
            else indexFile (file);

        }
    } catch (InterruptedException consumed) {
    }
}
----------------------------------------

public void run () {
    try {
        crawl (root);
    } catch (InterruptedException e) {
    } finally {
        while (true) {
            try {
                queue.put (POISON);
                break;
            } catch (InterruptedException e1) {
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8672452_8672839_22_44
8672452_8672977_5_14
Title: Making java wait until a property is called for? 
----------------------------------------

private Vector (double x, double y, double z, boolean isUnitVector) {
    double length = Math.sqrt (x * x + y * y + z * z);
    if (isUnitVector) {
        this.length = 1;
        this.x = x / length;
        this.y = y / length;
        this.z = z / length;
        this.unit = this;
    } else {
        this.length = Math.sqrt (x * x + y * y + z * z);
        this.x = x;
        this.y = y;
        this.z = z;
        this.unit = new Vector (x / length, y / length, z / length, true);
    }
}
----------------------------------------

public Vector (double x, double y, double z) {
    this.x = x;
    this.y = y;
    this.z = z;
    double length = calcLength (x, y, z);
    if (length == 1.0) this.unit = this;
    else this.unit = new Vector (x / length, y / length, z / length);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
867442_867472_1_10
867442_867563_1_13
Title: What is the best way to compare several javabean properties? 
----------------------------------------

public void compareAndUpdate (MyClass a, MyClass b) {
    for (int i = 0;
    i < a.getMemberCount (); ++ i) {
        String sa = a.getMember ();
        String sb = b.getMember ();
        if (! sa.equals (sb)) {
            Log.v ("compare", a.getMemberName (i));
            b.setMember (i, sa);
        }
    }
}
----------------------------------------

public void compareAndUpdate (MyClass other) throws IllegalAccessException {
    for (Field field : getClass ().getDeclaredFields ()) {
        if (field.getType () == String.class) {
            Object thisValue = field.get (this);
            Object otherValue = field.get (other);
            if (! thisValue.equals (otherValue)) {
                log (field.getName () + ": " + thisValue + " <> " + otherValue);
                field.set (other, thisValue);
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
867660_1022300_23_47
867660_868528_19_44
Title: "j2me networking threads and deadlocks" 
----------------------------------------

private void fetchImage () {
    new Thread (new Runnable () {
        public void run () {
            try {
                final HttpConnection httpConnection = (HttpConnection) Connector.open ("http://stackoverflow.com/content/img/so/logo.png");
                try {
                    final InputStream stream = httpConnection.openInputStream ();
                    try {
                        image = Image.createImage (stream);
                    } finally {
                        stream.close ();
                    }
                } finally {
                    httpConnection.close ();
                }
            } catch (IOException e) {
                e.printStackTrace ();
                imageFetchFailed = true;
            }
            repaint ();
        }}

    ).start ();
}
----------------------------------------

private void fetchImage () {
    new Thread (new Runnable () {
        public void run () {
            HttpConnection httpConnection = null;
            try {
                httpConnection = (HttpConnection) Connector.open ("http://10.4.71.200/stage/images/front/car.png");
                image = Image.createImage (httpConnection.openInputStream ());
            } catch (IOException e) {
                e.printStackTrace ();
                imageFetchFailed = true;
            }
            if (httpConnection != null) {
                try {
                    httpConnection.close ();
                } catch (IOException ignored) {
                }
            }
            repaint ();
        }}

    ).start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
867660_1022300_26_45
867660_868528_21_42
Title: "j2me networking threads and deadlocks" 
----------------------------------------

public void run () {
    try {
        final HttpConnection httpConnection = (HttpConnection) Connector.open ("http://stackoverflow.com/content/img/so/logo.png");
        try {
            final InputStream stream = httpConnection.openInputStream ();
            try {
                image = Image.createImage (stream);
            } finally {
                stream.close ();
            }
        } finally {
            httpConnection.close ();
        }
    } catch (IOException e) {
        e.printStackTrace ();
        imageFetchFailed = true;
    }
    repaint ();
}
----------------------------------------

public void run () {
    HttpConnection httpConnection = null;
    try {
        httpConnection = (HttpConnection) Connector.open ("http://10.4.71.200/stage/images/front/car.png");
        image = Image.createImage (httpConnection.openInputStream ());
    } catch (IOException e) {
        e.printStackTrace ();
        imageFetchFailed = true;
    }
    if (httpConnection != null) {
        try {
            httpConnection.close ();
        } catch (IOException ignored) {
        }
    }
    repaint ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
867660_1022300_7_21
867660_868528_6_16
Title: "j2me networking threads and deadlocks" 
----------------------------------------

protected void paint (Graphics g) {
    g.fillRect (0, 0, g.getClipWidth (), g.getClipHeight ());
    if (image == null) {
        if (imageDownloadStarted) return;

        imageDownloadStarted = true;
        fetchImage ();
        g.drawString ("Fetching...", getWidth ()>> 1, getHeight ()>> 1, Graphics.HCENTER | Graphics.TOP);
    } else if (imageFetchFailed) {
        g.drawString ("Failed to fetch image", getWidth ()>> 1, getHeight ()>> 1, Graphics.HCENTER | Graphics.TOP);
    } else {
        g.drawImage (image, 0, 0, 0);
    }

}
----------------------------------------

protected void paint (Graphics g) {
    if (image == null) {
        fetchImage ();
        g.drawString ("Fetching...", getWidth ()>> 1, getHeight ()>> 1, Graphics.HCENTER | Graphics.TOP)
    } else if (imageFetchFailed) {
        g.drawString ("Failed to fetch image", getWidth ()>> 1, getHeight ()>> 1, Graphics.HCENTER | Graphics.TOP)
    } else {
        g.drawImage (image, 0, 0, 0);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
86780_25379180_58_94
86780_40508106_7_26
Title: How to check if a String contains another String in a case insensitive manner in Java? 
----------------------------------------

public static void main (String [] args) throws Exception {
    final String src = "Hi, I am Adam";
    final String what = "i am";
    long start, end;
    final int N = 10_000_000;
    start = System.nanoTime ();
    for (int i = 0;
    i < N; i ++) containsIgnoreCase (src, what);

    end = System.nanoTime ();
    System.out.println ("Case 1 took " + ((end - start) / 1000000) + "ms");
    start = System.nanoTime ();
    for (int i = 0;
    i < N; i ++) containsConverting (src, what);

    end = System.nanoTime ();
    System.out.println ("Case 2 took " + ((end - start) / 1000000) + "ms");
    start = System.nanoTime ();
    for (int i = 0;
    i < N; i ++) containsConverting (src);

    end = System.nanoTime ();
    System.out.println ("Case 3 took " + ((end - start) / 1000000) + "ms");
    start = System.nanoTime ();
    for (int i = 0;
    i < N; i ++) containsIgnoreCaseRegexp (src, what);

    end = System.nanoTime ();
    System.out.println ("Case 4 took " + ((end - start) / 1000000) + "ms");
    start = System.nanoTime ();
    for (int i = 0;
    i < N; i ++) containsIgnoreCaseRegexp (src);

    end = System.nanoTime ();
    System.out.println ("Case 5 took " + ((end - start) / 1000000) + "ms");
}
----------------------------------------

public static void main (String [] args) {
    String in = "   Annulée ";
    String key = "annulee";
    if (Normalizer.normalize (in, Normalizer.Form.NFD).replaceAll ("[\\p{InCombiningDiacriticalMarks}]", "").toLowerCase ().contains (key)) {
        System.out.println ("OK");
    } else {
        System.out.println ("KO");
    }
    if (StringUtils.containsIgnoreCase (Normalizer.normalize (in, Normalizer.Form.NFD).replaceAll ("[\\p{InCombiningDiacriticalMarks}]", ""), key)) {
        System.out.println ("OK");
    } else {
        System.out.println ("KO");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8680610_22943954_18_34
8680610_8681806_21_29
Title: Java Generics: chaining together generic function object 
----------------------------------------

public List < OUT > run (List < IN > input) {
    List < OUT > allResults = new ArrayList < > ();
    List < MEDIAL > headResult;
    if (head == null) {
        headResult = (List < MEDIAL >) input;
    } else {
        headResult = head.run (input);
    }
    for (MEDIAL in : headResult) {
        allResults.addAll (tail.transform (in));
    }
    return allResults;
}
----------------------------------------

public T run (S s) {
    Object source = s;
    Object target = null;
    for (Pipe p : pipes) {
        target = p.transform (source);
        source = target;
    }
    return (T) target;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8680610_22943954_36_61
8680610_8681806_31_53
Title: Java Generics: chaining together generic function object 
----------------------------------------

public static void main (String [] args) {
    Transformer < String, Integer > pipe1 = new Transformer < String, Integer > () {
        @Override
        public List < Integer > transform (String s) {
            return Collections.singletonList (Integer.valueOf (s) * 3);
        }}

    ;
    Transformer < Integer, Long > pipe2 = new Transformer < Integer, Long > () {
        @Override
        public List < Long > transform (Integer s) {
            return Collections.singletonList (s.longValue () * 5);
        }}

    ;
    Transformer < Long, BigInteger > pipe3 = new Transformer < Long, BigInteger > () {
        @Override
        public List < BigInteger > transform (Long s) {
            return Collections.singletonList (new BigInteger (String.valueOf (s * 7)));
        }}

    ;
    Chain < String, ?, Integer > chain1 = Chain.makeHead (pipe1);
    Chain < String, Integer, Long > chain2 = Chain.append (chain1, pipe2);
    Chain < String, Long, BigInteger > chain3 = Chain.append (chain2, pipe3);
    List < BigInteger > result = chain3.run (Collections.singletonList ("1"));
    System.out.println (result);
}
----------------------------------------

public static void main (String [] args) {
    Pipe < String, Integer > pipe1 = new Pipe < String, Integer > () {
        @Override
        public Integer transform (String s) {
            return Integer.valueOf (s);
        }}

    ;
    Pipe < Integer, Long > pipe2 = new Pipe < Integer, Long > () {
        @Override
        public Long transform (Integer s) {
            return s.longValue ();
        }}

    ;
    Pipe < Long, BigInteger > pipe3 = new Pipe < Long, BigInteger > () {
        @Override
        public BigInteger transform (Long s) {
            return new BigInteger (s.toString ());
        }}

    ;
    Chain < String, BigInteger > chain = Chain.start (pipe1).append (pipe2).append (pipe3);
    BigInteger result = chain.run ("12");
    System.out.println (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
868651_13503677_16_61
868651_49549475_34_66
Title: Multi-line tooltips in Java? 
----------------------------------------

public static String splitToolTip (String tip, int length) {
    if (tip.length () <= length + SPACE_BUFFER) {
        return tip;
    }
    List < String > parts = new ArrayList < > ();
    int maxLength = 0;
    String overLong = tip.substring (0, length + SPACE_BUFFER);
    int lastSpace = overLong.lastIndexOf (' ');
    if (lastSpace >= length) {
        parts.add (tip.substring (0, lastSpace));
        maxLength = lastSpace;
    } else {
        parts.add (tip.substring (0, length));
        maxLength = length;
    }
    while (maxLength < tip.length ()) {
        if (maxLength + length < tip.length ()) {
            parts.add (tip.substring (maxLength, maxLength + length));
            maxLength += maxLength + length;
        } else {
            parts.add (tip.substring (maxLength));
            break;
        }
    }
    StringBuilder sb = new StringBuilder ("<html>");
    for (int i = 0;
    i < parts.size () - 1; i ++) {
        sb.append (parts.get (i) + "<br>");
    }
    sb.append (parts.get (parts.size () - 1));
    sb.append (("</html>"));
    return sb.toString ();
}
----------------------------------------

public static String splitToolTip (final String toolTip, final int desiredLength) {
    if (toolTip.length () <= desiredLength) {
        return toolTip;
    }
    List < String > parts = new ArrayList < > ();
    int stringPosition = 0;
    while (stringPosition < toolTip.length ()) {
        if (stringPosition + desiredLength < toolTip.length ()) {
            String tipSubstring = toolTip.substring (stringPosition, stringPosition + desiredLength);
            int lastSpace = tipSubstring.lastIndexOf (' ');
            if (lastSpace == - 1 || lastSpace == 0) {
                parts.add (toolTip.substring (stringPosition, stringPosition + desiredLength));
                stringPosition += desiredLength;
            } else {
                parts.add (toolTip.substring (stringPosition, stringPosition + lastSpace));
                stringPosition += lastSpace;
            }
        } else {
            parts.add (toolTip.substring (stringPosition));
            break;
        }
    }
    StringBuilder sb = new StringBuilder ("<html>");
    for (int i = 0;
    i < parts.size () - 1; i ++) {
        sb.append (parts.get (i) + "<br>");
    }
    sb.append (parts.get (parts.size () - 1));
    sb.append (("</html>"));
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8689754_26117143_1_13
8689754_8689779_1_21
Title: Java - Recursive function of the Euclidean Algorithm 
----------------------------------------

public static int gcd (int x, int y) {
    if (y == 0) return x;

    if (x < 0) return gcd (x * - 1, y);

    if (y < 0) return gcd (x, y * - 1);

    if (y <= x && x % y == 0) return y;

    return gcd (y, x % y);
}
----------------------------------------

public static int gcd (int x, int y) {
    if (y == 0) {
        return x;
    } else if (x >= y && y > 0) {
        return gcd (y, (x % y));
    }

    throw new IllegalArgumentException (String.format ("Unexpected values for x(%d) and y(%d)", Integer.valueOf (x), Integer.valueOf (y)));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8693296_8693597_1_32
8693296_8699551_23_70
Title: How to get view for an item in listview in android? 
----------------------------------------

@Override
public View getView (int position, View convertView, ViewGroup parent) {
    View view = null;
    if (convertView == null) {
        LayoutInflater inflater = context.getLayoutInflater ();
        view = inflater.inflate (textViewResourceId, parent, false);
        final ViewHolder viewHolder = new ViewHolder ();
        viewHolder.name = (TextView) view.findViewById (R.id.name);
        viewHolder.button = (ImageButton) view.findViewById (R.id.button);
        viewHolder.button.setOnClickListener (new View.OnClickListener () {
            @Override
            public void onClick (View view) {
                int position = (int) viewHolder.button.getTag ();
                Log.d (TAG, "Position is: " + position);
            }}

        );
        view.setTag (viewHolder);
        viewHolder.button.setTag (items.get (position));
    } else {
        view = convertView;
        ((ViewHolder) view.getTag ()).button.setTag (items.get (position));
    }
    ViewHolder holder = (ViewHolder) view.getTag ();
    return view;
}
----------------------------------------

public View getView (int position, View convertView, ViewGroup parent) {
    View v = convertView;
    ViewHolder holder = null;
    if (v == null) {
        try {
            holder = new ViewHolder ();
            LayoutInflater vi = (LayoutInflater) getSystemService (Context.LAYOUT_INFLATER_SERVICE);
            imageLoader = new FoodDriveImageLoader (FoodDriveModule.this);
            v = vi.inflate (R.layout.virtual_food_drive_row, null);
            holder.nm = (TextView) v.findViewById (R.id.name);
            holder.tnm = (TextView) v.findViewById (R.id.teamname);
            holder.tr = (TextView) v.findViewById (R.id.target);
            holder.re = (TextView) v.findViewById (R.id.received);
            holder.membercount = new TextView (FoodDriveModule.this);
            holder.membernm = new TextView (FoodDriveModule.this);
            holder.email = new TextView (FoodDriveModule.this);
            holder.phone = new TextView (FoodDriveModule.this);
            holder.ii = (ImageView) v.findViewById (R.id.icon);
            v.setTag (holder);
        } catch (Exception e) {
            System.out.println ("Excption Caught" + e);
        }
    } else {
        holder = (ViewHolder) v.getTag ();
    }
    CoordinatorData co = items.get (position);
    holder.nm.setText (co.getName ());
    holder.tnm.setText (co.getTeamName ());
    holder.tr.setText (co.getTarget ());
    holder.re.setText (co.getReceived ());
    holder.ii.setTag (co.getImage ());
    imageLoader.DisplayImage (co.getImage (), FoodDriveModule.this, holder.ii);
    if (co != null) {
    }
    return v;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8693342_18413639_150_167
8693342_8693635_96_112
Title: Drawing a simple line graph in Java 
----------------------------------------

private static void createAndShowGui () {
    List < Double > scores = new ArrayList < > ();
    Random random = new Random ();
    int maxDataPoints = 40;
    int maxScore = 10;
    for (int i = 0;
    i < maxDataPoints; i ++) {
        scores.add ((double) random.nextDouble () * maxScore);
    }
    GraphPanel mainPanel = new GraphPanel (scores);
    mainPanel.setPreferredSize (new Dimension (800, 600));
    JFrame frame = new JFrame ("DrawGraph");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.getContentPane ().add (mainPanel);
    frame.pack ();
    frame.setLocationRelativeTo (null);
    frame.setVisible (true);
}
----------------------------------------

private static void createAndShowGui () {
    List < Integer > scores = new ArrayList < Integer > ();
    Random random = new Random ();
    int maxDataPoints = 16;
    int maxScore = 20;
    for (int i = 0;
    i < maxDataPoints; i ++) {
        scores.add (random.nextInt (maxScore));
    }
    DrawGraph mainPanel = new DrawGraph (scores);
    JFrame frame = new JFrame ("DrawGraph");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.getContentPane ().add (mainPanel);
    frame.pack ();
    frame.setLocationByPlatform (true);
    frame.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8693342_18413639_36_118
8693342_8693635_32_89
Title: Drawing a simple line graph in Java 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - (2 * padding) - labelPadding) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * padding - labelPadding) / (getMaxScore () - getMinScore ());
    List < Point > graphPoints = new ArrayList < > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + padding + labelPadding);
        int y1 = (int) ((getMaxScore () - scores.get (i)) * yScale + padding);
        graphPoints.add (new Point (x1, y1));
    }
    g2.setColor (Color.WHITE);
    g2.fillRect (padding + labelPadding, padding, getWidth () - (2 * padding) - labelPadding, getHeight () - 2 * padding - labelPadding);
    g2.setColor (Color.BLACK);
    for (int i = 0;
    i < numberYDivisions + 1; i ++) {
        int x0 = padding + labelPadding;
        int x1 = pointWidth + padding + labelPadding;
        int y0 = getHeight () - ((i * (getHeight () - padding * 2 - labelPadding)) / numberYDivisions + padding + labelPadding);
        int y1 = y0;
        if (scores.size () > 0) {
            g2.setColor (gridColor);
            g2.drawLine (padding + labelPadding + 1 + pointWidth, y0, getWidth () - padding, y1);
            g2.setColor (Color.BLACK);
            String yLabel = ((int) ((getMinScore () + (getMaxScore () - getMinScore ()) * ((i * 1.0) / numberYDivisions)) * 100)) / 100.0 + "";
            FontMetrics metrics = g2.getFontMetrics ();
            int labelWidth = metrics.stringWidth (yLabel);
            g2.drawString (yLabel, x0 - labelWidth - 5, y0 + (metrics.getHeight () / 2) - 3);
        }
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size (); i ++) {
        if (scores.size () > 1) {
            int x0 = i * (getWidth () - padding * 2 - labelPadding) / (scores.size () - 1) + padding + labelPadding;
            int x1 = x0;
            int y0 = getHeight () - padding - labelPadding;
            int y1 = y0 - pointWidth;
            if ((i % ((int) ((scores.size () / 20.0)) + 1)) == 0) {
                g2.setColor (gridColor);
                g2.drawLine (x0, getHeight () - padding - labelPadding - 1 - pointWidth, x1, padding);
                g2.setColor (Color.BLACK);
                String xLabel = i + "";
                FontMetrics metrics = g2.getFontMetrics ();
                int labelWidth = metrics.stringWidth (xLabel);
                g2.drawString (xLabel, x0 - labelWidth / 2, y0 + metrics.getHeight () + 3);
            }
            g2.drawLine (x0, y0, x1, y1);
        }
    }
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, padding + labelPadding, padding);
    g2.drawLine (padding + labelPadding, getHeight () - padding - labelPadding, getWidth () - padding, getHeight () - padding - labelPadding);
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (lineColor);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (pointColor);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - pointWidth / 2;
        int y = graphPoints.get (i).y - pointWidth / 2;
        int ovalW = pointWidth;
        int ovalH = pointWidth;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2 = (Graphics2D) g;
    g2.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    double xScale = ((double) getWidth () - 2 * BORDER_GAP) / (scores.size () - 1);
    double yScale = ((double) getHeight () - 2 * BORDER_GAP) / (MAX_SCORE - 1);
    List < Point > graphPoints = new ArrayList < Point > ();
    for (int i = 0;
    i < scores.size (); i ++) {
        int x1 = (int) (i * xScale + BORDER_GAP);
        int y1 = (int) ((MAX_SCORE - scores.get (i)) * yScale + BORDER_GAP);
        graphPoints.add (new Point (x1, y1));
    }
    g2.drawLine (BORDER_GAP, getHeight () - BORDER_GAP, BORDER_GAP, BORDER_GAP);
    g2.drawLine (BORDER_GAP, getHeight () - BORDER_GAP, getWidth () - BORDER_GAP, getHeight () - BORDER_GAP);
    for (int i = 0;
    i < Y_HATCH_CNT; i ++) {
        int x0 = BORDER_GAP;
        int x1 = GRAPH_POINT_WIDTH + BORDER_GAP;
        int y0 = getHeight () - (((i + 1) * (getHeight () - BORDER_GAP * 2)) / Y_HATCH_CNT + BORDER_GAP);
        int y1 = y0;
        g2.drawLine (x0, y0, x1, y1);
    }
    for (int i = 0;
    i < scores.size () - 1; i ++) {
        int x0 = (i + 1) * (getWidth () - BORDER_GAP * 2) / (scores.size () - 1) + BORDER_GAP;
        int x1 = x0;
        int y0 = getHeight () - BORDER_GAP;
        int y1 = y0 - GRAPH_POINT_WIDTH;
        g2.drawLine (x0, y0, x1, y1);
    }
    Stroke oldStroke = g2.getStroke ();
    g2.setColor (GRAPH_COLOR);
    g2.setStroke (GRAPH_STROKE);
    for (int i = 0;
    i < graphPoints.size () - 1; i ++) {
        int x1 = graphPoints.get (i).x;
        int y1 = graphPoints.get (i).y;
        int x2 = graphPoints.get (i + 1).x;
        int y2 = graphPoints.get (i + 1).y;
        g2.drawLine (x1, y1, x2, y2);
    }
    g2.setStroke (oldStroke);
    g2.setColor (GRAPH_POINT_COLOR);
    for (int i = 0;
    i < graphPoints.size (); i ++) {
        int x = graphPoints.get (i).x - GRAPH_POINT_WIDTH / 2;
        int y = graphPoints.get (i).y - GRAPH_POINT_WIDTH / 2;
        int ovalW = GRAPH_POINT_WIDTH;
        int ovalH = GRAPH_POINT_WIDTH;
        g2.fillOval (x, y, ovalW, ovalH);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8693407_8693422_3_14
8693407_8693515_11_39
Title: Using the String.split() method 
----------------------------------------

public static void main (String [] args) {
    String str = "aaaaaaaaabb";
    String [] s = str.split ("a{3}");
    System.out.println (s.length);
    for (String x : s) {
        if (x == null) System.out.println ("NULL HERE");

        System.out.print (x);
    }
}
----------------------------------------

public static void main (String [] args) {
    strDump ("1,234,567,890".split (","));
    strDump ("1,234,567,890".split ("(?=,)"));
    strDump ("1,234,567,890".split ("(?<=,)"));
    strDump ("1,234,567,890".split ("(?<=,)|(?=,)"));
    strDump (":a:bb::c:".split ("(?=:)|(?<=:)"));
    strDump (":a:bb::c:".split ("(?=(?!^):)|(?<=:)"));
    strDump (":::a::::b  b::c:".split ("(?=(?!^):)(?<!:)|(?!:)(?<=:)"));
    strDump ("a,bb:::c  d..e".split ("(?!^)\\b"));
    strDump ("ArrayIndexOutOfBoundsException".split ("(?<=[a-z])(?=[A-Z])"));
    strDump ("1234567890".split ("(?<=\\G.{4})"));
    strDump ("Boooyaaaah! Yippieeee!!".split ("(?<=(?=(.)\\1(?!\\1))..)"));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8695223_42002276_2_14
8695223_8695692_7_40
Title: Java - For Loop to display all Unique Substrings 
----------------------------------------

public static void main (String args []) {
    String st;
    HashSet < String > hs = new HashSet < String > ();
    Scanner in = new Scanner (System.in);
    st = in.nextLine ();
    int length = st.length ();
    for (int i = 0;
    i < length; i ++) {
        for (int j = i + 1;
        j <= length; j ++) {
            hs.add (st.substring (i, j));
        }
    }
    System.out.println (hs);
}
----------------------------------------

public static void main (String...args) {
    String string, sub;
    ArrayList < String > al = new ArrayList < String > ();
    int i, c, length;
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter a string to print it's all unique substrings:->");
    string = in.nextLine ();
    length = string.length ();
    System.out.print ("Substrings of \"" + string + "\" are :->");
    for (c = 0; c < length; c ++) {
        for (i = 1; i <= length - c; i ++) {
            sub = string.substring (c, c + i);
            al.add (sub);
        }
    }
    HashSet hs = new HashSet ();
    hs.addAll (al);
    al.clear ();
    al.addAll (hs);
    for (String str : al) {
        System.out.println (str);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8708473_8722770_27_42
8708473_8727885_7_18
Title: "Waking up a sleeping thread - interrupt() versus ""splitting"" the sleep into multiple sleeps" 
----------------------------------------

public void startTask () {
    running = true;
    while (running) {
        doSomething ();
        try {
            int count = 0;
            while (running && count ++ < interval) {
                Thread.sleep (1000);
            }
        } catch (InterruptedException e) {
            Thread.currentThread ().interrupt ();
            running = false;
            break;
        }
    }
}
----------------------------------------

public void startTask () {
    while (running) {
        doSomething ();
        synchronized (lockObj) {
            try {
                lockObj.wait (interval * 1000);
            } catch (InterruptedException e) {
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8710719_12072058_13_23
8710719_8710748_2_38
Title: Generating an alphabetic sequence in Java 
----------------------------------------

public static void main (String [] args) {
    String sequence = "";
    for (int i = 0;
    i < 100; i ++) {
        if (i > 0) {
            sequence += ", ";
        }
        sequence += createSequenceElement (i);
    }
    System.out.println (sequence);
}
----------------------------------------

public static void main (String [] args) {
    int seqWidth = 3;
    Double charSetSize = 26d;
    Double total = Math.pow (charSetSize, (new Integer (seqWidth)).doubleValue ());
    StringBuilder [] sbArr = new StringBuilder [total.intValue ()];
    for (int j = 0;
    j < total; j ++) {
        sbArr [j] = new StringBuilder ();
    }
    char ch = 'A';
    for (int k = seqWidth;
    k > 0; k --) {
        for (int l = 1;
        l <= total; l ++) {
            sbArr [l - 1].append (ch);
            if ((l % (Math.pow (charSetSize, k - 1d))) == 0) {
                ch ++;
                if (ch > 'Z') {
                    ch = 'A';
                }
            }
        }
    }
    for (StringBuilder builder : sbArr) {
        System.out.println (builder.toString ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8713253_8713412_1_31
8713253_8713673_12_39
Title: HashMap key with multiple values 
----------------------------------------

public static String detectEquals (String text) {
    String a = null;
    String [] newString = text.split (" ");
    List < String > test = Arrays.asList (newString);
    StringBuilder strBuilder = new StringBuilder ();
    HashMap < String, List < Integer > > signs = new HashMap < String, List < Integer > > ();
    List < Integer > refList = new ArrayList < Integer > ();
    int index = 0;
    for (int i = 0;
    i < test.size (); i ++) {
        a = test.get (i).trim ();
        strBuilder.append (a);
        index = strBuilder.length () - a.length ();
        if (a.equals ("if") || a.equals ("=")) {
            refList = signs.get (a);
            if (refList == null) {
                refList = new ArrayList < Integer > ();
            }
            refList.add (index);
            signs.put (a, refList);
        }
    }
    System.out.println (signs);
    return a;
}
----------------------------------------

public static String detectEquals (String text) {
    String a = null;
    String [] newString = text.split (" ");
    List < Integer > tests = new ArrayList < Integer > ();
    List < Integer > equals = new ArrayList < Integer > ();
    int index = 0;
    for (int i = 0;
    i < newString.length; i ++) {
        a = newString [i].trim ();
        if (a.equals ("if")) {
            tests.add (index);
        } else {
            if (a.equals ("=")) {
                equals.add (index);
            }
        }
        index += newString [i].length ();
    }
    print ("if", tests);
    print ("=", equals);
    return a;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8719473_12317592_1_33
8719473_44723245_1_45
Title: "AffineTransform truncates image what do I wrong?" 
----------------------------------------

public static BufferedImage rotateImage (BufferedImage image, int quadrants) {
    int w0 = image.getWidth ();
    int h0 = image.getHeight ();
    int w1 = w0;
    int h1 = h0;
    int centerX = w0 / 2;
    int centerY = h0 / 2;
    if (quadrants % 2 == 1) {
        w1 = h0;
        h1 = w0;
    }
    if (quadrants % 4 == 1) {
        centerX = h0 / 2;
        centerY = h0 / 2;
    } else if (quadrants % 4 == 3) {
        centerX = w0 / 2;
        centerY = w0 / 2;
    }

    AffineTransform affineTransform = new AffineTransform ();
    affineTransform.setToQuadrantRotation (quadrants, centerX, centerY);
    AffineTransformOp opRotated = new AffineTransformOp (affineTransform, AffineTransformOp.TYPE_BILINEAR);
    BufferedImage transformedImage = new BufferedImage (w1, h1, image.getType ());
    transformedImage = opRotated.filter (image, transformedImage);
    return transformedImage;
}
----------------------------------------

public BufferedImage rotateImage (BufferedImage image, int quadrants) {
    int w0 = image.getWidth ();
    int h0 = image.getHeight ();
    int centerX = w0 / 2;
    int centerY = h0 / 2;
    if (quadrants % 4 == 1) {
        centerX = h0 / 2;
        centerY = h0 / 2;
    } else if (quadrants % 4 == 3) {
        centerX = w0 / 2;
        centerY = w0 / 2;
    }

    AffineTransform affineTransform = new AffineTransform ();
    affineTransform.setToQuadrantRotation (quadrants, centerX, centerY);
    AffineTransformOp opRotated = new AffineTransformOp (affineTransform, AffineTransformOp.TYPE_BILINEAR);
    BufferedImage transformedImage = opRotated.filter (image, null);
    return transformedImage;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8729252_8729305_38_49
8729252_8729305_58_68
Title: Changing Swing GUI Default Look and Feel in real time 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    float newAlpha = softButton1.getAlpha () + incrementer;
    if (newAlpha < 0) {
        newAlpha = 0;
        incrementer = - incrementer;
    } else if (newAlpha > 1f) {
        newAlpha = 1f;
        incrementer = - incrementer;
    }

    softButton1.setAlpha (newAlpha);
    softButton2.setAlpha (newAlpha);
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    try {
        UIManager.setLookAndFeel (laf [index].getClassName ());
        SwingUtilities.updateComponentTreeUI (frame);
        opaqueButton1.setText (laf [index].getClassName ());
        softButton1.setText (laf [index].getClassName ());
    } catch (Exception exc) {
        exc.printStackTrace ();
    }
    index = (index + 1) % laf.length;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8744148_8744314_9_37
8744148_8745459_1_39
Title: Reading text file in java 
----------------------------------------

public static void main (String [] args) {
    Hashtable ht = new Hashtable ();
    try {
        FileInputStream fstream = new FileInputStream ("C:/Users/kiran/Desktop/text.txt");
        DataInputStream in = new DataInputStream (fstream);
        BufferedReader br = new BufferedReader (new InputStreamReader (in));
        String str;
        while ((str = br.readLine ()) != null) {
            String sproof = (String) ht.get (str.trim ());
            if (sproof != null && sproof.equals ("1")) {
                System.out.println (str);
            } else {
                ht.put (str.trim (), "1");
            }
        }
        in.close ();
    } catch (Exception e) {
        System.err.println (e);
    }
}
----------------------------------------

public static void main (String [] args) {
    Map < Integer, Integer > frequency = new HashMap < Integer, Integer > ();
    try {
        FileInputStream fstream = new FileInputStream ("text.txt");
        DataInputStream in = new DataInputStream (fstream);
        BufferedReader br = new BufferedReader (new InputStreamReader (in));
        String str;
        while ((str = br.readLine ()) != null) {
            if (! "".equals (str.trim ())) {
                try {
                    Integer strInt = new Integer (str.trim ());
                    int val = 1;
                    if (frequency.containsKey (strInt)) {
                        val = frequency.get (strInt).intValue () + 1;
                    }
                    frequency.put (strInt, val);
                } catch (Exception e) {
                    System.err.println (e);
                }
            }
        }
        in.close ();
    } catch (Exception e) {
        System.err.println (e);
    }
    for (Integer key : frequency.keySet ()) {
        if (frequency.get (key).intValue () > 1) {
            System.out.println (key);
        }
    }
    for (Integer key : frequency.keySet ()) {
        System.out.println (String.format ("Value: %s, Freq: %s", key, frequency.get (key)));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8758752_8758786_2_22
8758752_8775893_16_32
Title: Reversing an Array 
----------------------------------------

public static void main (String [] args) {
    try {
        int [] arr = new int [5];
        arr [0] = 1;
        arr [1] = 2;
        arr [2] = 3;
        arr [3] = 4;
        arr [4] = 5;
        for (int i = 0;
        i <= arr.length / 2; i ++) {
            int temp = arr [i];
            arr [i] = arr [arr.length - i - 1];
            arr [arr.length - i - 1] = temp;
        }
        for (int i = 0;
        i <= arr.length - 1; i ++) {
            System.out.println (arr [i]);
        }
    } catch (Exception e) {
        System.out.println (e);
    }
}
----------------------------------------

public static void main (String...args) {
    Object [] arr = {1, 2, 3, 4, 5};
    arr = new Main ().reverseArray (arr);
    int newArray [] = new int [arr.length];
    for (int i = 0;
    i < arr.length; i ++) {
        newArray [i] = Integer.valueOf (arr [i].toString ());
    }
    for (int i = 0;
    i < arr.length; i ++) {
        System.out.println (newArray [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
876234_16950263_1_55
876234_876548_1_23
Title: Need a way to scale a font to fit a rectangle 
----------------------------------------

private Font scaleFont (String text, Rectangle rect, Graphics gc) {
    final float fMinimumFont = 0.1f;
    float fMaximumFont = 1000f;
    Point2D.Float lowerPoint = new Point2D.Float (fMinimumFont, getWidthInPixelsOfString (text, fMinimumFont, gc));
    Point2D.Float upperPoint = new Point2D.Float (fMaximumFont, getWidthInPixelsOfString (text, fMaximumFont, gc));
    Point2D.Float midPoint = new Point2D.Float ();
    for (int i = 0;
    i < 50; i ++) {
        float middleFont = (lowerPoint.x + upperPoint.x) / 2;
        midPoint.setLocation (middleFont, getWidthInPixelsOfString (text, middleFont, gc));
        if (midPoint.y >= rect.getWidth () * .95 && midPoint.y <= rect.getWidth ()) break;
        else if (midPoint.y < rect.getWidth ()) lowerPoint.setLocation (midPoint);
        else if (midPoint.y > rect.getWidth ()) upperPoint.setLocation (midPoint);

    }
    fMaximumFont = midPoint.x;
    Font font = gc.getFont ().deriveFont (fMaximumFont);
    lowerPoint.setLocation (fMinimumFont, getHeightInPixelsOfString (text, fMinimumFont, gc));
    upperPoint.setLocation (fMaximumFont, getHeightInPixelsOfString (text, fMaximumFont, gc));
    if (upperPoint.y < rect.getHeight ()) return font;

    for (int i = 0;
    i < 50; i ++) {
        float middleFont = (lowerPoint.x + upperPoint.x) / 2;
        midPoint.setLocation (middleFont, getHeightInPixelsOfString (text, middleFont, gc));
        if (midPoint.y >= rect.getHeight () * .95 && midPoint.y <= rect.getHeight ()) break;
        else if (midPoint.y < rect.getHeight ()) lowerPoint.setLocation (midPoint);
        else if (midPoint.y > rect.getHeight ()) upperPoint.setLocation (midPoint);

    }
    fMaximumFont = midPoint.x;
    font = gc.getFont ().deriveFont (fMaximumFont);
    return font;
}
----------------------------------------

public static Font scaleFont (String text, Rectangle rect, Graphics g, Font pFont) {
    float min = 0.1f;
    float max = 72f;
    float size = 18.0f;
    Font font = pFont;
    while (max - min <= 0.1) {
        font = g.getFont ().deriveFont (size);
        FontMetrics fm = g.getFontMetrics (font);
        int width = fm.stringWidth (text);
        if (width == rect.width) {
            return font;
        } else {
            if (width < rect.width) {
                min = size;
            } else {
                max = size;
            }
            size = Math.min (max, Math.max (min, size * (float) rect.width / (float) width));
        }
    }
    return font;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8769336_8770576_42_60
8769336_9846650_1_21
Title: Drag image from browser to drop onto JLabel 
----------------------------------------

private static TransferHandler createTransferHandler () {
    return new TransferHandler () {
        @Override
        public boolean importData (JComponent comp, Transferable aTransferable) {
            try {
                Object transferData = aTransferable.getTransferData (DataFlavor.imageFlavor);
                TEST_LABEL.setIcon (new ImageIcon ((Image) transferData));
            } catch (UnsupportedFlavorException e) {
            } catch (IOException e) {
            }
            return true;
        }@Override
        public boolean canImport (JComponent comp, DataFlavor [] transferFlavors) {
            return true;
        }}

    ;
}
----------------------------------------

private static TransferHandler createTransferHandler () {
    return new TransferHandler () {
        @Override
        public boolean importData (JComponent comp, Transferable aTransferable) {
            DataFlavor [] transferData = aTransferable.getTransferDataFlavors ();
            for (DataFlavor df : transferData) {
                System.out.println (df.toString ());
            }
            System.out.println ("-----------------------------------");
            return true;
        }@Override
        public boolean canImport (JComponent comp, DataFlavor [] transferFlavors) {
            return true;
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
877587_7333357_178_188
877587_7333357_84_94
Title: "Java Interface: Inheriting Overriding and Overloading Methods" 
----------------------------------------

public static void main (String [] x) {
    CZ o = new CZ ();
    IZR r = o.f ();
    if (CZ.someCondition) {
        CXR xr = (CXR) r;
    } else {
        CYR yr = (CYR) r;
    }
}
----------------------------------------

public static void main (String [] x) {
    CZ o = new CZ ();
    IZR r = o.f ();
    if (CZ.someCondition) {
        CXR xr = (CXR) r;
    } else {
        CYR yr = (CYR) r;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8784333_20946233_11_26
8784333_8785534_3_17
Title: can the main thread die before the child thread 
----------------------------------------

public void run () {
    for (int i = 0;
    i < 5; i ++) {
        System.out.println (thread.getName () + "\t" + (i + 1));
        try {
            Thread.sleep (1000);
        } catch (InterruptedException ie) {
            System.out.println ("Interrupted Exception " + thread.getName ());
        }
        System.out.println ("Is main thread alive " + mainThread.isAlive ());
    }
}
----------------------------------------

public void run () {
    for (int i = 0;
    i < 10; i ++) {
        System.out.println (" child " + i);
        try {
            Thread.sleep (1000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    System.out.println (Thread.currentThread ().getThreadGroup ().activeCount ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8818215_8818284_2_10
8818215_8818312_1_16
Title: "Java main method argument handling depending on user input" 
----------------------------------------

public static void main (String [] args) {
    if (args.length == 0) {
        System.out.println ("No arguments!");
    } else if (args [0].equals ("-i")) {
        System.out.println ("-i passed");
    } else {
        System.out.println ("Something else");
    }

}
----------------------------------------

public static void main (String [] args) {
    if (args.length == 0) {
        System.err.println ("No arguments");
    } else if (args.length == 1) {
        if (args [0].equals ("first")) {
            System.err.println ("The argument equals 'first'");
        } else {
            System.err.println ("Don't know what you want with " + args [0]);
        }
    } else {
        System.err.println ("Will not use the arguments");
        for (String arg : args) {
            System.err.println (arg);
        }
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8826301_8826533_3_20
8826301_8826577_3_21
Title: Solving a difficult equation with two variables in Java 
----------------------------------------

public static void main (String [] args) {
    int found = 0;
    searchSolutions : for (int y = 0;
    y <= 10; y ++) {
        for (int x = 0;
        x <= 10; x ++) {
            if (((x * x) + (y * y) - (12 * x) - (10 * y) + 36) == 0) {
                System.out.println ("(" + x + ", " + y + ")");
                found ++;
                if (found == 3) {
                    break searchSolutions;
                }
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] range = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    boolean isSolutionFound = Boolean.FALSE;
    int solCounter = 0;
    searchSolutions : for (Integer y : range) {
        for (Integer x : range) {
            isSolutionFound = checkForSolution (x, y);
            if (isSolutionFound) {
                printSolution (x, y);
                solCounter ++;
            }
            if (solCounter == 3) break searchSolutions;

        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8829903_8830157_21_63
8829903_8830524_5_39
Title: "How to use Scanner in java to count the number of words seperate by """" from a input .txt file?" 
----------------------------------------

public static void main (String [] args) throws IOException {
    File file = new File ("C:\\test.txt");
    Scanner input = new Scanner (file);
    BufferedReader bufRdr = new BufferedReader (new FileReader (file));
    String line = null;
    int row = 0;
    int col = 0;
    while ((line = bufRdr.readLine ()) != null) {
        while (input.hasNextLine ()) {
            String tmp = input.nextLine ();
            row ++;
        }
        StringTokenizer st = new StringTokenizer (line, ",");
        while (st.hasMoreElements ()) {
            col = Integer.parseInt (st.nextToken ());
        }
    }
    bufRdr.close ();
    String array [] [] = new String [row] [col];
    BufferedReader bufReader = new BufferedReader (new FileReader (file));
    String strLine = null;
    for (int i = 0;
    i < row; i ++) {
        if ((strLine = bufReader.readLine ()) != null) {
            StringTokenizer stringToken = null;
            stringToken = new StringTokenizer (strLine, ",");
            while (stringToken.hasMoreTokens ()) {
                for (int j = 0;
                j < col; j ++) {
                    array [i] [j] = stringToken.nextToken ();
                    System.out.println ("[" + i + "]" + "[" + j + "]:" + array [i] [j]);
                    System.out.println ("******************");
                }
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    File file = new File ("test.txt");
    BufferedReader br = new BufferedReader (new FileReader (file));
    int width = 0, height = 0;
    String line = "";
    while ((line = br.readLine ()) != null) {
        if (width == 0) {
            String [] str = line.split (",");
            width = str.length;
        }
        height ++;
    }
    System.out.println ("Row : " + height);
    System.out.println ("Column : " + width);
    String [] [] data = new String [height] [width];
    br = new BufferedReader (new FileReader (file));
    for (int i = 0;
    i < height; i ++) {
        if ((line = br.readLine ()) != null) {
            for (int j = 0;
            j < width; j ++) {
                String [] str = line.split (",");
                data [i] [j] = str [j];
                System.out.print ("Data[" + i + "][" + j + "] : " + data [i] [j] + " ");
            }
        }
        System.out.println ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8857590_44487027_27_45
8857590_8858608_29_43
Title: Android: CountDownTimer skips last onTick()! 
----------------------------------------

public void run () {
    if (isCanceled) {
        publishUpdate (0);
    } else {
        if (millisUntilFinished <= 0) {
            publishUpdate (0);
            return;
        }
        publishUpdate (millisUntilFinished);
        millisUntilFinished -= countDownInterval;
        mHandler.postDelayed (this, countDownInterval);
    }
}
----------------------------------------

public void run () {
    long sec = millisInFuture / 1000;
    if (status) {
        if (millisInFuture <= 0) {
            Log.v ("status", "done");
        } else {
            Log.v ("status", Long.toString (sec) + " seconds remain");
            millisInFuture -= countDownInterval;
            handler.postDelayed (this, countDownInterval);
        }
    } else {
        Log.v ("status", Long.toString (sec) + " seconds remain and timer has stopped!");
        handler.postDelayed (this, countDownInterval);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8861847_28731932_1_17
8861847_8862029_1_14
Title: Insertion sort algorithm flaw in Java code 
----------------------------------------

public static int [] insertionSort (int [] array) {
    int key;
    int i;
    for (int j = 1;
    j < array.length; j ++) {
        key = array [j];
        i = j;
        while (i > 0 && array [i - 1] < key) {
            array [i] = array [i - 1];
            i = i - 1;
        }
        array [i] = key;
    }
    return array;
}
----------------------------------------

public void insertionSort () {
    int key;
    int i;
    for (int j = 1;
    j < this.a.length; j ++) {
        key = a [j];
        i = j;
        while (i > 0 && a [i - 1] > key) {
            a [i] = a [i - 1];
            i = i - 1;
        }
        a [i] = key;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880342_23_34
8880286_8880928_30_37
Title: Write a program that will surely go into deadlock 
----------------------------------------

public static void main (String [] args) {
    final Friend alphonse = new Friend ("Alphonse");
    final Friend gaston = new Friend ("Gaston");
    new Thread (new Runnable () {
        public void run () {
            alphonse.bow (gaston);
        }}

    ).start ();
    new Thread (new Runnable () {
        public void run () {
            gaston.bow (alphonse);
        }}

    ).start ();
}
----------------------------------------

public static void main (String [] args) {
    Thread [] threads = new Thread [2];
    CountDownLatch latch = new CountDownLatch (threads.length);
    for (int i = 0;
    i < threads.length; ++ i) {
        threads [i] = new Thread (new BadRunnable (latch));
        threads [i].start ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880354_23_34
8880286_8880928_30_37
Title: Write a program that will surely go into deadlock 
----------------------------------------

public static void main (String [] args) {
    final Friend alphonse = new Friend ("Alphonse");
    final Friend gaston = new Friend ("Gaston");
    new Thread (new Runnable () {
        public void run () {
            alphonse.bow (gaston);
        }}

    ).start ();
    new Thread (new Runnable () {
        public void run () {
            gaston.bow (alphonse);
        }}

    ).start ();
}
----------------------------------------

public static void main (String [] args) {
    Thread [] threads = new Thread [2];
    CountDownLatch latch = new CountDownLatch (threads.length);
    for (int i = 0;
    i < threads.length; ++ i) {
        threads [i] = new Thread (new BadRunnable (latch));
        threads [i].start ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880501_17_30
8880286_8880660_16_30
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    String threadName = Thread.currentThread ().getName ();
    try {
        first.lock ();
        latch.countDown ();
        System.out.println (threadName + ": locked first lock");
        latch.await ();
        System.out.println (threadName + ": attempting to lock second lock");
        second.lock ();
        System.out.println (threadName + ": never reached");
    } catch (InterruptedException e) {
        throw new RuntimeException (e);
    }
}
----------------------------------------

public void run () {
    synchronized (obj1) {
        latch.countDown ();
        try {
            latch.await ();
        } catch (InterruptedException e) {
            throw new RuntimeException ();
        }
        synchronized (obj2) {
            System.out.println ("Thread finished");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880501_17_30
8880286_8880928_11_27
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    String threadName = Thread.currentThread ().getName ();
    try {
        first.lock ();
        latch.countDown ();
        System.out.println (threadName + ": locked first lock");
        latch.await ();
        System.out.println (threadName + ": attempting to lock second lock");
        second.lock ();
        System.out.println (threadName + ": never reached");
    } catch (InterruptedException e) {
        throw new RuntimeException (e);
    }
}
----------------------------------------

public void run () {
    System.out.println ("Thread " + Thread.currentThread ().getId () + " starting");
    synchronized (BadRunnable.class) {
        System.out.println ("Thread " + Thread.currentThread ().getId () + " acquired the monitor on BadRunnable.class");
        latch.countDown ();
        while (true) {
            try {
                latch.await ();
            } catch (InterruptedException ex) {
                continue;
            }
            break;
        }
    }
    System.out.println ("Thread " + Thread.currentThread ().getId () + " released the monitor on BadRunnable.class");
    System.out.println ("Thread " + Thread.currentThread ().getId () + " ending");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880501_17_30
8880286_8883630_8_20
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    String threadName = Thread.currentThread ().getName ();
    try {
        first.lock ();
        latch.countDown ();
        System.out.println (threadName + ": locked first lock");
        latch.await ();
        System.out.println (threadName + ": attempting to lock second lock");
        second.lock ();
        System.out.println (threadName + ": never reached");
    } catch (InterruptedException e) {
        throw new RuntimeException (e);
    }
}
----------------------------------------

public void run () {
    System.out.println ("Outer launched");
    System.out.println ("Obtaining lock");
    synchronized (lock) {
        Thread inner = new Thread (new InnerTask (lock), "inner");
        inner.start ();
        try {
            inner.join ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880501_17_30
8880286_9286697_18_26
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    String threadName = Thread.currentThread ().getName ();
    try {
        first.lock ();
        latch.countDown ();
        System.out.println (threadName + ": locked first lock");
        latch.await ();
        System.out.println (threadName + ": attempting to lock second lock");
        second.lock ();
        System.out.println (threadName + ": never reached");
    } catch (InterruptedException e) {
        throw new RuntimeException (e);
    }
}
----------------------------------------

public void run () {
    try {
        Thread t = new Thread (new Lock ());
        t.start ();
        t.join ();
    } catch (InterruptedException ex) {
        System.out.println ("won't see me");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880660_16_30
8880286_8880928_11_27
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    synchronized (obj1) {
        latch.countDown ();
        try {
            latch.await ();
        } catch (InterruptedException e) {
            throw new RuntimeException ();
        }
        synchronized (obj2) {
            System.out.println ("Thread finished");
        }
    }
}
----------------------------------------

public void run () {
    System.out.println ("Thread " + Thread.currentThread ().getId () + " starting");
    synchronized (BadRunnable.class) {
        System.out.println ("Thread " + Thread.currentThread ().getId () + " acquired the monitor on BadRunnable.class");
        latch.countDown ();
        while (true) {
            try {
                latch.await ();
            } catch (InterruptedException ex) {
                continue;
            }
            break;
        }
    }
    System.out.println ("Thread " + Thread.currentThread ().getId () + " released the monitor on BadRunnable.class");
    System.out.println ("Thread " + Thread.currentThread ().getId () + " ending");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880660_16_30
8880286_8883630_8_20
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    synchronized (obj1) {
        latch.countDown ();
        try {
            latch.await ();
        } catch (InterruptedException e) {
            throw new RuntimeException ();
        }
        synchronized (obj2) {
            System.out.println ("Thread finished");
        }
    }
}
----------------------------------------

public void run () {
    System.out.println ("Outer launched");
    System.out.println ("Obtaining lock");
    synchronized (lock) {
        Thread inner = new Thread (new InnerTask (lock), "inner");
        inner.start ();
        try {
            inner.join ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880660_16_30
8880286_9286697_18_26
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    synchronized (obj1) {
        latch.countDown ();
        try {
            latch.await ();
        } catch (InterruptedException e) {
            throw new RuntimeException ();
        }
        synchronized (obj2) {
            System.out.println ("Thread finished");
        }
    }
}
----------------------------------------

public void run () {
    try {
        Thread t = new Thread (new Lock ());
        t.start ();
        t.join ();
    } catch (InterruptedException ex) {
        System.out.println ("won't see me");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880928_11_27
8880286_8883630_8_20
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    System.out.println ("Thread " + Thread.currentThread ().getId () + " starting");
    synchronized (BadRunnable.class) {
        System.out.println ("Thread " + Thread.currentThread ().getId () + " acquired the monitor on BadRunnable.class");
        latch.countDown ();
        while (true) {
            try {
                latch.await ();
            } catch (InterruptedException ex) {
                continue;
            }
            break;
        }
    }
    System.out.println ("Thread " + Thread.currentThread ().getId () + " released the monitor on BadRunnable.class");
    System.out.println ("Thread " + Thread.currentThread ().getId () + " ending");
}
----------------------------------------

public void run () {
    System.out.println ("Outer launched");
    System.out.println ("Obtaining lock");
    synchronized (lock) {
        Thread inner = new Thread (new InnerTask (lock), "inner");
        inner.start ();
        try {
            inner.join ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8880928_11_27
8880286_9286697_18_26
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    System.out.println ("Thread " + Thread.currentThread ().getId () + " starting");
    synchronized (BadRunnable.class) {
        System.out.println ("Thread " + Thread.currentThread ().getId () + " acquired the monitor on BadRunnable.class");
        latch.countDown ();
        while (true) {
            try {
                latch.await ();
            } catch (InterruptedException ex) {
                continue;
            }
            break;
        }
    }
    System.out.println ("Thread " + Thread.currentThread ().getId () + " released the monitor on BadRunnable.class");
    System.out.println ("Thread " + Thread.currentThread ().getId () + " ending");
}
----------------------------------------

public void run () {
    try {
        Thread t = new Thread (new Lock ());
        t.start ();
        t.join ();
    } catch (InterruptedException ex) {
        System.out.println ("won't see me");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8880286_8883630_8_20
8880286_9286697_18_26
Title: Write a program that will surely go into deadlock 
----------------------------------------

public void run () {
    System.out.println ("Outer launched");
    System.out.println ("Obtaining lock");
    synchronized (lock) {
        Thread inner = new Thread (new InnerTask (lock), "inner");
        inner.start ();
        try {
            inner.join ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    try {
        Thread t = new Thread (new Lock ());
        t.start ();
        t.join ();
    } catch (InterruptedException ex) {
        System.out.println ("won't see me");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8891284_24279130_38_64
8891284_24279130_77_103
Title: Java concurrent queue for broadcast? 
----------------------------------------

public void run () {
    StringBuilder sb;
    while (true) {
        sb = getStringBuilder ();
        sb.setLength (0);
        sb.append ("Hello!");
        splitter.flush ();
        sb = getStringBuilder ();
        sb.setLength (0);
        sb.append ("Hi!");
        sb = getStringBuilder ();
        sb.setLength (0);
        sb.append ("Hi again!");
        splitter.flush ();
    }
}
----------------------------------------

public void run () {
    while (true) {
        long avail;
        while ((avail = splitter.availableToPoll (index)) == 0) {
        }
        for (int i = 0;
        i < avail; i ++) {
            StringBuilder sb = splitter.poll (index);
        }
        splitter.donePolling (index);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8896679_8897339_1_21
8896679_8897690_50_59
Title: Map that could be iterated in the order of values 
----------------------------------------

public static void main (String [] args) {
    Map < String, String > map = new HashMap < String, String > () {

        {
            put ("key1", "value1");
            put ("key2", "value3");
            put ("key3", "value4");
            put ("key4", "value2");
        }

    }

    ;
    List < Map.Entry < String, String > > entries = new ArrayList < > (map.entrySet ());
    Collections.sort (entries, new Comparator < Map.Entry < String, String > > () {
        @Override
        public int compare (Entry < String, String > o1, Entry < String, String > o2) {
            if (o1.getValue () == null && o2.getValue () == null) return 0;

            if (o1.getValue () == null) return - 1;

            return - o1.getValue ().compareTo (o2.getValue ());
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SortedValueMap < String, String > svm = SortedValueMap.reverse ();
    svm.put ("foo", "1");
    svm.put ("bar", "3");
    svm.put ("baz", "2");
    System.out.println (Joiner.on (", ").withKeyValueSeparator ("=").join (svm));
    System.out.println (Joiner.on (", ").join (svm.values ()));
    System.out.println (Joiner.on (", ").join (svm.keySet ()));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8897643_8897891_1_22
8897643_8897939_5_24
Title: Setup ShutdownHook and exit application 
----------------------------------------

public static void main (String [] args) {
    String event = "login";
    System.out.printf ("Handling event: %s %s\n", event, getCurrentLogin ());
    sendMessage (event, getCurrentLogin ());
    final CountDownLatch latch = new CountDownLatch (1);
    Runtime.getRuntime ().addShutdownHook (new Thread (new Runnable () {
        @Override
        public void run () {
            String event = "logout";
            System.out.printf ("Handling event: %s %s\n", event, getCurrentLogin ());
            sendMessage (event, getCurrentLogin ());
            latch.countDown ();
        }}

    ));
    latch.await ();
}
----------------------------------------

public static void main (String [] args) throws Exception {
    String event = "login";
    System.out.printf ("Handling event: %s %s\n", event, getCurrentLogin ());
    sendMessage (event, getCurrentLogin ());
    final CountDownLatch latch = new CountDownLatch (1);
    Runtime.getRuntime ().addShutdownHook (new Thread (new Runnable () {
        @Override
        public void run () {
            String event = "logout";
            System.out.printf ("Handling event: %s %s\n", event, getCurrentLogin ());
            sendMessage (event, getCurrentLogin ());
            latch.countDown ();
        }}

    ));
    latch.await (2, TimeUnit.SECONDS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8907229_19144750_27_57
8907229_8907323_39_85
Title: Transport.send(message) not working in the below code.. netbeans gets stuck at the running part. it doesn't proceed furthur.. it hangs there forever 
----------------------------------------

public void send () throws MessagingException {
    Properties props = new Properties ();
    props.put ("mail.transport.protocol", "smtp");
    props.put ("mail.smtp.host", "localhost");
    props.put ("mail.smtp.auth", "false");
    props.put ("mail.debug", "false");
    props.put ("mail.smtp.port", "25");
    Session session = Session.getDefaultInstance (props);
    InternetAddress fromAddress = null;
    InternetAddress toAddress = null;
    Transport transport = session.getTransport ("smtp");
    transport.connect ();
    try {
        Message simpleMessage = new MimeMessage (session);
        fromAddress = new InternetAddress (from);
        toAddress = new InternetAddress (to);
        simpleMessage.setFrom (fromAddress);
        simpleMessage.setRecipient (RecipientType.TO, toAddress);
        simpleMessage.setSubject (subject);
        simpleMessage.setText (text);
        transport.sendMessage (simpleMessage, simpleMessage.getAllRecipients ());
    } catch (MessagingException e) {
        e.printStackTrace ();
    } finally {
        transport.close ();
    }
}
----------------------------------------

public boolean send (FileReader msgFileReader, String from, String to) throws IOException {
    Socket smtpPipe;
    InputStream inn;
    OutputStream outt;
    BufferedReader msg;
    msg = new BufferedReader (msgFileReader);
    smtpPipe = new Socket (mailHost, SMTP_PORT);
    if (smtpPipe == null) {
        return false;
    }
    inn = smtpPipe.getInputStream ();
    outt = smtpPipe.getOutputStream ();
    in = new BufferedReader (new InputStreamReader (inn));
    out = new PrintWriter (new OutputStreamWriter (outt), true);
    if (inn == null || outt == null) {
        System.out.println ("Failed to open streams to socket.");
        return false;
    }
    String initialID = in.readLine ();
    System.out.println (initialID);
    System.out.println ("HELO " + localhost.getHostName ());
    out.println ("HELO " + localhost.getHostName ());
    String welcome = in.readLine ();
    System.out.println (welcome);
    System.out.println ("MAIL From:<" + from + "><![CDATA[");
    out.println ("MAIL From:<" + from + "><![CDATA[");
    String senderOK = in.readLine ();
    System.out.println (senderOK);
    System.out.println ("RCPT TO:<" + to + "><![CDATA[");
    out.println ("RCPT TO:<" + to + "><![CDATA[");
    String recipientOK = in.readLine ();
    System.out.println (recipientOK);
    System.out.println ("DATA");
    out.println ("DATA");
    String line;
    while ((line = msg.readLine ()) != null) {
        out.println (line);
    }
    System.out.println (".");
    out.println (".");
    String acceptedOK = in.readLine ();
    System.out.println (acceptedOK);
    System.out.println ("QUIT");
    out.println ("QUIT");
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8909058_8909243_18_50
8909058_8909712_19_36
Title: JComboBox check that a Select isnt from the program 
----------------------------------------

public void showUI () {
    this.setVisible (true);
    JPanel pane = new JPanel ();
    this.setContentPane (pane);
    final JComboBox combo = new JComboBox ();
    combo.addItemListener (new ItemListener () {
        @Override
        public void itemStateChanged (ItemEvent arg0) {
            if (first) if (arg0.getStateChange () == ItemEvent.SELECTED) {
                System.out.println ("You selected " + combo.getSelectedItem ());
            }

            first = true;
        }}

    );
    ArrayList < String > list = new ArrayList < String > ();
    list.add ("godsf");
    list.add ("södlkf");
    list.add ("ldsjlkfdsj");
    for (String s : list) {
        combo.addItem (s);
    }
    pane.add (combo);
    this.pack ();
}
----------------------------------------

public void showUI () {
    this.setVisible (true);
    JPanel pane = new JPanel ();
    this.setContentPane (pane);
    combo = new JComboBox ();
    refreshBox ();
    pane.add (combo);
    combo.addItemListener (new ItemListener () {
        @Override
        public void itemStateChanged (ItemEvent arg0) {
            if (arg0.getStateChange () == ItemEvent.SELECTED) {
                System.out.println ("You selected " + combo.getSelectedItem ());
            }
        }}

    );
    this.pack ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
891969_892148_1_20
891969_892335_1_14
Title: How do I optimize this method for breaking a string in chunks? 
----------------------------------------

public static List < String > breakStringInChunks (String text, int chunkSize) {
    if (chunkSize < 2) {
        throw new IllegalArgumentException ("Chunk size must be > 1");
    }
    if (null == text || text.isEmpty ()) {
        return Collections.emptyList ();
    }
    List < String > chunks = new ArrayList < String > (1 + (text.length () / chunkSize));
    int length = text.length () - (text.length () % chunkSize);
    for (int i = 0;
    i < length;) {
        chunks.add (text.substring (i, i += chunkSize));
    }
    if (length < text.length ()) chunks.add (text.substring (length));

    return chunks;
}
----------------------------------------

private List < String > breakStringInChunks (String text, int chunkSize) {
    List < String > chunks = new ArrayList < String > ();
    while (text.length () > 0) {
        if (chunkSize > text.length ()) {
            chunkSize = text.length ();
        }
        chunks.add (text.substring (0, chunkSize));
        text = text.substring (chunkSize);
    }
    return chunks;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
891969_892148_1_20
891969_893703_35_43
Title: How do I optimize this method for breaking a string in chunks? 
----------------------------------------

public static List < String > breakStringInChunks (String text, int chunkSize) {
    if (chunkSize < 2) {
        throw new IllegalArgumentException ("Chunk size must be > 1");
    }
    if (null == text || text.isEmpty ()) {
        return Collections.emptyList ();
    }
    List < String > chunks = new ArrayList < String > (1 + (text.length () / chunkSize));
    int length = text.length () - (text.length () % chunkSize);
    for (int i = 0;
    i < length;) {
        chunks.add (text.substring (i, i += chunkSize));
    }
    if (length < text.length ()) chunks.add (text.substring (length));

    return chunks;
}
----------------------------------------

private List < String > breakStringInChunks (String text, int chunkSize) {
    if (text.isEmpty ()) return Collections.emptyList ();

    int n = (text.length () + chunkSize - 1) / chunkSize;
    List < String > chunks = new ArrayList < String > (n);
    for (int i = 0;
    i < n; ++ i) chunks.add (text.substring (i * chunkSize, Math.min ((i + 1) * chunkSize, text.length ())));

    return chunks;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
891969_892335_1_14
891969_893703_35_43
Title: How do I optimize this method for breaking a string in chunks? 
----------------------------------------

private List < String > breakStringInChunks (String text, int chunkSize) {
    List < String > chunks = new ArrayList < String > ();
    while (text.length () > 0) {
        if (chunkSize > text.length ()) {
            chunkSize = text.length ();
        }
        chunks.add (text.substring (0, chunkSize));
        text = text.substring (chunkSize);
    }
    return chunks;
}
----------------------------------------

private List < String > breakStringInChunks (String text, int chunkSize) {
    if (text.isEmpty ()) return Collections.emptyList ();

    int n = (text.length () + chunkSize - 1) / chunkSize;
    List < String > chunks = new ArrayList < String > (n);
    for (int i = 0;
    i < n; ++ i) chunks.add (text.substring (i * chunkSize, Math.min ((i + 1) * chunkSize, text.length ())));

    return chunks;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8924599_26602618_1_15
8924599_8924682_1_20
Title: how to count the exact number of words in a string that has empty spaces between words? 
----------------------------------------

public static int wordCount (String s) {
    int counter = 0;
    for (int i = 0;
    i <= s.length () - 1; i ++) {
        if (Character.isLetter (s.charAt (i))) {
            counter ++;
            for (; i <= s.length () - 1; i ++) {
                if (s.charAt (i) == ' ') {
                    i ++;
                    break;
                }
            }
        }
    }
    return counter;
}
----------------------------------------

public static int wordCount (String s) {
    int counter = 0;
    for (int i = 0;
    i <= s.length () - 1; i ++) {
        if (Character.isLetter (s.charAt (i))) {
            counter ++;
            for (; i <= s.length () - 1; i ++) {
                if (s.charAt (i) == ' ') {
                    counter ++;
                    i ++;
                    while (s.charAt (i) == ' ') i ++;

                }
            }
        }
    }
    return counter;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8927725_8928148_1_29
8927725_8928238_1_18
Title: My Random Sudoku Generator Keeps Stalling 
----------------------------------------

boolean allTaken (int row, int column, int [] [] slot) {
    Set < Integer > taken = Collections.emptySet ();
    for (int x = 0;
    x < 9; x ++) {
        taken.add (slot [row] [x]);
    }
    for (int y = 0;
    y < 9; y ++) {
        taken.add (slot [y] [column]);
    }
    int sx = (row / 3) * 3;
    int sy = (column / 3) * 3;
    for (int dx = 0;
    dx < 3; dx ++) {
        for (int dy = 0;
        dy < 3; dy ++) {
            taken.add (slot [sx + dx] [sy + dy]);
        }
    }
    return taken.size () == 10;
}
----------------------------------------

public static boolean allTaken (int row, int column, int [] [] slot) {
    int z = 0;
    boolean [] taken = new boolean [10];
    for (int x = 0;
    x < 9; x ++) {
        taken [slot [row] [x]] = true;
    }
    for (int x = 0;
    x < 9; x ++) {
        taken [slot [x] [column]] = true;
    }
    boolean f = true;
    for (boolean b : taken) f = f && b;

    return f;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8935367_8935384_1_18
8935367_8935416_1_11
Title: Convert a 2D array into a 1D array 
----------------------------------------

public static int mode (int [] [] arr) {
    List < Integer > list = new ArrayList < Integer > ();
    for (int i = 0;
    i < arr.length; i ++) {
        for (int j = 0;
        j < arr [i].length; j ++) {
            list.add (arr [i] [j]);
        }
    }
    int [] vector = new int [list.size ()];
    for (int i = 0;
    i < vector.length; i ++) {
        vector [i] = list.get (i);
    }
}
----------------------------------------

public static int mode (int [] [] arr) {
    int [] oneDArray = new int [arr.length * arr.length];
    for (int i = 0;
    i < arr.length; i ++) {
        for (int s = 0;
        s < arr.length; s ++) {
            oneDArray [(i * arr.length) + s] = arr [i] [s];
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8938235_8938300_5_15
8938235_8938322_1_22
Title: Sort an array in Java 
----------------------------------------

public static void main (String args []) {
    int [] array = new int [10];
    for (int i = 0;
    i < array.length; i ++) {
        array [i] = ((int) (Math.random () * 100 + 1));
    }
    Arrays.sort (array);
    for (int i = 0;
    i < array.length; i ++) {
        System.out.println (array [i]);
    }
}
----------------------------------------

public static void main (String args []) {
    int [] array = new int [10];
    array [0] = ((int) (Math.random () * 100 + 1));
    array [1] = ((int) (Math.random () * 100 + 1));
    array [2] = ((int) (Math.random () * 100 + 1));
    array [3] = ((int) (Math.random () * 100 + 1));
    array [4] = ((int) (Math.random () * 100 + 1));
    array [5] = ((int) (Math.random () * 100 + 1));
    array [6] = ((int) (Math.random () * 100 + 1));
    array [7] = ((int) (Math.random () * 100 + 1));
    array [8] = ((int) (Math.random () * 100 + 1));
    array [9] = ((int) (Math.random () * 100 + 1));
    Arrays.sort (array);
    System.out.println (array [0] + " " + array [1] + " " + array [2] + " " + array [3] + " " + array [4] + " " + array [5] + " " + array [6] + " " + array [7] + " " + array [8] + " " + array [9]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8952585_8952680_1_17
8952585_8952788_1_14
Title: Check for duplicates while populating an array 
----------------------------------------

public void populateArray () {
    boolean OK = true;
    int i = 0;
    while (i < numberLine.length) {
        randomNumber = 1 + randomGen.nextInt (49);
        for (int j = 0;
        j < i; j ++) if (numberLine [j] == randomNumber) OK = false;

        if (OK) {
            numberLine [i] = randomNumber;
            i ++;
        }
        OK = true;
    }
    Arrays.sort (numberLine);
}
----------------------------------------

public void populateArray () {
    List < Integer > pool = new ArrayList < Integer > ();
    for (int i = 0;
    i < 49; ++ i) {
        pool.add (i + 1);
    }
    for (int i = 0;
    i < 6; ++ i) {
        randomNumber = randomGen.nextInt (pool.size ());
        numberLine [i] = pool.get (randomNumber);
        pool.remove (randomNumber);
    }
    Arrays.sort (numberLine);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_19597559_3_17
8965006_34328079_1_18
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    int n = 10000;
    BigInteger [] vec = new BigInteger [n];
    vec [0] = BigInteger.ZERO;
    vec [1] = BigInteger.ONE;
    for (int i = 2;
    i < n; i ++) {
        vec [i] = vec [i - 1].add (vec [i - 2]);
    }
    for (int i = vec.length - 1;
    i >= 0; i --) {
        System.out.println (vec [i]);
        System.out.println ("");
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("This program lists the Fibonacci sequence.");
    int answer = 0;
    int startValue = 1;
    int sum = 0;
    while (answer < 10000) {
        System.out.println (answer);
        sum = add (answer, startValue);
        startValue = answer;
        answer = sum;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_19597559_3_17
8965006_38372425_3_20
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    int n = 10000;
    BigInteger [] vec = new BigInteger [n];
    vec [0] = BigInteger.ZERO;
    vec [1] = BigInteger.ONE;
    for (int i = 2;
    i < n; i ++) {
        vec [i] = vec [i - 1].add (vec [i - 2]);
    }
    for (int i = vec.length - 1;
    i >= 0; i --) {
        System.out.println (vec [i]);
        System.out.println ("");
    }
}
----------------------------------------

public static void main (String [] args) {
    int n = 10;
    if (n == 1) {
        System.out.println (1);
    } else if (n == 2) {
        System.out.println (1);
        System.out.println (1);
    } else {
        System.out.println (1);
        System.out.println (1);
        int currentNo = 3;
        calFibRec (n, 1, 1, currentNo);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_19597559_3_17
8965006_44691479_6_47
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    int n = 10000;
    BigInteger [] vec = new BigInteger [n];
    vec [0] = BigInteger.ZERO;
    vec [1] = BigInteger.ONE;
    for (int i = 2;
    i < n; i ++) {
        vec [i] = vec [i - 1].add (vec [i - 2]);
    }
    for (int i = vec.length - 1;
    i >= 0; i --) {
        System.out.println (vec [i]);
        System.out.println ("");
    }
}
----------------------------------------

public static void main (String args []) {
    int num = 20;
    System.out.println ("By For Loop");
    Long startTimeForLoop = System.nanoTime ();
    int fibSeries [] = fib (num);
    for (int i = 0;
    i < fibSeries.length; i ++) {
        System.out.print (" " + fibSeries [i] + " ");
    }
    Long stopTimeForLoop = System.nanoTime ();
    System.out.println ("");
    System.out.println ("For Loop Time:" + (stopTimeForLoop - startTimeForLoop));
    System.out.println ("By Using Recursion");
    Long startTimeRecursion = System.nanoTime ();
    int fibSeriesRec [] = fibByRec (num);
    for (int i = 0;
    i < fibSeriesRec.length; i ++) {
        System.out.print (" " + fibSeriesRec [i] + " ");
    }
    Long stopTimeRecursion = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Recursion Time:" + (stopTimeRecursion - startTimeRecursion));
    System.out.println ("By Using Memoization Technique");
    Long startTimeMemo = System.nanoTime ();
    fibMemo = new int [num];
    fibByRecMemo (num - 1);
    for (int i = 0;
    i < fibMemo.length; i ++) {
        System.out.print (" " + fibMemo [i] + " ");
    }
    Long stopTimeMemo = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Memoization Time:" + (stopTimeMemo - startTimeMemo));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_19597559_3_17
8965006_44811131_3_16
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    int n = 10000;
    BigInteger [] vec = new BigInteger [n];
    vec [0] = BigInteger.ZERO;
    vec [1] = BigInteger.ONE;
    for (int i = 2;
    i < n; i ++) {
        vec [i] = vec [i - 1].add (vec [i - 2]);
    }
    for (int i = vec.length - 1;
    i >= 0; i --) {
        System.out.println (vec [i]);
        System.out.println ("");
    }
}
----------------------------------------

public static void main (String...a) {
    int x [] = new int [15];
    x [0] = 0;
    x [1] = 1;
    for (int i = 2;
    i < x.length; i ++) {
        x [i] = x [i - 1] + x [i - 2];
    }
    for (int i = 0;
    i < x.length; i ++) {
        System.out.println (x [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_19597559_3_17
8965006_45433244_3_11
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    int n = 10000;
    BigInteger [] vec = new BigInteger [n];
    vec [0] = BigInteger.ZERO;
    vec [1] = BigInteger.ONE;
    for (int i = 2;
    i < n; i ++) {
        vec [i] = vec [i - 1].add (vec [i - 2]);
    }
    for (int i = vec.length - 1;
    i >= 0; i --) {
        System.out.println (vec [i]);
        System.out.println ("");
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int N = scanner.nextInt ();
    for (int i = 0;
    i <= N; i ++) {
        int result = fibonacciSeries (i);
        System.out.println (result);
    }
    scanner.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_30423376_8_20
8965006_49691941_14_29
Title: Java recursive Fibonacci sequence 
----------------------------------------

public int findFibonacciValue (int number) {
    if (number == 0 || number == 1) {
        return number;
    } else if (map.containsKey (number)) {
        return map.get (number);
    } else {
        int fibonacciValue = findFibonacciValue (number - 2) + findFibonacciValue (number - 1);
        map.put (number, fibonacciValue);
        return fibonacciValue;
    }

}
----------------------------------------

public static long findFibonacciValue (long number) {
    if (number <= 1) {
        if (number == 0) {
            map.put (number, 0L);
            return 0L;
        }
        map.put (number, 1L);
        return 1L;
    } else if (map.containsKey (number)) {
        return map.get (number);
    } else {
        long fibonacciValue = findFibonacciValue (number - 1L) + findFibonacciValue (number - 2L);
        map.put (number, fibonacciValue);
        return fibonacciValue;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_31340261_1_14
8965006_44691479_94_111
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static long fib (int n) {
    long population = 0;
    if ((n == 0) || (n == 1)) {
        return n;
    } else {
        population += fib (n - 1) + fib (n - 2);
    }
    return population;
}
----------------------------------------

public static int [] fib (int num) {
    int fibSum [] = new int [num];
    for (int i = 0;
    i < num; i ++) {
        if (i == 0) {
            fibSum [i] = i;
            continue;
        }
        if (i == 1 || i == 2) {
            fibSum [i] = 1;
            continue;
        }
        fibSum [i] = fibSum [i - 1] + fibSum [i - 2];
    }
    return fibSum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_31340261_1_14
8965006_50213235_1_10
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static long fib (int n) {
    long population = 0;
    if ((n == 0) || (n == 1)) {
        return n;
    } else {
        population += fib (n - 1) + fib (n - 2);
    }
    return population;
}
----------------------------------------

public int fib (int index) {
    int tmp = 0, step1 = 0, step2 = 1, fibNumber = 0;
    while (tmp < index - 1) {
        fibNumber = step1 + step2;
        step1 = step2;
        step2 = fibNumber;
        tmp += 1;
    }
    return fibNumber;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_34328079_1_18
8965006_38372425_3_20
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    System.out.println ("This program lists the Fibonacci sequence.");
    int answer = 0;
    int startValue = 1;
    int sum = 0;
    while (answer < 10000) {
        System.out.println (answer);
        sum = add (answer, startValue);
        startValue = answer;
        answer = sum;
    }
}
----------------------------------------

public static void main (String [] args) {
    int n = 10;
    if (n == 1) {
        System.out.println (1);
    } else if (n == 2) {
        System.out.println (1);
        System.out.println (1);
    } else {
        System.out.println (1);
        System.out.println (1);
        int currentNo = 3;
        calFibRec (n, 1, 1, currentNo);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_34328079_1_18
8965006_44691479_6_47
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    System.out.println ("This program lists the Fibonacci sequence.");
    int answer = 0;
    int startValue = 1;
    int sum = 0;
    while (answer < 10000) {
        System.out.println (answer);
        sum = add (answer, startValue);
        startValue = answer;
        answer = sum;
    }
}
----------------------------------------

public static void main (String args []) {
    int num = 20;
    System.out.println ("By For Loop");
    Long startTimeForLoop = System.nanoTime ();
    int fibSeries [] = fib (num);
    for (int i = 0;
    i < fibSeries.length; i ++) {
        System.out.print (" " + fibSeries [i] + " ");
    }
    Long stopTimeForLoop = System.nanoTime ();
    System.out.println ("");
    System.out.println ("For Loop Time:" + (stopTimeForLoop - startTimeForLoop));
    System.out.println ("By Using Recursion");
    Long startTimeRecursion = System.nanoTime ();
    int fibSeriesRec [] = fibByRec (num);
    for (int i = 0;
    i < fibSeriesRec.length; i ++) {
        System.out.print (" " + fibSeriesRec [i] + " ");
    }
    Long stopTimeRecursion = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Recursion Time:" + (stopTimeRecursion - startTimeRecursion));
    System.out.println ("By Using Memoization Technique");
    Long startTimeMemo = System.nanoTime ();
    fibMemo = new int [num];
    fibByRecMemo (num - 1);
    for (int i = 0;
    i < fibMemo.length; i ++) {
        System.out.print (" " + fibMemo [i] + " ");
    }
    Long stopTimeMemo = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Memoization Time:" + (stopTimeMemo - startTimeMemo));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_34328079_1_18
8965006_44811131_3_16
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    System.out.println ("This program lists the Fibonacci sequence.");
    int answer = 0;
    int startValue = 1;
    int sum = 0;
    while (answer < 10000) {
        System.out.println (answer);
        sum = add (answer, startValue);
        startValue = answer;
        answer = sum;
    }
}
----------------------------------------

public static void main (String...a) {
    int x [] = new int [15];
    x [0] = 0;
    x [1] = 1;
    for (int i = 2;
    i < x.length; i ++) {
        x [i] = x [i - 1] + x [i - 2];
    }
    for (int i = 0;
    i < x.length; i ++) {
        System.out.println (x [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_34328079_1_18
8965006_45433244_3_11
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    System.out.println ("This program lists the Fibonacci sequence.");
    int answer = 0;
    int startValue = 1;
    int sum = 0;
    while (answer < 10000) {
        System.out.println (answer);
        sum = add (answer, startValue);
        startValue = answer;
        answer = sum;
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int N = scanner.nextInt ();
    for (int i = 0;
    i <= N; i ++) {
        int result = fibonacciSeries (i);
        System.out.println (result);
    }
    scanner.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_38372425_3_20
8965006_44691479_6_47
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String [] args) {
    int n = 10;
    if (n == 1) {
        System.out.println (1);
    } else if (n == 2) {
        System.out.println (1);
        System.out.println (1);
    } else {
        System.out.println (1);
        System.out.println (1);
        int currentNo = 3;
        calFibRec (n, 1, 1, currentNo);
    }

}
----------------------------------------

public static void main (String args []) {
    int num = 20;
    System.out.println ("By For Loop");
    Long startTimeForLoop = System.nanoTime ();
    int fibSeries [] = fib (num);
    for (int i = 0;
    i < fibSeries.length; i ++) {
        System.out.print (" " + fibSeries [i] + " ");
    }
    Long stopTimeForLoop = System.nanoTime ();
    System.out.println ("");
    System.out.println ("For Loop Time:" + (stopTimeForLoop - startTimeForLoop));
    System.out.println ("By Using Recursion");
    Long startTimeRecursion = System.nanoTime ();
    int fibSeriesRec [] = fibByRec (num);
    for (int i = 0;
    i < fibSeriesRec.length; i ++) {
        System.out.print (" " + fibSeriesRec [i] + " ");
    }
    Long stopTimeRecursion = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Recursion Time:" + (stopTimeRecursion - startTimeRecursion));
    System.out.println ("By Using Memoization Technique");
    Long startTimeMemo = System.nanoTime ();
    fibMemo = new int [num];
    fibByRecMemo (num - 1);
    for (int i = 0;
    i < fibMemo.length; i ++) {
        System.out.print (" " + fibMemo [i] + " ");
    }
    Long stopTimeMemo = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Memoization Time:" + (stopTimeMemo - startTimeMemo));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_38372425_3_20
8965006_44811131_3_16
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String [] args) {
    int n = 10;
    if (n == 1) {
        System.out.println (1);
    } else if (n == 2) {
        System.out.println (1);
        System.out.println (1);
    } else {
        System.out.println (1);
        System.out.println (1);
        int currentNo = 3;
        calFibRec (n, 1, 1, currentNo);
    }

}
----------------------------------------

public static void main (String...a) {
    int x [] = new int [15];
    x [0] = 0;
    x [1] = 1;
    for (int i = 2;
    i < x.length; i ++) {
        x [i] = x [i - 1] + x [i - 2];
    }
    for (int i = 0;
    i < x.length; i ++) {
        System.out.println (x [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_38372425_3_20
8965006_45433244_3_11
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String [] args) {
    int n = 10;
    if (n == 1) {
        System.out.println (1);
    } else if (n == 2) {
        System.out.println (1);
        System.out.println (1);
    } else {
        System.out.println (1);
        System.out.println (1);
        int currentNo = 3;
        calFibRec (n, 1, 1, currentNo);
    }

}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int N = scanner.nextInt ();
    for (int i = 0;
    i <= N; i ++) {
        int result = fibonacciSeries (i);
        System.out.println (result);
    }
    scanner.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_44691479_6_47
8965006_44811131_3_16
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    int num = 20;
    System.out.println ("By For Loop");
    Long startTimeForLoop = System.nanoTime ();
    int fibSeries [] = fib (num);
    for (int i = 0;
    i < fibSeries.length; i ++) {
        System.out.print (" " + fibSeries [i] + " ");
    }
    Long stopTimeForLoop = System.nanoTime ();
    System.out.println ("");
    System.out.println ("For Loop Time:" + (stopTimeForLoop - startTimeForLoop));
    System.out.println ("By Using Recursion");
    Long startTimeRecursion = System.nanoTime ();
    int fibSeriesRec [] = fibByRec (num);
    for (int i = 0;
    i < fibSeriesRec.length; i ++) {
        System.out.print (" " + fibSeriesRec [i] + " ");
    }
    Long stopTimeRecursion = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Recursion Time:" + (stopTimeRecursion - startTimeRecursion));
    System.out.println ("By Using Memoization Technique");
    Long startTimeMemo = System.nanoTime ();
    fibMemo = new int [num];
    fibByRecMemo (num - 1);
    for (int i = 0;
    i < fibMemo.length; i ++) {
        System.out.print (" " + fibMemo [i] + " ");
    }
    Long stopTimeMemo = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Memoization Time:" + (stopTimeMemo - startTimeMemo));
}
----------------------------------------

public static void main (String...a) {
    int x [] = new int [15];
    x [0] = 0;
    x [1] = 1;
    for (int i = 2;
    i < x.length; i ++) {
        x [i] = x [i - 1] + x [i - 2];
    }
    for (int i = 0;
    i < x.length; i ++) {
        System.out.println (x [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_44691479_6_47
8965006_45433244_3_11
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String args []) {
    int num = 20;
    System.out.println ("By For Loop");
    Long startTimeForLoop = System.nanoTime ();
    int fibSeries [] = fib (num);
    for (int i = 0;
    i < fibSeries.length; i ++) {
        System.out.print (" " + fibSeries [i] + " ");
    }
    Long stopTimeForLoop = System.nanoTime ();
    System.out.println ("");
    System.out.println ("For Loop Time:" + (stopTimeForLoop - startTimeForLoop));
    System.out.println ("By Using Recursion");
    Long startTimeRecursion = System.nanoTime ();
    int fibSeriesRec [] = fibByRec (num);
    for (int i = 0;
    i < fibSeriesRec.length; i ++) {
        System.out.print (" " + fibSeriesRec [i] + " ");
    }
    Long stopTimeRecursion = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Recursion Time:" + (stopTimeRecursion - startTimeRecursion));
    System.out.println ("By Using Memoization Technique");
    Long startTimeMemo = System.nanoTime ();
    fibMemo = new int [num];
    fibByRecMemo (num - 1);
    for (int i = 0;
    i < fibMemo.length; i ++) {
        System.out.print (" " + fibMemo [i] + " ");
    }
    Long stopTimeMemo = System.nanoTime ();
    System.out.println ("");
    System.out.println ("Memoization Time:" + (stopTimeMemo - startTimeMemo));
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int N = scanner.nextInt ();
    for (int i = 0;
    i <= N; i ++) {
        int result = fibonacciSeries (i);
        System.out.println (result);
    }
    scanner.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_44691479_94_111
8965006_50213235_1_10
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static int [] fib (int num) {
    int fibSum [] = new int [num];
    for (int i = 0;
    i < num; i ++) {
        if (i == 0) {
            fibSum [i] = i;
            continue;
        }
        if (i == 1 || i == 2) {
            fibSum [i] = 1;
            continue;
        }
        fibSum [i] = fibSum [i - 1] + fibSum [i - 2];
    }
    return fibSum;
}
----------------------------------------

public int fib (int index) {
    int tmp = 0, step1 = 0, step2 = 1, fibNumber = 0;
    while (tmp < index - 1) {
        fibNumber = step1 + step2;
        step1 = step2;
        step2 = fibNumber;
        tmp += 1;
    }
    return fibNumber;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8965006_44811131_3_16
8965006_45433244_3_11
Title: Java recursive Fibonacci sequence 
----------------------------------------

public static void main (String...a) {
    int x [] = new int [15];
    x [0] = 0;
    x [1] = 1;
    for (int i = 2;
    i < x.length; i ++) {
        x [i] = x [i - 1] + x [i - 2];
    }
    for (int i = 0;
    i < x.length; i ++) {
        System.out.println (x [i]);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int N = scanner.nextInt ();
    for (int i = 0;
    i <= N; i ++) {
        int result = fibonacciSeries (i);
        System.out.println (result);
    }
    scanner.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8976057_8976105_13_21
8976057_8976169_8_22
Title: Is this java class thread safe? 
----------------------------------------

public void add (int i) {
    synchronized (event1) {
        event1.wait ();
    }
    sum += i;
    synchronized (event2) {
        event2.notify ();
    }
}
----------------------------------------

public void add (int i) {
    lock.lock ();
    try {
        if (sum != 0) {
            multiplication.await ();
        }
        sum += i;
        addition.signal ();
    } finally {
        lock.unlock ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8976057_8976105_13_21
8976057_8976213_1_9
Title: Is this java class thread safe? 
----------------------------------------

public void add (int i) {
    synchronized (event1) {
        event1.wait ();
    }
    sum += i;
    synchronized (event2) {
        event2.notify ();
    }
}
----------------------------------------

public void add (int i) {
    synchronized (this) {
        while (! b) {
            try {
                wait ();
            } catch (InterruptedException e) {
            }
        }
        sum += i;
        b = true;
        notify ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8976057_8976105_23_31
8976057_8976169_24_34
Title: Is this java class thread safe? 
----------------------------------------

public void mul (int i) {
    synchronized (event2) {
        event2.wait ();
    }
    sum *= i;
    synchronized (event1) {
        event1.notify ();
    }
}
----------------------------------------

public void mul (int i) {
    lock.lock ();
    try {
        addition.await ();
        sum *= i;
        multiplication.signal ();
    } finally {
        lock.unlock ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8976057_8976105_23_31
8976057_8976213_11_18
Title: Is this java class thread safe? 
----------------------------------------

public void mul (int i) {
    synchronized (event2) {
        event2.wait ();
    }
    sum *= i;
    synchronized (event1) {
        event1.notify ();
    }
}
----------------------------------------

public void mul (int i) {
    synchronized (this) {
        while (b) {
            try {
                wait ();
            } catch (InterruptedException e) {
            }
        }
        sum *= i;
        b = false;
        notify ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8976057_8976169_24_34
8976057_8976213_11_18
Title: Is this java class thread safe? 
----------------------------------------

public void mul (int i) {
    lock.lock ();
    try {
        addition.await ();
        sum *= i;
        multiplication.signal ();
    } finally {
        lock.unlock ();
    }
}
----------------------------------------

public void mul (int i) {
    synchronized (this) {
        while (b) {
            try {
                wait ();
            } catch (InterruptedException e) {
            }
        }
        sum *= i;
        b = false;
        notify ();
    }
}
----------------------------------------
