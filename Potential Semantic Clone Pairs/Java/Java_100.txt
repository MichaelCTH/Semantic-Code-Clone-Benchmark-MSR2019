$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_30518998_1_12
4138827_50087122_1_12
Title: Check string for palindrome 
----------------------------------------

public boolean isPalindrome (String abc) {
    if (abc != null && abc.length () > 0) {
        char [] arr = abc.toCharArray ();
        for (int i = 0;
        i < arr.length / 2; i ++) {
            if (arr [i] != arr [arr.length - 1 - i]) {
                return false;
            }
        }
        return true;
    }
    return false;
}
----------------------------------------

public boolean isPalindrome (String input) {
    char [] inputChars = input.toCharArray ();
    int inputLength = inputChars.length;
    int inputMid = inputLength / 2;
    for (int i = 0;
    i <= inputMid; i ++) {
        if (inputChars [i] != inputChars [inputLength - i - 1]) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_30518998_1_12
4138827_53577305_1_11
Title: Check string for palindrome 
----------------------------------------

public boolean isPalindrome (String abc) {
    if (abc != null && abc.length () > 0) {
        char [] arr = abc.toCharArray ();
        for (int i = 0;
        i < arr.length / 2; i ++) {
            if (arr [i] != arr [arr.length - 1 - i]) {
                return false;
            }
        }
        return true;
    }
    return false;
}
----------------------------------------

public static boolean isPalindrome (Object obj) {
    String s = String.valueOf (obj);
    for (int left = 0, right = s.length () - 1;
    left < right; left ++, right --) {
        if (s.charAt (left ++) != s.charAt (right --)) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_34081338_6_44
4138827_41305719_4_30
Title: Check string for palindrome 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    String str = in.nextLine ();
    int x = str.length ();
    if (x % 2 != 0) {
        for (int i = 0;
        i < x / 2; i ++) {
            if (str.charAt (i) == str.charAt (x - 1 - i)) {
                continue;
            } else {
                System.out.println ("String is not a palindrom");
                break;
            }
        }
    } else {
        for (int i = 0;
        i <= x / 2; i ++) {
            if (str.charAt (i) == str.charAt (x - 1 - i)) {
                continue;
            } else {
                System.out.println ("String is not a palindrom");
                break;
            }
        }
    }
}
----------------------------------------

public static void main (String args []) {
    String original, reverse = "";
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter How Many number of Input you want : ");
    int numOfInt = in.nextInt ();
    original = in.nextLine ();
    do {
        if (numOfInt == 0) {
            System.out.println ("Your Input Conplete");
        } else {
            System.out.println ("Enter a string to check palindrome");
            original = in.nextLine ();
            StringBuffer buffer = new StringBuffer (original);
            reverse = buffer.reverse ().toString ();
            if (original.equalsIgnoreCase (reverse)) {
                System.out.println ("The entered string is Palindrome:" + reverse);
            } else {
                System.out.println ("The entered string is not Palindrome:" + reverse);
            }
        }
        numOfInt --;
    } while (numOfInt >= 0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_34081338_6_44
4138827_43512842_10_23
Title: Check string for palindrome 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    String str = in.nextLine ();
    int x = str.length ();
    if (x % 2 != 0) {
        for (int i = 0;
        i < x / 2; i ++) {
            if (str.charAt (i) == str.charAt (x - 1 - i)) {
                continue;
            } else {
                System.out.println ("String is not a palindrom");
                break;
            }
        }
    } else {
        for (int i = 0;
        i <= x / 2; i ++) {
            if (str.charAt (i) == str.charAt (x - 1 - i)) {
                continue;
            } else {
                System.out.println ("String is not a palindrom");
                break;
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    String str = in.nextLine ();
    str.replaceAll ("\\s+", "");
    Stack < String > stack = new Stack < String > ();
    stack.push (str);
    String str_rev = stack.pop ();
    if (str.equals (str_rev)) {
        System.out.println ("Palindrome");
    } else {
        System.out.println ("Not Palindrome");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_34081338_6_44
4138827_48009569_5_22
Title: Check string for palindrome 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    String str = in.nextLine ();
    int x = str.length ();
    if (x % 2 != 0) {
        for (int i = 0;
        i < x / 2; i ++) {
            if (str.charAt (i) == str.charAt (x - 1 - i)) {
                continue;
            } else {
                System.out.println ("String is not a palindrom");
                break;
            }
        }
    } else {
        for (int i = 0;
        i <= x / 2; i ++) {
            if (str.charAt (i) == str.charAt (x - 1 - i)) {
                continue;
            } else {
                System.out.println ("String is not a palindrom");
                break;
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    String s = "madam";
    String t = "";
    for (int i = s.length () - 1;
    i >= 0; i --) {
        t = t + s.charAt (i);
    }
    System.out.println ("reversed word is " + t);
    if (t.matches (s)) {
        System.out.println ("pallindrome");
    } else {
        System.out.println ("not pallindrome");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_37451272_1_11
4138827_40329718_1_14
Title: Check string for palindrome 
----------------------------------------

public static boolean isPalindrome (String s) {
    for (int i = 0, j = s.length () - 1;
    i < j; i ++, j --) {
        if (s.charAt (i) != s.charAt (j)) {
            return false;
        }
    }
    return true;
}
----------------------------------------

private boolean isPalindrome (String s) {
    int length = s.length ();
    if (length < 2) return true;
    else {
        if (s.charAt (0) != s.charAt (length - 1)) return false;
        else return isPalindrome (s.substring (1, length - 1));

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_37451272_1_11
4138827_44201746_1_12
Title: Check string for palindrome 
----------------------------------------

public static boolean isPalindrome (String s) {
    for (int i = 0, j = s.length () - 1;
    i < j; i ++, j --) {
        if (s.charAt (i) != s.charAt (j)) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPalindrome (String word) {
    String str = "";
    for (int i = word.length () - 1;
    i >= 0; i --) {
        str = str + word.charAt (i);
    }
    if (str.equalsIgnoreCase (word)) {
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_37451272_1_11
4138827_44334413_1_12
Title: Check string for palindrome 
----------------------------------------

public static boolean isPalindrome (String s) {
    for (int i = 0, j = s.length () - 1;
    i < j; i ++, j --) {
        if (s.charAt (i) != s.charAt (j)) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public int isPalindrome (String a) {
    String ab = a.replaceAll ("[^A-Za-z0-9]", "").toLowerCase ();
    for (int i = 0;
    i < ab.length () / 2; i ++) {
        if (ab.charAt (i) != ab.charAt ((ab.length () - 1) - i)) {
            return 0;
        }
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_37451272_1_11
4138827_50087122_1_12
Title: Check string for palindrome 
----------------------------------------

public static boolean isPalindrome (String s) {
    for (int i = 0, j = s.length () - 1;
    i < j; i ++, j --) {
        if (s.charAt (i) != s.charAt (j)) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isPalindrome (String input) {
    char [] inputChars = input.toCharArray ();
    int inputLength = inputChars.length;
    int inputMid = inputLength / 2;
    for (int i = 0;
    i <= inputMid; i ++) {
        if (inputChars [i] != inputChars [inputLength - i - 1]) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_37451272_1_11
4138827_53577305_1_11
Title: Check string for palindrome 
----------------------------------------

public static boolean isPalindrome (String s) {
    for (int i = 0, j = s.length () - 1;
    i < j; i ++, j --) {
        if (s.charAt (i) != s.charAt (j)) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPalindrome (Object obj) {
    String s = String.valueOf (obj);
    for (int left = 0, right = s.length () - 1;
    left < right; left ++, right --) {
        if (s.charAt (left ++) != s.charAt (right --)) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_40329718_1_14
4138827_44201746_1_12
Title: Check string for palindrome 
----------------------------------------

private boolean isPalindrome (String s) {
    int length = s.length ();
    if (length < 2) return true;
    else {
        if (s.charAt (0) != s.charAt (length - 1)) return false;
        else return isPalindrome (s.substring (1, length - 1));

    }
}
----------------------------------------

public static boolean isPalindrome (String word) {
    String str = "";
    for (int i = word.length () - 1;
    i >= 0; i --) {
        str = str + word.charAt (i);
    }
    if (str.equalsIgnoreCase (word)) {
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_40329718_1_14
4138827_44334413_1_12
Title: Check string for palindrome 
----------------------------------------

private boolean isPalindrome (String s) {
    int length = s.length ();
    if (length < 2) return true;
    else {
        if (s.charAt (0) != s.charAt (length - 1)) return false;
        else return isPalindrome (s.substring (1, length - 1));

    }
}
----------------------------------------

public int isPalindrome (String a) {
    String ab = a.replaceAll ("[^A-Za-z0-9]", "").toLowerCase ();
    for (int i = 0;
    i < ab.length () / 2; i ++) {
        if (ab.charAt (i) != ab.charAt ((ab.length () - 1) - i)) {
            return 0;
        }
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_40329718_1_14
4138827_50087122_1_12
Title: Check string for palindrome 
----------------------------------------

private boolean isPalindrome (String s) {
    int length = s.length ();
    if (length < 2) return true;
    else {
        if (s.charAt (0) != s.charAt (length - 1)) return false;
        else return isPalindrome (s.substring (1, length - 1));

    }
}
----------------------------------------

public boolean isPalindrome (String input) {
    char [] inputChars = input.toCharArray ();
    int inputLength = inputChars.length;
    int inputMid = inputLength / 2;
    for (int i = 0;
    i <= inputMid; i ++) {
        if (inputChars [i] != inputChars [inputLength - i - 1]) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_40329718_1_14
4138827_53577305_1_11
Title: Check string for palindrome 
----------------------------------------

private boolean isPalindrome (String s) {
    int length = s.length ();
    if (length < 2) return true;
    else {
        if (s.charAt (0) != s.charAt (length - 1)) return false;
        else return isPalindrome (s.substring (1, length - 1));

    }
}
----------------------------------------

public static boolean isPalindrome (Object obj) {
    String s = String.valueOf (obj);
    for (int left = 0, right = s.length () - 1;
    left < right; left ++, right --) {
        if (s.charAt (left ++) != s.charAt (right --)) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_41305719_4_30
4138827_43512842_10_23
Title: Check string for palindrome 
----------------------------------------

public static void main (String args []) {
    String original, reverse = "";
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter How Many number of Input you want : ");
    int numOfInt = in.nextInt ();
    original = in.nextLine ();
    do {
        if (numOfInt == 0) {
            System.out.println ("Your Input Conplete");
        } else {
            System.out.println ("Enter a string to check palindrome");
            original = in.nextLine ();
            StringBuffer buffer = new StringBuffer (original);
            reverse = buffer.reverse ().toString ();
            if (original.equalsIgnoreCase (reverse)) {
                System.out.println ("The entered string is Palindrome:" + reverse);
            } else {
                System.out.println ("The entered string is not Palindrome:" + reverse);
            }
        }
        numOfInt --;
    } while (numOfInt >= 0);
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    String str = in.nextLine ();
    str.replaceAll ("\\s+", "");
    Stack < String > stack = new Stack < String > ();
    stack.push (str);
    String str_rev = stack.pop ();
    if (str.equals (str_rev)) {
        System.out.println ("Palindrome");
    } else {
        System.out.println ("Not Palindrome");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_41305719_4_30
4138827_48009569_5_22
Title: Check string for palindrome 
----------------------------------------

public static void main (String args []) {
    String original, reverse = "";
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter How Many number of Input you want : ");
    int numOfInt = in.nextInt ();
    original = in.nextLine ();
    do {
        if (numOfInt == 0) {
            System.out.println ("Your Input Conplete");
        } else {
            System.out.println ("Enter a string to check palindrome");
            original = in.nextLine ();
            StringBuffer buffer = new StringBuffer (original);
            reverse = buffer.reverse ().toString ();
            if (original.equalsIgnoreCase (reverse)) {
                System.out.println ("The entered string is Palindrome:" + reverse);
            } else {
                System.out.println ("The entered string is not Palindrome:" + reverse);
            }
        }
        numOfInt --;
    } while (numOfInt >= 0);
}
----------------------------------------

public static void main (String [] args) {
    String s = "madam";
    String t = "";
    for (int i = s.length () - 1;
    i >= 0; i --) {
        t = t + s.charAt (i);
    }
    System.out.println ("reversed word is " + t);
    if (t.matches (s)) {
        System.out.println ("pallindrome");
    } else {
        System.out.println ("not pallindrome");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_4138856_1_12
4138827_4138884_8_23
Title: Check string for palindrome 
----------------------------------------

public static boolean istPalindrom (char [] word) {
    int i1 = 0;
    int i2 = word.length - 1;
    while (i2 > i1) {
        if (word [i1] != word [i2]) {
            return false;
        }
        ++ i1;
        -- i2;
    }
    return true;
}
----------------------------------------

public static boolean istPalindrom (char [] wort) {
    if (wort.length % 2 == 0) {
        for (int i = 0;
        i < wort.length / 2 - 1; i ++) {
            if (wort [i] != wort [wort.length - i - 1]) {
                return false;
            }
        }
    } else {
        for (int i = 0;
        i < (wort.length - 1) / 2 - 1; i ++) {
            if (wort [i] != wort [wort.length - i - 1]) {
                return false;
            }
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_43512842_10_23
4138827_48009569_5_22
Title: Check string for palindrome 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    String str = in.nextLine ();
    str.replaceAll ("\\s+", "");
    Stack < String > stack = new Stack < String > ();
    stack.push (str);
    String str_rev = stack.pop ();
    if (str.equals (str_rev)) {
        System.out.println ("Palindrome");
    } else {
        System.out.println ("Not Palindrome");
    }
}
----------------------------------------

public static void main (String [] args) {
    String s = "madam";
    String t = "";
    for (int i = s.length () - 1;
    i >= 0; i --) {
        t = t + s.charAt (i);
    }
    System.out.println ("reversed word is " + t);
    if (t.matches (s)) {
        System.out.println ("pallindrome");
    } else {
        System.out.println ("not pallindrome");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_44201746_1_12
4138827_44334413_1_12
Title: Check string for palindrome 
----------------------------------------

public static boolean isPalindrome (String word) {
    String str = "";
    for (int i = word.length () - 1;
    i >= 0; i --) {
        str = str + word.charAt (i);
    }
    if (str.equalsIgnoreCase (word)) {
        return true;
    } else {
        return false;
    }
}
----------------------------------------

public int isPalindrome (String a) {
    String ab = a.replaceAll ("[^A-Za-z0-9]", "").toLowerCase ();
    for (int i = 0;
    i < ab.length () / 2; i ++) {
        if (ab.charAt (i) != ab.charAt ((ab.length () - 1) - i)) {
            return 0;
        }
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_44201746_1_12
4138827_50087122_1_12
Title: Check string for palindrome 
----------------------------------------

public static boolean isPalindrome (String word) {
    String str = "";
    for (int i = word.length () - 1;
    i >= 0; i --) {
        str = str + word.charAt (i);
    }
    if (str.equalsIgnoreCase (word)) {
        return true;
    } else {
        return false;
    }
}
----------------------------------------

public boolean isPalindrome (String input) {
    char [] inputChars = input.toCharArray ();
    int inputLength = inputChars.length;
    int inputMid = inputLength / 2;
    for (int i = 0;
    i <= inputMid; i ++) {
        if (inputChars [i] != inputChars [inputLength - i - 1]) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_44201746_1_12
4138827_53577305_1_11
Title: Check string for palindrome 
----------------------------------------

public static boolean isPalindrome (String word) {
    String str = "";
    for (int i = word.length () - 1;
    i >= 0; i --) {
        str = str + word.charAt (i);
    }
    if (str.equalsIgnoreCase (word)) {
        return true;
    } else {
        return false;
    }
}
----------------------------------------

public static boolean isPalindrome (Object obj) {
    String s = String.valueOf (obj);
    for (int left = 0, right = s.length () - 1;
    left < right; left ++, right --) {
        if (s.charAt (left ++) != s.charAt (right --)) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_44334413_1_12
4138827_50087122_1_12
Title: Check string for palindrome 
----------------------------------------

public int isPalindrome (String a) {
    String ab = a.replaceAll ("[^A-Za-z0-9]", "").toLowerCase ();
    for (int i = 0;
    i < ab.length () / 2; i ++) {
        if (ab.charAt (i) != ab.charAt ((ab.length () - 1) - i)) {
            return 0;
        }
    }
    return 1;
}
----------------------------------------

public boolean isPalindrome (String input) {
    char [] inputChars = input.toCharArray ();
    int inputLength = inputChars.length;
    int inputMid = inputLength / 2;
    for (int i = 0;
    i <= inputMid; i ++) {
        if (inputChars [i] != inputChars [inputLength - i - 1]) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_44334413_1_12
4138827_53577305_1_11
Title: Check string for palindrome 
----------------------------------------

public int isPalindrome (String a) {
    String ab = a.replaceAll ("[^A-Za-z0-9]", "").toLowerCase ();
    for (int i = 0;
    i < ab.length () / 2; i ++) {
        if (ab.charAt (i) != ab.charAt ((ab.length () - 1) - i)) {
            return 0;
        }
    }
    return 1;
}
----------------------------------------

public static boolean isPalindrome (Object obj) {
    String s = String.valueOf (obj);
    for (int left = 0, right = s.length () - 1;
    left < right; left ++, right --) {
        if (s.charAt (left ++) != s.charAt (right --)) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4138827_50087122_1_12
4138827_53577305_1_11
Title: Check string for palindrome 
----------------------------------------

public boolean isPalindrome (String input) {
    char [] inputChars = input.toCharArray ();
    int inputLength = inputChars.length;
    int inputMid = inputLength / 2;
    for (int i = 0;
    i <= inputMid; i ++) {
        if (inputChars [i] != inputChars [inputLength - i - 1]) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPalindrome (Object obj) {
    String s = String.valueOf (obj);
    for (int left = 0, right = s.length () - 1;
    left < right; left ++, right --) {
        if (s.charAt (left ++) != s.charAt (right --)) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41396611_41398548_1_27
41396611_50098051_1_15
Title: Finding the number of distinct pairs of integers that sum up to an integer 
----------------------------------------

public static int SumPairs (Integer [] input, int k) {
    Map < Integer, Integer > frequencies = new HashMap < > ();
    int pairsCount = 0;
    for (int i = 0;
    i < input.length; i ++) {
        int value = input [i];
        int complement = k - input [i];
        if (frequencies.containsKey (complement)) {
            int freq = frequencies.get (complement) - 1;
            pairsCount ++;
            if (freq == 0) {
                frequencies.remove (complement);
            } else {
                frequencies.put (complement, freq);
            }
        } else {
            if (frequencies.containsKey (value)) {
                frequencies.put (value, frequencies.get (value) + 1);
            } else {
                frequencies.put (value, 1);
            }
        }
    }
    return pairsCount;
}
----------------------------------------

public static int SumPairs (int [] input, int k) {
    Map < Integer, Integer > pairs = new HashMap < Integer, Integer > ();
    int tmp = 0;
    for (int data : input) {
        if (pairs.containsKey (k - data) && pairs.get (k - data) == 0) {
            tmp ++;
            pairs.put ((k - data), pairs.get (k - data) + 1);
        } else if (! pairs.containsKey (data)) {
            pairs.put (data, 0);
        }

    }
    return tmp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41403166_41403256_3_25
41403166_41403735_31_38
Title: Java GUI - How to center a single button 
----------------------------------------

public static void main (String [] args) {
    JFrame start_frame = new JFrame ("P.D");
    int width = 1200;
    int height = 800;
    start_frame.setSize (width, height);
    start_frame.setVisible (true);
    start_frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    JPanel start_panel = new JPanel ();
    start_panel.setLayout (null);
    start_frame.add (start_panel);
    JButton start_button = new JButton ("Start");
    buttonWidth = 80;
    buttonHeight = 20;
    start_button.setBounds (new Rectangle ((width - buttonWidth) / 2, (height - buttonHeight) / 2, buttonWidth, buttonHeight));
    start_button.setSize (new Dimension (buttonWidth, buttonHeight));
    start_button.setFocusable (false);
    start_panel.add (start_button);
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            new MainGUIJFrame ().setVisible (true);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41403166_41403256_3_25
41403166_41403819_7_34
Title: Java GUI - How to center a single button 
----------------------------------------

public static void main (String [] args) {
    JFrame start_frame = new JFrame ("P.D");
    int width = 1200;
    int height = 800;
    start_frame.setSize (width, height);
    start_frame.setVisible (true);
    start_frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    JPanel start_panel = new JPanel ();
    start_panel.setLayout (null);
    start_frame.add (start_panel);
    JButton start_button = new JButton ("Start");
    buttonWidth = 80;
    buttonHeight = 20;
    start_button.setBounds (new Rectangle ((width - buttonWidth) / 2, (height - buttonHeight) / 2, buttonWidth, buttonHeight));
    start_button.setSize (new Dimension (buttonWidth, buttonHeight));
    start_button.setFocusable (false);
    start_panel.add (start_button);
}
----------------------------------------

public static void main (String [] args) {
    JFrame start_frame = new JFrame ("P.D");
    int FrameWidth = 1200, FrameHeight = 800;
    start_frame.setSize (FrameWidth, FrameHeight);
    start_frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    JPanel start_panel = new JPanel ();
    start_panel.setLayout (null);
    start_frame.add (start_panel);
    JButton start_button = new JButton ("Start");
    start_button.setFocusable (false);
    Dimension size = start_button.getPreferredSize ();
    start_button.setBounds (FrameWidth / 2 - size.width / 2, FrameHeight / 2 - size.height / 2, size.width, size.height);
    start_panel.add (start_button);
    start_frame.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41403166_41403735_31_38
41403166_41403819_7_34
Title: Java GUI - How to center a single button 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            new MainGUIJFrame ().setVisible (true);
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    JFrame start_frame = new JFrame ("P.D");
    int FrameWidth = 1200, FrameHeight = 800;
    start_frame.setSize (FrameWidth, FrameHeight);
    start_frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    JPanel start_panel = new JPanel ();
    start_panel.setLayout (null);
    start_frame.add (start_panel);
    JButton start_button = new JButton ("Start");
    start_button.setFocusable (false);
    Dimension size = start_button.getPreferredSize ();
    start_button.setBounds (FrameWidth / 2 - size.width / 2, FrameHeight / 2 - size.height / 2, size.width, size.height);
    start_panel.add (start_button);
    start_frame.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41410867_42030205_103_192
41410867_42030205_34_51
Title: Spring Mongodb Query ArrayIndexOutOfBoundsException 
----------------------------------------

public Table convert (DBObject source) {
    Table table = HashBasedTable.< Integer, String, HTMLInputTag > create ();
    Map m = source.toMap ();
    m.forEach ((k, v) -> {
        Map temp = (Map) v;
        temp.forEach ((s, t) -> {
            Map inputTagMap = ((DBObject) t).toMap ();
            final String className = (String) inputTagMap.get ("class");
            HTMLInputTag inputTagOriginal = null;
            try {
                inputTagOriginal = (HTMLInputTag) Class.forName (className).newInstance ();
            } catch (InstantiationException | IllegalAccessException | ClassNotFoundException e) {
                e.printStackTrace ();
                inputTagOriginal = new HTMLInputTag ();
            }
            final HTMLInputTag inputTag = inputTagOriginal.clone ();
            inputTagMap.keySet ().forEach (fieldname -> {
                Field field = null;
                if (className.equals (HTMLJustTag.class.getName ())) {
                    field = ReflectionUtils.findField (HTMLJustTag.class, (String) fieldname);
                } else {
                    field = ReflectionUtils.findField (HTMLInputTag.class, (String) fieldname);
                }
                if (null != field) {
                    if (! ReflectionUtils.isPublicStaticFinal (field)) {
                        ReflectionUtils.makeAccessible (field);
                        if (Collection.class.isAssignableFrom (field.getType ())) {
                            Type cls = null;
                            Class rawTypeClass = null;
                            Type type = field.getGenericType ();
                            if (type instanceof ParameterizedType) {
                                ParameterizedType pType = (ParameterizedType) type;
                                rawTypeClass = pType.getRawType ().getClass ();
                                cls = pType.getActualTypeArguments () [0];
                            } else {
                                cls = field.getType ();
                            }
                            final Set collectionData = new LinkedHashSet < > ();
                            Object value = inputTagMap.get (fieldname);
                            if (value instanceof BasicDBList) {
                                BasicDBList values = (BasicDBList) value;
                                values.forEach (e -> {
                                    if (e instanceof BasicDBObject) {
                                        String nestedClassName = ((BasicDBObject) e).getString ("class");
                                        Object ncls = (((BasicDBObject) e).toMap ()).get ("class");
                                        try {
                                            if (nestedClassName.equals (HTMLJustTag.class.getName ())) {
                                                collectionData.add (objectMapper.readValue (e.toString (), new TypeReference < HTMLJustTag > () {
                                                }

                                                ));
                                            } else if (nestedClassName.equals (HTMLAttribute.class.getName ())) {
                                                collectionData.add (objectMapper.readValue (e.toString (), new TypeReference < HTMLAttribute > () {
                                                }

                                                ));
                                            } else {
                                                collectionData.add (objectMapper.readValue (e.toString (), new TypeReference < HTMLInputTag > () {
                                                }

                                                ));
                                            }

                                        } catch (IOException e1) {
                                            e1.printStackTrace ();
                                        }
                                    }
                                });
                            } else {
                                ReflectionUtils.setField (field, inputTag, inputTagMap.get (fieldname));
                            }
                            ReflectionUtils.setField (field, inputTag, collectionData);
                        } else {
                            ReflectionUtils.setField (field, inputTag, inputTagMap.get (fieldname));
                        }
                    }
                }
            });
            if (k instanceof String) {
                table.put (Integer.parseInt ((String) k), s, inputTag);
            } else {
                table.put (k, s, inputTag);
            }
        });
    });
    return table;
}
----------------------------------------

public DBObject convert (Table value) {
    DBObject dbo = new BasicDBObject ();
    value.rowMap ().forEach ((i, map) -> {
        DBObject rowdbobject = new BasicDBObject ();
        ((Map) map).forEach ((k, v) -> {
            Object object = ((Map) map).get (k);
            if (object instanceof HTMLInputTag) {
                HTMLInputTag inputTag = (HTMLInputTag) object;
                rowdbobject.put (inputTag.getId (), convertHTMLInputTag (inputTag));
            } else {
                rowdbobject.put (object.toString (), object);
            }
        });
        dbo.put ("" + i, rowdbobject);
    });
    return dbo;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41418333_41418358_1_17
41418333_41419304_1_26
Title: recursively call a method but log only second time? 
----------------------------------------

private String decodeValue (String value, Charset charset, boolean isFirstTime) {
    if (! Strings.isNullOrEmpty (value)) {
        try {
            value = URLDecoder.decode (value, charset.name ());
        } catch (UnsupportedEncodingException ex) {
            if (isFirstTime) {
                value = value.replaceAll ("%(?![0-9a-fA-F]{2})", "%25");
                value = value.replaceAll ("\\+", "%2B");
                return decodeValue (value, charset.name (), false);
            } else {
                return null;
            }
        }
    }
    return value;
}
----------------------------------------

public String decodeValue (final String value, Charset charset) throws UnsupportedEncodingException {
    String result;
    if (! Strings.isNullOrEmpty (value)) {
        UnsupportedEncodingException [] lastException = new UnsupportedEncodingException [1];
        result = Stream.< Function < String, String > > of (Function.identity (), s -> {
            s = s.replaceAll ("%(?![0-9a-fA-F]{2})", "%25");
            s = s.replaceAll ("\\+", "%2B");
            return s;
        }).map (f -> f.apply (value)).map (appliedValue -> {
            try {
                return URLDecoder.decode (appliedValue, charset.name ());
            } catch (UnsupportedEncodingException e) {
                lastException [0] = e;
                return null;
            }
        }).filter (Objects :: nonNull).findFirst ().orElseThrow (() -> lastException [0]);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41418333_41418362_1_17
41418333_41418475_1_16
Title: recursively call a method but log only second time? 
----------------------------------------

public String decode (String value, Charset charset) {
    if (! Strings.isNullOrEmpty (value)) {
        try {
            value = URLDecoder.decode (value, charset.name ());
        } catch (UnsupportedEncodingException ex) {
            try {
                value = value.replaceAll ("%(?![0-9a-fA-F]{2})", "%25");
                value = value.replaceAll ("\\+", "%2B");
                value = URLDecoder.decode (value, charset.name ());
            } catch (UnsupportedEncodingException ex) {
                return null;
            }
        }
    }
    return value;
}
----------------------------------------

public String decode (String value, Charset charset) {
    boolean first = true;
    while (! Strings.isNullOrEmpty (value)) {
        try {
            return value = URLDecoder.decode (value, charset);
        } catch (UnsupportedEncodingException e) {
            if (first == false) {
                return null;
            }
            value = value.replaceAll ("%(?![0-9a-fA-F]{2})", "%25").replaceAll ("\\+", "%2B");
        }
        first = false;
    }
    return value;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41422519_41422654_3_22
41422519_41422680_1_24
Title: "Head First Java 2nd Ed- Page 44 Chaper 2" 
----------------------------------------

public static void main (String [] args) {
    Echo e1 = new Echo ();
    Echo e2 = new Echo ();
    int x = 0;
    while (x < 4) {
        e1.hello ();
        e1.count = e1.count + 1;
        if (x == 3) e2.count = e2.count + 1;

        if (x > 0) e2.count = e2.count + e1.count;

        x ++;
    }
    System.out.println (e2.count);
}
----------------------------------------

public static void main (String [] args) {
    Echo e1 = new Echo ();
    Echo e2 = new Echo ();
    int x = 0;
    while (x < 4) {
        e1.count += 1;
        System.out.println ("e1.count = " + e1.count);
        if (x == 3) {
            e2.count += 1;
            System.out.println ("e2.count = " + e2.count);
        }
        if (x > 0) {
            System.out.println ("e2.count = " + e2.count + "+" + e1.count);
            e2.count = e2.count + e1.count;
            System.out.println ("e2.count = " + e2.count);
        }
        x += 1;
    }
    System.out.println (e2.count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41431464_41431909_11_44
41431464_41432319_8_18
Title: numOfColors recursive function JAVA 
----------------------------------------

public static int numOfColors (int [] [] arr) {
    int unique = 0;
    if (arr.length == 0) {
        return unique;
    } else {
        int [] subArr = arr [arr.length - 1];
        outerLoop : for (int i = 0;
        i < subArr.length; i ++) {
            int j = i + 1;
            for (; j < subArr.length; j ++) {
                if (subArr [i] == subArr [j]) {
                    break;
                }
            }
            if (j == subArr.length) {
                int k = 0;
                for (; k < arr.length - 1; k ++) {
                    for (int l = 0;
                    l < arr [k].length; l ++) {
                        if (subArr [i] == arr [k] [l]) {
                            continue outerLoop;
                        }
                    }
                }
                if (k == arr.length - 1) {
                    unique ++;
                }
            }
        }
        int [] [] dest = new int [arr.length - 1] [];
        System.arraycopy (arr, 0, dest, 0, arr.length - 1);
        unique += numOfColors (dest);
        return unique;
    }
}
----------------------------------------

static int numOfColors (int [] [] map) {
    ArrayList < Integer > intlist = new ArrayList < Integer > ();
    for (int o = 0;
    o < map.length; o ++) {
        for (int n = 0;
        n < map [o].length; n ++) {
            intlist.add (map [o] [n]);
        }
    }
    intlist = removeDuplicates (intlist, 0);
    System.out.println (intlist.size () + " " + intlist);
    return intlist.size ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41439671_41440184_13_34
41439671_41440574_1_23
Title: Different values in array 
----------------------------------------

public static int numOfColors (int [] [] map, int [] collector, int currentPosition) {
    int [] result = collector;
    if (currentPosition < 0) {
        return collector.length;
    }
    for (int color : map [currentPosition]) {
        boolean found = false;
        for (int aResult : result) {
            if (aResult == color) {
                found = true;
                break;
            }
        }
        if (! found) {
            int [] newResult = new int [result.length + 1];
            System.arraycopy (result, 0, newResult, 0, result.length);
            newResult [newResult.length - 1] = color;
            result = newResult;
        }
    }
    return numOfColors (map, result, currentPosition - 1);
}
----------------------------------------

public static int numOfColors (int [] [] map) {
    int [] storage = new int [10];
    for (int i = 0;
    i < map.length; i ++) {
        for (int j = 0;
        j < map [0].length; j ++) {
            storage [map [i] [j]] ++;
        }
    }
    int colors = 0;
    for (int i = 0;
    i < storage.length; i ++) {
        if (storage [i] != 0) colors ++;

    }
    return colors;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41448826_41449031_1_18
41448826_41450241_1_12
Title: if-elseif-else like functionality with Java 8 streams 
----------------------------------------

public ShapeType resolveShapeType (final List < Shape > shapes) {
    boolean [] bits = new boolean [2];
    shapes.stream ().forEach (shape -> {
        int sides = shape.getSideCount ();
        if (sides == 4) {
            bits [0] = true;
        } else if (sides == 6) {
            bits [1] = true;
        }

    });
    if (bits [1]) {
        return ShapeType.HEXA;
    } else if (bits [0]) {
        return ShapeType.RECT;
    } else {
        return ShapeType.GENERIC;
    }

}
----------------------------------------

public ShapeType resolveShapeType (final List < Shape > shapes) {
    OptionalInt first = IntStream.range (0, shapes.size ()).filter (index -> {
        int count = shapes.get (index).getSideCount ();
        return count == 6 || count == 4;
    }).findFirst ();
    if (! first.isPresent ()) return ShapeType.GENERIC;

    int ix = first.getAsInt (), count = shapes.get (ix).getSideCount ();
    return count == 6 ? ShapeType.HEXA : shapes.subList (ix + 1, shapes.size ()).stream ().anyMatch (shape -> shape.getSideCount () == 6) ? ShapeType.HEXA : ShapeType.RECT;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4145034_4145588_14_30
4145034_4145805_12_43
Title: Not able to call Runtime.getRuntime().exec 
----------------------------------------

public boolean onData (INonBlockingConnection nbc) throws IOException, BufferUnderflowException, ClosedChannelException, MaxReadSizeExceededException {
    String data = nbc.readStringByDelimiter ("\r\n");
    nbc.write (data + "\r\n");
    System.out.println ("setup exec");
    Process p = Runtime.getRuntime ().exec (new String [] {"cmd", "java -jar D:\\chat.jar -n 0"});
    try {
        p.waitFor ();
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    System.out.println ("call exec");
    return true;
}
----------------------------------------

public boolean onData (INonBlockingConnection nbc) throws IOException, BufferUnderflowException, ClosedChannelException, MaxReadSizeExceededException {
    try {
        String data = nbc.readStringByDelimiter ("\0");
        String message = data;
        sendMessageToAll (message);
    } catch (Exception ex) {
        System.out.println ("onData2: " + ex.getMessage ());
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41451585_41451853_5_34
41451585_41533791_4_21
Title: Code is not printing results 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.print ("Enter a three-digit integer: ");
    int answer = 0;
    try {
        answer = input.nextInt ();
    } catch (InputMismatchException ex) {
    }
    if (answer < 100 || answer >= 1000) {
    } else {
        int digit1 = answer / 100;
        int digit3 = answer % 10;
        if (digit1 == digit3) {
            System.out.println (answer + " is a palindrome! ");
        } else {
            System.out.println (answer + " is not a palindrome");
        }
    }
}
----------------------------------------

public static void main (String args []) {
    String original, reverse = "";
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter a string : ");
    original = in.nextLine ();
    int length = original.length ();
    for (int i = length - 1;
    i >= 0; i --) reverse = reverse + original.charAt (i);

    if (original.equals (reverse)) System.out.println ("Entered string is a palindrome.");
    else System.out.println ("Entered string is not a palindrome.");

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41462622_41484111_12_21
41462622_41484111_23_32
Title: Keep Tooltip open as long as mouse is over it 
----------------------------------------

public void addHoveringTarget (Node object) {
    mapHoveringTarget2Hovering.put (object, false);
    object.setOnMouseEntered (e -> {
        onMouseEntered (object);
    });
    object.setOnMouseExited (e -> {
        onMouseExited (object);
    });
}
----------------------------------------

public void addHoveringTarget (Scene object) {
    mapHoveringTarget2Hovering.put (object, false);
    object.setOnMouseEntered (e -> {
        onMouseEntered (object);
    });
    object.setOnMouseExited (e -> {
        onMouseExited (object);
    });
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41471134_41472143_1_71
41471134_41489337_1_13
Title: Fast bitwise operations on a long 
----------------------------------------

private static final byte [] bitPositions (final long n) {
    final byte [] result = new byte [Long.bitCount (n)];
    int i = 0;
    if ((n & 1L) != 0L) result [i ++] = 1;

    if ((n & 2L) != 0L) result [i ++] = 2;

    if ((n & 4L) != 0L) result [i ++] = 3;

    if ((n & 8L) != 0L) result [i ++] = 4;

    if ((n & 16L) != 0L) result [i ++] = 5;

    if ((n & 32L) != 0L) result [i ++] = 6;

    if ((n & 64L) != 0L) result [i ++] = 7;

    if ((n & 128L) != 0L) result [i ++] = 8;

    if ((n & 256L) != 0L) result [i ++] = 9;

    if ((n & 512L) != 0L) result [i ++] = 10;

    if ((n & 1024L) != 0L) result [i ++] = 11;

    if ((n & 2048L) != 0L) result [i ++] = 12;

    if ((n & 4096L) != 0L) result [i ++] = 13;

    if ((n & 8192L) != 0L) result [i ++] = 14;

    if ((n & 16384L) != 0L) result [i ++] = 15;

    if ((n & 32768L) != 0L) result [i ++] = 16;

    if ((n & 65536L) != 0L) result [i ++] = 17;

    if ((n & 131072L) != 0L) result [i ++] = 18;

    if ((n & 262144L) != 0L) result [i ++] = 19;

    if ((n & 524288L) != 0L) result [i ++] = 20;

    if ((n & 1048576L) != 0L) result [i ++] = 21;

    if ((n & 2097152L) != 0L) result [i ++] = 22;

    if ((n & 4194304L) != 0L) result [i ++] = 23;

    if ((n & 8388608L) != 0L) result [i ++] = 24;

    if ((n & 16777216L) != 0L) result [i ++] = 25;

    if ((n & 33554432L) != 0L) result [i ++] = 26;

    if ((n & 67108864L) != 0L) result [i ++] = 27;

    if ((n & 134217728L) != 0L) result [i ++] = 28;

    if ((n & 268435456L) != 0L) result [i ++] = 29;

    if ((n & 536870912L) != 0L) result [i ++] = 30;

    if ((n & 1073741824L) != 0L) result [i ++] = 31;

    if ((n & 2147483648L) != 0L) result [i ++] = 32;

    if ((n & 4294967296L) != 0L) result [i ++] = 33;

    if ((n & 8589934592L) != 0L) result [i ++] = 34;

    if ((n & 17179869184L) != 0L) result [i ++] = 35;

    if ((n & 34359738368L) != 0L) result [i ++] = 36;

    if ((n & 68719476736L) != 0L) result [i ++] = 37;

    if ((n & 137438953472L) != 0L) result [i ++] = 38;

    if ((n & 274877906944L) != 0L) result [i ++] = 39;

    if ((n & 549755813888L) != 0L) result [i ++] = 40;

    if ((n & 1099511627776L) != 0L) result [i ++] = 41;

    if ((n & 2199023255552L) != 0L) result [i ++] = 42;

    if ((n & 4398046511104L) != 0L) result [i ++] = 43;

    if ((n & 8796093022208L) != 0L) result [i ++] = 44;

    if ((n & 17592186044416L) != 0L) result [i ++] = 45;

    if ((n & 35184372088832L) != 0L) result [i ++] = 46;

    if ((n & 70368744177664L) != 0L) result [i ++] = 47;

    if ((n & 140737488355328L) != 0L) result [i ++] = 48;

    if ((n & 281474976710656L) != 0L) result [i ++] = 49;

    if ((n & 562949953421312L) != 0L) result [i ++] = 50;

    if ((n & 1125899906842624L) != 0L) result [i ++] = 51;

    if ((n & 2251799813685248L) != 0L) result [i ++] = 52;

    if ((n & 4503599627370496L) != 0L) result [i ++] = 53;

    if ((n & 9007199254740992L) != 0L) result [i ++] = 54;

    if ((n & 18014398509481984L) != 0L) result [i ++] = 55;

    if ((n & 36028797018963968L) != 0L) result [i ++] = 56;

    if ((n & 72057594037927936L) != 0L) result [i ++] = 57;

    if ((n & 144115188075855872L) != 0L) result [i ++] = 58;

    if ((n & 288230376151711744L) != 0L) result [i ++] = 59;

    if ((n & 576460752303423488L) != 0L) result [i ++] = 60;

    if ((n & 1152921504606846976L) != 0L) result [i ++] = 61;

    if ((n & 2305843009213693952L) != 0L) result [i ++] = 62;

    if ((n & 4611686018427387904L) != 0L) result [i ++] = 63;

    if ((n & - 9223372036854775808L) != 0L) result [i ++] = 64;

    return result;
}
----------------------------------------

private static final byte [] bitPositions (long n) {
    final byte [] result = new byte [Long.bitCount (n)];
    byte bitPosition = 0;
    for (int i = 0;
    n != 0L; i ++) {
        final byte bitsToSkip = (byte) (Long.numberOfTrailingZeros (n) + 1);
        n>>>= bitsToSkip;
        bitPosition += bitsToSkip;
        result [i] = bitPosition;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41480722_41481836_3_26
41480722_41482011_1_15
Title: Arrange the numbers by subtracting 
----------------------------------------

public static void calculationMethod (int n, int k) {
    if (n < 2 || n / 2 < k) {
        System.out.println ("Impossible");
        return;
    } else {
        int i = (int) Math.ceil (n / 2.0);
        int j = n;
        int start = i;
        boolean flag = true;
        while (i >= 1 || j > start) {
            if (flag) {
                System.out.print (i + " ");
                i --;
                flag = false;
            } else {
                System.out.print (j + " ");
                j --;
                flag = true;
            }
        }
    }
}
----------------------------------------

public void calculationMethod (int n, int k) {
    ArrayList < Integer > intList = new ArrayList < > ();
    for (int i = 1;
    i <= n; i ++) {
        int a = i;
        int b = i + 2;
        if (! intList.contains (a) && a <= n) {
            intList.add (a);
        }
        if (! intList.contains (b) && b <= n) {
            intList.add (b);
        }
    }
    String mValues = TextUtils.join (",", intList);
    Log.i ("values", mValues);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41494302_41494774_10_27
41494302_41494774_14_26
Title: JavaFX not on FX application thread 
----------------------------------------

public void run () {
    Platform.runLater (new Runnable () {
        @Override
        public void run () {
            System.out.println ("I've started");
            try {
                Alert alert = new Alert (AlertType.ERROR, "Line is empty");
                alert.setTitle ("Error");
                alert.setHeaderText ("Line empty");
                System.out.println ("I've ended");
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }}

    );
}
----------------------------------------

public void run () {
    System.out.println ("I've started");
    try {
        Alert alert = new Alert (AlertType.ERROR, "Line is empty");
        alert.setTitle ("Error");
        alert.setHeaderText ("Line empty");
        System.out.println ("I've ended");
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41495113_41495201_5_25
41495113_41495391_1_20
Title: randomly replace random numbers of char in a string 
----------------------------------------

public static void main (String [] args) {
    Random generator = new Random ();
    int num1;
    String theWord;
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter a string to rearrange");
    theWord = in.nextLine ();
    int length = theWord.length ();
    Random times = new Random ();
    System.out.println ("Length of String:" + length);
    char [] chars = theWord.toCharArray ();
    Arrays.sort (chars);
    int timez = times.nextInt ();
    num1 = generator.nextInt (length);
    char c = theWord.charAt (num1);
    String newWord = new String (chars);
    for (int i = 0;
    i < timez; i ++) {
        newWord = newWord.replace (c, '*');
    }
    System.out.println (newWord);
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    char [] input = in.nextLine ().toCharArray ();
    Random rand = new Random ();
    for (int k = 0;
    k < 5; k ++) {
        int leftIndex = rand.nextInt (input.length - 1);
        int rightIndex = rand.nextInt (input.length - 1);
        if (leftIndex == rightIndex) continue;

        char buffer = input [leftIndex];
        input [leftIndex] = input [rightIndex];
        input [rightIndex] = buffer;
    }
    System.out.println (input);
    in.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41504408_41505041_14_68
41504408_41505172_9_62
Title: Chat program using TCP : Only first message reaches other end 
----------------------------------------

chattcp (String name, int lis, int snd) {
    this.setVisible (true);
    this.setTitle (name);
    this.setLayout (null);
    this.setSize (500, 500);
    this.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    TextField tf = new TextField ();
    this.add (tf);
    tf.setBounds (10, 20, 100, 40);
    TextArea ta = new TextArea ();
    this.add (ta);
    ta.setBounds (10, 80, 400, 400);
    ta.setEditable (false);
    ta.setFont (ta.getFont ().deriveFont (20f));
    Button b = new Button ("send");
    this.add (b);
    b.setBounds (130, 20, 60, 40);
    b.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent a) {
            try {
                String s = tf.getText ();
                Socket skt = new Socket ("localhost", snd);
                DataOutputStream dos = new DataOutputStream (skt.getOutputStream ());
                dos.writeUTF (s);
                ta.append ("You :" + s + "\n");
                tf.setText ("");
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }}

    );
    Thread receive = new Thread () {
        public void run () {
            try {
                while (true) {
                    ServerSocket ser = new ServerSocket (lis);
                    Socket sktt = ser.accept ();
                    DataInputStream dis = new DataInputStream (sktt.getInputStream ());
                    String s = dis.readUTF ();
                    ta.append ("Friend : " + s + "\n");
                    ser.close ();
                }
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }}

    ;
    receive.start ();
}
----------------------------------------

chattcp (String name, int lis, int snd) {
    this.setVisible (true);
    this.setTitle (name);
    this.setLayout (null);
    this.setSize (500, 500);
    this.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    TextField tf = new TextField ();
    this.add (tf);
    tf.setBounds (10, 20, 100, 40);
    TextArea ta = new TextArea ();
    this.add (ta);
    ta.setBounds (10, 80, 400, 400);
    ta.setEditable (false);
    ta.setFont (ta.getFont ().deriveFont (20f));
    Button b = new Button ("send");
    this.add (b);
    b.setBounds (130, 20, 60, 40);
    b.addActionListener (new ActionListener () {
        public void actionPerformed (ActionEvent a) {
            try {
                if (skt == null) {
                    skt = new Socket ("localhost", snd);
                }
                DataOutputStream dos = new DataOutputStream (skt.getOutputStream ());
                String s = tf.getText ();
                dos.writeUTF (s);
                ta.append ("You :" + s + "\n");
                tf.setText ("");
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }}

    );
    Thread receive = new Thread () {
        public void run () {
            try {
                ServerSocket ser = new ServerSocket (lis);
                Socket sktt = ser.accept ();
                DataInputStream dis = new DataInputStream (sktt.getInputStream ());
                while (true) {
                    String s = dis.readUTF ();
                    ta.append ("Friend : " + s + "\n");
                }
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }}

    ;
    receive.start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41504408_41505041_34_45
41504408_41505172_29_45
Title: Chat program using TCP : Only first message reaches other end 
----------------------------------------

public void actionPerformed (ActionEvent a) {
    try {
        String s = tf.getText ();
        Socket skt = new Socket ("localhost", snd);
        DataOutputStream dos = new DataOutputStream (skt.getOutputStream ());
        dos.writeUTF (s);
        ta.append ("You :" + s + "\n");
        tf.setText ("");
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void actionPerformed (ActionEvent a) {
    try {
        if (skt == null) {
            skt = new Socket ("localhost", snd);
        }
        DataOutputStream dos = new DataOutputStream (skt.getOutputStream ());
        String s = tf.getText ();
        dos.writeUTF (s);
        ta.append ("You :" + s + "\n");
        tf.setText ("");
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41504408_41505041_49_64
41504408_41505172_49_59
Title: Chat program using TCP : Only first message reaches other end 
----------------------------------------

public void run () {
    try {
        while (true) {
            ServerSocket ser = new ServerSocket (lis);
            Socket sktt = ser.accept ();
            DataInputStream dis = new DataInputStream (sktt.getInputStream ());
            String s = dis.readUTF ();
            ta.append ("Friend : " + s + "\n");
            ser.close ();
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    try {
        ServerSocket ser = new ServerSocket (lis);
        Socket sktt = ser.accept ();
        DataInputStream dis = new DataInputStream (sktt.getInputStream ());
        while (true) {
            String s = dis.readUTF ();
            ta.append ("Friend : " + s + "\n");
        }
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41514223_41622251_67_99
41514223_41628357_25_48
Title: Android: Tapping one to six buttons continuously [one after another] to string together different results 
----------------------------------------

protected void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.buttons);
    initializeLookup ();
    mEditText = (EditText) findViewById (R.id.edit_text);
    mButton00 = (Button) findViewById (R.id.button_0_0);
    mButton10 = (Button) findViewById (R.id.button_1_0);
    mButton01 = (Button) findViewById (R.id.button_0_1);
    mButton11 = (Button) findViewById (R.id.button_1_1);
    mButton02 = (Button) findViewById (R.id.button_0_2);
    mButton12 = (Button) findViewById (R.id.button_1_2);
    mButton00.setOnClickListener (this);
    mButton10.setOnClickListener (this);
    mButton01.setOnClickListener (this);
    mButton11.setOnClickListener (this);
    mButton02.setOnClickListener (this);
    mButton12.setOnClickListener (this);
    mHandleInputRunnable = new Runnable () {
        @Override
        public void run () {
            handleAlarmTrigger ();
        }}

    ;
}
----------------------------------------

protected void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.activity_main);
    Window window = this.getWindow ();
    window.addFlags (WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
    window.addFlags (WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
    window.addFlags (WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON);
    txtMessage = (TextView) findViewById (R.id.txtMesssage);
    Button buttonOne = (Button) findViewById (R.id.block1);
    Button buttonTwo = (Button) findViewById (R.id.block2);
    Button buttonThree = (Button) findViewById (R.id.block3);
    Button buttonFour = (Button) findViewById (R.id.block4);
    Button buttonFive = (Button) findViewById (R.id.block5);
    Button buttonSix = (Button) findViewById (R.id.block6);
    buttonOne.setOnClickListener (this);
    buttonTwo.setOnClickListener (this);
    buttonThree.setOnClickListener (this);
    buttonFour.setOnClickListener (this);
    buttonFive.setOnClickListener (this);
    buttonSix.setOnClickListener (this);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41519489_41519644_18_31
41519489_41519722_2_11
Title: Suggestions for performance improvements Java code 
----------------------------------------

public static void possibleStrings (int maxLength, char [] alphabet, String curr, Set < String > permutations) {
    if (curr.length () == maxLength) {
        permutations.add (curr);
    } else {
        for (char anAlphabet : alphabet) {
            possibleStrings (maxLength, alphabet, curr + anAlphabet, permutations);
        }
    }
}
----------------------------------------

static void possibleStrings (char [] alphabet, PrintWriter pw, char [] curr, int index) {
    if (index == curr.length) {
        pw.println (curr);
        return;
    }
    for (char c : alphabet) {
        curr [index] = c;
        possibleStrings (alphabet, pw, curr, index + 1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41523600_41523758_1_11
41523600_41524025_1_19
Title: How to check and validate more than one character of a string index? 
----------------------------------------

boolean isValid (String regiNum) {
    for (int i = 0;
    i < 11; i ++) {
        if (i == 8 || i == 10) {
        } else {
        }
    }
    return true;
}
----------------------------------------

boolean isValid (String reg) {
    if (reg.length < 11) {
        for (int i = 0;
        i < 11; i ++) {
            if (i == 8 || i == 10) {
                if (! Character.isLetter (reg.charAt (i))) {
                    return false;
                }
            } else {
                if (! Character.isDegit (reg.charAt (i))) {
                    return false;
                }
            }
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41529026_41529218_1_19
41529026_41529368_1_32
Title: Finding the 2nd max key of linked list? 
----------------------------------------

public Key secondMaxKey () {
    Node max = null;
    Node max_2nd = null;
    if (size () < 2) {
        return null;
    }
    for (Node x = first;
    x != null; x = x.next) {
        if (max == null || x.val.compareTo (max.val) > 0) {
            max_2nd = max;
            max = x;
        } else if (max_2nd == null || x.val.compareTo (max_2nd.val) > 0) {
            max_2nd = x;
        }

    }
    return max_2nd.key;
}
----------------------------------------

public Key secondMaxKey () {
    if (size () < 2) {
        return null;
    }
    Node max = null;
    Node max_2 = null;
    Node second = first.next;
    if (first.key.compareTo (second.key) > 0) {
        max = first;
        max_2 = second;
    } else {
        max = second;
        max_2 = first;
    }
    for (Node x = second.next;
    x != null; x = x.next) {
        if (x.key.compareTo (max.key) > 0) {
            max_2 = max;
            max = x;
        } else if ((x.key.compareTo (max_2.key) > 0) && (x.key.compareTo (max.key) < 0)) {
            max_2 = x;
        }

    }
    return max_2.key;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41529026_41529218_1_19
41529026_42172107_1_20
Title: Finding the 2nd max key of linked list? 
----------------------------------------

public Key secondMaxKey () {
    Node max = null;
    Node max_2nd = null;
    if (size () < 2) {
        return null;
    }
    for (Node x = first;
    x != null; x = x.next) {
        if (max == null || x.val.compareTo (max.val) > 0) {
            max_2nd = max;
            max = x;
        } else if (max_2nd == null || x.val.compareTo (max_2nd.val) > 0) {
            max_2nd = x;
        }

    }
    return max_2nd.key;
}
----------------------------------------

public Key secondMaxKey () {
    if (this.size () <= 1) return null;

    if (this.size () == 2) {
        if (first.key.compareTo (first.next.key) > 0) {
            return first.next.key;
        }
    }
    Key max = first.key;
    Key secondMax = first.next.key;
    Node n = first;
    for (Node x = n.next;
    x != null; x = x.next) {
        if (x.key.compareTo (max) >= 0) {
            secondMax = max;
            max = x.key;
        } else if (x.key.compareTo (secondMax) > 0) secondMax = x.key;

    }
    return secondMax;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41529026_41529368_1_32
41529026_41529832_1_25
Title: Finding the 2nd max key of linked list? 
----------------------------------------

public Key secondMaxKey () {
    if (size () < 2) {
        return null;
    }
    Node max = null;
    Node max_2 = null;
    Node second = first.next;
    if (first.key.compareTo (second.key) > 0) {
        max = first;
        max_2 = second;
    } else {
        max = second;
        max_2 = first;
    }
    for (Node x = second.next;
    x != null; x = x.next) {
        if (x.key.compareTo (max.key) > 0) {
            max_2 = max;
            max = x;
        } else if ((x.key.compareTo (max_2.key) > 0) && (x.key.compareTo (max.key) < 0)) {
            max_2 = x;
        }

    }
    return max_2.key;
}
----------------------------------------

public Key secondMaxKey () {
    Node max = first;
    Node max_2nd = null;
    Node temp = null;
    if (size () < 2) {
        return null;
    }
    for (Node x = first.next;
    x != null; x = x.next) {
        if (x.key.compareTo (max.key) > 0) {
            temp = max;
            max = x;
            if (temp.key.compareTo (max_2nd.key) > 0) {
                max_2nd = temp;
            }
        } else if (max_2nd == null || x.key.compareTo (max_2nd.key) > 0) {
            max_2nd = x;
        }

    }
    return max_2nd.key;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41529026_41529368_1_32
41529026_42172107_1_20
Title: Finding the 2nd max key of linked list? 
----------------------------------------

public Key secondMaxKey () {
    if (size () < 2) {
        return null;
    }
    Node max = null;
    Node max_2 = null;
    Node second = first.next;
    if (first.key.compareTo (second.key) > 0) {
        max = first;
        max_2 = second;
    } else {
        max = second;
        max_2 = first;
    }
    for (Node x = second.next;
    x != null; x = x.next) {
        if (x.key.compareTo (max.key) > 0) {
            max_2 = max;
            max = x;
        } else if ((x.key.compareTo (max_2.key) > 0) && (x.key.compareTo (max.key) < 0)) {
            max_2 = x;
        }

    }
    return max_2.key;
}
----------------------------------------

public Key secondMaxKey () {
    if (this.size () <= 1) return null;

    if (this.size () == 2) {
        if (first.key.compareTo (first.next.key) > 0) {
            return first.next.key;
        }
    }
    Key max = first.key;
    Key secondMax = first.next.key;
    Node n = first;
    for (Node x = n.next;
    x != null; x = x.next) {
        if (x.key.compareTo (max) >= 0) {
            secondMax = max;
            max = x.key;
        } else if (x.key.compareTo (secondMax) > 0) secondMax = x.key;

    }
    return secondMax;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41529026_41529832_1_25
41529026_42172107_1_20
Title: Finding the 2nd max key of linked list? 
----------------------------------------

public Key secondMaxKey () {
    Node max = first;
    Node max_2nd = null;
    Node temp = null;
    if (size () < 2) {
        return null;
    }
    for (Node x = first.next;
    x != null; x = x.next) {
        if (x.key.compareTo (max.key) > 0) {
            temp = max;
            max = x;
            if (temp.key.compareTo (max_2nd.key) > 0) {
                max_2nd = temp;
            }
        } else if (max_2nd == null || x.key.compareTo (max_2nd.key) > 0) {
            max_2nd = x;
        }

    }
    return max_2nd.key;
}
----------------------------------------

public Key secondMaxKey () {
    if (this.size () <= 1) return null;

    if (this.size () == 2) {
        if (first.key.compareTo (first.next.key) > 0) {
            return first.next.key;
        }
    }
    Key max = first.key;
    Key secondMax = first.next.key;
    Node n = first;
    for (Node x = n.next;
    x != null; x = x.next) {
        if (x.key.compareTo (max) >= 0) {
            secondMax = max;
            max = x.key;
        } else if (x.key.compareTo (secondMax) > 0) secondMax = x.key;

    }
    return secondMax;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41531672_41531809_1_27
41531672_41531834_7_27
Title: How to determine different behaviors with 2 booleans? 
----------------------------------------

public static void main (String [] args) throws Exception {
    boolean white = true, tall = false;
    StringBuilder result = new StringBuilder ();
    result.append (white ? 1 : 0);
    result.append (tall ? 1 : 0);
    switch (result.toString ()) {
        case "00" :
            break;
        case "01" :
            break;
        case "10" :
            break;
        case "11" :
            break;
    }
}
----------------------------------------

public static void main (String [] args) throws java.lang.Exception {
    System.out.println (getCaseNumber (true, true));
    System.out.println (getCaseNumber (true, false));
    System.out.println (getCaseNumber (false, true));
    System.out.println (getCaseNumber (false, false));
    switch (getCaseNumber (true, false)) {
        case 1 :
            System.out.println ("Case 1!");
            break;
        case 2 :
            System.out.println ("Case 2!");
            break;
        case 3 :
            System.out.println ("Case 3!");
            break;
        case 4 :
            System.out.println ("Case 4!");
            break;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41545169_41557258_4_12
41545169_41565527_1_17
Title: Recurring values in List<String> in Constructor java 
----------------------------------------

public Item () throws ParseException {
    synchronized (types) {
        if (null == types) {
            JsontoList j = new JsontoList ();
            String array = j.getarray ();
            types = j.getList (array);
        }
    }
}
----------------------------------------

public Item () throws ParseException {
    JsontoList j = new JsontoList ();
    array = j.getarray ();
    list1 = j.toList (array);
    list = j.getList (array);
    List < String > types = new ArrayList < String > ();
    types = list;
    Set < String > hs = new HashSet < > ();
    hs.addAll (types);
    types.clear ();
    types.addAll (hs);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41557914_41558407_1_10
41557914_41569911_1_20
Title: Recursion to normal loop convert 
----------------------------------------

public static double sum (int z, int x, int y) {
    int num = 0;
    for (int i = 0;
    i <= y; i ++) {
        if (z - x - i > 0) {
            num ++;
        }
    }
    return (double) (Math.pow (y, x) - num);
}
----------------------------------------

public static int sum (int z, int x, int y) {
    int [] [] calls = new int [x + 1] [x * y + 1];
    calls [0] [0] = 1;
    for (int i = 0;
    i < x; i ++) {
        for (int j = 0;
        j <= x * y; j ++) {
            for (int target = j + 1;
            target <= j + y && target <= x * y; target ++) {
                calls [i + 1] [target] += calls [i] [j];
            }
        }
    }
    int result = 0;
    for (int j = x * y;
    z - j <= 0; j --) {
        result += calls [x] [j];
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41560900_41560956_4_13
41560900_41561342_3_19
Title: How to shift elements in an array 1 over? 
----------------------------------------

public static void main (String [] args) {
    int [] array = new int [5];
    array [0] = 1;
    array [1] = 4;
    array [2] = 9;
    array [3] = 16;
    array [4] = 25;
    ShiftNumbers (array);
    System.out.print (Arrays.toString (array));
}
----------------------------------------

public static void main (String [] args) {
    int [] array = new int [5];
    array [0] = 1;
    array [1] = 4;
    array [2] = 9;
    array [3] = 16;
    array [4] = 25;
    shiftNumbers (array);
    printNumbers (array);
    shiftNumbers (array);
    printNumbers (array);
    shiftNumbers (array);
    printNumbers (array);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41560900_41561342_3_19
41560900_41562778_1_11
Title: How to shift elements in an array 1 over? 
----------------------------------------

public static void main (String [] args) {
    int [] array = new int [5];
    array [0] = 1;
    array [1] = 4;
    array [2] = 9;
    array [3] = 16;
    array [4] = 25;
    shiftNumbers (array);
    printNumbers (array);
    shiftNumbers (array);
    printNumbers (array);
    shiftNumbers (array);
    printNumbers (array);
}
----------------------------------------

public static void main (String [] args) {
    int [] array = new int [5];
    array [0] = 1;
    array [1] = 4;
    array [2] = 9;
    array [3] = 16;
    array [4] = 25;
    ReverseArray (array);
    System.out.print (Arrays.toString (array));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41562897_41564550_2_26
41562897_41567235_4_85
Title: java String-based on reverse 
----------------------------------------

public static void main (String [] args) {
    String input1 = "this is me.is this is me";
    String input2 = "is,me";
    String output = "";
    String [] wordsFromInput1 = input1.split ("[\\s.]");
    String [] wordsFromInput2 = input2.split (",");
    for (String tempWord1 : wordsFromInput1) {
        boolean existInSecond = false;
        for (String tempWord2 : wordsFromInput2) {
            if (tempWord1.equals (tempWord2)) {
                existInSecond = true;
                break;
            }
        }
        if (existInSecond) {
            output += tempWord1 + " ";
        } else {
            output += new StringBuffer (tempWord1).reverse () + " ";
        }
    }
    System.out.println (output.trim ());
}
----------------------------------------

public static void main (String args []) throws IOException {
    BufferedReader buf = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Enter the string to be selectively reversed");
    String str = buf.readLine ();
    str = str.trim ();
    str = " ".concat (str);
    int len = str.length ();
    System.out.println ("Enter the words to be left intact during reversal");
    String s = buf.readLine ();
    int l = s.length ();
    int j = 0;
    int k = len - 1;
    int wordcount = 1;
    String result = "";
    for (int i = 0;
    i < l; i ++) {
        if (s.charAt (i) == ',') {
            wordcount ++;
        }
    }
    String arr [] = new String [wordcount];
    int counter = 0;
    for (int i = 0;
    i < l; i ++) {
        if (s.charAt (i) == ',') {
            String subs = s.substring (j, i);
            arr [counter] = subs;
            j = i + 1;
            counter ++;
        }
    }
    arr [counter] = s.substring (j);
    boolean firstflag = false;
    for (int i = len - 1;
    i >= 0; i --) {
        String substr;
        if (str.charAt (i) == ' ' || str.charAt (i) == '.') {
            if (firstflag == false) {
                substr = str.substring (i + 1);
                firstflag = true;
                k = i;
            } else {
                substr = str.substring (i + 1, k);
                k = i;
            }
            boolean flag = false;
            for (int m = 0;
            m < wordcount; m ++) {
                if (arr [m].equalsIgnoreCase (substr)) {
                    flag = true;
                }
            }
            if (flag == true) {
                result = result + substr;
                result = result + " ";
            } else {
                String reverse = "";
                int ln = substr.length ();
                for (int n = ln - 1;
                n >= 0; n --) {
                    char ch = substr.charAt (n);
                    String chstring = Character.toString (ch);
                    reverse = reverse + chstring;
                }
                result = result + reverse;
                result = result + " ";
            }
        }
    }
    System.out.println (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41565134_41565222_1_11
41565134_41570298_1_11
Title: Factoring try catch 
----------------------------------------

private static Response respond (Responder responder) {
    try {
        return responder.handleRequest ();
    } catch (MyCustomException e1) {
        return Response.status (409).build ();
    } catch (UnauthorizedException e2) {
        return Response.status (401).build ();
    } catch (Exception e3) {
        return Response.status (500).build ();
    }
}
----------------------------------------

private static Response respond (Responder responder) {
    try {
        return responder.handleRequest ();
    } catch (MyCustomException e1) {
        return Response.status (409).build ();
    } catch (UnauthorizedException e2) {
        return Response.status (401).build ();
    } catch (Exception e3) {
        return Response.status (500).build ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41566601_41566656_1_11
41566601_41566724_1_13
Title: Java beginner advancing sum in array 
----------------------------------------

public static void main (String [] args) {
    int [] array = new int [] {0, 5, 1, - 3, 2, 0, 4};
    int [] newArray = new int [7];
    int x = 0;
    for (int i = 0;
    i < array.length; i ++) {
        x += array [i];
        newArray [i] = x;
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] array = new int [] {0, 5, 1, - 3, 2, 0, 4};
    int [] newArray = new int [7];
    int sum = 0;
    for (int i = 0;
    i < array.length; i ++) {
        sum += array [i];
        newArray [i] = sum;
        System.out.println (" " + newArray [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41566601_41566724_1_13
41566601_41566787_4_16
Title: Java beginner advancing sum in array 
----------------------------------------

public static void main (String [] args) {
    int [] array = new int [] {0, 5, 1, - 3, 2, 0, 4};
    int [] newArray = new int [7];
    int sum = 0;
    for (int i = 0;
    i < array.length; i ++) {
        sum += array [i];
        newArray [i] = sum;
        System.out.println (" " + newArray [i]);
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] originalArray = new int [] {0, 5, 1, - 3, 2, 0, 4};
    int [] sumArray = new int [originalArray.length];
    int runningTotal = 0;
    for (int i = 0;
    i < originalArray.length; i ++) {
        runningTotal += originalArray [i];
        sumArray [i] = runningTotal;
    }
    System.out.println ("The originalArray is: " + Arrays.toString (originalArray));
    System.out.println ("The sumArray is: " + Arrays.toString (sumArray));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41571393_41571476_2_16
41571393_41571487_1_10
Title: unable to start android service from activity that is in the different package 
----------------------------------------

public void onStartButtonClick (View view) {
    Intent myIntentToStartAlertListActivity = new Intent (LoginActivity.this, AlertService.class);
    String pkg = "nl.test.app.messaging";
    String cls = "nl.test.app.messaging.AlertService";
    myIntentToStartAlertListActivity.setComponent (new ComponentName (pkg, cls));
    if (startService (myIntentToStartAlertListActivity) != null) {
        Log.i ("Service Started", "Service started");
        Toast.makeText (getApplicationContext (), "Service is running\n", Toast.LENGTH_LONG).show ();
    } else {
        Toast.makeText (getApplicationContext (), "Service is not running\n", Toast.LENGTH_LONG).show ();
    }
}
----------------------------------------

public void onStartButtonClick (View view) {
    Intent myIntentToStartAlertListActivity = new Intent (LoginActivity.this, AlertService.class);
    if (startService (myIntentToStartAlertListActivity) != null) {
        Log.i ("Service Started", "Service started");
        Toast.makeText (getApplicationContext (), "Service is running\n", Toast.LENGTH_LONG).show ();
    } else {
        Toast.makeText (getApplicationContext (), "Service is not running\n", Toast.LENGTH_LONG).show ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4157675_4157761_2_15
4157675_4158039_3_25
Title: "Java: how to create 10 cats? when Cat (""cat"" + i) = ""cat name"" not working as in other languages" 
----------------------------------------

public static void main (String [] args) {
    Cat [] cats = new Cat [10];
    for (int i = 0;
    i < 10; i ++) {
        cats [i] = new Cat ("Cat " + i + 1);
    }
    for (Cat aCat : cats) {
        System.out.printLn ("My Cat is: " + aCat);
    }
}
----------------------------------------

public static void main (String [] args) {
    Cat [] cats = new Cat [10];
    Vector catsUnlimited = new Vector (10);
    Cat myCat = null;
    for (int i = 1;
    i < 11; i ++) {
        myCat = new Cat ("Cat" + i);
        cats [i - 1] = myCat;
        catsUnlimited.addElement (new Cat ("Cat" + i));
        System.out.println ("My cat is:  " + cats [i - 1]);
    }
    System.out.println ("Known cats");
    for (int x = 0;
    x < catsUnlimited.size (); x ++) {
        System.out.println ("Cat #" + (x + 1) + ":" + (Cat) catsUnlimited.get (x));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4157675_4157761_2_15
4157675_4158258_4_15
Title: "Java: how to create 10 cats? when Cat (""cat"" + i) = ""cat name"" not working as in other languages" 
----------------------------------------

public static void main (String [] args) {
    Cat [] cats = new Cat [10];
    for (int i = 0;
    i < 10; i ++) {
        cats [i] = new Cat ("Cat " + i + 1);
    }
    for (Cat aCat : cats) {
        System.out.printLn ("My Cat is: " + aCat);
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    int x = 0;
    DataInputStream in = new DataInputStream (System.in);
    x = Integer.parseInt (in.readLine ());
    Cat [] cats = new Cat [x];
    for (int i = 1;
    i < x; i ++) {
        cats [i - 1] = new Cat ("Cat" + i);
        System.out.println ("My cat is:  " + cats [i - 1]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4157675_4158039_3_25
4157675_4158258_4_15
Title: "Java: how to create 10 cats? when Cat (""cat"" + i) = ""cat name"" not working as in other languages" 
----------------------------------------

public static void main (String [] args) {
    Cat [] cats = new Cat [10];
    Vector catsUnlimited = new Vector (10);
    Cat myCat = null;
    for (int i = 1;
    i < 11; i ++) {
        myCat = new Cat ("Cat" + i);
        cats [i - 1] = myCat;
        catsUnlimited.addElement (new Cat ("Cat" + i));
        System.out.println ("My cat is:  " + cats [i - 1]);
    }
    System.out.println ("Known cats");
    for (int x = 0;
    x < catsUnlimited.size (); x ++) {
        System.out.println ("Cat #" + (x + 1) + ":" + (Cat) catsUnlimited.get (x));
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    int x = 0;
    DataInputStream in = new DataInputStream (System.in);
    x = Integer.parseInt (in.readLine ());
    Cat [] cats = new Cat [x];
    for (int i = 1;
    i < x; i ++) {
        cats [i - 1] = new Cat ("Cat" + i);
        System.out.println ("My cat is:  " + cats [i - 1]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41587736_41588027_1_16
41587736_41589947_1_12
Title: Java compiler error 'missing return statement' when using recursion 
----------------------------------------

public int traverse (Node n) {
    int returnValue = - 1;
    for (int i = 0;
    i < n.getNumEdges (); i ++) {
        if (n.getEdgeChar (i) == '#') {
            returnValue = 1;
            break;
        } else {
            returnValue = traverse ((n.getEdge (i)).getNode ());
            break;
        }
    }
    return returnValue;
}
----------------------------------------

public int traverse (Node n) {
    int numOfLeaves = 0;
    for (int i = 0;
    i < n.getNumEdges (); i ++) {
        if (n.getEdgeChar (i) == '#') {
            numOfLeaves += 1;
        } else {
            numOfLeaves += traverse ((n.getEdge (i)).getNode ());
        }
    }
    return numOfLeaves;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41609693_41609839_4_19
41609693_41610008_1_17
Title: How to avoid repeating code in Android across classes? 
----------------------------------------

public static String getPostcode (Context context, double lat, double lng) {
    Geocoder geoCoder = new Geocoder (context, Locale.getDefault ());
    List < Address > address = null;
    if (geoCoder != null) {
        try {
            address = geoCoder.getFromLocation (lat, lng, 1);
        } catch (IOException e1) {
            e1.printStackTrace ();
        }
        if (address.size () > 0) {
            return address.get (0).getPostalCode ();
        }
    }
    return null;
}
----------------------------------------

private String getPostcode (Activity activity, Double latitude, Double longitude) {
    String userPostcode = null;
    Geocoder geoCoder = new Geocoder (activity.getApplicationContext (), Locale.getDefault ());
    List < Address > address = null;
    if (geoCoder != null) {
        try {
            address = geoCoder.getFromLocation (latitude, longitude, 1);
        } catch (IOException e1) {
            e1.printStackTrace ();
        }
        if (address.size () > 0) {
            userPostcode = address.get (0).getPostalCode ();
        }
    }
    return userPostcode;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41609693_41609839_4_19
41609693_41610886_32_50
Title: How to avoid repeating code in Android across classes? 
----------------------------------------

public static String getPostcode (Context context, double lat, double lng) {
    Geocoder geoCoder = new Geocoder (context, Locale.getDefault ());
    List < Address > address = null;
    if (geoCoder != null) {
        try {
            address = geoCoder.getFromLocation (lat, lng, 1);
        } catch (IOException e1) {
            e1.printStackTrace ();
        }
        if (address.size () > 0) {
            return address.get (0).getPostalCode ();
        }
    }
    return null;
}
----------------------------------------

public String getPostcode () {
    String userPostcode = "";
    Geocoder geoCoder = new Geocoder (mContext, Locale.getDefault ());
    List < Address > address = null;
    if (geoCoder != null) {
        try {
            address = geoCoder.getFromLocation (mLatitude, mLongitude, 1);
        } catch (IOException e1) {
            e1.printStackTrace ();
        }
        if (address != null && address.size () > 0) {
            userPostcode = address.get (0).getPostalCode ();
        }
    }
    return userPostcode;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4161177_4161329_1_21
4161177_4161333_9_18
Title: Finding index of array where min value occurs 
----------------------------------------

public static final int findShortestString (final String [] arr, final int index, final int minIndex) {
    if (index >= arr.length - 1) {
        return minIndex;
    }
    if (- 1 == safeStringLength (arr [index])) {
        return index;
    }
    int currentMinIncex = minIndex;
    if (safeStringLength (arr [minIndex]) > safeStringLength (arr [index + 1])) {
        currentMinIncex = index + 1;
    }
    return findShortestString (arr, index + 1, currentMinIncex);
}
----------------------------------------

static int findShortestString (String [] paths, int lo, int hi) {
    if (lo == hi) return lo;

    if (paths [lo] == null) return findShortestString (paths, lo + 1, hi);

    int bestIndex = findShortestString (paths, lo + 1, hi);
    if (safeStringLength [lo] < safeStringLength [bestIndex]) return lo;

    return bestIndex;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41617047_41637878_1_21
41617047_41677078_1_23
Title: Get absolute position of character in JEditorPane 
----------------------------------------

static Point getLocation (int pos, JEditorPane editorPane) throws BadLocationException {
    HTMLDocument doc = (HTMLDocument) editorPane.getDocument ();
    View view = editorPane.getUI ().getRootView (editorPane);
    int index;
    while ((index = view.getViewIndex (pos, Position.Bias.Backward)) >= 0) {
        view = view.getView (index);
    }
    AttributeSet attr = doc.getStyleSheet ().getViewAttributes (view);
    Font f = doc.getStyleSheet ().getFont (attr);
    FontMetrics metrics = editorPane.getFontMetrics (f);
    Rectangle rect = editorPane.modelToView (pos);
    return new Point (rect.x, rect.y + rect.height - metrics.getDescent () - metrics.getAscent ());
}
----------------------------------------

static Point getLocation (int pos, JEditorPane editorPane) throws BadLocationException {
    View view = editorPane.getUI ().getRootView (editorPane);
    int index;
    while ((index = view.getViewIndex (pos, Position.Bias.Backward)) >= 0) {
        view = view.getView (index);
    }
    AttributeSet set = view.getAttributes ();
    if (set != null && set.getAttribute (StyleConstants.FontFamily) != null) {
        Font f = new Font ((String) set.getAttribute (StyleConstants.FontFamily), Font.PLAIN, (Integer) set.getAttribute (StyleConstants.FontSize));
        FontMetrics metrics = editorPane.getFontMetrics (f);
        Rectangle rect = editorPane.modelToView (pos);
        return new Point (rect.x, rect.y + rect.height - metrics.getDescent () - metrics.getAscent ());
    } else {
        return new Point (0, 0);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41622027_41622412_15_33
41622027_41622945_32_41
Title: Performance for Java Stream.concat VS Collection.addAll 
----------------------------------------

public void setUp (final int howMany, final int distinct) {
    final Set < String > valuesForA = new HashSet < > (howMany);
    final Set < String > valuesForB = new HashSet < > (howMany);
    if (- 1 == distinct) {
        for (int i = 0;
        i < howMany; ++ i) {
            valuesForA.add (Integer.toString (i));
            valuesForB.add (Integer.toString (howMany + i));
        }
    } else {
        Random r = new Random ();
        for (int i = 0;
        i < howMany; ++ i) {
            int j = r.nextInt (distinct);
            valuesForA.add (Integer.toString (i));
            valuesForB.add (Integer.toString (distinct + j));
        }
    }
    s1 = valuesForA;
    s2 = valuesForB;
}
----------------------------------------

public void setUp () {
    final Set < String > valuesForA = new HashSet < > ();
    final Set < String > valuesForB = new HashSet < > ();
    for (int i = 0;
    i < 1000; ++ i) {
        valuesForA.add (Integer.toString (i));
        valuesForB.add (Integer.toString (1000 + i));
    }
    s1 = valuesForA;
    s2 = valuesForB;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41625277_41625511_3_34
41625277_41625797_4_34
Title: Missing a logic on table based printing in Java 
----------------------------------------

public static void main (String [] args) {
    String word = "hello";
    int num = 0;
    char [] reverseWord = new char [word.length ()];
    int counter = 0;
    for (int i = word.length () - 1;
    i >= 0; i --) {
        reverseWord [counter] = word.charAt (i);
        counter ++;
    }
    for (int i = 0;
    i < word.length (); i ++) {
        counter = 0;
        for (int j = 0;
        j < word.length (); j ++) {
            if (i == 0) {
                System.out.print (word.charAt (j));
            } else {
                if (j == 0) {
                    System.out.print (word.charAt (i));
                } else if (j < (word.length () - 1)) {
                    if (i < (word.length () - 1)) {
                        System.out.print (" ");
                    } else {
                        System.out.print (reverseWord [j]);
                    }
                } else {
                    System.out.print (reverseWord [i]);
                }

            }
        }
        System.out.println ("");
    }
}
----------------------------------------

public static void main (String [] args) {
    String input = "hello";
    String middleSpaces = null;
    StringBuilder middleSpace = new StringBuilder ();
    middleSpace.append ("%");
    middleSpace.append (String.valueOf (input.length () - 2));
    middleSpace.append ("s");
    middleSpaces = String.format (middleSpace.toString (), " ");
    System.out.println (input);
    for (int i = 1;
    i <= input.length () - 2; i ++) {
        StringBuilder middleLine = new StringBuilder ();
        middleLine.append (input.charAt (i));
        middleLine.append (middleSpaces);
        middleLine.append (input.charAt (input.length () - 1 - i));
        System.out.println (middleLine.toString ());
    }
    StringBuilder lastLine = new StringBuilder ();
    lastLine.append (input);
    lastLine = lastLine.reverse ();
    System.out.println (lastLine);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41635425_41636056_16_34
41635425_41637990_16_31
Title: Global variable's value doesn't change after for Loop 
----------------------------------------

public void map (LongWritable key, Text value, Context context) throws IOException, InterruptedException {
    Date t = null;
    String [] line = value.toString ().split (",");
    String customer = line [0];
    try {
        t = ft.parse (line [1]);
    } catch (ParseException e) {
        throw new RuntimeException ("something wrong with the date!" + line [1]);
    }
    Integer consumption = Integer.parseInt (line [2]);
    if (t.compareTo (ft.parse ("2013-07-01 01:00:00")) == 0 && consumption == max) {
        context.write (new Text (customer), new IntWritable (consumption));
    }
    counter ++;
}
----------------------------------------

public void map (Object key, Text value, Context context) throws IOException, InterruptedException {
    try {
        lineno ++;
        filterDate = ft.parse (maxConsumptionDate.toString ());
        String [] fields = value.toString ().split (",");
        customer.set (fields [0].trim ());
        dateInFile = ft.parse (fields [1].trim ());
        consumption.set (Integer.parseInt (fields [2].trim ()));
        if (dateInFile.equals (filterDate)) context.write (new Text (customer), consumption);

    } catch (Exception e) {
        System.err.println ("Invaid Data at line: " + lineno + " Error: " + e.getMessage ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41636659_41636966_1_15
41636659_41637375_18_26
Title: How to add '.' before every consonant in a string? 
----------------------------------------

public static void main (String [] args) {
    String s = "The Boy is a good boy";
    StringBuilder newString = new StringBuilder ();
    for (int i = 0;
    i < s.length (); i ++) {
        if (! (s.charAt (i) == 'a' || s.charAt (i) == 'e' || s.charAt (i) == 'i' || s.charAt (i) == 'o' || s.charAt (i) == 'u' || s.charAt (i) == 'A' || s.charAt (i) == 'E' || s.charAt (i) == 'I' || s.charAt (i) == 'U' || s.charAt (i) == 'O' || s.charAt (i) == ' ')) {
            newString.append ('.');
        }
        newString.append (s.charAt (i));
    }
    System.out.println (newString);
}
----------------------------------------

public static void main (String [] args) {
    String inputString = "Hello";
    String newString = "";
    for (int i = 0;
    i < inputString.length (); i ++) {
        newString += addDots (inputString.charAt (i));
    }
    System.out.println ("Output " + newString);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41654756_41654811_1_14
41654756_41656913_1_26
Title: LinkedList why do we have to create the dummy here? 
----------------------------------------

public void swapPairs (ListNode head) {
    if (head != null) {
        while (head.next != null && head.next.next != null) {
            ListNode n1 = head.next, n2 = head.next.next;
            head.next = n2;
            n1.next = n2.next;
            n2.next = n1;
            head = n1;
        }
    }
}
----------------------------------------

public ListNode swapPairs (ListNode head) {
    if (head != null || head.next != null) {
        ListNode n1 = head;
        ListNode n2 = n1.next;
        head = n2;
        n1.next = n2.next;
        n2.next = n1;
        ListNode pred = n1;
        while (pred.next != null && pred.next.next != null) {
            n1 = pred.next;
            n2 = n1.next;
            pred.next = n2;
            n1.next = n2.next;
            n2.next = n1;
            pred = n1;
        }
    }
    return head;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41655446_41655775_9_47
41655446_41655836_4_24
Title: "I am trying to write a program that allows me to input multiple integers but it won't allow me to enter in my set of integers" 
----------------------------------------

public static void main (String [] args) {
    Scanner scan = new Scanner (System.in);
    int sum = 0, minNumber = 0, nCount = 0, countEvenIntegers = 0, sumPositive = 0;
    Scanner sc = new Scanner (System.in);
    List < Integer > numbers = new ArrayList < Integer > ();
    while (true) {
        int i = sc.nextInt ();
        if (i == 0) {
            break;
        }
        numbers.add (i);
    }
    if (numbers.size () > 0) {
        minNumber = numbers.get (0);
    }
    for (int number : numbers) {
        sum += number;
        if (minNumber > number) {
            minNumber = number;
        }
        if (number % 2 == 0) {
            countEvenIntegers ++;
        }
        if (number > 0) {
            sumPositive += number;
        }
    }
    nCount = numbers.size ();
    System.out.println ("The minimum integer is " + minNumber + "\nThe count of integers is " + nCount + "\nThe sum of positive integers is " + sumPositive + "\nThe count of even integers in the sequence is " + countEvenIntegers + "\nThe total sum is " + sum);
}
----------------------------------------

public static void main (String [] args) {
    int sum = 0, minNumber = 0, nCount = 0, countEvenIntegers = 0;
    Scanner sc = new Scanner (System.in);
    while (true) {
        int input = sc.nextInt ();
        if (input == 0) {
            break;
        }
        sum += input;
        nCount += 1;
    }
    System.out.println ("The minimum integer is " + minNumber);
    System.out.println ("The count of integers is " + nCount);
    System.out.println ("The sum of positive integers is " + sum);
    System.out.println ("The count of even integers in the sequence is " + countEvenIntegers);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41664943_41691649_1_37
41664943_41731879_39_56
Title: Jackson Serialization: Different formats for XML and JSON 
----------------------------------------

public static void main (String [] args) {
    Attribute a1 = new Attribute ();
    a1.id = 1;
    a1.value = 100;
    a1.name = "numericAttribute";
    Attribute a2 = new Attribute ();
    a2.id = 2;
    a2.value = 200;
    a2.name = "textAttribute";
    Map < String, Attribute > atts = new HashMap < > ();
    atts.put ("numeric", a1);
    atts.put ("text", a2);
    Key k1 = new Key ();
    k1.id = 10;
    k1.name = "key1";
    Key k2 = new Key ();
    k2.id = 20;
    k2.name = "key2";
    Data data = new Data ();
    data.attributes = new HashMap < > ();
    data.attributes.put (k1, atts);
    data.attributes.put (k2, atts);
    ObjectMapper mapper;
    if ("xml".equals (args [0])) {
        mapper = new XmlMapper ();
        mapper.registerModule (new XmlModule ());
    } else {
        mapper = new ObjectMapper ();
    }
    try {
        mapper.writeValue (System.out, data);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Pojo pojo = new Pojo ();
    SimpleModule objectMapperModule = new SimpleModule ();
    objectMapperModule.addSerializer (PojoField.class, new PojoFieldJSonSerializer ());
    ObjectMapper objectMapper = new ObjectMapper ();
    objectMapper.registerModule (objectMapperModule);
    objectMapper.writeValue (new File ("pojo.json"), pojo);
    SimpleModule xmlMapperModule = new SimpleModule ();
    xmlMapperModule.addSerializer (PojoField.class, new PojoFieldXmlSerializer ());
    XmlMapper xmlMapper = new XmlMapper ();
    xmlMapper.registerModule (xmlMapperModule);
    xmlMapper.writeValue (new File ("pojo.xml"), pojo);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41665326_41665367_1_25
41665326_41665431_7_18
Title: Input/output Java example 
----------------------------------------

public static void main (String [] args) {
    double waterLevel, initialWaterLeve;
    waterLevel = 0;
    initialWaterLeve = 0;
    int count = 0;
    Scanner sc = new Scanner (System.in);
    while (waterLevel > 0) {
        System.out.println ("What is the water level at now (in mm): ");
        waterLevel = sc.nextDouble ();
        if (waterLevel < initialWaterLevel) {
            count ++;
        } else {
            count = 0;
        }
        if (count >= 3) {
            System.out.println ("It appears that the flood is subsiding.");
            break;
        }
        initialWaterLevel = waterLevel;
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    while (true) {
        System.out.println ("What is the water level at now (in mm): ");
        currentWaterLevel = scanner.nextDouble ();
        waterLevels.add (currentWaterLevel);
        if (isFloodSubsiding ()) System.out.println ("Flood is subsiding");

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41676818_41676956_1_13
41676818_41678171_1_15
Title: Android Login Page Not Working Properly 
----------------------------------------

public void doSubmit (View view) {
    boolean login_validation_result = false;
    EditText name, username, e_mail;
    EditText password, re_enter_pass;
    name = (EditText) findViewById (R.id.name);
    username = (EditText) findViewById (R.id.userName);
    password = (EditText) findViewById (R.id.password);
    e_mail = (EditText) findViewById (R.id.e_mail);
    login_validation_result = login_validation ();
    if (login_validation_result == true) {
        Toast.makeText (this, "Success ful", Toast.LENGTH_SHORT).show ();
    }
}
----------------------------------------

public void doSubmit (View view) {
    boolean login_validation_result = false;
    EditText name, username, e_mail;
    EditText password, re_enter_pass;
    name = (EditText) findViewById (R.id.name);
    username = (EditText) findViewById (R.id.userName);
    password = (EditText) findViewById (R.id.password);
    e_mail = (EditText) findViewById (R.id.e_mail);
    login_validation_result = login_validation (false / true);
    if (login_validation_result == true) {
        Toast respond = new Toast (this);
        respond.makeText (this, "Success ful", Toast.LENGTH_SHORT).show ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41681331_41682134_1_20
41681331_41682186_1_22
Title: Listview scrolling is not working 
----------------------------------------

@Override
public View getView (int position, View convertView, ViewGroup parent) {
    View row = convertView;
    viewHolder holder = null;
    if (row == null) {
        LayoutInflater inflater = (LayoutInflater) context.getSystemService (Context.LAYOUT_INFLATER_SERVICE);
        row = inflater.inflate (R.layout.contact_list_style, parent, false);
        holder = new viewHolder (row);
        row.setTag (holder);
    } else {
        holder = (Holder) row.getTag ();
        Toast.makeText (context, "GRRRRRRRRRRR", Toast.LENGTH_SHORT).show ();
    }
    RowData temp = list.get (position);
    holder.user_name.setText (temp.user_name);
    holder.message_stats.setImageResource (temp.message_status);
    holder.user_img.setImageResource (temp.user_img);
    holder.user_message.setText (temp.user_msg);
    return row;
}
----------------------------------------

@Override
public View getView (int position, View convertView, ViewGroup parent) {
    View row = convertView;
    viewHolder holder = null;
    if (row == null) {
        LayoutInflater inflater = (LayoutInflater) context.getSystemService (Context.LAYOUT_INFLATER_SERVICE);
        row = inflater.inflate (R.layout.contact_list_style, parent, false);
        holder = new viewHolder (row);
        row.setTag (holder);
    } else {
        Toast.makeText (context, "GRRRRRRRRRRR", Toast.LENGTH_SHORT).show ();
        holder = (viewHolder) row.getTag ();
    }
    RowData temp = list.get (position);
    holder.user_name.setText (temp.user_name);
    holder.message_stats.setImageResource (temp.message_status);
    holder.user_img.setImageResource (temp.user_img);
    holder.user_message.setText (temp.user_msg);
    return row;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41684816_41684982_4_33
41684816_41685012_4_23
Title: Adding message when certain condition is met (Java) 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    System.out.println ("Java_Paws's Average of Numbers Program");
    System.out.println ("======================================");
    System.out.println ("Usage: Please enter numbers one per line and enter a 0 to output the average of the numbers:");
    double total = 0.0;
    int count = 0;
    while (scanner.hasNext ()) {
        if (scanner.hasNextDouble ()) {
            double inputNum = scanner.nextDouble ();
            if (inputNum == 0) {
                if (count == 0) {
                    System.out.println ("Error: Please enter some numbers first!");
                } else {
                    System.out.println ("\nThe average of the entered numbers is: " + (total / count));
                    break;
                }
            } else {
                total += inputNum;
                count ++;
            }
        } else {
            System.out.println ("ERROR: Invalid Input");
            System.out.print ("Please enter a number: ");
            scanner.next ();
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int number, average, total = 0, counter = 0;
    boolean firstTime = true;
    Scanner fromKeyboard = new Scanner (System.in);
    do {
        System.out.println ("Enter number to calculate the average, or 0 to exit");
        number = fromKeyboard.nextInt ();
        if (firstTime && number == 0) {
            System.out.println ("error enter number first");
            number = - 1;
            continue;
        }
        firstTime = false;
        total = total + number;
        counter = counter + 1;
        average = (total) / counter;
    } while (number != 0);
    System.out.println ("The average of all numbers entered is: " + average);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41685700_41686550_2_25
41685700_41686674_18_25
Title: Two JPanels in one JFrame 
----------------------------------------

public static void main (String [] args) {
    JFrame jframe = new JFrame ();
    jframe.setTitle ("Title");
    jframe.setResizable (false);
    GridLayout gridLayout = new GridLayout (0, 2);
    jframe.setLayout (gridLayout);
    gridLayout.layoutContainer (jframe);
    JPanel leftPanel = new JPanel ();
    leftPanel.add (new Label ("Left side"));
    jframe.add (leftPanel);
    JPanel rightPanel = new JPanel ();
    rightPanel.add (new Label ("Right side"));
    jframe.add (rightPanel);
    jframe.setSize (800, 500);
    jframe.setVisible (true);
    jframe.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            new Application ().createAndShowGui ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41686479_41686660_7_17
41686479_41687486_53_78
Title: Simple Object class and records 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Car1: ");
    car1.getMake ();
    car1.setMake (in);
    car1.getModel ();
    car1.setModel (in);
    car1.getYear ();
    car1.setYear (in);
}
----------------------------------------

public static void main (String [] args) throws IOException {
    File file = new File ("");
    Scanner in = new Scanner (System.in);
    if (! file.exists ()) {
        FileWriter writeFile = new FileWriter ("cars.txt");
    }
    Car [] cars = new Car [5];
    for (int i = 0;
    i < 5; i ++) {
        Car myCar = new Car ();
        System.out.println ("Enter information for Car" + (i + 1) + ":");
        System.out.println ();
        System.out.print ("Car" + (i + 1) + ": ");
        myCar.setMake (in);
        System.out.print ("Model: ");
        myCar.setModel (in);
        System.out.print ("Year: ");
        in.nextLine ();
        System.out.println ();
        cars [i] = myCar;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41686774_41813929_41_51
41686774_41813929_53_63
Title: Pack header and data layout in one byte array using ByteBuffer in an efficient way? 
----------------------------------------

public void withBuffer (Consumer < ByteBuffer > action) {
    if (action == null) throw new IllegalArgumentException ("action must not be null.");

    ByteBuffer buffer = acquire ();
    try {
        action.accept (buffer);
    } finally {
        release (buffer);
    }
}
----------------------------------------

public < T > T withBuffer (Function < ByteBuffer, T > function) {
    if (function == null) throw new IllegalArgumentException ("function must not be null.");

    ByteBuffer buffer = acquire ();
    try {
        return function.apply (buffer);
    } finally {
        release (buffer);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4168772_23026934_8_25
4168772_53173829_1_23
Title: Java concurrency: Countdown latch vs Cyclic barrier 
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    barrier = new CyclicBarrier (3);
    new Worker ().start ();
    Thread.sleep (1000);
    new Worker ().start ();
    Thread.sleep (1000);
    new Worker ().start ();
    Thread.sleep (1000);
    System.out.println ("Barrier automatically resets.");
    new Worker ().start ();
    Thread.sleep (1000);
    new Worker ().start ();
    Thread.sleep (1000);
    new Worker ().start ();
}
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    barrier = new CyclicBarrier (3, new Runnable () {
        @Override
        public void run () {
            System.out.println ("I run in the beginning and after the CyclicBarrier is tipped");
        }}

    );
    new Worker ().start ();
    Thread.sleep (1000);
    new Worker ().start ();
    Thread.sleep (1000);
    new Worker ().start ();
    Thread.sleep (1000);
    System.out.println ("Barrier automatically resets.");
    new Worker ().start ();
    Thread.sleep (1000);
    new Worker ().start ();
    Thread.sleep (1000);
    new Worker ().start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4168937_4169223_6_30
4168937_4169616_50_61
Title: Reading part of file with BufferedReader 
----------------------------------------

public static void main (String [] args) {
    StringBuffer buffer = new StringBuffer ();
    int length = 4;
    try {
        Reader fileReader = new BufferedReader (new FileReader ("teststring"));
        for (int i = 0;
        i < length && fileReader.ready (); i ++) {
            buffer.append ((char) fileReader.read ());
        }
        while (fileReader.ready ()) {
            System.out.println (buffer);
            buffer.deleteCharAt (0);
            buffer.append ((char) fileReader.read ());
        }
        System.out.println (buffer);
    } catch (IOException e) {
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    final StringBuilder sb = new StringBuilder ();
    consume (new StringReader ("hi my name is joe..."), new CharConsumer () {
        @Override
        public void consume (char [] chars) {
            sb.append ('<');
            sb.append (chars);
            sb.append ('>');
        }}

    );
    System.out.println (sb.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4168937_4169616_27_44
4168937_4210621_9_24
Title: Reading part of file with BufferedReader 
----------------------------------------

public static void consume (Reader rd, CharConsumer consumer) throws IOException {
    char [] chars = new char [4];
    int c;
    for (int i = 0;
    i < chars.length; i ++) {
        if ((c = rd.read ()) == - 1) {
            return;
        }
        chars [i] = (char) c;
    }
    consumer.consume (chars);
    while ((c = rd.read ()) != - 1) {
        System.arraycopy (chars, 1, chars, 0, chars.length - 1);
        chars [chars.length - 1] = (char) c;
        consumer.consume (chars);
    }
}
----------------------------------------

static void consume (Reader rd, int length) throws IOException {
    StringBuilder sb = new StringBuilder ();
    int c;
    for (int i = 0;
    i < length - 1; i ++) {
        if ((c = rd.read ()) == - 1) return;

        sb.append ((char) c);
    }
    while ((c = rd.read ()) != - 1) {
        sb.append ((char) c);
        System.out.println ("<" + sb + "><![CDATA[");
        sb.deleteCharAt (0);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41697656_44759325_20_38
41697656_44760806_22_73
Title: Dispose Child Thread As per the Id 
----------------------------------------

private void doTheWork () throws InterruptedException {
    ExecutorService executorService = Executors.newFixedThreadPool (TOTAL_THREADS_TO_PROCESS_CUSTOMER_WORK);
    while (customerCounter < 10) {
        try {
            CustomerInput customerInput = getWorkFromCustomer ();
            System.out.println ("main program. received work from customer: " + customerInput.getCustomerId ());
            executorService.submit (new WorkToBeDone (customerInput.getCustomerId (), customerInput.getWorkInfo ()));
        } catch (InterruptedException e) {
            break;
        }
        customerCounter ++;
    }
    executorService.shutdown ();
    executorService.awaitTermination (5, TimeUnit.SECONDS);
}
----------------------------------------

private void doTheWork () throws InterruptedException {
    final ExecutorService executorService = Executors.newFixedThreadPool (TOTAL_THREADS_TO_PROCESS_CUSTOMER_WORK);
    Map < String, Future < String > > map = new ConcurrentHashMap < > ();
    while (customerCounter < 11) {
        try {
            WorkToBeDone workToBeDone = getWorkFromCustomer ();
            System.out.println ("main program. received work from customer: " + workToBeDone.getClientId ());
            Future < String > resultFuture = executorService.submit (workToBeDone);
            map.put (workToBeDone.getClientId (), resultFuture);
        } catch (InterruptedException e) {
            break;
        }
        customerCounter ++;
    }
    Future < String > resultFuture = map.get ("10");
    System.out.println ("cancelling job of customerId: 10");
    resultFuture.cancel (true);
    Thread.sleep (2000);
    System.out.println ("looking for jobs that completed or were cancelled.");
    Iterator < Map.Entry < String, Future < String > > > iterator = map.entrySet ().iterator ();
    while (iterator.hasNext ()) {
        Map.Entry < String, Future < String > > entry = iterator.next ();
        if (entry.getValue ().isCancelled () || entry.getValue ().isDone ()) {
            System.out.println ("removing reference of job for customer: " + entry.getKey ());
            iterator.remove ();
        }
    }
    executorService.shutdown ();
    executorService.awaitTermination (5, TimeUnit.SECONDS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41697656_44759325_63_74
41697656_44760806_100_111
Title: Dispose Child Thread As per the Id 
----------------------------------------

public Void call () throws Exception {
    System.out.println ("inside a working thread: it is going to do the work of customer: " + clientId);
    try {
        Thread.sleep (5000);
    } catch (InterruptedException e) {
        System.out.println ("worker processing job from customer: " + clientId + " was interrupted. ending now");
        return null;
    }
    System.out.println ("work completed for customer: " + clientId);
    return null;
}
----------------------------------------

public String call () throws Exception {
    System.out.println ("inside a working thread: it is going to do the work of customer: " + clientId);
    try {
        Thread.sleep (2000);
    } catch (InterruptedException e) {
        System.out.println ("worker processing job from customer: " + clientId + " was interrupted. ending now");
        return clientId;
    }
    System.out.println ("work completed for customer: " + clientId);
    return clientId;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41702703_41703664_1_13
41702703_41707455_2_51
Title: Unable to print values for Area and Perimeter inside my formatted column 
----------------------------------------

public static void main (String [] args) {
    System.out.printf ("%32s", "Length");
    System.out.printf ("%7s", "");
    for (int i = 0;
    i <= 10; i ++) {
        System.out.printf ("\n%7s", i == 0 ? "" : i == 5 ? "Width " + i : i);
        for (int j = 1;
        j <= 10; j ++) {
            int area = i * j;
            System.out.printf ("%5s", i == 0 ? j : area);
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] width = new int [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int [] length = new int [] {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int [] [] areas = new int [width.length] [length.length];
    int [] [] perimeters = new int [width.length] [length.length];
    for (int currentWidth : width) {
        for (int currentLength : length) {
            areas [currentWidth - 1] [currentLength - 1] = currentWidth * currentLength;
            perimeters [currentWidth - 1] [currentLength - 1] = 2 * (currentWidth + currentLength);
        }
    }
    System.out.printf ("%39s\n", "Length");
    System.out.printf ("%10s%6s%6s%6s%6s%6s%6s%6s%6s%6s\n", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10");
    for (int currentWidth : width) {
        if (currentWidth == 5) {
            System.out.printf ("Width ");
        } else {
            System.out.printf ("      ");
        }
        System.out.printf ("%s%6s%6s%6s%6s%6s%6s%6s%6s%6s%6s\n", currentWidth, "A: " + areas [currentWidth - 1] [0], "A: " + areas [currentWidth - 1] [1], "A: " + areas [currentWidth - 1] [2], "A: " + areas [currentWidth - 1] [3], "A: " + areas [currentWidth - 1] [4], "A: " + areas [currentWidth - 1] [5], "A: " + areas [currentWidth - 1] [6], "A: " + areas [currentWidth - 1] [7], "A: " + areas [currentWidth - 1] [8], "A: " + areas [currentWidth - 1] [9]);
        System.out.printf ("%13s%6s%6s%6s%6s%6s%6s%6s%6s%6s\n", "P: " + perimeters [currentWidth - 1] [0], "P: " + perimeters [currentWidth - 1] [1], "P: " + perimeters [currentWidth - 1] [2], "P: " + perimeters [currentWidth - 1] [3], "P: " + perimeters [currentWidth - 1] [4], "P: " + perimeters [currentWidth - 1] [5], "P: " + perimeters [currentWidth - 1] [6], "P: " + perimeters [currentWidth - 1] [7], "P: " + perimeters [currentWidth - 1] [8], "P: " + perimeters [currentWidth - 1] [9]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41705191_41705435_1_17
41705191_41705911_19_39
Title: Java - text to array to text 
----------------------------------------

public static void main (String [] args) throws IOException {
    Data [] map = new Data [6];
    map [0] = new Data (5, "aa");
    map [1] = new Data (4, "bb");
    map [2] = new Data (3, "cc");
    map [3] = new Data (3, "dd");
    map [4] = new Data (1, "aa");
    map [5] = new Data (7, "bb");
    java.util.Arrays.sort (map);
    for (int i = 0;
    i < 4; i ++) {
        System.out.println (map [i].FirstPart + " " + map [i].SecondPart);
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Path path = Paths.get ("spl.txt");
    List < Entry < Integer, String > > resultList = new LinkedList < > ();
    try (BufferedReader reader = Files.newBufferedReader (path)) {
        String nextLine;
        while ((nextLine = reader.readLine ()) != null) {
            if (nextLine.equals ("\n") || nextLine.isEmpty ()) continue;

            resultList.add (parseLine (nextLine));
        }
    }
    Collections.sort (resultList, (e1, e2) -> e1.value1 - e2.value1 != 0 ? e1.value1 - e2.value1 : e1.value2.compareTo (e2.value2));
    try (BufferedWriter writer = Files.newBufferedWriter (path)) {
        resultList.forEach ((e) -> {
            try {
                writer.write (e.value1 + " " + e.value2 + "\n");
            } catch (IOException e1) {
                e1.printStackTrace ();
            }
        });
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41705191_41705435_1_17
41705191_41706907_13_24
Title: Java - text to array to text 
----------------------------------------

public static void main (String [] args) throws IOException {
    Data [] map = new Data [6];
    map [0] = new Data (5, "aa");
    map [1] = new Data (4, "bb");
    map [2] = new Data (3, "cc");
    map [3] = new Data (3, "dd");
    map [4] = new Data (1, "aa");
    map [5] = new Data (7, "bb");
    java.util.Arrays.sort (map);
    for (int i = 0;
    i < 4; i ++) {
        System.out.println (map [i].FirstPart + " " + map [i].SecondPart);
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    String path = "C:\\test\\";
    String fileName = path + "abc.txt";
    String newFileName = path + "abcNew.txt";
    System.out.println ("Reading Data from File " + fileName + " started...");
    Map < Integer, String > readDataFromTextFile = readDataFromTextFile (fileName);
    System.out.println ("Writing Sorted Data to File " + newFileName + " started...");
    writeDataInNewFile (readDataFromTextFile, newFileName);
    System.out.println ("Writing Data to File Completed...");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41705191_41705911_19_39
41705191_41706907_13_24
Title: Java - text to array to text 
----------------------------------------

public static void main (String [] args) throws IOException {
    Path path = Paths.get ("spl.txt");
    List < Entry < Integer, String > > resultList = new LinkedList < > ();
    try (BufferedReader reader = Files.newBufferedReader (path)) {
        String nextLine;
        while ((nextLine = reader.readLine ()) != null) {
            if (nextLine.equals ("\n") || nextLine.isEmpty ()) continue;

            resultList.add (parseLine (nextLine));
        }
    }
    Collections.sort (resultList, (e1, e2) -> e1.value1 - e2.value1 != 0 ? e1.value1 - e2.value1 : e1.value2.compareTo (e2.value2));
    try (BufferedWriter writer = Files.newBufferedWriter (path)) {
        resultList.forEach ((e) -> {
            try {
                writer.write (e.value1 + " " + e.value2 + "\n");
            } catch (IOException e1) {
                e1.printStackTrace ();
            }
        });
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    String path = "C:\\test\\";
    String fileName = path + "abc.txt";
    String newFileName = path + "abcNew.txt";
    System.out.println ("Reading Data from File " + fileName + " started...");
    Map < Integer, String > readDataFromTextFile = readDataFromTextFile (fileName);
    System.out.println ("Writing Sorted Data to File " + newFileName + " started...");
    writeDataInNewFile (readDataFromTextFile, newFileName);
    System.out.println ("Writing Data to File Completed...");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4171159_4172231_3_34
4171159_4401039_1_17
Title: "While the form is running other commands are executed" 
----------------------------------------

public static void main (String [] args) {
    final JFrame jframe = new JFrame ();
    final JButton jButton = new JButton ("JButton");
    jButton.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            if (e.getSource ().equals (jButton)) {
                jframe.dispose ();
                System.out.println ("Button clicked!");
            }
        }}

    );
    jframe.getContentPane ().add (jButton);
    jframe.pack ();
    jframe.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    jframe.setVisible (true);
    System.out.println ("test***ok");
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            JDialog d = new JDialog ((Frame) null, true);
            d.add (new JLabel ("This is my test dialog."));
            d.setLocationRelativeTo (null);
            d.pack ();
            System.out.println ("Dialog is opening...");
            d.setVisible (true);
            System.out.println ("Dialog is closed.");
            System.exit (0);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41721404_41721498_25_44
41721404_41721886_20_41
Title: How to use set method in a loop? (Java) 
----------------------------------------

public static void main (String [] args) throws Exception {
    ArrayList < Smartphone > smartphones = new ArrayList < Smartphone > ();
    for (int i = 0;
    i < 5; i ++) {
        Smartphone s = new Smartphone ("12345678", "Samsung");
        smartphones.add (s);
    }
    for (int i = 0;
    i < 5; i ++) {
        smartphones.get (i).setPrice (398);
    }
    for (int i = 0;
    i < 5; i ++) {
        System.out.println (smartphones.get (i).toString ());
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    ArrayList < Smartphone > smartphones = new ArrayList < Smartphone > ();
    for (int i = 0;
    i < 5; i ++) {
        Smartphone s = new Smartphone ("12345678", "Samsung");
        smartphones.add (s);
    }
    for (int i = 0;
    i < 5; i ++) {
        smartphones.get (i).setPrice (398);
    }
    for (Smartphone phone : smartphones) {
        System.out.println (phone.price);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41738214_41739336_25_47
41738214_41739336_95_113
Title: JsonReader.setLenient(true) to accept malformed JSON at line 1 column 1 path $ Error 
----------------------------------------

public void onResponse (Call < ServerResponse > call, retrofit2.Response < ServerResponse > response) {
    ServerResponse resp = response.body ();
    Snackbar.make (getView (), resp.getMessage (), Snackbar.LENGTH_LONG).show ();
    if (resp.getResult ().equals (Constants.SUCCESS)) {
        Snackbar.make (getView (), resp.getMessage (), Snackbar.LENGTH_LONG).show ();
        et_email.setVisibility (View.GONE);
        et_code.setVisibility (View.VISIBLE);
        et_password.setVisibility (View.VISIBLE);
        tv_timer.setVisibility (View.VISIBLE);
        btn_reset.setText ("Change Password");
        isResetInitiated = true;
        startCountdownTimer ();
    } else {
        Snackbar.make (getView (), resp.getMessage (), Snackbar.LENGTH_LONG).show ();
    }
    progress.setVisibility (View.INVISIBLE);
}
----------------------------------------

public void onResponse (Call < ServerResponse > call, retrofit2.Response < ServerResponse > response) {
    ServerResponse resp = response.body ();
    Snackbar.make (getView (), resp.getMessage (), Snackbar.LENGTH_LONG).show ();
    if (resp.getResult ().equals (Constants.SUCCESS)) {
        Snackbar.make (getView (), resp.getMessage (), Snackbar.LENGTH_LONG).show ();
        countDownTimer.cancel ();
        isResetInitiated = false;
        goToLogin ();
    } else {
        Snackbar.make (getView (), resp.getMessage (), Snackbar.LENGTH_LONG).show ();
    }
    progress.setVisibility (View.INVISIBLE);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41745112_41746280_19_45
41745112_41810910_3_17
Title: Comparator for Java classes? 
----------------------------------------

public int compare (final Class < ? extends T > o1, final Class < ? extends T > o2) {
    int result = 0;
    if (! o1.equals (o2)) {
        int o1Depth = - 1;
        Class < ? > o1Parent = o1;
        do {
            o1Parent = o1Parent.getSuperclass ();
            o1Depth ++;
            if (o1Parent.equals (o2)) {
                result = 1;
                break;
            } else if (o1Parent.isAssignableFrom (o2)) {
                final int o2Depth = calculateInheritanceDistance (o2, o1Parent);
                result = Integer.compare (o1Depth, o2Depth);
                break;
            }

        } while (o1Parent != null);
    }
    return result;
}
----------------------------------------

public int compare (Class < ? > first, Class < ? > second) {
    int areInterfaces = first.isInterface () ? 1 : 0;
    areInterfaces += second.isInterface () ? 2 : 0;
    switch (areInterfaces) {
        case 1 + 2 :
            return compareNumbersThenNames (getInterfaceCount (first), getInterfaceCount (second), first, second);
        case 0 + 2 :
            return - 1;
        case 1 + 0 :
            return 1;
        case 0 + 0 :
        default :
            return compareNumbersThenNames (getAncestorCount (first), getAncestorCount (second), first, second);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41748585_41749063_1_20
41748585_41749151_1_11
Title: Incorrect validation of rows in 2D array (Java) 
----------------------------------------

boolean checkHorizontal (String [] [] board) {
    final String emptyCell = "[ ]";
    for (int row = 0;
    row < board.length; row ++) {
        String firstElementInRow = board [row] [0];
        if (firstElementInRow.equals (emptyCell)) {
            continue;
        }
        int column;
        for (column = 1; column < board [row].length; column ++) {
            if (! board [row] [column].equals (firstElementInRow)) {
                break;
            }
        }
        if (column == board [row].length) {
            return true;
        }
    }
    return false;
}
----------------------------------------

public static boolean checkHorizontal (String [] [] field) {
    boolean valid = false;
    int j = 0;
    for (int i = 0;
    i < field.length; i ++) {
        String s = field [i] [0];
        if (s.equals (field [i] [j + 1]) && s.equals (field [i] [j + 2])) return true;

    }
    return valid;
}
----------------------------------------
