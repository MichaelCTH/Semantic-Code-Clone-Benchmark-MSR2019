$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2041542_2041629_9_22
2041542_29591649_3_14
Title: Java: Why does this swap method not work? 
----------------------------------------

public static void main (String [] args) {
    AtomicReference < Integer > a = new AtomicReference < Integer > (1);
    AtomicReference < Integer > b = new AtomicReference < Integer > (2);
    System.out.println ("a = " + a);
    System.out.println ("b = " + b);
    swap (a, b);
    System.out.println ("a = " + a);
    System.out.println ("b = " + b);
}
----------------------------------------

public static void main (String [] args) {
    int i, temp, Num1, Num2;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter Number1 and Number2");
    Num1 = sc.nextInt ();
    Num2 = sc.nextInt ();
    System.out.println ("Before Swapping Num1=" + Num1 + " Num2=" + Num2);
    temp = Num1;
    Num1 = Num2;
    Num2 = temp;
    System.out.println ("After Swapping Num1=" + Num1 + " Num2=" + Num2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2041542_24372597_13_27
2041542_29591649_3_14
Title: Java: Why does this swap method not work? 
----------------------------------------

public static void main (String [] arguments) {
    Swap trial = new Swap ();
    trial.n1 = 2;
    trial.n2 = 3;
    System.out.println ("trial.n1 = " + trial.n1);
    System.out.println ("trial.n2 = " + trial.n2);
    trial.valueSwap ();
    System.out.println ("trial.n1 = " + trial.n1);
    System.out.println ("trial.n2 = " + trial.n2);
}
----------------------------------------

public static void main (String [] args) {
    int i, temp, Num1, Num2;
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter Number1 and Number2");
    Num1 = sc.nextInt ();
    Num2 = sc.nextInt ();
    System.out.println ("Before Swapping Num1=" + Num1 + " Num2=" + Num2);
    temp = Num1;
    Num1 = Num2;
    Num2 = temp;
    System.out.println ("After Swapping Num1=" + Num1 + " Num2=" + Num2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20415655_20415700_1_15
20415655_20415759_15_26
Title: checking whether two sequences have the same values in the same order (beginning java) 
----------------------------------------

public boolean equals (Sequence other) {
    int [] first = this.getValues ();
    int [] second = other.getValues ();
    boolean same = true;
    if (first.length != second.length) {
        return false;
    }
    for (int i = 0;
    i < first.length; i ++) {
        if (first [i] != second [i]) {
            return false;
        }
    }
    return same;
}
----------------------------------------

public boolean equals (Object obj) {
    if (this == obj) return true;

    if (obj == null) return false;

    if (getClass () != obj.getClass ()) return false;

    Sequence other = (Sequence) obj;
    if (! Arrays.equals (values, other.values)) return false;

    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20415809_20415844_6_14
20415809_20415894_12_20
Title: Creating an Array with random numbers with a specific object reference 
----------------------------------------

public static void main (String [] args) {
    Random r = new Random ();
    calc = new Claclal [100];
    for (int i = 0;
    i < calc.length; i ++) {
        Claclal c = new Claclal ();
        c.setRandomNumber ((int) (r.nextDouble ()));
        calc [i] = c;
    }
}
----------------------------------------

public static void main (String [] args) {
    Random r = new Random ();
    calc = new Claclal [100];
    for (int i = 0;
    i < calc.length; i ++) {
        calc [i] = new Claclal (r.nextInt ());
        System.out.println ("" + calc [i].value);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20416223_20416332_35_74
20416223_20416439_2_27
Title: Executors are not running all the threads. 
----------------------------------------

public void testThread () {
    Callable < String > callable1 [] = new Callable [10];
    for (int i = 0;
    i < 10; ++ i) {
        callable1 [i] = new Callable < String > () {
            @Override
            public String call () throws Exception {
                System.out.println ("The current thread is " + Thread.currentThread ().getName ());
                return method1 ();
            }}

        ;
    }
    List < Callable < String > > taskList = new ArrayList < Callable < String > > ();
    for (int i = 0;
    i < 10; ++ i) {
        taskList.add (callable1 [i]);
    }
    ExecutorService executor = Executors.newFixedThreadPool (10);
    try {
        List < Future < String > > futureList = executor.invokeAll (taskList);
        executor.shutdown ();
    } catch (InterruptedException ie) {
    }
}
----------------------------------------

public void testThread () {
    List < Callable < String > > taskList = new ArrayList < Callable < String > > ();
    Callable < String > callable1 = null;
    for (int i = 0;
    i < 10; i ++) {
        callable1 = new Callable < String > () {
            @Override
            public String call () throws Exception {
                System.out.println ("The current thread is " + Thread.currentThread ().getName ());
                return method1 ();
            }}

        ;
        taskList.add (callable1);
    }
    ExecutorService executor = Executors.newFixedThreadPool (10);
    try {
        List < Future < String > > futureList = executor.invokeAll (taskList);
    } catch (InterruptedException ie) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2041718_34859760_37_49
2041718_34859760_51_74
Title: round robin scheduling java iterators 
----------------------------------------

public final synchronized T getNext (Filter < T > filter) {
    int start = index.get ();
    T t = getNext ();
    T result = null;
    while ((result == null) && (start != getIndex ())) {
        if (filter.accept (t)) {
            result = t;
        } else {
            t = getNext ();
        }
    }
    return result;
}
----------------------------------------

public final synchronized T getNext () {
    if (getIt () == null) {
        if (getList ().size () == 0) {
            index.set (0);
            return null;
        } else {
            it = getList ().iterator ();
            index.set (0);
            return it.next ();
        }
    } else if (it.hasNext ()) {
        index.incrementAndGet ();
        return it.next ();
    } else {
        if (list.size () == 0) {
            index.set (0);
            return null;
        } else {
            index.set (0);
            it = list.iterator ();
            return it.next ();
        }
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20427213_20427314_1_12
20427213_20427351_1_15
Title: Possible to add more values to a full array? 
----------------------------------------

public void add (String word) {
    if (counter >= words.length) {
        String [] newWords = new String [counter + 1];
        for (int i = 0;
        i < words.length; i ++) {
            newWords [i] = words [i];
        }
        words = newWords;
    }
    words [counter] = word;
    counter ++;
}
----------------------------------------

public void add (String word) {
    if (counter < words.length) {
        words [counter] = word;
    } else {
        String [] newWords = new String [(words.length * 3) / 2 + 1];
        System.arraycopy (words, 0, newWords, 0, words.length);
        words = newWords;
        words [counter] = word;
    }
    counter ++;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20429943_20429993_19_37
20429943_20430055_10_21
Title: Calling a method with an argument trough reflection 
----------------------------------------

public static void main (String [] args) throws SecurityException, NoSuchFieldException, IllegalArgumentException, IllegalAccessException {
    MyObject myObject = new MyObject ();
    myObject.setFieldA ("Test");
    Class clazz = myObject.getClass ();
    Field field = clazz.getDeclaredField ("fieldA");
    field.setAccessible (true);
    String fieldA = (String) field.get (myObject);
    System.out.println (fieldA);
    field.set (myObject, "Test2");
    fieldA = (String) field.get (myObject);
    System.out.println (fieldA);
    field.setAccessible (false);
}
----------------------------------------

public static void main (String [] args) throws NoSuchMethodException, SecurityException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
    X obj = new X ();
    obj.setField ("lala");
    Method method = obj.getClass ().getMethod ("getField", null);
    System.out.println (method.invoke (obj, null));
    Method setMethod = getWorkingMethod (obj);
    setMethod.invoke (obj, "who let the dogs out");
    System.out.println (obj.getField ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20430752_20430910_4_14
20430752_20430947_1_25
Title: Math.random into an array and then printing array into 10 lines of 10 
----------------------------------------

public static void main (String...args) {
    Random rand = new Random ();
    int [] a = new int [100];
    for (int i = 0;
    i < 100; i ++) {
        a [i] = rand.nextInt ();
        System.out.print (a [i] + ", ");
        if ((i + 1) % 10 == 0) {
            System.out.println ();
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] list = new int [100];
    for (int i = 0;
    i < list.length; i ++) {
        int rand = (int) (Math.random () * 500 + 1);
        list [i] = rand;
    }
    int lineNumberCounter = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (lineNumberCounter == 10) {
            System.out.println ();
            lineNumberCounter = 0;
        }
        System.out.print (list [i] + " ");
        lineNumberCounter ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_110_123
2043783_2048374_139_153
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = items.size ();
    -- i >= 0;) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
            items.remove (i);
        }
    }
    return items;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    int i = 0;
    for (Integer item : items) {
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
        i ++;
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_110_123
2043783_2048374_176_189
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = items.size ();
    -- i >= 0;) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
            items.remove (i);
        }
    }
    return items;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_110_123
2043783_2048374_196_211
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = items.size ();
    -- i >= 0;) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
            items.remove (i);
        }
    }
    return items;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    int j = 0;
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            if (j < i) {
                items.set (j, item);
            }
            j ++;
        }
    }
    return items.subList (0, j);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_110_123
2043783_2048374_218_231
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = items.size ();
    -- i >= 0;) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
            items.remove (i);
        }
    }
    return items;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = 0;
    i < items.size (); i ++) {
        if (mustRemoveItem (items.get (i), i, removeFactor)) {
            Integer retainedItem = removeSomeFromEnd (items, removeFactor, i);
            if (retainedItem == null) {
                items.remove (i);
                break;
            }
            items.set (i, retainedItem);
        }
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_110_123
2043783_2048374_249_258
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = items.size ();
    -- i >= 0;) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
            items.remove (i);
        }
    }
    return items;
}
----------------------------------------

protected List < Integer > removeItems (List < Integer > items, final int removeFactor) {
    Iterables.removeIf (items, new Predicate < Integer > () {
        public boolean apply (Integer input) {
            return mustRemoveItem (input, input, removeFactor);
        }}

    );
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_110_123
2043783_2048374_83_98
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = items.size ();
    -- i >= 0;) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
            items.remove (i);
        }
    }
    return items;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    if (items.size () > 300000 && items instanceof ArrayList) {
        info ("this removeItems is too slow, returning without processing");
        return items;
    }
    int i = 0;
    Iterator < Integer > iter = items.iterator ();
    while (iter.hasNext ()) {
        Integer item = iter.next ();
        if (mustRemoveItem (item, i, removeFactor)) {
            iter.remove ();
        }
        i ++;
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_139_153
2043783_2048374_196_211
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    int i = 0;
    for (Integer item : items) {
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
        i ++;
    }
    return res;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    int j = 0;
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            if (j < i) {
                items.set (j, item);
            }
            j ++;
        }
    }
    return items.subList (0, j);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_139_153
2043783_2048374_218_231
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    int i = 0;
    for (Integer item : items) {
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
        i ++;
    }
    return res;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = 0;
    i < items.size (); i ++) {
        if (mustRemoveItem (items.get (i), i, removeFactor)) {
            Integer retainedItem = removeSomeFromEnd (items, removeFactor, i);
            if (retainedItem == null) {
                items.remove (i);
                break;
            }
            items.set (i, retainedItem);
        }
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_139_153
2043783_2048374_249_258
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    int i = 0;
    for (Integer item : items) {
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
        i ++;
    }
    return res;
}
----------------------------------------

protected List < Integer > removeItems (List < Integer > items, final int removeFactor) {
    Iterables.removeIf (items, new Predicate < Integer > () {
        public boolean apply (Integer input) {
            return mustRemoveItem (input, input, removeFactor);
        }}

    );
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_139_153
2043783_2048374_83_98
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    int i = 0;
    for (Integer item : items) {
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
        i ++;
    }
    return res;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    if (items.size () > 300000 && items instanceof ArrayList) {
        info ("this removeItems is too slow, returning without processing");
        return items;
    }
    int i = 0;
    Iterator < Integer > iter = items.iterator ();
    while (iter.hasNext ()) {
        Integer item = iter.next ();
        if (mustRemoveItem (item, i, removeFactor)) {
            iter.remove ();
        }
        i ++;
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_176_189
2043783_2048374_196_211
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
    }
    return res;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    int j = 0;
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            if (j < i) {
                items.set (j, item);
            }
            j ++;
        }
    }
    return items.subList (0, j);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_176_189
2043783_2048374_218_231
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
    }
    return res;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = 0;
    i < items.size (); i ++) {
        if (mustRemoveItem (items.get (i), i, removeFactor)) {
            Integer retainedItem = removeSomeFromEnd (items, removeFactor, i);
            if (retainedItem == null) {
                items.remove (i);
                break;
            }
            items.set (i, retainedItem);
        }
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_176_189
2043783_2048374_249_258
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
    }
    return res;
}
----------------------------------------

protected List < Integer > removeItems (List < Integer > items, final int removeFactor) {
    Iterables.removeIf (items, new Predicate < Integer > () {
        public boolean apply (Integer input) {
            return mustRemoveItem (input, input, removeFactor);
        }}

    );
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_176_189
2043783_2048374_83_98
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    List < Integer > res = createResultList (items, removeFactor);
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            res.add (item);
        }
    }
    return res;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    if (items.size () > 300000 && items instanceof ArrayList) {
        info ("this removeItems is too slow, returning without processing");
        return items;
    }
    int i = 0;
    Iterator < Integer > iter = items.iterator ();
    while (iter.hasNext ()) {
        Integer item = iter.next ();
        if (mustRemoveItem (item, i, removeFactor)) {
            iter.remove ();
        }
        i ++;
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_196_211
2043783_2048374_218_231
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    int j = 0;
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            if (j < i) {
                items.set (j, item);
            }
            j ++;
        }
    }
    return items.subList (0, j);
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = 0;
    i < items.size (); i ++) {
        if (mustRemoveItem (items.get (i), i, removeFactor)) {
            Integer retainedItem = removeSomeFromEnd (items, removeFactor, i);
            if (retainedItem == null) {
                items.remove (i);
                break;
            }
            items.set (i, retainedItem);
        }
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_196_211
2043783_2048374_249_258
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    int j = 0;
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            if (j < i) {
                items.set (j, item);
            }
            j ++;
        }
    }
    return items.subList (0, j);
}
----------------------------------------

protected List < Integer > removeItems (List < Integer > items, final int removeFactor) {
    Iterables.removeIf (items, new Predicate < Integer > () {
        public boolean apply (Integer input) {
            return mustRemoveItem (input, input, removeFactor);
        }}

    );
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_196_211
2043783_2048374_83_98
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    int j = 0;
    for (int i = 0;
    i < items.size (); i ++) {
        Integer item = items.get (i);
        if (mustRemoveItem (item, i, removeFactor)) {
        } else {
            if (j < i) {
                items.set (j, item);
            }
            j ++;
        }
    }
    return items.subList (0, j);
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    if (items.size () > 300000 && items instanceof ArrayList) {
        info ("this removeItems is too slow, returning without processing");
        return items;
    }
    int i = 0;
    Iterator < Integer > iter = items.iterator ();
    while (iter.hasNext ()) {
        Integer item = iter.next ();
        if (mustRemoveItem (item, i, removeFactor)) {
            iter.remove ();
        }
        i ++;
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_218_231
2043783_2048374_249_258
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = 0;
    i < items.size (); i ++) {
        if (mustRemoveItem (items.get (i), i, removeFactor)) {
            Integer retainedItem = removeSomeFromEnd (items, removeFactor, i);
            if (retainedItem == null) {
                items.remove (i);
                break;
            }
            items.set (i, retainedItem);
        }
    }
    return items;
}
----------------------------------------

protected List < Integer > removeItems (List < Integer > items, final int removeFactor) {
    Iterables.removeIf (items, new Predicate < Integer > () {
        public boolean apply (Integer input) {
            return mustRemoveItem (input, input, removeFactor);
        }}

    );
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_218_231
2043783_2048374_83_98
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    for (int i = 0;
    i < items.size (); i ++) {
        if (mustRemoveItem (items.get (i), i, removeFactor)) {
            Integer retainedItem = removeSomeFromEnd (items, removeFactor, i);
            if (retainedItem == null) {
                items.remove (i);
                break;
            }
            items.set (i, retainedItem);
        }
    }
    return items;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    if (items.size () > 300000 && items instanceof ArrayList) {
        info ("this removeItems is too slow, returning without processing");
        return items;
    }
    int i = 0;
    Iterator < Integer > iter = items.iterator ();
    while (iter.hasNext ()) {
        Integer item = iter.next ();
        if (mustRemoveItem (item, i, removeFactor)) {
            iter.remove ();
        }
        i ++;
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2043783_2048374_249_258
2043783_2048374_83_98
Title: How to efficiently (performance) remove many items from List in Java? 
----------------------------------------

protected List < Integer > removeItems (List < Integer > items, final int removeFactor) {
    Iterables.removeIf (items, new Predicate < Integer > () {
        public boolean apply (Integer input) {
            return mustRemoveItem (input, input, removeFactor);
        }}

    );
    return items;
}
----------------------------------------

public List < Integer > removeItems (List < Integer > items, int removeFactor) {
    if (items.size () > 300000 && items instanceof ArrayList) {
        info ("this removeItems is too slow, returning without processing");
        return items;
    }
    int i = 0;
    Iterator < Integer > iter = items.iterator ();
    while (iter.hasNext ()) {
        Integer item = iter.next ();
        if (mustRemoveItem (item, i, removeFactor)) {
            iter.remove ();
        }
        i ++;
    }
    return items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20438347_20438404_1_20
20438347_20438442_18_29
Title: Capitalize every word using Scanner(System.in) Java 
----------------------------------------

public static char [] capCase (String theString) {
    String source = theString;
    StringBuffer res = new StringBuffer ();
    char [] chars = theString.toLowerCase ().toCharArray ();
    boolean found = false;
    for (int i = 0;
    i < chars.length; i ++) {
        if (! found && Character.isLetter (chars [i])) {
            chars [i] = Character.toUpperCase (chars [i]);
            found = true;
        } else if (Character.isWhitespace (chars [i])) {
            found = true;
        }

    }
    return chars;
}
----------------------------------------

public static String capCase (String theString) {
    if (theString == null) {
        return "";
    }
    StringBuilder sb = new StringBuilder (theString.trim ().toLowerCase ());
    if (sb.length () > 0) {
        char c = sb.charAt (0);
        sb.setCharAt (0, Character.toUpperCase (c));
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20438347_20438404_1_20
20438347_20438507_5_17
Title: Capitalize every word using Scanner(System.in) Java 
----------------------------------------

public static char [] capCase (String theString) {
    String source = theString;
    StringBuffer res = new StringBuffer ();
    char [] chars = theString.toLowerCase ().toCharArray ();
    boolean found = false;
    for (int i = 0;
    i < chars.length; i ++) {
        if (! found && Character.isLetter (chars [i])) {
            chars [i] = Character.toUpperCase (chars [i]);
            found = true;
        } else if (Character.isWhitespace (chars [i])) {
            found = true;
        }

    }
    return chars;
}
----------------------------------------

public static String capCase (String theString) {
    StringBuilder res = new StringBuilder ();
    String [] words = theString.split (" +");
    for (String word : words) {
        char ch = Character.toUpperCase (word.charAt (0));
        word = ch + word.substring (1);
        res.append (word).append (" ");
    }
    return res.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20438347_20438404_1_20
20438347_26122651_11_28
Title: Capitalize every word using Scanner(System.in) Java 
----------------------------------------

public static char [] capCase (String theString) {
    String source = theString;
    StringBuffer res = new StringBuffer ();
    char [] chars = theString.toLowerCase ().toCharArray ();
    boolean found = false;
    for (int i = 0;
    i < chars.length; i ++) {
        if (! found && Character.isLetter (chars [i])) {
            chars [i] = Character.toUpperCase (chars [i]);
            found = true;
        } else if (Character.isWhitespace (chars [i])) {
            found = true;
        }

    }
    return chars;
}
----------------------------------------

public static void capCase (String theString) {
    String source = theString.trim ();
    StringBuffer res = new StringBuffer ();
    String lower = theString.toLowerCase ();
    String [] split = lower.split (" ");
    for (int i = 0;
    i < split.length; i ++) {
        String temp = split [i].trim ();
        if (temp.matches ("^[a-zA-Z]+")) {
            split [i] = temp.substring (0, 1).toUpperCase () + temp.substring (1);
        }
        res.append (split [i] + " ");
    }
    System.out.println (res.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20438347_20438442_18_29
20438347_20438507_5_17
Title: Capitalize every word using Scanner(System.in) Java 
----------------------------------------

public static String capCase (String theString) {
    if (theString == null) {
        return "";
    }
    StringBuilder sb = new StringBuilder (theString.trim ().toLowerCase ());
    if (sb.length () > 0) {
        char c = sb.charAt (0);
        sb.setCharAt (0, Character.toUpperCase (c));
    }
    return sb.toString ();
}
----------------------------------------

public static String capCase (String theString) {
    StringBuilder res = new StringBuilder ();
    String [] words = theString.split (" +");
    for (String word : words) {
        char ch = Character.toUpperCase (word.charAt (0));
        word = ch + word.substring (1);
        res.append (word).append (" ");
    }
    return res.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20438347_20438442_18_29
20438347_26122651_11_28
Title: Capitalize every word using Scanner(System.in) Java 
----------------------------------------

public static String capCase (String theString) {
    if (theString == null) {
        return "";
    }
    StringBuilder sb = new StringBuilder (theString.trim ().toLowerCase ());
    if (sb.length () > 0) {
        char c = sb.charAt (0);
        sb.setCharAt (0, Character.toUpperCase (c));
    }
    return sb.toString ();
}
----------------------------------------

public static void capCase (String theString) {
    String source = theString.trim ();
    StringBuffer res = new StringBuffer ();
    String lower = theString.toLowerCase ();
    String [] split = lower.split (" ");
    for (int i = 0;
    i < split.length; i ++) {
        String temp = split [i].trim ();
        if (temp.matches ("^[a-zA-Z]+")) {
            split [i] = temp.substring (0, 1).toUpperCase () + temp.substring (1);
        }
        res.append (split [i] + " ");
    }
    System.out.println (res.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20438347_20438442_1_16
20438347_20438470_2_14
Title: Capitalize every word using Scanner(System.in) Java 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    while (scanner.hasNextLine ()) {
        String line = scanner.nextLine ();
        int i = 0;
        for (String s : line.split (" ")) {
            if (i != 0) {
                System.out.print (" ");
            }
            System.out.print (capCase (s));
            i ++;
        }
        System.out.println ();
        System.out.flush ();
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    String sentence = Scanner.nextLine ();
    StringBuilder ans = new StringBuilder ();
    for (String s : sentence.split (" ")) {
        char [] str = s.toLowerCase ().toCharArray ();
        if (str.Length > 0) str [0] = Character.toUpperCase (str [0]);

        ans.Append (str);
        ans.Append (' ');
    }
    System.out.println (ans);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20438347_20438507_5_17
20438347_26122651_11_28
Title: Capitalize every word using Scanner(System.in) Java 
----------------------------------------

public static String capCase (String theString) {
    StringBuilder res = new StringBuilder ();
    String [] words = theString.split (" +");
    for (String word : words) {
        char ch = Character.toUpperCase (word.charAt (0));
        word = ch + word.substring (1);
        res.append (word).append (" ");
    }
    return res.toString ();
}
----------------------------------------

public static void capCase (String theString) {
    String source = theString.trim ();
    StringBuffer res = new StringBuffer ();
    String lower = theString.toLowerCase ();
    String [] split = lower.split (" ");
    for (int i = 0;
    i < split.length; i ++) {
        String temp = split [i].trim ();
        if (temp.matches ("^[a-zA-Z]+")) {
            split [i] = temp.substring (0, 1).toUpperCase () + temp.substring (1);
        }
        res.append (split [i] + " ");
    }
    System.out.println (res.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20440839_20440931_7_19
20440839_20440961_7_17
Title: Can't invoke method with varargs parameters with reflection - NoSuchMethodException 
----------------------------------------

private void varargMethod (String string, Integer...var) {
    System.out.println ("vargarMethod() called");
    System.out.println (string + " Number of args: " + var.length + "\nContents");
    for (int i = 0;
    i < var.length; i ++) {
        System.out.printf (" args %d: %d", i, var [i]);
    }
    System.out.println ();
}
----------------------------------------

private void varargMethod (String string, Integer...var) {
    System.out.println ("vargarMethod() called");
    System.out.println (string + " Number of args: " + var.length + "\nContents:");
    for (int i = 0;
    i < var.length; i ++) {
        System.out.printf (" args %d: %d", i, var [i]);
    }
    System.out.println ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20441576_20443538_26_55
20441576_20443538_31_52
Title: How to play fragments of mp3 with JavaFX? 
----------------------------------------

public void run () {
    Platform.runLater (new Runnable () {
        @Override
        public void run () {
            player.setStartTime (Duration.millis (startTime));
            player.setStopTime (Duration.millis (endTime));
            System.out.println (player.getStartTime ());
            System.out.println (player.getStopTime ());
            player.play ();
            player.setOnStopped (new Runnable () {
                @Override
                public void run () {
                    int idtmp = id + 1;
                    System.out.println ("NEXT " + idtmp);
                    scheduler.call (idtmp);
                }}

            );
        }}

    );
}
----------------------------------------

public void run () {
    player.setStartTime (Duration.millis (startTime));
    player.setStopTime (Duration.millis (endTime));
    System.out.println (player.getStartTime ());
    System.out.println (player.getStopTime ());
    player.play ();
    player.setOnStopped (new Runnable () {
        @Override
        public void run () {
            int idtmp = id + 1;
            System.out.println ("NEXT " + idtmp);
            scheduler.call (idtmp);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20442263_20442386_13_19
20442263_20442386_22_28
Title: deep copy of two-dim array containing objects in java not working as expected 
----------------------------------------

public Board () {
    pos = new Square [boardSize] [boardSize];
    for (int row = 0;
    row < boardSize; row ++) for (int col = 0;
    col < boardSize; col ++) {
        pos [row] [col] = new Square (row, col);
    }

}
----------------------------------------

public Board (Board other) {
    pos = new Square [boardSize] [boardSize];
    for (int row = 0;
    row < boardSize; row ++) for (int col = 0;
    col < boardSize; col ++) {
        this.pos [row] [col] = new Square (other.pos [row] [col]);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20445186_20445338_30_42
20445186_20445389_24_42
Title: Static Input Dialog with JDialog 
----------------------------------------

private void init () {
    textField = new JTextField ();
    okButton = new JButton ("OK");
    okButton.addActionListener (this);
    setLayout (new GridLayout (2, 1, 5, 5));
    add (textField);
    add (okButton);
    pack ();
}
----------------------------------------

private void init () {
    textField = new JTextField ();
    JButton okButton = new JButton ("OK");
    okButton.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            dialog.dispose ();
        }}

    );
    dialog.setLayout (new GridLayout (2, 1, 5, 5));
    dialog.add (textField);
    dialog.add (okButton);
    dialog.pack ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20445186_20445338_30_42
20445186_20445478_23_34
Title: Static Input Dialog with JDialog 
----------------------------------------

private void init () {
    textField = new JTextField ();
    okButton = new JButton ("OK");
    okButton.addActionListener (this);
    setLayout (new GridLayout (2, 1, 5, 5));
    add (textField);
    add (okButton);
    pack ();
}
----------------------------------------

private void init () {
    textField = new JTextField ();
    okButton = new JButton ("OK");
    okButton.addActionListener (this);
    setLayout (new GridLayout (2, 1, 5, 5));
    add (textField);
    add (okButton);
    pack ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20445186_20445389_24_42
20445186_20445478_23_34
Title: Static Input Dialog with JDialog 
----------------------------------------

private void init () {
    textField = new JTextField ();
    JButton okButton = new JButton ("OK");
    okButton.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            dialog.dispose ();
        }}

    );
    dialog.setLayout (new GridLayout (2, 1, 5, 5));
    dialog.add (textField);
    dialog.add (okButton);
    dialog.pack ();
}
----------------------------------------

private void init () {
    textField = new JTextField ();
    okButton = new JButton ("OK");
    okButton.addActionListener (this);
    setLayout (new GridLayout (2, 1, 5, 5));
    add (textField);
    add (okButton);
    pack ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20445754_20445783_1_13
20445754_20445805_1_17
Title: Creating a <Fish> arrayList deep copy 
----------------------------------------

public Model (Model other) {
    fish = new ArrayList < Fish > ();
    plants = new ArrayList < Plant > ();
    this.landscape = other.landscape;
    for (Fish fishy : other.fish) {
        this.fish.add (new Fish (fishy));
    }
    for (Plant planty : other.plants) {
        this.plants.add (new Plant (planty));
    }
}
----------------------------------------

public Model (Model other) {
    this.landscape = other.landscape;
    this.fish = new ArrayList < Fish > ();
    this.plants = new ArrayList < Plants > ();
    if (other.fish != null) {
        for (Fish myFish : other.fish) {
            this.fish.add (new Fish (myFish));
        }
    }
    if (other.plants != null) {
        for (Plant myPlant : other.plants) {
            this.plants.add (new Plant (myPlant));
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20446460_20446967_27_39
20446460_20446967_5_22
Title: Changing the class of an object in an arraylist 
----------------------------------------

public Bee anotherDay () {
    eat ();
    if (health == 0) {
        return null;
    }
    age ++;
    if (age % 3 == 2) {
        hive.addBee (new Egg ());
    }
    return this;
}
----------------------------------------

public void anotherDay () {
    List < Bee > dead = new ArrayList < Bee > ();
    int size = cells.size ();
    for (int i = 0;
    i < size; i ++) {
        Bee bee = cells.get (i);
        System.out.println (bee);
        if ((bee = bee.anotherDay ()) == null) {
            dead.add (cells.get (i));
        } else {
            cells.set (i, bee);
        }
    }
    cells.removeAll (dead);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2045290_2322697_86_108
2045290_4168523_1_22
Title: XStream: Collapsing XML hierarchy as I parse 
----------------------------------------

public Object unmarshal (HierarchicalStreamReader reader, UnmarshallingContext context) {
    Position position = new Position ();
    reader.moveDown ();
    reader.moveDown ();
    String title = reader.getValue ();
    position.setTitle (title);
    reader.moveUp ();
    reader.moveDown ();
    String startDate = reader.getValue ();
    position.setStartDate (startDate);
    reader.moveUp ();
    reader.moveDown ();
    String endDate = reader.getValue ();
    position.setEndDate (endDate);
    reader.moveUp ();
    return position;
}
----------------------------------------

@Override
public Object unmarshal (HierarchicalStreamReader reader, UnmarshallingContext context) {
    Position mPosition = new Position ();
    while (reader.hasMoreChildren ()) {
        reader.moveDown ();
        String nodeName = reader.getNodeName ();
        if ("Title".equalsIgnoreCase (nodeName)) {
            mPosition.setTitle (reader.getValue ());
        } else if ("StartDate".equalsIgnoreCase (nodeName)) {
            mPosition.setStartDate (reader.getValue ());
        } else if ("attributeexample".equalsIgnoreCase (nodeName)) {
            mPosition.setAttributeExample (reader.getAttribute ("attrname"));
        }

        reader.moveUp ();
    }
    return mPosition;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20453450_20453514_1_16
20453450_20453854_3_17
Title: Check that a method throws an exception when applied to any element of a list of values 
----------------------------------------

@Test
public void testParseFailure () throws Exception {
    List < String > documents = Arrays.asList ("[1 2]", "[1, 2,]");
    for (String document : documents) {
        try {
            Parser.parse (document);
            fail ("Parsing " + document + " should have thrown a ParseException");
        } catch (ParseException e) {
        }
    }
}
----------------------------------------

public void testParseFailure () throws Exception {
    Map < String, String > documents = new LinkedHashMap < String, String > ();
    documents.put ("[1 2]", "Missing comma");
    documents.put ("[1, 2,]", "Additional commas");
    for (Entry < String, String > entry : documents.entrySet ()) {
        try {
            Parser.parse (entry.getKey ());
            fail ("Parsing " + entry.getKey () + " should have thrown a ParseException");
        } catch (ParseException e) {
            assertEquals (entry.getValue (), e.getMessage ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20454376_20454403_30_44
20454376_20454635_11_24
Title: Use variables from other class from other file to another in java 
----------------------------------------

public Enter (JFrame frame) {
    super (frame, "Welcome", true);
    this.setLayout (new FlowLayout ());
    enter.addActionListener (this);
    txtOne.addActionListener (this);
    add (txtOne);
    add (enter);
    pack ();
    setLocationRelativeTo (null);
}
----------------------------------------

public Enter () {
    this.setLayout (new FlowLayout ());
    setDefaultCloseOperation (EXIT_ON_CLOSE);
    setTitle ("Welcome");
    setSize (200, 130);
    setVisible (true);
    setResizable (false);
    setLocationRelativeTo (null);
    add (txtOne);
    enter.addActionListener (this);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20462839_20462905_24_39
20462839_20538331_6_27
Title: For Loop not waiting for User Response in JTextField 
----------------------------------------

public void actionPerformed (ActionEvent arg0) {
    if (count < STRINGS.length) {
        replies [count] = textField.getText ();
        count ++;
        if (count < STRINGS.length) {
            label.setText (STRINGS [count]);
        } else {
            label.setText ("Done!");
            System.out.println ("Replies:");
            for (String reply : replies) {
                System.out.println (reply);
            }
        }
        textField.setText ("");
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    if (count < colorSequence.length) {
        if (colorEntry.getText ().equals (colorSequence [count - 1])) {
            count ++;
            colorEntry.setText ("");
            colorPrompt.setText ("Enter color number: " + count);
        } else {
            colorEntry.setVisible (false);
            colorPrompt.setText ("Sorry - wrong answer. Eat more antioxidants.");
        }
    } else {
        colorPrompt.setText ("Congratulations - your memory is perfect");
        colorEntry.setVisible (false);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2047003_2047092_2_12
2047003_46814414_2_11
Title: print arraylist element? 
----------------------------------------

public static void main (final String [] args) {
    List < Dog > list = new ArrayList < Dog > ();
    Dog e = new Dog ("Tommy");
    list.add (e);
    list.add (new Dog ("tiger"));
    System.out.println (list);
    for (Dog d : list) {
        System.out.println (d);
    }
}
----------------------------------------

public static void main (String [] args) {
    ArrayList < Integer > arraylist = new ArrayList < Integer > ();
    for (int i = 0;
    i <= 10; i ++) {
        arraylist.add (i);
    }
    for (Integer n : arraylist) {
        System.out.println (n);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20479149_20479237_1_19
20479149_20479290_1_31
Title: Does Java method have a default result? 
----------------------------------------

public static int byteArrayToInt (byte [] paramArrayOfByte, int paramInt1, int paramInt2) {
    int i = 0;
    int j = 0;
    if (j >= paramInt2) return i;

    if ((j == 0) && (paramArrayOfByte [(paramInt1 + (paramInt2 - 1) - j)] < 0)) i |= (int) paramArrayOfByte [(paramInt1 + (paramInt2 - 1) - j)];

    while (true) {
        if (j < paramInt2 - 1) i <<= 8;

        j ++;
        break;
        i |= paramArrayOfByte [paramInt1 + (paramInt2 - 1) - j];
    }
    return i;
}
----------------------------------------

public static int byteArrayToInt (byte [] paramArrayOfByte, int paramInt1, int paramInt2) {
    int i = 0;
    int j = 0;
    if (j >= paramInt2) return i;

    if ((j == 0) && (paramArrayOfByte [(paramInt1 + (paramInt2 - 1) - j)] < 0)) i |= 0xFFFFFFFF & paramArrayOfByte [(paramInt1 + (paramInt2 - 1) - j)];

    while (true) {
        if (j < paramInt2 - 1) i <<= 8;

        j ++;
        break;
        i |= 0xFF & paramArrayOfByte [(paramInt1 + (paramInt2 - 1) - j)];
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20484965_20485180_1_23
20484965_20485219_114_174
Title: Make change program GUI 
----------------------------------------

private void jButton1ActionPerformed (java.awt.event.ActionEvent evt) {
    int quarters = 25;
    int dimes = 10;
    int nickles = 5;
    int pennies = 1;
    try {
        int input = Integer.parseInt (jTextField1.getText ());
    } catch (NumberFormatException e) {
    }
    if (1 <= input && input <= 99) {
    } else {
    }
}
----------------------------------------

private void jButton1ActionPerformed (java.awt.event.ActionEvent evt) {
    int quarters = 25;
    int dimes = 10;
    int nickles = 5;
    int pennies = 1;
    System.out.println ("Enter in a number between 1-99");
    System.out.println ();
    Scanner Userinput = new Scanner (System.in);
    int input = Integer.parseInt (jTextField1.getText ());
    int q = input / quarters;
    input -= q * quarters;
    jLabel2.setText ("Quarter: " + q);
    System.out.println ();
    int d = input / dimes;
    input -= d * dimes;
    jLabel3.setText ("Dimes: " + d);
    int n = input / nickles;
    input -= n * nickles;
    jLabel4.setText ("Nickles: " + n);
    int p = input / pennies;
    input -= p * pennies;
    jLabel5.setText ("Pennies: " + q);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20487329_20487365_27_50
20487329_20487416_15_38
Title: What's the best way to organize JPanels in a list? 
----------------------------------------

public void run () {
    try {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
    }
    final TestPane pane = new TestPane ();
    JButton add = new JButton ("Add");
    add.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            pane.addAnotherPane ();
        }}

    );
    JFrame frame = new JFrame ("Testing");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.setLayout (new BorderLayout ());
    frame.add (new JScrollPane (pane));
    frame.add (add, BorderLayout.SOUTH);
    frame.pack ();
    frame.setLocationRelativeTo (null);
    frame.setVisible (true);
}
----------------------------------------

public void run () {
    try {
        UIManager.setLookAndFeel (UIManager.getSystemLookAndFeelClassName ());
    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | UnsupportedLookAndFeelException ex) {
    }
    final TestPane pane = new TestPane ();
    JButton add = new JButton ("Add");
    add.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            pane.addAnotherPane ();
        }}

    );
    JFrame frame = new JFrame ("Testing");
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.setLayout (new BorderLayout ());
    frame.add (new JScrollPane (pane));
    frame.add (add, BorderLayout.SOUTH);
    frame.pack ();
    frame.setLocationRelativeTo (null);
    frame.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20487329_20487365_79_101
20487329_20487416_60_69
Title: What's the best way to organize JPanels in a list? 
----------------------------------------

public void addAnotherPane () {
    JPanel panel = new JPanel (new GridBagLayout ());
    panel.add (new JLabel ("Hello"));
    GridBagConstraints gbc = new GridBagConstraints ();
    gbc.gridy = y ++;
    gbc.weightx = 1;
    gbc.fill = GridBagConstraints.HORIZONTAL;
    gbc.gridwidth = GridBagConstraints.REMAINDER;
    gbc.insets = new Insets (4, 4, 4, 4);
    add (panel, gbc);
    GridBagLayout gbl = ((GridBagLayout) getLayout ());
    gbc = gbl.getConstraints (filler);
    gbc.gridy = y ++;
    gbl.setConstraints (filler, gbc);
    revalidate ();
    repaint ();
}
----------------------------------------

public void addAnotherPane () {
    SmallPanel panel = new SmallPanel ();
    panel.setLayout (new GridBagLayout ());
    panel.add (new JLabel ("Hello"));
    add (panel);
    add (Box.createVerticalStrut (4));
    revalidate ();
    repaint ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20494075_20494213_20_30
20494075_20494213_4_32
Title: java.lang.RuntimeException: Can't create handler inside thread that has not called Looper.prepare() WHY? 
----------------------------------------

public void run () {
    if (count == 1) {
        Toast.makeText (getApplicationContext (), "Successful Sign Up\nYour user_id : " + roll + "\nand password : " + roll, Toast.LENGTH_LONG).show ();
        Intent i = new Intent (StudentSignUpActivity.this, NoticeActivity.class);
        startActivity (i);
    } else {
        Toast.makeText (getApplicationContext (), "Unsuccessful Sign Up\nTry Again (Cause : " + cause + ")", Toast.LENGTH_LONG).show ();
        Intent i = new Intent (StudentSignUpActivity.this, SignUpActivity.class);
        startActivity (i);
    }
}
----------------------------------------

public void run () {
    String error = "-1";
    try {
        Class.forName (Driver_Class);
        Connection con = DriverManager.getConnection (URL, USER, PASSWORD);
        Statement st = con.createStatement ();
        st.executeUpdate ("insert into login(user_id,password) values('" + roll + "','" + roll + "')");
        count = 1;
    } catch (Exception e) {
        count = 0;
        e.printStackTrace ();
        error = e.toString ();
    }
    final String cause = error;
    runOnUiThread (new Runnable () {
        @Override
        public void run () {
            if (count == 1) {
                Toast.makeText (getApplicationContext (), "Successful Sign Up\nYour user_id : " + roll + "\nand password : " + roll, Toast.LENGTH_LONG).show ();
                Intent i = new Intent (StudentSignUpActivity.this, NoticeActivity.class);
                startActivity (i);
            } else {
                Toast.makeText (getApplicationContext (), "Unsuccessful Sign Up\nTry Again (Cause : " + cause + ")", Toast.LENGTH_LONG).show ();
                Intent i = new Intent (StudentSignUpActivity.this, SignUpActivity.class);
                startActivity (i);
            }
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20495042_20495131_2_17
20495042_20495232_9_32
Title: Parsing each row of a String Text 
----------------------------------------

public static void main (String [] args) throws IOException {
    File f = new File ("C:/downloads/log.txt");
    FileReader in = new FileReader (f);
    BufferedReader br = new BufferedReader (in);
    String line;
    StringBuilder builder = new StringBuilder ();
    String delim = ",";
    while ((line = br.readLine ()) != null) {
        builder.append (delim).append (line);
    }
    System.out.println (builder);
    br.close ();
    in.close ();
}
----------------------------------------

public static void main (String [] args) throws Exception {
    File f = new File ("C:/downloads/log.txt");
    FileReader in = new FileReader (f);
    BufferedReader br = new BufferedReader (in);
    String line;
    StringBuilder builder = new StringBuilder ();
    String delim = "";
    while ((line = br.readLine ()) != null) {
        delim = ",";
        builder.append (line);
        builder.append (delim);
        builder.append (System.getProperty ("line.separator"));
    }
    br.close ();
    BufferedWriter bw = new BufferedWriter (new FileWriter ("C:/downloads/log_modified.txt"));
    bw.write (builder.toString ());
    bw.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20501574_22662020_1_22
20501574_32921195_1_26
Title: How to get conditional formationg of cell in Excel file using Apache POI? 
----------------------------------------

private void expandConditionalFormatting (XSSFCell cell, XSSFCell styleCell) {
    XSSFSheetConditionalFormatting xscf = cell.getSheet ().getSheetConditionalFormatting ();
    for (int idx = 0;
    idx < xscf.getNumConditionalFormattings (); idx ++) {
        XSSFConditionalFormatting cf = xscf.getConditionalFormattingAt (idx);
        List < CellRangeAddress > cra = Arrays.asList (cf.getFormattingRanges ());
        List < CellRangeAddress > newCra = new ArrayList ();
        for (CellRangeAddress c : cra) {
            if (containsCell (c, styleCell) && ! containsCell (c, cell)) {
                newCra.add (new CellRangeAddress (Math.min (c.getFirstRow (), cell.getRowIndex ()), Math.max (c.getLastRow (), cell.getRowIndex ()), Math.min (c.getFirstColumn (), cell.getColumnIndex ()), Math.max (c.getLastColumn (), cell.getColumnIndex ())));
            } else {
                newCra.add (c);
            }
        }
        ArrayList < XSSFConditionalFormattingRule > cfs = new ArrayList ();
        for (int ci = 0;
        ci < cf.getNumberOfRules (); ci ++) {
            cfs.add (cf.getRule (ci));
        }
        xscf.addConditionalFormatting (newCra.toArray (new CellRangeAddress [newCra.size ()]), cfs.toArray (new XSSFConditionalFormattingRule [cfs.size ()]));
        xscf.removeConditionalFormatting (idx);
    }
}
----------------------------------------

private void expandConditionalFormatting (XSSFSheet sheet, CellRangeAddress cellRangeSourceAddress, CellRangeAddress cellRangeDestinationAddress) {
    XSSFSheetConditionalFormatting conditions = sheet.getSheetConditionalFormatting ();
    for (int idx = 0;
    idx < conditions.getNumConditionalFormattings (); idx ++) {
        XSSFConditionalFormatting cf = conditions.getConditionalFormattingAt (idx);
        List < CellRangeAddress > cra = Arrays.asList (cf.getFormattingRanges ());
        List < CellRangeAddress > newCra = new ArrayList < CellRangeAddress > ();
        for (CellRangeAddress c : cra) {
            if (cellRangeSourceAddress.getFirstColumn () == c.getFirstColumn () && cellRangeSourceAddress.getLastColumn () == c.getLastColumn () && cellRangeSourceAddress.getFirstRow () == c.getFirstRow () && cellRangeSourceAddress.getLastRow () == c.getLastRow ()) {
                newCra.add (cellRangeDestinationAddress);
            }
        }
        ArrayList < XSSFConditionalFormattingRule > cfs = new ArrayList < XSSFConditionalFormattingRule > ();
        for (int ci = 0;
        ci < cf.getNumberOfRules (); ci ++) {
            cfs.add (cf.getRule (ci));
        }
        if (newCra.size () > 0) {
            conditions.addConditionalFormatting (newCra.toArray (new CellRangeAddress [newCra.size ()]), cfs.toArray (new XSSFConditionalFormattingRule [cfs.size ()]));
            conditions.removeConditionalFormatting (idx);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2050731_2050877_1_13
2050731_2051021_1_10
Title: Android: Parsing XML DOM parser. Converting childnodes to string 
----------------------------------------

public String getParam1 (Document d) {
    if (d.getDocumentElement ().getTagName ().equals ("AmigoRequest")) {
        NodeList results = d.getElementsByTagName ("Param1");
        if (results.getLength () > 0 && results != null) {
            return extractHTMLTags (results.item (0).getTextContent ());
        }
    }
    return "";
}
----------------------------------------

public String getParam1 (Document d) {
    if (d.getDocumentElement ().getTagName ().equals ("AmigoRequest")) {
        NodeList results = d.getElementsByTagName ("Param1");
        if (results != null) {
            return results.getTextContent ();
        }
    }
    return "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20512637_20512795_1_14
20512637_20512839_1_16
Title: Palindrome program is not giving the correct output in Java 
----------------------------------------

public static void isPalindrome (char [] a, int used) {
    char [] newArr = new char [a.length];
    int newNumber = used - 1;
    System.out.println ("Your original word was: " + String.valueOf (a));
    for (int i = 0;
    i <= newNumber; i ++) {
        newArr [i] = a [newNumber - i];
    }
    System.out.println ("Backwards, your word is: " + String.valueOf (newArr));
    if (String.valueOf (newArr).equalsIgnoreCase (String.valueOf (a))) {
        System.out.println ("Your word or words are palindromes.");
    } else {
        System.out.println ("Your word or words are not palindromes");
    }
}
----------------------------------------

public static boolean isPalindrome (char [] a, int used) {
    char [] newA = new char [a.length];
    int newNumber = used - 1;
    for (int i = 0;
    i <= newNumber; i ++) {
        newA [i] = a [newNumber - i];
        System.out.println ("Your original word was: " + String.valueOf (a));
        System.out.println ("Backwards, your word is: " + String.valueOf (newA));
    }
    if (String.valueOf (String.valueOf (newA)).equalsIgnoreCase (String.valueOf (a))) {
        System.out.println ("Your word or words are palindromes.");
    } else {
        System.out.println ("Your word or words are not palindromes");
    }
    return (String.valueOf (String.valueOf (newA)).equalsIgnoreCase (String.valueOf (a)));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20512637_20512795_1_14
20512637_20513093_1_17
Title: Palindrome program is not giving the correct output in Java 
----------------------------------------

public static void isPalindrome (char [] a, int used) {
    char [] newArr = new char [a.length];
    int newNumber = used - 1;
    System.out.println ("Your original word was: " + String.valueOf (a));
    for (int i = 0;
    i <= newNumber; i ++) {
        newArr [i] = a [newNumber - i];
    }
    System.out.println ("Backwards, your word is: " + String.valueOf (newArr));
    if (String.valueOf (newArr).equalsIgnoreCase (String.valueOf (a))) {
        System.out.println ("Your word or words are palindromes.");
    } else {
        System.out.println ("Your word or words are not palindromes");
    }
}
----------------------------------------

public static boolean isPalindrome (char [] a, int used) {
    char [] reverse = new char [used];
    int newNumber = used - 1;
    for (int i = 0;
    i <= newNumber; i ++) {
        reverse [i] = a [newNumber - i];
    }
    System.out.println ("Your original word was: " + String.valueOf (a));
    System.out.println ("Backwards, your word is: " + String.valueOf (reverse));
    if (String.valueOf (reverse).equalsIgnoreCase (String.valueOf (a))) {
        System.out.println ("Your word or words are palindromes.");
    } else {
        System.out.println ("Your word or words are not palindromes");
    }
    return (String.valueOf (reverse).equalsIgnoreCase (String.valueOf (a)));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20512637_20512839_1_16
20512637_20513093_1_17
Title: Palindrome program is not giving the correct output in Java 
----------------------------------------

public static boolean isPalindrome (char [] a, int used) {
    char [] newA = new char [a.length];
    int newNumber = used - 1;
    for (int i = 0;
    i <= newNumber; i ++) {
        newA [i] = a [newNumber - i];
        System.out.println ("Your original word was: " + String.valueOf (a));
        System.out.println ("Backwards, your word is: " + String.valueOf (newA));
    }
    if (String.valueOf (String.valueOf (newA)).equalsIgnoreCase (String.valueOf (a))) {
        System.out.println ("Your word or words are palindromes.");
    } else {
        System.out.println ("Your word or words are not palindromes");
    }
    return (String.valueOf (String.valueOf (newA)).equalsIgnoreCase (String.valueOf (a)));
}
----------------------------------------

public static boolean isPalindrome (char [] a, int used) {
    char [] reverse = new char [used];
    int newNumber = used - 1;
    for (int i = 0;
    i <= newNumber; i ++) {
        reverse [i] = a [newNumber - i];
    }
    System.out.println ("Your original word was: " + String.valueOf (a));
    System.out.println ("Backwards, your word is: " + String.valueOf (reverse));
    if (String.valueOf (reverse).equalsIgnoreCase (String.valueOf (a))) {
        System.out.println ("Your word or words are palindromes.");
    } else {
        System.out.println ("Your word or words are not palindromes");
    }
    return (String.valueOf (reverse).equalsIgnoreCase (String.valueOf (a)));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20513183_20513648_23_33
20513183_20549197_1_17
Title: Java reading and writing to same file 
----------------------------------------

public static void main (String [] args) {
    try {
        File dir = new File ("C:\\mydir");
        PrintWriter out = new PrintWriter (new BufferedWriter (new FileWriter ("D:\\nawaaaaaa.txt", true)));
        walkin (dir, out);
        out.close ();
    } catch (IOException e) {
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        File dir = new File ("D:\\To Do");
        BufferedWriter out = new BufferedWriter (new FileWriter ("D:\\path.txt", true));
        walkin (dir, out);
        out.close ();
        readfile ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20514223_20547329_112_149
20514223_20547329_153_207
Title: JavaFx 2 - Draw line overlap axis 
----------------------------------------

public void handle (MouseEvent e) {
    Line l = (Line) e.getSource ();
    l.setStrokeWidth (3);
    if (e.getEventType () == MouseEvent.MOUSE_PRESSED && e.isSecondaryButtonDown ()) {
        ((Pane) reg.getParent ()).getChildren ().remove (l);
    } else if (e.getEventType () == MouseEvent.MOUSE_DRAGGED && e.isPrimaryButtonDown ()) {
        double tx = e.getX ();
        double ty = e.getY ();
        double dx = tx - x;
        double dy = ty - y;
        l.setStartX (l.getStartX () + dx);
        l.setStartY (l.getStartY () + dy);
        l.setEndX (l.getEndX () + dx);
        l.setEndY (l.getEndY () + dy);
        x = tx;
        y = ty;
    } else if (e.getEventType () == MouseEvent.MOUSE_ENTERED) {
        x = e.getX ();
        y = e.getY ();
        l.setStroke (Color.RED);
    } else if (e.getEventType () == MouseEvent.MOUSE_EXITED) {
        l.setStroke (Color.BLACK);
    }

    e.consume ();
}
----------------------------------------

public void handle (MouseEvent event) {
    if (event.getEventType () == MouseEvent.MOUSE_CLICKED) {
        double [] diff = getCoordDiff (reg, (Pane) reg.getParent ());
        if (! gotFirst) {
            x1 = x2 = event.getX () + diff [0];
            y1 = y2 = event.getY () + diff [1];
            line = new Line (x1, y1, x2, y2);
            line.setStrokeWidth (3);
            ((Pane) reg.getParent ()).getChildren ().add (line);
            gotFirst = true;
            line.setOnMouseClicked (new EventHandler < Event > () {
                @Override
                public void handle (Event arg0) {
                    line.setOnMouseEntered (lineHandler);
                    line.setOnMouseExited (lineHandler);
                    line.setOnMouseDragged (lineHandler);
                    line.setOnMousePressed (lineHandler);
                    line.setOnMouseClicked (lineHandler);
                    line.setOnMouseReleased (lineHandler);
                    line = null;
                    gotFirst = false;
                }}

            );
        }
    } else {
        if (line != null) {
            double [] diff = getCoordDiff (reg, (Pane) reg.getParent ());
            x2 = event.getX () + diff [0];
            y2 = event.getY () + diff [1];
            line.setEndX (x2);
            line.setEndY (y2);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20514223_20547329_112_149
20514223_20547329_174_187
Title: JavaFx 2 - Draw line overlap axis 
----------------------------------------

public void handle (MouseEvent e) {
    Line l = (Line) e.getSource ();
    l.setStrokeWidth (3);
    if (e.getEventType () == MouseEvent.MOUSE_PRESSED && e.isSecondaryButtonDown ()) {
        ((Pane) reg.getParent ()).getChildren ().remove (l);
    } else if (e.getEventType () == MouseEvent.MOUSE_DRAGGED && e.isPrimaryButtonDown ()) {
        double tx = e.getX ();
        double ty = e.getY ();
        double dx = tx - x;
        double dy = ty - y;
        l.setStartX (l.getStartX () + dx);
        l.setStartY (l.getStartY () + dy);
        l.setEndX (l.getEndX () + dx);
        l.setEndY (l.getEndY () + dy);
        x = tx;
        y = ty;
    } else if (e.getEventType () == MouseEvent.MOUSE_ENTERED) {
        x = e.getX ();
        y = e.getY ();
        l.setStroke (Color.RED);
    } else if (e.getEventType () == MouseEvent.MOUSE_EXITED) {
        l.setStroke (Color.BLACK);
    }

    e.consume ();
}
----------------------------------------

public void handle (Event arg0) {
    line.setOnMouseEntered (lineHandler);
    line.setOnMouseExited (lineHandler);
    line.setOnMouseDragged (lineHandler);
    line.setOnMousePressed (lineHandler);
    line.setOnMouseClicked (lineHandler);
    line.setOnMouseReleased (lineHandler);
    line = null;
    gotFirst = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20514223_20547329_153_207
20514223_20547329_174_187
Title: JavaFx 2 - Draw line overlap axis 
----------------------------------------

public void handle (MouseEvent event) {
    if (event.getEventType () == MouseEvent.MOUSE_CLICKED) {
        double [] diff = getCoordDiff (reg, (Pane) reg.getParent ());
        if (! gotFirst) {
            x1 = x2 = event.getX () + diff [0];
            y1 = y2 = event.getY () + diff [1];
            line = new Line (x1, y1, x2, y2);
            line.setStrokeWidth (3);
            ((Pane) reg.getParent ()).getChildren ().add (line);
            gotFirst = true;
            line.setOnMouseClicked (new EventHandler < Event > () {
                @Override
                public void handle (Event arg0) {
                    line.setOnMouseEntered (lineHandler);
                    line.setOnMouseExited (lineHandler);
                    line.setOnMouseDragged (lineHandler);
                    line.setOnMousePressed (lineHandler);
                    line.setOnMouseClicked (lineHandler);
                    line.setOnMouseReleased (lineHandler);
                    line = null;
                    gotFirst = false;
                }}

            );
        }
    } else {
        if (line != null) {
            double [] diff = getCoordDiff (reg, (Pane) reg.getParent ());
            x2 = event.getX () + diff [0];
            y2 = event.getY () + diff [1];
            line.setEndX (x2);
            line.setEndY (y2);
        }
    }
}
----------------------------------------

public void handle (Event arg0) {
    line.setOnMouseEntered (lineHandler);
    line.setOnMouseExited (lineHandler);
    line.setOnMouseDragged (lineHandler);
    line.setOnMousePressed (lineHandler);
    line.setOnMouseClicked (lineHandler);
    line.setOnMouseReleased (lineHandler);
    line = null;
    gotFirst = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20522676_20522761_1_12
20522676_20522796_1_15
Title: Performing calculations with arrays 
----------------------------------------

public static double [] calcGravity (double [] radius, double [] mass) {
    if (radius.length != mass.length) throw new IllegalArgumentException ("Cannot calculate gravities with unequal radii and masses.");

    double [] gravity = new double [radius.length];
    for (int i = 0;
    i < radius.length; i ++) {
        double [i] = (6.67E-17) * mass [i] / Math.pow (radius [i], 2);
    }
    return gravity;
}
----------------------------------------

public static double [] calcGravity (double [] radius, double [] mass) {
    int size = radius.length;
    if (size != mass.length) {
        throw IllegalArgumentException ("can't calculate with different count of array elements!");
    }
    double [] sums = new double [size];
    for (int i = 0;
    i < size; i ++) {
        sums [i] = (6.67E-17) * mass [i] / Math.pow (radius [i], 2);
    }
    return sums;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2052563_46520671_358_366
2052563_46520671_368_379
Title: binary search tree impelementation and java 
----------------------------------------

public void mirroeView () {
    BSTNode node = mirroeView (root);
    preorder (node);
    System.out.println ();
    inorder (node);
    System.out.println ();
    postorder (node);
    System.out.println ();
}
----------------------------------------

private BSTNode mirroeView (BSTNode node) {
    if (node == null || (node.left == null && node.rigth == null)) return node;

    BSTNode temp = node.left;
    node.left = node.rigth;
    node.rigth = temp;
    mirroeView (node.left);
    mirroeView (node.rigth);
    return node;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20528325_20528667_1_21
20528325_20528943_1_20
Title: Why is my code giving false output? 
----------------------------------------

public void restockProduct (String product, int quantity) {
    String Product = product;
    int Quantity = quantity;
    for (int i = 0;
    i < itemName.length; i ++) {
        if (Product.equals (itemName [i])) {
            if (Quantity > (maxPerSlot - stock [i] [0])) {
                Quantity -= maxPerSlot - stock [i] [0];
                stock [i] [0] += maxPerSlot - stock [i] [0];
            }
            if (Quantity <= (maxPerSlot - stock [i] [0])) {
                stock [i] [0] += Quantity;
                return;
            }
        }
    }
}
----------------------------------------

public void restockProduct (final String product, int quantity) {
    for (int i = 0;
    i < itemName.length; i ++) {
        if ((product.equals (itemName [i]) || "".equals (product)) && (maxPerSlot - stock [i] [0]) > 0) {
            stock [i] [0] += quantity;
            if (stock [i] [0] > maxPerSlot) {
                quantity = stock [i] [0] - maxPerSlot;
                stock [i] [0] = maxPerSlot;
            } else return;

        }
    }
    if (quantity > 0) throw new IllegalArgumentException ("Cannot stock product");

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530057_1_16
20529935_20530148_1_21
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    for (int i = 0;
    i < nums.length - 1; i ++) {
        if (nums [i] == 3 && nums [i + 1] == 3) {
            return false;
        }
        if ((nums [i] == 3)) {
            count ++;
        }
    }
    if (nums [nums.length - 1] == 3) {
        count ++;
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    boolean flag = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            if (flag) {
                return false;
            } else {
                count ++;
                flag = true;
            }
        } else {
            flag = false;
        }
    }
    return count == 3;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530057_1_16
20529935_20530572_1_12
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    for (int i = 0;
    i < nums.length - 1; i ++) {
        if (nums [i] == 3 && nums [i + 1] == 3) {
            return false;
        }
        if ((nums [i] == 3)) {
            count ++;
        }
    }
    if (nums [nums.length - 1] == 3) {
        count ++;
    }
    return count == 3;
}
----------------------------------------

boolean haveThree (int [] nums) {
    int count = 0, prevNum = 0;
    for (int i : nums) {
        if (i == 3) {
            count ++;
            if (prevNum == i) return false;

        }
        prevNum = i;
    }
    return count == 3;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530057_1_16
20529935_20745873_1_14
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    for (int i = 0;
    i < nums.length - 1; i ++) {
        if (nums [i] == 3 && nums [i + 1] == 3) {
            return false;
        }
        if ((nums [i] == 3)) {
            count ++;
        }
    }
    if (nums [nums.length - 1] == 3) {
        count ++;
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    int threeCount = 0;
    boolean successive3s = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            threeCount ++;
        }
        if (nums [i] == 3 && (i + 1) < nums.length && nums [i + 1] == 3) successive3s = true;

    }
    return (! successive3s && threeCount == 3);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530057_1_16
20529935_30424062_1_16
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    for (int i = 0;
    i < nums.length - 1; i ++) {
        if (nums [i] == 3 && nums [i + 1] == 3) {
            return false;
        }
        if ((nums [i] == 3)) {
            count ++;
        }
    }
    if (nums [nums.length - 1] == 3) {
        count ++;
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    if (nums.length >= 1 && nums [0] == 3) count ++;

    for (int i = 1;
    i < nums.length; i ++) {
        if (nums [i - 1] == 3 && nums [i] == 3) return false;

        if (nums [i] == 3) count ++;

    }
    return count == 3;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530057_1_16
20529935_41335762_1_41
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    for (int i = 0;
    i < nums.length - 1; i ++) {
        if (nums [i] == 3 && nums [i + 1] == 3) {
            return false;
        }
        if ((nums [i] == 3)) {
            count ++;
        }
    }
    if (nums [nums.length - 1] == 3) {
        count ++;
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    if (nums.length >= 5) {
        int counterInRow = 0;
        int counterThrees = 0;
        for (int i = 0;
        i < nums.length; i ++) {
            if (nums [i] == 3) {
                counterInRow ++;
                counterThrees ++;
            } else {
                counterInRow = 0;
            }
            if (counterInRow >= 2) {
                return false;
            }
        }
        return (counterThrees == 3);
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530148_1_21
20529935_20530572_1_12
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    boolean flag = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            if (flag) {
                return false;
            } else {
                count ++;
                flag = true;
            }
        } else {
            flag = false;
        }
    }
    return count == 3;
}
----------------------------------------

boolean haveThree (int [] nums) {
    int count = 0, prevNum = 0;
    for (int i : nums) {
        if (i == 3) {
            count ++;
            if (prevNum == i) return false;

        }
        prevNum = i;
    }
    return count == 3;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530148_1_21
20529935_20745873_1_14
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    boolean flag = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            if (flag) {
                return false;
            } else {
                count ++;
                flag = true;
            }
        } else {
            flag = false;
        }
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    int threeCount = 0;
    boolean successive3s = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            threeCount ++;
        }
        if (nums [i] == 3 && (i + 1) < nums.length && nums [i + 1] == 3) successive3s = true;

    }
    return (! successive3s && threeCount == 3);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530148_1_21
20529935_30424062_1_16
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    boolean flag = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            if (flag) {
                return false;
            } else {
                count ++;
                flag = true;
            }
        } else {
            flag = false;
        }
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    if (nums.length >= 1 && nums [0] == 3) count ++;

    for (int i = 1;
    i < nums.length; i ++) {
        if (nums [i - 1] == 3 && nums [i] == 3) return false;

        if (nums [i] == 3) count ++;

    }
    return count == 3;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530148_1_21
20529935_41335762_1_41
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    boolean flag = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            if (flag) {
                return false;
            } else {
                count ++;
                flag = true;
            }
        } else {
            flag = false;
        }
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    if (nums.length >= 5) {
        int counterInRow = 0;
        int counterThrees = 0;
        for (int i = 0;
        i < nums.length; i ++) {
            if (nums [i] == 3) {
                counterInRow ++;
                counterThrees ++;
            } else {
                counterInRow = 0;
            }
            if (counterInRow >= 2) {
                return false;
            }
        }
        return (counterThrees == 3);
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530572_1_12
20529935_20745873_1_14
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

boolean haveThree (int [] nums) {
    int count = 0, prevNum = 0;
    for (int i : nums) {
        if (i == 3) {
            count ++;
            if (prevNum == i) return false;

        }
        prevNum = i;
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    int threeCount = 0;
    boolean successive3s = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            threeCount ++;
        }
        if (nums [i] == 3 && (i + 1) < nums.length && nums [i + 1] == 3) successive3s = true;

    }
    return (! successive3s && threeCount == 3);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530572_1_12
20529935_30424062_1_16
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

boolean haveThree (int [] nums) {
    int count = 0, prevNum = 0;
    for (int i : nums) {
        if (i == 3) {
            count ++;
            if (prevNum == i) return false;

        }
        prevNum = i;
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    if (nums.length >= 1 && nums [0] == 3) count ++;

    for (int i = 1;
    i < nums.length; i ++) {
        if (nums [i - 1] == 3 && nums [i] == 3) return false;

        if (nums [i] == 3) count ++;

    }
    return count == 3;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20530572_1_12
20529935_41335762_1_41
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

boolean haveThree (int [] nums) {
    int count = 0, prevNum = 0;
    for (int i : nums) {
        if (i == 3) {
            count ++;
            if (prevNum == i) return false;

        }
        prevNum = i;
    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    if (nums.length >= 5) {
        int counterInRow = 0;
        int counterThrees = 0;
        for (int i = 0;
        i < nums.length; i ++) {
            if (nums [i] == 3) {
                counterInRow ++;
                counterThrees ++;
            } else {
                counterInRow = 0;
            }
            if (counterInRow >= 2) {
                return false;
            }
        }
        return (counterThrees == 3);
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20745873_1_14
20529935_30424062_1_16
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int threeCount = 0;
    boolean successive3s = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            threeCount ++;
        }
        if (nums [i] == 3 && (i + 1) < nums.length && nums [i + 1] == 3) successive3s = true;

    }
    return (! successive3s && threeCount == 3);
}
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    if (nums.length >= 1 && nums [0] == 3) count ++;

    for (int i = 1;
    i < nums.length; i ++) {
        if (nums [i - 1] == 3 && nums [i] == 3) return false;

        if (nums [i] == 3) count ++;

    }
    return count == 3;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_20745873_1_14
20529935_41335762_1_41
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int threeCount = 0;
    boolean successive3s = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 3) {
            threeCount ++;
        }
        if (nums [i] == 3 && (i + 1) < nums.length && nums [i + 1] == 3) successive3s = true;

    }
    return (! successive3s && threeCount == 3);
}
----------------------------------------

public boolean haveThree (int [] nums) {
    if (nums.length >= 5) {
        int counterInRow = 0;
        int counterThrees = 0;
        for (int i = 0;
        i < nums.length; i ++) {
            if (nums [i] == 3) {
                counterInRow ++;
                counterThrees ++;
            } else {
                counterInRow = 0;
            }
            if (counterInRow >= 2) {
                return false;
            }
        }
        return (counterThrees == 3);
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20529935_30424062_1_16
20529935_41335762_1_41
Title: Finding three elements in an array that are not adjacent 
----------------------------------------

public boolean haveThree (int [] nums) {
    int count = 0;
    if (nums.length >= 1 && nums [0] == 3) count ++;

    for (int i = 1;
    i < nums.length; i ++) {
        if (nums [i - 1] == 3 && nums [i] == 3) return false;

        if (nums [i] == 3) count ++;

    }
    return count == 3;
}
----------------------------------------

public boolean haveThree (int [] nums) {
    if (nums.length >= 5) {
        int counterInRow = 0;
        int counterThrees = 0;
        for (int i = 0;
        i < nums.length; i ++) {
            if (nums [i] == 3) {
                counterInRow ++;
                counterThrees ++;
            } else {
                counterInRow = 0;
            }
            if (counterInRow >= 2) {
                return false;
            }
        }
        return (counterThrees == 3);
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20533819_20533948_12_83
20533819_20534431_11_46
Title: Java - Hashmapping a text file 
----------------------------------------

public static void main (String [] args) throws FileNotFoundException {
    input = new Scanner (new File (fileName));
    Map < String, Integer > map = new HashMap < String, Integer > ();
    while (input.hasNext ()) {
        String word = input.next ();
        if (map.containsKey (word)) {
            int temp = map.get (word) + 1;
            map.put (word, temp);
        } else {
            map.put (word, 1);
        }
    }
    System.out.println ("printing longest word(s) with word count < 3");
    System.out.println ("");
    System.out.printf ("%-25s\t%-25s\t%s\n", "Word", "Word Length", "Count");
    String longest = getLongest (map);
    int valueOfLongest = 0;
    if (! longest.equals ("")) {
        valueOfLongest = longest.length ();
        System.out.printf ("%-25s\t%-25s\t%s\n", longest, longest.length (), map.get (longest));
        map.remove (longest);
    }
    boolean isAllRemoved = false;
    while (! isAllRemoved) {
        isAllRemoved = false;
        longest = getLongest (map);
        if (! longest.equals ("") && longest.length () == valueOfLongest) {
            System.out.printf ("%-25s\t%-25s\t%s\n", longest, longest.length (), map.get (longest));
            map.remove (longest);
        } else isAllRemoved = true;

    }
    System.out.println ("");
    System.out.println ("printing next longest word(s) with word count > = 3");
    System.out.println ("");
    System.out.printf ("%-25s\t%-25s\t%s\n", "Word", "Word Length", "Count");
    String nextLongest = getNextLongest (map, valueOfLongest);
    int valueOfNextLongest = 0;
    if (! longest.equals ("")) {
        valueOfNextLongest = nextLongest.length ();
        System.out.printf ("%-25s\t%-25s\t%s\n", nextLongest, nextLongest.length (), map.get (nextLongest));
        map.remove (nextLongest);
    }
    boolean isNextLongest = false;
    while (! isNextLongest) {
        isNextLongest = true;
        nextLongest = getNextLongest (map, valueOfLongest);
        if (! (nextLongest.equals ("")) && nextLongest.length () == valueOfNextLongest) {
            System.out.printf ("%-25s\t%-25s\t%s\n", nextLongest, nextLongest.length (), map.get (nextLongest));
            map.remove (nextLongest);
            isNextLongest = false;
        }
    }
}
----------------------------------------

public static void main (String args []) throws IOException {
    FileReader fr = new FileReader ("c:/a.txt");
    BufferedReader br = new BufferedReader (fr);
    int longestSize = 0;
    String s = null;
    Set < String > finalAnswerSet = new HashSet < String > ();
    Multiset < String > everyWordSet = HashMultiset.create ();
    while (br != null && (s = br.readLine ()) != null) {
        everyWordSet.add (s);
        if (everyWordSet.count (s) > 3) {
            if (s.length () > longestSize) {
                longestSize = s.length ();
                finalAnswerSet.clear ();
                finalAnswerSet.add (s);
            } else if (s.length () == longestSize) {
                finalAnswerSet.add (s);
            }

        }
    }
    System.out.println ("The longest size is:" + longestSize);
    for (String answer : finalAnswerSet) {
        System.out.println ("The word is :" + answer);
        System.out.println ("The word appears time is:" + everyWordSet.count (answer));
    }
    br.close ();
    fr.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20534862_20710876_1_34
20534862_20710876_36_65
Title: How to efficiently map a org.json.JSONObject to a POJO? 
----------------------------------------

static JsonNode convertJsonFormat (JSONObject json) {
    ObjectNode ret = JsonNodeFactory.instance.objectNode ();
    @SuppressWarnings ("unchecked")
    Iterator < String > iterator = json.keys ();
    for (; iterator.hasNext ();) {
        String key = iterator.next ();
        Object value;
        try {
            value = json.get (key);
        } catch (JSONException e) {
            throw new RuntimeException (e);
        }
        if (json.isNull (key)) ret.putNull (key);
        else if (value instanceof String) ret.put (key, (String) value);
        else if (value instanceof Integer) ret.put (key, (Integer) value);
        else if (value instanceof Long) ret.put (key, (Long) value);
        else if (value instanceof Double) ret.put (key, (Double) value);
        else if (value instanceof Boolean) ret.put (key, (Boolean) value);
        else if (value instanceof JSONObject) ret.put (key, convertJsonFormat ((JSONObject) value));
        else if (value instanceof JSONArray) ret.put (key, convertJsonFormat ((JSONArray) value));
        else throw new RuntimeException ("not prepared for converting instance of class " + value.getClass ());

    }
    return ret;
}
----------------------------------------

static JsonNode convertJsonFormat (JSONArray json) {
    ArrayNode ret = JsonNodeFactory.instance.arrayNode ();
    for (int i = 0;
    i < json.length (); i ++) {
        Object value;
        try {
            value = json.get (i);
        } catch (JSONException e) {
            throw new RuntimeException (e);
        }
        if (json.isNull (i)) ret.addNull ();
        else if (value instanceof String) ret.add ((String) value);
        else if (value instanceof Integer) ret.add ((Integer) value);
        else if (value instanceof Long) ret.add ((Long) value);
        else if (value instanceof Double) ret.add ((Double) value);
        else if (value instanceof Boolean) ret.add ((Boolean) value);
        else if (value instanceof JSONObject) ret.add (convertJsonFormat ((JSONObject) value));
        else if (value instanceof JSONArray) ret.add (convertJsonFormat ((JSONArray) value));
        else throw new RuntimeException ("not prepared for converting instance of class " + value.getClass ());

    }
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20535499_20539424_19_33
20535499_20554735_48_66
Title: Paint method not being called 
----------------------------------------

public static void main (String [] args) {
    Dynamic_Bg_Color d = new Dynamic_Bg_Color ();
    Dimension size = new Dimension (500, 400);
    d.setPreferredSize (new Dimension (size));
    d.setMinimumSize (new Dimension (size));
    d.setMaximumSize (new Dimension (size));
    d.frame.add (d);
    d.frame.setLocationRelativeTo (null);
    d.frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    d.frame.setLayout (new FlowLayout ());
    d.frame.pack ();
    d.frame.setVisible (true);
    d.frame.getContentPane ().setBackground (Color.cyan);
}
----------------------------------------

public static void main (String [] args) {
    Dynamic_Bg_Color d = new Dynamic_Bg_Color ();
    frame = new JFrame ("BG Color Changer");
    frame.setPreferredSize (new Dimension (size));
    frame.setMinimumSize (new Dimension (size));
    frame.setMaximumSize (new Dimension (size));
    frame.setLayout (new FlowLayout ());
    frame.setLocationRelativeTo (null);
    frame.add (d);
    frame.pack ();
    frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    frame.getContentPane ().setBackground (Color.cyan);
    frame.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20550028_34643164_177_194
20550028_34643164_197_213
Title: Jersey LoggingFilter with log4j 
----------------------------------------

public void filter (final ClientRequestContext context) throws IOException {
    final long id = _id.incrementAndGet ();
    context.setProperty (LOGGING_ID_PROPERTY, id);
    final StringBuilder b = new StringBuilder ();
    printRequestLine (b, "Sending client request", id, context.getMethod (), context.getUri ());
    printPrefixedHeaders (b, id, REQUEST_PREFIX, context.getStringHeaders ());
    if (printEntity && context.hasEntity ()) {
        final OutputStream stream = new LoggingStream (b, context.getEntityStream ());
        context.setEntityStream (stream);
        context.setProperty (ENTITY_LOGGER_PROPERTY, stream);
    } else {
        log (b);
    }
}
----------------------------------------

public void filter (final ClientRequestContext requestContext, final ClientResponseContext responseContext) throws IOException {
    final Object requestId = requestContext.getProperty (LOGGING_ID_PROPERTY);
    final long id = requestId != null ? (Long) requestId : _id.incrementAndGet ();
    final StringBuilder b = new StringBuilder ();
    printResponseLine (b, "Client response received", id, responseContext.getStatus ());
    printPrefixedHeaders (b, id, RESPONSE_PREFIX, responseContext.getHeaders ());
    if (printEntity && responseContext.hasEntity ()) {
        responseContext.setEntityStream (logInboundEntity (b, responseContext.getEntityStream (), MessageUtils.getCharset (responseContext.getMediaType ())));
    }
    log (b);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20550028_34643164_177_194
20550028_34643164_216_232
Title: Jersey LoggingFilter with log4j 
----------------------------------------

public void filter (final ClientRequestContext context) throws IOException {
    final long id = _id.incrementAndGet ();
    context.setProperty (LOGGING_ID_PROPERTY, id);
    final StringBuilder b = new StringBuilder ();
    printRequestLine (b, "Sending client request", id, context.getMethod (), context.getUri ());
    printPrefixedHeaders (b, id, REQUEST_PREFIX, context.getStringHeaders ());
    if (printEntity && context.hasEntity ()) {
        final OutputStream stream = new LoggingStream (b, context.getEntityStream ());
        context.setEntityStream (stream);
        context.setProperty (ENTITY_LOGGER_PROPERTY, stream);
    } else {
        log (b);
    }
}
----------------------------------------

public void filter (final ContainerRequestContext context) throws IOException {
    final long id = _id.incrementAndGet ();
    context.setProperty (LOGGING_ID_PROPERTY, id);
    final StringBuilder b = new StringBuilder ();
    printRequestLine (b, "Server has received a request", id, context.getMethod (), context.getUriInfo ().getRequestUri ());
    printPrefixedHeaders (b, id, REQUEST_PREFIX, context.getHeaders ());
    if (printEntity && context.hasEntity ()) {
        context.setEntityStream (logInboundEntity (b, context.getEntityStream (), MessageUtils.getCharset (context.getMediaType ())));
    }
    log (b);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20550028_34643164_197_213
20550028_34643164_216_232
Title: Jersey LoggingFilter with log4j 
----------------------------------------

public void filter (final ClientRequestContext requestContext, final ClientResponseContext responseContext) throws IOException {
    final Object requestId = requestContext.getProperty (LOGGING_ID_PROPERTY);
    final long id = requestId != null ? (Long) requestId : _id.incrementAndGet ();
    final StringBuilder b = new StringBuilder ();
    printResponseLine (b, "Client response received", id, responseContext.getStatus ());
    printPrefixedHeaders (b, id, RESPONSE_PREFIX, responseContext.getHeaders ());
    if (printEntity && responseContext.hasEntity ()) {
        responseContext.setEntityStream (logInboundEntity (b, responseContext.getEntityStream (), MessageUtils.getCharset (responseContext.getMediaType ())));
    }
    log (b);
}
----------------------------------------

public void filter (final ContainerRequestContext context) throws IOException {
    final long id = _id.incrementAndGet ();
    context.setProperty (LOGGING_ID_PROPERTY, id);
    final StringBuilder b = new StringBuilder ();
    printRequestLine (b, "Server has received a request", id, context.getMethod (), context.getUriInfo ().getRequestUri ());
    printPrefixedHeaders (b, id, REQUEST_PREFIX, context.getHeaders ());
    if (printEntity && context.hasEntity ()) {
        context.setEntityStream (logInboundEntity (b, context.getEntityStream (), MessageUtils.getCharset (context.getMediaType ())));
    }
    log (b);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20550028_34643164_197_213
20550028_34643164_235_253
Title: Jersey LoggingFilter with log4j 
----------------------------------------

public void filter (final ClientRequestContext requestContext, final ClientResponseContext responseContext) throws IOException {
    final Object requestId = requestContext.getProperty (LOGGING_ID_PROPERTY);
    final long id = requestId != null ? (Long) requestId : _id.incrementAndGet ();
    final StringBuilder b = new StringBuilder ();
    printResponseLine (b, "Client response received", id, responseContext.getStatus ());
    printPrefixedHeaders (b, id, RESPONSE_PREFIX, responseContext.getHeaders ());
    if (printEntity && responseContext.hasEntity ()) {
        responseContext.setEntityStream (logInboundEntity (b, responseContext.getEntityStream (), MessageUtils.getCharset (responseContext.getMediaType ())));
    }
    log (b);
}
----------------------------------------

public void filter (final ContainerRequestContext requestContext, final ContainerResponseContext responseContext) throws IOException {
    final Object requestId = requestContext.getProperty (LOGGING_ID_PROPERTY);
    final long id = requestId != null ? (Long) requestId : _id.incrementAndGet ();
    final StringBuilder b = new StringBuilder ();
    printResponseLine (b, "Server responded with a response", id, responseContext.getStatus ());
    printPrefixedHeaders (b, id, RESPONSE_PREFIX, responseContext.getStringHeaders ());
    if (printEntity && responseContext.hasEntity ()) {
        final OutputStream stream = new LoggingStream (b, responseContext.getEntityStream ());
        responseContext.setEntityStream (stream);
        requestContext.setProperty (ENTITY_LOGGER_PROPERTY, stream);
    } else {
        log (b);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20550028_34643164_216_232
20550028_34643164_235_253
Title: Jersey LoggingFilter with log4j 
----------------------------------------

public void filter (final ContainerRequestContext context) throws IOException {
    final long id = _id.incrementAndGet ();
    context.setProperty (LOGGING_ID_PROPERTY, id);
    final StringBuilder b = new StringBuilder ();
    printRequestLine (b, "Server has received a request", id, context.getMethod (), context.getUriInfo ().getRequestUri ());
    printPrefixedHeaders (b, id, REQUEST_PREFIX, context.getHeaders ());
    if (printEntity && context.hasEntity ()) {
        context.setEntityStream (logInboundEntity (b, context.getEntityStream (), MessageUtils.getCharset (context.getMediaType ())));
    }
    log (b);
}
----------------------------------------

public void filter (final ContainerRequestContext requestContext, final ContainerResponseContext responseContext) throws IOException {
    final Object requestId = requestContext.getProperty (LOGGING_ID_PROPERTY);
    final long id = requestId != null ? (Long) requestId : _id.incrementAndGet ();
    final StringBuilder b = new StringBuilder ();
    printResponseLine (b, "Server responded with a response", id, responseContext.getStatus ());
    printPrefixedHeaders (b, id, RESPONSE_PREFIX, responseContext.getStringHeaders ());
    if (printEntity && responseContext.hasEntity ()) {
        final OutputStream stream = new LoggingStream (b, responseContext.getEntityStream ());
        responseContext.setEntityStream (stream);
        requestContext.setProperty (ENTITY_LOGGER_PROPERTY, stream);
    } else {
        log (b);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20550037_20551809_7_21
20550037_32804234_8_34
Title: Find maximum product of 3 numbers in an array 
----------------------------------------

public static void main (String [] args) {
    int [] arr = {4, 5, - 19, 3};
    List < Integer > superSet = new ArrayList < > ();
    for (int a : arr) {
        superSet.add (a);
    }
    int k = 3;
    int maxProduct = computeMaxProduct (superSet, k);
    System.out.println ("maximum product is : " + maxProduct);
}
----------------------------------------

public static void main (String [] args) {
    int [] data1 = new int [] {};
    int [] data2 = new int [] {1, 5};
    int [] data3 = new int [] {1, 4, 2, 8, 9};
    int [] data4 = new int [] {10, 11, 12, - 20};
    int [] data5 = new int [] {- 5, - 6, - 10, 7, 8, 9};
    int [] data6 = new int [] {- 12, - 10, - 6, - 4};
    int [] data7 = new int [] {- 10, - 10, 1, 3, 2};
    try {
        productOfThree (data2);
    } catch (Exception e) {
        System.out.println (e.getMessage ());
    }
    try {
        System.out.println (productOfThree (data3));
        System.out.println (productOfThree (data4));
        System.out.println (productOfThree (data5));
        System.out.println (productOfThree (data6));
        System.out.println (productOfThree (data7));
    } catch (Exception e) {
        System.out.println ("You should not see this line");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20550037_20551809_7_21
20550037_49370798_8_35
Title: Find maximum product of 3 numbers in an array 
----------------------------------------

public static void main (String [] args) {
    int [] arr = {4, 5, - 19, 3};
    List < Integer > superSet = new ArrayList < > ();
    for (int a : arr) {
        superSet.add (a);
    }
    int k = 3;
    int maxProduct = computeMaxProduct (superSet, k);
    System.out.println ("maximum product is : " + maxProduct);
}
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    System.out.println ("enter the lenth of array:");
    int num1 = s.nextInt ();
    int [] num2 = new int [num1];
    System.out.println ("enter the numbers of array:");
    for (int i = 0;
    i < num1; i ++) {
        num2 [i] = s.nextInt ();
    }
    Arrays.sort (num2);
    long max1 = num2 [num1 - 1] * num2 [num1 - 2] * num2 [num1 - 3];
    long max2 = num2 [num1 - 1] * num2 [0] * num2 [1];
    long max3 = num2 [0] * num2 [1] * num2 [2];
    long max = max1;
    if (max < max2 && max3 < max2) {
        max = max2;
    } else if (max < max3 && max2 < max3) {
        max = max3;
    }

    System.out.println (max);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20550037_32804234_8_34
20550037_49370798_8_35
Title: Find maximum product of 3 numbers in an array 
----------------------------------------

public static void main (String [] args) {
    int [] data1 = new int [] {};
    int [] data2 = new int [] {1, 5};
    int [] data3 = new int [] {1, 4, 2, 8, 9};
    int [] data4 = new int [] {10, 11, 12, - 20};
    int [] data5 = new int [] {- 5, - 6, - 10, 7, 8, 9};
    int [] data6 = new int [] {- 12, - 10, - 6, - 4};
    int [] data7 = new int [] {- 10, - 10, 1, 3, 2};
    try {
        productOfThree (data2);
    } catch (Exception e) {
        System.out.println (e.getMessage ());
    }
    try {
        System.out.println (productOfThree (data3));
        System.out.println (productOfThree (data4));
        System.out.println (productOfThree (data5));
        System.out.println (productOfThree (data6));
        System.out.println (productOfThree (data7));
    } catch (Exception e) {
        System.out.println ("You should not see this line");
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    System.out.println ("enter the lenth of array:");
    int num1 = s.nextInt ();
    int [] num2 = new int [num1];
    System.out.println ("enter the numbers of array:");
    for (int i = 0;
    i < num1; i ++) {
        num2 [i] = s.nextInt ();
    }
    Arrays.sort (num2);
    long max1 = num2 [num1 - 1] * num2 [num1 - 2] * num2 [num1 - 3];
    long max2 = num2 [num1 - 1] * num2 [0] * num2 [1];
    long max3 = num2 [0] * num2 [1] * num2 [2];
    long max = max1;
    if (max < max2 && max3 < max2) {
        max = max2;
    } else if (max < max3 && max2 < max3) {
        max = max3;
    }

    System.out.println (max);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20556274_20556337_1_10
20556274_20556393_1_19
Title: Converting a List to Double[][] 
----------------------------------------

public static void main (String [] args) {
    List < Double [] > list = new ArrayList < Double [] > ();
    list.add (new Double [] {1.0});
    list.add (new Double [] {2.0, 2.0});
    list.add (new Double [] {3.0, 3.0, 3.0});
    Double [] [] array = list.toArray (new Double [list.size ()] []);
    for (Double [] numbers : array) {
        System.out.println (Arrays.toString (numbers));
    }
}
----------------------------------------

public static void main (String args []) {
    List < ArrayList < Double > > list1 = new ArrayList < ArrayList < Double > > ();
    ArrayList < Double > list2 = new ArrayList < Double > ();
    list2.add (1.0);
    list2.add (1.0);
    list1.add (list2);
    list2 = new ArrayList < Double > ();
    list2.add (2.0);
    list2.add (2.0);
    list1.add (list2);
    Double [] [] dim = new Double [2] [2];
    int i = 0;
    for (ArrayList < Double > inner : list1) dim [i ++] = inner.toArray (new Double [0]);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20561966_20562137_32_41
20561966_20562320_1_10
Title: Custom comparison using Comparator 
----------------------------------------

public static Status getStatus (final Iterable < String > input) {
    Status max = Status.AVAILABLE;
    for (final String in : input) {
        final Status curr = lookup (in);
        if (curr.compareTo (max) > 0) {
            max = curr;
        }
    }
    return max;
}
----------------------------------------

public String getStatus (final Collection < String > in) {
    final Set < String > set = new HashSet < > (in);
    if (set.contains ("Not Available")) {
        return "Not Available";
    }
    if (set.contains ("Partial")) {
        return "Partial";
    }
    return "Available";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20565243_20565408_5_12
20565243_20565893_4_11
Title: For if loop in Java with array 
----------------------------------------

public int indexOf (String s) {
    for (int i = 0;
    i < strArr.length; ++ i) {
        if (strArr [i].equals (s)) {
            return i;
        }
    }
    return - 1;
}
----------------------------------------

public int indexOf (String s) {
    for (int i = 0;
    i < strArr.length; i ++) {
        if (strArr [i].equals (s)) {
            return i;
        }
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20566267_20567630_24_40
20566267_20567630_3_13
Title: StreamGobbler - Thread to accept input into it? Java 
----------------------------------------

public void run () {
    try {
        BufferedWriter writer = new BufferedWriter (new OutputStreamWriter (os));
        while (true) {
            String command = commandQueue.take ();
            if ("EXIT".equals (command)) {
                return;
            }
            writer.write (command);
            writer.flush ();
        }
    } catch (IOException ex) {
    } catch (InterruptedException e) {
    }
}
----------------------------------------

public void run () {
    try {
        BufferedReader reader = new BufferedReader (new InputStreamReader (is));
        String line = reader.readLine ();
        while (line != null && ! line.trim ().equals ("--EOF--")) {
        }
    } catch (IOException ex) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2057387_2057489_9_19
2057387_2057513_1_13
Title: Converting a set of strings to a byte[] array 
----------------------------------------

public static byte [] convertStr (String ln) {
    System.out.println (ln);
    char [] chars = ln.toCharArray ();
    byte [] result = new byte [ln.length () / 2];
    for (int i = 0;
    i < result.length; i ++) {
        result [i] = (byte) hexToInt (chars [2 * i], chars [2 * i + 1]);
    }
    return result;
}
----------------------------------------

public static byte [] convertStr (String ln) {
    System.out.println (ln);
    String [] st = ln.split (" * ");
    byte [] byteArray = new byte [23];
    for (int i = 0;
    i < st.length; i ++) {
        byteArray [i] = Byte.parseByte (st [i]);
    }
    return byteArray;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20575925_20575978_1_17
20575925_20576100_1_11
Title: Reigniting conditional statement after breaking out of it? 
----------------------------------------

public String getString () {
    String result = "";
    while (true) {
        String message = inputGenerator.getMessage ();
        result += message;
        if (! message.startsWith ("hi")) {
            break;
        }
    }
    return result;
}
----------------------------------------

public String getString () {
    StringBuilder msg = new StringBuilder ();
    String read;
    do {
        read = inputGenerator.getMessage ();
        msg.append (read);
    } while (read.toLowerCase ().startsWith ("hi"));
    return msg.toString ();
}
----------------------------------------
