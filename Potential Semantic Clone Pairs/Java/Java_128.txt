$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5773279_5773355_249_275
5773279_5773355_279_291
Title: Checking whether two vertices are connected 
----------------------------------------

public double clusteringCoefficient (int i) {
    String [] temp = Edges [i].copyIntoArray ();
    int edgesInNbd = 0;
    for (int j = 0;
    j < temp.length; j ++) for (int k = 0;
    k < j; k ++) if (isEdge (temp [j], temp [k])) edgesInNbd ++;

    if (temp.length <= 1) return 1;
    else return edgesInNbd * 2.0 / (temp.length * (temp.length - 1));

}
----------------------------------------

public double clusteringCoefficient (String v) {
    int i = getIndex (v);
    if (i == - 1) {
        System.out.print ("clusteringCoefficient failed: ");
        System.out.print (v);
        System.out.println (" does not exist.");
        return 0;
    }
    return clusteringCoefficient (i);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5773279_5773355_456_468
5773279_5773355_476_528
Title: Checking whether two vertices are connected 
----------------------------------------

public int [] breadthFirstSearch (String source) {
    int sourceIndex = getIndex (source);
    if (sourceIndex == - 1) {
        System.out.print ("breadthFirstSearch failed: ");
        System.out.print (source);
        System.out.println (" does not exist.");
        return null;
    }
    return breadthFirstSearch (sourceIndex);
}
----------------------------------------

public int [] breadthFirstSearch (int sourceIndex) {
    int [] bfsTree = new int [numVertices];
    for (int i = 0;
    i < numVertices; i ++) bfsTree [i] = - 1;

    bfsTree [sourceIndex] = sourceIndex;
    boolean [] visited = new boolean [numVertices];
    for (int i = 0;
    i < numVertices; i ++) visited [i] = false;

    visited [sourceIndex] = true;
    Queue Q = new Queue (numVertices);
    Q.enqueue (sourceIndex);
    while (! Q.isEmpty ()) {
        int current = Q.dequeue ();
        int [] neighbors = getNeighbors (current);
        for (int i = 0;
        i < neighbors.length; i ++) {
            int currentNeighbor = neighbors [i];
            if (! visited [currentNeighbor]) {
                visited [currentNeighbor] = true;
                Q.enqueue (currentNeighbor);
                bfsTree [currentNeighbor] = current;
            }
        }
    }
    return bfsTree;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5773279_5773355_50_62
5773279_5773355_66_81
Title: Checking whether two vertices are connected 
----------------------------------------

protected String [] resize (String [] array, int newSize) {
    String [] temp = new String [newSize];
    int smallerSize = newSize;
    if (array.length < smallerSize) smallerSize = array.length;

    for (int i = 0;
    i < smallerSize; i ++) temp [i] = array [i];

    return temp;
}
----------------------------------------

protected StringLinkList [] resize (StringLinkList [] array, int newSize) {
    StringLinkList [] temp = new StringLinkList [newSize];
    int smallerSize = newSize;
    if (array.length < smallerSize) smallerSize = array.length;

    for (int i = 0;
    i < smallerSize; i ++) temp [i] = array [i];

    for (int i = smallerSize;
    i < temp.length; i ++) temp [i] = new StringLinkList ();

    return temp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5778176_14983018_15_38
5778176_15436285_30_63
Title: Finding all paths in JUNG? 
----------------------------------------

private static void findAllPaths (Entity currentNode, Entity startNode, Entity endNode, List < Edge > currentPath, DirectedGraph < Entity, Edge > graph) {
    Collection < Edge > outgoingEdges = graph.getOutEdges (currentNode);
    for (Edge outEdge : outgoingEdges) {
        Entity outNode = outEdge.getSupertype ();
        if (outNode.equals (startNode)) {
            List < Edge > cyclePath = new ArrayList < Edge > (currentPath);
            cyclePath.add (outEdge);
            System.out.println ("Found cycle provoked by path " + cyclePath);
            continue;
        }
        List < Edge > newPath = new ArrayList < Edge > (currentPath);
        newPath.add (outEdge);
        if (outNode.equals (endNode)) {
            allPaths.add (newPath);
            continue;
        }
        findAllPaths (outNode, startNode, endNode, newPath, graph);
    }
}
----------------------------------------

private void findAllPaths (V currentNode, V startNode, V endNode, List < E > currentPath, DirectedGraph < V, E > graph, int maxDepth, int currentDepth) {
    Collection < E > outgoingEdges = graph.getOutEdges (currentNode);
    if (currentDepth < maxDepth) {
        for (E outEdge : outgoingEdges) {
            V outNode = graph.getDest (outEdge);
            if (outNode.equals (startNode)) {
                List < E > cyclePath = new ArrayList < E > (currentPath);
                cyclePath.add (outEdge);
                System.out.println ("Found cycle provoked by path " + cyclePath);
                continue;
            }
            List < E > newPath = new ArrayList < E > (currentPath);
            newPath.add (outEdge);
            if (outNode.equals (endNode)) {
                allPaths.add (newPath);
                continue;
            }
            findAllPaths (outNode, startNode, endNode, newPath, graph, maxDepth, currentDepth + 1);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5778176_14983018_15_38
5778176_6025026_322_357
Title: Finding all paths in JUNG? 
----------------------------------------

private static void findAllPaths (Entity currentNode, Entity startNode, Entity endNode, List < Edge > currentPath, DirectedGraph < Entity, Edge > graph) {
    Collection < Edge > outgoingEdges = graph.getOutEdges (currentNode);
    for (Edge outEdge : outgoingEdges) {
        Entity outNode = outEdge.getSupertype ();
        if (outNode.equals (startNode)) {
            List < Edge > cyclePath = new ArrayList < Edge > (currentPath);
            cyclePath.add (outEdge);
            System.out.println ("Found cycle provoked by path " + cyclePath);
            continue;
        }
        List < Edge > newPath = new ArrayList < Edge > (currentPath);
        newPath.add (outEdge);
        if (outNode.equals (endNode)) {
            allPaths.add (newPath);
            continue;
        }
        findAllPaths (outNode, startNode, endNode, newPath, graph);
    }
}
----------------------------------------

private void findAllPaths (String start, Set < String > visited, Graph < String, String > path, LinkedList < String > currpath) {
    if (visited.contains (start)) {
        return;
    }
    visited.add (start);
    currpath.addLast (start);
    if (start.equals (mTo)) {
        String pred = null;
        for (String l : currpath) {
            if (pred != null) {
                path.addVertex (l);
                path.addVertex (pred);
                path.addEdge ((pred + l), pred, l);
            }
            pred = l;
        }
        currpath.removeLast ();
        visited.remove (start);
        return;
    }
    for (String edge : mGraph.getOutEdges (start)) {
        String succ = mGraph.getDest (edge);
        findAllPaths (succ, visited, path, currpath);
    }
    visited.remove (start);
    currpath.removeLast ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5778176_15436285_30_63
5778176_6025026_322_357
Title: Finding all paths in JUNG? 
----------------------------------------

private void findAllPaths (V currentNode, V startNode, V endNode, List < E > currentPath, DirectedGraph < V, E > graph, int maxDepth, int currentDepth) {
    Collection < E > outgoingEdges = graph.getOutEdges (currentNode);
    if (currentDepth < maxDepth) {
        for (E outEdge : outgoingEdges) {
            V outNode = graph.getDest (outEdge);
            if (outNode.equals (startNode)) {
                List < E > cyclePath = new ArrayList < E > (currentPath);
                cyclePath.add (outEdge);
                System.out.println ("Found cycle provoked by path " + cyclePath);
                continue;
            }
            List < E > newPath = new ArrayList < E > (currentPath);
            newPath.add (outEdge);
            if (outNode.equals (endNode)) {
                allPaths.add (newPath);
                continue;
            }
            findAllPaths (outNode, startNode, endNode, newPath, graph, maxDepth, currentDepth + 1);
        }
    }
}
----------------------------------------

private void findAllPaths (String start, Set < String > visited, Graph < String, String > path, LinkedList < String > currpath) {
    if (visited.contains (start)) {
        return;
    }
    visited.add (start);
    currpath.addLast (start);
    if (start.equals (mTo)) {
        String pred = null;
        for (String l : currpath) {
            if (pred != null) {
                path.addVertex (l);
                path.addVertex (pred);
                path.addEdge ((pred + l), pred, l);
            }
            pred = l;
        }
        currpath.removeLast ();
        visited.remove (start);
        return;
    }
    for (String edge : mGraph.getOutEdges (start)) {
        String succ = mGraph.getDest (edge);
        findAllPaths (succ, visited, path, currpath);
    }
    visited.remove (start);
    currpath.removeLast ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5778176_6025026_154_162
5778176_6025026_194_210
Title: Finding all paths in JUNG? 
----------------------------------------

public Paint transform (String e) {
    if (path == null || path.getEdges ().size () == 0) return Color.BLACK;

    if (isBlessed (e)) {
        return new Color (0.0f, 0.0f, 1.0f, 0.5f);
    } else {
        return Color.LIGHT_GRAY;
    }
}
----------------------------------------

public Paint transform (String v) {
    if (v.equals (mFrom)) {
        return Color.BLUE;
    }
    if (v.equals (mTo)) {
        return Color.BLUE;
    }
    if (path == null) {
        return Color.LIGHT_GRAY;
    } else {
        if (mGraph.getVertices ().contains (v)) {
            return Color.RED;
        } else {
            return Color.LIGHT_GRAY;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5778176_6025026_251_262
5778176_6025026_291_301
Title: Finding all paths in JUNG? 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String option = (String) path.getSelectedItem ();
    if (option.equals ("Full")) {
        full = true;
        label.setText ("Select a pair of vertices for which all possible paths will be displayed");
    } else {
        full = false;
        label.setText ("Select a pair of vertices for which a shortest path will be displayed");
    }
    drawPath ();
    repaint ();
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    String v = (String) choices.getSelectedItem ();
    if (from) {
        mFrom = v;
    } else {
        mTo = v;
    }
    drawPath ();
    repaint ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5797581_5797705_4_21
5797581_5797741_5_21
Title: How come my program doesn't return the value? 
----------------------------------------

public static void main (String [] args) {
    int vowels = 0;
    String sentence;
    Scanner keyboard = new Scanner (System.in);
    System.out.print ("Please enter a sentence, and the program" + " will return the # of vowels: ");
    System.out.println ();
    sentence = keyboard.nextLine ().toString ();
    for (char letter : sentence.toCharArray ()) {
        vowels += isVowel (letter);
    }
    System.out.println ("The amount of vowels in the sentence you inputed " + " was: " + vowels);
    System.exit (0);
}
----------------------------------------

public static void main (String [] args) {
    Scanner keyboard = new Scanner (System.in);
    System.out.println ("Please enter a sentence, and the program" + " will return the # of vowels: ");
    String sentence = keyboard.nextLine ();
    int vowels = 0;
    for (int i = 0;
    i < sentence.length (); i ++) {
        vowels += isVowel (sentence.charAt (i));
    }
    System.out.println ("The amount of vowels in the sentence you inputed " + " was: " + vowels);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5801734_5802781_57_90
5801734_5802802_15_27
Title: How to draw lines in Java 
----------------------------------------

public static void main (String [] args) {
    JFrame testFrame = new JFrame ();
    testFrame.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
    final LinesComponent comp = new LinesComponent ();
    comp.setPreferredSize (new Dimension (320, 200));
    testFrame.getContentPane ().add (comp, BorderLayout.CENTER);
    JPanel buttonsPanel = new JPanel ();
    JButton newLineButton = new JButton ("New Line");
    JButton clearButton = new JButton ("Clear");
    buttonsPanel.add (newLineButton);
    buttonsPanel.add (clearButton);
    testFrame.getContentPane ().add (buttonsPanel, BorderLayout.SOUTH);
    newLineButton.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            int x1 = (int) (Math.random () * 320);
            int x2 = (int) (Math.random () * 320);
            int y1 = (int) (Math.random () * 200);
            int y2 = (int) (Math.random () * 200);
            Color randomColor = new Color ((float) Math.random (), (float) Math.random (), (float) Math.random ());
            comp.addLine (x1, y1, x2, y2, randomColor);
        }}

    );
    clearButton.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            comp.clearLines ();
        }}

    );
    testFrame.pack ();
    testFrame.setVisible (true);
}
----------------------------------------

public static void main (String [] args) {
    Runnable r = new Runnable () {
        public void run () {
            LineComponent lineComponent = new LineComponent (400, 400);
            for (int ii = 0;
            ii < 30; ii ++) {
                lineComponent.addLine ();
            }
            JOptionPane.showMessageDialog (null, lineComponent);
        }}

    ;
    SwingUtilities.invokeLater (r);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5809626_5809651_14_31
5809626_5809676_3_27
Title: Items not Appearing in New Frame in Java 
----------------------------------------

public OutputPanel (Vector parsedOutput) {
    this.setTitle ("Output");
    this.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
    JPanel content = new JPanel (new GridLayout (0, 1));
    for (int i = 0;
    i < 100; i ++) {
        JLabel sectionLabel = new JLabel ("hello " + i);
        content.add (sectionLabel);
    }
    JScrollPane scrollPane = new JScrollPane (content);
    this.add (scrollPane);
    this.pack ();
    this.setVisible (true);
}
----------------------------------------

public OutputPanel (Vector parsedOutput) {
    this.setTitle ("Output");
    this.setDefaultCloseOperation (JFrame.DISPOSE_ON_CLOSE);
    JScrollPane scrollPane = new JScrollPane ();
    Iterator < Vector > outputIter = parsedOutput.iterator ();
    JPanel panel = new JPanel ();
    panel.setLayout (new FlowLayout ());
    scrollPane.setViewportView (panel);
    while (outputIter.hasNext ()) {
        Vector section = outputIter.next ();
        JLabel sectionLabel = new JLabel ((String) section.get (0));
        System.out.println ((String) section.get (0));
        panel.add (sectionLabel);
    }
    this.add (scrollPane);
    this.pack ();
    this.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
582278_582340_2_16
582278_582510_9_29
Title: How to calculate the difference between two Java java.sql.Timestamps? 
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    Timestamp t1 = new Timestamp (System.currentTimeMillis ());
    t1.setNanos (t1.getNanos () + 60);
    Thread.sleep (20);
    Timestamp t2 = new Timestamp (System.currentTimeMillis ());
    t2.setNanos (t2.getNanos () + 30);
    System.out.println (t1);
    System.out.println (t2);
    long firstTime = (getTimeNoMillis (t1) * 1000000) + t1.getNanos ();
    long secondTime = (getTimeNoMillis (t2) * 1000000) + t2.getNanos ();
    long diff = Math.abs (firstTime - secondTime);
    System.out.println (diff);
    System.out.println (Math.abs (t1.getTime () - t2.getTime ()));
}
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    final Timestamp t1;
    final Timestamp t2;
    final BigInteger firstTime;
    final BigInteger secondTime;
    final BigInteger diffTime;
    t1 = new Timestamp (System.currentTimeMillis ());
    Thread.sleep (20);
    t2 = new Timestamp (System.currentTimeMillis ());
    System.out.println (t1);
    System.out.println (t2);
    firstTime = BigInteger.valueOf (t1.getTime () / 1000 * 1000).multiply (ONE_BILLION).add (BigInteger.valueOf (t1.getNanos ()));
    secondTime = BigInteger.valueOf (t2.getTime () / 1000 * 1000).multiply (ONE_BILLION).add (BigInteger.valueOf (t2.getNanos ()));
    diffTime = firstTime.subtract (secondTime);
    System.out.println (firstTime);
    System.out.println (secondTime);
    System.out.println (diffTime);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5830581_12018566_3_16
5830581_22418475_1_11
Title: Getting a directory inside a .jar 
----------------------------------------

public static void main (String [] args) throws IOException {
    PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver ();
    Resource [] resources = resolver.getResources ("/Images/**");
    for (Resource resource : resources) {
        System.out.println ("resource = " + resource);
        InputStream is = resource.getInputStream ();
        BufferedImage img = ImageIO.read (is);
        System.out.println ("img.getHeight() = " + img.getHeight ());
        System.out.println ("img.getWidth() = " + img.getWidth ());
    }
}
----------------------------------------

public static void main (final String...args) throws IOException {
    final Map < String, ? > env = Collections.emptyMap ();
    final String jarName = "/opt/sunjdk/1.6/current/jre/lib/plugin.jar";
    final URI uri = URI.create ("jar:file:" + jarName);
    final FileSystem fs = FileSystems.newFileSystem (uri, env);
    final Path dir = fs.getPath ("/");
    for (Path entry : Files.newDirectoryStream (dir)) System.out.println (entry);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5830581_12018566_3_16
5830581_5831097_39_48
Title: Getting a directory inside a .jar 
----------------------------------------

public static void main (String [] args) throws IOException {
    PathMatchingResourcePatternResolver resolver = new PathMatchingResourcePatternResolver ();
    Resource [] resources = resolver.getResources ("/Images/**");
    for (Resource resource : resources) {
        System.out.println ("resource = " + resource);
        InputStream is = resource.getInputStream ();
        BufferedImage img = ImageIO.read (is);
        System.out.println ("img.getHeight() = " + img.getHeight ());
        System.out.println ("img.getWidth() = " + img.getWidth ());
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    JarFileContentsLoader jarFileContents = new JarFileContentsLoader ("/u1/svnedge-discovery/client-browser/lib/jmdns.jar");
    Set < URL > entries = jarFileContents.getDirEntries ("impl");
    Iterator < URL > a = entries.iterator ();
    while (a.hasNext ()) {
        URL element = a.next ();
        System.out.println (element);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5830581_22418475_1_11
5830581_5831097_39_48
Title: Getting a directory inside a .jar 
----------------------------------------

public static void main (final String...args) throws IOException {
    final Map < String, ? > env = Collections.emptyMap ();
    final String jarName = "/opt/sunjdk/1.6/current/jre/lib/plugin.jar";
    final URI uri = URI.create ("jar:file:" + jarName);
    final FileSystem fs = FileSystems.newFileSystem (uri, env);
    final Path dir = fs.getPath ("/");
    for (Path entry : Files.newDirectoryStream (dir)) System.out.println (entry);

}
----------------------------------------

public static void main (String [] args) throws IOException {
    JarFileContentsLoader jarFileContents = new JarFileContentsLoader ("/u1/svnedge-discovery/client-browser/lib/jmdns.jar");
    Set < URL > entries = jarFileContents.getDirEntries ("impl");
    Iterator < URL > a = entries.iterator ();
    while (a.hasNext ()) {
        URL element = a.next ();
        System.out.println (element);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5841620_5841690_8_47
5841620_5841708_10_25
Title: how to read directories in java 
----------------------------------------

public static void main (String [] args) {
    File file = new File ("c:/temp/");
    File [] files = file.listFiles ();
    for (int i = 0;
    i < files.length; i ++) {
        System.out.println (files [i]);
    }
    BufferedReader reader = null;
    try {
        reader = new BufferedReader (new FileReader ("c:/temp/test.txt"));
        String line = null;
        while (true) {
            line = reader.readLine ();
            if (line == null) break;

            System.out.println (line);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (reader != null) {
            try {
                reader.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        String contents = FileUtils.readFileToString (new File ("/etc/mtab"));
    } catch (IOException e) {
        e.printStackTrace ();
    }
    Collection < File > files = FileUtils.listFiles (new File ("/home/ross/tmp"), FileFilterUtils.trueFileFilter (), null);
    for (File f : files) {
        System.out.println (f.getName ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5841620_5841690_8_47
5841620_5841729_3_23
Title: how to read directories in java 
----------------------------------------

public static void main (String [] args) {
    File file = new File ("c:/temp/");
    File [] files = file.listFiles ();
    for (int i = 0;
    i < files.length; i ++) {
        System.out.println (files [i]);
    }
    BufferedReader reader = null;
    try {
        reader = new BufferedReader (new FileReader ("c:/temp/test.txt"));
        String line = null;
        while (true) {
            line = reader.readLine ();
            if (line == null) break;

            System.out.println (line);
        }
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (reader != null) {
            try {
                reader.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public static void main (String [] sr) throws IOException {
    File f = new File ("D:/workspace");
    if (! f.exists ()) System.out.println ("No File/Dir");

    if (f.isDirectory ()) {
        for (File file : f.listFiles ()) {
            System.out.println (file.getName ());
        }
    }
    File f1 = new File ("D:/workspace/so.txt");
    BufferedReader br = new BufferedReader (new FileReader (f1));
    StringBuilder sb = new StringBuilder ();
    String line = "";
    while ((line = br.readLine ()) != null) sb.append (line + "\n");

    System.out.println (sb);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5841620_5841708_10_25
5841620_5841729_3_23
Title: how to read directories in java 
----------------------------------------

public static void main (String [] args) {
    try {
        String contents = FileUtils.readFileToString (new File ("/etc/mtab"));
    } catch (IOException e) {
        e.printStackTrace ();
    }
    Collection < File > files = FileUtils.listFiles (new File ("/home/ross/tmp"), FileFilterUtils.trueFileFilter (), null);
    for (File f : files) {
        System.out.println (f.getName ());
    }
}
----------------------------------------

public static void main (String [] sr) throws IOException {
    File f = new File ("D:/workspace");
    if (! f.exists ()) System.out.println ("No File/Dir");

    if (f.isDirectory ()) {
        for (File file : f.listFiles ()) {
            System.out.println (file.getName ());
        }
    }
    File f1 = new File ("D:/workspace/so.txt");
    BufferedReader br = new BufferedReader (new FileReader (f1));
    StringBuilder sb = new StringBuilder ();
    String line = "";
    while ((line = br.readLine ()) != null) sb.append (line + "\n");

    System.out.println (sb);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5848029_5848048_1_101
5848029_5848442_19_39
Title: Creating thumbnail views of images using Java 
----------------------------------------

private static byte [] createThumbnail (byte [] bytes) {
    try {
        double scale;
        int sizeDifference, originalImageLargestDim;
        Image inImage = ImageIO.read (new ByteArrayInputStream (bytes));
        if (inImage.getWidth (null) > inImage.getHeight (null)) {
            scale = (double) LARGEST_DIMENSION / (double) inImage.getWidth (null);
            sizeDifference = inImage.getWidth (null) - LARGEST_DIMENSION;
            originalImageLargestDim = inImage.getWidth (null);
        } else {
            scale = (double) LARGEST_DIMENSION / (double) inImage.getHeight (null);
            sizeDifference = inImage.getHeight (null) - LARGEST_DIMENSION;
            originalImageLargestDim = inImage.getHeight (null);
        }
        BufferedImage outImage = new BufferedImage (100, 100, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2d;
        AffineTransform tx;
        if (scale < 1.0d) {
            int numSteps = sizeDifference / 100;
            int stepSize = sizeDifference / numSteps;
            int stepWeight = stepSize / 2;
            int heavierStepSize = stepSize + stepWeight;
            int lighterStepSize = stepSize - stepWeight;
            int currentStepSize, centerStep;
            double scaledW = inImage.getWidth (null);
            double scaledH = inImage.getHeight (null);
            if (numSteps % 2 == 1) centerStep = (int) Math.ceil ((double) numSteps / 2d);
            else centerStep = - 1;

            Integer intermediateSize = originalImageLargestDim, previousIntermediateSize = originalImageLargestDim;
            for (Integer i = 0;
            i < numSteps; i ++) {
                if (i + 1 != centerStep) {
                    if (i == numSteps - 1) {
                        currentStepSize = previousIntermediateSize - LARGEST_DIMENSION;
                    } else {
                        if (numSteps - i > numSteps / 2) currentStepSize = heavierStepSize;
                        else currentStepSize = lighterStepSize;

                    }
                } else {
                    currentStepSize = stepSize;
                }
                intermediateSize = previousIntermediateSize - currentStepSize;
                scale = (double) intermediateSize / (double) previousIntermediateSize;
                scaledW = (int) scaledW * scale;
                scaledH = (int) scaledH * scale;
                outImage = new BufferedImage ((int) scaledW, (int) scaledH, BufferedImage.TYPE_INT_RGB);
                g2d = outImage.createGraphics ();
                g2d.setBackground (Color.WHITE);
                g2d.clearRect (0, 0, outImage.getWidth (), outImage.getHeight ());
                g2d.setRenderingHint (RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);
                tx = new AffineTransform ();
                tx.scale (scale, scale);
                g2d.drawImage (inImage, tx, null);
                g2d.dispose ();
                inImage = new ImageIcon (outImage).getImage ();
                previousIntermediateSize = intermediateSize;
            }
        } else {
            outImage = new BufferedImage (inImage.getWidth (null), inImage.getHeight (null), BufferedImage.TYPE_INT_RGB);
            g2d = outImage.createGraphics ();
            g2d.setBackground (Color.WHITE);
            g2d.clearRect (0, 0, outImage.getWidth (), outImage.getHeight ());
            tx = new AffineTransform ();
            tx.setToIdentity ();
            g2d.drawImage (inImage, tx, null);
            g2d.dispose ();
        }
        ByteArrayOutputStream os = new ByteArrayOutputStream ();
        JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder (os);
        encoder.encode (outImage);
        return os.toByteArray ();
    } catch (Exception e) {
        throw new RuntimeException (e);
    }
}
----------------------------------------

private void createThumbnail (File file) {
    try {
        BufferedImage img = ImageIO.read (file);
        BufferedImage thumb = createEmptyThumbnail ();
        Graphics2D g2d = (Graphics2D) thumb.getGraphics ();
        g2d.drawImage (img, 0, 0, thumb.getWidth () - 1, thumb.getHeight () - 1, 0, 0, img.getWidth () - 1, img.getHeight () - 1, null);
        g2d.dispose ();
        ImageIO.write (thumb, "PNG", createOutputFile (file));
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5858966_5859094_10_28
5858966_5859279_23_50
Title: Why java numbers aren't iterable 
----------------------------------------

public Iterator < Integer > iterator () {
    return new Iterator < Integer > () {
        int c = _fromInclusive;
        public boolean hasNext () {
            return c < _toExclusive;
        } public Integer next () {
            if (c >= _toExclusive) {
                throw new NoSuchElementException ();
            }
            return c ++;
        } public void remove () {
            throw new UnsupportedOperationException ();
        }}

    ;
}
----------------------------------------

public Iterator < Integer > iterator () {
    return new Iterator < Integer > () {
        private int actual = start;
        @Override
        public boolean hasNext () {
            return actual != end;
        }@Override
        public Integer next () {
            int value = actual;
            if (actual < end) {
                actual ++;
            } else if (actual > end) {
                actual --;
            }

            return value;
        }@Override
        public void remove () {
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_16306496_1_15
5864159_35222706_1_19
Title: Count words in a string method? 
----------------------------------------

public static int countWords (String str) {
    if (str == null || str.isEmpty ()) return 0;

    int count = 0;
    for (int e = 0;
    e < str.length (); e ++) {
        if (str.charAt (e) != ' ') {
            count ++;
            while (str.charAt (e) != ' ' && e < str.length () - 1) {
                e ++;
            }
        }
    }
    return count;
}
----------------------------------------

public static int countWords (String input) {
    int wordCount = 0;
    boolean isBlankSet = false;
    input = input.trim ();
    for (int j = 0;
    j < input.length (); j ++) {
        if (input.charAt (j) == ' ') isBlankSet = true;
        else {
            if (isBlankSet) {
                wordCount ++;
                isBlankSet = false;
            }
        }
    }
    return wordCount + 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_16306496_1_15
5864159_47834479_1_22
Title: Count words in a string method? 
----------------------------------------

public static int countWords (String str) {
    if (str == null || str.isEmpty ()) return 0;

    int count = 0;
    for (int e = 0;
    e < str.length (); e ++) {
        if (str.charAt (e) != ' ') {
            count ++;
            while (str.charAt (e) != ' ' && e < str.length () - 1) {
                e ++;
            }
        }
    }
    return count;
}
----------------------------------------

public static int countWords (final String s) {
    int wordCount = 0;
    boolean word = false;
    final int endOfLine = s.length () - 1;
    for (int i = 0;
    i < s.length (); i ++) {
        if (isWordCharacter (s, i) && i != endOfLine) {
            word = true;
        } else if (! isWordCharacter (s, i) && word) {
            wordCount ++;
            word = false;
        } else if (isWordCharacter (s, i) && i == endOfLine) {
            wordCount ++;
        }

    }
    return wordCount;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_16306496_1_15
5864159_5864184_1_24
Title: Count words in a string method? 
----------------------------------------

public static int countWords (String str) {
    if (str == null || str.isEmpty ()) return 0;

    int count = 0;
    for (int e = 0;
    e < str.length (); e ++) {
        if (str.charAt (e) != ' ') {
            count ++;
            while (str.charAt (e) != ' ' && e < str.length () - 1) {
                e ++;
            }
        }
    }
    return count;
}
----------------------------------------

public static int countWords (String s) {
    int wordCount = 0;
    boolean word = false;
    int endOfLine = s.length () - 1;
    for (int i = 0;
    i < s.length (); i ++) {
        if (Character.isLetter (s.charAt (i)) && i != endOfLine) {
            word = true;
        } else if (! Character.isLetter (s.charAt (i)) && word) {
            wordCount ++;
            word = false;
        } else if (Character.isLetter (s.charAt (i)) && i == endOfLine) {
            wordCount ++;
        }

    }
    return wordCount;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_16654721_3_31
5864159_26556135_7_29
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) {
    int count = 0;
    boolean word = false;
    String str = "how ma ny wo rds are th ere in th is sente nce";
    char [] ch = str.toCharArray ();
    for (int i = 0;
    i < ch.length; i ++) {
        if (! (ch [i] == ' ')) {
            for (int j = i;
            j < ch.length; j ++, i ++) {
                if (! (ch [j] == ' ')) {
                    word = true;
                    if (j == ch.length - 1) {
                        count ++;
                    }
                    continue;
                } else {
                    if (word) {
                        count ++;
                    }
                    word = false;
                }
            }
        } else {
            continue;
        }
    }
    System.out.println ("there are " + (count) + " words");
}
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("enter Your String");
    String input = br.readLine ();
    char [] arr = input.toCharArray ();
    int i = 0;
    boolean notCounted = true;
    int counter = 0;
    while (i < arr.length) {
        if (arr [i] != ' ') {
            if (notCounted) {
                notCounted = false;
                counter ++;
            }
        } else {
            notCounted = true;
        }
        i ++;
    }
    System.out.println ("words in the string are : " + counter);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_16654721_3_31
5864159_29312924_1_43
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) {
    int count = 0;
    boolean word = false;
    String str = "how ma ny wo rds are th ere in th is sente nce";
    char [] ch = str.toCharArray ();
    for (int i = 0;
    i < ch.length; i ++) {
        if (! (ch [i] == ' ')) {
            for (int j = i;
            j < ch.length; j ++, i ++) {
                if (! (ch [j] == ' ')) {
                    word = true;
                    if (j == ch.length - 1) {
                        count ++;
                    }
                    continue;
                } else {
                    if (word) {
                        count ++;
                    }
                    word = false;
                }
            }
        } else {
            continue;
        }
    }
    System.out.println ("there are " + (count) + " words");
}
----------------------------------------

public static void main (String [] args) {
    File f = new File ("src/MyFrame.java");
    String value = null;
    int i = 0;
    int j = 0;
    int k = 0;
    try {
        Scanner in = new Scanner (f);
        while (in.hasNextLine ()) {
            String a = in.nextLine ();
            k ++;
            char chars [] = a.toCharArray ();
            i += chars.length;
        }
        in.close ();
        Scanner in2 = new Scanner (f);
        while (in2.hasNext ()) {
            String b = in2.next ();
            System.out.println (b);
            j ++;
        }
        in2.close ();
        System.out.println ("the number of chars is :" + i);
        System.out.println ("the number of words is :" + j);
        System.out.println ("the number of lines is :" + k);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_16654721_3_31
5864159_35227754_8_23
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) {
    int count = 0;
    boolean word = false;
    String str = "how ma ny wo rds are th ere in th is sente nce";
    char [] ch = str.toCharArray ();
    for (int i = 0;
    i < ch.length; i ++) {
        if (! (ch [i] == ' ')) {
            for (int j = i;
            j < ch.length; j ++, i ++) {
                if (! (ch [j] == ' ')) {
                    word = true;
                    if (j == ch.length - 1) {
                        count ++;
                    }
                    continue;
                } else {
                    if (word) {
                        count ++;
                    }
                    word = false;
                }
            }
        } else {
            continue;
        }
    }
    System.out.println ("there are " + (count) + " words");
}
----------------------------------------

public static void main (String [] args) throws IOException {
    String str;
    int cWords = 1;
    char ch;
    BufferedReader buffor = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Enter text: ");
    str = buffor.readLine ();
    for (int i = 0;
    i < str.length (); i ++) {
        ch = str.charAt (i);
        if (Character.isWhitespace (ch)) {
            cWords ++;
        }
    }
    System.out.println ("There are " + (int) cWords + " words.");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_16654721_3_31
5864159_43830925_7_25
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) {
    int count = 0;
    boolean word = false;
    String str = "how ma ny wo rds are th ere in th is sente nce";
    char [] ch = str.toCharArray ();
    for (int i = 0;
    i < ch.length; i ++) {
        if (! (ch [i] == ' ')) {
            for (int j = i;
            j < ch.length; j ++, i ++) {
                if (! (ch [j] == ' ')) {
                    word = true;
                    if (j == ch.length - 1) {
                        count ++;
                    }
                    continue;
                } else {
                    if (word) {
                        count ++;
                    }
                    word = false;
                }
            }
        } else {
            continue;
        }
    }
    System.out.println ("there are " + (count) + " words");
}
----------------------------------------

public static void main (String [] args) {
    Map < String, Integer > m = new HashMap < String, Integer > ();
    String phrase = "hello my name is John I repeat John";
    String [] array = phrase.split (" ");
    for (int i = 0;
    i < array.length; i ++) {
        String word_i = array [i];
        Integer ci = m.get (word_i);
        if (ci == null) {
            m.put (word_i, 1);
        } else m.put (word_i, ci + 1);

    }
    for (String s : m.keySet ()) {
        System.out.println (s + " repeats " + m.get (s));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_26556135_7_29
5864159_29312924_1_43
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("enter Your String");
    String input = br.readLine ();
    char [] arr = input.toCharArray ();
    int i = 0;
    boolean notCounted = true;
    int counter = 0;
    while (i < arr.length) {
        if (arr [i] != ' ') {
            if (notCounted) {
                notCounted = false;
                counter ++;
            }
        } else {
            notCounted = true;
        }
        i ++;
    }
    System.out.println ("words in the string are : " + counter);
}
----------------------------------------

public static void main (String [] args) {
    File f = new File ("src/MyFrame.java");
    String value = null;
    int i = 0;
    int j = 0;
    int k = 0;
    try {
        Scanner in = new Scanner (f);
        while (in.hasNextLine ()) {
            String a = in.nextLine ();
            k ++;
            char chars [] = a.toCharArray ();
            i += chars.length;
        }
        in.close ();
        Scanner in2 = new Scanner (f);
        while (in2.hasNext ()) {
            String b = in2.next ();
            System.out.println (b);
            j ++;
        }
        in2.close ();
        System.out.println ("the number of chars is :" + i);
        System.out.println ("the number of words is :" + j);
        System.out.println ("the number of lines is :" + k);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_26556135_7_29
5864159_35227754_8_23
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("enter Your String");
    String input = br.readLine ();
    char [] arr = input.toCharArray ();
    int i = 0;
    boolean notCounted = true;
    int counter = 0;
    while (i < arr.length) {
        if (arr [i] != ' ') {
            if (notCounted) {
                notCounted = false;
                counter ++;
            }
        } else {
            notCounted = true;
        }
        i ++;
    }
    System.out.println ("words in the string are : " + counter);
}
----------------------------------------

public static void main (String [] args) throws IOException {
    String str;
    int cWords = 1;
    char ch;
    BufferedReader buffor = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Enter text: ");
    str = buffor.readLine ();
    for (int i = 0;
    i < str.length (); i ++) {
        ch = str.charAt (i);
        if (Character.isWhitespace (ch)) {
            cWords ++;
        }
    }
    System.out.println ("There are " + (int) cWords + " words.");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_26556135_7_29
5864159_43830925_7_25
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader br = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("enter Your String");
    String input = br.readLine ();
    char [] arr = input.toCharArray ();
    int i = 0;
    boolean notCounted = true;
    int counter = 0;
    while (i < arr.length) {
        if (arr [i] != ' ') {
            if (notCounted) {
                notCounted = false;
                counter ++;
            }
        } else {
            notCounted = true;
        }
        i ++;
    }
    System.out.println ("words in the string are : " + counter);
}
----------------------------------------

public static void main (String [] args) {
    Map < String, Integer > m = new HashMap < String, Integer > ();
    String phrase = "hello my name is John I repeat John";
    String [] array = phrase.split (" ");
    for (int i = 0;
    i < array.length; i ++) {
        String word_i = array [i];
        Integer ci = m.get (word_i);
        if (ci == null) {
            m.put (word_i, 1);
        } else m.put (word_i, ci + 1);

    }
    for (String s : m.keySet ()) {
        System.out.println (s + " repeats " + m.get (s));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_29312924_1_43
5864159_35227754_8_23
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) {
    File f = new File ("src/MyFrame.java");
    String value = null;
    int i = 0;
    int j = 0;
    int k = 0;
    try {
        Scanner in = new Scanner (f);
        while (in.hasNextLine ()) {
            String a = in.nextLine ();
            k ++;
            char chars [] = a.toCharArray ();
            i += chars.length;
        }
        in.close ();
        Scanner in2 = new Scanner (f);
        while (in2.hasNext ()) {
            String b = in2.next ();
            System.out.println (b);
            j ++;
        }
        in2.close ();
        System.out.println ("the number of chars is :" + i);
        System.out.println ("the number of words is :" + j);
        System.out.println ("the number of lines is :" + k);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    String str;
    int cWords = 1;
    char ch;
    BufferedReader buffor = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Enter text: ");
    str = buffor.readLine ();
    for (int i = 0;
    i < str.length (); i ++) {
        ch = str.charAt (i);
        if (Character.isWhitespace (ch)) {
            cWords ++;
        }
    }
    System.out.println ("There are " + (int) cWords + " words.");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_29312924_1_43
5864159_43830925_7_25
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) {
    File f = new File ("src/MyFrame.java");
    String value = null;
    int i = 0;
    int j = 0;
    int k = 0;
    try {
        Scanner in = new Scanner (f);
        while (in.hasNextLine ()) {
            String a = in.nextLine ();
            k ++;
            char chars [] = a.toCharArray ();
            i += chars.length;
        }
        in.close ();
        Scanner in2 = new Scanner (f);
        while (in2.hasNext ()) {
            String b = in2.next ();
            System.out.println (b);
            j ++;
        }
        in2.close ();
        System.out.println ("the number of chars is :" + i);
        System.out.println ("the number of words is :" + j);
        System.out.println ("the number of lines is :" + k);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    Map < String, Integer > m = new HashMap < String, Integer > ();
    String phrase = "hello my name is John I repeat John";
    String [] array = phrase.split (" ");
    for (int i = 0;
    i < array.length; i ++) {
        String word_i = array [i];
        Integer ci = m.get (word_i);
        if (ci == null) {
            m.put (word_i, 1);
        } else m.put (word_i, ci + 1);

    }
    for (String s : m.keySet ()) {
        System.out.println (s + " repeats " + m.get (s));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_35222706_1_19
5864159_47834479_1_22
Title: Count words in a string method? 
----------------------------------------

public static int countWords (String input) {
    int wordCount = 0;
    boolean isBlankSet = false;
    input = input.trim ();
    for (int j = 0;
    j < input.length (); j ++) {
        if (input.charAt (j) == ' ') isBlankSet = true;
        else {
            if (isBlankSet) {
                wordCount ++;
                isBlankSet = false;
            }
        }
    }
    return wordCount + 1;
}
----------------------------------------

public static int countWords (final String s) {
    int wordCount = 0;
    boolean word = false;
    final int endOfLine = s.length () - 1;
    for (int i = 0;
    i < s.length (); i ++) {
        if (isWordCharacter (s, i) && i != endOfLine) {
            word = true;
        } else if (! isWordCharacter (s, i) && word) {
            wordCount ++;
            word = false;
        } else if (isWordCharacter (s, i) && i == endOfLine) {
            wordCount ++;
        }

    }
    return wordCount;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_35222706_1_19
5864159_5864184_1_24
Title: Count words in a string method? 
----------------------------------------

public static int countWords (String input) {
    int wordCount = 0;
    boolean isBlankSet = false;
    input = input.trim ();
    for (int j = 0;
    j < input.length (); j ++) {
        if (input.charAt (j) == ' ') isBlankSet = true;
        else {
            if (isBlankSet) {
                wordCount ++;
                isBlankSet = false;
            }
        }
    }
    return wordCount + 1;
}
----------------------------------------

public static int countWords (String s) {
    int wordCount = 0;
    boolean word = false;
    int endOfLine = s.length () - 1;
    for (int i = 0;
    i < s.length (); i ++) {
        if (Character.isLetter (s.charAt (i)) && i != endOfLine) {
            word = true;
        } else if (! Character.isLetter (s.charAt (i)) && word) {
            wordCount ++;
            word = false;
        } else if (Character.isLetter (s.charAt (i)) && i == endOfLine) {
            wordCount ++;
        }

    }
    return wordCount;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_35227754_8_23
5864159_43830925_7_25
Title: Count words in a string method? 
----------------------------------------

public static void main (String [] args) throws IOException {
    String str;
    int cWords = 1;
    char ch;
    BufferedReader buffor = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Enter text: ");
    str = buffor.readLine ();
    for (int i = 0;
    i < str.length (); i ++) {
        ch = str.charAt (i);
        if (Character.isWhitespace (ch)) {
            cWords ++;
        }
    }
    System.out.println ("There are " + (int) cWords + " words.");
}
----------------------------------------

public static void main (String [] args) {
    Map < String, Integer > m = new HashMap < String, Integer > ();
    String phrase = "hello my name is John I repeat John";
    String [] array = phrase.split (" ");
    for (int i = 0;
    i < array.length; i ++) {
        String word_i = array [i];
        Integer ci = m.get (word_i);
        if (ci == null) {
            m.put (word_i, 1);
        } else m.put (word_i, ci + 1);

    }
    for (String s : m.keySet ()) {
        System.out.println (s + " repeats " + m.get (s));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5864159_47834479_1_22
5864159_5864184_1_24
Title: Count words in a string method? 
----------------------------------------

public static int countWords (final String s) {
    int wordCount = 0;
    boolean word = false;
    final int endOfLine = s.length () - 1;
    for (int i = 0;
    i < s.length (); i ++) {
        if (isWordCharacter (s, i) && i != endOfLine) {
            word = true;
        } else if (! isWordCharacter (s, i) && word) {
            wordCount ++;
            word = false;
        } else if (isWordCharacter (s, i) && i == endOfLine) {
            wordCount ++;
        }

    }
    return wordCount;
}
----------------------------------------

public static int countWords (String s) {
    int wordCount = 0;
    boolean word = false;
    int endOfLine = s.length () - 1;
    for (int i = 0;
    i < s.length (); i ++) {
        if (Character.isLetter (s.charAt (i)) && i != endOfLine) {
            word = true;
        } else if (! Character.isLetter (s.charAt (i)) && word) {
            wordCount ++;
            word = false;
        } else if (Character.isLetter (s.charAt (i)) && i == endOfLine) {
            wordCount ++;
        }

    }
    return wordCount;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5875437_44466424_36_48
5875437_44466424_51_66
Title: Convert wait & notifyAll code to use Java 1.5 Lock object 
----------------------------------------

public void run () {
    while (true) {
        consumers.arriveAndAwaitAdvance ();
        for (int i = 0;
        i < array.length; i ++) {
            printMethod (array [i]);
        }
        producer.arriveAndAwaitAdvance ();
        System.out.println (Thread.currentThread ().getName () + " thread wakeup but will stuck with consumers.arriveAndAwaitAdvance!");
    }
}
----------------------------------------

public void run () {
    for (int j = 0;
    j < 3; j ++) {
        array = new String [5];
        for (int i = 0;
        i < array.length; i ++) {
            array [i] = "Phase_" + (j + 1) + " Count_" + (i + 1);
        }
        System.out.println ("Main thread pushed data.");
        consumers.arriveAndAwaitAdvance ();
        producer.arriveAndAwaitAdvance ();
        System.out.println ("Main thread wakeup and will start pushing data...");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5880169_5887380_18_29
5880169_5887380_35_47
Title: Loading a text file into a textarea 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    try {
        FileReader reader = new FileReader ("TextAreaLoad.txt");
        BufferedReader br = new BufferedReader (reader);
        edit.read (br, null);
        br.close ();
        edit.requestFocus ();
    } catch (Exception e2) {
        System.out.println (e2);
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    try {
        FileWriter writer = new FileWriter ("TextAreaLoad.txt");
        BufferedWriter bw = new BufferedWriter (writer);
        edit.write (bw);
        bw.close ();
        edit.setText ("");
        edit.requestFocus ();
    } catch (Exception e2) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5891223_33160742_1_11
5891223_5891278_1_10
Title: Recursively compute the value of base to the n power 
----------------------------------------

public int powerN (int base, int power) {
    if (power == 1) return base;
    else if (power % 2 == 0) {
        int x = powerN (base, power / 2);
        return x * x;
    } else {
        int x = powerN (base, (power - 1) / 2);
        return x * x * base;
    }

}
----------------------------------------

public static int powerN (int base, int n) {
    if (n < 0) {
        throw new IllegalArgumentException ("Illegal Power Argument");
    }
    if (n == 0) {
        return 1;
    } else {
        return base * powerN (base, n - 1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5891223_37879321_3_21
5891223_46005231_1_21
Title: Recursively compute the value of base to the n power 
----------------------------------------

int power (int n, int p) throws Exception {
    int s = n;
    if (n < 0 || p < 0) {
        throw new Exception ("n and p must be positive");
    }
    if (p == 2) {
        return n * n * r;
    } else {
        r = r * n;
        return power (n, p - 1);
    }
}
----------------------------------------

int power (int a, int b) {
    int k = a;
    int c = b;
    if (c == 1) {
        return a;
    } else if (c == 0) {
        return 1;
    } else if (c >= 1) {
        c --;
        k = k * power (k, c);
    }

    cout << k << endl;
    return k;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5902310_5902369_1_12
5902310_9942662_7_116
Title: How do I validate a timestamp? 
----------------------------------------

public static bool isTimeStampValid (String inputString) {
    SimpleDateFormat format = new java.text.SimpleDateFormat ("yyyy-MM-dd HH:mm:ss.SSSSSS");
    try {
        format.parse (inputString);
        return true;
    } catch (ParseException e) {
        return false;
    }
}
----------------------------------------

public static boolean isTimeStampValid (String timestamp) {
    boolean time = false;
    try {
        StringTokenizer st = new StringTokenizer (timestamp, " ");
        if (st.countTokens () != 2) {
            return false;
        }
        String [] dateAndTime = new String [2];
        int i = 0;
        while (st.hasMoreTokens ()) {
            dateAndTime [i] = st.nextToken ();
            i ++;
        }
        String timeToken = dateAndTime [1];
        StringTokenizer timeTokens = new StringTokenizer (timeToken, ":");
        if (timeTokens.countTokens () != 3) {
            return false;
        }
        String [] timeAt = new String [4];
        int j = 0;
        while (timeTokens.hasMoreTokens ()) {
            timeAt [j] = timeTokens.nextToken ();
            j ++;
        }
        try {
            int HH = Integer.valueOf (timeAt [0].toString ());
            int mm = Integer.valueOf (timeAt [1].toString ());
            float ss = Float.valueOf (timeAt [2].toString ());
            if (HH < 60 && HH >= 0 && mm < 60 && mm >= 0 && ss < 60 && ss >= 0) {
                time = true;
            } else {
            }
        } catch (Exception e) {
            e.printStackTrace ();
        }
        String dateToken = dateAndTime [0];
        StringTokenizer dateTokens = new StringTokenizer (dateToken, "-");
        if (dateTokens.countTokens () != 3) {
            return false;
        }
        String [] tokenAt = new String [3];
        int k = 0;
        while (dateTokens.hasMoreTokens ()) {
            tokenAt [k] = dateTokens.nextToken ();
            k ++;
        }
        int dayInt = Integer.parseInt (tokenAt [2]);
        int monthInt = Integer.parseInt (tokenAt [1]);
        int yearInt = Integer.parseInt (tokenAt [0]);
        Calendar cal = new GregorianCalendar ();
        cal.setLenient (false);
        cal.set (yearInt, monthInt - 1, dayInt);
        cal.getTime ();
    } catch (Exception e) {
        e.printStackTrace ();
        return false;
    }
    try {
        Pattern p = Pattern.compile ("^\\d{4}[-]?\\d{1,2}[-]?\\d{1,2} \\d{1,2}:\\d{1,2}:\\d{1,2}[.]?\\d{1,6}$");
        if (p.matcher (timestamp).matches ()) {
        } else {
            return false;
        }
    } catch (Exception e) {
        e.printStackTrace ();
        return false;
    }
    SimpleDateFormat format = new java.text.SimpleDateFormat ("yyyy-MM-dd HH:mm:ss.SSSSSS");
    try {
        format.parse (timestamp);
        if (time) {
            return true;
        } else {
            return false;
        }
    } catch (ParseException e) {
        e.printStackTrace ();
        return false;
    } catch (Exception e) {
        e.printStackTrace ();
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
590385_30503995_12_47
590385_590448_6_22
Title: How to get all dates of sundays in a particular year in Java? 
----------------------------------------

public static void main (String [] args) {
    SimpleDateFormat format = new SimpleDateFormat ("dd-MMM-yyyy");
    String DATE_FORMAT = "yyyy MM dd";
    SimpleDateFormat sdf = new SimpleDateFormat (DATE_FORMAT);
    Calendar c1 = Calendar.getInstance ();
    String y = sdf.format (c1.getTime ());
    String years = y.substring (0, 4);
    int year = Integer.parseInt (years);
    Calendar cal = new GregorianCalendar (year, Calendar.JANUARY, 1);
    for (int i = 0, inc = 1;
    i < 366 && cal.get (Calendar.YEAR) == year; i += inc) {
        if (cal.get (Calendar.DAY_OF_WEEK) == Calendar.SUNDAY) {
            String frm = "";
            frm = format.format (cal.getTime ());
            System.out.println ("the value of the sunday is " + format.format (cal.getTime ()));
            cal.add (Calendar.DAY_OF_MONTH, 7);
        } else {
            cal.add (Calendar.DAY_OF_MONTH, 1);
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int year = 2009;
    int dayOfWeek = Calendar.SUNDAY;
    String dayOfWeekString = "Sunday";
    Calendar cal = new GregorianCalendar ();
    cal.set (2009, 0, 1, 0, 0);
    cal.getTime ();
    cal.set (Calendar.DAY_OF_WEEK, dayOfWeek);
    cal.getTime ();
    int i = 1;
    while (cal.get (Calendar.YEAR) == 2009) {
        System.out.println (dayOfWeekString + " " + i + ": " + cal);
        cal.add (Calendar.DAY_OF_MONTH, 7);
        i ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5921965_5922059_1_28
5921965_5922144_1_30
Title: Can method be readable and shorter ?  
----------------------------------------

private int maxSequence (char player, Cell c) {
    int row = c.getRow ();
    int col = c.getCol ();
    int maxVert = 0;
    int maxHor = 0;
    int maxDiag = 0;
    for (int j = 0;
    j < _board [0].length; j ++) {
        if ((_board [col] [row + j] == O) || (_board [col] [row - j] == player)) {
            maxVert ++;
        }
        if ((_board [col + j] [row] == O) || (_board [col - j] [row] == player)) {
            maxHor ++;
        }
        if ((_board [col + j] [row + j] == 0) || (_board [col - j] [row - j] == player)) {
            maxDiag ++;
        }
    }
    return Math.max (maxDiag, Math.max (maxVert, maxHor));
}
----------------------------------------

private int maxSequence (char player, Cell c) {
    int row = c.getRow ();
    int col = c.getCol ();
    int maxVert = 0;
    int maxHor = 0;
    int maxDiag = 0;
    if (player == O) {
        for (int j = 0;
        j < _board [0].length; j ++) {
            if ((_board [col] [row + j] == O) || (_board [col] [row - j] == O)) maxVert ++;

            if ((_board [col + j] [row] == O) || (_board [col - j] [row] == O)) maxHor ++;

            if ((_board [col + j] [row + j] == 0) || (_board [col - j] [row - j] == O)) maxDiag ++;

        }
    }
    if (player == X) {
        for (int j = 0;
        j < _board [0].length; j ++) {
            if ((_board [col] [row + j] == O) || (_board [col] [row - j] == X)) maxVert ++;

            if ((_board [col + j] [row] == O) || (_board [col - j] [row] == X)) maxHor ++;

            if ((_board [col + j] [row + j] == 0) || (_board [col - j] [row - j] == X)) maxDiag ++;

        }
    }
    if ((maxDiag >= maxVert) && (maxDiag >= maxHor)) return maxDiag;

    if ((maxVert >= maxDiag) && (maxVert >= maxHor)) return maxVert;

    return maxHor;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5924422_5924451_1_23
5924422_5924471_9_21
Title: Dynamic JPanel with objects not displaying 
----------------------------------------

JPanel createTipTailoringPanel (TipCalcModel model) {
    JPanel content = new JPanel ();
    int size = model.getNumOfPeople ();
    content.setLayout (new GridLayout (0, 4));
    if (size == 0) {
        return content;
    } else {
        for (int i = 0;
        i < size; i ++) {
            content.add (new JTextField ());
            content.add (new JSlider ());
            content.add (new JLabel ("$"));
            content.add (new JLabel ());
        }
        return content;
    }
}
----------------------------------------

JPanel createTipTailoringPanel (int size) {
    JPanel content = new JPanel ();
    content.setLayout (new GridLayout (0, 4));
    for (int i = 0;
    i < size; i ++) {
        content.add (new JTextField ());
        content.add (new JSlider ());
        content.add (new JLabel ("$"));
        content.add (new JLabel ());
    }
    return content;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5955259_5957062_127_135
5955259_5957130_42_66
Title: how can i solve this error 
----------------------------------------

public Void doInBackground () {
    setProgress (0);
    try {
        Thread.sleep (SLEEP_TIME);
    } catch (InterruptedException e) {
    }
    setProgress (100);
    return null;
}
----------------------------------------

protected ArrayList < Integer > doInBackground () {
    if (javax.swing.SwingUtilities.isEventDispatchThread ()) {
        System.out.println ("javax.swing.SwingUtilities.isEventDispatchThread() returned true.");
    }
    Integer tmpValue = new Integer (1);
    ArrayList < Integer > list = new ArrayList < Integer > ();
    for (int i = 0;
    i < 100; i ++) {
        for (int j = 0;
        j < 100; j ++) {
            tmpValue = FindNextPrime (tmpValue.intValue ());
            if (isCancelled ()) {
                System.out.println ("SwingWorker - isCancelled");
                return list;
            }
        }
        publish (new Integer (i));
        list.add (tmpValue);
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5955259_5957062_22_30
5955259_5957130_161_170
Title: how can i solve this error 
----------------------------------------

public static void main (String [] args) {
    java.awt.EventQueue.invokeLater (new Runnable () {
        @Override
        public void run () {
            createAndShowUI ();
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            SwingWorkerExample swingWorkerExample = new SwingWorkerExample ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5958169_19141103_8_31
5958169_36790245_1_25
Title: How to merge two sorted arrays into a sorted array? 
----------------------------------------

public static void main (String [] args) {
    int FirstArrayLocation = 0;
    int SecondArrayLocation = 0;
    int [] mergeArr = new int [arr1.length + arr2.length];
    for (int i = 0;
    i <= arr1.length + arr2.length; i ++) {
        if ((FirstArrayLocation < arr1.length) && (SecondArrayLocation < arr2.length)) {
            if (arr1 [FirstArrayLocation] <= arr2 [SecondArrayLocation]) {
                mergeArr [i] = arr1 [FirstArrayLocation];
                FirstArrayLocation ++;
            } else {
                mergeArr [i] = arr2 [SecondArrayLocation];
                SecondArrayLocation ++;
            }
        } else if (SecondArrayLocation < arr2.length) {
            mergeArr [i] = arr2 [SecondArrayLocation];
            SecondArrayLocation ++;
        } else if (FirstArrayLocation < arr1.length) {
            mergeArr [i] = arr1 [FirstArrayLocation];
            FirstArrayLocation ++;
        }

    }
}
----------------------------------------

public static void main (String [] args) {
    int [] arr1 = {2, 4, 6, 8, 10, 999};
    int [] arr2 = {1, 3, 5, 9, 100, 1001};
    int [] arr3 = new int [arr1.length + arr2.length];
    int temp = 0;
    for (int i = 0;
    i < (arr3.length); i ++) {
        if (temp == arr2.length) {
            arr3 [i] = arr1 [i - temp];
        } else if (((i - temp) < (arr1.length)) && (arr1 [i - temp] < arr2 [temp])) {
            arr3 [i] = arr1 [i - temp];
        } else {
            arr3 [i] = arr2 [temp];
            temp ++;
        }

    }
    for (int i : arr3) {
        System.out.print (i + ", ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5958169_19509386_1_16
5958169_48857966_45_83
Title: How to merge two sorted arrays into a sorted array? 
----------------------------------------

private static int [] sortedArrayMerge (int a [], int b []) {
    int result [] = new int [a.length + b.length];
    int i = 0;
    int j = 0;
    int k = 0;
    while (i < a.length && j < b.length) {
        if (a [i] < b [j]) {
            result [k ++] = a [i];
            i ++;
        } else {
            result [k ++] = b [j];
            j ++;
        }
    }
    System.arraycopy (a, i, result, k, (a.length - i));
    System.arraycopy (b, j, result, k, (b.length - j));
    return result;
}
----------------------------------------

static public int [] sortedArrayMerge (int [] results, int [] a, int aRead, int b [], int bRead) {
    int write = aRead + bRead, length, gallopPos;
    if ((results == null) || (results.length < write)) {
        results = new int [write];
    }
    if (aRead > 0 && bRead > 0) {
        int c = Integer.compare (a [aRead - 1], b [bRead - 1]);
        while (aRead > 0 && bRead > 0) {
            switch (c) {
                default :
                    gallopPos = gallopSearch (aRead, a, b [bRead - 1]);
                    length = (aRead - gallopPos);
                    write -= length;
                    aRead = gallopPos;
                    System.arraycopy (a, gallopPos --, results, write, length);
                    c = - 1;
                    break;
                case - 1 :
                    gallopPos = gallopSearch (bRead, b, a [aRead - 1]);
                    length = (bRead - gallopPos);
                    write -= length;
                    bRead = gallopPos;
                    System.arraycopy (b, gallopPos --, results, write, length);
                    c = 1;
                    break;
            }
        }
    }
    if (bRead > 0) {
        if (b != results) {
            System.arraycopy (b, 0, results, 0, bRead);
        }
    } else if (aRead > 0) {
        if (a != results) {
            System.arraycopy (a, 0, results, 0, aRead);
        }
    }

    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5958169_24020374_1_31
5958169_24195323_1_24
Title: How to merge two sorted arrays into a sorted array? 
----------------------------------------

public static int [] merge (int [] listA, int [] listB) {
    int [] mergedList = new int [listA.length + listB.length];
    int i = 0;
    int j = 0;
    int k = 0;
    while (true) {
        if (i >= listA.length && j >= listB.length) {
            break;
        }
        if (i < listA.length && j < listB.length) {
            if (listA [i] <= listB [j]) {
                mergedList [k] = listA [i];
                k ++;
                i ++;
            } else {
                mergedList [k] = listB [j];
                k ++;
                j ++;
            }
        } else if (i < listA.length && j >= listB.length) {
            mergedList [k] = listA [i];
            k ++;
            i ++;
        } else if (i <= listA.length && j < listB.length) {
            mergedList [k] = listB [j];
            k ++;
            j ++;
        }

    }
    return mergedList;
}
----------------------------------------

public int [] merge (int [] a, int [] b) {
    int [] result = new int [a.length + b.length];
    int aIndex, bIndex = 0;
    for (int i = 0;
    i < result.length; i ++) {
        if (aIndex < a.length && bIndex < b.length) {
            if (a [aIndex] < b [bIndex]) {
                result [i] = a [aIndex];
                aIndex ++;
            } else {
                result [i] = b [bIndex];
                bIndex ++;
            }
        } else if (aIndex < a.length) {
            result [i] = a [aIndex];
            aIndex ++;
        } else {
            result [i] = b [bIndex];
            bIndex ++;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5958169_24020374_1_31
5958169_8949433_1_17
Title: How to merge two sorted arrays into a sorted array? 
----------------------------------------

public static int [] merge (int [] listA, int [] listB) {
    int [] mergedList = new int [listA.length + listB.length];
    int i = 0;
    int j = 0;
    int k = 0;
    while (true) {
        if (i >= listA.length && j >= listB.length) {
            break;
        }
        if (i < listA.length && j < listB.length) {
            if (listA [i] <= listB [j]) {
                mergedList [k] = listA [i];
                k ++;
                i ++;
            } else {
                mergedList [k] = listB [j];
                k ++;
                j ++;
            }
        } else if (i < listA.length && j >= listB.length) {
            mergedList [k] = listA [i];
            k ++;
            i ++;
        } else if (i <= listA.length && j < listB.length) {
            mergedList [k] = listB [j];
            k ++;
            j ++;
        }

    }
    return mergedList;
}
----------------------------------------

public static int [] merge (int [] a, int [] b) {
    int [] answer = new int [a.length + b.length];
    int i = 0, j = 0, k = 0;
    while (i < a.length && j < b.length) answer [k ++] = a [i] < b [j] ? a [i ++] : b [j ++];

    while (i < a.length) answer [k ++] = a [i ++];

    while (j < b.length) answer [k ++] = b [j ++];

    return answer;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5958169_24195323_1_24
5958169_8949433_1_17
Title: How to merge two sorted arrays into a sorted array? 
----------------------------------------

public int [] merge (int [] a, int [] b) {
    int [] result = new int [a.length + b.length];
    int aIndex, bIndex = 0;
    for (int i = 0;
    i < result.length; i ++) {
        if (aIndex < a.length && bIndex < b.length) {
            if (a [aIndex] < b [bIndex]) {
                result [i] = a [aIndex];
                aIndex ++;
            } else {
                result [i] = b [bIndex];
                bIndex ++;
            }
        } else if (aIndex < a.length) {
            result [i] = a [aIndex];
            aIndex ++;
        } else {
            result [i] = b [bIndex];
            bIndex ++;
        }

    }
    return result;
}
----------------------------------------

public static int [] merge (int [] a, int [] b) {
    int [] answer = new int [a.length + b.length];
    int i = 0, j = 0, k = 0;
    while (i < a.length && j < b.length) answer [k ++] = a [i] < b [j] ? a [i ++] : b [j ++];

    while (i < a.length) answer [k ++] = a [i ++];

    while (j < b.length) answer [k ++] = b [j ++];

    return answer;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5961067_5961624_18_32
5961067_5962041_1_22
Title: Why does this String.equals() method always return false? 
----------------------------------------

public boolean equals (Object obj) {
    if (this == obj) return true;

    if (obj == null) return false;

    if (getClass () != obj.getClass ()) return false;

    DataSource other = (DataSource) obj;
    if (mUid == null) {
        if (other.mUid != null) return false;

    } else if (! mUid.equals (other.mUid)) return false;

    return true;
}
----------------------------------------

public boolean equals (Object obj) {
    if (this == obj) return true;

    if (obj instanceof String) {
        String s = (String) obj;
        int i = count;
        if (i == s.count) {
            char ac [] = value;
            char ac1 [] = s.value;
            int j = offset;
            int k = s.offset;
            while (i -- != 0) if (ac [j ++] != ac1 [k ++]) return false;

            return true;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5977735_41232616_1_17
5977735_5977877_13_21
Title: Setting outer variable from anonymous inner class 
----------------------------------------

public Long getNumber (final String type, final String refNumber, final Long year) throws ServiceException {
    try {
        Session session = PersistenceHelper.getSession ();
        return session.doReturningWork (conn -> {
            CallableStatement st = conn.prepareCall ("{ CALL PACKAGE.procedure(?, ?, ?, ?) }");
            st.setString (1, type);
            st.setString (2, refNumber);
            st.setLong (3, year);
            st.registerOutParameter (4, OracleTypes.NUMBER);
            st.execute ();
            return st.getLong (4);
        });
    } catch (Exception e) {
        log.error (e);
    }
    return null;
}
----------------------------------------

public Long getNumber () {
    final LongHolder result = new LongHolder ();
    doWork (new Work () {
        public void doWork () {
            result.value = 1L;
        }}

    );
    return result.value;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5977735_41232616_1_17
5977735_5978898_1_24
Title: Setting outer variable from anonymous inner class 
----------------------------------------

public Long getNumber (final String type, final String refNumber, final Long year) throws ServiceException {
    try {
        Session session = PersistenceHelper.getSession ();
        return session.doReturningWork (conn -> {
            CallableStatement st = conn.prepareCall ("{ CALL PACKAGE.procedure(?, ?, ?, ?) }");
            st.setString (1, type);
            st.setString (2, refNumber);
            st.setLong (3, year);
            st.registerOutParameter (4, OracleTypes.NUMBER);
            st.execute ();
            return st.getLong (4);
        });
    } catch (Exception e) {
        log.error (e);
    }
    return null;
}
----------------------------------------

public Long getNumber (final String type, final String refNumber, final Long year) throws ServiceException {
    try {
        Session session = PersistenceHelper.getSession ();
        return session.doWork (new Work < Long > () {
            public Long execute (Connection conn) throws SQLException {
                CallableStatement st = conn.prepareCall ("{ CALL PACKAGE.procedure(?, ?, ?, ?) }");
                try {
                    st.setString (1, type);
                    st.setString (2, refNumber);
                    st.setLong (3, year);
                    st.registerOutParameter (4, OracleTypes.NUMBER);
                    st.execute ();
                    return st.getLong (4);
                } finally {
                    st.close ();
                }
            }}

        );
    } catch (Exception e) {
        throw ServiceException (e);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5977735_5977877_13_21
5977735_5978898_1_24
Title: Setting outer variable from anonymous inner class 
----------------------------------------

public Long getNumber () {
    final LongHolder result = new LongHolder ();
    doWork (new Work () {
        public void doWork () {
            result.value = 1L;
        }}

    );
    return result.value;
}
----------------------------------------

public Long getNumber (final String type, final String refNumber, final Long year) throws ServiceException {
    try {
        Session session = PersistenceHelper.getSession ();
        return session.doWork (new Work < Long > () {
            public Long execute (Connection conn) throws SQLException {
                CallableStatement st = conn.prepareCall ("{ CALL PACKAGE.procedure(?, ?, ?, ?) }");
                try {
                    st.setString (1, type);
                    st.setString (2, refNumber);
                    st.setLong (3, year);
                    st.registerOutParameter (4, OracleTypes.NUMBER);
                    st.execute ();
                    return st.getLong (4);
                } finally {
                    st.close ();
                }
            }}

        );
    } catch (Exception e) {
        throw ServiceException (e);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5988029_14098926_36_54
5988029_14098926_92_116
Title: Java Telnet Library 
----------------------------------------

public void run () {
    while (isKeepRunning) {
        String s;
        try {
            s = checker.messageQueue.take ();
        } catch (InterruptedException e) {
            break;
        }
        synchronized (Responder.class) {
            builder.append (s);
        }
        if (waitFor != null && latch != null && foundWaitFor (waitFor)) {
            latch.countDown ();
        }
    }
}
----------------------------------------

public void run () {
    InputStream instr = tc.getInputStream ();
    try {
        byte [] buff = new byte [1024];
        int ret_read = 0;
        do {
            ret_read = instr.read (buff);
            if (ret_read > 0) {
                checker.sendForResponse (new String (buff, 0, ret_read));
            }
        } while (ret_read >= 0);
    } catch (Exception e) {
        System.err.println ("Exception while reading socket:" + e.getMessage ());
    }
    try {
        tc.disconnect ();
        checker.stop ();
        System.out.println ("Disconnected.");
    } catch (Exception e) {
        System.err.println ("Exception while closing telnet:" + e.getMessage ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_18959436_48_60
5999193_18959436_70_84
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    System.out.println ("Starting producer thread.");
    for (char ch = 'A';
    ch <= 'Z'; ch ++) {
        System.out.println ("Producer thread getting ready to create a char.");
        try {
            Thread.sleep ((int) (Math.random () * 1000));
        } catch (InterruptedException e) {
        }
        s.setSharedChar (ch);
        System.out.println (ch + " produced by producer.");
    }
}
----------------------------------------

public void run () {
    System.out.println ("Starting consumer thread.");
    char ch;
    do {
        System.out.println ("Consumer thread getting ready to read a char.");
        try {
            Thread.sleep ((int) (Math.random () * 1000));
        } catch (InterruptedException e) {
        }
        ch = s.getSharedChar ();
        System.out.println (ch + " consumed by consumer.");
    } while (ch != 'Z');
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_18959436_48_60
5999193_28726421_10_26
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    System.out.println ("Starting producer thread.");
    for (char ch = 'A';
    ch <= 'Z'; ch ++) {
        System.out.println ("Producer thread getting ready to create a char.");
        try {
            Thread.sleep ((int) (Math.random () * 1000));
        } catch (InterruptedException e) {
        }
        s.setSharedChar (ch);
        System.out.println (ch + " produced by producer.");
    }
}
----------------------------------------

public void run () {
    synchronized (resource) {
        System.out.println ("Before Reading Updated Value By : " + Thread.currentThread ().getName ());
        try {
            resource.wait ();
            System.out.println ("Waiting is Over For : " + Thread.currentThread ().getName ());
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        System.out.println ("Updated Value of Resource Mesg :" + resource.getMesg () + " Read By :" + Thread.currentThread ().getName ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_18959436_48_60
5999193_48908308_21_41
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    System.out.println ("Starting producer thread.");
    for (char ch = 'A';
    ch <= 'Z'; ch ++) {
        System.out.println ("Producer thread getting ready to create a char.");
        try {
            Thread.sleep ((int) (Math.random () * 1000));
        } catch (InterruptedException e) {
        }
        s.setSharedChar (ch);
        System.out.println (ch + " produced by producer.");
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (queue) {
            while (queue.size () == maxSize) {
                try {
                    System.out.println ("Queue is full, " + "Producer thread waiting for " + "consumer to take 
                          something from queue");
                    queue.wait ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                }
            }
            Random random = new Random ();
            int i = random.nextInt ();
            System.out.println ("Producing value : " + i);
            queue.add (i);
            queue.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_18959436_48_60
5999193_48908308_51_68
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    System.out.println ("Starting producer thread.");
    for (char ch = 'A';
    ch <= 'Z'; ch ++) {
        System.out.println ("Producer thread getting ready to create a char.");
        try {
            Thread.sleep ((int) (Math.random () * 1000));
        } catch (InterruptedException e) {
        }
        s.setSharedChar (ch);
        System.out.println (ch + " produced by producer.");
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (queue) {
            while (queue.isEmpty ()) {
                try {
                    System.out.println ("Queue is empty," + "Consumer thread is waiting" + " for producer thread to put something in queue");
                    queue.wait ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                }
            }
            System.out.println ("Consuming value : " + queue.remove ());
            queue.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_18959436_70_84
5999193_28726421_10_26
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    System.out.println ("Starting consumer thread.");
    char ch;
    do {
        System.out.println ("Consumer thread getting ready to read a char.");
        try {
            Thread.sleep ((int) (Math.random () * 1000));
        } catch (InterruptedException e) {
        }
        ch = s.getSharedChar ();
        System.out.println (ch + " consumed by consumer.");
    } while (ch != 'Z');
}
----------------------------------------

public void run () {
    synchronized (resource) {
        System.out.println ("Before Reading Updated Value By : " + Thread.currentThread ().getName ());
        try {
            resource.wait ();
            System.out.println ("Waiting is Over For : " + Thread.currentThread ().getName ());
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        System.out.println ("Updated Value of Resource Mesg :" + resource.getMesg () + " Read By :" + Thread.currentThread ().getName ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_18959436_70_84
5999193_48908308_21_41
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    System.out.println ("Starting consumer thread.");
    char ch;
    do {
        System.out.println ("Consumer thread getting ready to read a char.");
        try {
            Thread.sleep ((int) (Math.random () * 1000));
        } catch (InterruptedException e) {
        }
        ch = s.getSharedChar ();
        System.out.println (ch + " consumed by consumer.");
    } while (ch != 'Z');
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (queue) {
            while (queue.size () == maxSize) {
                try {
                    System.out.println ("Queue is full, " + "Producer thread waiting for " + "consumer to take 
                          something from queue");
                    queue.wait ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                }
            }
            Random random = new Random ();
            int i = random.nextInt ();
            System.out.println ("Producing value : " + i);
            queue.add (i);
            queue.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_18959436_70_84
5999193_48908308_51_68
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    System.out.println ("Starting consumer thread.");
    char ch;
    do {
        System.out.println ("Consumer thread getting ready to read a char.");
        try {
            Thread.sleep ((int) (Math.random () * 1000));
        } catch (InterruptedException e) {
        }
        ch = s.getSharedChar ();
        System.out.println (ch + " consumed by consumer.");
    } while (ch != 'Z');
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (queue) {
            while (queue.isEmpty ()) {
                try {
                    System.out.println ("Queue is empty," + "Consumer thread is waiting" + " for producer thread to put something in queue");
                    queue.wait ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                }
            }
            System.out.println ("Consuming value : " + queue.remove ());
            queue.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_28726421_10_26
5999193_48908308_21_41
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    synchronized (resource) {
        System.out.println ("Before Reading Updated Value By : " + Thread.currentThread ().getName ());
        try {
            resource.wait ();
            System.out.println ("Waiting is Over For : " + Thread.currentThread ().getName ());
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        System.out.println ("Updated Value of Resource Mesg :" + resource.getMesg () + " Read By :" + Thread.currentThread ().getName ());
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (queue) {
            while (queue.size () == maxSize) {
                try {
                    System.out.println ("Queue is full, " + "Producer thread waiting for " + "consumer to take 
                          something from queue");
                    queue.wait ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                }
            }
            Random random = new Random ();
            int i = random.nextInt ();
            System.out.println ("Producing value : " + i);
            queue.add (i);
            queue.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_28726421_10_26
5999193_48908308_51_68
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    synchronized (resource) {
        System.out.println ("Before Reading Updated Value By : " + Thread.currentThread ().getName ());
        try {
            resource.wait ();
            System.out.println ("Waiting is Over For : " + Thread.currentThread ().getName ());
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        System.out.println ("Updated Value of Resource Mesg :" + resource.getMesg () + " Read By :" + Thread.currentThread ().getName ());
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (queue) {
            while (queue.isEmpty ()) {
                try {
                    System.out.println ("Queue is empty," + "Consumer thread is waiting" + " for producer thread to put something in queue");
                    queue.wait ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                }
            }
            System.out.println ("Consuming value : " + queue.remove ());
            queue.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5999193_48908308_21_41
5999193_48908308_51_68
Title: Does notify/notifyall release the lock being held 
----------------------------------------

public void run () {
    while (true) {
        synchronized (queue) {
            while (queue.size () == maxSize) {
                try {
                    System.out.println ("Queue is full, " + "Producer thread waiting for " + "consumer to take 
                          something from queue");
                    queue.wait ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                }
            }
            Random random = new Random ();
            int i = random.nextInt ();
            System.out.println ("Producing value : " + i);
            queue.add (i);
            queue.notifyAll ();
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        synchronized (queue) {
            while (queue.isEmpty ()) {
                try {
                    System.out.println ("Queue is empty," + "Consumer thread is waiting" + " for producer thread to put something in queue");
                    queue.wait ();
                } catch (Exception ex) {
                    ex.printStackTrace ();
                }
            }
            System.out.println ("Consuming value : " + queue.remove ());
            queue.notifyAll ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6002720_6002852_1_10
6002720_6002959_1_14
Title: How can I remove one of these if statements and shorten the code? 
----------------------------------------

public char checkWinner () {
    for (int i = 0;
    i < GRIDSIZE; i ++) {
        if (checkRow (i)) return winner;

        if (checkColumn (i)) return winner;

    }
    if (checkDiagTopLeft ()) return winner;

    if (checkDiagBottomLeft ()) return winner;

}
----------------------------------------

public char checkWinner () {
    for (int i = 0;
    i < GRIDSIZE; i ++) {
        if (rowEqual (i)) return grid [i] [0];

        if (columnEqual (i)) return grid [0] [i];

    }
    if (diagonalLeftToRightEqual ()) return grid [0] [0];

    if (diagonalRightToLefttEqual ()) return grid [0] [GRIDSIZE];

    int totalTiles = GRIDSIZE * GRIDSIZE;
    return movesMade == totalTiles ? TIE : BLACK;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6008894_6008979_20_30
6008894_6008979_2_16
Title: Figure out a String of variable length? 
----------------------------------------

public String bruteforce (String prefix, String md5, int availdepth) {
    if (availdepth <= 0) return null;

    for (char c = ' ';
    c < '~'; ++ c) {
        String attempt = prefix + Character.toString (c);
        if (hashesMatch (md5, generateMD5 (attempt))) return attempt;

        String res = bruteforce (attempt, md5, availdepth - 1);
        if (res != null) return res;

    }
    return null;
}
----------------------------------------

public String bruteforce (List < String > prefixes, String md5, int availdepth) {
    if (availabledepth < 0) return null;

    List < String > newprefixes = new ArrayList < String > ();
    for (String prefix : prefixes) {
        for (char c = ' ';
        c < '~'; ++ c) {
            String attempt = prefix + Character.toString (c);
            generatedMd5 = generateMD5 (attempt);
            if (hashesMatch (md5, generatedMd5)) return attempt;

            newprefixes.add (attempt);
        }
    }
    return bruteforce (newprefixes, md5, availddepth - 1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_15419738_11_26
6017281_22164687_31_40
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    String tname = Thread.currentThread ().getName ();
    while (true) {
        increment ();
        synchronized (Counter.class) {
            try {
                cl.notify ();
                cl.wait ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (! obj.isOdd) {
            System.out.println ("Even:" + obj.count);
            obj.count ++;
            obj.isOdd = true;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_15419738_11_26
6017281_22164687_52_60
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    String tname = Thread.currentThread ().getName ();
    while (true) {
        increment ();
        synchronized (Counter.class) {
            try {
                cl.notify ();
                cl.wait ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (obj.isOdd) {
            System.out.println ("Odd:" + obj.count);
            obj.count ++;
            obj.isOdd = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_15419738_11_26
6017281_23440275_18_43
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    String tname = Thread.currentThread ().getName ();
    while (true) {
        increment ();
        synchronized (Counter.class) {
            try {
                cl.notify ();
                cl.wait ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    lock.lock ();
    while (naturalOrder.currentNumber < 20) {
        while (naturalOrder.evenOdd != true) {
            try {
                condition.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        try {
            Thread.sleep (ThreadLocalRandom.current ().nextInt (1000));
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        if (naturalOrder.currentNumber % 2 == 0) {
            System.out.println (naturalOrder.currentNumber);
        }
        naturalOrder.currentNumber ++;
        naturalOrder.evenOdd = false;
        condition.signalAll ();
    }
    lock.unlock ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_15419738_11_26
6017281_23440567_17_26
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    String tname = Thread.currentThread ().getName ();
    while (true) {
        increment ();
        synchronized (Counter.class) {
            try {
                cl.notify ();
                cl.wait ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    int i = type.equals ("odd") ? 1 : 2;
    while (i <= 10) {
        if (type.equals ("odd")) printOdd (i);

        if (type.equals ("even")) printEven (i);

        i = i + 2;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_15419738_11_26
6017281_26446997_51_82
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    String tname = Thread.currentThread ().getName ();
    while (true) {
        increment ();
        synchronized (Counter.class) {
            try {
                cl.notify ();
                cl.wait ();
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    ReentrantLock prevLock = null;
    int printCounter = index;
    for (int counter = 0;
    printCounter <= 1000; counter ++) {
        int remCounter = counter % lckArray.length;
        int incCounter = lckArray.length - remCounter;
        int indexPostion = index + incCounter;
        int curElementIndex = indexPostion % lckArray.length;
        lckArray [curElementIndex].lock ();
        if (prevLock != null) prevLock.unlock ();

        prevLock = lckArray [curElementIndex];
        if (curElementIndex == 0) {
            System.out.println ("Printed by Thread " + index + " " + printCounter);
            printCounter = printCounter + lckArray.length - 1;
        }
    }
    if (prevLock != null) {
        if (prevLock.isHeldByCurrentThread ()) prevLock.unlock ();

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_22164687_31_40
6017281_22164687_52_60
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (! obj.isOdd) {
            System.out.println ("Even:" + obj.count);
            obj.count ++;
            obj.isOdd = true;
        }
    }
}
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (obj.isOdd) {
            System.out.println ("Odd:" + obj.count);
            obj.count ++;
            obj.isOdd = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_22164687_31_40
6017281_23440275_18_43
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (! obj.isOdd) {
            System.out.println ("Even:" + obj.count);
            obj.count ++;
            obj.isOdd = true;
        }
    }
}
----------------------------------------

public void run () {
    lock.lock ();
    while (naturalOrder.currentNumber < 20) {
        while (naturalOrder.evenOdd != true) {
            try {
                condition.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        try {
            Thread.sleep (ThreadLocalRandom.current ().nextInt (1000));
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        if (naturalOrder.currentNumber % 2 == 0) {
            System.out.println (naturalOrder.currentNumber);
        }
        naturalOrder.currentNumber ++;
        naturalOrder.evenOdd = false;
        condition.signalAll ();
    }
    lock.unlock ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_22164687_31_40
6017281_23440567_17_26
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (! obj.isOdd) {
            System.out.println ("Even:" + obj.count);
            obj.count ++;
            obj.isOdd = true;
        }
    }
}
----------------------------------------

public void run () {
    int i = type.equals ("odd") ? 1 : 2;
    while (i <= 10) {
        if (type.equals ("odd")) printOdd (i);

        if (type.equals ("even")) printEven (i);

        i = i + 2;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_22164687_31_40
6017281_26446997_51_82
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (! obj.isOdd) {
            System.out.println ("Even:" + obj.count);
            obj.count ++;
            obj.isOdd = true;
        }
    }
}
----------------------------------------

public void run () {
    ReentrantLock prevLock = null;
    int printCounter = index;
    for (int counter = 0;
    printCounter <= 1000; counter ++) {
        int remCounter = counter % lckArray.length;
        int incCounter = lckArray.length - remCounter;
        int indexPostion = index + incCounter;
        int curElementIndex = indexPostion % lckArray.length;
        lckArray [curElementIndex].lock ();
        if (prevLock != null) prevLock.unlock ();

        prevLock = lckArray [curElementIndex];
        if (curElementIndex == 0) {
            System.out.println ("Printed by Thread " + index + " " + printCounter);
            printCounter = printCounter + lckArray.length - 1;
        }
    }
    if (prevLock != null) {
        if (prevLock.isHeldByCurrentThread ()) prevLock.unlock ();

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_22164687_52_60
6017281_23440275_18_43
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (obj.isOdd) {
            System.out.println ("Odd:" + obj.count);
            obj.count ++;
            obj.isOdd = false;
        }
    }
}
----------------------------------------

public void run () {
    lock.lock ();
    while (naturalOrder.currentNumber < 20) {
        while (naturalOrder.evenOdd != true) {
            try {
                condition.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        try {
            Thread.sleep (ThreadLocalRandom.current ().nextInt (1000));
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        if (naturalOrder.currentNumber % 2 == 0) {
            System.out.println (naturalOrder.currentNumber);
        }
        naturalOrder.currentNumber ++;
        naturalOrder.evenOdd = false;
        condition.signalAll ();
    }
    lock.unlock ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_22164687_52_60
6017281_23440567_17_26
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (obj.isOdd) {
            System.out.println ("Odd:" + obj.count);
            obj.count ++;
            obj.isOdd = false;
        }
    }
}
----------------------------------------

public void run () {
    int i = type.equals ("odd") ? 1 : 2;
    while (i <= 10) {
        if (type.equals ("odd")) printOdd (i);

        if (type.equals ("even")) printEven (i);

        i = i + 2;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_22164687_52_60
6017281_26446997_51_82
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    while (obj.count < 100) {
        if (obj.isOdd) {
            System.out.println ("Odd:" + obj.count);
            obj.count ++;
            obj.isOdd = false;
        }
    }
}
----------------------------------------

public void run () {
    ReentrantLock prevLock = null;
    int printCounter = index;
    for (int counter = 0;
    printCounter <= 1000; counter ++) {
        int remCounter = counter % lckArray.length;
        int incCounter = lckArray.length - remCounter;
        int indexPostion = index + incCounter;
        int curElementIndex = indexPostion % lckArray.length;
        lckArray [curElementIndex].lock ();
        if (prevLock != null) prevLock.unlock ();

        prevLock = lckArray [curElementIndex];
        if (curElementIndex == 0) {
            System.out.println ("Printed by Thread " + index + " " + printCounter);
            printCounter = printCounter + lckArray.length - 1;
        }
    }
    if (prevLock != null) {
        if (prevLock.isHeldByCurrentThread ()) prevLock.unlock ();

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_23440275_18_43
6017281_23440567_17_26
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    lock.lock ();
    while (naturalOrder.currentNumber < 20) {
        while (naturalOrder.evenOdd != true) {
            try {
                condition.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        try {
            Thread.sleep (ThreadLocalRandom.current ().nextInt (1000));
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        if (naturalOrder.currentNumber % 2 == 0) {
            System.out.println (naturalOrder.currentNumber);
        }
        naturalOrder.currentNumber ++;
        naturalOrder.evenOdd = false;
        condition.signalAll ();
    }
    lock.unlock ();
}
----------------------------------------

public void run () {
    int i = type.equals ("odd") ? 1 : 2;
    while (i <= 10) {
        if (type.equals ("odd")) printOdd (i);

        if (type.equals ("even")) printEven (i);

        i = i + 2;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_23440275_18_43
6017281_26446997_51_82
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    lock.lock ();
    while (naturalOrder.currentNumber < 20) {
        while (naturalOrder.evenOdd != true) {
            try {
                condition.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        try {
            Thread.sleep (ThreadLocalRandom.current ().nextInt (1000));
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        if (naturalOrder.currentNumber % 2 == 0) {
            System.out.println (naturalOrder.currentNumber);
        }
        naturalOrder.currentNumber ++;
        naturalOrder.evenOdd = false;
        condition.signalAll ();
    }
    lock.unlock ();
}
----------------------------------------

public void run () {
    ReentrantLock prevLock = null;
    int printCounter = index;
    for (int counter = 0;
    printCounter <= 1000; counter ++) {
        int remCounter = counter % lckArray.length;
        int incCounter = lckArray.length - remCounter;
        int indexPostion = index + incCounter;
        int curElementIndex = indexPostion % lckArray.length;
        lckArray [curElementIndex].lock ();
        if (prevLock != null) prevLock.unlock ();

        prevLock = lckArray [curElementIndex];
        if (curElementIndex == 0) {
            System.out.println ("Printed by Thread " + index + " " + printCounter);
            printCounter = printCounter + lckArray.length - 1;
        }
    }
    if (prevLock != null) {
        if (prevLock.isHeldByCurrentThread ()) prevLock.unlock ();

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_23440567_17_26
6017281_26446997_51_82
Title: Odd even number printing using thread 
----------------------------------------

public void run () {
    int i = type.equals ("odd") ? 1 : 2;
    while (i <= 10) {
        if (type.equals ("odd")) printOdd (i);

        if (type.equals ("even")) printEven (i);

        i = i + 2;
    }
}
----------------------------------------

public void run () {
    ReentrantLock prevLock = null;
    int printCounter = index;
    for (int counter = 0;
    printCounter <= 1000; counter ++) {
        int remCounter = counter % lckArray.length;
        int incCounter = lckArray.length - remCounter;
        int indexPostion = index + incCounter;
        int curElementIndex = indexPostion % lckArray.length;
        lckArray [curElementIndex].lock ();
        if (prevLock != null) prevLock.unlock ();

        prevLock = lckArray [curElementIndex];
        if (curElementIndex == 0) {
            System.out.println ("Printed by Thread " + index + " " + printCounter);
            printCounter = printCounter + lckArray.length - 1;
        }
    }
    if (prevLock != null) {
        if (prevLock.isHeldByCurrentThread ()) prevLock.unlock ();

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6017281_23440567_28_44
6017281_6017387_1_14
Title: Odd even number printing using thread 
----------------------------------------

private void printOdd (int i) {
    lock.lock ();
    while (! oddTurn) {
        try {
            condition.await ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    System.out.println (type + " " + i);
    oddTurn = false;
    condition.signalAll ();
    lock.unlock ();
}
----------------------------------------

private void printOdd (int i) {
    synchronized (lock) {
        while (! oddTurn) {
            try {
                lock.wait ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
        System.out.println (type + i);
        oddTurn = false;
        lock.notifyAll ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6018602_21409750_13_26
6018602_28506374_17_28
Title: StateListDrawable to switch colorfilters 
----------------------------------------

protected boolean onStateChange (int [] states) {
    boolean isStatePressedInArray = false;
    for (int state : states) {
        if (state == android.R.attr.state_pressed) {
            isStatePressedInArray = true;
        }
    }
    if (isStatePressedInArray) {
        super.setColorFilter (selectionColor, PorterDuff.Mode.MULTIPLY);
    } else {
        super.clearColorFilter ();
    }
    return super.onStateChange (states);
}
----------------------------------------

protected boolean onStateChange (int [] states) {
    if (this.states != null) {
        for (int i = 0;
        i < this.states.length; i ++) {
            if (StateSet.stateSetMatches (this.states [i], states)) {
                super.setColorFilter (this.colors [i], PorterDuff.Mode.MULTIPLY);
                return super.onStateChange (states);
            }
        }
        super.clearColorFilter ();
    }
    return super.onStateChange (states);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6018602_21409750_13_26
6018602_6071813_8_17
Title: StateListDrawable to switch colorfilters 
----------------------------------------

protected boolean onStateChange (int [] states) {
    boolean isStatePressedInArray = false;
    for (int state : states) {
        if (state == android.R.attr.state_pressed) {
            isStatePressedInArray = true;
        }
    }
    if (isStatePressedInArray) {
        super.setColorFilter (selectionColor, PorterDuff.Mode.MULTIPLY);
    } else {
        super.clearColorFilter ();
    }
    return super.onStateChange (states);
}
----------------------------------------

protected boolean onStateChange (int [] states) {
    for (int state : states) {
        if (state == android.R.attr.state_selected) {
            super.setColorFilter (Color.argb (255, 255, 195, 0), PorterDuff.Mode.SRC_ATOP);
        } else {
            super.setColorFilter (Color.GRAY, PorterDuff.Mode.SRC_ATOP);
        }
    }
    return super.onStateChange (states);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6018602_28506374_17_28
6018602_6071813_8_17
Title: StateListDrawable to switch colorfilters 
----------------------------------------

protected boolean onStateChange (int [] states) {
    if (this.states != null) {
        for (int i = 0;
        i < this.states.length; i ++) {
            if (StateSet.stateSetMatches (this.states [i], states)) {
                super.setColorFilter (this.colors [i], PorterDuff.Mode.MULTIPLY);
                return super.onStateChange (states);
            }
        }
        super.clearColorFilter ();
    }
    return super.onStateChange (states);
}
----------------------------------------

protected boolean onStateChange (int [] states) {
    for (int state : states) {
        if (state == android.R.attr.state_selected) {
            super.setColorFilter (Color.argb (255, 255, 195, 0), PorterDuff.Mode.SRC_ATOP);
        } else {
            super.setColorFilter (Color.GRAY, PorterDuff.Mode.SRC_ATOP);
        }
    }
    return super.onStateChange (states);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6021379_6021443_49_64
6021379_6021451_2_22
Title: I need help with an assignment 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int number;
    while ((number = getNextNumber (input)) >= 0) {
        if (number == 0) {
            System.out.println ("Thank you for playing! Good bye!");
            break;
        }
        convertIntegerToWords (number);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    bool bPlay = true;
    while (bPlay) {
        System.out.print (" What is your integer ? ");
        int Number = input.nextInt ();
        if (Number != 0) validateLength (Number);
        else if (Number == 0) {
            System.out.print ("Thank you for playing! " + "Good bye! ");
            bPlay = false;
            break;
        }

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_100_108
60269_61982_289_302
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

public void drop (DropTargetDropEvent e) {
    if (isDropAcceptable (e)) {
        convertTab (dragTabIndex, getTargetTabIndex (e.getLocation ()));
        e.dropComplete (true);
    } else {
        e.dropComplete (false);
    }
    repaint ();
}
----------------------------------------

public void drop (DropTargetDropEvent a_event) {
    if (isDropAcceptable (a_event)) {
        convertTab (getTabTransferData (a_event), getTargetTabIndex (a_event.getLocation ()));
        a_event.dropComplete (true);
    } else {
        a_event.dropComplete (false);
    }
    m_isDrawRect = false;
    repaint ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_109_117
60269_61982_304_329
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

public boolean isDragAcceptable (DropTargetDragEvent e) {
    Transferable t = e.getTransferable ();
    if (t == null) return false;

    DataFlavor [] f = e.getCurrentDataFlavors ();
    if (t.isDataFlavorSupported (f [0]) && dragTabIndex >= 0) {
        return true;
    }
    return false;
}
----------------------------------------

public boolean isDragAcceptable (DropTargetDragEvent e) {
    Transferable t = e.getTransferable ();
    if (t == null) {
        return false;
    }
    DataFlavor [] flavor = e.getCurrentDataFlavors ();
    if (! t.isDataFlavorSupported (flavor [0])) {
        return false;
    }
    TabTransferData data = getTabTransferData (e);
    if (DnDTabbedPane.this == data.getTabbedPane () && data.getTabIndex () >= 0) {
        return true;
    }
    if (DnDTabbedPane.this != data.getTabbedPane ()) {
        if (m_acceptor != null) {
            return m_acceptor.isDropAcceptable (data.getTabbedPane (), data.getTabIndex ());
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_118_126
60269_61982_331_356
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

public boolean isDropAcceptable (DropTargetDropEvent e) {
    Transferable t = e.getTransferable ();
    if (t == null) return false;

    DataFlavor [] f = t.getTransferDataFlavors ();
    if (t.isDataFlavorSupported (f [0]) && dragTabIndex >= 0) {
        return true;
    }
    return false;
}
----------------------------------------

public boolean isDropAcceptable (DropTargetDropEvent e) {
    Transferable t = e.getTransferable ();
    if (t == null) {
        return false;
    }
    DataFlavor [] flavor = e.getCurrentDataFlavors ();
    if (! t.isDataFlavorSupported (flavor [0])) {
        return false;
    }
    TabTransferData data = getTabTransferData (e);
    if (DnDTabbedPane.this == data.getTabbedPane () && data.getTabIndex () >= 0) {
        return true;
    }
    if (DnDTabbedPane.this != data.getTabbedPane ()) {
        if (m_acceptor != null) {
            return m_acceptor.isDropAcceptable (data.getTabbedPane (), data.getTabIndex ());
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_11_78
60269_61982_29_127
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

public DnDTabbedPane () {
    super ();
    final DragSourceListener dsl = new DragSourceListener () {
        public void dragEnter (DragSourceDragEvent e) {
            e.getDragSourceContext ().setCursor (DragSource.DefaultMoveDrop);
        } public void dragExit (DragSourceEvent e) {
            e.getDragSourceContext ().setCursor (DragSource.DefaultMoveNoDrop);
            lineRect.setRect (0, 0, 0, 0);
            glassPane.setPoint (new Point (- 1000, - 1000));
            glassPane.repaint ();
        } public void dragOver (DragSourceDragEvent e) {
            Point tabPt = e.getLocation ();
            SwingUtilities.convertPointFromScreen (tabPt, DnDTabbedPane.this);
            Point glassPt = e.getLocation ();
            SwingUtilities.convertPointFromScreen (glassPt, glassPane);
            int targetIdx = getTargetTabIndex (glassPt);
            if (getTabAreaBound ().contains (tabPt) && targetIdx >= 0 && targetIdx != dragTabIndex && targetIdx != dragTabIndex + 1) {
                e.getDragSourceContext ().setCursor (DragSource.DefaultMoveDrop);
            } else {
                e.getDragSourceContext ().setCursor (DragSource.DefaultMoveNoDrop);
            }
        } public void dragDropEnd (DragSourceDropEvent e) {
            lineRect.setRect (0, 0, 0, 0);
            dragTabIndex = - 1;
            if (hasGhost ()) {
                glassPane.setVisible (false);
                glassPane.setImage (null);
            }
        } public void dropActionChanged (DragSourceDragEvent e) {
        }}

    ;
    final Transferable t = new Transferable () {
        private final DataFlavor FLAVOR = new DataFlavor (DataFlavor.javaJVMLocalObjectMimeType, NAME);
        public Object getTransferData (DataFlavor flavor) {
            return DnDTabbedPane.this;
        } public DataFlavor [] getTransferDataFlavors () {
            DataFlavor [] f = new DataFlavor [1];
            f [0] = this.FLAVOR;
            return f;
        } public boolean isDataFlavorSupported (DataFlavor flavor) {
            return flavor.getHumanPresentableName ().equals (NAME);
        }}

    ;
    final DragGestureListener dgl = new DragGestureListener () {
        public void dragGestureRecognized (DragGestureEvent e) {
            Point tabPt = e.getDragOrigin ();
            dragTabIndex = indexAtLocation (tabPt.x, tabPt.y);
            if (dragTabIndex < 0) return;

            initGlassPane (e.getComponent (), e.getDragOrigin ());
            try {
                e.startDrag (DragSource.DefaultMoveDrop, t, dsl);
            } catch (InvalidDnDOperationException idoe) {
                idoe.printStackTrace ();
            }
        }}

    new DropTarget (glassPane, DnDConstants.ACTION_COPY_OR_MOVE, new CDropTargetListener (), true);
    new DragSource ().createDefaultDragGestureRecognizer (this, DnDConstants.ACTION_COPY_OR_MOVE, dgl);
}
----------------------------------------

public DnDTabbedPane () {
    super ();
    final DragSourceListener dsl = new DragSourceListener () {
        public void dragEnter (DragSourceDragEvent e) {
            e.getDragSourceContext ().setCursor (DragSource.DefaultMoveDrop);
        } public void dragExit (DragSourceEvent e) {
            e.getDragSourceContext ().setCursor (DragSource.DefaultMoveNoDrop);
            m_lineRect.setRect (0, 0, 0, 0);
            m_isDrawRect = false;
            s_glassPane.setPoint (new Point (- 1000, - 1000));
            s_glassPane.repaint ();
        } public void dragOver (DragSourceDragEvent e) {
            TabTransferData data = getTabTransferData (e);
            if (data == null) {
                e.getDragSourceContext ().setCursor (DragSource.DefaultMoveNoDrop);
                return;
            }
            e.getDragSourceContext ().setCursor (DragSource.DefaultMoveDrop);
        } public void dragDropEnd (DragSourceDropEvent e) {
            m_isDrawRect = false;
            m_lineRect.setRect (0, 0, 0, 0);
            if (hasGhost ()) {
                s_glassPane.setVisible (false);
                s_glassPane.setImage (null);
            }
        } public void dropActionChanged (DragSourceDragEvent e) {
        }}

    ;
    final DragGestureListener dgl = new DragGestureListener () {
        public void dragGestureRecognized (DragGestureEvent e) {
            Point tabPt = e.getDragOrigin ();
            int dragTabIndex = indexAtLocation (tabPt.x, tabPt.y);
            if (dragTabIndex < 0) {
                return;
            }
            initGlassPane (e.getComponent (), e.getDragOrigin (), dragTabIndex);
            try {
                e.startDrag (DragSource.DefaultMoveDrop, new TabTransferable (DnDTabbedPane.this, dragTabIndex), dsl);
            } catch (InvalidDnDOperationException idoe) {
                idoe.printStackTrace ();
            }
        }}

    new DropTarget (this, DnDConstants.ACTION_COPY_OR_MOVE, new CDropTargetListener (), true);
    new DragSource ().createDefaultDragGestureRecognizer (this, DnDConstants.ACTION_COPY_OR_MOVE, dgl);
    m_acceptor = new TabAcceptor () {
        public boolean isDropAcceptable (DnDTabbedPane a_component, int a_index) {
            return true;
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_136_149
60269_61982_374_406
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

private int getTargetTabIndex (Point glassPt) {
    Point tabPt = SwingUtilities.convertPoint (glassPane, glassPt, DnDTabbedPane.this);
    boolean isTB = getTabPlacement () == JTabbedPane.TOP || getTabPlacement () == JTabbedPane.BOTTOM;
    for (int i = 0;
    i < getTabCount (); i ++) {
        Rectangle r = getBoundsAt (i);
        if (isTB) r.setRect (r.x - r.width / 2, r.y, r.width, r.height);
        else r.setRect (r.x, r.y - r.height / 2, r.width, r.height);

        if (r.contains (tabPt)) return i;

    }
    Rectangle r = getBoundsAt (getTabCount () - 1);
    if (isTB) r.setRect (r.x + r.width / 2, r.y, r.width, r.height);
    else r.setRect (r.x, r.y + r.height / 2, r.width, r.height);

    return r.contains (tabPt) ? getTabCount () : - 1;
}
----------------------------------------

private int getTargetTabIndex (Point a_point) {
    boolean isTopOrBottom = getTabPlacement () == JTabbedPane.TOP || getTabPlacement () == JTabbedPane.BOTTOM;
    if (getTabCount () == 0) {
        return 0;
    }
    for (int i = 0;
    i < getTabCount (); i ++) {
        Rectangle r = getBoundsAt (i);
        if (isTopOrBottom) {
            r.setRect (r.x - r.width / 2, r.y, r.width, r.height);
        } else {
            r.setRect (r.x, r.y - r.height / 2, r.width, r.height);
        }
        if (r.contains (a_point)) {
            return i;
        }
    }
    Rectangle r = getBoundsAt (getTabCount () - 1);
    if (isTopOrBottom) {
        int x = r.x + r.width / 2;
        r.setRect (x, r.y, getWidth () - x, r.height);
    } else {
        int y = r.y + r.height / 2;
        r.setRect (r.x, y, r.width, getHeight () - y);
    }
    return r.contains (a_point) ? getTabCount () : - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_150_173
60269_61982_408_457
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

private void convertTab (int prev, int next) {
    if (next < 0 || prev == next) {
        return;
    }
    Component cmp = getComponentAt (prev);
    String str = getTitleAt (prev);
    if (next == getTabCount ()) {
        remove (prev);
        addTab (str, cmp);
        setSelectedIndex (getTabCount () - 1);
    } else if (prev > next) {
        remove (prev);
        insertTab (str, null, cmp, null, next);
        setSelectedIndex (next);
    } else {
        remove (prev);
        insertTab (str, null, cmp, null, next - 1);
        setSelectedIndex (next - 1);
    }

}
----------------------------------------

private void convertTab (TabTransferData a_data, int a_targetIndex) {
    DnDTabbedPane source = a_data.getTabbedPane ();
    int sourceIndex = a_data.getTabIndex ();
    if (sourceIndex < 0) {
        return;
    }
    Component cmp = source.getComponentAt (sourceIndex);
    String str = source.getTitleAt (sourceIndex);
    if (this != source) {
        source.remove (sourceIndex);
        if (a_targetIndex == getTabCount ()) {
            addTab (str, cmp);
        } else {
            if (a_targetIndex < 0) {
                a_targetIndex = 0;
            }
            insertTab (str, null, cmp, null, a_targetIndex);
        }
        setSelectedComponent (cmp);
        return;
    }
    if (a_targetIndex < 0 || sourceIndex == a_targetIndex) {
        return;
    }
    if (a_targetIndex == getTabCount ()) {
        source.remove (sourceIndex);
        addTab (str, cmp);
        setSelectedIndex (getTabCount () - 1);
    } else if (sourceIndex > a_targetIndex) {
        source.remove (sourceIndex);
        insertTab (str, null, cmp, null, a_targetIndex);
        setSelectedIndex (a_targetIndex);
    } else {
        source.remove (sourceIndex);
        insertTab (str, null, cmp, null, a_targetIndex - 1);
        setSelectedIndex (a_targetIndex - 1);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_150_173
60269_8610017_1_52
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

private void convertTab (int prev, int next) {
    if (next < 0 || prev == next) {
        return;
    }
    Component cmp = getComponentAt (prev);
    String str = getTitleAt (prev);
    if (next == getTabCount ()) {
        remove (prev);
        addTab (str, cmp);
        setSelectedIndex (getTabCount () - 1);
    } else if (prev > next) {
        remove (prev);
        insertTab (str, null, cmp, null, next);
        setSelectedIndex (next);
    } else {
        remove (prev);
        insertTab (str, null, cmp, null, next - 1);
        setSelectedIndex (next - 1);
    }

}
----------------------------------------

private void convertTab (TabTransferData a_data, int a_targetIndex) {
    DnDTabbedPane source = a_data.getTabbedPane ();
    System.out.println ("this=source? " + (this == source));
    int sourceIndex = a_data.getTabIndex ();
    if (sourceIndex < 0) {
        return;
    }
    Component cmp = source.getComponentAt (sourceIndex);
    String str = source.getTitleAt (sourceIndex);
    Component tcmp = source.getTabComponentAt (sourceIndex);
    if (this != source) {
        source.remove (sourceIndex);
        if (a_targetIndex == getTabCount ()) {
            addTab (str, cmp);
            setTabComponentAt (getTabCount () - 1, tcmp);
        } else {
            if (a_targetIndex < 0) {
                a_targetIndex = 0;
            }
            insertTab (str, null, cmp, null, a_targetIndex);
            setTabComponentAt (a_targetIndex, tcmp);
        }
        setSelectedComponent (cmp);
        return;
    }
    if (a_targetIndex < 0 || sourceIndex == a_targetIndex) {
        return;
    }
    if (a_targetIndex == getTabCount ()) {
        source.remove (sourceIndex);
        addTab (str, cmp);
        setTabComponentAt (getTabCount () - 1, tcmp);
        setSelectedIndex (getTabCount () - 1);
    } else if (sourceIndex > a_targetIndex) {
        source.remove (sourceIndex);
        insertTab (str, null, cmp, null, a_targetIndex);
        setTabComponentAt (a_targetIndex, tcmp);
        setSelectedIndex (a_targetIndex);
    } else {
        source.remove (sourceIndex);
        insertTab (str, null, cmp, null, a_targetIndex - 1);
        setTabComponentAt (a_targetIndex - 1, tcmp);
        setSelectedIndex (a_targetIndex - 1);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_175_188
60269_61982_459_490
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

private void initTargetLeftRightLine (int next) {
    if (next < 0 || dragTabIndex == next || next - dragTabIndex == 1) {
        lineRect.setRect (0, 0, 0, 0);
    } else if (next == getTabCount ()) {
        Rectangle rect = getBoundsAt (getTabCount () - 1);
        lineRect.setRect (rect.x + rect.width - LINEWIDTH / 2, rect.y, LINEWIDTH, rect.height);
    } else if (next == 0) {
        Rectangle rect = getBoundsAt (0);
        lineRect.setRect (- LINEWIDTH / 2, rect.y, LINEWIDTH, rect.height);
    } else {
        Rectangle rect = getBoundsAt (next - 1);
        lineRect.setRect (rect.x + rect.width - LINEWIDTH / 2, rect.y, LINEWIDTH, rect.height);
    }

}
----------------------------------------

private void initTargetLeftRightLine (int next, TabTransferData a_data) {
    if (next < 0) {
        m_lineRect.setRect (0, 0, 0, 0);
        m_isDrawRect = false;
        return;
    }
    if ((a_data.getTabbedPane () == this) && (a_data.getTabIndex () == next || next - a_data.getTabIndex () == 1)) {
        m_lineRect.setRect (0, 0, 0, 0);
        m_isDrawRect = false;
    } else if (getTabCount () == 0) {
        m_lineRect.setRect (0, 0, 0, 0);
        m_isDrawRect = false;
        return;
    } else if (next == 0) {
        Rectangle rect = getBoundsAt (0);
        m_lineRect.setRect (- LINEWIDTH / 2, rect.y, LINEWIDTH, rect.height);
        m_isDrawRect = true;
    } else if (next == getTabCount ()) {
        Rectangle rect = getBoundsAt (getTabCount () - 1);
        m_lineRect.setRect (rect.x + rect.width - LINEWIDTH / 2, rect.y, LINEWIDTH, rect.height);
        m_isDrawRect = true;
    } else {
        Rectangle rect = getBoundsAt (next - 1);
        m_lineRect.setRect (rect.x + rect.width - LINEWIDTH / 2, rect.y, LINEWIDTH, rect.height);
        m_isDrawRect = true;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_189_202
60269_61982_492_523
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

private void initTargetTopBottomLine (int next) {
    if (next < 0 || dragTabIndex == next || next - dragTabIndex == 1) {
        lineRect.setRect (0, 0, 0, 0);
    } else if (next == getTabCount ()) {
        Rectangle rect = getBoundsAt (getTabCount () - 1);
        lineRect.setRect (rect.x, rect.y + rect.height - LINEWIDTH / 2, rect.width, LINEWIDTH);
    } else if (next == 0) {
        Rectangle rect = getBoundsAt (0);
        lineRect.setRect (rect.x, - LINEWIDTH / 2, rect.width, LINEWIDTH);
    } else {
        Rectangle rect = getBoundsAt (next - 1);
        lineRect.setRect (rect.x, rect.y + rect.height - LINEWIDTH / 2, rect.width, LINEWIDTH);
    }

}
----------------------------------------

private void initTargetTopBottomLine (int next, TabTransferData a_data) {
    if (next < 0) {
        m_lineRect.setRect (0, 0, 0, 0);
        m_isDrawRect = false;
        return;
    }
    if ((a_data.getTabbedPane () == this) && (a_data.getTabIndex () == next || next - a_data.getTabIndex () == 1)) {
        m_lineRect.setRect (0, 0, 0, 0);
        m_isDrawRect = false;
    } else if (getTabCount () == 0) {
        m_lineRect.setRect (0, 0, 0, 0);
        m_isDrawRect = false;
        return;
    } else if (next == getTabCount ()) {
        Rectangle rect = getBoundsAt (getTabCount () - 1);
        m_lineRect.setRect (rect.x, rect.y + rect.height - LINEWIDTH / 2, rect.width, LINEWIDTH);
        m_isDrawRect = true;
    } else if (next == 0) {
        Rectangle rect = getBoundsAt (0);
        m_lineRect.setRect (rect.x, - LINEWIDTH / 2, rect.width, LINEWIDTH);
        m_isDrawRect = true;
    } else {
        Rectangle rect = getBoundsAt (next - 1);
        m_lineRect.setRect (rect.x, rect.y + rect.height - LINEWIDTH / 2, rect.width, LINEWIDTH);
        m_isDrawRect = true;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_23_37
60269_60279_87_98
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

public void dragOver (DragSourceDragEvent e) {
    Point tabPt = e.getLocation ();
    SwingUtilities.convertPointFromScreen (tabPt, DnDTabbedPane.this);
    Point glassPt = e.getLocation ();
    SwingUtilities.convertPointFromScreen (glassPt, glassPane);
    int targetIdx = getTargetTabIndex (glassPt);
    if (getTabAreaBound ().contains (tabPt) && targetIdx >= 0 && targetIdx != dragTabIndex && targetIdx != dragTabIndex + 1) {
        e.getDragSourceContext ().setCursor (DragSource.DefaultMoveDrop);
    } else {
        e.getDragSourceContext ().setCursor (DragSource.DefaultMoveNoDrop);
    }
}
----------------------------------------

public void dragOver (final DropTargetDragEvent e) {
    if (getTabPlacement () == JTabbedPane.TOP || getTabPlacement () == JTabbedPane.BOTTOM) {
        initTargetLeftRightLine (getTargetTabIndex (e.getLocation ()));
    } else {
        initTargetTopBottomLine (getTargetTabIndex (e.getLocation ()));
    }
    repaint ();
    if (hasGhost ()) {
        glassPane.setPoint (e.getLocation ());
        glassPane.repaint ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_23_37
60269_61982_272_287
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

public void dragOver (DragSourceDragEvent e) {
    Point tabPt = e.getLocation ();
    SwingUtilities.convertPointFromScreen (tabPt, DnDTabbedPane.this);
    Point glassPt = e.getLocation ();
    SwingUtilities.convertPointFromScreen (glassPt, glassPane);
    int targetIdx = getTargetTabIndex (glassPt);
    if (getTabAreaBound ().contains (tabPt) && targetIdx >= 0 && targetIdx != dragTabIndex && targetIdx != dragTabIndex + 1) {
        e.getDragSourceContext ().setCursor (DragSource.DefaultMoveDrop);
    } else {
        e.getDragSourceContext ().setCursor (DragSource.DefaultMoveNoDrop);
    }
}
----------------------------------------

public void dragOver (final DropTargetDragEvent e) {
    TabTransferData data = getTabTransferData (e);
    if (getTabPlacement () == JTabbedPane.TOP || getTabPlacement () == JTabbedPane.BOTTOM) {
        initTargetLeftRightLine (getTargetTabIndex (e.getLocation ()), data);
    } else {
        initTargetTopBottomLine (getTargetTabIndex (e.getLocation ()), data);
    }
    repaint ();
    if (hasGhost ()) {
        s_glassPane.setPoint (buildGhostLocation (e.getLocation ()));
        s_glassPane.repaint ();
    }
}
----------------------------------------
