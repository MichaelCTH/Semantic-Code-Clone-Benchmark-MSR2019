$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_63_73
60269_61982_98_114
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

public void dragGestureRecognized (DragGestureEvent e) {
    Point tabPt = e.getDragOrigin ();
    dragTabIndex = indexAtLocation (tabPt.x, tabPt.y);
    if (dragTabIndex < 0) return;

    initGlassPane (e.getComponent (), e.getDragOrigin ());
    try {
        e.startDrag (DragSource.DefaultMoveDrop, t, dsl);
    } catch (InvalidDnDOperationException idoe) {
        idoe.printStackTrace ();
    }
}
----------------------------------------

public void dragGestureRecognized (DragGestureEvent e) {
    Point tabPt = e.getDragOrigin ();
    int dragTabIndex = indexAtLocation (tabPt.x, tabPt.y);
    if (dragTabIndex < 0) {
        return;
    }
    initGlassPane (e.getComponent (), e.getDragOrigin (), dragTabIndex);
    try {
        e.startDrag (DragSource.DefaultMoveDrop, new TabTransferable (DnDTabbedPane.this, dragTabIndex), dsl);
    } catch (InvalidDnDOperationException idoe) {
        idoe.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_60279_87_98
60269_61982_272_287
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

public void dragOver (final DropTargetDragEvent e) {
    if (getTabPlacement () == JTabbedPane.TOP || getTabPlacement () == JTabbedPane.BOTTOM) {
        initTargetLeftRightLine (getTargetTabIndex (e.getLocation ()));
    } else {
        initTargetTopBottomLine (getTargetTabIndex (e.getLocation ()));
    }
    repaint ();
    if (hasGhost ()) {
        glassPane.setPoint (e.getLocation ());
        glassPane.repaint ();
    }
}
----------------------------------------

public void dragOver (final DropTargetDragEvent e) {
    TabTransferData data = getTabTransferData (e);
    if (getTabPlacement () == JTabbedPane.TOP || getTabPlacement () == JTabbedPane.BOTTOM) {
        initTargetLeftRightLine (getTargetTabIndex (e.getLocation ()), data);
    } else {
        initTargetTopBottomLine (getTargetTabIndex (e.getLocation ()), data);
    }
    repaint ();
    if (hasGhost ()) {
        s_glassPane.setPoint (buildGhostLocation (e.getLocation ()));
        s_glassPane.repaint ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_61982_137_146
60269_61982_148_157
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

private TabTransferData getTabTransferData (DropTargetDropEvent a_event) {
    try {
        TabTransferData data = (TabTransferData) a_event.getTransferable ().getTransferData (FLAVOR);
        return data;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------

private TabTransferData getTabTransferData (DropTargetDragEvent a_event) {
    try {
        TabTransferData data = (TabTransferData) a_event.getTransferable ().getTransferData (FLAVOR);
        return data;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_61982_137_146
60269_61982_159_169
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

private TabTransferData getTabTransferData (DropTargetDropEvent a_event) {
    try {
        TabTransferData data = (TabTransferData) a_event.getTransferable ().getTransferData (FLAVOR);
        return data;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------

private TabTransferData getTabTransferData (DragSourceDragEvent a_event) {
    try {
        TabTransferData data = (TabTransferData) a_event.getDragSourceContext ().getTransferable ().getTransferData (FLAVOR);
        return data;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60269_61982_148_157
60269_61982_159_169
Title: How to implement draggable tab using Java Swing? 
----------------------------------------

private TabTransferData getTabTransferData (DropTargetDragEvent a_event) {
    try {
        TabTransferData data = (TabTransferData) a_event.getTransferable ().getTransferData (FLAVOR);
        return data;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------

private TabTransferData getTabTransferData (DragSourceDragEvent a_event) {
    try {
        TabTransferData data = (TabTransferData) a_event.getDragSourceContext ().getTransferable ().getTransferData (FLAVOR);
        return data;
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6029880_15391382_9_36
6029880_6029915_8_19
Title: Copy file (image) from CacheDir to SD Card 
----------------------------------------

public static boolean copyFile (String sourceLocation, String destLocation) {
    try {
        File sd = Environment.getExternalStorageDirectory ();
        if (sd.canWrite ()) {
            File source = new File (sourceLocation);
            File dest = new File (destLocation);
            if (! dest.exists ()) {
                dest.createNewFile ();
            }
            if (source.exists ()) {
                InputStream src = new FileInputStream (source);
                OutputStream dst = new FileOutputStream (dest);
                byte [] buf = new byte [1024];
                int len;
                while ((len = src.read (buf)) > 0) {
                    dst.write (buf, 0, len);
                }
                src.close ();
                dst.close ();
            }
        }
        return true;
    } catch (Exception ex) {
        ex.printStackTrace ();
        return false;
    }
}
----------------------------------------

void copyFile (File src, File dst) throws IOException {
    FileChannel inChannel = new FileInputStream (src).getChannel ();
    FileChannel outChannel = new FileOutputStream (dst).getChannel ();
    try {
        inChannel.transferTo (0, inChannel.size (), outChannel);
    } finally {
        if (inChannel != null) inChannel.close ();

        if (outChannel != null) outChannel.close ();

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
60302_1570269_8_16
60302_6303744_4_13
Title: Starting a process with inherited stdin/stdout/stderr in Java 6 
----------------------------------------

public void run () {
    try {
        byte [] buffer = new byte [1024];
        for (int n = 0;
        n != - 1; n = src.read (buffer)) {
            dest.write (buffer, 0, n);
        }
    } catch (IOException e) {
    }
}
----------------------------------------

public void run () {
    try {
        int ret = - 1;
        while ((ret = System.in.read ()) != - 1) {
            dest.write (ret);
            dest.flush ();
        }
    } catch (IOException e) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6040962_30082111_114_127
6040962_30082111_87_100
Title: Wait for cancel() on FutureTask 
----------------------------------------

public T get (long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, CancellationException, TimeoutException {
    try {
        return super.get (timeout, unit);
    } catch (CancellationException e) {
        semaphore.acquire ();
        semaphore.release ();
        throw e;
    }
}
----------------------------------------

public T get () throws InterruptedException, ExecutionException, CancellationException {
    try {
        return super.get ();
    } catch (CancellationException e) {
        semaphore.acquire ();
        semaphore.release ();
        throw e;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6049349_6049480_1_15
6049349_6049486_1_14
Title: A more efficient way to code this program 
----------------------------------------

public static < T > List < T > interleave (List < T > first, List < T > second) {
    Iterator < T > it = second.iterator ();
    int i = 1;
    while (it.hasNext ()) {
        T val = it.next ();
        if (first.size () >= i) first.add (i, val);
        else first.add (val);

        i += 2;
    }
    return first;
}
----------------------------------------

public static ArrayList < Integer > interleave (ArrayList < Integer > a1, ArrayList < Integer > a2) {
    Iterator < Integer > it1 = a1.iterator ();
    Iterator < Integer > it2 = a2.iterator ();
    ArrayList < Integer > output = new ArrayList < Integer > ();
    while (it1.hasNext () || it2.hasNext ()) {
        if (it1.hasNext ()) {
            output.add (it1.next ());
        }
        if (it2.hasNext ()) {
            output.add (it2.next ());
        }
    }
    return output;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6049349_6049480_1_15
6049349_6049620_1_16
Title: A more efficient way to code this program 
----------------------------------------

public static < T > List < T > interleave (List < T > first, List < T > second) {
    Iterator < T > it = second.iterator ();
    int i = 1;
    while (it.hasNext ()) {
        T val = it.next ();
        if (first.size () >= i) first.add (i, val);
        else first.add (val);

        i += 2;
    }
    return first;
}
----------------------------------------

public static < T > List < T > interleave (List < T > a1, List < T > a2) {
    List < T > list = new ArrayList < T > (a1.size () + a2.size ());
    Iterator < T > it1 = a1.iterator ();
    Iterator < T > it2 = a2.iterator ();
    while (it1.hasNext () || it2.hasNext ()) {
        if (it1.hasNext ()) {
            list.add (it1.next ());
        }
        if (it2.hasNext ()) {
            list.add (it2.next ());
        }
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6049349_6049486_1_14
6049349_6049620_1_16
Title: A more efficient way to code this program 
----------------------------------------

public static ArrayList < Integer > interleave (ArrayList < Integer > a1, ArrayList < Integer > a2) {
    Iterator < Integer > it1 = a1.iterator ();
    Iterator < Integer > it2 = a2.iterator ();
    ArrayList < Integer > output = new ArrayList < Integer > ();
    while (it1.hasNext () || it2.hasNext ()) {
        if (it1.hasNext ()) {
            output.add (it1.next ());
        }
        if (it2.hasNext ()) {
            output.add (it2.next ());
        }
    }
    return output;
}
----------------------------------------

public static < T > List < T > interleave (List < T > a1, List < T > a2) {
    List < T > list = new ArrayList < T > (a1.size () + a2.size ());
    Iterator < T > it1 = a1.iterator ();
    Iterator < T > it2 = a2.iterator ();
    while (it1.hasNext () || it2.hasNext ()) {
        if (it1.hasNext ()) {
            list.add (it1.next ());
        }
        if (it2.hasNext ()) {
            list.add (it2.next ());
        }
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6050407_6353398_31_66
6050407_6353398_77_113
Title: Grizzly + Jersey Listening ONLY on Localhost 
----------------------------------------

public static SelectorThread create (URI u, Class < ? extends Servlet > c, Map < String, String > initParams, boolean localHostOnly) throws IOException {
    if (u == null) throw new IllegalArgumentException ("The URI must not be null");

    ServletAdapter adapter = new ServletAdapter ();
    if (initParams == null) {
        adapter.addInitParameter (ClasspathResourceConfig.PROPERTY_CLASSPATH, System.getProperty ("java.class.path").replace (File.pathSeparatorChar, ';'));
    } else {
        for (Map.Entry < String, String > e : initParams.entrySet ()) {
            adapter.addInitParameter (e.getKey (), e.getValue ());
        }
    }
    adapter.setServletInstance (getInstance (c));
    String path = u.getPath ();
    if (path == null) throw new IllegalArgumentException ("The URI path, of the URI " + u + ", must be non-null");
    else if (path.length () == 0) throw new IllegalArgumentException ("The URI path, of the URI " + u + ", must be present");
    else if (path.charAt (0) != '/') throw new IllegalArgumentException ("The URI path, of the URI " + u + ". must start with a '/'");

    if (path.length () > 1) {
        if (path.endsWith ("/")) path = path.substring (0, path.length () - 1);

        adapter.setContextPath (path);
    }
    return create (u, adapter, localHostOnly);
}
----------------------------------------

public static SelectorThread create (URI u, Adapter adapter, boolean localHostOnly) throws IOException, IllegalArgumentException {
    if (u == null) throw new IllegalArgumentException ("The URI must not be null");

    final String scheme = u.getScheme ();
    if (! scheme.equalsIgnoreCase ("http")) throw new IllegalArgumentException ("The URI scheme, of the URI " + u + ", must be equal (ignoring case) to 'http'");

    if (adapter instanceof GrizzlyAdapter) {
        GrizzlyAdapter ga = (GrizzlyAdapter) adapter;
        ga.setResourcesContextPath (u.getRawPath ());
    }
    final SelectorThread selectorThread = new SelectorThread ();
    selectorThread.setAlgorithmClassName (StaticStreamAlgorithm.class.getName ());
    final int port = (u.getPort () == - 1) ? 80 : u.getPort ();
    selectorThread.setPort (port);
    if (localHostOnly) {
        selectorThread.setAddress (InetAddress.getByName ("localhost"));
    }
    selectorThread.setAdapter (adapter);
    try {
        selectorThread.listen ();
    } catch (InstantiationException e) {
        IOException _e = new IOException ();
        _e.initCause (e);
        throw _e;
    }
    return selectorThread;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6061049_6061128_1_18
6061049_6061186_1_15
Title: Can I pass a Method as parameter of another method in java? 
----------------------------------------

private void MeasureExecutionTime (Method m, Object target, Object args) throws IllegalArgumentException, IllegalAccessException, InvocationTargetException {
    long startTime = System.nanoTime ();
    long endTime;
    try {
        m.invoke (target, args);
    } finally {
        endTime = System.nanoTime ();
    }
    long elapsedTime = endTime - startTime;
    System.out.println ("This takes " + elapsedTime + " ns.");
}
----------------------------------------

private void MeasureExecutionTime (Method m) {
    startTime = System.nanoTime ();
    try {
        m.invoke (classObj, args);
    } finally {
        int endTime = System.nanoTime ();
    }
    elapsedTime = endTime - startTime;
    System.out.println ("This takes " + elapsedTime + " ns.");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6067673_18368345_1_11
6067673_6223859_1_27
Title: "URLDecoder: Illegal hex characters in escape (%) pattern - For input string: ""</""" 
----------------------------------------

public static String replacer (StringBuffer outBuffer) {
    String data = outBuffer.toString ();
    try {
        data = data.replaceAll ("%(?![0-9a-fA-F]{2})", "%25");
        data = data.replaceAll ("\\+", "%2B");
        data = URLDecoder.decode (data, "utf-8");
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return data;
}
----------------------------------------

public static String replacer (StringBuffer outBuffer) {
    String data = outBuffer.toString ();
    try {
        StringBuffer tempBuffer = new StringBuffer ();
        int incrementor = 0;
        int dataLength = data.length ();
        while (incrementor < dataLength) {
            char charecterAt = data.charAt (incrementor);
            if (charecterAt == '%') {
                tempBuffer.append ("<percentage>");
            } else if (charecterAt == '+') {
                tempBuffer.append ("<plus>");
            } else {
                tempBuffer.append (charecterAt);
            }

            incrementor ++;
        }
        data = tempBuffer.toString ();
        data = URLDecoder.decode (data, "utf-8");
        data = data.replaceAll ("<percentage>", "%");
        data = data.replaceAll ("<plus>", "+");
    } catch (Exception e) {
        e.printStackTrace ();
    }
    return data;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6072153_6072424_1_17
6072153_6072481_1_13
Title: Java String Memory Leak 
----------------------------------------

public static void read (BufferedReader br) throws Exception {
    long length = 0;
    StringBuilder sb = new StringBuilder ();
    while (true) {
        String s = br.readLine ();
        if (s == null) {
            break;
        }
        sb.append (s).append ("abcd");
        length += s.length ();
    }
    System.out.println ("Read: " + (length / 1024 / 1024) + " MB");
}
----------------------------------------

public static void read (BufferedReader br) throws Exception {
    long length = 0;
    StringBuilder sb = new StringBuilder (sb);
    while (true) {
        String ss = br.readLine ();
        if (ss == null) {
            break;
        }
        sb.append (ss);
        length += ss.length ();
    }
    System.out.println ("Read: " + (length / 1024 / 1024) + " MB");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6091531_6091597_47_59
6091531_6092439_10_50
Title: How to get the x and y of a program window in Java? 
----------------------------------------

public static void main (String [] args) {
    String windowName = "Document - WordPad";
    int [] rect;
    try {
        rect = GetWindowRect.getRect (windowName);
        System.out.printf ("The corner locations for the window \"%s\" are %s", windowName, Arrays.toString (rect));
    } catch (GetWindowRect.WindowNotFoundException e) {
        e.printStackTrace ();
    } catch (GetWindowRect.GetWindowRectException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    Robot robot = new Robot ();
    final Dimension screenSize = Toolkit.getDefaultToolkit ().getScreenSize ();
    final BufferedImage screen = robot.createScreenCapture (new Rectangle (screenSize));
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            JLabel screenLabel = new JLabel (new ImageIcon (screen));
            JScrollPane screenScroll = new JScrollPane (screenLabel);
            screenScroll.setPreferredSize (new Dimension ((int) (screenSize.getWidth () / 2), (int) (screenSize.getHeight () / 2)));
            final Point pointOfInterest = new Point ();
            JPanel panel = new JPanel (new BorderLayout ());
            panel.add (screenScroll, BorderLayout.CENTER);
            final JLabel pointLabel = new JLabel ("Click on any point in the screen shot!");
            panel.add (pointLabel, BorderLayout.SOUTH);
            screenLabel.addMouseListener (new MouseAdapter () {
                public void mouseClicked (MouseEvent me) {
                    pointOfInterest.setLocation (me.getPoint ());
                    pointLabel.setText ("Point: " + pointOfInterest.getX () + "x" + pointOfInterest.getY ());
                }}

            );
            JOptionPane.showMessageDialog (null, panel);
            System.out.println ("Point of interest: " + pointOfInterest);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6091736_6091748_1_23
6091736_6091755_1_14
Title: Java Text Input: How to ignore lines starting with certain characters in them? 
----------------------------------------

public String [] OpenFile () throws IOException {
    FileReader reader = new FileReader (path);
    BufferedReader textReader = new BufferedReader (reader);
    int numberOfLines = readLines ();
    String [] textData = new String [numberOfLines];
    int BufferIndex = 0;
    String line;
    while ((line = textReader.readLine ()) != null) {
        if (line.trim ().startsWith ("//")) {
        } else {
            textData [BufferIndex] = textReader.readLine ();
            BufferIndex = BufferIndex + 1;
        }
    }
    textReader.close ();
    return textData;
}
----------------------------------------

public String [] OpenFile () throws IOException {
    FileReader reader = new FileReader (path);
    BufferedReader textReader = new BufferedReader (reader);
    List < String > textData = new LinkedList < String > ();
    String line;
    while ((line = textReader.readLine ()) != null) {
        if (! line.contains ("//")) textData.add (line);

    }
    textReader.close ();
    return textData.toArray (new String [textData.size ()]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6102003_5_40
6101789_6103075_15_49
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

public static void main (String [] args) {
    int [] lengths = new int [] {10000, 50000, 125000, 250000};
    int [] loops = new int [] {1000, 5000, 10000, 20000};
    for (int length : lengths) {
        for (int loop : loops) {
            Object [] list1 = new Object [length];
            Object [] list2 = new Object [length];
            for (int k = 0;
            k < 100; k ++) {
                System.arraycopy (list1, 0, list2, 0, list1.length);
            }
            int [] len = new int [loop];
            int [] ofs = new int [loop];
            Random rnd = new Random ();
            for (int k = 0;
            k < loop; k ++) {
                len [k] = rnd.nextInt (length);
                ofs [k] = rnd.nextInt (length - len [k]);
            }
            long n = System.nanoTime ();
            for (int k = 0;
            k < loop; k ++) {
                System.arraycopy (list1, ofs [k], list2, ofs [k], len [k]);
            }
            n = System.nanoTime () - n;
            System.out.print ("length: " + length);
            System.out.print ("\tloop: " + loop);
            System.out.print ("\truntime [ms]: " + n / 1000000);
            System.out.println ();
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Random rnd = new SecureRandom ();
    Map < String, Long > timings = new TreeMap < String, Long > ();
    for (int outerPass = 0;
    outerPass < 10; ++ outerPass) {
        List < FilterStrategy > strategies = Arrays.asList (new CopyIntoNewListWithIterator (), new CopyIntoNewListWithoutIterator (), new FilterLinkedListInPlace (), new RandomRemoveByIndex (), new SequentialRemoveByIndex (), new ShiftDown ());
        for (FilterStrategy strategy : strategies) {
            String strategyName = strategy.getClass ().getSimpleName ();
            for (int innerPass = 0;
            innerPass < 10; ++ innerPass) {
                strategy.populate (rnd);
                if (outerPass >= 5 && innerPass >= 5) {
                    Long totalTime = timings.get (strategyName);
                    if (totalTime == null) totalTime = 0L;

                    timings.put (strategyName, totalTime - System.currentTimeMillis ());
                }
                Collection < Point > filtered = strategy.filter ();
                if (outerPass >= 5 && innerPass >= 5) {
                    Long totalTime = timings.get (strategyName);
                    timings.put (strategy.getClass ().getSimpleName (), totalTime + System.currentTimeMillis ());
                }
                CHECKSUM += filtered.hashCode ();
                System.err.printf ("%-30s %d %d %d%n", strategy.getClass ().getSimpleName (), outerPass, innerPass, filtered.size ());
                strategy.clear ();
            }
        }
    }
    for (Map.Entry < String, Long > e : timings.entrySet ()) {
        System.err.printf ("%-30s: %9.2fms%n", e.getKey (), e.getValue () * (1.0 / 25.0));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_103_111
6101789_6103075_131_139
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    int inputSize = list.size ();
    ArrayList < Point > dst = new ArrayList < Point > (inputSize);
    for (int i = 0;
    i < inputSize; ++ i) {
        Point p = list.get (i);
        if (wanted (p)) dst.add (p);

    }
    return dst;
}
----------------------------------------

Collection < Point > filter () {
    for (Iterator < Point > it = list.iterator ();
    it.hasNext ();) {
        Point p = it.next ();
        if (! wanted (p)) it.remove ();

    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_103_111
6101789_6103075_156_165
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    int inputSize = list.size ();
    ArrayList < Point > dst = new ArrayList < Point > (inputSize);
    for (int i = 0;
    i < inputSize; ++ i) {
        Point p = list.get (i);
        if (wanted (p)) dst.add (p);

    }
    return dst;
}
----------------------------------------

Collection < Point > filter () {
    for (int i = 0;
    i < list.size ();) {
        if (wanted (list.get (i))) {
            ++ i;
        } else {
            list.remove (i);
        }
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_103_111
6101789_6103075_182_191
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    int inputSize = list.size ();
    ArrayList < Point > dst = new ArrayList < Point > (inputSize);
    for (int i = 0;
    i < inputSize; ++ i) {
        Point p = list.get (i);
        if (wanted (p)) dst.add (p);

    }
    return dst;
}
----------------------------------------

Collection < Point > filter () {
    for (int i = 0;
    i < list.size ();) {
        if (wanted (list.get (i))) {
            ++ i;
        } else {
            list.remove (i);
        }
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_103_111
6101789_6103075_208_219
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    int inputSize = list.size ();
    ArrayList < Point > dst = new ArrayList < Point > (inputSize);
    for (int i = 0;
    i < inputSize; ++ i) {
        Point p = list.get (i);
        if (wanted (p)) dst.add (p);

    }
    return dst;
}
----------------------------------------

Collection < Point > filter () {
    int inputSize = list.size ();
    int outputSize = 0;
    for (int i = 0;
    i < inputSize; ++ i) {
        Point p = list.get (i);
        if (wanted (p)) {
            list.set (outputSize ++, p);
        }
    }
    list.subList (outputSize, inputSize).clear ();
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_131_139
6101789_6103075_156_165
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    for (Iterator < Point > it = list.iterator ();
    it.hasNext ();) {
        Point p = it.next ();
        if (! wanted (p)) it.remove ();

    }
    return list;
}
----------------------------------------

Collection < Point > filter () {
    for (int i = 0;
    i < list.size ();) {
        if (wanted (list.get (i))) {
            ++ i;
        } else {
            list.remove (i);
        }
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_131_139
6101789_6103075_182_191
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    for (Iterator < Point > it = list.iterator ();
    it.hasNext ();) {
        Point p = it.next ();
        if (! wanted (p)) it.remove ();

    }
    return list;
}
----------------------------------------

Collection < Point > filter () {
    for (int i = 0;
    i < list.size ();) {
        if (wanted (list.get (i))) {
            ++ i;
        } else {
            list.remove (i);
        }
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_131_139
6101789_6103075_208_219
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    for (Iterator < Point > it = list.iterator ();
    it.hasNext ();) {
        Point p = it.next ();
        if (! wanted (p)) it.remove ();

    }
    return list;
}
----------------------------------------

Collection < Point > filter () {
    int inputSize = list.size ();
    int outputSize = 0;
    for (int i = 0;
    i < inputSize; ++ i) {
        Point p = list.get (i);
        if (wanted (p)) {
            list.set (outputSize ++, p);
        }
    }
    list.subList (outputSize, inputSize).clear ();
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_156_165
6101789_6103075_208_219
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    for (int i = 0;
    i < list.size ();) {
        if (wanted (list.get (i))) {
            ++ i;
        } else {
            list.remove (i);
        }
    }
    return list;
}
----------------------------------------

Collection < Point > filter () {
    int inputSize = list.size ();
    int outputSize = 0;
    for (int i = 0;
    i < inputSize; ++ i) {
        Point p = list.get (i);
        if (wanted (p)) {
            list.set (outputSize ++, p);
        }
    }
    list.subList (outputSize, inputSize).clear ();
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6101789_6103075_182_191
6101789_6103075_208_219
Title: Why does Java's ArrayList's remove function seem to cost so little? 
----------------------------------------

Collection < Point > filter () {
    for (int i = 0;
    i < list.size ();) {
        if (wanted (list.get (i))) {
            ++ i;
        } else {
            list.remove (i);
        }
    }
    return list;
}
----------------------------------------

Collection < Point > filter () {
    int inputSize = list.size ();
    int outputSize = 0;
    for (int i = 0;
    i < inputSize; ++ i) {
        Point p = list.get (i);
        if (wanted (p)) {
            list.set (outputSize ++, p);
        }
    }
    list.subList (outputSize, inputSize).clear ();
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6104823_6104847_104_117
6104823_6104847_119_132
Title: How do I get an sql*plus connection for the oracle 11db that I downloaded on my computer yesterday? 
----------------------------------------

public static void close (Statement st) {
    try {
        if (st != null) {
            st.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void close (ResultSet rs) {
    try {
        if (rs != null) {
            rs.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6104823_6104847_104_117
6104823_6104847_88_101
Title: How do I get an sql*plus connection for the oracle 11db that I downloaded on my computer yesterday? 
----------------------------------------

public static void close (Statement st) {
    try {
        if (st != null) {
            st.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void close (Connection connection) {
    try {
        if (connection != null) {
            connection.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6104823_6104847_119_132
6104823_6104847_88_101
Title: How do I get an sql*plus connection for the oracle 11db that I downloaded on my computer yesterday? 
----------------------------------------

public static void close (ResultSet rs) {
    try {
        if (rs != null) {
            rs.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void close (Connection connection) {
    try {
        if (connection != null) {
            connection.close ();
        }
    } catch (SQLException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6113944_18932679_34_59
6113944_18932679_74_83
Title: How cancel the execution of a SwingWorker? 
----------------------------------------

public void run () {
    Exception exception = null;
    R rvalue = null;
    try {
        rvalue = doInBackground ();
    } catch (Exception ex) {
        exception = ex;
    }
    synchronized (MySwingWorker.this) {
        done = true;
        final Exception cexception = exception;
        final R crvalue = rvalue;
        final boolean ccancelled = cancelled;
        SwingUtilities.invokeLater (new Runnable () {
            @Override
            public void run () {
                done (crvalue, cexception, ccancelled);
            }}

        );
    }
}
----------------------------------------

public void run () {
    List < P > list;
    synchronized (syncprocess) {
        MySwingWorker.this.processstate = false;
        list = MySwingWorker.this.chunkes;
        MySwingWorker.this.chunkes = new LinkedList < > ();
    }
    process (list);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6125702_6125744_1_12
6125702_6125845_1_19
Title: Searching in a Tree that is NOT BINARY 
----------------------------------------

public TreeNode < City > search (City parent, TreeNode < City > t) {
    if (t.getCity ().equals (parent)) {
        return t;
    } else if (t.hasLeftChild ()) {
        return search (parent, t.getLeftChild ());
    } else if (t.hasNextSibling ()) {
        return search (parent, t.getNextSibling ());
    }

    return null;
}
----------------------------------------

public TreeNode < City > search (City parent, TreeNode < City > t) {
    if (t.getCity ().equals (parent)) {
        return t;
    }
    if (t.hasLeftChild ()) {
        if (tmp = search (parent, t.getLeftChild ())) {
            return tmp;
        }
    }
    if (t.hasnextSibling ()) {
        if (tmp = search (parent, t.getnextSibling ())) {
            return tmp;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6126907_25145352_26_36
6126907_25145352_38_57
Title: Java client framework / API to call Windows phone push notification service 
----------------------------------------

public boolean sendMessage (Jogador destinatario, Action mensagem) {
    try {
        OAuthToken token = getToken ();
        String jsonString = mapper.writeValueAsString (mensagem);
        StringEntity entity = new StringEntity (jsonString, Consts.UTF_8);
        return sendMessage (destinatario, entity, token);
    } catch (IOException e) {
        LOG.log (Level.SEVERE, e.getMessage (), e);
        throw new RuntimeException (e);
    }
}
----------------------------------------

private boolean sendMessage (Jogador destinatario, HttpEntity entity, OAuthToken token) throws IOException {
    HttpPost post = new HttpPost (destinatario.getCloudMessagingInfo ());
    post.addHeader ("Authorization", token.getAuthorization ());
    addPostHeaders (post, sendMessageWNSHeaders);
    post.setEntity (entity);
    HttpResponse response = executeMethod (post);
    if (response.getStatusLine ().getStatusCode () == HttpStatus.SC_UNAUTHORIZED) {
        return sendMessage (destinatario, entity, getNewToken ());
    }
    Header [] allHeaders = response.getAllHeaders ();
    StringBuilder builder = new StringBuilder ();
    for (Header header : allHeaders) {
        builder.append (header.getName () + ": " + header.getValue ());
        builder.append ('\n');
    }
    LOG.info (builder.toString ());
    return response.getStatusLine ().getStatusCode () == HttpStatus.SC_OK;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6137140_6137257_3_14
6137140_6137389_19_31
Title: return a byte array from a java method 
----------------------------------------

private static String nibbleSwap (byte [] inByte) {
    String ret = "";
    for (int i = 0;
    i < inByte.length; i ++) {
        int nibble0 = (inByte [i] << 4) & 0xf0;
        int nibble1 = (inByte [i]>>> 4) & 0x0f;
        byte b = (byte) ((nibble0 | nibble1));
        ret += String.format ("%x ", b);
    }
    return ret;
}
----------------------------------------

private static byte [] nibbleSwap (byte [] inByte) {
    int [] nibble0 = new int [inByte.length];
    int [] nibble1 = new int [inByte.length];
    byte [] b = new byte [inByte.length];
    for (int i = 0;
    i < inByte.length; i ++) {
        nibble0 [i] = (inByte [i] << 4) & 0xf0;
        nibble1 [i] = (inByte [i]>>> 4) & 0x0f;
        b [i] = (byte) ((nibble0 [i] | nibble1 [i]));
        System.out.printf ("%x ", b [i]);
    }
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6142901_16714929_9_19
6142901_37521412_6_17
Title: How to create a file in a directory in java? 
----------------------------------------

public static void main (String [] args) throws IOException {
    Path path = Paths.get ("/tmp/foo/bar.txt");
    Files.createDirectories (path.getParent ());
    try {
        Files.createFile (path);
    } catch (FileAlreadyExistsException e) {
        System.err.println ("already exists: " + e.getMessage ());
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        File file = new File ("d:/sampleFile.txt");
        if (file.createNewFile ()) System.out.println ("File creation successfull");
        else System.out.println ("Error while creating File, file already exists in specified path");

    } catch (IOException io) {
        io.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6144036_6160230_113_141
6144036_6160230_150_161
Title: parsing performance critical data in java 
----------------------------------------

public ReferenceData parse (String line) throws ParseException {
    int p1 = 0;
    String p2 = null;
    String p3 = null;
    String p4 = null;
    String p5 = null;
    String lineSplit [] = line.split (",");
    for (int i = 0;
    i < lineSplit.length; i ++) {
        String value = lineSplit [i].split ("==") [1];
        if (lineSplit [i].startsWith ("P1")) {
            p1 = Integer.valueOf (value);
        } else if (lineSplit [i].startsWith ("P2")) {
            p2 = value;
        } else if (lineSplit [i].startsWith ("P3")) {
            p3 = value;
        } else if (lineSplit [i].startsWith ("P4")) {
            p4 = value;
        } else if (lineSplit [i].startsWith ("P5")) {
            p5 = value;
        }

    }
    return new ReferenceData (p1, p2, p3, p4, p5);
}
----------------------------------------

public ReferenceData parse (String line) throws ParseException {
    Matcher m = p.matcher (line);
    if (! m.matches ()) {
        throw new ParseException (line, 0);
    }
    int p1 = Integer.parseInt (m.group (1));
    String p2 = m.group (2);
    String p3 = m.group (3);
    String p4 = m.group (4);
    String p5 = m.group (5);
    return new ReferenceData (p1, p2, p3, p4, p5);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6144036_6160230_113_141
6144036_6160230_176_319
Title: parsing performance critical data in java 
----------------------------------------

public ReferenceData parse (String line) throws ParseException {
    int p1 = 0;
    String p2 = null;
    String p3 = null;
    String p4 = null;
    String p5 = null;
    String lineSplit [] = line.split (",");
    for (int i = 0;
    i < lineSplit.length; i ++) {
        String value = lineSplit [i].split ("==") [1];
        if (lineSplit [i].startsWith ("P1")) {
            p1 = Integer.valueOf (value);
        } else if (lineSplit [i].startsWith ("P2")) {
            p2 = value;
        } else if (lineSplit [i].startsWith ("P3")) {
            p3 = value;
        } else if (lineSplit [i].startsWith ("P4")) {
            p4 = value;
        } else if (lineSplit [i].startsWith ("P5")) {
            p5 = value;
        }

    }
    return new ReferenceData (p1, p2, p3, p4, p5);
}
----------------------------------------

public ReferenceData parse (String line) throws ParseException {
    int p1 = 0;
    String p2 = null;
    String p3 = null;
    String p4 = null;
    String p5 = null;
    int state = STATE_INITIAL_P;
    int length = line.length ();
    int pNum = 0;
    int valueStart = 0;
    int valueEnd = 0;
    for (int i = 0;
    i < length; i ++) {
        char c = line.charAt (i);
        switch (state) {
            case STATE_INITIAL_P :
            case STATE_P :
                if (c != 'P') {
                    throw new ParseException (line, i);
                }
                state = STATE_P_NUM;
                break;
            case STATE_P_NUM :
                if (c < '1' || c > '5') {
                    throw new ParseException (line, i);
                }
                pNum = c - '0';
                state = STATE_EQ1;
                break;
            case STATE_EQ1 :
                if (c != '=') {
                    throw new ParseException (line, i);
                }
                state = STATE_EQ2;
                break;
            case STATE_EQ2 :
                if (c != '=') {
                    throw new ParseException (line, i);
                }
                valueStart = valueEnd = i + 1;
                state = STATE_VALUE;
                break;
            case STATE_VALUE :
                if ((c >= '0' && c <= '9') || c == '*') {
                    valueEnd ++;
                } else if (c == ',') {
                    if (valueStart == valueEnd) {
                        throw new ParseException (line, i);
                    }
                    switch (pNum) {
                        case 1 :
                            if (p1 != 0) {
                                throw new ParseException (line, i);
                            }
                            p1 = Integer.parseInt (line.substring (valueStart, valueEnd));
                            break;
                        case 2 :
                            if (p2 != null) {
                                throw new ParseException (line, i);
                            }
                            p2 = line.substring (valueStart, valueEnd);
                            break;
                        case 3 :
                            if (p3 != null) {
                                throw new ParseException (line, i);
                            }
                            p3 = line.substring (valueStart, valueEnd);
                            break;
                        case 4 :
                            if (p4 != null) {
                                throw new ParseException (line, i);
                            }
                            p4 = line.substring (valueStart, valueEnd);
                            break;
                        case 5 :
                            if (p5 != null) {
                                throw new ParseException (line, i);
                            }
                            p5 = line.substring (valueStart, valueEnd);
                            break;
                        default :
                            throw new ParseException (line, i);
                    }
                    state = STATE_P;
                }

                break;
        }
    }
    switch (state) {
        case STATE_INITIAL_P :
        case STATE_P :
        case STATE_P_NUM :
        case STATE_EQ1 :
        case STATE_EQ2 :
            throw new ParseException (line, length);
        case STATE_VALUE :
            if (valueStart == valueEnd) {
                throw new ParseException (line, length);
            }
            switch (pNum) {
                case 1 :
                    if (p1 != 0) {
                        throw new ParseException (line, length);
                    }
                    p1 = Integer.parseInt (line.substring (valueStart, valueEnd));
                    break;
                case 2 :
                    if (p2 != null) {
                        throw new ParseException (line, length);
                    }
                    p2 = line.substring (valueStart, valueEnd);
                    break;
                case 3 :
                    if (p3 != null) {
                        throw new ParseException (line, length);
                    }
                    p3 = line.substring (valueStart, valueEnd);
                    break;
                case 4 :
                    if (p4 != null) {
                        throw new ParseException (line, length);
                    }
                    p4 = line.substring (valueStart, valueEnd);
                    break;
                case 5 :
                    if (p5 != null) {
                        throw new ParseException (line, length);
                    }
                    p5 = line.substring (valueStart, valueEnd);
                    break;
                default :
                    throw new ParseException (line, length);
            }
            break;
        default :
            throw new RuntimeException ("unknown state: " + state);
    }
    return new ReferenceData (p1, p2, p3, p4, p5);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6144036_6160230_150_161
6144036_6160230_176_319
Title: parsing performance critical data in java 
----------------------------------------

public ReferenceData parse (String line) throws ParseException {
    Matcher m = p.matcher (line);
    if (! m.matches ()) {
        throw new ParseException (line, 0);
    }
    int p1 = Integer.parseInt (m.group (1));
    String p2 = m.group (2);
    String p3 = m.group (3);
    String p4 = m.group (4);
    String p5 = m.group (5);
    return new ReferenceData (p1, p2, p3, p4, p5);
}
----------------------------------------

public ReferenceData parse (String line) throws ParseException {
    int p1 = 0;
    String p2 = null;
    String p3 = null;
    String p4 = null;
    String p5 = null;
    int state = STATE_INITIAL_P;
    int length = line.length ();
    int pNum = 0;
    int valueStart = 0;
    int valueEnd = 0;
    for (int i = 0;
    i < length; i ++) {
        char c = line.charAt (i);
        switch (state) {
            case STATE_INITIAL_P :
            case STATE_P :
                if (c != 'P') {
                    throw new ParseException (line, i);
                }
                state = STATE_P_NUM;
                break;
            case STATE_P_NUM :
                if (c < '1' || c > '5') {
                    throw new ParseException (line, i);
                }
                pNum = c - '0';
                state = STATE_EQ1;
                break;
            case STATE_EQ1 :
                if (c != '=') {
                    throw new ParseException (line, i);
                }
                state = STATE_EQ2;
                break;
            case STATE_EQ2 :
                if (c != '=') {
                    throw new ParseException (line, i);
                }
                valueStart = valueEnd = i + 1;
                state = STATE_VALUE;
                break;
            case STATE_VALUE :
                if ((c >= '0' && c <= '9') || c == '*') {
                    valueEnd ++;
                } else if (c == ',') {
                    if (valueStart == valueEnd) {
                        throw new ParseException (line, i);
                    }
                    switch (pNum) {
                        case 1 :
                            if (p1 != 0) {
                                throw new ParseException (line, i);
                            }
                            p1 = Integer.parseInt (line.substring (valueStart, valueEnd));
                            break;
                        case 2 :
                            if (p2 != null) {
                                throw new ParseException (line, i);
                            }
                            p2 = line.substring (valueStart, valueEnd);
                            break;
                        case 3 :
                            if (p3 != null) {
                                throw new ParseException (line, i);
                            }
                            p3 = line.substring (valueStart, valueEnd);
                            break;
                        case 4 :
                            if (p4 != null) {
                                throw new ParseException (line, i);
                            }
                            p4 = line.substring (valueStart, valueEnd);
                            break;
                        case 5 :
                            if (p5 != null) {
                                throw new ParseException (line, i);
                            }
                            p5 = line.substring (valueStart, valueEnd);
                            break;
                        default :
                            throw new ParseException (line, i);
                    }
                    state = STATE_P;
                }

                break;
        }
    }
    switch (state) {
        case STATE_INITIAL_P :
        case STATE_P :
        case STATE_P_NUM :
        case STATE_EQ1 :
        case STATE_EQ2 :
            throw new ParseException (line, length);
        case STATE_VALUE :
            if (valueStart == valueEnd) {
                throw new ParseException (line, length);
            }
            switch (pNum) {
                case 1 :
                    if (p1 != 0) {
                        throw new ParseException (line, length);
                    }
                    p1 = Integer.parseInt (line.substring (valueStart, valueEnd));
                    break;
                case 2 :
                    if (p2 != null) {
                        throw new ParseException (line, length);
                    }
                    p2 = line.substring (valueStart, valueEnd);
                    break;
                case 3 :
                    if (p3 != null) {
                        throw new ParseException (line, length);
                    }
                    p3 = line.substring (valueStart, valueEnd);
                    break;
                case 4 :
                    if (p4 != null) {
                        throw new ParseException (line, length);
                    }
                    p4 = line.substring (valueStart, valueEnd);
                    break;
                case 5 :
                    if (p5 != null) {
                        throw new ParseException (line, length);
                    }
                    p5 = line.substring (valueStart, valueEnd);
                    break;
                default :
                    throw new ParseException (line, length);
            }
            break;
        default :
            throw new RuntimeException ("unknown state: " + state);
    }
    return new ReferenceData (p1, p2, p3, p4, p5);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6147031_6147054_40_56
6147031_6147287_23_39
Title: Java applet renders JLabel (and other components) with extra random letters 
----------------------------------------

public void init () {
    try {
        SwingUtilities.invokeAndWait (new Runnable () {
            public void run () {
                createGUI ();
            }}

        );
    } catch (Exception e) {
        System.err.println ("createGUI didn't successfully complete: " + e);
    }
}
----------------------------------------

public void init () {
    try {
        SwingUtilities.invokeAndWait (new Runnable () {
            public void run () {
                createGUI ();
            }}

        );
    } catch (Exception e) {
        System.err.println ("createGUI didn't successfully complete: " + e);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6157424_6157618_1_12
6157424_6157710_7_20
Title: Transformation of a number to different number using recursion 
----------------------------------------

int transform (int a, int b) {
    if (a >= b) {
        return a;
    } else {
        int c = a * 2 + 1;
        if (c > b) {
            return a;
        } else {
            return transform (c, b);
        }
    }
}
----------------------------------------

public static String transform (int a, int b) {
    if (a == b) return "" + a;

    if (b % 2 == 0 && 2 * a <= b) {
        b = b / 2;
        return transform (a, b) + " * 2";
    } else {
        b = b - 1;
        return "(" + transform (a, b) + " + 1)";
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6158936_6159029_46_54
6158936_6159029_60_71
Title: Are keySet entries of a WeakHashMap never null? 
----------------------------------------

public int nextInt (int lo, int hi) throws IllegalArgumentException {
    if (lo >= hi) throw new IllegalArgumentException ("lo must be < hi");

    int n = hi - lo + 1;
    int i = super.nextInt () % n;
    if (i < 0) i = - i;

    return lo + i;
}
----------------------------------------

public int nextInt (int lo, int hi, int xlo, int xhi) throws IllegalArgumentException {
    if (xlo < lo) throw new IllegalArgumentException ("xlo must be >= lo");

    if (xhi > hi) throw new IllegalArgumentException ("xhi must be =< hi");

    if (xlo > xhi) throw new IllegalArgumentException ("xlo must be >= xhi");

    int i;
    do {
        i = nextInt (lo, hi);
    } while (i >= xlo && i <= xhi);
    return (i);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
616924_616985_1_13
616924_617004_1_17
Title: How to check if the key pressed was an arrow key in Java KeyListener? 
----------------------------------------

public void keyPressed (KeyEvent e) {
    if (e.getKeyCode () == KeyEvent.VK_RIGHT) {
    } else if (e.getKeyCode () == KeyEvent.VK_LEFT) {
    } else if (e.getKeyCode () == KeyEvent.VK_UP) {
    } else if (e.getKeyCode () == KeyEvent.VK_DOWN) {
    }

    repaint ();
}
----------------------------------------

public void keyPressed (KeyEvent e) {
    int keyCode = e.getKeyCode ();
    switch (keyCode) {
        case KeyEvent.VK_UP :
            break;
        case KeyEvent.VK_DOWN :
            break;
        case KeyEvent.VK_LEFT :
            break;
        case KeyEvent.VK_RIGHT :
            break;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6174462_120_130
6171414_6186188_278_288
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public void propertyChange (PropertyChangeEvent event) {
    if ("state".equals (event.getPropertyName ()) && SwingWorker.StateValue.DONE == event.getNewValue ()) {
        System.out.println ("Thread Status with Name :" + str + ", SwingWorker Status is " + event.getNewValue ());
    } else if ("state".equals (event.getPropertyName ()) && SwingWorker.StateValue.PENDING == event.getNewValue ()) {
        System.out.println ("Thread Status with Mame :" + str + ", SwingWorker Status is " + event.getNewValue ());
    } else if ("state".equals (event.getPropertyName ()) && SwingWorker.StateValue.STARTED == event.getNewValue ()) {
        System.out.println ("Thread Status with Name :" + str + ", SwingWorker Status is " + event.getNewValue ());
    } else {
        System.out.println ("Thread Status with Name :" + str + ", Something wrong happends ");
    }

}
----------------------------------------

public void propertyChange (PropertyChangeEvent event) {
    if ("state".equals (event.getPropertyName ()) && SwingWorker.StateValue.DONE == event.getNewValue ()) {
        System.out.println ("Thread Status with Name :" + str + ", SwingWorker Status is " + event.getNewValue ());
    } else if ("state".equals (event.getPropertyName ()) && SwingWorker.StateValue.PENDING == event.getNewValue ()) {
        System.out.println ("Thread Status with Mame :" + str + ", SwingWorker Status is " + event.getNewValue ());
    } else if ("state".equals (event.getPropertyName ()) && SwingWorker.StateValue.STARTED == event.getNewValue ()) {
        System.out.println ("Thread Status with Name :" + str + ", SwingWorker Status is " + event.getNewValue ());
    } else {
        System.out.println ("Thread Status with Name :" + str + ", Something wrong happends ");
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6174462_133_143
6171414_6186188_291_300
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            executor.execute (new ExecutorAndSwingWorker1.MyTask ("startButton1"));
            executor.execute (new ExecutorAndSwingWorker1.MyTask ("startButton2"));
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            ExecutorAndSwingWorker2 executorAndSwingWorker = new ExecutorAndSwingWorker2 ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6174462_133_143
6171414_6824207_26_34
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            executor.execute (new ExecutorAndSwingWorker1.MyTask ("startButton1"));
            executor.execute (new ExecutorAndSwingWorker1.MyTask ("startButton2"));
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            MyFrame frame = new MyFrame ("Swing Concurrency Test");
            frame.setVisible (true);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6174462_75_86
6171414_6186188_229_244
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

protected Void doInBackground () throws Exception {
    if (str.equals ("startButton1")) {
        startButton1 ();
    } else if (str.equals ("startButton2")) {
        startButton2 ();
    } else if (str.equals ("startButton3")) {
        startButton3 ();
    } else if (str.equals ("startButton4")) {
        startButton4 ();
    }

    return null;
}
----------------------------------------

protected Void doInBackground () throws Exception {
    if (str.equals ("startButton1")) {
        colorAction1 ();
        startButton1 ();
    } else if (str.equals ("startButton2")) {
        colorAction2 ();
        startButton2 ();
    } else if (str.equals ("startButton3")) {
        colorAction3 ();
        startButton3 ();
    } else if (str.equals ("startButton4")) {
        colorAction4 ();
        startButton4 ();
    }

    return null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6174462_75_86
6171414_6824207_105_118
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

protected Void doInBackground () throws Exception {
    if (str.equals ("startButton1")) {
        startButton1 ();
    } else if (str.equals ("startButton2")) {
        startButton2 ();
    } else if (str.equals ("startButton3")) {
        startButton3 ();
    } else if (str.equals ("startButton4")) {
        startButton4 ();
    }

    return null;
}
----------------------------------------

protected String doInBackground () throws Exception {
    publish ("started...");
    Thread.sleep (2000);
    publish ("Waiting for line counter to finish...");
    long numLines = counterTask.get ();
    publish ("Line count received: " + numLines);
    Thread.sleep (5000);
    return "complete.";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6174462_94_104
6171414_6186188_252_262
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

protected void done () {
    if (str.equals ("startButton1")) {
        endButton1 ();
    } else if (str.equals ("startButton2")) {
        endButton2 ();
    } else if (str.equals ("startButton3")) {
        endButton3 ();
    } else if (str.equals ("startButton4")) {
        endButton4 ();
    }

}
----------------------------------------

protected void done () {
    if (str.equals ("startButton1")) {
        endButton1 ();
    } else if (str.equals ("startButton2")) {
        endButton2 ();
    } else if (str.equals ("startButton3")) {
        endButton3 ();
    } else if (str.equals ("startButton4")) {
        endButton4 ();
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6186188_123_134
6171414_6186188_147_158
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button2.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button2.validate ();
            button2.repaint ();
        }}

    );
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button3.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button3.validate ();
            button3.repaint ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6186188_123_134
6171414_6186188_171_182
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button2.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button2.validate ();
            button2.repaint ();
        }}

    );
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button4.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button4.validate ();
            button4.repaint ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6186188_123_134
6171414_6186188_99_110
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button2.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button2.validate ();
            button2.repaint ();
        }}

    );
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button1.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button1.validate ();
            button1.repaint ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6186188_147_158
6171414_6186188_171_182
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button3.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button3.validate ();
            button3.repaint ();
        }}

    );
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button4.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button4.validate ();
            button4.repaint ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6186188_147_158
6171414_6186188_99_110
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button3.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button3.validate ();
            button3.repaint ();
        }}

    );
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button1.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button1.validate ();
            button1.repaint ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6186188_171_182
6171414_6186188_99_110
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button4.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button4.validate ();
            button4.repaint ();
        }}

    );
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    random = new Random ();
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            button1.setBackground (new Color (127 + random.nextInt (128), 127 + random.nextInt (128), 127 + random.nextInt (128)));
            button1.validate ();
            button1.repaint ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6186188_229_244
6171414_6824207_105_118
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

protected Void doInBackground () throws Exception {
    if (str.equals ("startButton1")) {
        colorAction1 ();
        startButton1 ();
    } else if (str.equals ("startButton2")) {
        colorAction2 ();
        startButton2 ();
    } else if (str.equals ("startButton3")) {
        colorAction3 ();
        startButton3 ();
    } else if (str.equals ("startButton4")) {
        colorAction4 ();
        startButton4 ();
    }

    return null;
}
----------------------------------------

protected String doInBackground () throws Exception {
    publish ("started...");
    Thread.sleep (2000);
    publish ("Waiting for line counter to finish...");
    long numLines = counterTask.get ();
    publish ("Line count received: " + numLines);
    Thread.sleep (5000);
    return "complete.";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6171414_6186188_291_300
6171414_6824207_26_34
Title: How to share data with two(2) SwingWorker class in Java 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            ExecutorAndSwingWorker2 executorAndSwingWorker = new ExecutorAndSwingWorker2 ();
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            MyFrame frame = new MyFrame ("Swing Concurrency Test");
            frame.setVisible (true);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
617165_617257_17_62
617165_619656_13_67
Title: Is there a Java package to read the UNIX /etc/group file? 
----------------------------------------

public static GroupReader2 parseGroup (final String groupLine) throws InvalidGroupException {
    final String line;
    final String [] parts;
    if (groupLine == null) {
        throw new IllegalArgumentException ("groupLine cannot be null");
    }
    line = groupLine.trim ();
    if (line.startsWith ("#") || line.isEmpty ()) {
        return null;
    }
    parts = line.split (":");
    if (parts.length < 3) {
        throw new InvalidGroupException (groupLine + "must be in the format of name:passwd:gid[:userlist]");
    }
    try {
        final GroupReader2 group;
        final String name;
        final String passwd;
        final int gid;
        final List < String > userList;
        name = parts [0];
        passwd = parts [1];
        gid = Integer.parseInt (parts [2]);
        if (parts.length == 4) {
            userList = Arrays.asList (parts [3].split (","));
        } else {
            userList = Collections.emptyList ();
        }
        group = new GroupReader2 (name, passwd, gid, userList);
        return group;
    } catch (final NumberFormatException ex) {
        throw new InvalidGroupException (groupLine + " gid must be a number");
    }
}
----------------------------------------

public static Group parseGroup (final String groupLine) throws InvalidGroupException {
    final String line;
    final String [] parts;
    if (groupLine == null) {
        throw new IllegalArgumentException ("groupLine cannot be null");
    }
    line = groupLine.trim ();
    if (line.startsWith ("#") || line.isEmpty ()) {
        return null;
    }
    parts = line.split (":");
    if (parts.length < 3) {
        throw new InvalidGroupException (groupLine + "must be in the format of name:passwd:gid[:userlist]", line);
    }
    try {
        final Group group;
        final String name;
        final String passwd;
        final int gid;
        final List < String > userList;
        name = parts [0];
        passwd = parts [1];
        gid = Integer.parseInt (parts [2]);
        if (parts.length == 4) {
            userList = Arrays.asList (parts [3].split (","));
        } else {
            userList = Collections.emptyList ();
        }
        group = new Group (name, passwd, gid, userList);
        return group;
    } catch (final NumberFormatException ex) {
        throw new InvalidGroupException (groupLine + " gid must be a number", line);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
617165_617257_95_114
617165_619656_98_119
Title: Is there a Java package to read the UNIX /etc/group file? 
----------------------------------------

public String toString () {
    final StringBuilder sb;
    sb = new StringBuilder ();
    sb.append (name);
    sb.append (":");
    sb.append (passwd);
    sb.append (":");
    sb.append (gid);
    sb.append (":");
    for (final String user : userList) {
        sb.append (user);
        sb.append (",");
    }
    sb.setLength (sb.length () - 1);
    return (sb.toString ());
}
----------------------------------------

public String toString () {
    final StringBuilder sb;
    sb = new StringBuilder ();
    sb.append (name);
    sb.append (":");
    sb.append (passwd);
    sb.append (":");
    sb.append (gid);
    sb.append (":");
    for (final String user : userList) {
        sb.append (user);
        sb.append (",");
    }
    sb.setLength (sb.length () - 1);
    return (sb.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6175944_24086631_10_24
6175944_6176559_1_15
Title: event for check box in jtable header 
----------------------------------------

public void mouseClicked (MouseEvent e) {
    JTable table = ((JTableHeader) e.getSource ()).getTable ();
    TableColumnModel columnModel = table.getColumnModel ();
    int viewColumn = columnModel.getColumnIndexAtX (e.getX ());
    int modelColumn = table.convertColumnIndexToModel (viewColumn);
    if (modelColumn == index) {
        check.setSelected (! check.isSelected ());
        TableModel m = table.getModel ();
        Boolean f = check.isSelected ();
        for (int i = 0;
        i < m.getRowCount (); i ++) {
            m.setValueAt (f, i, index);
        }
        ((JTableHeader) e.getSource ()).repaint ();
    } else return;

}
----------------------------------------

public void mouseClicked (MouseEvent e) {
    JTable table = ((JTableHeader) e.getSource ()).getTable ();
    TableColumnModel columnModel = table.getColumnModel ();
    int viewColumn = columnModel.getColumnIndexAtX (e.getX ());
    int modelColumn = table.convertColumnIndexToModel (viewColumn);
    if (modelColumn == 0 || modelColumn == 1) {
        check.setSelected (! check.isSelected ());
        TableModel m = table.getModel ();
        Boolean f = check.isSelected ();
        for (int i = 0;
        i < m.getRowCount (); i ++) {
            m.setValueAt (f, i, modelColumn);
        }
        ((JTableHeader) e.getSource ()).repaint ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6185419_6185509_1_17
6185419_6185580_1_28
Title: non static variable cannot be referenced from a static context 
----------------------------------------

public static void main (String args []) {
    java.awt.EventQueue.invokeLater (new Runnable () {
        public void run () {
            Reg1 r = new Reg1 ();
            try {
                AudioInputStream audio = AudioSystem.getAudioInputStream (new File ("name.wav"));
                Clip clip = AudioSystem.getClip ();
                clip.open (audio);
                clip.start ();
            } catch (Exception e) {
                System.out.println (e);
            }
            r.captureAudio ();
        }}

    );
}
----------------------------------------

public static void main (String args []) {
    java.awt.EventQueue.invokeLater (new Runnable () {
        public void run () {
            Reg1 reg1 = new Reg1 ();
            KeyListener s;
            try {
                AudioInputStream audio = AudioSystem.getAudioInputStream (new File ("name.wav"));
                Clip clip = AudioSystem.getClip ();
                clip.open (audio);
                clip.start ();
            } catch (UnsupportedAudioFileException uae) {
                System.out.println (uae);
            } catch (IOException ioe) {
                System.out.println (ioe);
            } catch (LineUnavailableException lua) {
                System.out.println (lua);
            }
            reg1.captureAudio ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6185419_6185509_3_15
6185419_6185580_5_26
Title: non static variable cannot be referenced from a static context 
----------------------------------------

public void run () {
    Reg1 r = new Reg1 ();
    try {
        AudioInputStream audio = AudioSystem.getAudioInputStream (new File ("name.wav"));
        Clip clip = AudioSystem.getClip ();
        clip.open (audio);
        clip.start ();
    } catch (Exception e) {
        System.out.println (e);
    }
    r.captureAudio ();
}
----------------------------------------

public void run () {
    Reg1 reg1 = new Reg1 ();
    KeyListener s;
    try {
        AudioInputStream audio = AudioSystem.getAudioInputStream (new File ("name.wav"));
        Clip clip = AudioSystem.getClip ();
        clip.open (audio);
        clip.start ();
    } catch (UnsupportedAudioFileException uae) {
        System.out.println (uae);
    } catch (IOException ioe) {
        System.out.println (ioe);
    } catch (LineUnavailableException lua) {
        System.out.println (lua);
    }
    reg1.captureAudio ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6201736_43472266_13_27
6201736_6210694_24_71
Title: Java:using apache POI how to convert ms word file to pdf? 
----------------------------------------

public static void main (String [] args) throws Exception {
    String inputFile = "D:/TEST.docx";
    String outputFile = "D:/TEST.pdf";
    if (args != null && args.length == 2) {
        inputFile = args [0];
        outputFile = args [1];
    }
    System.out.println ("inputFile:" + inputFile + ",outputFile:" + outputFile);
    FileInputStream in = new FileInputStream (inputFile);
    XWPFDocument document = new XWPFDocument (in);
    File outFile = new File (outputFile);
    OutputStream out = new FileOutputStream (outFile);
    PdfOptions options = null;
    PdfConverter.getInstance ().convert (document, out, options);
}
----------------------------------------

public static void main (String [] args) {
    POIFSFileSystem fs = null;
    Document document = new Document ();
    try {
        System.out.println ("Starting the test");
        fs = new POIFSFileSystem (new FileInputStream ("D:/Resume.doc"));
        HWPFDocument doc = new HWPFDocument (fs);
        WordExtractor we = new WordExtractor (doc);
        OutputStream file = new FileOutputStream (new File ("D:/test.pdf"));
        PdfWriter writer = PdfWriter.getInstance (document, file);
        Range range = doc.getRange ();
        document.open ();
        writer.setPageEmpty (true);
        document.newPage ();
        writer.setPageEmpty (true);
        String [] paragraphs = we.getParagraphText ();
        for (int i = 0;
        i < paragraphs.length; i ++) {
            org.apache.poi.hwpf.usermodel.Paragraph pr = range.getParagraph (i);
            paragraphs [i] = paragraphs [i].replaceAll ("\\cM?\r?\n", "");
            System.out.println ("Length:" + paragraphs [i].length ());
            System.out.println ("Paragraph" + i + ": " + paragraphs [i].toString ());
            document.add (new Paragraph (paragraphs [i]));
        }
        System.out.println ("Document testing completed");
    } catch (Exception e) {
        System.out.println ("Exception during test");
        e.printStackTrace ();
    } finally {
        document.close ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
620993_13533390_4_27
620993_39903784_1_12
Title: Determining binary/text file type in Java? 
----------------------------------------

public static boolean isBinaryFile (File f) throws FileNotFoundException, IOException {
    FileInputStream in = new FileInputStream (f);
    int size = in.available ();
    if (size > 1024) size = 1024;

    byte [] data = new byte [size];
    in.read (data);
    in.close ();
    int ascii = 0;
    int other = 0;
    for (int i = 0;
    i < data.length; i ++) {
        byte b = data [i];
        if (b < 0x09) return true;

        if (b == 0x09 || b == 0x0A || b == 0x0C || b == 0x0D) ascii ++;
        else if (b >= 0x20 && b <= 0x7E) ascii ++;
        else other ++;

    }
    if (other == 0) return false;

    return 100 * other / (ascii + other) > 95;
}
----------------------------------------

boolean isBinaryFile (File f) throws IOException {
    String type = Files.probeContentType (f.toPath ());
    if (type == null) {
        return true;
    } else if (type.startsWith ("text")) {
        return false;
    } else {
        return true;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6210111_6210162_1_16
6210111_6210296_19_63
Title: Java Swing Help 
----------------------------------------

private static JPanel Board () {
    JButton [] [] buttons = new JButton [10] [10];
    for (int i = 0;
    i < 10; i ++) {
        for (int j = 0;
        j < 10; j ++) {
            buttons [i] [j] = new JButton ();
        }
    }
    JPanel board = new JPanel (new GridLayout (11, 11));
    String [] rowlabels = {" ", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J"};
    String [] columnlabels = {" ", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"};
    JTextField k;
}
----------------------------------------

private static JPanel Board () {
    JButton [] [] buttons = new JButton [10] [10];
    for (int x = 0;
    x < buttons.length; x ++) {
        for (int y = 0;
        y < buttons [0].length; y ++) {
            JButton temp = new JButton ();
            temp.setPreferredSize (new Dimension (30, 30));
            buttons [x] [y] = temp;
        }
    }
    JPanel board = new JPanel (new GridLayout (11, 11));
    String [] rowlabels = {" ", "A", "B", "C", "D", "E", "F", "G", "H", "I", "J"};
    String [] columnlabels = {" ", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"};
    JTextField k;
    for (int i = 0;
    i < 11; i ++) {
        for (int j = 0;
        j < 11; j ++) {
            if ((j != 0) && (i != 0)) {
                board.add (buttons [i - 1] [j - 1]);
            }
            if (i == 0) {
                if (j != 0) {
                    k = new JTextField (columnlabels [j]);
                    k.setEditable (false);
                    k.setHorizontalAlignment ((int) JFrame.CENTER_ALIGNMENT);
                } else {
                    k = new JTextField ();
                    k.setEditable (false);
                }
                board.add (k);
            } else if (j == 0) {
                k = new JTextField (rowlabels [i]);
                k.setEditable (false);
                k.setHorizontalAlignment ((int) JFrame.CENTER_ALIGNMENT);
                board.add (k);
            }

        }
    }
    return board;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6223477_6223523_8_21
6223477_6223587_11_24
Title: how to factor a number java 
----------------------------------------

static List < Integer > factorsOf (int val) {
    List < Integer > factors = new ArrayList < Integer > ();
    for (int i = 1;
    i <= val / 2; i ++) {
        if (val % i == 0) {
            factors.add (i);
        }
    }
    return factors;
}
----------------------------------------

static int [] factorsOf (int val) {
    int limit = (int) Math.ceil (Math.sqrt (val));
    int [] numArray = new int [limit];
    int index = 0;
    for (int i = 1;
    i <= limit; i ++) {
        if (val % i == 0) {
            numArray [index ++] = i;
            val /= i;
        }
    }
    numArray [index] = val;
    return numArray;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6228528_6228558_35_61
6228528_6228558_67_92
Title: Is there any way to avoid the finally clause to get executed? 
----------------------------------------

public void run () {
    try {
        println ("trying");
        throw new IllegalStateException ("catching");
    } catch (RuntimeException e) {
        println (e.getMessage ());
    } finally {
        println ("finally-sleeping");
        try {
            Thread.sleep (5000);
        } catch (InterruptedException e) {
            println ("finally-interrupted");
        }
        println ("finally-done");
    }
}
----------------------------------------

public void run () {
    try {
        println ("trying-sleeping");
        Thread.sleep (5000);
    } catch (InterruptedException e) {
        println ("trying-interrupted");
    } finally {
        println ("finally-sleeping");
        try {
            Thread.sleep (5000);
        } catch (InterruptedException e) {
            println ("finally-interrupted");
        }
        println ("finally-done");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6234893_6235687_5_26
6234893_6504233_6_27
Title: JList - select multiple items 
----------------------------------------

public static void main (String [] args) throws Exception {
    File f = new File ("MultiSelectList.java");
    InputStream is = new FileInputStream (f);
    InputStreamReader isr = new InputStreamReader (is);
    BufferedReader br = new BufferedReader (isr);
    final ArrayList < String > lines = new ArrayList < String > ();
    String line = br.readLine ();
    while (line != null) {
        lines.add (line);
        line = br.readLine ();
    }
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            JList list = new JList (lines.toArray ());
            list.setSelectionMode (ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
            int [] select = {19, 20, 22};
            list.setSelectedIndices (select);
            JOptionPane.showMessageDialog (null, new JScrollPane (list));
        }}

    );
}
----------------------------------------

public static void main (String [] args) throws Exception {
    File f = new File ("MultiSelectList.java");
    InputStream is = new FileInputStream (f);
    InputStreamReader isr = new InputStreamReader (is);
    BufferedReader br = new BufferedReader (isr);
    final ArrayList < String > lines = new ArrayList < String > ();
    String line = br.readLine ();
    while (line != null) {
        lines.add (line);
        line = br.readLine ();
    }
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            JList list = new JList (lines.toArray ());
            list.setSelectionMode (ListSelectionModel.MULTIPLE_INTERVAL_SELECTION);
            int [] select = {19, 20, 22};
            list.setSelectedIndices (select);
            JOptionPane.showMessageDialog (null, new JScrollPane (list));
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6245354_6245689_16_30
6245354_6245689_1_14
Title: Why does my recursive solution print duplicates? 
----------------------------------------

public static void makeChange (int n, int i, List < Integer > combos, List < String > output) {
    int sum = getSum (combos);
    if (sum == n) {
        output.add (0, combos.toString ());
    } else {
        while (i < combos.size ()) {
            combos.set (i, combos.get (i) + 1);
            if (getSum (combos) <= n) {
                makeChange (n, i, combos, output);
            }
            combos.set (i, combos.get (i) - 1);
            ++ i;
        }
    }
}
----------------------------------------

public static void makeChange (int n) {
    List < Integer > combos = new ArrayList < Integer > ();
    List < String > output = new ArrayList < String > ();
    combos.add (0);
    combos.add (0);
    combos.add (0);
    combos.add (0);
    System.out.println (" P  N  D  Q");
    System.out.println ("------------");
    makeChange (n, 0, combos, output);
    for (String s : output) {
        System.out.println (s);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
62490_179495_74_105
62490_179495_9_17
Title: How can I get Axis 1.4 to not generate several prefixes for the same XML namespace? 
----------------------------------------

public Node process (Node node) {
    if (node instanceof Element) {
        Element element = (Element) node;
        if (element.isRootElement ()) {
        } else {
            if (element.getName ().equals (targetElement)) {
                log.trace ("Found the target Element.  Adding requested namespace");
                Namespace already = element.getNamespaceForURI (namespace.getURI ());
                if (already == null) {
                    element.add (namespace);
                }
            } else if (! ignoreElements.contains (element.getName ())) {
                Namespace target = element.getNamespaceForURI (namespace.getURI ());
                if (target != null) {
                    element.remove (target);
                    element.setQName (new QName (element.getName (), namespace));
                }
            }

            Attribute type = element.attribute ("type");
            if (type != null) {
                log.trace ("Replacing type information: " + type.getText ());
                String typeText = type.getText ();
                typeText = typeText.replaceAll ("ns[0-9]+", namespace.getPrefix ());
                type.setText (typeText);
            }
        }
    }
    return node;
}
----------------------------------------

protected Document process (Document doc) {
    if (processingHandlers == null) {
        processingHandlers = new ArrayList ();
        processingHandlers.add (new EmptyProcessingHandler ());
    }
    log.trace (processingHandlers);
    treeWalk (doc.getRootElement ());
    return doc;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_163_205
625420_625810_98_149
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += stream.readByte ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_163_205
625420_846439_121_155
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += stream.readByte ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_163_205
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += stream.readByte ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_625810_277_331
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int size;
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        data = new byte [512];
        size = 0;
        sum = 0;
        do {
            size += stream.read (data);
            sum = 0;
            for (int i = 0;
            i < size; i ++) {
                sum += data [i];
            }
        } while (size != fileSize);
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_625810_344_390
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final FileChannel channel;
        final MappedByteBuffer buffer;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        channel = stream.getChannel ();
        buffer = channel.map (MapMode.READ_ONLY, 0, file.length ());
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_846439_167_201
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        int soFar;
        int sum;
        final int fileSize;
        stream = new FileInputStream (file);
        fileSize = (int) file.length ();
        soFar = 0;
        do {
            soFar += stream.read (StaticData, soFar, fileSize - soFar);
        } while (soFar != fileSize);
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticData [i];
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_846439_283_322
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int size;
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        data = new byte [512];
        size = 0;
        sum = 0;
        do {
            size += stream.read (data);
            sum = 0;
            for (int i = 0;
            i < size; i ++) {
                sum += data [i];
            }
        } while (size != fileSize);
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_846439_330_363
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final FileChannel channel;
        final MappedByteBuffer buffer;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        channel = stream.getChannel ();
        buffer = channel.map (MapMode.READ_ONLY, 0, file.length ());
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_846439_372_411
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        buffer = ByteBuffer.wrap (data);
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_846439_420_459
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocate ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_846439_468_507
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocateDirect ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_846439_516_554
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticBuffer.clear ();
        StaticBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticBuffer);
        StaticBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_219_263
625420_846439_563_601
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticDirectBuffer.clear ();
        StaticDirectBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticDirectBuffer);
        StaticDirectBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticDirectBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_277_331
625420_846439_246_275
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int size;
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        data = new byte [512];
        size = 0;
        sum = 0;
        do {
            size += stream.read (data);
            sum = 0;
            for (int i = 0;
            i < size; i ++) {
                sum += data [i];
            }
        } while (size != fileSize);
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_344_390
625420_625810_98_149
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final FileChannel channel;
        final MappedByteBuffer buffer;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        channel = stream.getChannel ();
        buffer = channel.map (MapMode.READ_ONLY, 0, file.length ());
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_344_390
625420_846439_246_275
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final FileChannel channel;
        final MappedByteBuffer buffer;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        channel = stream.getChannel ();
        buffer = channel.map (MapMode.READ_ONLY, 0, file.length ());
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_344_390
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final FileChannel channel;
        final MappedByteBuffer buffer;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        channel = stream.getChannel ();
        buffer = channel.map (MapMode.READ_ONLY, 0, file.length ());
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_98_149
625420_846439_210_238
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += stream.readByte ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_98_149
625420_846439_330_363
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final FileChannel channel;
        final MappedByteBuffer buffer;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        channel = stream.getChannel ();
        buffer = channel.map (MapMode.READ_ONLY, 0, file.length ());
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_98_149
625420_846439_372_411
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        buffer = ByteBuffer.wrap (data);
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_98_149
625420_846439_420_459
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocate ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_98_149
625420_846439_468_507
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocateDirect ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_98_149
625420_846439_516_554
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticBuffer.clear ();
        StaticBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticBuffer);
        StaticBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_625810_98_149
625420_846439_563_601
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticDirectBuffer.clear ();
        StaticDirectBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticDirectBuffer);
        StaticDirectBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticDirectBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_121_155
625420_846439_210_238
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += stream.readByte ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_121_155
625420_846439_372_411
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        buffer = ByteBuffer.wrap (data);
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_121_155
625420_846439_420_459
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocate ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_121_155
625420_846439_468_507
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocateDirect ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_121_155
625420_846439_516_554
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticBuffer.clear ();
        StaticBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticBuffer);
        StaticBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_121_155
625420_846439_563_601
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticDirectBuffer.clear ();
        StaticDirectBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticDirectBuffer);
        StaticDirectBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticDirectBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
