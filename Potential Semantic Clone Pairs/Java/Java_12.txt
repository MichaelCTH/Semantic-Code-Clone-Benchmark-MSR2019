$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13562961_13563034_1_26
13562961_13563332_1_13
Title: Why does Eclipse complain about dead code? 
----------------------------------------

public static void main (String [] args) {
    String img0 = null;
    String img1 = "Asdf";
    if (img0 != null && img1 != null) {
    } else if (img0 != null) {
    } else if (img1 != null) {
    } else {
    }

}
----------------------------------------

public static void main (String [] args) {
    String img0 = nullOrString ();
    String img1 = nullOrString ();
    if (img0 != null && img1 != null) {
    } else if (img0 != null) {
    } else if (img1 != null) {
    } else {
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13564464_15216697_4_63
13564464_15216998_2_48
Title: Problems with Levenshtein algorithm in Java 
----------------------------------------

public static void main (String args []) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter the correct string ");
    String correct = sc.nextLine ();
    System.out.println ("Enter the incorrect string ");
    String incorrect = sc.nextLine ();
    int i = correct.length (), j = incorrect.length ();
    ++ i;
    ++ j;
    int a [] [] = new int [i] [j];
    int b [] = new int [3];
    for (int m = 0;
    m < i; m ++) for (int n = 0;
    n < j; n ++) {
        if (m == 0 || n == 0) {
            a [0] [n] = n;
            a [m] [0] = m;
        } else {
            b [0] = a [m - 1] [n - 1];
            b [1] = a [m - 1] [n];
            b [2] = a [m] [n - 1];
            if (correct.charAt (m - 1) == incorrect.charAt (n - 1)) {
                a [m] [n] = a [m - 1] [n - 1];
            } else {
                for (int t = 0;
                t < 2; t ++) for (int u = 0;
                u < 2 - t; u ++) if (b [u] > b [u + 1]) b [u] = b [u + 1];

                a [m] [n] = b [0] + 1;
            }
        }
    }

    for (int m = 0;
    m < i; m ++) {
        for (int n = 0;
        n < j; n ++) System.out.print (a [m] [n] + "  ");

        System.out.print ("\n");
    }
    System.out.println (" Levenshtein distance :  " + a [i - 1] [j - 1]);
}
----------------------------------------

public static void main (String args []) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter the correct string ");
    String correct = sc.nextLine ();
    System.out.println ("Enter the incorrect string ");
    String incorrect = sc.nextLine ();
    int i = correct.length (), j = incorrect.length ();
    ++ i;
    ++ j;
    int a [] [] = new int [i] [j];
    int b [] = new int [3];
    for (int m = 0;
    m < i; m ++) for (int n = 0;
    n < j; n ++) {
        if (m == 0 || n == 0) {
            a [0] [n] = n;
            a [m] [0] = m;
        } else {
            b [0] = a [m - 1] [n - 1];
            b [1] = a [m - 1] [n];
            b [2] = a [m] [n - 1];
            if (correct.charAt (m - 1) == incorrect.charAt (n - 1)) a [m] [n] = a [m - 1] [n - 1];
            else {
                if ((b [0] <= b [1]) && (b [0]) <= b [2]) a [m] [n] = b [0] + 1;
                else if ((b [1] <= b [0]) && (b [1]) <= b [2]) a [m] [n] = b [1] + 1;
                else a [m] [n] = b [2] + 1;

            }
        }
    }

    for (int m = 0;
    m < i; m ++) {
        for (int n = 0;
        n < j; n ++) System.out.print (a [m] [n] + "  ");

        System.out.print ("\n");
    }
    System.out.println ("
Levenshtein distance :
  " + a [i - 1] [j - 1]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13564721_23614803_138_235
13564721_23614803_246_284
Title: Beginner Calculator 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    if (e.getSource () == num [0]) {
        display = tf.getText ();
        tf.setText (display + "1");
    } else if (e.getSource () == num [1]) {
        display = tf.getText ();
        tf.setText (display + "2");
    } else if (e.getSource () == num [2]) {
        display = tf.getText ();
        tf.setText (display + "3");
    } else if (e.getSource () == num [3]) {
        display = tf.getText ();
        tf.setText (display + "4");
    } else if (e.getSource () == num [4]) {
        display = tf.getText ();
        tf.setText (display + "5");
    } else if (e.getSource () == num [5]) {
        display = tf.getText ();
        tf.setText (display + "6");
    } else if (e.getSource () == num [6]) {
        display = tf.getText ();
        tf.setText (display + "7");
    } else if (e.getSource () == num [7]) {
        display = tf.getText ();
        tf.setText (display + "8");
    } else if (e.getSource () == num [8]) {
        display = tf.getText ();
        tf.setText (display + "9");
    } else if (e.getSource () == btNum0) {
        display = tf.getText ();
        tf.setText (display + "0");
    } else if (e.getSource () == btDot) {
        String dot = ".";
        display = tf.getText ();
        tf.setText (display + ".");
    } else if (e.getSource () == btAdd) {
        TEMP = Double.parseDouble (tf.getText ());
        tf.setText ("");
        addBool = true;
    } else if (e.getSource () == btSubtract) {
        TEMP = Double.parseDouble (tf.getText ());
        tf.setText ("");
        subBool = true;
    } else if (e.getSource () == btMultiply) {
        TEMP = Double.parseDouble (tf.getText ());
        tf.setText ("");
        mulBool = true;
    } else if (e.getSource () == btDivide) {
        TEMP = Double.parseDouble (tf.getText ());
        tf.setText ("");
        divBool = true;
    } else if (e.getSource () == btExponent) {
        TEMP = Double.parseDouble (tf.getText ());
        tf.setText ("");
        expBool = true;
    } else if (e.getSource () == btClear) {
        tf.setText (null);
    }

}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    SolveTEMP = Double.parseDouble (tf.getText ());
    if (addBool == true) {
        SolveTEMP = SolveTEMP + TEMP;
    } else if (subBool == true) {
        SolveTEMP = TEMP - SolveTEMP;
    } else if (mulBool == true) {
        SolveTEMP = SolveTEMP * TEMP;
    } else if (divBool == true) {
        SolveTEMP = TEMP / SolveTEMP;
    } else if (expBool == true) {
        double a = TEMP, b = SolveTEMP;
        SolveTEMP = 1;
        for (int i = 0;
        i < b; i ++) {
            SolveTEMP = SolveTEMP * TEMP;
        }
    }

    tf.setText (Double.toString (SolveTEMP));
    addBool = false;
    subBool = false;
    mulBool = false;
    divBool = false;
    expBool = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13565900_13566037_14_58
13565900_13566545_67_74
Title: JButton & Action & KeyBinding 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            final JFrame frame = new JFrame ();
            frame.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
            final JButton btn = new JButton ("Button") {
                @Override
                protected boolean processKeyBinding (KeyStroke ks, KeyEvent ke, int i, boolean bln) {
                    boolean b = super.processKeyBinding (ks, ke, i, bln);
                    if (b && ks.getKeyCode () == KeyEvent.VK_F1) {
                        requestFocusInWindow ();
                    }
                    return b;
                }}

            ;
            AbstractAction aa = new AbstractAction () {
                @Override
                public void actionPerformed (ActionEvent ae) {
                    System.out.println ("Here");
                }}

            ;
            btn.getInputMap (JComponent.WHEN_FOCUSED).put (KeyStroke.getKeyStroke (KeyEvent.VK_ENTER, 0), "Enter");
            btn.getActionMap ().put ("Enter", aa);
            btn.getInputMap (JComponent.WHEN_IN_FOCUSED_WINDOW).put (KeyStroke.getKeyStroke (KeyEvent.VK_F1, 0), "F1");
            btn.getActionMap ().put ("F1", aa);
            btn.addActionListener (aa);
            JTextField tf = new JTextField ("added to show ENTER wont work unless button in focus");
            frame.add (tf);
            frame.add (btn, BorderLayout.SOUTH);
            frame.pack ();
            frame.setVisible (true);
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            new IButtonSave ().initUI ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13575142_13575574_41_60
13575142_13576103_16_26
Title: Creating a line graph based on user input points 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    int width = getWidth ();
    int height = getHeight ();
    int maxX = Math.max (p1.x, p2.x);
    int maxY = Math.max (p1.y, p2.y);
    float scale = Math.min (width / (float) maxX, height / (float) maxY);
    int x1 = (int) (p1.x * scale);
    int y1 = (int) (p1.y * scale);
    int x2 = (int) (p2.x * scale);
    int y2 = (int) (p2.y * scale);
    g.drawLine (x1, y1, x2, y2);
}
----------------------------------------

public void paintComponent (Graphics g) {
    g.setColor (Color.BLACK);
    g.drawLine (0, xAxisPos, screenWidth, xAxisPos);
    g.drawLine (yAxisPos, 0, yAxisPos, screenHeight);
    int yValueStart = (int) y (- yAxisPos);
    int yValueEnd = (int) y (screenWidth - yAxisPos);
    g.setColor (Color.BLUE);
    g.drawLine (0, - yValueStart, screenWidth, - yValueEnd);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13578195_13578227_1_11
13578195_13578244_1_17
Title: How do I make a return type of int[][] with a for loop? 
----------------------------------------

public int getPieceCoords (int entityId) {
    int temp = 0;
    for (int x = 0;
    x < 8; x ++) {
        for (int y = 0;
        y < 8; y ++) {
            if (position [x] [y] == entityId) {
                temp = position [x] [y];
            }
        }
    }
    return temp;
}
----------------------------------------

public int getPieceCoords (int entityId) {
    int result = - 1;
    for (int x = 0;
    x < 8; x ++) {
        for (int y = 0;
        y < 8; y ++) {
            if (position [x] [y] == entityId) {
                result = position [x] [y];
                break;
            }
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13583521_13583581_3_15
13583521_13583888_110_134
Title: Join two arrays in Java? 
----------------------------------------

public static void main (String [] args) {
    int [] a = new int [] {1, 2, 3};
    int [] b = new int [] {3, 4, 5};
    int [] r = new int [a.length + b.length];
    System.arraycopy (a, 0, r, 0, a.length);
    System.arraycopy (b, 0, r, a.length, b.length);
    for (int x : r) {
        System.out.println (x);
    }
}
----------------------------------------

public static void main (String [] args) {
    JoinedArray < String > a = new JoinedArray < String > (new String [] {"One"}, new String [] {"Two", "Three", "Four", "Five"}, new String [] {"Six", "Seven", "Eight", "Nine"});
    for (String s : a) {
        System.out.println (s);
    }
    String [] four = new String [4];
    int copied = a.copyTo (four, 3, 4);
    System.out.println ("Copied " + copied + " = " + Arrays.toString (four));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1359689_11683932_14_55
1359689_1359702_5_16
Title: How to send HTTP request in java? 
----------------------------------------

public static void main (String [] args) {
    HttpClient client = new HttpClient ();
    PostMethod method = new PostMethod (url);
    method.setRequestHeader ("Content-type", "text/xml; charset=ISO-8859-1");
    NameValuePair nvp1 = new NameValuePair ("firstName", "fname");
    NameValuePair nvp2 = new NameValuePair ("lastName", "lname");
    NameValuePair nvp3 = new NameValuePair ("email", "email@email.com");
    method.setQueryString (new NameValuePair [] {nvp1, nvp2, nvp3});
    try {
        int statusCode = client.executeMethod (method);
        System.out.println ("Status Code = " + statusCode);
        System.out.println ("QueryString>>> " + method.getQueryString ());
        System.out.println ("Status Text>>>" + HttpStatus.getStatusText (statusCode));
        System.out.println (method.getResponseBodyAsString ());
        byte [] res = method.getResponseBody ();
        FileOutputStream fos = new FileOutputStream ("donepage.html");
        fos.write (res);
        method.releaseConnection ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    URL yahoo = new URL ("http://www.yahoo.com/");
    URLConnection yc = yahoo.openConnection ();
    BufferedReader in = new BufferedReader (new InputStreamReader (yc.getInputStream ()));
    String inputLine;
    while ((inputLine = in.readLine ()) != null) System.out.println (inputLine);

    in.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13607597_13607744_1_12
13607597_26840983_1_14
Title: "Does assertEquals(Object o1 Object o2) uses the equals method" 
----------------------------------------

static public void assertEquals (String message, Object expected, Object actual) {
    if (equalsRegardingNull (expected, actual)) {
        return;
    } else if (expected instanceof String && actual instanceof String) {
        String cleanMessage = message == null ? "" : message;
        throw new ComparisonFailure (cleanMessage, (String) expected, (String) actual);
    } else {
        failNotEquals (message, expected, actual);
    }

}
----------------------------------------

static public void assertEquals (Object actual, Object expected, String message) {
    if ((expected == null) && (actual == null)) {
        return;
    }
    if (expected != null) {
        if (expected.getClass ().isArray ()) {
            assertArrayEquals (actual, expected, message);
            return;
        } else if (expected.equals (actual)) {
            return;
        }

    }
    failNotEquals (actual, expected, message);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13609758_22757050_16_86
13609758_22900227_36_69
Title: Stuck on recursive Fork/Join 
----------------------------------------

protected Set < Point3D > compute () {
    if (radius <= SEQUENTIAL_THRESHHOLD) {
        return computeValue ();
    } else {
        final ForkPoints subCubes [] = new ForkPoints [8];
        final double newRadius = radius / 2;
        Point3D newOrigin = new Point3D ();
        newOrigin.setX (origin.getX () + newRadius);
        newOrigin.setY (origin.getY () + newRadius);
        newOrigin.setZ (origin.getZ () + newRadius);
        subCubes [0] = new ForkPoints (newOrigin, newRadius);
        subCubes [0].fork ();
        newOrigin = new Point3D ();
        newOrigin.setX (origin.getX () + newRadius);
        newOrigin.setY (origin.getY () + newRadius);
        newOrigin.setZ (origin.getZ () - newRadius);
        subCubes [1] = new ForkPoints (newOrigin, newRadius);
        subCubes [1].fork ();
        newOrigin = new Point3D ();
        newOrigin.setX (origin.getX () + newRadius);
        newOrigin.setY (origin.getY () - newRadius);
        newOrigin.setZ (origin.getZ () + newRadius);
        subCubes [2] = new ForkPoints (newOrigin, newRadius);
        subCubes [2].fork ();
        newOrigin = new Point3D ();
        newOrigin.setX (origin.getX () + newRadius);
        newOrigin.setY (origin.getY () - newRadius);
        newOrigin.setZ (origin.getZ () - newRadius);
        subCubes [3] = new ForkPoints (newOrigin, newRadius);
        subCubes [3].fork ();
        newOrigin = new Point3D ();
        newOrigin.setX (origin.getX () - newRadius);
        newOrigin.setY (origin.getY () + newRadius);
        newOrigin.setZ (origin.getZ () + newRadius);
        subCubes [4] = new ForkPoints (newOrigin, newRadius);
        subCubes [4].fork ();
        newOrigin = new Point3D ();
        newOrigin.setX (origin.getX () - newRadius);
        newOrigin.setY (origin.getY () + newRadius);
        newOrigin.setZ (origin.getZ () - newRadius);
        subCubes [5] = new ForkPoints (newOrigin, newRadius);
        subCubes [5].fork ();
        newOrigin = new Point3D ();
        newOrigin.setX (origin.getX () - newRadius);
        newOrigin.setY (origin.getY () - newRadius);
        newOrigin.setZ (origin.getZ () + newRadius);
        subCubes [6] = new ForkPoints (newOrigin, newRadius);
        subCubes [6].fork ();
        newOrigin = new Point3D ();
        newOrigin.setX (origin.getX () - newRadius);
        newOrigin.setY (origin.getY () - newRadius);
        newOrigin.setZ (origin.getZ () - newRadius);
        subCubes [7] = new ForkPoints (newOrigin, newRadius);
        subCubes [7].fork ();
        final Set < Point3D > results = new LinkedHashSet < Point3D > ();
        for (final ForkPoints singleSubCube : subCubes) {
            results.addAll (singleSubCube.join ());
        }
        return results;
    }
}
----------------------------------------

protected Set < Point3D > compute () {
    double dx = maxX - minX + 1;
    double dy = maxY - minY + 1;
    double dz = maxZ - minZ + 1;
    if (dx * dy * dz <= PTS_THRESHOLD) {
        return computeValue ();
    } else {
        bool splitx = (dx >= dy) && (dx >= dz);
        bool splity = ! splitx && (dy >= dz);
        ForkPoints left;
        ForkPoints right;
        if (splitx) {
            double midx = Math.floor ((minx + maxx) / 2);
            left = new ForkPoints (minx, midx, miny, maxy, minz, maxz);
            right = new ForkPoints (midx + 1, maxx, miny, maxy, minz, maxz);
        } else if (splity) {
            double midy = Math.floor ((miny + maxy) / 2);
            left = new ForkPoints (minx, maxx, miny, midy, minz, maxz);
            right = new ForkPoints (minx, maxx, midy + 1, maxy, minz, maxz);
        } else {
            double midz = Math.floor ((minz + maxz) / 2);
            left = new ForkPoints (minx, maxx, miny, maxy, minz, midz);
            right = new ForkPoints (minx, maxx, miny, maxy, midz + 1, maxz);
        }

        left.fork ();
        Set < Point3D > rightPoints = right.compute ();
        Set < Point3D > leftPoints = left.join ();
        leftPoints.addAll (rightPoints);
        return leftPoints;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13609758_22757050_88_128
13609758_22900227_71_88
Title: Stuck on recursive Fork/Join 
----------------------------------------

private Set < Point3D > computeValue () {
    double minX = origin.getX () - radius;
    double maxX = origin.getX () + radius;
    double minY = origin.getY () - radius;
    double maxY = origin.getY () + radius;
    double maxZ = origin.getZ () + radius;
    double x = minX;
    double y = minY;
    double z = origin.getZ () - radius;
    Set < Point3D > points = new LinkedHashSet < > ();
    boolean notFinished = true;
    while (notFinished) {
        if (x > maxX) {
            x = minX;
            y ++;
        }
        if (y > maxY) {
            y = minY;
            z ++;
        }
        if (z > maxZ) {
            break;
        }
        Point3D ppoint = new Point3D ();
        ppoint.setX (x);
        ppoint.setY (y);
        ppoint.setZ (z);
        points.add (ppoint);
        x ++;
    }
    return points;
}
----------------------------------------

private Set < Point3D > computeValue () {
    Set < Point3D > points = new LinkedHashSet < > ();
    for (double z = minZ;
    z < maxZ + 0.01; z += 1) for (double y = minY;
    y < maxY + 0.01; y += 1) for (double x = minX;
    x < maxX + 0.01; x += 1) {
        Point3D ppoint = new Point3D ();
        ppoint.setX (x);
        ppoint.setY (y);
        ppoint.setZ (z);
        points.add (ppoint);
    }

    return points;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13623175_13624060_6_23
13623175_34115875_7_32
Title: Deserialize to an ImmutableMap with GSON 
----------------------------------------

public < T > TypeAdapter < T > create (Gson gson, TypeToken < T > type) {
    if (! ImmutableMap.class.isAssignableFrom (type.getRawType ())) {
        return null;
    }
    final TypeAdapter < T > delegate = gson.getDelegateAdapter (this, type);
    return new TypeAdapter < T > () {
        @Override
        public void write (JsonWriter out, T value) throws IOException {
            delegate.write (out, value);
        }@Override
        @SuppressWarnings ("unchecked")
        public T read (JsonReader in) throws IOException {
            return (T) ImmutableMap.copyOf ((Map) delegate.read (in));
        }}

    ;
}
----------------------------------------

public < T > TypeAdapter < T > create (Gson gson, TypeToken < T > typeToken) {
    Type type = typeToken.getType ();
    if (typeToken.getRawType () != ImmutableMap.class || ! (type instanceof ParameterizedType)) {
        return null;
    }
    com.google.common.reflect.TypeToken < ImmutableMap < ?, ? > > betterToken = (com.google.common.reflect.TypeToken < ImmutableMap < ?, ? > >) com.google.common.reflect.TypeToken.of (typeToken.getType ());
    final TypeAdapter < HashMap < ?, ? > > hashMapAdapter = (TypeAdapter < HashMap < ?, ? > >) gson.getAdapter (TypeToken.get (betterToken.getSupertype (Map.class).getSubtype (HashMap.class).getType ()));
    return new TypeAdapter < T > () {
        @Override
        public void write (JsonWriter out, T value) throws IOException {
            HashMap < ?, ? > hashMap = Maps.newHashMap ((Map < ?, ? >) value);
            hashMapAdapter.write (out, hashMap);
        }@Override
        public T read (JsonReader in) throws IOException {
            HashMap < ?, ? > hashMap = hashMapAdapter.read (in);
            return (T) ImmutableMap.copyOf (hashMap);
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13623175_33835862_40_57
13623175_34115875_7_32
Title: Deserialize to an ImmutableMap with GSON 
----------------------------------------

public < T > TypeAdapter < T > create (Gson gson, TypeToken < T > type) {
    if (! ImmutableMap.class.isAssignableFrom (type.getRawType ())) {
        return null;
    }
    final TypeAdapter < T > delegate = gson.getDelegateAdapter (this, type);
    return new TypeAdapter < T > () {
        @Override
        public void write (JsonWriter out, T value) throws IOException {
            delegate.write (out, value);
        }@Override
        @SuppressWarnings ("unchecked")
        public T read (JsonReader in) throws IOException {
            return (T) ImmutableMap.copyOf ((Map) delegate.read (in));
        }}

    ;
}
----------------------------------------

public < T > TypeAdapter < T > create (Gson gson, TypeToken < T > typeToken) {
    Type type = typeToken.getType ();
    if (typeToken.getRawType () != ImmutableMap.class || ! (type instanceof ParameterizedType)) {
        return null;
    }
    com.google.common.reflect.TypeToken < ImmutableMap < ?, ? > > betterToken = (com.google.common.reflect.TypeToken < ImmutableMap < ?, ? > >) com.google.common.reflect.TypeToken.of (typeToken.getType ());
    final TypeAdapter < HashMap < ?, ? > > hashMapAdapter = (TypeAdapter < HashMap < ?, ? > >) gson.getAdapter (TypeToken.get (betterToken.getSupertype (Map.class).getSubtype (HashMap.class).getType ()));
    return new TypeAdapter < T > () {
        @Override
        public void write (JsonWriter out, T value) throws IOException {
            HashMap < ?, ? > hashMap = Maps.newHashMap ((Map < ?, ? >) value);
            hashMapAdapter.write (out, hashMap);
        }@Override
        public T read (JsonReader in) throws IOException {
            HashMap < ?, ? > hashMap = hashMapAdapter.read (in);
            return (T) ImmutableMap.copyOf (hashMap);
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13624442_13624548_15_31
13624442_47028753_17_46
Title: Getting last day of the month in a given string date 
----------------------------------------

public static void main (String [] args) {
    Date today = new Date ();
    Calendar calendar = Calendar.getInstance ();
    calendar.setTime (today);
    calendar.add (Calendar.MONTH, 1);
    calendar.set (Calendar.DAY_OF_MONTH, 1);
    calendar.add (Calendar.DATE, - 1);
    Date lastDayOfMonth = calendar.getTime ();
    DateFormat sdf = new SimpleDateFormat ("yyyy-MM-dd");
    System.out.println ("Today            : " + sdf.format (today));
    System.out.println ("Last Day of Month: " + sdf.format (lastDayOfMonth));
}
----------------------------------------

public static void main (String [] args) throws Exception {
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 1));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 3));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 4));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 5));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 6));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 7));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 8));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 9));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 10));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 11));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 12));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2018, 1));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2018, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2018, 3));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2010, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2011, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2012, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2013, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2014, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2015, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2016, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2017, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2018, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2019, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2020, 2));
    System.out.println ("Last Day of Month: " + getLastDayOfMonth (2021, 2));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1362890_1362974_1_12
1362890_1363021_15_26
Title: Generic deep compare equals 
----------------------------------------

@Override
public boolean equals (Object that) {
    if (this == that) return true;

    if (that instanceof Ie) {
        Object ThisValue = this.value;
        Object ThatValue = ((Ie < ? >) that).value;
        return ThisValue.equals (ThatValue);
    } else return false;

}
----------------------------------------

public boolean equals (Object obj) {
    if (obj == this) return true;

    if (obj instanceof Ie) {
        Object that = ((Ie < ? >) obj).value;
        if (type.isInstance (that)) {
            return value.compareTo (type.cast (that)) == 0;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1362890_1362974_1_12
1362890_1363175_7_23
Title: Generic deep compare equals 
----------------------------------------

@Override
public boolean equals (Object that) {
    if (this == that) return true;

    if (that instanceof Ie) {
        Object ThisValue = this.value;
        Object ThatValue = ((Ie < ? >) that).value;
        return ThisValue.equals (ThatValue);
    } else return false;

}
----------------------------------------

public boolean equals (Object obj) {
    if (obj == this) return true;

    if (obj instanceof Ie < ? >) {
        Ie < ? > That = (Ie < ? >) obj;
        if (value.getClass () != That.value.getClass ()) return false;

        return ((Ie < String >) this).equals ((Ie < String >) That);
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1362890_1363021_15_26
1362890_1363175_7_23
Title: Generic deep compare equals 
----------------------------------------

public boolean equals (Object obj) {
    if (obj == this) return true;

    if (obj instanceof Ie) {
        Object that = ((Ie < ? >) obj).value;
        if (type.isInstance (that)) {
            return value.compareTo (type.cast (that)) == 0;
        }
    }
    return false;
}
----------------------------------------

public boolean equals (Object obj) {
    if (obj == this) return true;

    if (obj instanceof Ie < ? >) {
        Ie < ? > That = (Ie < ? >) obj;
        if (value.getClass () != That.value.getClass ()) return false;

        return ((Ie < String >) this).equals ((Ie < String >) That);
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13634502_13652820_14_27
13634502_24696386_1_12
Title: Custom FocusTraversalPolicy class Java Swing 
----------------------------------------

public Component getComponentAfter (Container container, Component component) {
    if (component == this.getLastComponent (container)) {
        if (isValid (this.getFirstComponent (container))) {
            return this.getFirstComponent (container);
        } else {
            return this.getComponentAfter (container, this.getFirstComponent (container));
        }
    }
    if (exceptionsMap.containsKey (component) && isValid (exceptionsMap.get (component))) {
        return exceptionsMap.get (component);
    } else {
        return oldPolicy.getComponentAfter (container, component);
    }
}
----------------------------------------

public Component getComponentAfter (Container container, Component component) {
    if (component == this.getLastComponent (container)) {
        if (isValid (this.getFirstComponent (container))) return this.getFirstComponent (container);
        else return this.getComponentAfter (container, this.getFirstComponent (container));

    }
    if (exceptionsMap.containsKey (component)) {
        component = exceptionsMap.get (component);
        if (isValid (component)) return component;

        return this.getComponentAfter (container, component);
    }
    return oldPolicy.getComponentAfter (container, component);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13634502_13652820_29_42
13634502_24696386_13_24
Title: Custom FocusTraversalPolicy class Java Swing 
----------------------------------------

public Component getComponentBefore (Container container, Component component) {
    if (component == this.getFirstComponent (container)) {
        if (isValid (this.getLastComponent (container))) {
            return this.getLastComponent (container);
        } else {
            return this.getComponentBefore (container, this.getLastComponent (container));
        }
    }
    if (exceptionsMapReflection.containsKey (component) && isValid (exceptionsMapReflection.get (component))) {
        return exceptionsMapReflection.get (component);
    } else {
        return oldPolicy.getComponentBefore (container, component);
    }
}
----------------------------------------

public Component getComponentBefore (Container container, Component component) {
    if (component == this.getFirstComponent (container)) {
        if (isValid (this.getLastComponent (container))) return this.getLastComponent (container);
        else return this.getComponentBefore (container, this.getLastComponent (container));

    }
    if (exceptionsMapReflection.containsKey (component)) {
        component = exceptionsMapReflection.get (component);
        if (isValid (component)) return component;

        return this.getComponentBefore (container, component);
    }
    return oldPolicy.getComponentBefore (container, component);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13636094_13636151_2_19
13636094_13636442_33_48
Title: Is there any way to know if an arraylist contains a piece of text? 
----------------------------------------

public static void main (String [] args) {
    String searchMe = "Green Eggs and Ham";
    String findMe = "Eggs";
    int searchMeLength = searchMe.length ();
    int findMeLength = findMe.length ();
    boolean foundIt = false;
    for (int i = 0;
    i <= (searchMeLength - findMeLength); i ++) {
        if (searchMe.regionMatches (i, findMe, 0, findMeLength)) {
            foundIt = true;
            System.out.println (searchMe.substring (i, i + findMeLength));
            break;
        }
    }
    if (! foundIt) System.out.println ("No match found.");

}
----------------------------------------

public static void main (String [] args) {
    Logger logger = Logger.getAnonymousLogger ();
    ArrayList < String > list = new ArrayList < String > ();
    Random r = new Random ();
    logger.log (Level.INFO, "Creating entries.");
    for (int ii = 0;
    ii < 1000000; ii ++) {
        list.add (getPrefix (r) + getColor (r));
    }
    logger.log (Level.INFO, "Searching..");
    logger.log (Level.INFO, "Searching 'dark' " + countPrefixes (list, "dark"));
    logger.log (Level.INFO, "Searching 'light' " + countPrefixes (list, "light"));
    logger.log (Level.INFO, "Searching 'plain' " + countPrefixes (list, "plain"));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13657462_13657596_1_18
13657462_13657723_6_28
Title: String appended does not show up in System.out.println 
----------------------------------------

public static void main (String [] args) {
    try {
        int n = 10000;
        FileWriter fstream = new FileWriter ("input" + n + ".txt");
        BufferedWriter out = new BufferedWriter (fstream);
        for (int i = 0;
        i < n; i ++) {
            int temp = (int) Math.ceil ((Math.random () * n));
            out.write (temp + " ");
            out.flush ();
        }
        out.close ();
    } catch (Exception e) {
        System.err.println ("Error: " + e.getMessage ());
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        int n = 10000;
        String line = "";
        for (int i = 0;
        i < n; i ++) {
            int temp = (int) Math.ceil ((Math.random () * n));
            line = line + temp + " ";
            System.out.println (line);
        }
        System.out.println ("file name is :: input" + n + ".txt");
        FileWriter fstream = new FileWriter ("input" + n + ".txt");
        BufferedWriter out = new BufferedWriter (fstream);
        out.write (line);
        out.close ();
    } catch (Exception e) {
        System.err.println ("Error: " + e.getMessage ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13664875_13664974_1_12
13664875_19608634_1_15
Title: Can this be done with recursion only? 
----------------------------------------

public String stringClean (String str) {
    if (str.length () == 0) return "";

    if (str.length () == 1) return str;

    if (str.charAt (0) == str.charAt (1)) {
        return stringClean (str.substring (1));
    } else {
        return str.charAt (0) + stringClean (str.substring (1));
    }
}
----------------------------------------

public String stringClean (String str) {
    if (str == null) {
        return null;
    } else if (str.length () > 1) {
        String k = str.substring (0, 1);
        if (str.charAt (0) == str.charAt (1)) {
            String tmp = stringClean (str.substring (2));
            return k + stringClean (tmp);
        } else {
            return k + stringClean (stringClean (str.substring (1)));
        }
    } else {
        return str;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13665755_13665971_1_191
13665755_13666015_1_12
Title: Having a Variable and an Integer as User Input 
----------------------------------------

public static void main (String [] args) {
    double a = 0;
    double b = 0;
    double c = 0;
    String [] resultA = null;
    String [] resultB = null;
    String [] resultC = null;
    String [] result = null;
    if (args.length > 0) {
        for (int i = 0;
        i < args.length; i ++) {
            if (args [i].toUpperCase ().startsWith ("A")) {
                resultA = args [i].split ("=");
                a = Double.parseDouble (resultA [1]);
            } else if (args [i].toUpperCase ().startsWith ("B")) {
                resultB = args [i].split ("=");
                b = Double.parseDouble (resultB [1]);
            } else if (args [i].toUpperCase ().startsWith ("C")) {
                result = args [i].split ("=");
                resultC = result [1].split ("");
                for (int j = 1;
                j < resultC.length; j ++) {
                    if (resultC [j].toUpperCase ().startsWith ("A")) {
                        if (resultC [j + 1].equals ("+")) {
                            if (resultC [j + 2].toUpperCase ().startsWith ("A")) {
                                c = a + a;
                                break;
                            } else if (resultC [j + 2].toUpperCase ().startsWith ("B")) {
                                c = a + b;
                                break;
                            } else {
                                System.out.println ("Argument parse error");
                            }

                        } else if (resultC [j + 1].equals ("-")) {
                            if (resultC [j + 2].toUpperCase ().startsWith ("A")) {
                                c = a - a;
                                break;
                            } else if (resultC [j + 2].toUpperCase ().startsWith ("B")) {
                                c = a - b;
                                break;
                            } else {
                                System.out.println ("Argument parse error");
                            }

                        } else if (resultC [j + 1].equals ("*")) {
                            if (resultC [j + 2].toUpperCase ().startsWith ("A")) {
                                c = a * a;
                                break;
                            } else if (resultC [j + 2].toUpperCase ().startsWith ("B")) {
                                c = a * b;
                                break;
                            } else {
                                System.out.println ("Argument parse error");
                            }

                        } else if (resultC [j + 1].equals ("/")) {
                            if (resultC [j + 2].toUpperCase ().startsWith ("A")) {
                                c = a / a;
                                break;
                            } else if (resultC [j + 2].toUpperCase ().startsWith ("B")) {
                                c = a / b;
                            } else {
                                System.out.println ("Argument parse error");
                            }

                        }

                    } else if (resultC [j].toUpperCase ().startsWith ("B")) {
                        if (resultC [j + 1].equals ("+")) {
                            if (resultC [j + 2].toUpperCase ().startsWith ("A")) {
                                c = b + a;
                                break;
                            } else if (resultC [j + 2].toUpperCase ().startsWith ("B")) {
                                c = b + b;
                                break;
                            } else {
                                System.out.println ("Argument parse error");
                            }

                        } else if (resultC [j + 1].equals ("-")) {
                            if (resultC [j + 2].toUpperCase ().startsWith ("A")) {
                                c = b - a;
                                break;
                            } else if (resultC [j + 2].toUpperCase ().startsWith ("B")) {
                                c = b - b;
                                break;
                            } else {
                                System.out.println ("Argument parse error");
                            }

                        } else if (resultC [j + 1].equals ("*")) {
                            if (resultC [j + 2].toUpperCase ().startsWith ("A")) {
                                c = b * a;
                                break;
                            } else if (resultC [j + 2].toUpperCase ().startsWith ("B")) {
                                c = b * b;
                                break;
                            } else {
                                System.out.println ("Argument parse error");
                            }

                        } else if (resultC [j + 1].equals ("/")) {
                            if (resultC [j + 2].toUpperCase ().startsWith ("A")) {
                                c = b / a;
                                break;
                            } else if (resultC [j + 2].toUpperCase ().startsWith ("B")) {
                                c = b / b;
                                break;
                            } else {
                                System.out.println ("Argument parse error");
                            }

                        }

                    } else {
                        System.out.println ("Argument error in C");
                        System.exit (1);
                    }

                }
            }

        }
    } else {
        System.out.println ("Invalid number of arguments");
        System.exit (1);
    }
    System.out.printf ("A: %f\nB: %f\nC: %f\n", a, b, c);
}
----------------------------------------

public static void main (String [] args) {
    try {
        ScriptEngineManager mgr = new ScriptEngineManager ();
        ScriptEngine scripEngine = mgr.getEngineByExtension ("js");
        scripEngine.eval ("A=2; B=3; C=A+B");
        System.out.println ("" + scripEngine.get ("A") + "+" + scripEngine.get ("B") + "=" + scripEngine.get ("C"));
    } catch (ScriptException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13666108_13666227_9_18
13666108_13666835_20_30
Title: Customize adapter to use custom font 
----------------------------------------

public View getView (int pos, View convertView, ViewGoup parent) {
    TextView tv;
    tv = (TextView) convertView;
    if (null == tv) {
        tv = new TextView (parent.getContext ());
        tv.setTypeface (mFont);
    }
    tv.setText (getItem (pos));
}
----------------------------------------

public View getView (int position, View convertView, ViewGroup parent) {
    if (convertView == null) {
        convertView = inflater.inflate (resource, parent, false);
    }
    TextView text = (TextView) convertView.findViewById (textViewResourceId);
    text.setTypeface (tf);
    text.setText (objects [position]);
    return convertView;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13671586_13671624_1_11
13671586_13671643_1_11
Title: displaying index array 
----------------------------------------

public static int getMaxValue (int [] values) {
    int maxValue = values [0];
    int position = 0;
    for (int i = 0;
    i < values.length; i ++) {
        if (values [i] > maxValue) {
            maxValue = values [i];
            position = i;
        }
    }
    return position;
}
----------------------------------------

public static SimpleEntry < Integer, Integer > getMaxValue (int [] values) {
    int maxValue = Integer.MIN_VALUE;
    int maxIndex = - 1;
    for (int i = 0;
    i < values.length; i ++) {
        if (values [i] >= maxValue) {
            maxValue = values [i];
            maxIndex = i;
        }
    }
    return new SimpleEntry < Integer, Integer > (maxIndex, maxValue);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13673556_13673634_106_141
13673556_39209818_12_21
Title: Using password-based encryption on a file in Java 
----------------------------------------

public static void decryptFile (String fileName, String pass) throws GeneralSecurityException, IOException {
    byte [] encData;
    byte [] decData;
    File inFile = new File (fileName + ".encrypted");
    Cipher cipher = FileEncryptor.makeCipher (pass, false);
    FileInputStream inStream = new FileInputStream (inFile);
    encData = new byte [(int) inFile.length ()];
    inStream.read (encData);
    inStream.close ();
    decData = cipher.doFinal (encData);
    int padCount = (int) decData [decData.length - 1];
    if (padCount >= 1 && padCount <= 8) {
        decData = Arrays.copyOfRange (decData, 0, decData.length - padCount);
    }
    FileOutputStream target = new FileOutputStream (new File (fileName + ".decrypted.txt"));
    target.write (decData);
    target.close ();
}
----------------------------------------

public static void decryptFile (String inFileName, String outFileName, char [] pass) throws GeneralSecurityException, IOException {
    Cipher cipher = PasswordProtectFile.makeCipher (pass, false);
    try (CipherInputStream cipherInputStream = new CipherInputStream (new FileInputStream (inFileName), cipher); BufferedOutputStream bos = new BufferedOutputStream (new FileOutputStream (outFileName))) {
        int i;
        while ((i = cipherInputStream.read ()) != - 1) {
            bos.write (i);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13673556_13673634_36_60
13673556_39209818_23_44
Title: Using password-based encryption on a file in Java 
----------------------------------------

private static Cipher makeCipher (String pass, Boolean decryptMode) throws GeneralSecurityException {
    PBEKeySpec keySpec = new PBEKeySpec (pass.toCharArray ());
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance ("PBEWithMD5AndDES");
    SecretKey key = keyFactory.generateSecret (keySpec);
    PBEParameterSpec pbeParamSpec = new PBEParameterSpec (salt, 42);
    FileEncryptor.keyToFile (key);
    Cipher cipher = Cipher.getInstance ("PBEWithMD5AndDES");
    if (decryptMode) {
        cipher.init (Cipher.ENCRYPT_MODE, key, pbeParamSpec);
    } else {
        cipher.init (Cipher.DECRYPT_MODE, key, pbeParamSpec);
    }
    return cipher;
}
----------------------------------------

private static Cipher makeCipher (char [] pass, Boolean decryptMode) throws GeneralSecurityException {
    PBEKeySpec keySpec = new PBEKeySpec (pass);
    SecretKeyFactory keyFactory = SecretKeyFactory.getInstance ("PBEWithMD5AndDES");
    SecretKey key = keyFactory.generateSecret (keySpec);
    PBEParameterSpec pbeParamSpec = new PBEParameterSpec (salt, 43);
    Cipher cipher = Cipher.getInstance ("PBEWithMD5AndDES");
    if (decryptMode) {
        cipher.init (Cipher.ENCRYPT_MODE, key, pbeParamSpec);
    } else {
        cipher.init (Cipher.DECRYPT_MODE, key, pbeParamSpec);
    }
    return cipher;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13673556_13673634_64_102
13673556_39209818_1_10
Title: Using password-based encryption on a file in Java 
----------------------------------------

public static void encryptFile (String fileName, String pass) throws IOException, GeneralSecurityException {
    byte [] decData;
    byte [] encData;
    File inFile = new File (fileName);
    Cipher cipher = FileEncryptor.makeCipher (pass, true);
    FileInputStream inStream = new FileInputStream (inFile);
    int blockSize = 8;
    int paddedCount = blockSize - ((int) inFile.length () % blockSize);
    int padded = (int) inFile.length () + paddedCount;
    decData = new byte [padded];
    inStream.read (decData);
    inStream.close ();
    for (int i = (int) inFile.length ();
    i < padded; ++ i) {
        decData [i] = (byte) paddedCount;
    }
    encData = cipher.doFinal (decData);
    FileOutputStream outStream = new FileOutputStream (new File (fileName + ".encrypted"));
    outStream.write (encData);
    outStream.close ();
}
----------------------------------------

public static void encryptFile (String inFileName, String outFileName, char [] pass) throws IOException, GeneralSecurityException {
    Cipher cipher = PasswordProtectFile.makeCipher (pass, true);
    try (CipherOutputStream cipherOutputStream = new CipherOutputStream (new FileOutputStream (outFileName), cipher); BufferedInputStream bis = new BufferedInputStream (new FileInputStream (inFileName))) {
        int i;
        while ((i = bis.read ()) != - 1) {
            cipherOutputStream.write (i);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13675872_13675924_14_68
13675872_13676111_42_64
Title: Not looping through for loop - Java (android) 
----------------------------------------

public void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.questionviewmain);
    Button answer1 = (Button) findViewById (R.id.answer1);
    Button answer2 = (Button) findViewById (R.id.answer2);
    Button answer3 = (Button) findViewById (R.id.answer3);
    Button answer4 = (Button) findViewById (R.id.answer4);
    answer1.setOnClickListener (new OnClickListener () {
        public void onClick (View arg0) {
            if (answer == 0) {
                correctAnswers ++;
            } else {
                wrongAnswers ++;
            }
            reloadQuestion ();
        }}

    );
    answer2.setOnClickListener (new OnClickListener () {
        public void onClick (View arg0) {
            if (answer == 1) {
                correctAnswers ++;
            } else {
                wrongAnswers ++;
            }
            reloadQuestion ();
        }}

    );
    answer3.setOnClickListener (new OnClickListener () {
        public void onClick (View arg0) {
            if (answer == 2) {
                correctAnswers ++;
            } else {
                wrongAnswers ++;
            }
            reloadQuestion ();
        }}

    );
    answer4.setOnClickListener (new OnClickListener () {
        public void onClick (View arg0) {
            if (answer == 3) {
                correctAnswers ++;
            } else {
                wrongAnswers ++;
            }
            reloadQuestion ();
        }}

    );
    reloadQuestion ();
}
----------------------------------------

public void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.questionviewmain);
    TextView question = (TextView) findViewById (R.id.question);
    Button answer1 = (Button) findViewById (R.id.answer1);
    Button answer2 = (Button) findViewById (R.id.answer2);
    Button answer3 = (Button) findViewById (R.id.answer3);
    Button answer4 = (Button) findViewById (R.id.answer4);
    answer1.setId (1);
    answer1.setOnClickListener (clickListener);
    answer2.setId (2);
    answer2.setOnClickListener (clickListener);
    answer3.setId (3);
    answer3.setOnClickListener (clickListener);
    answer4.setId (4);
    answer4.setOnClickListener (clickListener);
    readNextQuestion ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13676874_13676900_6_18
13676874_13676911_5_18
Title: Java compiler can't find my Scanner variable 
----------------------------------------

public static void main (String args []) {
    Scanner scan = null;
    try {
        scan = new Scanner (new java.io.File ("textfile.txt"));
        while (scan != null) {
            String line = scan.nextLine ();
            String [] elements = line.split (",");
        }
    } catch (FileNotFoundException e) {
    }
}
----------------------------------------

public static void main (String args []) {
    try {
        Scanner scan = new Scanner (new java.io.File ("textfile.txt"));
    } catch (FileNotFoundException e) {
    }
    while (scan.hasNext ()) {
        String line = scan.nextLine ();
        String [] elements = line.split (",");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13676874_13676909_6_17
13676874_13676911_5_18
Title: Java compiler can't find my Scanner variable 
----------------------------------------

public static void main (String args []) {
    try {
        Scanner scan = new Scanner (new java.io.File ("textfile.txt"));
        while (scan.hasNext ()) {
            String line = scan.nextLine ();
            String [] elements = line.split (",");
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String args []) {
    try {
        Scanner scan = new Scanner (new java.io.File ("textfile.txt"));
    } catch (FileNotFoundException e) {
    }
    while (scan.hasNext ()) {
        String line = scan.nextLine ();
        String [] elements = line.split (",");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13677451_13677507_3_19
13677451_13677529_3_22
Title: Using while loops how do I calculate a sum between two values up to and including those values? 
----------------------------------------

public static void main (String [] args) {
    Scanner keyboard = new Scanner (System.in);
    System.out.print ("Please type two numbers ");
    int a = keyboard.nextInt ();
    int b = keyboard.nextInt ();
    int sum = 0;
    int s = Math.min (a, b);
    int e = Math.max (a, b);
    while (s <= e) {
        sum += s;
        s ++;
    }
    System.out.print ("The sum of the numbers between " + a + " and " + b + " is " + sum);
}
----------------------------------------

public static void main (String [] args) {
    Scanner keyboard = new Scanner (System.in);
    System.out.print ("Please type two numbers ");
    int a = keyboard.nextInt ();
    int b = keyboard.nextInt ();
    int sum = 0;
    if (a <= b) {
        while (a <= b) {
            sum += a;
            a ++;
        }
    } else if (b <= a) {
        while (b >= a) {
            sum += b;
            b --;
        }
    }

    System.out.print ("The sum of the numbers between " + a + " and " + b + " is " + sum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13689245_14869544_23_41
13689245_43097405_13_31
Title: Use threading to process file chunk by chunk 
----------------------------------------

public static void main (String [] args) {
    List < String > list = new ArrayList < String > ();
    for (int i = 0;
    i < 100; i ++) {
        list.add ("Elem:" + i);
    }
    int divideIndex = list.size () / 2;
    SomeRunnable obj1 = new SomeRunnable (list.subList (0, divideIndex), 1);
    SomeRunnable obj2 = new SomeRunnable (list.subList (divideIndex, list.size ()), 2);
    ExecutorService pool = Executors.newFixedThreadPool (2);
    pool.execute (obj1);
    pool.execute (obj2);
    pool.shutdown ();
}
----------------------------------------

public static void main (String [] args) throws IOException {
    FileProcessThreads fp = new FileProcessThreads ();
    List < List < String > > records = fp.process ("test.txt");
    ExecutorService es = Executors.newFixedThreadPool (5);
    int recordsInEachThread = (int) (records.size () / 5);
    System.out.println (recordsInEachThread);
    MyRunnable my1 = new MyRunnable (records.subList (0, recordsInEachThread));
    MyRunnable my2 = new MyRunnable (records.subList (recordsInEachThread + 1, recordsInEachThread * 2));
    MyRunnable my3 = new MyRunnable (records.subList (recordsInEachThread * 2 + 1, recordsInEachThread * 3));
    MyRunnable my4 = new MyRunnable (records.subList (recordsInEachThread * 3 + 1, recordsInEachThread * 4));
    MyRunnable my5 = new MyRunnable (records.subList (recordsInEachThread * 4 + 1, records.size () - 1));
    es.execute (my1);
    es.execute (my2);
    es.execute (my3);
    es.execute (my4);
    es.execute (my5);
    es.shutdown ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_13692305_1_17
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_17619855_1_25
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_20694360_7_27
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_21553387_1_30
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_23614842_1_32
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_32150902_1_15
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_34943538_1_12
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_42033604_2_21
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692242_1_17
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s2.length (); i ++) {
        if (! s1.contains ("" + s2.charAt (i))) {
            return false;
        }
        s1 = s1.replaceFirst ("" + s2.charAt (i), "");
        s2 = s2.replaceFirst ("" + s2.charAt (i), "");
    }
    return true;
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_17619855_1_25
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_20694360_7_27
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_21553387_1_30
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_23614842_1_32
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_32150902_1_15
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_34943538_1_12
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_42033604_2_21
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_13692305_1_17
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) {
        return false;
    }
    s1 = s1.toLowerCase ();
    s2 = s2.toLowerCase ();
    char [] c1 = s1.toCharArray ();
    char [] c2 = s2.toCharArray ();
    Arrays.sort (c1);
    Arrays.sort (c2);
    String sc1 = new String (c1);
    String sc2 = new String (c2);
    return sc1.equals (sc2);
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_17619855_1_25
13692221_20694360_7_27
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_17619855_1_25
13692221_21553387_1_30
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_17619855_1_25
13692221_23614842_1_32
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_17619855_1_25
13692221_32150902_1_15
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_17619855_1_25
13692221_34943538_1_12
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_17619855_1_25
13692221_42033604_2_21
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_17619855_1_25
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_17619855_1_25
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String a, String b) {
    boolean result = false;
    final String one = a.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    final String two = b.replaceAll ("[\\s+\\W+]", "").toLowerCase ();
    if (one.length () == two.length ()) {
        final char [] oneArray = one.toCharArray ();
        final char [] twoArray = two.toCharArray ();
        Arrays.sort (oneArray);
        Arrays.sort (twoArray);
        result = Arrays.equals (oneArray, twoArray);
    }
    return result;
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_29_41
13692221_33046584_1_26
Title: Anagram algorithm in java 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Enter your string");
    Scanner sc = new Scanner (System.in);
    String word1 = sc.nextLine ();
    String word2 = sc.nextLine ();
    boolean result = isAnagram (word1, word2);
    if (result) {
        System.out.println ("The words are Anagrams");
    } else {
        System.out.println ("The words are not Anagrams");
    }
}
----------------------------------------

public static void main (String [] args) {
    Map < Character, Integer > char_map = new HashMap < Character, Integer > ();
    Map < Character, Integer > empty_map = new HashMap < Character, Integer > ();
    String a = "HelloP";
    String b = "HePlol";
    if (a.length () != b.length ()) {
        System.out.println ("false");
        System.exit (0);
    }
    for (char c : a.toLowerCase ().toCharArray ()) {
        empty_map.put (c, 0);
        if (char_map.containsKey (c)) char_map.put (c, 1 + char_map.get (c));
        else char_map.put (c, 1);

    }
    for (char c : b.toLowerCase ().toCharArray ()) if (char_map.containsKey (c)) char_map.put (c, char_map.get (c) - 1);

    System.out.println (char_map.equals (empty_map));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_29_41
13692221_40062254_5_52
Title: Anagram algorithm in java 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Enter your string");
    Scanner sc = new Scanner (System.in);
    String word1 = sc.nextLine ();
    String word2 = sc.nextLine ();
    boolean result = isAnagram (word1, word2);
    if (result) {
        System.out.println ("The words are Anagrams");
    } else {
        System.out.println ("The words are not Anagrams");
    }
}
----------------------------------------

public static void main (String [] input) {
    String str1, str2;
    int len, len1, len2, i, j, found = 0, not_found = 0;
    Scanner scan = new Scanner (System.in);
    System.out.print ("Enter First String : ");
    str1 = scan.nextLine ();
    System.out.print ("Enter Second String : ");
    str2 = scan.nextLine ();
    len1 = str1.length ();
    len2 = str2.length ();
    if (len1 == len2) {
        len = len1;
        for (i = 0; i < len; i ++) {
            found = 0;
            for (j = 0; j < len; j ++) {
                if (str1.charAt (i) == str2.charAt (j)) {
                    found = 1;
                    break;
                }
            }
            if (found == 0) {
                not_found = 1;
                break;
            }
        }
        if (not_found == 1) {
            System.out.print ("Strings are not Anagram to Each Other..!!");
        } else {
            System.out.print ("Strings are Anagram");
        }
    } else {
        System.out.print ("Both Strings Must have the same number of Character to be an Anagram");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_7_27
13692221_21553387_1_30
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_7_27
13692221_23614842_1_32
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_7_27
13692221_32150902_1_15
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_7_27
13692221_34943538_1_12
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_7_27
13692221_42033604_2_21
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_7_27
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_20694360_7_27
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String word1, String word2) {
    if (word1.length () != word2.length ()) {
        return false;
    }
    int flag = 0;
    HashMap < Character, Integer > table = new HashMap < Character, Integer > ();
    for (int i = 0;
    i < word1.length (); i ++) {
        table.put (word1.charAt (i), 1);
    }
    for (int i = 0;
    i < word2.length (); i ++) {
        if (table.containsKey (word2.charAt (i))) {
            continue;
        } else {
            flag = 1;
            break;
        }
    }
    return flag == 0;
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_21553387_1_30
13692221_23614842_1_32
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_21553387_1_30
13692221_32150902_1_15
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_21553387_1_30
13692221_34943538_1_12
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_21553387_1_30
13692221_42033604_2_21
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_21553387_1_30
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_21553387_1_30
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String leftString, String rightString) {
    if (leftString == null || rightString == null) {
        return false;
    } else if (leftString.length () != rightString.length ()) {
        return false;
    }

    char letters [] = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'};
    Map < Character, Integer > occurrencesMap = new HashMap < > ();
    for (char l : letters) {
        occurrencesMap.put (l, 0);
    }
    for (int i = 0;
    i < leftString.length (); i ++) {
        char charFromLeft = leftString.charAt (i);
        Integer nrOfCharsInLeft = occurrencesMap.get (charFromLeft);
        occurrencesMap.put (charFromLeft, ++ nrOfCharsInLeft);
        char charFromRight = rightString.charAt (i);
        Integer nrOfCharsInRight = occurrencesMap.get (charFromRight);
        occurrencesMap.put (charFromRight, -- nrOfCharsInRight);
    }
    for (Integer occurrencesNr : occurrencesMap.values ()) {
        if (occurrencesNr != 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_23614842_1_32
13692221_32150902_1_15
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_23614842_1_32
13692221_34943538_1_12
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_23614842_1_32
13692221_42033604_2_21
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_23614842_1_32
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_23614842_1_32
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String _source1, String _source2) {
    int flag = 0, char_index = 0, counter = 0;
    if (_source2.length () < _source1.length ()) {
        return false;
    }
    char [] _stringchar = _source1.toCharArray ();
    char [] _tocheck = _source2.toCharArray ();
    for (char character : _stringchar) {
        char_index = character - 'a';
        if ((flag & (1 << char_index)) == 0) flag |= (1 << char_index);

    }
    for (char toCheckcChar : _tocheck) {
        char_index = toCheckcChar - 'a';
        if ((flag & (1 << char_index)) > 0) counter ++;
        else counter = 0;

        if (counter == _source1.length ()) return true;

    }
    return false;
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_32150902_1_15
13692221_34943538_1_12
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_32150902_1_15
13692221_42033604_2_21
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_32150902_1_15
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_32150902_1_15
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

static boolean isAnagram (String s1, String s2) {
    if (s1.length () != s2.length ()) return false;

    int n = s1.length ();
    int [] charMap = new int [256];
    for (int i = 0;
    i < n; i ++) {
        char c1 = s1.charAt (i);
        charMap [c1] ++;
        char c2 = s2.charAt (i);
        charMap [c2] --;
    }
    for (int i = 0;
    i < charMap.length; i ++) {
        if (charMap [i] != 0) return false;

    }
    return true;
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_33046584_1_26
13692221_40062254_5_52
Title: Anagram algorithm in java 
----------------------------------------

public static void main (String [] args) {
    Map < Character, Integer > char_map = new HashMap < Character, Integer > ();
    Map < Character, Integer > empty_map = new HashMap < Character, Integer > ();
    String a = "HelloP";
    String b = "HePlol";
    if (a.length () != b.length ()) {
        System.out.println ("false");
        System.exit (0);
    }
    for (char c : a.toLowerCase ().toCharArray ()) {
        empty_map.put (c, 0);
        if (char_map.containsKey (c)) char_map.put (c, 1 + char_map.get (c));
        else char_map.put (c, 1);

    }
    for (char c : b.toLowerCase ().toCharArray ()) if (char_map.containsKey (c)) char_map.put (c, char_map.get (c) - 1);

    System.out.println (char_map.equals (empty_map));
}
----------------------------------------

public static void main (String [] input) {
    String str1, str2;
    int len, len1, len2, i, j, found = 0, not_found = 0;
    Scanner scan = new Scanner (System.in);
    System.out.print ("Enter First String : ");
    str1 = scan.nextLine ();
    System.out.print ("Enter Second String : ");
    str2 = scan.nextLine ();
    len1 = str1.length ();
    len2 = str2.length ();
    if (len1 == len2) {
        len = len1;
        for (i = 0; i < len; i ++) {
            found = 0;
            for (j = 0; j < len; j ++) {
                if (str1.charAt (i) == str2.charAt (j)) {
                    found = 1;
                    break;
                }
            }
            if (found == 0) {
                not_found = 1;
                break;
            }
        }
        if (not_found == 1) {
            System.out.print ("Strings are not Anagram to Each Other..!!");
        } else {
            System.out.print ("Strings are Anagram");
        }
    } else {
        System.out.print ("Both Strings Must have the same number of Character to be an Anagram");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_34943538_1_12
13692221_42033604_2_21
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_34943538_1_12
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_34943538_1_12
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

public static boolean isAnagram (String str1, String str2) {
    if (str1.length () != str2.length ()) {
        return false;
    }
    int [] buffer = new int [256];
    for (char ch : str1.toCharArray ()) {
        buffer [ch] ++;
    }
    for (char ch : str2.toCharArray ()) {
        if (buffer [ch] == 0) return false;

        buffer [ch] = (buffer [ch] > 0) ? (buffer [ch] - 1) : - 1;
    }
    return true;
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_42033604_2_21
13692221_42892912_1_22
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_42033604_2_21
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

public boolean isAnagram (String left, String right) {
    if (left.length () == right.length ()) {
        Map < Character, Integer > map = new HashMap < > ();
        char [] a = left.toCharArray (), b = right.toCharArray ();
        for (int i = 0;
        i < a.length; i ++) {
            accumulate (map, a [i]);
            accumulate (map, b [i]);
        }
        for (char c : map.keySet ()) {
            if (map.get (c) > 0) {
                return false;
            }
        }
        return true;
    } else {
        return false;
    }
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692221_42892912_1_22
13692221_52659787_5_22
Title: Anagram algorithm in java 
----------------------------------------

private static boolean isAnagram (String s1, String s2) {
    int count = 0;
    boolean flag = false;
    if (s1.length () != s2.length ()) {
        return false;
    }
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < s2.length (); j ++) {
            if (s1.charAt (i) == s2.charAt (j)) {
                count ++;
                break;
            }
        }
    }
    if (count == s2.length ()) {
        flag = true;
    }
    return flag;
}
----------------------------------------

static boolean isAnagram (String a, String b) {
    a = a.toLowerCase ();
    b = b.toLowerCase ();
    if (a.length () != b.length ()) {
        return false;
    }
    char [] chars = a.toCharArray ();
    for (char c : chars) {
        int index = b.indexOf (c);
        if (index != - 1) {
            b = b.substring (0, index) + b.substring (index + 1, b.length ());
        } else {
            return false;
        }
    }
    return b.isEmpty ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13692327_13692541_4_12
13692327_13692762_2_10
Title: In Java finding numbers that are both a Triangle Number and a Star Number 
----------------------------------------

public static void main (String args []) {
    int triangle = 0;
    for (int i = 0;
    triangle >= 0; i ++) {
        triangle = determineTriangleNumber (i, triangle);
        if (isStarNumber (triangle)) {
            System.out.println (triangle);
        }
    }
}
----------------------------------------

public static void main (String...args) {
    final double q2 = Math.sqrt (2);
    out (1);
    int a = 1;
    for (int i = 1;
    a > 0; i ++) {
        a += (12 * i);
        if (x ((int) (Math.sqrt (a) * q2)) == a) out (a);

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13696027_13696114_3_21
13696027_28739741_1_22
Title: Determine how many digits and letters are in a string 
----------------------------------------

public static void main (String args []) {
    Scanner sc = new Scanner (System.in);
    String s = "";
    int firstnum = 0;
    System.out.print ("Enter a string: ");
    s = sc.nextLine ();
    int digitCount = 0, charCount = 0;
    for (int i = 0;
    i < s.length (); i ++) {
        if (s.charAt (i) == ' ') continue;
        else if ((s.charAt (i) >= 'a' && s.charAt (i) <= 'z') || (s.charAt (i) >= 'A' && s.charAt (i) <= 'Z')) charCount ++;
        else if (s.charAt (i) >= '0' && s.charAt (i) <= '9') digitCount ++;

    }
    System.out.println (digitCount + " " + charCount);
}
----------------------------------------

public static void main (String [] args) {
    String str = new String ("Hey123456789234Hey");
    String num = new String ("0123456789");
    int dig_count = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        for (int j = 0;
        j < num.length (); j ++) {
            if (str.charAt (i) == num.charAt (j)) {
                dig_count ++;
            }
        }
    }
    System.out.println ("Total length of String:" + str.length ());
    System.out.println ("Number of digits:" + dig_count);
    System.out.println ("Number of characters:" + (str.length () - dig_count));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13696027_28739741_1_22
13696027_39032274_5_24
Title: Determine how many digits and letters are in a string 
----------------------------------------

public static void main (String [] args) {
    String str = new String ("Hey123456789234Hey");
    String num = new String ("0123456789");
    int dig_count = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        for (int j = 0;
        j < num.length (); j ++) {
            if (str.charAt (i) == num.charAt (j)) {
                dig_count ++;
            }
        }
    }
    System.out.println ("Total length of String:" + str.length ());
    System.out.println ("Number of digits:" + dig_count);
    System.out.println ("Number of characters:" + (str.length () - dig_count));
}
----------------------------------------

public static void main (String args []) {
    Scanner s = new Scanner (System.in);
    String first = "";
    int firstnum = 0;
    System.out.print ("Enter a string: ");
    first = s.nextLine ();
    int numberCount = 0, charCount = 0;
    for (int i = 0;
    i < first.length (); i ++) {
        char c = first.charAt (i);
        if (c == '0' || c == '1' || c == '2' || c == '3' || c == '4' || c == '5' || c == '6' || c == '7' || c == '8' || c == '9') ++ numberCount;
        else ++ charCount;

    }
    System.out.println ("numberCount  :-" + numberCount + "  CharCount   :-" + charCount);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13705431_13705936_1_34
13705431_13706657_1_40
Title: Java 2D array diagonals for game 
----------------------------------------

public static boolean diagonals (char [] [] b, int row, int col, int l) {
    int forwardCounter = 1;
    int backCounter = 1;
    int distance = 1;
    boolean [] checks = new boolean [] {true, true, true, true};
    char charAtPosition = b [row] [col];
    while (checks [0] || checks [1] || checks [2] || checks [3]) {
        for (int i = 0;
        i < 4; i ++) {
            if (checks [i]) {
                checks [i] = checkSquare (b, row + (i < 2 ? - distance : distance), col + (i % 2 == 0 ? - distance : distance), charAtPosition);
                if (checks [i]) {
                    if (i % 3 == 0) {
                        backCounter ++;
                    } else {
                        forwardCounter ++;
                    }
                }
            }
        }
        if (forwardCounter >= l || backCounter >= l) return true;

        distance ++;
    }
    return false;
}
----------------------------------------

public static boolean diagonals (char [] [] b, int row, int col, int l) {
    int counter = 1;
    char charAtPosition = b [row] [col];
    int numRows = b.length;
    int numCols = b [0].length;
    int topleft = 0;
    int topright = 0;
    int bottomleft = 0;
    int bottomright = 0;
    for (int i = row - 1, j = col - 1;
    i >= 0 && j >= 0; i --, j --) {
        if (b [i] [j] == charAtPosition) {
            topleft ++;
        } else {
            break;
        }
    }
    for (int i = row - 1, j = col + 1;
    i >= 0 && j <= numCols; i --, j ++) {
        if (b [i] [j] == charAtPosition) {
            topright ++;
        } else {
            break;
        }
    }
    for (int i = row + 1, j = col - 1;
    i <= numRows && j >= 0; i ++, j --) {
        if (b [i] [j] == charAtPosition) {
            bottomleft ++;
        } else {
            break;
        }
    }
    for (int i = row + 1, j = col + 1;
    i <= numRows && j <= numCols; i ++, j ++) {
        if (b [i] [j] == charAtPosition) {
            bottomright ++;
        } else {
            break;
        }
    }
    return topleft + bottomright + 1 >= l || topright + bottomleft + 1 >= l;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13713257_13713549_1_12
13713257_13716478_10_20
Title: change this to use straight lines? In processing 
----------------------------------------

void spiral_triangle (float len, int startx, int starty, float angle) {
    if (len > 1) {
        float new_len = len - 0.1;
        float new_angle = angle + PI / 100;
        int oldx = int (startx + len * cos (angle));
        int oldy = int (starty + len * sin (angle));
        int newx = int (startx + new_len * cos (new_angle));
        int newy = int (starty + new_len * sin (new_angle));
        line (oldx, oldy, newx, newy);
        spiral_triangle (new_len, startx, starty, new_angle);
    }
}
----------------------------------------

void spiral_triangle (int len, int startx, int starty, float angle) {
    if (len > 1) {
        float [] spacing = {2, 2};
        dashline (startx, starty, int (startx + len * cos (angle)), int (starty + len * sin (angle)), spacing);
        int new_startx = int (startx + len * cos (angle));
        int new_starty = int (starty + len * sin (angle));
        int new_len = len - 10;
        float new_angle = angle + PI / 1.5;
        spiral_triangle (new_len, new_startx, new_starty, new_angle);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13719818_13719974_1_13
13719818_13720016_1_12
Title: Java integer operations 
----------------------------------------

public static void main (String [] args) throws UnsupportedEncodingException {
    int a = 5;
    int b = 3;
    int bLength = Integer.toBinaryString (b).length ();
    System.out.println ("a = " + Integer.toBinaryString (a));
    System.out.println ("b = " + Integer.toBinaryString (b));
    int c = (a << bLength) | b;
    System.out.println ("c = " + Integer.toBinaryString (c));
}
----------------------------------------

public static void main (String [] args) {
    int a = 2;
    int b = 1;
    int c = 2;
    int d = 0;
    int e = 0;
    int f = 0;
    int g = 1;
    System.out.println (g + (f << 4) + (e << 8) + (d << 12) + (c << 16) + (b << 20) + (a << 28));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13725422_23723263_51_61
13725422_23723263_96_116
Title: Future result update UI as soon as they arrive 
----------------------------------------

public void call (final String result) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            listModel.addElement (result);
        }}

    );
}
----------------------------------------

public String call () {
    int delayMS = 250 + random.nextInt (500);
    if (i == 5) {
        delayMS += 3000;
    }
    try {
        System.out.println ("For " + i + " waiting " + delayMS + " ms");
        Thread.sleep (delayMS);
        System.out.println ("For " + i + " waiting " + delayMS + " ms DONE");
    } catch (InterruptedException e) {
        Thread.currentThread ().interrupt ();
    }
    return String.valueOf (i);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13727030_13727332_1_10
13727030_13727872_22_36
Title: Mergesort in java 
----------------------------------------

static int [] mergeSort (int [] A) {
    if (A.length > 1) {
        int q = A.length / 2;
        int [] leftArray = Arrays.copyOfRange (A, 0, q);
        int [] rightArray = Arrays.copyOfRange (A, q + 1, A.length);
        return merge (mergeSort (leftArray), mergeSort (rightArray));
    } else return A;

}
----------------------------------------

static void mergeSort (int [] A) {
    if (A.length > 1) {
        int q = A.length / 2;
        int [] leftArray = Arrays.copyOfRange (A, 0, q - 1);
        int [] rightArray = Arrays.copyOfRange (A, q, A.length - 1);
        mergeSort (leftArray);
        mergeSort (rightArray);
        merge (A, leftArray, rightArray);
    }
}
----------------------------------------
