$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1925813_1925832_1_19
1925813_1925841_1_12
Title: NullreferenceException is unhandled 
----------------------------------------

private void buttonSend_Click (object sender, EventArgs e) {
    try {
        byte [] outStream = System.Text.Encoding.ASCII.GetBytes (textSend.Text + "$");
        serverStream.Write (outStream, 0, outStream.Length);
        serverStream.Flush ();
        textSend.Text = "";
    }
    catch (Exception ex) {
    }
    finally {
    }
}
----------------------------------------

private void buttonSend_Click (object sender, EventArgs e) {
    if (serverStream == null)
        return;

    byte [] outStream = System.Text.Encoding.ASCII.GetBytes (textSend.Text + "$");
    serverStream.Write (outStream, 0, outStream.Length);
    serverStream.Flush ();
    textSend.Text = "";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19260385_19260431_3_22
19260385_19261126_3_16
Title: Override count in treeview nodes c# 
----------------------------------------

public static int CountByText (this TreeView view, string text) {
    int count = 0;
    foreach (TreeNode node in view.Nodes) {
        nodeList.Add (node);
        Get (node);
    }
    foreach (TreeNode node in nodeList) {
        if (node.Text == text) {
            count ++;
        }
    }
    nodeList.Clear ();
    return count;
}
----------------------------------------

public static int CountByText (this TreeNode view, string text) {
    int count = 0;
    foreach (TreeNode node in view.Nodes) {
        if (node.Text == text) {
            count ++;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1927922_1927953_7_30
1927922_1928075_5_49
Title: Reading in files that contain specific characters in C# 
----------------------------------------

public static void Main () {
    string path = @"C:\Test.txt";
    try {
        if (File.Exists (path)) {
            using (StreamReader sr = new StreamReader (path))
            {
                while (sr.Peek () >= 0) {
                    char c = (char) sr.Read ();
                    if (Char.IsNumber (c))
                        Console.Write (c);

                }
            }}
    }
    catch (Exception e) {
        Console.WriteLine ("The process failed: {0}", e.ToString ());
    }
}
----------------------------------------

static void Main (string [] args) {
    var result = new List < int > ();
    using (var reader = new StreamReader (@"c:\test.txt"))
    {
        var readBuffer = new char [ReadBufferSize];
        var buffer = new StringBuilder ();
        while ((reader.Read (readBuffer, 0, readBuffer.Length)) > 0) {
            foreach (char c in readBuffer) {
                if (! char.IsDigit (c)) {
                    int newInt;
                    if (int.TryParse (buffer.ToString (), out newInt)) {
                        result.Add (newInt);
                    }
                    buffer.Remove (0, buffer.Length);
                } else {
                    buffer.Append (c);
                }
            }
        }
        if (buffer.Length > 0) {
            int newInt;
            if (int.TryParse (buffer.ToString (), out newInt)) {
                result.Add (newInt);
            }
        }
    } result.ForEach (Console.WriteLine);
    Console.ReadKey ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19279695_19280301_1_24
19279695_20322709_1_17
Title: Programmatically refreshing session timeout in ASP.NET MVC4 application 
----------------------------------------

protected void Page_Load (object sender, EventArgs e) {
    int timeout = 20;
    var hr = DateTime.Now.Hour;
    var min = DateTime.Now.Minute;
    var time = (hr * 60) + min;
    if (time <= 1080) {
        timeout = 1080 - time;
    }
    if (time > 1080) {
        timeout = (1440 - time) + 1080;
    }
    Session.Timeout = timeout;
}
----------------------------------------

protected void Page_Load (object sender, EventArgs e) {
    int timeout = 20;
    var hour = DataTime.Now.Hour;
    var minutes = DataTime.Now.Minutes;
    var time = (hour * 60) + minutes;
    if (time <= 2000) {
        timeout = 2000 - time;
    }
    if (time > 2000) {
        timeout = (3000 - time) + 2000;
    }
    Session.Timeout = timeout;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933126_1933371_11_24
1933126_1934609_8_21
Title: Powershell Command in C# 
----------------------------------------

static void Main () {
    using (var invoker = new RunspaceInvoke ())
    {
        string command = @"Get-WmiObject -list -namespace root\cimv2" + " | Foreach {$_.Name}";
        Collection < PSObject > results = invoker.Invoke (command);
        var classNames = results.Select (ps = > (string) ps.BaseObject);
        foreach (var name in classNames) {
            Console.WriteLine (name);
        }
    }}
----------------------------------------

static void Main (string [] args) {
    var script = @" 
                Get-WmiObject -list -namespace root\cimv2 | Foreach {$_.Name}
            ";
    var powerShell = PowerShell.Create ();
    powerShell.AddScript (script);
    foreach (var className in powerShell.Invoke ()) {
        Console.WriteLine (className);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19347164_19347210_1_15
19347164_19347234_1_14
Title: Call value from a method inside Main() function 
----------------------------------------

static void Main (string [] args) {
    int myInt = GetInputstring ();
    if (myInt <= 0) {
        Write1 (myInt);
    } else {
        Write2 (myInt);
    }
    Console.ReadKey ();
}
----------------------------------------

static void Main (string [] args) {
    int myInt = GetInputstring ();
    if (myInt <= 0) {
        Write1 (myInt);
    } else {
        Write2 (myInt);
    }
    Console.ReadKey ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1940214_33203934_1_14
1940214_7905390_1_21
Title: How to check if a list is ordered? 
----------------------------------------

public static bool IsAscendingOrder < T > (this IEnumerable < T > seq) where T : IComparable < T > {
    var predecessor = default (T);
    var hasPredecessor = false;
    foreach (var x in seq) {
        if (hasPredecessor && predecessor.CompareTo (x) >= 0)
            return false;

        predecessor = x;
        hasPredecessor = true;
    }
    return true;
}
----------------------------------------

public static bool IsOrderedBy < T, TProperty > (this List < T > list, Expression < Func < T, TProperty > > propertyExpression) where TProperty : IComparable < TProperty > {
    var member = (MemberExpression) propertyExpression.Body;
    var propertyInfo = (PropertyInfo) member.Member;
    IComparable < TProperty > previousValue = null;
    for (int i = 0; i < list.Count (); i ++) {
        var currentValue = (TProperty) propertyInfo.GetValue (list [i], null);
        if (previousValue == null) {
            previousValue = currentValue;
            continue;
        }
        if (previousValue.CompareTo (currentValue) > 0)
            return false;

        previousValue = currentValue;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1940790_1940851_1_11
1940790_1940880_1_13
Title: How can I abandon an IEnumerator without iterating to the end? 
----------------------------------------

static IEnumerable < string > readColors () {
    string [] colors = {"red", "green", "blue"};
    try {
        for (int i = 0; i < colors.Length; i ++) {
            yield return colors [i];
        }
    }
    finally {
        Console.WriteLine ("Cleanup goes here");
    }
}
----------------------------------------

public IEnumerable < string > readColors () {
    try {
        string [] colors = {"red", "green", "blue"};
        for (int i = 0; i < colors.Length; i ++)
            yield return colors [i];

    }
    finally {
        Console.WriteLine ("Cleanup goes here");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19446403_21056870_14_50
19446403_21077805_3_37
Title: Windows MIDI streaming and SysEx 
----------------------------------------

public static void Test () {
    int moID = 0;
    IntPtr moHdl = IntPtr.Zero;
    IntPtr instance = IntPtr.Zero;
    Chk (WinMM.midiStreamOpen (out moHdl, ref moID, 1, null, instance, 0));
    byte [] sx = {0xF0, 0x7E, 0x7F, 0x09, 0x01, 0xF7};
    int shdr = 0x40;
    var mhdr = new MidiHdr ();
    mhdr.bufferLength = mhdr.bytesRecorded = sx.Length;
    mhdr.data = Marshal.AllocHGlobal (mhdr.bufferLength);
    Marshal.Copy (sx, 0, mhdr.data, mhdr.bufferLength);
    IntPtr nhdr = Marshal.AllocHGlobal (shdr);
    Marshal.StructureToPtr (mhdr, nhdr, false);
    Chk (WinMM.midiOutPrepareHeader (moHdl, nhdr, shdr));
    Chk (WinMM.midiOutLongMsg (moHdl, nhdr, shdr));
}
----------------------------------------

public static void Test () {
    int moID = 0;
    IntPtr moHdl = IntPtr.Zero;
    IntPtr instance = IntPtr.Zero;
    Chk (WinMM.midiStreamOpen (out moHdl, ref moID, 1, null, instance, 0));
    byte [] sx = {0xF0, 0x7E, 0x7F, 0x09, 0x01, 0xF7};
    int shdr = Marshal.SizeOf (typeof (MidiHdr));
    IntPtr x = Marshal.OffsetOf (typeof (MidiHdr), "data");
    x = Marshal.OffsetOf (typeof (MidiHdr), "bufferLength");
    x = Marshal.OffsetOf (typeof (MidiHdr), "bytesRecorded");
    x = Marshal.OffsetOf (typeof (MidiHdr), "user");
    x = Marshal.OffsetOf (typeof (MidiHdr), "flags");
    x = Marshal.OffsetOf (typeof (MidiHdr), "next");
    x = Marshal.OffsetOf (typeof (MidiHdr), "reserved");
    x = Marshal.OffsetOf (typeof (MidiHdr), "offset");
    x = Marshal.OffsetOf (typeof (MidiHdr), "reservedArray");
    var mhdr = new MidiHdr ();
    mhdr.bufferLength = mhdr.bytesRecorded = sx.Length;
    mhdr.data = Marshal.AllocHGlobal (mhdr.bufferLength);
    Marshal.Copy (sx, 0, mhdr.data, mhdr.bufferLength);
    IntPtr nhdr = Marshal.AllocHGlobal (shdr);
    Marshal.StructureToPtr (mhdr, nhdr, false);
    Chk (WinMM.midiOutPrepareHeader (moHdl, nhdr, shdr));
    int r = WinMM.midiOutLongMsg (moHdl, nhdr, shdr);
    Chk (r);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19455919_20888893_10_32
19455919_34628875_1_52
Title: How to export large SQL Server table into a CSV file using the FileHelpers library? 
----------------------------------------

public void DumpTableToFile (SqlConnection connection, string tableName, string destinationFile) {
    using (var command = new SqlCommand ("select * from " + tableName, connection))
    using (var reader = command.ExecuteReader ())
    using (var outFile = File.CreateText (destinationFile))
    {
        string [] columnNames = GetColumnNames (reader).ToArray ();
        int numFields = columnNames.Length;
        outFile.WriteLine (string.Join (",", columnNames));
        if (reader.HasRows) {
            while (reader.Read ()) {
                string [] columnValues = Enumerable.Range (0, numFields).Select (i = > reader.GetValue (i).ToString ()).Select (field = > string.Concat ("\"", field.Replace ("\"", "\"\""), "\"")).ToArray ();
                outFile.WriteLine (string.Join (",", columnValues));
            }
        }
    }}
----------------------------------------

public static void DumpTableToFile (SqlConnection connection, Dictionary < string, string > cArgs) {
    string query = "SELECT ";
    string z = "";
    if (cArgs.TryGetValue ("top_count", out z)) {
        query += string.Format ("TOP {0} ", z);
    }
    query += string.Format ("* FROM {0} (NOLOCK) ", cArgs ["table"]);
    string lower_bound = "", upper_bound = "", column_name = "";
    if (cArgs.TryGetValue ("lower_bound", out lower_bound) && cArgs.TryGetValue ("column_name", out column_name)) {
        query += string.Format ("WHERE {0} >= {1} ", column_name, lower_bound);
        if (cArgs.TryGetValue ("upper_bound", out upper_bound)) {
            query += string.Format ("AND {0} < {1} ", column_name, upper_bound);
        }
    }
    Console.WriteLine (query);
    Console.WriteLine ("");
    using (var command = new SqlCommand (query, connection))
    using (var reader = command.ExecuteReader ())
    using (var outFile = File.CreateText (cArgs ["out_file"]))
    {
        string [] columnNames = GetColumnNames (reader).ToArray ();
        int numFields = columnNames.Length;
        Console.WriteLine (string.Join (",", columnNames));
        Console.WriteLine ("");
        if (reader.HasRows) {
            Type datetime_type = Type.GetType ("System.DateTime");
            Type byte_arr_type = Type.GetType ("System.Byte[]");
            string format = "yyyy-MM-dd HH:mm:ss.fff";
            int ii = 0;
            while (reader.Read ()) {
                ii += 1;
                string [] columnValues = Enumerable.Range (0, numFields).Select (i = > reader.GetValue (i).GetType () == datetime_type ? ((DateTime) reader.GetValue (i)).ToString (format) : (reader.GetValue (i).GetType () == byte_arr_type ? String.Concat (Array.ConvertAll ((byte []) reader.GetValue (i), x = > x.ToString ("X2"))) : reader.GetValue (i).ToString ())).Select (field = > field.Replace ("\t", " ")).ToArray ();
                outFile.WriteLine (string.Join ("\t", columnValues));
                if (ii % 100000 == 0) {
                    Console.WriteLine ("row {0}", ii);
                }
            }
        }
    }}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19459583_19461026_19_30
19459583_19461026_32_49
Title: Asyncronous While Loop? 
----------------------------------------

private static IEnumerable < T > Map < T > (SqlDataReader dr) where T : new () {
    var enumerableDataReader = dr.Cast < DbDataRecord > ().AsEnumerable ();
    var tObj = new T ();
    PropertyInfo [] propertyInfo = tObj.GetType ().GetProperties ();
    var batches = enumerableDataReader.Batch (10000);
    var resultCollection = new ConcurrentBag < List < T > > ();
    Parallel.ForEach (batches, batch = > resultCollection.Add (MapThis < T > (propertyInfo, batch)));
    return resultCollection.SelectMany (m = > m.Select (x = > x));
}
----------------------------------------

private static List < T > MapThis < T > (PropertyInfo [] propertyInfo, IEnumerable < DbDataRecord > batch) where T : new () {
    var list = new List < T > ();
    batch.AsParallel ().ForAll (record = > {
        T obj = new T ();
        foreach (PropertyInfo prop in propertyInfo) {
            var dbVal = record [prop.Name];
            if (! Equals (dbVal, DBNull.Value)) {
                prop.SetValue (obj, dbVal, null);
            }
        }
        list.Add (obj);
    });
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19459583_19461026_19_30
19459583_19461026_61_82
Title: Asyncronous While Loop? 
----------------------------------------

private static IEnumerable < T > Map < T > (SqlDataReader dr) where T : new () {
    var enumerableDataReader = dr.Cast < DbDataRecord > ().AsEnumerable ();
    var tObj = new T ();
    PropertyInfo [] propertyInfo = tObj.GetType ().GetProperties ();
    var batches = enumerableDataReader.Batch (10000);
    var resultCollection = new ConcurrentBag < List < T > > ();
    Parallel.ForEach (batches, batch = > resultCollection.Add (MapThis < T > (propertyInfo, batch)));
    return resultCollection.SelectMany (m = > m.Select (x = > x));
}
----------------------------------------

public static IEnumerable < IEnumerable < T > > Batch < T > (this IEnumerable < T > collection, int batchSize) {
    var nextbatch = new List < T > (batchSize);
    if (collection == null) {
        yield break;
    }
    foreach (T item in collection) {
        nextbatch.Add (item);
        if (nextbatch.Count != batchSize) {
            continue;
        }
        yield return nextbatch;
        nextbatch = new List < T > (batchSize);
    }
    if (nextbatch.Count > 0) {
        yield return nextbatch;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19459583_19461026_32_49
19459583_19461026_61_82
Title: Asyncronous While Loop? 
----------------------------------------

private static List < T > MapThis < T > (PropertyInfo [] propertyInfo, IEnumerable < DbDataRecord > batch) where T : new () {
    var list = new List < T > ();
    batch.AsParallel ().ForAll (record = > {
        T obj = new T ();
        foreach (PropertyInfo prop in propertyInfo) {
            var dbVal = record [prop.Name];
            if (! Equals (dbVal, DBNull.Value)) {
                prop.SetValue (obj, dbVal, null);
            }
        }
        list.Add (obj);
    });
    return list;
}
----------------------------------------

public static IEnumerable < IEnumerable < T > > Batch < T > (this IEnumerable < T > collection, int batchSize) {
    var nextbatch = new List < T > (batchSize);
    if (collection == null) {
        yield break;
    }
    foreach (T item in collection) {
        nextbatch.Add (item);
        if (nextbatch.Count != batchSize) {
            continue;
        }
        yield return nextbatch;
        nextbatch = new List < T > (batchSize);
    }
    if (nextbatch.Count > 0) {
        yield return nextbatch;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19475220_19475344_1_13
19475220_19511977_1_19
Title: How to edit Entity which spans over 4 tables 
----------------------------------------

[HttpPost] [ValidateAntiForgeryToken] public ActionResult Edit (DeviceEditViewModel devm) {
    if (ModelState.IsValid) {
        devm.device.CategoryId = devm.SelectedCategory;
        db.Entry (devm.device).State = EntityState.Modified;
        db.SaveChanges ();
        return RedirectToAction ("Index");
    }
    return View (devm);
}
----------------------------------------

[HttpPost] [ValidateAntiForgeryToken] public ActionResult Edit (DeviceEditViewModel editViewModel) {
    if (ModelState.IsValid) {
        Device device = db.Devices.Single (x = > x.Id == editViewModel.dev.Id);
        if (editViewModel.SelectedCategory != null) {
            device.Category = db.Categories.Where (x = > x.ID == editViewModel.SelectedCategory).Select (x = > x).Single ();
        }
        db.Entry (device).State = EntityState.Modified;
        db.Devices.AddOrUpdate (device);
        db.SaveChanges ();
        return RedirectToAction ("Index");
    }
    return View (editViewModel);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1947951_1947994_1_20
1947951_1949265_26_37
Title: The anti-DRY pattern 
----------------------------------------

private void LoadGroup (string option) {
    switch (option.ToUpper ()) {
        case "ALPHA" :
            BindData ("alphaGroup", uxAlphaGrid, FetchInformation (ManagerContext.Current.Group1));
            break;
        case "BRAVO" :
            BindData ("bravoGroup", uxBravoGrid, FetchInformation (ManagerContext.Current.Group2));
            break;
        case "CHARLIE" :
            BindData ("charlieGroup", uxCharlieGrid, FetchInformation (ManagerContext.Current.Group3));
            break;
        case "DELTA" :
            BindData ("deltaTeam", uxDeltaGrid, FetchInformation (ManagerContext.Current.Group4));
            break;
        default :
            break;
    }
}
----------------------------------------

private void LoadGroup (TGroup group, string groupName, TGrid grid) {
    VList < T > returnList = FetchInformation (group);
    if (Session [groupName] != null) {
        List < T > tempList = (List < T >) Session [groupName];
        returnList.AddRange (tempList);
    }
    grid.DataSource = returnList;
    grid.DataBind ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1947951_1948004_1_20
1947951_1949265_26_37
Title: The anti-DRY pattern 
----------------------------------------

private void LoadGroup (string option) {
    switch (option.ToUpper ()) {
        case "ALPHA" :
            BindGroup (ManagerContext.Current.Group1, "alphaGroup", uxAlphaGrid);
            break;
        case "BRAVO" :
            BindGroup (ManagerContext.Current.Group2, "bravoGroup", uxBravoGrid);
            break;
        case "CHARLIE" :
            BindGroup (ManagerContext.Current.Group3, "charlieGroup", uxCharlieGrid);
            break;
        case "DELTA" :
            BindGroup (ManagerContext.Current.Group4, "deltaGroup", uxDeltaGrid);
            break;
        default :
            break;
    }
}
----------------------------------------

private void LoadGroup (TGroup group, string groupName, TGrid grid) {
    VList < T > returnList = FetchInformation (group);
    if (Session [groupName] != null) {
        List < T > tempList = (List < T >) Session [groupName];
        returnList.AddRange (tempList);
    }
    grid.DataSource = returnList;
    grid.DataBind ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1947951_1948004_22_33
1947951_1948045_37_45
Title: The anti-DRY pattern 
----------------------------------------

private void BindGroup (GroupType group, string groupName, GridView grid) {
    VList < T > vList = FetchInformation (group);
    if (Session [groupName] != null) {
        List < T > tempList = (List < T >) Session [groupName];
        vList.AddRange (tempList);
    }
    grid.DataSource = vList;
    grid.DataBind ();
}
----------------------------------------

void BindGroup (Group group, string groupName, Grid grid) {
    VList < T > groupList = FetchInformation (group);
    if (Session [groupName] != null) {
        List < T > tempList = (List < T >) Session [groupName];
        groupList.AddRange (tempList);
    }
    grid.DataSource = groupList;
    grid.DataBind ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19480512_19480564_1_19
19480512_19511994_3_14
Title: How do I convert split string (string array) to double in C#? 
----------------------------------------

static void Main (string [] args) {
    string [] ints = Console.ReadLine ().Split (' ');
    double [] realInts = new Double [ints.Length];
    for (int i = 0; i <= ints.Length; i ++) {
        double val;
        if (Double.TryParse (ints [i], out val)) {
            realInts [i] = val;
        } else {
            realInts [i] = 0;
        }
    }
}
----------------------------------------

public static void Main (String [] args) {
    string [] height = Console.ReadLine ().Split (' ');
    double [] heightInDouble = new Double [height.Length];
    for (int i = 0; i < height.Length; i ++) {
        heightInDouble [i] = Convert.ToDouble (height [i]);
    }
    Console.WriteLine ("Highest: " + heightInDouble.Max () + " Lowest: " + heightInDouble.Min ());
    Console.ReadLine ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19487211_19487705_1_20
19487211_19488033_25_42
Title: sorting many arrays according to a sorted index of an array C# 
----------------------------------------

static void Main (string [] args) {
    int [] a = {120, 60, 50, 40, 30, 20};
    int [] b = {12, 29, 37, 85, 63, 11};
    int [] c = {30, 23, 90, 110, 21, 34};
    var indexes = Enumerable.Range (0, a.Length).OrderBy (i = > a [i]).ToArray ();
    var temp = new int [a.Length];
    foreach (var arr in new [] {a, b, c}) {
        for (int i = 0; i < a.Length; i ++)
            temp [i] = arr [indexes [i]];

        for (int i = 0; i < a.Length; i ++)
            arr [i] = temp [i];

    }
    Console.WriteLine (String.Join (", ", a));
    Console.WriteLine (String.Join (", ", b));
    Console.WriteLine (String.Join (", ", c));
    Console.ReadLine ();
}
----------------------------------------

static void Main (string [] args) {
    int [] a = {120, 60, 50, 40, 30, 20};
    int [] b = {12, 29, 37, 85, 63, 11};
    int [] c = {30, 23, 90, 110, 21, 34};
    int [,] a_index = {{120, 0}, {60, 1}, {50, 2}, {40, 3}, {30, 4}, {20, 5}};
    Array.Sort (a);
    b = Sort_by_index (b, a, a_index);
    c = Sort_by_index (c, a, a_index);
    Console.WriteLine ("Result A");
    Console.WriteLine (string.Join (", ", a));
    Console.WriteLine ("Result B");
    Console.WriteLine (string.Join (", ", b));
    Console.WriteLine ("Result C");
    Console.WriteLine (string.Join (", ", c));
    Console.ReadKey (false);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19507680_19508245_7_23
19507680_19508414_1_21
Title: C# Selecting text in form1 from form2 
----------------------------------------

public void searchText (string searchT) {
    if (searchT != null) {
        if (textBox1.TextLength > 0) {
            if (textBox1.Text.Contains (searchT)) {
                textBox1.Focus ();
                textBox1.SelectionStart = textBox1.Text.IndexOf (searchT);
                textBox1.SelectionLength = searchT.Length;
            }
        }
    }
}
----------------------------------------

private void searchText () {
    if (searchT != null) {
        if (textBox1.TextLength > 0) {
            int index = 0;
            while (index < textBox1.Text.LastIndexOf (searchT)) {
                textBox1.Find (searchT, index, textBox1.TextLength, RichTextBoxFinds.None);
                textBox1.SelectionBackColor = Color.Yellow;
                index = textBox1.Text.IndexOf (searchT, index) + 1;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19534002_19534200_1_21
19534002_19534200_23_68
Title: Export DataTable to Excel File in Webpage 
----------------------------------------

public void ExportToExcel (string strFileName, DataTable dt) {
    try {
        if (dt != null && dt.Rows.Count > 0) {
            GridView gv = new GridView ();
            gv.DataSource = dt;
            gv.DataBind ();
            ExportToExcel (strFileName, gv);
        } else {
            BindScript (this.Page, "excelError", "alert('No Data to Generate Excel !')");
        }
    }
    catch (Exception ex) {
        BindScript (this.Page, "excelError", "alert('Some error occured " + ex.Message + "')");
    }
}
----------------------------------------

private void ExportToExcel (string strFileName, GridView gv) {
    try {
        if (gv.Rows.Count > 0) {
            StringWriter tw = new StringWriter ();
            HtmlTextWriter hw = new HtmlTextWriter (tw);
            gv.RenderControl (hw);
            Response.ContentType = "application/vnd.ms-excel";
            Response.AppendHeader ("Content-Disposition", "attachment; filename=" + strFileName);
            EnableViewState = false;
            Response.Write (tw.ToString ());
            Response.End ();
        } else {
            BindScript (this.Page, "excelError", "alert('No Data to Generate Excel !')");
        }
    }
    catch (Exception ex) {
        BindScript (this.Page, "excelError", "alert('Some error occured " + ex.Message + "')");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19540530_19540697_13_36
19540530_19540718_1_22
Title: How to input in C# 
----------------------------------------

static void Main (string [] args) {
    int ? [] ar = new int ? [10002];
    int ? n = ReadInteger ();
    if (! n.HasValue) {
        Console.WriteLine ("Please input a correct integer");
        return;
    }
    for (int i = 0; i < n.Value; i ++) {
        ar [i] = ReadInteger ();
    }
    for (int i = 0; i < n.Value; i ++) {
        Console.WriteLine (ar [i].HasValue ? ar [i].Value.ToString () : "Incorrect input");
    }
    Console.ReadKey ();
}
----------------------------------------

static void Main (string [] args) {
    int [] ar = new int [10002];
    int n;
    if (int.TryParse (Console.ReadLine (), out n)) {
        int nr;
        for (int i = 0; i < n; i ++) {
            if (int.TryParse (Console.ReadLine (), out nr)) {
                ar [i] = nr;
            }
        }
        for (int i = 0; i < n; i ++) {
            Console.WriteLine (ar [i]);
        }
    }
    Console.ReadKey ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19562954_19563355_1_25
19562954_19563718_1_23
Title: What have I done wrong with this loop? 
----------------------------------------

public static void Main () {
    Console.WriteLine ("Please enter a number ");
    int input;
    string inputString;
    while (input != 0) {
        inputString = Console.ReadLine ();
        if (! int.TryParse (inputString, out input))
            break;

        FizzBuzz fizzbuzz = new FizzBuzz ();
        Console.WriteLine ("IsFizz " + fizzbuzz.IsFizz (input));
        Console.WriteLine ("IsBuzz " + fizzbuzz.IsBuzz (input));
        Console.WriteLine ("IsFizzBuzz " + fizzbuzz.IsFizzBuzz (input));
        Console.WriteLine ("IsPrime " + fizzbuzz.IsPrime (input));
        Console.WriteLine ("Fizz Count total is " + fizzbuzz.TotalFizz ());
        Console.WriteLine ("Buzz Count total is " + fizzbuzz.TotalBuzz ());
        Console.WriteLine ("FizzBuzz Count total is " + fizzbuzz.TotalFizzBuzz ());
        Console.WriteLine ("Prime Count total is " + fizzbuzz.TotalPrime ());
        Console.WriteLine ("Please enter another number or press 0 to exit");
    }
}
----------------------------------------

public static void Main () {
    Console.WriteLine ("Please enter a number ");
    string inputString;
    inputString = Console.ReadLine ();
    int input;
    input = int.Parse (inputString);
    while (input != 0) {
        FizzBuzz fizzbuzz = new FizzBuzz ();
        Console.WriteLine ("IsFizz {0}", fizzbuzz.IsFizz (input));
        Console.WriteLine ("IsBuzz {0}", fizzbuzz.IsBuzz (input));
        Console.WriteLine ("IsFizzBuzz {0}", fizzbuzz.IsFizzBuzz (input));
        Console.WriteLine ("IsPrime {0}", fizzbuzz.IsPrime (input));
        Console.WriteLine ("Fizz Count total is {0}", fizzbuzz.TotalFizz ());
        Console.WriteLine ("Buzz Count total is {0}", fizzbuzz.TotalBuzz ());
        Console.WriteLine ("FizzBuzz Count total is {0}", fizzbuzz.TotalFizzBuzz ());
        Console.WriteLine ("Prime Count total is {0}", fizzbuzz.TotalPrime ());
        Console.WriteLine ("Please enter another number or press 0 to exit");
        inputString = Console.ReadLine ();
        input = int.Parse (inputString);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19567282_19567581_1_29
19567282_22532729_6_27
Title: How do we map a .NET CustomCulture to a resource files 
----------------------------------------

public static void Main () {
    CultureAndRegionInfoBuilder car1 = new CultureAndRegionInfoBuilder ("ru-US", CultureAndRegionModifiers.None);
    car1.LoadDataFromCultureInfo (CultureInfo.CreateSpecificCulture ("ru-RU"));
    car1.LoadDataFromRegionInfo (new RegionInfo ("en-US"));
    car1.CultureEnglishName = "Russian (United States)";
    car1.CultureNativeName = "русский (США)";
    car1.CurrencyNativeName = "Доллар (США)";
    car1.RegionNativeName = "США";
    try {
        car1.Register ();
    }
    catch (InvalidOperationException) {
    }
    CultureInfo ci = CultureInfo.CreateSpecificCulture ("ru-US");
    Thread.CurrentThread.CurrentCulture = ci;
    Console.WriteLine ("Current Culture: {0}", Thread.CurrentThread.CurrentCulture.Name);
    Console.WriteLine ("Writing System: {0}", Thread.CurrentThread.CurrentCulture.TextInfo);
}
----------------------------------------

static void Main () {
    BuildAndRegisterHobbitCulture ();
    const string goodDay = "GoodDay";
    Console.WriteLine ("{0}: {1}", Thread.CurrentThread.CurrentCulture.Name, Resources.ResourceManager.GetString (goodDay));
    SetCulture ("de-DE");
    Console.WriteLine ("{0}: {1}", Thread.CurrentThread.CurrentCulture.Name, Resources.ResourceManager.GetString (goodDay));
    SetCulture ("en-Hobbit");
    Console.WriteLine ("{0}: {1}", Thread.CurrentThread.CurrentCulture.Name, Resources.ResourceManager.GetString (goodDay));
    Console.ReadLine ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19576370_19576371_117_162
19576370_19576371_172_229
Title: PetaPoco - Multiple result set support 
----------------------------------------

private IEnumerable < T > SinglePocoFromIDataReader < T > (int index) {
    if (_reader == null)
        throw new ObjectDisposedException (GetType ().FullName, "The data reader has been disposed");

    if (_consumed)
        throw new InvalidOperationException ("Query results must be consumed in the correct order, and each result can only be consumed once");

    _consumed = true;
    var pd = PocoData.ForType (typeof (T));
    try {
        while (index == _gridIndex) {
            var factory = pd.GetFactory (_command.CommandText, _command.Connection.ConnectionString, 0, _reader.FieldCount, _reader) as Func < IDataReader, T >;
            while (true) {
                T poco;
                try {
                    if (! _reader.Read ())
                        yield break;

                    poco = factory (_reader);
                }
                catch (Exception x) {
                    if (_db.OnException (x))
                        throw;

                    yield break;
                }
                yield return poco;
            }
        }
    }
    finally {
        if (index == _gridIndex) {
            NextResult ();
        }
    }
}
----------------------------------------

private IEnumerable < TRet > MultiPocoFromIDataReader < TRet > (int index, Type [] types, object cb) {
    if (_reader == null)
        throw new ObjectDisposedException (GetType ().FullName, "The data reader has been disposed");

    if (_consumed)
        throw new InvalidOperationException ("Query results must be consumed in the correct order, and each result can only be consumed once");

    _consumed = true;
    try {
        var cmd = _command;
        var r = _reader;
        var factory = MultiPocoFactory.GetFactory < TRet > (types, cmd.Connection.ConnectionString, cmd.CommandText, r);
        if (cb == null)
            cb = MultiPocoFactory.GetAutoMapper (types.ToArray ());

        bool bNeedTerminator = false;
        while (true) {
            TRet poco;
            try {
                if (! r.Read ())
                    break;

                poco = factory (r, cb);
            }
            catch (Exception x) {
                if (_db.OnException (x))
                    throw;

                yield break;
            }
            if (poco != null)
                yield return poco;
            else
                bNeedTerminator = true;

        }
        if (bNeedTerminator) {
            var poco = (TRet) (cb as Delegate).DynamicInvoke (new object [types.Length]);
            if (poco != null)
                yield return poco;
            else
                yield break;

        }
    }
    finally {
        if (index == _gridIndex) {
            NextResult ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19577520_19577665_11_38
19577520_23458508_1_30
Title: Loading data from List Box to Picture Box 
----------------------------------------

private void getPictures () {
    string [] filters = {"*.jpg", "*.jpeg", "*.png", "*.gif", "*.bmp"};
    var directory = new DirectoryInfo (@"C:\Users\Public\Pictures\Sample Pictures");
    var files = new List < FileInfo > ();
    foreach (var filter in filters) {
        var results = directory.GetFiles (filter, SearchOption.AllDirectories);
        files.AddRange (results);
    }
    foreach (var file in files) {
        listBox1.Items.Add (file);
    }
}
----------------------------------------

private void getPictures () {
    string [] filters = {"*.jpg", "*.jpeg", "*.png", "*.gif", "*.bmp"};
    string resulPath = "";
    var dialog = new FolderBrowserDialog ();
    var result = dialog.ShowDialog ();
    if (result == DialogResult.OK) {
        string path = dialog.SelectedPath;
        resulPath = path;
    }
    var directory = new DirectoryInfo (@"" + resulPath + "");
    var files = new List < FileInfo > ();
    foreach (var filter in filters) {
        var results = directory.GetFiles (filter, SearchOption.AllDirectories);
        files.AddRange (results);
    }
    foreach (var file in files) {
        listBox1.Items.Add (file);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19581089_19581361_1_22
19581089_19581625_1_48
Title: C# Checking users input before placing it into an array 
----------------------------------------

static void Main (string [] args) {
    int [] arr = new int [10];
    int count = 0;
    int a;
    do
        {
            if (int.TryParse (Console.ReadLine (), out a)) {
                if ((a > 10) && (a < 100)) {
                    if (! arr.Contains (a)) {
                        arr [count] = a;
                        count ++;
                    }
                }
            }
        } while (count < 10);
    Console.ReadLine ();
}
----------------------------------------

static void Main (string [] args) {
    int [] arr = new int [10];
    int input;
    int savedNumCount = 0;
    const int MIN = 10;
    const int MAX = 100;
    Console.WriteLine ("Please enter 10 numbers between 10 and 100. They cannot be identical.");
    do
        {
            if (int.TryParse (Console.ReadLine (), out input) == false) {
                Console.WriteLine ("Please enter a number.");
                continue;
            }
            if (input < MIN || input > MAX) {
                Console.WriteLine ("The number you entered does not fall between 10 and 100.\r\n Please try again.");
                continue;
            }
            if (savedNumCount == 0) {
                arr [savedNumCount] = input;
                savedNumCount ++;
            } else {
                if (! arr.Contains (input)) {
                    arr [savedNumCount] = input;
                    savedNumCount ++;
                } else {
                    Console.WriteLine ("The number you entered is identical to one of the other numbers. Please try again");
                }
            }
        } while (savedNumCount < arr.Length);
    string result = "The numbers you entered were ";
    foreach (int num in arr)
        result += num.ToString () + "  ";

    Console.WriteLine (result);
    Console.WriteLine ("Please press enter to continue");
    Console.ReadKey ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19583497_19633250_1_27
19583497_19652325_1_24
Title: Problems in DropDownList with updatepanel 
----------------------------------------

protected void Page_Load (object sender, EventArgs e) {
    if (! IsPostBack) {
        if (Session ["admin"] == null)
            Response.Redirect ("Login.aspx");
        else {
            lblAdmin.Text = "Welcome " + Session ["admin"].ToString ();
            ddlHotel.Items.Clear ();
            ddlHotel.Items.Add (new ListItem ("Select Hotel", ""));
            ddlHotel.AppendDataBoundItems = true;
            ddlHotel.DataSource = bll.getHotel ();
            ddlHotel.DataTextField = "HName";
            ddlHotel.DataValueField = "HotelID";
            ddlHotel.DataBind ();
            if (Session ["hotelID"] == null)
                ddlHotel.SelectedIndex = 0;
            else
                ddlHotel.SelectedValue = Session ["hotelID"].ToString ();

            ddlHotel_SelectedIndexChanged (null, null);
        }
    }
}
----------------------------------------

protected void Page_Load (object sender, EventArgs e) {
    if (Session ["admin"] != null) {
        lblAdmin.Text = "Wel Come " + Session ["admin"].ToString ();
    } else {
        Response.Redirect ("Login.aspx");
    }
    if (! Page.IsPostBack) {
        if (Session ["hotelID"] != null) {
            ddlHotel.SelectedValue = Session ["hotelID"].ToString ();
        }
        ddlHotel.DataSource = bll.getHotel ();
        ddlHotel.DataTextField = "HName";
        ddlHotel.DataValueField = "HotelID";
        ddlHotel.DataBind ();
        ddlHotel.Items.Insert (0, "Select Hotel");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19590734_19591442_1_21
19590734_19591696_1_15
Title: How to generalize functions returning either a Dictionary or a List 
----------------------------------------

public C Read < C, T > (Func < SqlConnection, SqlDataReader > func, Action < C, T > a) where C : ICollection, new () where T : EntityBase, new () {
    C objects = new C ();
    using (SqlConnection connection = GetConnection ())
    {
        using (SqlDataReader reader = func (connection))
        {
            while (reader.Read ()) {
                T obj = new T ();
                obj.PopulateFromReader (reader);
                a (objects, obj);
            }
        }} return objects;
}
----------------------------------------

static T Temp < T > (params object [] obj) where T : ICollection, new () {
    T s = new T ();
    if (s is IDictionary) {
        ((IDictionary) s).Add (obj [0], obj [1]);
    } else if (s is IList) {
        ((IList) s).Add (obj [0]);
    }
    return s;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19604058_19606065_30_75
19604058_31264387_1_30
Title: "Linked In current-status update in c# Getting Error (401) Unauthorized" 
----------------------------------------

protected void Page_Load (object sender, EventArgs e) {
    string url = getAuthorizationURL ();
    if (Request.QueryString ["code"] == null) {
        Response.Redirect (url, true);
    } else {
        code = Request.QueryString ["code"];
        String response = WebRequest (Method.GET, getAccessToeknURL (), "");
        JObject jobj = JObject.Parse (response);
        AccessToken = jobj ["access_token"].ToString ();
        response = WebRequest (Method.GET, linkedInPeapleURL + "?oauth2_access_token=" + AccessToken, "");
    }
}
----------------------------------------

protected void Page_Load (object sender, EventArgs e) {
    var config = LinkedInApiConfiguration.FromAppSettings ("LogiDemo.LinkedInConnect");
    var api = new LinkedInApi (config);
    var scope = AuthorizationScope.ReadBasicProfile | AuthorizationScope.ReadEmailAddress;
    var state = Guid.NewGuid ().ToString ();
    var redirectUrl = "http://localhost:49965/WebForm1.aspx";
    var url = api.OAuth2.GetAuthorizationUrl (scope, state, redirectUrl);
    Response.Redirect (url.OriginalString);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19618764_19619850_1_18
19618764_19628164_1_15
Title: C# SAPI - Recognizing phrases without pre-defined condition statements 
----------------------------------------

void Engine_SpeechRecognized (object sender, SpeechRecognizedEventsArgs e) {
    var commands = new Dictionary < string, Action < string > > ();
    commands.Add ("search google", (arg) = > {
        Search (arg);
    });
    commands.Add ("open application", (arg) = > {
        OpenApp ("https://www.google.com/#q=" + arg);
    });
    foreach (var command in commands.Keys) {
        if (e.Result.Text.StartsWith (command)) {
            Action (command, e.Result.Text, commands [command]);
        }
    }
}
----------------------------------------

void Engine_SpeechRecognized (object sender, SpeechRecognizedEventArgs e) {
    txtSpeech.Text = e.Result.Text;
    ExtractKeywords (e.Result.Text);
    if (e.Result.Grammar.Name.Equals ("Google Search")) {
        OpenApp ("www.google.com", result);
    } else if (e.Result.Grammar.Name.Equals ("StackOverflow Search")) {
        OpenApp ("www.stackoverflow.com", result);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19625495_19625937_1_25
19625495_19626105_2_20
Title: itoa conversion in C# 
----------------------------------------

static string itoa (int n) {
    char [] result = new char [11];
    int index = result.Length;
    bool sign = n < 0;
    do
        {
            int digit = n % 10;
            if (sign) {
                digit = - digit;
            }
            result [-- index] = (char) ('0' + digit);
            n /= 10;
        } while (n != 0);
    if (sign) {
        result [-- index] = '-';
    }
    return new string (result, index, result.Length - index);
}
----------------------------------------

public static String itoa (int n, int radix) {
    if (0 == n)
        return "0";

    var index = 10;
    var buffer = new char [1 + index];
    var xlat = "0123456789abcdefghijklmnopqrstuvwxyz";
    for (int r = Math.Abs (n), q; r > 0; r = q) {
        q = Math.DivRem (r, radix, out r);
        buffer [index -= 1] = xlat [r];
    }
    if (n < 0) {
        buffer [index -= 1] = '-';
    }
    return new String (buffer, index, buffer.Length - index);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19626050_19626130_1_36
19626050_19626173_17_48
Title: C# Invalid Syntax Errors 
----------------------------------------

public void BeginTesting () {
    for (int i = 1; i <= 100; i ++) {
        var results = string.Empty;
        if (i % 9 == 0) {
            results = "Fizz";
            TotalFizz ++;
        }
        if (i % 13 == 0) {
            results = "Buzz";
            TotalBuzz ++;
        }
        if (i % 9 == 0 && i % 13 == 0) {
            results = "FizzBuzz";
            TotalFizzBuzz ++;
        }
        if (string.IsNullOrEmpty (results)) {
            Console.WriteLine (i.ToString ());
        }
        Console.WriteLine (results);
    }
}
----------------------------------------

private static void BeginTesting () {
    for (int i = 1; i <= 100; i ++) {
        if (isDivisibleBy (i, 9)) {
            Console.WriteLine ("Fizz");
        } else if (isDivisibleBy (i, 13)) {
            Console.WriteLine ("Buzz");
        } else if (isDivisibleBy (i, 9) && isDivisibleBy (i, 13)) {
            Console.WriteLine ("FizzBuzz");
        } else {
            Console.WriteLine (i);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19631087_19631352_1_24
19631087_19631413_1_22
Title: Determine if an int is among a list or a range 
----------------------------------------

public bool IsInPattern (int inputToTest, string pattern) {
    var numbers = new List < int > ();
    var tokens = pattern.Split (new [] {",", " ", "or"}, StringSplitOptions.RemoveEmptyEntries);
    bool to_flag = false;
    foreach (var t in tokens) {
        int n;
        if (Int32.TryParse (t, out n)) {
            if (to_flag)
                numbers.AddRange (Enumerable.Range (numbers.Last () + 1, n - numbers.Last ()));
            else
                numbers.Add (n);

            to_flag = false;
        } else if (t == "to")
            to_flag = true;
        else
            throw new Exception ("invalid pattern");

    }
    return numbers.Contains (inputToTest);
}
----------------------------------------

public bool IsInPattern (int inputToTest, string pattern) {
    if (pattern.Contains (","))
        return pattern.Split (',').Contains (inputToTest.ToString ());
    else {
        var temp = pattern.Split (';');
        if (temp.Contains (inputToTest.ToString ()))
            return true;
        else {
            temp = temp.RemoveAll (x = > ! x.Contains ("-"));
            foreach (var x in temp) {
                string [] a = x.Split ("-").Select (x = > x.Trim ('[', ']')).ToArray ();
                if (IsInRange (inputToTest, int.Parse (a [0]), int.Parse (a [1])))
                    return true;

            }
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19645996_19647483_11_32
19645996_19648150_85_104
Title: Calling methods or properties of objects in List 
----------------------------------------

static void Main (string [] args) {
    Player one = new Player (25);
    Player two = new Player (50);
    List < DebugTuple > calls = new List < DebugTuple > ();
    calls.Add (new DebugTuple ("Player 1 health", delegate () {
        return one.x.ToString ();
    }));
    calls.Add (new DebugTuple ("Player 2 health", delegate () {
        return two.x.ToString ();
    }));
    foreach (DebugTuple c in calls)
        Console.WriteLine (c.Item1 + ": " + c.Item2 ());

    one.x = 100;
    two.x = 0;
    foreach (DebugTuple c in calls)
        Console.WriteLine (c.Item1 + ": " + c.Item2 ());

    Console.ReadLine ();
}
----------------------------------------

public static void Main (string [] args) {
    Player t = new Player ();
    t.Name = "Chuck Norris";
    t.Health = int.MaxValue;
    DebugExtensions.DebugList.Add (t);
    DebugExtensions.Print ();
    t.Health = 0;
    DebugExtensions.Print ();
    Console.ReadLine ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19673502_46379633_14_47
19673502_47141701_1_17
Title: How to Convert datarow to an Object 
----------------------------------------

public static void SetItemFromRow < T > (T item, DataRow row) where T : new () {
    foreach (DataColumn c in row.Table.Columns) {
        PropertyInfo p = item.GetType ().GetProperty (c.ColumnName);
        if (p != null && row [c] != DBNull.Value) {
            if (p.PropertyType.Name == "Int64") {
                p.SetValue (item, long.Parse (row [c].ToString ()), null);
            } else if (p.PropertyType.Name == "Int32") {
                p.SetValue (item, int.Parse (row [c].ToString ()), null);
            } else if (p.PropertyType.FullName.StartsWith ("System.Nullable`1[[System.Int32")) {
                p.SetValue (item, (int ?) int.Parse (row [c].ToString ()), null);
            } else if (p.PropertyType.FullName.StartsWith ("System.Nullable`1[[System.Int64")) {
                p.SetValue (item, (long ?) long.Parse (row [c].ToString ()), null);
            } else {
                p.SetValue (item, row [c], null);
            }
        }
    }
}
----------------------------------------

public static T ToObject < T > (this DataRow dataRow) where T : new () {
    T item = new T ();
    foreach (DataColumn column in dataRow.Table.Columns) {
        PropertyInfo property = item.GetType ().GetProperty (column.ColumnName);
        if (property != null && dataRow [column] != DBNull.Value) {
            object result = Convert.ChangeType (dataRow [column], property.PropertyType);
            property.SetValue (item, result, null);
        }
    }
    return item;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19673502_46379633_14_47
19673502_52545950_1_22
Title: How to Convert datarow to an Object 
----------------------------------------

public static void SetItemFromRow < T > (T item, DataRow row) where T : new () {
    foreach (DataColumn c in row.Table.Columns) {
        PropertyInfo p = item.GetType ().GetProperty (c.ColumnName);
        if (p != null && row [c] != DBNull.Value) {
            if (p.PropertyType.Name == "Int64") {
                p.SetValue (item, long.Parse (row [c].ToString ()), null);
            } else if (p.PropertyType.Name == "Int32") {
                p.SetValue (item, int.Parse (row [c].ToString ()), null);
            } else if (p.PropertyType.FullName.StartsWith ("System.Nullable`1[[System.Int32")) {
                p.SetValue (item, (int ?) int.Parse (row [c].ToString ()), null);
            } else if (p.PropertyType.FullName.StartsWith ("System.Nullable`1[[System.Int64")) {
                p.SetValue (item, (long ?) long.Parse (row [c].ToString ()), null);
            } else {
                p.SetValue (item, row [c], null);
            }
        }
    }
}
----------------------------------------

public static T ToObject < T > (this DataRow dataRow) where T : new () {
    T item = new T ();
    foreach (DataColumn column in dataRow.Table.Columns) {
        if (dataRow [column] != DBNull.Value) {
            PropertyInfo prop = item.GetType ().GetProperty (column.ColumnName);
            if (prop != null) {
                object result = Convert.ChangeType (dataRow [column], prop.PropertyType);
                prop.SetValue (item, result, null);
                continue;
            } else {
                FieldInfo fld = item.GetType ().GetField (column.ColumnName);
                if (fld != null) {
                    object result = Convert.ChangeType (dataRow [column], fld.FieldType);
                    fld.SetValue (item, result);
                }
            }
        }
    }
    return item;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19673502_47141701_1_17
19673502_52545950_1_22
Title: How to Convert datarow to an Object 
----------------------------------------

public static T ToObject < T > (this DataRow dataRow) where T : new () {
    T item = new T ();
    foreach (DataColumn column in dataRow.Table.Columns) {
        PropertyInfo property = item.GetType ().GetProperty (column.ColumnName);
        if (property != null && dataRow [column] != DBNull.Value) {
            object result = Convert.ChangeType (dataRow [column], property.PropertyType);
            property.SetValue (item, result, null);
        }
    }
    return item;
}
----------------------------------------

public static T ToObject < T > (this DataRow dataRow) where T : new () {
    T item = new T ();
    foreach (DataColumn column in dataRow.Table.Columns) {
        if (dataRow [column] != DBNull.Value) {
            PropertyInfo prop = item.GetType ().GetProperty (column.ColumnName);
            if (prop != null) {
                object result = Convert.ChangeType (dataRow [column], prop.PropertyType);
                prop.SetValue (item, result, null);
                continue;
            } else {
                FieldInfo fld = item.GetType ().GetField (column.ColumnName);
                if (fld != null) {
                    object result = Convert.ChangeType (dataRow [column], fld.FieldType);
                    fld.SetValue (item, result);
                }
            }
        }
    }
    return item;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19681374_19748560_3_31
19681374_19757023_3_14
Title: MEF RegistrationBuilder export specific Interface implementation 
----------------------------------------

static void Main () {
    var catalog = new AssemblyCatalog (typeof (Program).Assembly);
    var filteredCatalog = catalog.Filter (p = > {
        var type = ReflectionModelServices.GetPartType (p).Value;
        return typeof (IClass).IsAssignableFrom (type) && Attribute.IsDefined (type, typeof (ExportMetadataAttribute)) && type.GetCustomAttributes (typeof (ExportMetadataAttribute), true).Any (ca = > {
            var ema = (ExportMetadataAttribute) ca;
            return ema.Name == "Type" && (MyClassType) ema.Value == MyClassType.TypeA;
        });
    });
    var container = new CompositionContainer (filteredCatalog);
    MyClassConsumer mcc = new MyClassConsumer ();
    container.ComposeParts (mcc);
    Console.WriteLine ("Imported property's type: {0}", mcc.MyClass.GetType ());
    Console.ReadLine ();
}
----------------------------------------

private static void Main (string [] args) {
    var registrationBuilder = new RegistrationBuilder ();
    registrationBuilder.ForTypesMatching < IClass > (t = > FilterOnMetadata (t, MyClassType.TypeOne)).ExportInterfaces ();
    var assemblyCatalog = new AssemblyCatalog (typeof (MyClassType).Assembly, registrationBuilder);
    var compositionContainer = new CompositionContainer (assemblyCatalog);
    var ic = new TestImportContainer ();
    compositionContainer.ComposeParts (ic);
    var count = ic.ImportedParts.Count ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19694977_19695027_1_20
19694977_40838305_1_14
Title: How do you shift an array of objects while wrapping without iteration? 
----------------------------------------

private static T [] WrapAround < T > (T [] arr, int amount) {
    var newArr = new T [arr.Length];
    while (amount > 1) {
        for (var i = 0; i < arr.Length; i ++) {
            if (i != 0) {
                newArr [i] = arr [i - 1];
            }
            if (i == 0) {
                newArr [i] = arr [arr.Length - 1];
            }
        }
        arr = (T []) newArr.Clone ();
        amount --;
    }
    return newArr;
}
----------------------------------------

void Rotate < T > (T [] array, int offset) {
    if (offset == 0)
        return;

    if (offset > 0) {
        var temp = new T [offset];
        System.Array.Copy (array, array.Length - offset, temp, 0, offset);
        System.Array.Copy (array, 0, array, offset, array.Length - offset);
        System.Array.Copy (temp, 0, array, 0, offset);
    } else {
        var temp = new T [- offset];
        System.Array.Copy (array, 0, temp, 0, - offset);
        System.Array.Copy (array, - offset, array, 0, array.Length + offset);
        System.Array.Copy (temp, 0, array, array.Length + offset, - offset);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19707923_19708189_71_80
19707923_19708189_82_94
Title: How to prevent an assembly from loading when not used 
----------------------------------------

public object CreateInstance (string typeName) {
    if (! m_addIns.ContainsKey (typeName))
        throw new ArgumentException (string.Format (CultureInfo.CurrentCulture, "Type {0} was not loaded..", typeName), "typeName");

    MethodInfo method = m_addIns [typeName].GetMethod ("GetInstance", BindingFlags.Static | BindingFlags.Public | BindingFlags.Instance | BindingFlags.FlattenHierarchy);
    if (method != null)
        return method.Invoke (m_addIns [typeName], null);
    else
        return Activator.CreateInstance (m_addIns [typeName]);

}
----------------------------------------

public object CreateInstance (Type type) {
    if (type == null)
        throw new ArgumentNullException ("type", "Type is null");

    if (! m_addIns.ContainsKey (type.FullName))
        throw new ArgumentException (string.Format (CultureInfo.CurrentCulture, "Type {0} was not loaded..", type.FullName), "type");

    MethodInfo method = type.GetMethod ("GetInstance", BindingFlags.Static | BindingFlags.Public | BindingFlags.Instance | BindingFlags.FlattenHierarchy);
    if (method != null)
        return method.Invoke (type, null);
    else
        return Activator.CreateInstance (type);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19757992_39622975_1_13
19757992_52789678_1_12
Title: How do I check if my array has repeated values inside it? 
----------------------------------------

public static bool HasDuplicates < T > (IList < T > items) {
    Dictionary < T, bool > map = new Dictionary < T, bool > ();
    for (int i = 0; i < items.Count; i ++) {
        if (map.ContainsKey (items [i])) {
            return true;
        }
        map.Add (items [i], true);
    }
    return false;
}
----------------------------------------

public static bool HasDuplicate < T > (this IEnumerable < T > source, IEqualityComparer < T > comparer) {
    if (source == null)
        throw new ArgumentException (nameof (source));

    HashSet < T > set = new HashSet < T > (comparer);
    foreach (var item in source)
        if (! set.Add (item))
            return true;

    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19781576_19781706_16_39
19781576_19782062_16_54
Title: Keypress detection wont work after seemingly unrelated code change 
----------------------------------------

public bool CheckInput (Keys key, int checkType) {
    KeyboardState newState = Keyboard.GetState ();
    bool retType = false;
    var debug_new = newState.IsKeyDown (key);
    var debug_old = oldState.IsKeyDown (key);
    if (checkType == 0) {
        retType = newState.IsKeyDown (key);
    } else if (checkType == 1 && newState.IsKeyDown (key)) {
        retType = ! oldState.IsKeydown (key);
    }
    oldState = newState;
    return retType;
}
----------------------------------------

public bool CheckInput (Keys key, int checkType) {
    KeyboardState newState = Keyboard.GetState ();
    bool retType = false;
    if (checkType == 0) {
        if (newState.IsKeyDown (key)) {
            retType = true;
        } else {
            retType = false;
        }
    } else if (checkType == 1) {
        if (newState.IsKeyDown (key)) {
            if (! oldState.IsKeyDown (key)) {
                retType = true;
            } else {
                retType = false;
            }
        }
    }
    return retType;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1978528_1978593_35_48
1978528_1978593_51_67
Title: every forms should be closed but not mainform 
----------------------------------------

public void Subscribe < TEventArgs > (IListener listener) {
    if (_listeners.ContainsKey (typeof (TEventArgs))) {
        _listeners [typeof (TEventArgs)].Add (listener);
    } else {
        List < IListener > newListenerList = new List < IListener > ();
        newListenerList.Add (listener);
        _listeners.Add (typeof (TEventArgs), newListenerList);
    }
}
----------------------------------------

public void CancelSubscription < TEventArgs > (IListener listener) {
    Type eventArgsType = typeof (TEventArgs);
    if (_listeners.ContainsKey (eventArgsType)) {
        for (int i = _listeners [eventArgsType].Count - 1; i > - 1; i --) {
            if (ReferenceEquals (_listeners [eventArgsType] [i], listener)) {
                _listeners [eventArgsType].RemoveAt (i);
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19801706_19856413_15_34
19801706_19856413_1_13
Title: Focus handling for async behaviour - do not steal already set focus 
----------------------------------------

public static T GetChild < T > (this DependencyObject parent) where T : DependencyObject {
    if (parent == null)
        return null;

    T result = null;
    var childrenCount = VisualTreeHelper.GetChildrenCount (parent);
    for (var i = 0; i < childrenCount; i ++) {
        var childObject = VisualTreeHelper.GetChild (parent, i);
        var child = childObject as T;
        if (child == null)
            result = childObject.GetChild < T > ();
        else {
            result = (T) childObject;
            break;
        }
    }
    return result;
}
----------------------------------------

public static T GetParent < T > (this DependencyObject child) where T : DependencyObject {
    if (child == null)
        return null;

    var parentObject = VisualTreeHelper.GetParent (child);
    if (parentObject == null)
        return null;

    var parent = parentObject as T;
    return parent ?? GetParent < T > (parentObject);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19811301_19811557_19_28
19811301_19811557_3_17
Title: Merge two objects during serialization using json.net? 
----------------------------------------

private void WriteJson (JsonWriter writer, JObject value) {
    foreach (var p in value.Properties ()) {
        if (p.Value is JObject)
            WriteJson (writer, (JObject) p.Value);
        else
            p.WriteTo (writer);

    }
}
----------------------------------------

public override void WriteJson (JsonWriter writer, object value, JsonSerializer serializer) {
    JToken t = JToken.FromObject (value);
    if (t.Type != JTokenType.Object) {
        t.WriteTo (writer);
        return;
    }
    JObject o = (JObject) t;
    writer.WriteStartObject ();
    WriteJson (writer, o);
    writer.WriteEndObject ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19811754_19812170_3_26
19811754_19812939_9_28
Title: "Automated traversal C#" 
----------------------------------------

public static U SafeCast < T, U > (this T obj, Expression < Func < T, object > > memberExpression, U defaultValue) where T : class where U : class {
    if (obj == null) {
        return defaultValue;
    }
    var me = memberExpression.Body as MemberExpression;
    if (me == null) {
        throw new ArgumentException ("memberExpression must be MemberExpression");
    }
    var memberValue = obj.GetType ().GetProperty (me.Member.Name).GetValue (obj) as U;
    if (memberValue != null) {
        return memberValue;
    }
    return defaultValue;
}
----------------------------------------

public static T Traverse < T > (dynamic obj, Step [] steps) {
    dynamic current = obj;
    for (int i = 0; i < steps.Length; i ++) {
        if (current == null)
            return default (T);

        dynamic next = steps [i].Path (current);
        if (next.GetType () != steps [i].ExpectedType)
            return default (T);

        current = next;
    }
    if (current.GetType () == typeof (T))
        return (T) current;
    else
        return default (T);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19813785_19813884_1_11
19813785_19814135_1_12
Title: Windows Forms Application which doesn't start with form 
----------------------------------------

static void Main () {
    Application.EnableVisualStyles ();
    Application.SetCompatibleTextRenderingDefault (false);
    var someObject = SomeFactory.Fetch (someCriteria);
    if (someObject.SomeValue)
        Application.Run (new FormForValueBeingSet ());
    else
        Application.Run (new FormForValueNotBeingSet ());

}
----------------------------------------

static void Main () {
    DateTime now = DateTime.Now;
    DateTime tomorrow = now.AddDays (1);
    if (DateTime.Compare (now, tomorrow) == 0) {
        Application.EnableVisualStyles ();
        Application.SetCompatibleTextRenderingDefault (false);
        Application.Run (new Form1 ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19817474_19817498_1_15
19817474_19817535_1_11
Title: Listbox remove wrong item 
----------------------------------------

protected void Button4_Click (object sender, EventArgs e) {
    if (ListBox1.SelectedIndex != - 1) {
        ListBox1.Items.Remove (ListBox1.SelectedItem);
    }
    if (ListBox2.SelectedIndex != - 1) {
        ListBox2.Items.Remove (ListBox2.SelectedItem);
    }
    if (ListBox3.SelectedIndex != - 1) {
        ListBox3.Items.Remove (ListBox3.SelectedItem);
    }
}
----------------------------------------

protected void Button4_Click (object sender, EventArgs e) {
    if (ListBox1.SelectedIndex != - 1)
        ListBox1.Items.Remove (ListBox1.SelectedItem);

    if (ListBox2.SelectedIndex != - 1)
        ListBox2.Items.Remove (ListBox2.SelectedItem);

    if (ListBox3.SelectedIndex != - 1)
        ListBox3.Items.Remove (ListBox3.SelectedItem);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19820963_19821054_1_13
19820963_19821255_11_27
Title: C# stop calling MDI child again and again 
----------------------------------------

private void newToolStripMenuItem_Click (object sender, EventArgs e) {
    var f2 = this.MdiChildren.OfType < Form2 > ().FirstOrDefault ();
    if (f2 != null) {
        f2.Show ();
        return;
    }
    Form2 f = new Form2 ();
    f.MdiParent = this;
    f.Show ();
}
----------------------------------------

private void newToolStripMenuItem_Click (object sender, EventArgs e) {
    if (f2 == null || f2.IsDisposed) {
        f2 = new Form2 ();
        f2.MdiParent = this;
        f2.Show ();
    } else {
        if (f2.WindowState == FormWindowState.Minimized) {
            f2.WindowState = FormWindowState.Normal;
        }
        f2.Activate ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19829388_19829529_1_17
19829388_32578768_1_13
Title: Combine %USERPROFILE% in path 
----------------------------------------

void Main () {
    string userProfile = Environment.GetFolderPath (Environment.SpecialFolder.UserProfile);
    string subFolder = @"Local Settings\TEST";
    string path = Path.Combine (userProfile, subFolder);
    DirectoryInfo di = new DirectoryInfo (path);
    if (di.Exists) {
        Console.WriteLine ("Deleting " + di);
        di.Delete (true);
    } else {
        Console.WriteLine ("Directory " + di + " was not found");
    }
}
----------------------------------------

void Main () {
    string path = Environment.ExpandEnvironmentVariables (@"%USERPROFILE%\Local Settings\TEST");
    DirectoryInfo dir = new DirectoryInfo (path);
    foreach (FileInfo files in dir.GetFiles ()) {
        files.Delete ();
    }
    foreach (DirectoryInfo dirs in dir.GetDirectories ()) {
        dirs.Delete (true);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19829974_19832249_1_72
19829974_19832806_1_34
Title: Using one observable as a clock to test the other for timeout 
----------------------------------------

public static IObservable < R > TimeoutDetector2 < T1, T2, R > (this IObservable < T1 > source, IObservable < T2 > clock, int maxDiff, Func < R > timedOutSelector, Func < T1, R > okSelector) {
    return new AnonymousObservable < R > (observer = > {
        int counter = 0;
        object gate = new object ();
        bool error = false;
        bool completed = false;
        bool timedOut = false;
        var sourceSubscription = source.Subscribe (x = > {
            lock (gate)
            {
                if (! error && ! completed)
                    observer.OnNext (okSelector (x));

                counter = 0;
                timedOut = false;
            }}, ex = > {
            lock (gate)
            {
                error = true;
                if (! completed)
                    observer.OnError (ex);

            }}, () = > {
            lock (gate)
            {
                completed = true;
                if (! error)
                    observer.OnCompleted ();

            }});
        var clockSubscription = clock.Subscribe (x = > {
            lock (gate)
            {
                counter = counter + 1;
                if (! error && ! completed && counter > maxDiff && ! timedOut) {
                    timedOut = true;
                    observer.OnNext (timedOutSelector ());
                }
            }}, ex = > {
            lock (gate)
            {
                error = true;
                if (! completed)
                    observer.OnError (ex);

            }}, () = > {
            lock (gate)
            {
                completed = true;
                if (! error)
                    observer.OnCompleted ();

            }});
        return new CompositeDisposable (sourceSubscription, clockSubscription);
    }).Publish ().RefCount ();
}
----------------------------------------

public static IObservable < TR > TimeoutDetector < T1, T2, TR > (this IObservable < T1 > source, IObservable < T2 > clock, int countForTimeout, Func < TR > timedOutSelector, Func < T1, TR > okSelector) {
    return Observable.Create < TR > (observer = > {
        var counter = countForTimeout;
        var timeoutSub = clock.Subscribe (_ = > {
            var count = Interlocked.Decrement (ref counter);
            if (count == 0) {
                observer.OnNext (timedOutSelector ());
            }
        }, observer.OnError, observer.OnCompleted);
        var sourceSub = source.Subscribe (i = > {
            Interlocked.Exchange (ref counter, countForTimeout);
            observer.OnNext (okSelector (i));
        }, observer.OnError, observer.OnCompleted);
        return new CompositeDisposable (sourceSub, timeoutSub);
    });
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19830373_38537746_257_279
19830373_38537746_281_297
Title: XML Serialization Error - There was an error reflecting type 
----------------------------------------

public static bool Serialize < T > (object value, TextWriter output) {
    if (value == null)
        throw new ArgumentNullException ("Serialize(value)");

    bool result = false;
    Type T = value.GetType ();
    try {
        var xmlSerializer = new XmlSerializer (typeof (T));
        using (var xmlWriter = XmlWriter.Create (output, new XmlWriterSettings {Indent = true}))
        {
            xmlSerializer.Serialize (xmlWriter, value);
            result = true;
        }}
    catch (Exception) {
    }
    return result;
}
----------------------------------------

public static T Deserialize < T > (string fileName) {
    T result = default (T);
    try {
        using (var stream = System.IO.File.OpenRead (fileName))
        {
            var serializer = new XmlSerializer (typeof (T));
            result = (T) serializer.Deserialize (stream);
        }}
    catch (Exception) {
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19832005_19832031_1_15
19832005_19832204_1_14
Title: "what do they mean with ""not all code paths return a value""?" 
----------------------------------------

public bool Gewonnen () {
    for (int y = 0; y < _boolArray.GetLength (0); y ++) {
        for (int x = 0; x < _boolArray.GetLength (1); x ++) {
            if (_boolArray [x, y] == false)
                return false;
            else
                return true;

        }
    }
    return false;
}
----------------------------------------

public bool Gewonnen () {
    for (int y = 0; y < _boolArray.GetLength (0); y ++) {
        for (int x = 0; x < _boolArray.GetLength (1); x ++) {
            if (_boolArray [x, y] == false)
                return false;

        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1984681_1984902_123_162
1984681_1984935_3_19
Title: follow loading progress of huge XML files 
----------------------------------------

static void Main () {
    const string path = "bigfile";
    if (File.Exists (path))
        File.Delete (path);

    using (var chatty = new ChattyStream (File.Create (path)))
    {
        chatty.ProgressChanged += delegate {
            Console.WriteLine ("Writing: " + chatty.Position);
        };
        using (var writer = XmlWriter.Create (chatty))
        {
            writer.WriteStartDocument ();
            writer.WriteStartElement ("xml");
            for (int i = 0; i < 50000; i ++) {
                writer.WriteElementString ("add", i.ToString ());
            }
            writer.WriteEndElement ();
            writer.WriteEndDocument ();
        } chatty.Close ();
    } using (var chatty = new ChattyStream (File.OpenRead ("bigfile")))
    {
        chatty.ProgressChanged += delegate {
            Console.WriteLine ("Reading: " + chatty.Position);
        };
        XmlDocument doc = new XmlDocument ();
        doc.Load (chatty);
    }}
----------------------------------------

static void Main (string [] args) {
    Console.WriteLine ("Reading big file...");
    FileStream fileStream = File.OpenRead ("c:\\temp\\bigfile.xml");
    ProgressStreamWrapper progressStreamWrapper = new ProgressStreamWrapper (fileStream);
    progressStreamWrapper.PositionChanged += (o, ea) = > Console.WriteLine ((double) progressStreamWrapper.Position / progressStreamWrapper.Length * 100 + "% complete");
    XmlReader xmlReader = XmlReader.Create (progressStreamWrapper);
    while (xmlReader.Read ()) {
    }
    Console.WriteLine ("DONE");
    Console.ReadLine ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1985524_1985554_6_16
1985524_1986179_8_18
Title: C# Refactoring of If Statement 
----------------------------------------

public bool Validate (params Func < bool > [] validators) {
    var invalid = validators.FirstOrDefault (v = > ! v ());
    if (invalid != null) {
        LogLogic.AddEntry (LogLogic.GetEnumDescription (LogMessages.StatusMessages.JobValidationFailed));
        return false;
    }
    LogLogic.AddEntry (LogLogic.GetEnumDescription (LogMessages.StatusMessages.JobValidationPassed));
    return true;
}
----------------------------------------

private LogMessages.StatusMessages Validate () {
    if (! ValidRecordIdentifiers ())
        return LogMessages.StatusMessages.JobValidationFailed;

    if (! ValidateTotals ())
        return LogMessages.StatusMessages.JobValidationFailed;

    if (! ValidateRecordCount ())
        return LogMessages.StatusMessages.JobValidationFailed;

    return LogMessages.StatusMessages.JobValidationPassed;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19858754_19860760_1_16
19858754_20185608_1_15
Title: remove images while exporting excel from gridview 
----------------------------------------

protected void Export_to_Excel (object sender, EventArgs e) {
    GridView tmpGrid = new GridView ();
    Response.Clear ();
    Response.AddHeader ("content-disposition", "attachment;filename=vault-extract-nsf.xls");
    Response.ContentType = "application/vnd.xlsx";
    System.IO.StringWriter stringWrite = new System.IO.StringWriter ();
    System.Web.UI.HtmlTextWriter htmlWrite = new HtmlTextWriter (stringWrite);
    tmpGrid.RenderControl (htmlWrite);
    Response.Write (stringWrite.ToString ());
    Response.End ();
}
----------------------------------------

protected void Export_to_Excel (object sender, EventArgs e) {
    Response.Clear ();
    Response.AddHeader ("content-disposition", "attachment;filename=PatientSearchReport.xls");
    Response.ContentType = "application/vnd.xlsx";
    System.IO.StringWriter stringWrite = new System.IO.StringWriter ();
    System.Web.UI.HtmlTextWriter htmlWrite = new HtmlTextWriter (stringWrite);
    GridView1.RenderControl (htmlWrite);
    string html2 = Regex.Replace (stringWrite.ToString (), @"(<input type=""image""\/?[^>]+>)", @"", RegexOptions.IgnoreCase);
    html2 = Regex.Replace (html2, @"(<input class=""checkbox""\/?[^>]+>)", @"", RegexOptions.IgnoreCase);
    html2 = Regex.Replace (html2, @"(<a \/?[^>]+>)", @"", RegexOptions.IgnoreCase);
    Response.Write (html2.ToString ());
    Response.End ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19868308_19868374_1_11
19868308_19868398_1_11
Title: Cant seem to pass parameters without errors 
----------------------------------------

private void btnSubmit_Click (object sender, EventArgs e) {
    string strColor;
    string strMake;
    decimal decPrice;
    GetColor (ref strColor);
    GetMake (ref strMake);
    GetPrice (ref decPrice);
    DisplayResult (strColor, strMake, decPrice);
}
----------------------------------------

private void btnSubmit_Click (object sender, EventArgs e) {
    string strColor;
    string strMake;
    decimal decPrice;
    GetColor (ref strColor);
    GetMake (ref strMake);
    GetPrice (ref decPrice);
    DisplayResult (strColor, strMake, decPrice);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19924069_19924287_1_16
19924069_19924695_1_15
Title: detecting a property of an item before placing it in array 
----------------------------------------

public SuperCard [] GetCards (int cards_to_get) {
    SuperCard [] hand = new SuperCard [cards_to_get];
    for (int i = 0; i < cards_to_get; i ++) {
        int x = myRandom.Next (0, 51);
        if (cardArray [x].inPlay)
            hand [i] = cardArray [myRandom.Next (0, 51)];
        else {
            hand [i] = cardArray [myRandom.Next (0, 51)];
            cardArray [x].inPlay = true;
        }
    }
    return hand;
}
----------------------------------------

public SuperCard [] GetCards (int number) {
    SuperCard [] hand = new SuperCard [number];
    while (number > 0) {
        int x = myRandom.Next (0, 51);
        if (cardArray [x].inPlay == false) {
            hand [hand.Length - number] = cardArray [myRandom.Next (0, 51)];
            cardArray [x].inPlay = true;
            number --;
        }
    }
    return hand;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19924069_19924287_1_16
19924069_20235912_1_21
Title: detecting a property of an item before placing it in array 
----------------------------------------

public SuperCard [] GetCards (int cards_to_get) {
    SuperCard [] hand = new SuperCard [cards_to_get];
    for (int i = 0; i < cards_to_get; i ++) {
        int x = myRandom.Next (0, 51);
        if (cardArray [x].inPlay)
            hand [i] = cardArray [myRandom.Next (0, 51)];
        else {
            hand [i] = cardArray [myRandom.Next (0, 51)];
            cardArray [x].inPlay = true;
        }
    }
    return hand;
}
----------------------------------------

public SuperCard [] GetCards (int number) {
    SuperCard [] hand = new SuperCard [number];
    int index;
    for (int i = 0; i < number; i ++) {
        index = myRandom.Next (0, 51);
        hand [i] = cardArray [index];
        while (hand [i].inplay == true) {
            index = myRandom.Next (0, 51);
            hand [i] = cardArray [index];
        }
        hand [i].inplay = true;
    }
    return hand;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19924069_19924695_1_15
19924069_20235912_1_21
Title: detecting a property of an item before placing it in array 
----------------------------------------

public SuperCard [] GetCards (int number) {
    SuperCard [] hand = new SuperCard [number];
    while (number > 0) {
        int x = myRandom.Next (0, 51);
        if (cardArray [x].inPlay == false) {
            hand [hand.Length - number] = cardArray [myRandom.Next (0, 51)];
            cardArray [x].inPlay = true;
            number --;
        }
    }
    return hand;
}
----------------------------------------

public SuperCard [] GetCards (int number) {
    SuperCard [] hand = new SuperCard [number];
    int index;
    for (int i = 0; i < number; i ++) {
        index = myRandom.Next (0, 51);
        hand [i] = cardArray [index];
        while (hand [i].inplay == true) {
            index = myRandom.Next (0, 51);
            hand [i] = cardArray [index];
        }
        hand [i].inplay = true;
    }
    return hand;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19933933_19933994_1_28
19933933_19936027_1_24
Title: If statements in methods 
----------------------------------------

public void mood () {
    var unhappiness = Hunger + Boredom;
    string m = string.Empty;
    if (unhappiness < 5) {
        m = "Happy";
    }
    if (unhappiness >= 6 && unhappiness <= 10) {
        m = "Okay";
    }
    if (unhappiness >= 11 && unhappiness <= 15) {
        m = "Frustrated";
    }
    if (unhappiness >= 16) {
        m = "Mad";
    }
    Console.WriteLine (m);
}
----------------------------------------

public void mood () {
    var unhappiness = Hunger + Boredom;
    string m = "Unknown";
    if (unhappiness < 5) {
        m = "Happy";
    } else if (unhappiness >= 5 && unhappiness <= 10) {
        m = "Okay";
    } else if (unhappiness > 11 && unhappiness <= 15) {
        m = "Frustrated";
    } else if (unhappiness >= 16) {
        m = "Mad";
    }
    Console.WriteLine (m);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19934588_19953279_10_30
19934588_19953279_31_50
Title: Setting ItemsPanel's properties from itemsControl 
----------------------------------------

public static T FindVisualParent < T > (DependencyObject child) where T : DependencyObject {
    DependencyObject parentObject = VisualTreeHelper.GetParent (child);
    if (parentObject == null)
        return null;

    T parent = parentObject as T;
    if (parent != null) {
        return parent;
    } else {
        return FindVisualParent < T > (parentObject);
    }
}
----------------------------------------

public static T FindVisualChild < T > (DependencyObject parent) where T : DependencyObject {
    T child = default (T);
    int numVisuals = VisualTreeHelper.GetChildrenCount (parent);
    for (int i = 0; i < numVisuals; i ++) {
        Visual v = (Visual) VisualTreeHelper.GetChild (parent, i);
        child = v as T;
        if (child == null) {
            child = FindVisualChild < T > (v);
        }
        if (child != null) {
            break;
        }
    }
    return child;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936768_1_13
19936710_19936804_1_15
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = 0;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    } else if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = 0;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936768_1_13
19936710_19936879_1_16
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = 0;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    } else if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerinfo;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo ?? 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936768_1_13
19936710_19936889_1_13
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = 0;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    } else if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    var headerInfo = 0;
    switch (headerName) {
        case "flyer" :
            headerInfo = Service.GetFlierHeaderInfo (agentId);
        case "general" :
            headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936768_1_13
19936710_19936931_1_13
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = 0;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    } else if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = null;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936768_1_13
19936710_19937157_1_14
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = 0;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    } else if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object instance;
    switch (headerName) {
        case "flyer" :
            instance = Service.GetFlierHeaderInfo (agentId);
            break;
        case "general" :
            instance = Service.GetHeaderInfo (agentId);
            break;
        default :
            throw new ArgumentOutOfRangeException ("headerName");
    }
    return instance;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936804_1_15
19936710_19936889_1_13
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = 0;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    var headerInfo = 0;
    switch (headerName) {
        case "flyer" :
            headerInfo = Service.GetFlierHeaderInfo (agentId);
        case "general" :
            headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936804_1_15
19936710_19937157_1_14
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = 0;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object instance;
    switch (headerName) {
        case "flyer" :
            instance = Service.GetFlierHeaderInfo (agentId);
            break;
        case "general" :
            instance = Service.GetHeaderInfo (agentId);
            break;
        default :
            throw new ArgumentOutOfRangeException ("headerName");
    }
    return instance;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936879_1_16
19936710_19936889_1_13
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerinfo;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo ?? 0;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    var headerInfo = 0;
    switch (headerName) {
        case "flyer" :
            headerInfo = Service.GetFlierHeaderInfo (agentId);
        case "general" :
            headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936879_1_16
19936710_19937157_1_14
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerinfo;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo ?? 0;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object instance;
    switch (headerName) {
        case "flyer" :
            instance = Service.GetFlierHeaderInfo (agentId);
            break;
        case "general" :
            instance = Service.GetHeaderInfo (agentId);
            break;
        default :
            throw new ArgumentOutOfRangeException ("headerName");
    }
    return instance;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936889_1_13
19936710_19936931_1_13
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    var headerInfo = 0;
    switch (headerName) {
        case "flyer" :
            headerInfo = Service.GetFlierHeaderInfo (agentId);
        case "general" :
            headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = null;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936889_1_13
19936710_19937157_1_14
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    var headerInfo = 0;
    switch (headerName) {
        case "flyer" :
            headerInfo = Service.GetFlierHeaderInfo (agentId);
        case "general" :
            headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object instance;
    switch (headerName) {
        case "flyer" :
            instance = Service.GetFlierHeaderInfo (agentId);
            break;
        case "general" :
            instance = Service.GetHeaderInfo (agentId);
            break;
        default :
            throw new ArgumentOutOfRangeException ("headerName");
    }
    return instance;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19936710_19936931_1_13
19936710_19937157_1_14
Title: only one return() for the entire method 
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object headerInfo = null;
    if (headerName == "flyer") {
        headerInfo = Service.GetFlierHeaderInfo (agentId);
    }
    if (headerName == "general") {
        headerInfo = Service.GetHeaderInfo (agentId);
    }
    return headerInfo;
}
----------------------------------------

public object GetHeaderInfo (string agentId, string headerName) {
    object instance;
    switch (headerName) {
        case "flyer" :
            instance = Service.GetFlierHeaderInfo (agentId);
            break;
        case "general" :
            instance = Service.GetHeaderInfo (agentId);
            break;
        default :
            throw new ArgumentOutOfRangeException ("headerName");
    }
    return instance;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_104_177
19949318_19949830_179_193
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareProperties < T > (T value1, T value2) {
    if (IsGenericList (typeof (T))) {
        return ComparareGenericList (value1, value2);
    }
    List < PropertyInfo > properties = GetPropertiesToCheck < T > ();
    foreach (var p in properties) {
        try {
            var valueA = p.GetValue (value1, null);
            var valueB = p.GetValue (value2, null);
            if (! (valueA == null && valueB == null)) {
                if (valueA == null || valueB == null) {
                    throw new NotEqualsException (value1, value2);
                }
                if (IsBasicCompare (p.PropertyType)) {
                    valueA = ConvertTo (p.GetValue (value1, null), p.PropertyType);
                    valueB = ConvertTo (p.GetValue (value2, null), p.PropertyType);
                    if (! CompareBasic (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (IsEnumerable (p.PropertyType)) {
                    if (! CompareAsInumerable (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (p.PropertyType.IsClass) {
                    if (! Compare (ConvertTo (p.GetValue (value1, null), p.PropertyType), ConvertTo (p.GetValue (value2, null), p.PropertyType))) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else
                    throw new Exception (string.Format ("Tipo no especificado {0}", p.PropertyType));

            }
        }
        catch (NotEqualsException ex) {
            ex.AddParent (p.Name);
            throw;
        }
    }
    return true;
}
----------------------------------------

private List < PropertyInfo > GetPropertiesToCheck < T > () {
    List < PropertyInfo > properties = new List < PropertyInfo > ();
    Type typeToCheck = typeof (T);
    IExcludeProperties exclude = excludeProperties.FirstOrDefault (excl = > excl.ExcludeType ().IsAssignableFrom (typeToCheck));
    if (exclude != null)
        return typeToCheck.GetProperties ().Where (p = > p.CanRead && (! exclude.GetPropertiesNames ().Any (n = > n == p.Name))).ToList ();

    return typeToCheck.GetProperties ().Where (p = > p.CanRead).ToList ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_104_177
19949318_19949830_17_29
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareProperties < T > (T value1, T value2) {
    if (IsGenericList (typeof (T))) {
        return ComparareGenericList (value1, value2);
    }
    List < PropertyInfo > properties = GetPropertiesToCheck < T > ();
    foreach (var p in properties) {
        try {
            var valueA = p.GetValue (value1, null);
            var valueB = p.GetValue (value2, null);
            if (! (valueA == null && valueB == null)) {
                if (valueA == null || valueB == null) {
                    throw new NotEqualsException (value1, value2);
                }
                if (IsBasicCompare (p.PropertyType)) {
                    valueA = ConvertTo (p.GetValue (value1, null), p.PropertyType);
                    valueB = ConvertTo (p.GetValue (value2, null), p.PropertyType);
                    if (! CompareBasic (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (IsEnumerable (p.PropertyType)) {
                    if (! CompareAsInumerable (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (p.PropertyType.IsClass) {
                    if (! Compare (ConvertTo (p.GetValue (value1, null), p.PropertyType), ConvertTo (p.GetValue (value2, null), p.PropertyType))) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else
                    throw new Exception (string.Format ("Tipo no especificado {0}", p.PropertyType));

            }
        }
        catch (NotEqualsException ex) {
            ex.AddParent (p.Name);
            throw;
        }
    }
    return true;
}
----------------------------------------

public bool AreEquals < T1, T2 > (T1 value1, T2 value2) {
    try {
        reccorido = new Hashtable ();
        return Compare (value1, value2);
    }
    catch (NotEqualsException ex) {
        PropertyFail = ex.Where ();
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_104_177
19949318_19949830_195_215
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareProperties < T > (T value1, T value2) {
    if (IsGenericList (typeof (T))) {
        return ComparareGenericList (value1, value2);
    }
    List < PropertyInfo > properties = GetPropertiesToCheck < T > ();
    foreach (var p in properties) {
        try {
            var valueA = p.GetValue (value1, null);
            var valueB = p.GetValue (value2, null);
            if (! (valueA == null && valueB == null)) {
                if (valueA == null || valueB == null) {
                    throw new NotEqualsException (value1, value2);
                }
                if (IsBasicCompare (p.PropertyType)) {
                    valueA = ConvertTo (p.GetValue (value1, null), p.PropertyType);
                    valueB = ConvertTo (p.GetValue (value2, null), p.PropertyType);
                    if (! CompareBasic (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (IsEnumerable (p.PropertyType)) {
                    if (! CompareAsInumerable (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (p.PropertyType.IsClass) {
                    if (! Compare (ConvertTo (p.GetValue (value1, null), p.PropertyType), ConvertTo (p.GetValue (value2, null), p.PropertyType))) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else
                    throw new Exception (string.Format ("Tipo no especificado {0}", p.PropertyType));

            }
        }
        catch (NotEqualsException ex) {
            ex.AddParent (p.Name);
            throw;
        }
    }
    return true;
}
----------------------------------------

private bool ComparareGenericList < T > (T value1, T value2) {
    List < PropertyInfo > properties = typeof (T).GetProperties ().Where (p = > p.CanRead && p.Name != "Capacity").ToList ();
    PropertyInfo count = typeof (T).GetProperty ("Count");
    int totalA = ConvertTo (count.GetValue (value1, null), count.PropertyType);
    int totalB = ConvertTo (count.GetValue (value2, null), count.PropertyType);
    if (! Compare (totalA, totalB))
        return false;

    PropertyInfo item = typeof (T).GetProperty ("Item");
    CompareAsInumerable (value1, value2);
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_104_177
19949318_19949830_230_247
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareProperties < T > (T value1, T value2) {
    if (IsGenericList (typeof (T))) {
        return ComparareGenericList (value1, value2);
    }
    List < PropertyInfo > properties = GetPropertiesToCheck < T > ();
    foreach (var p in properties) {
        try {
            var valueA = p.GetValue (value1, null);
            var valueB = p.GetValue (value2, null);
            if (! (valueA == null && valueB == null)) {
                if (valueA == null || valueB == null) {
                    throw new NotEqualsException (value1, value2);
                }
                if (IsBasicCompare (p.PropertyType)) {
                    valueA = ConvertTo (p.GetValue (value1, null), p.PropertyType);
                    valueB = ConvertTo (p.GetValue (value2, null), p.PropertyType);
                    if (! CompareBasic (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (IsEnumerable (p.PropertyType)) {
                    if (! CompareAsInumerable (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (p.PropertyType.IsClass) {
                    if (! Compare (ConvertTo (p.GetValue (value1, null), p.PropertyType), ConvertTo (p.GetValue (value2, null), p.PropertyType))) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else
                    throw new Exception (string.Format ("Tipo no especificado {0}", p.PropertyType));

            }
        }
        catch (NotEqualsException ex) {
            ex.AddParent (p.Name);
            throw;
        }
    }
    return true;
}
----------------------------------------

private bool CompareFields < T > (T value1, T value2) {
    List < FieldInfo > fields = typeof (T).GetFields ().Where (f = > f.IsPublic).ToList ();
    foreach (var f in fields) {
        dynamic valueA = f.GetValue (value1);
        dynamic valueB = f.GetValue (value2);
        if (! Compare (f.GetValue (value1), f.GetValue (value2))) {
            throw new NotEqualsException (value1, value2);
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_104_177
19949318_19949830_250_288
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareProperties < T > (T value1, T value2) {
    if (IsGenericList (typeof (T))) {
        return ComparareGenericList (value1, value2);
    }
    List < PropertyInfo > properties = GetPropertiesToCheck < T > ();
    foreach (var p in properties) {
        try {
            var valueA = p.GetValue (value1, null);
            var valueB = p.GetValue (value2, null);
            if (! (valueA == null && valueB == null)) {
                if (valueA == null || valueB == null) {
                    throw new NotEqualsException (value1, value2);
                }
                if (IsBasicCompare (p.PropertyType)) {
                    valueA = ConvertTo (p.GetValue (value1, null), p.PropertyType);
                    valueB = ConvertTo (p.GetValue (value2, null), p.PropertyType);
                    if (! CompareBasic (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (IsEnumerable (p.PropertyType)) {
                    if (! CompareAsInumerable (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (p.PropertyType.IsClass) {
                    if (! Compare (ConvertTo (p.GetValue (value1, null), p.PropertyType), ConvertTo (p.GetValue (value2, null), p.PropertyType))) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else
                    throw new Exception (string.Format ("Tipo no especificado {0}", p.PropertyType));

            }
        }
        catch (NotEqualsException ex) {
            ex.AddParent (p.Name);
            throw;
        }
    }
    return true;
}
----------------------------------------

private bool CompareAsInumerable < T > (T valueA, T valueB) {
    IEnumerable < object > colA = ((IEnumerable) valueA).Cast < object > ();
    IEnumerable < object > colB = ((IEnumerable) valueB).Cast < object > ();
    if (colA.Count () != colB.Count ())
        return false;

    Type t1 = GetType (colA.GetType ());
    Type t2 = GetType (colB.GetType ());
    if (t1 != t2)
        return false;

    if (colA.Count () > 0) {
        Type itemType = GetTypeOfItem (colA);
        for (int i = 0; i < colA.Count (); i ++) {
            try {
                dynamic a = colA.ElementAt (i);
                dynamic b = colB.ElementAt (i);
                if (! Compare (a, b)) {
                    throw new NotEqualsException (colA.ElementAt (i), colB.ElementAt (i));
                }
            }
            catch (NotEqualsException ex) {
                ex.AddParent (itemType.Name);
                throw;
            }
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_104_177
19949318_19949830_310_331
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareProperties < T > (T value1, T value2) {
    if (IsGenericList (typeof (T))) {
        return ComparareGenericList (value1, value2);
    }
    List < PropertyInfo > properties = GetPropertiesToCheck < T > ();
    foreach (var p in properties) {
        try {
            var valueA = p.GetValue (value1, null);
            var valueB = p.GetValue (value2, null);
            if (! (valueA == null && valueB == null)) {
                if (valueA == null || valueB == null) {
                    throw new NotEqualsException (value1, value2);
                }
                if (IsBasicCompare (p.PropertyType)) {
                    valueA = ConvertTo (p.GetValue (value1, null), p.PropertyType);
                    valueB = ConvertTo (p.GetValue (value2, null), p.PropertyType);
                    if (! CompareBasic (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (IsEnumerable (p.PropertyType)) {
                    if (! CompareAsInumerable (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (p.PropertyType.IsClass) {
                    if (! Compare (ConvertTo (p.GetValue (value1, null), p.PropertyType), ConvertTo (p.GetValue (value2, null), p.PropertyType))) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else
                    throw new Exception (string.Format ("Tipo no especificado {0}", p.PropertyType));

            }
        }
        catch (NotEqualsException ex) {
            ex.AddParent (p.Name);
            throw;
        }
    }
    return true;
}
----------------------------------------

private bool CompareBasic < T > (T valueA, T valueB) {
    bool result;
    IComparable selfValueComparer;
    selfValueComparer = valueA as IComparable;
    if (valueA == null && valueB != null || valueA != null && valueB == null)
        result = false;
    else if (selfValueComparer != null && selfValueComparer.CompareTo (valueB) != 0)
        result = false;
    else if (! object.Equals (valueA, valueB))
        result = false;
    else
        result = true;

    if (! result)
        throw new NotEqualsException (valueA, valueB);

    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_104_177
19949318_19949830_37_84
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareProperties < T > (T value1, T value2) {
    if (IsGenericList (typeof (T))) {
        return ComparareGenericList (value1, value2);
    }
    List < PropertyInfo > properties = GetPropertiesToCheck < T > ();
    foreach (var p in properties) {
        try {
            var valueA = p.GetValue (value1, null);
            var valueB = p.GetValue (value2, null);
            if (! (valueA == null && valueB == null)) {
                if (valueA == null || valueB == null) {
                    throw new NotEqualsException (value1, value2);
                }
                if (IsBasicCompare (p.PropertyType)) {
                    valueA = ConvertTo (p.GetValue (value1, null), p.PropertyType);
                    valueB = ConvertTo (p.GetValue (value2, null), p.PropertyType);
                    if (! CompareBasic (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (IsEnumerable (p.PropertyType)) {
                    if (! CompareAsInumerable (valueA, valueB)) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else if (p.PropertyType.IsClass) {
                    if (! Compare (ConvertTo (p.GetValue (value1, null), p.PropertyType), ConvertTo (p.GetValue (value2, null), p.PropertyType))) {
                        throw new NotEqualsException (value1, value2);
                    }
                } else
                    throw new Exception (string.Format ("Tipo no especificado {0}", p.PropertyType));

            }
        }
        catch (NotEqualsException ex) {
            ex.AddParent (p.Name);
            throw;
        }
    }
    return true;
}
----------------------------------------

private bool Compare < T1, T2 > (T1 value1, T2 value2) {
    if (value1 == null && value2 == null) {
        return true;
    }
    if ((value1 == null) || (value2 == null)) {
        throw new NotEqualsException (value1, value2);
    }
    string key = GetKey < T1, T2 > (value1, value2);
    if (reccorido.Contains (key)) {
        return true;
    }
    reccorido.Add (key, true);
    Type tipo1 = GetType (value1.GetType ());
    Type tipo2 = GetType (value2.GetType ());
    if (tipo1 != tipo2) {
        throw new NotEqualsException (value1, value2);
    }
    if (IsBasicCompare (tipo1)) {
        return CompareBasic (ConvertTo (value1, tipo1), ConvertTo (value2, tipo1));
    }
    dynamic v1 = ConvertTo (value1, tipo1);
    dynamic v2 = ConvertTo (value2, tipo1);
    if (! CompareFields (v1, v2)) {
        throw new NotEqualsException (value1, value2);
    }
    return CompareProperties (v1, v2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_179_193
19949318_19949830_17_29
Title: Recursive call to compare object properties 
----------------------------------------

private List < PropertyInfo > GetPropertiesToCheck < T > () {
    List < PropertyInfo > properties = new List < PropertyInfo > ();
    Type typeToCheck = typeof (T);
    IExcludeProperties exclude = excludeProperties.FirstOrDefault (excl = > excl.ExcludeType ().IsAssignableFrom (typeToCheck));
    if (exclude != null)
        return typeToCheck.GetProperties ().Where (p = > p.CanRead && (! exclude.GetPropertiesNames ().Any (n = > n == p.Name))).ToList ();

    return typeToCheck.GetProperties ().Where (p = > p.CanRead).ToList ();
}
----------------------------------------

public bool AreEquals < T1, T2 > (T1 value1, T2 value2) {
    try {
        reccorido = new Hashtable ();
        return Compare (value1, value2);
    }
    catch (NotEqualsException ex) {
        PropertyFail = ex.Where ();
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_179_193
19949318_19949830_195_215
Title: Recursive call to compare object properties 
----------------------------------------

private List < PropertyInfo > GetPropertiesToCheck < T > () {
    List < PropertyInfo > properties = new List < PropertyInfo > ();
    Type typeToCheck = typeof (T);
    IExcludeProperties exclude = excludeProperties.FirstOrDefault (excl = > excl.ExcludeType ().IsAssignableFrom (typeToCheck));
    if (exclude != null)
        return typeToCheck.GetProperties ().Where (p = > p.CanRead && (! exclude.GetPropertiesNames ().Any (n = > n == p.Name))).ToList ();

    return typeToCheck.GetProperties ().Where (p = > p.CanRead).ToList ();
}
----------------------------------------

private bool ComparareGenericList < T > (T value1, T value2) {
    List < PropertyInfo > properties = typeof (T).GetProperties ().Where (p = > p.CanRead && p.Name != "Capacity").ToList ();
    PropertyInfo count = typeof (T).GetProperty ("Count");
    int totalA = ConvertTo (count.GetValue (value1, null), count.PropertyType);
    int totalB = ConvertTo (count.GetValue (value2, null), count.PropertyType);
    if (! Compare (totalA, totalB))
        return false;

    PropertyInfo item = typeof (T).GetProperty ("Item");
    CompareAsInumerable (value1, value2);
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_179_193
19949318_19949830_230_247
Title: Recursive call to compare object properties 
----------------------------------------

private List < PropertyInfo > GetPropertiesToCheck < T > () {
    List < PropertyInfo > properties = new List < PropertyInfo > ();
    Type typeToCheck = typeof (T);
    IExcludeProperties exclude = excludeProperties.FirstOrDefault (excl = > excl.ExcludeType ().IsAssignableFrom (typeToCheck));
    if (exclude != null)
        return typeToCheck.GetProperties ().Where (p = > p.CanRead && (! exclude.GetPropertiesNames ().Any (n = > n == p.Name))).ToList ();

    return typeToCheck.GetProperties ().Where (p = > p.CanRead).ToList ();
}
----------------------------------------

private bool CompareFields < T > (T value1, T value2) {
    List < FieldInfo > fields = typeof (T).GetFields ().Where (f = > f.IsPublic).ToList ();
    foreach (var f in fields) {
        dynamic valueA = f.GetValue (value1);
        dynamic valueB = f.GetValue (value2);
        if (! Compare (f.GetValue (value1), f.GetValue (value2))) {
            throw new NotEqualsException (value1, value2);
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_179_193
19949318_19949830_250_288
Title: Recursive call to compare object properties 
----------------------------------------

private List < PropertyInfo > GetPropertiesToCheck < T > () {
    List < PropertyInfo > properties = new List < PropertyInfo > ();
    Type typeToCheck = typeof (T);
    IExcludeProperties exclude = excludeProperties.FirstOrDefault (excl = > excl.ExcludeType ().IsAssignableFrom (typeToCheck));
    if (exclude != null)
        return typeToCheck.GetProperties ().Where (p = > p.CanRead && (! exclude.GetPropertiesNames ().Any (n = > n == p.Name))).ToList ();

    return typeToCheck.GetProperties ().Where (p = > p.CanRead).ToList ();
}
----------------------------------------

private bool CompareAsInumerable < T > (T valueA, T valueB) {
    IEnumerable < object > colA = ((IEnumerable) valueA).Cast < object > ();
    IEnumerable < object > colB = ((IEnumerable) valueB).Cast < object > ();
    if (colA.Count () != colB.Count ())
        return false;

    Type t1 = GetType (colA.GetType ());
    Type t2 = GetType (colB.GetType ());
    if (t1 != t2)
        return false;

    if (colA.Count () > 0) {
        Type itemType = GetTypeOfItem (colA);
        for (int i = 0; i < colA.Count (); i ++) {
            try {
                dynamic a = colA.ElementAt (i);
                dynamic b = colB.ElementAt (i);
                if (! Compare (a, b)) {
                    throw new NotEqualsException (colA.ElementAt (i), colB.ElementAt (i));
                }
            }
            catch (NotEqualsException ex) {
                ex.AddParent (itemType.Name);
                throw;
            }
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_179_193
19949318_19949830_310_331
Title: Recursive call to compare object properties 
----------------------------------------

private List < PropertyInfo > GetPropertiesToCheck < T > () {
    List < PropertyInfo > properties = new List < PropertyInfo > ();
    Type typeToCheck = typeof (T);
    IExcludeProperties exclude = excludeProperties.FirstOrDefault (excl = > excl.ExcludeType ().IsAssignableFrom (typeToCheck));
    if (exclude != null)
        return typeToCheck.GetProperties ().Where (p = > p.CanRead && (! exclude.GetPropertiesNames ().Any (n = > n == p.Name))).ToList ();

    return typeToCheck.GetProperties ().Where (p = > p.CanRead).ToList ();
}
----------------------------------------

private bool CompareBasic < T > (T valueA, T valueB) {
    bool result;
    IComparable selfValueComparer;
    selfValueComparer = valueA as IComparable;
    if (valueA == null && valueB != null || valueA != null && valueB == null)
        result = false;
    else if (selfValueComparer != null && selfValueComparer.CompareTo (valueB) != 0)
        result = false;
    else if (! object.Equals (valueA, valueB))
        result = false;
    else
        result = true;

    if (! result)
        throw new NotEqualsException (valueA, valueB);

    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_179_193
19949318_19949830_37_84
Title: Recursive call to compare object properties 
----------------------------------------

private List < PropertyInfo > GetPropertiesToCheck < T > () {
    List < PropertyInfo > properties = new List < PropertyInfo > ();
    Type typeToCheck = typeof (T);
    IExcludeProperties exclude = excludeProperties.FirstOrDefault (excl = > excl.ExcludeType ().IsAssignableFrom (typeToCheck));
    if (exclude != null)
        return typeToCheck.GetProperties ().Where (p = > p.CanRead && (! exclude.GetPropertiesNames ().Any (n = > n == p.Name))).ToList ();

    return typeToCheck.GetProperties ().Where (p = > p.CanRead).ToList ();
}
----------------------------------------

private bool Compare < T1, T2 > (T1 value1, T2 value2) {
    if (value1 == null && value2 == null) {
        return true;
    }
    if ((value1 == null) || (value2 == null)) {
        throw new NotEqualsException (value1, value2);
    }
    string key = GetKey < T1, T2 > (value1, value2);
    if (reccorido.Contains (key)) {
        return true;
    }
    reccorido.Add (key, true);
    Type tipo1 = GetType (value1.GetType ());
    Type tipo2 = GetType (value2.GetType ());
    if (tipo1 != tipo2) {
        throw new NotEqualsException (value1, value2);
    }
    if (IsBasicCompare (tipo1)) {
        return CompareBasic (ConvertTo (value1, tipo1), ConvertTo (value2, tipo1));
    }
    dynamic v1 = ConvertTo (value1, tipo1);
    dynamic v2 = ConvertTo (value2, tipo1);
    if (! CompareFields (v1, v2)) {
        throw new NotEqualsException (value1, value2);
    }
    return CompareProperties (v1, v2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_17_29
19949318_19949830_195_215
Title: Recursive call to compare object properties 
----------------------------------------

public bool AreEquals < T1, T2 > (T1 value1, T2 value2) {
    try {
        reccorido = new Hashtable ();
        return Compare (value1, value2);
    }
    catch (NotEqualsException ex) {
        PropertyFail = ex.Where ();
        return false;
    }
}
----------------------------------------

private bool ComparareGenericList < T > (T value1, T value2) {
    List < PropertyInfo > properties = typeof (T).GetProperties ().Where (p = > p.CanRead && p.Name != "Capacity").ToList ();
    PropertyInfo count = typeof (T).GetProperty ("Count");
    int totalA = ConvertTo (count.GetValue (value1, null), count.PropertyType);
    int totalB = ConvertTo (count.GetValue (value2, null), count.PropertyType);
    if (! Compare (totalA, totalB))
        return false;

    PropertyInfo item = typeof (T).GetProperty ("Item");
    CompareAsInumerable (value1, value2);
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_17_29
19949318_19949830_230_247
Title: Recursive call to compare object properties 
----------------------------------------

public bool AreEquals < T1, T2 > (T1 value1, T2 value2) {
    try {
        reccorido = new Hashtable ();
        return Compare (value1, value2);
    }
    catch (NotEqualsException ex) {
        PropertyFail = ex.Where ();
        return false;
    }
}
----------------------------------------

private bool CompareFields < T > (T value1, T value2) {
    List < FieldInfo > fields = typeof (T).GetFields ().Where (f = > f.IsPublic).ToList ();
    foreach (var f in fields) {
        dynamic valueA = f.GetValue (value1);
        dynamic valueB = f.GetValue (value2);
        if (! Compare (f.GetValue (value1), f.GetValue (value2))) {
            throw new NotEqualsException (value1, value2);
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_17_29
19949318_19949830_250_288
Title: Recursive call to compare object properties 
----------------------------------------

public bool AreEquals < T1, T2 > (T1 value1, T2 value2) {
    try {
        reccorido = new Hashtable ();
        return Compare (value1, value2);
    }
    catch (NotEqualsException ex) {
        PropertyFail = ex.Where ();
        return false;
    }
}
----------------------------------------

private bool CompareAsInumerable < T > (T valueA, T valueB) {
    IEnumerable < object > colA = ((IEnumerable) valueA).Cast < object > ();
    IEnumerable < object > colB = ((IEnumerable) valueB).Cast < object > ();
    if (colA.Count () != colB.Count ())
        return false;

    Type t1 = GetType (colA.GetType ());
    Type t2 = GetType (colB.GetType ());
    if (t1 != t2)
        return false;

    if (colA.Count () > 0) {
        Type itemType = GetTypeOfItem (colA);
        for (int i = 0; i < colA.Count (); i ++) {
            try {
                dynamic a = colA.ElementAt (i);
                dynamic b = colB.ElementAt (i);
                if (! Compare (a, b)) {
                    throw new NotEqualsException (colA.ElementAt (i), colB.ElementAt (i));
                }
            }
            catch (NotEqualsException ex) {
                ex.AddParent (itemType.Name);
                throw;
            }
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_17_29
19949318_19949830_310_331
Title: Recursive call to compare object properties 
----------------------------------------

public bool AreEquals < T1, T2 > (T1 value1, T2 value2) {
    try {
        reccorido = new Hashtable ();
        return Compare (value1, value2);
    }
    catch (NotEqualsException ex) {
        PropertyFail = ex.Where ();
        return false;
    }
}
----------------------------------------

private bool CompareBasic < T > (T valueA, T valueB) {
    bool result;
    IComparable selfValueComparer;
    selfValueComparer = valueA as IComparable;
    if (valueA == null && valueB != null || valueA != null && valueB == null)
        result = false;
    else if (selfValueComparer != null && selfValueComparer.CompareTo (valueB) != 0)
        result = false;
    else if (! object.Equals (valueA, valueB))
        result = false;
    else
        result = true;

    if (! result)
        throw new NotEqualsException (valueA, valueB);

    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_17_29
19949318_19949830_37_84
Title: Recursive call to compare object properties 
----------------------------------------

public bool AreEquals < T1, T2 > (T1 value1, T2 value2) {
    try {
        reccorido = new Hashtable ();
        return Compare (value1, value2);
    }
    catch (NotEqualsException ex) {
        PropertyFail = ex.Where ();
        return false;
    }
}
----------------------------------------

private bool Compare < T1, T2 > (T1 value1, T2 value2) {
    if (value1 == null && value2 == null) {
        return true;
    }
    if ((value1 == null) || (value2 == null)) {
        throw new NotEqualsException (value1, value2);
    }
    string key = GetKey < T1, T2 > (value1, value2);
    if (reccorido.Contains (key)) {
        return true;
    }
    reccorido.Add (key, true);
    Type tipo1 = GetType (value1.GetType ());
    Type tipo2 = GetType (value2.GetType ());
    if (tipo1 != tipo2) {
        throw new NotEqualsException (value1, value2);
    }
    if (IsBasicCompare (tipo1)) {
        return CompareBasic (ConvertTo (value1, tipo1), ConvertTo (value2, tipo1));
    }
    dynamic v1 = ConvertTo (value1, tipo1);
    dynamic v2 = ConvertTo (value2, tipo1);
    if (! CompareFields (v1, v2)) {
        throw new NotEqualsException (value1, value2);
    }
    return CompareProperties (v1, v2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_195_215
19949318_19949830_230_247
Title: Recursive call to compare object properties 
----------------------------------------

private bool ComparareGenericList < T > (T value1, T value2) {
    List < PropertyInfo > properties = typeof (T).GetProperties ().Where (p = > p.CanRead && p.Name != "Capacity").ToList ();
    PropertyInfo count = typeof (T).GetProperty ("Count");
    int totalA = ConvertTo (count.GetValue (value1, null), count.PropertyType);
    int totalB = ConvertTo (count.GetValue (value2, null), count.PropertyType);
    if (! Compare (totalA, totalB))
        return false;

    PropertyInfo item = typeof (T).GetProperty ("Item");
    CompareAsInumerable (value1, value2);
    return true;
}
----------------------------------------

private bool CompareFields < T > (T value1, T value2) {
    List < FieldInfo > fields = typeof (T).GetFields ().Where (f = > f.IsPublic).ToList ();
    foreach (var f in fields) {
        dynamic valueA = f.GetValue (value1);
        dynamic valueB = f.GetValue (value2);
        if (! Compare (f.GetValue (value1), f.GetValue (value2))) {
            throw new NotEqualsException (value1, value2);
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_195_215
19949318_19949830_250_288
Title: Recursive call to compare object properties 
----------------------------------------

private bool ComparareGenericList < T > (T value1, T value2) {
    List < PropertyInfo > properties = typeof (T).GetProperties ().Where (p = > p.CanRead && p.Name != "Capacity").ToList ();
    PropertyInfo count = typeof (T).GetProperty ("Count");
    int totalA = ConvertTo (count.GetValue (value1, null), count.PropertyType);
    int totalB = ConvertTo (count.GetValue (value2, null), count.PropertyType);
    if (! Compare (totalA, totalB))
        return false;

    PropertyInfo item = typeof (T).GetProperty ("Item");
    CompareAsInumerable (value1, value2);
    return true;
}
----------------------------------------

private bool CompareAsInumerable < T > (T valueA, T valueB) {
    IEnumerable < object > colA = ((IEnumerable) valueA).Cast < object > ();
    IEnumerable < object > colB = ((IEnumerable) valueB).Cast < object > ();
    if (colA.Count () != colB.Count ())
        return false;

    Type t1 = GetType (colA.GetType ());
    Type t2 = GetType (colB.GetType ());
    if (t1 != t2)
        return false;

    if (colA.Count () > 0) {
        Type itemType = GetTypeOfItem (colA);
        for (int i = 0; i < colA.Count (); i ++) {
            try {
                dynamic a = colA.ElementAt (i);
                dynamic b = colB.ElementAt (i);
                if (! Compare (a, b)) {
                    throw new NotEqualsException (colA.ElementAt (i), colB.ElementAt (i));
                }
            }
            catch (NotEqualsException ex) {
                ex.AddParent (itemType.Name);
                throw;
            }
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_195_215
19949318_19949830_310_331
Title: Recursive call to compare object properties 
----------------------------------------

private bool ComparareGenericList < T > (T value1, T value2) {
    List < PropertyInfo > properties = typeof (T).GetProperties ().Where (p = > p.CanRead && p.Name != "Capacity").ToList ();
    PropertyInfo count = typeof (T).GetProperty ("Count");
    int totalA = ConvertTo (count.GetValue (value1, null), count.PropertyType);
    int totalB = ConvertTo (count.GetValue (value2, null), count.PropertyType);
    if (! Compare (totalA, totalB))
        return false;

    PropertyInfo item = typeof (T).GetProperty ("Item");
    CompareAsInumerable (value1, value2);
    return true;
}
----------------------------------------

private bool CompareBasic < T > (T valueA, T valueB) {
    bool result;
    IComparable selfValueComparer;
    selfValueComparer = valueA as IComparable;
    if (valueA == null && valueB != null || valueA != null && valueB == null)
        result = false;
    else if (selfValueComparer != null && selfValueComparer.CompareTo (valueB) != 0)
        result = false;
    else if (! object.Equals (valueA, valueB))
        result = false;
    else
        result = true;

    if (! result)
        throw new NotEqualsException (valueA, valueB);

    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_195_215
19949318_19949830_37_84
Title: Recursive call to compare object properties 
----------------------------------------

private bool ComparareGenericList < T > (T value1, T value2) {
    List < PropertyInfo > properties = typeof (T).GetProperties ().Where (p = > p.CanRead && p.Name != "Capacity").ToList ();
    PropertyInfo count = typeof (T).GetProperty ("Count");
    int totalA = ConvertTo (count.GetValue (value1, null), count.PropertyType);
    int totalB = ConvertTo (count.GetValue (value2, null), count.PropertyType);
    if (! Compare (totalA, totalB))
        return false;

    PropertyInfo item = typeof (T).GetProperty ("Item");
    CompareAsInumerable (value1, value2);
    return true;
}
----------------------------------------

private bool Compare < T1, T2 > (T1 value1, T2 value2) {
    if (value1 == null && value2 == null) {
        return true;
    }
    if ((value1 == null) || (value2 == null)) {
        throw new NotEqualsException (value1, value2);
    }
    string key = GetKey < T1, T2 > (value1, value2);
    if (reccorido.Contains (key)) {
        return true;
    }
    reccorido.Add (key, true);
    Type tipo1 = GetType (value1.GetType ());
    Type tipo2 = GetType (value2.GetType ());
    if (tipo1 != tipo2) {
        throw new NotEqualsException (value1, value2);
    }
    if (IsBasicCompare (tipo1)) {
        return CompareBasic (ConvertTo (value1, tipo1), ConvertTo (value2, tipo1));
    }
    dynamic v1 = ConvertTo (value1, tipo1);
    dynamic v2 = ConvertTo (value2, tipo1);
    if (! CompareFields (v1, v2)) {
        throw new NotEqualsException (value1, value2);
    }
    return CompareProperties (v1, v2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_230_247
19949318_19949830_250_288
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareFields < T > (T value1, T value2) {
    List < FieldInfo > fields = typeof (T).GetFields ().Where (f = > f.IsPublic).ToList ();
    foreach (var f in fields) {
        dynamic valueA = f.GetValue (value1);
        dynamic valueB = f.GetValue (value2);
        if (! Compare (f.GetValue (value1), f.GetValue (value2))) {
            throw new NotEqualsException (value1, value2);
        }
    }
    return true;
}
----------------------------------------

private bool CompareAsInumerable < T > (T valueA, T valueB) {
    IEnumerable < object > colA = ((IEnumerable) valueA).Cast < object > ();
    IEnumerable < object > colB = ((IEnumerable) valueB).Cast < object > ();
    if (colA.Count () != colB.Count ())
        return false;

    Type t1 = GetType (colA.GetType ());
    Type t2 = GetType (colB.GetType ());
    if (t1 != t2)
        return false;

    if (colA.Count () > 0) {
        Type itemType = GetTypeOfItem (colA);
        for (int i = 0; i < colA.Count (); i ++) {
            try {
                dynamic a = colA.ElementAt (i);
                dynamic b = colB.ElementAt (i);
                if (! Compare (a, b)) {
                    throw new NotEqualsException (colA.ElementAt (i), colB.ElementAt (i));
                }
            }
            catch (NotEqualsException ex) {
                ex.AddParent (itemType.Name);
                throw;
            }
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19949318_19949830_230_247
19949318_19949830_310_331
Title: Recursive call to compare object properties 
----------------------------------------

private bool CompareFields < T > (T value1, T value2) {
    List < FieldInfo > fields = typeof (T).GetFields ().Where (f = > f.IsPublic).ToList ();
    foreach (var f in fields) {
        dynamic valueA = f.GetValue (value1);
        dynamic valueB = f.GetValue (value2);
        if (! Compare (f.GetValue (value1), f.GetValue (value2))) {
            throw new NotEqualsException (value1, value2);
        }
    }
    return true;
}
----------------------------------------

private bool CompareBasic < T > (T valueA, T valueB) {
    bool result;
    IComparable selfValueComparer;
    selfValueComparer = valueA as IComparable;
    if (valueA == null && valueB != null || valueA != null && valueB == null)
        result = false;
    else if (selfValueComparer != null && selfValueComparer.CompareTo (valueB) != 0)
        result = false;
    else if (! object.Equals (valueA, valueB))
        result = false;
    else
        result = true;

    if (! result)
        throw new NotEqualsException (valueA, valueB);

    return result;
}
----------------------------------------
