$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39944637_39944678_1_14
39944637_39944987_1_15
Title: Finding average in a file 
----------------------------------------

def myTest(file) :
INDENT
    with open('filename', 'r') as f :
    INDENT
        lines = f.readlines() < - - - 2
        inflation = []
        header = 1
        for line in lines :
        INDENT
            if header ! = 1 :
            INDENT
                infl = line.split(",") [2]
                inflation.append(float(infl))
            DEDENT
            header += 1 < - - - 1
            avgInflation = sum(inflation) / len(inflation)
        DEDENT
    DEDENT
    return avgInflation
DEDENT
----------------------------------------

def myTest(file) :
INDENT
    with open('filename', 'r') as f :
    INDENT
        inflation = []
        header = 1
        for line in f :
        INDENT
            if header == 1 :
            INDENT
                header += 1
                continue
            DEDENT
            else :
            INDENT
                infl = line.split(",") [2]
                inflation.append(float(infl))
            DEDENT
        DEDENT
        avgInflation = sum(inflation) / len(inflation)
    DEDENT
    return avgInflation
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39982763_39983439_1_7
39982763_39983724_1_9
Title: python try except yield combination 
----------------------------------------

def f(n) :
INDENT
    for i in xrange(n) :
    INDENT
        if i == 3 :
        INDENT
            yield ValueError('hit 3')
            continue
        DEDENT
        yield i
    DEDENT
DEDENT
----------------------------------------

def f(n) :
INDENT
    for i in range(n) :
    INDENT
        accept = True
        try :
        INDENT
            result = 1 / (3 - i)
        DEDENT
        except :
        INDENT
            accept = False
        DEDENT
        yield accept, i
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39999637_40000120_12_19
39999637_44990633_1_15
Title: Approximate pattern matching? 
----------------------------------------

def ApproximatePatternMatching(Pattern, Text, d) :
INDENT
    positions = []
    for i in range(len(Text) - len(Pattern) + 1) :
    INDENT
        if HammingDistance(Pattern, Text [i : i + len(Pattern)]) < d :
        INDENT
            positions.append(i)
        DEDENT
    DEDENT
    return positions
DEDENT
----------------------------------------

def ApproximatePatternMatching(Pattern, Text, d) :
INDENT
    positions = []

    for i in range(len(Text) - len(Pattern) + 1) :
    INDENT
        x = Text [i : i + len(Pattern) + 1]
        if x ! = Pattern :
        INDENT
            y = HammingDistance(Pattern, x)
            if y < = d :
            INDENT
                positions.append(i)
            DEDENT
        DEDENT
    DEDENT
    return positions

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40002118_40003444_1_15
40002118_40003524_1_12
Title: How to check whether the sum exists for a given path in a tree 
----------------------------------------

def doesSumExist(startNode, targetSum) :
INDENT
    def inner(node, targetSum, currentSum) :
    INDENT
        currentSum += node.value
        if currentSum == targetSum :
        INDENT
            return True

        DEDENT
        for child in node.children :
        INDENT
            if inner(child, targetSum, currentSum) :
            INDENT
                return True
            DEDENT
        DEDENT
        return False
    DEDENT
    if startNode is None :
    INDENT
        return False
    DEDENT
    return inner(startNode, targetSum, 0)
DEDENT
----------------------------------------

def doesSumExist(startNode, sumTarget, currentSum) :
INDENT
    totalSum = currentSum
    if startNode is not Null :
    INDENT
        if totalSum + startNode.value == sumTarget :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            totalSum += startNode.value
        DEDENT
    DEDENT
    if doesSumExist(startNode.left, sumTarget, totalSum) :
    INDENT
        return True
    DEDENT
    elif doesSumExist(startNode.right, sumTarget, totalSum) :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40003094_40003830_4_12
40003094_40020074_5_26
Title: Create List without similar crossovers 
----------------------------------------

def non_repeating(values) :
INDENT
    if not len(values) > 1 :
    INDENT
        raise ValueError('must have more than 1 value')
    DEDENT
    candidates = iter(lambda : choice(values), object())

    for k, g in groupby(candidates) :
    INDENT
        yield k
    DEDENT
DEDENT
----------------------------------------

def non_repeating(seq, copies = 3) :
INDENT
    seq = seq * copies
    while True :
    INDENT
        shuffle(seq)
        result, pool = [], []
        for k, g in groupby(seq) :
        INDENT
            result.append(k)
            n = len(list(g)) - 1
            if n :
            INDENT
                pool.extend(n * [k])
            DEDENT
        DEDENT
        for u in pool :
        INDENT
            for i in range(len(result) - 1) :
            INDENT
                if result [i] ! = u ! = result [i + 1] :
                INDENT
                    result.insert(i + 1, u)
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            return result

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40005618_40093862_20_27
40005618_40093862_7_16
Title: QRunnable in multiple cores 
----------------------------------------

def run() :
INDENT
    pool = Pool()
    batch_size = 10
    workers = (Worker('object%d' % i) for i in range(batch_size))
    result = pool.map(caller, workers)
    for item in result :
    INDENT
        print ('%s = %s' % item)
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    print ('running', self.name)
    a = 10
    b = 30
    c = 0
    for i in range(5000000) :
    INDENT
        c += a ** b
    DEDENT
    print ('done', self.name)
    return self.name, c
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40031690_40031897_1_14
40031690_40031967_1_14
Title: How to detect when a maximum number is rolled? 
----------------------------------------

def main() :
INDENT
    minimums = maximums = 0
    choice = int(input("Please enter a number corresponding to the"
            " number of faces on your dice. E.x. 4 for 4-Sided: "))
    die = Die(choice)
    cont = input("Would you like to roll the dice? Y or N: ")
    while cont.lower() == "y" :
    INDENT
        number = die.roll()
        if die.is_min(number) :
        INDENT
            minimums += 1
        DEDENT
        if die.is_max(number) :
        INDENT
            maximums += 1
        DEDENT
        cont = input("Would you like to roll again? Y or N: ")
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    choice = int(input("Please enter a number corresponding to the number of faces on your dice. E.x. 4 for 4-Sided: "))
    valid_inputs = [4, 6, 8, 10, 12]
    if choice not in valid_inputs :
    INDENT
        print ('Valid inputs are: 4,6,8,10,12. Try again.')
        main()
    DEDENT
    cont = input("Would you like to roll the dice? Y or N: ")
    while cont == "y" or cont == "Y" :
    INDENT
        roll = inphandle(choice)
        dice(roll)
        cont = input("Would you like to roll again? Y or N: ")
    DEDENT
    while cont == "n" or cont == "N" :
    INDENT
        easteregg()
        cont = input("Do I get bunus points now?!?")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40049375_40049494_1_14
40049375_40049613_1_13
Title: Return part of result if occur a except 
----------------------------------------

def getAll(m, d, v, t, s, tn, type) :
INDENT
    result = []
    flag = 0
    while flag == 0 :
    INDENT
        try :
        INDENT
            tempResult = getPart(m, d, v)
        DEDENT
        except SomeError :
        INDENT
            print ('The partial result is', result)
            raise
        DEDENT
        for i in range(0, len(tempResult)) :
        INDENT
            result.append(tempResult [i])
        DEDENT
        flag = tempResult [0]
    DEDENT
    return result
DEDENT
----------------------------------------

def getAll(m, d, v, t, s, tn, type) :
INDENT
    result = []
    flag = 0
    try :
    INDENT
        while flag == 0 :
        INDENT
            tempResult = getPart(m, d, v)
            for i in range(0, len(tempResult)) :
            INDENT
                result.append(tempResult [i])
            DEDENT
            flag = tempResult [0]
        DEDENT
        return result
    DEDENT
    except Exception as e :
    INDENT
        print e
        return result
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40049375_40049502_1_13
40049375_40049613_1_13
Title: Return part of result if occur a except 
----------------------------------------

def getAll(m, d, v, t, s, tn, type) :
INDENT
    result = []
    flag = 0
    while flag == 0 :
    INDENT
        try :
        INDENT
            tempResult = getPart(m, d, v)
        DEDENT
        except WhateverError :
        INDENT
            return result
        DEDENT
        for i in range(0, len(tempResult)) :
        INDENT
            result.append(tempResult [i])
        DEDENT
        flag = tempResult [0]
    DEDENT
    return result
DEDENT
----------------------------------------

def getAll(m, d, v, t, s, tn, type) :
INDENT
    result = []
    flag = 0
    try :
    INDENT
        while flag == 0 :
        INDENT
            tempResult = getPart(m, d, v)
            for i in range(0, len(tempResult)) :
            INDENT
                result.append(tempResult [i])
            DEDENT
            flag = tempResult [0]
        DEDENT
        return result
    DEDENT
    except Exception as e :
    INDENT
        print e
        return result
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40059033_40059229_2_12
40059033_40059495_1_20
Title: How to use recursion in python 
----------------------------------------

def macro_interpreter(code, macros, x = 0, y = 0, index = 0) :
INDENT
    for command in code :
    INDENT
        if command in macros :
        INDENT
            return macro_interpreter(macros [command], macros, x, y, index)
        DEDENT
        else :
        INDENT
            if command == 'move' :
            INDENT
                if state [index] == 'N' :
                INDENT
                    return macro_interpreter(code [1 :], macros, x, y = y + 1, index)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def macro_interpreter(code, macros, x = 0, y = 0, index = 0) :
INDENT
    state = ['N', 'E', 'S', 'W']
    for command in code :
    INDENT
        if command in macros :
        INDENT
            x, y, curr_state = macro_interpreter(macros [command], macros, x, y, index)
            index = state.index(curr_state)
        DEDENT
        else :
        INDENT
            if command == 'move' :
            INDENT
                if state [index] == 'N' :
                INDENT
                    y += 1
                DEDENT
                elif state [index] == 'E' :
                INDENT
                    x += 1
                DEDENT
                elif state [index] == 'S' :
                INDENT
                    y -= 1
                DEDENT
                elif state [index] == 'W' :
                INDENT
                    x -= 1
                DEDENT
            DEDENT
            elif command == 'turn' :
            INDENT
                index = (index + 1) % len(state)
            DEDENT
        DEDENT
    DEDENT
    return (x, y, state [index])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40067065_40069183_38_51
40067065_40073783_44_63
Title: python challenge qn for loop 
----------------------------------------

def main() :
INDENT
    flowers_state = [
        ['H', 'H', 'H', 'H', 'H'],
        ['H', 'H', 'I', 'H', 'H'],
        ['H', 'H', 'F', 'H', 'H'],
        ['H', 'H', 'H', 'H', 'H'],
        ['H', 'H', 'H', 'H', 'H']]
    f = Flowers(flowers_state)
    for _ in xrange(0, 3) :
    INDENT
        f.run_rule()
        f.print_states()
        print "\n"
    DEDENT
DEDENT
----------------------------------------

def main(grid, ngens) :
INDENT
    dct = {'H' : 0, 'I' : 1, 'F' : 2}
    rdct = dict(zip(dct.values(), dct.keys()))
    def to_string(array) :
    INDENT
        return '\n'.join(''.join(rdct [x] for x in row) for row in array)
    DEDENT
    def to_array(string) :
    INDENT
        return np.array([[dct [x] for x in row] for row in string.splitlines()])

    DEDENT
    grid = to_array(grid)
    print (to_string(grid))
    print ()
    for i, grid in zip(range(ngens), run(grid)) :
    INDENT
        print (to_string(grid))
        print ()
    DEDENT
    return to_string(grid)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40067659_40067863_1_13
40067659_40067904_1_20
Title: Replacing string in a list of strings 
----------------------------------------

def title_case(title, minor_words) :
INDENT
    minor_set = set(i for i in minor_words.lower().split())
    tokens = title.lower().split()
    new_title = ' '.join(i if i in minor_set else i.capitalize() for i in tokens)
    if len(new_title) > 1 :
    INDENT
        return new_title [0].upper() + new_title [1 :]
    DEDENT
    else :
    INDENT
        return new_title.upper()
    DEDENT
DEDENT
----------------------------------------

def title_case(title, minor_words) :
INDENT
    exclusions = minor_words.lower().split()
    words = title.split()

    for i, word in enumerate(words) :
    INDENT
        if i == 0 or word.lower() not in exclusions :
        INDENT
            words [i] = words [i].title()
        DEDENT
        else :
        INDENT
            words [i] = words [i].lower()
        DEDENT
    DEDENT
    title = " ".join(words)
    return title

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40077180_40077241_1_14
40077180_40077242_1_10
Title: File Access in python 
----------------------------------------

def loadData(self) :
INDENT
    roster = input("Filename to load: ")
    file = open(roster, "r")
    while True :
    INDENT
        inLine = file.readline()
        if not inLine :
        INDENT
            break
        DEDENT
        inLine = inLine [: - 1]
        name, number, jersey = inLine.split(",")
        dict_member [name] = (name, number, jersey)
    DEDENT
    print ("Data Loaded Successfully.")
    file.close()
    return dict_member
DEDENT
----------------------------------------

def loadData(self) :
INDENT
    file = open(input("Filename to load: "), "r")
    text = file.read()
    file.close()
    for line in text :
    INDENT
        name, number, jersey = (line.rstrip()).split(',')
        dict_member [name] = (name, number, jersey)
    DEDENT
    print ("Data Loaded Successfully.")
    return dict_member
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4009899_4009942_1_13
4009899_4013809_7_13
Title: "Stuck in a while loop can you please help?" 
----------------------------------------

def processRecords() :
INDENT
    print ("grade report\n").center(60).upper()
    print "name".upper(), "course".rjust(22).upper(), "grade".rjust(32).upper()
    print "-" * 60
    rec_count = 0
    for line in open("grades.txt", "r") :
    INDENT
        name = line [0 : 20]
        course = line [20 : 50]
        grade = line [50 : 51]
        print name, course.rjust(3), grade.rjust(3)
        rec_count += 1
    DEDENT
    return rec_count
DEDENT
----------------------------------------

def processRecords() :
INDENT
    numOfRecs = 0
    for line in open("grades.txt", "r") :
    INDENT
        numOfRecs += 1
        printLine(line)
    DEDENT
    return numOfRecs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40099498_40112961_1_29
40099498_40121592_58_78
Title: Check row by row in QTableWidget to affect QCombobox 
----------------------------------------

def populate_data(self) :
INDENT
    geo_name = self.all_mesh
    for row_index, geo_item in enumerate(geo_name) :
    INDENT
        new_item = QtGui.QTableWidgetItem(geo_item)
        self.mesh_table.setItem(row_index, 0, new_item)
        geo_exclude_num = ''.join(i for i in geo_item if not i.isdigit())
        color_list = read_json(geo_exclude_num)
        color_list.add("")
        color_combobox = QtGui.QComboBox()
        color_combobox.addItems(list(sorted(color_list)))
        self.mesh_table.setCellWidget(row_index, 1, color_combobox)

        objAttr = '%s.pyPickle' % geo_item
        storedData = attrToPy(objAttr)
        if 'color_set' in storedData :
        INDENT
            color_variant = storedData ['color_set']
        DEDENT
        else :
        INDENT
            color_variant = ''
        DEDENT
        combo_index = color_combobox.findText(color_variant, QtCore.Qt.MatchFixedString)
        color_combobox.setCurrentIndex(0 if combo_index < 0 else combo_index)
    DEDENT
DEDENT
----------------------------------------

def populate_data(self) :
INDENT
    geo_name = self.all_mesh
    for row_index, geo_item in enumerate(geo_name) :
    INDENT
        new_item = QtGui.QTableWidgetItem(geo_item)
        self.mesh_table.setItem(row_index, 0, new_item)
        geo_exclude_num = ''.join(i for i in geo_item if not i.isdigit())
        color_list = read_json(geo_exclude_num)
        color_list.add("")
        color_combobox = QtGui.QComboBox()
        color_combobox.addItems(list(sorted(color_list)))
        self.mesh_table.setCellWidget(row_index, 1, color_combobox)
        self.color_value_to_combobox(geo_item, color_combobox)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40104510_40104979_1_16
40104510_40105516_1_14
Title: modify lists removing elements without making a mess 
----------------------------------------

def modi(la, lb) :
INDENT
    del_la = []
    del_lb = []
    for i, (a, b) in enumerate(zip(la, lb)) :
    INDENT
        if a == b :
        INDENT
            del_la.append(i)
            del_lb.append(i)
        DEDENT
        if a > b :
        INDENT
            del_la.append(i)
        DEDENT
        if a < b :
        INDENT
            del_lb.append(i)
        DEDENT
    DEDENT
    for x in del_la [- 1 : : - 1] :
    INDENT
        del la [x]
    DEDENT
    for x in del_lb [- 1 : : - 1] :
    INDENT
        del lb [x]
    DEDENT
    return la, lb
DEDENT
----------------------------------------

def modi(la, lb) :
INDENT
    for i, j in zip(la, lb) :
    INDENT
        if i == j :
        INDENT
            la.remove(i)
            lb.remove(i)
        DEDENT
        elif i > j :
        INDENT
            la.remove(i)
        DEDENT
        else :
        INDENT
            lb.remove(j)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40111680_40111746_26_32
40111680_40111886_26_32
Title: IndexError: list index out of range in Python 3 
----------------------------------------

def __str__(self) :
INDENT
    res = []
    for card in self.cards :
    INDENT
        res.append(str(card))
    DEDENT
    return '\n'.join(res)

DEDENT
----------------------------------------

def __str__(self) :
INDENT
    res = []
    for card in self.cards :
    INDENT
        res.append(str(card))
    DEDENT
    return '\n'.join(res)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40118113_40130160_17_26
40118113_45658808_34_49
Title: How to convert JSON data into a tree image? 
----------------------------------------

def get_edges(treedict, parent = None) :
INDENT
    name = next(iter(treedict.keys()))
    if parent is not None :
    INDENT
        edges.append((parent, name))
    DEDENT
    for item in treedict [name] ["children"] :
    INDENT
        if isinstance(item, dict) :
        INDENT
            get_edges(item, parent = name)
        DEDENT
        else :
        INDENT
            edges.append((name, item))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_edges(treedict, parent = None) :
INDENT
    name = next(iter(treedict.keys()))
    if parent is not None :
    INDENT
        edges.append((parent, name))
    DEDENT
    for item in treedict [name] :
    INDENT
        if isinstance(item, dict) :
        INDENT
            get_edges(item, parent = name)
        DEDENT
        elif isinstance(item, list) :
        INDENT
            for el in item :
            INDENT
                if isinstance(item, dict) :
                INDENT
                    edges.append((parent, item.keys() [0]))
                    get_edges(item [item.keys() [0]])
                DEDENT
                else :
                INDENT
                    edges.append((parent, el))
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT
            edges.append((name, item))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4013838_10541214_6_26
4013838_4014164_3_29
Title: urlencode a multidimensional dictionary in python 
----------------------------------------

def recursive_urlencode(data) :
INDENT
    def r_urlencode(data, parent = None, pairs = None) :
    INDENT
        if pairs is None :
        INDENT
            pairs = {}
        DEDENT
        if parent is None :
        INDENT
            parents = []
        DEDENT
        else :
        INDENT
            parents = parent
        DEDENT
        for key, value in data.items() :
        INDENT
            if hasattr(value, 'values') :
            INDENT
                parents.append(key)
                r_urlencode(value, parents, pairs)
                parents.pop()
            DEDENT
            else :
            INDENT
                pairs [renderKey(parents + [key])] = renderVal(value)
            DEDENT
        DEDENT
        return pairs
    DEDENT
    return urllib.urlencode(r_urlencode(data))

DEDENT
----------------------------------------

def recursive_urlencode(d) :
INDENT
    def recursion(d, base = []) :
    INDENT
        pairs = []
        for key, value in d.items() :
        INDENT
            new_base = base + [key]
            if hasattr(value, 'values') :
            INDENT
                pairs += recursion(value, new_base)
            DEDENT
            else :
            INDENT
                new_pair = None
                if len(new_base) > 1 :
                INDENT
                    first = urllib.quote(new_base.pop(0))
                    rest = map(lambda x : urllib.quote(x), new_base)
                    new_pair = "%s[%s]=%s" % (first, ']['.join(rest), urllib.quote(unicode(value)))
                DEDENT
                else :
                INDENT
                    new_pair = "%s=%s" % (urllib.quote(unicode(key)), urllib.quote(unicode(value)))
                DEDENT
                pairs.append(new_pair)
            DEDENT
        DEDENT
        return pairs
    DEDENT
    return '&'.join(recursion(d))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4013838_10541214_7_23
4013838_39082010_17_31
Title: urlencode a multidimensional dictionary in python 
----------------------------------------

def r_urlencode(data, parent = None, pairs = None) :
INDENT
    if pairs is None :
    INDENT
        pairs = {}
    DEDENT
    if parent is None :
    INDENT
        parents = []
    DEDENT
    else :
    INDENT
        parents = parent
    DEDENT
    for key, value in data.items() :
    INDENT
        if hasattr(value, 'values') :
        INDENT
            parents.append(key)
            r_urlencode(value, parents, pairs)
            parents.pop()
        DEDENT
        else :
        INDENT
            pairs [renderKey(parents + [key])] = renderVal(value)
        DEDENT
    DEDENT
    return pairs
DEDENT
----------------------------------------

def r_urlencode(data) :
INDENT
    if isinstance(data, list) or isinstance(data, tuple) :
    INDENT
        for i in range(len(data)) :
        INDENT
            parents.append(i)
            r_urlencode(data [i])
            parents.pop()
        DEDENT
    DEDENT
    elif isinstance(data, dict) :
    INDENT
        for key, value in data.items() :
        INDENT
            parents.append(key)
            r_urlencode(value)
            parents.pop()
        DEDENT
    DEDENT
    else :
    INDENT
        pairs [renderKey(parents)] = str(data)
    DEDENT
    return pairs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40153438_40156242_16_31
40153438_40156242_38_48
Title: GAE NBD entities still seen in Datastore viewer after they are deleted from Python and Memchach is flushed 
----------------------------------------

def get(self) :
INDENT
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write('Get!\n')
    name = self.request.get('name')
    out_str = "Should not be seen"
    try :
    INDENT
        ancestor_key = datum_key [name]
        qry = Data.owner_query(ancestor_key)
        data = qry.fetch()
        out_str = data [- 1].value
    DEDENT
    except KeyError :
    INDENT
        out_str = "None"
    DEDENT
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write(out_str)

DEDENT
----------------------------------------

def get(self) :
INDENT
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write('End!')
    print "datum_key.values():", datum_key.values()
    print "before delete"
    self.show_entities()
    ndb.delete_multi(datum_key.values())
    print "after delete"
    self.show_entities()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40153438_40156242_16_31
40153438_40156242_50_60
Title: GAE NBD entities still seen in Datastore viewer after they are deleted from Python and Memchach is flushed 
----------------------------------------

def get(self) :
INDENT
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write('Get!\n')
    name = self.request.get('name')
    out_str = "Should not be seen"
    try :
    INDENT
        ancestor_key = datum_key [name]
        qry = Data.owner_query(ancestor_key)
        data = qry.fetch()
        out_str = data [- 1].value
    DEDENT
    except KeyError :
    INDENT
        out_str = "None"
    DEDENT
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write(out_str)

DEDENT
----------------------------------------

def get(self) :
INDENT
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write('Set!\n')
    name = self.request.get('name')
    data = Data(parent = ndb.Key("Datum", KEY),
        name = name,
        value = self.request.get('value'))
    ret_key = data.put()
    datum_key [name] = ret_key
    print "data:", data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40153438_40156242_38_48
40153438_40156242_50_60
Title: GAE NBD entities still seen in Datastore viewer after they are deleted from Python and Memchach is flushed 
----------------------------------------

def get(self) :
INDENT
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write('End!')
    print "datum_key.values():", datum_key.values()
    print "before delete"
    self.show_entities()
    ndb.delete_multi(datum_key.values())
    print "after delete"
    self.show_entities()

DEDENT
----------------------------------------

def get(self) :
INDENT
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write('Set!\n')
    name = self.request.get('name')
    data = Data(parent = ndb.Key("Datum", KEY),
        name = name,
        value = self.request.get('value'))
    ret_key = data.put()
    datum_key [name] = ret_key
    print "data:", data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40155268_40156146_114_135
40155268_40158955_20_27
Title: QtGui.QTextEdit set line color baced on what text the line contains 
----------------------------------------

def highlightBlock(self, text) :
INDENT
    for expression, nth, format in self.rules :
    INDENT
        index = expression.indexIn(text, 0)
        while index > = 0 :
        INDENT

            index = expression.pos(nth)
            length = expression.cap(nth).length()
            self.setFormat(index, length, format)
            index = expression.indexIn(text, index + length)
        DEDENT
    DEDENT
    self.setCurrentBlockState(0)

    in_multiline = self.match_multiline(text, * self.tri_single)
    if not in_multiline :
    INDENT
        in_multiline = self.match_multiline(text, * self.tri_double)

    DEDENT
DEDENT
----------------------------------------

def highlightBlock(self, text) :
INDENT
    if text.startswith('--[') :
    INDENT
        self.setFormat(0, len(text), self.sectionFormat)
    DEDENT
    elif text.startswith('[ERROR]') :
    INDENT
        self.setFormat(0, len(text), self.errorFormat)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40155268_40156146_66_113
40155268_40158955_29_36
Title: QtGui.QTextEdit set line color baced on what text the line contains 
----------------------------------------

def __init__(self, document) :
INDENT
    QSyntaxHighlighter.__init__(self, document)

    self.tri_single = (QRegExp("'''"), 1, STYLES ['string2'])
    self.tri_double = (QRegExp('"""'), 2, STYLES ['string2'])
    rules = []

    rules += [(r'\b%s\b' % w, 0, STYLES ['keyword']) for w in PythonHighlighter.keywords]
    rules += [(r'%s' % o, 0, STYLES ['operator']) for o in PythonHighlighter.operators]
    rules += [(r'%s' % b, 0, STYLES ['brace']) for b in PythonHighlighter.braces]

    rules += [
        (r'\bself\b', 0, STYLES ['self']),
        (r'"[^"\\]*(\\.[^"\\]*)*"', 0, STYLES ['string']),
        (r"'[^'\\]*(\\.[^'\\]*)*'", 0, STYLES ['string']),
        (r'\bdef\b\s*(\w+)', 1, STYLES ['defclass']),
        (r'\bclass\b\s*(\w+)', 1, STYLES ['defclass']),
        (r'#[^\n]*', 0, STYLES ['comment']),
        (r'\b[+-]?[0-9]+[lL]?\b', 0, STYLES ['numbers']),
        (r'\b[+-]?0[xX][0-9A-Fa-f]+[lL]?\b', 0, STYLES ['numbers']),
        (r'\b[+-]?[0-9]+(?:\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\b', 0, STYLES ['numbers']),
        ]

    self.rules = [(QRegExp(pat), index, fmt) for (pat, index, fmt) in rules]

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.editor = QtGui.QTextEdit(self)
    self.highlighter = Highlighter(self.editor.document())
    self.editor.setText(sample)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.editor)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40156634_40156934_1_36
40156634_40157523_1_26
Title: How to find a 2x2 object in a 2D list? 
----------------------------------------

def is_face_on_photo(photo) :
INDENT
    found = False
    for row, photo_row in enumerate(photo) :
    INDENT
        for col, letter in enumerate(photo_row) :
        INDENT
            if (letter in "face") and col + 1 < len(photo_row) and row + 1 < len(photo) :
            INDENT
                found = True
                num_found = {"f" : 0, "a" : 0, "c" : 0, "e" : 0}
                right_letter = photo_row [col + 1]
                below_letter = photo [row + 1] [col]
                below_right_letter = photo [row + 1] [col + 1]
                letters = [letter, right_letter, below_letter, below_right_letter]

                for let in letters :
                INDENT
                    if let in num_found :
                    INDENT
                        num_found [let] += 1

                    DEDENT
                DEDENT
                for let in "face" :
                INDENT
                    if num_found [let] == 0 :
                    INDENT
                        found = False
                        break
                    DEDENT
                DEDENT
            DEDENT
            if found :
            INDENT
                break
            DEDENT
        DEDENT
        if found :
        INDENT
            break
        DEDENT
    DEDENT
    return found
DEDENT
----------------------------------------

def is_face_on_photo(arr) :
INDENT
    word = set('face')
    num_rows = len(arr)
    num_cols = len(arr [0])
    for y, row in enumerate(arr) :
    INDENT
        for x, cell in enumerate(row) :
        INDENT
            if cell in word :
            INDENT
                if x + 3 < num_cols and set(row [x : x + 4]) == word :
                INDENT
                    return True
                DEDENT
                if y + 3 < num_rows and set(arr [i] [x] for i in range(y, y + 4)) == word :
                INDENT
                    return True
                DEDENT
                if x + 1 < num_cols and y + 1 < num_cols and set(arr [y] [x : x + 2] + arr [y + 1] [x : x + 2]) == word :
                INDENT
                    return True
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return False
    arr = [
        ['x', 'x', 'x', 'x'],
        ['x', 'f', 'c', 'x'],
        ['x', 'a', 'e', 'x'],
        ['x', 'x', 'x', 'x']]
    print (is_face_on_photo(arr))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4016798_4016874_2_12
4016798_4023031_2_14
Title: Testing call order across mock objects with Mox and Python 
----------------------------------------

def test_modify(self) :
INDENT
    mock_record = self.mox.CreateMockAnthing()
    mock_storeModifier = self.mox.CreateMockAnything()
    mock_storeModifier.read("test_key").AndReturn(mock_record)
    mock_storeModifier.modify(mock_record)
    mock_storeModifier.update("test_key", mock_record)
    self.mox.ReplayAll()
    updater = ReadModifyUpdate(mock_storeModifier, mock_storeModifier)
    updater.modify("test_key")
DEDENT
----------------------------------------

def test_modify(self) :
INDENT
    mock_record = self.mox.CreateMockAnthing()
    mock_store = self.mox.CreateMockAnything()
    mock_modifier = self.mox.CreateMockAnything()
    sequence = OrderedCallSequence(self)
    mock_store.read("test_key").WithSideEffects(sequence.assertOrder()).AndReturn(mock_record)
    mock_modifier.modify(mock_record).WithSideEffects(sequence.assertOrder())
    mock_store.update("test_key", mock_record).WithSideEffects(sequence.assertOrder())
    self.mox.ReplayAll()
    updater = ReadModifyUpdate(mock_store, mock_modifier)
    updater.modify("test_key")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40168199_40178542_41_53
40168199_40187751_65_75
Title: Tkinter project to turn pictures to greyscale 
----------------------------------------

def main() :
INDENT
    window = tk.Tk()
    window.title("Testing stuff")
    window.geometry("600x600+10+20")
    canvas = tk.Canvas(window)
    canvas.config(background = "blue")
    canvas.pack(fill = tk.BOTH, expand = True)
    images = add_images(canvas)
    window.mainloop()
DEDENT
----------------------------------------

def main() :
INDENT
    window = Tk()
    window.title("Testing stuff")
    window.geometry("600x600+10+20")
    a_canvas = Canvas(window)
    a_canvas.config(background = "blue")
    a_canvas.pack(fill = BOTH, expand = True)
    a_canvas.pack()
    image_list = run_shit(a_canvas)
    window.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40182073_40182634_9_44
40182073_40183675_9_40
Title: python risk game i can't get it to compare all the numbers only the last ones 
----------------------------------------

def main() :
INDENT
    print ("Welcome to risk dice")
    playing = input("Press Enter to Roll or Q to quit")
    if playing == 'q' :
    INDENT
        print ("Thanks for Playing")
        time.sleep(2)
        quit()
    DEDENT
    elif playing ! = 'q' :
    INDENT
        rolls = int(float(input('how many soliders are you attacking with:')))
        rolls_attack_res = [r(min, max) for i in range(rolls)]
        print ('you got a...')
        print ('\n'.join(rolls_attack_res))
        rolls = int(float(input('how many soliders are you defending with:')))
        rolls_defense_res = [r(min, max) for i in range(rolls)]
        print ('you got a...')
        print ('\n'.join(rolls_defense_res))

        max_len = max(len(rolls_attack_res), len(rolls_defense_res))
        rolls_attack_res.extend([0] * (max_len - len(rolls_attack_res)))
        rolls_defense_res.extend([0] * (max_len - len(rolls_defense_res)))
        rolls_attack_res.sort()
        rolls_defense_res.sort()
        rolls_res = zip(rolls_attack_res, rolls_defense_res)
        num_of_attack_wins = len([1 for a, d in rolls_res if a > d])
        num_of_defense_wins = len(rolls_res) - num_of_attack_wins
        if num_of_defense_wins > = num_of_attack_wins :
        INDENT
            print ('defence wins')
        DEDENT
        else :
        INDENT
            print ('attackers win')
        DEDENT
        main()
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    print ("Welcome to risk dice")
    playing = input("Press Enter to Roll or Q to quit")
    if playing == 'q' :
    INDENT
        print ("Thanks for Playing")
        time.sleep(2)
        quit()
    DEDENT
    elif playing ! = 'q' :
    INDENT
        rolls = int(float(input('how many soliders are you attacking with:')))
        a = [r(min, max) for x in range(rolls)]
        a.sort(reverse = True)
        print ('you got a...')
        print (a)
        rolls = int(float(input('how many soliders are you defending with:')))
        d = [r(min, max) for x in range(rolls)]
        d.sort(reverse = True)
        print ('you got a...')
        print (d)
        if a < = d :
        INDENT
            print ('defence wins the first battal')
        DEDENT
        elif a > d :
        INDENT
            print ('attackers win the first battal')
        DEDENT
        a2 = a [1]
        d2 = d [1]
        if a2 < = d2 :
        INDENT
            print ('defence wins the second battal')
        DEDENT
        elif a2 > d2 :
        INDENT
            print ('attackers win the second battal')
        DEDENT
        main()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40182180_40182966_10_19
40182180_40182966_25_36
Title: Trouble starting multiprocess threads and using events 
----------------------------------------

def run(self) :
INDENT
    i = 0
    run = True
    while run == True :
    INDENT
        print 'putting'
        self.q.put('foo %d' % i)
        time.sleep(.5)
        if self.e.is_set() :
        INDENT
            run = False
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            value = self.q.get(False)
            print value
        DEDENT
        except Empty :
        INDENT
            print 'Nothing to process atm'
            self.e.set()
        DEDENT
        time.sleep(.2)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40183333_40186971_42_61
40183333_40186971_85_96
Title: How can copy with drag and drop from one list but use move for internal drag and drop 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget.__init__(self)
    self.name = ''
    self.widget_QHBoxLayout = QtGui.QHBoxLayout(self)
    self.widget_QHBoxLayout.setSpacing(0)
    self.widget_QHBoxLayout.setContentsMargins(0, 0, 0, 0)
    self.name_QLabel = QtGui.QLabel(self)
    self.widget_QHBoxLayout.addWidget(self.name_QLabel)
    self.user_QLabel = QtGui.QLabel(self)
    self.widget_QHBoxLayout.addWidget(self.user_QLabel)
    self.widget_QHBoxLayout.setSpacing(0)
    self.widget_QHBoxLayout.setContentsMargins(0, 0, 0, 0)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(DragDropListWidget, self).__init__(parent)
    self._dropping = False
    self.itemPressed.connect(self.clicked)
    self.data = ''
    self.name = ''
    self.external = ''
    self.internal = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40185280_40185910_12_26
40185280_40185910_32_49
Title: Multiprocess Event not triggering 
----------------------------------------

def run(self) :
INDENT
    i = 0
    run = True
    while run :
    INDENT
        print 'putting'
        self.q.put('foo %d' % i)
        time.sleep(.5)
        print 'proc test if set ' + str(self.e.is_set())
        if self.e.is_set() :
        INDENT
            print "Exiting get_count"
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            time.sleep(1)
            value = self.q.get(False)
            print "val is ", value
            self.e.set()
            print "Event is ", self.e.is_set()
        DEDENT
        except Queue.Empty :
        INDENT
            print 'Nothing to process atm'
            self.e.set()
        DEDENT
        if self.e.is_set() :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40187266_40187414_1_15
40187266_40187553_1_18
Title: if statements or while loop conditions? 
----------------------------------------

def newtonsMethod(poly, x_, timeout) :
INDENT
    estimate = 0
    epsilon = 1e-20
    deriv_poly = findDerivative(poly)
    while True :
    INDENT
        value = evaluatePoly(poly, x_)
        if abs(value) < epsilon :
        INDENT
            return x_
        DEDENT
        deriv = evaluatePoly(deriv_poly, x_)
        if abs(deriv) < epsilon or estimate > timeout :
        INDENT
            raise ValueError("Not converging")
        DEDENT
        x_ -= value / deriv
        estimate += 1
    DEDENT
DEDENT
----------------------------------------

def newtonsMethod(poly, x_, epsilon, timeout) :
INDENT
    deriv_poly = findDerivative(poly)
    count = 1
    while True :
    INDENT
        deriv = evaluatePoly(deriv_poly, x_)
        value = evaluatePoly(poly, x_)
        if abs(value) < epsilon :
        INDENT
            boolean = True
            return (x_, boolean)
        DEDENT
        if abs(deriv) < epsilon or count > timeout :
        INDENT
            boolean = False
            return (x_, boolean)
        DEDENT
        x_ -= value / deriv
        count += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40192529_40192790_15_33
40192529_40195784_11_24
Title: Python printing from functions 
----------------------------------------

def menu() :
INDENT
    run = C()

    while True :
    INDENT

        q = input("a = ask, p = print, q = quit: ")
        if q == "q" :
        INDENT
            break
        DEDENT
        elif q == "a" :
        INDENT
            run.set_gen()
        DEDENT
        elif q == "p" :
        INDENT
            run.display_gen()

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def menu() :
INDENT
    RUN = C()
    while True :
    INDENT
        q = raw_input("press a to ask or b to print: ")
        if q == ("a") :
        INDENT
            RUN.set_gen()
        DEDENT
        elif q == ("b") :
        INDENT
            RUN.display_gen()

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40199261_40199603_10_22
40199261_40210564_18_29
Title: write an asynchronous http client using twisted framework 
----------------------------------------

def main() :
INDENT
    results = {}
    threads = []
    for i in range(5) :
    INDENT
        url = 'http://webpage/{}'.format(i)
        t = Thread(target = make_request, kwargs = {'url' : url, 'results' : results})
        t.start()
        threads.append(t)
    DEDENT
    for t in threads() :
    INDENT
        t.join()
    DEDENT
    print results
DEDENT
----------------------------------------

def main(reactor) :
INDENT
    urls = [
        'http://swapi.co/api/films/schema',
        'http://swapi.co/api/people/schema',
        'http://swapi.co/api/planets/schema',
        'http://swapi.co/api/species/schema',
        'http://swapi.co/api/starships/schema',
        ]
    d = fetchURL(* urls)
    d.addCallback(compare)
    return d
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40204990_40205172_3_13
40204990_40205348_1_10
Title: Input needing to be entered twice for my code to work 
----------------------------------------

def playAgain() :
INDENT
    print ('Do you want to play again? (yes or no)')
    while True :
    INDENT
        choice = input("><![CDATA[ ")
        if choice.lower().startswith('yes') :
        INDENT
            start()
        DEDENT
        elif choice.lower().startswith('no') :
        INDENT
            print ('Bye for now')
            exit(0)
        DEDENT
        else :
        INDENT
            print ("I don't understand what you mean?")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def playAgain() :
INDENT
    while True :
    INDENT
        ans = input("Do you want to play again? (yes or no) ")
        if ans.lower().startswith('y') :
        INDENT
            return True
        DEDENT
        elif ans.lower().startswith('n') :
        INDENT
            return False
        DEDENT
        else :
        INDENT
            print ("I don't understand what you mean?")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40204990_40205348_1_10
40204990_40205877_3_15
Title: Input needing to be entered twice for my code to work 
----------------------------------------

def playAgain() :
INDENT
    while True :
    INDENT
        ans = input("Do you want to play again? (yes or no) ")
        if ans.lower().startswith('y') :
        INDENT
            return True
        DEDENT
        elif ans.lower().startswith('n') :
        INDENT
            return False
        DEDENT
        else :
        INDENT
            print ("I don't understand what you mean?")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def playAgain() :
INDENT
    print ('Do you want to play again? (yes or no)')
    while True :
    INDENT
        inp = input("><![CDATA[ ").lower()
        if inp.startswith('y') :
        INDENT
            start()
        DEDENT
        elif inp.startswith('n') :
        INDENT
            print ('Bye for now')
            exit(0)
        DEDENT
        else :
        INDENT
            print ("I don't understand, what do you mean?")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40209092_40209282_1_10
40209092_40209837_10_18
Title: Using turtle in Python to draw six-pointed stars with different side lengths 
----------------------------------------

def sixPtdStar(sz) :
INDENT
    triangle(sz)
    tess.lt(90)
    tess.pu()
    tess.fd((2.0 / 3.0) * sz)
    tess.rt(90)
    tess.fd(sz)
    tess.pd()
    tess.rt(180)
    triangle(sz)
DEDENT
----------------------------------------

def sixPtdStar(size) :
INDENT
    triangle(size)
    tess.lt(30)
    tess.pu()
    tess.fd(size * WIDTH_RATIO)
    tess.lt(150)
    tess.pd()
    triangle(size)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40214679_40216143_16_26
40214679_40216143_2_12
Title: Sorting a python array by column with different data types 
----------------------------------------

def compare(x, y) :
INDENT
    if x [2] is None :
    INDENT
        return 1
    DEDENT
    elif y [2] is None :
    INDENT
        return - 1
    DEDENT
    elif x [2] < y [2] :
    INDENT
        return 1
    DEDENT
    elif x [2] > y [2] :
    INDENT
        return - 1
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------

def compare(x, y) :
INDENT
    if x [2] is None :
    INDENT
        return 1
    DEDENT
    elif y [2] is None :
    INDENT
        return - 1
    DEDENT
    elif x [2] > y [2] :
    INDENT
        return 1
    DEDENT
    elif x [2] < y [2] :
    INDENT
        return - 1
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40224680_40225024_1_13
40224680_40225154_1_11
Title: How to make a function return a list of indices of the characters in the second string that appears in the first string? 
----------------------------------------

def get_indices_from_the_second_string(string1, string2) :
INDENT
    acc = []
    string1_index = 0
    for char in string2 :
    INDENT
        while string1 [string1_index] ! = char :
        INDENT
            string1_index += 1
            if string1_index > = len(string1) :
            INDENT
                return acc
            DEDENT
        DEDENT
        acc.append(string1_index)
        string1_index += 1
        if string1_index > = len(string1) :
        INDENT
            return acc
        DEDENT
    DEDENT
    return acc
DEDENT
----------------------------------------

def get_indices_from_the_second_string(string1, string2) :
INDENT
    acc = []
    s2_counter = 0
    for i, letter in enumerate(string1) :
    INDENT
        if letter == string2 [s2_counter] :
        INDENT
            acc.append(i)
            s2_counter += 1
            if len(acc) == len(string2) :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    return acc
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40249063_40249209_2_15
40249063_40249256_1_14
Title: Longest sequence of even numbers in python 
----------------------------------------

def evenSeq(a) :
INDENT
    largest = 0
    temp_largest = 0
    location = 0
    for count, value in enumerate(a) :
    INDENT
        if value % 2 == 0 :
        INDENT
            temp_largest += 1
        DEDENT
        else :
        INDENT
            temp_largest = 0
        DEDENT
        if temp_largest > = largest :
        INDENT
            largest = temp_largest
            location = count + 1 - temp_largest
        DEDENT
    DEDENT
    return location, largest
DEDENT
----------------------------------------

def evenSeq(seq) :
INDENT
    i = startindex = maxindex = maxcount = 0
    while i < len(seq) :
    INDENT
        if seq [i] % 2 == 0 :
        INDENT
            startindex = i
            while i < len(seq) and seq [i] % 2 == 0 :
            INDENT
                i += 1
            DEDENT
            if maxcount < i - startindex :
            INDENT
                maxcount = i - startindex
                maxindex = startindex
            DEDENT
        DEDENT
        i += 1
    DEDENT
    return (maxindex, maxcount)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40275578_40275827_14_20
40275578_40299884_44_50
Title: batch rename files by common unique value 
----------------------------------------

def get_uid_filename_map(filenames, get_uid_func) :
INDENT
    uid_filename_map = {}
    for filename in filenames :
    INDENT
        uid_filename_map [get_uid_func(filename)] = filename
    DEDENT
    return uid_filename_map
DEDENT
----------------------------------------

def get_uid_filename_map(filenames, get_uid_func) :
INDENT
    uid_filename_map = {}
    for filename in filenames :
    INDENT
        uid_filename_map [get_uid_func(filename)] = filename
    DEDENT
    return uid_filename_map

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40277389_40277602_3_8
40277389_40277901_1_7
Title: Python - How to write recursively without global var 
----------------------------------------

def recurse(i, Xmlfile) :
INDENT
    if i < n :
    INDENT
        Xmlfile.write(str(i))
        recurse(i + 1, Xmlfile)
    DEDENT
    return (None)
DEDENT
----------------------------------------

def recurse(i, Xmlfile, deepness = 0, times = - 1) :
INDENT
    if times == - 1 :
    INDENT
        times = i
    DEDENT
    if deepness < times :
    INDENT
        Xmlfile.write(str(i))
        recurse(i + 1, Xmlfile, deepness + 1, times)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40287398_45868253_10_45
40287398_45868253_79_112
Title: PyQt5 styleSheet Animation 
----------------------------------------

def __init__(self) :
INDENT
    QLabel.__init__(self)
    color1 = QtGui.QColor(255, 0, 0)
    color2 = QtGui.QColor(255, 144, 0)
    color3 = QtGui.QColor(255, 255, 0)
    color4 = QtGui.QColor(224, 192, 192)
    color5 = QtGui.QColor(192, 224, 192)
    color6 = QtGui.QColor(192, 192, 192)
    color7 = QtGui.QColor(212, 208, 200)
    self.co_get = 0
    self.co_set = 0
    byar = QtCore.QByteArray()
    byar.append('zcolor')
    self.color_anim = QtCore.QPropertyAnimation(self, byar)
    self.color_anim.setStartValue(color4)
    self.color_anim.setKeyValueAt(0.15, color1)
    self.color_anim.setKeyValueAt(0.3, color2)
    self.color_anim.setKeyValueAt(0.5, color3)
    self.color_anim.setKeyValueAt(0.75, color2)
    self.color_anim.setEndValue(color4)
    self.color_anim.setDuration(2000)
    self.color_anim.setLoopCount(1)
    self.color_anim_ok = QtCore.QPropertyAnimation(self, byar)
    self.color_anim_ok.setStartValue(color5)
    self.color_anim_ok.setKeyValueAt(0.5, color6)
    self.color_anim_ok.setEndValue(color7)
    self.color_anim_ok.setDuration(1000)
    self.color_anim_ok.setLoopCount(- 1)
    self.custom_anim = QtCore.QPropertyAnimation(self, byar)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QDialog.__init__(self, parent)
    self.co_press = 0
    self.setModal(True)
    self.setWindowTitle('Animation Example')
    self.edit_pad = QLineEdit('-1')
    self.edit_rad = QLineEdit('-1')
    self._mapHeight = QLineEdit('0')
    self.layout = QFormLayout()
    self.lab_pad = QLabel('Padding (px):')
    self.lab_rad = QLabel('Radius (px):')
    self.layout.addRow(self.lab_pad, self.edit_pad)
    self.layout.addRow(self.lab_rad, self.edit_rad)
    self.anila = AnimatedLabel()
    self.anila.setText('Label for animation:')
    self.layout.addRow(self.anila, self._mapHeight)
    self.ok = QPushButton()
    self.ok.setText('OK -- change animation')
    self.ok.clicked.connect(self._okPress)
    self.layout.addRow(self.ok)
    self.layout.setLabelAlignment(QtCore.Qt.AlignRight)
    self.setLayout(self.layout)
    self.set_initial_data()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40311109_40311162_4_29
40311109_40311249_1_16
Title: How would I write a program that can call a variable from another def? 
----------------------------------------

def GameMode() :
INDENT
    global word
    choice = input('Play alone or play with friends? A F : ')
    choice = choice.upper()
    if choice == 'A' :
    INDENT
        wordslotmachine = ['stand', 'emerald', 'splash']
        word = random.choice(wordslotmachine)
        word = word.upper()
        Rules()
    DEDENT
    elif choice == 'F' :
    INDENT
        word = input('Enter your word for your friends to guess: ')
        word = word.upper()
        Rules()
    DEDENT
    else :
    INDENT
        choice = input('Please enter A or F: ')
        choice = choice.upper()

    DEDENT
    def MainGame() :
    INDENT
        guesses = ''
        turns = 10
        underscore = 0
        seconds = 1
        checker = 0
        cheaterchance = 5
        global word
    DEDENT
DEDENT
----------------------------------------

def GameMode() :
INDENT
    choice = input('Play alone or play with friends? A F : ')
    choice = choice.upper()
    if choice == 'A' :
    INDENT
        wordslotmachine = ['stand', 'emerald', 'splash']
        word = random.choice(wordslotmachine)
        word = word.upper()
        Rules()
    DEDENT
    elif choice == 'F' :
    INDENT
        word = input('Enter your word for your friends to guess: ')
        word = word.upper()
        Rules()
    DEDENT
    else :
    INDENT
        choice = input('Please enter A or F: ')
        choice = choice.upper()
    DEDENT
    return word
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40315936_40315987_1_14
40315936_40315994_1_27
Title: "Python - Recursion: duplicate int duplicate int in a list duplicate int in a nested list" 
----------------------------------------

def copy(nested_list) :
INDENT
    if isinstance(nested_list, int) :
    INDENT
        return copy([nested_list])
    DEDENT
    result = []
    for elem in nested_list :
    INDENT
        if isinstance(elem, int) :
        INDENT
            result.append(elem)
            result.append(elem)
        DEDENT
        else :
        INDENT
            result.append(copy(elem))
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def copy(nested_list) :
INDENT
    new_list = []

    if isinstance(nested_list, list) and len(nested_list) == 0 :
    INDENT
        return new_list

    DEDENT
    elif isinstance(nested_list, int) :
    INDENT
        new_list.append(nested_list)
        new_list.append(nested_list)
    DEDENT
    else :
    INDENT
        if isinstance(nested_list, list) :
        INDENT
            for num in range(len(nested_list)) :
            INDENT
                if isinstance(nested_list [num], int) :
                INDENT
                    new_list.append(nested_list [num])
                    new_list.append(nested_list [num])
                DEDENT
                elif isinstance(nested_list [num], list) :
                INDENT
                    tempList = copy(nested_list [num])
                    new_list.append(tempList)
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return new_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40315936_40315994_1_27
40315936_40316517_1_11
Title: "Python - Recursion: duplicate int duplicate int in a list duplicate int in a nested list" 
----------------------------------------

def copy(nested_list) :
INDENT
    new_list = []

    if isinstance(nested_list, list) and len(nested_list) == 0 :
    INDENT
        return new_list

    DEDENT
    elif isinstance(nested_list, int) :
    INDENT
        new_list.append(nested_list)
        new_list.append(nested_list)
    DEDENT
    else :
    INDENT
        if isinstance(nested_list, list) :
        INDENT
            for num in range(len(nested_list)) :
            INDENT
                if isinstance(nested_list [num], int) :
                INDENT
                    new_list.append(nested_list [num])
                    new_list.append(nested_list [num])
                DEDENT
                elif isinstance(nested_list [num], list) :
                INDENT
                    tempList = copy(nested_list [num])
                    new_list.append(tempList)
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return new_list
DEDENT
----------------------------------------

def copy(items) :
INDENT
    if isinstance(items, int) :
    INDENT
        return [items, items]
    DEDENT
    result = []
    for element in items :
    INDENT
        if isinstance(element, int) :
        INDENT
            result.extend(copy(element))
        DEDENT
        else :
        INDENT
            result.append(copy(element))
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40323075_40323356_1_19
40323075_44833963_14_24
Title: How can I start 2 function (turtle) at same time (PYTHON) 
----------------------------------------

def func1() :
INDENT
    for i in range(4) :
    INDENT
        nah.right(45)
        yield
        nah.forward(40)
        yield
        nah.left(45)
        yield
        nah.forward(30)
        yield
        nah.left(45)
        yield
        nah.forward(40)
        yield
        nah.right(45)
        yield
        nah.forward(30)
        yield
    DEDENT
DEDENT
----------------------------------------

def func1() :
INDENT
    for _ in range(4) :
    INDENT
        right(nah1, 45)
        forward(nah1, 40)
        left(nah1, 45)
        forward(nah1, 30)
        left(nah1, 45)
        forward(nah1, 40)
        right(nah1, 45)
        forward(nah1, 30)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40323075_40323356_20_37
40323075_44833963_25_35
Title: How can I start 2 function (turtle) at same time (PYTHON) 
----------------------------------------

def func2() :
INDENT
    for e in range(4) :
    INDENT
        nah1.left(45)
        yield
        nah1.forward(40)
        yield
        nah1.right(45)
        yield
        nah1.forward(30)
        yield
        nah1.right(45)
        yield
        nah1.forward(40)
        yield
        nah1.left(45)
        yield
        nah1.forward(30)
        yield
    DEDENT
DEDENT
----------------------------------------

def func2() :
INDENT
    for _ in range(4) :
    INDENT
        left(nah2, 45)
        forward(nah2, 40)
        right(nah2, 45)
        forward(nah2, 30)
        right(nah2, 45)
        forward(nah2, 40)
        left(nah2, 45)
        forward(nah2, 30)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40324756_40324867_11_19
40324756_50403049_4_13
Title: Where can I access request parameters in Django Rest Framework? 
----------------------------------------

def get_queryset(self) :
INDENT
    req = self.request
    print (req)
    make = req.query_params.get('make')
    if make :
    INDENT
        self.queryset = uploadobject.objects.filter(make = make)
        return self.queryset
    DEDENT
    else :
    INDENT
        return self.queryset
    DEDENT
DEDENT
----------------------------------------

def get_queryset(self) :
INDENT
    queryset = Purchase.objects.all()
    username = self.request.query_params.get('username', None)
    if username is not None :
    INDENT
        queryset = queryset.filter(purchaser__username = username)
    DEDENT
    return queryset
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40326651_40329046_16_22
40326651_42047294_8_17
Title: "Flask-Mail - Sending email asynchronously based on Flask-Cookiecutter" 
----------------------------------------

def send_email(to, subject, template, ** kwargs) :
INDENT
    app = current_app._get_current_object()
    msg = Message(subject, recipients = [to])
    msg.html = render_template('emails/' + template, ** kwargs)
    thr = Thread(target = send_async_email, args = [app, msg])
    thr.start()
    return thr
DEDENT
----------------------------------------

def send_email(subject, sender, recipients, text_body, html_body = None, ** kwargs) :
INDENT
    app.logger.info("send_email(subject='{subject}', recipients=['{recp}'], text_body='{txt}')".format(sender = sender, subject = subject, recp = recipients, txt = text_body))
    msg = Message(subject, sender = sender, recipients = recipients, ** kwargs)
    msg.body = text_body
    msg.html = html_body
    app.logger.info("Message(to=[{m.recipients}], from='{m.sender}')".format(m = msg))
    _send_async_email(app, msg)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40345815_40346363_1_14
40345815_40346379_27_34
Title: "Am implementing a queue in python What is making the dequeue part not to work?" 
----------------------------------------

def dequeue(self) :
INDENT
    if self.head == None :
    INDENT
        raise Exception("Queue is empty")
    DEDENT
    else :
    INDENT
        node = self.head
        prev = None
        while node :
        INDENT
            if node.next :
            INDENT
                prev = node = node.next
            DEDENT
            else :
            INDENT
                self.cur_node = prev
                if prev :
                INDENT
                    prev.next = None
                DEDENT
                return node.data
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def dequeue(self) :
INDENT
    if self.head :
    INDENT
        data = self.head.data
        self.head = self.head.next
        return data
    DEDENT
    else :
    INDENT
        raise Queue.EmptyQueue
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40347123_40347240_1_12
40347123_40347310_3_13
Title: Function that retrieves and returns letters from a list of lists 
----------------------------------------

def get_symbols(lot) :
INDENT
    symbols = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'
    newlot = []
    for i in lot :
    INDENT
        if i == symbols :
        INDENT
            newlot.append(symbols)
            return newlot
        DEDENT
        else :
        INDENT
            return None
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_symbols(lot) :
INDENT
    symbols = string.ascii_lowercase + string.ascii_uppercase
    newlot = []
    for sublot in lot :
    INDENT
        for x in sublot :
        INDENT
            if x in symbols and x not in newlot :
            INDENT
                newlot.append(x)
            DEDENT
        DEDENT
    DEDENT
    return newlot
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40351291_40351513_1_12
40351291_40352357_10_29
Title: Tail recursion to loop 
----------------------------------------

def pow_mod(a, b) :
INDENT
    if b == 0 :
    INDENT
        return 1
    DEDENT
    c = 1;
    while b > 1 :
    INDENT
        if b % 2 :
        INDENT
            c *= a
        DEDENT
        a *= a
        b //= 2
        a %= 10000
        c %= 10000
    DEDENT
    return a * c % 10000
DEDENT
----------------------------------------

def pow_mod(a, b) :
INDENT
    lst = []
    while b :
    INDENT
        lst.insert(0, b)
        b = b / / 2
    DEDENT
    def _pow_mod(a, b, answer) :
    INDENT
        if b == 2 :
        INDENT
            return a * a % 10000;
        DEDENT
        else :
        INDENT
            return ((b % 2 * (a - 1) + 1) * answer ** 2) % 10000
        DEDENT
    DEDENT
    answer = 1
    for b in lst :
    INDENT
        answer = _pow_mod(a, b, answer)
    DEDENT
    return answer

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4037076_4038276_32_43
4037076_4038276_6_26
Title: wxPython CheckListBox with HTML 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None)
    self.options = HtmlCheckListBox(
        self,
        [
            "<i>one</i>",
            "<b>two</b>",
            "<u>three</u>"])

DEDENT
----------------------------------------

def __init__(self, parent, choices = None) :
INDENT
    wx.html.HtmlWindow.__init__(self, parent)
    check_box = """
        <wxp module="wx" class="CheckBox"><![CDATA[
            <param name="id" value="%d"><![CDATA[
        </wxp>
        """
    self._ids = dict()
    if choices :
    INDENT
        items = list()
        for c, choice in enumerate(choices) :
        INDENT
            i = wx.NewId()
            self._ids [i] = c
            items.append((check_box % i) + choice)
        DEDENT
        self.SetPage("<hr>".join(items))
    DEDENT
    self.Bind(wx.EVT_CHECKBOX, self.OnCheck)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40377634_40377965_1_22
40377634_40377971_3_9
Title: Python: adding list to dictionary with padded zeros in list 
----------------------------------------

def merge_tuples(line_a, line_b, line_c) :
INDENT
    id_dict = dict()
    for line in line_a :
    INDENT
        if line [0] in id_dict :
        INDENT
            id_dict [line [0]].append(line [1])
        DEDENT
        else :
        INDENT
            id_dict [line [0]] = [line [1], 0, 0]
        DEDENT
    DEDENT
    for line in line_b :
    INDENT
        if line [0] in id_dict :
        INDENT
            id_dict [line [0]] [1] = line [1]
        DEDENT
        else :
        INDENT
            id_dict [line [0]] = [0, line [1], 0]
        DEDENT
    DEDENT
    for line in line_c :
    INDENT
        if line [0] in id_dict :
        INDENT
            id_dict [line [0]] [2] = line [1]
        DEDENT
        else :
        INDENT
            id_dict [line [0]] = [0, 0, line [1]]
        DEDENT
    DEDENT
    return id_dict
DEDENT
----------------------------------------

def merge_tuples(* args) :
INDENT
    id_dict = defaultdict(lambda : [0] * len(args))
    for i, lines in enumerate(args) :
    INDENT
        for line in lines :
        INDENT
            id_dict [line [0]] [i] = line [1]
        DEDENT
    DEDENT
    return id_dict
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40379205_40379787_33_39
40379205_40383666_22_29
Title: destroy() tkinter toplevel from queue fails silently (race condition?) 
----------------------------------------

def check_queue() :
INDENT
    while not app_queue.empty() :
    INDENT
        queue_item = app_queue.get()
        queue_item()
    DEDENT
    app.after(100, check_queue)

DEDENT
----------------------------------------

def check_queue() :
INDENT
    while not app_queue.empty() :
    INDENT
        queue_item = app_queue.get()
        queue_item()
        my_lock.release()
    DEDENT
    app.after(100, check_queue)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40379903_40380109_20_50
40379903_40380109_7_18
Title: __init__() missing argument: 'checkbutton' - Python 
----------------------------------------

def __init__(self, master) :
INDENT
    self.frame1 = tk.Frame(master)
    self.frame1.pack()

    print ("test frame")
    self.var1 = tk.IntVar()
    self.checkbutton = tk.Checkbutton(self.frame1, text = "Automatisch", variable = self.var1, onvalue = 1, offvalue = 0, pady = 20).grid(row = 0, column = 0, sticky = tk.E)
    print ("test checkbutton")
    self.Extend_Label = tk.Label(self.frame1, text = "Uitrol afstand", pady = 20).grid(row = 2, column = 0, sticky = tk.E)
    self.Retract_Label = tk.Label(self.frame1, text = "Inrol afstand", pady = 20).grid(row = 3, column = 0, sticky = tk.E)
    self.Temperture_Label = tk.Label(self.frame1, text = "Temperatuur Trigger", pady = 20).grid(row = 4, column = 0, sticky = tk.E)
    self.LightIntensity_Label = tk.Label(self.frame1, text = "Lichtintensiteit Trigger", pady = 20).grid(row = 5, column = 0, sticky = tk.E)
    print ("test label")
    self.Extend_Entry = tk.Entry(self.frame1).grid(row = 2, column = 1, sticky = tk.E)
    self.Retract_Entry = tk.Entry(self.frame1).grid(row = 3, column = 1, sticky = tk.E)
    self.Temperture_Entry = tk.Entry(self.frame1).grid(row = 4, column = 1, sticky = tk.E)
    self.LightIntensity_Entry = tk.Entry(self.frame1).grid(row = 5, column = 1, sticky = tk.E)
    print ("test entry")
    self.A = tk.Button(self.frame1, text = "Inrollen", padx = 10, pady = 20).grid(row = 6, column = 0)
    self.B = tk.Button(self.frame1, text = "Uitrollen", padx = 10, pady = 20).grid(row = 6, column = 1)
    print ("test button")
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    print ("hoi")
    window = tk.Tk()
    window.title("Project: Embedded Systems")
    rootframe = tk.Frame(window, width = 1800, height = 750)
    rootframe.pack()
    Unit(rootframe)
    window.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40386187_40395330_22_39
40386187_40398076_1_27
Title: Can't draw parabolic curve correctly with turtle graphics 
----------------------------------------

def throw_turtle(turtle) :
INDENT
    angle = int(input("Enter Angle (in degrees): "))
    power = int(input("Enter Power: "))

    for time in range(1, 20) :
    INDENT

        x = power * math.cos(math.radians(angle)) * time + origin_x
        y = power * math.sin(math.radians(angle)) * time - (((time ** 2) * G) / 2) + origin_y
        turtle.goto(x, y)
        turtle.stamp()

    DEDENT
DEDENT
----------------------------------------

def throw_turtle(turtle, target) :
INDENT
    angle = int(input("Enter Angle:"))
    power = int(input("Enter Power:"))
    '''
    parabola fomula: x coordinate: speed(in here, that is power) * cos(anlge)*time
                              y coordinate: speed*sin(angle)*time - (gravity speed*time**2)/2'''
    for time in range(1, 20) :
    INDENT
        x = power * math.cos(math.radians(angle)) * time + origin_x
        y = power * math.sin(math.radians(angle)) * time - (((time ** 2) * g) / 2) + origin_y
        turtle.goto(x, y)
        turtle.stamp()
        max_target_x = target.xcor() + 1
        min_target_y = target.ycor() - 1
        max_target_y = target.ycor() + 1
        min_target_y = target.ycor() - 1
        if ((turtle.xcor() > = min_target_x) or (turtle.xcor() < = max_target_x)) and ((turtle.ycor() > = min_target_y) or (turtle.ycor() < = max_target_y)) :
        INDENT
            print ("******Target is HIT!!! ******")
            print ("End of Game")
            flag = True
            break
        DEDENT
    DEDENT
    else :
    INDENT
        print ("You missed...")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40391901_40392101_12_23
40391901_42844998_9_27
Title: Getting Webcam Footage from OpenCV to PyQt 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget().__init__()
    self.camera = cv2.VideoCapture(0)
    self.label = QtGui.QLabel()
    layout = QtGui.QHBoxLayout()
    self.setLayout(layout)
    layout.addWidget(self.label)

    self.workThread = WorkThread(self.readVideo)
    self.update_video.connect(self.draw)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(VideoCapture, self).__init__()

    self.label = QtGui.QLabel(self)

    self.label.setGeometry(0, 0, 640, 480)

    self.workThread = WorkThread()

    self.connect(self.workThread, QtCore.SIGNAL('update_Camera'), self.draw)
    self.workThread.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40391901_40392101_42_52
40391901_42844998_32_41
Title: Getting Webcam Footage from OpenCV to PyQt 
----------------------------------------

def draw(self) :
INDENT
    print "I should Redraw"
    height, width, channel = self.frame.shape
    bpl = 3 * width
    qImg = QImage(self.frame.data, width, height, bpl, QImage.Format_RGB888)
    pix = QtGui.QPixmap(qImg)
    self.label.setPixmap(pix)

DEDENT
----------------------------------------

def draw(self, img) :
INDENT
    print "I should Redraw"
    height, width, channel = img.shape
    bpl = 3 * width
    self.qImg = QImage(img, width, height, bpl, QImage.Format_RGB888)
    pix = QtGui.QPixmap(self.qImg)
    self.label.setPixmap(pix)
    self.label.show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40392463_40392988_1_12
40392463_40393114_3_14
Title: Python product of arbitrary number of variables 
----------------------------------------

def prods(factors, limit, index = 0, total = 1) :
INDENT
    if index > = len(factors) :
    INDENT
        yield total
        return
    DEDENT
    while total < = limit :
    INDENT
        for res in prods(factors, limit, index + 1, total) :
        INDENT
            yield res
        DEDENT
        total *= factors [index]
    DEDENT
DEDENT
----------------------------------------

def prods(factors, limit, index = 0, total = 1) :
INDENT
    if index > = len(factors) :
    INDENT
        yield total
        return
    DEDENT
    iters = []
    while total < limit :
    INDENT
        iters.append(prods(factors, limit, index + 1, total))
        total *= factors [index]
    DEDENT
    for res in merge(* iters) :
    INDENT
        yield res
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4039374_4039387_1_8
4039374_4039472_1_9
Title: "How can I return the odd numbers of a list using only recursion in Python?" 
----------------------------------------

def find_odds(numbers, odds) :
INDENT
    if len(numbers) == 0 :
    INDENT
        return
    DEDENT
    v = numbers.pop()
    if v % 2 == 1 :
    INDENT
        odds.append(v)
    DEDENT
    find_odds(numbers, odds)
DEDENT
----------------------------------------

def find_odds(numbers, odds) :
INDENT
    if len(numbers) == 0 :
    INDENT
        return odds
    DEDENT
    if numbers [0] % 2 == 1 :
    INDENT
        odds.append(numbers [0])
    DEDENT
    return find_odds(numbers [1 :], odds)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40399049_40403051_14_20
40399049_40403051_29_34
Title: Parallel display updates for Animations in pygame 
----------------------------------------

def update(self) :
INDENT
    self.state += 1
    self.image.fill((0, 0, 0))
    pygame.draw.circle(self.image, (200, 5 * self.state, 0), self.image.get_rect().center, self.state)
    if self.state > 30 :
    INDENT
        self.kill()
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    if not screen.get_rect().contains(self.rect) :
    INDENT
        self.dir *= - 1
    DEDENT
    self.image.fill((self.rect.x % 255, 60, 200))
    self.rect.move_ip(self.dir, 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40404162_40404329_1_14
40404162_40404817_7_13
Title: Get child node if exists otherwise create in Python 
----------------------------------------

def get_node_by_path(path) :
INDENT
    cur_node = root
    for elem_name in path :
    INDENT
        found = False
        for child in cur_node.children :
        INDENT
            if child.name == elem_name :
            INDENT
                cur_node = child
                found = True
                break
            DEDENT
        DEDENT
        if not found :
        INDENT
            new_node = Node(elem_name)
            cur_node.children.append(new_node)
            cur_node = new_node
        DEDENT
    DEDENT
    return cur_node
DEDENT
----------------------------------------

def get_node_by_path(path = []) :
INDENT
    for c, n in enumerate(reversed(path)) :
    INDENT
        if not c :
        INDENT
            Node(name = n)
        DEDENT
        else :
        INDENT
            Node(name = n, childern = path [- c :])
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4042452_47804416_15_23
4042452_47911405_4_42
Title: Display help message with python argparse when script is called without any arguments 
----------------------------------------

def main(argp = None) :
INDENT
    if argp is None :
    INDENT
        argp = ARGP.parse_args()
    DEDENT
    if 'soemthing_went_wrong' and not argp.example :
    INDENT
        ARGP.print_help()
        ARGP.exit(status = 128, message = "\nI just don't know what went wrong, maybe missing --example condition?\n")

    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    parser = argparse.ArgumentParser()
    parser.add_argument('-d', '--days', required = False, help = "Check mapped inventory that is x days old", default = None)
    parser.add_argument('-e', '--event', required = False, action = "store", dest = "event_id",
        help = "Check mapped inventory for a specific event", default = None)
    parser.add_argument('-b', '--broker', required = False, action = "store", dest = "broker_id",
        help = "Check mapped inventory for a broker", default = None)
    parser.add_argument('-k', '--keyword', required = False, action = "store", dest = "event_keyword",
        help = "Check mapped inventory for a specific event keyword", default = None)
    parser.add_argument('-p', '--product', required = False, action = "store", dest = "product_id",
        help = "Check mapped inventory for a specific product", default = None)
    parser.add_argument('-m', '--metadata', required = False, action = "store", dest = "metadata",
        help = "Check mapped inventory for specific metadata, good for debugging past tix", default = None)
    parser.add_argument('-u', '--update', required = False, action = "store_true", dest = "make_updates",
        help = "Update the event for a product if there is a difference, default No", default = False)
    args = parser.parse_args()
    days = args.days
    event_id = args.event_id
    broker_id = args.broker_id
    event_keyword = args.event_keyword
    product_id = args.product_id
    metadata = args.metadata
    make_updates = args.make_updates
    no_change_counter = 0
    change_counter = 0
    req_arg = bool(days) + bool(event_id) + bool(broker_id) + bool(product_id) + bool(event_keyword) + bool(metadata)
    if not req_arg :
    INDENT
        print ("Need to specify days, broker id, event id, event keyword or past tickets full metadata")
        parser.print_help()
        sys.exit()
    DEDENT
    elif req_arg ! = 1 :
    INDENT
        print ("More than one option specified. Need to specify only one required option")
        parser.print_help()
        sys.exit()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40427481_40428151_9_18
40427481_40429153_9_16
Title: push engine in tornado 
----------------------------------------

def get_data() :
INDENT
    while True :
    INDENT
        yield {
            "current_time" : datetime.datetime.strftime(
                datetime.datetime.now(), "%Y-%m-%d %H:%M:%S")}
        time.sleep(1)

    DEDENT
DEDENT
----------------------------------------

def get_data() :
INDENT
    process = Subprocess(['tail', '-f', '/var/log/system.log'], stdout = Subprocess.STREAM)
    while True :
    INDENT
        line = yield process.stdout.read_until('\n')
        BroadcastHandler.broadcast(line)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40434080_40434127_1_12
40434080_40434160_1_11
Title: Combine two strings (char by char) and repeat last char of shortest one 
----------------------------------------

def extendedString(string1, string2) :
INDENT
    x = string1
    y = string2
    z = ""
    if len(x) == len(y) :
    INDENT
        return "".join(i for j in zip(string1, string2) for i in j)
    DEDENT
    elif len(x) < len(y) :
    INDENT
        x = x + x [- 1] * (len(y) - len(x))
        return extendedString(x, y)
    DEDENT
    else :
    INDENT
        y = y + y [- 1] * (len(x) - len(y))
        return extendedString(x, y)
    DEDENT
DEDENT
----------------------------------------

def extendedString(string1, string2) :
INDENT
    x = string1
    y = string2
    if len(x) < len(y) :
    INDENT
        x = x + x [- 1] * (len(y) - len(x))
    DEDENT
    elif len(x) > len(y) :
    INDENT
        y = y + y [- 1] * (len(x) - len(y))
    DEDENT
    return "".join(i for j in zip(x, y) for i in j)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40434080_40434127_1_12
40434080_40434228_1_17
Title: Combine two strings (char by char) and repeat last char of shortest one 
----------------------------------------

def extendedString(string1, string2) :
INDENT
    x = string1
    y = string2
    z = ""
    if len(x) == len(y) :
    INDENT
        return "".join(i for j in zip(string1, string2) for i in j)
    DEDENT
    elif len(x) < len(y) :
    INDENT
        x = x + x [- 1] * (len(y) - len(x))
        return extendedString(x, y)
    DEDENT
    else :
    INDENT
        y = y + y [- 1] * (len(x) - len(y))
        return extendedString(x, y)
    DEDENT
DEDENT
----------------------------------------

def extendedString(string1, string2) :
INDENT
    if len(string1) < = len(string2) :
    INDENT
        x = string1
        y = string2
    DEDENT
    else :
    INDENT
        x = string2
        y = string1
    DEDENT
    z = ""
    for i in range(len(x)) :
    INDENT
        z += x [i]
        z += y [i]
    DEDENT
    if i < len(y) :
    INDENT
        for j in range(i + 1, len(y)) :
        INDENT
            z += x [i]
            z += y [j]
        DEDENT
    DEDENT
    return z
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40434080_40434160_1_11
40434080_40434228_1_17
Title: Combine two strings (char by char) and repeat last char of shortest one 
----------------------------------------

def extendedString(string1, string2) :
INDENT
    x = string1
    y = string2
    if len(x) < len(y) :
    INDENT
        x = x + x [- 1] * (len(y) - len(x))
    DEDENT
    elif len(x) > len(y) :
    INDENT
        y = y + y [- 1] * (len(x) - len(y))
    DEDENT
    return "".join(i for j in zip(x, y) for i in j)
DEDENT
----------------------------------------

def extendedString(string1, string2) :
INDENT
    if len(string1) < = len(string2) :
    INDENT
        x = string1
        y = string2
    DEDENT
    else :
    INDENT
        x = string2
        y = string1
    DEDENT
    z = ""
    for i in range(len(x)) :
    INDENT
        z += x [i]
        z += y [i]
    DEDENT
    if i < len(y) :
    INDENT
        for j in range(i + 1, len(y)) :
        INDENT
            z += x [i]
            z += y [j]
        DEDENT
    DEDENT
    return z
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40441135_40441492_4_17
40441135_40442543_10_23
Title: Make function recursive 
----------------------------------------

def turtle_spiral(forward) :
INDENT
    minus = 8
    randm = random.randrange(5)
    colours = ["blue", "orange", "yellow", "green", "purple", "black", "red", "pink"]
    if forward < = 10 :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        t.color(colours [randm])
        t.right(90)
        t.fd(forward)
        return turtle_spiral(forward - minus)
    DEDENT
DEDENT
----------------------------------------

def turtle_spiral(turtle, length, delta, limit) :
INDENT
    if length < limit :
    INDENT
        return
    DEDENT
    extent = 360 / delta
    for radius in range(delta) :
    INDENT
        turtle.circle(length - radius, extent = extent)
        if randrange(delta) == 0 :
        INDENT
            turtle.color(choice(colors))
        DEDENT
    DEDENT
    turtle_spiral(turtle, length - delta, delta, limit)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40453496_40580156_32_41
40453496_40707100_20_28
Title: Python multiprocessing - Capturing signals to restart child processes or shut down parent process 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        print self.counter
        time.sleep(1)
        self.counter += 1

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    signal(SIGTERM, SIG_DFL)
    while True :
    INDENT
        print self.counter
        time.sleep(1)
        self.counter += 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40453496_40580156_32_41
40453496_40707100_8_14
Title: Python multiprocessing - Capturing signals to restart child processes or shut down parent process 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        print self.counter
        time.sleep(1)
        self.counter += 1

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    signal(SIGTERM, SIG_DFL)
    while True :
    INDENT
        print "Hello World"
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40453496_40580156_42_94
40453496_40707100_29_59
Title: Python multiprocessing - Capturing signals to restart child processes or shut down parent process 
----------------------------------------

def signal_handler(helloProcess, counterProcess, signum, frame) :
INDENT
    print multiprocessing.active_children()
    print "helloProcess: ", helloProcess
    print "counterProcess: ", counterProcess
    print "current_process: ", multiprocessing.current_process()
    if signum == 17 :
    INDENT
        for signame in [SIGINT, SIGTERM, SIGQUIT, SIGCHLD] :
        INDENT
            signal(signame, SIG_DFL)
        DEDENT
        print "helloProcess: ", helloProcess.is_alive()
        if not helloProcess.is_alive() :
        INDENT
            print "Restarting helloProcess"
            helloProcess = HelloWorld()
            helloProcess.start()
        DEDENT
        print "counterProcess: ", counterProcess.is_alive()
        if not counterProcess.is_alive() :
        INDENT
            print "Restarting counterProcess"
            counterProcess = Counter()
            counterProcess.start()

        DEDENT
        for signame in [SIGINT, SIGTERM, SIGQUIT, SIGCHLD] :
        INDENT
            signal(signame, partial(signal_handler, helloProcess, counterProcess))

        DEDENT
    DEDENT
    else :
    INDENT

        signal(SIGCHLD, SIG_IGN)
        if helloProcess.is_alive() :
        INDENT
            print "Stopping helloProcess"
            helloProcess.terminate()
        DEDENT
        if counterProcess.is_alive() :
        INDENT
            print "Stopping counterProcess"
            counterProcess.terminate()
        DEDENT
        sys.exit(0)

    DEDENT
DEDENT
----------------------------------------

def signal_handler(signum, _) :
INDENT
    global helloProcess, counterProcess
    if signum == SIGCHLD :
    INDENT
        pid, status = os.waitpid(- 1, os.WNOHANG | os.WUNTRACED | os.WCONTINUED)
        if os.WIFCONTINUED(status) or os.WIFSTOPPED(status) :
        INDENT
            return
        DEDENT
        if os.WIFSIGNALED(status) or os.WIFEXITED(status) :
        INDENT
            if helloProcess.pid == pid :
            INDENT
                print ("Restarting helloProcess")
                helloProcess = HelloWorld()
                helloProcess.start()
            DEDENT
            elif counterProcess.pid == pid :
            INDENT
                print ("Restarting counterProcess")
                counterProcess = Counter()
                counterProcess.start()
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT

        signal(SIGCHLD, SIG_DFL)
        if helloProcess.is_alive() :
        INDENT
            print ("Stopping helloProcess")
            helloProcess.terminate()
        DEDENT
        if counterProcess.is_alive() :
        INDENT
            print ("Stopping counterProcess")
            counterProcess.terminate()
        DEDENT
        sys.exit(0)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40453496_40707100_20_28
40453496_40707100_8_14
Title: Python multiprocessing - Capturing signals to restart child processes or shut down parent process 
----------------------------------------

def run(self) :
INDENT
    signal(SIGTERM, SIG_DFL)
    while True :
    INDENT
        print self.counter
        time.sleep(1)
        self.counter += 1

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    signal(SIGTERM, SIG_DFL)
    while True :
    INDENT
        print "Hello World"
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40454536_40454603_11_36
40454536_40454778_52_67
Title: "How can I keep track of scores in this quiz? Also is this the best approach? (Python 3.5.2)" 
----------------------------------------

def ask_question(self) :
INDENT
    print ('Question {0} -\n'.format(self.number))
    print (self.question + "\n")
    answers = self.incorrect + [self.correct]
    letters = dict(enumerate(string.ascii_lowercase, 1))
    random.shuffle(answers)
    for x in range(len(answers)) :
    INDENT
        print (letters [x + 1] + ": " + answers [x])
    DEDENT
    print ()
    flipped = dict((v, k) for k, v in letters.items())
    acceptable = False
    while not acceptable :
    INDENT
        answer_input = input('Please insert your answer:')
        try :
        INDENT
            idx = flipped [answer_input]
            acceptable = True
        DEDENT
        except KeyError :
        INDENT
            print ("Invalid Input. Please try again. Only enter a letter")
        DEDENT
    DEDENT
    if answers [idx - 1] == self.correct :
    INDENT
        print ("Correct!")
        return 1
    DEDENT
    else :
    INDENT
        print ("Incorrect")
        return 0
    DEDENT
DEDENT
----------------------------------------

def ask_question(question_dict) :
INDENT
    print (question_dict ['question'])
    for i, option in enumerate(question_dict ['options']) :
    INDENT
        print (i, ': ', option)
        answer = input('Please insert your answer:')

    DEDENT
    if answer == str(question_dict ['correct_answer']) :
    INDENT
        print ('Correct!')
        return True
    DEDENT
    else :
    INDENT
        print ('Wrong!')
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40454536_40454603_11_36
40454536_40454854_19_29
Title: "How can I keep track of scores in this quiz? Also is this the best approach? (Python 3.5.2)" 
----------------------------------------

def ask_question(self) :
INDENT
    print ('Question {0} -\n'.format(self.number))
    print (self.question + "\n")
    answers = self.incorrect + [self.correct]
    letters = dict(enumerate(string.ascii_lowercase, 1))
    random.shuffle(answers)
    for x in range(len(answers)) :
    INDENT
        print (letters [x + 1] + ": " + answers [x])
    DEDENT
    print ()
    flipped = dict((v, k) for k, v in letters.items())
    acceptable = False
    while not acceptable :
    INDENT
        answer_input = input('Please insert your answer:')
        try :
        INDENT
            idx = flipped [answer_input]
            acceptable = True
        DEDENT
        except KeyError :
        INDENT
            print ("Invalid Input. Please try again. Only enter a letter")
        DEDENT
    DEDENT
    if answers [idx - 1] == self.correct :
    INDENT
        print ("Correct!")
        return 1
    DEDENT
    else :
    INDENT
        print ("Incorrect")
        return 0
    DEDENT
DEDENT
----------------------------------------

def ask_question(question) :
INDENT
    question.pose_question()
    print ()
    question.display_answers()
    print ()
    ans = input('Please insert your answer:')
    return question.check_ans(ans)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40454536_40454778_52_67
40454536_40454854_19_29
Title: "How can I keep track of scores in this quiz? Also is this the best approach? (Python 3.5.2)" 
----------------------------------------

def ask_question(question_dict) :
INDENT
    print (question_dict ['question'])
    for i, option in enumerate(question_dict ['options']) :
    INDENT
        print (i, ': ', option)
        answer = input('Please insert your answer:')

    DEDENT
    if answer == str(question_dict ['correct_answer']) :
    INDENT
        print ('Correct!')
        return True
    DEDENT
    else :
    INDENT
        print ('Wrong!')
        return False
    DEDENT
DEDENT
----------------------------------------

def ask_question(question) :
INDENT
    question.pose_question()
    print ()
    question.display_answers()
    print ()
    ans = input('Please insert your answer:')
    return question.check_ans(ans)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40478662_40478750_1_27
40478662_40479078_1_16
Title: Program keeps giving me an attribute error: 'int' has no attribute 'upper' 
----------------------------------------

def main() :
INDENT
    list1 = []
    amountOfscoresEntered = 0
    while True :
    INDENT

        userInput = input("Please enter an integer between 0 and 10: ")

        if userInput.upper() == "Q" :
        INDENT
            break
        DEDENT
        elif 0 < int(userInput) < 10 :
        INDENT
            print ("Invalid Input")
        DEDENT
        else :
        INDENT

            list1.append(int(userInput))
            amountOfscoresEntered += 1
        DEDENT
    DEDENT
    totalNumofPointsearned = sum(list1)
DEDENT
----------------------------------------

def main() :
INDENT
    list1 = []
    amountOfScoresEntered = 0
    totalNumOfPointsEarned = 0
    userInput = raw_input("Please enter an integer between 0 and 10: ")
    while str(userInput).upper() ! = "Q" :
    INDENT

        amountOfScoresEntered = amountOfScoresEntered + 1
        if int(userInput) < 0 and int(userInput) > 10 :
        INDENT
            print ("Invalid Input")
        DEDENT
        else :
        INDENT
            list1.append(userInput)
            totalNumofPointsEarned = sum(list1)
        DEDENT
        userInput = raw_input("Please enter an integer between 0 and 10: ")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40484435_40497984_14_29
40484435_40497984_54_77
Title: Making a plot in a second window using data from main window 
----------------------------------------

def __init__(self) :
INDENT
    super(Newsphere, self).__init__()
    self.mainbox = QtGui.QWidget()
    self.mainbox.setLayout(QtGui.QHBoxLayout())
    self.setCentralWidget(self.mainbox)
    self.spin = QtGui.QSpinBox()
    self.spin.setValue(5)
    self.spin.setMaximum(10)
    self.spin.setMinimum(1)
    self.checkPlot = QtGui.QCheckBox("Check")
    self.mainbox.layout().addWidget(self.spin)
    self.mainbox.layout().addWidget(self.checkPlot)
    self.Plot = None
    self.checkPlot.clicked.connect(self.showPlot)
DEDENT
----------------------------------------

def __init__(self, v = None, factor = 1) :
INDENT
    super(Plot, self).__init__()
    self.setLayout(QtGui.QHBoxLayout())
    self.fig = plt.figure()
    self.ax = self.fig.add_subplot(111, projection = '3d')
    self.ax.set_aspect('equal')
    self.fig.tight_layout()
    self.ax.view_init(40, 225)
    self.ax.set_xlim3d(0, 3)
    self.ax.set_ylim3d(0, 3)
    self.ax.set_zlim3d(0, 4)
    self.canvas = FigureCanvas(self.fig)
    self.layout().addWidget(self.canvas)
    self.pos = v
    self.setup_plot()
    self.update_factor(factor)
    self.ani = animation.FuncAnimation(self.fig, self.update_plot, blit = False)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40490680_40490949_1_12
40490680_40491027_4_9
Title: python: recursive function counter. persistence issue 
----------------------------------------

def persistence(num) :
INDENT
    def _persist(num, count = 0) :
    INDENT
        multi = 1
        while num :
        INDENT
            multi *= num % 10
            num /= 10
        DEDENT
        if (multi > = 10) :
        INDENT
            return _persist(multi, count + 1)
        DEDENT
        else :
        INDENT
            return count
        DEDENT
    DEDENT
    return _persist(num)
DEDENT
----------------------------------------

def persistence(num) :
INDENT
    if len(str(num)) == 1 :
    INDENT
        return 0
    DEDENT
    val = reduce(operator.mul, map(int, str(num)))
    return 1 + persistence(val)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40506062_40506489_13_20
40506062_40506617_13_20
Title: Animation of a polar circle in python 
----------------------------------------

def animate(i) :
INDENT
    theta = np.linspace(0, 2 * np.pi, 100)
    r = np.sqrt(np.abs(np.sin(0.1 * i)))
    x = r * np.cos(theta) + 1
    y = r * np.sin(theta)
    line.set_data(x, y)
    return line,
DEDENT
----------------------------------------

def animate(i) :
INDENT
    theta = np.linspace(0, 2 * np.pi, 100)
    r = 2 * np.sqrt(np.abs(np.sin(0.1 * i)))
    x = r * np.cos(theta)
    y = r * np.sin(theta)
    line.set_data(x, y)
    return line,
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40513514_40513623_2_13
40513514_40513709_2_17
Title: Python - Program That Prints Grade Using Nested If-Else Statements 
----------------------------------------

def grade(x) :
INDENT
    if x > = 90 :
    INDENT
        return "A"
    DEDENT
    elif x > = 80 :
    INDENT
        return "B"
    DEDENT
    elif x > = 70 :
    INDENT
        return "C"
    DEDENT
    elif x > = 60 :
    INDENT
        return "D"
    DEDENT
    else :
    INDENT
        return "F"
    DEDENT
DEDENT
----------------------------------------

def grade(x) :
INDENT
    if x > = 90 :
    INDENT
        return "A"
    DEDENT
    else :
    INDENT
        if x > = 80 :
        INDENT
            return "B"
        DEDENT
        else :
        INDENT
            if x > = 70 :
            INDENT
                return "C"
            DEDENT
            else :
            INDENT
                if x > = 60 :
                INDENT
                    return "D"
                DEDENT
                else :
                INDENT
                    return "F"
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40513514_40513680_3_14
40513514_40513709_2_17
Title: Python - Program That Prints Grade Using Nested If-Else Statements 
----------------------------------------

def grade(x) :
INDENT
    if x > = 90 :
    INDENT
        return 'A'
    DEDENT
    elif x > = 80 :
    INDENT
        return 'B'
    DEDENT
    elif x > = 70 :
    INDENT
        return 'C'
    DEDENT
    elif x > = 60 :
    INDENT
        return 'D'
    DEDENT
    else :
    INDENT
        return 'F'
    DEDENT
DEDENT
----------------------------------------

def grade(x) :
INDENT
    if x > = 90 :
    INDENT
        return "A"
    DEDENT
    else :
    INDENT
        if x > = 80 :
        INDENT
            return "B"
        DEDENT
        else :
        INDENT
            if x > = 70 :
            INDENT
                return "C"
            DEDENT
            else :
            INDENT
                if x > = 60 :
                INDENT
                    return "D"
                DEDENT
                else :
                INDENT
                    return "F"
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40519199_40519625_14_21
40519199_40519625_38_46
Title: I need sprite to keep moving after shooting a bullet 
----------------------------------------

def __init__(self, surface, x, y) :
INDENT
    self.surface = surface
    self.image = pygame.image.load("cat1.png").convert_alpha()
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y
    self.dist = 10
DEDENT
----------------------------------------

def __init__(self, surface, x, y) :
INDENT
    self.surface = surface
    self.image = pygame.image.load("bullet.png").convert_alpha()
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y
    self.dist = 10
    self.dead = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40519518_40519776_11_23
40519518_40520441_3_23
Title: Creating multiple nested dictionaries from .txt file 
----------------------------------------

def main() :
INDENT
    with open('test.csv', 'r') as intron :
    INDENT
        for line in intron.readlines() :
        INDENT
            chromosome, start, end, strand, = line.split()
            if strand not in first_dict [chromosome] :
            INDENT
                first_dict [chromosome] [strand] = defaultdict(list)
            DEDENT
            first_dict [chromosome] [strand] ['start'].append(start)
            first_dict [chromosome] [strand] ['end'].append(end)
        DEDENT
    DEDENT
    pprint(first_dict)
DEDENT
----------------------------------------

def main() :
INDENT
    with open(sys.argv [1], 'r') as intron :
    INDENT
        for line in intron.readlines() :
        INDENT
            line = line.split()
            chromosome = line [0]
            start = int(line [1])
            end = int(line [2])
            strand = line [3]
            first_dict = {strand : {'start' : [start], 'end' : [end]}}
            if intron_dict.has_key(chromosome) :
            INDENT
                if intron_dict [chromosome].has_key(strand) :
                INDENT
                    intron_dict [chromosome] [strand] ['start'].append(start)
                    intron_dict [chromosome] [strand] ['end'].append(end)
                DEDENT
                else :
                INDENT
                    intron_dict [chromosome] [strand] = first_dict [strand]
                DEDENT
            DEDENT
            else :
            INDENT
                intron_dict.setdefault(chromosome, first_dict)
            DEDENT
        DEDENT
        print (intron_dict)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40530563_40534667_1_11
40530563_40535746_1_16
Title: Django : NameError at /approved/filter/7/ - name 'testElement' is not defined 
----------------------------------------

def post(self, request, testPlanId) :
INDENT
    elemType = request.POST.get('testElementType');
    elemCategory = request.POST.get('category');
    if (elemCategory == 'routing') :
    INDENT
        testElement = ApprovedTestElement.objects.filter(testElementType = elemType, routing = 'y');
    DEDENT
    if (elemCategory == 'switching') :
    INDENT
        testElement = ApprovedTestElement.objects.filter(testElementType = elemType, switching = 'y');
    DEDENT
    return render(request, self.template_name, {'testElement' : testElement, 'testPlanId' : testPlanId})
DEDENT
----------------------------------------

def post(self, request, testPlanId) :
INDENT
    elemType = request.POST.get('testElementType')
    elemCategory = request.POST.get('category')
    if elemCategory :
    INDENT
        if (elemCategory == 'routing') :
        INDENT
            testElement = ApprovedTestElement.objects.filter(testElementType = elemType, routing = 'y')
        DEDENT
        if (elemCategory == 'switching') :
        INDENT
            testElement = ApprovedTestElement.objects.filter(testElementType = elemType, switching = 'y')
        DEDENT
        if not (elemCategory == 'routing' or elemCategory == 'switching') :
        INDENT
            testElement = 'Not Found!'
        DEDENT
    DEDENT
    else :
    INDENT
        testElement = 'Not Found!'
    DEDENT
    return render(request, self.template_name, {'testElement' : testElement, 'testPlanId' : testPlanId})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40549870_40550692_2_13
40549870_40552058_7_35
Title: counting paths for a given situation 
----------------------------------------

def countPaths() :
INDENT
    noRows = 3
    noCols = 7
    paths = []
    for row in range(0, noRows) :
    INDENT

        paths.append([])
        for col in range(0, noCols) :
        INDENT
            paths [row].append(int(fac(row + col) / fac(row) / fac(col)))
        DEDENT
    DEDENT
    return paths
DEDENT
----------------------------------------

def countPaths(row, col) :
INDENT
    global count
    global path
    global paths
    if (row, col) in path :
    INDENT
        return
    DEDENT
    else :
    INDENT
        path.append((row, col))
    DEDENT
    if row == rowLength and col == colLength :
    INDENT
        count += 1
        print ("Reached end, Path followed: ", path)
        paths.append(path)
        path.pop()
        return
    DEDENT
    if row > rowLength or col > colLength :
    INDENT
        path.pop()
        return
    DEDENT
    countPaths(row + 1, col)

    countPaths(row, col + 1)
    path.pop()
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40560153_40560646_8_17
40560153_40560649_13_22
Title: Basic multiprocessing with infinity loop and queue 
----------------------------------------

def main() :
INDENT
    manager = multiprocessing.Manager()
    a = manager.Queue()
    pool = multiprocessing.Pool()
    proc1 = pool.apply_async(af, [a])
    proc2 = pool.apply_async(bf, [a])

DEDENT
----------------------------------------

def main() :
INDENT
    a = Queue()
    p = Process(target = af, args = (a,))
    c = Process(target = bf, args = (a,))
    p.start()
    c.start()
    p.join()
    c.join()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40563216_41663634_126_137
40563216_41663634_23_67
Title: How to show a video in a Gtk dialog? 
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self, title = "Dialog Example")
    self.set_border_width(6)
    button = Gtk.Button("Open dialog")
    button.connect("clicked", self.on_button_clicked)
    self.add(button)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    Gtk.Dialog.__init__(self, "My Dialog", parent, 0,
        (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OK, Gtk.ResponseType.OK))
    self.drawingarea = Gtk.DrawingArea.new()
    self.drawingarea.connect('draw', self.on_draw)
    self.drawingarea.connect('realize', self.on_realize)
    self.drawingarea.connect('unrealize', self.on_unrealize)
    self.drawingarea.set_size_request(800, 600)
    self.set_default_size(1000, 800)
    self.btn_Play = Gtk.Button.new_with_label("Play")
    self.btn_Play.connect('clicked', self.on_click)
    box = self.get_content_area()
    box.add(self.drawingarea)
    box.add(self.btn_Play)

    self.pipeline = Gst.Pipeline()

    self.bus = self.pipeline.get_bus()
    self.bus.add_signal_watch()
    self.bus.connect('message::eos', self.on_eos)
    self.bus.connect('message::error', self.on_error)

    self.bus.enable_sync_message_emission()
    self.bus.connect('sync-message::element', self.on_sync_message)

    self.playbin = Gst.ElementFactory.make('playbin', None)

    self.pipeline.add(self.playbin)

    self.playbin.set_property('uri', uri)
    self.show_all()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40563216_41663634_126_137
40563216_51545076_72_81
Title: How to show a video in a Gtk dialog? 
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self, title = "Dialog Example")
    self.set_border_width(6)
    button = Gtk.Button("Open dialog")
    button.connect("clicked", self.on_button_clicked)
    self.add(button)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self, title = "Open VideoDialog")
    self.filename = "https://www.freedesktop.org/software/gstreamer-sdk" + "/data/media/sintel_trailer-480p.webm"
    self.set_border_width(40)
    self.set_default_size(200, 110)
    button = Gtk.Button("Don't push the button!")
    button.connect("clicked", self.on_button_clicked)
    self.add(button)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40563216_41663634_138_151
40563216_51545076_82_94
Title: How to show a video in a Gtk dialog? 
----------------------------------------

def on_button_clicked(self, widget) :
INDENT
    dialog = DialogExample(self)

    response = dialog.run()
    if response == Gtk.ResponseType.OK :
    INDENT
        print ("The OK button was clicked")
    DEDENT
    elif response == Gtk.ResponseType.CANCEL :
    INDENT
        print ("The Cancel button was clicked")
    DEDENT
    dialog.destroy()

DEDENT
----------------------------------------

def on_button_clicked(self, widget) :
INDENT
    videoDialog = VideoDialog(self, self.filename)
    videoDialog.set_transient_for(self)
    videoDialog.set_modal(True)
    if Gtk.ResponseType.OK == videoDialog.run() :
    INDENT
        print ("Response: OK")
    DEDENT
    else :
    INDENT
        print ("Response: Cancel")
    DEDENT
    videoDialog.player.set_state(Gst.State.NULL)
    videoDialog.destroy()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40563216_41663634_23_67
40563216_51545076_72_81
Title: How to show a video in a Gtk dialog? 
----------------------------------------

def __init__(self, parent) :
INDENT
    Gtk.Dialog.__init__(self, "My Dialog", parent, 0,
        (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OK, Gtk.ResponseType.OK))
    self.drawingarea = Gtk.DrawingArea.new()
    self.drawingarea.connect('draw', self.on_draw)
    self.drawingarea.connect('realize', self.on_realize)
    self.drawingarea.connect('unrealize', self.on_unrealize)
    self.drawingarea.set_size_request(800, 600)
    self.set_default_size(1000, 800)
    self.btn_Play = Gtk.Button.new_with_label("Play")
    self.btn_Play.connect('clicked', self.on_click)
    box = self.get_content_area()
    box.add(self.drawingarea)
    box.add(self.btn_Play)

    self.pipeline = Gst.Pipeline()

    self.bus = self.pipeline.get_bus()
    self.bus.add_signal_watch()
    self.bus.connect('message::eos', self.on_eos)
    self.bus.connect('message::error', self.on_error)

    self.bus.enable_sync_message_emission()
    self.bus.connect('sync-message::element', self.on_sync_message)

    self.playbin = Gst.ElementFactory.make('playbin', None)

    self.pipeline.add(self.playbin)

    self.playbin.set_property('uri', uri)
    self.show_all()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self, title = "Open VideoDialog")
    self.filename = "https://www.freedesktop.org/software/gstreamer-sdk" + "/data/media/sintel_trailer-480p.webm"
    self.set_border_width(40)
    self.set_default_size(200, 110)
    button = Gtk.Button("Don't push the button!")
    button.connect("clicked", self.on_button_clicked)
    self.add(button)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40569554_40569646_4_13
40569554_40569730_9_16
Title: Reading csv file and returning as dictionary 
----------------------------------------

def read_file(filename) :
INDENT
    with open(filename, 'r') as f :
    INDENT
        reader = csv.DictReader(f, delimiter = ',')
        result_dict = defaultdict(list)
        fields = ("Title", "Year", "Total  Height", "Total  Width", "Media", "Country")
        for row in reader :
        INDENT
            result_dict [row ['Artist']].append(
                tuple(row [field] for field in fields))
        DEDENT
    DEDENT
    return dict(result_dict)
DEDENT
----------------------------------------

def read_file(filename) :
INDENT
    thefile = open(filename, "r")
    lines = []
    for i in thefile :
    INDENT
        lines.append(i)
    DEDENT
    thefile.close()
    return lines
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40570215_40570248_1_15
40570215_40570315_12_26
Title: Find the best next key in a dictionary which value fits in a constrain 
----------------------------------------

def findNextFit(adict, val, limit = 10) :
INDENT
    v = list(adict.values())
    k = list(adict.keys())
    diff = limit - val
    if diff in v :
    INDENT
        return k [v.index(diff)]
    DEDENT
    elif diff < 0 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        vfit = [i for i in v if i < diff]
        if not vfit : return False
        return k [v.index(max(vfit))]
    DEDENT
DEDENT
----------------------------------------

def findNextFit(adict, val, limit = 10) :
INDENT
    diff = limit - val
    if diff in adict :
    INDENT
        return adict [diff] [0]
    DEDENT
    elif diff < = 0 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        vfit = [i for i in adict if i < diff]
        if not vfit :
        INDENT
            return False
        DEDENT
        return adict [max(vfit)] [0]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40570472_40570522_21_28
40570472_40570539_1_10
Title: Function that iterates through a linked list 
----------------------------------------

def add_after(ll, value, new) :
INDENT
    for item in ll :
    INDENT
        if item.value == value :
        INDENT
            ll.next = LN(new, ll.next)
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def add_after(ll, value, new, occ = 1) :
INDENT
    item = ll
    while item is not None :
    INDENT
        if item.value == value :
        INDENT
            occ -= 1
            if occ == 0 :
            INDENT
                newnode = LN(new, item.next)
                item.next = newnode
                break
            DEDENT
        DEDENT
        item = item.next
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40573854_40618477_22_34
40573854_40618477_36_50
Title: redraw line when objects move 
----------------------------------------

def __init__(self, diagramScene, parent = None, h = 60, w = 60) :
INDENT
    super(ParentNode, self).__init__(parent)
    self.setPen(QPen(Qt.black, 2))
    self.setBrush(QBrush(Qt.black))
    self.setFlags(QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemIsMovable)
    self.setCursor(QCursor(Qt.PointingHandCursor))
    square = QGraphicsPolygonItem()
    square.setPolygon(QPolygonF([QPointF(0, 0), QPointF(20, 0), QPointF(20, 20), QPointF(0, 20)]))
    self.setRect(0.0, 0.0, w, h)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(ChildNode, self).__init__(parent)
    self.setFlags(QGraphicsItem.ItemIsSelectable | QGraphicsItem.ItemIsMovable)
    self.line = QGraphicsLineItem()
    parent.scene().addItem(self.line)
    self.updateLine(self.pos())
    triangle = Triangle(self)
    triangle.setPolygon(QPolygonF([QPointF(0, 0), QPointF(20, 0), QPointF(10, 20)]))
    triangle.setPen(QPen(Qt.red, 2))
    self.addToGroup(triangle)
    self.setPos(180, 180)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40575634_40576203_2_11
40575634_40591365_26_39
Title: User creation with unique constraint in Django Rest framework 
----------------------------------------

def create(self, validated_data) :
INDENT
    try :
    INDENT
        userinstance = User.objects.get_or_create(** user_data) [0]
        customer = Customer.objects.get_or_create(
            user = userinstance, defaults = validated_data) [0]
        return customer
    DEDENT
    except Exception as exception :
    INDENT
        raise ConflictError({"user" : "User already exists"})
    DEDENT
DEDENT
----------------------------------------

def create(self, request, * args, ** kwargs) :
INDENT
    print "This is view create -----------------------------"
    serializer = self.get_serializer(data = request.data)

    try :
    INDENT
        serializer.is_valid(raise_exception = True)
        self.perform_create(serializer)
        headers = self.get_success_headers(serializer.data)
        return Response(serializer.data, status = status.HTTP_201_CREATED, headers = headers)
    DEDENT
    except ValidationError as e :
    INDENT
        if e.detail.get('username') == ['user with this username already exists.'] :
        INDENT
            raise Custom409()
        DEDENT
    DEDENT
    return Response(serializer.errors, status = status.HTTP_400_BAD_REQUEST)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40594416_40597164_209_220
40594416_40597164_32_44
Title: How may I reset the view of a canvas in tkinter? 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    if not 'canvas' in kwargs :
    INDENT
        raise ValueError("'canvas' not passed.")
    DEDENT
    canvas = kwargs ['canvas']
    del kwargs ['canvas']

    super().__init__(* args, ** kwargs)
    self.config(command = self.reset)
    self.canvas = canvas

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    if 'settings' not in kwargs :
    INDENT
        raise ValueError("'settings' not passed.")
    DEDENT
    settings = kwargs ['settings']
    del kwargs ['settings']

    super().__init__(* args, ** kwargs)
    self.config(highlightthickness = 0)
    self.settings = settings
    self.bind_events()
DEDENT
----------------------------------------
