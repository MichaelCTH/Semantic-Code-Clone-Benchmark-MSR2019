$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44022929_1_33
44022382_44024290_1_35
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    if len([x for x in lst if x ! = "a"]) < 2 :
    INDENT
        return False

    DEDENT
    first_number = next((e for e in lst if e ! = "a"), None)

    first_index = lst.index(first_number)

    diff = first_number - first_index

    if diff < 0 :
    INDENT
        return False

    DEDENT
    all_numbers = []
    for i, x in enumerate(lst) :
    INDENT
        if x == "a" :
        INDENT
            all_numbers.append(i + diff)
        DEDENT
        else :
        INDENT
            all_numbers.append(x)

        DEDENT
    DEDENT
    if all(all_numbers [i + 1] == all_numbers [i] + 1 for i in range(len(all_numbers) - 1)) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def check_consecutive(input_list) :
INDENT
    start_seq = None
    for i, el in enumerate(input_list) :
    INDENT
        if el ! = 'a' :
        INDENT

            start_seq = el - i
            break
        DEDENT
    DEDENT
    if start_seq is None :
    INDENT
        return False
    DEDENT
    if start_seq < 1 :
    INDENT
        return False

    DEDENT
    num_n = 0
    old_value = start_seq - 1
    for el in input_list :
    INDENT
        if el ! = 'a' :
        INDENT
            num_n += 1
            if el ! = (old_value + 1) :
            INDENT
                return False

            DEDENT
        DEDENT
        old_value += 1
    DEDENT
    if num_n < 2 :
    INDENT
        return False
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44023076_1_27
44022382_44023605_1_16
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    last = 0
    number_count = len(lst) - lst.count('a')
    if number_count < 2 :
    INDENT
        return False
    DEDENT
    for i in reversed(range(len(lst))) :
    INDENT
        if not last :
        INDENT
            last = lst [i] if lst [i] ! = "a" else 0
            continue
        DEDENT
        else :
        INDENT
            if lst [i] ! = "a" and last - lst [i] ! = 1 :
            INDENT
                return False

            DEDENT
            last -= 1

            if last < 1 :
            INDENT
                return False

            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def check_consecutive(lst) :
INDENT
    cond = [0, 1]
    n_sum = False
    for x in lst :
    INDENT
        if not (cond [1]) and x ! = 'a' :
        INDENT
            n_sum = True;
            if (cond [0] - x) ! = (lst.index(cond [0]) - lst.index(x)) :
            INDENT
                return False
            DEDENT
            elif x < = lst.index(x) :
            INDENT
                return False
            DEDENT
        DEDENT
        if x ! = 'a' and cond [1] :
        INDENT
            cond [0] = x;
            cond [1] = 0;
        DEDENT
    DEDENT
    print cond
    return n_sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44023076_1_27
44022382_44023682_1_30
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    last = 0
    number_count = len(lst) - lst.count('a')
    if number_count < 2 :
    INDENT
        return False
    DEDENT
    for i in reversed(range(len(lst))) :
    INDENT
        if not last :
        INDENT
            last = lst [i] if lst [i] ! = "a" else 0
            continue
        DEDENT
        else :
        INDENT
            if lst [i] ! = "a" and last - lst [i] ! = 1 :
            INDENT
                return False

            DEDENT
            last -= 1

            if last < 1 :
            INDENT
                return False

            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def check_consecutive(seq) :
INDENT
    PLACEHOLDER = 'a'
    if sum(obj ! = PLACEHOLDER for obj in seq) < 2 :
    INDENT
        return False
    DEDENT
    if isinstance(seq [0], int) :
    INDENT

        incrementing = True
        delta = 1
    DEDENT
    else :
    INDENT

        incrementing = False
        delta = - 1
    DEDENT
    iterator = iter(seq) if incrementing else reversed(seq)
    previous_item = next(iterator)
    assert previous_item ! = PLACEHOLDER
    for item in iterator :
    INDENT
        if item == PLACEHOLDER :
        INDENT
            item = previous_item + delta
        DEDENT
        if item < = 0 or item ! = (previous_item + delta) :
        INDENT
            return False
        DEDENT
        previous_item = item
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44023076_1_27
44022382_44024290_1_35
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    last = 0
    number_count = len(lst) - lst.count('a')
    if number_count < 2 :
    INDENT
        return False
    DEDENT
    for i in reversed(range(len(lst))) :
    INDENT
        if not last :
        INDENT
            last = lst [i] if lst [i] ! = "a" else 0
            continue
        DEDENT
        else :
        INDENT
            if lst [i] ! = "a" and last - lst [i] ! = 1 :
            INDENT
                return False

            DEDENT
            last -= 1

            if last < 1 :
            INDENT
                return False

            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def check_consecutive(input_list) :
INDENT
    start_seq = None
    for i, el in enumerate(input_list) :
    INDENT
        if el ! = 'a' :
        INDENT

            start_seq = el - i
            break
        DEDENT
    DEDENT
    if start_seq is None :
    INDENT
        return False
    DEDENT
    if start_seq < 1 :
    INDENT
        return False

    DEDENT
    num_n = 0
    old_value = start_seq - 1
    for el in input_list :
    INDENT
        if el ! = 'a' :
        INDENT
            num_n += 1
            if el ! = (old_value + 1) :
            INDENT
                return False

            DEDENT
        DEDENT
        old_value += 1
    DEDENT
    if num_n < 2 :
    INDENT
        return False
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44023605_1_16
44022382_44023682_1_30
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    cond = [0, 1]
    n_sum = False
    for x in lst :
    INDENT
        if not (cond [1]) and x ! = 'a' :
        INDENT
            n_sum = True;
            if (cond [0] - x) ! = (lst.index(cond [0]) - lst.index(x)) :
            INDENT
                return False
            DEDENT
            elif x < = lst.index(x) :
            INDENT
                return False
            DEDENT
        DEDENT
        if x ! = 'a' and cond [1] :
        INDENT
            cond [0] = x;
            cond [1] = 0;
        DEDENT
    DEDENT
    print cond
    return n_sum
DEDENT
----------------------------------------

def check_consecutive(seq) :
INDENT
    PLACEHOLDER = 'a'
    if sum(obj ! = PLACEHOLDER for obj in seq) < 2 :
    INDENT
        return False
    DEDENT
    if isinstance(seq [0], int) :
    INDENT

        incrementing = True
        delta = 1
    DEDENT
    else :
    INDENT

        incrementing = False
        delta = - 1
    DEDENT
    iterator = iter(seq) if incrementing else reversed(seq)
    previous_item = next(iterator)
    assert previous_item ! = PLACEHOLDER
    for item in iterator :
    INDENT
        if item == PLACEHOLDER :
        INDENT
            item = previous_item + delta
        DEDENT
        if item < = 0 or item ! = (previous_item + delta) :
        INDENT
            return False
        DEDENT
        previous_item = item
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44023605_1_16
44022382_44024290_1_35
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    cond = [0, 1]
    n_sum = False
    for x in lst :
    INDENT
        if not (cond [1]) and x ! = 'a' :
        INDENT
            n_sum = True;
            if (cond [0] - x) ! = (lst.index(cond [0]) - lst.index(x)) :
            INDENT
                return False
            DEDENT
            elif x < = lst.index(x) :
            INDENT
                return False
            DEDENT
        DEDENT
        if x ! = 'a' and cond [1] :
        INDENT
            cond [0] = x;
            cond [1] = 0;
        DEDENT
    DEDENT
    print cond
    return n_sum
DEDENT
----------------------------------------

def check_consecutive(input_list) :
INDENT
    start_seq = None
    for i, el in enumerate(input_list) :
    INDENT
        if el ! = 'a' :
        INDENT

            start_seq = el - i
            break
        DEDENT
    DEDENT
    if start_seq is None :
    INDENT
        return False
    DEDENT
    if start_seq < 1 :
    INDENT
        return False

    DEDENT
    num_n = 0
    old_value = start_seq - 1
    for el in input_list :
    INDENT
        if el ! = 'a' :
        INDENT
            num_n += 1
            if el ! = (old_value + 1) :
            INDENT
                return False

            DEDENT
        DEDENT
        old_value += 1
    DEDENT
    if num_n < 2 :
    INDENT
        return False
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44023682_1_30
44022382_44024290_1_35
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(seq) :
INDENT
    PLACEHOLDER = 'a'
    if sum(obj ! = PLACEHOLDER for obj in seq) < 2 :
    INDENT
        return False
    DEDENT
    if isinstance(seq [0], int) :
    INDENT

        incrementing = True
        delta = 1
    DEDENT
    else :
    INDENT

        incrementing = False
        delta = - 1
    DEDENT
    iterator = iter(seq) if incrementing else reversed(seq)
    previous_item = next(iterator)
    assert previous_item ! = PLACEHOLDER
    for item in iterator :
    INDENT
        if item == PLACEHOLDER :
        INDENT
            item = previous_item + delta
        DEDENT
        if item < = 0 or item ! = (previous_item + delta) :
        INDENT
            return False
        DEDENT
        previous_item = item
    DEDENT
    return True
DEDENT
----------------------------------------

def check_consecutive(input_list) :
INDENT
    start_seq = None
    for i, el in enumerate(input_list) :
    INDENT
        if el ! = 'a' :
        INDENT

            start_seq = el - i
            break
        DEDENT
    DEDENT
    if start_seq is None :
    INDENT
        return False
    DEDENT
    if start_seq < 1 :
    INDENT
        return False

    DEDENT
    num_n = 0
    old_value = start_seq - 1
    for el in input_list :
    INDENT
        if el ! = 'a' :
        INDENT
            num_n += 1
            if el ! = (old_value + 1) :
            INDENT
                return False

            DEDENT
        DEDENT
        old_value += 1
    DEDENT
    if num_n < 2 :
    INDENT
        return False
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022859_44030657_26_38
44022859_44030657_46_57
Title: How to pass the 2D array from one class to another in Tkinter? 
----------------------------------------

def __init__(self, master) :
INDENT
    self.slave = tk.Toplevel(master)
    self.slave.grab_set()

    self.q_entry = tk.Entry(self.slave, text = "")
    self.q_entry.pack()
    tk.Button(self.slave, text = 'save', command = self.save_q_data).pack()

    self.data = "No data entered"
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.slave = tk.Toplevel(master)
    self.slave.grab_set()

    q_data = master.q_data
    tk.Label(self.slave, text = q_data).pack()
    tk.Button(self.slave, text = 'back', command = self.slave.destroy).pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4403443_4403578_14_22
4403443_4403636_4_14
Title: How do I change variable in a thread? 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Test", size = (500, 270))
    panel = wx.Panel(self, - 1)
    self.buttonStart = wx.Button(panel, - 1, label = "Start thread", pos = (0, 0))
    self.buttonChange = wx.Button(panel, - 1, label = "Change var", pos = (0, 30))
    panel.Bind(wx.EVT_BUTTON, self.startThread, id = self.buttonStart.GetId())
    panel.Bind(wx.EVT_BUTTON, self.changeVar, id = self.buttonChange.GetId())
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Test", size = (500, 270))
    panel = wx.Panel(self, - 1)
    self.buttonStart = wx.Button(panel, - 1, label = "Start timer", pos = (0, 0))
    self.buttonChange = wx.Button(panel, - 1, label = "Change var", pos = (0, 30))
    panel.Bind(wx.EVT_BUTTON, self.startTimer, id = self.buttonStart.GetId())
    panel.Bind(wx.EVT_BUTTON, self.changeVar, id = self.buttonChange.GetId())
    self.value = 1
    self.timer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.printer, self.timer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44036874_44036969_16_28
44036874_48366820_11_24
Title: "Testdome ""Path"" Python - Can't determine why my solution isn't 100% correct" 
----------------------------------------

def cd(self, path) :
INDENT
    if path.startswith(ROOT) :
    INDENT

        self.dirs = []
        path = path [len(ROOT) :]

    DEDENT
    for dir in path.split(DIV) :
    INDENT
        if dir == PREV :
        INDENT
            self.dirs.pop()
        DEDENT
        else :
        INDENT
            self.dirs.append(dir)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def cd(self, new_path) :
INDENT
    if new_path [0] == '/' :
    INDENT
        self.current_path = "/"
        self.current = ['']
    DEDENT
    new_path_list = new_path.split('/')
    for item in new_path_list :
    INDENT
        if item ! = '' :
        INDENT
            if item == parent :
            INDENT
                self.current.pop()
            DEDENT
            else :
            INDENT
                self.current.append(item)
            DEDENT
            self.current_path = div.join(self.current)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44036874_44036969_16_28
44036874_49191195_5_24
Title: "Testdome ""Path"" Python - Can't determine why my solution isn't 100% correct" 
----------------------------------------

def cd(self, path) :
INDENT
    if path.startswith(ROOT) :
    INDENT

        self.dirs = []
        path = path [len(ROOT) :]

    DEDENT
    for dir in path.split(DIV) :
    INDENT
        if dir == PREV :
        INDENT
            self.dirs.pop()
        DEDENT
        else :
        INDENT
            self.dirs.append(dir)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def cd(self, new_path) :
INDENT
    PREV = '..'
    DIV = '/'

    c_list = self.current_path.split(DIV)
    n_list = new_path.split(DIV)
    for item in n_list :
    INDENT
        if item == PREV :
        INDENT
            del c_list [- 1]
        DEDENT
        else :
        INDENT
            c_list.append(item)
        DEDENT
    DEDENT
    self.current_path = "/".join(c_list)
    return self.current_path

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44036874_48366820_11_24
44036874_49191195_5_24
Title: "Testdome ""Path"" Python - Can't determine why my solution isn't 100% correct" 
----------------------------------------

def cd(self, new_path) :
INDENT
    if new_path [0] == '/' :
    INDENT
        self.current_path = "/"
        self.current = ['']
    DEDENT
    new_path_list = new_path.split('/')
    for item in new_path_list :
    INDENT
        if item ! = '' :
        INDENT
            if item == parent :
            INDENT
                self.current.pop()
            DEDENT
            else :
            INDENT
                self.current.append(item)
            DEDENT
            self.current_path = div.join(self.current)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def cd(self, new_path) :
INDENT
    PREV = '..'
    DIV = '/'

    c_list = self.current_path.split(DIV)
    n_list = new_path.split(DIV)
    for item in n_list :
    INDENT
        if item == PREV :
        INDENT
            del c_list [- 1]
        DEDENT
        else :
        INDENT
            c_list.append(item)
        DEDENT
    DEDENT
    self.current_path = "/".join(c_list)
    return self.current_path

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44038718_44051554_25_50
44038718_44051554_8_23
Title: Incorrect widget.size() when checking before a signal 
----------------------------------------

def __init__(self, widgets, parent = None) :
INDENT
    super(QLineEditCtx, self).__init__(parent)
    self.widgets = widgets

    self.setMaximumHeight(50)
    spacer = QSpacerItem(0, 0, QSizePolicy.Expanding, QSizePolicy.Minimum)
    layout = QHBoxLayout(self)
    layout.setContentsMargins(5, 5, 5, 5)
    layout.addItem(spacer)
    for widget in widgets :
    INDENT
        widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Expanding)
        widget.setCursor(widget.cursor())
        layout.addWidget(widget)

        print 'init:', widget, widget.size()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.setWindowTitle('Blah')
    self.setAttribute(Qt.WA_DeleteOnClose, True)
    self.setGeometry(400, 350, 500, 350)

    push_button = QPushButton('bleh')
    push_button.setFixedWidth(200)
    check_box = QCheckBox()
    self.sp_widget = QLineEditCtx([check_box, push_button])
    self.setCentralWidget(self.sp_widget)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44061870_44063346_11_20
44061870_44063346_27_40
Title: Can't display more than 1 sprites - PyGame 
----------------------------------------

def __init__(self, * args) :
INDENT
    pygame.sprite.Sprite.__init__(self, * args)
    self.image = pygame.Surface((30, 30))
    self.image.fill(BLUE)
    self.rect = self.image.get_rect()
    self.rect.x = random.randrange(0, WIDTH - self.rect.width)
    self.rect.y = random.randrange(- 100, - 40)
    self.velY = 6
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    pygame.init()
    pygame.mixer.init()
    self.clock = pygame.time.Clock()
    self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption(TITLE)
    self.running = True
    self.clock = pygame.time.Clock()
    self.allSprites = pygame.sprite.Group()
    self.obstacles = pygame.sprite.Group()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44067129_44095031_18_25
44067129_44095031_2_16
Title: How to use ttk progressbar with tkinter frame in python 2.7? 
----------------------------------------

def __init__(self, master = None, ** kw) :
INDENT
    tk.Canvas.__init__(self, master, ** kw)
    self.width = float(self.config() ["width"] [- 1]) + 2
    self.height = float(self.config() ["height"] [- 1]) + 2
    self.value = 0
    self.bar = self.create_rectangle(0, 0, self.width * self.value / 100., self.height, fill = "dark green")
    self.text = self.create_text(self.width / 2., self.height / 2., text = str(int(self.value)) + " %")
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    self.grid_rowconfigure(0)
    self.grid_columnconfigure(0, weight = 1)
    globals() ["progress"] = ProgressBar(self, height = 25, width = ws)
    globals() ["progress"].grid(row = 2, column = 0, columnspan = 3, sticky = "EW")
    for i in range(101) :
    INDENT
        globals() ["progress"].set_value(i)
        time.sleep(0.1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44068169_44071820_13_26
44068169_44071820_50_57
Title: Beginner: Pyqt 4 connecting touch keyboard to a Browser widget 
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__()
    self.central_widget = QWidget()
    self.cw_layout = QHBoxLayout()
    self.central_widget.setLayout(self.cw_layout)
    self.setCentralWidget(self.central_widget)
    self.line = LineEdit()
    self.kb = KeyBoard()
    self.cw_layout.addWidget(self.line)
    self.create_connections()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(KeyBoard, self).__init__()
    self.layout = QHBoxLayout()
    for key in ['q', 'w', 'e', 'r', 't', 'y'] :
    INDENT
        self.layout.addWidget(QPushButton(key))
    DEDENT
    self.setLayout(self.layout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44082819_44083079_1_7
44082819_44084054_1_10
Title: counting the number of substrings in a string 
----------------------------------------

def count(substr, theStr) :
INDENT
    num = 0
    for i in range(len(theStr)) :
    INDENT
        if theStr [i : i + len(substr)] == substr :
        INDENT
            num += 1
        DEDENT
    DEDENT
    return num
DEDENT
----------------------------------------

def count(substr, theStr) :
INDENT
    num = i = 0
    while True :
    INDENT
        j = theStr.find(substr, i)
        if j == - 1 :
        INDENT
            break
        DEDENT
        num += 1
        i = j + 1
    DEDENT
    return num
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44083685_44085322_5_18
44083685_44085322_99_113
Title: wxPython custom progressBar problems 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(TestArc, self).__init__(* args, ** kwargs)
    self.lineWidth = 0
    self.min = - 90
    self.max = 360
    self._value = 0
    self.setText = '---'
    self.position = wx.Rect()
    self.startPoint = math.radians(0)
    self.endPoint = math.radians(0)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
DEDENT
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 600))
    self.gauge = TestArc(self)
    self.gauge.SetFocus()
    self.gauge.setMinimun(90)
    self.gauge.setMaximun(360)
    self.gauge.setValue(90)

    self.val = 90
    self.timer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.OnTimer, self.timer)
    self.timer.Start(100)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4409502_10614335_16_28
4409502_19974994_17_25
Title: Directory transfers on paramiko 
----------------------------------------

def mkdir(self, sftp, remotepath, mode = 0777, intermediate = False) :
INDENT
    remotepath = self.normalize_dirpath(remotepath)
    if intermediate :
    INDENT
        try :
        INDENT
            sftp.mkdir(remotepath, mode = mode)
        DEDENT
        except IOError, e :
        INDENT
            self.mkdir(sftp, remotepath.rsplit("/", 1) [0], mode = mode,
                intermediate = True)
            return sftp.mkdir(remotepath, mode = mode)
        DEDENT
    DEDENT
    else :
    INDENT
        sftp.mkdir(remotepath, mode = mode)

    DEDENT
DEDENT
----------------------------------------

def mkdir(self, path, mode = 511, ignore_existing = False) :
INDENT
    try :
    INDENT
        super(MySFTPClient, self).mkdir(path, mode)
    DEDENT
    except IOError :
    INDENT
        if ignore_existing :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            raise
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44099654_44100741_12_20
44099654_44100741_33_41
Title: Creating collision in pygame 
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.image = pygame.Surface((30, 30))
    self.image.fill((190, 140, 20))
    self.rect = self.image.get_rect()
    self.x = 300
    self.y = 640
    self.speed = 20
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.image = pygame.Surface((30, 30))
    self.image.fill((230, 230, 40))
    self.rect = self.image.get_rect()
    self.x = random.randrange(0, 770)
    self.y = - 50
    self.speed = 5
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44100694_44101051_13_25
44100694_44101051_6_11
Title: an abstract base class(abc) giving error __new__() takes exactly 4 arguments (2 given) 
----------------------------------------

def __init__(self, search_key = '', ** kwargs) :
INDENT
    super(GoogleCrawler, self).__init__(search_key, ** kwargs)

    self.search_url_prefix = kwargs.get('search_url_prefix', 'https://www.google.com.sg/search?q=')
    self.search_url_postfix = kwargs.get('search_url_postfix', '&source=lnms&tbm=isch&sa=X&ei=0eZEVbj3IJG5uATalICQAQ&ved=0CAcQ_AUoAQ&biw=939&bih=591')

    self.show_more_find_type = kwargs.get('show_more_find_type', 'id')
    self.show_more_find_value = kwargs.get('show_more_find_value', 'smb')
DEDENT
----------------------------------------

def __init__(self, search_key = '', ** kwargs) :
INDENT
    if type(search_key) == str :
    INDENT
        if search_key == '' :
        INDENT
            search_key = 'Kabe'
        DEDENT
        self.g_search_key_list = [search_key]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44102548_44103714_45_64
44102548_44103714_6_30
Title: Cannot change value of a QSlider from a QWidget 
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__()
    self.filter1 = Filter()
    self.filter2 = Filter()

    v_main_lay = QVBoxLayout()
    v_main_lay.addWidget(self.filter1)
    v_main_lay.addWidget(self.filter2)

    self.setLayout(v_main_lay)

    self.setGeometry(300, 300, 350, 300)
    self.setWindowTitle('Review')
    self.show()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Filter, self).__init__()
    lay = QVBoxLayout(self)

    self.k = 3

    self.k_lbl = QLabel(str(self.k))

    Filter.filterCount += 1

    self.thresh_sld = QSlider(Qt.Horizontal, self)
    self.thresh_sld.setFocusPolicy(Qt.NoFocus)
    self.thresh_sld.setMinimum(3)
    self.thresh_sld.setMaximum(51)
    self.thresh_sld.setValue(self.k)
    self.thresh_sld.setSingleStep(2)
    self.thresh_sld.valueChanged.connect(self.changeValue)
    lay.addWidget(self.k_lbl)
    lay.addWidget(self.thresh_sld)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44115807_44130888_59_78
44115807_44130888_9_16
Title: Python Updating Variables Based on Current Widget Selected 
----------------------------------------

def __init__(self, number, ax, R = 0, parent = None, ** kwargs) :
INDENT
    super(LineWidget, self).__init__(parent)
    self.number = number
    label = QtGui.QLabel("cU " + str(self.number))
    self.spin = QtGui.QDoubleSpinBox()
    self.spin.setSingleStep(0.2)
    self.spin.setRange(- 100, 100)
    self.setLayout(QtGui.QHBoxLayout())
    self.layout().addWidget(label)
    self.layout().addWidget(self.spin)
    self.R = R
    self.t = np.linspace(0, 1)
    self.f = lambda t, R : R * t
    self.ax = ax
    self.line, = self.ax.plot([], [], ** kwargs)
    self.update()
    self.spin.valueChanged.connect(self.changed)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Viewer, self).__init__(parent)
    self.setupUI()
    self.ax = self.fig.add_subplot(111)
    self.count = 0
    self.container = []
    self.button.clicked.connect(self.addLine)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4412484_4412904_14_19
4412484_4412904_27_32
Title: Python Most Efficient Way to Search a List 
----------------------------------------

def tally(items) :
INDENT
    totals = dict()
    for kind, count in items :
    INDENT
        totals.setdefault(kind, [0]) [0] += count
    DEDENT
    return sorted([key.__name__, total [0]] for key, total in totals.iteritems())
DEDENT
----------------------------------------

def tally(items) :
INDENT
    totals = collections.defaultdict(int)
    for kind, count in items :
    INDENT
        totals [kind] += count
    DEDENT
    return sorted([key.__name__, total] for key, total in totals.iteritems())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4412484_4412904_14_19
4412484_4412904_38_43
Title: Python Most Efficient Way to Search a List 
----------------------------------------

def tally(items) :
INDENT
    totals = dict()
    for kind, count in items :
    INDENT
        totals.setdefault(kind, [0]) [0] += count
    DEDENT
    return sorted([key.__name__, total [0]] for key, total in totals.iteritems())
DEDENT
----------------------------------------

def tally(items) :
INDENT
    totals = collections.Counter()
    for kind, count in items :
    INDENT
        totals [kind] += count
    DEDENT
    return sorted([key.__name__, total] for key, total in totals.iteritems())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4412484_4412904_27_32
4412484_4412904_38_43
Title: Python Most Efficient Way to Search a List 
----------------------------------------

def tally(items) :
INDENT
    totals = collections.defaultdict(int)
    for kind, count in items :
    INDENT
        totals [kind] += count
    DEDENT
    return sorted([key.__name__, total] for key, total in totals.iteritems())
DEDENT
----------------------------------------

def tally(items) :
INDENT
    totals = collections.Counter()
    for kind, count in items :
    INDENT
        totals [kind] += count
    DEDENT
    return sorted([key.__name__, total] for key, total in totals.iteritems())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44137608_44138201_2_16
44137608_44138254_2_16
Title: python3 self variable from class to decorator 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if not os.path.isfile(self.filename) :
    INDENT
        return self.cache(fn(* args, ** kwargs))
    DEDENT
    time_ago = self.time_ago
    filename = self.filename
    c_age = datetime.fromtimestamp(os.path.getctime(filename))
    m_age = datetime.fromtimestamp(os.path.getmtime(filename))
    print (c_age)
    print (m_age)
    print (time_ago)
    if c_age < time_ago or m_age < time_ago :
    INDENT
        return self.cache(fn(* args, ** kwargs))
    DEDENT
    else :
    INDENT
        return self.read()
    DEDENT
DEDENT
----------------------------------------

def wrapper(* args, ** kw) :
INDENT
    if not os.path.isfile(self.filename) :
    INDENT
        return self.cache(fn(self))
    DEDENT
    time_ago = self.time_ago
    filename = self.filename
    c_age = datetime.fromtimestamp(os.path.getctime(filename))
    m_age = datetime.fromtimestamp(os.path.getmtime(filename))
    print (c_age)
    print (m_age)
    print (time_ago)
    if c_age < time_ago or m_age < time_ago :
    INDENT
        return self.cache(fn(self))
    DEDENT
    else :
    INDENT
        return self.read()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44169735_44169811_1_6
44169735_52376827_1_18
Title: Implement a group_by_owners dictionary 
----------------------------------------

def group_by_owners(files) :
INDENT
    result = {}
    for file, owner in files.items() :
    INDENT
        result [owner] = result.get(owner, []) + [file]
    DEDENT
    return result
DEDENT
----------------------------------------

def group_by_owners(files) :
INDENT
    values = []
    dic = {}
    for k, v in files.items() :
    INDENT
        values.append(v)
    DEDENT
    s_values = set(values)
    l_values = list(s_values)
    for i in l_values :
    INDENT
        keys = []
        for k, v in files.items() :
        INDENT
            if v == i :
            INDENT
                keys.append(k)
            DEDENT
        DEDENT
        dic [i] = keys
    DEDENT
    return dic
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44169735_44169811_1_6
44169735_52868988_5_18
Title: Implement a group_by_owners dictionary 
----------------------------------------

def group_by_owners(files) :
INDENT
    result = {}
    for file, owner in files.items() :
    INDENT
        result [owner] = result.get(owner, []) + [file]
    DEDENT
    return result
DEDENT
----------------------------------------

def group_by_owners(files) :
INDENT
    new_dic = {}
    for key, val in files.items() :
    INDENT
        key_list = []
        for k, v in files.items() :
        INDENT
            if v == val :
            INDENT

                key_list.append(k)
                new_dic [v] = key_list
            DEDENT
        DEDENT
    DEDENT
    return new_dic
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44169735_52376827_1_18
44169735_52868988_5_18
Title: Implement a group_by_owners dictionary 
----------------------------------------

def group_by_owners(files) :
INDENT
    values = []
    dic = {}
    for k, v in files.items() :
    INDENT
        values.append(v)
    DEDENT
    s_values = set(values)
    l_values = list(s_values)
    for i in l_values :
    INDENT
        keys = []
        for k, v in files.items() :
        INDENT
            if v == i :
            INDENT
                keys.append(k)
            DEDENT
        DEDENT
        dic [i] = keys
    DEDENT
    return dic
DEDENT
----------------------------------------

def group_by_owners(files) :
INDENT
    new_dic = {}
    for key, val in files.items() :
    INDENT
        key_list = []
        for k, v in files.items() :
        INDENT
            if v == val :
            INDENT

                key_list.append(k)
                new_dic [v] = key_list
            DEDENT
        DEDENT
    DEDENT
    return new_dic
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44191996_44202658_2_12
44191996_44202658_40_66
Title: Text not displaying - Python (PyGame) 
----------------------------------------

def __init__(self, x, color) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface((10, 100))
    self.image.fill(color)
    self.rect = self.image.get_rect()
    self.rect.y = HEIGHT / 2 - self.rect.height / 2
    self.rect.centerx = x
    self.displacement = 8
    self.score = 0
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.sprite.Sprite.__init__(self)

    pygame.init()

    pygame.mixer.init()
    pygame.font.init()

    self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
    pygame.display.set_caption(TITLE)
    self.running = True
    self.clock = pygame.time.Clock()

    self.scoreText = pygame.font.Font("assets/fonts/square.TTF", 25)
    self.titleFontLight = pygame.font.Font("assets/fonts/square.TTF", 50)

    self.allSprites = pygame.sprite.Group()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44192668_44192764_1_13
44192668_44192786_1_6
Title: Find most numbers occurrences in lists 
----------------------------------------

def print_most_numbers_occurrences(numbers_str) :
INDENT
    print (numbers_str.split(" "))
    number_list = [int(x) for x in numbers_str.split()]
    most_occurances = []
    for i in set(number_list) :
    INDENT
        occurances = number_list.count(i)
        if len(most_occurances) == 0 :
        INDENT
            most_occurances.append(i)
        DEDENT
        elif most_occurances [0] < occurances :
        INDENT
            most_occurances = [i]
        DEDENT
        elif most_occurances [0] == occurances :
        INDENT
            most_occurances.append(i)
        DEDENT
    DEDENT
    print (most_occurances)
DEDENT
----------------------------------------

def print_most_numbers_occurrences(numbers_str) :
INDENT
    number_list = [int(number) for number in numbers_str.split(' ') if number ! = ""]
    for i in number_list :
    INDENT
        i = max(number_list, key = number_list.count)
    DEDENT
    print (i, number_list.count(i))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44193227_44193384_4_18
44193227_44248794_6_13
Title: PyQT5: How can I draw inside existing QGraphicsVIew? 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtWidgets.QMainWindow.__init__(self, parent = parent)
    self.setupUi(self)
    scene = QtWidgets.QGraphicsScene()
    self.graphicsView.setScene(scene)
    pen = QtGui.QPen(QtCore.Qt.green)
    side = 20
    for i in range(16) :
    INDENT
        for j in range(16) :
        INDENT
            r = QtCore.QRectF(QtCore.QPointF(i * side, j * side), QtCore.QSizeF(side, side))
            scene.addRect(r, pen)

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__()
    self.central_widget = QWidget()
    self.layout_container = QVBoxLayout()
    self.central_widget.setLayout(self.layout_container)
    self.setCentralWidget(self.central_widget)
    self.layout_container.addWidget(GraphicsView())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44203271_44204236_7_19
44203271_44205411_10_23
Title: How to save multiple files with incrementing names using pywinauto 
----------------------------------------

def make_labels(a, b) :
INDENT
    app = Application().start("notepad.exe")
    app.UntitledNotepad.edit1.SetText("This is me typing %r" % b)
    app.UntitledNotepad.MenuSelect("File -> SaveAs")
    app.SaveAs.edit1.SetText("Test_File%r.txt" % b)
    app.SaveAs.Save.Click()
    app.SaveAs.Save.Click()
    app.UntitledNotepad.TypeKeys("%FX")
    b = b + 1
    return b
DEDENT
----------------------------------------

def make_labels(b, app) :
INDENT
    app.Notepad.edit1.SetText("This is me typing %r" % b)
    app.Notepad.TypeKeys("^S")
    app.SaveAs.edit1.SetText("Test_File%r.txt" % b)
    app.SaveAs.Save.Click()

    b = b + 1
    return b

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44204316_44204520_22_33
44204316_44204520_9_20
Title: How to wait until signal 
----------------------------------------

def run(self) :
INDENT
    global queue
    while True :
    INDENT
        lock.acquire()
        if not queue :
        INDENT
            print "Nothing in queue, but consumer will try to consume"
        DEDENT
        num = queue.pop(0)
        print "Consumed", num
        lock.release()
        time.sleep(random.random())

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    nums = range(5)
    global queue
    while True :
    INDENT
        num = random.choice(nums)
        lock.acquire()
        queue.append(num)
        print "Produced", num
        lock.release()
        time.sleep(random.random())

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44207724_44207852_1_12
44207724_44208350_1_6
Title: Issue with python recursion 
----------------------------------------

def cartesian_product(set1, n) :
INDENT
    rv = set()
    if n == 0 :
    INDENT

        rv.add(())
    DEDENT
    else :
    INDENT
        rv = set()
        for x in set1 :
        INDENT
            for y in cartesian_product(set1, n - 1) :
            INDENT
                rv.add((x,) + y)
            DEDENT
        DEDENT
    DEDENT
    return rv
DEDENT
----------------------------------------

def cartesian_product(* X) :
INDENT
    if len(X) == 1 :
    INDENT
        return [(x0,) for x0 in X [0]]
    DEDENT
    else :
    INDENT
        return [(x0,) + t1 for x0 in X [0] for t1 in cartesian_product(* X [1 :])]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44211433_44214979_13_31
44211433_44214979_1_34
Title: Implement special metaclass. Nonify field in inherited class 
----------------------------------------

def __new__(cls, * args, ** kwargs) :
INDENT
    for supercls in cls.__mro__ [1 :] :
    INDENT
        if '__new__' in supercls.__dict__ :
        INDENT

            instance = supercls.__new__(cls)
            break
        DEDENT
    DEDENT
    for names in kwargs :
    INDENT
        if '_{}'.format(names) in cls.__slots__ :
        INDENT

            setattr(instance, kwargs [names])
        DEDENT
    DEDENT
    return instance
DEDENT
----------------------------------------

def __new__(mcs, name, bases, diction) :
INDENT
    socket = set()
    for base in bases :
    INDENT
        if hasattr(base, '__slots__') :
        INDENT
            socket.update(base.__slots__)
        DEDENT
    DEDENT
    for key, value in diction.iteritems() :
    INDENT
        if isinstance(value, StringField) :
        INDENT
            value.name = "_{}".format(key)
            socket.add(value.name)

        DEDENT
    DEDENT
    def __new__(cls, * args, ** kwargs) :
    INDENT
        for supercls in cls.__mro__ [1 :] :
        INDENT
            if '__new__' in supercls.__dict__ :
            INDENT

                instance = supercls.__new__(cls)
                break
            DEDENT
        DEDENT
        for names in kwargs :
        INDENT
            if '_{}'.format(names) in cls.__slots__ :
            INDENT

                setattr(instance, kwargs [names])
            DEDENT
        DEDENT
        return instance
    DEDENT
    diction ["__slots__"] = list(socket)
    diction ["__new__"] = __new__
    return super(ModelCreator, mcs).__new__(mcs, name, bases, diction)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44215038_44215098_3_12
44215038_44215139_1_16
Title: Python using input() within function to determine data type 
----------------------------------------

def input_type(userInput) :
INDENT
    if userInput in ("True", "False") :
    INDENT
        return "boolean"
    DEDENT
    elif re.match("^\d+?\.\d+?$", userInput) :
    INDENT
        return "float"
    DEDENT
    elif userInput.isdigit() :
    INDENT
        return "int"
    DEDENT
    else :
    INDENT
        return "string"
    DEDENT
DEDENT
----------------------------------------

def input_type(userInput) :
INDENT
    digitTable = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
    test1 = userInput.find(''.join([str(x) for x in digitTable]))
    if userInput == "True" or userInput == "False" :
    INDENT
        return "boolean"
    DEDENT
    elif test1 == - 1 :
    INDENT
        return "string"
    DEDENT
    elif userInput == "True" or userInput == "False" :
    INDENT
        return "boolean"
    DEDENT
    else :
    INDENT
        test2 = userInput.find(".")
        if test2 == - 1 :
        INDENT
            return "integer"
        DEDENT
        else :
        INDENT
            return "float"
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44222270_44222347_2_9
44222270_44222597_2_9
Title: getting all attributes of an object python 3 
----------------------------------------

def __init__(self, legs, name, color, smell, age, kids) :
INDENT
    self.legs = legs
    self.name = name
    self.color = color
    self.smell = smell
    self.age = age
    self.kids = kids
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.legs = 2
    self.name = 'Dog'
    self.color = 'Spotted'
    self.smell = 'Alot'
    self.age = 10
    self.kids = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44228519_44229380_1_18
44228519_44231287_1_18
Title: Python turtle concentric circles 
----------------------------------------

def circle_around_point(radius) :
INDENT
    circumference = 2 * 3.1415 * radius
    seg_length = circumference / 36
    penup()
    fd(radius)
    right(90)
    pendown()
    for i in range(36) :
    INDENT
        fd(seg_length)
        right(10)
    DEDENT
    penup()
    right(90)
    fd(radius)
    right(180)
    pendown()
DEDENT
----------------------------------------

def circle_around_point(turtle, radius) :
INDENT
    is_down = turtle.isdown()
    if is_down :
    INDENT
        turtle.penup()
    DEDENT
    turtle.forward(radius)
    turtle.left(90)
    turtle.pendown()
    turtle.circle(radius)
    turtle.penup()
    turtle.right(90)
    turtle.backward(radius)
    if is_down :
    INDENT
        turtle.pendown()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44229106_44229150_1_9
44229106_44229536_5_12
Title: "How to prepare a list containing a mix of integers float and strings?" 
----------------------------------------

def convert(value) :
INDENT
    try :
    INDENT
        return int(value)
    DEDENT
    except ValueError :
    INDENT
        try :
        INDENT
            return float(value)
        DEDENT
        except ValueError :
        INDENT
            return value
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def convert(item) :
INDENT
    if re.match(r'-?\d+$', item) :
    INDENT
        return int(item)
    DEDENT
    elif re.match(r'-?\d+\.\d+$', item) :
    INDENT
        return float(item)
    DEDENT
    else :
    INDENT
        return item
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44241612_44249552_16_27
44241612_44249552_30_70
Title: Custom Titlebar with frame in PyQt5 
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__()
    self.layout = QVBoxLayout()
    self.layout.addWidget(MyBar(self))
    self.setLayout(self.layout)
    self.layout.setContentsMargins(0, 0, 0, 0)
    self.layout.addStretch(- 1)
    self.setMinimumSize(800, 400)
    self.setWindowFlags(Qt.FramelessWindowHint)
    self.pressing = False

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MyBar, self).__init__()
    self.parent = parent
    print (self.parent.width())
    self.layout = QHBoxLayout()
    self.layout.setContentsMargins(0, 0, 0, 0)
    self.title = QLabel("My Own Bar")
    btn_size = 35
    self.btn_close = QPushButton("x")
    self.btn_close.clicked.connect(self.btn_close_clicked)
    self.btn_close.setFixedSize(btn_size, btn_size)
    self.btn_close.setStyleSheet("background-color: red;")
    self.btn_min = QPushButton("-")
    self.btn_min.clicked.connect(self.btn_min_clicked)
    self.btn_min.setFixedSize(btn_size, btn_size)
    self.btn_min.setStyleSheet("background-color: gray;")
    self.btn_max = QPushButton("+")
    self.btn_max.clicked.connect(self.btn_max_clicked)
    self.btn_max.setFixedSize(btn_size, btn_size)
    self.btn_max.setStyleSheet("background-color: gray;")
    self.title.setFixedHeight(35)
    self.title.setAlignment(Qt.AlignCenter)
    self.layout.addWidget(self.title)
    self.layout.addWidget(self.btn_min)
    self.layout.addWidget(self.btn_max)
    self.layout.addWidget(self.btn_close)
    self.title.setStyleSheet("""
            background-color: black;
            color: white;
        """)
    self.setLayout(self.layout)
    self.start = QPoint(0, 0)
    self.pressing = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44242910_44243089_2_18
44242910_44243116_1_12
Title: Converting an Integer to Binary in Python 
----------------------------------------

def func(num) :
INDENT
    while num ! = 1 :
    INDENT
        modnum = int(num % 2)
        num = int(num / 2)
        if modnum == 0 :
        INDENT
            alist.append(0)
            print (alist)
        DEDENT
        elif modnum == 1 :
        INDENT
            alist.append(1)
            print (alist)
        DEDENT
    DEDENT
    alist.append(1)
DEDENT
----------------------------------------

def func(num) :
INDENT
    if num == 0 :
    INDENT
        return [num]
    DEDENT
    binary_digits = []
    while num ! = 0 :
    INDENT
        modnum = int(num % 2)
        num = int(num / 2)
        binary_digits.append(modnum)
    DEDENT
    return list(reversed(binary_digits))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44242910_44243089_2_18
44242910_44243217_2_8
Title: Converting an Integer to Binary in Python 
----------------------------------------

def func(num) :
INDENT
    while num ! = 1 :
    INDENT
        modnum = int(num % 2)
        num = int(num / 2)
        if modnum == 0 :
        INDENT
            alist.append(0)
            print (alist)
        DEDENT
        elif modnum == 1 :
        INDENT
            alist.append(1)
            print (alist)
        DEDENT
    DEDENT
    alist.append(1)
DEDENT
----------------------------------------

def func(num) :
INDENT
    while num ! = 0 :
    INDENT
        modnum = int(num % 2)
        num = int(num / 2)
        alist.append(modnum)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44242910_44243116_1_12
44242910_44243217_2_8
Title: Converting an Integer to Binary in Python 
----------------------------------------

def func(num) :
INDENT
    if num == 0 :
    INDENT
        return [num]
    DEDENT
    binary_digits = []
    while num ! = 0 :
    INDENT
        modnum = int(num % 2)
        num = int(num / 2)
        binary_digits.append(modnum)
    DEDENT
    return list(reversed(binary_digits))

DEDENT
----------------------------------------

def func(num) :
INDENT
    while num ! = 0 :
    INDENT
        modnum = int(num % 2)
        num = int(num / 2)
        alist.append(modnum)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44257285_44257649_1_7
44257285_44274035_1_8
Title: passing lists to a function 
----------------------------------------

def calculation(input_lists, n) :
INDENT
    for i in range(n) :
    INDENT
        val = input_lists [i]
        cal1 = val [0] + 5
        cal2 = val [2] + 0.05
        print (cal1, cal2)
    DEDENT
DEDENT
----------------------------------------

def calculation(* inputs) :
INDENT
    for val in inputs :
    INDENT

        cal1 = val [0] + 5
        cal2 = val [2] + 0.05
        yield cal1, cal2

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44257665_48316287_23_31
44257665_48316287_6_13
Title: Multidimensional RNN on Tensorflow 
----------------------------------------

def setUp(self) :
INDENT
    self.num_features = 1
    self.time_steps = 1
    self.batch_size = 1
    tf.reset_default_graph()
    self.input_layer = tf.placeholder(tf.float32, [self.batch_size, self.time_steps, self.num_features])
    self.cell_fw = grid_rnn.Grid1LSTMCell(num_units = 8)
    self.cell_bw = grid_rnn.Grid1LSTMCell(num_units = 8)
DEDENT
----------------------------------------

def setUp(self) :
INDENT
    self.num_features = 1
    self.time_steps = 1
    self.batch_size = 1
    tf.reset_default_graph()
    self.input_layer = tf.placeholder(tf.float32, [self.batch_size, self.time_steps, self.num_features])
    self.cell = grid_rnn.Grid1LSTMCell(num_units = 8)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44267056_44267277_5_18
44267056_44268251_5_23
Title: for loop doing weird things python 
----------------------------------------

def line(num) :
INDENT
    mylist = np.zeros((width, height))
    for row in mylist :
    INDENT
        row [randint(0, 9)] = 1
    DEDENT
    npArr = mylist.T
    a = Image.new("RGB", (width, height))
    mylist = []
    for idx, val in np.ndenumerate(npArr) :
    INDENT
        if val == 1 :
        INDENT
            mylist.append(black)
        DEDENT
        else :
        INDENT
            mylist.append(white)
        DEDENT
    DEDENT
    a.putdata(mylist)
    a.save("boop" + str(num) + ".png")
DEDENT
----------------------------------------

def line(num) :
INDENT
    a = Image.new("RGB", (width, height))
    for pixel in xrange(width * height) :
    INDENT
        mylist.append(white)
    DEDENT
    for row in xrange(width) :
    INDENT
        dot = False
        for col in xrange(height) :
        INDENT
            rand1 = random()
            rand2 = random()
            b = float(col) / (height - 1)
            if rand1 < b < rand2 and not dot :
            INDENT
                mylist [col * width + row] = black
                dot = True
            DEDENT
            if col == height - 1 and not dot :
            INDENT
                rand3 = randint(0, height - 1)
                mylist [rand3 * width + row] = black
            DEDENT
        DEDENT
    DEDENT
    a.putdata(mylist)
    a.save("boop" + str(num) + ".png")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44275663_44276485_25_33
44275663_44442442_7_15
Title: Snapping an object to another object vertex in Maya over Python Script 
----------------------------------------

def processTask() :
INDENT
    cmds.select(cmds.polyListComponentConversion(tv = True))
    vertices = cmds.ls(sl = True)
    print (vertices)
    for vrtx in vertices :
    INDENT
        snapToVertex(vrtx, srcObj)
    DEDENT
DEDENT
----------------------------------------

def processTask() :
INDENT
    verts = mc.ls(os = True)
    src = 'pCone1'
    base_name = 'fancy_cone'
    for i, vert in enumerate(verts) :
    INDENT
        dup = mc.duplicate(src, n = '%s_%s' % (base_name, i)) [0]
        snapToVertex(vert, dup)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44279295_44279556_1_11
44279295_44280041_1_12
Title: Randomizing outputs to file 
----------------------------------------

def get_lines(userid) :
INDENT
    line1 = "Document Header - Once per document"
    line2 = "\nDocument Information - Once per document"
    line3 = "\nDocument Information 2 - Once per document"
    line4 = "\nUser information {}".format(userid)
    line5 = "\nUser Information {}".format(userid)
    line6 = "\nUser Information {}".format(userid)
    line7 = "\nDocument Footer - Once per document"
    return line1 + line2 + line3 + line4 + line5 + line6 + line7
DEDENT
----------------------------------------

def get_lines() :
INDENT
    line1 = "Document Header - Once per document"
    line2 = "\nDocument Information - Once per document"
    line3 = "\nDocument Information 2 - Once per document"
    line4 = "\nUser information 1"
    line5 = "\nUser Information 1"
    line6 = "\nUser Information 1"
    line7 = "\nDocument Footer - Once per document"
    return setLine(line1, 1) + setLine(line2, 1) + setLine(line3, 1) + setLine(line4, 3) + setLine(line4, 3, "1", "2")

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44296465_44296486_1_15
44296465_44296564_3_8
Title: Make the variable available outside the function 
----------------------------------------

def Payment() :
INDENT
    print ('The cost for' 'is 1')
    print ('Please insert coin')
    credit = float(input())
    while credit < 1 :
    INDENT
        print ('Your credit now is', credit, '')
        print ('You still need to add other', - credit + 1, 'cent')
        newcredit = float(input())
        credit = newcredit + credit
    DEDENT
    return credit

DEDENT
----------------------------------------

def Payment() :
INDENT
    global credit
    credit = float(input())
    while credit < 1 :
    INDENT
        newcredit = float(input())
        credit = newcredit + credit
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44296465_44296486_1_15
44296465_44297887_2_11
Title: Make the variable available outside the function 
----------------------------------------

def Payment() :
INDENT
    print ('The cost for' 'is 1')
    print ('Please insert coin')
    credit = float(input())
    while credit < 1 :
    INDENT
        print ('Your credit now is', credit, '')
        print ('You still need to add other', - credit + 1, 'cent')
        newcredit = float(input())
        credit = newcredit + credit
    DEDENT
    return credit

DEDENT
----------------------------------------

def Payment(currentcredit) :
INDENT
    print ('The cost for' 'is 1')
    print ('Please insert a coin')
    credit = float(input())
    while credit < 1 :
    INDENT
        print ('Your credit is now', currentcredit, '')
        print ('You still need to add another', - credit + 1, 'cents!')
        newcredit = float(input())
        credit = newcredit + credit
    DEDENT
    return currentcredit - credit
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44296465_44296564_3_8
44296465_44297887_2_11
Title: Make the variable available outside the function 
----------------------------------------

def Payment() :
INDENT
    global credit
    credit = float(input())
    while credit < 1 :
    INDENT
        newcredit = float(input())
        credit = newcredit + credit
    DEDENT
DEDENT
----------------------------------------

def Payment(currentcredit) :
INDENT
    print ('The cost for' 'is 1')
    print ('Please insert a coin')
    credit = float(input())
    while credit < 1 :
    INDENT
        print ('Your credit is now', currentcredit, '')
        print ('You still need to add another', - credit + 1, 'cents!')
        newcredit = float(input())
        credit = newcredit + credit
    DEDENT
    return currentcredit - credit
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44307480_44307481_1_21
44307480_51253225_1_46
Title: "Convert size notation with units (100kb 32MB) to number of bytes in Python" 
----------------------------------------

def convert_size_to_bytes(size) :
INDENT
    multipliers = {
        'kb' : 1024,
        'mb' : 1024 * 1024,
        'gb' : 1024 * 1024 * 1024,
        'tb' : 1024 * 1024 * 1024 * 1024}
    for suffix in multipliers :
    INDENT
        if size.lower().endswith(suffix) :
        INDENT
            return int(size [0 : - len(suffix)]) * multipliers [suffix]
        DEDENT
    DEDENT
    else :
    INDENT
        if size.lower().endswith('b') :
        INDENT
            return int(size [0 : - 1])
        DEDENT
    DEDENT
    try :
    INDENT
        return int(size)
    DEDENT
    except ValueError :
    INDENT
        print ('Malformed input!')
        exit()
    DEDENT
DEDENT
----------------------------------------

def convert_size_to_bytes(size_str) :
INDENT
    multipliers = {
        'kilobyte' : 1024,
        'megabyte' : 1024 ** 2,
        'gigabyte' : 1024 ** 3,
        'terabyte' : 1024 ** 4,
        'petabyte' : 1024 ** 5,
        'exabyte' : 1024 ** 6,
        'zetabyte' : 1024 ** 7,
        'yottabyte' : 1024 ** 8,
        'kb' : 1024,
        'mb' : 1024 ** 2,
        'gb' : 1024 ** 3,
        'tb' : 1024 ** 4,
        'pb' : 1024 ** 5,
        'eb' : 1024 ** 6,
        'zb' : 1024 ** 7,
        'yb' : 1024 ** 8,
        }
    for suffix in multipliers :
    INDENT
        size_str = size_str.lower().strip().strip('s')
        if size_str.lower().endswith(suffix) :
        INDENT
            return int(float(size_str [0 : - len(suffix)]) * multipliers [suffix])
        DEDENT
    DEDENT
    else :
    INDENT
        if size_str.endswith('b') :
        INDENT
            size_str = size_str [0 : - 1]
        DEDENT
        elif size_str.endswith('byte') :
        INDENT
            size_str = size_str [0 : - 4]
        DEDENT
    DEDENT
    return int(size_str)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44320314_44320383_1_11
44320314_44320659_1_14
Title: Why am I getting syntax error on 'excpet'? 
----------------------------------------

def length() :
INDENT
    global gameLength
    gameLength = int(input("How many words do you want to play? You can chose anywhere from 1-40: "))
    if gameLength < = 40 and gameLength > = 1 :
    INDENT
        quit
    DEDENT
    else :
    INDENT
        try :
        INDENT
            int(input("Please choose a number between 1 & 40 "))
        DEDENT
        except ValueError == True :
        INDENT
            int(input("Please choose a number between 1 & 40 "))
        DEDENT
    DEDENT
    return gameLength
DEDENT
----------------------------------------

def length() :
INDENT
    global gameLength
    try :
    INDENT
        gameLength = int(input("How many words do you want to play? You can choose any number from 1-40: "))
        if gameLength < = 40 and gameLength > = 1 :
        INDENT
            quit()
        DEDENT
        else :
        INDENT
            return ValueError
        DEDENT
    DEDENT
    except ValueError :
    INDENT
        print ("Please type a number from 1-40.")
        length()
    DEDENT
    return gameLength
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44321028_44321347_117_128
44321028_44321347_6_101
Title: "Attempting to add QLayout """" to QWidget """" which already has a layout" 
----------------------------------------

def __init__(self, device_type = None, ip = None, username = None, password = None, secret = None, command = None) :
INDENT
    self.device_type = device_type
    self.ip = ip
    self.username = username
    self.password = password
    self.secret = secret
    self.command = command

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QWidget.__init__(self, parent = parent)
    self.device_list = []
    self.setWindowTitle("Network Automation")

    lb_device_list = QLabel(self)
    lb_device_list.setText('Device Type')
    self.cb_device_list = QComboBox(self)
    self.cb_device_list.addItem('cisco_ios')
    self.cb_device_list.addItem('cisco_s300')
    lb_ip = QLabel(self)
    bt = QPushButton(self)
    btadd = QPushButton(self)

    lb_ip.setText('IP Address')
    self.le_ip = QLineEdit(self)
    self.le_ip.setText('')
    self.le_ip.setPlaceholderText('Input Device IP')
    self.le_ip.setFixedWidth(150)

    lb_username = QLabel(self)
    self.le_username = QLineEdit(self)
    lb_username.setText('Username')
    self.le_username.setText('')
    self.le_username.setPlaceholderText('Input Username')
    self.le_username.setFixedWidth(150)

    lb_password = QLabel(self)
    self.le_password = QLineEdit(self)
    lb_password.setText('Password')
    self.le_password.setText('')
    self.le_password.setPlaceholderText('Input Password')
    self.le_password.setFixedWidth(150)

    lb_enable = QLabel(self)
    lb_enable.setText('Privilege Mode Password')
    self.le_enable = QLineEdit(self)
    self.le_enable.setText('')
    self.le_enable.setPlaceholderText('Input Enable Password')
    self.le_enable.setFixedWidth(150)
    bt.setText('Generate')
    bt.setFixedWidth(70)
    btadd.setText('Add')
    line = QFrame(self)
    line.setFrameShape(QFrame.VLine)
    line.setFrameShadow(QFrame.Sunken)
    line.setLineWidth(3)

    lb3 = QLabel(self)
    lb3.setText('IP Device List')
    self.combobox_ip_list = QComboBox(self)
    self.combobox_ip_list.setFixedWidth(170)

    hblayout = QHBoxLayout()
    hblayout.addWidget(bt)
    hblayout.addWidget(btadd)
    sublayout = QVBoxLayout()
    sublayout.addWidget(lb_device_list)
    sublayout.addWidget(self.cb_device_list)
    sublayout.addWidget(lb_ip)
    sublayout.addWidget(self.le_ip)
    sublayout.addWidget(lb_username)
    sublayout.addWidget(self.le_username)
    sublayout.addWidget(lb_password)
    sublayout.addWidget(self.le_password)
    sublayout.addWidget(lb_enable)
    sublayout.addWidget(self.le_enable)
    sublayout.addLayout(hblayout)
    sublayout2 = QVBoxLayout()
    sublayout2.addWidget(lb3)
    sublayout2.addWidget(self.combobox_ip_list)
    sublayout2.addStretch(1)
    layout = QGridLayout(self)
    layout.addLayout(sublayout, 0, 0)
    layout.addWidget(line, 0, 1)
    layout.addLayout(sublayout2, 0, 2)
    btadd.clicked.connect(self.addDevice)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44328750_44329475_2_17
44328750_44329475_41_49
Title: PyQT QGraphicScene move item in background thread 
----------------------------------------

def __init__(self, x, y, width, height) :
INDENT
    super().__init__()
    self.x = x
    self.y = y
    self.width = width
    self.height = height
    self.setPos(self.x, self.y)
    self.color = QColor('red')
    self.setAcceptDrops(True)
    self.setCursor(Qt.OpenHandCursor)
    self.setFlag(QGraphicsItem.ItemIsSelectable, True)
    self.setFlag(QGraphicsItem.ItemIsMovable, True)
    self.setFlag(QGraphicsItem.ItemIsFocusable, True)
    self.setAcceptHoverEvents(True)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.rect = QRectF(0, 0, 800, 800)
    self.Scene = QGraphicsScene(self.rect)
    self.View = QGraphicsView()
    self.View.setCacheMode(QGraphicsView.CacheNone)
    self.sceneConfig()
    self.displayUI()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333245_9_21
44333084_44333303_3_13
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def fib(self, n) :
INDENT
    if n == 2 :
    INDENT
        self.count += 1
    DEDENT
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        return self.fib(n - 1) + self.fib(n - 2)

    DEDENT
DEDENT
----------------------------------------

def fib(n) :
INDENT
    global count
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        if n == 2 :
        INDENT
            count += 1
        DEDENT
        return fib(n - 1) + fib(n - 2)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333245_9_21
44333084_44333350_1_13
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def fib(self, n) :
INDENT
    if n == 2 :
    INDENT
        self.count += 1
    DEDENT
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        return self.fib(n - 1) + self.fib(n - 2)

    DEDENT
DEDENT
----------------------------------------

def fib(n) :
INDENT
    if n == 2 :
    INDENT
        try :
        INDENT
            fib.two_count += 1
        DEDENT
        except AttributeError :
        INDENT
            fib.two_count = 1
        DEDENT
    DEDENT
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        return fib(n - 1) + fib(n - 2)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333245_9_21
44333084_44333354_1_14
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def fib(self, n) :
INDENT
    if n == 2 :
    INDENT
        self.count += 1
    DEDENT
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        return self.fib(n - 1) + self.fib(n - 2)

    DEDENT
DEDENT
----------------------------------------

def fib(n) :
INDENT
    if n == 0 or n == 1 :
    INDENT
        return n, 0
    DEDENT
    else :
    INDENT
        f1, count1 = fib(n - 1)
        f2, count2 = fib(n - 2)
        sum_counts = count1 + count2
        if n == 2 :
        INDENT
            sum_counts = 1
        DEDENT
        return f1 + f2, sum_counts

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333303_14_19
44333084_44333350_14_21
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def testfib(n) :
INDENT
    global count
    for i in range(n + 1) :
    INDENT
        count = 0
        print ('fib of', i, 'is ', fib(i), ', called fib(2)', count, 'times')
    DEDENT
DEDENT
----------------------------------------

def testfib(n) :
INDENT
    for i in range(n + 1) :
    INDENT
        fib.two_count = 0
        print (
            'fib of', i, 'is ', fib(i),
            'and fib(2) was called', fib.two_count, 'times')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333303_14_19
44333084_44333354_15_20
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def testfib(n) :
INDENT
    global count
    for i in range(n + 1) :
    INDENT
        count = 0
        print ('fib of', i, 'is ', fib(i), ', called fib(2)', count, 'times')
    DEDENT
DEDENT
----------------------------------------

def testfib(n) :
INDENT
    for i in range(n + 1) :
    INDENT
        f, count = fib(i)
        print('fib of', i, 'is ', f, end = "\t")
        print ('count of fib(2) is ', count)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333303_3_13
44333084_44333350_1_13
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def fib(n) :
INDENT
    global count
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        if n == 2 :
        INDENT
            count += 1
        DEDENT
        return fib(n - 1) + fib(n - 2)
    DEDENT
DEDENT
----------------------------------------

def fib(n) :
INDENT
    if n == 2 :
    INDENT
        try :
        INDENT
            fib.two_count += 1
        DEDENT
        except AttributeError :
        INDENT
            fib.two_count = 1
        DEDENT
    DEDENT
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        return fib(n - 1) + fib(n - 2)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333303_3_13
44333084_44333354_1_14
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def fib(n) :
INDENT
    global count
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        if n == 2 :
        INDENT
            count += 1
        DEDENT
        return fib(n - 1) + fib(n - 2)
    DEDENT
DEDENT
----------------------------------------

def fib(n) :
INDENT
    if n == 0 or n == 1 :
    INDENT
        return n, 0
    DEDENT
    else :
    INDENT
        f1, count1 = fib(n - 1)
        f2, count2 = fib(n - 2)
        sum_counts = count1 + count2
        if n == 2 :
        INDENT
            sum_counts = 1
        DEDENT
        return f1 + f2, sum_counts

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333350_14_21
44333084_44333354_15_20
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def testfib(n) :
INDENT
    for i in range(n + 1) :
    INDENT
        fib.two_count = 0
        print (
            'fib of', i, 'is ', fib(i),
            'and fib(2) was called', fib.two_count, 'times')
    DEDENT
DEDENT
----------------------------------------

def testfib(n) :
INDENT
    for i in range(n + 1) :
    INDENT
        f, count = fib(i)
        print('fib of', i, 'is ', f, end = "\t")
        print ('count of fib(2) is ', count)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44333084_44333350_1_13
44333084_44333354_1_14
Title: Trouble adding feature to recursive Fibonacci program 
----------------------------------------

def fib(n) :
INDENT
    if n == 2 :
    INDENT
        try :
        INDENT
            fib.two_count += 1
        DEDENT
        except AttributeError :
        INDENT
            fib.two_count = 1
        DEDENT
    DEDENT
    if n == 0 or n == 1 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        return fib(n - 1) + fib(n - 2)
    DEDENT
DEDENT
----------------------------------------

def fib(n) :
INDENT
    if n == 0 or n == 1 :
    INDENT
        return n, 0
    DEDENT
    else :
    INDENT
        f1, count1 = fib(n - 1)
        f2, count2 = fib(n - 2)
        sum_counts = count1 + count2
        if n == 2 :
        INDENT
            sum_counts = 1
        DEDENT
        return f1 + f2, sum_counts

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44337093_44337328_1_13
44337093_44337363_1_17
Title: Printing out python output to an html file 
----------------------------------------

def printTohtml(Alist) :
INDENT
    myfile = open('zip_files.html', 'w')
    html = """<html>
    <head></head>
    <body><p></p>{htmlText}</body>
    </html>"""
    title = "Study - User - zip file -  Last date modified"
    Alist = [title] + [", ".join(line) for line in Alist]
    myfile.write(html.format(htmlText = "\n".join(Alist)))
    myfile.close()
DEDENT
----------------------------------------

def printTohtml(Alist) :
INDENT
    myfile = open('zip_files.html', 'w')
    html = """<html>
    <head></head>
    <body><p>{htmlText}</p></body>
    </html>"""
    complete_string = "Study - User - zip file -  Last date modified"
    for newL in Alist :
    INDENT
        for j in newL :
        INDENT
            if j == newL [- 1] :
            INDENT
                complete_string += j + "<br>"
            DEDENT
            else :
            INDENT
                message = j + ', '
                complete_string += message + "<br>"
            DEDENT
        DEDENT
    DEDENT
    myfile.write(html.format(htmlText = complete_string))
    myfile.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44359150_44365410_22_29
44359150_44365410_8_15
Title: Issue Drawing Multiple Moving Items of Screen Pygame 
----------------------------------------

def __init__(self) :
INDENT
    pg.init()
    self.screen = pg.display.set_mode((1280, 800))
    self.clock = pg.time.Clock()
    self.bg_color = pg.Color(20, 20, 20)
    self.asteroids = [Asteroid() for _ in range(10)]
    self.done = False
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.image = pg.Surface((50, 50))
    self.image.fill((150, 60, 10))
    self.pos = pg.math.Vector2(random.randrange(1230),
        random.randrange(750))
    self.vel = pg.math.Vector2(random.uniform(- 5, 5),
        random.uniform(- 5, 5))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44372046_44372450_5_24
44372046_44372709_5_17
Title: Tkinter timer to start at 0 on button click 
----------------------------------------

def __init__(self, master) :
INDENT
    self.root = master
    self.parent = tk.Frame(self.root)
    self.parent.pack(fill = tk.BOTH)
    self.parent.config(bg = "black")
    self.now = time.time()
    self.buttonVar = tk.IntVar()
    self.buttonCycle = False
    self.buttonVar.set(0)
    self.button = tk.Button(root,
        textvariable = self.buttonVar,
        command = self.updateButton)
    self.button.pack(fill = tk.BOTH)
    self.button_cycle()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    root = tk.Tk()
    root.title('Stopwatch')
    self.display = tk.Label(root, text = '00:00', width = 20)
    self.display.pack()
    self.button = tk.Button(root, text = 'Start', command = self.toggle)
    self.button.pack()
    self.paused = True
    root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44378947_44382334_74_81
44378947_44382334_7_28
Title: Understanding & making infinite bullets to shoot in Pygame 
----------------------------------------

def __init__(self, ship) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface((7, 7))
    self.image.fill((230, 140, 30))
    self.rect = self.image.get_rect()
    self.rect.centerx = ship.rect.centerx
    self.rect.centery = ship.rect.centery - 25
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.done = False
    self.screen_width = 800
    self.screen_height = 600
    self.image = pygame.Surface((800, 600))
    self.image.fill((30, 40, 50))
    self.screen = pygame.display.set_mode(
        (self.screen_width, self.screen_height))

    self.all_sprites = pygame.sprite.Group()

    self.bullet_group = pygame.sprite.Group()
    self.ship = Ship()
    self.all_sprites.add(self.ship)
    bullet = Bullet(self.ship)
    self.bullet_group.add(bullet)
    self.all_sprites.add(bullet)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44450775_44458561_157_167
44450775_44458561_18_28
Title: Pyqt GUI with multiple tabs 
----------------------------------------

def __init__(self) :
INDENT
    super(WidgetTab, self).__init__()
    self.setStyleSheet("""
            border-radius: 4px;
            background:rgb(37,43,52,220);
        """)
    self.layout = QVBoxLayout()
    self.setLayout(self.layout)
    self.setMinimumSize(800, 400)
    self.init_ui()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(MyWidget, self).__init__()
    self.setStyleSheet("""
                    border-radius: 4px;
                    background:rgb(37,43,52,220);
                """)
    self.name = self.default_name

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44450775_44458561_157_167
44450775_44458561_34_91
Title: Pyqt GUI with multiple tabs 
----------------------------------------

def __init__(self) :
INDENT
    super(WidgetTab, self).__init__()
    self.setStyleSheet("""
            border-radius: 4px;
            background:rgb(37,43,52,220);
        """)
    self.layout = QVBoxLayout()
    self.setLayout(self.layout)
    self.setMinimumSize(800, 400)
    self.init_ui()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(TabBarPlus, self).__init__()
    self.setParent(parent)
    self.setStyleSheet(
        """
            QTabBar::tab {
                width: 80px;

            }

           QTabBar::tab:selected {
                font-family: Roboto;
                font-size: 18px;
                font: italic;
                color: rgb(0,0,0,255);

                background: rgb(234,234,234,255);
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;

                border:1px;
                border-color: rgb(197,197,199,255);
                border-top-style: solid;
                border-right-style: solid;
                border-left-style: solid;
                padding: 10px 50px 10px 24px;

           }

           QTabBar::tab:!selected{
                font-family: Roboto;
                font-size: 18px;
                font: italic;
                color: rgb(255,255,255,255);
                background: rgb(175,175,175,255);
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;

               border:1px;
                border-color: rgb(197,197,199,255);
                border-top-style: solid;
                border-right-style: solid;
                border-bottom-style: ;
                border-left-style: solid;
                padding: 10px 50px 10px 24px;
            }

        """)
    self.plusButton = QPushButton("+")
    self.plusButton.setParent(self)
    self.plusButton.setMaximumSize(20, 20)
    self.plusButton.setMinimumSize(20, 20)
    self.plusButton.clicked.connect(self.plusClicked.emit)
    self.movePlusButton()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44450775_44458561_18_28
44450775_44458561_34_91
Title: Pyqt GUI with multiple tabs 
----------------------------------------

def __init__(self) :
INDENT
    super(MyWidget, self).__init__()
    self.setStyleSheet("""
                    border-radius: 4px;
                    background:rgb(37,43,52,220);
                """)
    self.name = self.default_name

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(TabBarPlus, self).__init__()
    self.setParent(parent)
    self.setStyleSheet(
        """
            QTabBar::tab {
                width: 80px;

            }

           QTabBar::tab:selected {
                font-family: Roboto;
                font-size: 18px;
                font: italic;
                color: rgb(0,0,0,255);

                background: rgb(234,234,234,255);
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;

                border:1px;
                border-color: rgb(197,197,199,255);
                border-top-style: solid;
                border-right-style: solid;
                border-left-style: solid;
                padding: 10px 50px 10px 24px;

           }

           QTabBar::tab:!selected{
                font-family: Roboto;
                font-size: 18px;
                font: italic;
                color: rgb(255,255,255,255);
                background: rgb(175,175,175,255);
                border-top-left-radius: 8px;
                border-top-right-radius: 8px;

               border:1px;
                border-color: rgb(197,197,199,255);
                border-top-style: solid;
                border-right-style: solid;
                border-bottom-style: ;
                border-left-style: solid;
                padding: 10px 50px 10px 24px;
            }

        """)
    self.plusButton = QPushButton("+")
    self.plusButton.setParent(self)
    self.plusButton.setMaximumSize(20, 20)
    self.plusButton.setMinimumSize(20, 20)
    self.plusButton.clicked.connect(self.plusClicked.emit)
    self.movePlusButton()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44454913_44455138_6_14
44454913_44455436_3_9
Title: to merge lists in python 
----------------------------------------

def disk() :
INDENT
    for i in ('/tmp', '/usr/mware', '/var', '/var/mware') :
    INDENT
        df1 = subprocess.Popen(['df', '-h', i],
            stdout = subprocess.PIPE).communicate() [0].split()
        df1.remove("on")

        df_out.append(df1 [6 :])
    DEDENT
DEDENT
----------------------------------------

def disk() :
INDENT
    df_set = set()
    for i in ('/tmp', '/usr/mware', '/var', '/var/mware') :
    INDENT
        df1 = subprocess.Popen(['df', '-h', i], stdout = subprocess.PIPE).communicate() [0].split()
        df1.remove("on")
        df_set = df_set.union(set(df1))
    DEDENT
    print (list(df_set))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44468579_44490249_18_25
44468579_44490249_4_16
Title: How to pass a variable from ModelSerializer.update() to ModelViewSet.update() in Django REST Framework 
----------------------------------------

def update(self, request, * args, ** kwargs) :
INDENT
    partial = kwargs.pop('partial', False)
    instance = self.get_object()
    serializer = self.get_serializer(instance, data = request.data, partial = partial)
    serializer.is_valid(raise_exception = True)
    self.perform_update(serializer)
    important_info = serializer.important_info
    return Response(serializer.data)
DEDENT
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    something_special = validated_data.pop('something_special')
    self.important_info = model.update_something_special(something_special)
    for attr, value in validated_data.items() :
    INDENT
        setattr(instance, attr, value)
    DEDENT
    instance.save()
    return instance

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44479937_44480280_1_20
44479937_44480875_2_28
Title: "can I assign ""pass"" keyword to a variable/name?" 
----------------------------------------

def validate_password(first_pwd, second_pwd) :
INDENT
    vowels = [a, e, i, o, u]
    first_length = len(first_pwd)
    second_length = len(second_pwd)

    if first_length < 8 :
    INDENT
        print ("Password too short")
    DEDENT
    elif first_pwd ! = second_pwd :
    INDENT
        print ("Password Mismatch")
    DEDENT
    elif first_pwd [0] == first_pwd [- 1] :
    INDENT
        print ("First Charater cannot be same as the last character")
    DEDENT
    elif first_pwd [0].isalpha(vowels) ! = first_pwd [- 1].isalpha(vowels) :
    INDENT
        pass
    DEDENT
    else :
    INDENT
        print ("All is good!")
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def validate_password(first_pwd, second_pwd) :
INDENT
    first_length = len(first_pwd)
    second_length = len(second_pwd)
    tmp = first_pwd.lower()

    if first_length < 8 :
    INDENT
        print ("Password too short")
    DEDENT
    elif first_pwd ! = second_pwd :
    INDENT
        print ("Password Mismatch")
    DEDENT
    elif tmp [0].isalpha() and tmp [- 1].isalpha() and tmp [0] == tmp [- 1] :
    INDENT
        print ("First Charater cannot be same as the last character")
    DEDENT
    elif len(re.findall('[aeiou]', tmp)) > 2 :
    INDENT
        print ("More than 2 vowels")
    DEDENT
    elif not re.search(r'[a-z]', tmp) :
    INDENT
        print ("No alphabetic character")
    DEDENT
    elif first_pwd in (first_pwd.upper(), tmp) :
    INDENT
        print ("All Characters are in same case")
    DEDENT
    else :
    INDENT
        return True
    DEDENT
    return False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44491391_44492298_60_152
44491391_44499860_22_77
Title: How to make a rectangle appear after another in pygame? 
----------------------------------------

def gameloop() :
INDENT
    x = (display_width *.45)
    y = (display_height *.4)
    x_change = 0
    y_change = 0

    totalPlaytime = 0.0
    faintDisplay = True
    solidDisplay = False
    choosenCoords = False
    gameExit = False
    while not gameExit :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == pygame.QUIT :
            INDENT

                gameExit = True
            DEDENT
            if event.type == pygame.KEYDOWN :
            INDENT
                if event.key == pygame.K_LEFT :
                INDENT
                    x_change = - 5
                DEDENT
                elif event.key == pygame.K_RIGHT :
                INDENT
                    x_change = 5
                DEDENT
                elif event.key == pygame.K_UP :
                INDENT
                    y_change = - 5
                DEDENT
                elif event.key == pygame.K_DOWN :
                INDENT
                    y_change = 5

                DEDENT
            DEDENT
            if event.type == pygame.KEYUP :
            INDENT
                if event.key == pygame.K_LEFT or event.key == pygame.K_RIGHT :
                INDENT
                    x_change = 0
                DEDENT
            DEDENT
            if event.type == pygame.KEYUP :
            INDENT
                if event.key == pygame.K_UP or event.key == pygame.K_DOWN :
                INDENT
                    y_change = 0

                DEDENT
            DEDENT
        DEDENT
        x += x_change
        y += y_change
        gameDisplay.blit(windowImg, (0, 0))
        fly(x, y)

        if faintDisplay and not choosenCoords :
        INDENT
            xSwatter = random.randrange(0, display_width - 400)
            ySwatter = random.randrange(0, display_height - 510)
            choosenCoords = True
            faintSwatterBeginTime = totalPlaytime
        DEDENT
        if faintDisplay :
        INDENT
            if totalPlaytime - faintSwatterBeginTime < 2.0 :
            INDENT
                gameDisplay.blit(faintSwatter, (xSwatter, ySwatter))
            DEDENT
            else :
            INDENT
                faintDisplay = False
                solidDisplay = True
                solidSwatterBeginTime = totalPlaytime
            DEDENT
        DEDENT
        if solidDisplay :
        INDENT
            if totalPlaytime - solidSwatterBeginTime < 0.5 :
            INDENT
                gameDisplay.blit(realswatter, (xSwatter, ySwatter))
                if ((x + 80 > xSwatter) and (x < xSwatter + 400) and (y + 80 > ySwatter) and (y < ySwatter + 510)) :
                INDENT
                    crashed = True
                    gameExit = True
                DEDENT
            DEDENT
            else :
            INDENT
                solidDisplay = False
                faintDisplay = True
                choosenCoords = False

            DEDENT
        DEDENT
        pygame.display.update()
        if x > display_width - fly_width or x < 0 :
        INDENT
            gameExit = True
        DEDENT
        if y > display_height - fly_width or y < 0 :
        INDENT
            gameExit = True

        DEDENT
        milliseconds = clock.tick(60)
        totalPlaytime += milliseconds / 1000.0

    DEDENT
DEDENT
----------------------------------------

def gameloop() :
INDENT
    fly = pg.Rect(100, 150, 70, 70)
    x_change = 0
    y_change = 0
    swatter = pg.Rect(90, 50, 400, 510)
    swatter_timer = 3
    swatterImg = faintSwatter
    dt = 0
    gameExit = False
    while not gameExit :
    INDENT
        for event in pg.event.get() :
        INDENT
            if event.type == pg.QUIT :
            INDENT
                gameExit = True
            DEDENT
            if event.type == pg.KEYDOWN :
            INDENT
                if event.key == pg.K_LEFT :
                INDENT
                    x_change = - 5
                DEDENT
                elif event.key == pg.K_RIGHT :
                INDENT
                    x_change = 5
                DEDENT
                elif event.key == pg.K_UP :
                INDENT
                    y_change = - 5
                DEDENT
                elif event.key == pg.K_DOWN :
                INDENT
                    y_change = 5
                DEDENT
            DEDENT
            if event.type == pg.KEYUP :
            INDENT
                if event.key == pg.K_LEFT or event.key == pg.K_RIGHT :
                INDENT
                    x_change = 0
                DEDENT
                elif event.key == pg.K_UP or event.key == pg.K_DOWN :
                INDENT
                    y_change = 0
                DEDENT
            DEDENT
        DEDENT
        fly.x += x_change
        fly.y += y_change
        swatter_timer -= dt

        if 0 < swatter_timer < 1.5 :
        INDENT
            swatterImg = realswatter
            if fly.colliderect(swatter) :
            INDENT
                print ('Collision!')
            DEDENT
        DEDENT
        elif swatter_timer < = 0 :
        INDENT
            swatterImg = faintSwatter
            swatter_timer = 3
            swatter.topleft = (random.randrange(displayrect.w - 400),
                random.randrange(displayrect.h - 510))

        DEDENT
        gameDisplay.fill((30, 30, 30))
        gameDisplay.blit(flyImg, fly)
        gameDisplay.blit(swatterImg, swatter)
        pg.display.update()
        dt = clock.tick(60) / 1000
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44509497_44511299_12_17
44509497_44511299_23_27
Title: How do I allow the editing of my extended UserProfile with UserChangeForm Django? 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(EditUserProfileForm, self).__init__(* args, ** kwargs)
    f = self.fields.get('user_permissions', None)
    if f is not None :
    INDENT
        f.queryset = f.queryset.select_related('content_type')
    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(EditUserForm, self).__init__(* args, ** kwargs)
    f = self.fields.get('user_permissions', None)
    if f is not None :
    INDENT
        f.queryset = f.queryset.select_related('content_type')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44516105_44516893_1_17
44516105_44517309_9_18
Title: Form validation does not work. How to call clean_field methods 
----------------------------------------

def makepicturepost(request) :
INDENT
    form = PostForm2(request.POST)
    print ('View called')
    print ('Request_method ' + request.method + ' Form.is_valid ' + str(form.is_valid()))
    if request.method == 'POST' and form.is_valid() :
    INDENT
        author = form.author
        comment = form.comment
        picture = form.picture
        newpost = PicturePost(author = author, comment = comment, picture = picture)
        newpost.save()
        return HttpResponseRedirect('/')
    DEDENT
    context = {
        "form" : form}
    return render(request, "makepost.htm", context)
DEDENT
----------------------------------------

def makepicturepost(request) :
INDENT
    form = PostForm2(request.POST)
    if request.method == 'POST' and form.is_valid() :
    INDENT
        form.save()
        return HttpResponseRedirect('/')
    DEDENT
    context = {
        "form" : form}
    return render(request, "makepost.htm", context)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44516105_44516893_1_17
44516105_44517377_1_17
Title: Form validation does not work. How to call clean_field methods 
----------------------------------------

def makepicturepost(request) :
INDENT
    form = PostForm2(request.POST)
    print ('View called')
    print ('Request_method ' + request.method + ' Form.is_valid ' + str(form.is_valid()))
    if request.method == 'POST' and form.is_valid() :
    INDENT
        author = form.author
        comment = form.comment
        picture = form.picture
        newpost = PicturePost(author = author, comment = comment, picture = picture)
        newpost.save()
        return HttpResponseRedirect('/')
    DEDENT
    context = {
        "form" : form}
    return render(request, "makepost.htm", context)
DEDENT
----------------------------------------

def makepicturepost(request) :
INDENT
    if request.method == 'POST' :
    INDENT
        form = PostForm2(request.POST, request.FILES)
        if form.is_valid() :
        INDENT
            author = form.cleaned_data ['author']
            comment = form.cleaned_data ['comment']
            picture = form.cleaned_data ['picture']
            newpost = PicturePost(author = author, comment = comment, picture = picture)
            newpost.save()
            return HttpResponseRedirect('/')
        DEDENT
    DEDENT
    else :
    INDENT
        form = PostForm2()
    DEDENT
    context = {
        'form' : form}
    return render(request, 'makepost.htm', context)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44516105_44517309_9_18
44516105_44517377_1_17
Title: Form validation does not work. How to call clean_field methods 
----------------------------------------

def makepicturepost(request) :
INDENT
    form = PostForm2(request.POST)
    if request.method == 'POST' and form.is_valid() :
    INDENT
        form.save()
        return HttpResponseRedirect('/')
    DEDENT
    context = {
        "form" : form}
    return render(request, "makepost.htm", context)
DEDENT
----------------------------------------

def makepicturepost(request) :
INDENT
    if request.method == 'POST' :
    INDENT
        form = PostForm2(request.POST, request.FILES)
        if form.is_valid() :
        INDENT
            author = form.cleaned_data ['author']
            comment = form.cleaned_data ['comment']
            picture = form.cleaned_data ['picture']
            newpost = PicturePost(author = author, comment = comment, picture = picture)
            newpost.save()
            return HttpResponseRedirect('/')
        DEDENT
    DEDENT
    else :
    INDENT
        form = PostForm2()
    DEDENT
    context = {
        'form' : form}
    return render(request, 'makepost.htm', context)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44533622_44533864_1_28
44533622_44540468_7_36
Title: Python Turtle Recursive Binary Tree 
----------------------------------------

def tree(d, x1, y1) :
INDENT
    if d == 0 :
    INDENT
        return 0
    DEDENT
    a = t.Turtle()
    b = t.Turtle()
    a.penup()
    b.penup()
    a.goto(x1, y1)
    b.goto(x1, y1)
    a.pendown()
    b.pendown()
    a.left(45)
    b.right(45)
    a.forward(10 * (2 ** d))
    b.forward(10 * (2 ** d))
    ax, ay = a.pos()
    bx, by = b.pos()
    tree(d - 1, ax, ay)
    tree(d - 1, bx, by)
DEDENT
----------------------------------------

def tree(turtle, d, origin) :
INDENT
    turtle.penup()
    turtle.setposition(origin)
    turtle.dot(DOT_DIAMETER)
    if d == 0 :
    INDENT
        return
    DEDENT
    distance = (GENERATION_DISTANCE ** 2 + (2 ** d * DOT_DIAMETER / 2) ** 2) ** 0.5
    angle = acos(GENERATION_DISTANCE / distance)
    turtle.pendown()
    turtle.left(angle)
    turtle.forward(distance)
    upper = turtle.position()
    turtle.right(angle)
    turtle.penup()
    turtle.setposition(origin)
    turtle.pendown()
    turtle.right(angle)
    turtle.forward(distance)
    lower = turtle.position()
    turtle.left(angle)
    tree(turtle, d - 1, upper)
    tree(turtle, d - 1, lower)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44535561_44549732_17_30
44535561_44549732_63_74
Title: How to create keyboard and mouse events with Pyqt widgets 
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__()
    self.central_widget = QWidget()
    self.cw_layout = QHBoxLayout()
    self.central_widget.setLayout(self.cw_layout)
    self.setCentralWidget(self.central_widget)
    self.line = LineEdit()
    self.kb = KeyBoard(self.line)
    self.cw_layout.addWidget(self.line)
    self.create_connections()
DEDENT
----------------------------------------

def __init__(self, receiver) :
INDENT
    super(KeyBoard, self).__init__()
    self.receiver = receiver
    self.layout = QHBoxLayout()
    self.keys = ['q', 'w', 'e', 'r', 't', 'y']
    self.dict_keys = {'q' : Qt.Key_Q, 'w' : Qt.Key_W, 'e' : Qt.Key_E, 'r' : Qt.Key_R, 't' : Qt.Key_T, 'y' : Qt.Key_Y,}
    for key in self.keys :
    INDENT
        key_keyboard = Key(key, self.dict_keys [key], receiver)
        key_keyboard.clicked.connect(self.key_pressed)
        self.layout.addWidget(key_keyboard)
    DEDENT
    self.setLayout(self.layout)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4453602_38326779_1_10
4453602_4453715_1_11
Title: How to find the mountpoint a file resides on? 
----------------------------------------

def find_mount_point(path) :
INDENT
    if not os.path.islink(path) :
    INDENT
        path = os.path.abspath(path)
    DEDENT
    elif os.path.islink(path) and os.path.lexists(os.readlink(path)) :
    INDENT
        path = os.path.realpath(path)
    DEDENT
    while not os.path.ismount(path) :
    INDENT
        path = os.path.dirname(path)
        if os.path.islink(path) and os.path.lexists(os.readlink(path)) :
        INDENT
            path = os.path.realpath(path)
        DEDENT
    DEDENT
    return path
DEDENT
----------------------------------------

def find_mount_point(path) :
INDENT
    path = os.path.abspath(path)
    orig_dev = os.stat(path).st_dev
    while path ! = '/' :
    INDENT
        dir = os.path.dirname(path)
        if os.stat(dir).st_dev ! = orig_dev :
        INDENT
            break
        DEDENT
        path = dir
    DEDENT
    return path
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44543950_44544153_3_14
44543950_44544161_3_9
Title: Finding minimum value in a list recursively 
----------------------------------------

def findMinimum(l) :
INDENT
    if len(l) == 0 :
    INDENT
        raise ValueError('Cannot find the minimum of an empty list.')
    DEDENT
    elif len(l) == 1 :
    INDENT
        return l [0]
    DEDENT
    else :
    INDENT
        minNumber = findMinimum(l [1 :])
        min = l [0]
        if minNumber < min :
        INDENT
            min = minNumber
        DEDENT
        return min
    DEDENT
DEDENT
----------------------------------------

def findMinimum(l) :
INDENT
    if len(l) == 1 :
    INDENT
        return l [0]
    DEDENT
    else :
    INDENT
        return min(l [0], findMinimum(l [1 :]))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44550764_44550928_8_17
44550764_44551213_19_25
Title: How can I embed an image on each of my subplots in matplotlib? 
----------------------------------------

def multi_plot() :
INDENT
    fig, axes = plt.subplots(4, 1)
    x = 0
    for axis in axes :
    INDENT
        axis.plot(xs, xs ** 2)
        axis.imshow(im, extent = (0.4, 0.6,.5,.7), zorder = - 1, aspect = 'auto')
        axis.set_xlim(0, 1)
        axis.set_ylim(0, 1)
    DEDENT
    plt.show()
DEDENT
----------------------------------------

def multi_plot() :
INDENT
    fig, axes = plt.subplots(4, 1)
    for axis in axes :
    INDENT
        axis.plot(xs, xs ** 2)
        place_image(im, loc = 2, ax = axis, pad = 0, zoom = 1)
    DEDENT
    plt.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44552775_44555520_1_10
44552775_44555845_1_10
Title: How to extrapolate a periodic time serie in Pandas? 
----------------------------------------

def extrapolate_periodic(df, new_index) :
INDENT
    df_right = df.groupby([df.index.dayofyear, df.index.hour]).mean()
    df_left = pd.DataFrame({'new_index' : new_index}).set_index('new_index')
    df_left = df_left.assign(dayofyear = lambda x : x.index.dayofyear,
        hour = lambda x : x.index.hour)
    df = (pd.merge(df_left, df_right, left_on = ['dayofyear', 'hour'],
            right_index = True, suffixes = ('', '_y'))
        .drop(['dayofyear', 'hour'], axis = 1))
    return df.sort_index()
DEDENT
----------------------------------------

def extrapolate_periodic(df, new_index) :
INDENT
    index = df.index
    start_date = np.min(index)
    end_date = np.max(index)
    period = np.array((end_date - start_date) / np.timedelta64(1, 'h'), dtype = int)
    time = np.array((new_index - start_date) / np.timedelta64(1, 'h'), dtype = int)
    new_df = pd.DataFrame(index = new_index)
    for col in list(df.columns) :
    INDENT
        new_df [col] = np.array(df [col].iloc [time % period])
    DEDENT
    return new_df
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44556478_44556489_4_10
44556478_44556531_3_9
Title: "My function returned value is not global and won't end the ""while"" loop" 
----------------------------------------

def lost_game() :
INDENT
    done = False
    if player_health < = 0 :
    INDENT
        done = True
        print ('You died')
        return done
    DEDENT
DEDENT
----------------------------------------

def lost_game() :
INDENT
    if player_health < = 0 :
    INDENT
        print ('You died')
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44565861_44570642_23_36
44565861_44570642_6_14
Title: scrollToTop not working correctly in ScrollPanel with RadioBox 
----------------------------------------

def __init__(self, parent, ** kwargs) :
INDENT
    SP.ScrolledPanel.__init__(self, parent, - 1, ** kwargs)
    self.parent = parent
    self.SetupScrolling(scroll_x = False, scroll_y = True, scrollToTop = False)
    choices = [l for l in "abcdefghijklmnopqrstuv"]
    self.fieldradiobox = wx.RadioBox(self, label = 'letters',
        style = wx.RA_SPECIFY_ROWS,
        choices = choices)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(self.fieldradiobox, 0, wx.EXPAND | wx.ALL, 10)
    self.SetSizer(vbox)
    self.Bind(wx.EVT_CHILD_FOCUS, self.on_focus)
    self.SetupScrolling(scroll_x = False, scrollToTop = False)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Frame", size = (300, 300))
    self.scrolledPanel = ScrollPanel(self, size = (- 1, 200))
    self.panel = PlotTypePanel(self)
    hbox = wx.BoxSizer(wx.VERTICAL)
    hbox.Add(self.scrolledPanel, 0, wx.EXPAND | wx.ALL, 0)
    hbox.Add(self.panel, 1, wx.EXPAND | wx.ALL, 0)
    self.SetSizer(hbox)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44578487_44578555_3_30
44578487_44578706_5_34
Title: python programming- average of exams and assignments and print grade 
----------------------------------------

def main() :
INDENT
    Assignment1 = int(input("Please enter the score for Assignment 1: "))
    Assignment2 = int(input("Please enter the score for Assignment 2: "))
    Assignment_total = Assignment1 + Assignment2
    Assignment_average = Assignment_total / 2
    print ("The average of the assignment is", round(Assignment_average, 2))
    Exam1 = int(input("Please enter the score for Exam 1: "))
    Exam2 = int(input("Please enter the score for Exam 2: "))
    Exam_total = Exam1 + Exam2
    Exam_average = Exam_total / 2
    print ("The average of the Exam is", round(Exam_average, 2))
    Final_grade = 0.4 * Assignment_average + 0.6 * Exam_average
    print ("The final grade is", round(Final_grade, 2))
    if 90 < = Final_grade < = 100 :
    INDENT
        print ('A')
    DEDENT
    elif 80 < = Final_grade < = 89 :
    INDENT
        print ('B')
    DEDENT
    elif 70 < = Final_grade < = 79 :
    INDENT
        print ('C')
    DEDENT
    elif 60 < = Final_grade < = 69 :
    INDENT
        print ('D')
    DEDENT
    else :
    INDENT
        print ('F')
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    a1 = int(input("Please enter the score for Assignment 1: "))
    a2 = int(input("Please enter the score for Assignment 2: "))
    atot = a1 + a2
    aavg = atot / 2
    print ("The average of the assignment is", round(aavg, 2))
    e1 = int(input("Please enter the score for Exam 1: "))
    e2 = int(input("Please enter the score for Exam 2: "))
    etot = e1 + e2
    eavg = etot / 2
    print ("The average of the Exam is", round(eavg, 2))
    fingrd = ((0.4 * aavg) + (0.6 * eavg))
    if (90 < = fingrd < = 100) :
    INDENT
        print (fingrd, ': A')
    DEDENT
    elif (80 < = fingrd < 90) :
    INDENT
        print (fingrd, ': B')
    DEDENT
    elif (70 < = fingrd < 80) :
    INDENT
        print (fingrd, ': C')
    DEDENT
    elif (60 < = fingrd < 70) :
    INDENT
        print (fingrd, ': D')
    DEDENT
    else :
    INDENT
        print (fingrd, ': F')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44599411_44600670_44_52
44599411_44600670_5_42
Title: Jquery Autocomplete with Python and webapp2 
----------------------------------------

def get(self) :
INDENT
    term = self.request.get('term', None)
    self.response.headers ['Content-Type'] = 'application/json'
    data = ['cat', 'dog', 'bird', 'wolf']
    if term :
    INDENT
        data = [{"label" : i, "id" : i + "_id"} for i in data if i.find(term) > = 0]
    DEDENT
    data = json.dumps(data)
    self.response.out.write(data)
DEDENT
----------------------------------------

def get(self) :
INDENT
    self.response.out.write("""
<html>
<head>
<link rel="stylesheet" href="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/themes/smoothness/jquery-ui.css"><![CDATA[
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"><![CDATA[</script>
<script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js"><![CDATA[</script>
<script>
  $( function() {
    function log( message ) {
      $( "<div>" ).text( message ).prependTo( "#log" );
      $( "#log" ).scrollTop( 0 );
    }

    $( "#animals" ).autocomplete({
      source: "./products",
      minLength: 2,
      select: function( event, ui ) {
        log( "Selected: " + ui.item.value + " aka " + ui.item.id  );
      }
    });
  } );
</script>
</head>
<body>
<div class="ui-widget"><![CDATA[
  <label for="animals"><![CDATA[Animals: </label>
  <input id="animals"><![CDATA[
</div>

<div class="ui-widget" style="margin-top:2em; font-family:Arial"><![CDATA[
  Result:
  <div id="log" style="height: 200px; width: 300px; overflow: auto;" class="ui-widget-content"><![CDATA[</div>
</div>
</body>
</html>
""")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44615392_44615496_1_17
44615392_44615650_1_23
Title: How to replace multiple elements in 2d list on python? 
----------------------------------------

def display_list(A, B) :
INDENT
    data = [("01", "02", "03", "04", "05", "06", "07"),
        ("08", "09", "10", "11", "12", "13", "14"),
        ("15", "16", "17", "18", "19", "20", "21")]
    result = []
    for sublist in data :
    INDENT
        tmp_result = []
        for element in sublist :
        INDENT
            value = int(element)
            if value == A :
            INDENT
                tmp_result.append("A")
            DEDENT
            elif value == B :
            INDENT
                tmp_result.append("B")
            DEDENT
            else :
            INDENT
                tmp_result.append(element)
            DEDENT
        DEDENT
        result.append(tuple(tmp_result))
    DEDENT
    return result
DEDENT
----------------------------------------

def display_list(A, B) :
INDENT
    mylist = [("01", "02", "03", "04", "05", "06", "07"),
        ("08", "09", "10", "11", "12", "13", "14"),
        ("15", "16", "17", "18", "19", "20", "21")]
    for row_index in range(len(mylist)) :
    INDENT

        elements_list = list(mylist [row_index])

        elements_list = ["A" if int(element) == A else "B" if int(element) == B else element for element in elements_list]

        mylist [row_index] = tuple(elements_list)
    DEDENT
    print (mylist)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44643260_44652126_106_117
44643260_44652126_5_28
Title: From Python Basics to Tkinter 
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Opt4")
    master.geometry("400x400")
    self.opt4lab = tk.Label(self, text = 'This is option 4')
    self.opt4lab.pack()
    self.gobackbut4 = tk.Button(self, text = 'Go Back', command = self.goback4)
    self.gobackbut4.pack()
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Menu")
    master.geometry("500x400")
    self.but1 = tk.Button(self, text = '1', command = self.opt1)
    self.but1.pack()
    self.but2 = tk.Button(self, text = '2', command = self.opt2)
    self.but2.pack()
    self.but3 = tk.Button(self, text = '3', command = self.opt3)
    self.but3.pack()
    self.but4 = tk.Button(self, text = '4', command = self.opt4)
    self.but4.pack()
    self.but5 = tk.Button(self, text = '5', command = self.opt5)
    self.but5.pack()
    self.but6 = tk.Button(self, text = '6', command = self.opt6)
    self.but6.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44643260_44652126_123_134
44643260_44652126_5_28
Title: From Python Basics to Tkinter 
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Opt5")
    master.geometry("400x400")
    self.opt5lab = tk.Label(self, text = 'This is option 5')
    self.opt5lab.pack()
    self.gobackbut5 = tk.Button(self, text = 'Go Back', command = self.goback5)
    self.gobackbut5.pack()
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Menu")
    master.geometry("500x400")
    self.but1 = tk.Button(self, text = '1', command = self.opt1)
    self.but1.pack()
    self.but2 = tk.Button(self, text = '2', command = self.opt2)
    self.but2.pack()
    self.but3 = tk.Button(self, text = '3', command = self.opt3)
    self.but3.pack()
    self.but4 = tk.Button(self, text = '4', command = self.opt4)
    self.but4.pack()
    self.but5 = tk.Button(self, text = '5', command = self.opt5)
    self.but5.pack()
    self.but6 = tk.Button(self, text = '6', command = self.opt6)
    self.but6.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44643260_44652126_140_151
44643260_44652126_5_28
Title: From Python Basics to Tkinter 
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Opt6")
    master.geometry("400x400")
    self.opt6lab = tk.Label(self, text = 'This is option 6')
    self.opt6lab.pack()
    self.gobackbut6 = tk.Button(self, text = 'Go Back', command = self.goback6)
    self.gobackbut6.pack()
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Menu")
    master.geometry("500x400")
    self.but1 = tk.Button(self, text = '1', command = self.opt1)
    self.but1.pack()
    self.but2 = tk.Button(self, text = '2', command = self.opt2)
    self.but2.pack()
    self.but3 = tk.Button(self, text = '3', command = self.opt3)
    self.but3.pack()
    self.but4 = tk.Button(self, text = '4', command = self.opt4)
    self.but4.pack()
    self.but5 = tk.Button(self, text = '5', command = self.opt5)
    self.but5.pack()
    self.but6 = tk.Button(self, text = '6', command = self.opt6)
    self.but6.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44643260_44652126_54_65
44643260_44652126_5_28
Title: From Python Basics to Tkinter 
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Opt1")
    master.geometry("400x400")
    self.opt1lab = tk.Label(self, text = 'This is option 1')
    self.opt1lab.pack()
    self.gobackbut1 = tk.Button(self, text = 'Go Back', command = self.goback1)
    self.gobackbut1.pack()
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Menu")
    master.geometry("500x400")
    self.but1 = tk.Button(self, text = '1', command = self.opt1)
    self.but1.pack()
    self.but2 = tk.Button(self, text = '2', command = self.opt2)
    self.but2.pack()
    self.but3 = tk.Button(self, text = '3', command = self.opt3)
    self.but3.pack()
    self.but4 = tk.Button(self, text = '4', command = self.opt4)
    self.but4.pack()
    self.but5 = tk.Button(self, text = '5', command = self.opt5)
    self.but5.pack()
    self.but6 = tk.Button(self, text = '6', command = self.opt6)
    self.but6.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44643260_44652126_5_28
44643260_44652126_71_82
Title: From Python Basics to Tkinter 
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Menu")
    master.geometry("500x400")
    self.but1 = tk.Button(self, text = '1', command = self.opt1)
    self.but1.pack()
    self.but2 = tk.Button(self, text = '2', command = self.opt2)
    self.but2.pack()
    self.but3 = tk.Button(self, text = '3', command = self.opt3)
    self.but3.pack()
    self.but4 = tk.Button(self, text = '4', command = self.opt4)
    self.but4.pack()
    self.but5 = tk.Button(self, text = '5', command = self.opt5)
    self.but5.pack()
    self.but6 = tk.Button(self, text = '6', command = self.opt6)
    self.but6.pack()
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Opt2")
    master.geometry("400x400")
    self.opt2lab = tk.Label(self, text = 'This is option 2')
    self.opt2lab.pack()
    self.gobackbut2 = tk.Button(self, text = 'Go Back', command = self.goback2)
    self.gobackbut2.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44643260_44652126_5_28
44643260_44652126_89_100
Title: From Python Basics to Tkinter 
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Menu")
    master.geometry("500x400")
    self.but1 = tk.Button(self, text = '1', command = self.opt1)
    self.but1.pack()
    self.but2 = tk.Button(self, text = '2', command = self.opt2)
    self.but2.pack()
    self.but3 = tk.Button(self, text = '3', command = self.opt3)
    self.but3.pack()
    self.but4 = tk.Button(self, text = '4', command = self.opt4)
    self.but4.pack()
    self.but5 = tk.Button(self, text = '5', command = self.opt5)
    self.but5.pack()
    self.but6 = tk.Button(self, text = '6', command = self.opt6)
    self.but6.pack()
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Opt3")
    master.geometry("400x400")
    self.opt3lab = tk.Label(self, text = 'This is option 3')
    self.opt3lab.pack()
    self.gobackbut3 = tk.Button(self, text = 'Go Back', command = self.goback3)
    self.gobackbut3.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44663788_44663820_1_6
44663788_44663919_1_10
Title: Find the divisors: codewars 
----------------------------------------

def divisors(integer) :
INDENT
    arr = []
    for x in range(2, integer - 1) :
    INDENT
        if integer % x == 0 :
        INDENT
            arr.append(x)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def divisors(integer) :
INDENT
    arr = []
    for x in range(2, round(integer ** 0.5)) :
    INDENT
        if integer % x == 0 :
        INDENT
            arr.append(x)
        DEDENT
    DEDENT
    if len(arr) == 0 :
    INDENT
        return str(integer) + ' is prime'
    DEDENT
    else :
    INDENT
        return arr
    DEDENT
DEDENT
----------------------------------------
