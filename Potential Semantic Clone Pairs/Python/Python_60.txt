$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5843709_5843774_21_30
5843709_5843782_7_15
Title: Python dumps variable from loop 
----------------------------------------

def main() :
INDENT
    keepGoing = 'y'
    while keepGoing == 'y' :
    INDENT
        b = Bottles()
        b.getBottles()
        b.calcPayout()
        b.printInfo()
        keepGoing == raw_input('Do you want to run the program again?')
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    keepGoing = 'y'
    while keepGoing == 'y' :
    INDENT
        totalBottles = getBottles(totalBottles, todayBottles)
        totalPayout = calcPayout(totalBottles)
        printInfo(totalBottles, totalPayout)
        keepGoing == raw_input('Do you want to run the program again?')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5843709_5843774_8_13
5843709_5843782_16_23
Title: Python dumps variable from loop 
----------------------------------------

def getBottles(self) :
INDENT
    while self.counter < 8 :
    INDENT
        self.todayBottles = input('Enter number of bottles returned for the day:')
        self.totalBottles = self.todayBottles + self.totalBottles
        self.counter = self.counter + 1
    DEDENT
DEDENT
----------------------------------------

def getBottles(totalBottles, todayBottles) :
INDENT
    counter = 1
    while counter < 8 :
    INDENT
        todayBottles = input('Enter number of bottles returned for the day:')
        totalBottles = todayBottles + totalBottles
        counter = counter + 1
    DEDENT
    return totalBottles
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5848252_18475322_2_13
5848252_35365253_1_11
Title: wtforms Form class subclassing and field ordering 
----------------------------------------

def __iter__(self) :
INDENT
    field_order = getattr(self, 'field_order', None)
    if field_order :
    INDENT
        temp_fields = []
        for name in field_order :
        INDENT
            if name == '*' :
            INDENT
                temp_fields.extend([f for f in self._unbound_fields if f [0] not in field_order])
            DEDENT
            else :
            INDENT
                temp_fields.append([f for f in self._unbound_fields if f [0] == name] [0])
            DEDENT
        DEDENT
        self._unbound_fields = temp_fields
    DEDENT
    return super(BaseForm, self).__iter__()
DEDENT
----------------------------------------

def __iter__(self) :
INDENT
    ordered_fields = collections.OrderedDict()
    for name in getattr(self, 'field_order', []) :
    INDENT
        ordered_fields [name] = self._fields.pop(name)
    DEDENT
    ordered_fields.update(self._fields)
    self._fields = ordered_fields
    return super(BaseForm, self).__iter__()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849484_5849765_22_28
5849484_5852044_25_47
Title: How to exit a multithreaded program? 
----------------------------------------

def run(self) :
INDENT
    while not self.quit :
    INDENT
        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        conn.connect(('localhost', 2727))
        conn.send('sending\n')
        print conn.recv(100)
        conn.close()
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn.bind(('', self.port))
    conn.listen(5)
    conn.settimeout(0.01)
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            csock, caddr = conn.accept()
            listen_thread = Listen(csock, caddr)
            self.threads.append(listen_thread)
            listen_thread.start()
        DEDENT
        except socket.timeout :
        INDENT
            for thread in self.threads :
            INDENT
                if thread.isAlive() == False :
                INDENT
                    self.threads.remove(thread)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    self.stop_threads()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849484_5849765_22_28
5849484_5852044_62_80
Title: How to exit a multithreaded program? 
----------------------------------------

def run(self) :
INDENT
    while not self.quit :
    INDENT
        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        conn.connect(('localhost', 2727))
        conn.send('sending\n')
        print conn.recv(100)
        conn.close()
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            recv_data = self.csock.recv(250)
            if len(recv_data) > 0 :
            INDENT
                print str(self.caddr) + ": " + recv_data
                self.csock.send("got it")
            DEDENT
            else :
            INDENT

                self.stop_event.set()
            DEDENT
        DEDENT
        except socket.error as (sock_errno, sock_errstr) :
        INDENT
            if (sock_errno == errno.EWOULDBLOCK) :
            INDENT

                time.sleep(0.1)
            DEDENT
            else :
            INDENT

                self.stop_event.set()
            DEDENT
        DEDENT
    DEDENT
    channel.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849484_5849765_22_28
5849484_5852044_86_112
Title: How to exit a multithreaded program? 
----------------------------------------

def run(self) :
INDENT
    while not self.quit :
    INDENT
        conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        conn.connect(('localhost', 2727))
        conn.send('sending\n')
        print conn.recv(100)
        conn.close()
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            address = raw_input("who u talking to? ")
            conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            conn.connect((address, self.sport))
            break
        DEDENT
        except socket.error :
        INDENT
            print "can't connect to " + str(address)
        DEDENT
        except :
        INDENT

            self.stop_event.set()
        DEDENT
    DEDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            print "what to send? :",
            msg = raw_input()
            conn.send(msg)
        DEDENT
        except :
        INDENT

            self.stop_event.set()
        DEDENT
    DEDENT
    conn.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849484_5852044_25_47
5849484_5852044_62_80
Title: How to exit a multithreaded program? 
----------------------------------------

def run(self) :
INDENT
    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn.bind(('', self.port))
    conn.listen(5)
    conn.settimeout(0.01)
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            csock, caddr = conn.accept()
            listen_thread = Listen(csock, caddr)
            self.threads.append(listen_thread)
            listen_thread.start()
        DEDENT
        except socket.timeout :
        INDENT
            for thread in self.threads :
            INDENT
                if thread.isAlive() == False :
                INDENT
                    self.threads.remove(thread)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    self.stop_threads()
DEDENT
----------------------------------------

def run(self) :
INDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            recv_data = self.csock.recv(250)
            if len(recv_data) > 0 :
            INDENT
                print str(self.caddr) + ": " + recv_data
                self.csock.send("got it")
            DEDENT
            else :
            INDENT

                self.stop_event.set()
            DEDENT
        DEDENT
        except socket.error as (sock_errno, sock_errstr) :
        INDENT
            if (sock_errno == errno.EWOULDBLOCK) :
            INDENT

                time.sleep(0.1)
            DEDENT
            else :
            INDENT

                self.stop_event.set()
            DEDENT
        DEDENT
    DEDENT
    channel.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849484_5852044_25_47
5849484_5852044_86_112
Title: How to exit a multithreaded program? 
----------------------------------------

def run(self) :
INDENT
    conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    conn.bind(('', self.port))
    conn.listen(5)
    conn.settimeout(0.01)
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            csock, caddr = conn.accept()
            listen_thread = Listen(csock, caddr)
            self.threads.append(listen_thread)
            listen_thread.start()
        DEDENT
        except socket.timeout :
        INDENT
            for thread in self.threads :
            INDENT
                if thread.isAlive() == False :
                INDENT
                    self.threads.remove(thread)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    self.stop_threads()
DEDENT
----------------------------------------

def run(self) :
INDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            address = raw_input("who u talking to? ")
            conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            conn.connect((address, self.sport))
            break
        DEDENT
        except socket.error :
        INDENT
            print "can't connect to " + str(address)
        DEDENT
        except :
        INDENT

            self.stop_event.set()
        DEDENT
    DEDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            print "what to send? :",
            msg = raw_input()
            conn.send(msg)
        DEDENT
        except :
        INDENT

            self.stop_event.set()
        DEDENT
    DEDENT
    conn.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849484_5852044_62_80
5849484_5852044_86_112
Title: How to exit a multithreaded program? 
----------------------------------------

def run(self) :
INDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            recv_data = self.csock.recv(250)
            if len(recv_data) > 0 :
            INDENT
                print str(self.caddr) + ": " + recv_data
                self.csock.send("got it")
            DEDENT
            else :
            INDENT

                self.stop_event.set()
            DEDENT
        DEDENT
        except socket.error as (sock_errno, sock_errstr) :
        INDENT
            if (sock_errno == errno.EWOULDBLOCK) :
            INDENT

                time.sleep(0.1)
            DEDENT
            else :
            INDENT

                self.stop_event.set()
            DEDENT
        DEDENT
    DEDENT
    channel.close()
DEDENT
----------------------------------------

def run(self) :
INDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            address = raw_input("who u talking to? ")
            conn = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            conn.connect((address, self.sport))
            break
        DEDENT
        except socket.error :
        INDENT
            print "can't connect to " + str(address)
        DEDENT
        except :
        INDENT

            self.stop_event.set()
        DEDENT
    DEDENT
    while self.stop_event.is_set() == False :
    INDENT
        try :
        INDENT
            print "what to send? :",
            msg = raw_input()
            conn.send(msg)
        DEDENT
        except :
        INDENT

            self.stop_event.set()
        DEDENT
    DEDENT
    conn.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849800_18903019_7_12
5849800_46874648_11_17
Title: "tic toc functions analog in Python" 
----------------------------------------

def toc() :
INDENT
    import time
    if 'startTime_for_tictoc' in globals() :
    INDENT
        print "Elapsed time is " + str(time.time() - startTime_for_tictoc) + " seconds."
    DEDENT
    else :
    INDENT
        print "Toc: start time not set"
    DEDENT
DEDENT
----------------------------------------

def toc(name = None) :
INDENT
    if name is None :
    INDENT
        start = start_stack.pop()
    DEDENT
    else :
    INDENT
        start = start_named.pop(name)
    DEDENT
    elapsed = time() - start
    return elapsed
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849800_18903019_7_12
5849800_51547906_127_135
Title: "tic toc functions analog in Python" 
----------------------------------------

def toc() :
INDENT
    import time
    if 'startTime_for_tictoc' in globals() :
    INDENT
        print "Elapsed time is " + str(time.time() - startTime_for_tictoc) + " seconds."
    DEDENT
    else :
    INDENT
        print "Toc: start time not set"
    DEDENT
DEDENT
----------------------------------------

def toc(self) :
INDENT
    self.tend = self.get_time()
    if self.indentation :
    INDENT
        if len(self.tstart) > 0 :
        INDENT
            self.elapsed = self.tend - self.tstart.pop()
        DEDENT
        else :
        INDENT
            self.elapsed = None
        DEDENT
    DEDENT
    else :
    INDENT
        self.elapsed = self.tend - self.tstart
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849800_46874648_11_17
5849800_51547906_127_135
Title: "tic toc functions analog in Python" 
----------------------------------------

def toc(name = None) :
INDENT
    if name is None :
    INDENT
        start = start_stack.pop()
    DEDENT
    else :
    INDENT
        start = start_named.pop(name)
    DEDENT
    elapsed = time() - start
    return elapsed
DEDENT
----------------------------------------

def toc(self) :
INDENT
    self.tend = self.get_time()
    if self.indentation :
    INDENT
        if len(self.tstart) > 0 :
        INDENT
            self.elapsed = self.tend - self.tstart.pop()
        DEDENT
        else :
        INDENT
            self.elapsed = None
        DEDENT
    DEDENT
    else :
    INDENT
        self.elapsed = self.tend - self.tstart
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849800_46874648_5_10
5849800_51547906_121_126
Title: "tic toc functions analog in Python" 
----------------------------------------

def tic(name = None) :
INDENT
    if name is None :
    INDENT
        start_stack.append(time())
    DEDENT
    else :
    INDENT
        start_named [name] = time()
    DEDENT
DEDENT
----------------------------------------

def tic(self) :
INDENT
    if self.indentation :
    INDENT
        self.tstart.append(self.get_time())
    DEDENT
    else :
    INDENT
        self.tstart = self.get_time()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5849800_50957722_9_16
5849800_51547906_109_120
Title: "tic toc functions analog in Python" 
----------------------------------------

def __exit__(self, type, value, traceback) :
INDENT
    message = 'Elapsed: %.2f seconds' % (time.time() - self.tstart)
    if self.name :
    INDENT
        message = '[%s] ' % self.name + message
    DEDENT
    print (message)
    if self.filename :
    INDENT
        with open(self.filename, 'a') as file :
        INDENT
            print(str(datetime.datetime.now()) + ": ", message, file = file)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __exit__(self, type, value, traceback) :
INDENT
    self.tend = self.get_time()
    if self.indentation :
    INDENT
        self.elapsed = self.tend - self.tstart.pop()
    DEDENT
    else :
    INDENT
        self.elapsed = self.tend - self.tstart
    DEDENT
    if self.name ! = '' : name = '[{}] '.format(self.name)
    else : name = self.name
    print ('{0}Elapsed time: {1} ({2})'.format(name, self.elapsed, self.__measure))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5852704_5852852_1_11
5852704_5855323_1_14
Title: Python: write multiple str.format() lines to a file? 
----------------------------------------

def print_host(host, address) :
INDENT
    f = open(host, 'w')
    f.write("""define host {{
        host_name            {host}
        alias                {host}
        display_name         {host}
        address              {address}
        use                  linux-server
        register             1
    }}\n""".format(host = host, address = address))
DEDENT
----------------------------------------

def print_host(host, serv, numb, ch = ('define host {{\n'
    '    {0:<21}{6}\n'
    '    {1:<21}{6}\n'
    '    {2:<21}{6}\n'
    '    {3:<21}{7}\n'
    '    {4:<21}{8}\n'
    '    {5:<21}{9}\n'
    '}}\n')) :
INDENT
    f = open(host, 'w')
    f.write(ch.format('host_name', 'alias', 'display_name',
            'address', 'use', 'register',
            host,
            str(socket.gethostbyname(host)), serv, numb))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5888734_5889358_14_21
5888734_5889359_11_16
Title: Dictionary+Queue Data Structure with Active Removal of Old Messages 
----------------------------------------

def pop(self, name) :
INDENT
    queue = self.get_queue(name)
    if queue :
    INDENT
        key, msg = queue.pop()
        self._expire [key] [name] -= 1
        return msg
    DEDENT
    return None
DEDENT
----------------------------------------

def pop(self) :
INDENT
    self._queue = [(t, msg) for (t, msg) in self._queue if t > time.time()]
    if len(self._queue) == 0 :
    INDENT
        raise EmptyException()
    DEDENT
    return self._queue.pop(0) [1]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5911362_46799894_32_42
5911362_46799894_65_73
Title: pipe large amount of data to stdin while using subprocess.Popen 
----------------------------------------

def __init__(self, f, lines, autoclose = True, buffer_size = 16 * 1024, encoding = "utf-8", linesep = os.linesep) :
INDENT
    super(nonblocking_line_writer, self).__init__(f)
    self._lines = iter(lines)
    self._lines_ended = False
    self._autoclose = autoclose
    self._buffer_size = buffer_size
    self._buffer_offset = 0
    self._buffer = bytearray()
    self._encoding = encoding
    self._linesep = bytearray(linesep, encoding)
DEDENT
----------------------------------------

def __init__(self, f, autoclose = True, buffer_size = 16 * 1024, encoding = "utf-8") :
INDENT
    super(nonblocking_line_reader, self).__init__(f)
    self._autoclose = autoclose
    self._buffer_size = buffer_size
    self._encoding = encoding
    self._file_ended = False
    self._line_part = ""

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5911362_46799894_32_42
5911362_46799894_7_18
Title: pipe large amount of data to stdin while using subprocess.Popen 
----------------------------------------

def __init__(self, f, lines, autoclose = True, buffer_size = 16 * 1024, encoding = "utf-8", linesep = os.linesep) :
INDENT
    super(nonblocking_line_writer, self).__init__(f)
    self._lines = iter(lines)
    self._lines_ended = False
    self._autoclose = autoclose
    self._buffer_size = buffer_size
    self._buffer_offset = 0
    self._buffer = bytearray()
    self._encoding = encoding
    self._linesep = bytearray(linesep, encoding)
DEDENT
----------------------------------------

def __init__(self, f) :
INDENT
    self._fd = - 1
    if type(f) is int :
    INDENT
        self._fd = os.dup(f)
        os.close(f)
    DEDENT
    elif type(f) is file :
    INDENT
        self._fd = os.dup(f.fileno())
        f.close()
    DEDENT
    else :
    INDENT
        raise TypeError("Only accept file objects or interger file descriptors")
    DEDENT
    flag = fcntl.fcntl(self._fd, fcntl.F_GETFL)
    fcntl.fcntl(self._fd, fcntl.F_SETFL, flag | os.O_NONBLOCK)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5911362_46799894_65_73
5911362_46799894_7_18
Title: pipe large amount of data to stdin while using subprocess.Popen 
----------------------------------------

def __init__(self, f, autoclose = True, buffer_size = 16 * 1024, encoding = "utf-8") :
INDENT
    super(nonblocking_line_reader, self).__init__(f)
    self._autoclose = autoclose
    self._buffer_size = buffer_size
    self._encoding = encoding
    self._file_ended = False
    self._line_part = ""

DEDENT
----------------------------------------

def __init__(self, f) :
INDENT
    self._fd = - 1
    if type(f) is int :
    INDENT
        self._fd = os.dup(f)
        os.close(f)
    DEDENT
    elif type(f) is file :
    INDENT
        self._fd = os.dup(f.fileno())
        f.close()
    DEDENT
    else :
    INDENT
        raise TypeError("Only accept file objects or interger file descriptors")
    DEDENT
    flag = fcntl.fcntl(self._fd, fcntl.F_GETFL)
    fcntl.fcntl(self._fd, fcntl.F_SETFL, flag | os.O_NONBLOCK)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5938309_5941853_1_34
5938309_5942043_6_83
Title: """sorted 1-d iterator"" based on ""2-d iterator"" (Cartesian product of iterators)" 
----------------------------------------

def increasing(fn, left, right) :
INDENT
    left_items = [next(left)]
    right_items = [next(right)]

    columns = [(fn(left_items [0], right_items [0]), 0)]
    while True :
    INDENT

        min_col_index = min(xrange(len(columns)), key = lambda i : columns [i] [0])

        while right_items [0] < = columns [min_col_index] [0] and left_items [- 1] < = columns [min_col_index] [0] :
        INDENT
            next_left = next(left)
            left_items.append(next_left)
            columns.append((fn(next_left, right_items [0]), 0))
            if columns [- 1] [0] < columns [min_col_index] [0] :
            INDENT
                min_col_index = len(columns) - 1

            DEDENT
        DEDENT
        yield columns [min_col_index] [0]

        val, right_index = columns [min_col_index]

        while right_index + 1 > = len(right_items) :
        INDENT
            right_items.append(next(right))
        DEDENT
        columns [min_col_index] = (fn(left_items [min_col_index], right_items [right_index + 1]),
            right_index + 1)
    DEDENT
DEDENT
----------------------------------------

def increasing(fn, left, right) :
INDENT
    left_items = [next(left)]
    right_items = [next(right)]

    heap = []
    def add_value(left_index, right_index) :
    INDENT
        value = fn(left_items [left_index], right_items [right_index])

        heapq.heappush(heap, (value, left_index, right_index))

    DEDENT
    add_value(0, 0)

    while True :
    INDENT

        value, left_index, right_index = heapq.heappop(heap)

        yield value

        if left_index + 1 == len(left_items) :
        INDENT
            left_items.append(next(left))
        DEDENT
        add_value(left_index + 1, right_index)

        if left_index == 0 :
        INDENT
            right_items.append(next(right))
            add_value(0, right_index + 1)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5940416_5940623_4_10
5940416_5941361_5_19
Title: Compress a series of 1s and 0s into the shortest possible ascii string 
----------------------------------------

def encode(n) :
INDENT
    data = struct.pack('<Q', n).rstrip('\x00')
    if len(data) == 0 :
    INDENT
        data = '\x00'
    DEDENT
    s = base64.urlsafe_b64encode(data).rstrip('=')
    return s
DEDENT
----------------------------------------

def encode(bin_string) :
INDENT
    chunks = [bin_string [i : i + 6] for i in range(0, len(bin_string), 6)]

    last_chunk_length = len(chunks [- 1])
    decimals = [int(chunk, 2) for chunk in chunks]
    decimals.append(last_chunk_length)
    ascii_string = ''.join([charset [i] for i in decimals])
    return ascii_string
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5969806_38629223_5_13
5969806_42775862_2_9
Title: Print all properties of a Python Class 
----------------------------------------

def __init__(self) :
INDENT
    self.legs = 2
    self.name = 'Dog'
    self.color = 'Spotted'
    self.smell = 'Alot'
    self.age = 10
    self.kids = 0

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.legs = 2
    self.name = 'Dog'
    self.color = 'Spotted'
    self.smell = 'Alot'
    self.age = 10
    self.kids = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
597369_50068400_9_17
597369_5690387_11_20
Title: How to create MS Paint clone with Python and pygame 
----------------------------------------

def __init__(self) :
INDENT
    os.environ ['SDL_VIDEO_CENTERED'] = '1'
    pg.init()
    self.w, self.h = 800, 600
    self.screen = pg.display.set_mode((self.w, self.h))
    self.screen.fill(pg.Color('white'))
    self.clock = pg.time.Clock()
    self.drawcolor = (0, 0, 0)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.w, self.h = 800, 600
    PygameHelper.__init__(self, size = (self.w, self.h), fill = ((255, 255, 255)))
    self.img = pygame.image.load("colors.png")
    self.screen.blit(self.img, (0, 0))
    self.drawcolor = (0, 0, 0)
    self.x = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5983237_5983970_15_22
5983237_5984569_3_11
Title: How do I make 'import x' return a subclass of types.ModuleType? 
----------------------------------------

def __getattribute__(self, key) :
INDENT
    context = object.__getattribute__(self, 'context')
    if hasattr(context, '__all__') and key not in context.__all__ :
    INDENT
        warnings.warn('%s not in %s.__all__' % (key, context.__name__),
            EncapsulationWarning,
            2)
    DEDENT
    return context.__getattribute__(key)
DEDENT
----------------------------------------

def __getattribute__(self, key) :
INDENT
    if key is "__dict__" :
    INDENT
        return dict((k, v) for k, v in globals().iteritems()
            if k.startswith("__") or k in __all__)
    DEDENT
    if (key.startswith("__") or key in __all__) and key in globals() :
    INDENT
        return globals() [key]
    DEDENT
    else :
    INDENT
        raise AttributeError("'module' object has no attribute '%s'" % key)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
599430_15468266_3_15
599430_599492_8_20
Title: Why doesn't the weakref work on this bound method? 
----------------------------------------

def __init__(self, item) :
INDENT
    try :
    INDENT
        self.method = weakref.ref(item.im_func)
        self.instance = weakref.ref(item.im_self)
    DEDENT
    except AttributeError :
    INDENT
        self.reference = weakref.ref(item)
    DEDENT
    else :
    INDENT
        self.reference = None

    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    def MyCallbackA() :
    INDENT
        print 'MyCallbackA'
    DEDENT
    self.MyCallbackA = MyCallbackA
    self._testA = weakref.proxy(self.MyCallbackA)
    print "Create MyCallbackB"
    self._testB = weakref.proxy(self.MyCallbackB, trace)
    print "Done playing with MyCallbackB"
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
600268_11860637_4_12
600268_27611157_2_10
Title: mkdir -p functionality in Python 
----------------------------------------

def mkdir_p(path) :
INDENT
    try :
    INDENT
        os.makedirs(path)
    DEDENT
    except OSError as exc :
    INDENT
        if exc.errno == errno.EEXIST and os.path.isdir(path) :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            raise
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def mkdir_p(filename) :
INDENT
    try :
    INDENT
        folder = os.path.dirname(filename)
        if not os.path.exists(folder) :
        INDENT
            os.makedirs(folder)
        DEDENT
        return True
    DEDENT
    except :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
600268_27611157_2_10
600268_600612_5_12
Title: mkdir -p functionality in Python 
----------------------------------------

def mkdir_p(filename) :
INDENT
    try :
    INDENT
        folder = os.path.dirname(filename)
        if not os.path.exists(folder) :
        INDENT
            os.makedirs(folder)
        DEDENT
        return True
    DEDENT
    except :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def mkdir_p(path) :
INDENT
    try :
    INDENT
        os.makedirs(path)
    DEDENT
    except OSError as exc :
    INDENT
        if exc.errno == errno.EEXIST and os.path.isdir(path) :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            raise
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6012380_6012666_16_26
6012380_6012666_2_14
Title: wxMessageBox with an auto-close timer in wxPython 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (100, 100), style = wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX | wx.CLIP_CHILDREN)
    host = os.system('hostname')
    if host ! = 'superman' :
    INDENT
        dlg = MessageDialog('The host name should be superman. Closing this dialog box in 2s...', 'Info')
        wx.FutureCall(2000, dlg.Destroy)
        dlg.ShowModal()
    DEDENT
    else :
    INDENT
        self.Center()
        self.Show()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, message, title) :
INDENT
    wx.Dialog.__init__(self, None, - 1, title, size = (300, 120))
    self.CenterOnScreen(wx.BOTH)
    ok = wx.Button(self, wx.ID_OK, "OK")
    ok.SetDefault()
    text = wx.StaticText(self, - 1, message)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(text, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(ok, 1, wx.ALIGN_CENTER | wx.BOTTOM, 10)
    self.SetSizer(vbox)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6012380_6012666_16_26
6012380_6022634_5_24
Title: wxMessageBox with an auto-close timer in wxPython 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (100, 100), style = wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX | wx.CLIP_CHILDREN)
    host = os.system('hostname')
    if host ! = 'superman' :
    INDENT
        dlg = MessageDialog('The host name should be superman. Closing this dialog box in 2s...', 'Info')
        wx.FutureCall(2000, dlg.Destroy)
        dlg.ShowModal()
    DEDENT
    else :
    INDENT
        self.Center()
        self.Show()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, message, title, ttl = 10) :
INDENT
    wx.Dialog.__init__(self, None, - 1, title, size = (400, 150))
    self.CenterOnScreen(wx.BOTH)
    self.timeToLive = ttl
    stdBtnSizer = self.CreateStdDialogButtonSizer(wx.OK | wx.CANCEL)
    stMsg = wx.StaticText(self, - 1, message)
    self.stTTLmsg = wx.StaticText(self, - 1, 'Closing this dialog box in %ds...' % self.timeToLive)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(stMsg, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(self.stTTLmsg, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(stdBtnSizer, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    self.SetSizer(vbox)
    self.timer = wx.Timer(self)
    self.timer.Start(1000)
    self.timeToLive = 10
    self.Bind(wx.EVT_TIMER, self.onTimer, self.timer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6012380_6012666_2_14
6012380_6022634_34_44
Title: wxMessageBox with an auto-close timer in wxPython 
----------------------------------------

def __init__(self, message, title) :
INDENT
    wx.Dialog.__init__(self, None, - 1, title, size = (300, 120))
    self.CenterOnScreen(wx.BOTH)
    ok = wx.Button(self, wx.ID_OK, "OK")
    ok.SetDefault()
    text = wx.StaticText(self, - 1, message)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(text, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(ok, 1, wx.ALIGN_CENTER | wx.BOTTOM, 10)
    self.SetSizer(vbox)
DEDENT
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (100, 100), style = wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX | wx.CLIP_CHILDREN)
    host = os.system('hostname')
    if host ! = 'superman' :
    INDENT
        dlg = MessageDialog('The host name should be superman', 'Info', ttl = 10)
        dlg.ShowModal()
    DEDENT
    else :
    INDENT
        self.Center()
        self.Show()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6012380_6012666_2_14
6012380_6022634_5_24
Title: wxMessageBox with an auto-close timer in wxPython 
----------------------------------------

def __init__(self, message, title) :
INDENT
    wx.Dialog.__init__(self, None, - 1, title, size = (300, 120))
    self.CenterOnScreen(wx.BOTH)
    ok = wx.Button(self, wx.ID_OK, "OK")
    ok.SetDefault()
    text = wx.StaticText(self, - 1, message)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(text, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(ok, 1, wx.ALIGN_CENTER | wx.BOTTOM, 10)
    self.SetSizer(vbox)
DEDENT
----------------------------------------

def __init__(self, message, title, ttl = 10) :
INDENT
    wx.Dialog.__init__(self, None, - 1, title, size = (400, 150))
    self.CenterOnScreen(wx.BOTH)
    self.timeToLive = ttl
    stdBtnSizer = self.CreateStdDialogButtonSizer(wx.OK | wx.CANCEL)
    stMsg = wx.StaticText(self, - 1, message)
    self.stTTLmsg = wx.StaticText(self, - 1, 'Closing this dialog box in %ds...' % self.timeToLive)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(stMsg, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(self.stTTLmsg, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(stdBtnSizer, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    self.SetSizer(vbox)
    self.timer = wx.Timer(self)
    self.timer.Start(1000)
    self.timeToLive = 10
    self.Bind(wx.EVT_TIMER, self.onTimer, self.timer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6012380_6022634_34_44
6012380_6022634_5_24
Title: wxMessageBox with an auto-close timer in wxPython 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (100, 100), style = wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX | wx.CLIP_CHILDREN)
    host = os.system('hostname')
    if host ! = 'superman' :
    INDENT
        dlg = MessageDialog('The host name should be superman', 'Info', ttl = 10)
        dlg.ShowModal()
    DEDENT
    else :
    INDENT
        self.Center()
        self.Show()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, message, title, ttl = 10) :
INDENT
    wx.Dialog.__init__(self, None, - 1, title, size = (400, 150))
    self.CenterOnScreen(wx.BOTH)
    self.timeToLive = ttl
    stdBtnSizer = self.CreateStdDialogButtonSizer(wx.OK | wx.CANCEL)
    stMsg = wx.StaticText(self, - 1, message)
    self.stTTLmsg = wx.StaticText(self, - 1, 'Closing this dialog box in %ds...' % self.timeToLive)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(stMsg, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(self.stTTLmsg, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    vbox.Add(stdBtnSizer, 1, wx.ALIGN_CENTER | wx.TOP, 10)
    self.SetSizer(vbox)
    self.timer = wx.Timer(self)
    self.timer.Start(1000)
    self.timeToLive = 10
    self.Bind(wx.EVT_TIMER, self.onTimer, self.timer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
602046_602087_2_10
602046_604568_1_19
Title: Should I check the types of constructor arguments (and at other places too)? 
----------------------------------------

def __init__(self, f, fieldnames, restval = "", extrasaction = "raise",
dialect = "excel", * args, ** kwds) :
INDENT
    self.fieldnames = fieldnames
    self.restval = restval
    if extrasaction.lower() not in ("raise", "ignore") :
    INDENT
        raise ValueError, ("extrasaction (%s) must be 'raise' or 'ignore'" %
            extrasaction)
    DEDENT
    self.extrasaction = extrasaction
    self.writer = writer(f, dialect, * args, ** kwds)
DEDENT
----------------------------------------

def __init__(self, a_number, a_boolean, a_duck, a_sequence) :
INDENT
    self.a_number = a_number + 0
    self.a_boolean = not not a_boolean
    try :
    INDENT
        a_duck.quack
    DEDENT
    except AttributeError :
    INDENT
        raise TypeError, "can't use it if it doesn't quack"
    DEDENT
    else :
    INDENT
        self.a_duck = a_duck
    DEDENT
    try :
    INDENT
        iter(a_sequence)
    DEDENT
    except TypeError :
    INDENT
        raise TypeError, "expected an iterable sequence"
    DEDENT
    else :
    INDENT
        self.a_sequence = a_sequence
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6031870_6041472_168_187
6031870_6041472_194_207
Title: adding wxGLCanvas to wxPanel problem 
----------------------------------------

def __init__(self, parent, canvas, * args, ** kwargs) :
INDENT
    wx.Panel.__init__(self, parent, * args, ** kwargs)
    self.canvas = canvas
    self.button1 = wx.Button(self, label = "TEXT 1")
    self.button2 = wx.Button(self, label = "TEXT 2")
    self.check1 = wx.CheckBox(self, label = "Show Axes")
    self.Bind(wx.EVT_CHECKBOX, self.Check1)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.button1, flag = wx.BOTTOM, border = 5)
    self.sizer.Add(self.button2, flag = wx.BOTTOM, border = 5)
    self.sizer.Add(self.check1)
    self.border = wx.BoxSizer()
    self.border.Add(self.sizer, flag = wx.ALL | wx.EXPAND, border = 5)
    self.SetSizerAndFit(self.border)

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, title = 'OpenGL', * args, ** kwargs)
    self.canvas = myGLCanvas(self, size = (640, 480))
    self.panel = ToolPanel(self, canvas = self.canvas)
    self.sizer = wx.BoxSizer()
    self.sizer.Add(self.canvas, 1, wx.EXPAND)
    self.sizer.Add(self.panel, 0, wx.EXPAND)
    self.SetSizerAndFit(self.sizer)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6031870_6041472_168_187
6031870_6041472_9_33
Title: adding wxGLCanvas to wxPanel problem 
----------------------------------------

def __init__(self, parent, canvas, * args, ** kwargs) :
INDENT
    wx.Panel.__init__(self, parent, * args, ** kwargs)
    self.canvas = canvas
    self.button1 = wx.Button(self, label = "TEXT 1")
    self.button2 = wx.Button(self, label = "TEXT 2")
    self.check1 = wx.CheckBox(self, label = "Show Axes")
    self.Bind(wx.EVT_CHECKBOX, self.Check1)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.button1, flag = wx.BOTTOM, border = 5)
    self.sizer.Add(self.button2, flag = wx.BOTTOM, border = 5)
    self.sizer.Add(self.check1)
    self.border = wx.BoxSizer()
    self.border.Add(self.sizer, flag = wx.ALL | wx.EXPAND, border = 5)
    self.SetSizerAndFit(self.border)

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    GLCanvas.__init__(self, * args, ** kwargs)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_SIZE, self.OnResize)
    self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
    self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
    self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
    self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
    self.Bind(wx.EVT_MOTION, self.OnMouse)
    self.init = False
    self.width, self.height = self.GetSize()
    self.alpha = 0
    self.beta = 0
    self.distance = 5.0
    self.oldX = 0
    self.oldY = 0
    self.leftDown = False
    self.rightDown = False
    self.axes = False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6031870_6041472_194_207
6031870_6041472_9_33
Title: adding wxGLCanvas to wxPanel problem 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, title = 'OpenGL', * args, ** kwargs)
    self.canvas = myGLCanvas(self, size = (640, 480))
    self.panel = ToolPanel(self, canvas = self.canvas)
    self.sizer = wx.BoxSizer()
    self.sizer.Add(self.canvas, 1, wx.EXPAND)
    self.sizer.Add(self.panel, 0, wx.EXPAND)
    self.SetSizerAndFit(self.sizer)
    self.Show()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    GLCanvas.__init__(self, * args, ** kwargs)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_SIZE, self.OnResize)
    self.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
    self.Bind(wx.EVT_RIGHT_DOWN, self.OnRightDown)
    self.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
    self.Bind(wx.EVT_RIGHT_UP, self.OnRightUp)
    self.Bind(wx.EVT_MOTION, self.OnMouse)
    self.init = False
    self.width, self.height = self.GetSize()
    self.alpha = 0
    self.beta = 0
    self.distance = 5.0
    self.oldX = 0
    self.oldY = 0
    self.leftDown = False
    self.rightDown = False
    self.axes = False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6037503_6037657_1_11
6037503_6037725_2_10
Title: Python - Unflatten dict 
----------------------------------------

def unflatten(dictionary) :
INDENT
    resultDict = dict()
    for key, value in dictionary.iteritems() :
    INDENT
        parts = key.split(".")
        d = resultDict
        for part in parts [: - 1] :
        INDENT
            if part not in d :
            INDENT
                d [part] = dict()
            DEDENT
            d = d [part]
        DEDENT
        d [parts [- 1]] = value
    DEDENT
    return resultDict
DEDENT
----------------------------------------

def unflatten(d) :
INDENT
    ret = defaultdict(dict)
    for k, v in d.items() :
    INDENT
        k1, delim, k2 = k.partition('.')
        if delim :
        INDENT
            ret [k1].update({k2 : v})
        DEDENT
        else :
        INDENT
            ret [k1] = v
        DEDENT
    DEDENT
    return ret
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6039103_35698158_1_27
6039103_6040217_4_11
Title: Counting depth or the deepest level a nested list goes to 
----------------------------------------

def depth(arg, exclude = None) :
INDENT
    if exclude is None :
    INDENT
        exclude = (str,)
    DEDENT
    if isinstance(arg, tuple(exclude)) :
    INDENT
        return 0
    DEDENT
    try :
    INDENT
        if next(iter(arg)) is arg :
        INDENT
            return 1
        DEDENT
    DEDENT
    except TypeError :
    INDENT
        return 0
    DEDENT
    try :
    INDENT
        depths_in = map(lambda x : depth(x, exclude), arg.values())
    DEDENT
    except AttributeError :
    INDENT
        try :
        INDENT
            depths_in = map(lambda x : depth(x, exclude), arg)
        DEDENT
        except TypeError :
        INDENT
            return 0
        DEDENT
    DEDENT
    try :
    INDENT
        depth_in = max(depths_in)
    DEDENT
    except ValueError :
    INDENT
        depth_in = 0
    DEDENT
    return 1 + depth_in
DEDENT
----------------------------------------

def depth(seq) :
INDENT
    seq = iter(seq)
    try :
    INDENT
        for level in count() :
        INDENT
            seq = chain([next(seq)], seq)
            seq = chain.from_iterable(s for s in seq if isinstance(s, Sequence))
        DEDENT
    DEDENT
    except StopIteration :
    INDENT
        return level
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
605013_605248_12_22
605013_605248_24_32
Title: python: how to send packets in multi thread and then the thread kill itself 
----------------------------------------

def run(self) :
INDENT
    global killed
    starttime = time.time()
    counter = 0
    while (time.time() - starttime) < test_time :
    INDENT
        if killed :
        INDENT
            break
        DEDENT
        counter = counter + 1
        time.sleep(0.1)
    DEDENT
    print "I did %d loops" % counter
DEDENT
----------------------------------------

def run(self) :
INDENT
    global killed
    while True :
    INDENT
        var = raw_input("Enter something: ")
        if var == "quit" :
        INDENT
            killed = True
            break
        DEDENT
    DEDENT
    print "Got var [%s]" % var
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6059217_14252471_6_28
6059217_22964916_7_33
Title: Cutting one image into multiple images using the Python Image Library 
----------------------------------------

def long_slice(image_path, out_name, outdir, slice_size) :
INDENT
    img = Image.open(image_path)
    width, height = img.size
    upper = 0
    left = 0
    slices = int(math.ceil(height / slice_size))
    count = 1
    for slice in range(slices) :
    INDENT
        if count == slices :
        INDENT
            lower = height
        DEDENT
        else :
        INDENT
            lower = int(count * slice_size)
        DEDENT
        bbox = (left, upper, width, lower)
        working_slice = img.crop(bbox)
        upper += slice_size
        working_slice.save(os.path.join(outdir, "slice_" + out_name + "_" + str(count) + ".png"))
        count += 1
    DEDENT
DEDENT
----------------------------------------

def long_slice(image_path, out_name, outdir, sliceHeight, sliceWidth) :
INDENT
    img = Image.open(image_path)
    imageWidth, imageHeight = img.size
    left = 0
    upper = 0
    while (left < imageWidth) :
    INDENT
        while (upper < imageHeight) :
        INDENT
            if (upper + sliceHeight > imageHeight and left + sliceWidth > imageWidth) :
            INDENT
                bbox = (left, upper, imageWidth, imageHeight)
            DEDENT
            elif (left + sliceWidth > imageWidth) :
            INDENT
                bbox = (left, upper, imageWidth, upper + sliceHeight)
            DEDENT
            elif (upper + sliceHeight > imageHeight) :
            INDENT
                bbox = (left, upper, left + sliceWidth, imageHeight)

            DEDENT
            else :
            INDENT
                bbox = (left, upper, left + sliceWidth, upper + sliceHeight)
            DEDENT
            working_slice = img.crop(bbox)
            working_slice.save(os.path.join(outdir, 'slice_' + out_name + '_' + str(upper) + '_' + str(left) + '.jpg'))
            upper += sliceHeight
        DEDENT
        left += sliceWidth
        upper = 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6068739_6070016_29_62
6068739_6070016_9_18
Title: wxpython - Creating Unique GUI Elements With a Loop 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (700, 400))
    panelControl = wx.Panel(self, 1, style = wx.MAXIMIZE)
    sizerControl = wx.GridBagSizer(hgap = 4, vgap = 4)
    lblTitle = wx.StaticText(panelControl, label = "Pick Scores")
    self.btnRoll = wx.Button(panelControl, label = "Roll!")
    sizerControl.Add(lblTitle, pos = (0, 0),
        flag = wx.ALIGN_CENTER | wx.TOP | wx.LEFT | wx.BOTTOM, border = 5)
    sizerControl.Add(self.btnRoll, pos = (0, 1),
        span = (1, 5), flag = wx.EXPAND | wx.LEFT | wx.RIGHT, border = 5)
    rboxPick = ["Default", "Strength", "Dexterity", "Constitution",
        "Intelligence", "Wisdom", "Charisma"]
    labels = ["One", "Two", "Three", "Four"]

    for row, label in enumerate(labels) :
    INDENT
        rbox = LblRadBox(panelControl, rbLbl = "Roll %s" % (label), choices = rboxPick)

        sizerControl.Add(rbox, pos = (row + 1, 1), span = (1, 5),
            flag = wx.EXPAND | wx.LEFT | wx.RIGHT, border = 2)
    DEDENT
    panelControl.Bind(wx.EVT_RADIOBOX, self.onRadioBox)
    sizerMain = wx.BoxSizer()
    sizerMain.Add(sizerControl)
    panelControl.SetSizerAndFit(sizerMain)
DEDENT
----------------------------------------

def __init__(self, parent, stLbl = "", rbLbl = "", choices = []) :
INDENT
    wx.Panel.__init__(self, parent)
    self.stLbl = wx.StaticText(self, label = stLbl)
    self.rbox = wx.RadioBox(self, label = rbLbl, choices = choices)
    sizer = wx.BoxSizer()
    sizer.Add(self.stLbl)
    sizer.Add(self.rbox)
    self.SetSizerAndFit(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6076690_12155971_2_31
6076690_6076779_12_23
Title: Verbose level with argparse and multiple -v options 
----------------------------------------

def __call__(self, parser, args, values, option_string = None) :
INDENT
    if args.verbose == None :
    INDENT
        base = 0
    DEDENT
    else :
    INDENT
        base = args.verbose
    DEDENT
    option_string = option_string.lstrip('-')
    if option_string [0] == 'q' :
    INDENT
        incr = - 1
    DEDENT
    elif option_string [0] == 'v' :
    INDENT
        incr = 1
    DEDENT
    else :
    INDENT
        raise argparse.ArgumentError(self,
            'Option string for verbosity must start with v(erbose) or q(uiet)')
    DEDENT
    if values == None :
    INDENT
        values = base + incr
    DEDENT
    else :
    INDENT
        try :
        INDENT
            values = int(values)
        DEDENT
        except ValueError :
        INDENT
            values = values.lower()
            if not re.match('^[vq]+$', values) :
            INDENT
                raise argparse.ArgumentError(self,
                    "Option string for -v/-q must contain only further 'v'/'q' letters")
            DEDENT
            values = base + incr + values.count('v') - values.count('q')
        DEDENT
    DEDENT
    setattr(args, self.dest, values)
DEDENT
----------------------------------------

def __call__(self, parser, args, values, option_string = None) :
INDENT
    if values is None :
    INDENT
        self.values += 1
    DEDENT
    else :
    INDENT
        try :
        INDENT
            self.values = int(values)
        DEDENT
        except ValueError :
        INDENT
            self.values = values.count('v') + 1
        DEDENT
    DEDENT
    setattr(args, self.dest, self.values)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6077017_6077220_35_42
6077017_6079039_34_43
Title: Python/Matplotlib - Quickly Updating Text on Axes 
----------------------------------------

def cbUpdateCursor(self, event) :
INDENT
    if event.inaxes :
    INDENT
        text = 'x = %5.4f, y = %5.4f' % (event.xdata, event.ydata)
        self.sb.SetStatusText(text)
        self.cursor_pos.SetLabel(text)

    DEDENT
DEDENT
----------------------------------------

def cbUpdateCursor(self, event) :
INDENT
    if event.inaxes :
    INDENT
        text = 'x = %5.4f, y = %5.4f' % (event.xdata, event.ydata)
        self.sb.SetStatusText(text)
        self.canvas.restore_region(self.background)
        self.text.set_text(text)
        self.axes.draw_artist(self.text)
        self.canvas.blit(self.text.get_window_extent())
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6136588_6140013_8_22
6136588_8696558_62_103
Title: Image Cropping using Python 
----------------------------------------

def mainLoop(screen, px) :
INDENT
    topleft = bottomright = prior = None
    n = 0
    while n ! = 1 :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == pygame.MOUSEBUTTONUP :
            INDENT
                if not topleft :
                INDENT
                    topleft = event.pos
                DEDENT
                else :
                INDENT
                    bottomright = event.pos
                    n = 1
                DEDENT
            DEDENT
        DEDENT
        if topleft :
        INDENT
            prior = displayImage(screen, px, topleft, prior)
        DEDENT
    DEDENT
    return (topleft + bottomright)
DEDENT
----------------------------------------

def mainLoop(screen, px, filelist) :
INDENT
    topleft = bottomright = prior = None
    n = 0
    scale = 1
    pos = [0, 0]
    while n ! = 1 :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == pygame.MOUSEBUTTONUP :
            INDENT
                if not topleft :
                INDENT
                    topleft = [(val + pos [i]) * scale for i, val in enumerate(event.pos)]
                    print "tr: ", topleft
                DEDENT
                else :
                INDENT
                    bottomright = [(val + pos [i]) * scale for i, val in enumerate(event.pos)]
                    print "br: ", bottomright
                    n = 1
                DEDENT
            DEDENT
            if event.type == pygame.KEYDOWN and event.key == K_a :
            INDENT
                pos = [pos [0] - 200, pos [1]]
                move(pos, scale, px, screen)
            DEDENT
            if event.type == pygame.KEYDOWN and event.key == K_d :
            INDENT
                pos = [pos [0] + 200, pos [1]]
                move(pos, scale, px, screen)
            DEDENT
            if event.type == pygame.KEYDOWN and event.key == K_w :
            INDENT
                pos = [pos [0], pos [1] - 200]
                move(pos, scale, px, screen)
            DEDENT
            if event.type == pygame.KEYDOWN and event.key == K_s :
            INDENT
                pos = [pos [0], pos [1] + 200]
                move(pos, scale, px, screen)

            DEDENT
            if event.type == pygame.KEYDOWN and event.key == K_RIGHTBRACKET :
            INDENT
                scale = scale / 1.25
                move(pos, scale, px, screen)
            DEDENT
            if event.type == pygame.KEYDOWN and event.key == K_LEFTBRACKET :
            INDENT
                scale = scale * 1.25
                move(pos, scale, px, screen)

            DEDENT
        DEDENT
        if topleft :
        INDENT
            prior = displayRect(screen, px, topleft, prior, pos, scale)
        DEDENT
    DEDENT
    return (topleft + bottomright)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6200270_25206079_3_13
6200270_51720081_5_18
Title: Decorator to print function call details - parameters names and effective values 
----------------------------------------

def wrapper(* func_args, ** func_kwargs) :
INDENT
    arg_names = func.__code__.co_varnames [: func.__code__.co_argcount]
    args = func_args [: len(arg_names)]
    defaults = func.__defaults__ or ()
    args = args + defaults [len(defaults) - (func.__code__.co_argcount - len(args)) :]
    params = list(zip(arg_names, args))
    args = func_args [len(arg_names) :]
    if args : params.append(('args', args))
    if func_kwargs : params.append(('kwargs', func_kwargs))
    print (func.__name__ + ' (' + ', '.join('%s = %r' % p for p in params) + ' )')
    return func(* func_args, ** func_kwargs)
DEDENT
----------------------------------------

def wrapper(* func_args, ** func_kwargs) :
INDENT
    arg_names = func.func_code.co_varnames [: func.func_code.co_argcount]
    args = func_args [: len(arg_names)]
    defaults = func.func_defaults or ()
    args = args + defaults [len(defaults) - (func.func_code.co_argcount - len(args)) :]
    params = zip(arg_names, args)
    new_arg_list = [list(i) for i in params]
    for key in func_kwargs :
    INDENT
        for param in new_arg_list :
        INDENT
            if key == param [0] :
            INDENT
                param [1] = func_kwargs [key]
            DEDENT
        DEDENT
    DEDENT
    new_arg_list = [tuple(i) for i in new_arg_list]
    print func.func_name + ' (' + ', '.join('%s = %r' % p for p in new_arg_list) + ' )'
    return func(* func_args, ** func_kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6200270_25206079_3_13
6200270_6278457_3_13
Title: Decorator to print function call details - parameters names and effective values 
----------------------------------------

def wrapper(* func_args, ** func_kwargs) :
INDENT
    arg_names = func.__code__.co_varnames [: func.__code__.co_argcount]
    args = func_args [: len(arg_names)]
    defaults = func.__defaults__ or ()
    args = args + defaults [len(defaults) - (func.__code__.co_argcount - len(args)) :]
    params = list(zip(arg_names, args))
    args = func_args [len(arg_names) :]
    if args : params.append(('args', args))
    if func_kwargs : params.append(('kwargs', func_kwargs))
    print (func.__name__ + ' (' + ', '.join('%s = %r' % p for p in params) + ' )')
    return func(* func_args, ** func_kwargs)
DEDENT
----------------------------------------

def wrapper(* func_args, ** func_kwargs) :
INDENT
    arg_names = func.func_code.co_varnames [: func.func_code.co_argcount]
    args = func_args [: len(arg_names)]
    defaults = func.func_defaults or ()
    args = args + defaults [len(defaults) - (func.func_code.co_argcount - len(args)) :]
    params = zip(arg_names, args)
    args = func_args [len(arg_names) :]
    if args : params.append(('args', args))
    if func_kwargs : params.append(('kwargs', func_kwargs))
    print func.func_name + ' (' + ', '.join('%s = %r' % p for p in params) + ' )'
    return func(* func_args, ** func_kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6200270_51720081_5_18
6200270_6278457_3_13
Title: Decorator to print function call details - parameters names and effective values 
----------------------------------------

def wrapper(* func_args, ** func_kwargs) :
INDENT
    arg_names = func.func_code.co_varnames [: func.func_code.co_argcount]
    args = func_args [: len(arg_names)]
    defaults = func.func_defaults or ()
    args = args + defaults [len(defaults) - (func.func_code.co_argcount - len(args)) :]
    params = zip(arg_names, args)
    new_arg_list = [list(i) for i in params]
    for key in func_kwargs :
    INDENT
        for param in new_arg_list :
        INDENT
            if key == param [0] :
            INDENT
                param [1] = func_kwargs [key]
            DEDENT
        DEDENT
    DEDENT
    new_arg_list = [tuple(i) for i in new_arg_list]
    print func.func_name + ' (' + ', '.join('%s = %r' % p for p in new_arg_list) + ' )'
    return func(* func_args, ** func_kwargs)
DEDENT
----------------------------------------

def wrapper(* func_args, ** func_kwargs) :
INDENT
    arg_names = func.func_code.co_varnames [: func.func_code.co_argcount]
    args = func_args [: len(arg_names)]
    defaults = func.func_defaults or ()
    args = args + defaults [len(defaults) - (func.func_code.co_argcount - len(args)) :]
    params = zip(arg_names, args)
    args = func_args [len(arg_names) :]
    if args : params.append(('args', args))
    if func_kwargs : params.append(('kwargs', func_kwargs))
    print func.func_name + ' (' + ', '.join('%s = %r' % p for p in params) + ' )'
    return func(* func_args, ** func_kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6290791_6291157_108_125
6290791_6291157_11_54
Title: wxPython: Problems with thread 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "IndexGenerator", size = (430, 330),
        style = ((wx.DEFAULT_FRAME_STYLE | wx.NO_FULL_REPAINT_ON_RESIZE |
                wx.STAY_ON_TOP) ^ wx.RESIZE_BORDER))
    self.CreateStatusBar()
    self.fileMenu = wx.Menu()
    self.fileMenu.Append(ID_EXIT, "E&xit", "Exit the program")
    self.menuBar = wx.MenuBar()
    self.menuBar.Append(self.fileMenu, "&File")
    self.SetMenuBar(self.menuBar)
    wx.EVT_MENU(self, ID_EXIT, self.OnExit)
    self.Panel = MainPanel(self)
    self.CentreOnScreen()
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.buttonRun = wx.Button(self, label = "Run")
    self.buttonRun.Bind(wx.EVT_BUTTON, self.OnRun)
    self.buttonExit = wx.Button(self, label = "Exit")
    self.buttonExit.Bind(wx.EVT_BUTTON, self.OnExit)
    self.labelChooseRoot = wx.StaticText(self, label = "Root catalog: ")
    self.labelScratchWrk = wx.StaticText(self, label = "Scratch workspace: ")
    self.labelMergeFile = wx.StaticText(self, label = "Merge file: ")
    self.textChooseRoot = wx.TextCtrl(self, size = (210, - 1))
    self.textChooseRoot.Bind(wx.EVT_LEFT_UP, self.OnChooseRoot)
    self.textScratchWrk = wx.TextCtrl(self, size = (210, - 1))
    self.textMergeFile = wx.TextCtrl(self, size = (210, - 1))
    self.textOutput = wx.TextCtrl(self, style = wx.TE_MULTILINE | wx.TE_READONLY)
    self.sizerF = wx.FlexGridSizer(3, 2, 5, 5)
    self.sizerF.Add(self.labelChooseRoot)
    self.sizerF.Add(self.textChooseRoot)
    self.sizerF.Add(self.labelScratchWrk)
    self.sizerF.Add(self.textScratchWrk)
    self.sizerF.Add(self.labelMergeFile)
    self.sizerF.Add(self.textMergeFile)
    self.sizerB = wx.BoxSizer(wx.VERTICAL)
    self.sizerB.Add(self.buttonRun, 1, wx.ALIGN_RIGHT | wx.ALL, 5)
    self.sizerB.Add(self.buttonExit, 0, wx.ALIGN_RIGHT | wx.ALL, 5)
    self.sizer1 = wx.BoxSizer()
    self.sizer1.Add(self.sizerF, 0, wx.ALIGN_RIGHT | wx.EXPAND | wx.ALL, 10)
    self.sizer1.Add(self.sizerB, 0, wx.ALIGN_RIGHT | wx.EXPAND | wx.ALL)
    self.sizer2 = wx.BoxSizer()
    self.sizer2.Add(self.textOutput, 1, wx.EXPAND | wx.ALL, 5)
    self.sizerFinal = wx.BoxSizer(wx.VERTICAL)
    self.sizerFinal.Add(self.sizer1, 0, wx.ALIGN_RIGHT | wx.EXPAND | wx.ALL)
    self.sizerFinal.Add(self.sizer2, 1, wx.ALIGN_RIGHT | wx.EXPAND | wx.ALL)
    self.SetSizerAndFit(self.sizerFinal)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6370705_6389846_46_54
6370705_6389846_5_17
Title: double valued gauge in wxpython 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title)
    self.minmax = MinMax(self, 0, 100)
    self.minmax.SetSpacing(20)
    self.minmax.SetMinIndicatorValue(30)
    self.minmax.SetMaxIndicatorValue(84)
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent, range_min, range_max, orient = wx.HORIZONTAL) :
INDENT
    rc.RulerCtrl.__init__(self, parent, orient)
    self.SetRange(range_min, range_max)
    self.LabelMinor(False)
    self.range_min = range_min
    self.range_max = range_max
    self.AddIndicator(wx.NewId(), range_min)
    self.AddIndicator(wx.NewId(), range_max)
    self.Bind(rc.EVT_INDICATOR_CHANGING, self.OnIndicatorChanging)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6396541_18776152_372_390
6396541_18776152_52_88
Title: Web Scraping Multiple Links with PyQt / QtWebkit 
----------------------------------------

def __init__(self, host, port) :
INDENT
    import socket
    global args
    self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    self.socket.connect((host, port))
    o = self.read()
    if args.verbosity > 2 :
    INDENT
        print "\n------------------------------\n" + o + "\n------------------------------\n"
    DEDENT
    return
DEDENT
----------------------------------------

def __init__(self, host = "0.0.0.0", port = 50007, parent = None, enableImages = True, enablePlugins = True) :
INDENT
    super(CrawlerWebServer, self).__init__(parent)
    self.command = None
    self.isLoading = True
    self.isConnected = False
    self.url = QUrl("http://mast3rpee.tk/")
    self.timeout = QTimerWithPause(self)
    self.socket = QTcpServer(self)

    self.settings().enablePersistentStorage()
    self.settings().setAttribute(QWebSettings.AutoLoadImages, enableImages)
    self.settings().setAttribute(QWebSettings.PluginsEnabled, enablePlugins)
    self.settings().setAttribute(QWebSettings.DeveloperExtrasEnabled, True)

    if args.verbosity > 0 : print "Starting server..."
    self.socket.setProxy(QNetworkProxy(QNetworkProxy.NoProxy))
    self.socket.listen(QHostAddress(host), int(port))
    self.connect(self.socket, SIGNAL("newConnection()"), self._connect)
    if args.verbosity > 1 :
    INDENT
        print "    Waiting for connection(" + host + ":" + str(port) + ")..."
    DEDENT
    self._load(10 * 1000, self._loadFinished)
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6414417_6414533_1_13
6414417_6414673_4_30
Title: Invalid url's throw an exception - python 
----------------------------------------

def getUrl(url) :
INDENT
    status = None
    try :
    INDENT

        status = response.status
    DEDENT
    except Exception, e :
    INDENT
        pass
    DEDENT
    finally :
    INDENT
        if status ! = 200 :
        INDENT
            print "Error"
        DEDENT
        else :
        INDENT
            print "Awesome"
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def getUrl(url) :
INDENT
    parts = urlparse.urlsplit(url)
    server = parts [1]
    path = parts [2]
    obj = httplib.HTTPConnection(server, 80)
    try :
    INDENT
        obj.connect()
    DEDENT
    except socket.gaierror :
    INDENT
        print "Host %s does not exist" % server
        return
    DEDENT
    except socket.error :
    INDENT
        print "Cannot connect to %s:%s." % (server, 80)
        return
    DEDENT
    obj.putrequest('HEAD', path)
    obj.putheader('Accept', '*/*')
    obj.endheaders()
    response = obj.getresponse()
    contentType = response.getheader("content-type", "unknown")
    obj.close()
    if response.status ! = 200 :
    INDENT
        print 'Error'
    DEDENT
    else :
    INDENT
        print 'Awesome'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6434482_6442017_22_38
6434482_7308379_7_12
Title: Python function overloading 
----------------------------------------

def __call__(cls, alias, * args, ** kwargs) :
INDENT
    if cls ! = Bullet :
    INDENT
        raise TypeError("Bullet subclass %r objects should not to "
            "be explicitly constructed." % cls.__name__)
    DEDENT
    elif alias not in cls.registry :
    INDENT
        raise NotImplementedError("Unknown Bullet subclass %r" %
            str(alias))
    DEDENT
    subclass = cls.registry [alias]
    return type.__call__(subclass, * args, ** kwargs)

DEDENT
----------------------------------------

def __call__(self, * args) :
INDENT
    types = tuple(arg.__class__ for arg in args)
    function = self.typemap.get(types)
    if function is None :
    INDENT
        raise TypeError("no match")
    DEDENT
    return function(* args)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6434482_7308379_13_18
6434482_7308379_20_26
Title: Python function overloading 
----------------------------------------

def register(self, types, function) :
INDENT
    if types in self.typemap :
    INDENT
        raise TypeError("duplicate registration")
    DEDENT
    self.typemap [types] = function

DEDENT
----------------------------------------

def register(function) :
INDENT
    name = function.__name__
    mm = registry.get(name)
    if mm is None :
    INDENT
        mm = registry [name] = MultiMethod(name)
    DEDENT
    mm.register(types, function)
    return mm
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6450170_6783255_176_194
6450170_6783255_80_102
Title: Using pygtk how can I make a simple fullscreen slide show 
----------------------------------------

def __init__(self) :
INDENT
    self.window = gtk.Window()
    self.window.connect('destroy', gtk.main_quit)
    self.window.set_title('Slideshow')
    self.image = ResizableImage(True, True, gtk.gdk.INTERP_BILINEAR)
    self.image.show()
    self.window.add(self.image)
    self.load_file_list()
    self.window.show_all()
    if self.FULLSCREEN :
    INDENT
        self.window.fullscreen()
    DEDENT
    glib.timeout_add_seconds(self.SECONDS_BETWEEN_PICTURES, self.on_tick)
    self.display()
DEDENT
----------------------------------------

def __init__(self, aspect = True, enlarge = False,
interp = gtk.gdk.INTERP_NEAREST, backcolor = None, max = (1600, 1200)) :
INDENT
    super(ResizableImage, self).__init__()
    self.pixbuf = None
    self.aspect = aspect
    self.enlarge = enlarge
    self.interp = interp
    self.backcolor = backcolor
    self.max = max
    self.connect('expose_event', self.expose)
    self.connect('realize', self.on_realize)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6462272_6462632_17_25
6462272_6462633_19_64
Title: Subtract Overlaps Between Two Ranges Without Sets 
----------------------------------------

def minus(self, tup) :
INDENT
    pos, (x, y) = self.has(tup)
    out = []
    if x < tup [0] :
    INDENT
        out.append((x, tup [0] - 1))
    DEDENT
    if y > tup [1] :
    INDENT
        out.append((tup [1] + 1, y))
    DEDENT
    self.ranges [pos : pos + 1] = out
DEDENT
----------------------------------------

def minus(r1, r2) :
INDENT
    r1 = r1 [:]
    r2 = r2 [:]
    l = []
    v = r1.pop(0)
    b = r2.pop(0)
    while True :
    INDENT
        r = minus1(v, b)
        if r :
        INDENT
            if len(r) == 1 :
            INDENT
                if r [0] == v :
                INDENT
                    if v [1] < b [0] and v [1] < b [1] :
                    INDENT
                        l.append(r [0])
                        if r1 :
                        INDENT
                            v = r1.pop(0)
                        DEDENT
                        else :
                        INDENT
                            break
                        DEDENT
                    DEDENT
                    else :
                    INDENT
                        if r2 :
                        INDENT
                            b = r2.pop(0)
                        DEDENT
                        else :
                        INDENT
                            break
                        DEDENT
                    DEDENT
                DEDENT
                else :
                INDENT
                    v = r [0]
                DEDENT
            DEDENT
            else :
            INDENT
                l.append(r [0])
                v = r [1]
                if r2 :
                INDENT
                    b = r2.pop(0)
                DEDENT
                else :
                INDENT
                    l.append(v)
                    break
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT
            if r1 :
            INDENT
                v = r1.pop(0)
            DEDENT
            else :
            INDENT
                break
            DEDENT
            if r2 :
            INDENT
                b = r2.pop(0)
            DEDENT
            else :
            INDENT
                l.append(v)
                l.extend(r1)
                break
            DEDENT
        DEDENT
    DEDENT
    return l
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6485264_33467310_13_29
6485264_6498063_13_33
Title: Gtk.StatusIcon PopupMenu in python 
----------------------------------------

def right_click_event(self, icon, button, time) :
INDENT
    self.menu = Gtk.Menu()
    about = Gtk.MenuItem()
    about.set_label("About")
    about.connect("activate", self.show_about_dialog)
    self.menu.append(about)
    quit = Gtk.MenuItem()
    quit.set_label("Quit")
    quit.connect("activate", Gtk.main_quit)
    self.menu.append(quit)
    self.menu.show_all()
    self.menu.popup(None, None, None, self.status_icon, button, time)
DEDENT
----------------------------------------

def right_click_event(self, icon, button, time) :
INDENT
    self.menu = Gtk.Menu()
    about = Gtk.MenuItem()
    about.set_label("About")
    quit = Gtk.MenuItem()
    quit.set_label("Quit")
    about.connect("activate", self.show_about_dialog)
    quit.connect("activate", Gtk.main_quit)
    self.menu.append(about)
    self.menu.append(quit)
    self.menu.show_all()
    def pos(menu, icon) :
    INDENT
        return (Gtk.StatusIcon.position_menu(menu, icon))
    DEDENT
    self.menu.popup(None, None, pos, self.statusicon, button, time)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6502013_6502923_7_41
6502013_6505761_26_41
Title: Get rid of a label inside a thread? 
----------------------------------------

def moveit(number) :
INDENT
    global lock
    songas = Label(Admin, text = number, bg = 'red')
    def ji(lock) :
    INDENT
        plad = 0.0
        recount = 0
        times = 0
        while 1 :
        INDENT
            plad -= 0.1
            recount += 1
            times += 1
            time.sleep(0.5)
            pls = 0.0
            pls += plad

            if recount == 4 :
            INDENT

                pls = 0
                plad = 0.0
                recount = 0
            DEDENT
            songas.place(relx = pls, rely = 0.7)
            if not lock.locked() :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    if lock :
    INDENT

        lock.release()
    DEDENT
    lock = thread.allocate_lock()
    lock.acquire()
    thread.start_new_thread(ji, (lock,))
DEDENT
----------------------------------------

def moveit(self) :
INDENT
    if not self._running :
    INDENT

        self.label.place_forget()
    DEDENT
    if self._running :
    INDENT
        if not self.label.winfo_viewable() :
        INDENT

            self._relx = [.5,.4,.3,.2,.1, 0]
        DEDENT
        relx = self._relx.pop(0)
        self._relx.append(relx)
        self.label.place(relx = relx, rely = 0.7)
        self.after(1000, self.moveit)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6509261_44719580_1_9
6509261_6514268_26_36
Title: How to use concurrent.futures with timeouts? 
----------------------------------------

def main() :
INDENT
    with concurrent.futures.ProcessPoolExecutor(max_workers = len(max_numbers)) as executor :
    INDENT
        try :
        INDENT
            for future in concurrent.futures.as_completed(executor.map(run_loop, max_numbers, timeout = 1), timeout = 1) :
            INDENT
                print (future.result(timeout = 1))
            DEDENT
        DEDENT
        except concurrent.futures._base.TimeoutError :
        INDENT
            print ("This took to long...")
            stop_process_pool(executor)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    with concurrent.futures.ThreadPoolExecutor(max_workers = len(max_numbers)) as executor :
    INDENT
        tasks = [Task(num) for num in max_numbers]
        for task, future in [(i, executor.submit(i)) for i in tasks] :
        INDENT
            try :
            INDENT
                print (future.result(timeout = 1))
            DEDENT
            except concurrent.futures.TimeoutError :
            INDENT
                print ("this took too long...")
                task.interrupt()

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6514783_10214574_19_31
6514783_10214574_45_64
Title: Tornado login Examples/Tutorials 
----------------------------------------

def post(self) :
INDENT
    email = self.get_argument("email", "")
    password = self.get_argument("password", "")
    user = self.application.syncdb ['users'].find_one({'user' : email})
    if user and user ['password'] and bcrypt.hashpw(password, user ['password']) == user ['password'] :
    INDENT
        self.set_current_user(email)
        self.redirect("hello")
    DEDENT
    else :
    INDENT
        error_msg = u"?error=" + tornado.escape.url_escape("Login incorrect.")
        self.redirect(u"/login" + error_msg)
    DEDENT
DEDENT
----------------------------------------

def post(self) :
INDENT
    email = self.get_argument("email", "")
    already_taken = self.application.syncdb ['users'].find_one({'user' : email})
    if already_taken :
    INDENT
        error_msg = u"?error=" + tornado.escape.url_escape("Login name already taken")
        self.redirect(u"/login" + error_msg)

    DEDENT
    password = self.get_argument("password", "")
    hashed_pass = bcrypt.hashpw(password, bcrypt.gensalt(8))
    user = {}
    user ['user'] = email
    user ['password'] = hashed_pass
    auth = self.application.syncdb ['users'].save(user)
    self.set_current_user(email)
    self.redirect("hello")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6546092_6556312_23_42
6546092_6556312_5_12
Title: how to make multiline wx.ListBox 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, size = (200, 400))
    self.numbers = PhoneNumbers(self)
    self.contact_name = wx.TextCtrl(self)
    self.contact_number = wx.TextCtrl(self)
    self.add_btn = wx.Button(self, label = "Add contact")
    self.Sizer = wx.BoxSizer(wx.VERTICAL)
    self.Sizer.Add(self.numbers, 1, wx.EXPAND)
    self.Sizer.Add(wx.SearchCtrl(self), 0, wx.EXPAND)
    self.Sizer.Add(wx.StaticText(self, label = "Name"), 0, wx.TOP, 10)
    self.Sizer.Add(self.contact_name)
    self.Sizer.Add(wx.StaticText(self, label = "Number"), 0, wx.TOP, 5)
    self.Sizer.Add(self.contact_number)
    self.Sizer.Add(self.add_btn, 0, wx.ALL, 10)
    self.numbers.Bind(wx.EVT_LISTBOX, self.OnSelectNumber)
    self.add_btn.Bind(wx.EVT_BUTTON, self.OnAddNumber)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.HtmlListBox.__init__(self, parent)
    self.data = [
        ("Foo", "3452-453"),
        ("Bar", "5672-346"),
        ]
    self.SetItemCount(len(self.data))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6548837_48684170_4_20
6548837_51406895_5_14
Title: How do I get an event callback when a Tkinter Entry widget is modified? 
----------------------------------------

def __init__(self) :
INDENT
    self.str1 = StringVar()
    self.e1 = Entry(root, textvariable = self.str1)
    self.str1.trace('w', self.callback_1)
    self.e1.pack()
    self.str2 = StringVar()
    self.e2 = Entry(root, textvariable = self.str2, state = 'readonly')
    self.e2.pack()
    self.str3 = StringVar()
    self.e3 = Entry(root, textvariable = self.str3, state = 'readonly')
    self.e3.pack()
    bt = Button(root, text = 'ещё', command = self.callback_2)
    bt.pack()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tk()
    self.sv = StringVar()
    self.prevlaue = ''
    self.entry = ttk.Entry(self.root, width = 30, textvariable = self.sv)
    self.entry.grid(pady = 20, padx = 20)
    self.entry.bind("<KeyRelease>", self.OnEntryClick)
    self.root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6548837_48684170_4_20
6548837_7714228_7_19
Title: How do I get an event callback when a Tkinter Entry widget is modified? 
----------------------------------------

def __init__(self) :
INDENT
    self.str1 = StringVar()
    self.e1 = Entry(root, textvariable = self.str1)
    self.str1.trace('w', self.callback_1)
    self.e1.pack()
    self.str2 = StringVar()
    self.e2 = Entry(root, textvariable = self.str2, state = 'readonly')
    self.e2.pack()
    self.str3 = StringVar()
    self.e3 = Entry(root, textvariable = self.str3, state = 'readonly')
    self.e3.pack()
    bt = Button(root, text = 'ещё', command = self.callback_2)
    bt.pack()
DEDENT
----------------------------------------

def __init__(self, root) :
INDENT
    cf = Frame(root)
    cf.pack()
    self.string_vars = []
    self.fruit = ("Apple", "Banana", "Cherry", "Date")
    for f in self.fruit :
    INDENT
        i = len(self.string_vars)
        self.string_vars.append(StringVar())
        self.string_vars [i].trace("w", lambda name, index, mode, var = self.string_vars [i], i = i :
            self.entryupdate(var, i))
        Label(cf, text = f).grid(column = 2, row = i)
        Entry(cf, width = 6, textvariable = self.string_vars [i]).grid(column = 4, row = i)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6548837_51406895_5_14
6548837_7714228_7_19
Title: How do I get an event callback when a Tkinter Entry widget is modified? 
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tk()
    self.sv = StringVar()
    self.prevlaue = ''
    self.entry = ttk.Entry(self.root, width = 30, textvariable = self.sv)
    self.entry.grid(pady = 20, padx = 20)
    self.entry.bind("<KeyRelease>", self.OnEntryClick)
    self.root.mainloop()
DEDENT
----------------------------------------

def __init__(self, root) :
INDENT
    cf = Frame(root)
    cf.pack()
    self.string_vars = []
    self.fruit = ("Apple", "Banana", "Cherry", "Date")
    for f in self.fruit :
    INDENT
        i = len(self.string_vars)
        self.string_vars.append(StringVar())
        self.string_vars [i].trace("w", lambda name, index, mode, var = self.string_vars [i], i = i :
            self.entryupdate(var, i))
        Label(cf, text = f).grid(column = 2, row = i)
        Entry(cf, width = 6, textvariable = self.string_vars [i]).grid(column = 4, row = i)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6566322_11235898_24_40
6566322_9176662_19_28
Title: Scrapy Crawl URLs in Order 
----------------------------------------

def parse(self, response) :
INDENT
    log.msg("Begin Parsing", level = log.INFO)
    log.msg("Response from: %s" % response.url, level = log.INFO)
    hxs = HtmlXPathSelector(response)
    sites = hxs.select("//*[@id='moduleData8460']")
    items = response.meta ['items']
    for site in sites :
    INDENT
        item = MlboddsItem()
        item ['header'] = site.select('//div[@class="scoreboard-bar"]//h2//span[position()>1]//text()').extract()
        item ['game1'] = site.select('/*//table[position()=1]//tr//td[@class="tbl-odds-c2"]//text()').extract()
        items.append(item)

    DEDENT
    if self.other_urls :
    INDENT
        return Request(self.other_urls.pop(0), meta = {'items' : items})
    DEDENT
    return items
DEDENT
----------------------------------------

def parse(self, response) :
INDENT
    hxs = HtmlXPathSelector(response)
    sites = hxs.select('//div[@id="col_3"]//div[@id="module3_1"]//div[@id="moduleData4952"]')
    items = []
    for site in sites :
    INDENT
        item = MlboddsItem()
        item ['header'] = site.select('//div[@class="scoreboard-bar"]//h2//span[position()>1]//text()').extract()
        item ['game1'] = site.select('/*//table[position()=1]//tr//td[@class="tbl-odds-c2"]//text() | /*//table[position()=1]//tr//td[@class="tbl-odds-c4"]//text() | /*//table[position()=1]//tr//td[@class="tbl-odds-c6"]//text()').extract()
        items.append(item)
    DEDENT
    return items
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
658763_45604186_1_13
658763_46298331_1_21
Title: How do I suppress scientific notation in Python? 
----------------------------------------

def getExpandedScientificNotation(flt) :
INDENT
    str_vals = str(flt).split('e')
    coef = float(str_vals [0])
    exp = int(str_vals [1])
    return_val = ''
    if int(exp) > 0 :
    INDENT
        return_val += str(coef).replace('.', '')
        return_val += ''.join(['0' for _ in range(0, abs(exp - len(str(coef).split('.') [1])))])
    DEDENT
    elif int(exp) < 0 :
    INDENT
        return_val += '0.'
        return_val += ''.join(['0' for _ in range(0, abs(exp) - 1)])
        return_val += str(coef).replace('.', '')
    DEDENT
    return return_val
DEDENT
----------------------------------------

def getExpandedScientificNotation(flt) :
INDENT
    was_neg = False
    if not ("e" in flt) :
    INDENT
        return flt
    DEDENT
    if flt.startswith('-') :
    INDENT
        flt = flt [1 :]
        was_neg = True
    DEDENT
    str_vals = str(flt).split('e')
    coef = float(str_vals [0])
    exp = int(str_vals [1])
    return_val = ''
    if int(exp) > 0 :
    INDENT
        return_val += str(coef).replace('.', '')
        return_val += ''.join(['0' for _ in range(0, abs(exp - len(str(coef).split('.') [1])))])
    DEDENT
    elif int(exp) < 0 :
    INDENT
        return_val += '0.'
        return_val += ''.join(['0' for _ in range(0, abs(exp) - 1)])
        return_val += str(coef).replace('.', '')
    DEDENT
    if was_neg :
    INDENT
        return_val = '-' + return_val
    DEDENT
    return return_val
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6602256_52370996_5_19
6602256_6602483_5_14
Title: Python: wrap all functions in a library 
----------------------------------------

def __getattribute__(self, method_name) :
INDENT
    attribute = super(Client, self).__getattribute__(method_name)
    if not inspect.ismethod(attribute) :
    INDENT
        return attribute
    DEDENT
    metric = TIMINGS.labels(method_name)
    def decorator(* args, ** kw) :
    INDENT
        start_time = get_time()
        rv = attribute(* args, ** kw)
        metric.observe(get_time() - start_time)
        return rv
    DEDENT
    return decorator
DEDENT
----------------------------------------

def __getattribute__(self, name) :
INDENT
    TO_OVERRIDE = ['append']
    if name in TO_OVERRIDE :
    INDENT
        start = time.clock()
    DEDENT
    ret = super(list, self).__getattribute__(name)
    if name in TO_OVERRIDE :
    INDENT
        stop = time.clock()
        print "It took %s seconds to perform %s" % (str(stop - start), name)
    DEDENT
    return ret
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
660836_695464_2_10
660836_8894216_2_9
Title: Django-way of specifying channel image in rss feed 
----------------------------------------

def add_root_elements(self, handler) :
INDENT
    super(RssFooFeedGenerator, self).add_root_elements(handler)
    handler.addQuickElement(u"image", '',
        {
            'url' : u"http://www.example.com/images/logo.jpg",
            'title' : u"Some title",
            'link' : u"http://www.example.com/",
            })
DEDENT
----------------------------------------

def add_root_elements(self, handler) :
INDENT
    super(ImageRssFeedGenerator, self).add_root_elements(handler)
    handler.startElement(u'image', {})
    handler.addQuickElement(u"url", self.feed ['image_url'])
    handler.addQuickElement(u"title", self.feed ['title'])
    handler.addQuickElement(u"link", self.feed ['link'])
    handler.endElement(u'image')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6657820_6658130_6_17
6657820_6658949_19_34
Title: How to convert an iterable to a stream? 
----------------------------------------

def read(self, size) :
INDENT
    result = ""
    while size > 0 :
    INDENT
        data = self.buffered or next(self.iter, None)
        self.buffered = ""
        if data is None :
        INDENT
            break
        DEDENT
        size -= len(data)
        if size < 0 :
        INDENT
            data, self.buffered = data [: size], data [size :]
        DEDENT
        result += data
    DEDENT
    return result
DEDENT
----------------------------------------

def read(self, size) :
INDENT
    data = self.leftover
    count = len(self.leftover)
    if count < size :
    INDENT
        try :
        INDENT
            while count < size :
            INDENT
                chunk = self.next()
                data += chunk
                count += len(chunk)
            DEDENT
        DEDENT
        except StopIteration :
        INDENT
            pass
        DEDENT
    DEDENT
    self.leftover = data [size :]
    return data [: size]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6665329_6665444_1_31
6665329_6665599_1_22
Title: syntax error in python due to whitespaces i think 
----------------------------------------

def SendSMS2(phone_number, sms_text) :
INDENT
    print 'made it to def'
    res = MDM.send('AT+CMGS=' + phone_number + '\r', 5)
    n = 0
    while n < 20 :
    INDENT
        res = MDM.receive(1)
        if res.find("><![CDATA[") > - 1 :
        INDENT
            print n
            break
        DEDENT
        else :
        INDENT
            n = n + 1
        DEDENT
    DEDENT
    res = MDM.send(sms_text, 10)
    if res ! = - 1 :
    INDENT
        print 'Text sent ok'
    DEDENT
    res = MDM.sendbyte(0x1a, 10)
    n = 0
    while n < 20 :
    INDENT
        res = MDM.receive(1)
        if res.find("+CMGS") > - 1 :
        INDENT
            print n
            if res.find("ERROR") > - 1 :
            INDENT
                print 'not good'
            DEDENT
            else :
            INDENT
                print 'sms ok'
            DEDENT
            break
        DEDENT
        else :
        INDENT
            n = n + 1
        DEDENT
    DEDENT
    print 'def completed *******************'
DEDENT
----------------------------------------

def SendSMS2(phone_number, sms_text) :
INDENT
    print 'made it to def'
    res = MDM.send('AT+CMGS=%s\r' % phone_number, 5)
    for n in range(20) :
    INDENT
        res = MDM.receive(1)
        if res.find("><![CDATA[") > - 1 :
        INDENT
            print n
            break
        DEDENT
    DEDENT
    res = MDM.send(sms_text, 10)
    if res ! = - 1 :
    INDENT
        print 'Text sent ok'
    DEDENT
    res = MDM.sendbyte(0x1a, 10)
    for n in range(20) :
    INDENT
        res = MDM.receive(1)
        if res.find("+CMGS") > - 1 :
        INDENT
            print n
            break
        DEDENT
        if res.find("ERROR") > - 1 :
        INDENT
            print 'sms ok'
        DEDENT
        else :
        INDENT
            print 'not good'
        DEDENT
    DEDENT
    print 'def completed *******************'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6672525_10487798_1_11
6672525_31989004_4_13
Title: Multiprocessing Queue in Python 
----------------------------------------

def worker(q, nameStr) :
INDENT
    print 'Worker %s started' % nameStr
    while True :
    INDENT
        item = q.get()
        if item is None :
        INDENT
            break
        DEDENT
        print '%s processed %s' % (nameStr, item)
        q.task_done()
    DEDENT
    print 'Worker %s Finished' % nameStr
    q.task_done()
DEDENT
----------------------------------------

def worker(q) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            work = q.get_nowait()
            q.task_done()
        DEDENT
        except Empty :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6672525_10487798_1_11
6672525_6672593_7_12
Title: Multiprocessing Queue in Python 
----------------------------------------

def worker(q, nameStr) :
INDENT
    print 'Worker %s started' % nameStr
    while True :
    INDENT
        item = q.get()
        if item is None :
        INDENT
            break
        DEDENT
        print '%s processed %s' % (nameStr, item)
        q.task_done()
    DEDENT
    print 'Worker %s Finished' % nameStr
    q.task_done()
DEDENT
----------------------------------------

def worker() :
INDENT
    for item in iter(q.get, None) :
    INDENT
        do_work(item)
        q.task_done()
    DEDENT
    q.task_done()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6672525_15101216_9_15
6672525_31989004_4_13
Title: Multiprocessing Queue in Python 
----------------------------------------

def worker(q, nameStr) :
INDENT
    while True :
    INDENT
        item = q.get()
        if item is None :
        INDENT
            break
        DEDENT
        print '%s processed %s' % (nameStr, item)
    DEDENT
DEDENT
----------------------------------------

def worker(q) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            work = q.get_nowait()
            q.task_done()
        DEDENT
        except Empty :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6672525_15101216_9_15
6672525_6672593_7_12
Title: Multiprocessing Queue in Python 
----------------------------------------

def worker(q, nameStr) :
INDENT
    while True :
    INDENT
        item = q.get()
        if item is None :
        INDENT
            break
        DEDENT
        print '%s processed %s' % (nameStr, item)
    DEDENT
DEDENT
----------------------------------------

def worker() :
INDENT
    for item in iter(q.get, None) :
    INDENT
        do_work(item)
        q.task_done()
    DEDENT
    q.task_done()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6672525_31989004_4_13
6672525_6672593_7_12
Title: Multiprocessing Queue in Python 
----------------------------------------

def worker(q) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            work = q.get_nowait()
            q.task_done()
        DEDENT
        except Empty :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def worker() :
INDENT
    for item in iter(q.get, None) :
    INDENT
        do_work(item)
        q.task_done()
    DEDENT
    q.task_done()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6676595_6676850_1_12
6676595_6676894_1_10
Title: A simple IF statement in python 
----------------------------------------

def find_details(id2find) :
INDENT
    found = False
    with open('roombookings2.txt', 'r') as rb_text :
    INDENT
        for line in rb_text :
        INDENT
            s = {}
            (s ['Date'], s ['Room'], s ['Course'], s ['Stage']) = line.split(",")
            if id2find == s ['Room'] :
            INDENT
                found = True
                yield (s)
            DEDENT
        DEDENT
    DEDENT
    if not found :
    INDENT
        raise ValueError("No such room number!")
    DEDENT
DEDENT
----------------------------------------

def find_details(id2find) :
INDENT
    rb_text = open('roombookings2.txt', 'r')
    for line in rb_text :
    INDENT
        s = {}
        (s ['Date'], s ['Room'], s ['Course'], s ['Stage']) = line.split(",")
        if id2find == (s ['Room']) :
        INDENT
            yield (s)
        DEDENT
        else :
        INDENT
            print "this print will execute if d2find != (s['Room'])"
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6692248_22707429_5_24
6692248_6692653_4_11
Title: python logging string formatting 
----------------------------------------

def format(self, record) :
INDENT
    cpath = '%s:%s:%s' % (record.module, record.funcName, record.lineno)
    cpath = cpath [- self.width :].ljust(self.width)
    record.message = record.getMessage()
    s = "%-7s %s %s : %s" % (record.levelname, self.formatTime(record, self.datefmt), cpath, record.getMessage())
    if record.exc_info :
    INDENT
        if not record.exc_text :
        INDENT
            record.exc_text = self.formatException(record.exc_info)
        DEDENT
    DEDENT
    if record.exc_text :
    INDENT
        if s [- 1 :] ! = "\n" :
        INDENT
            s = s + "\n"
        DEDENT
        s = s + record.exc_text

    DEDENT
    return s
DEDENT
----------------------------------------

def format(self, record) :
INDENT
    max_filename_width = self.width - 3 - len(str(record.lineno))
    filename = record.filename
    if len(record.filename) > max_filename_width :
    INDENT
        filename = record.filename [: max_filename_width]
    DEDENT
    a = "%s:%s" % (filename, record.lineno)
    return "[%s] %s" % (a.ljust(self.width), record.msg)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6718196_27937540_4_15
6718196_6718435_2_10
Title: Python: Determine prefix from a set of (similar) strings 
----------------------------------------

def commonprefix(instrings) :
INDENT
    d = collections.OrderedDict()
    for instring in instrings :
    INDENT
        for idx, char in enumerate(instring) :
        INDENT

            d [(char, idx)] = d.get((char, idx), 0) + 1

        DEDENT
    DEDENT
    return ''.join([k [0] for k in itertools.takewhile(lambda x : d [x] == len(instrings), d)])
DEDENT
----------------------------------------

def commonprefix(m) :
INDENT
    "Given a list of pathnames, returns the longest common leading component"
    if not m : return ''
    s1 = min(m)
    s2 = max(m)
    for i, c in enumerate(s1) :
    INDENT
        if c ! = s2 [i] :
        INDENT
            return s1 [: i]
        DEDENT
    DEDENT
    return s1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6726008_6726249_1_6
6726008_6726251_1_6
Title: Using variable length argument lists and named parameters together 
----------------------------------------

def wrapper(function) :
INDENT
    def closure(* args, ** kwargs) :
    INDENT
        print kwargs.get('uname')
        function(* args)
    DEDENT
    return closure
DEDENT
----------------------------------------

def wrapper(f) :
INDENT
    def wrapped(* args, ** kwargs) :
    INDENT
        print kwargs ["uname"]
        return mainfunc(* args, ** kwargs)
    DEDENT
    return wrapped
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6728719_6728731_1_12
6728719_6731597_1_11
Title: How do I make this list function faster? 
----------------------------------------

def countWordDistances(li) :
INDENT
    wordmap = {}
    unique_words = set(li)
    for w in unique_words :
    INDENT
        distances = [i + 1 for i, x in enumerate(li) if x == w]
        wordmap [w] = float(sum(distances)) / float(len(distances))
    DEDENT
    return wordmap
DEDENT
----------------------------------------

def countWordDistances(li) :
INDENT
    wordmap = {}
    for i in range(len(li)) :
    INDENT
        if li [i] in wordmap :
        INDENT
            avg, num = wordmap [li [i]]
            new_avg = avg * (num / (num + 1.0)) + (1.0 / (num + 1.0)) * i
            wordmap [li [i]] = new_avg, num + 1
        DEDENT
        else :
        INDENT
            wordmap [li [i]] = (i, 1)
        DEDENT
    DEDENT
    return wordmap
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6742943_6743082_1_8
6742943_6743087_1_11
Title: List problem with extracting data from Twitter XML page 
----------------------------------------

def get_names() :
INDENT
    search_page = "http://search.twitter.com/search.atom?q="
    search_page += raw_input("What term do you want to search for?")
    doc = urllib.urlopen(search_page).read()
    soup = BeautifulStoneSoup(doc)
    doc.close()
    data = [str(uri.extract()) [5 : - 6] for uri in soup.findall('uri')]
    return data
DEDENT
----------------------------------------

def get_names(search_term = raw_input("What term do you want to search for?")) :
INDENT
    search_page = "http://search.twitter.com/search.atom?q="
    search_page += search_term
    data = []
    doc = urllib.urlopen(search_page).read()
    soup = BeautifulStoneSoup(''.join(doc))
    for uri in soup.findAll('uri') :
    INDENT
        uri = str(uri.extract())
        data.append(uri [5 : - 6])
    DEDENT
    print data
    return data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6784084_36736744_3_16
6784084_6784311_3_14
Title: How to pass arguments to functions by the click of button in PyQt? 
----------------------------------------

def __init__(self, fileInfo, parent = None) :
INDENT
    super(Tab5, self).__init__(parent)
    layout = QtGui.QVBoxLayout()
    for key in sorted(assets) :
    INDENT
        b = self.buttons [key] = QtGui.QPushButton(assets [key], self)
        b.clicked.connect(self.processButton)
        layout.addWidget(b)
        print 'b[key]=', b, ' b-text=', assets [key]
        self.keydata [b] = key
    DEDENT
    layout.addStretch(1)
    self.setLayout(layout)
DEDENT
----------------------------------------

def __init__(self, * args) :
INDENT
    super(QtGui.QWidget, self).__init__()
    grid = QtGui.QGridLayout()
    names = ('One', 'Two', 'Three', 'Four', 'Five',
        'Six', 'Seven', 'Eight', 'Nine', 'Ten')
    for i, name in enumerate(names) :
    INDENT
        button = QtGui.QPushButton(name, self)
        button.clicked.connect(self.make_calluser(name))
        row, col = divmod(i, 5)
        grid.addWidget(button, row, col)
    DEDENT
    self.setLayout(grid)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6796523_6796560_1_16
6796523_6796618_1_10
Title: Use of return in long if-elseif-else statements (Python) 
----------------------------------------

def some_function(eggs) :
INDENT
    if eggs not in [1, 2, 3] :
    INDENT
        do_error()
        return
    DEDENT
    if eggs == 1 :
    INDENT
        do_something_1()
    DEDENT
    elif eggs == 2 :
    INDENT
        do_something_2()
    DEDENT
    elif eggs == 3 :
    INDENT
        do_something_3()
    DEDENT
    else :
    INDENT
        assert False
    DEDENT
    do_something_4()
    do_something_5()
    do_something_6()
DEDENT
----------------------------------------

def some_function(eggs) :
INDENT
    options = {1 : do_something_1, 2 : do_something_2, 3 : do_something_3}
    if eggs in options :
    INDENT
        options [eggs]()
        do_something_4()
        do_something_5()
        do_something_6()
    DEDENT
    else :
    INDENT
        do_error()
        return
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6796523_6796600_1_17
6796523_6796618_1_10
Title: Use of return in long if-elseif-else statements (Python) 
----------------------------------------

def some_function(eggs) :
INDENT
    error_code = 0
    if eggs == 1 :
    INDENT
        do_something_1()
    DEDENT
    elif eggs == 2 :
    INDENT
        do_something_2()
    DEDENT
    elif eggs == 3 :
    INDENT
        do_something_3()
    DEDENT
    else :
    INDENT
        do_error()
        error_code = 1
    DEDENT
    if error_code == 0 :
    INDENT
        do_something_4()
        do_something_5()
        do_something_6()
    DEDENT
    return
DEDENT
----------------------------------------

def some_function(eggs) :
INDENT
    options = {1 : do_something_1, 2 : do_something_2, 3 : do_something_3}
    if eggs in options :
    INDENT
        options [eggs]()
        do_something_4()
        do_something_5()
        do_something_6()
    DEDENT
    else :
    INDENT
        do_error()
        return
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6836274_6837146_20_31
6836274_6837146_5_13
Title: simple application using wxPython and matplotlib freezes 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None)
    self.figure = MyFigurePanel(self)
    self.buttons = MyButtonPanel(self)
    grid = wx.BoxSizer(wx.VERTICAL)
    grid.Add(self.buttons, flag = wx.EXPAND)
    grid.Add(self.figure, flag = wx.EXPAND)
    self.SetSizer(grid)
    self.Fit()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.figure = Figure()
    self.axes = self.figure.add_subplot(111)
    x = np.arange(0, 6,.01)
    y = np.sin(x ** 2) * np.exp(- x)
    self.axes.plot(x, y)
    self.canvas = FigureCanvas(self, wx.ID_ANY, self.figure)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6846829_6846902_3_11
6846829_6847131_3_16
Title: override recursive method in python 
----------------------------------------

def f(self, x) :
INDENT
    print x,
    if x < 0 :
    INDENT
        self.__f(x + 1)
    DEDENT
    if x > 0 :
    INDENT
        self.__f(x - 1)
    DEDENT
    if x == 0 :
    INDENT
        print ""
    DEDENT
DEDENT
----------------------------------------

def f(self, x, func = None) :
INDENT
    if func is None :
    INDENT
        func = A.f
    DEDENT
    print x,
    if x < 0 :
    INDENT
        func(self, x + 1, func)
    DEDENT
    if x > 0 :
    INDENT
        func(self, x - 1, func)
    DEDENT
    if x == 0 :
    INDENT
        print ""
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6881170_6881323_32_39
6881170_6882225_97_114
Title: Is there a way to autogenerate valid arithmetic expressions? 
----------------------------------------

def __str__(self) :
INDENT
    s = '{0!s} {1} {2!s}'.format(self.left, self.operator, self.right)
    if self.grouped :
    INDENT
        return '({0})'.format(s)
    DEDENT
    else :
    INDENT
        return s

    DEDENT
DEDENT
----------------------------------------

def __str__(self) :
INDENT
    left_str = self.left.__str__()
    right_str = self.right.__str__()
    op_str = self.symbol

    if self.left.precedence() > self.precedence() :
    INDENT
        left_str = '(' + left_str + ')'
    DEDENT
    if self.right.precedence() > self.precedence() :
    INDENT
        right_str = '(' + right_str + ')'

    DEDENT
    if operators [self.symbol] ['prec'] > = 30 :
    INDENT
        op_str = ' ' + op_str + ' '
    DEDENT
    return left_str + op_str + right_str
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6881170_6882225_29_41
6881170_6882225_75_93
Title: Is there a way to autogenerate valid arithmetic expressions? 
----------------------------------------

def create_random(cls, level) :
INDENT
    if level == 0 :
    INDENT
        is_op = True
    DEDENT
    elif level == max_levels :
    INDENT
        is_op = False
    DEDENT
    else :
    INDENT
        is_op = random.random() < = 1.0 - pow(level / max_levels, 2.0)
    DEDENT
    if is_op :
    INDENT
        return binary_expression.create_random(level)
    DEDENT
    else :
    INDENT
        return integer_expression.create_random(level)
    DEDENT
DEDENT
----------------------------------------

def create_random(cls, level) :
INDENT
    symbol = None

    r = random.random()
    cumulative = 0.0
    for k, v in operators.items() :
    INDENT
        cumulative += v ['prob']
        if r < = cumulative :
        INDENT
            symbol = k
            break
        DEDENT
    DEDENT
    assert symbol ! = None
    left = expression.create_random(level + 1)
    right = expression.create_random(level + 1)
    return binary_expression(symbol, left, right)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6881193_37644481_12_58
6881193_38314027_7_45
Title: Learn Python the Hard Way Exercise 48 help 
----------------------------------------

def scan(d) :
INDENT
    list2 = d.split()
    list1 = []
    list3 = []
    try :
    INDENT
        for x in d.split() :
        INDENT
            if int(x) in xrange(999999999) :
            INDENT
                a = x
                list1.append(a)
                list2.remove(a)
            DEDENT
            else :
            INDENT
                print "yes"
            DEDENT
        DEDENT
    DEDENT
    except :
    INDENT
        list99 = []
    DEDENT
    for x in d.split() :
    INDENT
        if x in nouns :
        INDENT
            z1 = ("noun", x)
            list3.append(z1)
        DEDENT
        elif x in directions :
        INDENT
            z2 = ("direction", x)
            list3.append(z2)
        DEDENT
        elif x in verbs :
        INDENT
            z2 = ("verb", x)
            list3.append(z2)
        DEDENT
        elif x in list1 :
        INDENT
            z2 = ("number", int(x))
            list3.append(z2)
        DEDENT
        elif x in stops :
        INDENT
            z2 = ("stop", x)
            list3.append(z2)
        DEDENT
        elif x in list2 :
        INDENT
            z2 = ("error", x)
            list3.append(z2)
        DEDENT
        else :
        INDENT
            print "yes"
        DEDENT
    DEDENT
    print "d:%s" % d.split()
    print "list1:%s" % list1
    print "list2:%s" % list2
    print "list3:%s" % list3
    return list3
DEDENT
----------------------------------------

def scan(sentence) :
INDENT
    split_sentence = sentence.split()
    list1 = []
    list2 = []
    length_of_list = len(split_sentence)
    counter = 0
    while counter < length_of_list :
    INDENT
        for x in split_sentence :
        INDENT
            try :
            INDENT
                if int(x) in xrange(999999999) :
                INDENT
                    tuple = ("numbers", x)
                    list1.append(tuple)
                    split_sentence.remove(x)
                    counter += 1
                DEDENT
                else :
                INDENT

                    counter += 1
                DEDENT
            DEDENT
            except :
            INDENT

                counter += 1
            DEDENT
        DEDENT
    DEDENT
    for i in split_sentence :
    INDENT
        for j in list_of_lists :
        INDENT
            if i in j :
            INDENT
                for k, v in list(globals().iteritems()) :
                INDENT
                    if j is v :
                    INDENT
                        tuple = (k, i)
                        list1.append(tuple)
                    DEDENT
                    else :
                    INDENT
                        pass
                    DEDENT
                DEDENT
            DEDENT
            else :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    print list1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6881193_37644481_12_58
6881193_44529076_11_95
Title: Learn Python the Hard Way Exercise 48 help 
----------------------------------------

def scan(d) :
INDENT
    list2 = d.split()
    list1 = []
    list3 = []
    try :
    INDENT
        for x in d.split() :
        INDENT
            if int(x) in xrange(999999999) :
            INDENT
                a = x
                list1.append(a)
                list2.remove(a)
            DEDENT
            else :
            INDENT
                print "yes"
            DEDENT
        DEDENT
    DEDENT
    except :
    INDENT
        list99 = []
    DEDENT
    for x in d.split() :
    INDENT
        if x in nouns :
        INDENT
            z1 = ("noun", x)
            list3.append(z1)
        DEDENT
        elif x in directions :
        INDENT
            z2 = ("direction", x)
            list3.append(z2)
        DEDENT
        elif x in verbs :
        INDENT
            z2 = ("verb", x)
            list3.append(z2)
        DEDENT
        elif x in list1 :
        INDENT
            z2 = ("number", int(x))
            list3.append(z2)
        DEDENT
        elif x in stops :
        INDENT
            z2 = ("stop", x)
            list3.append(z2)
        DEDENT
        elif x in list2 :
        INDENT
            z2 = ("error", x)
            list3.append(z2)
        DEDENT
        else :
        INDENT
            print "yes"
        DEDENT
    DEDENT
    print "d:%s" % d.split()
    print "list1:%s" % list1
    print "list2:%s" % list2
    print "list3:%s" % list3
    return list3
DEDENT
----------------------------------------

def scan(self, sentence) :
INDENT
    self.flag = ''
    self.list_var = []
    self.sentence = sentence
    self.words = self.sentence.split()
    for k1, k2, k3 in izip(direction, verbs, nouns) :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if direction [k1] [1] == self.words [self.j] :
            INDENT
                self.flag = 'd'
                break
            DEDENT
            elif verbs [k2] [1] == self.words [self.j] :
            INDENT
                self.flag = 'v'
                break
            DEDENT
            elif nouns [k3] [1] == self.words [self.j] :
            INDENT
                self.flag = 'n'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    for k4 in numbers :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if str(numbers [k4] [1]) == self.words [self.j] :
            INDENT
                self.flag = 'nu'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    for k5 in stop :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if stop [k5] [1] == self.words [self.j] :
            INDENT
                print 'in if set flag'
                self.flag = 's'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    if self.flag == 'd' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(direction.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(direction.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'v' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(verbs.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            print "else"
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(verbs.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'n' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(nouns.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(nouns.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'nu' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(numbers.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(numbers.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 's' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(stop.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(stop.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6881193_37644481_12_58
6881193_7241227_1_19
Title: Learn Python the Hard Way Exercise 48 help 
----------------------------------------

def scan(d) :
INDENT
    list2 = d.split()
    list1 = []
    list3 = []
    try :
    INDENT
        for x in d.split() :
        INDENT
            if int(x) in xrange(999999999) :
            INDENT
                a = x
                list1.append(a)
                list2.remove(a)
            DEDENT
            else :
            INDENT
                print "yes"
            DEDENT
        DEDENT
    DEDENT
    except :
    INDENT
        list99 = []
    DEDENT
    for x in d.split() :
    INDENT
        if x in nouns :
        INDENT
            z1 = ("noun", x)
            list3.append(z1)
        DEDENT
        elif x in directions :
        INDENT
            z2 = ("direction", x)
            list3.append(z2)
        DEDENT
        elif x in verbs :
        INDENT
            z2 = ("verb", x)
            list3.append(z2)
        DEDENT
        elif x in list1 :
        INDENT
            z2 = ("number", int(x))
            list3.append(z2)
        DEDENT
        elif x in stops :
        INDENT
            z2 = ("stop", x)
            list3.append(z2)
        DEDENT
        elif x in list2 :
        INDENT
            z2 = ("error", x)
            list3.append(z2)
        DEDENT
        else :
        INDENT
            print "yes"
        DEDENT
    DEDENT
    print "d:%s" % d.split()
    print "list1:%s" % list1
    print "list2:%s" % list2
    print "list3:%s" % list3
    return list3
DEDENT
----------------------------------------

def scan(data) :
INDENT
    data = data.split()
    results = []
    for l in data :
    INDENT
        if l in directions :
        INDENT
            results.append(('direction', l))
        DEDENT
        elif l in verbs :
        INDENT
            results.append(('verb', l))
        DEDENT
        elif l in stop_words :
        INDENT
            results.append(('stop', l))
        DEDENT
        elif l in nouns :
        INDENT
            results.append(('noun', l))
        DEDENT
        elif convert_number(l) in numbers :
        INDENT
            results.append(('number', convert_number(l)))
        DEDENT
        else :
        INDENT
            results.append(('error', l))
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6881193_38314027_7_45
6881193_44529076_11_95
Title: Learn Python the Hard Way Exercise 48 help 
----------------------------------------

def scan(sentence) :
INDENT
    split_sentence = sentence.split()
    list1 = []
    list2 = []
    length_of_list = len(split_sentence)
    counter = 0
    while counter < length_of_list :
    INDENT
        for x in split_sentence :
        INDENT
            try :
            INDENT
                if int(x) in xrange(999999999) :
                INDENT
                    tuple = ("numbers", x)
                    list1.append(tuple)
                    split_sentence.remove(x)
                    counter += 1
                DEDENT
                else :
                INDENT

                    counter += 1
                DEDENT
            DEDENT
            except :
            INDENT

                counter += 1
            DEDENT
        DEDENT
    DEDENT
    for i in split_sentence :
    INDENT
        for j in list_of_lists :
        INDENT
            if i in j :
            INDENT
                for k, v in list(globals().iteritems()) :
                INDENT
                    if j is v :
                    INDENT
                        tuple = (k, i)
                        list1.append(tuple)
                    DEDENT
                    else :
                    INDENT
                        pass
                    DEDENT
                DEDENT
            DEDENT
            else :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    print list1
DEDENT
----------------------------------------

def scan(self, sentence) :
INDENT
    self.flag = ''
    self.list_var = []
    self.sentence = sentence
    self.words = self.sentence.split()
    for k1, k2, k3 in izip(direction, verbs, nouns) :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if direction [k1] [1] == self.words [self.j] :
            INDENT
                self.flag = 'd'
                break
            DEDENT
            elif verbs [k2] [1] == self.words [self.j] :
            INDENT
                self.flag = 'v'
                break
            DEDENT
            elif nouns [k3] [1] == self.words [self.j] :
            INDENT
                self.flag = 'n'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    for k4 in numbers :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if str(numbers [k4] [1]) == self.words [self.j] :
            INDENT
                self.flag = 'nu'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    for k5 in stop :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if stop [k5] [1] == self.words [self.j] :
            INDENT
                print 'in if set flag'
                self.flag = 's'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    if self.flag == 'd' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(direction.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(direction.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'v' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(verbs.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            print "else"
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(verbs.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'n' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(nouns.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(nouns.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'nu' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(numbers.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(numbers.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 's' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(stop.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(stop.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6881193_38314027_7_45
6881193_7241227_1_19
Title: Learn Python the Hard Way Exercise 48 help 
----------------------------------------

def scan(sentence) :
INDENT
    split_sentence = sentence.split()
    list1 = []
    list2 = []
    length_of_list = len(split_sentence)
    counter = 0
    while counter < length_of_list :
    INDENT
        for x in split_sentence :
        INDENT
            try :
            INDENT
                if int(x) in xrange(999999999) :
                INDENT
                    tuple = ("numbers", x)
                    list1.append(tuple)
                    split_sentence.remove(x)
                    counter += 1
                DEDENT
                else :
                INDENT

                    counter += 1
                DEDENT
            DEDENT
            except :
            INDENT

                counter += 1
            DEDENT
        DEDENT
    DEDENT
    for i in split_sentence :
    INDENT
        for j in list_of_lists :
        INDENT
            if i in j :
            INDENT
                for k, v in list(globals().iteritems()) :
                INDENT
                    if j is v :
                    INDENT
                        tuple = (k, i)
                        list1.append(tuple)
                    DEDENT
                    else :
                    INDENT
                        pass
                    DEDENT
                DEDENT
            DEDENT
            else :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    print list1
DEDENT
----------------------------------------

def scan(data) :
INDENT
    data = data.split()
    results = []
    for l in data :
    INDENT
        if l in directions :
        INDENT
            results.append(('direction', l))
        DEDENT
        elif l in verbs :
        INDENT
            results.append(('verb', l))
        DEDENT
        elif l in stop_words :
        INDENT
            results.append(('stop', l))
        DEDENT
        elif l in nouns :
        INDENT
            results.append(('noun', l))
        DEDENT
        elif convert_number(l) in numbers :
        INDENT
            results.append(('number', convert_number(l)))
        DEDENT
        else :
        INDENT
            results.append(('error', l))
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6881193_44529076_11_95
6881193_7241227_1_19
Title: Learn Python the Hard Way Exercise 48 help 
----------------------------------------

def scan(self, sentence) :
INDENT
    self.flag = ''
    self.list_var = []
    self.sentence = sentence
    self.words = self.sentence.split()
    for k1, k2, k3 in izip(direction, verbs, nouns) :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if direction [k1] [1] == self.words [self.j] :
            INDENT
                self.flag = 'd'
                break
            DEDENT
            elif verbs [k2] [1] == self.words [self.j] :
            INDENT
                self.flag = 'v'
                break
            DEDENT
            elif nouns [k3] [1] == self.words [self.j] :
            INDENT
                self.flag = 'n'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    for k4 in numbers :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if str(numbers [k4] [1]) == self.words [self.j] :
            INDENT
                self.flag = 'nu'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    for k5 in stop :
    INDENT
        self.j = 0
        while self.j < len(self.words) :
        INDENT
            if stop [k5] [1] == self.words [self.j] :
            INDENT
                print 'in if set flag'
                self.flag = 's'
                break
            DEDENT
            self.j = self.j + 1
        DEDENT
    DEDENT
    if self.flag == 'd' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(direction.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(direction.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'v' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(verbs.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            print "else"
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(verbs.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'n' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(nouns.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(nouns.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 'nu' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(numbers.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(numbers.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
    elif self.flag == 's' :
    INDENT
        if len(self.words) == 1 :
        INDENT
            self.list_var.append(stop.get(self.words [0]))
            return self.list_var
        DEDENT
        else :
        INDENT
            self.i = 0
            while self.i < len(self.words) :
            INDENT
                self.list_var.append(stop.get(self.words [self.i]))
                self.i = self.i + 1;
            DEDENT
            return self.list_var
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def scan(data) :
INDENT
    data = data.split()
    results = []
    for l in data :
    INDENT
        if l in directions :
        INDENT
            results.append(('direction', l))
        DEDENT
        elif l in verbs :
        INDENT
            results.append(('verb', l))
        DEDENT
        elif l in stop_words :
        INDENT
            results.append(('stop', l))
        DEDENT
        elif l in nouns :
        INDENT
            results.append(('noun', l))
        DEDENT
        elif convert_number(l) in numbers :
        INDENT
            results.append(('number', convert_number(l)))
        DEDENT
        else :
        INDENT
            results.append(('error', l))
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6899101_6899295_16_22
6899101_6899396_3_18
Title: Select a range of dates in Python dictionary 
----------------------------------------

def get_records(dict_history, str_from_date, str_to_date) :
INDENT
    sorted_keys = sorted(dict_history.iterkeys())
    start = bisect.bisect_left(sorted_keys, str_from_date)
    end = bisect.bisect_right(sorted_keys, str_to_date)
    for date in sorted(dict_history.iteritems()) [start : end] :
    INDENT
        yield date
    DEDENT
DEDENT
----------------------------------------

def get_records(history, start_date, end_date) :
INDENT
    fmt = "%Y-%m-%d"
    start_date = datetime.strptime(start_date, fmt)
    end_date = datetime.strptime(end_date, fmt)
    dt = history.iteritems()
    dt = sorted(dt, key = lambda date : datetime.strptime(date [0], fmt))
    for date in dt :
    INDENT
        if datetime.strptime(date [0], fmt) > end_date :
        INDENT
            break
        DEDENT
        elif datetime.strptime(date [0], fmt) > = start_date :
        INDENT
            yield (date [0], history [date [0]])
        DEDENT
        else :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6914803_6915269_7_12
6914803_6916433_6_15
Title: python iterator through tree with list of children 
----------------------------------------

def __iter__(self) :
INDENT
    "implement the iterator protocol"
    for v in chain(* imap(iter, self.children)) :
    INDENT
        yield v
    DEDENT
    yield self.value
DEDENT
----------------------------------------

def __iter__(self) :
INDENT
    for child in self.l :
    INDENT
        for item in child :
        INDENT
            yield item

        DEDENT
    DEDENT
    yield self
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6932507_6933211_1_17
6932507_6933284_1_14
Title: working with a big list 
----------------------------------------

def coart(phonemeFile) :
INDENT
    results = {}
    f = open("syllabifiedPhonemes.txt", "r")
    for line in f.readlines() :
    INDENT
        syllables = line.split("'")
        for syllable in syllables :
        INDENT
            phonemes = list(map(lambda x : x.strip(), syllable.split()))
            data = []
            for phoneme in phonemes :
            INDENT
                data.append(param_values [phoneme])
            DEDENT
            results [' '.join(phonemes)] = data
        DEDENT
    DEDENT
    print (results)
    f.close()
DEDENT
----------------------------------------

def coart(phonemeFile) :
INDENT
    all_lines = []
    with open(phonemeFile, "r") as pFile :
    INDENT
        for line in pFile :
        INDENT
            next_line = []
            line = line.split()
            for syllable in line :
            INDENT
                if syllable == "'" :
                INDENT
                    continue
                DEDENT
                next_coart = param_values.get(syllable)
                next_line.append((syllable, next_coart))
            DEDENT
            all_lines.append(next_line)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
694366_695187_8_20
694366_697001_1_21
Title: How can I make this recursive crawl function iterative? 
----------------------------------------

def crawl(self, url) :
INDENT
    "Get all URLS from which to scrape categories."
    links = get_links(url)
    while len(links) > 0 :
    INDENT
        link = links.pop()
        for attr in link.attrs :
        INDENT
            if Crawler._match_attr(attr) :
            INDENT
                if Crawler._is_category(attr) :
                INDENT
                    pass
                DEDENT
            DEDENT
            elif attr [1] not in self._crawled :
            INDENT
                self._crawled.append(attr [1])
                links = get_links(attr [1]) + links
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def crawl(self, url) :
INDENT
    urls = Queue(- 1)
    _crawled = []
    urls.put(url)
    while not urls.empty() :
    INDENT
        url = urls.get()
        try :
        INDENT
            links = BeautifulSoup(urllib2.urlopen(url)).findAll(Crawler._match_tag)
        DEDENT
        except urllib2.HTTPError :
        INDENT
            continue
        DEDENT
        for link in links :
        INDENT
            for attr in link.attrs :
            INDENT
                if Crawler._match_attr(attr) :
                INDENT
                    if Crawler._is_category(attr) :
                    INDENT
                        continue
                    DEDENT
                    else :
                    INDENT
                        Crawler._visit(attr [1])
                        if attr [1] not in _crawled :
                        INDENT
                            urls.put(attr [1])
                        DEDENT
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6971819_6972116_1_11
6971819_6972357_13_18
Title: "Find the numbers that can be made with addition and subtraction using all numbers given" 
----------------------------------------

def pmv(nums) :
INDENT
    chunklen = 6
    res = dict()
    res [0] = ()
    for i in xrange(0, len(nums), chunklen) :
    INDENT
        part = plus_minus_variations(nums [i : i + chunklen])
        resnew = dict()
        for (i, j) in itertools.product(res, part) :
        INDENT
            resnew [i + j] = tuple(list(res [i]) + list(part [j]))
        DEDENT
        res = resnew
    DEDENT
    return res
DEDENT
----------------------------------------

def pmv(nums) :
INDENT
    if len(nums) > 1 :
    INDENT
        l = pmv(nums [: len(nums) / 2])
        r = pmv(nums [len(nums) / 2 :])
        return combine(l, r)
    DEDENT
    return {nums [0] : [1]}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6971819_6972116_1_11
6971819_6974515_1_10
Title: "Find the numbers that can be made with addition and subtraction using all numbers given" 
----------------------------------------

def pmv(nums) :
INDENT
    chunklen = 6
    res = dict()
    res [0] = ()
    for i in xrange(0, len(nums), chunklen) :
    INDENT
        part = plus_minus_variations(nums [i : i + chunklen])
        resnew = dict()
        for (i, j) in itertools.product(res, part) :
        INDENT
            resnew [i + j] = tuple(list(res [i]) + list(part [j]))
        DEDENT
        res = resnew
    DEDENT
    return res
DEDENT
----------------------------------------

def pmv(nums) :
INDENT
    sums = set()
    sums.add(0)
    for i in range(0, len(nums)) :
    INDENT
        partialsums = set()
        for s in sums :
        INDENT
            partialsums.add(s + nums [i])
            partialsums.add(s - nums [i])
        DEDENT
        sums = partialsums
    DEDENT
    return sums
DEDENT
----------------------------------------
