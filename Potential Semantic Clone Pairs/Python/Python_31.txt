$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35545291_35545491_1_20
35545291_35545674_1_33
Title: Why Wont Maze solver Code Work 
----------------------------------------

def main(x, y) :
INDENT
    if grid [x] [y] == " " or grid [x] [y] == "T" :
    INDENT
        print "Found empty at %d %d" % (x, y)
        grid [x] [y] = "x"
    DEDENT
    elif grid [x] [y] == "#" :
    INDENT
        print "Found wall at %d %d" % (x, y)
        return
    DEDENT
    elif grid [x] [y] == "E" :
    INDENT
        print "Found exit at %d %d" % (x, y)
        return
    DEDENT
    else : return
    if y < len(grid) - 1 :
    INDENT
        main(x, y + 1)
    DEDENT
    if y > 0 :
    INDENT
        main(x, y - 1)
    DEDENT
    if x < len(grid [x]) - 1 :
    INDENT
        main(x + 1, y)
    DEDENT
    if x > 0 :
    INDENT
        main(x - 1, y)
    DEDENT
DEDENT
----------------------------------------

def main(x, y) :
INDENT
    if y < 0 or y > = len(grid) :
    INDENT
        return False
    DEDENT
    if x < 0 or x > = len(grid [y]) :
    INDENT
        return False
    DEDENT
    if grid [x] [y] == "E" :
    INDENT
        print "Found exit at %d %d" % (x, y)
        return True
    DEDENT
    elif grid [x] [y] == "#" :
    INDENT
        print "Found wall at %d %d" % (x, y)
        return False
    DEDENT
    elif grid [x] [y] == " " or grid [x] [y] == "T" :
    INDENT
        print "Found empty at %d %d" % (x, y)
        grid [x] [y] = "x"
    DEDENT
    else :
    INDENT
        return False
    DEDENT
    found = False

    if y < len(grid) - 1 and not found :
    INDENT
        found = main(x, y + 1)
    DEDENT
    if y > 0 and not found :
    INDENT
        found = main(x, y - 1)
    DEDENT
    if x < len(grid [x]) - 1 and not found :
    INDENT
        found = main(x + 1, y)
    DEDENT
    if x > 0 and not found :
    INDENT
        found = main(x - 1, y)
    DEDENT
    return found
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35557693_35640009_1_21
35557693_35664512_1_20
Title: How to check if two permutations are symmetric? 
----------------------------------------

def compare(A, B) :
INDENT
    same = True
    for i, (a, b) in enumerate(zip(A, B)) :
    INDENT
        if same and a ! = b :
        INDENT
            same = False
            n = i
            firstval = a
        DEDENT
        elif (not same) and (a == b or b == firstval) :
        INDENT
            m = i
            break
        DEDENT
    DEDENT
    origin = A [n : m]
    if n == 0 :
    INDENT
        dest = A [- m :]
        B_expect = dest + A [m : - m] + origin
    DEDENT
    else :
    INDENT
        dest = A [- m : - n]
        B_expect = A [: n] + dest + A [m : - m] + origin + A [- n :]
    DEDENT
    return bool(B_expect == B)
DEDENT
----------------------------------------

def compare(a, b) :
INDENT
    i_zip = list(enumerate(zip(a, b)))
    llen = len(a)
    hp = llen / / 2
    def find_index(i_zip) :
    INDENT
        for i, (x, y) in i_zip :
        INDENT
            if x ! = y :
            INDENT
                return i
            DEDENT
        DEDENT
        return i_zip [0] [0]

    DEDENT
    n = find_index(i_zip [: hp])
    p = find_index(i_zip [hp :])
    m = llen - p
    q = llen - n
    if a [: n] + a [p : q] + a [m : p] + a [n : m] + a [q :] ! = b :
    INDENT
        return None
    DEDENT
    return n, m
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35559632_35559760_1_10
35559632_45259817_6_11
Title: Insert a Node at the Tail of a Linked List python HackerRank 
----------------------------------------

def Insert(head, data) :
INDENT
    if (head == None) :
    INDENT
        head = Node(data)
    DEDENT
    else :
    INDENT
        current = head
        while (current.next ! = None) :
        INDENT
            current = current.next
        DEDENT
        current.next = Node(data)
    DEDENT
    return head
DEDENT
----------------------------------------

def Insert(head, data) :
INDENT
    if head == None :
    INDENT
        return Node(data)
    DEDENT
    tail = getTail(head)
    tail.next = Node(data)
    return head
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35572698_35572950_1_7
35572698_35572988_1_11
Title: Python - If not statement with 0.0 
----------------------------------------

def square(x = None) :
INDENT
    if not isinstance(x, numbers.Number) or isinstance(x, numbers.Complex) :
    INDENT
        print ("you have not entered x")
    DEDENT
    else :
    INDENT
        y = x ** 2
        return y
    DEDENT
DEDENT
----------------------------------------

def square(x) :
INDENT
    if not x :
    INDENT
        print "you have not entered x"
    DEDENT
    else :
    INDENT
        try :
        INDENT
            int(y) = x ** 2
            return y
        DEDENT
        except TypeError :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35590503_35591095_12_29
35590503_35600160_14_44
Title: Creating html results from tests generated dynamically 
----------------------------------------

def main() :
INDENT
    tests_map = {
        'foo' : [1, 1],
        'bar' : [1, 2],
        'baz' : [5, 5]}
    for name, params in tests_map.iteritems() :
    INDENT
        test_name = "test_gen_%s" % name
        _method = make_method(test_name, params [0], params [1])
        setattr(DynamicClassBase, test_name, _method)
    DEDENT
    suite = unittest.TestLoader().loadTestsFromTestCase(DynamicClassBase)
    unittest.TextTestRunner(verbosity = 2)
    with open('results.html', 'w') as html_file :
    INDENT
        runner = HTMLTestRunner.HTMLTestRunner(stream = html_file,
            title = 'demo title',
            description = 'demo descr')
        runner.run(suite)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    tests_classes = []
    testsmap = {
        'foo' : [1, 1],
        'bar' : [1, 2],
        'baz' : [5, 5]}
    for name, params in testsmap.iteritems() :
    INDENT
        test_func = make_test_function(name, params [0], params [1])
        klassname = 'Test_{0}'.format(name)
        globals() [klassname] = type(klassname,
            (DynamicClassBase,),
            {'test_gen_{0}'.format(name) : test_func})
        test_classes_to_run.append(globals() [klassname])

    DEDENT
    loader = unittest.TestLoader()
    suites_list = []
    for test_class in test_classes_to_run :
    INDENT
        suite = loader.loadTestsFromTestCase(test_class)
        suites_list.append(suite)
    DEDENT
    big_suite = unittest.TestSuite(suites_list)
    with open('results.html', 'w') as html_file :
    INDENT
        runner = HTMLTestRunner.HTMLTestRunner(stream = html_file,
            verbosity = 2,
            title = 'demo title',
            description = 'demo descr')
        runner.run(big_suite)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35593676_35593774_1_10
35593676_35593950_1_11
Title: Python Memory Error for a capitalize function 
----------------------------------------

def transform_capitalize(st) :
INDENT
    l = []
    l.append(st.lower())
    newl = l [:]
    length = len(st)
    for x in range(0, length) :
    INDENT
        for i in l :
        INDENT
            newl.append(i [: x] + i [x].upper() + i [(x + 1) :])
        DEDENT
        l = newl [:]
    DEDENT
    return l
DEDENT
----------------------------------------

def transform_capitalize(st) :
INDENT
    result = []
    if len(st) > 0 :
    INDENT
        head = st [0]
        tails = transform_capitalize(st [1 :])
        for t in tails :
        INDENT
            result.append(head.lower() + t)
            result.append(head.upper() + t)
        DEDENT
    DEDENT
    else :
    INDENT
        result = ['']
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35595116_35595429_15_23
35595116_35596783_3_36
Title: Finding the second smallest int in list of list in Python 3 with recursion 
----------------------------------------

def find(lst) :
INDENT
    mins = []
    if not all(isinstance(item, list) for item in lst) :
    INDENT
        mins.append(MIN(lst))
    DEDENT
    for item in lst :
    INDENT
        if isinstance(item, list) :
        INDENT
            mins.append(MIN(item))
        DEDENT
    DEDENT
    return filter(lambda x : x == 0 or x, mins)
DEDENT
----------------------------------------

def find(abc) :
INDENT
    if len(abc) == 2 :
    INDENT
        if isinstance(abc [0], list) and isinstance(abc [1], list) :
        INDENT
            re = find(abc [0] + abc [1 :])
        DEDENT
        elif isinstance(abc [1], list) :
        INDENT
            re = find(abc [: 1] + abc [1])
        DEDENT
        elif isinstance(abc [0], list) :
        INDENT
            re = find(abc [0] + abc [1 :])
        DEDENT
        else :
        INDENT
            if abc [0] > abc [1] :
            INDENT
                re = (abc [0], abc [1])
            DEDENT
            else :
            INDENT
                re = (abc [1], abc [0])
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        if len(abc) == 0 :
        INDENT
            return (sys.maxsize, sys.maxsize)
        DEDENT
        if isinstance(abc [0], list) :
        INDENT
            re = find(abc [0] + abc [1 :])
        DEDENT
        else :
        INDENT
            current = abc [0]
            second, first = find(abc [1 :])
            if (second < current) :
            INDENT
                re = (second, first)
            DEDENT
            elif (current > first) and (second > = current) :
            INDENT
                re = (current, first)
            DEDENT
            else :
            INDENT
                re = (first, current)
            DEDENT
        DEDENT
    DEDENT
    return re
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35598736_35599798_4_30
35598736_35599919_3_8
Title: A single letter insert or delete function 
----------------------------------------

def single_insert_or_delete(s1, s2) :
INDENT
    s1 = s1.lower()
    s2 = s2.lower()
    l1 = [i for i in s1]
    l2 = [j for j in s2]
    if s1 == s2 :
    INDENT
        flag = 0
    DEDENT
    elif abs(len(s1) - len(s2)) == 1 :
    INDENT
        if len(l2) > len(l1) :
        INDENT
            l1, l2 = l2, l1
        DEDENT
        l3 = list(numpy.in1d(l1, l2))

        if l3.count(False) > 1 :
        INDENT
            flag = 2
        DEDENT
        else :
        INDENT
            flag = 1
        DEDENT
    DEDENT
    else :
    INDENT
        flag = 2
    DEDENT
    return flag

DEDENT
----------------------------------------

def single_insert_or_delete(word1, word2) :
INDENT
    change_count = sum(1 for s in ndiff(word1.lower(), word2.lower()) if (s [0] == '-' or s [0] == '+'))
    if change_count > 1 :
    INDENT
        return 2
    DEDENT
    return change_count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35608711_35609252_1_18
35608711_35610507_11_25
Title: Mismatched strings in Python -- how to continue process? 
----------------------------------------

def find_mismatch(s1, s2) :
INDENT
    s1 = s1.lower()
    s2 = s2.lower()
    x = s1.split()
    y = s2.split()
    mismatch = 0
    count = 0
    for char in range(0, len(x + 1)) :
    INDENT
        if len(x) == len(y) and x [0 :] == y [0 :] :
        INDENT
            return 0
        DEDENT
        if not len(s1) == len(s2) :
        INDENT
            return 2
        DEDENT
        if len(s1) == len(s2) and not x [count] == y [count] :
        INDENT
            mismatch += 1

        DEDENT
    DEDENT
    return mismatch if mismatch < = 2 else 2
DEDENT
----------------------------------------

def find_mismatch(string_a, string_b) :
INDENT
    if len(string_a) ! = len(string_b) :
    INDENT
        return 2
    DEDENT
    folded_a, folded_b = string_a.casefold(), string_b.casefold()
    if folded_a == folded_b :
    INDENT
        return 0
    DEDENT
    found_difference = False
    for character_a, character_b in zip(folded_a, folded_b) :
    INDENT
        if character_a ! = character_b :
        INDENT
            if found_difference :
            INDENT
                return 2
            DEDENT
            found_difference = True
        DEDENT
    DEDENT
    return 1

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35608711_35609252_1_18
35608711_35610507_26_45
Title: Mismatched strings in Python -- how to continue process? 
----------------------------------------

def find_mismatch(s1, s2) :
INDENT
    s1 = s1.lower()
    s2 = s2.lower()
    x = s1.split()
    y = s2.split()
    mismatch = 0
    count = 0
    for char in range(0, len(x + 1)) :
    INDENT
        if len(x) == len(y) and x [0 :] == y [0 :] :
        INDENT
            return 0
        DEDENT
        if not len(s1) == len(s2) :
        INDENT
            return 2
        DEDENT
        if len(s1) == len(s2) and not x [count] == y [count] :
        INDENT
            mismatch += 1

        DEDENT
    DEDENT
    return mismatch if mismatch < = 2 else 2
DEDENT
----------------------------------------

def find_mismatch(a, b) :
INDENT
    if len(a) ! = len(b) :
    INDENT
        return 2
    DEDENT
    a, b = a.casefold(), b.casefold()
    if a == b :
    INDENT
        return 0
    DEDENT
    error = False
    for a, b in zip(a, b) :
    INDENT
        if a ! = b :
        INDENT
            if error :
            INDENT
                return 2
            DEDENT
            error = True
        DEDENT
    DEDENT
    return 1

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35608711_35609252_1_18
35608711_35656025_1_14
Title: Mismatched strings in Python -- how to continue process? 
----------------------------------------

def find_mismatch(s1, s2) :
INDENT
    s1 = s1.lower()
    s2 = s2.lower()
    x = s1.split()
    y = s2.split()
    mismatch = 0
    count = 0
    for char in range(0, len(x + 1)) :
    INDENT
        if len(x) == len(y) and x [0 :] == y [0 :] :
        INDENT
            return 0
        DEDENT
        if not len(s1) == len(s2) :
        INDENT
            return 2
        DEDENT
        if len(s1) == len(s2) and not x [count] == y [count] :
        INDENT
            mismatch += 1

        DEDENT
    DEDENT
    return mismatch if mismatch < = 2 else 2
DEDENT
----------------------------------------

def find_mismatch(s1, s2) :
INDENT
    count = 0
    if len(s1) == len(s2) :
    INDENT
        for i in range(len(s1)) :
        INDENT
            if s1 [i].lower() ! = s2 [i].lower() :
            INDENT
                count += 1
            DEDENT
        DEDENT
        if count == 0 :
        INDENT
            return 0
        DEDENT
        elif count == 1 :
        INDENT
            return 1
        DEDENT
        else :
        INDENT
            return 2
        DEDENT
    DEDENT
    else :
    INDENT
        return 2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35608711_35610507_11_25
35608711_35656025_1_14
Title: Mismatched strings in Python -- how to continue process? 
----------------------------------------

def find_mismatch(string_a, string_b) :
INDENT
    if len(string_a) ! = len(string_b) :
    INDENT
        return 2
    DEDENT
    folded_a, folded_b = string_a.casefold(), string_b.casefold()
    if folded_a == folded_b :
    INDENT
        return 0
    DEDENT
    found_difference = False
    for character_a, character_b in zip(folded_a, folded_b) :
    INDENT
        if character_a ! = character_b :
        INDENT
            if found_difference :
            INDENT
                return 2
            DEDENT
            found_difference = True
        DEDENT
    DEDENT
    return 1

DEDENT
----------------------------------------

def find_mismatch(s1, s2) :
INDENT
    count = 0
    if len(s1) == len(s2) :
    INDENT
        for i in range(len(s1)) :
        INDENT
            if s1 [i].lower() ! = s2 [i].lower() :
            INDENT
                count += 1
            DEDENT
        DEDENT
        if count == 0 :
        INDENT
            return 0
        DEDENT
        elif count == 1 :
        INDENT
            return 1
        DEDENT
        else :
        INDENT
            return 2
        DEDENT
    DEDENT
    else :
    INDENT
        return 2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35608711_35610507_26_45
35608711_35656025_1_14
Title: Mismatched strings in Python -- how to continue process? 
----------------------------------------

def find_mismatch(a, b) :
INDENT
    if len(a) ! = len(b) :
    INDENT
        return 2
    DEDENT
    a, b = a.casefold(), b.casefold()
    if a == b :
    INDENT
        return 0
    DEDENT
    error = False
    for a, b in zip(a, b) :
    INDENT
        if a ! = b :
        INDENT
            if error :
            INDENT
                return 2
            DEDENT
            error = True
        DEDENT
    DEDENT
    return 1

DEDENT
----------------------------------------

def find_mismatch(s1, s2) :
INDENT
    count = 0
    if len(s1) == len(s2) :
    INDENT
        for i in range(len(s1)) :
        INDENT
            if s1 [i].lower() ! = s2 [i].lower() :
            INDENT
                count += 1
            DEDENT
        DEDENT
        if count == 0 :
        INDENT
            return 0
        DEDENT
        elif count == 1 :
        INDENT
            return 1
        DEDENT
        else :
        INDENT
            return 2
        DEDENT
    DEDENT
    else :
    INDENT
        return 2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35612901_35614796_30_38
35612901_35614796_43_51
Title: Changing between Widgets in QMainWindows central Widget 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Start, self).__init__(parent)
    layout = QHBoxLayout()
    button = QPushButton(text = QString('Push me!'))
    layout.addWidget(button)
    self.setLayout(layout)
    button.clicked.connect(self.clicked.emit)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Second, self).__init__(parent)
    layout = QHBoxLayout()
    button = QPushButton(text = QString('Back to Start!'))
    layout.addWidget(button)
    self.setLayout(layout)
    button.clicked.connect(self.clicked.emit)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35612901_35614796_30_38
35612901_35614796_8_25
Title: Changing between Widgets in QMainWindows central Widget 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Start, self).__init__(parent)
    layout = QHBoxLayout()
    button = QPushButton(text = QString('Push me!'))
    layout.addWidget(button)
    self.setLayout(layout)
    button.clicked.connect(self.clicked.emit)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QMainWindow.__init__(self, parent)
    self.central_widget = QStackedWidget()
    self.setCentralWidget(self.central_widget)
    self.start_screen = Start(self)
    self.second_screen = Second(self)
    self.central_widget.addWidget(self.start_screen)
    self.central_widget.addWidget(self.second_screen)
    self.central_widget.setCurrentWidget(self.start_screen)
    self.start_screen.clicked.connect(lambda : self.central_widget.setCurrentWidget(self.second_screen))
    self.second_screen.clicked.connect(lambda : self.central_widget.setCurrentWidget(self.start_screen))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35612901_35614796_43_51
35612901_35614796_8_25
Title: Changing between Widgets in QMainWindows central Widget 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Second, self).__init__(parent)
    layout = QHBoxLayout()
    button = QPushButton(text = QString('Back to Start!'))
    layout.addWidget(button)
    self.setLayout(layout)
    button.clicked.connect(self.clicked.emit)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QMainWindow.__init__(self, parent)
    self.central_widget = QStackedWidget()
    self.setCentralWidget(self.central_widget)
    self.start_screen = Start(self)
    self.second_screen = Second(self)
    self.central_widget.addWidget(self.start_screen)
    self.central_widget.addWidget(self.second_screen)
    self.central_widget.setCurrentWidget(self.start_screen)
    self.start_screen.clicked.connect(lambda : self.central_widget.setCurrentWidget(self.second_screen))
    self.second_screen.clicked.connect(lambda : self.central_widget.setCurrentWidget(self.start_screen))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35618557_35618641_1_7
35618557_35618670_1_12
Title: Finding the number of matching letters in two different string at the same indices 
----------------------------------------

def overlap(string1, string2) :
INDENT
    count = 0
    for i in range(min(len(string1), len(string2))) :
    INDENT
        if string1 [i] == string2 [i] :
        INDENT
            count = count + 1
        DEDENT
    DEDENT
    return count
DEDENT
----------------------------------------

def overlap(string1, string2) :
INDENT
    count = 0;
    len1 = len(string1)
    len2 = len(string2)
    smallLen = len1
    if len2 < len1 :
    INDENT
        smallLen = len2
    DEDENT
    for i in range(smallLen) :
    INDENT
        if string1 [i] == string2 [i] :
        INDENT
            count += 1
        DEDENT
    DEDENT
    return count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35648736_38505908_42_72
35648736_38505908_93_131
Title: Python - Real Time Plotting 
----------------------------------------

def __init__(self) :
INDENT
    super(CustomMainWindow, self).__init__()

    self.setGeometry(300, 300, 800, 400)
    self.setWindowTitle("my first window")

    self.FRAME_A = QtGui.QFrame(self)
    self.FRAME_A.setStyleSheet("QWidget { background-color: %s }" % QtGui.QColor(210, 210, 235, 255).name())
    self.LAYOUT_A = QtGui.QGridLayout()
    self.FRAME_A.setLayout(self.LAYOUT_A)
    self.setCentralWidget(self.FRAME_A)

    self.zoomBtn = QtGui.QPushButton(text = 'zoom')
    setCustomSize(self.zoomBtn, 100, 50)
    self.zoomBtn.clicked.connect(self.zoomBtnAction)
    self.LAYOUT_A.addWidget(self.zoomBtn, * (0, 0))

    self.myFig = CustomFigCanvas()
    self.LAYOUT_A.addWidget(self.myFig, * (0, 1))

    myDataLoop = threading.Thread(name = 'myDataLoop', target = dataSendLoop, args = (self.addData_callbackFunc,))
    myDataLoop.start()
    self.show()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.addedData = []
    print (matplotlib.__version__)
    self.xlim = 200
    self.n = np.linspace(0, self.xlim - 1, self.xlim)
    a = []
    b = []
    a.append(2.0)
    a.append(4.0)
    a.append(2.0)
    b.append(4.0)
    b.append(3.0)
    b.append(4.0)
    self.y = (self.n * 0.0) + 50

    self.fig = Figure(figsize = (5, 5), dpi = 100)
    self.ax1 = self.fig.add_subplot(111)

    self.ax1.set_xlabel('time')
    self.ax1.set_ylabel('raw data')
    self.line1 = Line2D([], [], color = 'blue')
    self.line1_tail = Line2D([], [], color = 'red', linewidth = 2)
    self.line1_head = Line2D([], [], color = 'red', marker = 'o', markeredgecolor = 'r')
    self.ax1.add_line(self.line1)
    self.ax1.add_line(self.line1_tail)
    self.ax1.add_line(self.line1_head)
    self.ax1.set_xlim(0, self.xlim - 1)
    self.ax1.set_ylim(0, 100)

    FigureCanvas.__init__(self, self.fig)
    TimedAnimation.__init__(self, self.fig, interval = 50, blit = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35649771_35650852_1_15
35649771_52112010_1_10
Title: Anagram test for two strings in python 
----------------------------------------

def anagram(a, b) :
INDENT
    str1 = list(a.lower())
    str2 = list(b.lower())

    str1.sort()
    str2.sort()

    str1 = ''.join(str1)
    str2 = ''.join(str2)
    return str1 == str2
DEDENT
----------------------------------------

def anagram(test, test1) :
INDENT
    value = ''
    for data in test :
    INDENT
        if data in test1 :
        INDENT
            value += data
        DEDENT
    DEDENT
    if len(value) == len(test1) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35654355_35655532_9_23
35654355_35655940_11_19
Title: Mocking FTP in unit test 
----------------------------------------

def test_func_happy_path(self, MockFTP, m_open) :
INDENT
    MockFTP.return_value = Mock()
    mock_ftp_obj = MockFTP()
    m_open.return_value = Mock()
    func('localhost', 'fred', 's3Kr3t')
    assert mock_ftp_obj.retrbinary.called
    assert m_open.called
    m_open.assert_called_once_with('README', 'wb')

DEDENT
----------------------------------------

def test_func_happy_path(MockFTP) :
INDENT
    mock_ftp = MockFTP.return_value
    with patch('__main__.open', mock_open(), create = True) as m :
    INDENT
        func('localhost', 'fred', 's3Kr3t')
    DEDENT
    assert mock_ftp.retrbinary.called
    m.assert_called_once_with('README', 'wb')

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35670094_35670205_7_19
35670094_35670382_1_9
Title: Sorting a file in Python 
----------------------------------------

def insertion_sort(items) :
INDENT
    for i in range(1, len(items)) :
    INDENT
        j = list [i]
        i = i - 1
        while i > = 0 :
        INDENT
            if j < list [i] :
            INDENT
                list [i + 1] = list [i]
                list [i] = j
                i = i - 1
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def insertion_sort(items) :
INDENT
    for i in range(1, len(items)) :
    INDENT
        j = i
        while j > 0 and items [j] < items [j - 1] :
        INDENT
            temp = items [j]
            items [j] = items [j - 1]
            items [j - 1] = temp
            j = j - 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
356718_356782_1_10
356718_357004_3_15
Title: How to handle constructors or methods with a different set (or type) of arguments in Python? 
----------------------------------------

def __init__(self, r = 0, g = 0, b = 0) :
INDENT
    if (type(r) == type([1, 2, 3])) :
    INDENT
        r, g, b = r [0], r [1], r [2]
    DEDENT
    if (type(r) == type(self)) :
    INDENT
        r, g, b = r.r, r.g, r.b
    DEDENT
    self.r = r
    self.g = g
    self.b = b
DEDENT
----------------------------------------

def __init__(self, ** parms) :
INDENT
    if parms.get('list') :
    INDENT
        self.r, self.g, self.b = parms ['list']
    DEDENT
    elif parms.get('color') :
    INDENT
        color = parms ['color']
        self.r = color.r
        self.g = color.g
        self.b = color.b
    DEDENT
    else :
    INDENT
        self.r = parms ['red']
        self.g = parms ['green']
        self.b = parms ['blue']
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35672827_35672914_1_9
35672827_35673336_3_14
Title: How to write a recursive function without calling for raw input more than once? 
----------------------------------------

def rawEncode(input = '', force_input = True) :
INDENT
    if force_input :
    INDENT
        input = raw_input("GIVE ME SUPER SECRET MESSAGE TO ENCODE")
    DEDENT
    if "%s" % input == '' :
    INDENT
        return ['']
    DEDENT
    else :
    INDENT
        answer = ord("%s" % input [0])
        return [answer] + rawEncode(input = input [1 :], force_input = False)
    DEDENT
DEDENT
----------------------------------------

def rawEncode(input) :
INDENT
    if TempVar == 0 :
    INDENT
        input = raw_input("GIVE ME SUPER SECRET MESSAGE TO ENCODE")
        TempVar = TempVar + 1
    DEDENT
    unencoded = "%s" % input [:]
    if "%s" % input == '' :
    INDENT
        return ''
    DEDENT
    else :
    INDENT
        answer = ord("%s" % input [0])
        return answer
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35672998_35673042_2_10
35672998_35674808_4_13
Title: Python - Put factors of a number into an array in sorted order 
----------------------------------------

def find_all_factors(n) :
INDENT
    factors = []
    for i in range(1, math.floor(math.sqrt(n)) + 1) :
    INDENT
        if n % i == 0 :
        INDENT
            bisect.insort(factors, i)
            cofactor = n / / i
            if i ! = cofactor : bisect.insort(factors, cofactor)
        DEDENT
    DEDENT
    return factors
DEDENT
----------------------------------------

def find_all_factors(n) :
INDENT
    factors = []
    for i in xrange(1, int(floor(sqrt(n))) + 1) :
    INDENT
        quotient, remainder = divmod(n, i)
        if remainder == 0 :
        INDENT
            factors.append(i)
            if quotient not in factors :
            INDENT
                factors.append(quotient)
            DEDENT
        DEDENT
    DEDENT
    return sorted(factors)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35695708_35695805_1_8
35695708_35695823_27_31
Title: Python - Is it possible to generate nodes in a loop? 
----------------------------------------

def make_nodes(n) :
INDENT
    nodes = []
    nodes.append(Node(0, None))
    for i in range(1, n) :
    INDENT
        nodes.append(Node(i, None))
        nodes [i - 1].next = nodes [i]
    DEDENT
    return nodes
DEDENT
----------------------------------------

def make_nodes(n) :
INDENT
    head_node = Node(0)
    for i in range(1, n) :
    INDENT
        new_node = Node(i)
        head_node.append_a_node(new_node)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35702010_35702274_1_10
35702010_35702278_1_15
Title: Count down and then up 
----------------------------------------

def updown(n, m) :
INDENT
    if n % 2 ! = 0 :
    INDENT
        n = n - 1
    DEDENT
    while n > = m :
    INDENT
        print (n)
        n = n - m
    DEDENT
    while n < = 7 :
    INDENT
        print (n)
        n = n + 1
    DEDENT
DEDENT
----------------------------------------

def updown(n, m) :
INDENT
    start = n

    n = m * (n / / m)
    while n > = m :
    INDENT
        print (n)
        n -= m
    DEDENT
    while n < = start :
    INDENT
        print (n)
        n += 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35702010_35702274_1_10
35702010_35702293_1_15
Title: Count down and then up 
----------------------------------------

def updown(n, m) :
INDENT
    if n % 2 ! = 0 :
    INDENT
        n = n - 1
    DEDENT
    while n > = m :
    INDENT
        print (n)
        n = n - m
    DEDENT
    while n < = 7 :
    INDENT
        print (n)
        n = n + 1
    DEDENT
DEDENT
----------------------------------------

def updown(n, m) :
INDENT
    aux = n
    while aux > 1 :
    INDENT
        print (aux - 1)
        aux = aux - m
    DEDENT
    aux = 0
    while aux < = n :
    INDENT
        print (aux)
        aux = aux + 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35702010_35702274_1_10
35702010_35702613_1_6
Title: Count down and then up 
----------------------------------------

def updown(n, m) :
INDENT
    if n % 2 ! = 0 :
    INDENT
        n = n - 1
    DEDENT
    while n > = m :
    INDENT
        print (n)
        n = n - m
    DEDENT
    while n < = 7 :
    INDENT
        print (n)
        n = n + 1
    DEDENT
DEDENT
----------------------------------------

def updown(n, m = 2) :
INDENT
    if n % 2 == 0 :
    INDENT
        updownhelper(- n, n, m)
    DEDENT
    else :
    INDENT
        updownhelper(- (n - 1), n, m)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35702010_35702278_1_15
35702010_35702293_1_15
Title: Count down and then up 
----------------------------------------

def updown(n, m) :
INDENT
    start = n

    n = m * (n / / m)
    while n > = m :
    INDENT
        print (n)
        n -= m
    DEDENT
    while n < = start :
    INDENT
        print (n)
        n += 1

    DEDENT
DEDENT
----------------------------------------

def updown(n, m) :
INDENT
    aux = n
    while aux > 1 :
    INDENT
        print (aux - 1)
        aux = aux - m
    DEDENT
    aux = 0
    while aux < = n :
    INDENT
        print (aux)
        aux = aux + 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35702010_35702278_1_15
35702010_35702613_1_6
Title: Count down and then up 
----------------------------------------

def updown(n, m) :
INDENT
    start = n

    n = m * (n / / m)
    while n > = m :
    INDENT
        print (n)
        n -= m
    DEDENT
    while n < = start :
    INDENT
        print (n)
        n += 1

    DEDENT
DEDENT
----------------------------------------

def updown(n, m = 2) :
INDENT
    if n % 2 == 0 :
    INDENT
        updownhelper(- n, n, m)
    DEDENT
    else :
    INDENT
        updownhelper(- (n - 1), n, m)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35702010_35702293_1_15
35702010_35702613_1_6
Title: Count down and then up 
----------------------------------------

def updown(n, m) :
INDENT
    aux = n
    while aux > 1 :
    INDENT
        print (aux - 1)
        aux = aux - m
    DEDENT
    aux = 0
    while aux < = n :
    INDENT
        print (aux)
        aux = aux + 1
    DEDENT
DEDENT
----------------------------------------

def updown(n, m = 2) :
INDENT
    if n % 2 == 0 :
    INDENT
        updownhelper(- n, n, m)
    DEDENT
    else :
    INDENT
        updownhelper(- (n - 1), n, m)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35710361_35716619_10_21
35710361_45111660_2_21
Title: Python Flask send_file StringIO blank files 
----------------------------------------

def test_download() :
INDENT
    buffer = BytesIO()
    buffer.write(b'jJust some letters.')

    buffer.seek(0)
    return send_file(buffer, as_attachment = True,
        attachment_filename = 'a_file.txt',
        mimetype = 'text/csv')

DEDENT
----------------------------------------

def test_download() :
INDENT
    row = ['hello', 'world']
    proxy = io.StringIO()
    writer = csv.writer(proxy)
    writer.writerow(row)

    mem = io.BytesIO()
    mem.write(proxy.getvalue().encode('utf-8'))
    mem.seek(0)
    proxy.close(0)
    return send_file(
        mem,
        as_attachment = True,
        attachment_filename = 'test.csv',
        mimetype = 'text/csv')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35723207_36118707_128_143
35723207_36118707_22_49
Title: How does one create a metaclass? 
----------------------------------------

def __new__(cls, function) :
INDENT
    cls.extra = function
    print "================================================================"
    print " Class' __new__ (\"creates\" instance objects)"
    print "----------------------------------------------------------------"
    print "Bounded to object: " + str(cls)
    print "Bounded object's __dict__: "
    pprint(DictType(cls.__dict__), depth = 1)
    print "----------------------------------------------------------------"
    print "Parameter 'function': \n" + str(function)
    print "\n"
    return super(Factory, cls).__new__(cls)
DEDENT
----------------------------------------

def __new__(meta, name, bases, dict) :
INDENT
    dict ['new_elem'] = "effective"
    meta.var = "Change made to %s by metaclass' __new__" % str(meta)
    meta.count += 1
    print "================================================================"
    print " Metaclass's __new__ (creates class objects)"
    print "----------------------------------------------------------------"
    print "Bounded to object: " + str(meta)
    print "Bounded object's __dict__: "
    pprint(DictType(meta.__dict__), depth = 1)
    print "----------------------------------------------------------------"
    print "Parameter 'name': " + str(name)
    print "Parameter 'bases': " + str(bases)
    print "Parameter 'dict': "
    pprint(dict, depth = 1)
    print "\n"
    return super(FactoryMeta, meta).__new__(meta, name, bases, dict)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35723207_36118707_144_166
35723207_36118707_50_71
Title: How does one create a metaclass? 
----------------------------------------

def __init__(self, function, * args, ** kwargs) :
INDENT
    self.classFactory = self.__class__.classFactory
    print "================================================================"
    print " Class' __init__ (initiates instance objects)"
    print "----------------------------------------------------------------"
    print "Bounded to object: " + str(self)
    print "Bounded object's __dict__: "
    pprint(DictType(self.__dict__), depth = 1)
    print "----------------------------------------------------------------"
    print "Parameter 'function': \n" + str(function)
    print "\n"
    return super(Factory, self).__init__(* args, ** kwargs)

DEDENT
----------------------------------------

def __init__(cls, name, bases, dict) :
INDENT
    dict ['init_elem'] = "defective"
    cls.var = "Change made to %s by metaclass' __init__" % str(cls)
    print "================================================================"
    print " Metaclass's __init__ (initiates class objects)"
    print "----------------------------------------------------------------"
    print "Bounded to object: " + str(cls)
    print "Bounded object's __dict__: "
    pprint(DictType(cls.__dict__), depth = 1)
    print "----------------------------------------------------------------"
    print "Parameter 'name': " + str(name)
    print "Parameter 'bases': " + str(bases)
    print "Parameter 'dict': "
    pprint(dict, depth = 1)
    print "\n"
    return super(FactoryMeta, cls).__init__(name, bases, dict)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35734795_35735613_30_42
35734795_35735613_4_18
Title: How to keep values in Entry Widget after I wrote them for furthers lookback 
----------------------------------------

def __init__(self, master, var) :
INDENT
    self.master = master
    self.var = var
    self.inputframe = tk.Frame(self.master)
    self.inputframe.pack()
    self.stuffinput = tk.Entry(self.inputframe, textvariable = self.var)
    self.stuffinput.pack()
    self.okbutton = tk.Button(self.inputframe, text = "Ok", command = self.inputok)
    self.okbutton.pack(side = "right", padx = 5, pady = 10)
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.mainframe = tk.Frame(self.master)
    self.mainframe.pack()

    self.inputVar = tk.DoubleVar()
    self.sinputbutton = tk.Button(self.mainframe, text = "INPUT", command = self.openinput)
    self.sinputbutton.pack()

    self.displaybutton = tk.Button(self.mainframe, text = "Display", command = self.display)
    self.displaybutton.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35754307_35754839_1_15
35754307_35755047_7_29
Title: How do I access a local variable in my decorated function from my decorator 
----------------------------------------

def validate(schema, arg_pos) :
INDENT
    def decorator(method) :
    INDENT
        @ functools.wraps(method)
        def f(* args, ** kwargs) :
        INDENT
            args = args [: arg_pos] + (validate_schema(schema, args [arg_pos]),) + args [arg_pos + 1 :]

            return method(* args, ** kwargs)
        DEDENT
        return f
    DEDENT
    return decorator
DEDENT
----------------------------------------

def validate(schema) :
INDENT
    def my_decorator(func) :
    INDENT
        @ wraps(func)
        def wrapper(* args, ** kwargs) :
        INDENT
            _backup, _check = None, False
            if 'valid_json' in func.func_globals :
            INDENT
                _backup, _check = func.func_globals ['valid_json'], True
            DEDENT
            valid_json = {'hi' : 'mom'}
            func.func_globals ['valid_json'] = valid_json
            output = func(* args, ** kwargs)
            if _check :
            INDENT
                func.func_globals ['valid_json'] = _backup
            DEDENT
            else :
            INDENT
                del func.func_globals ['valid_json']

            DEDENT
            return output
        DEDENT
        return wrapper
    DEDENT
    return my_decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35786068_35786277_1_19
35786068_35786576_1_25
Title: IF-ELIF statements nested 
----------------------------------------

def call_back(self) :
INDENT
    show = tkMessageBox.showinfo
    if not self.text_n.get() :
    INDENT
        show("Mandatory Information", "Please input an integer value for Number of Tessellations Cells")
    DEDENT
    elif not self.text_id.get() :
    INDENT
        show("Mandatory Information", "Please input an integer value for Tessellation Identifier")
    DEDENT
    elif not domain_container :
    INDENT
        show("Mandatory Information", "Please input Domain")
    DEDENT
    elif self.text_fmax.get() and not 0 < = int(self.text_fmax.get()) < = 180 :
    INDENT
        show("Incorrect Value", "Face Flatness should be less than 180")
    DEDENT
    elif not filename4 :
    INDENT
        show("Mandatory Information", "Please input Output File Name")
    DEDENT
    else :
    INDENT
        self.execute_neper_code()
    DEDENT
DEDENT
----------------------------------------

def call_back(self) :
INDENT
    t_msgs = {"mdt" : "Mandatory Information",
        "incrt_val" : "Incorrect Value"}
    checkFields = {(self.text_n, 0) :
        (t_msgs ["mdt"],
            "Please input an integer value for Number of Tessellations Cells"),
        (self.text_id, 0) :
        (t_msgs ["mdt"],
            "Please input an integer value for Tessellation Identifier"),
        (domain_container, 0) :
        (t_msgs ["mdt"],
            "Please input Domain"),
        (self.text_fmax, range(0, 181, 180)) :
        (t_msgs ["incrt_val"],
            "Face Flatness should be less than 180"),
        (len(filename4), 0) :
        (t_msgs ["mdt"],
            "Please input Output File Name")}
    for field in checkFields :
    INDENT
        if not field [1] :
        INDENT
            tkMessageBox.showinfo(checkFields [field] [0], checkFields [field] [1])
        DEDENT
        else :
        INDENT
            if not (field [1] [0] < field [0].get() < field [1] [1]) :
            INDENT
                tkMessageBox.showinfo(checkFields [field [0]], checkFields [field] [1])
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35790276_35790496_1_17
35790276_35790799_1_10
Title: Replacing characters from string one to string two 
----------------------------------------

def replace(char, word1, word2) :
INDENT
    newWord = ""
    word2List = list(word2)

    if char not in word1 or len(word1) ! = len(word2) :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        for i, c in enumerate(word1) :
        INDENT
            if c == char :
            INDENT
                word2List [i] = c

            DEDENT
        DEDENT
    DEDENT
    return ''.join(word2List)
DEDENT
----------------------------------------

def replace(char, word1, word2) :
INDENT
    new_word = ""
    for i in range(len(word2)) :
    INDENT
        if word1 [i] == char :
        INDENT
            new_word += char
        DEDENT
        else :
        INDENT
            new_word += word2 [i]
        DEDENT
    DEDENT
    return new_word

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35797708_35798778_105_122
35797708_35798778_127_140
Title: Python/Tkinter- Problems with calling variables from another class and plot graph 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.actionframe = tk.Frame(self.master)
    self.actionforce = tk.Label(self.actionframe, text = "Nodal Force [kN]")
    self.actionforce.pack()
    self.actionforceinpute = tk.Entry(self.actionframe, textvariable = tk.DoubleVar)
    self.actionforceinpute.pack()
    self.actionforcedistance = tk.Label(self.actionframe, text = "Node distance [m]")
    self.actionforcedistance.pack()
    self.actionforcedistanceinpute = tk.Entry(self.actionframe, textvariable = tk.DoubleVar)
    self.actionforcedistanceinpute.pack()
    self.linearload = tk.Label(self.actionframe, text = "Linear Load [kN/m]")
    self.linearload.pack()
    self.linearloadinpute = tk.Entry(self.actionframe, textvariable = tk.DoubleVar)
    self.linearloadinpute.pack()
    self.actionexitbutton = tk.Button(self.actionframe, text = "Ok", command = self.actionexit)
    self.actionexitbutton.pack(side = "right", padx = 5, pady = 10)
    self.actionframe.pack()
DEDENT
----------------------------------------

def __init__(self, mainwin) :
INDENT
    self.f = mainwin.action.actionforceinpute.get()
    self.df = mainwin.action.actionforcedistanceinpute.get()
    self.E = mainwin.beam.beamstiffnessinpute.get()
    self.J = mainwin.beam.beaminertiainpute.get()
    self.B = mainwin.beam.beambaseinpute.get()
    self.Et = mainwin.soil.soilstiffnessinpute.get()
    self.Hdef = mainwin.soil.deflayerinpute.get()
    self.v = mainwin.soil.poissonratioinpute.get()
    self.L = mainwin.glinpute.get()
    self.l = mainwin.gl2inpute.get()
    print ("ok!")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35797708_35798778_105_122
35797708_35798778_4_47
Title: Python/Tkinter- Problems with calling variables from another class and plot graph 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.actionframe = tk.Frame(self.master)
    self.actionforce = tk.Label(self.actionframe, text = "Nodal Force [kN]")
    self.actionforce.pack()
    self.actionforceinpute = tk.Entry(self.actionframe, textvariable = tk.DoubleVar)
    self.actionforceinpute.pack()
    self.actionforcedistance = tk.Label(self.actionframe, text = "Node distance [m]")
    self.actionforcedistance.pack()
    self.actionforcedistanceinpute = tk.Entry(self.actionframe, textvariable = tk.DoubleVar)
    self.actionforcedistanceinpute.pack()
    self.linearload = tk.Label(self.actionframe, text = "Linear Load [kN/m]")
    self.linearload.pack()
    self.linearloadinpute = tk.Entry(self.actionframe, textvariable = tk.DoubleVar)
    self.linearloadinpute.pack()
    self.actionexitbutton = tk.Button(self.actionframe, text = "Ok", command = self.actionexit)
    self.actionexitbutton.pack(side = "right", padx = 5, pady = 10)
    self.actionframe.pack()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.mainframe = tk.LabelFrame(self.master, text = "INPUT")
    self.outputframe = tk.LabelFrame(self.master, text = "OUTPUT")
    self.sinputbutton = tk.Button(self.mainframe, text = "Soil INPUT", command = self.opensoilinput)
    self.sinputbutton.pack()

    self.binputbutton = tk.Button(self.mainframe, text = "Beam INPUT", compound = "top", command = self.openbeaminput)
    self.binputbutton.pack()
    self.actinputbutton = tk.Button(self.mainframe, text = "Actions INPUT", command = self.openactioninput)
    self.actinputbutton.pack()
    self.glabel = tk.Label(self.mainframe, text = "Beam leinght [m]")
    self.glabel.pack()
    self.glinpute = tk.Entry(self.mainframe, textvariable = tk.DoubleVar)
    self.glinpute.pack()
    self.g2label = tk.Label(self.mainframe, text = "Strip leinght [m]")
    self.g2label.pack()
    self.gl2inpute = tk.Entry(self.mainframe, textvariable = tk.DoubleVar)
    self.gl2inpute.pack()
    self.runbutton = tk.Button(self.outputframe, text = "RUN", command = self.runkoenig)
    self.runbutton.pack(side = "bottom")
    self.plotbutton = tk.Button(self.outputframe, text = "Plot", command = self.plotaction)
    self.plotbutton.pack()
    self.canvplot = tk.Canvas(self.outputframe, width = 800, height = 600, bg = "#60B7FF")
    self.canvplot.pack()
    self.mainframe.pack()
    self.outputframe.pack()
    self.soilwindow = tk.Toplevel(self.master)
    self.soilwindow.title("Soil INPUT")
    self.soil = Soilinput(self.soilwindow)
    self.soilwindow.withdraw()
    self.beamwindow = tk.Toplevel(self.master)
    self.beamwindow.title("Beam INPUT")
    self.beam = Beaminput(self.beamwindow)
    self.beamwindow.withdraw()
    self.actionwindow = tk.Toplevel(self.master)
    self.actionwindow.title("Actions INPUT")
    self.action = Actioninput(self.actionwindow)
    self.actionwindow.withdraw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35797708_35798778_127_140
35797708_35798778_4_47
Title: Python/Tkinter- Problems with calling variables from another class and plot graph 
----------------------------------------

def __init__(self, mainwin) :
INDENT
    self.f = mainwin.action.actionforceinpute.get()
    self.df = mainwin.action.actionforcedistanceinpute.get()
    self.E = mainwin.beam.beamstiffnessinpute.get()
    self.J = mainwin.beam.beaminertiainpute.get()
    self.B = mainwin.beam.beambaseinpute.get()
    self.Et = mainwin.soil.soilstiffnessinpute.get()
    self.Hdef = mainwin.soil.deflayerinpute.get()
    self.v = mainwin.soil.poissonratioinpute.get()
    self.L = mainwin.glinpute.get()
    self.l = mainwin.gl2inpute.get()
    print ("ok!")
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.mainframe = tk.LabelFrame(self.master, text = "INPUT")
    self.outputframe = tk.LabelFrame(self.master, text = "OUTPUT")
    self.sinputbutton = tk.Button(self.mainframe, text = "Soil INPUT", command = self.opensoilinput)
    self.sinputbutton.pack()

    self.binputbutton = tk.Button(self.mainframe, text = "Beam INPUT", compound = "top", command = self.openbeaminput)
    self.binputbutton.pack()
    self.actinputbutton = tk.Button(self.mainframe, text = "Actions INPUT", command = self.openactioninput)
    self.actinputbutton.pack()
    self.glabel = tk.Label(self.mainframe, text = "Beam leinght [m]")
    self.glabel.pack()
    self.glinpute = tk.Entry(self.mainframe, textvariable = tk.DoubleVar)
    self.glinpute.pack()
    self.g2label = tk.Label(self.mainframe, text = "Strip leinght [m]")
    self.g2label.pack()
    self.gl2inpute = tk.Entry(self.mainframe, textvariable = tk.DoubleVar)
    self.gl2inpute.pack()
    self.runbutton = tk.Button(self.outputframe, text = "RUN", command = self.runkoenig)
    self.runbutton.pack(side = "bottom")
    self.plotbutton = tk.Button(self.outputframe, text = "Plot", command = self.plotaction)
    self.plotbutton.pack()
    self.canvplot = tk.Canvas(self.outputframe, width = 800, height = 600, bg = "#60B7FF")
    self.canvplot.pack()
    self.mainframe.pack()
    self.outputframe.pack()
    self.soilwindow = tk.Toplevel(self.master)
    self.soilwindow.title("Soil INPUT")
    self.soil = Soilinput(self.soilwindow)
    self.soilwindow.withdraw()
    self.beamwindow = tk.Toplevel(self.master)
    self.beamwindow.title("Beam INPUT")
    self.beam = Beaminput(self.beamwindow)
    self.beamwindow.withdraw()
    self.actionwindow = tk.Toplevel(self.master)
    self.actionwindow.title("Actions INPUT")
    self.action = Actioninput(self.actionwindow)
    self.actionwindow.withdraw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35797708_35798778_127_140
35797708_35798778_61_78
Title: Python/Tkinter- Problems with calling variables from another class and plot graph 
----------------------------------------

def __init__(self, mainwin) :
INDENT
    self.f = mainwin.action.actionforceinpute.get()
    self.df = mainwin.action.actionforcedistanceinpute.get()
    self.E = mainwin.beam.beamstiffnessinpute.get()
    self.J = mainwin.beam.beaminertiainpute.get()
    self.B = mainwin.beam.beambaseinpute.get()
    self.Et = mainwin.soil.soilstiffnessinpute.get()
    self.Hdef = mainwin.soil.deflayerinpute.get()
    self.v = mainwin.soil.poissonratioinpute.get()
    self.L = mainwin.glinpute.get()
    self.l = mainwin.gl2inpute.get()
    print ("ok!")
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.soilframe = tk.Frame(self.master)
    self.soilstiffness = tk.Label(self.soilframe, text = "Soil stiffness [kPa]")
    self.soilstiffness.pack()
    self.soilstiffnessinpute = tk.Entry(self.soilframe, textvariable = tk.DoubleVar)
    self.soilstiffnessinpute.pack()
    self.deflayer = tk.Label(self.soilframe, text = "Deformable layer [m]")
    self.deflayer.pack()
    self.deflayerinpute = tk.Entry(self.soilframe, textvariable = tk.DoubleVar)
    self.deflayerinpute.pack()
    self.poissonratio = tk.Label(self.soilframe, text = "Poisson ratio v")
    self.poissonratio.pack()
    self.poissonratioinpute = tk.Entry(self.soilframe, textvariable = tk.DoubleVar)
    self.poissonratioinpute.pack()
    self.soilbutton = tk.Button(self.soilframe, text = "Ok", command = self.soilinputquit)
    self.soilbutton.pack(side = "right", padx = 5, pady = 10)
    self.soilframe.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35797708_35798778_127_140
35797708_35798778_83_100
Title: Python/Tkinter- Problems with calling variables from another class and plot graph 
----------------------------------------

def __init__(self, mainwin) :
INDENT
    self.f = mainwin.action.actionforceinpute.get()
    self.df = mainwin.action.actionforcedistanceinpute.get()
    self.E = mainwin.beam.beamstiffnessinpute.get()
    self.J = mainwin.beam.beaminertiainpute.get()
    self.B = mainwin.beam.beambaseinpute.get()
    self.Et = mainwin.soil.soilstiffnessinpute.get()
    self.Hdef = mainwin.soil.deflayerinpute.get()
    self.v = mainwin.soil.poissonratioinpute.get()
    self.L = mainwin.glinpute.get()
    self.l = mainwin.gl2inpute.get()
    print ("ok!")
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.beamframe = tk.Frame(self.master)
    self.beamstiffness = tk.Label(self.beamframe, text = "Beam stiffness [kPa]")
    self.beamstiffness.pack()
    self.beamstiffnessinpute = tk.Entry(self.beamframe, textvariable = tk.DoubleVar)
    self.beamstiffnessinpute.pack()
    self.beaminertia = tk.Label(self.beamframe, text = "Beam inertia [kPa]")
    self.beaminertia.pack()
    self.beaminertiainpute = tk.Entry(self.beamframe, textvariable = tk.DoubleVar)
    self.beaminertiainpute.pack()
    self.beambase = tk.Label(self.beamframe, text = "Beam base [m]")
    self.beambase.pack()
    self.beambaseinpute = tk.Entry(self.beamframe, textvariable = tk.DoubleVar)
    self.beambaseinpute.pack()
    self.beamexitbutton = tk.Button(self.beamframe, text = "Ok", command = self.beamexit)
    self.beamexitbutton.pack(side = "right", padx = 5, pady = 10)
    self.beamframe.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35797708_35798778_4_47
35797708_35798778_61_78
Title: Python/Tkinter- Problems with calling variables from another class and plot graph 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.mainframe = tk.LabelFrame(self.master, text = "INPUT")
    self.outputframe = tk.LabelFrame(self.master, text = "OUTPUT")
    self.sinputbutton = tk.Button(self.mainframe, text = "Soil INPUT", command = self.opensoilinput)
    self.sinputbutton.pack()

    self.binputbutton = tk.Button(self.mainframe, text = "Beam INPUT", compound = "top", command = self.openbeaminput)
    self.binputbutton.pack()
    self.actinputbutton = tk.Button(self.mainframe, text = "Actions INPUT", command = self.openactioninput)
    self.actinputbutton.pack()
    self.glabel = tk.Label(self.mainframe, text = "Beam leinght [m]")
    self.glabel.pack()
    self.glinpute = tk.Entry(self.mainframe, textvariable = tk.DoubleVar)
    self.glinpute.pack()
    self.g2label = tk.Label(self.mainframe, text = "Strip leinght [m]")
    self.g2label.pack()
    self.gl2inpute = tk.Entry(self.mainframe, textvariable = tk.DoubleVar)
    self.gl2inpute.pack()
    self.runbutton = tk.Button(self.outputframe, text = "RUN", command = self.runkoenig)
    self.runbutton.pack(side = "bottom")
    self.plotbutton = tk.Button(self.outputframe, text = "Plot", command = self.plotaction)
    self.plotbutton.pack()
    self.canvplot = tk.Canvas(self.outputframe, width = 800, height = 600, bg = "#60B7FF")
    self.canvplot.pack()
    self.mainframe.pack()
    self.outputframe.pack()
    self.soilwindow = tk.Toplevel(self.master)
    self.soilwindow.title("Soil INPUT")
    self.soil = Soilinput(self.soilwindow)
    self.soilwindow.withdraw()
    self.beamwindow = tk.Toplevel(self.master)
    self.beamwindow.title("Beam INPUT")
    self.beam = Beaminput(self.beamwindow)
    self.beamwindow.withdraw()
    self.actionwindow = tk.Toplevel(self.master)
    self.actionwindow.title("Actions INPUT")
    self.action = Actioninput(self.actionwindow)
    self.actionwindow.withdraw()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.soilframe = tk.Frame(self.master)
    self.soilstiffness = tk.Label(self.soilframe, text = "Soil stiffness [kPa]")
    self.soilstiffness.pack()
    self.soilstiffnessinpute = tk.Entry(self.soilframe, textvariable = tk.DoubleVar)
    self.soilstiffnessinpute.pack()
    self.deflayer = tk.Label(self.soilframe, text = "Deformable layer [m]")
    self.deflayer.pack()
    self.deflayerinpute = tk.Entry(self.soilframe, textvariable = tk.DoubleVar)
    self.deflayerinpute.pack()
    self.poissonratio = tk.Label(self.soilframe, text = "Poisson ratio v")
    self.poissonratio.pack()
    self.poissonratioinpute = tk.Entry(self.soilframe, textvariable = tk.DoubleVar)
    self.poissonratioinpute.pack()
    self.soilbutton = tk.Button(self.soilframe, text = "Ok", command = self.soilinputquit)
    self.soilbutton.pack(side = "right", padx = 5, pady = 10)
    self.soilframe.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35797708_35798778_4_47
35797708_35798778_83_100
Title: Python/Tkinter- Problems with calling variables from another class and plot graph 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.mainframe = tk.LabelFrame(self.master, text = "INPUT")
    self.outputframe = tk.LabelFrame(self.master, text = "OUTPUT")
    self.sinputbutton = tk.Button(self.mainframe, text = "Soil INPUT", command = self.opensoilinput)
    self.sinputbutton.pack()

    self.binputbutton = tk.Button(self.mainframe, text = "Beam INPUT", compound = "top", command = self.openbeaminput)
    self.binputbutton.pack()
    self.actinputbutton = tk.Button(self.mainframe, text = "Actions INPUT", command = self.openactioninput)
    self.actinputbutton.pack()
    self.glabel = tk.Label(self.mainframe, text = "Beam leinght [m]")
    self.glabel.pack()
    self.glinpute = tk.Entry(self.mainframe, textvariable = tk.DoubleVar)
    self.glinpute.pack()
    self.g2label = tk.Label(self.mainframe, text = "Strip leinght [m]")
    self.g2label.pack()
    self.gl2inpute = tk.Entry(self.mainframe, textvariable = tk.DoubleVar)
    self.gl2inpute.pack()
    self.runbutton = tk.Button(self.outputframe, text = "RUN", command = self.runkoenig)
    self.runbutton.pack(side = "bottom")
    self.plotbutton = tk.Button(self.outputframe, text = "Plot", command = self.plotaction)
    self.plotbutton.pack()
    self.canvplot = tk.Canvas(self.outputframe, width = 800, height = 600, bg = "#60B7FF")
    self.canvplot.pack()
    self.mainframe.pack()
    self.outputframe.pack()
    self.soilwindow = tk.Toplevel(self.master)
    self.soilwindow.title("Soil INPUT")
    self.soil = Soilinput(self.soilwindow)
    self.soilwindow.withdraw()
    self.beamwindow = tk.Toplevel(self.master)
    self.beamwindow.title("Beam INPUT")
    self.beam = Beaminput(self.beamwindow)
    self.beamwindow.withdraw()
    self.actionwindow = tk.Toplevel(self.master)
    self.actionwindow.title("Actions INPUT")
    self.action = Actioninput(self.actionwindow)
    self.actionwindow.withdraw()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.beamframe = tk.Frame(self.master)
    self.beamstiffness = tk.Label(self.beamframe, text = "Beam stiffness [kPa]")
    self.beamstiffness.pack()
    self.beamstiffnessinpute = tk.Entry(self.beamframe, textvariable = tk.DoubleVar)
    self.beamstiffnessinpute.pack()
    self.beaminertia = tk.Label(self.beamframe, text = "Beam inertia [kPa]")
    self.beaminertia.pack()
    self.beaminertiainpute = tk.Entry(self.beamframe, textvariable = tk.DoubleVar)
    self.beaminertiainpute.pack()
    self.beambase = tk.Label(self.beamframe, text = "Beam base [m]")
    self.beambase.pack()
    self.beambaseinpute = tk.Entry(self.beamframe, textvariable = tk.DoubleVar)
    self.beambaseinpute.pack()
    self.beamexitbutton = tk.Button(self.beamframe, text = "Ok", command = self.beamexit)
    self.beamexitbutton.pack(side = "right", padx = 5, pady = 10)
    self.beamframe.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35812703_35813433_1_14
35812703_35813685_1_12
Title: Only accept a float between 0 and 1 - python 
----------------------------------------

def user_input() :
INDENT
    while True :
    INDENT
        initial_input = input("Please enter a number between 1 and 0").strip()
        if "." in initial_input or initial_input.isnumeric() :
        INDENT
            initial_input = float(initial_input)
            if 0 < = initial_input < = 1 :
            INDENT
                print ("Thank you.")
                return initial_input
            DEDENT
            else :
            INDENT
                print ("Please try again, it must be a number between 0 and 1")
            DEDENT
        DEDENT
        else :
        INDENT
            print ("Input MUST be a number!")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def user_input() :
INDENT
    while True :
    INDENT
        try :
        INDENT

            initial_input = float(input("Please enter a number between 1 and 0"))
            if 0 < = initial_input < = 1 :
            INDENT
                return (initial_input)
            DEDENT
            print ("Please try again, it must be a number between 0 and 1")
        DEDENT
        except ValueError :
        INDENT
            print ("Input must be numeric.")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35817170_35817214_1_17
35817170_35817498_1_11
Title: Iterating List of lists- Return only one list out of four lists 
----------------------------------------

def list_list(x, y) :
INDENT
    z = zip(x, y)
    l = [list(x) for x in z]
    returnlist = []
    print (l)
    for el in l :
    INDENT
        print (el)
        if el [0] > = 60 or el [1] > = 60 :
        INDENT
            el.append('pass')
            returnlist.append(el)
        DEDENT
        else :
        INDENT
            el.append('fail')
            returnlist.append(el)
        DEDENT
    DEDENT
    return returnlist

DEDENT
----------------------------------------

def list_list(x, y) :
INDENT
    for a, b in zip(x, y) :
    INDENT
        if a > = 60 or b > = 60 :
        INDENT
            word = 'pass'
        DEDENT
        else :
        INDENT
            word = 'fail'

        DEDENT
        yield [a, b, word]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35818327_36003372_121_134
35818327_36003372_252_258
Title: How to effiiciently rebuild pandas hdfstore table when append fails 
----------------------------------------

def put(self, df) :
INDENT
    if len(df) == 0 :
    INDENT
        warnings.warn('An empty DataFrame was passed to put(). Continuing.')
        return
    DEDENT
    frame_no = df [self.t_column].values [0]
    key = code_key(frame_no)

    try :
    INDENT
        self.store.remove(key)
    DEDENT
    except KeyError :
    INDENT
        pass
    DEDENT
    self.store.put(key, df, format = 'table')
DEDENT
----------------------------------------

def put(self, df) :
INDENT
    if len(df) == 0 :
    INDENT
        warnings.warn('An empty DataFrame was passed to put(). Continuing.')
        return
    DEDENT
    self._validate(df)
    self.store.append(self.key, df, data_columns = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35818327_36003372_264_280
35818327_36003372_45_60
Title: How to effiiciently rebuild pandas hdfstore table when append fails 
----------------------------------------

def dump(self, N = None) :
INDENT
    if N is None :
    INDENT
        return self.store.select(self.key)
    DEDENT
    else :
    INDENT
        Nth_frame = self.frames [N - 1]
        return self.store.select(self.key, '{0} <= {1}'.format(
                self._t_column, Nth_frame))
    DEDENT
DEDENT
----------------------------------------

def dump(self, N = None) :
INDENT
    if N is None :
    INDENT
        return pd.concat(iter(self))
    DEDENT
    else :
    INDENT
        i = iter(self)
        return pd.concat((next(i) for _ in range(N)))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3582696_3583576_38_48
3582696_3583576_5_25
Title: How to add items to wx.ScrolledPanel? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    openDlg_btn = wx.Button(self, label = "Open Dialog")
    self.Bind(wx.EVT_BUTTON, self.onBtn)
    mainSizer = wx.BoxSizer(wx.HORIZONTAL)
    mainSizer.Add(openDlg_btn, 0, wx.ALL, 10)
    self.SetSizerAndFit(mainSizer)
    self.Centre()
DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Dialog.__init__(self, parent = parent, title = title, size = wx.DefaultSize)
    self.scrollPnl = scrolled.ScrolledPanel(self, - 1, size = (200, 200), style = wx.TAB_TRAVERSAL | wx.SUNKEN_BORDER)
    self.addBtn = wx.Button(self, id = wx.ID_ADD)
    self.Bind(wx.EVT_BUTTON, self.on_add, self.addBtn)
    self.mainSizer = wx.BoxSizer(wx.VERTICAL)
    self.scrollPnlSizer = wx.BoxSizer(wx.VERTICAL)
    img = wx.Image("image.jpg", wx.BITMAP_TYPE_ANY)
    staticBitmap = wx.StaticBitmap(self.scrollPnl, wx.ID_ANY, wx.BitmapFromImage(img))
    self.scrollPnlSizer.Add(staticBitmap, 1, wx.EXPAND | wx.ALL, 3)
    self.mainSizer.Add(self.addBtn)
    self.mainSizer.Add(self.scrollPnl)
    self.SetSizerAndFit(self.mainSizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35829198_35829485_6_31
35829198_35831474_1_29
Title: Find a word in a crossword 
----------------------------------------

def capitalize_word_in_crossword(crosswords, words) :
INDENT
    for rownum, row in enumerate(crosswords) :
    INDENT
        word_index = 0
        for word in words :
        INDENT
            find_index = ''.join(row).lower().find(word)
            if find_index > 0 :
            INDENT
                for i in range(find_index, len(word) + 1) :
                INDENT
                    crosswords [rownum] [i] = crosswords [rownum] [i].upper()
                DEDENT
                if not horizontal_match_found [word_index] :
                INDENT
                    horizontal_match_found [word_index] = True
                DEDENT
            DEDENT
            word_index += 1
        DEDENT
    DEDENT
    for colindex in range(len(crosswords [0])) :
    INDENT
        word_index = 0
        for word in words :
        INDENT
            if not horizontal_match_found [word_index] :
            INDENT
                colvalues = [row [colindex] for row in crosswords]
                find_index = ''.join(colvalues).lower().find(word)
                if find_index > 0 :
                INDENT
                    for i in range(find_index, len(word) + 1) :
                    INDENT
                        crosswords [i] [colindex] = crosswords [i] [colindex].upper()
                    DEDENT
                DEDENT
            DEDENT
            word_index += 1
        DEDENT
    DEDENT
    return crosswords
DEDENT
----------------------------------------

def capitalize_word_in_crossword(crosswords, word) :
INDENT
    i_v = - 1
    j_v = - 1
    i_h = - 1
    j_h = - 1
    index_cap = find_word_horizontal(crosswords, word)
    if index_cap is not None :
    INDENT
        i_h, j_h = index_cap
    DEDENT
    else :
    INDENT
        index_cap = find_word_vertical(crosswords, word)
        if index_cap is not None :
        INDENT
            i_v, j_v = index_cap

        DEDENT
    DEDENT
    for row_index in range(len(crosswords)) :
    INDENT
        for col_index in range(len(crosswords [row_index])) :
        INDENT
            for w in range(len(word)) :
            INDENT
                if i_h is not - 1 :
                INDENT
                    if row_index == i_h and col_index == j_h + w :
                    INDENT
                        crosswords [row_index] [col_index] = (crosswords [row_index] [col_index]).upper()
                    DEDENT
                DEDENT
                if i_v is not - 1 :
                INDENT
                    if row_index == i_v + w and col_index == j_v :
                    INDENT
                        crosswords [row_index] [col_index] = (crosswords [row_index] [col_index]).upper()
                    DEDENT
                    else :
                    INDENT
                        crosswords [row_index] [col_index] = (crosswords [row_index] [col_index])
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return (crosswords)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35831412_35835873_4_21
35831412_35836434_3_22
Title: Generating random lists in Python query 
----------------------------------------

def Shuffler() :
INDENT
    try :
    INDENT
        amount = input("Numbers up to: ")
        p = list(permutations(range(1, amount + 1), 2))
        p_uniq = [list(x) for x in p if x [: : - 1] in p and x [0] < = x [1]]
        shuf_max = len(p_uniq) / (amount / 2)
        times = shuf_max + 1
        while times > shuf_max :
        INDENT
            shuffle(p_uniq)
            times = input("Number of shuffles (MAX %s): " % (shuf_max))
        DEDENT
        else :
        INDENT
            for i, group in enumerate(list(zip(* [iter(p_uniq [: (amount / 2) * times + 1])] * (amount / 2)))) :
            INDENT
                print "%i: " % (i + 1), list(group)
            DEDENT
        DEDENT
        Shuffler()
    DEDENT
    except :
    INDENT
        print 'quitting...'
    DEDENT
DEDENT
----------------------------------------

def Shuffler() :
INDENT
    amount = int(raw_input("Numbers up to: "))
    times = int(raw_input("Number of shuffles: "))
    rng = range(1, amount + 1)
    final = []
    lst_len = amount / 2
    combos_unique = set()
    while len(combos_unique) < lst_len * times :
    INDENT
        combo_rand = random.sample(rng, 2)
        if combo_rand [0] < combo_rand [1] :
        INDENT
            combos_unique.add(tuple(combo_rand))
        DEDENT
    DEDENT
    tmp = []
    for combo in combos_unique :
    INDENT
        tmp.append(list(combo))
        if len(tmp) > = lst_len :
        INDENT
            final.append(tmp)
            tmp = []
        DEDENT
    DEDENT
    for i, lst in enumerate(final) :
    INDENT
        print str(i + 1) + ": ", lst
    DEDENT
    Shuffler()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35840848_35841731_1_15
35840848_35841768_7_28
Title: Best way (if any) to hook a generator function 
----------------------------------------

def __call__(self, f) :
INDENT
    if isinstance(f, types.GeneratorType) :
    INDENT
        def run_gen(* args, ** kwargs) :
        INDENT
            for _ in f(* argw, ** kwargs) :
            INDENT
                yield _
            DEDENT
        DEDENT
        return run_gen
    DEDENT
    else :
    INDENT
        def run(* args, ** kwargs) :
        INDENT
            r = f(* argw, ** kwargs)
            return r
        DEDENT
        return run
    DEDENT
DEDENT
----------------------------------------

def __call__(self, func) :
INDENT
    @ wraps(func)
    def debug_generator(func) :
    INDENT
        for i, x in enumerate(list(func)) :
        INDENT
            print "What you want: step %s" % i
            yield x
        DEDENT
    DEDENT
    @ wraps(func)
    def run(* args, ** kwargs) :
    INDENT
        params = ""
        if self.p :
        INDENT
            params = ", ".join(["{}".format(arg) for arg in args] + ["{}={}".format(k, v) for k, v in kwargs.items()])
        DEDENT
        print ("\n\tDebug output for '{}({})'".format(func.__name__, params))
        if self.d :
        INDENT
            print ('\tDocstring: "{}"'.format(func.__doc__))
        DEDENT
        val = func(* args, ** kwargs)
        print ("\tReturn Type: '{}'\n".format(type(val).__name__))
        if inspect.isgenerator(val) :
        INDENT
            return debug_generator(val)
        DEDENT
        return val
    DEDENT
    return run
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35851256_35851699_1_13
35851256_35853822_1_13
Title: Count consecutive digits in binary string 
----------------------------------------

def consecutive_length(s, output, prev_char, count) :
INDENT
    if s == '' :
    INDENT
        output.append(count)
        return output
    DEDENT
    if s [0] == prev_char :
    INDENT
        return consecutive_length(s [1 :], output, s [0], count + 1)
    DEDENT
    else :
    INDENT
        prev_char = s [0]
        output.append(count)
        return consecutive_length(s [1 :], output, s [0], 1)
    DEDENT
DEDENT
----------------------------------------

def consecutive_length(s) :
INDENT
    def sub(idx, lst, last_char, count) :
    INDENT
        try :
        INDENT
            c = s [idx]
        DEDENT
        except IndexError :
        INDENT
            if count :
            INDENT
                lst.append(count)
            DEDENT
            return lst
        DEDENT
        if c ! = last_char :
        INDENT
            lst.append(count)
            count = 0
        DEDENT
        return sub(idx + 1, lst, c, count + 1)
    DEDENT
    return sub(0, [], s [0] if s else None, 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35854984_35855453_1_13
35854984_35856006_8_17
Title: Python Error: NameError: global name 'ftp' is not defined 
----------------------------------------

def ftpConnect() :
INDENT
    global ftp, ftpIP, ftp_status
    try :
    INDENT
        ftp = FTP(ftpIP)
        ftp.login(XXXXX)
        ftp.cwd(ftpDirectory)
        ftp_status = 1
    DEDENT
    except Exception, e :
    INDENT
        print str(e)
        ftp_status = 0
        pass
    DEDENT
DEDENT
----------------------------------------

def ftpConnect(ftpIP, ftp_directory = '.', user = '', passwd = '') :
INDENT
    try :
    INDENT
        ftp = FTP(ftpIP)
        ftp.login(user, passwd)
        ftp.cwd(ftp_directory)
        return ftp
    DEDENT
    except Exception, e :
    INDENT
        print str(e)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35854984_35855866_9_22
35854984_35856006_8_17
Title: Python Error: NameError: global name 'ftp' is not defined 
----------------------------------------

def ftpConnect() :
INDENT
    try :
    INDENT
        ftp = FTP(ftpIP)
        ftp.login(XXXXX)
        ftp.cwd(ftpDirectory)
        ftp_status = 1
    DEDENT
    except Exception, e :
    INDENT
        print str(e)
        ftp_status = 0
        pass
    DEDENT
DEDENT
----------------------------------------

def ftpConnect(ftpIP, ftp_directory = '.', user = '', passwd = '') :
INDENT
    try :
    INDENT
        ftp = FTP(ftpIP)
        ftp.login(user, passwd)
        ftp.cwd(ftp_directory)
        return ftp
    DEDENT
    except Exception, e :
    INDENT
        print str(e)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35857089_35857175_1_16
35857089_35857327_1_11
Title: Looping Caeser Cipher characters with both upper and lowercase letters 
----------------------------------------

def encode(userPhrase, key) :
INDENT
    finalmsg = userPhrase
    word = ""
    for ch in finalmsg :
    INDENT
        new_ch = ord(ch) + int(key)
        if ch.isupper() and new_ch > ord('Z') :
        INDENT
            new_ch -= 26
        DEDENT
        elif ch.islower() and new_ch > ord('z') :
        INDENT
            new_ch -= 26
        DEDENT
        elif ch.isupper() and new_ch < ord('A') :
        INDENT
            new_ch += 26
        DEDENT
        elif ch.islower() and new_ch < ord('a') :
        INDENT
            new_ch += 26
        DEDENT
        word += chr(new_ch)
    DEDENT
    return word
DEDENT
----------------------------------------

def encode(userPhrase, key) :
INDENT
    word = ""
    key = int(key)
    for ch in userPhrase :
    INDENT
        new_ch = ord(ch) + key
        if not ((ord('A') > new_ch > ord('Z')) or (ord('a') > new_ch > ord('z'))) :
        INDENT
            new_ch -= 26
        DEDENT
        word += chr(new_ch)
    DEDENT
    return word

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35874217_35874933_18_27
35874217_35874933_36_46
Title: watchdog (Python's library) - How to send signal when a file is modified? 
----------------------------------------

def __init__(self, path, filename) :
INDENT
    super(WatchOutForFileModifications, self).__init__()
    self.path = path
    self.filename = filename
    self.observer = Observer()
    self.event_handler = MyEventHandler(self.filename)
    self.observer.schedule(self.event_handler, self.path, recursive = False)
    self.observer.start()
    self.connect(self.event_handler, QtCore.SIGNAL("fileModified"), self.modified)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__()
    path = r'D:\Code\\'
    filename = "Hexagon_Grid_Creation.py"
    self.fileWatcher = WatchOutForFileModifications(path, filename)
    self.connect(self.fileWatcher, QtCore.SIGNAL("fileModified1"), self.fileModified)
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35876962_35877516_26_80
35876962_35877516_82_108
Title: unable to quit wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    file_drop_target = MyFileDropTarget(self)
    file_drop_target2 = MyFileDropTarget(self)
    file_drop_target3 = MyFileDropTarget(self)

    mainSizer = wx.BoxSizer(wx.VERTICAL)
    grid = wx.GridBagSizer(hgap = 5, vgap = 5)
    hSizer = wx.BoxSizer(wx.HORIZONTAL)

    self.button = wx.Button(self, label = "Test")

    sysList = ['QEXL', 'QEX10', 'QEX7']
    wlList = ['1100', '1400', '1800']
    sys = wx.RadioBox(self, label = "What system are you calibrating ?",
        pos = (20, 40), choices = sysList, majorDimension = 3,
        style = wx.RA_SPECIFY_COLS)
    grid.Add(sys, pos = (1, 0), span = (1, 3))
    WL = wx.RadioBox(self, label = "Maximum WL you currently Calibrating ?",
        pos = (20, 100), choices = wlList, majorDimension = 0,
        style = wx.RA_SPECIFY_COLS)
    grid.Add(WL, pos = (2, 0), span = (1, 3))

    self.lblname = wx.StaticText(self, label = "Cal File 1 :")
    grid.Add(self.lblname, pos = (3, 0))
    self.Cal_1 = wx.TextCtrl(self, name = "Cal_1", value = "", size = (240, - 1))
    self.Cal_1.SetDropTarget(file_drop_target)
    grid.Add(self.Cal_1, pos = (3, 1))
    self.lblname = wx.StaticText(self, label = "Cal File 2 :")
    grid.Add(self.lblname, pos = (4, 0))
    self.Cal_2 = wx.TextCtrl(self, value = "", name = "Cal_2", size = (240, - 1))
    self.Cal_2.SetDropTarget(file_drop_target2)
    grid.Add(self.Cal_2, pos = (4, 1))
    self.lblname = wx.StaticText(self, label = "Cal File 3 :")
    grid.Add(self.lblname, pos = (5, 0))
    self.Cal_3 = wx.TextCtrl(self, value = "", name = "Cal_3", size = (240, - 1))
    self.Cal_3.SetDropTarget(file_drop_target3)
    grid.Add(self.Cal_3, pos = (5, 1))
    hSizer.Add(grid, 0, wx.ALL, 5)
    mainSizer.Add(hSizer, 0, wx.ALL, 5)
    mainSizer.Add(self.button, 0, wx.CENTER)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (400, 400))
    panel = MyPanel(self)
    self.CreateStatusBar()

    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    helpMenu = wx.Menu()
    menubar.Append(fileMenu, '&File')
    menuOpen = fileMenu.Append(wx.ID_OPEN, "&Open", " Open a file to edit")
    fileMenu.AppendSeparator()
    menuExit = fileMenu.Append(wx.ID_EXIT, "E&xit", " Terminate the program")
    self.Bind(wx.EVT_MENU, self.OnExit, menuExit)
    menubar.Append(helpMenu, '&Help')
    menuAbout = helpMenu.Append(wx.ID_ABOUT, "&About",
        " Information about this program")
    self.Bind(wx.EVT_MENU, self.OnAbout, menuAbout)
    self.SetMenuBar(menubar)
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35876962_35877516_26_80
35876962_35899502_81_107
Title: unable to quit wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    file_drop_target = MyFileDropTarget(self)
    file_drop_target2 = MyFileDropTarget(self)
    file_drop_target3 = MyFileDropTarget(self)

    mainSizer = wx.BoxSizer(wx.VERTICAL)
    grid = wx.GridBagSizer(hgap = 5, vgap = 5)
    hSizer = wx.BoxSizer(wx.HORIZONTAL)

    self.button = wx.Button(self, label = "Test")

    sysList = ['QEXL', 'QEX10', 'QEX7']
    wlList = ['1100', '1400', '1800']
    sys = wx.RadioBox(self, label = "What system are you calibrating ?",
        pos = (20, 40), choices = sysList, majorDimension = 3,
        style = wx.RA_SPECIFY_COLS)
    grid.Add(sys, pos = (1, 0), span = (1, 3))
    WL = wx.RadioBox(self, label = "Maximum WL you currently Calibrating ?",
        pos = (20, 100), choices = wlList, majorDimension = 0,
        style = wx.RA_SPECIFY_COLS)
    grid.Add(WL, pos = (2, 0), span = (1, 3))

    self.lblname = wx.StaticText(self, label = "Cal File 1 :")
    grid.Add(self.lblname, pos = (3, 0))
    self.Cal_1 = wx.TextCtrl(self, name = "Cal_1", value = "", size = (240, - 1))
    self.Cal_1.SetDropTarget(file_drop_target)
    grid.Add(self.Cal_1, pos = (3, 1))
    self.lblname = wx.StaticText(self, label = "Cal File 2 :")
    grid.Add(self.lblname, pos = (4, 0))
    self.Cal_2 = wx.TextCtrl(self, value = "", name = "Cal_2", size = (240, - 1))
    self.Cal_2.SetDropTarget(file_drop_target2)
    grid.Add(self.Cal_2, pos = (4, 1))
    self.lblname = wx.StaticText(self, label = "Cal File 3 :")
    grid.Add(self.lblname, pos = (5, 0))
    self.Cal_3 = wx.TextCtrl(self, value = "", name = "Cal_3", size = (240, - 1))
    self.Cal_3.SetDropTarget(file_drop_target3)
    grid.Add(self.Cal_3, pos = (5, 1))
    hSizer.Add(grid, 0, wx.ALL, 5)
    mainSizer.Add(hSizer, 0, wx.ALL, 5)
    mainSizer.Add(self.button, 0, wx.CENTER)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (400, 400))
    panel = MyPanel(self)
    self.CreateStatusBar()

    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    helpMenu = wx.Menu()
    menubar.Append(fileMenu, '&File')
    menuOpen = fileMenu.Append(wx.ID_OPEN, "&Open", " Open a file to edit")
    fileMenu.AppendSeparator()
    menuExit = fileMenu.Append(wx.ID_EXIT, "E&xit", " Terminate the program")
    self.Bind(wx.EVT_MENU, self.OnExit, menuExit)
    menubar.Append(helpMenu, '&Help')
    menuAbout = helpMenu.Append(wx.ID_ABOUT, "&About",
        " Information about this program")
    self.Bind(wx.EVT_MENU, self.OnAbout, menuAbout)
    self.SetMenuBar(menubar)
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35876962_35877516_82_108
35876962_35899502_26_79
Title: unable to quit wxpython 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (400, 400))
    panel = MyPanel(self)
    self.CreateStatusBar()

    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    helpMenu = wx.Menu()
    menubar.Append(fileMenu, '&File')
    menuOpen = fileMenu.Append(wx.ID_OPEN, "&Open", " Open a file to edit")
    fileMenu.AppendSeparator()
    menuExit = fileMenu.Append(wx.ID_EXIT, "E&xit", " Terminate the program")
    self.Bind(wx.EVT_MENU, self.OnExit, menuExit)
    menubar.Append(helpMenu, '&Help')
    menuAbout = helpMenu.Append(wx.ID_ABOUT, "&About",
        " Information about this program")
    self.Bind(wx.EVT_MENU, self.OnAbout, menuAbout)
    self.SetMenuBar(menubar)
    self.Show(True)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)

    mainSizer = wx.BoxSizer(wx.VERTICAL)
    grid = wx.GridBagSizer(hgap = 5, vgap = 5)
    hSizer = wx.BoxSizer(wx.HORIZONTAL)

    self.button = wx.Button(self, label = "Test")

    sysList = ['QEXL', 'QEX10', 'QEX7']
    wlList = ['1100', '1400', '1800']
    sys = wx.RadioBox(self, label = "What system are you calibrating ?",
        pos = (20, 40), choices = sysList, majorDimension = 3,
        style = wx.RA_SPECIFY_COLS)
    grid.Add(sys, pos = (1, 0), span = (1, 3))
    WL = wx.RadioBox(self, label = "Maximum WL you currently Calibrating ?",
        pos = (20, 100), choices = wlList, majorDimension = 0,
        style = wx.RA_SPECIFY_COLS)
    grid.Add(WL, pos = (2, 0), span = (1, 3))

    self.lblname = wx.StaticText(self, label = "Cal File 1 :")
    grid.Add(self.lblname, pos = (3, 0))
    self.Cal_1 = wx.TextCtrl(self, name = "Cal_1", value = "", size = (240, - 1))
    Cal1 = MyFileDropTarget(self.Cal_1)
    self.Cal_1.SetDropTarget(Cal1)
    grid.Add(self.Cal_1, pos = (3, 1))
    self.lblname = wx.StaticText(self, label = "Cal File 2 :")
    grid.Add(self.lblname, pos = (4, 0))
    self.Cal_2 = wx.TextCtrl(self, value = "", name = "Cal_2", size = (240, - 1))
    Cal2 = MyFileDropTarget(self.Cal_2)
    self.Cal_2.SetDropTarget(Cal2)
    grid.Add(self.Cal_2, pos = (4, 1))
    self.lblname = wx.StaticText(self, label = "Cal File 3 :")
    grid.Add(self.lblname, pos = (5, 0))
    self.Cal_3 = wx.TextCtrl(self, value = "", name = "Cal_3", size = (240, - 1))
    Cal3 = MyFileDropTarget(self.Cal_3)
    self.Cal_3.SetDropTarget(Cal3)
    grid.Add(self.Cal_3, pos = (5, 1))
    hSizer.Add(grid, 0, wx.ALL, 5)
    mainSizer.Add(hSizer, 0, wx.ALL, 5)
    mainSizer.Add(self.button, 0, wx.CENTER)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35876962_35899502_26_79
35876962_35899502_81_107
Title: unable to quit wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)

    mainSizer = wx.BoxSizer(wx.VERTICAL)
    grid = wx.GridBagSizer(hgap = 5, vgap = 5)
    hSizer = wx.BoxSizer(wx.HORIZONTAL)

    self.button = wx.Button(self, label = "Test")

    sysList = ['QEXL', 'QEX10', 'QEX7']
    wlList = ['1100', '1400', '1800']
    sys = wx.RadioBox(self, label = "What system are you calibrating ?",
        pos = (20, 40), choices = sysList, majorDimension = 3,
        style = wx.RA_SPECIFY_COLS)
    grid.Add(sys, pos = (1, 0), span = (1, 3))
    WL = wx.RadioBox(self, label = "Maximum WL you currently Calibrating ?",
        pos = (20, 100), choices = wlList, majorDimension = 0,
        style = wx.RA_SPECIFY_COLS)
    grid.Add(WL, pos = (2, 0), span = (1, 3))

    self.lblname = wx.StaticText(self, label = "Cal File 1 :")
    grid.Add(self.lblname, pos = (3, 0))
    self.Cal_1 = wx.TextCtrl(self, name = "Cal_1", value = "", size = (240, - 1))
    Cal1 = MyFileDropTarget(self.Cal_1)
    self.Cal_1.SetDropTarget(Cal1)
    grid.Add(self.Cal_1, pos = (3, 1))
    self.lblname = wx.StaticText(self, label = "Cal File 2 :")
    grid.Add(self.lblname, pos = (4, 0))
    self.Cal_2 = wx.TextCtrl(self, value = "", name = "Cal_2", size = (240, - 1))
    Cal2 = MyFileDropTarget(self.Cal_2)
    self.Cal_2.SetDropTarget(Cal2)
    grid.Add(self.Cal_2, pos = (4, 1))
    self.lblname = wx.StaticText(self, label = "Cal File 3 :")
    grid.Add(self.lblname, pos = (5, 0))
    self.Cal_3 = wx.TextCtrl(self, value = "", name = "Cal_3", size = (240, - 1))
    Cal3 = MyFileDropTarget(self.Cal_3)
    self.Cal_3.SetDropTarget(Cal3)
    grid.Add(self.Cal_3, pos = (5, 1))
    hSizer.Add(grid, 0, wx.ALL, 5)
    mainSizer.Add(hSizer, 0, wx.ALL, 5)
    mainSizer.Add(self.button, 0, wx.CENTER)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (400, 400))
    panel = MyPanel(self)
    self.CreateStatusBar()

    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    helpMenu = wx.Menu()
    menubar.Append(fileMenu, '&File')
    menuOpen = fileMenu.Append(wx.ID_OPEN, "&Open", " Open a file to edit")
    fileMenu.AppendSeparator()
    menuExit = fileMenu.Append(wx.ID_EXIT, "E&xit", " Terminate the program")
    self.Bind(wx.EVT_MENU, self.OnExit, menuExit)
    menubar.Append(helpMenu, '&Help')
    menuAbout = helpMenu.Append(wx.ID_ABOUT, "&About",
        " Information about this program")
    self.Bind(wx.EVT_MENU, self.OnAbout, menuAbout)
    self.SetMenuBar(menubar)
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35880149_35880353_10_14
35880149_35880355_10_14
Title: Print only one list in recursion 
----------------------------------------

def compress(S) :
INDENT
    if S == '' :
    INDENT
        return []
    DEDENT
    cons_length = consecutive_length(S)
    return [cons_length] + compress(S [cons_length :])
DEDENT
----------------------------------------

def compress(S) :
INDENT
    if S == '' :
    INDENT
        return []
    DEDENT
    cons_length = consecutive_length(S)
    return [cons_length] + compress(S [cons_length :])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35882520_35883082_8_45
35882520_35883096_9_43
Title: Unsupported operand type 
----------------------------------------

def pearson(ratingsUser1, ratingsUser2) :
INDENT
    sum_ratingsUser1 = sum(ratingsUser1.values())
    sum_ratingsUser2 = sum(ratingsUser2.values())

    square_sum1 = 0
    square_sum2 = 0
    for value in ratingsUser1.values() :
    INDENT
        square_sum1 += pow(value, 2)
    DEDENT
    for value in ratingsUser2.values() :
    INDENT
        square_sum2 += pow(value, 2)

    DEDENT
    product = sum_ratingsUser1 * sum_ratingsUser2

    numerator = product - (sum_ratingsUser1 * sum_ratingsUser2 / len(ratingsUser1))
    denominator = ((square_sum1 - pow(sum_ratingsUser1, 2) / len(ratingsUser1)) * (square_sum2 -
            pow(sum_ratingsUser2, 2) / len(ratingsUser1))) ** 0.5

    if denominator == 0 :
    INDENT
        return 0
    DEDENT
    result = numerator / denominator
    return result

DEDENT
----------------------------------------

def pearson(ratingsUser1, ratingsUser2) :
INDENT
    sum_ratingsUser1 = sum(ratingsUser1.values())
    sum_ratingsUser2 = sum(ratingsUser2.values())
    square_sum1 = sum(base ** 2 for base in ratingsUser1.values())
    square_sum2 = sum(base ** 2 for base in ratingsUser2.values())
    product = sum_ratingsUser1 * sum_ratingsUser2

    try :
    INDENT

        numerator = product - (sum_ratingsUser1 * sum_ratingsUser2 / len(ratingsUser1))
        denominator = (
            (square_sum1 - pow(sum_ratingsUser1, 2) / len(ratingsUser1)) *
            (square_sum2 - pow(sum_ratingsUser2, 2) / len(ratingsUser1))) ** 0.5
        return numerator / denominator
    DEDENT
    except ZeroDivisionError :
    INDENT
        return 0

    DEDENT
    def nearest_neighbor(username, ratings) :
    INDENT
        distances = [(pearson(ratings [username], ratings [other_user]), other_user) for other_user in ratings if other_user ! = username and username in ratings]
        distances.sort()
        return distances

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35908466_35908512_1_10
35908466_35908627_6_20
Title: Python - Error: Expected an Indented Block 
----------------------------------------

def OnKeyboardEvent(event) :
INDENT
    if event.Ascii == 5 :
    INDENT
        sys.exit()
    DEDENT
    if event.Ascii ! = 0 or 8 :
    INDENT
        f = open('c:\\output.txt', 'a')
        keylogs = chr(event.Ascii)
    DEDENT
    if event.Ascii == 13 :
    INDENT
        keylogs = keylogs + '\n'
        f.write(keylogs)
        f.close()
    DEDENT
DEDENT
----------------------------------------

def OnKeyboardEvent(event) :
INDENT
    if event.Ascii == 5 :
    sys.exit()
    if event.Ascii ! = 0 or 8 :
    INDENT
        f = open('c:\\output.txt', 'a')
        keylogs = chr(event.Ascii)
    DEDENT
    if event.Ascii == 13 :
    INDENT
        keylogs = keylogs + '\n'
        f.write(keylogs)
        f.close()
    DEDENT
    while True :
    INDENT
        hm = pyHook.HookManager()
        hm.KeyDown = OnKeyboardEvent
        hm.HookKeyboard()
        pythoncom.PumpMessages()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35934735_35941350_3_11
35934735_35942234_6_13
Title: Bind callback to the object instance 
----------------------------------------

def __init__(self, * args, ** kw) :
INDENT
    super().__init__(* args, ** kw)
    @ listen_on('test')
    def on_test(self, event) :
    INDENT
        print ("self is " + str(self))
        print ("FF" + str(event))
    DEDENT
    self.on_test = on_test
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    for attr_name in dir(self) :
    INDENT
        method = getattr(self, attr_name)
        if hasattr(method, "_component_emitter_on") :
        INDENT
            for event in method._component_emitter_on :
            INDENT
                self._emiter.on(event, method)
            DEDENT
        DEDENT
        self.attr_name = method
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35949167_35949246_1_14
35949167_35949283_1_15
Title: List that keeps track of the iteration of characters in a string 
----------------------------------------

def numberCheck(string) :
INDENT
    numberList = []
    teller = 1
    i = 0
    while i < len(string) :
    INDENT
        for j in range(i + 1, len(string)) :
        INDENT
            if string [i] == string [j] :
            INDENT
                teller += 1
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        numberList.append(teller)
        i += teller
        teller = 1
    DEDENT
    return numberList
DEDENT
----------------------------------------

def numberCheck(string) :
INDENT
    if not string :
    INDENT
        return []
    DEDENT
    numberList = []
    current = string [0]
    i = 0
    for char in string :
    INDENT
        if char == current :
        INDENT
            i += 1
        DEDENT
        else :
        INDENT
            current = char
            numberList.append(i)
            i = 1
        DEDENT
    DEDENT
    numberList.append(i)
    return numberList
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35964155_35964184_12_16
35964155_35965348_8_11
Title: Checking if list is a sublist 
----------------------------------------

def get_all_in(one, another) :
INDENT
    for element in one :
    INDENT
        if element in another :
        INDENT
            yield element
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_all_in(one, another) :
INDENT
    for element in one :
    INDENT
        if element in another :
        INDENT
            yield element
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35964155_35964184_1_21
35964155_48346149_1_26
Title: Checking if list is a sublist 
----------------------------------------

def sublist(ls1, ls2) :
INDENT
    def get_all_in(one, another) :
    INDENT
        for element in one :
        INDENT
            if element in another :
            INDENT
                yield element
            DEDENT
        DEDENT
    DEDENT
    for x1, x2 in zip(get_all_in(ls1, ls2), get_all_in(ls2, ls1)) :
    INDENT
        if x1 ! = x2 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def sublist(sublist, lst) :
INDENT
    if not isinstance(sublist, list) :
    INDENT
        raise ValueError("sublist must be a list")
    DEDENT
    if not isinstance(lst, list) :
    INDENT
        raise ValueError("lst must be a list")
    DEDENT
    sublist_len = len(sublist)
    k = 0
    s = None
    if (sublist_len > len(lst)) :
    INDENT
        return False
    DEDENT
    elif (sublist_len == 0) :
    INDENT
        return True
    DEDENT
    for x in lst :
    INDENT
        if x == sublist [k] :
        INDENT
            if (k == 0) : s = x
            elif (x ! = s) : s = None
            k += 1
            if k == sublist_len :
            INDENT
                return True
            DEDENT
        DEDENT
        elif k > 0 and sublist [k - 1] ! = s :
        INDENT
            k = 0
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35964155_35964184_1_21
35964155_52841497_5_14
Title: Checking if list is a sublist 
----------------------------------------

def sublist(ls1, ls2) :
INDENT
    def get_all_in(one, another) :
    INDENT
        for element in one :
        INDENT
            if element in another :
            INDENT
                yield element
            DEDENT
        DEDENT
    DEDENT
    for x1, x2 in zip(get_all_in(ls1, ls2), get_all_in(ls2, ls1)) :
    INDENT
        if x1 ! = x2 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def sublist(lst1, lst2) :
INDENT
    for item in lst2 :
    INDENT
        try :
        INDENT
            lst1.index(item)
        DEDENT
        except ValueError :
        INDENT
            return False
        DEDENT
        return True

    DEDENT
    print (sublist(lst1, lst2))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35964155_48346149_1_26
35964155_52841497_5_14
Title: Checking if list is a sublist 
----------------------------------------

def sublist(sublist, lst) :
INDENT
    if not isinstance(sublist, list) :
    INDENT
        raise ValueError("sublist must be a list")
    DEDENT
    if not isinstance(lst, list) :
    INDENT
        raise ValueError("lst must be a list")
    DEDENT
    sublist_len = len(sublist)
    k = 0
    s = None
    if (sublist_len > len(lst)) :
    INDENT
        return False
    DEDENT
    elif (sublist_len == 0) :
    INDENT
        return True
    DEDENT
    for x in lst :
    INDENT
        if x == sublist [k] :
        INDENT
            if (k == 0) : s = x
            elif (x ! = s) : s = None
            k += 1
            if k == sublist_len :
            INDENT
                return True
            DEDENT
        DEDENT
        elif k > 0 and sublist [k - 1] ! = s :
        INDENT
            k = 0
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def sublist(lst1, lst2) :
INDENT
    for item in lst2 :
    INDENT
        try :
        INDENT
            lst1.index(item)
        DEDENT
        except ValueError :
        INDENT
            return False
        DEDENT
        return True

    DEDENT
    print (sublist(lst1, lst2))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35966715_35967218_12_33
35966715_35967518_1_19
Title: Fastest way to search a list for strings for superstrings of a given string in python 
----------------------------------------

def checkForSubstrings(words) :
INDENT
    d = defaultdict(set)
    for windex, word in enumerate(words) :
    INDENT
        for i in range(len(word)) :
        INDENT
            for j in range(len(word)) :
            INDENT
                if word [i : j + 1] :
                INDENT

                    d [word [i : j + 1]].add((windex, word [i : j + 1] == word))

                DEDENT
            DEDENT
        DEDENT
    DEDENT
    for windex, word in enumerate(words) :
    INDENT
        matches = d.get(word, [])
        for obj in matches :
        INDENT
            if not obj [1] :
            INDENT
                print ("%s is a substring of some other string" % word)
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def checkForSubstrings(words) :
INDENT
    super_strings = defaultdict(list)
    substrings = defaultdict(list)
    words.sort(key = len, reverse = True)
    while words :
    INDENT

        word = words.pop()
        subwords = substrings [word]
        current_words = min(super_strings [w] for w in subwords, key = len)
        if not current_words :
        INDENT
            current_words = words
        DEDENT
        super_words = [w for w in current_words if len(w) > len(word) and w.find(word) > - 1]
        for s in super_words :
        INDENT
            substrings [s].append(word)
        DEDENT
        super_strings [word] = super_words
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35983457_35983558_1_8
35983457_35983600_3_14
Title: how to pass variable from function using Python 
----------------------------------------

def search(seed) :
INDENT
    abc = 123
    if abc == 123 :
    INDENT
        return seed
    DEDENT
    else :
    INDENT
        print ("why")
    DEDENT
DEDENT
----------------------------------------

def search() :
INDENT
    global seed
    abc = 123
    if abc == 123 :
    INDENT
        seed = 0
        print (seed)
        return seed
    DEDENT
    else :
    INDENT
        print ("why")
    DEDENT
    seed = search(seed)
    print (seed)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35986285_35986442_12_20
35986285_35986442_3_11
Title: Returning Dictionary-length of words in string 
----------------------------------------

def n_letter_dictionary(my_string) :
INDENT
    my_dict = {}
    for word in my_string.split() :
    INDENT
        word_length = len(word)
        if word_length in my_dict :
        INDENT
            if word not in my_dict [word_length] :
            INDENT
                my_dict [word_length].append(word)
            DEDENT
        DEDENT
        else :
        INDENT
            my_dict [word_length] = [word]
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def n_letter_dictionary(my_string) :
INDENT
    my_dict = defaultdict(list)
    for word in my_string.split() :
    INDENT
        if word not in my_dict [len(word)] :
        INDENT
            my_dict [len(word)].append(word)
        DEDENT
    DEDENT
    return my_dict

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35997473_36000374_1_15
35997473_36005147_5_19
Title: How do I create a spiral off-shoot from my larger spiral? 
----------------------------------------

def spiral(size) :
INDENT
    if size < 1 : return
    draw_segment(size)
    position = getposition()
    angle = getangle()
    spiral(size - 1)
    penup()
    setposition(position)
    pendown()
    setangle(angle + 180)
    spiral(size - 2)
DEDENT
----------------------------------------

def spiral(steps, left, forward, level) :
INDENT
    for step in range(50, steps) :
    INDENT
        me.left(left)
        me.forward(step / forward)
        if step % 200 == 0 and level > 0 :
        INDENT
            x, y = me.position()
            heading = me.heading()
            spiral((steps * 2) / 3, - left * 1.2, forward * 1.2, level - 1)
            me.up()
            me.setpos(x, y)
            me.setheading(heading)
            me.down()

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35999624_35999689_2_9
35999624_36009947_2_8
Title: Python: Extract numbers from a string and put numbers into a list 
----------------------------------------

def extract_nums(string) :
INDENT
    trash = []
    for x in string :
    INDENT
        if x.isalpha() :
        INDENT
            trash.append(x)
        DEDENT
        else :
        INDENT
            new.append(x)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def extract_nums(string) :
INDENT
    for x in string :
    INDENT
        try :
        INDENT
            new.append(int(x))
        DEDENT
        except ValueError :
        INDENT
            continue
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35999624_35999810_2_10
35999624_36009947_2_8
Title: Python: Extract numbers from a string and put numbers into a list 
----------------------------------------

def extract_nums(string) :
INDENT
    trash = []
    for x in string :
    INDENT
        if x.isalpha() :
        INDENT
            trash.append(x)
        DEDENT
        elif x == ' ' :
        INDENT
            trash.append(x)
        DEDENT
        else :
        INDENT
            new.append(x)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def extract_nums(string) :
INDENT
    for x in string :
    INDENT
        try :
        INDENT
            new.append(int(x))
        DEDENT
        except ValueError :
        INDENT
            continue
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36032472_36033164_1_25
36032472_36033257_10_22
Title: python wont print a variable right please help as it allways prints somthin random 
----------------------------------------

def start() :
INDENT
    print ("Hello user, welcome to the Number Guesser")
    time.sleep(1)
    name = input("Please enter your name: ")
    print ("Hello ", name, " now I'm thinking of a random number between 0 and 20. Try to guess it!")
    number_guess = random.randint(0, 20)
    number(number_guess, 0)
    def number(arg, counter) :
    INDENT
        guess = int(input("Please enter a number: "))
        if guess == arg :
        INDENT
            print ("Well done, the number was ", arg, " you guessed it in ", counter, " goes!!! Would you like to do another number?")
            awn = input("y for yes or n for no ").lower()
            if awn == "y" :
            INDENT
                start()
            DEDENT
            elif awn == "n" :
            INDENT
                sys.exit()
            DEDENT
        DEDENT
        elif guess < arg :
        INDENT
            print ("That number is too small. Try again.")
            number(arg, counter + 1)
        DEDENT
        elif guess < arg :
        INDENT
            print ("That number is too big. Try again.")
            number(arg, counter + 1)
        DEDENT
    DEDENT
    start()
DEDENT
----------------------------------------

def start() :
INDENT
    global number_guess
    print ("hello user welcome to the number guesser.")
    time.sleep(1)
    name = input("please enter youre name. ")
    print ("hello", name, "now im thinking of a random number between 0 and 20 try to guess is")
    number_guess = 1
    guesses_taken = 0
    number()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36032472_36033164_9_24
36032472_36033257_23_52
Title: python wont print a variable right please help as it allways prints somthin random 
----------------------------------------

def number(arg, counter) :
INDENT
    guess = int(input("Please enter a number: "))
    if guess == arg :
    INDENT
        print ("Well done, the number was ", arg, " you guessed it in ", counter, " goes!!! Would you like to do another number?")
        awn = input("y for yes or n for no ").lower()
        if awn == "y" :
        INDENT
            start()
        DEDENT
        elif awn == "n" :
        INDENT
            sys.exit()
        DEDENT
    DEDENT
    elif guess < arg :
    INDENT
        print ("That number is too small. Try again.")
        number(arg, counter + 1)
    DEDENT
    elif guess < arg :
    INDENT
        print ("That number is too big. Try again.")
        number(arg, counter + 1)
    DEDENT
DEDENT
----------------------------------------

def number() :
INDENT
    global guesses_taken
    global guess
    global number_guess
    guess = int(input("please enter a number "))
    while guess > number_guess :
    INDENT
        print ("That number is to big try again")
        guesses_taken = guesses_taken + 1
        number()
    DEDENT
    while guess < number_guess :
    INDENT
        guesses_taken = guesses_taken + 1
        print ("that number is to small try agian")
        number()
    DEDENT
    if guess == number_guess :
    INDENT

        guesses_taken = guesses_taken + 1
        global awn
        print ("well done the number was", number_guess, "you guessed it in", guesses_taken, " goes!!! Would you like to do another number?")
        awn = input("y for yes or n for no ").lower()
        if awn == "y" :
        INDENT
            start()
        DEDENT
        elif awn == "n" :
        INDENT
            sys.exit()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3603502_29368642_3_23
3603502_36898596_3_14
Title: Prevent creating new attributes outside __init__ 
----------------------------------------

def froze_it(cls) :
INDENT
    cls.__frozen = False
    def frozensetattr(self, key, value) :
    INDENT
        if self.__frozen and not hasattr(self, key) :
        INDENT
            print ("Class {} is frozen. Cannot set {} = {}"
                .format(cls.__name__, key, value))
        DEDENT
        else :
        INDENT
            object.__setattr__(self, key, value)
        DEDENT
    DEDENT
    def init_decorator(func) :
    INDENT
        @ wraps(func)
        def wrapper(self, * args, ** kwargs) :
        INDENT
            func(self, * args, ** kwargs)
            self.__frozen = True
        DEDENT
        return wrapper
    DEDENT
    cls.__setattr__ = frozensetattr
    cls.__init__ = init_decorator(cls.__init__)
    return cls
DEDENT
----------------------------------------

def froze_it(cls) :
INDENT
    def frozensetattr(self, key, value) :
    INDENT
        if not hasattr(self, key) and inspect.stack() [1] [3] ! = "__init__" :
        INDENT
            print ("Class {} is frozen. Cannot set {} = {}"
                .format(cls.__name__, key, value))
        DEDENT
        else :
        INDENT
            self.__dict__ [key] = value
        DEDENT
    DEDENT
    cls.__setattr__ = frozensetattr
    return cls
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3603502_35511594_15_22
3603502_37649455_3_13
Title: Prevent creating new attributes outside __init__ 
----------------------------------------

def __setattr__(self, name, value) :
INDENT
    if not hasattr(self, name) :
    INDENT
        raise AttributeError("Model instances do not accept arbitrary attributes")
    DEDENT
    else :
    INDENT
        object.__setattr__(self, name, value)

    DEDENT
DEDENT
----------------------------------------

def __setattr__(self, key, value) :
INDENT
    setIsOK = False
    for item in self.__List :
    INDENT
        if key == item :
        INDENT
            setIsOK = True
        DEDENT
    DEDENT
    if setIsOK == True :
    INDENT
        object.__setattr__(self, key, value)
    DEDENT
    else :
    INDENT
        raise TypeError("%r has no attributes %r" % (self, key))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3603502_37649455_3_13
3603502_38017411_8_12
Title: Prevent creating new attributes outside __init__ 
----------------------------------------

def __setattr__(self, key, value) :
INDENT
    setIsOK = False
    for item in self.__List :
    INDENT
        if key == item :
        INDENT
            setIsOK = True
        DEDENT
    DEDENT
    if setIsOK == True :
    INDENT
        object.__setattr__(self, key, value)
    DEDENT
    else :
    INDENT
        raise TypeError("%r has no attributes %r" % (self, key))
    DEDENT
DEDENT
----------------------------------------

def __setattr__(self, attribute, value) :
INDENT
    if not attribute in self.__class__.__allowed_attr :
    INDENT
        raise AttributeError
    DEDENT
    else :
    INDENT
        super().__setattr__(attribute, value)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36038330_36038470_1_18
36038330_36038559_10_20
Title: TypeError: send() missing 2 required positional arguments: 'interp' and 'cmd' 
----------------------------------------

def create_widgets(self) :
INDENT
    def send() :
    INDENT
        self.start = time.time()
        self.lbl2 = Label(self, text = "Sending...")
        self.lbl2.grid(row = 1, column = 1, sticky = W)
        self.start.sleep(2)
        self.lbl2.destroy()
    DEDENT
    self.lbl1 = Label(self, text = "Write your message:")
    self.lbl1.grid(row = 0, column = 0, columnspan = 2, sticky = W)
    self.entry = Entry(self)
    self.entry.grid(row = 0, column = 2, columnspan = 3, sticky = W)
    self.bttn = Button(self, text = "Send", command = send)
    self.bttn.grid(row = 1, column = 0, sticky = W)
DEDENT
----------------------------------------

def create_widgets(self) :
INDENT
    self.lbl1 = Label(self, text = "Write your message:")
    self.lbl1.grid(row = 0, column = 0, columnspan = 2, sticky = W)
    self.entry = Entry(self)
    self.entry.grid(row = 0, column = 2, columnspan = 3, sticky = W)
    self.bttn = Button(self, text = "Send", command = self.send)
    self.bttn.grid(row = 1, column = 0, sticky = W)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36041797_36041844_1_17
36041797_36041863_3_17
Title: Python list to txt 
----------------------------------------

def random_grid(file) :
INDENT
    grid = []
    num_rows = raw_input("How many raws would you like in your grid? ")
    num_columns = raw_input("How many columns would you like in your grid? ")
    min_range = raw_input("What is the minimum number you would like in your grid? ")
    max_range = raw_input("what is the maximum number you would like in your grid? ")
    for row in range(int(num_rows)) :
    INDENT
        grid.append([])
        for column in range(int(num_columns)) :
        INDENT
            grid [row].append(random.randint((int(min_range)), (int(max_range))))
        DEDENT
    DEDENT
    for row in grid :
    INDENT
        x = (' '.join([str(x) for x in row]))
        print x
        with open(r"test.txt", 'a') as text_file :
        INDENT
            text_file.write(x)
            text_file.write("\n")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def random_grid(file) :
INDENT
    grid = []
    num_rows = int(raw_input("How many rows would you like in your grid? "))
    num_columns = int(raw_input("How many columns would you like in your grid? "))
    min_range = int(raw_input("What is the minimum number you would like in your grid? "))
    max_range = int(raw_input("What is the maximum number you would like in your grid? "))
    for _ in range(num_rows) :
    INDENT
        grid.append([random.randint(min_range, max_range) for _ in range(num_columns)])
    DEDENT
    grid_str = '\n'.join(' '.join(map(str, row)) for row in grid)
    with open(r"test.txt", 'w') as text_file :
    INDENT
        text_file.write(grid_str)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36054645_36055201_14_20
36054645_36055610_13_20
Title: Is there any better way to iterate two list to find relation between items in python? 
----------------------------------------

def netaddr_test(ips, netsets) :
INDENT
    for ip in ips :
    INDENT
        for stringnet, info in netsets.iteritems() :
        INDENT
            if ip in info ['subnet'] :
            INDENT
                print ip, '\t', info ['name']
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def netaddr_test(ips, grouped_netsets) :
INDENT
    for ip in ips :
    INDENT
        for group, netsets in grouped_netsets.iteritems() :
        INDENT
            if IPAddress(ip) in IPNetwork(group) :
            INDENT
                for subnet, name in netsets.iteritems() :
                INDENT
                    if IPAddress(ip) in IPNetwork(subnet) :
                    INDENT
                        print (ip, '\t', name)
                        break
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36092239_36092312_1_20
36092239_36821112_1_13
Title: "I keep getting the following error ""local variable 'total_results' referenced before assignment""" 
----------------------------------------

def post_search(request) :
INDENT
    results = []
    total_results = 0
    form = SearchForm()
    if 'query' in request.GET :
    INDENT
        form = SearchForm(request.GET)
        if form.is_valid() :
        INDENT
            cd = form.cleaned_data
            results = SearchQuerySet().models(Post).filter(content = cd ['query']).load_all()
            total_results = results.count()
        DEDENT
    DEDENT
    template = 'blog/post/search.html'
    context = {
        'form' : form,
        'cd' : cd,
        'results' : results,
        'total_results' : total_results}
    return render(request, template, context)
DEDENT
----------------------------------------

def post_search(request) :
INDENT
    if 'query' in request.GET :
    INDENT
        form = SearchForm(request.GET)
        if form.is_valid() :
        INDENT
            cd = form.cleaned_data
            results = SearchQuerySet().models(Post).filter(content = cd ['query']).load_all()
            total_results = results.count()
            context = {'form' : form, 'cd' : cd, 'results' : results, 'total_results' : total_results}
            return render(request, 'blog/post/search.html', context)
        DEDENT
    DEDENT
    else :
    INDENT
        form = SearchForm()
        context = {'form' : form}
        return render(request, 'blog/post/search.html', context)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36096573_36096611_1_10
36096573_36096797_3_24
Title: "How to determine if a string object is a integer double boolean date or string using python?" 
----------------------------------------

def text_type_determine(i) :
INDENT
    i = eval(i)
    if type(i) == int :
    INDENT
        return 'integer'
    DEDENT
    elif type(i) == float :
    INDENT
        return 'double'
    DEDENT
    elif type(i) == bool :
    INDENT
        return 'boolean'
    DEDENT
    elif type(i) == str :
    INDENT
        return 'string'
    DEDENT
DEDENT
----------------------------------------

def text_type_determine(i) :
INDENT
    try :
    INDENT
        datetime.strftime(i, '%Y-%m-%d')
        return 'date'
    DEDENT
    except :
    INDENT
        try :
        INDENT
            int(i)
            return 'integer'
        DEDENT
        except :
        INDENT
            try :
            INDENT

                float(i)
                return 'double'
            DEDENT
            except :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    if i in ['true', 'false'] :
    INDENT
        return 'boolean'
    DEDENT
    return 'string'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36096573_36096611_1_10
36096573_36096897_4_11
Title: "How to determine if a string object is a integer double boolean date or string using python?" 
----------------------------------------

def text_type_determine(i) :
INDENT
    i = eval(i)
    if type(i) == int :
    INDENT
        return 'integer'
    DEDENT
    elif type(i) == float :
    INDENT
        return 'double'
    DEDENT
    elif type(i) == bool :
    INDENT
        return 'boolean'
    DEDENT
    elif type(i) == str :
    INDENT
        return 'string'
    DEDENT
DEDENT
----------------------------------------

def text_type_determine(i) :
INDENT
    types = {int : 'integer', float : 'double', bool : 'boolean', str : 'string', datetime : "date"}
    for tpe in [literal_eval, parser.parse] :
    INDENT
        try :
        INDENT
            return types.get(type(tpe(i)))
        DEDENT
        except (AttributeError, ValueError) :
        INDENT
            pass
        DEDENT
    DEDENT
    return types.get(type(i))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36096573_36096797_3_24
36096573_36096897_4_11
Title: "How to determine if a string object is a integer double boolean date or string using python?" 
----------------------------------------

def text_type_determine(i) :
INDENT
    try :
    INDENT
        datetime.strftime(i, '%Y-%m-%d')
        return 'date'
    DEDENT
    except :
    INDENT
        try :
        INDENT
            int(i)
            return 'integer'
        DEDENT
        except :
        INDENT
            try :
            INDENT

                float(i)
                return 'double'
            DEDENT
            except :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    if i in ['true', 'false'] :
    INDENT
        return 'boolean'
    DEDENT
    return 'string'
DEDENT
----------------------------------------

def text_type_determine(i) :
INDENT
    types = {int : 'integer', float : 'double', bool : 'boolean', str : 'string', datetime : "date"}
    for tpe in [literal_eval, parser.parse] :
    INDENT
        try :
        INDENT
            return types.get(type(tpe(i)))
        DEDENT
        except (AttributeError, ValueError) :
        INDENT
            pass
        DEDENT
    DEDENT
    return types.get(type(i))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36105504_36105990_5_12
36105504_36106128_1_17
Title: Django: do I need to make a caching method? 
----------------------------------------

def url_profile_picture(self) :
INDENT
    a = PersonnePhoto.objects.filter(personne = self,
        photo_type = PersonnePhoto.PHOTO_PROFIL)
    if len(a) :
    INDENT
        a = reverse('url_public', kwargs = {'path' : a [0].photo})
    DEDENT
    else :
    INDENT
        a = staticfiles.static('img/no-picture-yet.png')
    DEDENT
    return a
DEDENT
----------------------------------------

def url_profile_picture(self) :
INDENT
    retour = cache.get('profile_picture_%s' % self.pk)
    if retour :
    INDENT
        return retour
    DEDENT
    else :
    INDENT
        a = PersonnePhoto.objects.filter(personne = self,
            photo_type = PersonnePhoto.PHOTO_PROFIL)
        if len(a) :
        INDENT
            a = reverse('url_public', kwargs = {'path' : a [0].photo})
        DEDENT
        else :
        INDENT
            a = staticfiles.static('img/no-picture-yet.png')
        DEDENT
        cache.set('profile_picture_%s' % self.pk, a)
        return a
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36109165_36109218_1_9
36109165_36109231_1_8
Title: Reverse a List by Swap Ends 
----------------------------------------

def reverse(list) :
INDENT
    for i in range(len(list) / 2) :
    INDENT
        j = i + 1
        x = list [i]
        y = list [- j]
        list [- j] = x
        list [i] = y
    DEDENT
DEDENT
----------------------------------------

def reverse(seq) :
INDENT
    for i in range(len(seq) / / 2) :
    INDENT
        x = seq [i]
        y = seq [- i - 1]
        seq [i] = y
        seq [- i - 1] = x
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36130776_36133892_16_27
36130776_36133892_46_56
Title: python play output from /dev/video0 
----------------------------------------

def __init__(self, draw) :
INDENT
    self.draw = draw
    self.fifo = "/tmp/%s.%d" % (os.path.basename(__file__), time.time())

    cmd = string.split("mplayer -slave -wid %d tv:// -tv driver=v4l2:norm=PAL:width=640:height=480:outfmt=uyvy:device=/dev/video0 -hardframedrop -input file=%s" % (self.draw.window.xid, self.fifo))
    self.devnull = open(os.devnull)
    process = subprocess.Popen(cmd)
    self.pid = process.pid
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
    self.draw = gtk.DrawingArea()
    self.mplayer = None
    self.setup_widgets()
    self.window.set_decorated(False)
    self.window.resize(640, 480)
    self.window.set_position(gtk.WIN_POS_CENTER)
    self.play()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36137791_36138928_8_22
36137791_36139232_11_27
Title: How to create a button for each element in a list and put it in a scroll-area? 
----------------------------------------

def __init__(self) :
INDENT
    super(TestGui, self).__init__()
    self.lay = QtGui.QHBoxLayout()
    self.sA = QtGui.QScrollArea()
    self.sA_lay = QtGui.QVBoxLayout()
    self.sA.setLayout(self.sA_lay)
    self.closeGui = QtGui.QPushButton("Close")
    self.add_file_button = QtGui.QPushButton("Add File")
    self.lay.addWidget(self.closeGui)
    self.lay.addWidget(self.add_file_button)
    self.lay.addWidget(self.sA)
    self.setLayout(self.lay)
    self.connect_()
    self.show()
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Window, self).__init__(parent)
    self.centralwidget = QtGui.QWidget(self)
    self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
    self.scrollArea = QtGui.QScrollArea(self.centralwidget)
    self.scrollArea.setWidgetResizable(True)
    self.scrollAreaWidgetContents = QtGui.QWidget(self.scrollArea)
    self.scrollArea.setWidget(self.scrollAreaWidgetContents)
    self.verticalLayout.addWidget(self.scrollArea)
    self.setCentralWidget(self.centralwidget)

    self.formLayout = QtGui.QFormLayout(self.scrollAreaWidgetContents)
    self.addFiles()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36146398_36146901_9_19
36146398_41556170_10_27
Title: Check if clicks are within a graphic shape (circle) 
----------------------------------------

def main() :
INDENT
    win = GraphWin('Example Window', 100, 100)
    circle = Circle(Point(50, 50), 25)
    circle.setFill('blue')
    circle.draw(win)
    mousePos = win.getMouse()
    if isClicked(circle, mousePos) :
    INDENT
        print "You clicked in the circle!"
    DEDENT
    else :
    INDENT
        print "You clicked outside the circle!"
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    win = GraphWin('Example', 100, 100)
    circle = Circle(Point(50, 50), 25)
    circle.setFill('blue')
    circle.draw(win)
    while True :
    INDENT
        mousePos = win.getMouse()
        if isClicked(circle, mousePos) :
        INDENT
            print ("You clicked in the circle!")
            break
        DEDENT
        else :
        INDENT
            print ("You clicked outside the circle!")
        DEDENT
    DEDENT
    win.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36147597_36147897_1_16
36147597_36149101_8_15
Title: Adding Items To Shopping Cart Django Python 
----------------------------------------

def add_to_cart(request, book_id) :
INDENT
    if request.user.is_authenticated() :
    INDENT
        try :
        INDENT
            book = Book.objects.get(pk = book_id)
        DEDENT
        except ObjectDoesNotExist :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            try :
            INDENT
                cart = Cart.objects.get(user = request.user, active = True)
            DEDENT
            except ObjectDoesNotExist :
            INDENT
                cart = Cart.objects.create(user = request.user)
                cart.save()
            DEDENT
            cart.add_to_cart(book_id)
        DEDENT
        return redirect('cart')
    DEDENT
    else :
    INDENT
        return redirect('index')
    DEDENT
DEDENT
----------------------------------------

def add_to_cart(request, book_id) :
INDENT
    book = get_object_or_404(Book, pk = book_id)
    cart, created = Cart.objects.get_or_create(user = request.user, active = True)
    order, created = BookOrder.objects.get_or_create(book = book, cart = cart)
    order.quantity += 1
    order.save()
    messages.success(request, "Cart updated!")
    return redirect('cart')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36183145_36183393_7_12
36183145_36218393_4_14
Title: Django DRY class based view 
----------------------------------------

def get_initial(self, ** kwargs) :
INDENT
    initial = super(PostCreate, self).get_initial(** kwargs)
    if self.blog is not None :
    INDENT
        initial ['blog'] = self.blog
    DEDENT
    return initial
DEDENT
----------------------------------------

def get_initial(self, ** kwargs) :
INDENT
    context = self.get_context_data(** kwargs)
    blog_pk = self.kwargs.get('product_pk', None)
    self.blog = None
    if blog_pk :
    INDENT
        try :
        INDENT
            self.blog = Blog.objects.get(pk = blog_pk)
            return {"blog" : self.blog}
        DEDENT
        except Blog.DoesNotExist :
        INDENT
            return {}
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36186013_36186423_2_7
36186013_36190595_1_13
Title: kivy How to get text in TextInput? 
----------------------------------------

def messageShow(self, evt) :
INDENT
    if self.txt1.text == "stock" :
    INDENT
        pop = Popup(text = "yes")
    DEDENT
    else :
    INDENT
        pop = Popup(text = "error")
    DEDENT
DEDENT
----------------------------------------

def messageShow(message) :
INDENT
    if message == "stock" :
    INDENT
        btn3 = Button(text = 'Close me!')
        pop = Popup(content = btn3, title = 'Information Message !')
        pop.open()
        btn3.bind(on_press = pop.dismiss)
    DEDENT
    else :
    INDENT
        btn3 = Button(text = 'Exit')
        pop = Popup(content = btn3, title = 'Information Message !')
        pop.open()
        btn3.bind(on_press = pop.dismiss)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36192308_36192700_1_17
36192308_36193017_1_21
Title: How to find the largest palindrome made of two three digit numbers in python? 
----------------------------------------

def Problem4() :
INDENT
    y = 100
    a = []
    x1 = []
    y1 = []
    while y < 1000 :
    INDENT
        y = y + 1
        x = 100
        while x < 1000 :
        INDENT
            z = x * y
            if str(z) == str(z) [: : - 1] :
            INDENT
                a.append(z)
            DEDENT
            x = x + 1
        DEDENT
    DEDENT
    a.sort()
    print (a)
DEDENT
----------------------------------------

def Problem4() :
INDENT
    y = 909
    a = []
    b = []
    x1 = []
    y1 = []
    while y < 1000 :
    INDENT
        x = 100
        while x < 1000 :
        INDENT
            z = x * y
            if str(z) == str(z) [: : - 1] :
            INDENT
                a.append(z)
                x1.append(x)
                y1.append(y)
            DEDENT
            else :
            INDENT
                b.append(z)
            DEDENT
            x = x + 1
        DEDENT
        y = y + 1
    DEDENT
    print (a)
    print (x1)
    print (y1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36203492_36204083_1_16
36203492_36204113_3_25
Title: "Reading data from a file in python but taking specific data from the file throughout" 
----------------------------------------

def Cucumber_Scoreboard() :
INDENT
    with open('veggies_2015.dat', 'r') as in_file :
    INDENT
        data = []
        try :
        INDENT
            while True :
            INDENT
                rec = read_data(in_file)
                data.append(rec)
            DEDENT
        DEDENT
        except StopIteration :
        INDENT
            pass
        DEDENT
    DEDENT
    data_sorted = sorted(data, key = lambda x : x ["cucumber"])
    return data_sorted
DEDENT
----------------------------------------

def Cucumber_Scoreboard() :
INDENT
    with open('name_example.txt', 'r') as f :
    INDENT
        count = 0
        excess_count = 0
        complete_person_list = []
        sublist = []
        for line in f :
        INDENT
            if count < 3 :
            INDENT
                print (line)
                sublist.append(line.replace('\n', ''))
                count += 1
            DEDENT
            elif count == 3 and excess_count < 1 :
            INDENT
                excess_count += 1
            DEDENT
            else :
            INDENT
                count = 0
                excess_count = 0
                complete_person_list.append(sublist)
                sublist = []
            DEDENT
        DEDENT
        sorted_list = sorted(complete_person_list, key = itemgetter(2), reverse = True)
    DEDENT
    return sorted_list
DEDENT
----------------------------------------
