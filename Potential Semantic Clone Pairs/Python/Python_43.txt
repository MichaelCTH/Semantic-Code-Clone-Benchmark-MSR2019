$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44676100_44676642_1_8
44676100_44678052_19_26
Title: Python: Unable to call function when in while loop 
----------------------------------------

def menu() :
INDENT
    mode = input("""Choose options:\n
    a) Test1 Calls logged() function
    b) Test2
    Enter the letter to select mode\n
    > """)
    return mode
DEDENT
----------------------------------------

def menu() :
INDENT
    mode = input("""Choose options:\n
    a) Test1 Calls logged() function
    b) Test2
    Enter the letter to select mode\n
    > """)
    return mode
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44690907_44708822_38_48
44690907_44708822_8_19
Title: sge-pygame rotating parent and child sprites 
----------------------------------------

def __init__(self, pos, offset, * groups) :
INDENT
    super().__init__(groups)
    self.image = pg.Surface((50, 30), pg.SRCALPHA)
    self.image.fill(pg.Color('mediumaquamarine'))
    self.orig_image = self.image
    self.rect = self.image.get_rect(center = pos)
    self.pos = Vector2(pos)
    self.offset = Vector2(offset)
    self.angle = 0
DEDENT
----------------------------------------

def __init__(self, pos, * groups) :
INDENT
    super().__init__(groups)
    self.image = pg.Surface((90, 40), pg.SRCALPHA)
    self.image.fill(pg.Color('steelblue2'))
    self.orig_image = self.image
    self.rect = self.image.get_rect(center = pos)
    self.vel = Vector2(0, 0)
    self.pos = Vector2(pos)
    self.angle = 0
    self.children = [Child(self.pos, Vector2(90, 30), * groups)]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44690907_44708822_38_48
44690907_44709019_32_45
Title: sge-pygame rotating parent and child sprites 
----------------------------------------

def __init__(self, pos, offset, * groups) :
INDENT
    super().__init__(groups)
    self.image = pg.Surface((50, 30), pg.SRCALPHA)
    self.image.fill(pg.Color('mediumaquamarine'))
    self.orig_image = self.image
    self.rect = self.image.get_rect(center = pos)
    self.pos = Vector2(pos)
    self.offset = Vector2(offset)
    self.angle = 0
DEDENT
----------------------------------------

def __init__(self, position, size) :
INDENT
    super().__init__()
    self.original_image = pygame.Surface(size)
    self.original_image.fill((255, 0, 0))
    self.original_image.set_colorkey(BACKGROUND_COLOR)
    self.image = self.original_image
    self.rect = self.image.get_rect(center = position)
    self.angle = 0
    self.position = pygame.math.Vector2(position)
    self.velocity = pygame.math.Vector2(0, 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44690907_44708822_64_95
44690907_44709019_56_86
Title: sge-pygame rotating parent and child sprites 
----------------------------------------

def main() :
INDENT
    screen = pg.display.set_mode((640, 480))
    clock = pg.time.Clock()
    sprite_group = pg.sprite.Group()
    player = Player((100, 250), sprite_group)
    done = False
    while not done :
    INDENT
        for event in pg.event.get() :
        INDENT
            if event.type == pg.QUIT :
            INDENT
                done = True
            DEDENT
            elif event.type == pg.KEYDOWN :
            INDENT
                if event.key == pg.K_d :
                INDENT
                    player.vel.x = 5
                DEDENT
                elif event.key == pg.K_r :
                INDENT
                    player.rotate(15)
                DEDENT
                elif event.key == pg.K_c :
                INDENT
                    player.children.append(Child(
                            player.pos, Vector2(- 90, - 30), sprite_group))
                DEDENT
            DEDENT
            elif event.type == pg.KEYUP :
            INDENT
                if event.key == pg.K_d :
                INDENT
                    player.vel.x = 0
                DEDENT
            DEDENT
        DEDENT
        sprite_group.update()
        screen.fill((30, 30, 30))
        sprite_group.draw(screen)
        pg.display.flip()
        clock.tick(30)

    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    parent = Entity(position = (200, 200), size = (128, 32))
    child = Entity(position = (356, 200), size = (32, 32))
    all_sprites = pygame.sprite.Group(parent, child)
    running = True
    while running :
    INDENT

        dt = clock.tick(FPS) / 1000
        for event in pygame.event.get() :
        INDENT
            if event.type == pygame.QUIT :
            INDENT
                running = False
            DEDENT
            elif event.type == pygame.KEYDOWN :
            INDENT
                if event.key == pygame.K_q :
                INDENT
                    update_child_rotation(parent, child, 10, 156)
                DEDENT
                elif event.key == pygame.K_e :
                INDENT
                    update_child_rotation(parent, child, - 10, 156)
                DEDENT
            DEDENT
            elif event.type == pygame.KEYUP :
            INDENT
                if event.key == pygame.K_RIGHT or event.key == pygame.K_LEFT :
                INDENT
                    parent.velocity.x = 0
                DEDENT
                elif event.key == pygame.K_DOWN or event.key == pygame.K_UP :
                INDENT
                    parent.velocity.y = 0
                DEDENT
            DEDENT
        DEDENT
        all_sprites.update(dt)
        screen.fill(BACKGROUND_COLOR)
        all_sprites.draw(screen)
        pygame.display.update()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44690907_44708822_8_19
44690907_44709019_32_45
Title: sge-pygame rotating parent and child sprites 
----------------------------------------

def __init__(self, pos, * groups) :
INDENT
    super().__init__(groups)
    self.image = pg.Surface((90, 40), pg.SRCALPHA)
    self.image.fill(pg.Color('steelblue2'))
    self.orig_image = self.image
    self.rect = self.image.get_rect(center = pos)
    self.vel = Vector2(0, 0)
    self.pos = Vector2(pos)
    self.angle = 0
    self.children = [Child(self.pos, Vector2(90, 30), * groups)]
DEDENT
----------------------------------------

def __init__(self, position, size) :
INDENT
    super().__init__()
    self.original_image = pygame.Surface(size)
    self.original_image.fill((255, 0, 0))
    self.original_image.set_colorkey(BACKGROUND_COLOR)
    self.image = self.original_image
    self.rect = self.image.get_rect(center = position)
    self.angle = 0
    self.position = pygame.math.Vector2(position)
    self.velocity = pygame.math.Vector2(0, 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44700189_44700391_1_32
44700189_44700548_1_20
Title: Python Text Parsing & Splitting 
----------------------------------------

def normalize(utterance) :
INDENT
    utterance = ' '.join(utterance.lower().split())
    print utterance
    punctuations_list = [',', '.', '?', ':', ';', '!', ')', '(', '\'']
    for punctuation in utterance :
    INDENT
        if punctuation in punctuations_list :
        INDENT
            print punctuation
            try :
            INDENT
                char_before = str(utterance [utterance.index(punctuation) - 1])
                char_after = str(utterance [utterance.index(punctuation) + 1])
            DEDENT
            except IndexError :
            INDENT
                char_after = "0"
            DEDENT
            print char_before
            if char_before.isdigit() == False and char_before not in punctuations_list :
            INDENT
                utterance = utterance.replace(char_before + punctuation, char_before + " " + punctuation)
            DEDENT
            if char_before.isdigit() == True :
            INDENT
                utterance = utterance.replace(punctuation, "" + punctuation)
            DEDENT
            if char_after.isdigit() == False and char_after not in punctuations_list :
            INDENT
                utterance = utterance.replace(punctuation + char_after, punctuation + " " + char_after)
            DEDENT
        DEDENT
    DEDENT
    return utterance
DEDENT
----------------------------------------

def normalize(utterance) :
INDENT
    utterance = ' '.join(utterance.lower().split())
    punctuations_list = [',', '.', '?', ':', ';', '!', ')', '(', '\'']

    target = utterance [0]
    for i in range(1, len(utterance) - 1) :
    INDENT
        ch = utterance [i]
        char_before = utterance [i - 1]
        char_after = utterance [i + 1]
        if ch in punctuations_list and not char_before.isdigit() and char_before not in punctuations_list :
        INDENT
            target += " "
        DEDENT
        target += ch
        if ch in punctuations_list and not char_after.isdigit() and char_after not in punctuations_list :
        INDENT
            target += " "
        DEDENT
    DEDENT
    target += utterance [- 1]
    return target
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44711521_44753147_36_58
44711521_44753147_4_20
Title: tkinter tk/toplevel execution pauses a callback's execution? 
----------------------------------------

def __init__(self) :
INDENT
    self.string = None

    self.window = Toplevel()
    self.input = Entry(self.window)
    self.input.bind("<Return>", self.on_set_string)
    set_button = Button(
        self.window,
        command = self.on_set_string,
        text = "Set")

    self.input.pack(side = LEFT)
    set_button.pack(side = RIGHT)
    return
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.window = Tk()
    get_string = Button(
        self.window,
        command = self.on_get_string,
        text = "Open string")

    get_string.pack()
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44712022_44712363_1_10
44712022_44712457_13_18
Title: Django 1.11: post form data to database 
----------------------------------------

def content_get(request) :
INDENT
    if request.method == 'POST' :
    INDENT
        form = ContentForm(request.POST)
        if form.is_valid() :
        INDENT
            instance = form.save()
            return HttpResponse('create success')
        DEDENT
        else :
        INDENT
            return HttpResponse(forms.errors)
        DEDENT
    DEDENT
    else :
    INDENT
        return render(request, 'main.html', {'form' : form})
    DEDENT
DEDENT
----------------------------------------

def content_get(request) :
INDENT
    if request.method == 'POST' :
    INDENT
        form = ContentForm(request.POST)
        if form.is_valid() :
        INDENT
            form.save()
        DEDENT
        return redirect('/')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44718670_44741456_9_16
44718670_47594310_10_19
Title: mock_s3 decorating pytest fixture 
----------------------------------------

def moto_boto() :
INDENT
    @ mock_s3
    def boto_resource() :
    INDENT
        res = boto3.resource('s3')
        res.create_bucket(Bucket = BUCKET)
        return res
    DEDENT
    return boto_resource
DEDENT
----------------------------------------

def moto_boto() :
INDENT
    mock_s3().start()
    res = boto3.resource('s3')
    res.create_bucket(Bucket = BUCKET)
    yield
    mock_s3.stop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44728706_44729344_1_17
44728706_44729425_21_31
Title: Detecting when the TextBox has been edited rather than detecting key press? 
----------------------------------------

def add_to_text(self) :
INDENT
    if self.text.edit_modified() :
    INDENT

        answer = messagebox.askquestion("Update TextBox",
            "Are you sure you want change the content of the TextBox? Any unsaved changed will be lost!")
        if answer ! = "yes" :
        INDENT
            return
        DEDENT
    DEDENT
    self.text.delete(1.0, "end-1c")
    self.text.insert("end-1c", "Some other text to work with.\nMore text.")
    self.text.see("end-1c")

    self.text.edit_modified(False)
DEDENT
----------------------------------------

def add_to_text(self, text) :
INDENT
    if self.text.edit_modified() and not messagebox.askyesno("Update TextBox",
        "Are you sure you want change the content of the TextBox? Any unsaved changed will be lost!") :
    INDENT
        return
    DEDENT
    self.text.delete(1.0, tk.END)
    self.text.insert(1.0, text)
    self.text.see(tk.END)
    self.text.edit_modified(False)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44731601_44731717_1_20
44731601_44732089_4_12
Title: "Python strange loop" 
----------------------------------------

def detect_anagrams(word, candidates) :
INDENT
    word_lower = word.lower()
    word_set = set(word_lower)
    anagrams = []
    for candidate in candidates :
    INDENT

        candidate_lower = candidate.lower()
        if set(candidate_lower) == word_set :
        INDENT
            if candidate_lower ! = word_lower :
            INDENT
                for character in candidate_lower :
                INDENT
                    if candidate_lower.count(character) ! = word_lower.count(character) :
                    INDENT
                        break
                    DEDENT
                DEDENT
                else :
                INDENT
                    anagrams.append(candidate)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return anagrams
DEDENT
----------------------------------------

def detect_anagrams(word, candidates) :
INDENT
    anagrams = []
    for element in candidates :
    INDENT
        if element == word :
        INDENT
            continue
        DEDENT
        if not any(element.count(char) > word.count(char) for char in element) :
        INDENT
            anagrams.append(element)
        DEDENT
    DEDENT
    return anagrams
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44742127_47168173_22_31
44742127_48275252_1_21
Title: Codefights areSimilar challenge in python3 
----------------------------------------

def areSimilar(a, b) :
INDENT
    if check(a, b) ! = - 1 :
    INDENT
        i = check(a, b)
        if swp(i, a, b) == - 1 :
        INDENT
            swp(i, a, b)
            if check(a, b) ! = - 1 :
            INDENT
                return False
            DEDENT
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def areSimilar(a, b) :
INDENT
    swap = False
    for i, x, y in zip(range(len(a)), a, b) :
    INDENT
        if x == y :
        INDENT
            pass
        DEDENT
        elif (x ! = y) and (swap == False) :
        INDENT
            try :
            INDENT
                k = b.index(x)
            DEDENT
            except :
            INDENT
                return False
            DEDENT
            b [k] = y
            swap = True
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44742127_47168173_22_31
44742127_51005987_1_18
Title: Codefights areSimilar challenge in python3 
----------------------------------------

def areSimilar(a, b) :
INDENT
    if check(a, b) ! = - 1 :
    INDENT
        i = check(a, b)
        if swp(i, a, b) == - 1 :
        INDENT
            swp(i, a, b)
            if check(a, b) ! = - 1 :
            INDENT
                return False
            DEDENT
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def areSimilar(a, b) :
INDENT
    count = 0
    list_a = []
    list_b = []
    for i in range(len(a)) :
    INDENT
        if (a [i] ! = b [i]) :
        INDENT
            count += 1
            list_a.append(a [i])
            list_b.append(b [i])
        DEDENT
    DEDENT
    if (count == 0) :
    INDENT
        return True
    DEDENT
    elif count == 2 :
    INDENT
        return set(list_a) == set(list_b)
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44742127_48275252_1_21
44742127_51005987_1_18
Title: Codefights areSimilar challenge in python3 
----------------------------------------

def areSimilar(a, b) :
INDENT
    swap = False
    for i, x, y in zip(range(len(a)), a, b) :
    INDENT
        if x == y :
        INDENT
            pass
        DEDENT
        elif (x ! = y) and (swap == False) :
        INDENT
            try :
            INDENT
                k = b.index(x)
            DEDENT
            except :
            INDENT
                return False
            DEDENT
            b [k] = y
            swap = True
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def areSimilar(a, b) :
INDENT
    count = 0
    list_a = []
    list_b = []
    for i in range(len(a)) :
    INDENT
        if (a [i] ! = b [i]) :
        INDENT
            count += 1
            list_a.append(a [i])
            list_b.append(b [i])
        DEDENT
    DEDENT
    if (count == 0) :
    INDENT
        return True
    DEDENT
    elif count == 2 :
    INDENT
        return set(list_a) == set(list_b)
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44742709_44744191_20_42
44742709_44767807_4_15
Title: (Kivy) How to address a specific button in a menu? 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(LandingScreen, self).__init__(** kwargs)
    self.add_widget(Button(text = 'Hello 1', background_color = (.5,.5,.5, 1)))
    self.add_widget(Button(text = 'Hello 1'))
    self.add_widget(Button(text = 'Hello 2'))
    self.add_widget(Button(text = 'World 2'))
    self.add_widget(Button(text = 'Hello 1'))
    self.add_widget(Button(text = 'World 1'))
    self.add_widget(Button(text = 'Hello 2'))
    self.add_widget(Button(text = 'World 2'))
    self.add_widget(Button(text = 'Hello 1'))
    self.add_widget(Button(text = 'World 1'))
    self.add_widget(Button(text = 'Hello 2'))
    self.add_widget(Button(text = 'World 2'))
    self.add_widget(Button(text = 'Hello 1'))
    self.add_widget(Button(text = 'World 1'))
    self.add_widget(Button(text = 'Hello 2'))
    self.add_widget(Button(text = 'World 2'))
    self.add_widget(Button(text = 'Hello 1'))
    self.add_widget(Button(text = 'World 1'))
    self.add_widget(Button(text = 'Hello 2'))
    self.add_widget(Button(text = 'World 2'))
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(LandingScreen, self).__init__(** kwargs)
    self.cols = 5
    Color(.5,.5,.5, 1)
    self.buttons = []
    for x in range(20) :
    INDENT
        self.buttons.append(Button(text = 'button ' + str(x)))
        self.add_widget(self.buttons [x])
    DEDENT
    self.buttons [0].background_color = (0, 0.8, 0, 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44782866_44782926_1_11
44782866_44782973_1_12
Title: Combine two python with statements that share the same code 
----------------------------------------

def test(file_name) :
INDENT
    loader = None
    if file_name.lower().endswith('.gz') :
    INDENT
        loader = gzip.open
    DEDENT
    elif file_name.lower().endswith('.csv') :
    INDENT
        loader = open
    DEDENT
    if loader is not None :
    INDENT
        with loader(file_name) as f :
        INDENT
            f_csv = csv.reader(i.TextIOWrapper(f))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def test(file_name) :
INDENT
    f = None
    if file_name.lower().endswith('.gz') :
    INDENT
        f = gzip.open(file_name)
    DEDENT
    if file_name.lower().endswith('.csv') :
    INDENT
        f = open(file_name)
    DEDENT
    if f is not None :
    INDENT
        f_csv = csv.reader(i.TextIOWrapper(f))
        f.close()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44786848_44787371_1_15
44786848_44788119_1_20
Title: How to efficiently find identical indices in multiple dataframes 
----------------------------------------

def report_diff_index(self, dnc_data, folders) :
INDENT
    master_report_dict, master_val_dict = self.report_orderer(folders)
    sorts = self.report_sorter(dnc_data, master_tree)

    unique_keys = set(sorts.keys())
    consolidated_report = {}
    consolidated_val = {}
    for key in unique_keys :
    INDENT
        consolidated_report [key] = master_report_dict [key]
        consolidated_val [key] = master_val_dict [key]
    DEDENT
    return consolidated_report, consolidated_val
DEDENT
----------------------------------------

def report_diff_index(self, dnc_data, folders) :
INDENT
    master_report_dict, master_val_dict = self.report_orderer(folders)
    sorts = self.report_sorter(dnc_data, master_report_dict)
    print ('Original Report Size: ', len(sorts))
    unique_reports = dict()
    for report_key, report in sorts.items :
    INDENT
        key = frozenset(report.index)
        unique_reports [key] = report_key
        if key not in unique_reports :
        INDENT
            unique_reports [key] = report_key
        DEDENT
    DEDENT
    consolidated_sorts = unique_reports.values()
    print ('Consolidated Report Size: ', len(consolidated_sorts))
    consolidated_report = {}
    consolidated_val = {}
    for s in consolidated_sorts :
    INDENT
        consolidated_report [s] = master_report_dict [s]
        consolidated_val [s] = master_val_dict [s]
    DEDENT
    return consolidated_report, consolidated_val
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44800759_44818436_36_52
44800759_44818436_69_97
Title: PyQt5 threading GUI does not work 
----------------------------------------

def __init__(self, msg = 'Loading ', parent = None) :
INDENT
    super(InfoMessage, self).__init__(parent)
    uic.loadUi('loading.ui', self)

    self.o_msg = msg
    self.msg = msg
    self.val = 0
    self.info_label.setText(msg)
    self.show()
    self.timer = QtCore.QTimer()
    self.timer.setInterval(500)
    self.timer.timeout.connect(self.update_message)
    self.timer.start()
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainDialog, self).__init__(parent)

    self.my_thread = LongRunning(limit = 10)
    self.my_thread.start()
    self.my_loader = InfoMessage('Loading ')
    self.my_thread.finished.connect(self.my_loader.loading_stop)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44813564_44815642_12_25
44813564_44837474_13_23
Title: Python multithreading issue 
----------------------------------------

def run(self) :
INDENT
    print ("run() starts.")
    path = "./sample.fifo"
    fifo = open(path, "r")
    count = 0
    for line in fifo :
    INDENT
        count = count + 1
        self.dict_buffer [count] = line
        print ("in for expression: before show_dict()")
        self.show_dict()
    DEDENT
    fifo.close()
    print ("run() completes.")
DEDENT
----------------------------------------

def run(self) :
INDENT
    print ("Begin inner thread run...")
    path = "/media/ramdisk/sample.fifo"
    count = 0
    with open(path, "r") as fifo :
    INDENT
        for line in fifo :
        INDENT
            count += 1
            self.dict_buffer [count] = line
        DEDENT
    DEDENT
    print ("End inner thread run")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44815835_44815859_1_8
44815835_44815901_1_10
Title: Detecting escape sequences in Python 3 
----------------------------------------

def quote_me(phrase) :
INDENT
    if phrase.startswith("\"") :
    INDENT
        print ('\'' + phrase [1 : - 1] + '\'')
    DEDENT
    if phrase.startswith('\'') :
    INDENT
        print ("\"" + phrase [1 : - 1] + "\"")
    DEDENT
    else :
    INDENT
        print ("use quotations in your input for phrase")
    DEDENT
DEDENT
----------------------------------------

def quote_me(phrase) :
INDENT
    if phrase [0] == "\"" :
    INDENT
        print ('dq')
        print ('\'', phrase [1 : - 1], '\'')
    DEDENT
    elif phrase [0] == ('\'') :
    INDENT
        print ('sq')
        print ("\"", phrase [1 : - 1], "\"")
    DEDENT
    else :
    INDENT
        print ("use quotations in your input for phrase")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44821118_44822342_14_21
44821118_44822347_5_18
Title: Python Saving files in different folders 
----------------------------------------

def saver(my, info) :
INDENT
    with open(file2_path + '/save.txt', 'a') as f :
    INDENT
        for i in info :
        INDENT
            f.write(info)
        DEDENT
    DEDENT
    lo = info [0]
    with open(file1_path + '/txt.txt', 'a') as f :
    INDENT
        for i in lo :
        INDENT
            f.write(lo)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def saver(self, info) :
INDENT
    path_name = os.path.join(completeName, 'file2')
    if not os.path.exists(path_name) :
    INDENT
        os.makedirs(path_name)
    DEDENT
    with open(os.path.join(path_name, 'save.txt'), 'a') as f :
    INDENT
        for i in info :
        INDENT
            f.write(info)
        DEDENT
    DEDENT
    lo = info [0]
    path_name = os.path.join(completeName, 'file1')
    if not os.path.exists(path_name) :
    INDENT
        os.makedirs(path_name)
    DEDENT
    with open(os.path.join(path_name, 'txt.txt'), 'a') as f :
    INDENT
        for i in lo :
        INDENT
            f.write(lo)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44849849_44849965_16_22
44849849_44849991_16_22
Title: Passing parameters instead of globals 
----------------------------------------

def load_more(clickLoad) :
INDENT
    print (clickLoad)
    while clickLoad < 0 :
    INDENT

        clickLoad -= 1
    DEDENT
    return clickLoad
DEDENT
----------------------------------------

def load_more(clickLoad) :
INDENT
    print (clickLoad)
    while clickLoad < 0 :
    INDENT

        clickLoad -= 1
    DEDENT
    return clickLoad
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44854248_44854341_1_12
44854248_44854395_1_12
Title: Specific Indentation error in nested if statement in for loop 
----------------------------------------

def login() :
INDENT
    print ("*****LOGIN SCREEN******")
    username = input("Username: ")
    password = input("Password: ")
    found = False
    for index_of_current_user, current_user in enumerate(usernames) :
    INDENT
        if username == current_user and passwords [index_of_current_user] == password :
        INDENT
            print ("correct login")
            found = True
            break
        DEDENT
    DEDENT
    if found == False :
    INDENT
        print ("invalid username or password")
    DEDENT
DEDENT
----------------------------------------

def login() :
INDENT
    print ("*****LOGIN SCREEN******")
    username = input("Username: ")
    password = input("Password: ")
    try :
    INDENT
        index = usernames.index(username)
        if password == passwords [index] :
        INDENT
            print ("correct login")
        DEDENT
        else :
        INDENT
            print ("invalid username or password")
        DEDENT
    DEDENT
    except :
    INDENT
        print ("invalid username or password")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44854248_44854395_1_12
44854248_44854441_1_13
Title: Specific Indentation error in nested if statement in for loop 
----------------------------------------

def login() :
INDENT
    print ("*****LOGIN SCREEN******")
    username = input("Username: ")
    password = input("Password: ")
    try :
    INDENT
        index = usernames.index(username)
        if password == passwords [index] :
        INDENT
            print ("correct login")
        DEDENT
        else :
        INDENT
            print ("invalid username or password")
        DEDENT
    DEDENT
    except :
    INDENT
        print ("invalid username or password")
    DEDENT
DEDENT
----------------------------------------

def login() :
INDENT
    print ("*****LOGIN SCREEN******")
    username = input("Username: ")
    password = input("Password: ")
    correct_login = False
    for index_of_current_user, current_user in enumerate(usernames) :
    INDENT
        if username == current_user and passwords [index_of_current_user] == password :
        INDENT
            correct_login = True
            break
        DEDENT
    DEDENT
    if (correct_login) :
    INDENT
        print ("correct login")
    DEDENT
    else :
    INDENT
        print ("invalid user name or password")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44857651_44857843_12_22
44857651_44857986_2_11
Title: 2 lists permutations in python 
----------------------------------------

def is_list_permutation(list1, list2) :
INDENT
    if (isPermutation(list1, list2) == False) :
    INDENT
        return False
    DEDENT
    elif not list1 :
    INDENT
        return (None, None, None)
    DEDENT
    else :
    INDENT
        mostOccurItem = max(set(list1), key = list1.count)
        numberOfTimes = list1.count(mostOccurItem)
        theType = type(mostOccurItem)
        return (mostOccurItem, numberOfTimes, theType)
    DEDENT
DEDENT
----------------------------------------

def is_list_permutation(l1, l2) :
INDENT
    c1 = Counter(l1)
    c2 = Counter(l2)
    if c1 ! = c2 :
    INDENT
        return False
    DEDENT
    elif len(c1) == 0 :
    INDENT
        return (None, None, None)
    DEDENT
    else :
    INDENT
        t = c1.most_common(1) [0]
        return t + (type(t [0]),)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44857817_44858007_8_14
44857817_44859108_12_33
Title: How can I shuffle a very large list stored in a file in Python? 
----------------------------------------

def draw(self) :
INDENT
    number = random.randint(0, 2 ** 32)
    while number in self.usedNumbers :
    INDENT
        number = random.randint(0, 2 ** 32)
    DEDENT
    self.usedNumbers.append(number)
    return number
DEDENT
----------------------------------------

def draw(self) :
INDENT
    if self._free() == 0 :
    INDENT
        return False

    DEDENT
    i = random.randint(0, 2 ** 32 - 1)

    while self.used [i] :
    INDENT
        i = (i + 1) % 2 ** 32

    DEDENT
    self.used [i] = True

    return i
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44870877_44871978_5_22
44870877_44872133_18_51
Title: Rows in tkinter grid 
----------------------------------------

def __init__(self, field_names, database) :
INDENT
    self.root = tk.Tk()
    self.window = ttk.Frame(self.root, borderwidth = 2,
        relief = "raised", padding = (10, 10))
    self.window.grid()

    for col, field_name in enumerate(field_names) :
    INDENT
        self.add_field(field_name, 0, col, background = '#ccf')

    DEDENT
    for row, record in enumerate(database, 1) :
    INDENT
        for col, field_name in enumerate(field_names) :
        INDENT
            self.add_field(record [field_name], row, col)
        DEDENT
    DEDENT
    self.root.mainloop()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tk()
    self.root.title('Control V' + __version__)
    self.root.geometry('500x400')
    self.root.configure(bg = 'beige')
    self.root.minsize(400, 300)
    self.window = ttk.Frame(self.root, borderwidth = 2, relief = "raised",
        padding = (10, 10))
    self.window.grid(column = 0, row = 0)
    self.window.option_add("*Font", "Helvetica 12")
    self.listbox = Listbox(self.window)
    self.listbox.grid(row = 0, column = 0, sticky = N + E + S + W)
    self.scrollbar = Scrollbar(self.window)
    self.scrollbar.grid(row = 0, column = 1, sticky = N + S)
    self.listbox.config(yscrollcommand = self.scrollbar.set)
    self.scrollbar.config(command = self.listbox.yview)

    self.listbox.insert(END, "Header")

    endless_data = cycle(db)
    for i in range(20) :
    INDENT
        row = next(endless_data)
        line = '{Name:5} {Age:2} {Class}'.format(** row)
        self.listbox.insert(END, line)

    DEDENT
    self.root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44877880_44878038_6_15
44877880_44878044_6_14
Title: Use of Global Variables in Python? 
----------------------------------------

def main() :
INDENT
    global df1
    df1 = pd.DataFrame(np.array([['a', 5, 9],
                ['b', 4, 61],
                ['c', 24, 9]]),
        columns = ['name', 'attr1', 'attr2'])
    print (df1)
    print_df_in_a_function()
DEDENT
----------------------------------------

def main() :
INDENT
    df1 = pd.DataFrame(np.array([['a', 5, 9],
                ['b', 4, 61],
                ['c', 24, 9]]),
        columns = ['name', 'attr1', 'attr2'])
    print (df1)
    print_df_in_a_function(df1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44914234_44914272_1_14
44914234_44914395_1_10
Title: Print n choose k combination algorithm using recursion 
----------------------------------------

def Print_nCk(the_list, k, str_builder, used, prev = 0) :
INDENT
    if len(str_builder) == k :
    INDENT
        print str_builder
        return
    DEDENT
    else :
    INDENT
        for i in xrange(prev, len(the_list)) :
        INDENT
            if used [i] ! = True :
            INDENT
                str_builder += the_list [i]
                used [i] = True
                Print_nCk(the_list, k, str_builder, used, i + 1)
                str_builder = str_builder [: - 1]
                used [i] = False

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def Print_nCk(the_list, size) :
INDENT
    combs = []
    if size == 1 :
    INDENT
        return the_list
    DEDENT
    for i, c in enumerate(the_list [: - size + 1]) :
    INDENT
        for sub_comb in Print_nCk(the_list [i + 1 :], size - 1) :
        INDENT
            combs.append(c + sub_comb)
        DEDENT
    DEDENT
    return combs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44922108_44923311_3_14
44922108_44923392_2_9
Title: Python: parsing a string of concatenated ascending integers 
----------------------------------------

def numbers(a, n) :
INDENT
    current_num, i = 0, 0
    while True :
    INDENT
        while i + n < = len(a) and int(a [i : i + n]) < = current_num :
        INDENT
            n += 1
        DEDENT
        if i + n < = len(a) :
        INDENT
            current_num = int(a [i : i + n])
            yield current_num
            i += n
        DEDENT
        else :
        INDENT
            return
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def numbers(a, n) :
INDENT
    current_num, i = 0, 0
    while True :
    INDENT
        while i + n < = len(a) and int(a [i : i + n]) < = current_num : n += 1
        if i + 2 * n > len(a) : current_num = int(a [i :]); yield current_num; return
        elif i + n < = len(a) : current_num = int(a [i : i + n]); yield current_num; i += n
        else : return
        print (current_num)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4494404_31167622_1_17
4494404_4495197_15_39
Title: Find large number of consecutive values fulfilling condition in a numpy array 
----------------------------------------

def contiguous_regions(condition) :
INDENT
    idx = []
    i = 0
    while i < len(condition) :
    INDENT
        x1 = i + condition [i :].argmax()
        try :
        INDENT
            x2 = x1 + condition [x1 :].argmin()
        DEDENT
        except :
        INDENT
            x2 = x1 + 1
        DEDENT
        if x1 == x2 :
        INDENT
            if condition [x1] == True :
            INDENT
                x2 = len(condition)
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        idx.append([x1, x2])
        i = x2
    DEDENT
    return idx
DEDENT
----------------------------------------

def contiguous_regions(condition) :
INDENT
    d = np.diff(condition)
    idx, = d.nonzero()

    idx += 1
    if condition [0] :
    INDENT

        idx = np.r_ [0, idx]
    DEDENT
    if condition [- 1] :
    INDENT

        idx = np.r_ [idx, condition.size]

    DEDENT
    idx.shape = (- 1, 2)
    return idx
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44947729_44948063_1_12
44947729_44948302_3_22
Title: split a large file into small file based on pattern that can occur randomly Python 
----------------------------------------

def split_file(filename) :
INDENT
    dest = {}
    with open(filename) as source :
    INDENT
        header_line = next(source)
        for line in source :
        INDENT
            name = line.rstrip().split() [- 1]
            if name not in dest :
            INDENT
                dest [name] = open(name + '.txt', 'w')
                dest [name].write(header_line)
            DEDENT
            dest [name].write(line)
        DEDENT
    DEDENT
    for d in dest.values() :
    INDENT
        d.close()
    DEDENT
DEDENT
----------------------------------------

def split_file(path) :
INDENT
    file_handles = {}
    target_path = os.path.dirname(path)
    with open(path, "r") as f :
    INDENT
        header = next(f)
        for line in f :
        INDENT
            index = line.rfind(" ")
            value = line [index + 1 :].rstrip()
            if not value :
            INDENT
                continue
            DEDENT
            if value not in file_handles :
            INDENT

                handle = open(os.path.join(target_path, value + ".txt"), "a")
                handle.write(header)
                file_handles [value] = handle
            DEDENT
            else :
            INDENT
                handle = file_handles [value]
            DEDENT
            handle.write(line)
        DEDENT
    DEDENT
    for handle in file_handles.values() :
    INDENT
        handle.close()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4495003_4495061_1_22
4495003_4501528_2_11
Title: Python: How can I merge these 2 overloaded constructors into 1 constructor 
----------------------------------------

def __init__(self, _app_parent, _db_path, stock_list = None) :
INDENT
    self.db_path = _db_path
    self.app_parent = _app_parent
    self.tracking_stocks = []
    self.registered_stocks = []
    self.total_purchase_exp = 0
    self.ytd_roi = 0
    self.cash_reserve = 500
    if stock_list :
    INDENT
        if database_exists(self.db_path) :
        INDENT
            return None
        DEDENT
        self.create_database()
        self.import_portfolio_data()
        for stock_data in stock_list :
        INDENT
            self.add_stock(stock_data)
        DEDENT
    DEDENT
    else :
    INDENT
        if not self.database_exists(self.db_path) :
        INDENT
            return None
        DEDENT
        self.import_portfolio_data()
        self.import_stocks()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, app_parent, db_path) :
INDENT
    self.db_path = db_path
    self.app_parent = app_parent
    self.tracking_stocks = []
    self.registered_stocks = []
    self.total_purchase_exp = 0
    self.ytd_roi = 0
    self.cash_reserve = 500
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4495176_4495418_1_19
4495176_4495428_1_14
Title: nth word in a text 
----------------------------------------

def my_txt(text, target) :
INDENT
    count = 0
    last_was_space = False
    start = end = 0
    for index, letter in enumerate(text) :
    INDENT
        if letter.isspace() :
        INDENT
            if not last_was_space :
            INDENT
                end = index
            DEDENT
            last_was_space = True
        DEDENT
        elif last_was_space :
        INDENT
            last_was_space = False
            count += 1
            if count > target :
            INDENT
                return text [start : end]
            DEDENT
            elif count == target :
            INDENT
                start = index
            DEDENT
        DEDENT
    DEDENT
    if count == target :
    INDENT
        return text [start :].strip()
    DEDENT
    raise ValueError("Word not found")
DEDENT
----------------------------------------

def my_txt(txt, n, i = 0) :
INDENT
    if n == 1 :
    INDENT
        r = ""
        s = 0
        for c in txt :
        INDENT
            if s > = i :
            INDENT
                if c == " " :
                INDENT
                    return r
                DEDENT
                r += c
            DEDENT
            s += 1
        DEDENT
    DEDENT
    while txt [i] ! = " " :
    INDENT
        i += 1
    DEDENT
    return my_txt(txt, n - 1, i + 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44958501_44959150_9_21
44958501_44959190_1_22
Title: Insertion in Binary Tree (Not BST) Python 
----------------------------------------

def insert(node, val = None) :
INDENT
    if not val :
    INDENT
        return Node(node)
    DEDENT
    if not node.left :
    INDENT
        node.left = val
        return
    DEDENT
    if not node.right :
    INDENT
        node.right = val
        return
    DEDENT
    return insert(node.left, val)
    return insert(node.right, val)

DEDENT
----------------------------------------

def insert(node, val) :
INDENT
    if not node :
    INDENT
        return Node(val)
    DEDENT
    queue = [node]
    while len(queue) > 0 :
    INDENT

        n = queue.pop(0)

        if not n.left :
        INDENT
            n.left = Node(val)
            return node
        DEDENT
        if not n.right :
        INDENT
            n.right = Node(val)
            return node
        DEDENT
        queue.append(n.left)
        queue.append(n.right)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44969383_44969639_1_12
44969383_44969779_91_104
Title: while loop condition needs to check if dictionary contains items and return to main menu if not 
----------------------------------------

def searchplayer() :
INDENT
    print ("===============SEARCH by player: Calculate average goals==================")
    while len(player_info) > 0 :
    INDENT
        print ("Please enter a valid player name:")
        name = input("Player name : ")
        if name in player_info.keys() :
        INDENT
            print ("Average player goals : ", str(sum(player_info [name].values()) / 3.0))
            break
        DEDENT
    DEDENT
    else :
    INDENT
        print ("No players found. Please add some first.")
    DEDENT
    print ()
    mainmenu()
DEDENT
----------------------------------------

def searchplayer() :
INDENT
    print ("===============SEARCH by player: Calculate average goals==================")
    if not player_info :
    INDENT
        print ("you have no players registered")
    DEDENT
    else :
    INDENT
        name = input("Player name : ")
        while name not in player_info.keys() :
        INDENT
            print ("Please enter a valid player name:")
            name = input("Player name: ")
        DEDENT
        print ("Average player goals : ", str(sum(player_info [name].values()) / 3.0))
    DEDENT
    print ()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4497038_4497985_30_42
4497038_4497985_9_20
Title: Algorithm to sum/stack values from a time series graph where data points don't match on time 
----------------------------------------

def next(self) :
INDENT
    xs = [stream.next_x for stream in self.streams if stream.next_x is not None]
    if not xs :
    INDENT
        raise StopIteration()
    DEDENT
    next_x = min(xs)
    current_y = 0
    for stream in self.streams :
    INDENT
        if stream.next_x == next_x :
        INDENT
            stream.next()
        DEDENT
        current_y += stream.current_y
    DEDENT
    self.outseq.append((next_x, current_y))
    return self.outseq [- 1]
DEDENT
----------------------------------------

def next(self) :
INDENT
    if self.next_item is None :
    INDENT
        raise StopIteration()
    DEDENT
    self.current_y = self.next_item [1]
    try :
    INDENT
        self.next_item = self.iterable.next()
        self.next_x = self.next_item [0]
    DEDENT
    except StopIteration :
    INDENT
        self.next_item = None
        self.next_x = None
    DEDENT
    return self.next_item
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44970939_44972963_40_61
44970939_44972963_7_34
Title: Python tkinter frames do not fill parent container using Grid 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)

    self.columnconfigure(0, weight = 1)
    self.rowconfigure(0, weight = 1)
    self.rowconfigure(1, weight = 1)
    self.rowconfigure(2, weight = 1)
    self.rowconfigure(3, weight = 1)
    label = tk.Label(self, text = "Main Page", font = LARGE_FONT)
    label.grid(row = 0, padx = 10, pady = 10)
    button1 = ttk.Button(self, text = "Graphs", command = lambda : controller.show_frame(GraphsPage))
    button1.grid(row = 1, sticky = 'nswe')
    button2 = ttk.Button(self, text = "Page 2", command = lambda : controller.show_frame(Page2))
    button2.grid(row = 2, sticky = 'nswe')
    button3 = ttk.Button(self, text = "Exit", command = quit)
    button3.grid(row = 3, sticky = 'nswe')
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.grid_rowconfigure(0, weight = 1)
    self.grid_columnconfigure(0, weight = 1)
    main_container = tk.Frame(self)
    main_container.grid(column = 0, row = 0, sticky = "nsew")
    main_container.grid_rowconfigure(0, weight = 1)
    main_container.grid_columnconfigure(0, weight = 1)
    menu_bar = tk.Menu(main_container)
    file_menu = tk.Menu(menu_bar, tearoff = 0)
    file_menu.add_command(label = "Save settings", command = lambda : popupmsg("Not supported yet!"))
    file_menu.add_separator()
    file_menu.add_command(label = "Exit", command = quit)
    menu_bar.add_cascade(label = "File", menu = file_menu)
    tk.Tk.config(self, menu = menu_bar)
    self.frames = {}
    for fr in (MainPage,) :
    INDENT
        frame = fr(main_container, self)
        self.frames [fr] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(MainPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44979215_44979585_5_27
44979215_45276499_1_21
Title: Unable to delete rows from .csv file pyexcel 
----------------------------------------

def prepare_file(time, mkt) :
INDENT
    global previous_time
    for file in glob.glob(os.getcwd() + '\Reports\*') :
    INDENT
        if time > previous_time :
        INDENT
            previous_time = time
            fin = open(file, 'r')
            fout = open((os.getcwd() + '\\Reports\\' + mkt [0] + '.csv'), 'w', newline = '')
            reader = csv.reader(fin)
            writer = csv.writer(fout)
            for row in reader :
            INDENT
                if row [1] not in changed_addresses :
                INDENT
                    writer.writerow(row)

                DEDENT
            DEDENT
            fin.close()
            fout.close()

            os.remove(file)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def prepare_file(time, mkt) :
INDENT
    global previous_time
    for file in glob.glob(os.getcwd() + '\Reports\*') :
    INDENT
        if time > previous_time :
        INDENT
            previous_time = time
            sheet = pyexcel.get_sheet(file_name = file)
            indices_to_be_removed = []
            for index, row in enumerate(sheet) :
            INDENT
                if row [1] in changed_addresses :
                INDENT
                    pass
                DEDENT
                else :
                INDENT
                    indices_to_be_removed
                DEDENT
            DEDENT
            del sheet.row [indices_to_be_removed]
            sheet.save_as(
                os.getcwd() + '\\Reports\\' + mkt [0] + '.csv')
            os.remove(file)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44984728_44984836_1_20
44984728_44984837_1_18
Title: Could not get json value while fetching all data from table using python 
----------------------------------------

def view_book(request) :
INDENT
    conn = sqlite3.connect("db.sqlite3")
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute("SELECT  * FROM booking_meeting ORDER BY id desc")
    all_value = cursor.fetchall()
    root = []
    for book in all_value :
    INDENT
        book = dict(book)
        root.append(
            {'lname' : book ["location_name"],
                'roomname' : book ["room_name"],
                'seat' : book ["no_seat"],
                'project' : book ["projector"],
                'video' : book ["video"],
                'from_date' : book ["from_date"],
                'to_date' : book ["to_date"]})
    DEDENT
    return render(request, 'booking/view_book.html', {'people' : root})
DEDENT
----------------------------------------

def view_book(request) :
INDENT
    conn = sqlite3.connect("db.sqlite3")
    cursor = conn.cursor()
    cursor.execute("SELECT  * FROM booking_meeting ORDER BY id desc")
    all_value = cursor.fetchall()
    root = []
    for book in all_value :
    INDENT
        root.append(
            {'lname' : book.location_name,
                'roomname' : book.room_name,
                'seat' : book.no_seat,
                'project' : book.projector,
                'video' : book.video,
                'from_date' : book.from_date,
                'to_date' : book.to_date})
    DEDENT
    return render(request, 'booking/view_book.html', {'people' : root})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44984728_44984836_1_20
44984728_44984843_1_16
Title: Could not get json value while fetching all data from table using python 
----------------------------------------

def view_book(request) :
INDENT
    conn = sqlite3.connect("db.sqlite3")
    conn.row_factory = sqlite3.Row
    cursor = conn.cursor()
    cursor.execute("SELECT  * FROM booking_meeting ORDER BY id desc")
    all_value = cursor.fetchall()
    root = []
    for book in all_value :
    INDENT
        book = dict(book)
        root.append(
            {'lname' : book ["location_name"],
                'roomname' : book ["room_name"],
                'seat' : book ["no_seat"],
                'project' : book ["projector"],
                'video' : book ["video"],
                'from_date' : book ["from_date"],
                'to_date' : book ["to_date"]})
    DEDENT
    return render(request, 'booking/view_book.html', {'people' : root})
DEDENT
----------------------------------------

def view_book(request) :
INDENT
    all_value = BookingMeeting.objects.order_by('-id')
    root = []
    for book in all_value :
    INDENT
        root.append(
            {'lname' : book.location_name,
                'roomname' : book.room_name,
                'seat' : book.no_seat,
                'project' : book.projector,
                'video' : book.video,
                'from_date' : book.from_date,
                'to_date' : book.to_date})
    DEDENT
    json_output = json.dumps(root)
    return render(request, 'booking/view_book.html', {'people' : root})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44994354_44994472_3_8
44994354_44994517_3_8
Title: why do I get a truncated .txt file 
----------------------------------------

def generate_test(l, r) :
INDENT
    lst = []
    for x in range(1, l) :
    INDENT
        lst = lst + [random.randrange(0, r)]
    DEDENT
    return lst
DEDENT
----------------------------------------

def generate_test(l, r) :
INDENT
    lst = []
    for x in range(1, l) :
    INDENT
        lst = lst + [random.randrange(0, r)]
    DEDENT
    return lst
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44998121_44998556_1_18
44998121_45001302_10_21
Title: "Python: How to ""redo"" an iteration of a for loop?" 
----------------------------------------

def choose_dice() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            dice_quantity = int(input("How many dice would you like to use? "))
        DEDENT
        except (TypeError, ValueError) as _ :
        INDENT
            print ("Oops, it seems you have entered a non integer ")
        DEDENT
        dice_sides = []
        current_dice = 1
        while current_dice ! = dice_quantity + 1 :
        INDENT
            try :
            INDENT
                sides = int(input("How many sides on {} dice? ".format(str(current_dice) + ordinal(current_dice))))
                dice_sides.append([str(current_dice) + ordinal(current_dice) + " dice", sides])
                current_dice += 1
            DEDENT
            except (TypeError, ValueError, NameError) as _ :
            INDENT
                print ("Oops, it seems you have entered a non integer ")
            DEDENT
        DEDENT
        print (dice_sides)
        return dice_sides
    DEDENT
DEDENT
----------------------------------------

def choose_dice() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            dice_quantity = int(input("How many dice would you like to use? "))
            dice_sides = []
            for current_dice in range(1, dice_quantity + 1) :
            INDENT
                sides = getSidesOnDice(current_dice)
                dice_sides.append([str(current_dice) + ordinal(current_dice) + " dice", sides])
            DEDENT
            print (dice_sides)
            return dice_sides
        DEDENT
        except (TypeError, ValueError) as _ :
        INDENT
            print ("Oops, it seems you have entered a non integer ")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45034462_45034726_7_14
45034462_45035667_1_9
Title: List append in recursion 
----------------------------------------

def pascal(n) :
INDENT
    def aux(m, prev, k) :
    INDENT
        if n == m :
        INDENT
            return k([prev])
        DEDENT
        else :
        INDENT
            return aux(m + 1, [1] + [x + y for (x, y) in sliding(2, prev)] + [1], lambda rest : k([prev] + rest))
        DEDENT
    DEDENT
    return aux(1, [1], lambda x : x)
DEDENT
----------------------------------------

def pascal(rows) :
INDENT
    for i in range(rows) :
    value = 1
    List = [value]
    for j in range(i) :
    INDENT
        value = value * (i - j) * 1 / (j + 1)
        List.append(int(value))
    DEDENT
    print (List)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45057179_45093503_19_32
45057179_45093503_39_51
Title: "Kivy - on_press option does not work within a ""with self.canvas""?" 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(GameBoard, self).__init__(* args, ** kwargs)
    big = BigGrid()
    for i in range(9) :
    INDENT
        small = SmallGrid()
        for j in range(9) :
        INDENT
            small.add_widget(Button(text = "{}, {}".format(i, j), on_release = self.callback))
        DEDENT
        big.add_widget(small)
    DEDENT
    self.add_widget(big)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(RootWidget, self).__init__(* args, ** kwargs)
    self.orientation = 'vertical'
    self.add_widget(GameBoard())
    bottom_btns_container = GridLayout(cols = 2, size_hint = (1,.2))
    for i in range(4) :
    INDENT

        bottom_btns_container.add_widget(Button(text = "Button {}".format(i)))
    DEDENT
    self.add_widget(bottom_btns_container)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45061116_45109678_25_38
45061116_45109678_71_84
Title: Playing mp3 on Android? 
----------------------------------------

def load(self, filename) :
INDENT
    try :
    INDENT
        self.actualsong = filename
        self.secs = 0
        self.mplayer.setDataSource(filename)
        self.mplayer.prepare()
        self.length = self.mplayer.getDuration() / 1000
        Logger.info('mplayer load: %s' % filename)
        Logger.info('type: %s' % type(filename))
        return True
    DEDENT
    except :
    INDENT
        Logger.info('error in title: %s' % filename)
        return False
    DEDENT
DEDENT
----------------------------------------

def load(self, filename) :
INDENT
    self.__init__()
    if type(filename) == unicode : filename = filename.encode('utf-8')
    self.sound = SoundLoader.load(filename)
    if self.sound :
    INDENT
        if self.sound.length ! = - 1 :
        INDENT
            self.length = self.sound.length
            self.actualsong = filename
            Logger.info('mplayer: load %s' % filename)
            return True
        DEDENT
        else :
        INDENT
            Logger.info('mplayer: songlength = -1 ...')
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45066125_45066575_1_7
45066125_45066793_1_10
Title: Storing the guessed word in Hangman game 
----------------------------------------

def g(secret_word, letters_guessed) :
INDENT
    letters = set(secret_word)
    guess = set(letters_guessed)
    for i in letters.difference(guess) :
    INDENT
        secret_word = secret_word.replace(i, '_')
    DEDENT
    print (secret_word)
DEDENT
----------------------------------------

def g(secret_word, letters_guessed) :
INDENT
    a = []
    for char1 in secret_word :
    INDENT
        for thing in letters_guessed :
        INDENT
            if thing == char1 :
            INDENT
                a += thing
                break
            DEDENT
            elif thing ! = char1 :
            INDENT
                a [secret_word.index(char1)] == '_ '
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45066228_45066740_27_33
45066228_45066832_29_43
Title: Open Tkniter Toplevel only if it doesn't already exist 
----------------------------------------

def timed_loop(self) :
INDENT
    if self.alive :
    INDENT
        self.after(1000, self.timed_loop)
        self.value += 1
        self.textArea.insert('end', "{}\n".format(self.value))
        self.textArea.see('end')
    DEDENT
DEDENT
----------------------------------------

def timed_loop(self) :
INDENT
    if self.alive == True and tk.Toplevel.winfo_exists(self.textWindow) :
    INDENT
        self.master.after(1000, self.timed_loop)
        self.value += 1
        self.list_for_toplevel.append(self.value)
        self.textArea.delete(1.0, "end-1c")
        for item in self.list_for_toplevel :
        INDENT
            self.textArea.insert('end', "{}\n".format(item))
            self.textArea.see('end')
        DEDENT
    DEDENT
    else :
    INDENT
        self.alive = False

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45069843_45069890_17_43
45069843_45069925_1_18
Title: Restart my Python script 
----------------------------------------

def run_game(self) :
INDENT
    answer = input()

    if answer.isdigit() :
    INDENT

        n = int(answer)

        while not self.guessed :
        INDENT
            if n > int(self.rand) :
            INDENT
                print ("Number is less than " + str(n))
                self.run_game()
            DEDENT
            elif n < int(self.rand) :
            INDENT
                print ("Number is greater than " + str(n))
                self.run_game()
            DEDENT
            else :
            INDENT
                print ("You have guessed the correct number!")
                self.guessed = True
                return self.play_again()
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        print ("Please enter a number")
        self.run_game()
        return
    DEDENT
DEDENT
----------------------------------------

def run_game() :
INDENT
    rand = randint(1, 100)
    while True :
    INDENT
        answer = input()
        if answer.isdigit() :
        INDENT
            n = int(answer)
            if n > rand :
            INDENT
                print ("Number is less than " + str(n))
            DEDENT
            elif n < rand :
            INDENT
                print ("Number is greater than " + str(n))
            DEDENT
            else :
            INDENT
                print ("You have guessed the correct number!")
                if not play_again() :
                INDENT
                    break
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT
            print ("Please enter a number")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45079372_45420335_52_60
45079372_45420335_85_94
Title: "Best way to threading when with/as is needed (python pyqt)" 
----------------------------------------

def run(self) :
INDENT
    self.t = QThread()
    self.x = worker()
    self.x.signal.connect(self.write)
    self.x.statusSignal.connect(self.runExit)
    self.x.moveToThread(self.t)
    self.t.started.connect(self.x.run)
    self.t.start()
DEDENT
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        self.signal.emit("Run")
        time.sleep(2)
        self.moveToThread(mainThread)
        raise err("err message")
    DEDENT
    except err :
    INDENT
        exc_type, exc_value, exc_traceback = sys.exc_info()
        self.statusSignal.emit(exc_type, exc_value, exc_traceback)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45088664_45088764_1_15
45088664_45089064_2_11
Title: Summing the numbers in a list except for the first even number in Python? 
----------------------------------------

def totsum_effen(n) :
INDENT
    sum = 0
    flag = False
    for val in nmbrs :
    INDENT
        if not flag :
        INDENT
            if val % 2 == 0 :
            INDENT
                flag = True
            DEDENT
            else :
            INDENT
                sum += val
            DEDENT
        DEDENT
        else :
        INDENT
            sum = sum + val
        DEDENT
    DEDENT
    return (sum)
DEDENT
----------------------------------------

def totsum_effen(n) :
INDENT
    sum = 0
    ignore_first_even = True
    for i in n :
    INDENT
        if (i % 2 == 0 and ignore_first_even) :
        INDENT
            ignore_first_even = False
            continue
        DEDENT
        sum = sum + i
    DEDENT
    return (sum)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45088664_45088764_1_15
45088664_45089190_3_11
Title: Summing the numbers in a list except for the first even number in Python? 
----------------------------------------

def totsum_effen(n) :
INDENT
    sum = 0
    flag = False
    for val in nmbrs :
    INDENT
        if not flag :
        INDENT
            if val % 2 == 0 :
            INDENT
                flag = True
            DEDENT
            else :
            INDENT
                sum += val
            DEDENT
        DEDENT
        else :
        INDENT
            sum = sum + val
        DEDENT
    DEDENT
    return (sum)
DEDENT
----------------------------------------

def totsum_effen(nmbrs) :
INDENT
    sum = 0
    count = 0
    for i in nmbrs :
    INDENT
        if i % 2 == 0 and count == 0 :
        INDENT
            count = count + 1
            continue
        DEDENT
        sum = sum + i
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45117871_45118044_1_18
45117871_45118167_1_17
Title: Organizing strings in recursive functions - python 
----------------------------------------

def split_rec(s, lo = '', up = '') :
INDENT
    if not s :
    INDENT
        return lo + ' ' + up

    DEDENT
    c = s [0]
    if c.islower() :
    INDENT
        lo += c
    DEDENT
    else :
    INDENT
        up += c
    DEDENT
    return split_rec(s [1 :], lo, up)

DEDENT
----------------------------------------

def split_rec(s) :
INDENT
    if not '|' in s :
    INDENT
        s = s + '|'
    DEDENT
    if s.startswith('|') :
    INDENT
        return s.replace('|', ' ')
    DEDENT
    elif s [0].islower() :
    INDENT
        return s [0] + split_rec(s [1 :])
    DEDENT
    elif s [0].isupper() :
    INDENT

        s = s [1 :] + s [0]
        return split_rec(s)
    DEDENT
    else :
    INDENT
        return split_rec(s [1 :])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45127311_45127392_7_17
45127311_45127775_5_20
Title: how to decorate a function with decorators when a argument is passed or say a condition is matched 
----------------------------------------

def newdecorator(funct) :
INDENT
    @ wraps(funct)
    def timercheck(* args, ** kwarg) :
    INDENT
        if TIMING_ENABLED :
        INDENT
            starttime = time.time()
            print ("starting time", time.time())
        DEDENT
        funct(* args, ** kwarg)
        if TIMING_ENABLED :
        INDENT
            print ("TOTAL TIME TAKEN ::", time.time() - starttime)
        DEDENT
    DEDENT
    return timercheck
DEDENT
----------------------------------------

def newdecorator(arg1) :
INDENT
    if script_called_with_t :
    INDENT
        def benchmarking(funct) :
        INDENT
            print ("this is the value of argument", arg1)
            def timercheck(* args, ** kwarg) :
            INDENT
                starttime = time.time()
                print ("starting time", time.time())
                funct(* args, ** kwarg)
                print ("TOTAL TIME TAKEN ::", time.time() - starttime)
            DEDENT
            return timercheck
        DEDENT
        return benchmarking
    DEDENT
    else :
    INDENT
        return lambda funct : funct
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45127311_45127392_9_15
45127311_45128296_9_15
Title: how to decorate a function with decorators when a argument is passed or say a condition is matched 
----------------------------------------

def timercheck(* args, ** kwarg) :
INDENT
    if TIMING_ENABLED :
    INDENT
        starttime = time.time()
        print ("starting time", time.time())
    DEDENT
    funct(* args, ** kwarg)
    if TIMING_ENABLED :
    INDENT
        print ("TOTAL TIME TAKEN ::", time.time() - starttime)
    DEDENT
DEDENT
----------------------------------------

def timercheck(* args, ** kwarg) :
INDENT
    if TIMING_ENABLED :
    INDENT
        starttime = time.time()
        print ("starting time", time.time())
    DEDENT
    funct(* args, ** kwarg)
    if TIMING_ENABLED :
    INDENT
        print ("TOTAL TIME TAKEN ::", time.time() - starttime)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45127311_45127775_5_20
45127311_45128296_7_21
Title: how to decorate a function with decorators when a argument is passed or say a condition is matched 
----------------------------------------

def newdecorator(arg1) :
INDENT
    if script_called_with_t :
    INDENT
        def benchmarking(funct) :
        INDENT
            print ("this is the value of argument", arg1)
            def timercheck(* args, ** kwarg) :
            INDENT
                starttime = time.time()
                print ("starting time", time.time())
                funct(* args, ** kwarg)
                print ("TOTAL TIME TAKEN ::", time.time() - starttime)
            DEDENT
            return timercheck
        DEDENT
        return benchmarking
    DEDENT
    else :
    INDENT
        return lambda funct : funct
    DEDENT
DEDENT
----------------------------------------

def newdecorator() :
INDENT
    def benchmarking(funct) :
    INDENT
        def timercheck(* args, ** kwarg) :
        INDENT
            if TIMING_ENABLED :
            INDENT
                starttime = time.time()
                print ("starting time", time.time())
            DEDENT
            funct(* args, ** kwarg)
            if TIMING_ENABLED :
            INDENT
                print ("TOTAL TIME TAKEN ::", time.time() - starttime)
            DEDENT
        DEDENT
        return timercheck
    DEDENT
    return benchmarking

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45127311_45127775_7_15
45127311_45128296_8_16
Title: how to decorate a function with decorators when a argument is passed or say a condition is matched 
----------------------------------------

def benchmarking(funct) :
INDENT
    print ("this is the value of argument", arg1)
    def timercheck(* args, ** kwarg) :
    INDENT
        starttime = time.time()
        print ("starting time", time.time())
        funct(* args, ** kwarg)
        print ("TOTAL TIME TAKEN ::", time.time() - starttime)
    DEDENT
    return timercheck
DEDENT
----------------------------------------

def benchmarking(funct) :
INDENT
    def timercheck(* args, ** kwarg) :
    INDENT
        if TIMING_ENABLED :
        INDENT
            starttime = time.time()
            print ("starting time", time.time())
        DEDENT
        funct(* args, ** kwarg)
        if TIMING_ENABLED :
        INDENT
            print ("TOTAL TIME TAKEN ::", time.time() - starttime)
        DEDENT
    DEDENT
    return timercheck
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45145967_45193398_12_32
45145967_45193398_47_56
Title: Opening a new window to collect data and process it in main window 
----------------------------------------

def __init__(self) :
INDENT
    super(MainWidget, self).__init__()
    self.setFixedSize(500, 500)
    self.window2 = Window2(self)

    self.btn_show_window2 = QPushButton("Open Window 2")
    self.btn_show_window2.clicked.connect(self.show_window2)
    self.layout = QVBoxLayout()
    self.setLayout(self.layout)
    self.text_from_window2 = QLineEdit()
    self.text_from_window2.setStyleSheet("color: red;")
    self.text_from_window2.setDisabled(True)
    self.layout.addWidget(self.text_from_window2)
    self.layout.addWidget(self.btn_show_window2)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(Window2, self).__init__()
    self.setFixedSize(300, 200)
    self.layout = QVBoxLayout()
    self.setLayout(self.layout)
    self.line_edit = QLineEdit()
    self.line_edit.textChanged.connect(parent.update_label)
    self.layout.addWidget(self.line_edit)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45148147_45155850_11_21
45148147_45155850_24_31
Title: Kivy: Multiple Screens and Menu Items not impletmenting 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Manager, self).__init__(* args, ** kwargs)
    for i in range(4) :
    INDENT
        txt = 'Screen {}'.format(i)
        lbl = Label(text = txt)
        screen = Screen(name = txt)
        screen.add_widget(lbl)
        self.add_widget(screen)

    DEDENT
DEDENT
----------------------------------------

def __init__(self, sm = None, * args, ** kwargs) :
INDENT
    super(Nav, self).__init__(* args, ** kwargs)
    self.sm = sm
    self.rows = 4
    self.size_hint = (.2, 1)
    for i in range(4) :
    INDENT
        self.add_widget(Button(text = "Screen {}".format(i), on_release = self.change))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45148147_45155850_11_21
45148147_45155850_38_46
Title: Kivy: Multiple Screens and Menu Items not impletmenting 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Manager, self).__init__(* args, ** kwargs)
    for i in range(4) :
    INDENT
        txt = 'Screen {}'.format(i)
        lbl = Label(text = txt)
        screen = Screen(name = txt)
        screen.add_widget(lbl)
        self.add_widget(screen)

    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Root, self).__init__(* args, ** kwargs)
    self.orientation = "horizontal"
    sm = Manager()
    self.add_widget(Nav(sm = sm))
    self.add_widget(sm)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45148147_45155850_24_31
45148147_45155850_38_46
Title: Kivy: Multiple Screens and Menu Items not impletmenting 
----------------------------------------

def __init__(self, sm = None, * args, ** kwargs) :
INDENT
    super(Nav, self).__init__(* args, ** kwargs)
    self.sm = sm
    self.rows = 4
    self.size_hint = (.2, 1)
    for i in range(4) :
    INDENT
        self.add_widget(Button(text = "Screen {}".format(i), on_release = self.change))
    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Root, self).__init__(* args, ** kwargs)
    self.orientation = "horizontal"
    sm = Manager()
    self.add_widget(Nav(sm = sm))
    self.add_widget(sm)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45157516_45158106_7_12
45157516_45168373_16_23
Title: Creating a Simple Recommendation System in Python 
----------------------------------------

def friendsbooks(self) :
INDENT
    books = set()
    for friend in self.friends :
    INDENT
        books.update(friend.books)
    DEDENT
    return books
DEDENT
----------------------------------------

def friendsbooks(self) :
INDENT
    recommendation_list = set()
    for friend in self.friends :
    INDENT
        rec_books = recommendation.booksgraph [friend]
        if rec_books :
        INDENT
            recommendation_list.add(rec_books)
        DEDENT
    DEDENT
    return recommendation_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45193035_45193315_23_30
45193035_45193315_7_14
Title: Memory Management and Tkinter 
----------------------------------------

def __init__(self, parent, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, parent, * args, ** kwargs)
    self.parent = parent
    self.pack()
    print ("Frame2 created")
    btn = ttk.Button(self, text = "CLICK", command = self.openFrame1)
    btn.pack()
DEDENT
----------------------------------------

def __init__(self, parent, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, parent, * args, ** kwargs)
    self.parent = parent
    self.pack()
    print ("Frame1 created")
    btn = ttk.Button(self, text = "PRESS", command = self.openFrame2)
    btn.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45202238_45202680_1_10
45202238_45202802_1_17
Title: How to check if input is digit and in range at the same time? Python 
----------------------------------------

def get_main_menu_choice(choices) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            number = int(input('Chose an option from menu: '))
            if number in choices :
            INDENT
                return number
            DEDENT
            else :
            INDENT
                raise ValueError
            DEDENT
        DEDENT
        except (TypeError, ValueError) :
        INDENT
            print ("Invalid choice. Valid choices: {}".format(str(choices) [1 : - 1]))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_main_menu_choice(prompt = None, start = 1, end = 3) :
INDENT
    prompt = prompt or 'Chose an option from menu: '
    ask = True
    while ask is True :
    INDENT
        number = input(prompt)
        ask = False if number.isdigit() and 1 < = int(number) < = 3 else True
    DEDENT
    return int(number)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_115_136
45203228_45362373_142_165
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self, name, image, type, hitBox) :
INDENT
    self.name = name
    self.image = image
    self.type = type
    self.hitBox = hitBox
    self.rect = self.image.get_rect()
    if (self.hitBox ! = "none") :
    INDENT
        self.shiftX = hitBox [0] [0]
        self.shiftY = hitBox [0] [1]
        for i in range(1, len(hitBox)) :
        INDENT
            if (hitBox [i] [0] < self.shiftX) :
            INDENT
                self.shiftX = hitBox [i] [0]
            DEDENT
            if (hitBox [i] [1] < self.shiftY) :
            INDENT
                self.shiftY = hitBox [i] [1]
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        self.shiftX = self.rect [2] / 2
        self.shiftY = self.rect [3] / 2
    DEDENT
    imageTable.append(self)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.tileSize = 800
    self.size = self.tileSize * 10
    self.tiles = []
    self.centerTile = [5, 5]
    self.amount = round(self.size / self.tileSize)
    self.sprites = OrderedDict()
    self.grass_image = pygame.image.load("Grass.png")
    self.grass_group = pygame.sprite.Group()
    for x in range(0, self.amount * 60, 60) :
    INDENT
        for y in range(0, self.amount * 60, 60) :
        INDENT

            index = len(self.sprites)

            self.sprites [index] = pygame.sprite.Sprite()
            self.sprites [index].image = self.grass_image
            self.sprites [index].rect = pygame.Rect(x, y, 60, 60)

            self.grass_group.add(self.sprites [index])
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_115_136
45203228_45362373_177_185
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self, name, image, type, hitBox) :
INDENT
    self.name = name
    self.image = image
    self.type = type
    self.hitBox = hitBox
    self.rect = self.image.get_rect()
    if (self.hitBox ! = "none") :
    INDENT
        self.shiftX = hitBox [0] [0]
        self.shiftY = hitBox [0] [1]
        for i in range(1, len(hitBox)) :
        INDENT
            if (hitBox [i] [0] < self.shiftX) :
            INDENT
                self.shiftX = hitBox [i] [0]
            DEDENT
            if (hitBox [i] [1] < self.shiftY) :
            INDENT
                self.shiftY = hitBox [i] [1]
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        self.shiftX = self.rect [2] / 2
        self.shiftY = self.rect [3] / 2
    DEDENT
    imageTable.append(self)
DEDENT
----------------------------------------

def __init__(self, image, coords) :
INDENT
    transparentSurface = pygame.Surface([1000, 1000], pygame.SRCALPHA, 32)
    self.x = coords [0]
    self.y = coords [1]
    self.loaded = False
    self.buttomLayer = image
    self.middleLayer = copy.copy(transparentSurface)
    self.topLayer = transparentSurface
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_115_136
45203228_45362373_187_209
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self, name, image, type, hitBox) :
INDENT
    self.name = name
    self.image = image
    self.type = type
    self.hitBox = hitBox
    self.rect = self.image.get_rect()
    if (self.hitBox ! = "none") :
    INDENT
        self.shiftX = hitBox [0] [0]
        self.shiftY = hitBox [0] [1]
        for i in range(1, len(hitBox)) :
        INDENT
            if (hitBox [i] [0] < self.shiftX) :
            INDENT
                self.shiftX = hitBox [i] [0]
            DEDENT
            if (hitBox [i] [1] < self.shiftY) :
            INDENT
                self.shiftY = hitBox [i] [1]
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        self.shiftX = self.rect [2] / 2
        self.shiftY = self.rect [3] / 2
    DEDENT
    imageTable.append(self)
DEDENT
----------------------------------------

def __init__(self, info, tile, coords) :
INDENT
    self.info = info
    self.image = info.image
    self.rect = self.image.get_rect()
    self.x = coords [0]
    self.y = coords [1]
    self.hitBox = []
    if (self.info.hitBox ! = "none") :
    INDENT
        for i in range(0, len(self.info.hitBox)) :
        INDENT
            self.hitBox.append([self.info.hitBox [i] [0] + self.x, self.info.hitBox [i] [1] + self.y])

        DEDENT
    DEDENT
    if (info.type == "background") :
    INDENT
        tile.buttomLayer.blit(self.image, (self.x, self.y))
    DEDENT
    if (info.type == "object") :
    INDENT
        tile.middleLayer.blit(self.image, (self.x, self.y))
    DEDENT
    if (info.type == "object alphas") :
    INDENT
        tile.topLayer.blit(self.image, (self.x, self.y))

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_115_136
45203228_45362373_46_55
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self, name, image, type, hitBox) :
INDENT
    self.name = name
    self.image = image
    self.type = type
    self.hitBox = hitBox
    self.rect = self.image.get_rect()
    if (self.hitBox ! = "none") :
    INDENT
        self.shiftX = hitBox [0] [0]
        self.shiftY = hitBox [0] [1]
        for i in range(1, len(hitBox)) :
        INDENT
            if (hitBox [i] [0] < self.shiftX) :
            INDENT
                self.shiftX = hitBox [i] [0]
            DEDENT
            if (hitBox [i] [1] < self.shiftY) :
            INDENT
                self.shiftY = hitBox [i] [1]
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        self.shiftX = self.rect [2] / 2
        self.shiftY = self.rect [3] / 2
    DEDENT
    imageTable.append(self)
DEDENT
----------------------------------------

def __init__(self, frameReset, function, parse, reset) :
INDENT
    self.frameReset = frameReset
    self.currentFrame = frameReset
    self.function = function
    self.parse = parse
    self.reset = reset
    if (self.reset ! = "onComplete") :
    INDENT
        self.reset = (reset - 1)
    DEDENT
    enterFrameTable.append(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_142_165
45203228_45362373_177_185
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self) :
INDENT
    self.tileSize = 800
    self.size = self.tileSize * 10
    self.tiles = []
    self.centerTile = [5, 5]
    self.amount = round(self.size / self.tileSize)
    self.sprites = OrderedDict()
    self.grass_image = pygame.image.load("Grass.png")
    self.grass_group = pygame.sprite.Group()
    for x in range(0, self.amount * 60, 60) :
    INDENT
        for y in range(0, self.amount * 60, 60) :
        INDENT

            index = len(self.sprites)

            self.sprites [index] = pygame.sprite.Sprite()
            self.sprites [index].image = self.grass_image
            self.sprites [index].rect = pygame.Rect(x, y, 60, 60)

            self.grass_group.add(self.sprites [index])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, image, coords) :
INDENT
    transparentSurface = pygame.Surface([1000, 1000], pygame.SRCALPHA, 32)
    self.x = coords [0]
    self.y = coords [1]
    self.loaded = False
    self.buttomLayer = image
    self.middleLayer = copy.copy(transparentSurface)
    self.topLayer = transparentSurface
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_142_165
45203228_45362373_187_209
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self) :
INDENT
    self.tileSize = 800
    self.size = self.tileSize * 10
    self.tiles = []
    self.centerTile = [5, 5]
    self.amount = round(self.size / self.tileSize)
    self.sprites = OrderedDict()
    self.grass_image = pygame.image.load("Grass.png")
    self.grass_group = pygame.sprite.Group()
    for x in range(0, self.amount * 60, 60) :
    INDENT
        for y in range(0, self.amount * 60, 60) :
        INDENT

            index = len(self.sprites)

            self.sprites [index] = pygame.sprite.Sprite()
            self.sprites [index].image = self.grass_image
            self.sprites [index].rect = pygame.Rect(x, y, 60, 60)

            self.grass_group.add(self.sprites [index])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, info, tile, coords) :
INDENT
    self.info = info
    self.image = info.image
    self.rect = self.image.get_rect()
    self.x = coords [0]
    self.y = coords [1]
    self.hitBox = []
    if (self.info.hitBox ! = "none") :
    INDENT
        for i in range(0, len(self.info.hitBox)) :
        INDENT
            self.hitBox.append([self.info.hitBox [i] [0] + self.x, self.info.hitBox [i] [1] + self.y])

        DEDENT
    DEDENT
    if (info.type == "background") :
    INDENT
        tile.buttomLayer.blit(self.image, (self.x, self.y))
    DEDENT
    if (info.type == "object") :
    INDENT
        tile.middleLayer.blit(self.image, (self.x, self.y))
    DEDENT
    if (info.type == "object alphas") :
    INDENT
        tile.topLayer.blit(self.image, (self.x, self.y))

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_142_165
45203228_45362373_46_55
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self) :
INDENT
    self.tileSize = 800
    self.size = self.tileSize * 10
    self.tiles = []
    self.centerTile = [5, 5]
    self.amount = round(self.size / self.tileSize)
    self.sprites = OrderedDict()
    self.grass_image = pygame.image.load("Grass.png")
    self.grass_group = pygame.sprite.Group()
    for x in range(0, self.amount * 60, 60) :
    INDENT
        for y in range(0, self.amount * 60, 60) :
        INDENT

            index = len(self.sprites)

            self.sprites [index] = pygame.sprite.Sprite()
            self.sprites [index].image = self.grass_image
            self.sprites [index].rect = pygame.Rect(x, y, 60, 60)

            self.grass_group.add(self.sprites [index])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, frameReset, function, parse, reset) :
INDENT
    self.frameReset = frameReset
    self.currentFrame = frameReset
    self.function = function
    self.parse = parse
    self.reset = reset
    if (self.reset ! = "onComplete") :
    INDENT
        self.reset = (reset - 1)
    DEDENT
    enterFrameTable.append(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_177_185
45203228_45362373_187_209
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self, image, coords) :
INDENT
    transparentSurface = pygame.Surface([1000, 1000], pygame.SRCALPHA, 32)
    self.x = coords [0]
    self.y = coords [1]
    self.loaded = False
    self.buttomLayer = image
    self.middleLayer = copy.copy(transparentSurface)
    self.topLayer = transparentSurface
DEDENT
----------------------------------------

def __init__(self, info, tile, coords) :
INDENT
    self.info = info
    self.image = info.image
    self.rect = self.image.get_rect()
    self.x = coords [0]
    self.y = coords [1]
    self.hitBox = []
    if (self.info.hitBox ! = "none") :
    INDENT
        for i in range(0, len(self.info.hitBox)) :
        INDENT
            self.hitBox.append([self.info.hitBox [i] [0] + self.x, self.info.hitBox [i] [1] + self.y])

        DEDENT
    DEDENT
    if (info.type == "background") :
    INDENT
        tile.buttomLayer.blit(self.image, (self.x, self.y))
    DEDENT
    if (info.type == "object") :
    INDENT
        tile.middleLayer.blit(self.image, (self.x, self.y))
    DEDENT
    if (info.type == "object alphas") :
    INDENT
        tile.topLayer.blit(self.image, (self.x, self.y))

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_177_185
45203228_45362373_46_55
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self, image, coords) :
INDENT
    transparentSurface = pygame.Surface([1000, 1000], pygame.SRCALPHA, 32)
    self.x = coords [0]
    self.y = coords [1]
    self.loaded = False
    self.buttomLayer = image
    self.middleLayer = copy.copy(transparentSurface)
    self.topLayer = transparentSurface
DEDENT
----------------------------------------

def __init__(self, frameReset, function, parse, reset) :
INDENT
    self.frameReset = frameReset
    self.currentFrame = frameReset
    self.function = function
    self.parse = parse
    self.reset = reset
    if (self.reset ! = "onComplete") :
    INDENT
        self.reset = (reset - 1)
    DEDENT
    enterFrameTable.append(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45203228_45362373_187_209
45203228_45362373_46_55
Title: "Low frame rate possibly because un-accelerated graphics" 
----------------------------------------

def __init__(self, info, tile, coords) :
INDENT
    self.info = info
    self.image = info.image
    self.rect = self.image.get_rect()
    self.x = coords [0]
    self.y = coords [1]
    self.hitBox = []
    if (self.info.hitBox ! = "none") :
    INDENT
        for i in range(0, len(self.info.hitBox)) :
        INDENT
            self.hitBox.append([self.info.hitBox [i] [0] + self.x, self.info.hitBox [i] [1] + self.y])

        DEDENT
    DEDENT
    if (info.type == "background") :
    INDENT
        tile.buttomLayer.blit(self.image, (self.x, self.y))
    DEDENT
    if (info.type == "object") :
    INDENT
        tile.middleLayer.blit(self.image, (self.x, self.y))
    DEDENT
    if (info.type == "object alphas") :
    INDENT
        tile.topLayer.blit(self.image, (self.x, self.y))

    DEDENT
DEDENT
----------------------------------------

def __init__(self, frameReset, function, parse, reset) :
INDENT
    self.frameReset = frameReset
    self.currentFrame = frameReset
    self.function = function
    self.parse = parse
    self.reset = reset
    if (self.reset ! = "onComplete") :
    INDENT
        self.reset = (reset - 1)
    DEDENT
    enterFrameTable.append(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45204381_45204454_1_11
45204381_45204555_5_10
Title: Nested if ... else (Python exercise) 
----------------------------------------

def minimal_three(a, b, c) :
INDENT
    if a < b :
    INDENT
        if a < c :
        INDENT
            return (a)
        DEDENT
    DEDENT
    if b < a :
    INDENT
        if b < c :
        INDENT
            return (b)
        DEDENT
    DEDENT
    if c < a :
    INDENT
        if c < b :
        INDENT
            return (c)
        DEDENT
    DEDENT
    return 'none'
DEDENT
----------------------------------------

def minimal_three(a, b, c) :
INDENT
    for y in list :
    INDENT
        n = y
    DEDENT
    for x in list :
    INDENT
        if x < n :
        INDENT
            print (n)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
452104_42360900_6_32
452104_452143_4_19
Title: Is it worth using Python's re.compile? 
----------------------------------------

def _compile(pattern, flags) :
INDENT
    try :
    INDENT
        p, loc = _cache [type(pattern), pattern, flags]
        if loc is None or loc == _locale.setlocale(_locale.LC_CTYPE) :
        INDENT
            return p
        DEDENT
    DEDENT
    except KeyError :
    INDENT
        pass
    DEDENT
    if isinstance(pattern, _pattern_type) :
    INDENT
        if flags :
        INDENT
            raise ValueError(
                "cannot process flags argument with a compiled pattern")
        DEDENT
        return pattern
    DEDENT
    if not sre_compile.isstring(pattern) :
    INDENT
        raise TypeError("first argument must be string or compiled pattern")
    DEDENT
    p = sre_compile.compile(pattern, flags)
    if not (flags & DEBUG) :
    INDENT
        if len(_cache) > = _MAXCACHE :
        INDENT
            _cache.clear()
        DEDENT
        if p.flags & LOCALE :
        INDENT
            if not _locale :
            INDENT
                return p
            DEDENT
            loc = _locale.setlocale(_locale.LC_CTYPE)
        DEDENT
        else :
        INDENT
            loc = None
        DEDENT
        _cache [type(pattern), pattern, flags] = p, loc
    DEDENT
    return p
DEDENT
----------------------------------------

def _compile(* key) :
INDENT
    cachekey = (type(key [0]),) + key
    p = _cache.get(cachekey)
    if p is not None : return p

    if len(_cache) > = _MAXCACHE :
    INDENT
        _cache.clear()
    DEDENT
    _cache [cachekey] = p
    return p
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45211075_45211799_4_21
45211075_45212144_2_12
Title: "In python3 tkinter the wigdet frame doesn't show in interface" 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    tk.Frame.__init__(self, parent)
    self.master.title("measurement")
    self.grid(row = 0, column = 0)
    self.master.geometry("700x400+100+50")
    self.master.Frame1 = tk.Frame(self, relief = 'groove', bg = 'white')
    self.master.Frame1.grid(column = 1, row = 9)
    labelExemple = tk.Label(self.master.Frame1, text = "Exemple")
    labelExemple.grid(row = 0, column = 0)
    self.can = tk.Canvas(self, bg = "ivory", width = 200, height = 150)
    self.master.canvas = tk.Canvas(self.master, width = 150, height = 120, background = 'snow')
    self.ligne1 = self.master.canvas.create_line(75, 0, 75, 120)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    self.parent = parent
    super().__init__(self.parent)
    self.Frame1 = Frame(self, relief = GROOVE)
    self.Frame1.grid()
    self.canvas = Canvas(self.Frame1, bg = "ivory", width = 200, height = 150)
    self.canvas.grid()
    self.canvas.create_line(75, 0, 75, 120)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45220697_45238112_10_16
45220697_45262686_25_37
Title: "Getting error again and again while using ""ids"" in kv file" 
----------------------------------------

def build(self) :
INDENT
    self.sm = ScreenManager()
    self.screen1 = User1(name = "start")
    self.screen2 = User2(name = "let's_chat")
    self.sm.add_widget(self.screen1)
    self.sm.add_widget(self.screen2)
    return self.sm
DEDENT
----------------------------------------

def build(self) :
INDENT
    self.sm = ScreenManager()
    self.screen1 = User1(name = "start")
    self.screen2 = User2(name = "chat_screen")
    self.sm.add_widget(self.screen1)
    self.sm.add_widget(self.screen2)
    return self.sm

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45226878_45226907_3_11
45226878_45226928_2_8
Title: Python - IndentationError 
----------------------------------------

def __init__(self, coordinates) :
INDENT
    try :
    INDENT
        if not coordinates :
        INDENT
            raise ValueError
        DEDENT
        self.coordinates = tuple(coordinates)
        self.dimension = len(coordinates)
    DEDENT
    except :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def __init__(self, coordinates) :
INDENT
    if not coordinates :
    INDENT
        raise ValueError
    DEDENT
    self.coordinates = tuple(coordinates)
    self.dimension = len(coordinates)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45226878_45226923_2_11
45226878_45226928_2_8
Title: Python - IndentationError 
----------------------------------------

def __init__(self, coordinates) :
INDENT
    try :
    INDENT
        if not coordinates :
        INDENT
            raise ValueError
        DEDENT
        self.coordinates = tuple(coordinates)
        self.dimension = len(coordinates)
    DEDENT
    except ValueError as e :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def __init__(self, coordinates) :
INDENT
    if not coordinates :
    INDENT
        raise ValueError
    DEDENT
    self.coordinates = tuple(coordinates)
    self.dimension = len(coordinates)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45243351_45243649_5_17
45243351_45243714_1_17
Title: "Problems sorting dataframe in pandas multiple column names" 
----------------------------------------

def Triangle_area(height, base) :
INDENT
    H = np.array(height)
    ratio = H * base
    area = ratio / 2
    A1 = pd.DataFrame({'H' : height, 'area' : area})
    return A1

DEDENT
----------------------------------------

def Triangle_area() :
INDENT
    '''
    @param Base, scalar length of triangle base
    @param H, array of various triangle heights
    @returns A1, dataframe with columns 'H' and 'area'
        corresponding to height and area of triangle with 
        that height
    '''
    ratio = Base * np.array(H)
    area = np.divide(ratio, 2)
    A1 = pd.DataFrame({'H' : np.array(H), 'area' : area})
    return A1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45272514_45274708_6_25
45272514_45274879_3_19
Title: Need basic understanding of python arguments in order to be able code system of ODE's solution 
----------------------------------------

def heun(ndof, dt, y, t) :
INDENT
    ydot = [0] * (ndof)
    y_tilde = [0] * (ndof)
    ydot_at_tilde = [0] * (ndof)
    ydot = rhs(y, ydot)

    for i in range(0, ndof) :
    INDENT
        y_tilde [i] = y [i] + dt * ydot [i]
    DEDENT
    ydot_at_tilde = rhs(y_tilde, ydot_at_tilde)
    for i in range(0, ndof) :
    INDENT
        y [i] = y [i] + dt / 2 * (ydot [i] + ydot_at_tilde [i])
    DEDENT
    t = t + dt
    return y, t;
DEDENT
----------------------------------------

def heun(ndof, dt, y, t) :
INDENT
    ydot = numpy.zeros(ndof)
    y_tilde = numpy.zeros(ndof)
    ydot_at_tilde = numpy.zeros(ndof)

    ydot [: 1] = y [: 1]
    y_tilde = y + dt * ydot
    ydot_at_tilde [: 1] = y_tilde [: 1]
    y = y + dt / 2 * (ydot + ydot_at_tilde)
    t = t + dt
    return y, t
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45279318_45279768_10_40
45279318_45279768_67_82
Title: Python frames tkinter 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.geometry("600x600+10+10")

    self.frame_header = tk.Frame(self, background = 'black', width = 600, height = 50)
    self.frame_header.grid(column = 0, row = 0, columnspan = 10)

    container = tk.Frame(self, width = 600, height = 400)
    container.grid(column = 0, row = 1, columnspan = 10)

    self.frames = {}

    for F in (StartPage, HomePage) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 1, column = 0, sticky = "nsew", columnspan = 10)
    DEDENT
    self.show_page("StartPage")

    self.frame_footer = tk.Frame(self, background = 'yellow', width = 600, height = 50)
    self.frame_footer.grid(column = 0, row = 3, columnspan = 10)

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)

    tk.Label(self, text = "Select:").grid(column = 0, row = 2, stick = 'W')
    self.button1 = tk.Button(self, text = "Select")
    self.button1.grid(row = 2, column = 5, stick = 'W', padx = (50, 0))
    tk.Label(self, text = "Select:").grid(column = 0, row = 3, stick = 'W')
    self.button2 = tk.Button(self, text = "Select")
    self.button2.grid(row = 4, column = 5, stick = 'W', padx = (50, 0))
    self.submit = tk.Button(self, text = "Start")
    self.submit.grid(row = 10, column = 9, stick = 'W')

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45279318_45279768_10_40
45279318_45279768_85_102
Title: Python frames tkinter 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.geometry("600x600+10+10")

    self.frame_header = tk.Frame(self, background = 'black', width = 600, height = 50)
    self.frame_header.grid(column = 0, row = 0, columnspan = 10)

    container = tk.Frame(self, width = 600, height = 400)
    container.grid(column = 0, row = 1, columnspan = 10)

    self.frames = {}

    for F in (StartPage, HomePage) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 1, column = 0, sticky = "nsew", columnspan = 10)
    DEDENT
    self.show_page("StartPage")

    self.frame_footer = tk.Frame(self, background = 'yellow', width = 600, height = 50)
    self.frame_footer.grid(column = 0, row = 3, columnspan = 10)

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = """ALPHA application.
        use at your own risk. There is no promise
        of warranty""", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button1 = ttk.Button(self, text = "Agree",
        command = lambda : controller.show_page("HomePage"))
    button1.pack()
    button2 = ttk.Button(self, text = "Disagree",
        command = controller.destroy)
    button2.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45279318_45279768_67_82
45279318_45279768_85_102
Title: Python frames tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)

    tk.Label(self, text = "Select:").grid(column = 0, row = 2, stick = 'W')
    self.button1 = tk.Button(self, text = "Select")
    self.button1.grid(row = 2, column = 5, stick = 'W', padx = (50, 0))
    tk.Label(self, text = "Select:").grid(column = 0, row = 3, stick = 'W')
    self.button2 = tk.Button(self, text = "Select")
    self.button2.grid(row = 4, column = 5, stick = 'W', padx = (50, 0))
    self.submit = tk.Button(self, text = "Start")
    self.submit.grid(row = 10, column = 9, stick = 'W')

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = """ALPHA application.
        use at your own risk. There is no promise
        of warranty""", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button1 = ttk.Button(self, text = "Agree",
        command = lambda : controller.show_page("HomePage"))
    button1.pack()
    button2 = ttk.Button(self, text = "Disagree",
        command = controller.destroy)
    button2.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45286641_45287130_1_10
45286641_45287339_1_9
Title: Could someone explain why this fixes my recursion error? 
----------------------------------------

def bs_h(items, key, lower, upper) :
INDENT
    if lower > upper :
    INDENT
        return None
    DEDENT
    mid = (lower + upper) / / 2
    if key < items [mid] :
    INDENT
        return bs_h(items, key, lower, mid - 1)
    DEDENT
    elif key > items [mid] :
    INDENT
        return bs_h(items, key, mid + 1, upper)
    DEDENT
    else :
    INDENT
        return mid
    DEDENT
DEDENT
----------------------------------------

def bs_h(items, key, lower, upper) :
INDENT
    if lower > upper : return None
    mid = (lower + upper) / / 2
    if key < items [mid] :
    INDENT
        return bs_h(items, key, lower, mid - 1)
    DEDENT
    elif key > items [mid] :
    INDENT
        return bs_h(items, key, mid + 1, upper)
    DEDENT
    else : return mid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45287522_45315506_3_15
45287522_45351002_14_25
Title: Using multiprocess to build Gurobi expression in Python 
----------------------------------------

def penalty_function(var, obj, D) :
INDENT
    num_nodes = len(var)
    for i, fil in enumerate(D) :
    INDENT
        for j, val in enumerate(fil) :
        INDENT
            if val ! = 0 :
            INDENT
                obj += var [i] * var [j] * val
            DEDENT
            if (j > i) :
            INDENT
                minval = sum(min(D [j] [k], D [i] [k]) for k in range(num_nodes))
                if minval ! = 0 :
                INDENT
                    obj += var [i] * var [j] * minval
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return obj
DEDENT
----------------------------------------

def penalty_function(var, obj, D, num_nodes) :
INDENT
    num_process = 8
    inc = math.ceil(num_nodes / num_process)
    if __name__ == '__main__' :
    INDENT
        pool = mp.Pool(processes = num_process)
        minval = pool.starmap(parallel_function, [(D, num_nodes, u * inc, u * inc + inc) for u in range(8)])
        pool.close()
    DEDENT
    minD = []
    for x in minval :
    INDENT
        minD = minD + x
    DEDENT
    obj += np.array(var).dot((np.array(minD) + np.array(D))).dot(var)
    return obj
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45294110_45294203_10_37
45294110_45294230_1_22
Title: Trouble returning in recursive call 
----------------------------------------

def brute_force_crack(hashed_pass) :
INDENT
    char_list = create_possible_chars()
    def build_combos(curr_str = "") :
    INDENT
        if len(curr_str) == 4 :
        INDENT
            return None
        DEDENT
        for letter in char_list :
        INDENT

            guess = curr_str + letter
            if is_password(guess, hashed_pass) :
            INDENT
                return guess
            DEDENT
            else :
            INDENT

                result = build_combos(guess)

                if result is not None :
                INDENT
                    return result

                DEDENT
            DEDENT
        DEDENT
        return None
    DEDENT
    return build_combos()
DEDENT
----------------------------------------

def brute_force_crack(hashed_pass) :
INDENT
    char_list = create_possible_chars()

    def build_combos(curr_str) :
    INDENT
        if is_password(curr_str, hashed_pass) :
        INDENT
            return curr_str
        DEDENT
        if len(curr_str) > = 4 :
        INDENT
            return
        DEDENT
        for letter in char_list :
        INDENT

            password = build_combos(curr_str + letter)
            if password :
            INDENT
                return password

            DEDENT
        DEDENT
    DEDENT
    return build_combos("")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45294110_45294203_13_35
45294110_45294230_5_21
Title: Trouble returning in recursive call 
----------------------------------------

def build_combos(curr_str = "") :
INDENT
    if len(curr_str) == 4 :
    INDENT
        return None
    DEDENT
    for letter in char_list :
    INDENT

        guess = curr_str + letter
        if is_password(guess, hashed_pass) :
        INDENT
            return guess
        DEDENT
        else :
        INDENT

            result = build_combos(guess)

            if result is not None :
            INDENT
                return result

            DEDENT
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def build_combos(curr_str) :
INDENT
    if is_password(curr_str, hashed_pass) :
    INDENT
        return curr_str
    DEDENT
    if len(curr_str) > = 4 :
    INDENT
        return
    DEDENT
    for letter in char_list :
    INDENT

        password = build_combos(curr_str + letter)
        if password :
        INDENT
            return password

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45299434_45299620_1_10
45299434_45299659_1_13
Title: Python count list items through a function 
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    if sequence == item :
    INDENT
        return 1
    DEDENT
    for num in sequence :
    INDENT
        if num == item :
        INDENT
            found += 1
        DEDENT
    DEDENT
    return found
DEDENT
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    if sequence == item :
    INDENT
        found += 1
        return found
    DEDENT
    else :
    INDENT
        for num in range(len(sequence)) :
        INDENT
            if item == sequence [num] :
            INDENT
                found += 1
            DEDENT
        DEDENT
        if found > 0 :
        INDENT
            return found
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45299434_45299620_1_10
45299434_45299737_1_10
Title: Python count list items through a function 
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    if sequence == item :
    INDENT
        return 1
    DEDENT
    for num in sequence :
    INDENT
        if num == item :
        INDENT
            found += 1
        DEDENT
    DEDENT
    return found
DEDENT
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    if isinstance(sequence, list) :
    INDENT
        for x in sequence :
        INDENT
            found += count(x, item)
        DEDENT
    DEDENT
    else :
    INDENT
        return int(item == sequence)
    DEDENT
    return found

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45299434_45299659_1_13
45299434_45299737_1_10
Title: Python count list items through a function 
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    if sequence == item :
    INDENT
        found += 1
        return found
    DEDENT
    else :
    INDENT
        for num in range(len(sequence)) :
        INDENT
            if item == sequence [num] :
            INDENT
                found += 1
            DEDENT
        DEDENT
        if found > 0 :
        INDENT
            return found
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    if isinstance(sequence, list) :
    INDENT
        for x in sequence :
        INDENT
            found += count(x, item)
        DEDENT
    DEDENT
    else :
    INDENT
        return int(item == sequence)
    DEDENT
    return found

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45299434_45299659_1_13
45299434_45299820_5_12
Title: Python count list items through a function 
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    if sequence == item :
    INDENT
        found += 1
        return found
    DEDENT
    else :
    INDENT
        for num in range(len(sequence)) :
        INDENT
            if item == sequence [num] :
            INDENT
                found += 1
            DEDENT
        DEDENT
        if found > 0 :
        INDENT
            return found
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    for i in sequence :
    INDENT
        if item == i :
        INDENT
            found += 1
        DEDENT
        elif isinstance(i, Sequence) and item in i :
        INDENT
            found += count(i, item)
        DEDENT
    DEDENT
    return found
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45299434_45299737_1_10
45299434_45299820_5_12
Title: Python count list items through a function 
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    if isinstance(sequence, list) :
    INDENT
        for x in sequence :
        INDENT
            found += count(x, item)
        DEDENT
    DEDENT
    else :
    INDENT
        return int(item == sequence)
    DEDENT
    return found

DEDENT
----------------------------------------

def count(sequence, item) :
INDENT
    found = 0
    for i in sequence :
    INDENT
        if item == i :
        INDENT
            found += 1
        DEDENT
        elif isinstance(i, Sequence) and item in i :
        INDENT
            found += count(i, item)
        DEDENT
    DEDENT
    return found
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45311994_45312173_7_17
45311994_45312220_1_7
Title: convert each sub-dictionary in a nested dictionary to defaultdict in Python 
----------------------------------------

def nest_dict(dct) :
INDENT
    dct = res = MyDict(dct)
    candidates = [(k, dct) for k in dct]
    while candidates :
    INDENT
        k, dct = candidates.pop()
        if isinstance(dct [k], dict) :
        INDENT
            dct [k] = MyDict(dct [k])
            candidates.extend((k_, dct [k]) for k_ in dct [k])
        DEDENT
    DEDENT
    return res
DEDENT
----------------------------------------

def nest_dict(dct) :
INDENT
    dct = MyDict(dct)
    for k, v in dct.items() :
    INDENT
        if isinstance(v, dict) :
        INDENT
            dct [k] = nest_dict(v)
        DEDENT
    DEDENT
    return dct
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45360615_45374532_18_28
45360615_45374532_8_15
Title: How to save a pygame sprite-group using the shelve module 
----------------------------------------

def __init__(self) :
INDENT
    self.fps = 30
    self.done = False
    self.bg_color = pg.Color('gray13')
    self.clock = pg.time.Clock()
    self.screen = pg.display.set_mode((640, 480))
    actor1 = Actor((250, 120), pg.Color('steelblue1'))
    actor2 = Actor((400, 260), pg.Color('sienna1'))
    self.all_sprites = pg.sprite.Group(actor1, actor2)
    self.selected = None
DEDENT
----------------------------------------

def __init__(self, pos, color) :
INDENT
    super().__init__()
    self.color = color
    self.image = pg.Surface((32, 52))
    self.image.fill(self.color)
    self.rect = self.image.get_rect(topleft = pos)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45385986_45386279_3_10
45385986_45386437_11_19
Title: Capitalizing the name of reference list in my function 
----------------------------------------

def sort_by_matches(ref, lists) :
INDENT
    ref = eval(ref.upper())
    reference = set(ref)
    lists = sorted([[len(reference.intersection(set(l))), name, l] for name, l in lists], key = lambda x : (x [0], - len(x [2])), reverse = True)
    for matches, name, a_list in lists :
    INDENT
        if matches ! = 0 :
        INDENT
            print ("Matches {} in {}".format(matches, name))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def sort_by_matches(ref, lists) :
INDENT
    reference = set(lists [ref.upper()])
    found = sorted([[len(reference.intersection(set(l))), name, l] for name, l in lists.items()],
        key = lambda x : (x [0], - len(x [2])), reverse = True)
    for matches, name, _ in found :
    INDENT
        print ("Matches {} in {}".format(matches, name))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45386171_45386485_3_17
45386171_45396948_3_16
Title: Shorten a Python turtle program for a house 
----------------------------------------

def yellowHouse() :
INDENT
    wn = turtle.Screen()
    wn.title("Yellow House")
    wn.bgcolor("Blue")
    house = turtle.Turtle()
    Diagonal_length = 0.5 * math.sqrt(2 * (200 ** 2))
    event = ["pensize", "speed", "color", "left", "forward", "right", "forward", "right", "forward", "left", "forward", "left", "forward", "right", "forward", "left", "forward", "right", "forward", "right", "forward", "right", "forward", "left"]
    event_val = [5, 4.6, "Yellow", 90, 200, 135, Diagonal_length, 90, Diagonal_length, 135, 200, 135, Diagonal_length, 90, Diagonal_length, 135, 200, 135, Diagonal_length, 90, Diagonal_length, 45, 200, 90]
    event_zip = zip(event, event_val)
    for i, j in event_zip :
    INDENT
        if type(j).__name__ == "str" :
        INDENT
            eval("house.{}('{}')".format(i, j))
        DEDENT
        else :
        INDENT
            eval("house.{}({})".format(i, j))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def yellowHouse(side_length) :
INDENT
    wn.register_shape("brick", ((0, 0), (- 0.5, - 0.5), (0.5, - 0.5)))
    house = Turtle('brick', visible = False)
    house.shapesize(stretch_wid = side_length, outline = 5)
    house.color("yellow", wn.bgcolor())
    house.penup()
    for angle in range(360, 0, - 90) :
    INDENT
        house.setheading(angle)
        house.stamp()
    DEDENT
    house.forward(side_length)
    house.stamp()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45386171_45386485_3_17
45386171_49706289_2_22
Title: Shorten a Python turtle program for a house 
----------------------------------------

def yellowHouse() :
INDENT
    wn = turtle.Screen()
    wn.title("Yellow House")
    wn.bgcolor("Blue")
    house = turtle.Turtle()
    Diagonal_length = 0.5 * math.sqrt(2 * (200 ** 2))
    event = ["pensize", "speed", "color", "left", "forward", "right", "forward", "right", "forward", "left", "forward", "left", "forward", "right", "forward", "left", "forward", "right", "forward", "right", "forward", "right", "forward", "left"]
    event_val = [5, 4.6, "Yellow", 90, 200, 135, Diagonal_length, 90, Diagonal_length, 135, 200, 135, Diagonal_length, 90, Diagonal_length, 135, 200, 135, Diagonal_length, 90, Diagonal_length, 45, 200, 90]
    event_zip = zip(event, event_val)
    for i, j in event_zip :
    INDENT
        if type(j).__name__ == "str" :
        INDENT
            eval("house.{}('{}')".format(i, j))
        DEDENT
        else :
        INDENT
            eval("house.{}({})".format(i, j))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def yellowHouse() :
INDENT
    wn = turtle.Screen()
    wn.title("Yellow House")
    wn.bgcolor("Blue")
    house = turtle.Turtle()
    house.pensize(5)
    house.speed(4.6)
    house.color("Yellow")
    side = 200
    diag = (2 * (side ** 2)) ** 0.5
    ang = 90
    for i in range(4) :
    INDENT
        house.fd(side)
        house.lt(ang)
    DEDENT
    house.lt(ang / 2)
    moves = [(diag, ang), (diag / 2, ang), (diag / 2, ang), (diag, ang)]
    for (move, turn) in moves :
    INDENT
        house.fd(move)
        house.lt(turn)
    DEDENT
    wn.mainloop()
DEDENT
----------------------------------------
