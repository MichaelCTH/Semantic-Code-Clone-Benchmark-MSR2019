$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28777219_47712620_1_11
28777219_50012689_1_20
Title: Basic program to convert integer to Roman numerals? 
----------------------------------------

def int_to_roman(a) :
INDENT
    all_roman_digits = []
    digit_lookup_table = [
        "", "0", "00", "000", "01",
        "1", "10", "100", "1000", "02"]
    for i, c in enumerate(reversed(str(a))) :
    INDENT
        roman_digit = ""
        for d in digit_lookup_table [int(c)] :
        INDENT
            roman_digit += ("IVXLCDM" [int(d) + i * 2])
        DEDENT
        all_roman_digits.append(roman_digit)
    DEDENT
    return "".join(reversed(all_roman_digits))
DEDENT
----------------------------------------

def int_to_roman(num) :
INDENT
    _values = [
        1000000, 900000, 500000, 400000, 100000, 90000, 50000, 40000, 10000, 9000, 5000, 4000, 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    _strings = [
        'M', 'C', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    result = ""
    decimal = num
    while decimal > 0 :
    INDENT
        for i in range(len(_values)) :
        INDENT
            if decimal > = _values [i] :
            INDENT
                if _values [i] > 1000 :
                INDENT
                    result += u'\u0304'.join(list(_strings [i])) + u'\u0304'
                DEDENT
                else :
                INDENT
                    result += _strings [i]
                DEDENT
                decimal -= _values [i]
                break
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28777219_47713392_17_22
28777219_50012689_1_20
Title: Basic program to convert integer to Roman numerals? 
----------------------------------------

def int_to_roman(number) :
INDENT
    result = ""
    for (arabic, roman) in ROMAN :
    INDENT
        (factor, number) = divmod(number, arabic)
        result += roman * factor
    DEDENT
    return result
DEDENT
----------------------------------------

def int_to_roman(num) :
INDENT
    _values = [
        1000000, 900000, 500000, 400000, 100000, 90000, 50000, 40000, 10000, 9000, 5000, 4000, 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]
    _strings = [
        'M', 'C', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
    result = ""
    decimal = num
    while decimal > 0 :
    INDENT
        for i in range(len(_values)) :
        INDENT
            if decimal > = _values [i] :
            INDENT
                if _values [i] > 1000 :
                INDENT
                    result += u'\u0304'.join(list(_strings [i])) + u'\u0304'
                DEDENT
                else :
                INDENT
                    result += _strings [i]
                DEDENT
                decimal -= _values [i]
                break
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28786195_28786249_11_18
28786195_28786249_2_9
Title: Creating methods with the same attributes 
----------------------------------------

def __init__(self, nm, am, wp, ht, tp, ide) :
INDENT
    self.name = nm
    self.ammo = am
    self.weapon = wp
    self.health = ht
    self.type = tp
    self.id = ide
DEDENT
----------------------------------------

def __init__(self, nm, am, wp, ht, tp, ide) :
INDENT
    self.name = nm
    self.ammo = am
    self.weapon = wp
    self.health = ht
    self.type = tp
    self.id = ide
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28788598_28789373_1_22
28788598_34125960_4_21
Title: The view didn't return an HttpResponse object - Django and mongoengine 
----------------------------------------

def peer_signup(request) :
INDENT
    if not request.user.is_authenticated() and request.method == 'POST' :
    INDENT
        form_signup = FormSignup(request.POST)
        if form_signup.is_valid() :
        INDENT
            nombreusuario = form_signup.cleaned_data ['username']
            email = form_signup.cleaned_data ['email']
            password = form_signup.cleaned_data ['password']
            birthday = form_signup.cleaned_data ['birthday']
            sex = form_signup.cleaned_data ['sex']
            peer = service_save_peer(username = nombreusuario, email = email,
                birth_date = birthday, first_name = u'',
                last_name = u'', password = password, sex = sex)
            if peer :
            INDENT
                peer_auth = service_authenticate_peer(peer = str('chavez'),
                    password = str(peer.password))
                auth.login(request, peer_auth)
            DEDENT
        DEDENT
        return HttpResponse('/peer/signup/')
    DEDENT
    else :
    INDENT
        form_signup = FormSignup()
    DEDENT
    return render(request, 'peer_signup.html', {'form' : form_signup})
DEDENT
----------------------------------------

def peer_signup(request) :
INDENT
    form = FormSignup(request.POST or None)
    if form.is_valid() :
    INDENT
        nombreusuario = form.cleaned_data ['username']
        email = form.cleaned_data ['email']
        password = form.cleaned_data ['password']
        birthday = form.cleaned_data ['birthday']
        sex = form.cleaned_data ['sex']
        peer = service_save_peer(username = nombreusuario, email = email,
            birth_date = birthday, first_name = u'',
            last_name = u'', password = password, sex = sex)
        if peer :
        INDENT
            service_authenticate_peer(peer = str('chavez'),
                password = peer.password)
            return redirect('/thank-you-page')
        DEDENT
    DEDENT
    return render(request, 'peer_signup.html', {'form' : form})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28793832_29304506_1_23
28793832_37893165_9_32
Title: Can luigi rerun tasks when the task dependencies become out of date? 
----------------------------------------

def complete(self) :
INDENT
    import os
    import time
    def mtime(path) :
    INDENT
        return time.ctime(os.path.getmtime(path))

    DEDENT
    if not os.path.exists(self.output().path) :
    INDENT
        return False
    DEDENT
    self_mtime = mtime(self.output().path)

    for el in self.requires() :
    INDENT
        if not el.complete() :
        INDENT
            return False
        DEDENT
        for output in el.output() :
        INDENT
            if mtime(output.path) > self_mtime :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def complete(self) :
INDENT
    def to_list(obj) :
    INDENT
        if type(obj) in (type(()), type([])) :
        INDENT
            return obj
        DEDENT
        else :
        INDENT
            return [obj]
        DEDENT
    DEDENT
    def mtime(path) :
    INDENT
        return time.ctime(os.path.getmtime(path))
    DEDENT
    if not all(os.path.exists(out.path) for out in to_list(self.output())) :
    INDENT
        return False
    DEDENT
    self_mtime = min(mtime(out.path) for out in to_list(self.output()))

    for el in to_list(self.requires()) :
    INDENT
        if not el.complete() :
        INDENT
            return False
        DEDENT
        for output in to_list(el.output()) :
        INDENT
            if mtime(output.path) > self_mtime :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28793832_29304506_1_23
28793832_47840326_11_34
Title: Can luigi rerun tasks when the task dependencies become out of date? 
----------------------------------------

def complete(self) :
INDENT
    import os
    import time
    def mtime(path) :
    INDENT
        return time.ctime(os.path.getmtime(path))

    DEDENT
    if not os.path.exists(self.output().path) :
    INDENT
        return False
    DEDENT
    self_mtime = mtime(self.output().path)

    for el in self.requires() :
    INDENT
        if not el.complete() :
        INDENT
            return False
        DEDENT
        for output in el.output() :
        INDENT
            if mtime(output.path) > self_mtime :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def complete(self) :
INDENT
    def to_list(obj) :
    INDENT
        if type(obj) in (type(()), type([])) :
        INDENT
            return obj
        DEDENT
        else :
        INDENT
            return [obj]
        DEDENT
    DEDENT
    def mtime(path) :
    INDENT
        return os.path.getmtime(path)
    DEDENT
    if not all(os.path.exists(out.path) for out in to_list(self.output())) :
    INDENT
        return False
    DEDENT
    self_mtime = min(mtime(out.path) for out in to_list(self.output()))

    for el in to_list(self.requires()) :
    INDENT
        if not el.complete() :
        INDENT
            return False
        DEDENT
        for output in to_list(el.output()) :
        INDENT
            if mtime(output.path) > self_mtime :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28793832_37893165_10_15
28793832_47840326_12_17
Title: Can luigi rerun tasks when the task dependencies become out of date? 
----------------------------------------

def to_list(obj) :
INDENT
    if type(obj) in (type(()), type([])) :
    INDENT
        return obj
    DEDENT
    else :
    INDENT
        return [obj]
    DEDENT
DEDENT
----------------------------------------

def to_list(obj) :
INDENT
    if type(obj) in (type(()), type([])) :
    INDENT
        return obj
    DEDENT
    else :
    INDENT
        return [obj]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28833940_28837731_28_38
28833940_28891005_54_66
Title: Maya Python: OptionMenu Selection With Button 
----------------------------------------

def ObjectCreation(* args) :
INDENT
    currentValue = cmds.optionMenu("UI_PolygonOptionMenu", query = True, value = True)
    if currentValue == "Sphere" :
    INDENT
        cmds.polySphere(name = "Sphere")
    DEDENT
    elif currentValue == "Cube" :
    INDENT
        cmds.polyCube(name = "Cube")
    DEDENT
    elif currentValue == "Cylinder" :
    INDENT
        cmds.polyCylinder(name = "Cylinder")
    DEDENT
    elif currentValue == "Cone" :
    INDENT
        cmds.polyCone(name = "Cone")
    DEDENT
DEDENT
----------------------------------------

def ObjectCreation(self, * args) :
INDENT
    if UI_Test_thingy.debug : print 'DEBUG - ObjectCreation called: args: {}'.format(args)
    menuVal = cmds.optionMenu(self.polygonSelectMenu, q = True, value = True)
    if menuVal == "Sphere" :
    INDENT
        UI_Test_thingy.createdThingys += cmds.polySphere(name = "Sphere")
    DEDENT
    elif menuVal == "Cube" :
    INDENT
        UI_Test_thingy.createdThingys += cmds.polyCube(name = "Cube")
    DEDENT
    elif menuVal == "Cylinder" :
    INDENT
        UI_Test_thingy.createdThingys += cmds.polyCylinder(name = "Cylinder")
    DEDENT
    elif menuVal == "Cone" :
    INDENT
        UI_Test_thingy.createdThingys += cmds.polyCone(name = "Cone")

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28833940_28837731_3_24
28833940_28891005_13_40
Title: Maya Python: OptionMenu Selection With Button 
----------------------------------------

def drawUI() :
INDENT
    if cmds.window("UI_MainWindow", exists = True) :
    INDENT
        cmds.deleteUI("UI_MainWindow")
    DEDENT
    cmds.window("UI_MainWindow", title = "User Interface Test", w = 500, h = 700, mnb = False, mxb = False, sizeable = False)
    cmds.columnLayout("UI_MainLayout", w = 300, h = 500)
    cmds.button("UI_ResetButton", label = "Reset", w = 300, command = SceneClear)
    cmds.optionMenu("UI_PolygonOptionMenu", w = 250, label = "Polygon Selection:")
    cmds.menuItem(label = " ")
    cmds.menuItem(label = "Sphere")
    cmds.menuItem(label = "Cube")
    cmds.menuItem(label = "Cylinder")
    cmds.menuItem(label = "Cone")
    cmds.button("UI_CreateButton", label = "Create", w = 200, command = ObjectCreation)
    cmds.button("UI_DeleteButton", label = "Delete", w = 200, command = DeleteButton)
    cmds.showWindow("UI_MainWindow")
DEDENT
----------------------------------------

def drawUI(self) :
INDENT
    if UI_Test_thingy.debug : print 'DEBUG - drawUI called'
    try :
    INDENT
        cmds.deleteUI(UI_Test_thingy.windowName)
    DEDENT
    except :
    INDENT
        pass
    DEDENT
    UIwindow = cmds.window(UI_Test_thingy.windowName, title = "User Interface Test {}".format(UI_Test_thingy.version), w = 500, h = 700, mnb = False, mxb = False, sizeable = False)
    mainLayout = cmds.columnLayout(w = 300, h = 500)
    cmds.button(label = "Reset", w = 300, command = self.SceneClear)
    self.polygonSelectMenu = cmds.optionMenu(w = 250, label = "Polygon Selection:")
    cmds.menuItem(label = " ")
    cmds.menuItem(label = "Sphere")
    cmds.menuItem(label = "Cube")
    cmds.menuItem(label = "Cylinder")
    cmds.menuItem(label = "Cone")
    cmds.button(label = "Create", w = 200, command = self.ObjectCreation)
    cmds.button(label = "Delete", w = 200, command = self.DeleteButton)
    cmds.showWindow(UIwindow)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28870085_28870218_12_19
28870085_28870397_1_14
Title: Python: Problems when calling outside function 
----------------------------------------

def your_name() :
INDENT
    while True :
    INDENT
        name = raw_input("What is your name? ")
        if not name :
        INDENT
            continue
        DEDENT
        else :
        INDENT
            confirm(your_name)
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def your_name() :
INDENT
    flag = True
    while flag :
    INDENT
        name = raw_input("What is your name? ")
        if name :
        INDENT
            while True :
            INDENT
                answer = raw_input('Are you sure? ')
                if answer == 'yes' :
                INDENT
                    flag = False
                    break
                DEDENT
                elif answer == 'no' :
                INDENT
                    break
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    print 'Congratulations! You have a name!'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28870085_28870218_12_19
28870085_28870516_12_20
Title: Python: Problems when calling outside function 
----------------------------------------

def your_name() :
INDENT
    while True :
    INDENT
        name = raw_input("What is your name? ")
        if not name :
        INDENT
            continue
        DEDENT
        else :
        INDENT
            confirm(your_name)
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def your_name() :
INDENT
    name = ''
    while name == '' :
    INDENT
        name = raw_input("What is your name? ")
    DEDENT
    if confirm() :
    INDENT
        print 'Congratulations! You have a name!'
    DEDENT
    else :
    INDENT
        your_name()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28870085_28870227_11_18
28870085_28870397_1_14
Title: Python: Problems when calling outside function 
----------------------------------------

def your_name() :
INDENT
    while True :
    INDENT
        name = raw_input("What is your name? ")
        if not name :
        INDENT
            continue
        DEDENT
        elif confirm() :
        INDENT
            print 'Congratulations! You have a name!'
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def your_name() :
INDENT
    flag = True
    while flag :
    INDENT
        name = raw_input("What is your name? ")
        if name :
        INDENT
            while True :
            INDENT
                answer = raw_input('Are you sure? ')
                if answer == 'yes' :
                INDENT
                    flag = False
                    break
                DEDENT
                elif answer == 'no' :
                INDENT
                    break
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    print 'Congratulations! You have a name!'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28870085_28870227_11_18
28870085_28870516_12_20
Title: Python: Problems when calling outside function 
----------------------------------------

def your_name() :
INDENT
    while True :
    INDENT
        name = raw_input("What is your name? ")
        if not name :
        INDENT
            continue
        DEDENT
        elif confirm() :
        INDENT
            print 'Congratulations! You have a name!'
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def your_name() :
INDENT
    name = ''
    while name == '' :
    INDENT
        name = raw_input("What is your name? ")
    DEDENT
    if confirm() :
    INDENT
        print 'Congratulations! You have a name!'
    DEDENT
    else :
    INDENT
        your_name()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28870085_28870397_1_14
28870085_28870516_12_20
Title: Python: Problems when calling outside function 
----------------------------------------

def your_name() :
INDENT
    flag = True
    while flag :
    INDENT
        name = raw_input("What is your name? ")
        if name :
        INDENT
            while True :
            INDENT
                answer = raw_input('Are you sure? ')
                if answer == 'yes' :
                INDENT
                    flag = False
                    break
                DEDENT
                elif answer == 'no' :
                INDENT
                    break
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    print 'Congratulations! You have a name!'
DEDENT
----------------------------------------

def your_name() :
INDENT
    name = ''
    while name == '' :
    INDENT
        name = raw_input("What is your name? ")
    DEDENT
    if confirm() :
    INDENT
        print 'Congratulations! You have a name!'
    DEDENT
    else :
    INDENT
        your_name()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28870224_28870312_3_21
28870224_28870335_6_22
Title: Return not showing up when called 
----------------------------------------

def results(val) :
INDENT
    guesses = 0
    while True :
    INDENT
        user = int(input("Guess the number: "))
        guesses = guesses + 1
        diff = user - computer
        if diff < - 10 :
        INDENT
            print ("Too Low")
        DEDENT
        elif diff > 10 :
        INDENT
            print ("Too High")
        DEDENT
        elif diff < 0 :
        INDENT
            print ("Getting warmer, but still low")
        DEDENT
        elif diff > 0 :
        INDENT
            print ("Getting warmer, but still high")
        DEDENT
        else :
        INDENT
            print ('Good job, you guessed correctly in {} guesses!'.format(guesses))
            break
        DEDENT
    DEDENT
    return guesses
DEDENT
----------------------------------------

def results(computer, user) :
INDENT
    results = ""
    diff = 0
    diff = user - computer
    if diff < - 10 :
    INDENT
        result = ("Too Low")
    DEDENT
    elif diff > 10 :
    INDENT
        result = ("Too High")
    DEDENT
    elif diff < 0 :
    INDENT
        result = ("Getting warmer, but still low")
    DEDENT
    elif diff > 0 :
    INDENT
        result = ("Getting warmer, but still high")
    DEDENT
    else :
    INDENT
        guesses = str(guesses)
        result = ('Good job, you guessed correctly in,', guesses, 'guesses!')
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28885085_28885252_1_12
28885085_28885520_6_15
Title: python file parsing next() function 
----------------------------------------

def get_length(fn) :
INDENT
    with open(fn, 'r') as inp :
    INDENT
        x = None
        for n, line in enumerate(inp) :
        INDENT
            if x is None and line.strip().startswith('HOMOGENEIZED CROSS SECTIONS FOR CELL') :
            INDENT
                x = n + 3
            DEDENT
            elif x == n :
            INDENT
                sigtr = float(line.split() [9])
                siga = float(line.split() [6])
                x = None
            DEDENT
        DEDENT
    DEDENT
    length = 1.0 / (3.0 * sigtr * siga)
    return length
DEDENT
----------------------------------------

def get_length(fn) :
INDENT
    with open(fn, 'r') as inp :
    INDENT
        for line in inp :
        INDENT
            if line.strip().startswith('HOMOGENEIZED CROSS SECTIONS FOR CELL') :
            INDENT
                consume_and_ignore(inp, 2)
                line = next(inp)
                sigtr = float(line.split() [9])
                siga = float(line.split() [6])
            DEDENT
        DEDENT
    DEDENT
    length = 1.0 / (3.0 * sigtr * siga)
    return length
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28892492_28893133_20_41
28892492_28893133_69_83
Title: Different Windows in TKinter 
----------------------------------------

def createWidgets(self) :
INDENT
    self.lUSER = tk.Label(self, text = "Username: ")
    self.lUSER.pack(side = "left")
    self.eUSER = tk.Entry(self)
    self.eUSER.pack(side = "left")
    self.lPASS = tk.Label(self, text = "Password: ")
    self.lPASS.pack(side = "left")
    self.ePASS = tk.Entry(self, show = "*")
    self.ePASS.pack(side = "left")

    self.LOGIN = tk.Button(self, text = "Login", fg = "green", command = self.setCredentials)
    self.LOGIN.pack(side = "left")
    self.QUIT = tk.Button(self, text = "QUIT", fg = "red", command = self.master.destroy)
    self.QUIT.pack(side = "left")

DEDENT
----------------------------------------

def createWidgets(self) :
INDENT
    self.bBuild = tk.Button(self, text = "Build Data", command = self.build)
    self.bBuild.pack(side = "top")

    self.bSearch = tk.Button(self, text = "Search", command = self.search)
    self.bSearch ["text"] = "Search"
    self.bSearch ["command"] = self.search
    self.bSearch.pack(side = "top")

    self.QUIT = tk.Button(self, text = "QUIT", fg = "red", command = self.master.destroy)
    self.QUIT.pack(side = "bottom")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2889255_13114208_6_18
2889255_3099287_28_44
Title: Return value from wxPython Frame 
----------------------------------------

def __init__(self, title, parent = None, size = (400, 300)) :
INDENT
    wx.App.__init__(self, False)
    self.frame = wx.Frame(parent, title = title, size = size)
    self.apple_button = wx.Button(self.frame, - 1, "Apple", (0, 0))
    self.apple_button.Bind(wx.EVT_BUTTON, self.apple_button_click)
    self.orange_button = wx.Button(self.frame, - 1, "Orange", (0, 100))
    self.orange_button.Bind(wx.EVT_BUTTON, self.orange_button_click)
    self.fruit = None
    self.frame.Show(True)
DEDENT
----------------------------------------

def __init__(self, parent, ID = - 1, title = "", pos = wx.DefaultPosition,
size = wx.DefaultSize, style = wx.DEFAULT_FRAME_STYLE) :
INDENT
    wx.Frame.__init__(self, parent, ID, title, pos, size, style)
    self.panel = panel = wx.Panel(self, - 1, style = wx.TAB_TRAVERSAL
        | wx.CLIP_CHILDREN
        | wx.FULL_REPAINT_ON_RESIZE)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add((25, 25))
    row = wx.BoxSizer(wx.HORIZONTAL)
    row.Add((25, 1))
    m_close = wx.Button(self.panel, wx.ID_CLOSE, "Close")
    m_close.Bind(wx.EVT_BUTTON, self.OnClose)
    row.Add(m_close, 0, wx.ALL, 10)
    sizer.Add(row)
    self.panel.SetSizer(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28893469_28894063_8_17
28893469_28895309_8_15
Title: "Python ""Switch-Case"" alternative showing error" 
----------------------------------------

def run() :
INDENT
    x = int(raw_input("Enter 1 or 2 :"))
    print x
    if x == 1 :
    INDENT
        case_1()
    DEDENT
    elif x == 2 :
    INDENT
        case_2()
    DEDENT
    else :
    INDENT
        print "Please enter 1 or 2 only"
    DEDENT
DEDENT
----------------------------------------

def run() :
INDENT
    dic = {1 : case_1, 2 : case_2}
    x = int(raw_input("Enter 1 or 2 :"))
    if x == 1 or x == 2 :
    INDENT
        dic [x]()
    DEDENT
    else :
    INDENT
        print "Please enter 1 or 2 only"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28894747_28903232_26_54
28894747_28903232_7_19
Title: add pages on button press (wx.Notebook) 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Notebook Tutorial",
        size = (600, 400))
    panel = wx.Panel(self)
    self.tab_num = 3
    self.notebook = wx.Notebook(panel)
    tabOne = TabPanel(self.notebook)
    self.notebook.AddPage(tabOne, "Tab 1")
    tabTwo = TabPanel(self.notebook)
    self.notebook.AddPage(tabTwo, "Tab 2")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.notebook, 1, wx.ALL | wx.EXPAND, 5)
    btn = wx.Button(panel, label = "Add Page")
    btn.Bind(wx.EVT_BUTTON, self.addPage)
    sizer.Add(btn)
    panel.SetSizer(sizer)
    self.Layout()
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    colors = ["red", "blue", "gray", "yellow", "green"]
    self.SetBackgroundColour(random.choice(colors))
    btn = wx.Button(self, label = "Press Me")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(btn, 0, wx.ALL, 10)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28897985_1_12
28897925_28897986_3_13
Title: Calling a function recursively 
----------------------------------------

def my_change(amount, i = None) :
INDENT
    c = [1, 2, 5, 10, 20, 50, 100, 500]
    if i is None :
    INDENT
        i = len(c) - 1
    DEDENT
    note = c [i]
    n, rest = divmod(amount, note)
    result = {}
    if n > 0 :
    INDENT
        result [note] = n
    DEDENT
    if rest > 0 :
    INDENT
        result.update(my_change(rest, i - 1))
    DEDENT
    return result
DEDENT
----------------------------------------

def my_change(my_amount) :
INDENT
    my_dict = {}
    c = [1, 2, 5, 10, 20, 50, 100, 500]
    while (my_amount > 0) :
    INDENT
        my_pos = bisect.bisect(c, my_amount)
        my_val = c [my_pos - 1]
        my_num = my_amount / / my_val
        my_recurr = my_amount - (my_num * c [my_pos - 1])
        my_dir [my_val] = my_num
        my_amount = my_recurr
    DEDENT
    return my_dir
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28897985_1_12
28897925_28898211_5_13
Title: Calling a function recursively 
----------------------------------------

def my_change(amount, i = None) :
INDENT
    c = [1, 2, 5, 10, 20, 50, 100, 500]
    if i is None :
    INDENT
        i = len(c) - 1
    DEDENT
    note = c [i]
    n, rest = divmod(amount, note)
    result = {}
    if n > 0 :
    INDENT
        result [note] = n
    DEDENT
    if rest > 0 :
    INDENT
        result.update(my_change(rest, i - 1))
    DEDENT
    return result
DEDENT
----------------------------------------

def my_change(amount) :
INDENT
    def go(amount, notesUsed) :
    INDENT
        if amount < = 0 :
        INDENT
            return notesUsed
        DEDENT
        largestNote = next(x for x in notes if x < = amount)
        notesUsed [largestNote] += 1
        return go(amount - largestNote, notesUsed)
    DEDENT
    return go(amount, collections.defaultdict(int))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28897985_1_12
28897925_28898704_5_18
Title: Calling a function recursively 
----------------------------------------

def my_change(amount, i = None) :
INDENT
    c = [1, 2, 5, 10, 20, 50, 100, 500]
    if i is None :
    INDENT
        i = len(c) - 1
    DEDENT
    note = c [i]
    n, rest = divmod(amount, note)
    result = {}
    if n > 0 :
    INDENT
        result [note] = n
    DEDENT
    if rest > 0 :
    INDENT
        result.update(my_change(rest, i - 1))
    DEDENT
    return result
DEDENT
----------------------------------------

def my_change(amount) :
INDENT
    my_notes = list(all_notes)
    change = {}
    print amount
    while amount > 0 :
    INDENT
        while my_notes [- 1] > amount :
        INDENT
            my_notes.pop()
        DEDENT
        note = my_notes [- 1]
        num, amount = divmod(amount, note)
        print '%d x %d = %d, %d' % (num, note, num * note, amount)
        change [note] = num
    DEDENT
    return change
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28897985_1_12
28897925_28901106_8_24
Title: Calling a function recursively 
----------------------------------------

def my_change(amount, i = None) :
INDENT
    c = [1, 2, 5, 10, 20, 50, 100, 500]
    if i is None :
    INDENT
        i = len(c) - 1
    DEDENT
    note = c [i]
    n, rest = divmod(amount, note)
    result = {}
    if n > 0 :
    INDENT
        result [note] = n
    DEDENT
    if rest > 0 :
    INDENT
        result.update(my_change(rest, i - 1))
    DEDENT
    return result
DEDENT
----------------------------------------

def my_change(amount, available_cash) :
INDENT
    change = {}
    for note in reversed(available_cash.keys()) :
    INDENT
        note_count = amount / note
        if note_count == 0 :
        INDENT
            continue
        DEDENT
        elif note_count > available_cash [note] :
        INDENT
            note_count = available_cash [note]
            available_cash [note] = 0
        DEDENT
        else :
        INDENT
            available_cash [note] -= note_count
        DEDENT
        change [note] = note_count
        amount -= note_count * note
        if amount == 0 :
        INDENT
            break
        DEDENT
    DEDENT
    return change
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28897986_3_13
28897925_28898211_5_13
Title: Calling a function recursively 
----------------------------------------

def my_change(my_amount) :
INDENT
    my_dict = {}
    c = [1, 2, 5, 10, 20, 50, 100, 500]
    while (my_amount > 0) :
    INDENT
        my_pos = bisect.bisect(c, my_amount)
        my_val = c [my_pos - 1]
        my_num = my_amount / / my_val
        my_recurr = my_amount - (my_num * c [my_pos - 1])
        my_dir [my_val] = my_num
        my_amount = my_recurr
    DEDENT
    return my_dir
DEDENT
----------------------------------------

def my_change(amount) :
INDENT
    def go(amount, notesUsed) :
    INDENT
        if amount < = 0 :
        INDENT
            return notesUsed
        DEDENT
        largestNote = next(x for x in notes if x < = amount)
        notesUsed [largestNote] += 1
        return go(amount - largestNote, notesUsed)
    DEDENT
    return go(amount, collections.defaultdict(int))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28897986_3_13
28897925_28898704_5_18
Title: Calling a function recursively 
----------------------------------------

def my_change(my_amount) :
INDENT
    my_dict = {}
    c = [1, 2, 5, 10, 20, 50, 100, 500]
    while (my_amount > 0) :
    INDENT
        my_pos = bisect.bisect(c, my_amount)
        my_val = c [my_pos - 1]
        my_num = my_amount / / my_val
        my_recurr = my_amount - (my_num * c [my_pos - 1])
        my_dir [my_val] = my_num
        my_amount = my_recurr
    DEDENT
    return my_dir
DEDENT
----------------------------------------

def my_change(amount) :
INDENT
    my_notes = list(all_notes)
    change = {}
    print amount
    while amount > 0 :
    INDENT
        while my_notes [- 1] > amount :
        INDENT
            my_notes.pop()
        DEDENT
        note = my_notes [- 1]
        num, amount = divmod(amount, note)
        print '%d x %d = %d, %d' % (num, note, num * note, amount)
        change [note] = num
    DEDENT
    return change
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28897986_3_13
28897925_28901106_8_24
Title: Calling a function recursively 
----------------------------------------

def my_change(my_amount) :
INDENT
    my_dict = {}
    c = [1, 2, 5, 10, 20, 50, 100, 500]
    while (my_amount > 0) :
    INDENT
        my_pos = bisect.bisect(c, my_amount)
        my_val = c [my_pos - 1]
        my_num = my_amount / / my_val
        my_recurr = my_amount - (my_num * c [my_pos - 1])
        my_dir [my_val] = my_num
        my_amount = my_recurr
    DEDENT
    return my_dir
DEDENT
----------------------------------------

def my_change(amount, available_cash) :
INDENT
    change = {}
    for note in reversed(available_cash.keys()) :
    INDENT
        note_count = amount / note
        if note_count == 0 :
        INDENT
            continue
        DEDENT
        elif note_count > available_cash [note] :
        INDENT
            note_count = available_cash [note]
            available_cash [note] = 0
        DEDENT
        else :
        INDENT
            available_cash [note] -= note_count
        DEDENT
        change [note] = note_count
        amount -= note_count * note
        if amount == 0 :
        INDENT
            break
        DEDENT
    DEDENT
    return change
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28898211_5_13
28897925_28898704_5_18
Title: Calling a function recursively 
----------------------------------------

def my_change(amount) :
INDENT
    def go(amount, notesUsed) :
    INDENT
        if amount < = 0 :
        INDENT
            return notesUsed
        DEDENT
        largestNote = next(x for x in notes if x < = amount)
        notesUsed [largestNote] += 1
        return go(amount - largestNote, notesUsed)
    DEDENT
    return go(amount, collections.defaultdict(int))
DEDENT
----------------------------------------

def my_change(amount) :
INDENT
    my_notes = list(all_notes)
    change = {}
    print amount
    while amount > 0 :
    INDENT
        while my_notes [- 1] > amount :
        INDENT
            my_notes.pop()
        DEDENT
        note = my_notes [- 1]
        num, amount = divmod(amount, note)
        print '%d x %d = %d, %d' % (num, note, num * note, amount)
        change [note] = num
    DEDENT
    return change
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28898211_5_13
28897925_28901106_8_24
Title: Calling a function recursively 
----------------------------------------

def my_change(amount) :
INDENT
    def go(amount, notesUsed) :
    INDENT
        if amount < = 0 :
        INDENT
            return notesUsed
        DEDENT
        largestNote = next(x for x in notes if x < = amount)
        notesUsed [largestNote] += 1
        return go(amount - largestNote, notesUsed)
    DEDENT
    return go(amount, collections.defaultdict(int))
DEDENT
----------------------------------------

def my_change(amount, available_cash) :
INDENT
    change = {}
    for note in reversed(available_cash.keys()) :
    INDENT
        note_count = amount / note
        if note_count == 0 :
        INDENT
            continue
        DEDENT
        elif note_count > available_cash [note] :
        INDENT
            note_count = available_cash [note]
            available_cash [note] = 0
        DEDENT
        else :
        INDENT
            available_cash [note] -= note_count
        DEDENT
        change [note] = note_count
        amount -= note_count * note
        if amount == 0 :
        INDENT
            break
        DEDENT
    DEDENT
    return change
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28897925_28898704_5_18
28897925_28901106_8_24
Title: Calling a function recursively 
----------------------------------------

def my_change(amount) :
INDENT
    my_notes = list(all_notes)
    change = {}
    print amount
    while amount > 0 :
    INDENT
        while my_notes [- 1] > amount :
        INDENT
            my_notes.pop()
        DEDENT
        note = my_notes [- 1]
        num, amount = divmod(amount, note)
        print '%d x %d = %d, %d' % (num, note, num * note, amount)
        change [note] = num
    DEDENT
    return change
DEDENT
----------------------------------------

def my_change(amount, available_cash) :
INDENT
    change = {}
    for note in reversed(available_cash.keys()) :
    INDENT
        note_count = amount / note
        if note_count == 0 :
        INDENT
            continue
        DEDENT
        elif note_count > available_cash [note] :
        INDENT
            note_count = available_cash [note]
            available_cash [note] = 0
        DEDENT
        else :
        INDENT
            available_cash [note] -= note_count
        DEDENT
        change [note] = note_count
        amount -= note_count * note
        if amount == 0 :
        INDENT
            break
        DEDENT
    DEDENT
    return change
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28900100_28901595_107_121
28900100_28901595_14_31
Title: Python Tkinter check radio button state before proceed 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Page 02!!!", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button1 = tk.Button(self, text = "Back to Home",
        command = lambda : controller.show_frame(MainPage))
    button1.pack()
    button2 = tk.Button(self, text = "Page 01",
        command = lambda : controller.show_frame(PageSub35t))
    button2.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack()
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (MainPage, Page01, Page02) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(MainPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28900100_28901595_107_121
28900100_28901595_46_104
Title: Python Tkinter check radio button state before proceed 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Page 02!!!", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button1 = tk.Button(self, text = "Back to Home",
        command = lambda : controller.show_frame(MainPage))
    button1.pack()
    button2 = tk.Button(self, text = "Page 01",
        command = lambda : controller.show_frame(PageSub35t))
    button2.pack()

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    option1 = tk.IntVar()
    option2 = tk.IntVar()
    option3 = tk.IntVar()
    tk.Frame.__init__(self, parent)
    f = tk.Frame(self)
    f.pack(side = 'left')
    label1 = tk.Label(f, text = 'Select options', fg = 'blue', font = ("Arial", 36, "bold"), width = 54, relief = 'solid').grid(row = 1, column = 1, columnspan = 3)

    buttonoption21 = tk.Radiobutton(f, text = "Option 2 - A", variable = option2, value = 1, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption21.grid(row = 3, column = 2)
    buttonoption22 = tk.Radiobutton(f, text = "Option 2 - B", variable = option2, value = 2, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption22.grid(row = 4, column = 2)
    buttonoption32 = tk.Radiobutton(f, text = "Option 3 - B", variable = option3, value = 2, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption32.grid(row = 4, column = 3)
    buttonoption23 = tk.Radiobutton(f, text = "Option 2 - C", variable = option2, value = 3, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption23.grid(row = 5, column = 2)

    list_conditional = [buttonoption21, buttonoption22, buttonoption32, buttonoption23]

    def switch_button(button, active = True) :
    INDENT
        if button is not None :
        INDENT
            button ['state'] = {True : tk.NORMAL, False : tk.DISABLED} [active]

        DEDENT
    DEDENT
    def switch_all_button(active = True) :
    INDENT
        for button in list_conditional :
        INDENT
            switch_button(button, active = active)
        DEDENT
    DEDENT
    def after_option_command(what_button_should_be_disabled = None) :
    INDENT
        def after_option() :
        INDENT
            switch_all_button(active = True)
            switch_button(what_button_should_be_disabled, active = False)
        DEDENT
        return after_option

    DEDENT
    buttonoption11 = tk.Radiobutton(f, command = after_option_command(buttonoption23), text = "Option 1 - A", variable = option1, value = 1, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption11.grid(row = 3, column = 1)
    buttonoption12 = tk.Radiobutton(f, command = after_option_command(), text = "Option 1 - B", variable = option1, value = 2, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption12.grid(row = 4, column = 1)

    buttonnback = tk.Button(f, text = 'Back', fg = 'blue', font = ('Helvetica', 26), height = 1, width = 15, command = lambda : controller.show_frame(MainPage)).grid(row = 10, column = 1)
    buttonnext = tk.Button(f, text = 'Next', fg = 'blue', font = ('Helvetica', 26), height = 3, width = 15, command = lambda : controller.show_frame(Page02)).grid(row = 10, column = 2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28900100_28901595_14_31
28900100_28901595_46_104
Title: Python Tkinter check radio button state before proceed 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack()
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (MainPage, Page01, Page02) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(MainPage)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    option1 = tk.IntVar()
    option2 = tk.IntVar()
    option3 = tk.IntVar()
    tk.Frame.__init__(self, parent)
    f = tk.Frame(self)
    f.pack(side = 'left')
    label1 = tk.Label(f, text = 'Select options', fg = 'blue', font = ("Arial", 36, "bold"), width = 54, relief = 'solid').grid(row = 1, column = 1, columnspan = 3)

    buttonoption21 = tk.Radiobutton(f, text = "Option 2 - A", variable = option2, value = 1, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption21.grid(row = 3, column = 2)
    buttonoption22 = tk.Radiobutton(f, text = "Option 2 - B", variable = option2, value = 2, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption22.grid(row = 4, column = 2)
    buttonoption32 = tk.Radiobutton(f, text = "Option 3 - B", variable = option3, value = 2, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption32.grid(row = 4, column = 3)
    buttonoption23 = tk.Radiobutton(f, text = "Option 2 - C", variable = option2, value = 3, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption23.grid(row = 5, column = 2)

    list_conditional = [buttonoption21, buttonoption22, buttonoption32, buttonoption23]

    def switch_button(button, active = True) :
    INDENT
        if button is not None :
        INDENT
            button ['state'] = {True : tk.NORMAL, False : tk.DISABLED} [active]

        DEDENT
    DEDENT
    def switch_all_button(active = True) :
    INDENT
        for button in list_conditional :
        INDENT
            switch_button(button, active = active)
        DEDENT
    DEDENT
    def after_option_command(what_button_should_be_disabled = None) :
    INDENT
        def after_option() :
        INDENT
            switch_all_button(active = True)
            switch_button(what_button_should_be_disabled, active = False)
        DEDENT
        return after_option

    DEDENT
    buttonoption11 = tk.Radiobutton(f, command = after_option_command(buttonoption23), text = "Option 1 - A", variable = option1, value = 1, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption11.grid(row = 3, column = 1)
    buttonoption12 = tk.Radiobutton(f, command = after_option_command(), text = "Option 1 - B", variable = option1, value = 2, indicatoron = 0, fg = 'blue', font = ('Helvetica', 26), height = 1, width = 20)
    buttonoption12.grid(row = 4, column = 1)

    buttonnback = tk.Button(f, text = 'Back', fg = 'blue', font = ('Helvetica', 26), height = 1, width = 15, command = lambda : controller.show_frame(MainPage)).grid(row = 10, column = 1)
    buttonnext = tk.Button(f, text = 'Next', fg = 'blue', font = ('Helvetica', 26), height = 3, width = 15, command = lambda : controller.show_frame(Page02)).grid(row = 10, column = 2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28909474_28909712_5_10
28909474_28910017_16_20
Title: Dectecting a value change in Python loop 
----------------------------------------

def update(self, new) :
INDENT
    if self.val == new :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        self.val = new
        return True
    DEDENT
DEDENT
----------------------------------------

def update(self, new_value) :
INDENT
    self._is_changed = (new_value ! = self.current_value)
    if self._is_changed :
    INDENT
        self.last_value = self.current_value
        self.current_value = new_value
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28956693_28981607_44_55
28956693_29268818_14_22
Title: PyQt5 QTextEdit auto completion 
----------------------------------------

def insertCompletion(self, completion) :
INDENT
    tc = self.textCursor()
    extra = (len(completion) -
        len(self.completer.completionPrefix()))
    tc.movePosition(QtGui.QTextCursor.Left)
    tc.movePosition(QtGui.QTextCursor.EndOfWord)
    tc.insertText(completion [- extra :])
    self.setTextCursor(tc)

DEDENT
----------------------------------------

def insertCompletion(self, completion) :
INDENT
    tc = self.textCursor()
    extra = (len(completion) - len(self.completer.completionPrefix()))
    tc.movePosition(QTextCursor.Left)
    tc.movePosition(QTextCursor.EndOfWord)
    tc.insertText(completion [- extra :])
    self.setTextCursor(tc)
    self.completer.popup().hide()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28956693_28981607_74_147
28956693_29268818_28_49
Title: PyQt5 QTextEdit auto completion 
----------------------------------------

def keyPressEvent(self, event) :
INDENT
    if self.completer and self.completer.popup() and self.completer.popup().isVisible() :
    INDENT
        if event.key() in (
            QtCore.Qt.Key_Enter,
            QtCore.Qt.Key_Return,
            QtCore.Qt.Key_Escape,
            QtCore.Qt.Key_Tab,
            QtCore.Qt.Key_Backtab) :
        INDENT
            event.ignore()
            return
        DEDENT
    DEDENT
    isShortcut = (event.modifiers() == QtCore.Qt.ControlModifier and event.key() == QtCore.Qt.Key_Space)
    inline = (event.modifiers() == QtCore.Qt.ControlModifier and event.key() == QtCore.Qt.Key_E)
    if inline :
    INDENT

        self.completer.setCompletionMode(QtGui.QCompleter.InlineCompletion)
        completionPrefix = self.textUnderCursor()
        if (completionPrefix ! = self.completer.completionPrefix()) :
        INDENT
            self.completer.setCompletionPrefix(completionPrefix)
        DEDENT
        self.completer.complete()

        self.completer.insertText.emit(self.completer.currentCompletion())
        self.completer.setCompletionMode(QtGui.QCompleter.PopupCompletion)
        return
    DEDENT
    if (not self.completer or not isShortcut) :
    INDENT
        pass
        QtGui.QTextEdit.keyPressEvent(self, event)

    DEDENT
    ctrlOrShift = event.modifiers() in (QtCore.Qt.ControlModifier, QtCore.Qt.ShiftModifier)
    if ctrlOrShift and event.text() == '' :
    INDENT
        return
    DEDENT
    eow = "~!@#$%^&*+{}|:\"<>?,./;'[]\\-="
    hasModifier = ((event.modifiers() ! = QtCore.Qt.NoModifier) and not ctrlOrShift)
    completionPrefix = self.textUnderCursor()

    if not isShortcut :
    INDENT
        if self.completer.popup() :
        INDENT
            self.completer.popup().hide()
        DEDENT
        return
    DEDENT
    self.completer.setCompletionPrefix(completionPrefix)
    popup = self.completer.popup()
    popup.setCurrentIndex(
        self.completer.completionModel().index(0, 0))
    cr = self.cursorRect()
    cr.setWidth(self.completer.popup().sizeHintForColumn(0)
        + self.completer.popup().verticalScrollBar().sizeHint().width())
    self.completer.complete(cr)

DEDENT
----------------------------------------

def keyPressEvent(self, event) :
INDENT
    tc = self.textCursor()
    if event.key() == Qt.Key_Tab and self.completer.popup().isVisible() :
    INDENT
        self.completer.insertText.emit(self.completer.getSelected())
        self.completer.setCompletionMode(QCompleter.PopupCompletion)
        return
    DEDENT
    QPlainTextEdit.keyPressEvent(self, event)
    tc.select(QTextCursor.WordUnderCursor)
    cr = self.cursorRect()
    if len(tc.selectedText()) > 0 :
    INDENT
        self.completer.setCompletionPrefix(tc.selectedText())
        popup = self.completer.popup()
        popup.setCurrentIndex(self.completer.completionModel().index(0, 0))
        cr.setWidth(self.completer.popup().sizeHintForColumn(0)
            + self.completer.popup().verticalScrollBar().sizeHint().width())
        self.completer.complete(cr)
    DEDENT
    else :
    INDENT
        self.completer.popup().hide()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28977575_28977635_1_10
28977575_28986220_3_9
Title: Change a text file to a list 
----------------------------------------

def computeWordFrequencies(filename) :
INDENT
    f = open(filename, 'r')
    line = f.readlines()
    L [0] = []
    L [1] = []
    for line in lines :
    INDENT
        L [0].append(line)
        L [0] = uniqueExtend(L [0])
    DEDENT
    return (L [0])
DEDENT
----------------------------------------

def computeWordFrequencies(filename) :
INDENT
    with open(filename) as f :
    INDENT
        words = [word for line in f for word in line.split()]
    DEDENT
    words_count = Counter(words)
    unique_words = words_count.keys()
    return unique_words
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28990497_28995530_9_15
28990497_44960770_13_27
Title: Creating a shell command line application with Python and Click 
----------------------------------------

def default(self, line) :
INDENT
    subcommand = cli.commands.get(line)
    if subcommand :
    INDENT
        self.ctx.invoke(subcommand)
    DEDENT
    else :
    INDENT
        return cmd.Cmd.default(self, line)
    DEDENT
DEDENT
----------------------------------------

def default(self, line) :
INDENT
    subcommand = line.split() [0]
    args = line.split() [1 :]
    subcommand = cli.commands.get(subcommand)
    if subcommand :
    INDENT
        try :
        INDENT
            subcommand.parse_args(self.ctx, args)
            self.ctx.forward(subcommand)
        DEDENT
        except UsageError as e :
        INDENT
            print (e.format_message())
        DEDENT
    DEDENT
    else :
    INDENT
        return cmd.Cmd.default(self, line)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29005959_29006785_3_11
29005959_29006786_3_8
Title: Depth of a json tree 
----------------------------------------

def depth(root) :
INDENT
    if root is None :
    INDENT
        return 0
    DEDENT
    if isinstance(root, list) :
    INDENT
        return max(map(depth, root)) + 1
    DEDENT
    if not isinstance(root, dict) :
    INDENT
        return 1
    DEDENT
    return max(depth(v) for k, v in root.items()) + 1
DEDENT
----------------------------------------

def depth(jsn) :
INDENT
    if jsn.has_key('children') :
    INDENT
        return 1 + max([0] + map(depth, jsn ['children']))
    DEDENT
    else :
    INDENT
        return 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29018331_29018555_5_12
29018331_29018723_5_14
Title: WxPython using Listbox and other UserInput with a Button 
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, 'Title', size = (300, 200))
    tournLevel = ['$10,000', '$15,000', '$20,000', '$50,000', '$75,000', '$100,000']
    self.levelBox = wx.ListBox(panel, - 1, (40, 50), (90, 90), tournLevel)
    self.levelBox.SetSelection(1)
    self.checkButton = wx.Button(panel, label = "Check Now", pos = (150, 50), size = (90, 40))
    self.Bind(wx.EVT_BUTTON, self.OnClick, self.checkButton)
DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, 'Title', size = (300, 200))
    panel = wx.Panel(self)
    tournLevel = ['$10,000', '$15,000', '$20,000', '$50,000', '$75,000', '$100,000']
    levelBox = wx.ListBox(panel, - 1, (40, 50), (90, 90), tournLevel)
    levelBox.SetSelection(1)
    checkButton = wx.Button(panel, label = "Check Now", pos = (150, 50), size = (90, 40))
    evt = lambda caller, widget = levelBox : self.OnClick(caller, widget)
    checkButton.Bind(wx.EVT_BUTTON, evt)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29023605_29023738_1_6
29023605_52304830_3_24
Title: "iterative implementation of the ruler function (121312141213...)" 
----------------------------------------

def ruler(k) :
INDENT
    pow = 1
    while ((2 * k) % (2 ** pow)) == 0 :
    INDENT
        pow += 1
    DEDENT
    return pow - 1
DEDENT
----------------------------------------

def ruler() :
INDENT
    print ("Initiating ruler function...")
    num = int(input("Enter the value to Eval::  "))
    expNumrange = 1234567890
    if num % 2 == 0 :
    INDENT
        for i in range(num) :
        INDENT
            print(expNumrange, end = '----')
        DEDENT
    DEDENT
    else :
    INDENT
        rem = num % 2
        remLen = len(str(abs(rem)))
        expNumrangelen = len(str(abs(expNumrange)))
        finval = len(str(abs(expNumrange - remLen)))
        setVal = expNumrange - finval
        for i in range(num) :
        INDENT
            print(expNumrange, end = (str(setVal) + '--'))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29056597_29056637_4_23
29056597_29056865_4_18
Title: Taking input from user and returning an answer in TKinter 
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tk.Tk()
    self.root.wm_title("Fibonacci Calculator")
    self.label = Tk.Label(self.root, text = "Set the digit number you want.")
    self.label.pack()
    self.digits = Tk.StringVar()
    Tk.Entry(self.root, textvariable = self.digits).pack()
    self.buttontext = Tk.StringVar()
    self.buttontext.set("Calculate")
    Tk.Button(self.root,
        textvariable = self.buttontext,
        command = self.clicked1).pack()
    self.label = Tk.Label(self.root, text = " ")
    self.label.pack()
    self.root.mainloop()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tk.Tk()
    self.root.wm_title("Fibonacci Calculator")
    self.root.wm_iconbitmap("@icon2.xbm")
    Tk.Label(self.root, text = "Set the digit number you want.").pack()
    self.digits = Tk.StringVar()
    Tk.Entry(self.root, textvariable = self.digits).pack()
    Tk.Button(self.root, text = "Calculate", command = self.clicked).pack()
    self.result = Tk.Label(self.root, text = " ")
    self.result.pack()
    self.root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29089435_29089530_1_12
29089435_29089675_5_13
Title: Large list generation optimization 
----------------------------------------

def expand_seq(seq) :
INDENT
    expanded = []
    for s in seq :
    INDENT
        name, indices = s [0 : - 1].split("[")
        if ":" in indices :
        INDENT
            index1, index2 = [int(i) for i in indices.split(":")]
        DEDENT
        else :
        INDENT
            index1 = int(indices)
            index2 = index1
        DEDENT
        for n in range(index1, index2 + 1) :
        INDENT
            expanded.append("{}[{}]".format(name, n))
        DEDENT
    DEDENT
    return expanded
DEDENT
----------------------------------------

def expand_seq(seq) :
INDENT
    result = []
    for item in seq :
    INDENT
        m = r.match(item)
        name, start, end = m.group(1), int(m.group(2)), m.group(3)
        rng = xrange(start, int(end)) if end else (start,)
        t = name + "["
        result.extend(t + str(i) + "]" for i in rng)
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29106642_29109596_14_28
29106642_29109596_33_86
Title: How to remove blank space left by a removed window in wxpython? 
----------------------------------------

def __init__(self, Ani = 999.0e29, AZ = 9.99) :
INDENT
    self.Ani = Ani
    self.AZ = AZ
    self.Axmin = []
    self.Axmax = []
    self.Aymin = []
    self.Aymax = []

    region.nreg += 1

DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    super(MainWindow, self).__init__(parent, title = title, size = (450, 350))
    self.dirname = ""
    self.filename = ""
    self.ibox = 0
    self.iv = 0
    self.iw = 0
    self.Aregion_objects = []
    self.test_vbox = wx.BoxSizer(wx.VERTICAL)

    self.text_Atitle = []
    self.text_Ani = []
    self.tc_Ani = []
    self.text_AZ = []
    self.tc_AZ = []
    self.text_Axmin = []
    self.tc_Axmin = []
    self.text_Axmax = []
    self.tc_Axmax = []
    self.text_Aymin = []
    self.tc_Aymin = []
    self.text_Aymax = []
    self.tc_Aymax = []
    self.button_Aremove = []

    self.sizer = wx.GridBagSizer(5, 1)
    self.sizer2 = wx.GridBagSizer(1, 1)
    self.SetClientSize((900, 900))
    self.SetMinSize((- 1, - 1))
    self.InitGUI()
    self.Centre()
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29107641_29107956_1_22
29107641_29108057_3_12
Title: Making a new list in alphabetical order 
----------------------------------------

def merge(list1, list2) :
INDENT
    iter1 = iter(list1)
    iter2 = iter(list2)
    top1 = iter1.next()
    top2 = iter2.next()
    newlist = []
    while True :
    INDENT
        if top1 < = top2 :
        INDENT
            newlist.append(top1)
            try :
            INDENT
                top1 = iter1.next()
            DEDENT
            except StopIteration :
            INDENT
                newlist.extend(iter2)
                break
            DEDENT
        DEDENT
        else :
        INDENT
            newlist.append(top2)
            try :
            INDENT
                top2 = iter2.next()
            DEDENT
            except StopIteration :
            INDENT
                newlist.extend(iter1)
                break
            DEDENT
        DEDENT
    DEDENT
    return newlist
DEDENT
----------------------------------------

def merge(lst1, lst2) :
INDENT
    lst1, lst2 = lst1 [: : - 1], lst2 [: : - 1]
    result = []
    while True :
    INDENT
        if not all([lst1, lst2]) :
        INDENT
            return result + lst1 [: : - 1] + lst2 [: : - 1]
        DEDENT
        lst_to_pop_from = min(lst1, lst2, key = iget(- 1))
        result.append(lst_to_pop_from.pop())
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29111782_29112027_9_25
29111782_29116367_1_30
Title: Deleting multiple lines based on serach conditon python 
----------------------------------------

def delete_host(s) :
INDENT
    host = raw_input('Please enter host you would like to delete: ')
    lines = s.split('\n')
    for i, line in enumerate(lines) :
    INDENT
        if re.match(r'\s*host\s+' + host + '\s*{', line) :
        INDENT
            break
        DEDENT
    DEDENT
    for j, line in enumerate(lines [i + 1 :]) :
    INDENT
        if re.match(r'\s*}', line) :
        INDENT
            break
        DEDENT
    DEDENT
    j = i + j + 1
    new_lines = lines [: i] + lines [j + 1 :]
    return '\n'.join(new_lines)
DEDENT
----------------------------------------

def delete_host() :
INDENT
    infile = 'C:\dhcp.txt'
    host = raw_input('Please enter host you would like to delete: ');
    start = False;
    f = open(infile, 'r')
    nf = open(r'C:\test.txt', 'w')
    myfile = str()
    myindex = list()
    mystr = str()
    count = 0
    lines = f.readlines()
    for i, line in enumerate(lines) :
    INDENT
        if re.search(host, line) :
        INDENT
            start = True
        DEDENT
        if start :
        INDENT

            myindex.append(lines.index(line))
            if re.search('}', line) :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    print myindex
    print type(myindex [0])
    del lines [myindex]

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29111782_29112027_9_25
29111782_29173409_1_25
Title: Deleting multiple lines based on serach conditon python 
----------------------------------------

def delete_host(s) :
INDENT
    host = raw_input('Please enter host you would like to delete: ')
    lines = s.split('\n')
    for i, line in enumerate(lines) :
    INDENT
        if re.match(r'\s*host\s+' + host + '\s*{', line) :
        INDENT
            break
        DEDENT
    DEDENT
    for j, line in enumerate(lines [i + 1 :]) :
    INDENT
        if re.match(r'\s*}', line) :
        INDENT
            break
        DEDENT
    DEDENT
    j = i + j + 1
    new_lines = lines [: i] + lines [j + 1 :]
    return '\n'.join(new_lines)
DEDENT
----------------------------------------

def delete_host() :
INDENT
    host = raw_input('Please enter host you would like to delete: ');
    start = False;
    infile = '/etc/dhcp/dhcpd.conf'
    f = open(infile, 'r')
    lines = f.readlines()
    nf = open('/var/tmp/testing', 'w')
    for line in lines :
    INDENT
        if re.search(host, line) :
        INDENT
            print 'if search'
            start = True
        DEDENT
        if start :
        INDENT
            print 'is start'
            print line
            if re.search('}', line) :
            INDENT
                start = False
                print 'false'
            DEDENT
        DEDENT
        else :
        INDENT

            nf.write(line)
            print 'writing'
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29111782_29116367_1_30
29111782_29173409_1_25
Title: Deleting multiple lines based on serach conditon python 
----------------------------------------

def delete_host() :
INDENT
    infile = 'C:\dhcp.txt'
    host = raw_input('Please enter host you would like to delete: ');
    start = False;
    f = open(infile, 'r')
    nf = open(r'C:\test.txt', 'w')
    myfile = str()
    myindex = list()
    mystr = str()
    count = 0
    lines = f.readlines()
    for i, line in enumerate(lines) :
    INDENT
        if re.search(host, line) :
        INDENT
            start = True
        DEDENT
        if start :
        INDENT

            myindex.append(lines.index(line))
            if re.search('}', line) :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    print myindex
    print type(myindex [0])
    del lines [myindex]

DEDENT
----------------------------------------

def delete_host() :
INDENT
    host = raw_input('Please enter host you would like to delete: ');
    start = False;
    infile = '/etc/dhcp/dhcpd.conf'
    f = open(infile, 'r')
    lines = f.readlines()
    nf = open('/var/tmp/testing', 'w')
    for line in lines :
    INDENT
        if re.search(host, line) :
        INDENT
            print 'if search'
            start = True
        DEDENT
        if start :
        INDENT
            print 'is start'
            print line
            if re.search('}', line) :
            INDENT
                start = False
                print 'false'
            DEDENT
        DEDENT
        else :
        INDENT

            nf.write(line)
            print 'writing'
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29113330_29114404_37_45
29113330_29114404_63_74
Title: How to fix the int error in a matching game using python? 
----------------------------------------

def __init__(self, pairs) :
INDENT
    self._pairs = pairs
    self._cards = []
    for cards in range(self._pairs) :
    INDENT
        c1 = Card(cards)
        self._cards.append(c1)
        c2 = Card(cards)
        self._cards.append(c2)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, rows, columns) :
INDENT
    self._deck = Deck((rows * columns) / / 2)
    self._rows = rows
    self._columns = columns
    self._board = []
    for row in range(self._rows) :
    INDENT
        self._board.append([0] * self._columns)
    DEDENT
    self.populateBoard()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29138412_29138613_4_15
29138412_29138817_1_11
Title: Memory Error with function calling large parameters 
----------------------------------------

def gibberish_sentence(seedBank, pairs) :
INDENT
    seed = random.choice(seedBank)
    gibSentence = StringIO()
    gibSentence.write(seed)
    gibSentence.write(' ')
    x = seed
    while (pairs.get(x) is not None) :
    INDENT
        y = random.choice(pairs.get(x))
        gibSentence.write(y)
        gibSentence.write(' ')
        x = y
    DEDENT
    return gibSentence.getvalue()
DEDENT
----------------------------------------

def gibberish_sentence(seedBank, pairs) :
INDENT
    gibSentence = []
    gibSentence.append(random.choice(seedBank))
    x = gibSentence [0]
    while (pairs.get(x) is not None) :
    INDENT
        y = random.choice(pairs.get(x))
        if y == '.' :
        INDENT
            break
        DEDENT
        gibSentence.append(y)
        x = y
    DEDENT
    return ' '.join(gibSentence)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
291740_27641636_1_14
291740_33151466_11_39
Title: How do I split a huge text file in python 
----------------------------------------

def splitfile(infilepath, chunksize) :
INDENT
    fname, ext = infilepath.rsplit('.', 1)
    i = 0
    written = False
    with open(infilepath) as infile :
    INDENT
        while True :
        INDENT
            outfilepath = "{}{}.{}".format(fname, i, ext)
            with open(outfilepath, 'w') as outfile :
            INDENT
                for line in (infile.readline() for _ in range(chunksize)) :
                INDENT
                    outfile.write(line)
                DEDENT
                written = bool(line)
            DEDENT
            if not written :
            INDENT
                break
            DEDENT
            i += 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def splitfile(filename, splitsize) :
INDENT
    if not os.path.isfile(filename) :
    INDENT
        print ("No such file as: \"%s\"" % filename)
        return
    DEDENT
    filesize = getfilesize(filename)
    with open(filename, "rb") as fr :
    INDENT
        counter = 1
        orginalfilename = filename.split(".")
        readlimit = 5000
        n_splits = filesize / / splitsize
        print ("splitfile: No of splits required: %s" % str(n_splits))
        for i in range(n_splits + 1) :
        INDENT
            chunks_count = int(splitsize) / / int(readlimit)
            data_5kb = fr.read(readlimit)
            print ("chunks_count: %d" % chunks_count)
            with open(orginalfilename [0] + "_{id}.".format(id = str(counter)) + orginalfilename [1], "ab") as fw :
            INDENT
                fw.seek(0)
                fw.truncate()
                while data_5kb :
                INDENT
                    fw.write(data_5kb)
                    if chunks_count :
                    INDENT
                        chunks_count -= 1
                        data_5kb = fr.read(readlimit)
                    DEDENT
                    else : break
                DEDENT
            DEDENT
            counter += 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29192592_29192693_16_31
29192592_29192768_1_12
Title: Resuming list reading and remembering the cursor 
----------------------------------------

def run() :
INDENT
    global flag
    global indx
    for i, j in enumerate(read(), 1) :
    INDENT
        if j == 2 :
        INDENT
            flag = False
            indx = i
        DEDENT
        print j
    DEDENT
    print "**********"
    flag = True
    for i in read(indx) :
    INDENT
        print i
    DEDENT
    print '********'
DEDENT
----------------------------------------

def run() :
INDENT
    iterator = read()
    for i in iterator :
    INDENT
        print i
        if i == 2 :
        INDENT
            break
        DEDENT
    DEDENT
    print 'flip'
    for i in iterator :
    INDENT
        print i
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29202851_29202951_3_16
29202851_29203059_3_14
Title: how would i write a recursive function to add all numbers in a deeply nested list of numbers and words 
----------------------------------------

def flat_sum(q) :
INDENT
    global total
    if not q :
    INDENT
        return
    DEDENT
    if isinstance(q, list) :
    INDENT
        if not isinstance(q [0], list) and not isinstance(q [0], str) :
        INDENT
            total += q [0]
        DEDENT
        else :
        INDENT
            flat_sum(q [0])
        DEDENT
        flat_sum(q [1 :])
    DEDENT
    else :
    INDENT
        if not isinstance(q, str) :
        INDENT
            total += q
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def flat_sum(lst) :
INDENT
    if len(lst) == 0 :
    INDENT
        return 0
    DEDENT
    hd, tl = lst [0], lst [1 :]
    if isinstance(hd, list) :
    INDENT
        return flat_sum(hd) + flat_sum(tl)
    DEDENT
    elif isinstance(hd, Number) :
    INDENT
        return hd + flat_sum(tl)
    DEDENT
    else :
    INDENT
        return flat_sum(tl)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29203767_29203801_17_23
29203767_29203843_17_27
Title: Getting the value of a variable from another function 
----------------------------------------

def askQuestion(a) :
INDENT
    guess = input("")
    if guess == a :
    INDENT
        print ("Correct")
    DEDENT
    else :
    INDENT
        print ("Wrong, the answer is ", a)
    DEDENT
DEDENT
----------------------------------------

def askQuestion(a) :
INDENT
    guess = input("")
    try :
    INDENT
        if int(guess) == a :
        INDENT
            print ("Correct")
        DEDENT
        else :
        INDENT
            print ("Wrong, the answer is ", a)
        DEDENT
    DEDENT
    except :
    INDENT
        print ('Did not input integer')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29203767_29203801_9_16
29203767_29203843_9_16
Title: Getting the value of a variable from another function 
----------------------------------------

def generateQuestion() :
INDENT
    x = random.randint(1, 10)
    y = random.randint(1, 10)
    op = random.choice(list(ops.keys()))
    a = ops.get(op)(x, y)
    print ("What is {} {} {}?\n".format(x, op, y))
    return a
DEDENT
----------------------------------------

def generateQuestion() :
INDENT
    x = random.randint(1, 10)
    y = random.randint(1, 10)
    op = random.choice(list(ops.keys()))
    a = ops.get(op)(x, y)
    print ("What is {} {} {}?\n".format(x, op, y))
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29203767_29203801_9_16
29203767_29203872_8_16
Title: Getting the value of a variable from another function 
----------------------------------------

def generateQuestion() :
INDENT
    x = random.randint(1, 10)
    y = random.randint(1, 10)
    op = random.choice(list(ops.keys()))
    a = ops.get(op)(x, y)
    print ("What is {} {} {}?\n".format(x, op, y))
    return a
DEDENT
----------------------------------------

def generateQuestion() :
INDENT
    x = random.randint(1, 10)
    y = random.randint(1, 10)
    op = random.choice(list(ops.keys()))
    global a
    a = ops.get(op)(x, y)
    print ("What is {} {} {}?\n".format(x, op, y))
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29203767_29203843_17_27
29203767_29203872_17_24
Title: Getting the value of a variable from another function 
----------------------------------------

def askQuestion(a) :
INDENT
    guess = input("")
    try :
    INDENT
        if int(guess) == a :
        INDENT
            print ("Correct")
        DEDENT
        else :
        INDENT
            print ("Wrong, the answer is ", a)
        DEDENT
    DEDENT
    except :
    INDENT
        print ('Did not input integer')
    DEDENT
DEDENT
----------------------------------------

def askQuestion() :
INDENT
    guess = input("")
    if guess == a :
    INDENT
        print ("Correct")
    DEDENT
    else :
    INDENT
        print ("Wrong, the answer is ", a)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29203767_29203843_9_16
29203767_29203872_8_16
Title: Getting the value of a variable from another function 
----------------------------------------

def generateQuestion() :
INDENT
    x = random.randint(1, 10)
    y = random.randint(1, 10)
    op = random.choice(list(ops.keys()))
    a = ops.get(op)(x, y)
    print ("What is {} {} {}?\n".format(x, op, y))
    return a
DEDENT
----------------------------------------

def generateQuestion() :
INDENT
    x = random.randint(1, 10)
    y = random.randint(1, 10)
    op = random.choice(list(ops.keys()))
    global a
    a = ops.get(op)(x, y)
    print ("What is {} {} {}?\n".format(x, op, y))
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29209350_29209533_28_55
29209350_29209535_34_38
Title: How Python threading Timer work internally? 
----------------------------------------

def run(self) :
INDENT
    self.new_task = False

    while True :
    INDENT

        next_fire, task = self.event_queue.get()

        sleep_for = int(next_fire - time.time())
        for _ in xrange(sleep_for) :
        INDENT
            time.sleep(1)
            if self.new_task :
            INDENT
                self.new_task = False
                self.event_queue.put((next_fire, task))
                continue
            DEDENT
        DEDENT
        task.fn()
        time.sleep(1)
        next_fire = task.get_next_fire_date()
        if next_fire :
        INDENT
            event_queue.put((next_fire, task))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    self.finished.wait(self.interval)
    if not self.finished.is_set() :
    INDENT
        self.function(* self.args, ** self.kwargs)
    DEDENT
    self.finished.set()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29249931_29328568_27_46
29249931_29328568_6_21
Title: Python Tkinter multiple frames with background image 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    logo = tk.PhotoImage(file = "/home/pi/Saffi.gif")
    BGlabel = tk.Label(self, image = logo)
    BGlabel.image = logo
    BGlabel.place(x = 0, y = 0, width = 592, height = 450)
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.place(x = 0, y = 0, width = 592, height = 44)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame(PageOne))
    button2 = tk.Button(self, text = "Go to Page two",
        command = lambda : controller.show_frame(PageTwo))
    button3 = tk.Button(self, text = "Exit",
        command = self.quit)
    button1.place(x = 100, y = 406, width = 200, height = 44)
    button2.place(x = 300, y = 406, width = 200, height = 44)
    button3.place(x = 500, y = 406, width = 80, height = 44)

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    self.attributes("-fullscreen", True)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29249931_29328568_48_65
29249931_29328568_6_21
Title: Python Tkinter multiple frames with background image 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    logo = tk.PhotoImage(file = "/home/pi/Saffi.gif")
    BGlabel = tk.Label(self, image = logo)
    BGlabel.image = logo
    BGlabel.place(x = 0, y = 0, width = 592, height = 450)
    label = tk.Label(self, text = "This is page one", font = TITLE_FONT)
    label.place(x = 0, y = 0, width = 592, height = 44)
    button1 = tk.Button(self, text = "Go to Start Page",
        command = lambda : controller.show_frame(StartPage))

    button3 = tk.Button(self, text = "Exit",
        command = self.quit)
    button1.place(x = 100, y = 406, width = 200, height = 44)
    button3.place(x = 300, y = 406, width = 200, height = 44)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    self.attributes("-fullscreen", True)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29249931_29328568_67_84
29249931_29328568_6_21
Title: Python Tkinter multiple frames with background image 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    logo = tk.PhotoImage(file = "/home/pi/Saffi.gif")
    BGlabel = tk.Label(self, image = logo)
    BGlabel.image = logo
    BGlabel.place(x = 0, y = 0, width = 592, height = 450)
    label = tk.Label(self, text = "This is page two", font = TITLE_FONT)
    label.place(x = 0, y = 0, width = 592, height = 44)
    button1 = tk.Button(self, text = "Go to Start Page",
        command = lambda : controller.show_frame(StartPage))

    button3 = tk.Button(self, text = "Exit",
        command = self.quit)
    button1.place(x = 100, y = 406, width = 200, height = 44)
    button3.place(x = 300, y = 406, width = 200, height = 44)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    self.attributes("-fullscreen", True)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29253832_29412950_126_135
29253832_29412950_92_116
Title: How to redraw only the updated data using Matplotlib 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Example", font = LARGE_FONT)
    label.grid(row = 0, column = 0, sticky = 'N')
    canvas = FigureCanvasTkAgg(fig, self)
    canvas.show()
    canvas.get_tk_widget().grid(row = 1, column = 0, rowspan = 6, columnspan = 3, sticky = 'NSEW')
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)

    self.frames = {}
    frame = GraphPage(container, self)
    self.frames [GraphPage] = frame
    frame.grid(row = 0, column = 0, sticky = "nsew")
    self.show_frame(GraphPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29269370_29280606_13_18
29269370_32067269_12_18
Title: How to properly create and run concurrent tasks using python's asyncio module? 
----------------------------------------

def say_baa() :
INDENT
    i = 0
    while True :
    INDENT
        print ('...baa {0}'.format(i))
        i += 1
    DEDENT
DEDENT
----------------------------------------

def say_baa() :
INDENT
    i = 0
    while True :
    INDENT
        yield
        print ("...baa {0}".format(i))
        i += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29269370_29280606_6_12
29269370_32067269_4_10
Title: How to properly create and run concurrent tasks using python's asyncio module? 
----------------------------------------

def say_boo() :
INDENT
    i = 0
    while True :
    INDENT
        print ('...boo {0}'.format(i))
        i += 1

    DEDENT
DEDENT
----------------------------------------

def say_boo() :
INDENT
    i = 0
    while True :
    INDENT
        yield None
        print ("...boo {0}".format(i))
        i += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29270061_29270425_7_21
29270061_29273019_7_15
Title: All paths of a tree 
----------------------------------------

def get_paths(t, paths = None, current_path = None) :
INDENT
    if paths is None :
    INDENT
        paths = []
    DEDENT
    if current_path is None :
    INDENT
        current_path = []
    DEDENT
    current_path.append(t.value)
    if len(t.children) == 0 :
    INDENT
        paths.append(current_path)
    DEDENT
    else :
    INDENT
        for child in t.children :
        INDENT
            get_paths(child, paths, list(current_path))
        DEDENT
    DEDENT
    return paths

DEDENT
----------------------------------------

def get_paths(t) :
INDENT
    if t.children :
    INDENT
        return tuple((t.value,) + path for child in t.children
            for path in get_paths(child))
    DEDENT
    else :
    INDENT
        return ((t.value,),)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29271274_29271332_1_25
29271274_29271610_3_16
Title: trouble appending lists to another list 
----------------------------------------

def twentyone(seq, groups = None, final = None, first_call = True) :
INDENT
    if not groups :
    INDENT
        groups = []
    DEDENT
    if first_call :
    INDENT
        final = []
    DEDENT
    goal = 21
    s = sum(groups)
    if s == goal :
    INDENT
        final.append(groups)
    DEDENT
    if s > = goal :
    INDENT
        return
    DEDENT
    for i in range(len(seq)) :
    INDENT
        n = seq [i]
        remaining = seq [i + 1 :]
        twentyone(remaining, groups + [n], final, False)
    DEDENT
    return final

DEDENT
----------------------------------------

def twentyone(seq, groups = []) :
INDENT
    goal = 21
    s = sum(groups)
    if s == goal :
    INDENT
        myfinal.final.append(groups)
    DEDENT
    if s > = goal :
    INDENT
        return
    DEDENT
    for i in range(len(seq)) :
    INDENT
        n = seq [i]
        remaining = seq [i + 1 :]
        twentyone(remaining, groups + [n])

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29277262_29279867_22_27
29277262_29279867_6_19
Title: "Classes objects and lists in python" 
----------------------------------------

def __init__(self) :
INDENT
    self.clan_list = []
    for i in range(random.randrange(3, 7)) :
    INDENT
        self.clan_list.append(Clan())

    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    r = random.randrange(20, 101)
    self.area = r
    s = random.randrange(1, 6)
    self.familySize = s
    Clan.counter += 1
    self.counter = Clan.counter

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29318358_29318721_12_30
29318358_29318821_1_27
Title: I have an array of strings; is there a way to see which one an argument string is closest to? 
----------------------------------------

def match(phrase) :
INDENT
    phr_list = phrase.split()
    max_count = 0
    key = None
    for k, v in phrases.iteritems() :
    INDENT
        count = sum(1 for word in phr_list if word.lower() in v.split())
        if count > max_count :
        INDENT
            count = max_count
            key = k
        DEDENT
    DEDENT
    if key :
    INDENT
        return phrases.get(key)
    DEDENT
    return phrase

DEDENT
----------------------------------------

def match(phrase) :
INDENT
    phrases = [
        "what time is it",
        "what's the weather",
        "what's the date",
        "hello",
        "hi",
        "what's up",
        "how are you"]

    match_word_dict = {}
    for element in phrases :
    INDENT
        sameness = 0
        for index in range(len(element)) :
        INDENT
            if len(phrase) == index :
            INDENT
                break
            DEDENT
            if phrase [index] == element [index] :
            INDENT
                sameness += 1

            DEDENT
        DEDENT
        percent = (sameness * 1.0 / len(element) * 1.0) * 100
        match_word_dict [element] = percent
    DEDENT
    return match_word_dict
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29326371_29326415_26_49
29326371_29327477_6_28
Title: Run a function only by the thread that is the first one to reach it's calling 
----------------------------------------

def askIP(self, ind) :
INDENT
    global guard
    guard = False
    print ("askIP start")
    IPgettingMethods = [
        ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],
        ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],
        ]
    for i in IPgettingMethods :
    INDENT
        th = Thread(target = self.getIP, args = (i,))
        th.start()

    DEDENT
    return False
DEDENT
----------------------------------------

def askIP(self, ind) :
INDENT
    print ("askIP start")
    IPgettingMethods = [
        ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],
        ["dig", "+short", "myip.opendns.com", "@resolver1.opendns.com"],
        ]
    def get_ip_controller() :
    INDENT
        with ThreadPoolExecutor(len(IPgettingMethods)) as executor :
        INDENT
            futures = [executor.submit(self.getIP, i) for i in IPgettingMethods]
            for future in as_completed(futures) :
            INDENT
                ip = future.result()
                if ip :
                INDENT
                    GLib.idle_add(self.setIndicatingMenus, ip, self.hIndicator)
                    break
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    Thread(target = get_ip_controller).start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29330283_29331230_13_19
29330283_29331246_1_10
Title: Modify context after using form 
----------------------------------------

def get_context_data(self, ** kwargs) :
INDENT
    context = super(AllView, self).get_context_data(** kwargs)
    if 'TagForm' not in context :
    INDENT
        context ['TagForm'] = TagForm()
    DEDENT
    context ['tag'] = self.object
    return context
DEDENT
----------------------------------------

def get_context_data(self, ** kwargs) :
INDENT
    context = super(AllView, self).get_context_data(** kwargs)
    if 'TagForm' not in context :
    INDENT
        context ['TagForm'] = TagForm()
    DEDENT
    tag_form = TagForm(self.request.GET)
    if tag_form.is_valid() :
    INDENT
        context ['tag'] = tag_form.cleaned_data.get('tag')
    DEDENT
    return context
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29332056_41655397_4_9
29332056_51704844_6_11
Title: Global error handler for any exception 
----------------------------------------

def handle_error(error) :
INDENT
    code = 500
    if isinstance(error, HTTPException) :
    INDENT
        code = error.code
    DEDENT
    return jsonify(error = 'error', code = code)
DEDENT
----------------------------------------

def handle_error(error) :
INDENT
    code = 500
    if isinstance(error, HTTPException) :
    INDENT
        code = error.code
    DEDENT
    return jsonify(error = 'error', code = code)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2936863_44170934_2_11
2936863_9951672_1_12
Title: Python: Implementing slicing in __getitem__ 
----------------------------------------

def __getitem__(self, given) :
INDENT
    if isinstance(given, slice) :
    INDENT
        print ("slice", given.start, given.stop, given.step)
    DEDENT
    elif isinstance(given, tuple) :
    INDENT
        print ("multidim", given)
    DEDENT
    else :
    INDENT
        print ("plain", given)
    DEDENT
DEDENT
----------------------------------------

def __getitem__(self, key) :
INDENT
    if isinstance(key, slice) :
    INDENT
        return [self [ii] for ii in xrange(* key.indices(len(self)))]
    DEDENT
    elif isinstance(key, int) :
    INDENT
        if key < 0 :
        INDENT
            key += len(self)
        DEDENT
        if key < 0 or key > = len(self) :
        INDENT
            raise IndexError, "The index (%d) is out of range." % key
        DEDENT
        return self.getData(key)
    DEDENT
    else :
    INDENT
        raise TypeError, "Invalid argument type."
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29372983_29374751_10_15
29372983_29374820_1_18
Title: How to write foldr (right fold) generator in Python? 
----------------------------------------

def foldr(function, iterable, initializer) :
INDENT
    it = iter(iterable)
    try :
    INDENT
        return function(next(it), Defer(foldr, function, it, initializer))
    DEDENT
    except StopIteration :
    INDENT
        return initializer
    DEDENT
DEDENT
----------------------------------------

def foldr(a, b, l) :
INDENT
    if isinstance(l, Iterator) :
    INDENT
        it = reversed(list(l))
    DEDENT
    else :
    INDENT
        it = reversed(l)
    DEDENT
    try :
    INDENT
        nxt = next(it)
    DEDENT
    except StopIteration :
    INDENT
        return
    DEDENT
    c = a(nxt, b)
    stop = object()
    while nxt is not stop :
    INDENT
        yield c
        nxt = next(it, stop)
        c = a(nxt, c) if nxt is not stop else c

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29377029_29377102_1_15
29377029_29377151_1_12
Title: Is there a way to “break” or “continue” within a Python function? 
----------------------------------------

def index() :
INDENT
    messages = []
    test1result = test1(request.form ['data'])
    if not test1result :
    INDENT
        message.append('Failed test 1')
    DEDENT
    test2result = test2(request.form ['data'])
    if not test2result :
    INDENT
        message.append('Failed test 2')
    DEDENT
    test3result = test3(request.form ['data'])
    if not test3result :
    INDENT
        message.append('Failed test 3')
    DEDENT
    return render_template('index.html', messages = messages)
DEDENT
----------------------------------------

def index() :
INDENT
    test1result = test1(request.form ['data'])
    test2result = test2(request.form ['data'])
    test3result = test3(request.form ['data'])
    if not test1result :
    INDENT
        message = 'Failed test 1'
    DEDENT
    elif not test2result :
    INDENT
        message = 'Failed test 2'
    DEDENT
    elif not test3result :
    INDENT
        message = 'Failed test 3'
    DEDENT
    return render_template('index.html', message = message)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29380700_29380724_3_12
29380700_29381329_1_8
Title: Write a program that reads a file with numbers separated by commas and print those numbers to the turtle screen 
----------------------------------------

def file() :
INDENT
    filename = "t.txt"
    openfile = open(filename, "r")
    readlines = openfile.readlines()
    nums = []
    for lines in readlines :
    INDENT
        nums.append(lines.strip().split(","))
    DEDENT
    return nums
DEDENT
----------------------------------------

def file() :
INDENT
    with open('test.txt', 'r') as data :
    INDENT
        nums = []
        for lines in data.readlines() :
        INDENT
            nums.append(lines.strip().split(","))
        DEDENT
    DEDENT
    return nums
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29392223_29440459_111_118
29392223_29440459_150_175
Title: PyQt Node interface - Parrent to ItemIsMovable object 
----------------------------------------

def __init__(self, pnode, posX, posY) :
INDENT
    self.parentNode = pnode
    self.x = posX
    self.y = posY
    self.color = 1
    QtGui.QGraphicsRectItem.__init__(self, self.x - self.width, self.y, self.width, self.height, self.parentNode)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMainWindow.__init__(self)
    self.setWindowTitle('RIS RIB Generator')
    self.scene = Scene(0, 0, 800, 850, self)
    self.view = QtGui.QGraphicsView()
    self.setCentralWidget(self.view)
    self.view.setScene(self.scene)

    exitAction = QtGui.QAction(QtGui.QIcon('exit24.png'), 'Exit', self)
    exitAction.setShortcut('Ctrl+Q')
    exitAction.setStatusTip('Exit application')
    exitAction.triggered.connect(self.close)
    newNodeAction = QtGui.QAction(QtGui.QIcon('exit24.png'), 'New Node', self)
    newNodeAction.setStatusTip('Add a blank node')
    newNodeAction.triggered.connect(self.scene.addNode)

    self.statusBar()
    menubar = self.menuBar()
    fileMenu = menubar.addMenu('&File')
    fileMenu.addAction(newNodeAction)
    fileMenu.addAction(exitAction)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29392223_29440459_111_118
29392223_29440459_33_42
Title: PyQt Node interface - Parrent to ItemIsMovable object 
----------------------------------------

def __init__(self, pnode, posX, posY) :
INDENT
    self.parentNode = pnode
    self.x = posX
    self.y = posY
    self.color = 1
    QtGui.QGraphicsRectItem.__init__(self, self.x - self.width, self.y, self.width, self.height, self.parentNode)

DEDENT
----------------------------------------

def __init__(self, n_x, n_y, n_width, n_height) :
INDENT
    QtGui.QGraphicsRectItem.__init__(self, n_x, n_y, n_width, n_height)
    self.width = n_width
    self.height = n_height
    self.x = n_x
    self.y = n_y
    self.setFlag(QtGui.QGraphicsItem.ItemIsMovable, True)
    self.setFlag(QtGui.QGraphicsItem.ItemIsSelectable, True)
    self.iniNodeData()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29392223_29440459_111_118
29392223_29440459_92_100
Title: PyQt Node interface - Parrent to ItemIsMovable object 
----------------------------------------

def __init__(self, pnode, posX, posY) :
INDENT
    self.parentNode = pnode
    self.x = posX
    self.y = posY
    self.color = 1
    QtGui.QGraphicsRectItem.__init__(self, self.x - self.width, self.y, self.width, self.height, self.parentNode)

DEDENT
----------------------------------------

def __init__(self, pnode, posX, posY) :
INDENT
    self.parentNode = pnode
    self.x = posX
    self.y = posY
    self.color = 1
    QtGui.QGraphicsRectItem.__init__(self, self.x + self.parentNode.x, self.y + self.parentNode.y, self.width, self.height, self.parentNode)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29392223_29440459_150_175
29392223_29440459_33_42
Title: PyQt Node interface - Parrent to ItemIsMovable object 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMainWindow.__init__(self)
    self.setWindowTitle('RIS RIB Generator')
    self.scene = Scene(0, 0, 800, 850, self)
    self.view = QtGui.QGraphicsView()
    self.setCentralWidget(self.view)
    self.view.setScene(self.scene)

    exitAction = QtGui.QAction(QtGui.QIcon('exit24.png'), 'Exit', self)
    exitAction.setShortcut('Ctrl+Q')
    exitAction.setStatusTip('Exit application')
    exitAction.triggered.connect(self.close)
    newNodeAction = QtGui.QAction(QtGui.QIcon('exit24.png'), 'New Node', self)
    newNodeAction.setStatusTip('Add a blank node')
    newNodeAction.triggered.connect(self.scene.addNode)

    self.statusBar()
    menubar = self.menuBar()
    fileMenu = menubar.addMenu('&File')
    fileMenu.addAction(newNodeAction)
    fileMenu.addAction(exitAction)

DEDENT
----------------------------------------

def __init__(self, n_x, n_y, n_width, n_height) :
INDENT
    QtGui.QGraphicsRectItem.__init__(self, n_x, n_y, n_width, n_height)
    self.width = n_width
    self.height = n_height
    self.x = n_x
    self.y = n_y
    self.setFlag(QtGui.QGraphicsItem.ItemIsMovable, True)
    self.setFlag(QtGui.QGraphicsItem.ItemIsSelectable, True)
    self.iniNodeData()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29392223_29440459_150_175
29392223_29440459_92_100
Title: PyQt Node interface - Parrent to ItemIsMovable object 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMainWindow.__init__(self)
    self.setWindowTitle('RIS RIB Generator')
    self.scene = Scene(0, 0, 800, 850, self)
    self.view = QtGui.QGraphicsView()
    self.setCentralWidget(self.view)
    self.view.setScene(self.scene)

    exitAction = QtGui.QAction(QtGui.QIcon('exit24.png'), 'Exit', self)
    exitAction.setShortcut('Ctrl+Q')
    exitAction.setStatusTip('Exit application')
    exitAction.triggered.connect(self.close)
    newNodeAction = QtGui.QAction(QtGui.QIcon('exit24.png'), 'New Node', self)
    newNodeAction.setStatusTip('Add a blank node')
    newNodeAction.triggered.connect(self.scene.addNode)

    self.statusBar()
    menubar = self.menuBar()
    fileMenu = menubar.addMenu('&File')
    fileMenu.addAction(newNodeAction)
    fileMenu.addAction(exitAction)

DEDENT
----------------------------------------

def __init__(self, pnode, posX, posY) :
INDENT
    self.parentNode = pnode
    self.x = posX
    self.y = posY
    self.color = 1
    QtGui.QGraphicsRectItem.__init__(self, self.x + self.parentNode.x, self.y + self.parentNode.y, self.width, self.height, self.parentNode)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29392223_29440459_33_42
29392223_29440459_92_100
Title: PyQt Node interface - Parrent to ItemIsMovable object 
----------------------------------------

def __init__(self, n_x, n_y, n_width, n_height) :
INDENT
    QtGui.QGraphicsRectItem.__init__(self, n_x, n_y, n_width, n_height)
    self.width = n_width
    self.height = n_height
    self.x = n_x
    self.y = n_y
    self.setFlag(QtGui.QGraphicsItem.ItemIsMovable, True)
    self.setFlag(QtGui.QGraphicsItem.ItemIsSelectable, True)
    self.iniNodeData()
DEDENT
----------------------------------------

def __init__(self, pnode, posX, posY) :
INDENT
    self.parentNode = pnode
    self.x = posX
    self.y = posY
    self.color = 1
    QtGui.QGraphicsRectItem.__init__(self, self.x + self.parentNode.x, self.y + self.parentNode.y, self.width, self.height, self.parentNode)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_102_113
29446301_29476762_16_27
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.pack()
    parent.title("Creacio de fitxer comprimit")
    lp = LeftPanel(self)
    lp.pack(side = LEFT)
    rp = RightPanel(self)
    rp.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    b = Button(self, text = 'Escollir directori treball', command = curdir)
    b.pack(side = LEFT)
    v = StringVar()
    v.set("/home")
    e = Entry(self, width = 35, textvariable = v)
    e.pack(side = LEFT)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_102_113
29446301_29476762_29_41
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.pack()
    parent.title("Creacio de fitxer comprimit")
    lp = LeftPanel(self)
    lp.pack(side = LEFT)
    rp = RightPanel(self)
    rp.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    l = Label(self, text = "Llista:")
    l.pack(side = LEFT)
    br = Button(self, text = 'Reomplir')
    br.pack(side = LEFT)
    bo = Button(self, text = 'Ocultar no seleccionats')
    bo.pack(side = LEFT)
    bos = Button(self, text = 'Ocultar seleccionats')
    bos.pack(side = LEFT)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_102_113
29446301_29476762_53_65
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.pack()
    parent.title("Creacio de fitxer comprimit")
    lp = LeftPanel(self)
    lp.pack(side = LEFT)
    rp = RightPanel(self)
    rp.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.scrollbar = Scrollbar(self)
    self.scrollbar.pack(side = RIGHT, fill = Y)
    self.listbox = Listbox(self, bd = 0,
        yscrollcommand = self.scrollbar.set,
        width = 55)
    self.listbox.pack(side = RIGHT)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_102_113
29446301_29476762_67_75
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.pack()
    parent.title("Creacio de fitxer comprimit")
    lp = LeftPanel(self)
    lp.pack(side = LEFT)
    rp = RightPanel(self)
    rp.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    EscollirDireccion(self).pack()
    Llista(self).pack()
    ListBoxWithScrollbar(self).pack()
    SortirButtonBox(self).pack(fill = X)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_102_113
29446301_29476762_77_90
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.pack()
    parent.title("Creacio de fitxer comprimit")
    lp = LeftPanel(self)
    lp.pack(side = LEFT)
    rp = RightPanel(self)
    rp.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    widgets = [(Label(self, text = "Tots"), None),
        (Button(self, text = "><![CDATA[>>"), None),
        (Label(self, text = "Als seleccionats"), None),
        (Button(self, text = "->"), None),
        (Button(self, text = "<-"), None),
        (Label(self, text = "Tots"), None),
        (Button(self, text = "<<<"), None)]
    widgets.reverse()
    for wdg in widgets :
    INDENT
        wdg [0].pack(side = BOTTOM);
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_16_27
29446301_29476762_29_41
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    b = Button(self, text = 'Escollir directori treball', command = curdir)
    b.pack(side = LEFT)
    v = StringVar()
    v.set("/home")
    e = Entry(self, width = 35, textvariable = v)
    e.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    l = Label(self, text = "Llista:")
    l.pack(side = LEFT)
    br = Button(self, text = 'Reomplir')
    br.pack(side = LEFT)
    bo = Button(self, text = 'Ocultar no seleccionats')
    bo.pack(side = LEFT)
    bos = Button(self, text = 'Ocultar seleccionats')
    bos.pack(side = LEFT)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_16_27
29446301_29476762_53_65
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    b = Button(self, text = 'Escollir directori treball', command = curdir)
    b.pack(side = LEFT)
    v = StringVar()
    v.set("/home")
    e = Entry(self, width = 35, textvariable = v)
    e.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.scrollbar = Scrollbar(self)
    self.scrollbar.pack(side = RIGHT, fill = Y)
    self.listbox = Listbox(self, bd = 0,
        yscrollcommand = self.scrollbar.set,
        width = 55)
    self.listbox.pack(side = RIGHT)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_16_27
29446301_29476762_67_75
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    b = Button(self, text = 'Escollir directori treball', command = curdir)
    b.pack(side = LEFT)
    v = StringVar()
    v.set("/home")
    e = Entry(self, width = 35, textvariable = v)
    e.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    EscollirDireccion(self).pack()
    Llista(self).pack()
    ListBoxWithScrollbar(self).pack()
    SortirButtonBox(self).pack(fill = X)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_16_27
29446301_29476762_77_90
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    b = Button(self, text = 'Escollir directori treball', command = curdir)
    b.pack(side = LEFT)
    v = StringVar()
    v.set("/home")
    e = Entry(self, width = 35, textvariable = v)
    e.pack(side = LEFT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    widgets = [(Label(self, text = "Tots"), None),
        (Button(self, text = "><![CDATA[>>"), None),
        (Label(self, text = "Als seleccionats"), None),
        (Button(self, text = "->"), None),
        (Button(self, text = "<-"), None),
        (Label(self, text = "Tots"), None),
        (Button(self, text = "<<<"), None)]
    widgets.reverse()
    for wdg in widgets :
    INDENT
        wdg [0].pack(side = BOTTOM);
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_29_41
29446301_29476762_53_65
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    l = Label(self, text = "Llista:")
    l.pack(side = LEFT)
    br = Button(self, text = 'Reomplir')
    br.pack(side = LEFT)
    bo = Button(self, text = 'Ocultar no seleccionats')
    bo.pack(side = LEFT)
    bos = Button(self, text = 'Ocultar seleccionats')
    bos.pack(side = LEFT)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.scrollbar = Scrollbar(self)
    self.scrollbar.pack(side = RIGHT, fill = Y)
    self.listbox = Listbox(self, bd = 0,
        yscrollcommand = self.scrollbar.set,
        width = 55)
    self.listbox.pack(side = RIGHT)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_29_41
29446301_29476762_67_75
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    l = Label(self, text = "Llista:")
    l.pack(side = LEFT)
    br = Button(self, text = 'Reomplir')
    br.pack(side = LEFT)
    bo = Button(self, text = 'Ocultar no seleccionats')
    bo.pack(side = LEFT)
    bos = Button(self, text = 'Ocultar seleccionats')
    bos.pack(side = LEFT)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    EscollirDireccion(self).pack()
    Llista(self).pack()
    ListBoxWithScrollbar(self).pack()
    SortirButtonBox(self).pack(fill = X)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_29_41
29446301_29476762_77_90
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    l = Label(self, text = "Llista:")
    l.pack(side = LEFT)
    br = Button(self, text = 'Reomplir')
    br.pack(side = LEFT)
    bo = Button(self, text = 'Ocultar no seleccionats')
    bo.pack(side = LEFT)
    bos = Button(self, text = 'Ocultar seleccionats')
    bos.pack(side = LEFT)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    widgets = [(Label(self, text = "Tots"), None),
        (Button(self, text = "><![CDATA[>>"), None),
        (Label(self, text = "Als seleccionats"), None),
        (Button(self, text = "->"), None),
        (Button(self, text = "<-"), None),
        (Label(self, text = "Tots"), None),
        (Button(self, text = "<<<"), None)]
    widgets.reverse()
    for wdg in widgets :
    INDENT
        wdg [0].pack(side = BOTTOM);
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_53_65
29446301_29476762_67_75
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.scrollbar = Scrollbar(self)
    self.scrollbar.pack(side = RIGHT, fill = Y)
    self.listbox = Listbox(self, bd = 0,
        yscrollcommand = self.scrollbar.set,
        width = 55)
    self.listbox.pack(side = RIGHT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    EscollirDireccion(self).pack()
    Llista(self).pack()
    ListBoxWithScrollbar(self).pack()
    SortirButtonBox(self).pack(fill = X)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_53_65
29446301_29476762_77_90
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.scrollbar = Scrollbar(self)
    self.scrollbar.pack(side = RIGHT, fill = Y)
    self.listbox = Listbox(self, bd = 0,
        yscrollcommand = self.scrollbar.set,
        width = 55)
    self.listbox.pack(side = RIGHT)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    widgets = [(Label(self, text = "Tots"), None),
        (Button(self, text = "><![CDATA[>>"), None),
        (Label(self, text = "Als seleccionats"), None),
        (Button(self, text = "->"), None),
        (Button(self, text = "<-"), None),
        (Label(self, text = "Tots"), None),
        (Button(self, text = "<<<"), None)]
    widgets.reverse()
    for wdg in widgets :
    INDENT
        wdg [0].pack(side = BOTTOM);
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29446301_29476762_67_75
29446301_29476762_77_90
Title: Tkinter Scrollbar taking more space than expected 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    EscollirDireccion(self).pack()
    Llista(self).pack()
    ListBoxWithScrollbar(self).pack()
    SortirButtonBox(self).pack(fill = X)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    widgets = [(Label(self, text = "Tots"), None),
        (Button(self, text = "><![CDATA[>>"), None),
        (Label(self, text = "Als seleccionats"), None),
        (Button(self, text = "->"), None),
        (Button(self, text = "<-"), None),
        (Label(self, text = "Tots"), None),
        (Button(self, text = "<<<"), None)]
    widgets.reverse()
    for wdg in widgets :
    INDENT
        wdg [0].pack(side = BOTTOM);
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29457630_29471913_1_10
29457630_47029164_15_21
Title: Extend user model Django REST framework 3.x.x 
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    user_data = validated_data.pop('user', None)
    for attr, value in user_data.items() :
    INDENT
        setattr(instance.user, attr, value)
    DEDENT
    for attr, value in validated_data.items() :
    INDENT
        setattr(instance, attr, value)
    DEDENT
    instance.save()
    return instance
DEDENT
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    user_data = validated_data.pop('user', {})
    user_serializer = UserSerializer(instance.user, data = user_data, partial = True)
    user_serializer.is_valid(raise_exception = True)
    user_serializer.update(instance.user, user_data)
    super(ProfileSerializer, self).update(instance, validated_data)
    return instance
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29459188_29462307_13_18
29459188_29463146_1_16
Title: Scraping Data from a table with Scrapy 
----------------------------------------

def parse(self, response) :
INDENT
    for h3 in response.xpath('//h3').extract() :
    INDENT
        yield MyItem(title = h3)
    DEDENT
    for url in response.xpath('//a/@href').extract() :
    INDENT
        yield scrapy.Request(url, callback = self.parse)
    DEDENT
DEDENT
----------------------------------------

def parse(self, response) :
INDENT
    sites = response.xpath('//*[@id="ctl00_ContentPlaceHolder1_divData"]/table[3]/tr') [1 : - 2]
    for site in sites :
    INDENT
        item = Digi()
        item ['sl'] = site.xpath('td[1]/text()').extract()
        item ['player_name'] = site.xpath('td[2]/a/text()').extract()
        item ['dismissal_info'] = site.xpath('td[3]/text()').extract()
        item ['bowler_name'] = site.xpath('td[4]/text()').extract()
        item ['runs_scored'] = site.xpath('td[5]/b/text()').extract()
        item ['balls_faced'] = site.xpath('td[6]/text()').extract()
        item ['minutes_played'] = site.xpath('td[7]/text()').extract()
        item ['fours'] = site.xpath('td[8]/text()').extract()
        item ['sixes'] = site.xpath('td[9]/text()').extract()
        item ['strike_rate'] = site.xpath('td[10]/text()').extract()
        yield item
    DEDENT
DEDENT
----------------------------------------
