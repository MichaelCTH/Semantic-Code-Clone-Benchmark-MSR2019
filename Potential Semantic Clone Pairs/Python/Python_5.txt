$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14585597_14586447_16_21
14585597_14586659_14_21
Title: Learning about Queue module in python (how to run it) 
----------------------------------------

def worker() :
INDENT
    while True :
    INDENT
        item = q.get()
        do_work(item)
        q.task_done()
    DEDENT
DEDENT
----------------------------------------

def worker() :
INDENT
    while True :
    INDENT

        item = q_in.get()
        q_out.put(do_work(item))
        q_in.task_done()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14585597_14586447_23_33
14585597_14586659_34_55
Title: Learning about Queue module in python (how to run it) 
----------------------------------------

def main() :
INDENT
    for i in range(2) :
    INDENT
        t = Thread(target = worker)
        t.daemon = True
        t.start()
    DEDENT
    for item in source() :
    INDENT
        q.put(item)
    DEDENT
    q.join()
DEDENT
----------------------------------------

def main() :
INDENT
    for i in range(num_worker_threads) :
    INDENT
        t = threading.Thread(target = worker)
        t.daemon = True
        t.start()

    DEDENT
    t = threading.Thread(target = printer)
    t.daemon = True
    t.start()

    for item in range(10) :
    INDENT
        q_in.put(item)

    DEDENT
    q_in.join()
    q_out.join()
    print ("Processing Complete")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14592010_14592131_3_15
14592010_14592373_1_20
Title: nesting a string and printing deepest nest 
----------------------------------------

def is_nested(str) :
INDENT
    stack = []
    deepest = []
    for c in str :
    INDENT
        if c in OPEN :
        INDENT
            stack.append(c)
            if len(stack) > len(deepest) :
            INDENT
                deepest.append(c)
            DEDENT
        DEDENT
        elif c in CLOSED :
        INDENT
            x = stack.pop()
            if OPEN.index(x) ! = CLOSED.index(c) :
            INDENT
                return "Error"
            DEDENT
        DEDENT
    DEDENT
    return ''.join(deepest)
DEDENT
----------------------------------------

def is_nested(nested_str) :
INDENT
    opening = ['(', '{', '[', '<']
    closing = {'(' : ')', '{' : '}', '[' : ']', '<' : '>'}
    braces = []
    depth = 0
    max_depth = 0
    max_depth_index = None
    for index, char in enumerate(nested_str) :
    INDENT
        if char in opening :
        INDENT
            braces.append(char)
            depth += 1
        DEDENT
        elif char == closing [braces [- 1]] :
        INDENT
            braces.pop()
            depth -= 1
        DEDENT
        else :
        INDENT
            raise ValueError("This is not a valid str")
        DEDENT
        if depth > max_depth :
        INDENT
            max_depth = depth
            max_depth_index = index
        DEDENT
    DEDENT
    return max_depth, max_depth_index
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14592010_14592131_3_15
14592010_14592381_1_23
Title: nesting a string and printing deepest nest 
----------------------------------------

def is_nested(str) :
INDENT
    stack = []
    deepest = []
    for c in str :
    INDENT
        if c in OPEN :
        INDENT
            stack.append(c)
            if len(stack) > len(deepest) :
            INDENT
                deepest.append(c)
            DEDENT
        DEDENT
        elif c in CLOSED :
        INDENT
            x = stack.pop()
            if OPEN.index(x) ! = CLOSED.index(c) :
            INDENT
                return "Error"
            DEDENT
        DEDENT
    DEDENT
    return ''.join(deepest)
DEDENT
----------------------------------------

def is_nested(in_str) :
INDENT
    stack = []
    deepest = tuple()
    open_b = ('(', '[', '{', '<')
    close_b = (')', ']', '}', '>')
    for i in in_str :
    INDENT
        print stack, i
        if i in open_b :
        INDENT
            stack.append(i)
            if len(stack) > len(deepest) :
            INDENT
                deepest = tuple(stack)
            DEDENT
        DEDENT
        else :
        INDENT
            p = stack.pop()
            print p
            print open_b.index(p)
            print close_b [open_b.index(p)]
            if i ! = close_b [open_b.index(p)] :
            INDENT
                raise Exception('Wrongly nested')
            DEDENT
        DEDENT
    DEDENT
    if len(stack) > 0 :
    INDENT
        raise Exception('Wrongly nested')
    DEDENT
    return deepest
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14592010_14592373_1_20
14592010_14592381_1_23
Title: nesting a string and printing deepest nest 
----------------------------------------

def is_nested(nested_str) :
INDENT
    opening = ['(', '{', '[', '<']
    closing = {'(' : ')', '{' : '}', '[' : ']', '<' : '>'}
    braces = []
    depth = 0
    max_depth = 0
    max_depth_index = None
    for index, char in enumerate(nested_str) :
    INDENT
        if char in opening :
        INDENT
            braces.append(char)
            depth += 1
        DEDENT
        elif char == closing [braces [- 1]] :
        INDENT
            braces.pop()
            depth -= 1
        DEDENT
        else :
        INDENT
            raise ValueError("This is not a valid str")
        DEDENT
        if depth > max_depth :
        INDENT
            max_depth = depth
            max_depth_index = index
        DEDENT
    DEDENT
    return max_depth, max_depth_index
DEDENT
----------------------------------------

def is_nested(in_str) :
INDENT
    stack = []
    deepest = tuple()
    open_b = ('(', '[', '{', '<')
    close_b = (')', ']', '}', '>')
    for i in in_str :
    INDENT
        print stack, i
        if i in open_b :
        INDENT
            stack.append(i)
            if len(stack) > len(deepest) :
            INDENT
                deepest = tuple(stack)
            DEDENT
        DEDENT
        else :
        INDENT
            p = stack.pop()
            print p
            print open_b.index(p)
            print close_b [open_b.index(p)]
            if i ! = close_b [open_b.index(p)] :
            INDENT
                raise Exception('Wrongly nested')
            DEDENT
        DEDENT
    DEDENT
    if len(stack) > 0 :
    INDENT
        raise Exception('Wrongly nested')
    DEDENT
    return deepest
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14610228_14612069_17_66
14610228_14612069_87_143
Title: wxPython Button to load multiple images 
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, 'Window', size = (1000, 700))
    panel = wx.Panel(self, - 1)
    self.SetBackgroundColour(wx.Colour(100, 100, 100))
    self.Centre()
    self.Show()
    status = self.CreateStatusBar()
    menubar = wx.MenuBar()
    filemenu = wx.Menu()
    exitmenu = filemenu.Append(wx.NewId(), "Exit", "Exit Program")
    menubar.Append(filemenu, "File")
    self.Bind(wx.EVT_MENU, self.onExit, exitmenu)
    self.SetMenuBar(menubar)
    font1 = wx.Font(
        30, wx.MODERN, wx.NORMAL, wx.NORMAL, False, u'Consolas')
    Text1 = wx.StaticText(panel, - 1, "Rhythm Trainer", (10, 15))
    Text1.SetFont(font1)
    Text1.SetForegroundColour('white')
    btn1 = wx.Button(panel, label = 'Basic', pos = (100, 200), size = (150, 50))
    btn1.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    self.Bind(wx.EVT_BUTTON, self.newwindow, btn1)
    btn2 = wx.Button(
        panel, label = 'Advanced', pos = (100, 270), size = (150, 50))
    btn2.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    btn3 = wx.Button(
        panel, label = 'Notations', pos = (100, 340), size = (150, 50))
    btn3.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    btn4 = wx.Button(
        panel, label = 'Settings', pos = (100, 410), size = (150, 50))
    btn4.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    btn5 = wx.Button(panel, label = "Quit", pos = (820, 550), size = (150, 50))
    btn5.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    self.Bind(wx.EVT_BUTTON, self.OnClick, btn5)
DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, 'Window2', size = (1000, 700))
    panel = wx.Panel(self, - 1)
    self.SetBackgroundColour(wx.Colour(100, 100, 100))
    self.Centre()
    self.Show()
    status = self.CreateStatusBar()
    menubar = wx.MenuBar()
    filemenu = wx.Menu()
    exitmenu = filemenu.Append(wx.NewId(), "Exit", "Exit Program")
    menubar.Append(filemenu, "File")
    self.Bind(wx.EVT_MENU, self.onExit, exitmenu)
    self.SetMenuBar(menubar)
    font2 = wx.Font(
        30, wx.MODERN, wx.NORMAL, wx.NORMAL, False, u'Consolas')
    Text2 = wx.StaticText(panel, - 1, "Rhythm Trainer", (10, 15))
    Text2.SetFont(font2)
    Text2.SetForegroundColour('white')
    self.Show(True)
    btn1 = wx.Button(panel, label = "Back", pos = (820, 550), size = (150, 50))
    btn1.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    self.Bind(wx.EVT_BUTTON, self.OnClick, btn1)
    btn2 = wx.Button(panel, label = "Play", pos = (820, 100), size = (150, 50))
    btn2.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    self.Bind(wx.EVT_BUTTON, self.onPlaySound, btn2)
    btn3 = wx.Button(panel, label = "Stop", pos = (820, 150), size = (150, 50))
    btn3.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    self.Bind(wx.EVT_BUTTON, self.onStopSound, btn3)
    btn4 = wx.Button(panel, label = "Next", pos = (820, 200), size = (150, 50))
    btn4.SetFont(
        wx.Font(14, wx.DEFAULT, wx.NORMAL, wx.NORMAL, 0, u'Consolas'))
    self.Bind(wx.EVT_BUTTON, self.loadImage, btn4)
    self.panel = wx.Panel(self, - 1, pos = (50, 50), size = (800, 200))
    self.images = IT.cycle(
        [filename for filename in os.listdir(IMAGE_DIR)
            if any(filename.lower().endswith(ext) for ext in ('.png', '.jpg', '.jpeg'))])
    self.image_file = next(self.images)
    img = wx.EmptyImage(240, 240)
    self.imageCtrl = wx.StaticBitmap(self.panel, wx.ID_ANY,
        wx.BitmapFromImage(img), pos = (200, 50))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14610988_14680881_40_49
14610988_14680881_62_95
Title: pyqt: dynamically update properties for dynamically created widgets 
----------------------------------------

def __init__(self, referrer = None, value = 1) :
INDENT
    self.referrer = referrer
    self.value = ObservableVariable(value)
    self._initial_value = value
    if referrer :
    INDENT

        referrer.value.changed.connect(
            lambda x : self.value.changed.emit(self.value.value))
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(GuiExample, self).__init__()
    self.values = []
    layout = QtGui.QVBoxLayout(self)
    obj = None
    for i in range(5) :
    INDENT
        obj = MyClass(obj, i)
        self.values.append(obj)
        hlayout = QtGui.QHBoxLayout()
        spinbox = QtGui.QSpinBox()
        spinbox.setValue(obj.value.value)
        start_label = QtGui.QLabel()
        end_label = QtGui.QLabel()
        hlayout.addWidget(start_label)
        hlayout.addWidget(spinbox)
        hlayout.addWidget(end_label)
        layout.addLayout(hlayout)

        def update_start_end(instance, start_label, end_label) :
        INDENT
            start_label.setText(str(instance.start))
            end_label.setText(str(instance.end))
        DEDENT
        action = functools.partial(update_start_end, obj, start_label,
            end_label)
        action()
        obj.value.changed.connect(action)
        spinbox.valueChanged.connect(obj.value.set_value)
        obj.value.changed.connect(spinbox.setValue)
    DEDENT
    layout.addWidget(QtGui.QPushButton('test',
            clicked = self.test_modification))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14611931_14612608_16_26
14611931_14612608_8_13
Title: Few slot connection in cycle 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(CheckComboGroup, self).__init__(parent)
    self.checkBox = QCheckBox()
    self.checkBox.clicked.connect(self.handleComboBox)
    self.comboBox = QComboBox()
    self.addWidget(self.checkBox)
    self.addWidget(self.comboBox)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Main, self).__init__()
    layout = QVBoxLayout(self)
    for x in xrange(3) :
    INDENT
        layout.addLayout(CheckComboGroup())
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14614964_14666739_7_50
14614964_14666739_89_137
Title: Wxpython Listctrl 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "List Control Tutorial", size = (700, 400))

    panel = wx.Panel(self, wx.ID_ANY)
    self.index = 0
    self.list_ctrl = wx.ListCtrl(panel, size = (- 1, 200),
        style = wx.LC_REPORT
        | wx.BORDER_SUNKEN)
    self.list_ctrl.InsertColumn(0, 'Machine Name')
    self.list_ctrl.InsertColumn(1, 'Sim Port')
    self.list_ctrl.InsertColumn(2, 'Sim Script', width = 125)
    self.list_ctrl.InsertColumn(3, 'Status', width = 150)
    self.list_ctrl.InsertColumn(4, 'Status Detail', width = 300)
    btn = wx.Button(panel, label = "Add Line")
    btn.Bind(wx.EVT_BUTTON, self.add_line)
    btn2 = wx.Button(panel, label = "Add Script")
    btn2.Bind(wx.EVT_BUTTON, self.add_script)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.list_ctrl, 0, wx.ALL | wx.EXPAND, 5)
    sizer.Add(btn, 0, wx.ALL | wx.CENTER, 5)
    sizer.Add(btn2, 0, wx.ALL | wx.CENTER, 5)
    panel.SetSizer(sizer)
    menu = wx.Menu()

    menuBar = wx.MenuBar()
    self.SetMenuBar(menuBar)
    self.popupmenu = wx.Menu()
    for text in "Start Stop Remove".split() :
    INDENT
        item = self.popupmenu.Append(- 1, text)
        self.Bind(wx.EVT_MENU, self.OnPopupItemSelected, item)
        self.list_ctrl.Bind(wx.EVT_CONTEXT_MENU, self.ShowPopUp)

    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, 'New Window', size = (400, 300))
    self.parent = parent
    wx.Frame.CenterOnScreen(self)
    panel = wx.Panel(self)
    sizer = wx.GridBagSizer(5, 5)
    text1 = wx.StaticText(panel, label = "Machine")
    sizer.Add(text1, pos = (2, 0), flag = wx.LEFT, border = 10)
    comboBox1Choices = [u"LDR2", u"AT02"]
    self.comboBox1 = wx.ComboBox(panel, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, comboBox1Choices, 0)
    sizer.Add(self.comboBox1, pos = (2, 1), span = (1, 3), flag = wx.TOP | wx.EXPAND)
    text2 = wx.StaticText(panel, label = "Sim Port")
    sizer.Add(text2, pos = (3, 0), flag = wx.LEFT | wx.TOP, border = 10)
    comboBox2Choices = [u"22000", u"23000"]
    self.comboBox2 = wx.ComboBox(panel, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, comboBox2Choices, 0)
    sizer.Add(self.comboBox2, pos = (3, 1), span = (1, 3), flag = wx.TOP | wx.EXPAND)
    text3 = wx.StaticText(panel, label = "Sim Scripts")
    sizer.Add(text3, pos = (4, 0), flag = wx.TOP | wx.LEFT, border = 10)
    comboBox3Choices = [u"LF12-Ldr", u"LF1-Trk", u"CN1-Trk"]
    self.comboBox3 = wx.ComboBox(panel, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, comboBox3Choices, 0)
    sizer.Add(self.comboBox3, pos = (4, 1), span = (1, 3), flag = wx.TOP | wx.EXPAND)
    text4 = wx.StaticText(panel, label = "Status")
    sizer.Add(text4, pos = (5, 0), flag = wx.TOP | wx.LEFT, border = 10)
    comboBox4Choices = [u"Not Started", u"Running"]
    self.comboBox4 = wx.ComboBox(panel, wx.ID_ANY, u"", wx.DefaultPosition, wx.DefaultSize, comboBox4Choices, 0)
    sizer.Add(self.comboBox4, pos = (5, 1), span = (1, 3), flag = wx.TOP | wx.EXPAND)
    self.button4 = wx.Button(panel, label = "Update and Close")
    sizer.Add(self.button4, pos = (7, 3))
    sizer.AddGrowableCol(2)
    panel.SetSizer(sizer)
    self.button4.Bind(wx.EVT_BUTTON, self.onupdateandClose)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14621838_14622686_15_22
14621838_14624041_5_10
Title: Identifying equivalent varargs function calls for memoization in Python 
----------------------------------------

def memoizer(* args, ** kwargs) :
INDENT
    key = make_key(args, kwargs)
    if key not in cache :
    INDENT
        cache [key] = obj(* args, ** kwargs)
        print "Not using cached result for key %s" % str(key)
    DEDENT
    else :
    INDENT
        print "Using cached result for key %s" % str(key)
    DEDENT
    return cache [key]
DEDENT
----------------------------------------

def memoizer(* args, ** kwargs) :
INDENT
    kwargs.update(dict(zip(inspect.getargspec(obj).args, args)))
    key = tuple(kwargs.get(k, None) for k in inspect.getargspec(obj).args)
    if key not in cache :
    INDENT
        cache [key] = obj(** kwargs)
    DEDENT
    return cache [key]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14621838_14622686_5_24
14621838_14624041_2_11
Title: Identifying equivalent varargs function calls for memoization in Python 
----------------------------------------

def memoize(obj) :
INDENT
    def make_key(args, kwargs) :
    INDENT
        ordered_kwargs = OrderedDict(kwargs)
        parameters = tuple([args,
                tuple(ordered_kwargs.keys()),
                tuple(ordered_kwargs.values())])
        return parameters
    DEDENT
    cache = obj.cache = {}
    @ functools.wraps(obj)
    def memoizer(* args, ** kwargs) :
    INDENT
        key = make_key(args, kwargs)
        if key not in cache :
        INDENT
            cache [key] = obj(* args, ** kwargs)
            print "Not using cached result for key %s" % str(key)
        DEDENT
        else :
        INDENT
            print "Using cached result for key %s" % str(key)
        DEDENT
        return cache [key]
    DEDENT
    return memoizer
DEDENT
----------------------------------------

def memoize(obj) :
INDENT
    cache = obj.cache = {}
    @ functools.wraps(obj)
    def memoizer(* args, ** kwargs) :
    INDENT
        kwargs.update(dict(zip(inspect.getargspec(obj).args, args)))
        key = tuple(kwargs.get(k, None) for k in inspect.getargspec(obj).args)
        if key not in cache :
        INDENT
            cache [key] = obj(** kwargs)
        DEDENT
        return cache [key]
    DEDENT
    return memoizer
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14636350_15302213_12_20
14636350_28654546_18_23
Title: toggling decorators 
----------------------------------------

def __call__(cls, func) :
INDENT
    if cls.disabled :
    INDENT
        return func
    DEDENT
    @ functools.wraps(func)
    def deco(* args, ** kwargs) :
    INDENT
        print ("--> benchmarking %s(%s,%s)" % (func.__name__, args, kwargs))
        ret = func(* args, ** kwargs)
        print ("<-- done")
    DEDENT
    return deco
DEDENT
----------------------------------------

def __call__(self, target) :
INDENT
    if self._enabled :
    INDENT
        return self._enabled_func(target)
    DEDENT
    return target

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14639484_14655285_8_20
14639484_14668539_22_53
Title: How to change only some QTableWidgetItems in a row? 
----------------------------------------

def __init__(self) :
INDENT
    super(Main, self).__init__()
    self.table = Table(self)
    self.change = QPushButton('Change')
    layout = QHBoxLayout(self)
    layout.addWidget(self.table)
    layout.addWidget(self.change)
    self.change.clicked.connect(self.table.updateCell)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__(parent)
    self.tableWidget = QtGui.QTableWidget(self)
    self.tableWidget.setRowCount(2)
    self.tableWidget.setColumnCount(4)
    self.tableWidget.horizontalHeader().setResizeMode(QtGui.QHeaderView.Stretch)
    self.signalMapper = QtCore.QSignalMapper(self)
    self.signalMapper.mapped.connect(self.on_signalMapper_mapped)
    for row in range(2) :
    INDENT
        status = random.getrandbits(1)
        state = "Ok" if status else "Failed"
        thread = MyThread(self)
        thread.status = status
        self.signalMapper.setMapping(thread, row)
        thread.statusChanged.connect(self.signalMapper.map)
        thread.start()
        values = ["user", "passwd", "url.com", state]
        for column, value in enumerate(values) :
        INDENT
            item = QtGui.QTableWidgetItem()
            item.setText("{0}: {1}".format(row, value))
            self.tableWidget.setItem(row, column, item)
        DEDENT
    DEDENT
    self.gridLayout = QtGui.QGridLayout(self)
    self.gridLayout.addWidget(self.tableWidget, 0, 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14643200_14654407_11_26
14643200_14657268_10_30
Title: How to render DateField with 3 selects 
----------------------------------------

def __call__(self, field, ** kwargs) :
INDENT
    kwargs.setdefault('id', field.id)
    date_form = self.SelectDateForm(prefix = field.name)
    days_html = date_form.days_select(class_ = "input-mini").__html__()
    month_html = date_form.month_select(class_ = "input-mini").__html__()
    year_html = date_form.year_select(class_ = "input-small").__html__()
    widget_html = field.format
    widget_html = widget_html.replace('%d', days_html)
    widget_html = widget_html.replace('%m', month_html)
    widget_html = widget_html.replace('%Y', year_html)
    return HTMLString(widget_html)
DEDENT
----------------------------------------

def __call__(self, field, ** kwargs) :
INDENT
    field_id = kwargs.pop('id', field.id)
    html = []
    for format in field.format.split() :
    INDENT
        choices = self.FORMAT_CHOICES [format]
        id_suffix = format.replace('%', '-')
        params = dict(kwargs, name = field.name, id = field_id + id_suffix)
        html.append('<select %s>' % html_params(params))
        if field.data :
        INDENT
            current_value = int(field.data.strftime(format))
        DEDENT
        else :
        INDENT
            current_value = None
        DEDENT
        for value, label in choices :
        INDENT
            selected = (value == current_value)
            html.append(Select.render_option(value, label, selected))
        DEDENT
        html.append('</select>')
    DEDENT
    return HTMLString(''.join(html))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14643200_14654407_11_26
14643200_14664504_17_49
Title: How to render DateField with 3 selects 
----------------------------------------

def __call__(self, field, ** kwargs) :
INDENT
    kwargs.setdefault('id', field.id)
    date_form = self.SelectDateForm(prefix = field.name)
    days_html = date_form.days_select(class_ = "input-mini").__html__()
    month_html = date_form.month_select(class_ = "input-mini").__html__()
    year_html = date_form.year_select(class_ = "input-small").__html__()
    widget_html = field.format
    widget_html = widget_html.replace('%d', days_html)
    widget_html = widget_html.replace('%m', month_html)
    widget_html = widget_html.replace('%Y', year_html)
    return HTMLString(widget_html)
DEDENT
----------------------------------------

def __call__(self, field, ** kwargs) :
INDENT
    field_id = kwargs.pop('id', field.id)
    html = []
    allowed_format = ['%d', '%m', '%Y']
    for format in field.format.split() :
    INDENT
        if (format in allowed_format) :
        INDENT
            choices = self.FORMAT_CHOICES [format]
            id_suffix = format.replace('%', '-')
            id_current = field_id + id_suffix
            kwargs ['class'] = self.FORMAT_CLASSES [format]
            try : del kwargs ['placeholder']
            except : pass

            html.append('<select %s>' % html_params(name = field.name, id = id_current, ** kwargs))
            if field.data :
            INDENT
                current_value = int(field.data.strftime(format))
            DEDENT
            else :
            INDENT
                current_value = None
            DEDENT
            for value, label in choices :
            INDENT
                selected = (value == current_value)
                html.append(Select.render_option(value, label, selected))
            DEDENT
            html.append('</select>')
        DEDENT
        else :
        INDENT
            html.append(format)
            html.append('<input type="hidden" value="' + format + '" %s></input>' % html_params(name = field.name, id = id_current, ** kwargs))
        DEDENT
        html.append(' ')
    DEDENT
    return HTMLString(''.join(html))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14643200_14657268_10_30
14643200_14664504_17_49
Title: How to render DateField with 3 selects 
----------------------------------------

def __call__(self, field, ** kwargs) :
INDENT
    field_id = kwargs.pop('id', field.id)
    html = []
    for format in field.format.split() :
    INDENT
        choices = self.FORMAT_CHOICES [format]
        id_suffix = format.replace('%', '-')
        params = dict(kwargs, name = field.name, id = field_id + id_suffix)
        html.append('<select %s>' % html_params(params))
        if field.data :
        INDENT
            current_value = int(field.data.strftime(format))
        DEDENT
        else :
        INDENT
            current_value = None
        DEDENT
        for value, label in choices :
        INDENT
            selected = (value == current_value)
            html.append(Select.render_option(value, label, selected))
        DEDENT
        html.append('</select>')
    DEDENT
    return HTMLString(''.join(html))

DEDENT
----------------------------------------

def __call__(self, field, ** kwargs) :
INDENT
    field_id = kwargs.pop('id', field.id)
    html = []
    allowed_format = ['%d', '%m', '%Y']
    for format in field.format.split() :
    INDENT
        if (format in allowed_format) :
        INDENT
            choices = self.FORMAT_CHOICES [format]
            id_suffix = format.replace('%', '-')
            id_current = field_id + id_suffix
            kwargs ['class'] = self.FORMAT_CLASSES [format]
            try : del kwargs ['placeholder']
            except : pass

            html.append('<select %s>' % html_params(name = field.name, id = id_current, ** kwargs))
            if field.data :
            INDENT
                current_value = int(field.data.strftime(format))
            DEDENT
            else :
            INDENT
                current_value = None
            DEDENT
            for value, label in choices :
            INDENT
                selected = (value == current_value)
                html.append(Select.render_option(value, label, selected))
            DEDENT
            html.append('</select>')
        DEDENT
        else :
        INDENT
            html.append(format)
            html.append('<input type="hidden" value="' + format + '" %s></input>' % html_params(name = field.name, id = id_current, ** kwargs))
        DEDENT
        html.append(' ')
    DEDENT
    return HTMLString(''.join(html))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14656473_14656960_1_9
14656473_44080291_2_11
Title: Python Beginner's Loop (Finding Primes) 
----------------------------------------

def is_prime(n) :
INDENT
    i = 2
    while i < n :
    INDENT
        if n % i == 0 :
        INDENT
            return False
        DEDENT
        i += 1
    DEDENT
    return True

DEDENT
----------------------------------------

def is_prime(a_num) :
INDENT
    for i in prime_list :
    INDENT
        div, rem = divmod(a_num, i)
        if rem == 0 :
        INDENT
            return False
        DEDENT
        elif div < i :
        INDENT
            break;
        DEDENT
    DEDENT
    prime_list.append(a_num)
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14656473_14656960_1_9
14656473_45599747_4_14
Title: Python Beginner's Loop (Finding Primes) 
----------------------------------------

def is_prime(n) :
INDENT
    i = 2
    while i < n :
    INDENT
        if n % i == 0 :
        INDENT
            return False
        DEDENT
        i += 1
    DEDENT
    return True

DEDENT
----------------------------------------

def is_prime(n) :
INDENT
    if n in my_List :
    INDENT
        return True
    DEDENT
    elif n > = 2 :
    INDENT
        for i in range(2, n) :
        INDENT
            if n % i == 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14656473_44080291_2_11
14656473_45599747_4_14
Title: Python Beginner's Loop (Finding Primes) 
----------------------------------------

def is_prime(a_num) :
INDENT
    for i in prime_list :
    INDENT
        div, rem = divmod(a_num, i)
        if rem == 0 :
        INDENT
            return False
        DEDENT
        elif div < i :
        INDENT
            break;
        DEDENT
    DEDENT
    prime_list.append(a_num)
    return True
DEDENT
----------------------------------------

def is_prime(n) :
INDENT
    if n in my_List :
    INDENT
        return True
    DEDENT
    elif n > = 2 :
    INDENT
        for i in range(2, n) :
        INDENT
            if n % i == 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1466140_1495895_5_24
1466140_3070519_54_72
Title: multiline checkbox in wxpython 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Hello World", size = (300, 200))
    self.panel = wx.Panel(self, - 1)
    myVSizer = wx.BoxSizer(wx.VERTICAL)

    myHSizer = wx.BoxSizer(wx.HORIZONTAL)
    cb = wx.CheckBox(self.panel, - 1, label = "")
    label = wx.StaticText(self.panel, label = "This is a very very long label for 100 pixel wide cb!", size = (100, - 1))
    label.Wrap(100)
    myHSizer.Add(cb, border = 5, flag = wx.ALL)
    myHSizer.Add(label, border = 5, flag = wx.ALL)
    myVSizer.Add(myHSizer)
    self.panel.SetSizer(myVSizer)
    myVSizer.Layout()

DEDENT
----------------------------------------

def __init__(self, pos = wx.DefaultPosition) :
INDENT
    wx.Frame.__init__(self, None, title = "Hello World", size = wx.Size(600, 400), pos = pos)
    self.panel = wx.Panel(self, - 1)
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    self.panel.SetSizer(sizer)
    sizer.Layout()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1466140_1495895_5_24
1466140_3070519_5_31
Title: multiline checkbox in wxpython 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Hello World", size = (300, 200))
    self.panel = wx.Panel(self, - 1)
    myVSizer = wx.BoxSizer(wx.VERTICAL)

    myHSizer = wx.BoxSizer(wx.HORIZONTAL)
    cb = wx.CheckBox(self.panel, - 1, label = "")
    label = wx.StaticText(self.panel, label = "This is a very very long label for 100 pixel wide cb!", size = (100, - 1))
    label.Wrap(100)
    myHSizer.Add(cb, border = 5, flag = wx.ALL)
    myHSizer.Add(label, border = 5, flag = wx.ALL)
    myVSizer.Add(myHSizer)
    self.panel.SetSizer(myVSizer)
    myVSizer.Layout()

DEDENT
----------------------------------------

def __init__(self, parent, id = - 1, label = wx.EmptyString, wrap = 10, pos = wx.DefaultPosition, size = wx.DefaultSize, style = 0, validator = wx.DefaultValidator, name = wx.RadioButtonNameStr) :
INDENT
    wx.RadioButton.__init__(self, parent, id, '', pos, size, style, validator, name)
    self._label = label
    self._wrap = wrap
    lines = self._label.split('\n')
    self._wrappedLabel = []
    for line in lines :
    INDENT
        self._wrappedLabel.extend(textwrap.wrap(line, self._wrap))
    DEDENT
    self._textHOffset = 20
    dc = wx.ClientDC(self)
    font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
    dc.SetFont(font)
    maxWidth = 0
    totalHeight = 0
    lineHeight = 0
    for line in self._wrappedLabel :
    INDENT
        width, height = dc.GetTextExtent(line)
        maxWidth = max(maxWidth, width)
        lineHeight = height
        totalHeight += lineHeight
    DEDENT
    self._textHeight = totalHeight
    self.SetInitialSize(wx.Size(self._textHOffset + maxWidth, totalHeight))
    self.Bind(wx.EVT_PAINT, self.OnPaint)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1466140_1495895_5_24
1466140_3070519_74_92
Title: multiline checkbox in wxpython 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Hello World", size = (300, 200))
    self.panel = wx.Panel(self, - 1)
    myVSizer = wx.BoxSizer(wx.VERTICAL)

    myHSizer = wx.BoxSizer(wx.HORIZONTAL)
    cb = wx.CheckBox(self.panel, - 1, label = "")
    label = wx.StaticText(self.panel, label = "This is a very very long label for 100 pixel wide cb!", size = (100, - 1))
    label.Wrap(100)
    myHSizer.Add(cb, border = 5, flag = wx.ALL)
    myHSizer.Add(label, border = 5, flag = wx.ALL)
    myVSizer.Add(myHSizer)
    self.panel.SetSizer(myVSizer)
    myVSizer.Layout()

DEDENT
----------------------------------------

def __init__(self, pos = wx.DefaultPosition) :
INDENT
    wx.Frame.__init__(self, None, title = "Hello World", size = wx.Size(600, 400), pos = pos)
    self.panel = wx.Panel(self, - 1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    self.panel.SetSizer(sizer)
    sizer.Layout()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1466140_3070519_54_72
1466140_3070519_5_31
Title: multiline checkbox in wxpython 
----------------------------------------

def __init__(self, pos = wx.DefaultPosition) :
INDENT
    wx.Frame.__init__(self, None, title = "Hello World", size = wx.Size(600, 400), pos = pos)
    self.panel = wx.Panel(self, - 1)
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    self.panel.SetSizer(sizer)
    sizer.Layout()

DEDENT
----------------------------------------

def __init__(self, parent, id = - 1, label = wx.EmptyString, wrap = 10, pos = wx.DefaultPosition, size = wx.DefaultSize, style = 0, validator = wx.DefaultValidator, name = wx.RadioButtonNameStr) :
INDENT
    wx.RadioButton.__init__(self, parent, id, '', pos, size, style, validator, name)
    self._label = label
    self._wrap = wrap
    lines = self._label.split('\n')
    self._wrappedLabel = []
    for line in lines :
    INDENT
        self._wrappedLabel.extend(textwrap.wrap(line, self._wrap))
    DEDENT
    self._textHOffset = 20
    dc = wx.ClientDC(self)
    font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
    dc.SetFont(font)
    maxWidth = 0
    totalHeight = 0
    lineHeight = 0
    for line in self._wrappedLabel :
    INDENT
        width, height = dc.GetTextExtent(line)
        maxWidth = max(maxWidth, width)
        lineHeight = height
        totalHeight += lineHeight
    DEDENT
    self._textHeight = totalHeight
    self.SetInitialSize(wx.Size(self._textHOffset + maxWidth, totalHeight))
    self.Bind(wx.EVT_PAINT, self.OnPaint)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1466140_3070519_5_31
1466140_3070519_74_92
Title: multiline checkbox in wxpython 
----------------------------------------

def __init__(self, parent, id = - 1, label = wx.EmptyString, wrap = 10, pos = wx.DefaultPosition, size = wx.DefaultSize, style = 0, validator = wx.DefaultValidator, name = wx.RadioButtonNameStr) :
INDENT
    wx.RadioButton.__init__(self, parent, id, '', pos, size, style, validator, name)
    self._label = label
    self._wrap = wrap
    lines = self._label.split('\n')
    self._wrappedLabel = []
    for line in lines :
    INDENT
        self._wrappedLabel.extend(textwrap.wrap(line, self._wrap))
    DEDENT
    self._textHOffset = 20
    dc = wx.ClientDC(self)
    font = wx.SystemSettings.GetFont(wx.SYS_DEFAULT_GUI_FONT)
    dc.SetFont(font)
    maxWidth = 0
    totalHeight = 0
    lineHeight = 0
    for line in self._wrappedLabel :
    INDENT
        width, height = dc.GetTextExtent(line)
        maxWidth = max(maxWidth, width)
        lineHeight = height
        totalHeight += lineHeight
    DEDENT
    self._textHeight = totalHeight
    self.SetInitialSize(wx.Size(self._textHOffset + maxWidth, totalHeight))
    self.Bind(wx.EVT_PAINT, self.OnPaint)
DEDENT
----------------------------------------

def __init__(self, pos = wx.DefaultPosition) :
INDENT
    wx.Frame.__init__(self, None, title = "Hello World", size = wx.Size(600, 400), pos = pos)
    self.panel = wx.Panel(self, - 1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    cb = RadioButton(self.panel, - 1, label = "This is a very very long label for the control!", wrap = 10)
    sizer.Add(cb, 1)
    self.panel.SetSizer(sizer)
    sizer.Layout()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14685999_14687465_35_48
14685999_14688072_11_16
Title: Trigger an event when clipboard content changes 
----------------------------------------

def main() :
INDENT
    watcher = ClipboardWatcher(is_url_but_not_bitly,
        print_to_stdout,
        5.)
    watcher.start()
    while True :
    INDENT
        try :
        INDENT
            print "Waiting for changed clipboard..."
            time.sleep(10)
        DEDENT
        except KeyboardInterrupt :
        INDENT
            watcher.stop()
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        t = Timer(1, poll_clipboard)
        t.start()
        t.join()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14699586_14701014_13_19
14699586_34769747_28_37
Title: Is there a Python library equivalent of the Java's FixedThreadPool? 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        func, args, kargs = self.tasks.get()
        try : func(* args, ** kargs)
        except Exception, e : print e
        self.tasks.task_done()
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        func, callback, args, kargs = self.tasks.get()
        try :
        INDENT
            data = func(* args, ** kargs)
            callback(data, False)
        DEDENT
        except Exception, e :
        INDENT
            callback(e, True)
        DEDENT
        self.tasks.task_done()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14714491_14714859_3_18
14714491_14715244_1_11
Title: Remove line pattern 
----------------------------------------

def delete_line(dello) :
INDENT
    opener = open("abc.csv", 'rb')
    dataset = csv.reader(opener, delimiter = ',')
    output = []
    for line in dataset :
    INDENT
        if dello ! = line [1] :
        INDENT

            output.append(",".join(line) + "\n")
        DEDENT
    DEDENT
    opener.close()
    fn = "abc.csv"
    f = open(fn, 'w')
    f.writelines(output)
    f.close()
DEDENT
----------------------------------------

def delete_line(input_csv, dello) :
INDENT
    with open(input_csv, 'rb') as f :
    INDENT
        csv_reader = csv.reader(f)
        output = []
        for line in csv_reader :
        INDENT
            if dello not in line :
            INDENT
                output.append(line)
            DEDENT
        DEDENT
    DEDENT
    with open(input_csv, 'wb') as f :
    INDENT
        csv_writer = csv.writer(f)
        csv_writer.writerows(output)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14719882_14720058_1_23
14719882_14720278_5_22
Title: Formatting a string in required format in Python 
----------------------------------------

def parse(data) :
INDENT
    nodes = set()
    links = set()
    for line in data.split('\n') :
    INDENT
        fields = line.split()
        id1, id2 = map(int, fields [: 2])
        value = float(fields [2])
        nodes.update((id1, id2))
        links.add((id1, id2, value))
    DEDENT
    return {
        'nodes' : [{
                'name' : node} for node in nodes],
        'links' : [{
                'source' : link [0],
                'target' : link [1],
                'value' : link [2]} for link in links]}
DEDENT
----------------------------------------

def parse(inpath, namedict) :
INDENT
    lastname = [0]
    def lookup_name(name) :
    INDENT
        try :
        INDENT
            print ('Looking up {} in {}'.format(name, names))
            return namedict [name]
        DEDENT
        except KeyError :
        INDENT
            lastname [0] += 1
            print ('Adding {} as {}'.format(name, lastname [0]))
            namedict [name] = lastname [0]
            return lastname [0]
        DEDENT
    DEDENT
    with open(inpath) as f :
    INDENT
        reader = csv.reader(f, delimiter = ' ', skipinitialspace = True)
        for id1, id2, value in reader :
        INDENT
            yield {'source' : lookup_name(id1),
                'target' : lookup_name(id2),
                'value' : value}
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14735469_14735668_1_14
14735469_14737195_12_26
Title: windchill table using nested loop 
----------------------------------------

def main() :
INDENT
    def wind_chill(temp, wind_speed) :
    INDENT
        return 35.74 + (0.6215 * temp) - 35.75 * (wind_speed ** 0.16) + 0.4275 * temp * (wind_speed ** 0.16)
    DEDENT
    heading = '  '
    for temp in range(- 20, 70, 10) :
    INDENT
        heading += "{:>7d}".format(temp)
    DEDENT
    print heading + "\n   " + "-" * 62
    for wind_speed in range(0, 35, 5) :
    INDENT
        output_line = "{:>2d}".format(wind_speed)
        for temp in range(- 20, 70, 10) :
        INDENT
            output_line += "{:>7.1f}".format(wind_chill(temp, wind_speed))
        DEDENT
        print output_line
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    temps = xrange(- 20, 70, 10)
    num_temps = len(temps)
    data = [" "] + [temp for temp in temps]
    print ("{:3s}" + num_temps * " {:5d}").format(* data)
    data = [" "] + num_temps * [5 * "-"]
    print ("{:3s}" + num_temps * " {:5s}").format(* data)
    row_format_string = "{:3d}" + num_temps * " {:5.1F}"
    for wind_speed in xrange(0, 35, 5) :
    INDENT
        data = [wind_speed] + [wind_chill(temp, wind_speed) for temp in temps]
        print row_format_string.format(* data)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14739425_22187084_16_30
14739425_22187084_47_57
Title: How to embed IPython kernel into PyQt4 program? 
----------------------------------------

def __init__(self, customBanner = None, * args, ** kwargs) :
INDENT
    if customBanner ! = None : self.banner = customBanner
    super(QIPythonWidget, self).__init__(* args, ** kwargs)
    self.kernel_manager = kernel_manager = QtInProcessKernelManager()
    kernel_manager.start_kernel()
    kernel_manager.kernel.gui = 'qt4'
    self.kernel_client = kernel_client = self._kernel_manager.client()
    kernel_client.start_channels()
    def stop() :
    INDENT
        kernel_client.stop_channels()
        kernel_manager.shutdown_kernel()
        guisupport.get_app_qt4().exit()
    DEDENT
    self.exit_requested.connect(stop)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(ExampleWidget, self).__init__(parent)
    layout = QVBoxLayout(self)
    self.button = QPushButton('Another widget')
    ipyConsole = QIPythonWidget(customBanner = "Welcome to the embedded ipython console\n")
    layout.addWidget(self.button)
    layout.addWidget(ipyConsole)
    ipyConsole.pushVariables({"foo" : 43, "print_process_id" : print_process_id})
    ipyConsole.printText("The variable 'foo' and the method 'print_process_id()' are available. Use the 'whos' command for information.")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1475950_13691289_3_15
1475950_1476006_2_10
Title: tail -f in python with no time.sleep 
----------------------------------------

def follow(thefile) :
INDENT
    thefile.seek(0, 2)
    sleep = 0.00001
    while True :
    INDENT
        line = thefile.readline()
        if not line :
        INDENT
            time.sleep(sleep)
            if sleep < 1.0 :
            INDENT
                sleep += 0.00001
            DEDENT
            continue
        DEDENT
        sleep = 0.00001
        yield line
    DEDENT
DEDENT
----------------------------------------

def follow(thefile) :
INDENT
    thefile.seek(0, 2)
    while True :
    INDENT
        line = thefile.readline()
        if not line :
        INDENT
            time.sleep(0.1)
            continue
        DEDENT
        yield line
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1475950_13691289_3_15
1475950_32337655_13_41
Title: tail -f in python with no time.sleep 
----------------------------------------

def follow(thefile) :
INDENT
    thefile.seek(0, 2)
    sleep = 0.00001
    while True :
    INDENT
        line = thefile.readline()
        if not line :
        INDENT
            time.sleep(sleep)
            if sleep < 1.0 :
            INDENT
                sleep += 0.00001
            DEDENT
            continue
        DEDENT
        sleep = 0.00001
        yield line
    DEDENT
DEDENT
----------------------------------------

def follow(filename, blocksize = 8192) :
INDENT
    with INotify() as inotify :
    INDENT

        stop_mask = IN_DELETE_SELF | IN_MOVE_SELF
        inotify.add_watch(filename, IN_MODIFY | stop_mask)

        filepos = 0
        while True :
        INDENT
            with open(filename, "rb") as fileobj :
            INDENT
                fileobj.seek(filepos)
                while True :
                INDENT
                    data = fileobj.read(blocksize)
                    if not data :
                    INDENT
                        break
                    DEDENT
                    filepos += len(data)
                    yield data

                DEDENT
            DEDENT
            _, mask, _, _ = inotify.next_event()
            if mask & stop_mask :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1475950_1476006_2_10
1475950_32337655_13_41
Title: tail -f in python with no time.sleep 
----------------------------------------

def follow(thefile) :
INDENT
    thefile.seek(0, 2)
    while True :
    INDENT
        line = thefile.readline()
        if not line :
        INDENT
            time.sleep(0.1)
            continue
        DEDENT
        yield line
    DEDENT
DEDENT
----------------------------------------

def follow(filename, blocksize = 8192) :
INDENT
    with INotify() as inotify :
    INDENT

        stop_mask = IN_DELETE_SELF | IN_MOVE_SELF
        inotify.add_watch(filename, IN_MODIFY | stop_mask)

        filepos = 0
        while True :
        INDENT
            with open(filename, "rb") as fileobj :
            INDENT
                fileobj.seek(filepos)
                while True :
                INDENT
                    data = fileobj.read(blocksize)
                    if not data :
                    INDENT
                        break
                    DEDENT
                    filepos += len(data)
                    yield data

                DEDENT
            DEDENT
            _, mask, _, _ = inotify.next_event()
            if mask & stop_mask :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14763829_14764167_5_16
14763829_14765746_7_15
Title: Return whichever expression returns first 
----------------------------------------

def firstresult(* functions) :
INDENT
    queue = Queue()
    threads = []
    for f in functions :
    INDENT
        def thread_main() :
        INDENT
            queue.put(f())
        DEDENT
        thread = Thread(target = thread_main)
        threads.append(thread)
        thread.start()
    DEDENT
    result = queue.get()
    return result
DEDENT
----------------------------------------

def firstresult(func1, func2) :
INDENT
    queue = Queue()
    proc1 = Process(target = func1, args = (queue,))
    proc2 = Process(target = func2, args = (queue,))
    proc1.start(); proc2.start()
    result = queue.get()
    proc1.terminate(); proc2.terminate()
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14764237_14764295_4_10
14764237_14764923_16_34
Title: How to encode a long in Base64 in Python? 
----------------------------------------

def encode(n) :
INDENT
    data = struct.pack('<Q', n).rstrip('\x00')
    if len(data) == 0 :
    INDENT
        data = '\x00'
    DEDENT
    s = base64.urlsafe_b64encode(data).rstrip('=')
    return s
DEDENT
----------------------------------------

def encode(n, big_endian = False) :
INDENT
    lst = []
    while True :
    INDENT
        n, lsb = divmod(n, 0x100)
        lst.append(chr(lsb))
        if not n :
        INDENT
            break
        DEDENT
    DEDENT
    if big_endian :
    INDENT

        initial_zero_bytes = '\x00' * 2
        data = initial_zero_bytes + ''.join(reversed(lst))
    DEDENT
    else :
    INDENT
        data = ''.join(lst)
    DEDENT
    s = base64.urlsafe_b64encode(data).rstrip('=')
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14768633_14769530_1_31
14768633_14771163_1_19
Title: Merging three lists together 
----------------------------------------

def merge(a, b) :
INDENT
    L = a
    l = b
    i = 0
    j = 0
    res = []
    if (len(b) > len(a)) :
    INDENT
        L = b
        l = a

    DEDENT
    while (i < len(L)) :
    INDENT
        if (len(l) > 0) :
        INDENT
            while (j < len(l)) :
            INDENT
                if (L [i] < = l [j]) :
                INDENT
                    res.append(L [i])
                    del L [i]
                    break
                DEDENT
                else :
                INDENT
                    res.append(l [j])
                    del l [j]
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT

            res = list(res + L)
            L = []
            break
        DEDENT
    DEDENT
    if len(l) > 0 :
    INDENT
        res = list(res + l)
        l = []
    DEDENT
    return res
DEDENT
----------------------------------------

def merge(* args) :
INDENT
    lst = list(args)
    idx = [0] * len(lst)
    out = []
    while lst :
    INDENT
        m = 0
        for i in range(len(lst)) :
        INDENT
            if lst [i] [idx [i]] < lst [m] [idx [m]] :
            INDENT
                m = i
            DEDENT
        DEDENT
        out.append(lst [m] [idx [m]])
        idx [m] += 1
        if idx [m] > = len(lst [m]) :
        INDENT
            del lst [m]
            del idx [m]

        DEDENT
    DEDENT
    return out

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14783947_14783998_1_20
14783947_15491515_1_10
Title: Grouping / clustering numbers in Python 
----------------------------------------

def cluster(data, maxgap) :
INDENT
    data.sort()
    groups = [[data [0]]]
    for x in data [1 :] :
    INDENT
        if abs(x - groups [- 1] [- 1]) < = maxgap :
        INDENT
            groups [- 1].append(x)
        DEDENT
        else :
        INDENT
            groups.append([x])
        DEDENT
    DEDENT
    return groups
DEDENT
----------------------------------------

def cluster(sequence, maxgap) :
INDENT
    batch = []
    for prev, val in pairify(sequence) :
    INDENT
        if val - prev > = maxgap :
        INDENT
            yield batch
            batch = []
        DEDENT
        else :
        INDENT
            batch.append(val)
        DEDENT
    DEDENT
    if batch :
    INDENT
        yield batch
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14797607_14797923_1_20
14797607_14798050_1_11
Title: How to update pyxb tree-like object in a loop? 
----------------------------------------

def override_setup(exp, args) :
INDENT
    exp_dict = vars(exp)
    opts = vars(args)

    for key in exp_dict :
    INDENT
        cur_param = None
        for param in ['param1', 'param2'] :
        INDENT
            if key.endswith(param) :
            INDENT
                cur_param = param
            DEDENT
        DEDENT
        if not cur_param or opts [cur_param] is None :
        INDENT
            continue
        DEDENT
        try :
        INDENT
            exp_dict [key] = opts [cur_param]
        DEDENT
        except Exception as e :
        INDENT
            print e
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def override_setup(exp, args) :
INDENT
    opts = vars(args)
    for param in ['param1', 'param2'] :
    INDENT
        if opts [param] is None :
        INDENT
            continue
        DEDENT
        try :
        INDENT
            setattr(exp, param, opts [param])
        DEDENT
        except Exception as e :
        INDENT
            print e
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14800191_14964278_2_14
14800191_15036742_2_21
Title: Dajax/Dajaxice saving object in ajax.py with parameters 
----------------------------------------

def save_comment(req, form, user_username, other_username) :
INDENT
    dajax = Dajax()
    comment_form = CreateCommentForm(deserialize_form(form))
    if comment_form.is_valid() :
    INDENT
        text = comment_form.cleaned_data ['text']
        user = User.objects.get(username = user_username)
        other_user = User.objects.get(username = other_username)
        other_profile = Profile.objects.get(user = other_user)
        comment = Comment(owner = user, text = text)
        comment.save()
        other_profile.comments.add(comment)
        return dajax.json()
    DEDENT
DEDENT
----------------------------------------

def save_comment(req, form, user_username, other_username) :
INDENT
    dajax = Dajax()
    user = User.objects.get(username = user_username)
    other_user = User.objects.get(username = other_username)
    other_profile = Profile.objects.get(user = other_user)

    comment = Comments(owner = user)
    comment_form = CreateCommentForm(deserialize_form(form), instance = comment)
    if comment_form.is_valid() :
    INDENT
        comment_form.save()
        dajax.alert('Form is valid')
    DEDENT
    else :
    INDENT
        dajax.alert('Form is invalid')
        for error in comment_form.errors :
        INDENT
            dajax.add_css_class('#id_%s' % error, 'error')

        DEDENT
    DEDENT
    return dajax.json()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1482308_1482322_1_11
1482308_14906761_5_11
Title: How to get all subsets of a set? (powerset) 
----------------------------------------

def powerset(seq) :
INDENT
    if len(seq) < = 1 :
    INDENT
        yield seq
        yield []
    DEDENT
    else :
    INDENT
        for item in powerset(seq [1 :]) :
        INDENT
            yield [seq [0]] + item
            yield item
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def powerset(items) :
INDENT
    combo = []
    for r in range(len(items) + 1) :
    INDENT

        combo.append(list(combinations(items, r)))
    DEDENT
    return combo
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1482308_1482322_1_11
1482308_15942290_2_15
Title: How to get all subsets of a set? (powerset) 
----------------------------------------

def powerset(seq) :
INDENT
    if len(seq) < = 1 :
    INDENT
        yield seq
        yield []
    DEDENT
    else :
    INDENT
        for item in powerset(seq [1 :]) :
        INDENT
            yield [seq [0]] + item
            yield item
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def powerset(base_set) :
INDENT
    from itertools import chain, combinations
    base_list = list(base_set)
    combo_list = [combinations(base_list, r) for r in range(len(base_set) + 1)]
    powerset = set([])
    for ll in combo_list :
    INDENT
        list_of_frozensets = list(map(frozenset, map(list, ll)))
        set_of_frozensets = set(list_of_frozensets)
        powerset = powerset.union(set_of_frozensets)
    DEDENT
    return powerset
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1482308_14906761_5_11
1482308_15942290_2_15
Title: How to get all subsets of a set? (powerset) 
----------------------------------------

def powerset(items) :
INDENT
    combo = []
    for r in range(len(items) + 1) :
    INDENT

        combo.append(list(combinations(items, r)))
    DEDENT
    return combo
DEDENT
----------------------------------------

def powerset(base_set) :
INDENT
    from itertools import chain, combinations
    base_list = list(base_set)
    combo_list = [combinations(base_list, r) for r in range(len(base_set) + 1)]
    powerset = set([])
    for ll in combo_list :
    INDENT
        list_of_frozensets = list(map(frozenset, map(list, ll)))
        set_of_frozensets = set(list_of_frozensets)
        powerset = powerset.union(set_of_frozensets)
    DEDENT
    return powerset
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1482308_14906761_5_11
1482308_19078726_1_10
Title: How to get all subsets of a set? (powerset) 
----------------------------------------

def powerset(items) :
INDENT
    combo = []
    for r in range(len(items) + 1) :
    INDENT

        combo.append(list(combinations(items, r)))
    DEDENT
    return combo
DEDENT
----------------------------------------

def powerset(seq) :
INDENT
    if len(seq) < = 0 :
    INDENT
        yield []
    DEDENT
    else :
    INDENT
        for item in powerset(seq [1 :]) :
        INDENT
            yield [seq [0]] + item
            yield item
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1482308_15942290_2_15
1482308_19078726_1_10
Title: How to get all subsets of a set? (powerset) 
----------------------------------------

def powerset(base_set) :
INDENT
    from itertools import chain, combinations
    base_list = list(base_set)
    combo_list = [combinations(base_list, r) for r in range(len(base_set) + 1)]
    powerset = set([])
    for ll in combo_list :
    INDENT
        list_of_frozensets = list(map(frozenset, map(list, ll)))
        set_of_frozensets = set(list_of_frozensets)
        powerset = powerset.union(set_of_frozensets)
    DEDENT
    return powerset
DEDENT
----------------------------------------

def powerset(seq) :
INDENT
    if len(seq) < = 0 :
    INDENT
        yield []
    DEDENT
    else :
    INDENT
        for item in powerset(seq [1 :]) :
        INDENT
            yield [seq [0]] + item
            yield item
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14824163_48477519_14_23
14824163_48477519_162_182
Title: How to get the input from the Tkinter Text Box Widget? 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    tk.LabelFrame.__init__(self, master, * args, ** kwargs)
    self.start_arg = ''
    self.end_arg = None
    self.position_frames = dict()
    self._create_widgets()
    self._layout()
    self.update()

DEDENT
----------------------------------------

def __init__(self, master, update_callback = None, * args, ** kwargs) :
INDENT
    tk.Text.__init__(self, master, * args, ** kwargs)
    self._events = ('<KeyPress>',
        '<KeyRelease>',
        '<ButtonRelease-1>',
        '<ButtonRelease-2>',
        '<ButtonRelease-3>',
        '<Delete>',
        '<<Cut>>',
        '<<Paste>>',
        '<<Undo>>',
        '<<Redo>>')
    self.line_count = None
    self.lines_length = list()
    self.update_callback = update_callback
    self.update_stats()
    self.bind_events_on_widget_to_callback(self._events,
        self,
        self.update_stats)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14824163_48477519_226_233
14824163_48477519_46_58
Title: How to get the input from the Tkinter Text Box Widget? 
----------------------------------------

def _layout(self) :
INDENT
    self.line.grid(sticky = 'ns', row = 0, column = 0, rowspan = 2)
    self.column.grid(sticky = 'ew', row = 0, column = 1, columnspan = 2)
    self.label.grid(sticky = 'nsew', row = 1, column = 1)
    self.grid_rowconfigure(1, weight = 1)
    self.grid_columnconfigure(1, weight = 1)

DEDENT
----------------------------------------

def _layout(self) :
INDENT
    self._is_two_args.grid(sticky = 'nsw', row = 0, column = 1)
    self.position_frames ['start'].grid(sticky = 'nsew', row = 1, column = 0)
    self.text.grid(sticky = 'nsew', row = 2, column = 0,
        rowspan = 2, columnspan = 2)
    _grid_size = self.grid_size()
    for _col in range(_grid_size [0]) :
    INDENT
        self.grid_columnconfigure(_col, weight = 1)
    DEDENT
    for _row in range(_grid_size [1] - 1) :
    INDENT
        self.grid_rowconfigure(_row + 1, weight = 1)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14838635_14838798_20_27
14838635_14838798_4_12
Title: quit mainloop in python 
----------------------------------------

def __init__(self, master) :
INDENT
    tk.Frame.__init__(self, master)
    tk.Label(self, text = "Hey", font = ("Arial", 16)).pack()
    button = tk.Button(self, text = "the End",
        command = self.CloseWindow, font = ("Arial", 12))
    button.pack()
    self.pack()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    tk.Frame.__init__(self, master)
    tk.Label(self, text = "Hi", font = ("Arial", 16)).pack()
    self.button = tk.Button(self, text = "I am ready",
        command = self.CloseWindow, font = ("Arial", 12))
    self.button.pack()
    self.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1484310_1484579_17_26
1484310_1484579_28_35
Title: Python process pool and scope 
----------------------------------------

def run(self) :
INDENT
    for x in xrange(1000) :
    INDENT
        for y in xrange(1000) :
        INDENT
            for z in xrange(1000) :
            INDENT
                if time.time() - self.lastexecutiontime > 1 :
                INDENT
                    print "process %s" % self.name
                    self.lastexecutiontime = self.lastexecutiontime + 1
                    yield
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    self.result = self.name.uppercase()
DEDENT
----------------------------------------

def run(self) :
INDENT
    for x in range(10000000) :
    INDENT
        if time.time() - self.lastexecutiontime > 1 :
        INDENT
            print "process %s" % self.name
            self.lastexecutiontime = self.lastexecutiontime + 1
            yield
        DEDENT
    DEDENT
    self.result = self.name.capitalize()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14849284_14862423_25_57
14849284_14880904_51_100
Title: Pygame particle effects 
----------------------------------------

def main() :
INDENT
    pygame.init()
    screen = pygame.display.set_mode((xmax, ymax))
    white = (255, 255, 255)
    black = (0, 0, 0)
    grey = (128, 128, 128)
    clock = pygame.time.Clock()
    particles = []
    for part in range(300) :
    INDENT
        if part % 2 > 0 : col = black
        else : col = grey
        particles.append(Particle(515, 500, col))
    DEDENT
    exitflag = False
    while not exitflag :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == QUIT :
            INDENT
                exitflag = True
            DEDENT
            elif event.type == KEYDOWN :
            INDENT
                if event.key == K_ESCAPE :
                INDENT
                    exitflag = True
                DEDENT
            DEDENT
        DEDENT
        screen.fill(white)
        for p in particles :
        INDENT
            p.move()
            pygame.draw.circle(screen, p.col, (p.x, p.y), 2)
        DEDENT
        pygame.display.flip()
        clock.tick(50)
    DEDENT
    pygame.quit()
DEDENT
----------------------------------------

def main() :
INDENT
    xmax = 640
    ymax = 480
    white = (255, 255, 255)
    black = (0, 0, 0)
    grey = (128, 128, 128)
    pygame.init()
    screen = pygame.display.set_mode((xmax, ymax))
    clock = pygame.time.Clock()
    particles = []
    for i in range(1000) :
    INDENT
        if i % 2 :
        INDENT
            colour = black
        DEDENT
        else :
        INDENT
            colour = grey
        DEDENT
        x = random.randint(0, xmax)
        y = random.randint(0, ymax)
        speed = random.randint(0, 20) * 0.1
        angle = random.randint(0, 360)
        radius = 3
        particles.append(Particle((x, y), radius, speed, angle, colour, screen))
    DEDENT
    done = False
    while not done :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == pygame.QUIT :
            INDENT
                done = True
                break
            DEDENT
            elif event.type == pygame.KEYDOWN :
            INDENT
                if event.key == pygame.K_ESCAPE :
                INDENT
                    done = True
                    break
                DEDENT
            DEDENT
        DEDENT
        if done :
        INDENT
            break
        DEDENT
        screen.fill(white)
        for p in particles :
        INDENT
            p.move()
            p.bounce()
            p.draw()
        DEDENT
        clock.tick(40)
        pygame.display.flip()
    DEDENT
    pygame.quit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14855690_14855725_1_11
14855690_14858591_14_29
Title: Generate summed up ranges from a list 
----------------------------------------

def to_ranges(seq) :
INDENT
    iseq = iter(seq)
    x = next(iseq)
    yield range(0, x + 1)
    start = x
    for x in iseq :
    INDENT
        stop = start + x
        yield range(start + 1, stop + 1)
        start = stop

    DEDENT
DEDENT
----------------------------------------

def to_ranges(iterable) :
INDENT
    xs = _get_xs(iterable)
    ys = _get_ys(iterable)
    for x, y in izip(xs, ys) :
    INDENT
        if x < y :
        INDENT
            step = 1
            y += 1
        DEDENT
        elif x > y :
        INDENT
            step = - 1
            y -= 1
        DEDENT
        else :
        INDENT
            step = 0
        DEDENT
        try :
        INDENT
            yield range(x, y, step)
        DEDENT
        except ValueError :
        INDENT
            yield [x]
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14872763_14873873_11_23
14872763_14873873_25_35
Title: How to pop out a separate window from a tabWidget in PySide Qt 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Tab, self).__init__(parent)
    popOutButton = QtGui.QPushButton('Pop Out')
    popOutButton.clicked.connect(lambda : self.popOut.emit(self))
    popInButton = QtGui.QPushButton('Pop In')
    popInButton.clicked.connect(lambda : self.popIn.emit(self))
    layout = QtGui.QHBoxLayout(self)
    layout.addWidget(popOutButton)
    layout.addWidget(popInButton)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Window, self).__init__()
    self.button = QtGui.QPushButton('Add Tab')
    self.button.clicked.connect(self.createTab)
    self._count = 0
    self.tab = QtGui.QTabWidget()
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.button)
    layout.addWidget(self.tab)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14880117_14880520_2_21
14880117_14881981_3_14
Title: Controlling child class method from parent class 
----------------------------------------

def __new__(cls, name, bases, dct) :
INDENT
    new_dct = {}
    for member_name, member in dct.items() :
    INDENT
        if callable(member) :
        INDENT
            member = cls.wrap(bases, member_name, member)
        DEDENT
        new_dct [member_name] = member
    DEDENT
    return super(ReverserMetaclass, cls).__new__(cls, name, bases, new_dct)

DEDENT
----------------------------------------

def __new__(metaclass, classname, bases, classdict) :
INDENT
    clsobj = super(metaclass, metaclass).__new__(metaclass, classname,
        bases, classdict)
    if classname ! = 'Foo' and 'write' in classdict :
    INDENT
        def call_base_write_after(self, * args, ** kwargs) :
        INDENT
            classdict ['write'](self, * args, ** kwargs)
            Foo.write(self, * args, ** kwargs)
        DEDENT
        setattr(clsobj, 'write', call_base_write_after)
    DEDENT
    return clsobj
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
148853_549017_127_140
148853_549017_71_77
Title: Caching in urllib2? 
----------------------------------------

def __init__(self, cache_location, url, set_cache_header = True) :
INDENT
    self.cache_location = cache_location
    hpath, bpath = calculate_cache_path(cache_location, url)
    StringIO.StringIO.__init__(self, file(bpath).read())
    self.url = url
    self.code = 200
    self.msg = "OK"
    headerbuf = file(hpath).read()
    if set_cache_header :
    INDENT
        headerbuf += "x-local-cache: %s\r\n" % (bpath)
    DEDENT
    self.headers = httplib.HTTPMessage(StringIO.StringIO(headerbuf))
DEDENT
----------------------------------------

def __init__(self, cache_location, max_age = 21600) :
INDENT
    self.max_age = max_age
    self.cache_location = cache_location
    if not os.path.exists(self.cache_location) :
    INDENT
        os.mkdir(self.cache_location)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14894836_14894982_16_28
14894836_14894982_40_55
Title: "How to multithread a client and server in the same .py  but on different ports" 
----------------------------------------

def run(self) :
INDENT
    self.socket.listen(5)
    while True :
    INDENT
        print 'Waiting for connection..'
        client, caddr = self.socket.accept()
        print 'Connected To', caddr
        data = client.recv(self.bufsize)
        if not data :
        INDENT
            continue
        DEDENT
        print data
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    invalid = True
    while invalid :
    INDENT
        try :
        INDENT
            invalid = False
            self.socket.connect(self.addr)
        DEDENT
        except :
        INDENT
            invalid = True
        DEDENT
    DEDENT
    while True :
    INDENT
        data = raw_input('> ')
        if not data :
        INDENT
            continue
        DEDENT
        data = name + ' said : ' + data
        tcpClient.send(data)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14913524_14913632_3_11
14913524_14913772_2_15
Title: Tarfile stops after first regular file 
----------------------------------------

def tariter(filename) :
INDENT
    with tarfile.open(filename) as archive :
    INDENT
        for tarinfo in archive :
        INDENT
            if tarinfo.isreg() :
            INDENT
                handle = archive.extractfile(tarinfo.name)
                data = handle.read()
                handle.close()
                yield tarinfo, data
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def tariter(filename) :
INDENT
    with tarfile.open(filename) as archive :
    INDENT
        it = archive.__iter__()
        while True :
        INDENT
            tarinfo = it.next()
            if tarinfo is None :
            INDENT
                break
            DEDENT
            if tarinfo.isreg() :
            INDENT
                handle = archive.extractfile(tarinfo.name)
                data = handle.read()
                handle.close()
                yield tarinfo, data
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14913524_14913632_3_11
14913524_14924883_1_13
Title: Tarfile stops after first regular file 
----------------------------------------

def tariter(filename) :
INDENT
    with tarfile.open(filename) as archive :
    INDENT
        for tarinfo in archive :
        INDENT
            if tarinfo.isreg() :
            INDENT
                handle = archive.extractfile(tarinfo.name)
                data = handle.read()
                handle.close()
                yield tarinfo, data
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def tariter(filename) :
INDENT
    with tarfile.open(filename) as archive :
    INDENT
        while True :
        INDENT
            tarinfo = archive.next()
            if tarinfo is None :
            INDENT
                break
            DEDENT
            if tarinfo.isreg() :
            INDENT
                handle = archive.extractfile(tarinfo)
                data = handle.read()
                handle.close()
                yield tarinfo, data
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14944629_14945119_29_44
14944629_14945712_12_20
Title: Passing Partial Lists into Python Function 
----------------------------------------

def main() :
INDENT
    handler = lambda _ : 0
    for line in open('test.txt') :
    INDENT

        search_func = search_key_func(line)
        if search_func :
        INDENT

            handler = search_func
            continue
        DEDENT
        handler(line)

    DEDENT
DEDENT
----------------------------------------

def main(argv = None) :
INDENT
    if argv is None :
    INDENT
        argv = sys.argv
    DEDENT
    with open(argv [1], 'r') as f :
    INDENT
        text = f.read().splittext()
    DEDENT
    find(text, "c", find(text, "b", find(text, "a")))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14946963_14947661_5_14
14946963_33004214_4_30
Title: Tkinter Grid: How to position widgets so they are not stuck together 
----------------------------------------

def __init__(self, parent) :
INDENT
    self.top_left_label = Label(parent, text = "Top Left")
    self.top_left_label.grid(row = 0, column = 0, padx = 2, pady = 2, sticky = N + S + W)
    self.top_right_label = Label(parent, text = "Top Right")
    self.top_right_label.grid(row = 0, column = 1, padx = 2, pady = 2, sticky = N + S + E)
    self.text_box = Text(parent, height = 5, width = 40)
    self.text_box.grid(row = 1, column = 0, columnspan = 2)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    self.myParent = parent
    self.main_container = Frame(parent, bg = "green")
    self.main_container.grid()
    self.top_frame = Frame(self.main_container)
    self.top_frame.grid()
    self.top_left = Frame(self.top_frame, bd = 2)
    self.top_left.grid(row = 0, column = 0)
    self.top_right = Frame(self.top_frame, bd = 2)
    self.top_right.grid(row = 0, column = 2)
    self.top_left_label = Label(self.top_left, bd = 2, bg = "red", text = "Top Left", width = 22, anchor = W)
    self.top_left_label.grid(row = 0, column = 0)
    self.top_right_label = Label(self.top_right, bd = 2, bg = "blue", text = "Top Right", width = 22, anchor = E)
    self.top_right_label.grid(row = 0, column = 0)
    self.bottom_frame = Frame(self.main_container, bd = 2)
    self.bottom_frame.grid(row = 2, column = 0)
    self.text_box = Text(self.bottom_frame, width = 40, height = 5)
    self.text_box.grid(row = 0, column = 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1500718_15774013_15_22
1500718_40484215_2_11
Title: What is the right way to override the copy/deepcopy operations on an object in Python? 
----------------------------------------

def __deepcopy__(self, memo) :
INDENT
    cls = self.__class__
    result = cls.__new__(cls)
    memo [id(self)] = result
    for k, v in self.__dict__.items() :
    INDENT
        setattr(result, k, deepcopy(v, memo))
    DEDENT
    return result
DEDENT
----------------------------------------

def __deepcopy__(self, memo) :
INDENT
    deepcopy_method = self.__deepcopy__
    self.__deepcopy__ = None
    cp = deepcopy(self, memo)
    self.__deepcopy__ = deepcopy_method

    return cp
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1500718_40484215_2_11
1500718_48550898_13_20
Title: What is the right way to override the copy/deepcopy operations on an object in Python? 
----------------------------------------

def __deepcopy__(self, memo) :
INDENT
    deepcopy_method = self.__deepcopy__
    self.__deepcopy__ = None
    cp = deepcopy(self, memo)
    self.__deepcopy__ = deepcopy_method

    return cp
DEDENT
----------------------------------------

def __deepcopy__(self, memo) :
INDENT
    cls = self.__class__
    result = cls.__new__(cls)
    memo [id(self)] = result
    for k, v in self.__dict__.items() :
    INDENT
        setattr(result, k, copy.deepcopy(v, memo))
    DEDENT
    super(Foo, result).__init__(* self._base_params)
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1503072_1503075_1_20
1503072_1503598_1_19
Title: How to check if permutations have equal parity? 
----------------------------------------

def arePermsEqualParity(perm0, perm1) :
INDENT
    transCount = 0
    for loc in range(len(perm0) - 1) :
    INDENT
        if perm0 [loc] ! = perm1 [loc] :
        INDENT
            sloc = perm1.index(perm0 [loc])
            perm1 [loc], perm1 [sloc] = perm1 [sloc], perm1 [loc]
            transCount += 1

        DEDENT
    DEDENT
    if (transCount % 2) == 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def arePermsEqualParity(perm0, perm1) :
INDENT
    perm1 = list(perm1)
    perm1_map = dict((v, i) for i, v in enumerate(perm1))
    transCount = 0
    for loc, p0 in enumerate(perm0) :
    INDENT
        p1 = perm1 [loc]
        if p0 ! = p1 :
        INDENT
            sloc = perm1_map [p0]
            perm1 [loc], perm1 [sloc] = p0, p1
            perm1_map [p0], perm1_map [p1] = sloc, loc
            transCount += 1
        DEDENT
    DEDENT
    return (transCount % 2) == 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1503072_1503075_1_20
1503072_4215652_1_19
Title: How to check if permutations have equal parity? 
----------------------------------------

def arePermsEqualParity(perm0, perm1) :
INDENT
    transCount = 0
    for loc in range(len(perm0) - 1) :
    INDENT
        if perm0 [loc] ! = perm1 [loc] :
        INDENT
            sloc = perm1.index(perm0 [loc])
            perm1 [loc], perm1 [sloc] = perm1 [sloc], perm1 [loc]
            transCount += 1

        DEDENT
    DEDENT
    if (transCount % 2) == 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def arePermsEqualParity(perm0, perm1) :
INDENT
    perm1 = list(perm1)
    perm1_map = dict((v, i) for i, v in enumerate(perm1))
    transCount = 0
    for loc, p0 in enumerate(perm0) :
    INDENT
        p1 = perm1 [loc]
        if p0 ! = p1 :
        INDENT
            sloc = perm1_map [p0]
            perm1 [loc], perm1 [sloc] = p0, p1
            perm1_map [p0], perm1_map [p1] = loc, sloc
            transCount += 1
        DEDENT
    DEDENT
    return (transCount % 2) == 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1503072_1503144_1_23
1503072_1503598_1_19
Title: How to check if permutations have equal parity? 
----------------------------------------

def arePermsEqualParity(perm0, perm1) :
INDENT
    perm1 = perm1 [:]
    transCount = 0
    for loc in range(len(perm0) - 1) :
    INDENT
        p0 = perm0 [loc]
        p1 = perm1 [loc]
        if p0 ! = p1 :
        INDENT
            sloc = perm1 [loc :].index(p0) + loc
            perm1 [loc], perm1 [sloc] = p0, p1
            transCount += 1

        DEDENT
    DEDENT
    if (transCount % 2) == 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def arePermsEqualParity(perm0, perm1) :
INDENT
    perm1 = list(perm1)
    perm1_map = dict((v, i) for i, v in enumerate(perm1))
    transCount = 0
    for loc, p0 in enumerate(perm0) :
    INDENT
        p1 = perm1 [loc]
        if p0 ! = p1 :
        INDENT
            sloc = perm1_map [p0]
            perm1 [loc], perm1 [sloc] = p0, p1
            perm1_map [p0], perm1_map [p1] = sloc, loc
            transCount += 1
        DEDENT
    DEDENT
    return (transCount % 2) == 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1503072_1503144_1_23
1503072_4215652_1_19
Title: How to check if permutations have equal parity? 
----------------------------------------

def arePermsEqualParity(perm0, perm1) :
INDENT
    perm1 = perm1 [:]
    transCount = 0
    for loc in range(len(perm0) - 1) :
    INDENT
        p0 = perm0 [loc]
        p1 = perm1 [loc]
        if p0 ! = p1 :
        INDENT
            sloc = perm1 [loc :].index(p0) + loc
            perm1 [loc], perm1 [sloc] = p0, p1
            transCount += 1

        DEDENT
    DEDENT
    if (transCount % 2) == 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def arePermsEqualParity(perm0, perm1) :
INDENT
    perm1 = list(perm1)
    perm1_map = dict((v, i) for i, v in enumerate(perm1))
    transCount = 0
    for loc, p0 in enumerate(perm0) :
    INDENT
        p1 = perm1 [loc]
        if p0 ! = p1 :
        INDENT
            sloc = perm1_map [p0]
            perm1 [loc], perm1 [sloc] = p0, p1
            perm1_map [p0], perm1_map [p1] = loc, sloc
            transCount += 1
        DEDENT
    DEDENT
    return (transCount % 2) == 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15052704_15052850_1_10
15052704_15054217_1_11
Title: How to create a counter inside a recursive function 
----------------------------------------

def towers(n, source, destination, spare, count = 0) :
INDENT
    if n == 1 :
    INDENT
        count += 1
        print ('move From', source, ' to destination ', destination, count)
    DEDENT
    else :
    INDENT
        count = towers(n - 1, source, spare, destination, count)
        count = towers(1, source, destination, spare, count)
        count = towers(n - 1, spare, destination, source, count)
    DEDENT
    return count
DEDENT
----------------------------------------

def towers(n, source, destination, spare) :
INDENT
    count = 0
    if n == 1 :
    INDENT
        print ('move From', source, ' to destination ', destination)
        return 1
    DEDENT
    else :
    INDENT
        count += towers(n - 1, source, spare, destination)
        count += towers(1, source, destination, spare)
        count += towers(n - 1, spare, destination, source)
        return count
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15053160_15053216_1_11
15053160_15053533_1_18
Title: Loop keeps going after being carried out 
----------------------------------------

def Help(string) :
INDENT
    if string == 'Manifest' :
    INDENT
        return Manifest()
    DEDENT
    elif string == 'Intent' :
    INDENT
        return Intent()
    DEDENT
    else :
    INDENT
        print ('The options available are:\n%s\nType Q to Quit\n' % '\n'.join(andHelp))
        x = input('What option do you choose: ')
        print ('\n')
        if x ! = 'Q' :
        INDENT
            Help(x)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def Help(string) :
INDENT
    validOptions = ('Manifest', 'Intent', 'Q')
    while string not in validOptions :
    INDENT
        print ('The options available are: \n')
        for i in andHelp :
        INDENT
            print (i)
        DEDENT
        print ('Type Q to Quit \n')
        string = input('What option do you choose: ')
        print ('\n')
    DEDENT
    if string == 'Manifest' :
    INDENT
        return Manifest()
    DEDENT
    elif string == 'Intent' :
    INDENT
        return Intent()
    DEDENT
    elif string == 'Q' :
    INDENT
        return
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15054674_15054837_4_14
15054674_15057599_6_16
Title: Create a two dimensional list 
----------------------------------------

def main() :
INDENT
    student_grades = {}
    for c in range(COLS) :
    INDENT
        student = (input("enter student ID number "))
        grades = []
        for r in range(ROWS) :
        INDENT
            grade = (input("Enter grade for module: "))
            grades.append(grade)
        DEDENT
        student_grades [student] = grades
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    for c in range(COLS) :
    INDENT
        student = int(input("enter student ID: "))
        grades [student] = []
        for r in range(ROWS) :
        INDENT
            grade = int(input("Enter grade for module: "))
            grades [student].append(grade)
        DEDENT
    DEDENT
    for student in grades.keys() :
    INDENT
        print 'student:{}, grades:{}'.format(student, grades [student])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15057700_15058305_1_13
15057700_15058560_1_13
Title: Black to Red fade on ppm using python 
----------------------------------------

def main() :
INDENT
    with open("testImage.ppm", "wb") as f :
    INDENT
        f.write("P3\n")
        width = 256
        height = 256
        f.write("%d %d\n" % (width, height))
        f.write("255\n")
        delta_red = 256./ width
        row = ' '.join('{} {} {}'.format(int(i * delta_red), 0, 0) for i in xrange(width)) + '\n'
        for _ in xrange(height) :
        INDENT
            f.write(row)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    f = open("testImage.ppm", "w")
    f.write("P3 \n")
    width = 256
    height = 256
    f.write("%d %d \n" % (width, height))
    f.write("255 \n")
    for i in range(width * height) :
    INDENT
        x = i % 256
        y = i / 256
        f.write("%s, 0, 0 \n" % x)
    DEDENT
    f.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15061702_15061754_1_10
15061702_15061808_1_12
Title: Scrapy - Crawl and Scrape a website 
----------------------------------------

def parse_items_1(self, response) :
INDENT
    hxs = HtmlXPathSelector(response)
    titles = hxs.select('//h3')
    for title in titles :
    INDENT
        item = AmazeItem()
        item ["title"] = title.select('.//a[@class="title"]/text()').extract()
        item ["link"] = title.select('.//a[@class="title"]/@href').extract()
        yield item
    DEDENT
DEDENT
----------------------------------------

def parse_items_1(self, response) :
INDENT
    items = []
    print ('*** response:', response.url)
    hxs = HtmlXPathSelector(response)
    titles = hxs.select('//h3')
    for title in titles :
    INDENT
        item = AmazeItem()
        item ["title"] = title.select('.//a[@class="title"]/text()').extract()
        item ["link"] = title.select('.//a[@class="title"]/@href').extract()
        print ('**parse-items_1:', item ["title"], item ["link"])
        items.append(item)
    DEDENT
    return items
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15062844_15062966_3_12
15062844_15063261_3_14
Title: Maximum sum sublist? 
----------------------------------------

def mssl(lst, return_sublist = False) :
INDENT
    d = defaultdict(list)
    for i in range(len(lst) + 1) :
    INDENT
        for j in range(len(lst) + 1) :
        INDENT
            d [sum(lst [i : j])].append(lst [i : j])
        DEDENT
    DEDENT
    key = max(d.keys())
    if return_sublist :
    INDENT
        return (key, d [key])
    DEDENT
    return key
DEDENT
----------------------------------------

def mssl(lst, return_sublist = False) :
INDENT
    partsum = {(0, 0) : 0}
    for i in xrange(len(lst) - 1) :
    INDENT
        last = partsum [i, i + 1] = lst [i]
        for j in xrange(i + 1, len(lst)) :
        INDENT
            last = partsum [i, j + 1] = last + lst [j]
        DEDENT
    DEDENT
    if return_sublist :
    INDENT
        (i, j), sum = max(partsum.iteritems(), key = operator.itemgetter(1))
        return sum, lst [i : j]
    DEDENT
    return max(partsum.itervalues())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15062844_15062966_3_12
15062844_15063394_1_12
Title: Maximum sum sublist? 
----------------------------------------

def mssl(lst, return_sublist = False) :
INDENT
    d = defaultdict(list)
    for i in range(len(lst) + 1) :
    INDENT
        for j in range(len(lst) + 1) :
        INDENT
            d [sum(lst [i : j])].append(lst [i : j])
        DEDENT
    DEDENT
    key = max(d.keys())
    if return_sublist :
    INDENT
        return (key, d [key])
    DEDENT
    return key
DEDENT
----------------------------------------

def mssl(l) :
INDENT
    best = cur = 0
    curi = starti = besti = 0
    for ind, i in enumerate(l) :
    INDENT
        if cur + i > 0 :
        INDENT
            cur += i
        DEDENT
        else :
        INDENT
            cur, curi = 0, ind + 1
        DEDENT
        if cur > best :
        INDENT
            starti, besti, best = curi, ind + 1, cur
        DEDENT
    DEDENT
    return starti, besti, best
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15062844_15063261_3_14
15062844_15063394_1_12
Title: Maximum sum sublist? 
----------------------------------------

def mssl(lst, return_sublist = False) :
INDENT
    partsum = {(0, 0) : 0}
    for i in xrange(len(lst) - 1) :
    INDENT
        last = partsum [i, i + 1] = lst [i]
        for j in xrange(i + 1, len(lst)) :
        INDENT
            last = partsum [i, j + 1] = last + lst [j]
        DEDENT
    DEDENT
    if return_sublist :
    INDENT
        (i, j), sum = max(partsum.iteritems(), key = operator.itemgetter(1))
        return sum, lst [i : j]
    DEDENT
    return max(partsum.itervalues())
DEDENT
----------------------------------------

def mssl(l) :
INDENT
    best = cur = 0
    curi = starti = besti = 0
    for ind, i in enumerate(l) :
    INDENT
        if cur + i > 0 :
        INDENT
            cur += i
        DEDENT
        else :
        INDENT
            cur, curi = 0, ind + 1
        DEDENT
        if cur > best :
        INDENT
            starti, besti, best = curi, ind + 1, cur
        DEDENT
    DEDENT
    return starti, besti, best
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15148995_15149100_1_6
15148995_15149360_5_12
Title: The sum of all Fibonacci numbers up to a million 
----------------------------------------

def fib() :
INDENT
    x, y = 0, 1
    while True :
    INDENT
        yield x
        x, y = y, x + y
    DEDENT
DEDENT
----------------------------------------

def fib(list_of_numbers) :
INDENT
    x, y = 0, 1
    while x + y < = 4000000 :
    INDENT
        list_of_numbers.append(y)
        x, y = y, x + y
    DEDENT
    return list_of_numbers
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15148995_15149100_7_11
15148995_15149360_13_22
Title: The sum of all Fibonacci numbers up to a million 
----------------------------------------

def even(seq) :
INDENT
    for number in seq :
    INDENT
        if not number % 2 :
        INDENT
            yield number
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def even(list_of_numbers, even_fibs) :
INDENT
    coord = 0
    for number in range(len(list_of_numbers)) :
    INDENT
        test_number = list_of_numbers [coord]
        if (test_number % 2) == 0 :
        INDENT
            even_fibs.append(test_number)
        DEDENT
        coord += 1
    DEDENT
    return even_fibs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1517862_1517965_9_14
1517862_1517967_16_26
Title: Using lookahead with generators 
----------------------------------------

def next(self) :
INDENT
    if self.buffer :
    INDENT
        return self.buffer.pop(0)
    DEDENT
    else :
    INDENT
        return self.iter.next()
    DEDENT
DEDENT
----------------------------------------

def next(self) :
INDENT
    if not self.stopped :
    INDENT
        try :
        INDENT
            self.lookahead.append(self.gen.next())
        DEDENT
        except StopIteration :
        INDENT
            self.stopped = True
        DEDENT
    DEDENT
    if self.lookahead ! = [] :
    INDENT
        return self.lookahead.pop(0)
    DEDENT
    else :
    INDENT
        raise StopIteration
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15192899_15193034_1_13
15192899_15193671_1_12
Title: Python: Looking for the same word in a file? 
----------------------------------------

def duplicate(fname) :
INDENT
    infile = open(fname, 'r')
    for line in infile.readlines() :
    INDENT
        for a in line.split(' ') :
        INDENT
            line = line.replace(a, "", 1)
            if a in line :
            INDENT
                return True

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def duplicate(fname) :
INDENT
    '(file.txt) ==> (Boolean) Returns True if there are duplicate words'
    infile = open(fname, 'r')
    fLines = []
    for line in infile :
    INDENT
        l = line.split(' ')
        fLines += [i.lower().rstrip('\n') for i in l]
    DEDENT
    infile.close()
    nLines = list(set(fLines))
    for l in nLines :
    INDENT
        if fLines.count(l) > 1 : return True
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15195816_15195942_1_9
15195816_15196486_1_30
Title: guess the word game in python - how to mask a word (eg. ------) 
----------------------------------------

def maskWord(state, word, guess) :
INDENT
    state = list(state)
    for i in range(len(word)) :
    INDENT
        if word [i] == guess :
        INDENT
            state [i] = guess
        DEDENT
    DEDENT
    return "".join(state)

DEDENT
----------------------------------------

def maskWord(state, word, guess) :
INDENT
    result = ''
    guessed = []
    character = ''
    for character in state :
    INDENT
        if not character == '-' :
        INDENT
            if not character in guessed :
            INDENT
                guessed.append(character)
            DEDENT
        DEDENT
    DEDENT
    if not guess in guessed :
    INDENT
        guessed.append(guess)
    DEDENT
    for guess in word :
    INDENT
        if guess in guessed :
        INDENT
            result += guess
        DEDENT
        else :
        INDENT
            result += "-"

        DEDENT
    DEDENT
    if False :
    INDENT
        print 'state %s' % state
        print 'word %s' % word
        print 'guess %s' % guess
        print guessed
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15211279_15211717_18_71
15211279_15211717_5_15
Title: How to make tabbing between fields work in a Frame in wxPython 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (1000, 900))
    self.CreateStatusBar()
    self.buttons = []
    filemenu = wx.Menu()
    helpmenu = wx.Menu()
    menuOpen = filemenu.Append(wx.ID_OPEN, "&Open", "Open a file to edit")
    menuSave = filemenu.Append(wx.ID_SAVE, "&Save", "Save the current file")
    menuSaveAs = filemenu.Append(wx.ID_SAVEAS, "&Save As", "Save the current file as")
    menuExit = filemenu.Append(wx.ID_EXIT, "E&xit", "Terminate the program")
    menuAbout = helpmenu.Append(wx.ID_ABOUT, "&About", "Information about this program,")
    menuBar = wx.MenuBar()
    menuBar.Append(filemenu, "&File")
    menuBar.Append(helpmenu, "&Help")
    self.SetMenuBar(menuBar)
    self.openFiles = {}

    self.p = wx.Panel(self)
    self.nb = wx.Notebook(self.p)
    self.newTab = tab(self.nb)
    self.nb.AddPage(self.newTab, "New Tab")
    self.sizer = wx.BoxSizer()
    self.sizer.Add(self.nb, 1, wx.EXPAND)
    self.p.SetSizer(self.sizer)

    saveid = wx.NewId()
    openid = wx.NewId()
    boldid = wx.NewId()

    self.Bind(wx.EVT_MENU, self.OnAbout, menuAbout)
    self.Bind(wx.EVT_MENU, self.OnExit, menuExit)
    self.Bind(wx.EVT_MENU, self.OnOpen, menuOpen)
    self.Bind(wx.EVT_MENU, self.OnSave, menuSave)
    self.Bind(wx.EVT_MENU, self.OnSave, menuSaveAs)
    self.Bind(wx.EVT_MENU, self.OnSave, id = saveid)
    self.Bind(wx.EVT_MENU, self.OnOpen, id = openid)
    self.Bind(wx.EVT_MENU, self.OnBold, id = boldid)
    self.accel_tbl = wx.AcceleratorTable([(wx.ACCEL_CTRL, ord('S'), saveid),
            (wx.ACCEL_CTRL, ord('O'), openid),
            (wx.ACCEL_CTRL, ord('B'), boldid)])
    self.SetAcceleratorTable(self.accel_tbl)
    self.Show(True)
DEDENT
----------------------------------------

def __init__(self, parent, newid = 0, name = "New Tab", file = None, aNewTab = False) :
INDENT
    wx.Panel.__init__(self, parent)
    self.control = wx.TextCtrl(self, style = wx.TE_MULTILINE)
    sizer = wx.BoxSizer()
    sizer.Add(self.control, - 1, wx.EXPAND, newid)
    self.SetSizer(sizer)
    if file ! = None :
    INDENT
        self.control.write(file)
    DEDENT
    else :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15211417_15211745_36_44
15211417_15211745_46_53
Title: menu tk in python 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame(PageOne))
    button1.pack()

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "This is page 1", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame(StartPage))
    button.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15211417_15211745_36_44
15211417_15211745_7_29
Title: menu tk in python 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame(PageOne))
    button1.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    menubar = tk.Menu(self)
    file_menu = tk.Menu(menubar)
    file_menu.add_command(label = 'Quit', command = sys.exit)
    menubar.add_cascade(label = 'File', menu = file_menu)
    self.config(menu = menubar)
    self.frames = {}
    for F in (StartPage, PageOne,
        ) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15211417_15211745_46_53
15211417_15211745_7_29
Title: menu tk in python 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "This is page 1", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame(StartPage))
    button.pack()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    menubar = tk.Menu(self)
    file_menu = tk.Menu(menubar)
    file_menu.add_command(label = 'Quit', command = sys.exit)
    menubar.add_cascade(label = 'File', menu = file_menu)
    self.config(menu = menubar)
    self.frames = {}
    for F in (StartPage, PageOne,
        ) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15214852_15214896_1_10
15214852_15233706_2_10
Title: depth of a tree python 
----------------------------------------

def depth(self) :
INDENT
    current_depth = 0
    if self.left :
    INDENT
        current_depth = max(current_depth, self.left.depth())
    DEDENT
    if self.right :
    INDENT
        current_depth = max(current_depth, self.right.depth())
    DEDENT
    return current_depth + 1
DEDENT
----------------------------------------

def depth(self) :
INDENT
    if self.left == None and self.right == None :
    INDENT
        return 1
    DEDENT
    elif self.left == None :
    INDENT
        return self.right.depth() + 1
    DEDENT
    elif self.right == None :
    INDENT
        return self.left.depth() + 1
    DEDENT
    else :
    INDENT
        return max(self.left.depth(), self.right.depth()) + 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15253529_15253626_17_25
15253529_15253626_2_9
Title: 8 tile solver with repeated nodes - Python 
----------------------------------------

def __init__(self, board, parent) :
INDENT
    self.state = board
    self.parent = parent
    if not parent :
    INDENT
        self.g = 0
    DEDENT
    else :
    INDENT
        self.g = parent.g + 1
    DEDENT
    self.h = heuristic(board)
DEDENT
----------------------------------------

def __init__(self, matrix, whitepos = None) :
INDENT
    self.matrix = matrix
    self.whitepos = whitepos
    if not whitepos :
    INDENT
        for y in xrange(3) :
        INDENT
            for x in xrange(3) :
            INDENT
                if board [y] [x] == 0 :
                INDENT
                    self.whitepos = (x, y)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15258801_15258864_1_15
15258801_15259511_1_12
Title: How to find out what my unhandled exception is 
----------------------------------------

def draw() :
INDENT
    try :
    INDENT
        while True :
        INDENT
            for x in range(0, 10) :
            INDENT
                for y in range(0, 10) :
                INDENT
                    if (coord [i] [j] == 0) :
                    INDENT
                        canvas.create_rectangle((x * 40) + 10, (y * 40) + 10, (x * 40) + 50, (y * 40) + 50, fill = "white")
                    DEDENT
                    if (coord [i] [j] == 1) :
                    INDENT
                        canvas.create_rectangle((x * 40) + 10, (y * 40) + 10, (x * 40) + 50, (y * 40) + 50, fill = "red")
                    DEDENT
                    if (coord [i] [j] == 2) :
                    INDENT
                        canvas.create_rectangle((x * 40) + 10, (y * 40) + 10, (x * 40) + 50, (y * 40) + 50, fill = "darkorange")
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
        time.sleep(0.03)
    DEDENT
    except Exception as e :
    INDENT
        print (e)
        raise
    DEDENT
DEDENT
----------------------------------------

def draw() :
INDENT
    for x in range(0, 10) :
    INDENT
        for y in range(0, 10) :
        INDENT
            item = canvas.create_rectangle((x * 40) + 10, (y * 40) + 10,
                (x * 40) + 50, (y * 40) + 50)
            if (coord [i] [j] == 0) :
            INDENT
                canvas.itemconfig(item, fill = "white")
            DEDENT
            if (coord [i] [j] == 1) :
            INDENT
                canvas.itemconfig(item, fill = "red")
            DEDENT
            if (coord [i] [j] == 2) :
            INDENT
                canvas.itemconfig(item, fill = "darkorange")
            DEDENT
        DEDENT
    DEDENT
    canvas.after(30, draw)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15263789_15264548_1_16
15263789_15265526_1_20
Title: Using extend correctly? 
----------------------------------------

def leaves_and_internals(self) :
INDENT
    if not self.left and not self.right :
    INDENT
        return ([], [self.item])
    DEDENT
    if self.left is not None :
    INDENT
        if self.right is not None :
        INDENT
            return tuple(map(operator.add, ([self.item], []), self.right.leaves_and_internals()))
        DEDENT
        return tuple(map(operator.add, ([self.item], []), self.left.leaves_and_internals()))
    DEDENT
    elif self.right is not None :
    INDENT
        return tuple(map(operator.add, ([self.item], []), self.right.leaves_and_internals()))
    DEDENT
DEDENT
----------------------------------------

def leaves_and_internals(self) :
INDENT
    leaves = []
    internals = []
    if self.left or self.right :
    INDENT
        internals.append(self.item)
    DEDENT
    else :
    INDENT
        leaves.append(self.item)
    DEDENT
    if self.left :
    INDENT
        sub_leaves, sub_internals = self.left.leaves_and_internals()
        leaves.extend(sub_leaves)
        internals.extend(sub_internals)
    DEDENT
    if self.right :
    INDENT
        sub_leaves, sub_internals = self.right.leaves_and_internals()
        leaves.extend(sub_leaves)
        internals.extend(sub_internals)
    DEDENT
    return leaves, internals
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15288824_15289497_23_29
15288824_15292222_8_14
Title: python - struggling with designing this 
----------------------------------------

def connectTo(self, link) :
INDENT
    if isinstance(link, Link) :
    INDENT
        self.linkedTo = link
    DEDENT
    else :
    INDENT
        raise TypeError
    DEDENT
DEDENT
----------------------------------------

def connectTo(self, other) :
INDENT
    if self.right or other.left :
    INDENT
        raise ValueError("Links already have connections")
    DEDENT
    self.right = other
    other.left = self
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15307531_15312689_4_17
15307531_15313248_2_24
Title: Getting Input from Radiobutton 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.type_integration = None
    self.typeChoice = tk.StringVar()
    self.typeChoice.set(None)
    self.typeFrame = tk.Frame(master)
    OPTIONS = [('Left Rectangular', 'l'),
        ('Right Rectangular', 'r'),
        ('Trapezoidal', 't'),
        ('Simpsons Rule', 's')]
    for text, value in OPTIONS :
    INDENT
        tk.Radiobutton(self.typeFrame, text = text, variable = self.typeChoice, value = value).pack()
    DEDENT
    tk.Button(self.typeFrame, text = "Exit", command = self.exit).pack()
    self.typeFrame.pack()
DEDENT
----------------------------------------

def __init__(self, master, window, items) :
INDENT
    self.window = window
    self.items = items
    self.runProgram = True
    self.frame = tk.Frame(master)
    self.typeFrame = tk.Frame(self.frame)
    self.typeChoice = tk.StringVar(self.typeFrame)
    self.quitButton = tk.Button(self.frame, text = 'Quit', command = self.frame.quit)
    self.optLabel = tk.Label(self.frame, text = 'Type of Approximation: ')
    self.optL = tk.Radiobutton(self.typeFrame, text = 'Left Rectangular', variable = self.typeChoice, value = 'l')
    self.optR = tk.Radiobutton(self.typeFrame, text = 'Right Rectangular', variable = self.typeChoice, value = 'r')
    self.optT = tk.Radiobutton(self.typeFrame, text = 'Trapezoidal', variable = self.typeChoice, value = 't')
    self.optS = tk.Radiobutton(self.typeFrame, text = 'Simpsons Rule', variable = self.typeChoice, value = 's')
    self.optL.grid(row = 1, column = 1, padx = 5, pady = 5)
    self.optR.grid(row = 1, column = 2, padx = 5, pady = 5)
    self.optT.grid(row = 2, column = 1, padx = 5, pady = 5)
    self.optS.grid(row = 2, column = 2, padx = 5, pady = 5)
    self.optLabel.grid(row = 4)
    self.typeFrame.grid(row = 5)
    self.quitButton.grid(row = 6)
    self.frame.grid()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15323574_15323917_10_20
15323574_15374078_15_30
Title: How to connect a progress bar to a function? 
----------------------------------------

def __init__(self) :
INDENT
    tk.Tk.__init__(self)
    self.queue = queue.Queue()
    self.listbox = tk.Listbox(self, width = 20, height = 5)
    self.progressbar = ttk.Progressbar(self, orient = 'horizontal',
        length = 300, mode = 'determinate')
    self.button = tk.Button(self, text = "Start", command = self.spawnthread)
    self.listbox.pack(padx = 10, pady = 10)
    self.progressbar.pack(padx = 10, pady = 10)
    self.button.pack(padx = 10, pady = 10)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = tkinter.Tk()
    self.int_var = tkinter.IntVar()
    progbar = ttk.Progressbar(self.root, maximum = 4)
    progbar ['variable'] = self.int_var
    progbar.pack()
    self.label = ttk.Label(self.root, text = '0/4')
    self.label.pack()
    self.b_start = ttk.Button(self.root, text = 'Start')
    self.b_start ['command'] = self.start_thread
    self.b_start.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15328632_30418975_6_13
15328632_33490429_11_31
Title: Dynamically limiting queryset of related field 
----------------------------------------

def get_queryset(self) :
INDENT
    if self.custom_query and callable(self.custom_query) :
    INDENT
        qry = self.custom_query()(self)
    DEDENT
    else :
    INDENT
        qry = super(CustomQueryHyperlinkedRelatedField, self).get_queryset()
    DEDENT
    return qry
DEDENT
----------------------------------------

def get_queryset(self) :
INDENT
    queryset = self.queryset
    if hasattr(queryset, '__call__') :
    INDENT
        queryset = queryset(self)
    DEDENT
    if isinstance(queryset, (QuerySet, Manager)) :
    INDENT

        queryset = queryset.all()
    DEDENT
    return queryset

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15400008_15400456_25_42
15400008_15400669_1_16
Title: python pig latin converter 
----------------------------------------

def convert_file(fileName) :
INDENT
    inputFile = open(fileName, 'r')
    converted_lines = []
    for line in inputFile :
    INDENT
        line, punctuation = strip_punctuation(line)
        line = line.split()
        new_words = []
        for word in line :
        INDENT
            endString = str(word [1 :])
            them = endString, str(word [0 : 1]), 'ay'
            new_word = "".join(them)
            new_words.append(new_word)
        DEDENT
        new_sentence = ' '.join(new_words)
        new_sentence = new_sentence.lower()
        if len(new_sentence) :
        INDENT
            new_sentence = new_sentence [0].upper() + new_sentence [1 :]
        DEDENT
        converted_lines.append(new_sentence + punctuation)
    DEDENT
    return converted_lines
DEDENT
----------------------------------------

def convert_file(fileName) :
INDENT
    inputFile = open(fileName, 'r')
    punctuations = ['.', ',', '!', '?', ':', ';']
    newWords = []
    linenum = 1
    for line in inputFile :
    INDENT
        line_string = line.split()
        for word in line_string :
        INDENT
            endString = str(word [1]).upper() + str(word [2 :])
            them = endString, str(word [0 : 1]).lower(), 'ay'
            word = ''.join(them)
            wordAndline = [word, linenum]
            newWords.append(wordAndline)
        DEDENT
        linenum += 1
    DEDENT
    return newWords
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15424895_23531792_4_12
15424895_34582593_4_20
Title: Creating Lexicon and Scanner in Python 
----------------------------------------

def scan(self, sentence) :
INDENT
    self.sentence = sentence
    self.words = sentence.split()
    stuff = []
    for word in self.words :
    INDENT
        if word in direction :
        INDENT
            stuff.append(('direction', word))
        DEDENT
    DEDENT
    return stuff
DEDENT
----------------------------------------

def scan() :
INDENT
    stuff = raw_input('> ')
    words = stuff.split()
    pairs = []
    for word in words :
    INDENT
        if word in lexicon [0] :
        INDENT
            pairs.append(('direction', word))
        DEDENT
        elif word in lexicon [1] :
        INDENT
            pairs.append(('verb', word))
        DEDENT
        elif word in lexicon [2] :
        INDENT
            pairs.append(('nouns', word))
        DEDENT
        else :
        INDENT
            pairs.append(('error', word))
        DEDENT
    DEDENT
    print pairs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15439582_15439934_28_37
15439582_15439934_5_13
Title: "Python: Given 2 processes A and B call a function in A from B" 
----------------------------------------

def __init__(self) :
INDENT
    multiprocessing.Process.__init__(self)
    class MyManager(BaseManager) :
    INDENT
        pass
    DEDENT
    MyManager.register('Maths')
    self.m = MyManager(address = ('', 50000), authkey = 'abracadabra')

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    multiprocessing.Process.__init__(self)
    class MathsClass(object) :
    INDENT
        def add(innerSelf, x, y) :
        INDENT
            return ManagerServer.addOuter(self, x, y)
        DEDENT
        def mul(innerSelf, x, y) :
        INDENT
            return x * y
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15447382_15447415_2_12
15447382_15447546_3_16
Title: How can I write this solution more efficiently? 
----------------------------------------

def f(random = random.random) :
INDENT
    a = [int(1000 * random()) for i in xrange(10)]
    b = [int(1000 * random()) for i in xrange(10)]
    c = [int(1000 * random()) for i in xrange(10)]
    d = {}
    for i in xrange(len(a)) :
    INDENT
        for j in xrange(len(b) - i) :
        INDENT
            k = 10 - i - j
            if 0 < = k < 10 :
            INDENT
                d [i, j, k] = a [i] + b [j] + c [k]
            DEDENT
        DEDENT
    DEDENT
    return max(d.values())
DEDENT
----------------------------------------

def f() :
INDENT
    rand = random.random
    a = [int(1000 * rand()) for _ in xrange(10)]
    b = [int(1000 * rand()) for _ in xrange(10)]
    c = [int(1000 * rand()) for _ in xrange(10)]
    d = dict()
    for i in xrange(10) :
    INDENT
        for j in xrange(10 - i) :
        INDENT
            k = 10 - i - j
            if 0 < = k < 10 :
            INDENT
                d [(i, j, k)] = a [i] + b [j] + c [k]
            DEDENT
        DEDENT
    DEDENT
    print max(d.values())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15464386_15464665_21_28
15464386_15464665_4_12
Title: how to pass values to popup command on right click in python tkinter 
----------------------------------------

def __init__(self, master, a, b) :
INDENT
    Menu.__init__(self, master, tearoff = 0)
    self.a = a
    self.b = b
    self.add_command(label = "Next", command = self.next)
    self.add_command(label = "Previous")
    self.add_separator()
    self.add_command(label = "Home")
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Tk.__init__(self)
    self.a = 1
    self.b = 2
    self.label = Label(self, text = "Right-click to display menu", width = 40, height = 20)
    self.button = Button(self, text = "Quit", command = self.destroy)
    self.label.bind("<Button-3>", self.do_popup)
    self.label.pack()
    self.button.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15464386_15464665_21_28
15464386_32006375_4_17
Title: how to pass values to popup command on right click in python tkinter 
----------------------------------------

def __init__(self, master, a, b) :
INDENT
    Menu.__init__(self, master, tearoff = 0)
    self.a = a
    self.b = b
    self.add_command(label = "Next", command = self.next)
    self.add_command(label = "Previous")
    self.add_separator()
    self.add_command(label = "Home")
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Tk.__init__(self)
    self.a = 1
    self.b = 2
    self.menu = Popup(self)
    self.label = Label(self, text = "Right-click to display menu",
        width = 40, height = 20)
    self.button = Button(self, text = "Quit", command = self.destroy)
    self.label.bind("<Button-3>",
        lambda e : self.menu.popup(e.x_root, e.y_root,
            self.a, self.b))
    self.label.pack()
    self.button.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15464386_15464665_4_12
15464386_32006375_4_17
Title: how to pass values to popup command on right click in python tkinter 
----------------------------------------

def __init__(self) :
INDENT
    Tk.__init__(self)
    self.a = 1
    self.b = 2
    self.label = Label(self, text = "Right-click to display menu", width = 40, height = 20)
    self.button = Button(self, text = "Quit", command = self.destroy)
    self.label.bind("<Button-3>", self.do_popup)
    self.label.pack()
    self.button.pack()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Tk.__init__(self)
    self.a = 1
    self.b = 2
    self.menu = Popup(self)
    self.label = Label(self, text = "Right-click to display menu",
        width = 40, height = 20)
    self.button = Button(self, text = "Quit", command = self.destroy)
    self.label.bind("<Button-3>",
        lambda e : self.menu.popup(e.x_root, e.y_root,
            self.a, self.b))
    self.label.pack()
    self.button.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15465901_15466102_1_10
15465901_15466272_4_17
Title: How to end a list in python? 
----------------------------------------

def coin_change(avail_change, total_cents) :
INDENT
    if not avail_change :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        first = total_cents / / avail_change [0]
        result = coin_change(avail_change [1 :], (total_cents % avail_change [0]))
        if first > 0 :
        INDENT
            result.insert(0, [avail_change [0], first])
        DEDENT
        return result
    DEDENT
DEDENT
----------------------------------------

def coin_change(avail_change, total_cents) :
INDENT
    if not avail_change :
    INDENT
        return []
    DEDENT
    if total_cents / / avail_change [0] > = 1 :
    INDENT
        first = total_cents / / avail_change [0]
        first_list.append([avail_change [0], first])
        coin_change(avail_change [1 :], (total_cents - (avail_change [0] * first)))
    DEDENT
    else :
    INDENT
        coin_change(avail_change [1 :], total_cents)
    DEDENT
    return first_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15465901_15466102_1_10
15465901_15466911_2_17
Title: How to end a list in python? 
----------------------------------------

def coin_change(avail_change, total_cents) :
INDENT
    if not avail_change :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        first = total_cents / / avail_change [0]
        result = coin_change(avail_change [1 :], (total_cents % avail_change [0]))
        if first > 0 :
        INDENT
            result.insert(0, [avail_change [0], first])
        DEDENT
        return result
    DEDENT
DEDENT
----------------------------------------

def coin_change(avail_change, total_cents) :
INDENT
    if avail_change == [] :
    INDENT
        raise Exception()
    DEDENT
    if total_cents / / avail_change [0] > = 1 :
    INDENT
        first = total_cents / / avail_change [0]
        first_list = [avail_change [0], first]
        coins.append(first_list)
        try :
        INDENT
            return coin_change(avail_change [1 :], (total_cents - (avail_change [0] * first)))
        DEDENT
        except :
        INDENT
            return coins
        DEDENT
    DEDENT
    else :
    INDENT
        try :
        INDENT
            return coin_change(avail_change [1 :], total_cents)
        DEDENT
        except :
        INDENT
            return coins
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15465901_15466272_4_17
15465901_15466911_2_17
Title: How to end a list in python? 
----------------------------------------

def coin_change(avail_change, total_cents) :
INDENT
    if not avail_change :
    INDENT
        return []
    DEDENT
    if total_cents / / avail_change [0] > = 1 :
    INDENT
        first = total_cents / / avail_change [0]
        first_list.append([avail_change [0], first])
        coin_change(avail_change [1 :], (total_cents - (avail_change [0] * first)))
    DEDENT
    else :
    INDENT
        coin_change(avail_change [1 :], total_cents)
    DEDENT
    return first_list
DEDENT
----------------------------------------

def coin_change(avail_change, total_cents) :
INDENT
    if avail_change == [] :
    INDENT
        raise Exception()
    DEDENT
    if total_cents / / avail_change [0] > = 1 :
    INDENT
        first = total_cents / / avail_change [0]
        first_list = [avail_change [0], first]
        coins.append(first_list)
        try :
        INDENT
            return coin_change(avail_change [1 :], (total_cents - (avail_change [0] * first)))
        DEDENT
        except :
        INDENT
            return coins
        DEDENT
    DEDENT
    else :
    INDENT
        try :
        INDENT
            return coin_change(avail_change [1 :], total_cents)
        DEDENT
        except :
        INDENT
            return coins
        DEDENT
    DEDENT
DEDENT
----------------------------------------
