$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23718950_23719241_1_17
23718950_23720100_1_39
Title: Replacing multiple words in a string from a file 
----------------------------------------

def main() :
INDENT
    sentence = input("enter a sentence to translate\n")
    slang_dict = {}
    slang_file = open('slang.txt', 'r')
    for line in slang_file :
    INDENT
        slangword, unslang = line.split(":")
        slang_dict [slangword] = unslang
    DEDENT
    result = ""
    for item in sentence.split() :
    INDENT
        if item in slang_dict.keys() :
        INDENT
            result += slang_dict [item]
        DEDENT
        else :
        INDENT
            result += item
        DEDENT
        result += " "
    DEDENT
    print result
DEDENT
----------------------------------------

def main() :
INDENT
    slang_file = open("slang.txt")

    tmp_list = []

    for line in slang_file :
    INDENT

        line = line.strip()

        tmp_list.append(line.split(":"))

    DEDENT
    slang = {}

    for key, value in tmp_list :
    INDENT
        slang [key] = value

    DEDENT
    sentence = input("enter a sentence to translate\n")

    print (
        re.sub(r"\w+", lambda m : slang.get(m.group(), m.group()), sentence))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2375316_2375414_1_15
2375316_2375567_1_11
Title: Create a python function procedurally (specifically the arguments) 
----------------------------------------

def __call__(self, cls) :
INDENT
    def init(cls_self, * args, ** kw) :
    INDENT
        for param, value in zip(self.params, args) :
        INDENT
            if param in kw :
            INDENT
                raise TypeError("Multiple values for %s" % param)
            DEDENT
            kw [param] = value
        DEDENT
        unexpected_args = list(set(kw) - set(self.params))
        if unexpected_args :
        INDENT
            raise TypeError("Unexpected args %s" % unexpected_args)
        DEDENT
        missing_args = list(set(self.params) - set(kw))
        if missing_args :
        INDENT
            raise TypeError("Expected args %s" % missing_args)
        DEDENT
        vars(cls_self).update(kw)
    DEDENT
    cls.__init__ = init
    return cls
DEDENT
----------------------------------------

def __call__(self, cls) :
INDENT
    paramtxt = ', '.join(['self'] + self.params)
    bodytxt = '\n\t'.join('self.%(param)s = %(param)s' % locals() for param in self.params)
    template = 'def __init__(%(paramtxt)s):\n\t%(bodytxt)s' % locals()
    namespace = dict()
    exec template in namespace
    cls.__init__ = namespace ['__init__']
    return cls
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2375613_2375905_10_24
2375613_2375905_30_48
Title: Is it possible to dock wx.auiManager panes onto tops/bottoms of another panes? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = wx.ID_ANY)
    sizer = wx.BoxSizer(wx.VERTICAL)
    txtOne = wx.TextCtrl(self, wx.ID_ANY, "")
    txtTwo = wx.TextCtrl(self, wx.ID_ANY, "")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(txtOne, 0, wx.ALL, 5)
    sizer.Add(txtTwo, 0, wx.ALL, 5)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = wx.ID_ANY)

    nb = wx.aui.AuiNotebook(self)

    pages = [(TabPanel(nb), "Tab 1"),
        (TabPanel(nb), "Tab 2"),
        (TabPanel(nb), "Tab 3")]
    for page, label in pages :
    INDENT
        nb.AddPage(page, label)
    DEDENT
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(nb, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2375613_2375905_10_24
2375613_2375905_55_63
Title: Is it possible to dock wx.auiManager panes onto tops/bottoms of another panes? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = wx.ID_ANY)
    sizer = wx.BoxSizer(wx.VERTICAL)
    txtOne = wx.TextCtrl(self, wx.ID_ANY, "")
    txtTwo = wx.TextCtrl(self, wx.ID_ANY, "")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(txtOne, 0, wx.ALL, 5)
    sizer.Add(txtTwo, 0, wx.ALL, 5)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "AUI-Notebook Tutorial",
        size = (600, 400))
    panel = DemoPanel(self)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2375613_2375905_30_48
2375613_2375905_55_63
Title: Is it possible to dock wx.auiManager panes onto tops/bottoms of another panes? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = wx.ID_ANY)

    nb = wx.aui.AuiNotebook(self)

    pages = [(TabPanel(nb), "Tab 1"),
        (TabPanel(nb), "Tab 2"),
        (TabPanel(nb), "Tab 3")]
    for page, label in pages :
    INDENT
        nb.AddPage(page, label)
    DEDENT
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(nb, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "AUI-Notebook Tutorial",
        size = (600, 400))
    panel = DemoPanel(self)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23770766_23770895_2_29
23770766_23771032_2_37
Title: python code not working 
----------------------------------------

def rps() :
INDENT
    computerchoice = random.randint(1, 3)
    if computerchoice == 1 :
    INDENT
        computerchoice = "rock"
    DEDENT
    elif computerchoice == 2 :
    INDENT
        computerchoice = "paper"
    DEDENT
    elif computerchoice == 3 :
    INDENT
        computerchoice = "scissors"
    DEDENT
    choice = raw_input("Rock, paper, or scissors?:")
    choice = choice.lower()
    if choice not in ["scissors", "paper", "rock"] :
    INDENT
        rps()
    DEDENT
    print "The computer chose " + computerchoice + "."
    if choice == computerchoice :
    INDENT
        choice + computerchoice
        print "It's a draw!"
    DEDENT
    elif choice + computerchoice == "rockpaper" :
    INDENT
        print "Computer wins, paper covers rock!"
    DEDENT
    elif choice + computerchoice == "rockscissors" :
    INDENT
        print "Player wins, rock crushes scissors!"
    DEDENT
    elif choice + computerchoice == "paperrock" :
    INDENT
        print "Player wins, paper covers rock!"
    DEDENT
    elif choice + computerchoice == "paperscissors" :
    INDENT
        print "Computer wins, scissors cut paper!"
    DEDENT
    elif choice + computerchoice == "scissorsrock" :
    INDENT
        print "Computer wins, rock crushes scissors!"
    DEDENT
    elif choice + computerchoice == "scissorspaper" :
    INDENT
        print "Player wins, scissors cuts paper!"
    DEDENT
DEDENT
----------------------------------------

def rps() :
INDENT
    computerchoice = random.randint(1, 3)
    if computerchoice == 1 :
    INDENT
        computerchoice = "rock"
    DEDENT
    elif computerchoice == 2 :
    INDENT
        computerchoice = "paper"
    DEDENT
    elif computerchoice == 3 :
    INDENT
        computerchoice = "scissors"
    DEDENT
    choice = raw_input("Rock, paper, or scissors?:")
    choice = choice.lower()
    print "The computer chose " + computerchoice + "."
    if choice == 'rock' :
    INDENT
        if computerchoice == 'rock' :
        INDENT
            print 'Draw: you both picked rock'
        DEDENT
        elif computerchoice == 'scissors' :
        INDENT
            print 'You win! Rock beats scissors'
        DEDENT
        elif computerchoice == 'paper' :
        INDENT
            print 'You lose.  Try again'
        DEDENT
    DEDENT
    elif choice == 'paper' :
    INDENT
        if computerchoice == 'rock' :
        INDENT
            print 'You win!'
        DEDENT
        elif computerchoice == 'scissors' :
        INDENT
            print 'You lose.'
        DEDENT
        elif computerchoice == 'paper' :
        INDENT
            print 'You draw.'
        DEDENT
    DEDENT
    elif choice == 'scissors' :
    INDENT
        if computerchoice == 'rock' :
        INDENT
            print 'You lose.'
        DEDENT
        elif computerchoice == 'scissors' :
        INDENT
            print 'You draw.'
        DEDENT
        elif computerchoice == 'paper' :
        INDENT
            print 'You win.'
        DEDENT
    DEDENT
    else :
    INDENT
        print 'I am sorry, I could not make out what you typed.  Try again'
        rps()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23770766_23770895_2_29
23770766_23771105_16_31
Title: python code not working 
----------------------------------------

def rps() :
INDENT
    computerchoice = random.randint(1, 3)
    if computerchoice == 1 :
    INDENT
        computerchoice = "rock"
    DEDENT
    elif computerchoice == 2 :
    INDENT
        computerchoice = "paper"
    DEDENT
    elif computerchoice == 3 :
    INDENT
        computerchoice = "scissors"
    DEDENT
    choice = raw_input("Rock, paper, or scissors?:")
    choice = choice.lower()
    if choice not in ["scissors", "paper", "rock"] :
    INDENT
        rps()
    DEDENT
    print "The computer chose " + computerchoice + "."
    if choice == computerchoice :
    INDENT
        choice + computerchoice
        print "It's a draw!"
    DEDENT
    elif choice + computerchoice == "rockpaper" :
    INDENT
        print "Computer wins, paper covers rock!"
    DEDENT
    elif choice + computerchoice == "rockscissors" :
    INDENT
        print "Player wins, rock crushes scissors!"
    DEDENT
    elif choice + computerchoice == "paperrock" :
    INDENT
        print "Player wins, paper covers rock!"
    DEDENT
    elif choice + computerchoice == "paperscissors" :
    INDENT
        print "Computer wins, scissors cut paper!"
    DEDENT
    elif choice + computerchoice == "scissorsrock" :
    INDENT
        print "Computer wins, rock crushes scissors!"
    DEDENT
    elif choice + computerchoice == "scissorspaper" :
    INDENT
        print "Player wins, scissors cuts paper!"
    DEDENT
DEDENT
----------------------------------------

def rps() :
INDENT
    computerchoice = random.choice(CHOICES.keys())
    choice = raw_input("Rock, paper, or scissors?:").lower()
    while choice not in CHOICES :
    INDENT
        print "Check your spelling and try again."
        choice = raw_input("Rock, paper, or scissors?:").lower()
    DEDENT
    print "The computer chose %s." % computerchoice
    winner = win(choice, computerchoice)
    if winner == 0 :
    INDENT
        print "It's a draw!"
    DEDENT
    if winner == 1 :
    INDENT
        print "Player wins, %s %s %s!" % (choice, CHOICES [choice], computerchoice)
    DEDENT
    if winner == 2 :
    INDENT
        print "Computer wins, %s %s %s!" % (computerchoice, CHOICES [computerchoice], choice)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23770766_23771032_2_37
23770766_23771105_16_31
Title: python code not working 
----------------------------------------

def rps() :
INDENT
    computerchoice = random.randint(1, 3)
    if computerchoice == 1 :
    INDENT
        computerchoice = "rock"
    DEDENT
    elif computerchoice == 2 :
    INDENT
        computerchoice = "paper"
    DEDENT
    elif computerchoice == 3 :
    INDENT
        computerchoice = "scissors"
    DEDENT
    choice = raw_input("Rock, paper, or scissors?:")
    choice = choice.lower()
    print "The computer chose " + computerchoice + "."
    if choice == 'rock' :
    INDENT
        if computerchoice == 'rock' :
        INDENT
            print 'Draw: you both picked rock'
        DEDENT
        elif computerchoice == 'scissors' :
        INDENT
            print 'You win! Rock beats scissors'
        DEDENT
        elif computerchoice == 'paper' :
        INDENT
            print 'You lose.  Try again'
        DEDENT
    DEDENT
    elif choice == 'paper' :
    INDENT
        if computerchoice == 'rock' :
        INDENT
            print 'You win!'
        DEDENT
        elif computerchoice == 'scissors' :
        INDENT
            print 'You lose.'
        DEDENT
        elif computerchoice == 'paper' :
        INDENT
            print 'You draw.'
        DEDENT
    DEDENT
    elif choice == 'scissors' :
    INDENT
        if computerchoice == 'rock' :
        INDENT
            print 'You lose.'
        DEDENT
        elif computerchoice == 'scissors' :
        INDENT
            print 'You draw.'
        DEDENT
        elif computerchoice == 'paper' :
        INDENT
            print 'You win.'
        DEDENT
    DEDENT
    else :
    INDENT
        print 'I am sorry, I could not make out what you typed.  Try again'
        rps()
    DEDENT
DEDENT
----------------------------------------

def rps() :
INDENT
    computerchoice = random.choice(CHOICES.keys())
    choice = raw_input("Rock, paper, or scissors?:").lower()
    while choice not in CHOICES :
    INDENT
        print "Check your spelling and try again."
        choice = raw_input("Rock, paper, or scissors?:").lower()
    DEDENT
    print "The computer chose %s." % computerchoice
    winner = win(choice, computerchoice)
    if winner == 0 :
    INDENT
        print "It's a draw!"
    DEDENT
    if winner == 1 :
    INDENT
        print "Player wins, %s %s %s!" % (choice, CHOICES [choice], computerchoice)
    DEDENT
    if winner == 2 :
    INDENT
        print "Computer wins, %s %s %s!" % (computerchoice, CHOICES [computerchoice], choice)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2383212_2436729_28_49
2383212_2436729_8_26
Title: pyqt QTreeWidget setItemWidget dissapears after drag/drop 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QTreeWidget.__init__(self, parent)

    self.setDragDropMode(QAbstractItemView.InternalMove)
    self.installEventFilter(self)
    self.setColumnCount(3)
    for n in range(2) :
    INDENT
        i = QTreeWidgetItem(self)
        i.setText(0, "first" + str(n))
        i.setText(1, "second")
        for m in range(2) :
        INDENT
            j = QTreeWidgetItem(i)
            j.setText(0, "child first" + str(m))

        DEDENT
    DEDENT
    self.item = InlineEditor(self)
    self.setItemWidget(self.topLevelItem(0).child(1), 1, self.item)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    QWidget.__init__(self, parent)
    self.setAutoFillBackground(True)
    lo = QHBoxLayout()
    lo.setSpacing(4)
    self._cbFoo = QComboBox()
    for x in ["ABC", "DEF", "GHI", "JKL"] :
    INDENT
        self._cbFoo.addItem(x)
    DEDENT
    self._leBar = QLineEdit('', self)
    lo.addWidget(self._cbFoo, 3)
    lo.addSpacing(5)
    lo.addWidget(QLabel('Bar:'))
    lo.addWidget(self._leBar, 3)
    lo.addStretch(5)
    self.setLayout(lo)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2383212_2436729_28_49
2383212_2441033_7_25
Title: pyqt QTreeWidget setItemWidget dissapears after drag/drop 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QTreeWidget.__init__(self, parent)

    self.setDragDropMode(QAbstractItemView.InternalMove)
    self.installEventFilter(self)
    self.setColumnCount(3)
    for n in range(2) :
    INDENT
        i = QTreeWidgetItem(self)
        i.setText(0, "first" + str(n))
        i.setText(1, "second")
        for m in range(2) :
        INDENT
            j = QTreeWidgetItem(i)
            j.setText(0, "child first" + str(m))

        DEDENT
    DEDENT
    self.item = InlineEditor(self)
    self.setItemWidget(self.topLevelItem(0).child(1), 1, self.item)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    QWidget.__init__(self, parent)
    self.setAutoFillBackground(True)
    lo = QHBoxLayout()
    lo.setSpacing(4)
    self._cbFoo = QComboBox()
    for x in ["ABC", "DEF", "GHI", "JKL"] :
    INDENT
        self._cbFoo.addItem(x)
    DEDENT
    self._leBar = QLineEdit('', self)
    lo.addWidget(self._cbFoo, 3)
    lo.addSpacing(5)
    lo.addWidget(QLabel('Bar:'))
    lo.addWidget(self._leBar, 3)
    lo.addStretch(5)
    self.setLayout(lo)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2383212_2436729_8_26
2383212_2441033_27_46
Title: pyqt QTreeWidget setItemWidget dissapears after drag/drop 
----------------------------------------

def __init__(self, parent) :
INDENT
    QWidget.__init__(self, parent)
    self.setAutoFillBackground(True)
    lo = QHBoxLayout()
    lo.setSpacing(4)
    self._cbFoo = QComboBox()
    for x in ["ABC", "DEF", "GHI", "JKL"] :
    INDENT
        self._cbFoo.addItem(x)
    DEDENT
    self._leBar = QLineEdit('', self)
    lo.addWidget(self._cbFoo, 3)
    lo.addSpacing(5)
    lo.addWidget(QLabel('Bar:'))
    lo.addWidget(self._leBar, 3)
    lo.addStretch(5)
    self.setLayout(lo)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QTreeWidget.__init__(self, parent)

    self.setDragDropMode(QAbstractItemView.InternalMove)
    self.installEventFilter(self)
    self.setColumnCount(3)
    self.dropEvent = self.treeDropEvent
    for n in range(2) :
    INDENT
        i = QTreeWidgetItem(self)
        i.setText(0, "first" + str(n))
        i.setText(1, "second")
        for m in range(2) :
        INDENT
            j = QTreeWidgetItem(i)
            j.setText(0, "child first" + str(m))
        DEDENT
    DEDENT
    self.item = InlineEditor(self)
    self.setItemWidget(self.topLevelItem(0).child(1), 1, self.item)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2383212_2441033_27_46
2383212_2441033_7_25
Title: pyqt QTreeWidget setItemWidget dissapears after drag/drop 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QTreeWidget.__init__(self, parent)

    self.setDragDropMode(QAbstractItemView.InternalMove)
    self.installEventFilter(self)
    self.setColumnCount(3)
    self.dropEvent = self.treeDropEvent
    for n in range(2) :
    INDENT
        i = QTreeWidgetItem(self)
        i.setText(0, "first" + str(n))
        i.setText(1, "second")
        for m in range(2) :
        INDENT
            j = QTreeWidgetItem(i)
            j.setText(0, "child first" + str(m))
        DEDENT
    DEDENT
    self.item = InlineEditor(self)
    self.setItemWidget(self.topLevelItem(0).child(1), 1, self.item)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    QWidget.__init__(self, parent)
    self.setAutoFillBackground(True)
    lo = QHBoxLayout()
    lo.setSpacing(4)
    self._cbFoo = QComboBox()
    for x in ["ABC", "DEF", "GHI", "JKL"] :
    INDENT
        self._cbFoo.addItem(x)
    DEDENT
    self._leBar = QLineEdit('', self)
    lo.addWidget(self._cbFoo, 3)
    lo.addSpacing(5)
    lo.addWidget(QLabel('Bar:'))
    lo.addWidget(self._leBar, 3)
    lo.addStretch(5)
    self.setLayout(lo)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23832851_23832987_1_12
23832851_27409878_1_14
Title: Codecademy Practice Makes Perfect 10/15 (Word Censoring) 
----------------------------------------

def censor(text, word) :
INDENT
    length_of_word = len(word)
    word_now_censored = '*' * length_of_word
    wordlist = text.split()
    new_words_list = []
    for item in wordlist :
    INDENT
        if item == word :
        INDENT
            new_words_list.append(word_now_censored)
        DEDENT
        else :
        INDENT
            new_words_list.append(item)
        DEDENT
    DEDENT
    return " ".join(new_words_list)
DEDENT
----------------------------------------

def censor(text, word) :
INDENT
    result = ""
    count = 0
    no_of_stars = 0
    split_list = text.split()
    for i in split_list :
    INDENT
        count += 1
        if (i == word) :
        INDENT
            result += "*" * len(i)
        DEDENT
        else :
        INDENT
            result += i
        DEDENT
        if (count ! = len(split_list)) :
        INDENT
            result += " "
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23832851_23832987_1_12
23832851_32656227_1_11
Title: Codecademy Practice Makes Perfect 10/15 (Word Censoring) 
----------------------------------------

def censor(text, word) :
INDENT
    length_of_word = len(word)
    word_now_censored = '*' * length_of_word
    wordlist = text.split()
    new_words_list = []
    for item in wordlist :
    INDENT
        if item == word :
        INDENT
            new_words_list.append(word_now_censored)
        DEDENT
        else :
        INDENT
            new_words_list.append(item)
        DEDENT
    DEDENT
    return " ".join(new_words_list)
DEDENT
----------------------------------------

def censor(text, word) :
INDENT
    c = ''
    for i in text.split() :
    INDENT
        if i == word :
        INDENT
            i = "*" * len(word)
            c += ' ' + i
        DEDENT
        else :
        INDENT
            c += ' ' + i
        DEDENT
    DEDENT
    return c

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23832851_23832987_1_12
23832851_33629453_1_19
Title: Codecademy Practice Makes Perfect 10/15 (Word Censoring) 
----------------------------------------

def censor(text, word) :
INDENT
    length_of_word = len(word)
    word_now_censored = '*' * length_of_word
    wordlist = text.split()
    new_words_list = []
    for item in wordlist :
    INDENT
        if item == word :
        INDENT
            new_words_list.append(word_now_censored)
        DEDENT
        else :
        INDENT
            new_words_list.append(item)
        DEDENT
    DEDENT
    return " ".join(new_words_list)
DEDENT
----------------------------------------

def censor(text, word) :
INDENT
    text = list(text)
    for n in range(0, len(text)) :
    INDENT
        i = 0
        while 1 == 1 :
        INDENT
            for i in range(0, len(word)) :
            INDENT
                if text [n + i] == word [i] :
                INDENT
                    i += 1
                DEDENT
                else :
                INDENT
                    break
                DEDENT
            DEDENT
            if i == len(word) :
            INDENT
                for m in range(0, i) :
                INDENT
                    text [n + m] = '*'
                DEDENT
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        n += i
    DEDENT
    return "".join(text)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23832851_27409878_1_14
23832851_32656227_1_11
Title: Codecademy Practice Makes Perfect 10/15 (Word Censoring) 
----------------------------------------

def censor(text, word) :
INDENT
    result = ""
    count = 0
    no_of_stars = 0
    split_list = text.split()
    for i in split_list :
    INDENT
        count += 1
        if (i == word) :
        INDENT
            result += "*" * len(i)
        DEDENT
        else :
        INDENT
            result += i
        DEDENT
        if (count ! = len(split_list)) :
        INDENT
            result += " "
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def censor(text, word) :
INDENT
    c = ''
    for i in text.split() :
    INDENT
        if i == word :
        INDENT
            i = "*" * len(word)
            c += ' ' + i
        DEDENT
        else :
        INDENT
            c += ' ' + i
        DEDENT
    DEDENT
    return c

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23832851_27409878_1_14
23832851_33629453_1_19
Title: Codecademy Practice Makes Perfect 10/15 (Word Censoring) 
----------------------------------------

def censor(text, word) :
INDENT
    result = ""
    count = 0
    no_of_stars = 0
    split_list = text.split()
    for i in split_list :
    INDENT
        count += 1
        if (i == word) :
        INDENT
            result += "*" * len(i)
        DEDENT
        else :
        INDENT
            result += i
        DEDENT
        if (count ! = len(split_list)) :
        INDENT
            result += " "
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def censor(text, word) :
INDENT
    text = list(text)
    for n in range(0, len(text)) :
    INDENT
        i = 0
        while 1 == 1 :
        INDENT
            for i in range(0, len(word)) :
            INDENT
                if text [n + i] == word [i] :
                INDENT
                    i += 1
                DEDENT
                else :
                INDENT
                    break
                DEDENT
            DEDENT
            if i == len(word) :
            INDENT
                for m in range(0, i) :
                INDENT
                    text [n + m] = '*'
                DEDENT
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        n += i
    DEDENT
    return "".join(text)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23832851_32656227_1_11
23832851_33629453_1_19
Title: Codecademy Practice Makes Perfect 10/15 (Word Censoring) 
----------------------------------------

def censor(text, word) :
INDENT
    c = ''
    for i in text.split() :
    INDENT
        if i == word :
        INDENT
            i = "*" * len(word)
            c += ' ' + i
        DEDENT
        else :
        INDENT
            c += ' ' + i
        DEDENT
    DEDENT
    return c

DEDENT
----------------------------------------

def censor(text, word) :
INDENT
    text = list(text)
    for n in range(0, len(text)) :
    INDENT
        i = 0
        while 1 == 1 :
        INDENT
            for i in range(0, len(word)) :
            INDENT
                if text [n + i] == word [i] :
                INDENT
                    i += 1
                DEDENT
                else :
                INDENT
                    break
                DEDENT
            DEDENT
            if i == len(word) :
            INDENT
                for m in range(0, i) :
                INDENT
                    text [n + m] = '*'
                DEDENT
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        n += i
    DEDENT
    return "".join(text)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23840639_23840681_21_27
23840639_23841490_11_18
Title: Quick Sort Comparison Counter in Python 
----------------------------------------

def quicksort(mylist, start, end) :
INDENT
    if less_than(start, end) :
    INDENT
        pos = partition(mylist, start, end)
        quicksort(mylist, start, pos - 1)
        quicksort(mylist, pos + 1, end)

    DEDENT
DEDENT
----------------------------------------

def quicksort(mylist, start, end, count) :
INDENT
    if start < end :
    INDENT
        pos, count = partition(mylist, start, end, count)
        count = quicksort(mylist, start, pos - 1, count)
        count = quicksort(mylist, pos + 1, end, count)
    DEDENT
    return count

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23840639_23840681_21_27
23840639_23841877_20_26
Title: Quick Sort Comparison Counter in Python 
----------------------------------------

def quicksort(mylist, start, end) :
INDENT
    if less_than(start, end) :
    INDENT
        pos = partition(mylist, start, end)
        quicksort(mylist, start, pos - 1)
        quicksort(mylist, pos + 1, end)

    DEDENT
DEDENT
----------------------------------------

def quicksort(mylist, start = None, end = None) :
INDENT
    if start is None :
    INDENT
        start = 0
    DEDENT
    if end is None :
    INDENT
        end = len(mylist) - 1
    DEDENT
    return _quicksort(mylist, start, end)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23840639_23841490_11_18
23840639_23841877_20_26
Title: Quick Sort Comparison Counter in Python 
----------------------------------------

def quicksort(mylist, start, end, count) :
INDENT
    if start < end :
    INDENT
        pos, count = partition(mylist, start, end, count)
        count = quicksort(mylist, start, pos - 1, count)
        count = quicksort(mylist, pos + 1, end, count)
    DEDENT
    return count

DEDENT
----------------------------------------

def quicksort(mylist, start = None, end = None) :
INDENT
    if start is None :
    INDENT
        start = 0
    DEDENT
    if end is None :
    INDENT
        end = len(mylist) - 1
    DEDENT
    return _quicksort(mylist, start, end)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23841128_36947964_14_22
23841128_36947964_39_46
Title: pygame how to check mouse coordinates 
----------------------------------------

def __init__(self, width, height) :
INDENT
    super().__init__()
    all_sprite_list.add(self)
    block_list.add(self)
    self.image = pygame.Surface((32, 32))
    self.rect = self.image.get_rect()
    self.change_y = 0
    self.change_x = 0
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    player_list.add(self)
    all_sprite_list.add(self)
    self.rect = Rect(400, 300, 16, 16)
    self.image = pygame.Surface((16, 16))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23850696_23874177_26_93
23850696_23874177_6_23
Title: Populating a QListWidget with custom widgets 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(animItemWidget, self).__init__()
    self.horizontalLayout_4 = QtGui.QHBoxLayout(self)
    self.horizontalLayout_4.setSpacing(2)
    self.horizontalLayout_4.setMargin(3)
    self.horizontalLayout_4.setObjectName(QtCore.QString.fromUtf8("horizontalLayout_4"))
    self.verticalLayout_2 = QtGui.QVBoxLayout()
    self.verticalLayout_2.setObjectName(QtCore.QString.fromUtf8("verticalLayout_2"))
    self.label = QtGui.QLabel(self)
    font = QtGui.QFont()
    font.setPointSize(11)
    font.setWeight(75)
    font.setBold(True)
    self.label.setFont(font)
    self.label.setObjectName(QtCore.QString.fromUtf8("label"))
    self.verticalLayout_2.addWidget(self.label)
    self.pixMap02 = QtGui.QLabel(self)
    self.pixMap02.setText(QtCore.QString.fromUtf8(""))
    self.pixMap02.setObjectName(QtCore.QString.fromUtf8("pixMap02"))
    self.verticalLayout_2.addWidget(self.pixMap02)
    self.horizontalLayout_4.addLayout(self.verticalLayout_2)
    self.verticalLayout = QtGui.QVBoxLayout()
    self.verticalLayout.setObjectName(QtCore.QString.fromUtf8("verticalLayout"))
    self.horizontalLayout = QtGui.QHBoxLayout()
    self.horizontalLayout.setSpacing(2)
    self.horizontalLayout.setObjectName(QtCore.QString.fromUtf8("horizontalLayout"))
    self.pixMap01 = QtGui.QLabel(self)
    self.pixMap01.setText(QtCore.QString.fromUtf8(""))
    self.pixMap01.setObjectName(QtCore.QString.fromUtf8("pixMap01"))
    self.horizontalLayout.addWidget(self.pixMap01)
    spacerItem = QtGui.QSpacerItem(40, 20, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem)
    self.button02 = QtGui.QPushButton(self)
    self.button02.setMaximumSize(QtCore.QSize(24, 24))
    self.button02.setText(QtCore.QString.fromUtf8(""))
    self.button02.setObjectName(QtCore.QString.fromUtf8("button02"))
    self.horizontalLayout.addWidget(self.button02)
    self.button01 = QtGui.QPushButton(self)
    self.button01.setMaximumSize(QtCore.QSize(24, 24))
    self.button01.setText(QtCore.QString.fromUtf8(""))
    self.button01.setObjectName(QtCore.QString.fromUtf8("button01"))
    self.horizontalLayout.addWidget(self.button01)
    self.button04 = QtGui.QPushButton(self)
    self.button04.setMaximumSize(QtCore.QSize(24, 24))
    self.button04.setText(QtCore.QString.fromUtf8(""))
    self.button04.setObjectName(QtCore.QString.fromUtf8("button04"))
    self.horizontalLayout.addWidget(self.button04)
    self.button03 = QtGui.QPushButton(self)
    self.button03.setMaximumSize(QtCore.QSize(24, 24))
    self.button03.setText(QtCore.QString.fromUtf8(""))
    self.button03.setObjectName(QtCore.QString.fromUtf8("button03"))
    self.horizontalLayout.addWidget(self.button03)
    self.button05 = QtGui.QPushButton(self)
    self.button05.setMaximumSize(QtCore.QSize(24, 24))
    self.button05.setText(QtCore.QString.fromUtf8(""))
    self.button05.setObjectName(QtCore.QString.fromUtf8("button05"))
    self.horizontalLayout.addWidget(self.button05)
    self.verticalLayout.addLayout(self.horizontalLayout)
    self.horizontalLayout_3 = QtGui.QHBoxLayout()
    self.horizontalLayout_3.setObjectName(QtCore.QString.fromUtf8("horizontalLayout_3"))
    self.label_2 = QtGui.QLabel(self)
    self.label_2.setObjectName(QtCore.QString.fromUtf8("label_2"))
    self.horizontalLayout_3.addWidget(self.label_2)
    self.verticalLayout.addLayout(self.horizontalLayout_3)
    self.horizontalLayout_4.addLayout(self.verticalLayout)
    self.connect(self.button02, QtCore.SIGNAL("clicked()"), self.awesome)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(uiControlTest, self).__init__()
    self.ui = uic.loadUi('uiControlTest.ui')
    self.ui.show()
    for i in range(0, 300) :
    INDENT
        wid = animItemWidget()
        wid.label_2.setText('Last edited by chrise @2014.06.21:23:17')
        wid.label.setText('Animation ' + str(i) + '       ')
        wid2 = QtGui.QListWidgetItem()
        wid2.setSizeHint(QtCore.QSize(100, 40))
        self.ui.list.addItem(wid2)
        self.ui.list.setItemWidget(wid2, wid)
    DEDENT
    def awesomeButtonPressed() :
    INDENT
        print 'awesome!'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23859837_23885887_15_68
23859837_23885887_4_13
Title: wxPython Panel is two shades of gray? 
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    wx.Frame.__init__(self, * args, ** kwds)
    prefPanel = wx.Panel(self)
    """This makes no sense: according to the wx.Frame.__init__ above self is a wx.Frame."""

    prefSizer = wx.GridBagSizer(13, 9)

    xIndex = 0
    yIndex = 0

    self.tc_DBExt = wx.TextCtrl(prefPanel, - 1, "", (0, 0), (150, 21))
    self.label_DBExt = wx.StaticText(prefPanel, label = "Default Database Extensions:")
    help_tc_DBExt = "Enter this as: *.<extension>"
    self.tc_DBExt.SetToolTip(wx.ToolTip(help_tc_DBExt))
    """Replaced with something static."""
    self.tc_DBExt.Value = 'conftxt'
    prefSizer.Add(self.label_DBExt, pos = (xIndex, 0), flag = wx.LEFT | wx.ALIGN_CENTER_VERTICAL | wx.TOP, border = 10)
    prefSizer.Add(self.tc_DBExt, pos = (xIndex, 1), span = (1, 5), flag = wx.EXPAND | wx.LEFT | wx.ALIGN_CENTER_VERTICAL | wx.TOP, border = 10).SetMinSize((200, 22))
    """Assuming panel definition from outside.

        It has to be created here. If it is to be created **before**
        the parent is created, it is very complicated to create it with a
        dummy parent and ``Reparent`` it to this Frame/Panel. Don't do that."""
    panel = panel_class(prefPanel, - 1)
    """Attach ``panel`` to a sizer in **this** hierarchy
        It looks disconnected, because it has brought already it's own
        sizer, which is child to the GridBagSizer."""
    xindex = 1
    prefSizer.Add(panel, pos = (xindex, 0), span = (1, 5), flag = wx.EXPAND | wx.LEFT | wx.ALIGN_CENTER_VERTICAL | wx.TOP, border = 10).SetMinSize((200, 22))
    """You have to tell wxPython somehow to what element the sizer is coupled (in this case to the main pane)l"""
    prefPanel.SetSizer(prefSizer)
    """I have no idea """
    """Normally not needed/happening automagically on standard controls"""

DEDENT
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    wx.Panel.__init__(self, * args, ** kwds)
    pnl = self
    szmain = wx.BoxSizer(wx.HORIZONTAL)
    szmain.Add(wx.TextCtrl(pnl, - 1, 'Database path'), 1, wx.EXPAND)
    szmain.Add(wx.Button(pnl, - 1, 'Database path'), 0, wx.EXPAND)
    pnl.SetSizer(szmain)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2386541_2387330_25_36
2386541_2387330_2_12
Title: Creating a custom Django form field that uses two <input>s 
----------------------------------------

def __init__(self, required = True, widget = None, label = None, initial = None) :
INDENT
    fields = (
        forms.CharField(),
        forms.MultipleChoiceField(choices = (('J', 'John'),
                ('P', 'Paul'),
                ('G', 'George'),
                ('R', 'Ringo'))),
        forms.SplitDateTimeField())
    super(ComplexField, self).__init__(fields, required,
        widget, label, initial)
DEDENT
----------------------------------------

def __init__(self, attrs = None) :
INDENT
    widgets = (
        forms.TextInput(),
        forms.SelectMultiple(choices = (('J', 'John'),
                ('P', 'Paul'),
                ('G', 'George'),
                ('R', 'Ringo'))),
        forms.SplitDateTimeWidget(),
        )
    super(ComplexMultiWidget, self).__init__(widgets, attrs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23935516_43026570_42_54
23935516_43026570_6_24
Title: Tkinter-how to 'get' data values from more than one entry box using one button? 
----------------------------------------

def __init__(self, parent, con) :
INDENT
    tk.Frame.__init__(self, parent);
    l1 = tkinter.ttk.Label(self, text = 'Enter dealer id :', width = 20)
    l2 = tkinter.ttk.Label(self, text = 'Enter dealer password :', width = 20)
    e1 = tkinter.ttk.Entry(self)
    e2 = tkinter.ttk.Entry(self)
    print (type(e1), type(e2), type(tkinter.ttk.Entry()))
    b1 = ttk.Button(self, text = "Back", command = lambda : con.show_frame(pa1)).grid(row = 2, column = 0)
    b2 = ttk.Button(self, text = 'Submit', command = lambda : self.check(e1, e2)).grid(row = 2, column = 1)
    l1.grid(row = 0, column = 0)
    l2.grid(row = 1, column = 0)
    e1.grid(row = 0, column = 1)
    e2.grid(row = 1, column = 1)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    a = tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(a)
    container.grid(row = 0, column = 0)
    self.menu = tk.Menu(a, tearoff = 0)
    self.menu.add_command(label = "Beep", command = self.bell)
    self.menu.add_command(label = "Exit")
    self.bind("<Button-3>", self.showMenu)
    self.frames = {}
    for f in (pa1, pa2, pa3, pa4, pa5, pa6, pa7, pa8, pa9, pa10) :
    INDENT
        frame = f(container, self)
        self.frames [f] = frame
        frame.grid(row = 0, column = 0, sticky = 'nsew')
    DEDENT
    self.show_frame(pa1)
    menu = tk.Menu(self)
    self.config(menu = menu)
    file = tk.Menu(menu)
    file.add_command(label = 'Exit', command = self.over)
    menu.add_cascade(label = 'File', menu = file)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23987606_23987691_1_7
23987606_23987723_1_6
Title: How to make a grid from a dictionary? 
----------------------------------------

def createEmptyGrid(grid_dimensions) :
INDENT
    grid = {}
    for x in range(grid_dimensions) :
    INDENT
        for y in range(grid_dimensions) :
        INDENT
            grid [x, y] = '.'
        DEDENT
    DEDENT
    return grid
DEDENT
----------------------------------------

def createEmptyGrid(grid_dimensions) :
INDENT
    grid = [None] * grid_dimensions
    for x in range(grid_dimensions) :
    INDENT
        grid [x] = ['.'] * grid_dimensions
    DEDENT
    return grid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23987606_23987702_1_7
23987606_23987723_1_6
Title: How to make a grid from a dictionary? 
----------------------------------------

def createEmptyGrid(grid_dimensions) :
INDENT
    grid = {}
    for x in range(grid_dimensions) :
    INDENT
        for y in range(grid_dimensions) :
        INDENT
            grid [x, y] = '.'
        DEDENT
    DEDENT
    return grid
DEDENT
----------------------------------------

def createEmptyGrid(grid_dimensions) :
INDENT
    grid = [None] * grid_dimensions
    for x in range(grid_dimensions) :
    INDENT
        grid [x] = ['.'] * grid_dimensions
    DEDENT
    return grid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24008820_24602776_100_151
24008820_24602776_191_244
Title: Use django-import-export with class based views 
----------------------------------------

def post(self, * args, ** kwargs) :
INDENT
    resource = self.get_import_resource_class()()
    context = {}
    import_formats = self.get_import_formats()
    form = ImportForm(import_formats,
        self.request.POST or None,
        self.request.FILES or None)
    if self.request.POST and form.is_valid() :
    INDENT
        input_format = import_formats [
            int(form.cleaned_data ['input_format'])]()
        import_file = form.cleaned_data ['import_file']

        with tempfile.NamedTemporaryFile(delete = False) as uploaded_file :
        INDENT
            for chunk in import_file.chunks() :
            INDENT
                uploaded_file.write(chunk)

            DEDENT
        DEDENT
        with open(uploaded_file.name,
            input_format.get_read_mode()) as uploaded_import_file :
        INDENT

            data = uploaded_import_file.read()
            if not input_format.is_binary() and self.from_encoding :
            INDENT
                data = force_text(data, self.from_encoding)
            DEDENT
            dataset = input_format.create_dataset(data)
            result = resource.import_data(dataset, dry_run = True,
                raise_errors = False)
        DEDENT
        context ['result'] = result
        if not result.has_errors() :
        INDENT
            context ['confirm_form'] = ConfirmImportForm(initial = {
                    'import_file_name' : os.path.basename(uploaded_file.name),
                    'input_format' : form.cleaned_data ['input_format'],
                    })
        DEDENT
    DEDENT
    context ['form'] = form
    context ['opts'] = self.model._meta
    context ['fields'] = [f.column_name for f in resource.get_fields()]
    return TemplateResponse(self.request, [self.import_template_name], context)
DEDENT
----------------------------------------

def post(self, * args, ** kwargs) :
INDENT
    opts = self.model._meta
    resource = self.get_import_resource_class()()
    confirm_form = ConfirmImportForm(self.request.POST)
    if confirm_form.is_valid() :
    INDENT
        import_formats = self.get_import_formats()
        input_format = import_formats [
            int(confirm_form.cleaned_data ['input_format'])]()
        import_file_name = os.path.join(
            tempfile.gettempdir(),
            confirm_form.cleaned_data ['import_file_name'])
        import_file = open(import_file_name, input_format.get_read_mode())
        data = import_file.read()
        if not input_format.is_binary() and self.from_encoding :
        INDENT
            data = force_text(data, self.from_encoding)
        DEDENT
        dataset = input_format.create_dataset(data)
        result = resource.import_data(dataset, dry_run = False,
            raise_errors = True)

        ADDITION = 1
        CHANGE = 2
        DELETION = 3
        logentry_map = {
            RowResult.IMPORT_TYPE_NEW : ADDITION,
            RowResult.IMPORT_TYPE_UPDATE : CHANGE,
            RowResult.IMPORT_TYPE_DELETE : DELETION,
            }
        content_type_id = ContentType.objects.get_for_model(self.model).pk
        '''
            for row in result:
                LogEntry.objects.log_action(
                    user_id=request.user.pk,
                    content_type_id=content_type_id,
                    object_id=row.object_id,
                    object_repr=row.object_repr,
                    action_flag=logentry_map[row.import_type],
                    change_message="%s through import_export" % row.import_type,
                )
            '''
        success_message = _('Import finished')
        messages.success(self.request, success_message)
        import_file.close()
        url = reverse('%s_list' % (str(opts.app_label).lower()))
        return HttpResponseRedirect(url)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24008820_24602776_47_99
24008820_25456303_10_47
Title: Use django-import-export with class based views 
----------------------------------------

def get(self, * args, ** kwargs) :
INDENT
    resource = self.get_import_resource_class()()
    context = {}
    import_formats = self.get_import_formats()
    form = ImportForm(import_formats,
        self.request.POST or None,
        self.request.FILES or None)
    if self.request.POST and form.is_valid() :
    INDENT
        input_format = import_formats [
            int(form.cleaned_data ['input_format'])]()
        import_file = form.cleaned_data ['import_file']

        with tempfile.NamedTemporaryFile(delete = False) as uploaded_file :
        INDENT
            for chunk in import_file.chunks() :
            INDENT
                uploaded_file.write(chunk)

            DEDENT
        DEDENT
        with open(uploaded_file.name,
            input_format.get_read_mode()) as uploaded_import_file :
        INDENT

            data = uploaded_import_file.read()
            if not input_format.is_binary() and self.from_encoding :
            INDENT
                data = force_text(data, self.from_encoding)
            DEDENT
            dataset = input_format.create_dataset(data)
            result = resource.import_data(dataset, dry_run = True,
                raise_errors = False)
        DEDENT
        context ['result'] = result
        if not result.has_errors() :
        INDENT
            context ['confirm_form'] = ConfirmImportForm(initial = {
                    'import_file_name' : os.path.basename(uploaded_file.name),
                    'input_format' : form.cleaned_data ['input_format'],
                    })
        DEDENT
    DEDENT
    context ['form'] = form
    context ['opts'] = self.model._meta
    context ['fields'] = [f.column_name for f in resource.get_fields()]
    return TemplateResponse(self.request, [self.import_template_name], context)

DEDENT
----------------------------------------

def get(self, request, * args, ** kwargs) :
INDENT
    client_name = str(self.client).replace(' ', '_').lower()
    if 'query' in kwargs :
    INDENT
        if kwargs ['query'] == u'complete' :
        INDENT
            complete_runners = Place.objects.filter(
                ~ models.Q(runner__completed_on = None),
                console = self.console).values_list(
                'client',
                flat = True).distinct()
            dataset = PlaceResource().export(
                Place.objects.filter(
                    console = self.console, client = self.client,
                    runner__in = complete_runners))
            filename = '{}_completed_runners'.format(client_name)
        DEDENT
    DEDENT
    else :
    INDENT
        dataset = PlaceResource().export(Place.objects.filter(
                console = self.console, client = self.client,
                ))
        filename = '{}_Runners'.format(client_name)
    DEDENT
    export_type = kwargs ['format']
    _dataset_methods = {
        'csv' : dataset.csv,
        'xls' : dataset.xls}
    response = HttpResponse(
        _dataset_methods [export_type], content_type = export_type)
    response [
        'Content-Disposition'] = 'attachment; filename={filename}.{ext}'.format(
        filename = filename,
        ext = export_type)
    return response
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2401185_2403889_4_9
2401185_3357718_5_10
Title: Python Vector Class 
----------------------------------------

def __init__(cls, name, bases, cdict) :
INDENT
    super(_AutoProperties, cls).__init__(name, bases, cdict)
    for attr in props :
    INDENT
        fget = cls._auto_getter(attr)
        fset = cls._auto_setter(attr)
        setattr(cls, attr, property(fget, fset))
    DEDENT
DEDENT
----------------------------------------

def __init__(cls, name, bases, cdict) :
INDENT
    super(_AutoFloatProperties, cls).__init__(name, bases, cdict)
    for attr in props :
    INDENT
        def fget(self, _attr = '_' + attr) : return getattr(self, _attr)
        def fset(self, value, _attr = '_' + attr) : setattr(self, _attr, float(value))
        setattr(cls, attr, property(fget, fset))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2413271_2413296_1_6
2413271_25909794_3_8
Title: Get decorated function object by string name 
----------------------------------------

def log(func) :
INDENT
    def wrapper(* a, ** kw) :
    INDENT
        return func(* a, ** kw)
    DEDENT
    wrapper.func = func
    return wrapper
DEDENT
----------------------------------------

def log(func) :
INDENT
    @ wraps(func)
    def wrapper(* a, ** kw) :
    INDENT
        return func(* a, ** kw)
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24165374_24166179_4_45
24165374_24168353_6_34
Title: Printing a function's local variable names and values 
----------------------------------------

def show_guts(f) :
INDENT
    sentinel = object()
    gutsdata = threading.local()
    gutsdata.captured_locals = None
    gutsdata.tracing = False
    def trace_locals(frame, event, arg) :
    INDENT
        if event.startswith('c_') :
        INDENT
            return
        DEDENT
        if event == 'call' :
        INDENT
            if gutsdata.tracing :
            INDENT
                return None
            DEDENT
            gutsdata.tracing = True
            return trace_locals
        DEDENT
        if event == 'line' :
        INDENT
            return trace_locals

        DEDENT
        gutsdata.captured_locals = frame.f_locals.copy()
        return None
    DEDENT
    def wrapper(* args, ** kw) :
    INDENT
        old_trace = sys.gettrace()
        sys.settrace(trace_locals)
        retval = sentinel
        try :
        INDENT
            retval = f(* args, ** kw)
        DEDENT
        finally :
        INDENT

            sys.settrace(old_trace)
            for key, val in gutsdata.captured_locals.items() :
            INDENT
                print '{}: {!r}'.format(key, val)
            DEDENT
            if retval is not sentinel :
            INDENT
                print 'Returned: {!r}'.format(retval)
            DEDENT
            gutsdata.captured_locals = None
            gutsdata.tracing = False
        DEDENT
        return retval
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def show_guts(fn) :
INDENT
    source = inspect.getsource(fn)
    lines = []
    for line in source.split('\n') :
    INDENT
        if 'show_guts' in line :
        INDENT
            continue
        DEDENT
        lines.append(line)
        if 'def' in line :
        INDENT
            continue
        DEDENT
        search = assignment_regex.search(line)
        try :
        INDENT
            groups = search.groups()
            leading_whitespace = groups [0]
            variable_name = groups [1]
            lines.append(leading_whitespace + 'print "Assigning {0} =", {0}'.format(variable_name))
        DEDENT
        except AttributeError :
        INDENT
            pass
        DEDENT
    DEDENT
    new_source = '\n'.join(lines)
    namespace = {}
    exec new_source in namespace
    fn = namespace [fn.__name__]
    def wrapped(* args, ** kwargs) :
    INDENT
        arg_string = ', '.join(map(str, args))
        kwarg_string = ', '.join(key + '=' + str(value) for key, value in kwargs.iteritems())
        print "Calling", fn.__name__ + '(' + ', '.join((arg_string, kwarg_string)) + ')'
        return fn(* args, ** kwargs)
    DEDENT
    return wrapped
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24216198_24216256_1_16
24216198_24216303_1_11
Title: Storing a string and a set in a dictionary 
----------------------------------------

def unique_words(input_file) :
INDENT
    file = open(input_file)
    wordlist = {}
    dups = []
    copy = []
    for index, value in enumerate(file) :
    INDENT
        words = value.split()
        for word in words :
        INDENT
            wordlist [word] = index
            dups.append(word)
        DEDENT
    DEDENT
    for word in dups :
    INDENT
        if dups.count(word) ! = 1 and word not in copy :
        INDENT
            del (wordlist [word])
            copy.append(word)
        DEDENT
    DEDENT
    for item in wordlist :
    INDENT
        print 'The unique word ' + item + ' occurs on line ' + str(wordlist [item])
    DEDENT
DEDENT
----------------------------------------

def unique_words(input_file) :
INDENT
    word_map = dict()
    for i, line in enumerate(input_file) :
    INDENT
        words = line.strip().split()
        for word in words :
        INDENT
            word = word.lower().strip(string.punctuation)
            if word in word_map :
            INDENT
                word_map [word] = None
            DEDENT
            else :
            INDENT
                word_map [word] = i
            DEDENT
        DEDENT
    DEDENT
    return dict((w, i) for w, i in word_map.items() if i is not None)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24221921_24222017_1_14
24221921_24222075_3_12
Title: "Python: How to continue overwrite the code after ""Return True""" 
----------------------------------------

def CheckReady() :
INDENT
    with open("CheckReady.txt") as check :
    INDENT
        s = check.read()
    DEDENT
    print "Ready= ", s
    if s == "1" :
    INDENT
        print "ready"
        s = "0"
        with open("TrakStarReady.txt", 'w') as trak :
        INDENT
            trak.write(s)
        DEDENT
        print "Ready= ", s, "Reset Complete"
        return True
    DEDENT
    else :
    INDENT
        print "not ready"
        return False
    DEDENT
DEDENT
----------------------------------------

def CheckReady() :
INDENT
    if os.path.isfile('/my/path/ready.txt') :
    INDENT

        os.rename('/my/path/ready.txt', '/my/path/notready.txt')
        with open("TrakStarReady.txt", 'w') :
        INDENT
            f.write(1)
        DEDENT
        return True
    DEDENT
    else :
    INDENT
        print "not ready"
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24238743_24238851_11_17
24238743_24238851_24_29
Title: Flask: Decorator to verify JSON and JSON Schema 
----------------------------------------

def wrapper(* args, ** kw) :
INDENT
    try :
    INDENT
        request.json
    DEDENT
    except BadRequest, e :
    INDENT
        msg = "payload must be a valid json"
        return jsonify({"error" : msg}), 400
    DEDENT
    return f(* args, ** kw)
DEDENT
----------------------------------------

def wrapper(* args, ** kw) :
INDENT
    try :
    INDENT
        validate(request.json, current_app.config [schema_name])
    DEDENT
    except ValidationError, e :
    INDENT
        return jsonify({"error" : e.message}), 400
    DEDENT
    return f(* args, ** kw)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2424648_2424870_268_275
2424648_2424870_318_324
Title: Getting registry information using Python 
----------------------------------------

def __setitem__(self, key, value) :
INDENT
    'Assign the item to a key.'
    key = Key(_winreg.CreateKey(self.__key, key), mode = KEY.ALL_ACCESS)
    for name in value.values :
    INDENT
        key.values [name] = value.values [name]
    DEDENT
    for name in value.keys :
    INDENT
        key.keys [name] = value.keys [name]
    DEDENT
DEDENT
----------------------------------------

def __setitem__(self, key, value) :
INDENT
    'Assign the item to a value.'
    if isinstance(value, self.TYPES) :
    INDENT
        _winreg.SetValueEx(self.__key, key, 0, list(self.TYPES).index(value.__class__), value.value)
    DEDENT
    else :
    INDENT
        _winreg.SetValueEx(self.__key, key, 0, _winreg.QueryValueEx(self.__key, key) [1], value)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24251190_24251577_3_20
24251190_24252866_2_14
Title: How do I show updated values in the 'label' widget in Python Tkinter GUI? 
----------------------------------------

def getRead() :
INDENT
    global labelR2s
    readComm()

    for i in range(0, len(labelR2s)) :
    INDENT
        labelR2s [i].config(text = printList [i])
    DEDENT
    for i in range(len(labelR2s), len(printList)) :
    INDENT
        labelR2s.append(Tk.Label(frameRead, text = str(printList [i])))
        labelR2s [i].pack(padx = 10, pady = 3)
    DEDENT
    for i in range(len(printList), len(labelR2s)) :
    INDENT
        labelR2s [i].destroy()
    DEDENT
    labelR2s = labelR2s [0 : len(printList)]
    window.update_idletasks()
DEDENT
----------------------------------------

def getRead() :
INDENT
    readComm()

    for i in range(0, len(printList)) :
    INDENT
        if (len(printList) > len(labelR2s)) :
        INDENT
            labelR2s.append(Tk.Label(frameRead, text = str(printList [i])))
            labelR2s [i].pack(padx = 10, pady = 3)
        DEDENT
        else :
        INDENT
            labelR2s [i].config(text = printList [i])
        DEDENT
    DEDENT
    window.update_idletasks()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24251898_27122095_39_62
24251898_40810805_26_35
Title: Flask App: Update progress bar while function runs 
----------------------------------------

def index() :
INDENT
    debug_template = """
     <html>
       <head>
       </head>
       <body>
         <h1>Server sent events</h1>
         <div id="event"><![CDATA[</div>
         <script type="text/javascript"><![CDATA[

         var eventOutputContainer = document.getElementById("event");
         var evtSrc = new EventSource("/subscribe");

         evtSrc.onmessage = function(e) {
             console.log(e.data);
             eventOutputContainer.innerHTML = e.data;
         };

         </script>
       </body>
     </html>
    """
    return (debug_template)
DEDENT
----------------------------------------

def index() :
INDENT
    global exporting_threads
    thread_id = random.randint(0, 10000)
    exporting_threads [thread_id] = ExportingThread()
    exporting_threads [thread_id].start()
    return 'task id: #%s' % thread_id

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2425543_2425670_1_14
2425543_2425687_1_29
Title: Python: list assignment out of range 
----------------------------------------

def deleteitem() :
INDENT
    showlist()
    get_item = int(raw_input("\n Enter number of item to delete: \n"))
    f = open('todo.txt')
    lines = f.readlines()
    f.close()
    try :
    INDENT
        lines [get_item] = ""
    DEDENT
    except Exception, err :
    INDENT
        print err
    DEDENT
    f = open('todo.txt', 'w')
    f.writelines(lines)
    f.close()
    showlist()
DEDENT
----------------------------------------

def deleteitem() :
INDENT
    showlist()
    with open("todo.txt") as f :
    INDENT
        lines = f.readlines()
    DEDENT
    if len(lines) == 0 :
    INDENT
        return
    DEDENT
    prompt = "Enter number to delete (1-%d), or 0 to abort: " % len(lines)
    while True :
    INDENT
        input = raw_input(prompt)
        try :
        INDENT
            input = int(input, 10)
        DEDENT
        except ValueError :
        INDENT
            print "Invalid input."
        DEDENT
        else :
        INDENT
            if 0 < = input < = len(lines) :
            INDENT
                break
            DEDENT
            print "Input out of range."
        DEDENT
    DEDENT
    if input == 0 :
    INDENT
        return
    DEDENT
    input -= 1

    lines [input] = "\n"
    with open("todo.txt", "w") as f :
    INDENT
        f.writelines(lines)
    DEDENT
    showlist()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24307959_24308785_10_38
24307959_24309206_1_15
Title: Find borders on a list in python 
----------------------------------------

def find_borders(L) :
INDENT
    it = iter(L)
    start_none = False
    for item in it :
    INDENT
        if item is None :
        INDENT
            start_none = True
            continue
        DEDENT
        if start_none :
        INDENT
            start = item
        DEDENT
        else :
        INDENT
            start = None
        DEDENT
        end = item
        end_none = False
        for item in it :
        INDENT
            if item is None :
            INDENT
                end_none = True
                break
            DEDENT
            end = item
        DEDENT
        if not end_none :
        INDENT
            end = None
        DEDENT
        yield (start, end)
        start_none = True
    DEDENT
DEDENT
----------------------------------------

def find_borders(L) :
INDENT
    entries = []
    exits = []
    if L [0] is not None :
    INDENT
        entries.append(None)
    DEDENT
    for i in range(len(L [: - 2])) :
    INDENT
        if L [i] is None :
        INDENT
            entries.append(L [i + 1])
        DEDENT
        if L [i + 2] is None :
        INDENT
            exits.append(L [i + 1])
        DEDENT
    DEDENT
    if L [- 1] is not None :
    INDENT
        exits.append(None)
    DEDENT
    return zip(entries, exits)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24319631_24319783_1_8
24319631_24319866_3_13
Title: checking whether representation of number in a given base is valid 
----------------------------------------

def check(n, a, i = 0) :
INDENT
    if len(n) < = i :
    INDENT
        return True
    DEDENT
    if int(n [i]) > = a :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        return check(n, a, i + 1)
    DEDENT
DEDENT
----------------------------------------

def check(num, base, i = 0) :
INDENT
    if i > = len(num) :
    INDENT
        return True
    DEDENT
    if not num [i].isdigit() :
    INDENT
        val = string.ascii_lowercase.find(num [i].lower())
        if val == - 1 or val + 10 > = base :
        INDENT
            return False
        DEDENT
    DEDENT
    elif int(num [i]) > = base :
    INDENT
        return False
    DEDENT
    return check(num, base, i + 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24355300_24356729_1_11
24355300_31157444_1_20
Title: While Loop Print List formatting 
----------------------------------------

def factors(num) :
INDENT
    i = 1
    result = "["
    while i < = num :
    INDENT
        if num % i == 0 :
        INDENT
            result = result + str(i) + ","
        DEDENT
        i += i
    DEDENT
    result = result [: - 1] + "]"
    print result
DEDENT
----------------------------------------

def factors(num) :
INDENT
    i = 1
    while i < = num :
    INDENT
        if i == 1 :
        INDENT
            if num % i == 0 :
            INDENT
                print "[",
            DEDENT
            else :
            INDENT
                print "[",
            DEDENT
        DEDENT
        if i == num :
        INDENT
            print "%s]" % (i)
        DEDENT
        elif num % i == 0 :
        INDENT
            if i == num :
            INDENT
                print i, "]"
            DEDENT
            else :
            INDENT
                print "%s," % (i),
            DEDENT
        DEDENT
        i = i + 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24355300_24356729_1_11
24355300_31159413_1_9
Title: While Loop Print List formatting 
----------------------------------------

def factors(num) :
INDENT
    i = 1
    result = "["
    while i < = num :
    INDENT
        if num % i == 0 :
        INDENT
            result = result + str(i) + ","
        DEDENT
        i += i
    DEDENT
    result = result [: - 1] + "]"
    print result
DEDENT
----------------------------------------

def factors(num) :
INDENT
    i = 1
    a = "["
    while i < num :
    INDENT
        if num % i == 0 :
        INDENT
            a += str(i) + ", "
        DEDENT
        i = i + 1
    DEDENT
    print (a + str(num) + str("]"))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24355300_31157444_1_20
24355300_31159413_1_9
Title: While Loop Print List formatting 
----------------------------------------

def factors(num) :
INDENT
    i = 1
    while i < = num :
    INDENT
        if i == 1 :
        INDENT
            if num % i == 0 :
            INDENT
                print "[",
            DEDENT
            else :
            INDENT
                print "[",
            DEDENT
        DEDENT
        if i == num :
        INDENT
            print "%s]" % (i)
        DEDENT
        elif num % i == 0 :
        INDENT
            if i == num :
            INDENT
                print i, "]"
            DEDENT
            else :
            INDENT
                print "%s," % (i),
            DEDENT
        DEDENT
        i = i + 1
    DEDENT
DEDENT
----------------------------------------

def factors(num) :
INDENT
    i = 1
    a = "["
    while i < num :
    INDENT
        if num % i == 0 :
        INDENT
            a += str(i) + ", "
        DEDENT
        i = i + 1
    DEDENT
    print (a + str(num) + str("]"))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24355300_31157444_1_20
24355300_33194048_1_11
Title: While Loop Print List formatting 
----------------------------------------

def factors(num) :
INDENT
    i = 1
    while i < = num :
    INDENT
        if i == 1 :
        INDENT
            if num % i == 0 :
            INDENT
                print "[",
            DEDENT
            else :
            INDENT
                print "[",
            DEDENT
        DEDENT
        if i == num :
        INDENT
            print "%s]" % (i)
        DEDENT
        elif num % i == 0 :
        INDENT
            if i == num :
            INDENT
                print i, "]"
            DEDENT
            else :
            INDENT
                print "%s," % (i),
            DEDENT
        DEDENT
        i = i + 1
    DEDENT
DEDENT
----------------------------------------

def factors(num) :
INDENT
    i = 1
    factors = []
    while i < = num :
    INDENT
        if num % i == 0 :
        INDENT
            factors.append(i)
        DEDENT
    DEDENT
    i += 1
    print factors
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24355300_31159413_1_9
24355300_33194048_1_11
Title: While Loop Print List formatting 
----------------------------------------

def factors(num) :
INDENT
    i = 1
    a = "["
    while i < num :
    INDENT
        if num % i == 0 :
        INDENT
            a += str(i) + ", "
        DEDENT
        i = i + 1
    DEDENT
    print (a + str(num) + str("]"))
DEDENT
----------------------------------------

def factors(num) :
INDENT
    i = 1
    factors = []
    while i < = num :
    INDENT
        if num % i == 0 :
        INDENT
            factors.append(i)
        DEDENT
    DEDENT
    i += 1
    print factors
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24357256_24357759_4_25
24357256_34784001_4_38
Title: Are there any Tkinter Widgets like OptionMenu that can be nested? 
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self, parent)
    items = {"one" : ["a", "b", "c"],
        "two" : ["d", "e", "f"],
        "three" : ["g", "h", "i"]}
    self.the_value = tk.StringVar()
    self.the_value.set("a")
    self.menubutton = tk.Menubutton(self, textvariable = self.the_value, indicatoron = True)
    self.topMenu = tk.Menu(self.menubutton, tearoff = False)
    self.menubutton.configure(menu = self.topMenu)
    for key in sorted(items.keys()) :
    INDENT
        menu = tk.Menu(self.topMenu)
        self.topMenu.add_cascade(label = key, menu = menu)
        for value in items [key] :
        INDENT
            menu.add_radiobutton(label = value, variable = self.the_value, value = value)
        DEDENT
    DEDENT
    self.menubutton.pack()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    def create_menu(top_info, top_menu, value_var) :
    INDENT
        if isinstance(top_info, dict) :
        INDENT
            print "Evaluating dictionary with keys:"
            for key in top_info.keys() :
            INDENT
                print 'Key:' + key
                menu = tk.Menu(top_menu)
                top_menu.add_cascade(label = key, menu = menu)
                create_menu(top_info [key], menu, value_var)
            DEDENT
            return
        DEDENT
        else :
        INDENT
            print "Evaluating list of values:"
            for value in top_info :
            INDENT
                print 'Value:' + value
                top_menu.add_radiobutton(label = value, variable = value_var, value = value)
            DEDENT
            return
        DEDENT
    DEDENT
    tk.Frame.__init__(self, parent)
    items = {"one" : {"a" : ["aa", "aaa", "aaaa"], "b" : ["bb", "bb"], "c" : ["cc"]},
        "two" : ["d", "e", "f"],
        "three" : ["g", "h", "i"]}
    self.the_value = tk.StringVar()
    self.the_value.set("a")
    self.menubutton = tk.Menubutton(self, textvariable = self.the_value, indicatoron = True)
    self.topMenu = tk.Menu(self.menubutton, tearoff = False)
    self.menubutton.configure(menu = self.topMenu)
    create_menu(items, self.topMenu, self.the_value)
    self.menubutton.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24359181_24362204_10_23
24359181_24362204_31_64
Title: pySide QComboBox refresh 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QDialog.__init__(self, parent)
    self.tabWidget = QtGui.QTabWidget()
    self.mainTab = mainTab(self)
    self.secondTab = secondTab(self)
    self.tabWidget.addTab(self.mainTab, self.tr("Main"))
    self.tabWidget.addTab(self.secondTab, self.tr("Second "))
    mainLayout = QtGui.QVBoxLayout()
    mainLayout.addWidget(self.tabWidget)
    self.setLayout(mainLayout)
DEDENT
----------------------------------------

def __init__(self, parent = tabDialog) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    self.q = 1234
    self.createGroup = QtGui.QGroupBox(self.tr("Add Item to list"))
    self.fileNameEdit = QtGui.QLineEdit(self)
    self.fileNameEdit.setPlaceholderText("new item")

    self.createButton = QtGui.QPushButton('add', self)
    self.createButton.clicked.connect(parent.additemToList)
    self.createLayout = QtGui.QGridLayout()
    self.createLayout.addWidget(self.fileNameEdit, 1, 2)
    self.createLayout.addWidget(self.createButton, 1, 3)
    self.setLayout(self.createLayout)
    self.createGroup.setLayout(self.createLayout)

    self.addGroup = QtGui.QGroupBox(self.tr("list items"))
    self.projectLabel = QtGui.QLabel(self.tr("item : "))
    self.projectListCombo = QtGui.QComboBox(self)
    self.projectListCombo.addItems(listItems())
    self.addLayout = QtGui.QHBoxLayout()
    self.addLayout.addWidget(self.projectLabel)
    self.addLayout.addWidget(self.projectListCombo)
    self.addGroup.setLayout(self.addLayout)
    self.mainLayout = QtGui.QVBoxLayout()
    self.mainLayout.addWidget(self.createGroup)
    self.mainLayout.addWidget(self.addGroup)
    self.setLayout(self.mainLayout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24373987_24375063_1_18
24373987_24375358_3_11
Title: Generator for combinations in special order 
----------------------------------------

def h(width, top, top_count) :
INDENT
    if width == 0 :
    INDENT
        yield []
    DEDENT
    elif width == top_count :
    INDENT
        yield [top - 1] * top_count
    DEDENT
    else :
    INDENT
        for x in range(top - 1) :
        INDENT
            for result in h(width - 1, top, top_count) :
            INDENT
                yield [x] + result
            DEDENT
        DEDENT
        if top_count > 0 :
        INDENT
            for result in h(width - 1, top, top_count - 1) :
            INDENT
                yield [top - 1] + result

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def h(width, top) :
INDENT
    for t in range(top) :
    INDENT
        for topAmount in range(1, width + 1) :
        INDENT
            for topPositions in combinations(range(width), topAmount) :
            INDENT
                for fillers in product(
                    * [range(t) for x in range(width - len(topPositions))]) :
                INDENT
                    fillers = list(fillers)
                    yield [t if i in topPositions else fillers.pop() for i in range(width)]
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24419321_24424443_24_31
24419321_24424443_3_19
Title: How do I scroll to the bottom of a ScrolledWindow when using a sizer 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, 'Programmatic size change')
    sz = wx.BoxSizer(wx.VERTICAL)
    self.ascrolledwindow = AScrolledWindow(self)
    sz.Add(self.ascrolledwindow, 1, wx.EXPAND)
    self.SetSizer(sz)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    self.parent = parent
    wx.ScrolledWindow.__init__(self, parent, - 1, style = wx.TAB_TRAVERSAL)
    box = wx.BoxSizer(wx.VERTICAL)
    self.sizer = box
    self._labels = []
    self.button = wx.Button(self, - 1, "Scroll Me")
    box.Add(self.button)
    self.Bind(wx.EVT_BUTTON, self.OnClickTop, self.button)
    for y in xrange(1, 30) :
    INDENT
        self._labels.append(wx.StaticText(self, - 1, "Label #%d" % (y,)))
        box.Add(self._labels [- 1])
    DEDENT
    self.SetSizer(self.sizer)
    fontsz = wx.SystemSettings.GetFont(wx.SYS_SYSTEM_FONT).GetPixelSize()
    self.SetScrollRate(fontsz.x, fontsz.y)
    self.EnableScrolling(True, True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24431743_24431798_12_17
24431743_24432009_16_24
Title: Python - sort method parameter takes same precedence 
----------------------------------------

def __lt__(self, other) :
INDENT
    if not self.lastName :
    INDENT
        if not other.lastName :
        INDENT
            return self.firstName < other.firstName
        DEDENT
        return self.firstName < other.lastName
    DEDENT
    return (self.lastName, self.firstName) < (other.lastName, other.firstName)
DEDENT
----------------------------------------

def __lt__(self, other) :
INDENT
    if self.last_name and other.last_name :
    INDENT
        if self.last_name == other.last_name :
        INDENT
            return self.first_name < other.first_name
        DEDENT
        return self.last_name < other.last_name
    DEDENT
    else :
    INDENT
        if other.last_name :
        INDENT
            return self.first_name < other.last_name
        DEDENT
        return self.first_name < other.first_name
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24443879_24443926_1_11
24443879_24443948_14_23
Title: Program stuck in while loop not printing 
----------------------------------------

def usertypetest(x, y, result) :
INDENT
    while x < = 9 :
    INDENT
        result = usertype()
        if result == 'Correct' :
        INDENT
            x = x + 1
            y = y + 5
        DEDENT
        else :
        INDENT
            x = x + 1
            y = y - 2
        DEDENT
        print (result)
    DEDENT
    return str(y) + 'is your score'
DEDENT
----------------------------------------

def usertypetest(moves, score) :
INDENT
    while moves < 10 :
    INDENT
        result = usertype()
        moves = moves + 1
        if result :
        INDENT
            score = score + 5
        DEDENT
        else :
        INDENT
            score = score - 2
        DEDENT
    DEDENT
    return str(score) + ' is your score'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24443879_24443947_11_21
24443879_24443948_14_23
Title: Program stuck in while loop not printing 
----------------------------------------

def usertypetest(x, y, result) :
INDENT
    while x < = 9 :
    INDENT
        result = usertype()
        if result == 'Correct' :
        INDENT
            x = x + 1
            y = y + 5
        DEDENT
        else :
        INDENT
            x = x + 1
            y = y - 2
        DEDENT
    DEDENT
    return str(y) + 'is your score'
DEDENT
----------------------------------------

def usertypetest(moves, score) :
INDENT
    while moves < 10 :
    INDENT
        result = usertype()
        moves = moves + 1
        if result :
        INDENT
            score = score + 5
        DEDENT
        else :
        INDENT
            score = score - 2
        DEDENT
    DEDENT
    return str(score) + ' is your score'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24449482_24449815_3_13
24449482_24449991_1_14
Title: Specific sequence stored in a list 
----------------------------------------

def is_sequence_same(l1, l2) :
INDENT
    if l1 == l2 :
    INDENT
        return True
    DEDENT
    if set(l1) ! = set(l2) or len(l1) ! = len(l2) :
    INDENT
        return False
    DEDENT
    d2 = deque(l2)
    for i in range(len(l2)) :
    INDENT
        if l1 == list(d2) :
        INDENT
            return True
        DEDENT
        d2.rotate()
    DEDENT
    return False
DEDENT
----------------------------------------

def is_sequence_same(first, second) :
INDENT
    try :
    INDENT
        i = second.index(first [0])
        if i == - 1 :
        INDENT
            return False
        DEDENT
        for e in first [1 :] :
        INDENT
            i += 1
            if i == len(second) :
            INDENT
                i = 0
            DEDENT
            if e ! = second [i] :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    except ValueError :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24469090_24469597_18_27
24469090_24470107_19_31
Title: Detect simultaneous left and right clicks in python gui 
----------------------------------------

def onAnyofTwoPressed(self, event) :
INDENT
    if event.num == 1 :
    INDENT
        self.left_mouse_pressed = True
    DEDENT
    if event.num == 3 :
    INDENT
        self.right_mouse_pressed = True
    DEDENT
    if (self.left_mouse_pressed and self.right_mouse_pressed) :
    INDENT
        print 'yay both pressed'
    DEDENT
DEDENT
----------------------------------------

def onAnyofTwoPressed(self, event) :
INDENT
    if self.left_mouse_pressed and self.left_mouse_pressed < = time.time() :
    INDENT
        self.left_mouse_pressed = False
    DEDENT
    if self.right_mouse_pressed and self.right_mouse_pressed < = time.time() :
    INDENT
        self.right_mouse_pressed = False
    DEDENT
    if event.num == 1 :
    INDENT
        self.left_mouse_pressed = time.time() + 500
    DEDENT
    if event.num == 3 :
    INDENT
        self.right_mouse_pressed = time.time() + 500

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24518944_24519419_9_23
24518944_24531618_4_15
Title: Try/except when using Python requests module 
----------------------------------------

def return_json(url) :
INDENT
    try :
    INDENT
        response = requests.get(url)

        if not response.status_code / / 100 == 2 :
        INDENT
            return "Error: Unexpected response {}".format(response)
        DEDENT
        json_obj = response.json()
        return json_obj
    DEDENT
    except requests.exceptions.RequestException as e :
    INDENT
        return "Error: {}".format(e)

    DEDENT
DEDENT
----------------------------------------

def return_json(URL) :
INDENT
    response = requests.get(testURL)
    try :
    INDENT
        response.raise_for_status()
    DEDENT
    except requests.exceptions.HTTPError as e :
    INDENT
        return "Error: " + str(e)

    DEDENT
    json_obj = response.json()
    return json_obj
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24528278_24528746_10_20
24528278_24530696_1_13
Title: Stream multiple files into a readable object in Python 
----------------------------------------

def read(self, size = None) :
INDENT
    remaining = size
    data = StringIO()
    while self.fds and (remaining > 0 or remaining is None) :
    INDENT
        data_read = self.fds [- 1].read(remaining or - 1)
        if len(data_read) < remaining or remaining is None :
        INDENT
            self.fds.pop()
        DEDENT
        if not remaining is None :
        INDENT
            remaining -= len(data_read)
        DEDENT
        data.write(data_read)
    DEDENT
    return data.getvalue()
DEDENT
----------------------------------------

def read(self, block_size = None) :
INDENT
    block_size = block_size or self._block_size
    total_read = 0
    chunks = []
    for chunk in self._reader :
    INDENT
        chunks.append(chunk)
        total_read += len(chunk)
        if total_read > block_size :
        INDENT
            contents = ''.join(chunks)
            self._reader = chain([contents [block_size :]], self._reader)
            return contents [: block_size]
        DEDENT
    DEDENT
    return ''.join(chunks)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24557228_24561135_5_11
24557228_24582942_5_12
Title: python - global variables 
----------------------------------------

def __init__(self, threadID, name, q) :
INDENT
    threading.Thread.__init__(self)
    self.threadID = threadID
    self.name = name
    self.q = q
    self.__exitFlag = False
    self.__signal_lock = threading.Lock()
DEDENT
----------------------------------------

def __init__(self, threadID, threadname, q) :
INDENT
    threading.Thread.__init__(self)
    self.threadID = threadID
    self.threadname = threadname
    self.queue = q
    self.__exitFlag = False
    self.__signal_lock = threading.Lock()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24560112_24560340_1_15
24560112_24560470_2_15
Title: How to get my code to stop printing a keyword in my web crawler 
----------------------------------------

def seo(url) :
INDENT
    result = requests.get(url)
    soup = BeautifulSoup(result.text)
    lowercased = result.text.lower()
    keywords = ['creative']
    for keyword in keywords :
    INDENT
        if keyword.lower() in lowercased :
        INDENT
            print (keyword)
            return True
        DEDENT
    DEDENT
    links = soup.find_all('a') [1 :]
    for link in links :
    INDENT
        if seo(link ['href']) :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def seo(url) :
INDENT
    result = requests.get(url)
    soup = BeautifulSoup(result.text)
    links = [urlparse.urljoin(url, tag ['href']) for tag in soup.findAll('a', href = True)]
    lower_cased = result.text.lower()
    keywords = ['creative']
    while links :
    INDENT
        for keyword in keywords :
        INDENT
            if keyword.lower() in lower_cased :
            INDENT
                print "Success we found the keyword: {}".format(keyword)
                return
            DEDENT
        DEDENT
        link = links.pop()
        result = requests.get(link)
        lower_cased = result.text.lower()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24571558_24571972_6_16
24571558_24573149_4_12
Title: Can't play animation in wxPython 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, - 1, title)
    self.animation = AnimationCtrl(self, pos = (40, 40), size = (24, 24), name = "AnimationCtrl")
    self.animation.LoadFile("animated.gif")
    self.animation.Play()
    size = (400, 400)
    self.SetSize(size)
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent, id = wx.ID_ANY, title = u"Testing!", pos = wx.DefaultPosition, size = (300, 300), style = wx.DEFAULT_FRAME_STYLE | wx.RESIZE_BORDER)
    self.m_animCtrl1 = wx.animate.AnimationCtrl(self, wx.ID_ANY, wx.animate.NullAnimation, (40, 40), (- 1, - 1), wx.animate.AC_DEFAULT_STYLE)
    self.m_animCtrl1.LoadFile(u"img.GIF")
    self.m_animCtrl1.Play()
    self.Layout()
    self.Show()
    self.Centre(wx.BOTH)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24577876_24578069_6_11
24577876_24578070_4_9
Title: Is there an error in PythonDecoratorLibrary - Property Definition 3? 
----------------------------------------

def probe_func(frame, event, arg) :
INDENT
    if event == 'return' :
    INDENT
        locals = frame.f_locals
        func_locals.update(dict((k, locals.get(k)) for k in keys))
        sys.settrace(None)
    DEDENT
    return probe_func
DEDENT
----------------------------------------

def probe_func(frame, event, arg) :
INDENT
    if event == 'return' :
    INDENT
        locals = frame.f_locals
        func_locals.update(dict((k, locals.get(k)) for k in keys))
        sys.settrace(None)
    DEDENT
    return probe_func
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24580815_24582351_4_9
24580815_24686022_4_9
Title: improving performance of a Python puzzle 
----------------------------------------

def number_of_distinct_permutations(counts) :
INDENT
    f = factorial(sum(counts.values()))
    for letter, count in counts.items() :
    INDENT
        f //= factorial(count)
    DEDENT
    return f
DEDENT
----------------------------------------

def number_of_distinct_permutations(counted) :
INDENT
    result = factorial(sum(counted))
    for each in counted :
    INDENT
        result //= factorial(each)
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24583017_24583171_4_11
24583017_24583366_3_14
Title: mix two uneven lists with fill requirements 
----------------------------------------

def mix(a, b) :
INDENT
    diff = len(a) - len(b)
    fill = 'spam'
    if diff > 0 :
    INDENT
        b = [fill] * diff + b
    DEDENT
    elif diff < 0 :
    INDENT
        a = [fill] * abs(diff) + a
    DEDENT
    return list(itertools.chain(* zip(a, b)))
DEDENT
----------------------------------------

def mix(a, b) :
INDENT
    a_rev = reversed(a)
    b_rev = reversed(b)
    if len(a) > len(b) :
    INDENT
        temp = itertools.izip_longest(a_rev, b_rev, fillvalue = 'spam')
    DEDENT
    elif len(b) > len(a) :
    INDENT
        temp = itertools.izip_longest(b_rev, a_rev, fillvalue = 'spam')
    DEDENT
    sequence = list()
    for item in temp :
    sequence.extend(item)
    return sequence
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24585885_24589847_36_66
24585885_24591488_17_72
Title: trying to split the file download buffer to into separate threads 
----------------------------------------

def main(url = None, splitBy = 3) :
INDENT
    start_time = time.time()
    if not url :
    INDENT
        print "Please Enter some url to begin download."
        return
    DEDENT
    fileName = url.split('/') [- 1]
    sizeInBytes = requests.head(url, headers = {'Accept-Encoding' : 'identity'}).headers.get('content-length', None)
    print "%s bytes to download." % sizeInBytes
    if not sizeInBytes :
    INDENT
        print "Size cannot be determined."
        return
    DEDENT
    dataLst = []
    for idx in range(splitBy) :
    INDENT
        byteRange = buildRange(int(sizeInBytes), splitBy) [idx]
        bufTh = SplitBufferThreads(url, byteRange)
        bufTh.start()
        bufTh.join()
        dataLst.append(bufTh.getFileData())
    DEDENT
    content = ''.join(dataLst)
    if dataLst :
    INDENT
        if os.path.exists(fileName) :
        INDENT
            os.remove(fileName)
        DEDENT
        print "--- %s seconds ---" % str(time.time() - start_time)
        with open(fileName, 'w') as fh :
        INDENT
            fh.write(content)
        DEDENT
        print "Finished Writing file %s" % fileName
    DEDENT
DEDENT
----------------------------------------

def main(url = None, splitBy = 3) :
INDENT
    start_time = time.time()
    if not url :
    INDENT
        print "Please Enter some url to begin download."
        return
    DEDENT
    fileName = url.split('/') [- 1]
    sizeInBytes = requests.head(url, headers = {'Accept-Encoding' : 'identity'}).headers.get('content-length', None)
    print "%s bytes to download." % sizeInBytes
    if not sizeInBytes :
    INDENT
        print "Size cannot be determined."
        return
    DEDENT
    dataDict = {}

    ranges = buildRange(int(sizeInBytes), splitBy)
    def downloadChunk(idx, irange) :
    INDENT
        req = urllib2.Request(url)
        req.headers ['Range'] = 'bytes={}'.format(irange)
        dataDict [idx] = urllib2.urlopen(req).read()

    DEDENT
    downloaders = [
        threading.Thread(
            target = downloadChunk,
            args = (idx, irange),
            ) for idx, irange in enumerate(ranges)
        ]

    for th in downloaders :
    INDENT
        th.start()
    DEDENT
    for th in downloaders :
    INDENT
        th.join()
    DEDENT
    print 'done: got {} chunks, total {} bytes'.format(
        len(dataDict), sum((
                len(chunk) for chunk in dataDict.values()
                )))
    print "--- %s seconds ---" % str(time.time() - start_time)
    if os.path.exists(fileName) :
    INDENT
        os.remove(fileName)
    DEDENT
    with open(fileName, 'w') as fh :
    INDENT
        for _idx, chunk in sorted(dataDict.iteritems()) :
        INDENT
            fh.write(chunk)
        DEDENT
    DEDENT
    print "Finished Writing file %s" % fileName
    print 'file size {} bytes'.format(os.path.getsize(fileName))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2459295_20409020_8_19
2459295_23642203_18_33
Title: Invertible STFT and ISTFT in Python 
----------------------------------------

def istft(X, overlap = 4) :
INDENT
    fftsize = (X.shape [1] - 1) * 2
    hop = fftsize / overlap
    w = scipy.hanning(fftsize + 1) [: - 1]
    x = scipy.zeros(X.shape [0] * hop)
    wsum = scipy.zeros(X.shape [0] * hop)
    for n, i in enumerate(range(0, len(x) - fftsize, hop)) :
    INDENT
        x [i : i + fftsize] += scipy.real(np.fft.irfft(X [n])) * w
        wsum [i : i + fftsize] += w ** 2.
    DEDENT
    pos = wsum ! = 0
    x [pos] /= wsum [pos]
    return x
DEDENT
----------------------------------------

def istft(X, fs, T, hop) :
INDENT
    length = T * fs
    x = scipy.zeros(T * fs)
    framesamp = X.shape [1]
    hopsamp = int(hop * fs)
    for n, i in enumerate(range(0, len(x) - framesamp, hopsamp)) :
    INDENT
        x [i : i + framesamp] += scipy.real(scipy.ifft(X [n]))
    DEDENT
    env = scipy.zeros(T * fs)
    w = scipy.hamming(framesamp)
    for i in range(0, len(x) - framesamp, hopsamp) :
    INDENT
        env [i : i + framesamp] += w
    DEDENT
    env [- (length % hopsamp) :] += w [- (length % hopsamp) :]
    env = np.maximum(env,.01)
    return x / env
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2459295_20409020_8_19
2459295_51586974_9_24
Title: Invertible STFT and ISTFT in Python 
----------------------------------------

def istft(X, overlap = 4) :
INDENT
    fftsize = (X.shape [1] - 1) * 2
    hop = fftsize / overlap
    w = scipy.hanning(fftsize + 1) [: - 1]
    x = scipy.zeros(X.shape [0] * hop)
    wsum = scipy.zeros(X.shape [0] * hop)
    for n, i in enumerate(range(0, len(x) - fftsize, hop)) :
    INDENT
        x [i : i + fftsize] += scipy.real(np.fft.irfft(X [n])) * w
        wsum [i : i + fftsize] += w ** 2.
    DEDENT
    pos = wsum ! = 0
    x [pos] /= wsum [pos]
    return x
DEDENT
----------------------------------------

def istft(X, overlap = 4) :
INDENT
    fftsize = (X.shape [1] - 1) * 2
    hop = fftsize / / overlap
    w = scipy.hanning(fftsize + 1) [: - 1]
    rcs = int(np.ceil(float(X.shape [0]) / float(overlap))) * fftsize
    print (rcs)
    x = np.zeros(rcs)
    wsum = np.zeros(rcs)
    for n, i in zip(X, range(0, len(X) * hop, hop)) :
    INDENT
        l = len(x [i : i + fftsize])
        x [i : i + fftsize] += np.fft.irfft(n).real [: l]
        wsum [i : i + fftsize] += w [: l]
    DEDENT
    pos = wsum ! = 0
    x [pos] /= wsum [pos]
    return x
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2459295_23642203_18_33
2459295_51586974_9_24
Title: Invertible STFT and ISTFT in Python 
----------------------------------------

def istft(X, fs, T, hop) :
INDENT
    length = T * fs
    x = scipy.zeros(T * fs)
    framesamp = X.shape [1]
    hopsamp = int(hop * fs)
    for n, i in enumerate(range(0, len(x) - framesamp, hopsamp)) :
    INDENT
        x [i : i + framesamp] += scipy.real(scipy.ifft(X [n]))
    DEDENT
    env = scipy.zeros(T * fs)
    w = scipy.hamming(framesamp)
    for i in range(0, len(x) - framesamp, hopsamp) :
    INDENT
        env [i : i + framesamp] += w
    DEDENT
    env [- (length % hopsamp) :] += w [- (length % hopsamp) :]
    env = np.maximum(env,.01)
    return x / env
DEDENT
----------------------------------------

def istft(X, overlap = 4) :
INDENT
    fftsize = (X.shape [1] - 1) * 2
    hop = fftsize / / overlap
    w = scipy.hanning(fftsize + 1) [: - 1]
    rcs = int(np.ceil(float(X.shape [0]) / float(overlap))) * fftsize
    print (rcs)
    x = np.zeros(rcs)
    wsum = np.zeros(rcs)
    for n, i in zip(X, range(0, len(X) * hop, hop)) :
    INDENT
        l = len(x [i : i + fftsize])
        x [i : i + fftsize] += np.fft.irfft(n).real [: l]
        wsum [i : i + fftsize] += w [: l]
    DEDENT
    pos = wsum ! = 0
    x [pos] /= wsum [pos]
    return x
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24616757_24634370_2_46
24616757_24680327_5_32
Title: Maya Python: cmds.button( ) with UI passing variables and calling a function? 
----------------------------------------

def superExtrude(* args) :
INDENT
    myObjectLt = pm.ls(selection = True)

    for i in myObjectLt :
    INDENT

        pm.select(cl = True)

        thisScale = extrScaleVal.getValue()

        pm.polyExtrudeFacet(i.getShape().f, constructionHistory = True, keepFacesTogether = False, localScaleX = thisScale, localScaleY = thisScale, localScaleZ = thisScale)
        pm.delete()

        thisDist = extrDistVal.getValue()
        pm.polyExtrudeFacet(i.getShape().f, constructionHistory = True, keepFacesTogether = True, localTranslateZ = thisDist)
    DEDENT
DEDENT
----------------------------------------

def superExtrude(extrScaleField, extrDistField, * args) :
INDENT
    myObjectLt = cmds.ls(selection = True)

    extrScale = cmds.floatField(extrScaleField, q = 1, v = 1)
    extrDist = cmds.floatField(extrDistField, q = 1, v = 1)
    for i in range(len(myObjectLt)) :
    INDENT
        numFaces = cmds.polyEvaluate(face = True)
        item = myObjectLt [i] + ".f[:]"
        cmds.select(clear = True)
        cmds.select(item, replace = True)

        cmds.polyExtrudeFacet(constructionHistory = True, keepFacesTogether = False, localScaleX = extrScale, localScaleY = extrScale, localScaleZ = extrScale)
        selFaces = cmds.ls(selection = True)
        cmds.delete(selFaces)

        cmds.select(item, replace = True)
        cmds.polyExtrudeFacet(constructionHistory = True, keepFacesTogether = True, localTranslateZ = extrDist)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24616757_24634370_47_78
24616757_24680327_33_61
Title: Maya Python: cmds.button( ) with UI passing variables and calling a function? 
----------------------------------------

def extrWindow() :
INDENT
    global extrScaleVal, extrDistVal
    """Creates the user interface UI for the user input of the extrusion scale and height"""
    windowID = "superExtrWindow"

    try :
    INDENT
        pm.deleteUI(windowID)
    DEDENT
    except :
    INDENT
        pass
    DEDENT
    pm.window(windowID, title = "SuperExtrude", sizeable = False, resizeToFitChildren = True)
    pm.rowColumnLayout(numberOfColumns = 2, columnWidth = [(1, 120), (2, 120)], columnOffset = [1, "right", 3])
    pm.text(label = "Extrusion Scale:")
    extrScaleVal = pm.floatField(v = 0.9)
    pm.text(label = "Extrusion Height:")
    extrDistVal = pm.floatField(v = - 0.3)
    pm.separator(height = 10, style = "none")
    pm.separator(height = 10, style = "none")
    pm.separator(height = 10, style = "none")
    pm.button(label = "Apply", c = superExtrude)
    pm.showWindow()
DEDENT
----------------------------------------

def extrWindow() :
INDENT
    windowID = "superExtrWindow"
    if cmds.window(windowID, exists = True) :
    INDENT
        cmds.deleteUI(windowID)
    DEDENT
    cmds.window(windowID, title = "SuperExtrude", sizeable = False, resizeToFitChildren = True)
    cmds.rowColumnLayout(numberOfColumns = 2, columnWidth = [(1, 120), (2, 120)], columnOffset = [1, "right", 3])
    cmds.text(label = "Extrusion Scale:")

    extrScaleVal = cmds.floatField(value = 0.9)
    cmds.text(label = "Extrusion Height:")
    extrDistVal = cmds.floatField(value = - 0.3)
    cmds.separator(height = 10, style = "none")
    cmds.separator(height = 10, style = "none")
    cmds.separator(height = 10, style = "none")

    cmds.button(label = "Apply", command = partial(superExtrude, extrScaleVal, extrDistVal))
    cmds.showWindow(windowID)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24619098_24619235_3_19
24619098_24619459_1_21
Title: Python does not accept some numeric inputs 
----------------------------------------

def DashInsertII(num) :
INDENT
    num_str = str(num)

    num_str = re.sub(r'([02468])([02468])', r'\1*\2', num_str)

    num_str = re.sub(r'([13579])([13579])', r'\1-\2', num_str)
    return num_str
DEDENT
----------------------------------------

def DashInsertII(num) :
INDENT
    prev_even = (int(num [0]) % 2 == 0)
    result = num [0]
    for i in num [1 :] :
    INDENT

        curr_even = (int(i) % 2 == 0)
        if prev_even and curr_even :
        INDENT
            result += '*'
        DEDENT
        elif not prev_even and not curr_even :
        INDENT
            result += '-'
        DEDENT
        result += i
        prev_even = curr_even
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2462401_2500375_6_20
2462401_2595656_5_16
Title: Problem in understanding connectSlotsByName() in pyqt? 
----------------------------------------

def __init__(self, args) :
INDENT
    self.app = MainApp(args)
    QtGui.QWidget.__init__(self)
    self.setObjectName('I')
    self._layout = QtGui.QVBoxLayout(self)
    self.setLayout(self._layout)
    self.pushButtoninWidget2 = QtGui.QPushButton(self)
    self.pushButtoninWidget2.setObjectName("pushButtoninWidget2")
    self.pushButtoninWidget2.setText('Click NOW!')
    self._layout.addWidget(self.pushButtoninWidget2)
    QtCore.QMetaObject.connectSlotsByName(self)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWidget, self).__init__(parent)
    self._layout = QtGui.QVBoxLayout()
    self.setLayout(self._layout)
    self._button = QtGui.QPushButton()
    self._button.setText('Click NOW!')
    self._layout.addWidget(self._button)
    self._button.clicked.connect(self._printMessage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24689800_24739145_154_166
24689800_24739145_16_31
Title: Async like pattern in pyqt? Or cleaner background call pattern? 
----------------------------------------

def __init__(self, func, * args, ** kwargs) :
INDENT
    super(AsyncTask, self).__init__()
    self.result = None
    self.func = func
    self.args = args
    self.kwargs = kwargs
    self.finished = False
    self.finished_cb_ran = False
    self.finished_callback = None
    self.objThread = RunThreadCallback(self, self.func, self.on_finished,
        * self.args, ** self.kwargs)
    self.objThread.start()
DEDENT
----------------------------------------

def __init__(self, method) :
INDENT
    try :
    INDENT
        if method.im_self is not None :
        INDENT

            self._obj = weakref.ref(method.im_self)
        DEDENT
        else :
        INDENT

            self._obj = None
        DEDENT
        self._func = method.im_func
        self._class = method.im_class
    DEDENT
    except AttributeError :
    INDENT

        self._obj = None
        self._func = method
        self._class = None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24689800_24739145_154_166
24689800_24790124_58_66
Title: Async like pattern in pyqt? Or cleaner background call pattern? 
----------------------------------------

def __init__(self, func, * args, ** kwargs) :
INDENT
    super(AsyncTask, self).__init__()
    self.result = None
    self.func = func
    self.args = args
    self.kwargs = kwargs
    self.finished = False
    self.finished_cb_ran = False
    self.finished_callback = None
    self.objThread = RunThreadCallback(self, self.func, self.on_finished,
        * self.args, ** self.kwargs)
    self.objThread.start()
DEDENT
----------------------------------------

def __init__(self, func, on_finish, * args, ** kwargs) :
INDENT
    super(RunThread, self).__init__()
    self.args = args
    self.kwargs = kwargs
    self.func = func
    self.finished.connect(on_finish)
    self.finished [int].connect(on_finish)
    self.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24689800_24739145_16_31
24689800_24790124_58_66
Title: Async like pattern in pyqt? Or cleaner background call pattern? 
----------------------------------------

def __init__(self, method) :
INDENT
    try :
    INDENT
        if method.im_self is not None :
        INDENT

            self._obj = weakref.ref(method.im_self)
        DEDENT
        else :
        INDENT

            self._obj = None
        DEDENT
        self._func = method.im_func
        self._class = method.im_class
    DEDENT
    except AttributeError :
    INDENT

        self._obj = None
        self._func = method
        self._class = None
    DEDENT
DEDENT
----------------------------------------

def __init__(self, func, on_finish, * args, ** kwargs) :
INDENT
    super(RunThread, self).__init__()
    self.args = args
    self.kwargs = kwargs
    self.func = func
    self.finished.connect(on_finish)
    self.finished [int].connect(on_finish)
    self.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24689800_24739145_200_209
24689800_24790124_67_78
Title: Async like pattern in pyqt? Or cleaner background call pattern? 
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        result = self.func(* self.args, ** self.kwargs)
    DEDENT
    except Exception as e :
    INDENT
        print "e is %s" % e
        result = e
    DEDENT
    finally :
    INDENT
        CallbackEvent.post_to(self.parent(), self.on_finished, result)

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        result = self.func(* self.args, ** self.kwargs)
    DEDENT
    except Exception as e :
    INDENT
        print "e is %s" % e
        result = e
    DEDENT
    finally :
    INDENT
        if isinstance(result, int) :
        INDENT
            self.finished [int].emit(result)
        DEDENT
        else :
        INDENT
            self.finished.emit(str(result))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24689800_24739145_200_209
24689800_24790124_92_112
Title: Async like pattern in pyqt? Or cleaner background call pattern? 
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        result = self.func(* self.args, ** self.kwargs)
    DEDENT
    except Exception as e :
    INDENT
        print "e is %s" % e
        result = e
    DEDENT
    finally :
    INDENT
        CallbackEvent.post_to(self.parent(), self.on_finished, result)

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        start = cur_time = time.time()
        while cur_time - start < 10 :
        INDENT
            if self.cancelled :
            INDENT
                print ("cancelled")
                result = "cancelled"
                break
            DEDENT
            print "doing work in worker..."
            time.sleep(1)
            cur_time = time.time()
        DEDENT
    DEDENT
    except Exception as e :
    INDENT
        print "e is %s" % e
        result = e
    DEDENT
    finally :
    INDENT
        if isinstance(result, int) :
        INDENT
            self.finished [int].emit(result)
        DEDENT
        else :
        INDENT
            self.finished.emit(str(result))

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24689800_24739145_32_47
24689800_24739145_78_87
Title: Async like pattern in pyqt? Or cleaner background call pattern? 
----------------------------------------

def __call__(self) :
INDENT
    if self.is_dead() :
    INDENT
        return None
    DEDENT
    if self._obj is not None :
    INDENT
        return types.MethodType(self._func, self._obj(), self._class)
    DEDENT
    else :
    INDENT
        return self._func
    DEDENT
DEDENT
----------------------------------------

def __call__(self, * args, ** kwargs) :
INDENT
    func = ref.__call__(self)
    if func is None :
    INDENT
        if self._quiet :
        INDENT
            return
        DEDENT
        else :
        INDENT
            raise ReferenceError('object is dead')
        DEDENT
    DEDENT
    else :
    INDENT
        return func(* args, ** kwargs)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24689800_24790124_67_78
24689800_24790124_92_112
Title: Async like pattern in pyqt? Or cleaner background call pattern? 
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        result = self.func(* self.args, ** self.kwargs)
    DEDENT
    except Exception as e :
    INDENT
        print "e is %s" % e
        result = e
    DEDENT
    finally :
    INDENT
        if isinstance(result, int) :
        INDENT
            self.finished [int].emit(result)
        DEDENT
        else :
        INDENT
            self.finished.emit(str(result))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        start = cur_time = time.time()
        while cur_time - start < 10 :
        INDENT
            if self.cancelled :
            INDENT
                print ("cancelled")
                result = "cancelled"
                break
            DEDENT
            print "doing work in worker..."
            time.sleep(1)
            cur_time = time.time()
        DEDENT
    DEDENT
    except Exception as e :
    INDENT
        print "e is %s" % e
        result = e
    DEDENT
    finally :
    INDENT
        if isinstance(result, int) :
        INDENT
            self.finished [int].emit(result)
        DEDENT
        else :
        INDENT
            self.finished.emit(str(result))

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24690591_24691076_4_14
24690591_24691177_1_13
Title: "Using (xy) coordinates to get to a specific ""village"" (Python 3)" 
----------------------------------------

def __init__(self) :
INDENT
    self.name = 'Random name'
    x = random.randint(1, 9)
    y = random.randint(1, 9)
    self.coordinates = [x, y]
    tribe = random.randint(1, 2)
    if tribe == 1 :
    INDENT
        self.tribe = 'gauls'
    DEDENT
    elif tribe == 2 :
    INDENT
        self.tribe = 'teutons'
    DEDENT
DEDENT
----------------------------------------

def __init__(self, locations) :
INDENT
    if not locations :
    INDENT
        print ('board is full!')
        raise ValueError
    DEDENT
    self.coordinates = random.choice(locations)
    del locations [locations.index(self.coordinates)]

    self.name = 'Random name'
    self.tribe = random.choice(('gauls', 'teutons'))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24707308_24707779_11_25
24707308_24742920_27_44
Title: Get command window output to display in widget with tkinter 
----------------------------------------

def __init__(self, parent) :
INDENT
    tkinter.Tk.__init__(self, parent)
    self.parent = parent
    self.wm_title("TextBoxDemo")
    self.textbox = tkinter.Text(self)
    self.textbox.pack()
    self.txt_var = tkinter.StringVar()
    self.entry = tkinter.Entry(self, textvariable = self.txt_var)
    self.entry.pack(anchor = "w")
    self.button = tkinter.Button(self, text = "Add", command = self.add)
    self.button.pack(anchor = "e")

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    self.root = parent
    self.root.title("Redirect")
    self.frame = Tkinter.Frame(parent)
    self.frame.pack()
    self.text = ScrolledText.ScrolledText(self.frame)
    self.text.pack()

    redir = RedirectText(self.text)
    sys.stdout = redir
    btn = Tkinter.Button(self.frame, text = "Open file", command = self.open_file)
    btn.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24709576_24709600_3_12
24709576_24711018_3_8
Title: Die roller using python 
----------------------------------------

def roll_die(die_type, roll_times, print_op = False) :
INDENT
    total_roll = 0
    for _ in range(roll_times) :
    INDENT
        roll_result = random.randint(1, die_type)
        total_roll += roll_result
        if print_op :
        INDENT
            print (roll_result)
        DEDENT
    DEDENT
    if print_op :
    INDENT
        print (total_roll)
    DEDENT
    return total_roll
DEDENT
----------------------------------------

def roll_die(die_type, print_op = False) :
INDENT
    roll_result = random.randint(1, die_type)
    if print_op :
    INDENT
        print ("Roll: {0}.".format(roll_result))
    DEDENT
    return roll_result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24727644_24727869_33_52
24727644_24727869_6_30
Title: Binding keys to start and stop with tkinter 
----------------------------------------

def __init__(self, parent) :
INDENT
    self.parent = parent
    self._myself = tk.Canvas(master = parent, width = 850, height = 400, bg = 'grey', highlightthickness = 0)
    self._myself.grid(row = 0, column = 0, sticky = tk.NSEW)
    self.fracX = 1
    self.fracY = 1
    self._oval1 = self._myself.create_oval(50 * self.fracX, 50 * self.fracY, 160 * self.fracX, 160 * self.fracY, fill = "black", tags = 'oval1')
    self._oval2 = self._myself.create_oval(210 * self.fracX, 50 * self.fracY, 320 * self.fracX, 160 * self.fracY, fill = "black", tags = 'oval2')
    self._oval3 = self._myself.create_oval(370 * self.fracX, 50 * self.fracY, 480 * self.fracX, 160 * self.fracY, fill = "black", tags = 'oval3')
    self._oval4 = self._myself.create_oval(530 * self.fracX, 50 * self.fracY, 640 * self.fracX, 160 * self.fracY, fill = "black", tags = 'oval4')
    self._oval5 = self._myself.create_oval(690 * self.fracX, 50 * self.fracY, 800 * self.fracX, 160 * self.fracY, fill = "black", tags = 'oval5')
    self._started = False
    self._myself.bind("<Configure>", self._on_resize)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self._tk = tk.Tk()
    self._tk.rowconfigure(0, weight = 1)
    self._tk.columnconfigure(0, weight = 1)
    self._myframe = tk.Frame(master = self._tk)
    self._myframe.grid(row = 0, column = 0, sticky = tk.NSEW)
    self._mycanvas = MyCanvas(self._tk)
    self._tk._but1 = tk.Button(self._tk, text = "start", command = self._mycanvas.start)
    self._tk._but1.grid(row = 2, column = 0, sticky = "w")
    self._tk._but2 = tk.Button(self._tk, text = "amber", command = self._mycanvas.flashing)
    self._tk._but2.grid(row = 2, sticky = "w", padx = (80))
    self._tk._but1 = tk.Button(self._tk, text = "stop", command = self._mycanvas.stop)
    self._tk._but1.grid(row = 2, column = 0, sticky = "w", padx = (40))
    self._tk.bind("s", self._mycanvas.start)
    self._tk.bind("w", self._mycanvas.stop)
    self._tk.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24758012_24783296_18_29
24758012_24783296_2_12
Title: PyQt keyPressEvent not triggered from QDialog 
----------------------------------------

def __init__(self) :
INDENT
    QMainWindow.__init__(self)
    self.setWindowTitle('KeyPressEvent Test')
    main = QVBoxLayout(self)
    child = KpeWindow(self)
    child.setFocusPolicy(Qt.StrongFocus)
    self.setFocusProxy(child)
    main.addWidget(child)
    child.setFocus(True)
    self.adjustSize()
    self.setLayout(main)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QWidget.__init__(self, parent)
    main = QVBoxLayout(self)
    label = QLabel(self)
    label.setText('Test the keyPressEvent')
    main.addWidget(label)
    self.adjustSize()
    self.setLayout(main)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24771381_32262005_3_10
24771381_51512033_1_11
Title: How to check if string is a pangram? 
----------------------------------------

def panagram(phrase) :
INDENT
    new_phrase = sorted(phrase.lower())
    phrase_letters = ""
    for index in new_phrase :
    INDENT
        for letter in string.ascii_lowercase :
        INDENT
            if index == letter and index not in phrase_letters :
            INDENT
                phrase_letters += letter
            DEDENT
        DEDENT
    DEDENT
    print len(phrase_letters) == 26
DEDENT
----------------------------------------

def panagram(str1) :
INDENT
    str1 = str1.replace(' ', '').lower()
    s = set(str1)
    l = list(s)
    if len(l) == 26 :
    INDENT
        return True
    DEDENT
    return False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24776715_24777652_3_12
24776715_24790585_19_24
Title: Using Pythons fileinput with virtual file / RAM file 
----------------------------------------

def do_stuff_with_file(lines, filename, parameters) :
INDENT
    for line in lines :
    INDENT
        if fileinput.filename() == filename :
        INDENT
            new_line = do_a_lot_of_stuff_with(line, parameters)
            print_something(line, parameters)
            print new_line,
            print_some_more(line, parameters)
        DEDENT
        else :
        INDENT
            print line
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def do_stuff_with_file(self, data, parameters) :
INDENT
    output = None
    for line in data :
    INDENT
        output = do_a_lot_of_stuff_with(line, parameters)
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24794682_24795374_23_47
24794682_24795374_3_20
Title: Panel not switch 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Notebook Tutorial",
        size = (600, 400))
    panel = wx.Panel(self)
    notebook = NotebookDemo(panel)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(notebook, 1, wx.ALL | wx.EXPAND, 5)
    panel.SetSizer(sizer)
    self.Layout()
    self.Show()
    self.tab_one = TabPanel(self)
    self.panel_one = PanelOne(self)
    self.panel_one.Hide()
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.tab_one, 1, wx.EXPAND)
    self.sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.SetSizer(self.sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Notebook.__init__(self, parent, id = wx.ID_ANY, style =
        wx.BK_DEFAULT
        )

    self.tabOne = TabPanel(self)
    self.AddPage(self.tabOne, "TabOne")

    self.tabTwo = TabPanel2(self)
    self.AddPage(self.tabTwo, "TabTwo")

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24832628_24917467_1_11
24832628_24941241_1_10
Title: Python configparser getting and setting without exceptions 
----------------------------------------

def read_config(section, location) :
INDENT
    config = configparser.ConfigParser()
    config.read(location)
    apple = config.get(section, 'apple',
        vars = DefaultOption(config, section, apple = None))
    pear = config.get(section, 'pear',
        vars = DefaultOption(config, section, pear = None))
    banana = config.get(section, 'banana',
        vars = DefaultOption(config, section, banana = None))
    return apple, pear, banana
DEDENT
----------------------------------------

def read_config(section, default = None, * vars) :
INDENT
    config = configparser.ConfigParser()
    config.read(location)
    ret = []
    for var in vars :
    INDENT
        try :
        INDENT
            ret.append(config.get(section, var))
        DEDENT
        except NoSectionError, NoOptionError :
        INDENT
            ret.append(default)
        DEDENT
    DEDENT
    return ret
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24852345_26856771_1_10
24852345_31628808_1_21
Title: HSV to RGB Color Conversion 
----------------------------------------

def hsv_to_rgb(h, s, v) :
INDENT
    if s == 0.0 : v *= 255; return (v, v, v)
    i = int(h * 6.)
    f = (h * 6.) - i; p, q, t = int(255 * (v * (1.- s))), int(255 * (v * (1.- s * f))), int(255 * (v * (1.- s * (1.- f)))); v *= 255; i %= 6
    if i == 0 : return (v, t, p)
    if i == 1 : return (q, v, p)
    if i == 2 : return (p, v, t)
    if i == 3 : return (p, q, v)
    if i == 4 : return (t, p, v)
    if i == 5 : return (v, p, q)
DEDENT
----------------------------------------

def hsv_to_rgb(h, s, v) :
INDENT
    shape = h.shape
    i = int_(h * 6.)
    f = h * 6.- i
    q = f
    t = 1.- f
    i = ravel(i)
    f = ravel(f)
    i %= 6
    t = ravel(t)
    q = ravel(q)
    clist = (1 - s * vstack([zeros_like(f), ones_like(f), q, t])) * v

    order = array([[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]])
    rgb = clist [order [i], arange(prod(shape)) [:, None]]
    return rgb.reshape(shape + (3,))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24856687_24857165_48_63
24856687_24857165_8_31
Title: wxPython button widget won't move 
----------------------------------------

def __init__(self, camera, fps = 10) :
INDENT
    wx.Frame.__init__(self, None)
    self.panel = wx.Panel(self, - 1)

    self.webcampanel = webcamPanel(self.panel, camera)

    webcampanelsize = self.webcampanel.GetSize()

    self.but = wx.Button(self.panel, label = "Capture", pos = (0, webcampanelsize.height), size = (webcampanelsize.width, 75))

DEDENT
----------------------------------------

def __init__(self, parent, camera, fps = 10) :
INDENT
    wx.Panel.__init__(self, parent)
    self.camera = camera
    ret_value, frame = self.camera.read()
    height, width = frame.shape [: 2]

    self.SetSize((width, height))

    self.GetParent().GetParent().SetSize((width, height + 75))
    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    frame = cv2.flip(frame, 1)
    self.bmp = wx.BitmapFromBuffer(width, height, frame)
    self.timer = wx.Timer(self)
    self.timer.Start(1000./ fps)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_TIMER, self.NextFrame)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24862545_24862647_6_15
24862545_24862709_6_14
Title: Assure minimal wait between calls with decorators 
----------------------------------------

def wrapper(f) :
INDENT
    @ functools.wraps(f)
    def func(* args, ** kwargs) :
    INDENT
        if (time.time() - func.last_time) < interval :
        INDENT
            time.sleep(interval)
        DEDENT
        result = f(* args, ** kwargs)
        func.last_time = time.time()
        return result
    DEDENT
    func.last_time = time.time()
    return func
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    time_diff = time.time() - last_time [0]
    if time_diff < 1 :
    INDENT
        print ("Too fast...")
        time.sleep(1 - time_diff)
        last_time [0] = time.time()
        return f(* args, ** kwargs)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24872527_27095669_5_21
24872527_40490622_5_19
Title: combine word document using python docx 
----------------------------------------

def combine_word_documents(files) :
INDENT
    combined_document = Document('empty.docx')
    count, number_of_files = 0, len(files)
    for file in files :
    INDENT
        sub_doc = Document(file)

        if count < number_of_files - 1 :
        INDENT
            sub_doc.add_page_break()
        DEDENT
        for element in sub_doc._document_part.body._element :
        INDENT
            combined_document._document_part.body._element.append(element)
        DEDENT
        count += 1
    DEDENT
    combined_document.save('combined_word_documents.docx')
DEDENT
----------------------------------------

def combine_word_documents(files) :
INDENT
    merged_document = Document()
    for index, file in enumerate(files) :
    INDENT
        sub_doc = Document(file)

        if index < len(files) - 1 :
        INDENT
            sub_doc.add_page_break()
        DEDENT
        for element in sub_doc.element.body :
        INDENT
            merged_document.element.body.append(element)
        DEDENT
    DEDENT
    merged_document.save('merged.docx')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24872527_27095669_5_21
24872527_46405169_1_25
Title: combine word document using python docx 
----------------------------------------

def combine_word_documents(files) :
INDENT
    combined_document = Document('empty.docx')
    count, number_of_files = 0, len(files)
    for file in files :
    INDENT
        sub_doc = Document(file)

        if count < number_of_files - 1 :
        INDENT
            sub_doc.add_page_break()
        DEDENT
        for element in sub_doc._document_part.body._element :
        INDENT
            combined_document._document_part.body._element.append(element)
        DEDENT
        count += 1
    DEDENT
    combined_document.save('combined_word_documents.docx')
DEDENT
----------------------------------------

def combine_word_documents(input_files) :
INDENT
    for filnr, file in enumerate(input_files) :
    INDENT
        if 'offerte_template' in file :
        INDENT
            file = os.path.join(settings.MEDIA_ROOT, file)
        DEDENT
        if filnr == 0 :
        INDENT
            merged_document = Document(file)
            merged_document.add_page_break()
        DEDENT
        else :
        INDENT
            sub_doc = Document(file)

            if filnr < len(input_files) - 1 :
            INDENT
                sub_doc.add_page_break()
            DEDENT
            for element in sub_doc.element.body :
            INDENT
                merged_document.element.body.append(element)
            DEDENT
        DEDENT
    DEDENT
    return merged_document
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24872527_40490622_5_19
24872527_46405169_1_25
Title: combine word document using python docx 
----------------------------------------

def combine_word_documents(files) :
INDENT
    merged_document = Document()
    for index, file in enumerate(files) :
    INDENT
        sub_doc = Document(file)

        if index < len(files) - 1 :
        INDENT
            sub_doc.add_page_break()
        DEDENT
        for element in sub_doc.element.body :
        INDENT
            merged_document.element.body.append(element)
        DEDENT
    DEDENT
    merged_document.save('merged.docx')
DEDENT
----------------------------------------

def combine_word_documents(input_files) :
INDENT
    for filnr, file in enumerate(input_files) :
    INDENT
        if 'offerte_template' in file :
        INDENT
            file = os.path.join(settings.MEDIA_ROOT, file)
        DEDENT
        if filnr == 0 :
        INDENT
            merged_document = Document(file)
            merged_document.add_page_break()
        DEDENT
        else :
        INDENT
            sub_doc = Document(file)

            if filnr < len(input_files) - 1 :
            INDENT
                sub_doc.add_page_break()
            DEDENT
            for element in sub_doc.element.body :
            INDENT
                merged_document.element.body.append(element)
            DEDENT
        DEDENT
    DEDENT
    return merged_document
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24875416_24893086_5_10
24875416_36676634_1_14
Title: How can I fit text in label in Kivy? 
----------------------------------------

def on_texture_size(self, * args) :
INDENT
    if not self.factor :
    INDENT
        self.factor = [self.font_size / self.texture_size [0], self.font_size / self.texture_size [1]]
    DEDENT
    if not self.dimension :
    INDENT
        self.dimension = 1 if self.texture_size [0] * self.size [1] < self.texture_size [1] * self.size [0] else 0
    DEDENT
    self.font_size = self.size [self.dimension] * self.scale_factor * self.factor [self.dimension]
DEDENT
----------------------------------------

def on_texture_size(self, * args) :
INDENT
    try :
    INDENT
        if not self.factor :
        INDENT
            self.factor = [self.font_size / self.texture_size [0], self.font_size / self.texture_size [1]]
        DEDENT
        self.font_size0 = self.size [0] * self.scale_factor * self.factor [0]
        self.font_size1 = self.size [1] * self.scale_factor * self.factor [1]
        if self.font_size0 < self.font_size1 :
        INDENT
            self.font_size = self.font_size0
        DEDENT
        else :
        INDENT
            self.font_size = self.font_size1
        DEDENT
    DEDENT
    except ZeroDivisionError :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24887486_24887564_127_150
24887486_24887564_188_200
Title: Nested Classes Python and Indentation errors 
----------------------------------------

def __init__(
self,
scheme = None,
cardNumber = None,
month = None,
year = None,
setSchemeAsDefault = None) :
INDENT
    if (scheme is None) :
    INDENT
        scheme = "GM"
        self.scheme = scheme
    DEDENT
    if (cardNumber is None) :
    INDENT
        month = "1231456A"
        self.cardNumber = cardNumber
    DEDENT
    if (month is None) :
    INDENT
        month = "September"
        self.month = month
    DEDENT
    if (year is None) :
    INDENT
        year = "2015"
        self.year = year
    DEDENT
    if (setSchemeAsDefault is None) :
    INDENT
        setSchemeAsDefault = "true"
        self.setSchemeAsDefault = setSchemeAsDefault
    DEDENT
DEDENT
----------------------------------------

def __init__(
self,
testID,
printBagLabel = None,
printDrugLabel = None) :
INDENT
    self.testID = testID
    if (printBagLabel is None) :
    INDENT
        printBagLabel = "false"
        self.drug = drug
    DEDENT
    if (printDrugLabel is None) :
    INDENT
        printDrugLabel = "false"
        self.printDrugLabel = printDrugLabel
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24887486_24887564_127_150
24887486_24887564_45_115
Title: Nested Classes Python and Indentation errors 
----------------------------------------

def __init__(
self,
scheme = None,
cardNumber = None,
month = None,
year = None,
setSchemeAsDefault = None) :
INDENT
    if (scheme is None) :
    INDENT
        scheme = "GM"
        self.scheme = scheme
    DEDENT
    if (cardNumber is None) :
    INDENT
        month = "1231456A"
        self.cardNumber = cardNumber
    DEDENT
    if (month is None) :
    INDENT
        month = "September"
        self.month = month
    DEDENT
    if (year is None) :
    INDENT
        year = "2015"
        self.year = year
    DEDENT
    if (setSchemeAsDefault is None) :
    INDENT
        setSchemeAsDefault = "true"
        self.setSchemeAsDefault = setSchemeAsDefault
    DEDENT
DEDENT
----------------------------------------

def __init__(
self,
testID,
firstname = None,
middlename = None,
surname = None,
gender = None,
birthDate = None,
title = None,
ppsno = None,
address1 = None,
address2 = None,
address3 = None,
address4 = None,
town = None,
county = None,
country = None,
email = None,
mobile = None) :
INDENT
    self.testID = testID
    if (firstname is None) :
    INDENT
        firstname = "Sample"
        self.firstname = firstname
    DEDENT
    if (surname is None) :
    INDENT
        surname = "Patient"
        self.surname = surname
    DEDENT
    if (middlename is None) :
    INDENT
        middlename = "Mary"
        self.middlename = middlename
    DEDENT
    if (gender is None) :
    INDENT
        gender = "Female"
        self.gender = gender
    DEDENT
    if (birthDate is None) :
    INDENT
        birthDate = "03091959"
        self.birthDate = birthDatename
    DEDENT
    if (title is None) :
    INDENT
        title = "Mrs"
        self.title = title
    DEDENT
    if (ppsno is None) :
    INDENT
        ppsno = "7445213P"
        self.ppsno = ppsno
    DEDENT
    if (address1 is None) :
    INDENT
        address1 = "100"
        self.address1 = address1
    DEDENT
    if (address2 is None) :
    INDENT
        address2 = "Green Glade"
        self.address1 = address1
    DEDENT
    if (address3 is None) :
    INDENT
        address3 = "Pleasent Way"
        self.address3 = address3
    DEDENT
    if (address4 is None) :
    INDENT
        address4 = "Ballybehy"
        self.address4 = address4
    DEDENT
    if (town is None) :
    INDENT
        town = "Abbeyfeale"
        self.town = town
    DEDENT
    if (county is None) :
    INDENT
        county = "Limerick"
        self.county = county
    DEDENT
    if (country is None) :
    INDENT
        country = "Ireland"
        self.country = country
    DEDENT
    if (email is None) :
    INDENT
        email = "supertest69@freewebmail.ie"
        self.email = email
    DEDENT
    if (mobile is None) :
    INDENT
        mobile = "0870563229"
        self.mobile = mobile
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24887486_24887564_161_186
24887486_24887564_188_200
Title: Nested Classes Python and Indentation errors 
----------------------------------------

def __init__(
self,
drug = None,
packSize = None,
dosageSystem = None,
scheme = None) :
INDENT
    if (drug is None) :
    INDENT
        drug = "ABBOTT THIN LANCET TYPE C GMS"
        self.drug = drug
    DEDENT
    if (packSize is None) :
    INDENT
        packSize = "28"
        self.packSize = packSize
    DEDENT
    if (dosageSystem is None) :
    INDENT
        dosageSystem = "MD"
        self.dosageSystem = dosageSystem
    DEDENT
    if (scheme is None) :
    INDENT
        scheme = "GM"
        self.scheme = scheme
    DEDENT
    def getStuff(self) :
    INDENT
        return self.stuff

    DEDENT
DEDENT
----------------------------------------

def __init__(
self,
testID,
printBagLabel = None,
printDrugLabel = None) :
INDENT
    self.testID = testID
    if (printBagLabel is None) :
    INDENT
        printBagLabel = "false"
        self.drug = drug
    DEDENT
    if (printDrugLabel is None) :
    INDENT
        printDrugLabel = "false"
        self.printDrugLabel = printDrugLabel
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24887486_24887564_161_186
24887486_24887564_45_115
Title: Nested Classes Python and Indentation errors 
----------------------------------------

def __init__(
self,
drug = None,
packSize = None,
dosageSystem = None,
scheme = None) :
INDENT
    if (drug is None) :
    INDENT
        drug = "ABBOTT THIN LANCET TYPE C GMS"
        self.drug = drug
    DEDENT
    if (packSize is None) :
    INDENT
        packSize = "28"
        self.packSize = packSize
    DEDENT
    if (dosageSystem is None) :
    INDENT
        dosageSystem = "MD"
        self.dosageSystem = dosageSystem
    DEDENT
    if (scheme is None) :
    INDENT
        scheme = "GM"
        self.scheme = scheme
    DEDENT
    def getStuff(self) :
    INDENT
        return self.stuff

    DEDENT
DEDENT
----------------------------------------

def __init__(
self,
testID,
firstname = None,
middlename = None,
surname = None,
gender = None,
birthDate = None,
title = None,
ppsno = None,
address1 = None,
address2 = None,
address3 = None,
address4 = None,
town = None,
county = None,
country = None,
email = None,
mobile = None) :
INDENT
    self.testID = testID
    if (firstname is None) :
    INDENT
        firstname = "Sample"
        self.firstname = firstname
    DEDENT
    if (surname is None) :
    INDENT
        surname = "Patient"
        self.surname = surname
    DEDENT
    if (middlename is None) :
    INDENT
        middlename = "Mary"
        self.middlename = middlename
    DEDENT
    if (gender is None) :
    INDENT
        gender = "Female"
        self.gender = gender
    DEDENT
    if (birthDate is None) :
    INDENT
        birthDate = "03091959"
        self.birthDate = birthDatename
    DEDENT
    if (title is None) :
    INDENT
        title = "Mrs"
        self.title = title
    DEDENT
    if (ppsno is None) :
    INDENT
        ppsno = "7445213P"
        self.ppsno = ppsno
    DEDENT
    if (address1 is None) :
    INDENT
        address1 = "100"
        self.address1 = address1
    DEDENT
    if (address2 is None) :
    INDENT
        address2 = "Green Glade"
        self.address1 = address1
    DEDENT
    if (address3 is None) :
    INDENT
        address3 = "Pleasent Way"
        self.address3 = address3
    DEDENT
    if (address4 is None) :
    INDENT
        address4 = "Ballybehy"
        self.address4 = address4
    DEDENT
    if (town is None) :
    INDENT
        town = "Abbeyfeale"
        self.town = town
    DEDENT
    if (county is None) :
    INDENT
        county = "Limerick"
        self.county = county
    DEDENT
    if (country is None) :
    INDENT
        country = "Ireland"
        self.country = country
    DEDENT
    if (email is None) :
    INDENT
        email = "supertest69@freewebmail.ie"
        self.email = email
    DEDENT
    if (mobile is None) :
    INDENT
        mobile = "0870563229"
        self.mobile = mobile
    DEDENT
DEDENT
----------------------------------------
