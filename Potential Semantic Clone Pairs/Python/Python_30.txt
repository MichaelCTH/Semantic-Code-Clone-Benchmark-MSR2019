$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34821974_34827474_5_10
34821974_36226267_3_10
Title: How to serve a static webpage from falcon application? 
----------------------------------------

def on_get(self, req, resp) :
INDENT
    resp.status = falcon.HTTP_200
    resp.content_type = 'text/html'
    with open('index.html', 'r') as f :
    INDENT
        resp.body = f.read()
    DEDENT
DEDENT
----------------------------------------

def on_get(self, req, resp, filename) :
INDENT
    resp.status = falcon.HTTP_200
    resp.content_type = 'appropriate/content-type'
    with open(filename, 'r') as f :
    INDENT
        resp.body = f.read()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34823075_34823245_6_13
34823075_34823559_3_10
Title: Use argparse to parse a list of objects 
----------------------------------------

def __init__(self, id, value, tag) :
INDENT
    if (value < = 0) :
    INDENT
        raise ValueError("Amount must be greater than 0")
    DEDENT
    self.id = id
    self.value = value
    self.tag = tag

DEDENT
----------------------------------------

def __init__(self, id, value, tag) :
INDENT
    self.id = int(id)
    self.value = float(value)
    if self.value < = 0 :
    INDENT
        raise ValueError("Amount must be greater than 0")
    DEDENT
    self.tag = int(tag)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34845041_34845251_2_10
34845041_34846244_2_10
Title: PyQt5 - cannot resolve a dialog's slot 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QDialog.__init__(self)
    Ui_NewGameDialog.__init__(self)
    self.setupUi(self)
    self.setFixedSize(self.size())
    self.setWindowFlags(
        self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtWidgets.QDialog.__init__(self)
    self.ui = Ui_NewGameDialog()
    self.ui.setupUi(self)
    self.setFixedSize(self.size())
    self.setWindowFlags(
        self.windowFlags() ^ QtCore.Qt.WindowContextHelpButtonHint)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34855705_34860774_23_38
34855705_34860774_47_61
Title: matplotlib + QGraphicsView + zoom = big ugly pixels 
----------------------------------------

def __init__(self) :
INDENT
    super(MPLPlot, self).__init__()
    figure = Figure()
    axes = figure.gca()
    axes.set_title("Use the mouse wheel to zoom")
    axes.plot(np.random.rand(5))
    canvas = FigureCanvas(figure)
    canvas.setGeometry(0, 0, 500, 500)
    imgdata = StringIO.StringIO()
    figure.savefig(imgdata, format = 'svg')
    imgdata.seek(0)
    xmlreader = QtCore.QXmlStreamReader(imgdata.getvalue())
    self.renderer = QtSvg.QSvgRenderer(xmlreader)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QGraphicsView.__init__(self)
    scene = QtGui.QGraphicsScene(self)
    self.scene = scene
    plot = MPLPlot()
    scene.addWidget(plot)
    circle = Circle()
    self.circle = circle
    scene.addWidget(circle)
    self.setScene(scene)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3487301_3487359_15_28
3487301_3491233_12_23
Title: python program bug help 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT

        num = random.randint(0, 100)
        self.datamutex.acquire()
        self.data [0] = num

        time.sleep(1)
        self.data [1] = num * 4
        self.datamutex.release()
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT

        num = random.randint(0, 100)
        data0 = num

        time.sleep(1)
        data1 = num * 4
        self.data [0 : 2] = data0, data1
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3487301_3487359_15_28
3487301_3491233_29_36
Title: python program bug help 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT

        num = random.randint(0, 100)
        self.datamutex.acquire()
        self.data [0] = num

        time.sleep(1)
        self.data [1] = num * 4
        self.datamutex.release()
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT

        num1, num2 = self.data [0 : 2]
        print "Values are %d and %d." % (num1, num2)
        if num2 ! = num1 * 4 :
        INDENT
            print "\tDATA INCONSISTENCY!"
        DEDENT
        time.sleep(2)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3487301_3491233_12_23
3487301_3491233_29_36
Title: python program bug help 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT

        num = random.randint(0, 100)
        data0 = num

        time.sleep(1)
        data1 = num * 4
        self.data [0 : 2] = data0, data1
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT

        num1, num2 = self.data [0 : 2]
        print "Values are %d and %d." % (num1, num2)
        if num2 ! = num1 * 4 :
        INDENT
            print "\tDATA INCONSISTENCY!"
        DEDENT
        time.sleep(2)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34907620_34907848_1_13
34907620_34907853_1_12
Title: Python calculator/ defining 
----------------------------------------

def rep(num1, ans) :
INDENT
    num2 = int(input("Next number? "))
    choice = input("select operation -,+,x,/. ")
    if (choice == "+") :
    INDENT
        ans = (num1 + num2)
    DEDENT
    elif (choice == "-") :
    INDENT
        ans = (num1 - num2)
    DEDENT
    elif (choice == "x") :
    INDENT
        ans = (num1 * num2)
    DEDENT
    elif (choice == "/") :
    INDENT
        ans = (num1 / num2)
    DEDENT
    print (ans)
DEDENT
----------------------------------------

def rep(num) :
INDENT
    num_two = int(input("Next number? "))
    choice = input("select operation -,+,x,/. ")
    if choice == "+" :
    INDENT
        ans = num + num_two
    DEDENT
    elif choice == "-" :
    INDENT
        ans = num - num_two
    DEDENT
    elif choice == "x" :
    INDENT
        ans = num * num_two
    DEDENT
    elif choice == "/" :
    INDENT
        ans = num / num_two
    DEDENT
    print (ans)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34914042_34915158_1_18
34914042_34917434_1_33
Title: How can I write a recursive python function that splits a dictionary into an array of dictionaries? 
----------------------------------------

def expand_dictionary(d, name = None, l = None) :
INDENT
    obj = {}
    if l == None :
    INDENT
        l = [obj]
    DEDENT
    else :
    INDENT
        l.append(obj)
    DEDENT
    prefix = (name + '_' if name else '')
    if prefix : obj ['_parent_object'] = name
    for i, v in d.iteritems() :
    INDENT
        if isinstance(v, list) :
        INDENT
            map(lambda x : expand_dictionary(x, prefix + i, l), v)
        DEDENT
        elif isinstance(v, dict) :
        INDENT
            obj.update(flatten_dictionary({i : v}))
        DEDENT
        else :
        INDENT
            obj [i] = v
        DEDENT
    DEDENT
    return l
DEDENT
----------------------------------------

def expand_dictionary(original_object, object_name, objects = None) :
INDENT
    if objects is None :
    INDENT
        objects = []
    DEDENT
    def flatten_dictionary(dictionary) :
    INDENT
        def expand(key, value) :
        INDENT
            if isinstance(value, dict) :
            INDENT
                return [(key + '_' + k, v) for k, v in flatten_dictionary(value).items()]
            DEDENT
            else :
            INDENT
                if value is None or value == [] or value == '' :
                INDENT
                    return []
                DEDENT
                return [(key, value)]
            DEDENT
        DEDENT
        items = [item for k, v in dictionary.items() for item in expand(k, v)]
        return dict(items)
    DEDENT
    original_object_root = flatten_dictionary(original_object).copy()
    original_object_root ['_meta_object_name'] = object_name
    for key, value in original_object_root.copy().items() :
    INDENT
        if isinstance(value, dict) :
        INDENT
            flatten_dictionary(value, objects)
        DEDENT
        if isinstance(value, list) :
        INDENT
            original_object_root.pop(key)
            for nested_object in value :
            INDENT
                nested_object ['_meta_parent_foreign_key'] = original_object_root ['id']
                nested_object ['_meta_object_name'] = object_name + "_" + key
                expand_dictionary(nested_object, object_name + "_" + key, objects)
            DEDENT
        DEDENT
    DEDENT
    objects.append(original_object_root)
    return objects
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34934954_34935292_1_10
34934954_34935601_1_13
Title: Check if a number is found x amount of times consecutively in a 2d list 
----------------------------------------

def alignment(list, n, j, target) :
INDENT
    for y in range(n) :
    INDENT
        for x in range(n - j) :
        INDENT
            counter = 0
            if list [y] [x] == target :
            INDENT
                for z in range(j) :
                INDENT
                    if list [y] [x] == list [y] [x + z] :
                    INDENT
                        counter += 1
                    DEDENT
                    if counter == j :
                    INDENT
                        return True
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def alignment(nums, j, target) :
INDENT
    for row in nums :
    INDENT
        counter = 0
        for i in row :
        INDENT
            if i ! = target :
            INDENT
                if counter == j :
                INDENT
                    return True
                DEDENT
                counter = 0
                continue
            DEDENT
            counter += 1
        DEDENT
        if counter == j :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34935170_34938655_1_64
34935170_34954906_3_55
Title: How to append a file and take out a specific line python 3 
----------------------------------------

def main() :
INDENT
    products = {}
    product_location = {}
    location = 0
    with open('stockfile.txt', 'r+') as f :
    INDENT
        for line in f :
        INDENT

            product_location [line.split(',') [0]] = location
            location += len(line)
            line = line [: - 1]
            row = line.split(',')
            products [row [0]] = [row [1], row [2], row [3]]
            """
            The products are equal to row 1 and row 2 and row 3. The GTIN is going to take the values of the product and
            price so GTIN 12345678 is going to correspond to Fridge and 1.
            """
        DEDENT
        print (sorted(products.items()))
        total = 0
        while True :
        INDENT
            GTIN = input('\nPlease input GTIN or press [Enter] to quit:\n')
            if GTIN == "" :
            INDENT
                break
            DEDENT
            if (GTIN not in products) :
            INDENT
                print ('Sorry your code was invalid, try again:')
                continue
            DEDENT
            row = products [GTIN]
            print ('GTIN:', GTIN)
            description = row [0]
            value = row [1]
            stock = row [2]
            stock_length = len(row [2])
            backorder = 0
            print ('In Stock:', stock)
            quantity = input('Please also input your quantity required:\n')
            if int(quantity) > int(stock) :
            INDENT
                row [2] = 0
                backorder = int(quantity) - int(stock)
                Backordered_Stock = GTIN + ',' + description + ',' + value + ',' + str(backorder) + '\n'
            DEDENT
            else :
            INDENT
                row [2] = int(stock) - int(quantity)
            DEDENT
            products [row [2]] = row [2]
            product_total = (int(quantity) * int(value))
            New_Stock = GTIN + ',' + description + ',' + value + ',' + str(products [row [2]]).rjust(stock_length) + '\n'
            f.seek(product_location [GTIN])
            f.write(New_Stock)
            print ('Ordered - {0:>6} GTIN: {1:>10}  Desc: {2:<20}  at £{3:>6}  Total value: £{4:>6}  On backorder: {5:>4}'.
                format(int(quantity), GTIN, description, int(value), product_total, backorder))
            total = total + product_total
        DEDENT
        print ('Total of the order is £%s' % total)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    products = {}
    product_location = {}
    location = 0
    with open('stockfile.txt', 'r+') as f :
    INDENT
        for line in f :
        INDENT

            product_location [line.split(',') [0]] = location
            location += len(line)
            line = line [: - 1]
            row = line.split(',')
            products [row [0]] = [row [1], row [2], row [3]]

        DEDENT
        print (products)
        total = 0
        while True :
        INDENT
            GTIN = input('Please input GTIN: ')
            if GTIN == "" :
            INDENT
                break
            DEDENT
            if (GTIN not in products) :
            INDENT
                print ('Sorry your code was invalid, try again:')
                break
            DEDENT
            row = products [GTIN]
            description, value, stock = row
            print ('Stock data: ')
            print ('GTIN \t\tDesc. \t\tStock \t\tValue')
            print (GTIN, '\t', description, '\t', stock, '\t', value)
            quantity = input('Please also input your quantity required: ')
            row [2] = str(int(stock) - int(quantity))
            product_total = int(quantity) * int(value)
            for i in range(len(row)) :
            INDENT
                row [i] = row [i].rjust(MAX_FIELD_LEN)
            DEDENT
            New_Stock = GTIN.rjust(MAX_FIELD_LEN) + ',' + ','.join(row) + '\n'
            f.seek(product_location [GTIN])
            f.write(New_Stock)
            print ('You bought: {0} {1} \nCost: {2}'.format(GTIN, description, product_total))
            total = total + product_total
        DEDENT
        f.close()
        print ('Total of the order is £%s' % total)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34941978_34942219_15_33
34941978_45107093_12_39
Title: How to count messages received with Python 
----------------------------------------

def onMessage(self, room, user, message) :
INDENT
    print ("[{0}] {1}: {2}".format(room.name, user.name.title(), message.body))
    global count
    count = count + 1
    print (count)
    try :
    INDENT
        cmd, args = message.body.split(" ", 1)
    DEDENT
    except :
    INDENT
        cmd, args = message.body, ""
    DEDENT
    if cmd [0] == "!" :
    INDENT
        prfx = True
        cmd = cmd [1 :]
    DEDENT
    else :
    INDENT
        prfx = False
    DEDENT
DEDENT
----------------------------------------

def onMessage(self, room, user, message) :
INDENT
    f = open("log.txt", "a")
    f.write("[{0}] {1}: {2}".format(room.name, user.name.title(), message.body) + "\n")
    f.close()
    print ("[{0}] {1}: {2}".format(room.name, user.name.title(), message.body))
    try :
    INDENT
        cmd, args = message.body.split(" ", 1)
    DEDENT
    except :
    INDENT
        cmd, args = message.body, ""
    DEDENT
    if len(cmd) > 0 :
    INDENT
        if cmd [0] == "!" :
        INDENT
            prfx = True
            cmd = cmd [1 :]
        DEDENT
        else :
        INDENT
            prfx = False
        DEDENT
    DEDENT
    else :
    INDENT
        return
    DEDENT
    if cmd == "say" and prfx :
    INDENT
        if args : room.message(args)
        else : room.message("Nothing to say!")
    DEDENT
    elif cmd == "count" and prfx :
    INDENT
        room.message("Numbers of messages sent in all rooms I am in: " + str(len(open("log.txt").readlines())))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34942062_34942738_27_34
34942062_34942738_41_75
Title: I am trying to add in collision but it isn't working 
----------------------------------------

def update(self, enemies) :
INDENT
    if self.target :
    INDENT
        dx, dy = self.target.rect.x - self.rect.x, self.target.rect.y - self.rect.y
        dist = math.hypot(dx, dy)
        dx, dy = dx / dist, dy / dist
        self.rect.x += dx * self.speed
        self.rect.y += dy * self.speed
    DEDENT
DEDENT
----------------------------------------

def update(self, enemies) :
INDENT
    pygame.sprite.spritecollide(self, enemies, True)
    key = pygame.key.get_pressed()
    if key [pygame.K_w] :
    INDENT
        self.rect.y -= self.speed
    DEDENT
    elif key [pygame.K_s] :
    INDENT
        self.rect.y += self.speed
    DEDENT
    if key [pygame.K_a] :
    INDENT
        self.rect.x -= self.speed
    DEDENT
    elif key [pygame.K_d] :
    INDENT
        self.rect.x += self.speed
    DEDENT
    if self.rect.x > 1110 :
    INDENT
        self.rect.x = 1110
    DEDENT
    if self.rect.y < 20 :
    INDENT
        self.rect.y = 20
    DEDENT
    elif self.rect.y > 710 :
    INDENT
        self.rect.y = 710
    DEDENT
    if self.rect.x < 20 :
    INDENT
        self.rect.x = 20
    DEDENT
    elif self.rect.x == 1110 and self.rect.y > 300 and self.rect.y < 400 :
    INDENT
        self.rect.x = 25
    DEDENT
    if self.rect.y == 20 and self.rect.x > 500 and self.rect.x < 600 :
    INDENT
        self.rect.y = 715
    DEDENT
    elif self.rect.x == 20 and self.rect.y > 300 and self.rect.y < 400 :
    INDENT
        self.rect.x = 1090
    DEDENT
    if self.rect.y == 710 and self.rect.x > 500 and self.rect.x < 600 :
    INDENT
        self.rect.y = 25

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34948928_34952608_9_19
34948928_38906843_9_18
Title: Multiple interact() commands duplicate widgets in IPython 
----------------------------------------

def fun1(dataset_id) :
INDENT
    dataset = read_dataset(dataset_id)
    sliders = interactive(fun2, data = fixed(dataset), var = (0, dataset ["property"], 0.1))
    close_button = widgets.Button(description = "Remove sliders")
    def remove_sliders(b) :
    INDENT
        sliders.close()
        b.close()
    DEDENT
    close_button.on_click(remove_sliders)
    display(sliders)
    display(close_button)
DEDENT
----------------------------------------

def fun1(dataset_id) :
INDENT
    global sliders
    try :
    INDENT
        sliders.close()
    DEDENT
    except NameError :
    INDENT
        pass
    DEDENT
    dataset = read_dataset(dataset_id)
    sliders = interactive(fun2, data = fixed(dataset), var = (0, dataset ["property"], 0.1))
    display(sliders)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34968722_39558290_16_23
34968722_42797620_1_42
Title: How to implement the Softmax function in Python 
----------------------------------------

def softmax(z) :
INDENT
    assert len(z.shape) == 2
    s = np.max(z, axis = 1)
    s = s [:, np.newaxis]
    e_x = np.exp(z - s)
    div = np.sum(e_x, axis = 1)
    div = div [:, np.newaxis]
    return e_x / div
DEDENT
----------------------------------------

def softmax(X, theta = 1.0, axis = None) :
INDENT
    y = np.atleast_2d(X)

    if axis is None :
    INDENT
        axis = next(j [0] for j in enumerate(y.shape) if j [1] > 1)

    DEDENT
    y = y * float(theta)

    y = y - np.expand_dims(np.max(y, axis = axis), axis)

    y = np.exp(y)

    ax_sum = np.expand_dims(np.sum(y, axis = axis), axis)

    p = y / ax_sum

    if len(X.shape) == 1 : p = p.flatten()
    return p
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34975015_34976184_24_41
34975015_34976184_6_15
Title: How to scroll line numbers in a QTextEdit 
----------------------------------------

def __init__(self, font = QFont('Monospace', 12)) :
INDENT
    super(WinE, self).__init__()
    self.font = font
    self.font.setFixedPitch(True)
    self.ce = Editor(self)
    self.ce.setFont(self.font)
    self.setWindowTitle('Code Editor')
    self.textr = QRect(3, 5, self.ce.childrenRect().x() - 12, self.ce.childrenRect().height())
    self.setGeometry(QRect(800, 840, 351, 250))
    self.setCentralWidget(self.ce)
    self.show()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(Editor, self).__init__()
    self.setPlainText(u'apple, banana\norange\nblah blah\n\nOh yeah!....\n' * 6)
    self.setParent(parent)
    self.setWordWrapMode(QTextOption.NoWrap)
    self.setViewportMargins(50, 0, 0, 0)
    QObject.connect(self, SIGNAL("textChanged()"), self.repainting)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34976247_34976301_3_10
34976247_34976380_3_10
Title: Searching features implementation in django project 
----------------------------------------

def search(request) :
INDENT
    if request.method == "GET" :
    INDENT
        search_terms = request.GET ['title']
        search_terms = search_terms.split(',')
        search_terms = set(search_terms)
        queryargs = [Q(title__contains = i) for i in search_terms]
        jobs = Job.objects.filter(* queryargs)
    DEDENT
DEDENT
----------------------------------------

def search(request) :
INDENT
    if request.method == "GET" :
    INDENT
        search_terms = request.GET ['title']
        search_filter = Q()
        for term in search_terms.split(',') :
        INDENT
            search_filter |= Q(title__contains = term)
        DEDENT
        jobs = Job.objects.filter(search_filter)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34980763_34980999_10_18
34980763_34981178_13_25
Title: Trying to print two functions starting on the same line 
----------------------------------------

def top_left(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    for num in range(2, nsize + 1, 1) :
    INDENT
        spaces = nsize - num
        line += str(num)
        yield (spaces * ' ' + line [: : - 1])
    DEDENT
DEDENT
----------------------------------------

def top_left(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    output = [(nsize - 1) * ' ']
    for num in range(2, nsize + 1) :
    INDENT
        spaces = nsize - num
        line += str(num)
        output.append(spaces * ' ' + line [: : - 1])
    DEDENT
    return output

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34980763_34980999_10_18
34980763_34981417_11_20
Title: Trying to print two functions starting on the same line 
----------------------------------------

def top_left(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    for num in range(2, nsize + 1, 1) :
    INDENT
        spaces = nsize - num
        line += str(num)
        yield (spaces * ' ' + line [: : - 1])
    DEDENT
DEDENT
----------------------------------------

def top_left(size) :
INDENT
    line = ''
    nsize = size / / 2
    out = []
    line = ""
    for num in range(nsize) :
    INDENT
        line += str(num + 1)
        out.append((nsize - len(line)) * ' ' + line)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34980763_34980999_1_9
34980763_34981178_1_12
Title: Trying to print two functions starting on the same line 
----------------------------------------

def top_right(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    spaces = nsize - 1
    for num in range(1, nsize + 1, 1) :
    INDENT
        line += str(num)
        yield (line)
    DEDENT
DEDENT
----------------------------------------

def top_right(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    spaces = nsize - 1
    output = list()
    for num in range(1, nsize + 1) :
    INDENT
        line += str(num)
        output.append(line + '\n')
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34980763_34980999_1_9
34980763_34981417_1_10
Title: Trying to print two functions starting on the same line 
----------------------------------------

def top_right(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    spaces = nsize - 1
    for num in range(1, nsize + 1, 1) :
    INDENT
        line += str(num)
        yield (line)
    DEDENT
DEDENT
----------------------------------------

def top_right(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    out = [""]
    line = ""
    for num in range(nsize) :
    INDENT
        line = str(num + 1) + line
        out.append(line)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34980763_34981178_13_25
34980763_34981417_11_20
Title: Trying to print two functions starting on the same line 
----------------------------------------

def top_left(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    output = [(nsize - 1) * ' ']
    for num in range(2, nsize + 1) :
    INDENT
        spaces = nsize - num
        line += str(num)
        output.append(spaces * ' ' + line [: : - 1])
    DEDENT
    return output

DEDENT
----------------------------------------

def top_left(size) :
INDENT
    line = ''
    nsize = size / / 2
    out = []
    line = ""
    for num in range(nsize) :
    INDENT
        line += str(num + 1)
        out.append((nsize - len(line)) * ' ' + line)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34980763_34981178_1_12
34980763_34981417_1_10
Title: Trying to print two functions starting on the same line 
----------------------------------------

def top_right(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    spaces = nsize - 1
    output = list()
    for num in range(1, nsize + 1) :
    INDENT
        line += str(num)
        output.append(line + '\n')
    DEDENT
    return output
DEDENT
----------------------------------------

def top_right(size) :
INDENT
    line = ''
    nsize = size / / 2 + 1
    out = [""]
    line = ""
    for num in range(nsize) :
    INDENT
        line = str(num + 1) + line
        out.append(line)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34983092_34983990_4_17
34983092_35005094_26_35
Title: Django: Get request in base class 
----------------------------------------

def dispatch(self, request, * args, ** kwargs) :
INDENT
    try :
    INDENT
        if self.request.session.get('sessionToken', None) == None :
        INDENT
            raise ValueError("User Not Logged In")
        DEDENT
        register(APPLICATION_ID, REST_API_KEY, session_token = token)
        self.user = User.current_user()
        self.LoggedIn = True
        print ("SUCCESS")
    DEDENT
    except :
    INDENT
        print ("FAILED")
        self.user = None
        self.LoggedIn = False
        print ("CALLED INIT")
    DEDENT
    return super(IndexView, self).dispatch(request, * args, ** kwargs)
DEDENT
----------------------------------------

def dispatch(self, request, * args, ** kwargs) :
INDENT
    token = self.request.session.get('sessionToken', None)
    if token ! = None :
    INDENT
        print ("Token : {0}".format(token))
        super(IndexView, self).__init__(* args, sessionToken = token)
    DEDENT
    if not self.isLoggedIn :
    INDENT
        HttpResponseRedirect('/')
    DEDENT
    return super(IndexView, self).dispatch(request, * args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34990950_34991261_1_13
34990950_34991415_1_19
Title: Creating list with dates 
----------------------------------------

def main() :
INDENT
    for number, s in enumerate(sections, 1) :
    INDENT

        lines = s.split("\n")
        if lines [4] :
        INDENT
            parts = lines [4].split(' ')
            print (number, parts [0], parts [2])
        DEDENT
        if lines [5] :
        INDENT
            parts = lines [5].split(' ')
            print (number, parts [0], parts [2])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    with open('output.txt', 'w') as f :
    INDENT
        for i in range(len(sections)) :
        INDENT
            date_row4 = sections [i].split("\n") [4].split(" ")
            date_row5 = sections [i].split("\n") [5].split(" ")
            print (date_row4)
            print (date_row5)
            month_row4 = date_row4 [1]
            year_row4 = date_row4 [3]
            month_row5 = date_row5 [1]
            year_row5 = date_row5 [3]
            if len(month_row4) :
            INDENT
                f.write("{} {}{}".format(month_row4, year_row4, '\n'))
            DEDENT
            if len(month_row4) :
            INDENT
                f.write("{} {}{}".format(month_row5, year_row5, '\n'))
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
34998715_35000165_1_19
34998715_35000165_2_17
Title: Need help to modify flood fill algorithm 
----------------------------------------

def fill(matrix, x, y, color1, color2) :
INDENT
    def fill(matrix, x, y, color1, color2) :
    INDENT
        matWidth = len(matrix)
        matHeight = len(matrix [0])
        if x < 0 or y < 0 or x > = matWidth or y > = matHeight :
        INDENT
            return
        DEDENT
        if matrix [x] [y] == color2 or matrix [x] [y] ! = color1 :
        INDENT
            return
        DEDENT
        if matrix [x] [y] == color1 :
        INDENT
            matrix [x] [y] = color2
        DEDENT
        fill(matrix, x - 1, y, color1, color2)
        fill(matrix, x + 1, y, color1, color2)
        fill(matrix, x, y - 1, color1, color2)
        fill(matrix, x, y + 1, color1, color2)
    DEDENT
    fill(matrix, x, y, color1, color2)
    return matrix
DEDENT
----------------------------------------

def fill(matrix, x, y, color1, color2) :
INDENT
    matWidth = len(matrix)
    matHeight = len(matrix [0])
    if x < 0 or y < 0 or x > = matWidth or y > = matHeight :
    INDENT
        return
    DEDENT
    if matrix [x] [y] == color2 or matrix [x] [y] ! = color1 :
    INDENT
        return
    DEDENT
    if matrix [x] [y] == color1 :
    INDENT
        matrix [x] [y] = color2
    DEDENT
    fill(matrix, x - 1, y, color1, color2)
    fill(matrix, x + 1, y, color1, color2)
    fill(matrix, x, y - 1, color1, color2)
    fill(matrix, x, y + 1, color1, color2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35010905_35011670_12_80
35010905_35011684_5_29
Title: IntVar returning only 0 even with .get() function 
----------------------------------------

def genInput() :
INDENT
    gen = Toplevel()
    gen.wm_title("Data Input")
    v = IntVar()
    ent1 = Entry(gen, textvariable = v).pack()
    ent1Txt = Label(gen, text = 'Input Juvenile Populations')
    ent1Txt.pack()

    v2 = StringVar()
    ent2 = Entry(gen, textvariable = v2)
    ent2Txt = Label(gen, text = 'Input Adult Populations')
    ent2.pack()
    ent2Txt.pack()
    v3 = StringVar()
    ent3 = Entry(gen, textvariable = v3)
    ent3Txt = Label(gen, text = 'Input Senile Populations')
    ent3.pack()
    ent3Txt.pack()
    v4 = StringVar()
    ent4 = Entry(gen, textvariable = v4)
    ent4Txt = Label(gen, text = 'Input Survival rates for Juveniles')
    ent4.pack()
    ent4Txt.pack()
    v5 = StringVar()
    ent5 = Entry(gen, textvariable = v5)
    ent5Txt = Label(gen, text = 'Input Survival rates for Adults')
    ent5.pack()
    ent5Txt.pack()
    v6 = StringVar()
    ent6 = Entry(gen, textvariable = v6)
    ent6Txt = Label(gen, text = 'Input Survival rates for Seniles')
    ent6.pack()
    ent6Txt.pack()
    v7 = StringVar()
    ent7 = Entry(gen, textvariable = v7)
    ent7Txt = Label(gen, text = 'Input the birth rate')
    ent7.pack()
    ent7Txt.pack()
    v8 = StringVar()
    ent8 = Entry(gen, textvariable = v8)
    ent8Txt = Label(gen, text = 'Number of Generations')
    ent8.pack()
    ent8Txt.pack()
    def quit1() :
    INDENT
        gen.destroy()
        return
    DEDENT
    def submit() :
    INDENT
        popJ = v.get()
        popJtxt = Label(gen, text = popJ).pack()
        return
    DEDENT
    submit1 = Button(gen, text = "Submit")
    submit1.pack()
    submit1.configure(command = submit)
    return1 = Button(gen, text = 'Return to Menu')
    return1.pack(pady = 30)
    return1.configure(command = quit1)
    return
DEDENT
----------------------------------------

def genInput() :
INDENT
    gen = Toplevel()
    gen.wm_title("Data Input")
    v = IntVar()
    v.set(popJ)
    ent1 = Entry(gen, textvariable = v)
    ent1.pack()
    Label(gen, text = 'Input Juvenile Populations').pack()
    def quit1() :
    INDENT
        gen.destroy()
    DEDENT
    def submit() :
    INDENT
        global popJ
        popJ = v.get()
        Label(gen, text = popJ).pack()
        return
    DEDENT
    submit1 = Button(gen, text = "Submit")
    submit1.pack()
    submit1.configure(command = submit)
    return1 = Button(gen, text = 'Return to Menu')
    return1.pack(pady = 30)
    return1.configure(command = quit1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35010905_35011670_89_117
35010905_35011684_30_37
Title: IntVar returning only 0 even with .get() function 
----------------------------------------

def menu() :
INDENT
    menu = Tk()
    menu.wm_title("Greenfly model")
    genInp = Button(menu, text = "Set Generation Values")
    genVew = Button(menu, text = 'Dysplay Generation Values')
    modelCal = Button(menu, text = 'Run model')
    exportData = Button(menu, text = 'Export Data')
    genTxt = Label(menu, text = 'Input the Generation values')
    genvTxt = Label(menu, text = 'View the current generation values')
    modelTxt = Label(menu, text = 'Run the model')
    exportTxt = Label(menu, text = 'Export data')
    genInp.grid(row = 1, column = 1)
    genVew.grid(row = 2, column = 1)
    modelCal.grid(row = 3, column = 1)
    exportData.grid(row = 4, column = 1)
    genTxt.grid(row = 1, column = 2)
    genvTxt.grid(row = 2, column = 2)
    modelTxt.grid(row = 3, column = 2)
    exportTxt.grid(row = 4, column = 2)
    genInp.configure(command = genInput)
    genVew.configure(command = genView)
DEDENT
----------------------------------------

def menu() :
INDENT
    menu = Tk()
    menu.wm_title("Greenfly model")
    genInp = Button(menu, text = "Set Generation Values")
    genInp.grid(row = 1, column = 1)
    genInp.configure(command = genInput)
    menu.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35010905_35011684_30_37
35010905_35012001_93_122
Title: IntVar returning only 0 even with .get() function 
----------------------------------------

def menu() :
INDENT
    menu = Tk()
    menu.wm_title("Greenfly model")
    genInp = Button(menu, text = "Set Generation Values")
    genInp.grid(row = 1, column = 1)
    genInp.configure(command = genInput)
    menu.mainloop()
DEDENT
----------------------------------------

def menu() :
INDENT
    menu = Tk()
    menu.wm_title("Greenfly model")
    genInp = Button(menu, text = "Set Generation Values")
    genVew = Button(menu, text = 'Dysplay Generation Values')
    modelCal = Button(menu, text = 'Run model')
    exportData = Button(menu, text = 'Export Data')
    genTxt = Label(menu, text = 'Input the Generation values')
    genvTxt = Label(menu, text = 'View the current generation values')
    modelTxt = Label(menu, text = 'Run the model')
    exportTxt = Label(menu, text = 'Export data')
    genInp.grid(row = 1, column = 1)
    genVew.grid(row = 2, column = 1)
    modelCal.grid(row = 3, column = 1)
    exportData.grid(row = 4, column = 1)
    genTxt.grid(row = 1, column = 2)
    genvTxt.grid(row = 2, column = 2)
    modelTxt.grid(row = 3, column = 2)
    exportTxt.grid(row = 4, column = 2)
    genInp.configure(command = genInput)
    genVew.configure(command = genView)
    menu.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35010905_35011684_5_29
35010905_35012001_12_84
Title: IntVar returning only 0 even with .get() function 
----------------------------------------

def genInput() :
INDENT
    gen = Toplevel()
    gen.wm_title("Data Input")
    v = IntVar()
    v.set(popJ)
    ent1 = Entry(gen, textvariable = v)
    ent1.pack()
    Label(gen, text = 'Input Juvenile Populations').pack()
    def quit1() :
    INDENT
        gen.destroy()
    DEDENT
    def submit() :
    INDENT
        global popJ
        popJ = v.get()
        Label(gen, text = popJ).pack()
        return
    DEDENT
    submit1 = Button(gen, text = "Submit")
    submit1.pack()
    submit1.configure(command = submit)
    return1 = Button(gen, text = 'Return to Menu')
    return1.pack(pady = 30)
    return1.configure(command = quit1)
DEDENT
----------------------------------------

def genInput() :
INDENT
    gen = Toplevel()
    gen.wm_title("Data Input")
    v = IntVar()
    ent1 = Entry(gen, textvariable = v).pack()
    ent1Txt = Label(gen, text = 'Input Juvenile Populations')
    ent1Txt.pack()

    v2 = StringVar()
    ent2 = Entry(gen, textvariable = v2)
    ent2Txt = Label(gen, text = 'Input Adult Populations')
    ent2.pack()
    ent2Txt.pack()
    v3 = StringVar()
    ent3 = Entry(gen, textvariable = v3)
    ent3Txt = Label(gen, text = 'Input Senile Populations')
    ent3.pack()
    ent3Txt.pack()
    v4 = StringVar()
    ent4 = Entry(gen, textvariable = v4)
    ent4Txt = Label(gen, text = 'Input Survival rates for Juveniles')
    ent4.pack()
    ent4Txt.pack()
    v5 = StringVar()
    ent5 = Entry(gen, textvariable = v5)
    ent5Txt = Label(gen, text = 'Input Survival rates for Adults')
    ent5.pack()
    ent5Txt.pack()
    v6 = StringVar()
    ent6 = Entry(gen, textvariable = v6)
    ent6Txt = Label(gen, text = 'Input Survival rates for Seniles')
    ent6.pack()
    ent6Txt.pack()
    v7 = StringVar()
    ent7 = Entry(gen, textvariable = v7)
    ent7Txt = Label(gen, text = 'Input the birth rate')
    ent7.pack()
    ent7Txt.pack()
    v8 = StringVar()
    ent8 = Entry(gen, textvariable = v8)
    ent8Txt = Label(gen, text = 'Number of Generations')
    ent8.pack()
    ent8Txt.pack()
    def quit1() :
    INDENT
        gen.destroy()
        return
    DEDENT
    def submit() :
    INDENT
        global popJ
        popJ = v.get()
        popJtxt = Label(gen, text = v.get()).pack()
        return
    DEDENT
    submit1 = Button(gen, text = "Submit")
    submit1.pack()
    submit1.configure(command = submit)
    return1 = Button(gen, text = 'Return to Menu')
    return1.pack(pady = 30)
    return1.configure(command = quit1)
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35030301_35030679_1_26
35030301_35030869_3_14
Title: "Combine compare and order a list in a certain order" 
----------------------------------------

def get_negatives_at_front(list1, list2) :
INDENT
    a = max(len(list2), len(list1))
    if len(list1) > len(list2) :
    INDENT
        for d in range(0, len(list1) - len(list2)) :
        INDENT
            list2.append(None)
        DEDENT
    DEDENT
    elif len(list2) > len(list1) :
    INDENT
        for d in range(0, len(list2) - len(list1)) :
        INDENT
            list1.append(None)
        DEDENT
    DEDENT
    neg = []
    pos = []
    for l in range(0, a) :
    INDENT
        print l
        if list1 [l] ! = None :
        INDENT
            if list1 [l] < 0 :
            INDENT
                neg.append(list1 [l])
            DEDENT
            else :
            INDENT
                pos.append(list1 [l])
            DEDENT
        DEDENT
        if list2 [l] ! = None :
        INDENT
            if list2 [l] < 0 :
            INDENT
                neg.append(list2 [l])
            DEDENT
            else :
            INDENT
                pos.append(list2 [l])
            DEDENT
        DEDENT
    DEDENT
    print neg + pos
DEDENT
----------------------------------------

def get_negatives_at_front(list1, list2) :
INDENT
    pos = []
    neg = []
    for v1, v2 in zip_longest(list1, list2) :
    INDENT
        if v1 is not None :
        INDENT
            neg.append(v1) if v1 < 0 else pos.append(v1)
        DEDENT
        if v2 is not None :
        INDENT
            neg.append(v2) if v2 < 0 else pos.append(v2)
        DEDENT
    DEDENT
    return neg + pos
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35030301_35030679_1_26
35030301_35030978_1_7
Title: "Combine compare and order a list in a certain order" 
----------------------------------------

def get_negatives_at_front(list1, list2) :
INDENT
    a = max(len(list2), len(list1))
    if len(list1) > len(list2) :
    INDENT
        for d in range(0, len(list1) - len(list2)) :
        INDENT
            list2.append(None)
        DEDENT
    DEDENT
    elif len(list2) > len(list1) :
    INDENT
        for d in range(0, len(list2) - len(list1)) :
        INDENT
            list1.append(None)
        DEDENT
    DEDENT
    neg = []
    pos = []
    for l in range(0, a) :
    INDENT
        print l
        if list1 [l] ! = None :
        INDENT
            if list1 [l] < 0 :
            INDENT
                neg.append(list1 [l])
            DEDENT
            else :
            INDENT
                pos.append(list1 [l])
            DEDENT
        DEDENT
        if list2 [l] ! = None :
        INDENT
            if list2 [l] < 0 :
            INDENT
                neg.append(list2 [l])
            DEDENT
            else :
            INDENT
                pos.append(list2 [l])
            DEDENT
        DEDENT
    DEDENT
    print neg + pos
DEDENT
----------------------------------------

def get_negatives_at_front(list1, list2) :
INDENT
    lp, ln = [], []
    for i in range(len(list1) if len(list1) > = len(list2) else len(list2)) :
    INDENT
        if i < len(list1) : ln.append(list1 [i]) if list1 [i] < 0 else lp.insert(0, list1 [i])
        if i < len(list2) : ln.append(list2 [i]) if list2 [i] < 0 else lp.insert(0, list2 [i])
    DEDENT
    return ln + lp
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35030301_35030679_1_26
35030301_35030983_3_17
Title: "Combine compare and order a list in a certain order" 
----------------------------------------

def get_negatives_at_front(list1, list2) :
INDENT
    a = max(len(list2), len(list1))
    if len(list1) > len(list2) :
    INDENT
        for d in range(0, len(list1) - len(list2)) :
        INDENT
            list2.append(None)
        DEDENT
    DEDENT
    elif len(list2) > len(list1) :
    INDENT
        for d in range(0, len(list2) - len(list1)) :
        INDENT
            list1.append(None)
        DEDENT
    DEDENT
    neg = []
    pos = []
    for l in range(0, a) :
    INDENT
        print l
        if list1 [l] ! = None :
        INDENT
            if list1 [l] < 0 :
            INDENT
                neg.append(list1 [l])
            DEDENT
            else :
            INDENT
                pos.append(list1 [l])
            DEDENT
        DEDENT
        if list2 [l] ! = None :
        INDENT
            if list2 [l] < 0 :
            INDENT
                neg.append(list2 [l])
            DEDENT
            else :
            INDENT
                pos.append(list2 [l])
            DEDENT
        DEDENT
    DEDENT
    print neg + pos
DEDENT
----------------------------------------

def get_negatives_at_front(l1, l2) :
INDENT
    negatives = []
    positives = []

    for x, y in izip_longest(l1, l2) :
    INDENT
        if x is not None :
        INDENT
            negatives.append(x) if x < 0 else positives.append(x)
        DEDENT
        if y is not None :
        INDENT
            negatives.append(y) if y < 0 else positives.append(y)
        DEDENT
    DEDENT
    return negatives + list(reversed(positives))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35030301_35030869_3_14
35030301_35030978_1_7
Title: "Combine compare and order a list in a certain order" 
----------------------------------------

def get_negatives_at_front(list1, list2) :
INDENT
    pos = []
    neg = []
    for v1, v2 in zip_longest(list1, list2) :
    INDENT
        if v1 is not None :
        INDENT
            neg.append(v1) if v1 < 0 else pos.append(v1)
        DEDENT
        if v2 is not None :
        INDENT
            neg.append(v2) if v2 < 0 else pos.append(v2)
        DEDENT
    DEDENT
    return neg + pos
DEDENT
----------------------------------------

def get_negatives_at_front(list1, list2) :
INDENT
    lp, ln = [], []
    for i in range(len(list1) if len(list1) > = len(list2) else len(list2)) :
    INDENT
        if i < len(list1) : ln.append(list1 [i]) if list1 [i] < 0 else lp.insert(0, list1 [i])
        if i < len(list2) : ln.append(list2 [i]) if list2 [i] < 0 else lp.insert(0, list2 [i])
    DEDENT
    return ln + lp
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35030301_35030978_1_7
35030301_35030983_3_17
Title: "Combine compare and order a list in a certain order" 
----------------------------------------

def get_negatives_at_front(list1, list2) :
INDENT
    lp, ln = [], []
    for i in range(len(list1) if len(list1) > = len(list2) else len(list2)) :
    INDENT
        if i < len(list1) : ln.append(list1 [i]) if list1 [i] < 0 else lp.insert(0, list1 [i])
        if i < len(list2) : ln.append(list2 [i]) if list2 [i] < 0 else lp.insert(0, list2 [i])
    DEDENT
    return ln + lp
DEDENT
----------------------------------------

def get_negatives_at_front(l1, l2) :
INDENT
    negatives = []
    positives = []

    for x, y in izip_longest(l1, l2) :
    INDENT
        if x is not None :
        INDENT
            negatives.append(x) if x < 0 else positives.append(x)
        DEDENT
        if y is not None :
        INDENT
            negatives.append(y) if y < 0 else positives.append(y)
        DEDENT
    DEDENT
    return negatives + list(reversed(positives))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35031081_35052988_12_31
35031081_35052988_70_86
Title: Relating a canvas to a figure wxPython 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, parent = None, id = - 1, title = 'SWAP!', size = (480, 390))
    self.figurePanel = FigurePanel(parent = self)
    self.canvas1 = self.figurePanel.canvas
    self.canvas2 = self.figurePanel.enlarged_canvas
    self.fig1 = self.figurePanel.enlarged_figure
    self.fig2 = self.figurePanel.figure
    self.fig1.set_canvas(self.canvas1)
    self.canvas1.Show()
    self.Show()
    self.canvas2.mpl_connect("button_release_event", self.OnLoadFigure)
    print "Click anywhere on the figure to swap the plots!"
    self.display = 1
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.figPanel = self
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.figure = Figure(figsize = (8, 6.1), dpi = 60)
    self.ax = self.figure.add_subplot(1, 1, 1)
    self.ax.plot([1, 2, 3], [1, 2, 3])
    self.enlarged_figure = Figure(figsize = (8, 6.1), dpi = 60)
    self.ax1 = self.enlarged_figure.add_subplot(2, 1, 1)
    self.ax2 = self.enlarged_figure.add_subplot(2, 1, 2)
    self.ax1.plot([1, 2, 3], [1, 4, 9])
    self.ax2.plot([1, 2, 3], [1, 4, 9])
    self.canvas = FigureCanvas(self, - 1, self.figure)
    self.enlarged_canvas = FigureCanvas(self, - 1, self.enlarged_figure)
    self.Layout()
    self.Fit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35031182_35035247_39_47
35031182_35035247_49_58
Title: Why attribute lookup in Python is designed this way (precedence chain)? 
----------------------------------------

def __init__(self) :
INDENT
    self.attr = 10
    self.get_set_attr = 10
    self.get_set_attr = GetSetDesc(5)
    self.set_attr = 10
    self.set_attr = SetDesc(5)
    self.get_attr = 10
    self.get_attr = GetDesc(5)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.attr = 100
    self.get_set_attr = 100
    self.get_set_attr = GetSetDesc(50)
    self.set_attr = 100
    self.set_attr = SetDesc(50)
    self.get_attr = 100
    self.get_attr = GetDesc(50)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35049912_35050087_3_12
35049912_35050192_21_26
Title: Passing Variables/lists through Functions 
----------------------------------------

def random_gen(number1, number2) :
INDENT
    for i in range(20) :
    INDENT
        num = random.randint(number1, number2)
        if num % 2 == 0 :
        INDENT
            print ("Random Number", num, "is even")
        DEDENT
        else :
        INDENT
            print ("Random Number", num, "is odd")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def random_gen() :
INDENT
    number1, number2 = user_input()
    for i in range(20) :
    INDENT
        num = randint(number1, number2)
        odd_even(num)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35050867_35050882_1_10
35050867_35055149_1_14
Title: Python function that sums up lists and numbers 
----------------------------------------

def super_sum(* args) :
INDENT
    total = 0
    for i in args :
    INDENT
        if isinstance(i, (int, long)) :
        INDENT
            total += i
        DEDENT
        else :
        INDENT
            total += super_sum(* i)
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------

def super_sum(* args) :
INDENT
    total = 0
    args = list(args)
    if len(args) == 1 :
    INDENT
        args = args [0]
    DEDENT
    for d in args :
    INDENT
        if isinstance(d, list) :
        INDENT

            total += super_sum(d)
        DEDENT
        else :
        INDENT
            total += d
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056626_11_17
35056347_35056637_10_16
Title: Decorators around function with *args 
----------------------------------------

def add(* args) :
INDENT
    total = 0
    for i in args [0] :
    INDENT
        total += i
    DEDENT
    return total

DEDENT
----------------------------------------

def add(* args) :
INDENT
    result = 0
    for i in range(0, len(args [0])) :
    INDENT
        result += args [0] [i]
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056626_11_17
35056347_35056902_15_20
Title: Decorators around function with *args 
----------------------------------------

def add(* args) :
INDENT
    total = 0
    for i in args [0] :
    INDENT
        total += i
    DEDENT
    return total

DEDENT
----------------------------------------

def add(* args) :
INDENT
    result = 0
    for i in range(0, len(args [0])) :
    INDENT
        result += args [0] [i]
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056626_1_9
35056347_35056637_1_8
Title: Decorators around function with *args 
----------------------------------------

def wrapper(func) :
INDENT
    def inner(* args) :
    INDENT
        for i in args [0] :
        INDENT
            if not isinstance(i, int) :
            INDENT
                raise Exception('a non integer was encountered')
            DEDENT
        DEDENT
        else :
        INDENT
            return func(* args)
        DEDENT
    DEDENT
    return inner
DEDENT
----------------------------------------

def wrapper(func) :
INDENT
    def inner(* args) :
    INDENT
        for i in range(len(args [0])) :
        INDENT
            if not isinstance(args [0] [i], int) :
            INDENT
                return 'Invalid values.'
            DEDENT
        DEDENT
        return func(* args)
    DEDENT
    return inner
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056626_1_9
35056347_35056660_1_8
Title: Decorators around function with *args 
----------------------------------------

def wrapper(func) :
INDENT
    def inner(* args) :
    INDENT
        for i in args [0] :
        INDENT
            if not isinstance(i, int) :
            INDENT
                raise Exception('a non integer was encountered')
            DEDENT
        DEDENT
        else :
        INDENT
            return func(* args)
        DEDENT
    DEDENT
    return inner
DEDENT
----------------------------------------

def wrapper(func) :
INDENT
    def inner(args) :
    INDENT
        for item in args :
        INDENT
            if not isinstance(item, int) :
            INDENT
                return 'Invalid value found'
            DEDENT
        DEDENT
        return func(args)
    DEDENT
    return inner
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056626_2_7
35056347_35056637_2_6
Title: Decorators around function with *args 
----------------------------------------

def inner(* args) :
INDENT
    for i in args [0] :
    INDENT
        if not isinstance(i, int) :
        INDENT
            raise Exception('a non integer was encountered')
        DEDENT
    DEDENT
    else :
    INDENT
        return func(* args)
    DEDENT
DEDENT
----------------------------------------

def inner(* args) :
INDENT
    for i in range(len(args [0])) :
    INDENT
        if not isinstance(args [0] [i], int) :
        INDENT
            return 'Invalid values.'
        DEDENT
    DEDENT
    return func(* args)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056626_2_7
35056347_35056660_2_6
Title: Decorators around function with *args 
----------------------------------------

def inner(* args) :
INDENT
    for i in args [0] :
    INDENT
        if not isinstance(i, int) :
        INDENT
            raise Exception('a non integer was encountered')
        DEDENT
    DEDENT
    else :
    INDENT
        return func(* args)
    DEDENT
DEDENT
----------------------------------------

def inner(args) :
INDENT
    for item in args :
    INDENT
        if not isinstance(item, int) :
        INDENT
            return 'Invalid value found'
        DEDENT
    DEDENT
    return func(args)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056626_2_7
35056347_35056902_2_11
Title: Decorators around function with *args 
----------------------------------------

def inner(* args) :
INDENT
    for i in args [0] :
    INDENT
        if not isinstance(i, int) :
        INDENT
            raise Exception('a non integer was encountered')
        DEDENT
    DEDENT
    else :
    INDENT
        return func(* args)
    DEDENT
DEDENT
----------------------------------------

def inner(* args) :
INDENT
    for i in range(0, len(args [0])) :
    INDENT
        if not isinstance(i, int) :
        INDENT
            return 'Invaild values.'
        DEDENT
    DEDENT
    else :
    INDENT
        return func(* args)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056637_10_16
35056347_35056902_15_20
Title: Decorators around function with *args 
----------------------------------------

def add(* args) :
INDENT
    result = 0
    for i in range(0, len(args [0])) :
    INDENT
        result += args [0] [i]
    DEDENT
    return result

DEDENT
----------------------------------------

def add(* args) :
INDENT
    result = 0
    for i in range(0, len(args [0])) :
    INDENT
        result += args [0] [i]
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056637_1_8
35056347_35056660_1_8
Title: Decorators around function with *args 
----------------------------------------

def wrapper(func) :
INDENT
    def inner(* args) :
    INDENT
        for i in range(len(args [0])) :
        INDENT
            if not isinstance(args [0] [i], int) :
            INDENT
                return 'Invalid values.'
            DEDENT
        DEDENT
        return func(* args)
    DEDENT
    return inner
DEDENT
----------------------------------------

def wrapper(func) :
INDENT
    def inner(args) :
    INDENT
        for item in args :
        INDENT
            if not isinstance(item, int) :
            INDENT
                return 'Invalid value found'
            DEDENT
        DEDENT
        return func(args)
    DEDENT
    return inner
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056637_1_8
35056347_35056902_1_14
Title: Decorators around function with *args 
----------------------------------------

def wrapper(func) :
INDENT
    def inner(* args) :
    INDENT
        for i in range(len(args [0])) :
        INDENT
            if not isinstance(args [0] [i], int) :
            INDENT
                return 'Invalid values.'
            DEDENT
        DEDENT
        return func(* args)
    DEDENT
    return inner
DEDENT
----------------------------------------

def wrapper(func) :
INDENT
    def inner(* args) :
    INDENT
        for i in range(0, len(args [0])) :
        INDENT
            if not isinstance(i, int) :
            INDENT
                return 'Invaild values.'
            DEDENT
        DEDENT
        else :
        INDENT
            return func(* args)
        DEDENT
    DEDENT
    return inner

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056637_2_6
35056347_35056660_2_6
Title: Decorators around function with *args 
----------------------------------------

def inner(* args) :
INDENT
    for i in range(len(args [0])) :
    INDENT
        if not isinstance(args [0] [i], int) :
        INDENT
            return 'Invalid values.'
        DEDENT
    DEDENT
    return func(* args)
DEDENT
----------------------------------------

def inner(args) :
INDENT
    for item in args :
    INDENT
        if not isinstance(item, int) :
        INDENT
            return 'Invalid value found'
        DEDENT
    DEDENT
    return func(args)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056637_2_6
35056347_35056902_2_11
Title: Decorators around function with *args 
----------------------------------------

def inner(* args) :
INDENT
    for i in range(len(args [0])) :
    INDENT
        if not isinstance(args [0] [i], int) :
        INDENT
            return 'Invalid values.'
        DEDENT
    DEDENT
    return func(* args)
DEDENT
----------------------------------------

def inner(* args) :
INDENT
    for i in range(0, len(args [0])) :
    INDENT
        if not isinstance(i, int) :
        INDENT
            return 'Invaild values.'
        DEDENT
    DEDENT
    else :
    INDENT
        return func(* args)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056660_1_8
35056347_35056902_1_14
Title: Decorators around function with *args 
----------------------------------------

def wrapper(func) :
INDENT
    def inner(args) :
    INDENT
        for item in args :
        INDENT
            if not isinstance(item, int) :
            INDENT
                return 'Invalid value found'
            DEDENT
        DEDENT
        return func(args)
    DEDENT
    return inner
DEDENT
----------------------------------------

def wrapper(func) :
INDENT
    def inner(* args) :
    INDENT
        for i in range(0, len(args [0])) :
        INDENT
            if not isinstance(i, int) :
            INDENT
                return 'Invaild values.'
            DEDENT
        DEDENT
        else :
        INDENT
            return func(* args)
        DEDENT
    DEDENT
    return inner

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35056347_35056660_2_6
35056347_35056902_2_11
Title: Decorators around function with *args 
----------------------------------------

def inner(args) :
INDENT
    for item in args :
    INDENT
        if not isinstance(item, int) :
        INDENT
            return 'Invalid value found'
        DEDENT
    DEDENT
    return func(args)
DEDENT
----------------------------------------

def inner(* args) :
INDENT
    for i in range(0, len(args [0])) :
    INDENT
        if not isinstance(i, int) :
        INDENT
            return 'Invaild values.'
        DEDENT
    DEDENT
    else :
    INDENT
        return func(* args)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35074757_35075226_3_16
35074757_35075477_9_17
Title: How to evaluate two items of the same list and return their sum if equal? 
----------------------------------------

def merge(line) :
INDENT
    cnt = len(line)
    line = [num for num in line if num ! = 0]
    out = []
    for num, niter in groupby(line) :
    INDENT
        ncnt = len(list(niter))
        out.extend([num * 2] * (ncnt / / 2))
        if ncnt % 2 :
        INDENT
            out.append(num)
        DEDENT
    DEDENT
    out.extend([0] * (cnt - len(out)))
    return out
DEDENT
----------------------------------------

def merge(line) :
INDENT
    size = len(line)
    resul = []
    for num, val in groupby(ifilter(bool, line)) :
    INDENT
        for pair in grouper(val, 2, 0) :
        INDENT
            resul.append(sum(pair))
        DEDENT
    DEDENT
    if len(resul) < size :
    INDENT
        resul.extend(repeat(0, size - len(resul)))
    DEDENT
    return resul
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
350799_1191310_2_12
350799_28843066_7_24
Title: How does Django Know the Order to Render Form Fields? 
----------------------------------------

def __init__(self, * args, ** kw) :
INDENT
    super(ModelForm, self).__init__(* args, ** kw)
    self.fields.keyOrder = [
        'super_user',
        'all_districts',
        'multi_district',
        'all_schools',
        'manage_users',
        'direct_login',
        'student_detail',
        'license']
DEDENT
----------------------------------------

def __init__(self, guide, * args, ** kwargs) :
INDENT
    self.guide = guide
    super(ChecklistForm, self).__init__(* args, ** kwargs)
    new_fields = OrderedDict()
    for tier, tasks in guide.tiers().items() :
    INDENT
        questions = [(t ['task'], t ['question']) for t in tasks if 'question' in t]
        new_fields [tier.lower()] = forms.MultipleChoiceField(
            label = tier,
            widget = forms.CheckboxSelectMultiple(),
            choices = questions,
            help_text = 'desired set of site features')
    DEDENT
    new_fields ['name'] = self.fields ['name']
    new_fields ['email'] = self.fields ['email']
    new_fields ['website'] = self.fields ['website']
    self.fields = new_fields
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
350799_1191310_2_12
350799_5747259_6_13
Title: How does Django Know the Order to Render Form Fields? 
----------------------------------------

def __init__(self, * args, ** kw) :
INDENT
    super(ModelForm, self).__init__(* args, ** kw)
    self.fields.keyOrder = [
        'super_user',
        'all_districts',
        'multi_district',
        'all_schools',
        'manage_users',
        'direct_login',
        'student_detail',
        'license']
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(ContestForm, self).__init__(* args, ** kwargs)
    self.fields.keyOrder = [
        'name',
        'description',
        'image',
        'video_link',
        'category']
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
350799_1191310_2_12
350799_871048_17_25
Title: How does Django Know the Order to Render Form Fields? 
----------------------------------------

def __init__(self, * args, ** kw) :
INDENT
    super(ModelForm, self).__init__(* args, ** kw)
    self.fields.keyOrder = [
        'super_user',
        'all_districts',
        'multi_district',
        'all_schools',
        'manage_users',
        'direct_login',
        'student_detail',
        'license']
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.fields = []
    for field_name in dir(self) :
    INDENT
        field = getattr(self, field_name)
        if isinstance(field, Field) :
        INDENT
            field.name = field_name
            self.fields.append(field)
        DEDENT
    DEDENT
    self.fields.sort(key = operator.attrgetter('count'))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
350799_28843066_7_24
350799_5747259_6_13
Title: How does Django Know the Order to Render Form Fields? 
----------------------------------------

def __init__(self, guide, * args, ** kwargs) :
INDENT
    self.guide = guide
    super(ChecklistForm, self).__init__(* args, ** kwargs)
    new_fields = OrderedDict()
    for tier, tasks in guide.tiers().items() :
    INDENT
        questions = [(t ['task'], t ['question']) for t in tasks if 'question' in t]
        new_fields [tier.lower()] = forms.MultipleChoiceField(
            label = tier,
            widget = forms.CheckboxSelectMultiple(),
            choices = questions,
            help_text = 'desired set of site features')
    DEDENT
    new_fields ['name'] = self.fields ['name']
    new_fields ['email'] = self.fields ['email']
    new_fields ['website'] = self.fields ['website']
    self.fields = new_fields
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(ContestForm, self).__init__(* args, ** kwargs)
    self.fields.keyOrder = [
        'name',
        'description',
        'image',
        'video_link',
        'category']
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
350799_28843066_7_24
350799_871048_17_25
Title: How does Django Know the Order to Render Form Fields? 
----------------------------------------

def __init__(self, guide, * args, ** kwargs) :
INDENT
    self.guide = guide
    super(ChecklistForm, self).__init__(* args, ** kwargs)
    new_fields = OrderedDict()
    for tier, tasks in guide.tiers().items() :
    INDENT
        questions = [(t ['task'], t ['question']) for t in tasks if 'question' in t]
        new_fields [tier.lower()] = forms.MultipleChoiceField(
            label = tier,
            widget = forms.CheckboxSelectMultiple(),
            choices = questions,
            help_text = 'desired set of site features')
    DEDENT
    new_fields ['name'] = self.fields ['name']
    new_fields ['email'] = self.fields ['email']
    new_fields ['website'] = self.fields ['website']
    self.fields = new_fields
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.fields = []
    for field_name in dir(self) :
    INDENT
        field = getattr(self, field_name)
        if isinstance(field, Field) :
        INDENT
            field.name = field_name
            self.fields.append(field)
        DEDENT
    DEDENT
    self.fields.sort(key = operator.attrgetter('count'))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
350799_5747259_6_13
350799_871048_17_25
Title: How does Django Know the Order to Render Form Fields? 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(ContestForm, self).__init__(* args, ** kwargs)
    self.fields.keyOrder = [
        'name',
        'description',
        'image',
        'video_link',
        'category']
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.fields = []
    for field_name in dir(self) :
    INDENT
        field = getattr(self, field_name)
        if isinstance(field, Field) :
        INDENT
            field.name = field_name
            self.fields.append(field)
        DEDENT
    DEDENT
    self.fields.sort(key = operator.attrgetter('count'))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35094941_35095844_1_12
35094941_35095978_1_11
Title: Trying to compress a string 
----------------------------------------

def compress(string) :
INDENT
    prevchar = string [: 1]
    cnt = 1
    result = []
    for char in string [1 :] :
    INDENT
        if char == prevchar :
        INDENT
            cnt += 1
        DEDENT
        else :
        INDENT
            result.append(prevchar + str(cnt))
            cnt = 1
        DEDENT
        prevchar = char
    DEDENT
    return ''.join(result) + prevchar + str(cnt)
DEDENT
----------------------------------------

def compress(s) :
INDENT
    it = iter(s)
    prev, i = next(it), 0
    for ch in s :
    INDENT
        if ch ! = prev :
        INDENT
            yield prev + str(i)
            i = 0
        DEDENT
        prev = ch
        i += 1
    DEDENT
    yield prev + str(i)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35096817_35097016_1_14
35096817_35097123_1_13
Title: Finding which coins make up the minimum of a total 
----------------------------------------

def changeSlow(coinValueList, total, coinsDict) :
INDENT
    if total == 0 :
    INDENT
        return 0
    DEDENT
    if total > = max(coinValueList) :
    INDENT
        total -= max(coinValueList)
        coinsDict [str(max(coinValueList))] += 1
    DEDENT
    else :
    INDENT
        coinValueList.pop()
        return changeSlow(coinValueList, total, coinsDict)
    DEDENT
    print (coinsDict)
    return 1 + changeSlow(coinValueList, total, coinsDict)

DEDENT
----------------------------------------

def changeSlow(coinValueList, total) :
INDENT
    options = []
    for coin in coinValueList :
    INDENT
        if coin < total :
        INDENT
            res = changeSlow(coinValueList, total - coin)
            if res :
            INDENT
                options.append([coin] + res)
            DEDENT
        DEDENT
        elif coin == total :
        INDENT
            return [coin]
        DEDENT
    DEDENT
    if options :
    INDENT
        return sorted(options, key = lambda x : len(x)) [0]
    DEDENT
    return []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35185543_35185823_2_11
35185543_35185892_1_13
Title: Overriding __eq__ and comparing two objects 
----------------------------------------

def __init__(self, temp = 0.0, unit = 'C') :
INDENT
    if float(temp) == str(temp) :
    INDENT
        raise ValueError('could not convert string to float: ' + "'" + str(temp) + "'")
    DEDENT
    else :
    INDENT
        self.t = float(temp)
    DEDENT
    if unit.upper() not in 'CF' :
    INDENT
        raise Exception
    DEDENT
    else :
    INDENT
        self.u = unit.upper()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, temp, unit) :
INDENT
    temp = float(temp)
    self.orig = temp
    self.unit = unit
    if unit == "K" :
    INDENT
        self.t = temp
    DEDENT
    elif unit == "C" :
    INDENT
        self.t = tmp + 273.15
    DEDENT
    elif unit == "F" :
    INDENT
        self.t = (temp + 459.67) * 5 / 9.0
    DEDENT
    else :
    INDENT
        raise ValueError("Unrecognized unit %s" % (unit,))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35205618_35206464_19_38
35205618_35207396_11_16
Title: sqlite query in python writes only last row to file using objects 
----------------------------------------

def main() :
INDENT
    fromVolunteers()
    testOutput = open(FILENAME, "w+")
    for row in rows :
    INDENT
        vlist = VLIST()
        vlist.setBob(row [0])
        vlist.setDave(row [1])
        vlist.setCarol(row [2])
        vlist.setAndy(row [3])
        vlist.setCarl(row [4])
        vlist.setDanny(row [5])
        vlist.setCheryl(row [6])
        vlist.setCynthia(row [7])
        vlist.setTara(row [8])
        vlist.setScott(row [9])
        vlist.setAshley(row [10])
        vlist.setCrystal(row [11])
        vlist.dump_object(testOutput)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    with open(OUTPUT, 'w') as file :
    INDENT
        for row in from_volunteers() :
        INDENT
            file.write(str(VolunteerList.new(row)))

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35236639_35237027_25_32
35236639_35239172_27_34
Title: Creating linked-list in python without using native lists 
----------------------------------------

def push_back(self, value) :
INDENT
    if self.empty() :
    INDENT
        self.front = self.rear = self.node(value, None)
    DEDENT
    else :
    INDENT
        x = self.node(value, None)
        self.rear.next = x
        self.rear = x
    DEDENT
DEDENT
----------------------------------------

def push_back(self, value) :
INDENT
    last_node = self._find_last()
    if last_node is None :
    INDENT

        self.push_front(value)
    DEDENT
    else :
    INDENT
        last_node.next = Node(value, None)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35236639_35237027_33_41
35236639_35239172_35_40
Title: Creating linked-list in python without using native lists 
----------------------------------------

def pop_front(self) :
INDENT
    if self.empty() :
    INDENT
        raise RuntimeError("Empty List")
    DEDENT
    x = self.front.value
    self.front = self.front.next
    if not self.front :
    INDENT
        self.rear = None
    DEDENT
    return x
DEDENT
----------------------------------------

def pop_front(self) :
INDENT
    if self.is_empty :
    INDENT
        raise RuntimeError('list empty')
    DEDENT
    value, self.head = self.head.value, self.head.next
    return value
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35236639_35237027_42_56
35236639_35239172_41_53
Title: Creating linked-list in python without using native lists 
----------------------------------------

def pop_back(self) :
INDENT
    if self.empty() :
    INDENT
        raise RuntimeError("Empty List")
    DEDENT
    y = self.rear.value
    if not self.front.next :
    INDENT
        self.front = self.rear = None
    DEDENT
    else :
    INDENT
        x = self.front
        while x.next is not self.rear :
        INDENT
            x = x.next
        DEDENT
        x.next = None
        self.rear = x
    DEDENT
    return y

DEDENT
----------------------------------------

def pop_back(self) :
INDENT
    last_node = self._find_last()
    if last_node is None :
    INDENT
        raise RuntimeError('list empty')
    DEDENT
    if last_node is self.head :
    INDENT
        self.head = None
    DEDENT
    else :
    INDENT
        for node in self :
        INDENT
            if node.next is last_node :
            INDENT
                node.next = None
            DEDENT
        DEDENT
    DEDENT
    return last_node.value
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35241872_35245162_14_26
35241872_35245162_39_46
Title: How to download from JavaScript rendered webpage? 
----------------------------------------

def __init__(self, html) :
INDENT
    self.html = None
    self.app = QApplication(sys.argv)
    QWebEngineView.__init__(self)
    self.loadFinished.connect(self._loadFinished)
    self.setHtml(html)
    while self.html is None :
    INDENT
        self.app.processEvents(
            QEventLoop.ExcludeUserInputEvents |
            QEventLoop.ExcludeSocketNotifiers |
            QEventLoop.WaitForMoreEvents)
    DEDENT
    self.app.quit()
DEDENT
----------------------------------------

def __init__(self, html) :
INDENT
    self.html = None
    self.app = QApplication(sys.argv)
    QWebPage.__init__(self)
    self.loadFinished.connect(self._loadFinished)
    self.mainFrame().setHtml(html)
    self.app.exec_()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3525387_3532673_20_27
3525387_3532673_45_59
Title: How do I ensure data integrity for objects in google app engine without using key names? 
----------------------------------------

def txn() :
INDENT
    existing_alias = cls.all().ancestor(alias_root).filter('alias = ', category_alias).get()
    if existing_alias is None :
    INDENT
        existing_alias = CategoryAlias(parent = alias_root, alias = category_alias)
        existing_alias.put()
    DEDENT
    return existing_alias
DEDENT
----------------------------------------

def txn(category_keyname) :
INDENT
    category_key = Key.from_path('Category', category_keyname)
    existing_category = db.get(category_key)
    if existing_category is None :
    INDENT
        existing_category = Category(key_name = category_keyname)
        existing_category.put()
    DEDENT
    existing_item = Item.all().ancestor(existing_category).filter('name = ', item_name).get()
    if existing_item is None :
    INDENT
        existing_item = Item(parent = existing_category, name = item_name)
        existing_item.put()
    DEDENT
    return existing_item
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35256993_35258372_1_15
35256993_35262606_1_15
Title: Python: TypeError: 'int' object is not iterable 
----------------------------------------

def is_fib(n) :
INDENT
    def fib(x) :
    INDENT
        if x == 0 :
        INDENT
            return 0
        DEDENT
        elif x == 1 :
        INDENT
            return 1
        DEDENT
        else :
        INDENT
            return fib(x - 1) + fib(x - 2)
        DEDENT
    DEDENT
    for a in range(n + 2) :
    INDENT
        if fib(a) == n :
        INDENT
            return True

        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def is_fib(n) :
INDENT
    if n < 0 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        fib_0 = 0
        fib_1 = 1
        if n == fib_0 or n == fib_1 :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            for a in range(2, n + 2) :
            INDENT
                fib = fib_0 + fib_1
                fib_0, fib_1 = fib_1, fib
                if fib > = n :
                INDENT
                    break
                DEDENT
            DEDENT
            return fib == n
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35272592_46104634_26_37
35272592_52912500_20_31
Title: How are finite automata implemented in code? 
----------------------------------------

def trans(transition, input, final, state, i) :
INDENT
    for j in range(len(input)) :
    INDENT
        for each in transition [state] [int(input [j])] :
        INDENT
            if each < 4 :
            INDENT
                state = each
                if j == len(input) - 1 and (str(state) in final) :
                INDENT
                    print "accepted"
                    sys.exit()
                DEDENT
                trans(transition, input [i + 1 :], final, state, i)
            DEDENT
        DEDENT
        i = i + 1

    DEDENT
DEDENT
----------------------------------------

def trans(transition, input, final, state) :
INDENT
    for each in transition [state] [int(input [0])] :
    INDENT
        if each < 4 :
        INDENT
            state = each
            if len(input) == 1 :
            INDENT
                if (str(state) in final) :
                INDENT
                    print "accepted"
                    sys.exit()
                DEDENT
                else :
                INDENT
                    continue
                DEDENT
            DEDENT
            trans(transition, input [1 :], final, state)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35281511_35281564_1_9
35281511_35281641_1_10
Title: "Python: NameError: name ""string"" is not defined not via input()" 
----------------------------------------

def isISBN(n) :
INDENT
    checkSum = 0
    for i in range(9) :
    INDENT
        checkSum = checkSum + (eval(n [i]) * (i + 1))
    DEDENT
    if (checkSum % 11 == 10 and n [9] == 'X') or checkSum % 11 == eval(n [9]) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def isISBN(n) :
INDENT
    checkSum = 0
    for i in range(9) :
    INDENT
        checkSum = checkSum + (int(n [i]) * (i + 1))
    DEDENT
    if n [9] == 'X' :
    INDENT
        if checkSum % 11 == 10 : return True
        else : return False
    DEDENT
    elif checkSum % 11 == int(n [9]) : return True
    else : return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35288944_35289134_3_14
35288944_35289163_1_11
Title: Adding values to a matrix with a for loop in python 
----------------------------------------

def matrixH0(k) :
INDENT
    H0 = []
    for m in range(k) :
    INDENT

        row = []
        for n in range(k) :
        INDENT
            if abs(m - n) == 1 :
            INDENT
                row.append(math.sqrt(n + m + 1) / 2.)
            DEDENT
            else :
            INDENT
                row.append(0)
            DEDENT
        DEDENT
        H0.append(row)
    DEDENT
    return H0
DEDENT
----------------------------------------

def matrixH0(k) :
INDENT
    H0 = []
    print H0
    for m in range(0, k) :
    INDENT
        H0.append([])
        for n in range(0, k) :
        INDENT
            if abs(m - n) == 1 :
            INDENT
                H0 [m].append(math.sqrt(n + m + 1) / 2.)
            DEDENT
            else :
            INDENT
                H0 [m].append(0)
            DEDENT
        DEDENT
        print H0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35288944_35289134_3_14
35288944_35289165_1_11
Title: Adding values to a matrix with a for loop in python 
----------------------------------------

def matrixH0(k) :
INDENT
    H0 = []
    for m in range(k) :
    INDENT

        row = []
        for n in range(k) :
        INDENT
            if abs(m - n) == 1 :
            INDENT
                row.append(math.sqrt(n + m + 1) / 2.)
            DEDENT
            else :
            INDENT
                row.append(0)
            DEDENT
        DEDENT
        H0.append(row)
    DEDENT
    return H0
DEDENT
----------------------------------------

def matrixH0(k) :
INDENT
    H0 = []
    print H0
    for m in range(0, k) :
    INDENT
        H0.append([])
        for n in range(0, k) :
        INDENT
            if abs(m - n) == 1 :
            INDENT
                H0 [m].append(math.sqrt(n + m + 1) / 2.)
            DEDENT
            else :
            INDENT
                H0 [m].append(0)
            DEDENT
        DEDENT
        print H0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35296348_35296428_1_19
35296348_35297843_13_21
Title: How can I refactor this code to be more concise? 
----------------------------------------

def get_pvs(service, profile_id, start_date, end_date, type, data) :
INDENT
    if type == 'url' :
    INDENT
        kwargs = {
            'dimensions' : 'ga:pagePath',
            'filters' : 'ga:pageviews!=0',
            'maxresults' : 100}
    DEDENT
    elif type == 'author' :
    INDENT
        kwargs = {
            'dimensions' : 'ga:dimension2',
            'max_results' : '100'}
    DEDENT
    return service.data().ga().get(
        ids = 'ga:' + profile_id,
        start_date = start_date,
        end_date = end_date,
        metrics = 'ga:pageviews',
        sort = '-ga:pageviews',
        ** kwargs).execute()
DEDENT
----------------------------------------

def get_pvs(service, profile_id, start_date, end_date, type, data) :
INDENT
    if type in TYPE_SETTINGS :
    INDENT
        return service.data().ga().get(
            ids = 'ga:' + profile_id,
            start_date = start_date,
            end_date = end_date,
            metrics = 'ga:pageviews',
            sort = '-ga:pageviews',
            ** TYPE_SETTINGS [type]).execute()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35330330_35330403_1_12
35330330_35330499_29_45
Title: Create a Program using Python: Program must count the number of words and count the number of letters in each word 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        phrase = input("Enter Your Sentence or quit to exit: \n")
        if phrase.lower() == 'quit' :
        INDENT
            break
        DEDENT
        else :
        INDENT
            words = phrase.split()
            WordCount = len(words)
            LetterCount = [len(word) for word in words]
            print ("Total Amount of Words in Sentence:", WordCount)
            print ("Total Amount of Letters in Sentence:", LetterCount)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    start_again = "y"
    while start_again == "y" :
    INDENT
        phrase = user_input()
        number_words = word_count(phrase)
        letters = letter_count(phrase)
        print ("Total amount of words: ", number_words)
        print ("Total amount of letters: ", letters)
        print ()
        start_again = restart_program()
        print ()
    DEDENT
    print ("Good Bye")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35331292_35339157_10_18
35331292_35370973_4_18
Title: "Tkinter Optionmenu-options list to be update(Upon selection should remove that selection from options)" 
----------------------------------------

def __init__(self, master) :
INDENT
    tk.Frame.__init__(self, master)
    self.dict = ['a', 'b', 'c']
    self.variable_a = tk.StringVar()
    self.optionmenu_a = tk.OptionMenu(self, self.variable_a, * self.dict)
    tk.Button(self, text = "Add", command = self.func).pack()
    self.optionmenu_a.pack()
    self.pack()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self, parent)
    self.menubutton = tk.Menubutton(self, text = "Pick an option", indicatoron = True,
        borderwidth = 1, relief = "raised")
    self.menu = tk.Menu(self.menubutton, tearoff = False)
    self.menubutton.configure(menu = self.menu)
    for choice in ("a", "b", "c") :
    INDENT
        self.menu.add_command(label = choice,
            command = lambda option = choice : self.set_option(option))
    DEDENT
    self.text = tk.Text(self)
    self.menubutton.pack(side = "top")
    self.text.pack(side = "top", fill = "both", expand = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35334473_35335575_1_8
35334473_35335697_1_26
Title: Hash table simulation 
----------------------------------------

def hash_probe(table, key) :
INDENT
    size = len(table)
    hash_key = key % size
    while table [hash_key] is not None :
    INDENT
        hash_key = (hash_key + 1) % size
    DEDENT
    table [hash_key] = key
    return table
DEDENT
----------------------------------------

def hash_probe(keys, size) :
INDENT
    hash_table = [None] * size
    for key in keys :
    INDENT
        hash_key = key % size
        if hash_table [hash_key] is None :
        INDENT
            hash_table [hash_key] = key
        DEDENT
        else :
        INDENT
            i = (hash_key + 1) % size

            count = 0
            while count < size and hash_table [i] is not None :
            INDENT
                i = (i + 1) % size
                count += 1

            DEDENT
            if hash_table [i] is None :
            INDENT
                hash_table [i] = key
            DEDENT
            else :
            INDENT
                print ("No more space in the hash table!!")
            DEDENT
        DEDENT
    DEDENT
    return hash_table

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35353287_35353528_55_83
35353287_35353687_58_73
Title: Python adding through if else and def 
----------------------------------------

def question_d(tom = 0, jon = 0, chris = 0) :
INDENT
    print "Do you own a husky?"
    q = ''
    while q not in ['yes', 'no'] :
    INDENT
        q = raw_input("><![CDATA[ ")
        if q == "no" :
        INDENT
            tom = tom + 1
            chris = chris + 1
        DEDENT
        elif q == "yes" :
        INDENT
            jon = jon + 1
        DEDENT
        else :
        INDENT
            print "Hey you, follow the rules."
        DEDENT
    DEDENT
    if tom > jon and tom > chris :
    INDENT
        print "You're tom"
    DEDENT
    if jon > chris and jon > tom :
    INDENT
        print "You're jon"
    DEDENT
    if chris > tom and chris > jon :
    INDENT
        print "You're chris"
    DEDENT
    if raw_input('Play again? (yes or no)') == 'yes' :
    INDENT
        question_a()
    DEDENT
    else :
    INDENT
        print 'bye.'
    DEDENT
DEDENT
----------------------------------------

def question_d() :
INDENT
    global Tom, Chris, Jon
    print "Do you own a husky?"
    q1 = raw_input("><![CDATA[ ")
    if q1 == "no" :
    INDENT
        Tom = Tom + 1
        Chris = Chris + 1
    DEDENT
    elif q1 == "yes" :
    INDENT
        Jon = Jon + 1
    DEDENT
    else :
    INDENT
        print "Hey you, follow the rules."
        question_d()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35366897_35366997_1_18
35366897_35367350_1_14
Title: If else statement error in Python 
----------------------------------------

def make_tracker(self) :
INDENT
    self.region = re.search(r'CLI Command: \'show system information\'', line)
    if self.region :
    INDENT
        self.region = "show system information"
        return self.region
    DEDENT
    self.region = re.search(r'CLI Command: \'show card detail\'', line)
    if self.region :
    INDENT

        self.region = "CPM or IOM"
        return self.region
    DEDENT
    self.region = re.search(r'CLI Command: \'show mda detail\'', line)
    if self.region :
    INDENT
        self.region = "MDA"
        return self.region
    DEDENT
    print "Could not Enter any of the regions"
DEDENT
----------------------------------------

def make_tracker(self) :
INDENT
    if "CLI Command: 'show system information'" in line :
    INDENT
        self.region = "show system information"
        return self.region
    DEDENT
    elif "CLI Command: 'show card detail'" in line :
    INDENT
        self.region = "CPM or IOM"
        return self.region
    DEDENT
    elif "CLI Command: 'show mda detail'" in line :
    INDENT
        self.region = "MDA"
    DEDENT
    else :
    INDENT
        print "Could not Enter any of the regions"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35372867_35374116_12_23
35372867_35374116_39_53
Title: Simple Multithreaded Web Server in Python 
----------------------------------------

def run(self) :
INDENT
    self.serverSocket.bind(('', self.serverPort))
    self.serverSocket.listen(1)
    while True :
    INDENT
        print 'Ready to serve...'
        connectionSocket, addr = self.serverSocket.accept()
        message = connectionSocket.recv(1024)
        print "Message recieved, opening new thread"
        self.connectionThreads.append(connectionThread(connectionSocket, message))
        self.connectionThreads [- 1].daemon = 1
        self.connectionThreads [- 1].start()
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        filename = self.message.split() [1]
        f = open(filename [1 :])
        outputdata = f.read()
        f.close()
        self.connSocket.send("HTTP/1.0 200 OK\r\n")
        for i in range(0, len(outputdata)) :
        INDENT
            self.connSocket.send(outputdata [i])
        DEDENT
    DEDENT
    except IOError :
    INDENT
        self.connSocket.send("404 Not Found")
    DEDENT
    finally :
    INDENT
        self.connSocket.shutdown(SHUT_RDWR)
        self.connSocket.close()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35373391_35373551_27_39
35373391_35373732_31_47
Title: Allowing users to create multiple list in Python 
----------------------------------------

def menu() :
INDENT
    print "PLease choose an option (1-4):\n"
    choice = raw_input("1) input\n" "2) change price and owner\n" "3) search a car and print info\n" "\"exit\" Exit")
    if choice == "1" :
    INDENT
        input_car()
    DEDENT
    elif choice == "2" :
    INDENT
        print "Price"
    DEDENT
    elif choice == "3" :
    INDENT
        print "Search and Print info"
    DEDENT
DEDENT
----------------------------------------

def menu() :
INDENT
    keep_running = True

    while keep_running :
    INDENT
        print "PLease choose an option (1-4):\n"
        choice = raw_input("1) input\n" "2) change price and owner\n" "3) list all cars\n" "\"exit\" Exit")
        if choice == "1" :
        INDENT
            input()
        DEDENT
        elif choice == "2" :
        INDENT
            print "Price"
        DEDENT
        elif choice == "3" :
        INDENT
            print "\n".join(map(str, listing))
        DEDENT
        elif choice == "exit" :
        INDENT
            keep_running = False
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35381004_35381552_9_19
35381004_35381600_15_34
Title: Schedule Maximum Number Tasks That have Fixed Start and End times 
----------------------------------------

def max_meetings(slots) :
INDENT
    unique = 0
    while len(slots) > 0 :
    INDENT
        meeting = slots.pop(0)
        for slot in slots :
        INDENT
            if overlaps(meeting, slot) :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            unique += 1
        DEDENT
    DEDENT
    return unique
DEDENT
----------------------------------------

def max_meetings(meetings) :
INDENT
    meetings.sort()

    lst = [- 1]
    for m in meetings :
    INDENT

        i = bisect(lst, m.start)
        if i == len(lst) :
        INDENT

            lst.append(m.end)
        DEDENT
        elif m.end < lst [i] :
        INDENT

            lst [i] = m.end

        DEDENT
    DEDENT
    return len(lst) - 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35382289_35388927_10_24
35382289_35388927_39_46
Title: Controlling pygame animation through text input 
----------------------------------------

def __init__(self, surface, rows, cols, time_between_frames, on_finish) :
INDENT
    self.images = []
    self.current_image = 0
    self.time_between_frames = time_between_frames
    self.current_time
    self.on_finish = on_finish
    surf_width = (surface.get_width() / cols)
    surf_height = (surface.get_height() / rows)
    for x in range(cols) :
    INDENT
        for y in range(rows) :
        INDENT
            surf = pygame.Surface(surface.get_size())
            from_rect = pygame.Rect(x * surf_width, y * surf_height, surf_width, surf_height)
            surf.blit(surface, (0, 0), from_rect)
            self.images.append(surf)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    self.x = x
    self.y = y
    self.action = Player.resting
    self.restingAnimation = Animation(pygame.image.load("resting.png"), 2, 3, 500)
    self.abdomenKickAnimation = Animation(pygame.image.load("abdomenKick.png"), 4, 6, 50)
    self.currentAnimation = self.restingAnimation
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35385324_35385572_1_12
35385324_35385680_11_28
Title: This bisection method doesn't return a result 
----------------------------------------

def bisection(f, x1, x3, eps = 1e-4) :
INDENT
    while True :
    INDENT
        x2 = 0.5 * (x1 + x3)
        w = f(x2)
        if abs(w) < eps :
        INDENT
            break
        DEDENT
        if w < 0 :
        INDENT
            x1 = x2
        DEDENT
        else :
        INDENT
            x3 = x2
        DEDENT
    DEDENT
    return x2
DEDENT
----------------------------------------

def bisection(f, a, b, eps = 1e-4, maxIters = 10000) :
INDENT
    count = 1
    while count < maxIters :
    INDENT
        c = 0.5 * (a + b)
        if f(c) == 0 or 0.5 * (b - a) < = eps :
        INDENT
            break
        DEDENT
        count += 1
        fc = f(c)
        fa = f(a)
        if sign(fc) == sign(fa) :
        INDENT
            a = c
        DEDENT
        else :
        INDENT
            b = c
        DEDENT
    DEDENT
    return c
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35400065_39472895_23_32
35400065_39472895_5_14
Title: Multilabel Text Classification using TensorFlow 
----------------------------------------

def __init__(self, input, n_in, n_out) :
INDENT
    self.input = input
    w_o = tf.Variable(tf.random_normal([n_in, n_out], mean = 0.0, stddev = 0.05))
    b_o = tf.Variable(tf.zeros([n_out]))
    self.w = w_o
    self.b = b_o
    self.params = [self.w, self.b]
DEDENT
----------------------------------------

def __init__(self, input, n_in, n_out) :
INDENT
    self.input = input
    w_h = tf.Variable(tf.random_normal([n_in, n_out], mean = 0.0, stddev = 0.05))
    b_h = tf.Variable(tf.zeros([n_out]))
    self.w = w_h
    self.b = b_h
    self.params = [self.w, self.b]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35415018_35415210_1_10
35415018_35415433_1_11
Title: Most Divisors in Python 
----------------------------------------

def find_integer_with_most_divisors(input_list) :
INDENT
    nr_divisors = []
    for i in input_list :
    INDENT
        my_list = []
        for x in range(1, i + 1) :
        INDENT
            if i % x == 0 :
            INDENT
                my_list.append(x)
            DEDENT
        DEDENT
        nr_divisors.append(len(my_list))
    DEDENT
    return input_list [nr_divisors.index(max(nr_divisors))]
DEDENT
----------------------------------------

def find_integer_with_most_divisors(input_list) :
INDENT
    def divisor_length(num) :
    INDENT
        length = 0
        for i in range(1, num + 1) :
        INDENT
            if num % i == 0 :
            INDENT
                length += 1
            DEDENT
        DEDENT
        return length
    DEDENT
    return sorted(input_list, key = lambda x : divisor_length(x), reverse = True) [0]

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35423206_35429637_4_18
35423206_35436941_8_25
Title: wxpython: how to let button and static text appear in one window 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, 'Button Example',
        size = (300, 100))
    panel = wx.Panel(self, - 1)
    self.text = wx.StaticText(panel, - 1, "Release Tool v11.0", (130, 20))
    font = wx.Font(18, wx.DECORATIVE, wx.ITALIC, wx.NORMAL)
    self.text.SetFont(font)
    self.button = wx.Button(panel, - 1, "Hello", pos = (50, 20))
    self.Bind(wx.EVT_BUTTON, self.OnClick, self.button)
    self.button.SetDefault()
    MySizer = wx.BoxSizer(wx.VERTICAL)
    MySizer.Add(self.text, flag = wx.ALL, border = 10)
    MySizer.Add(self.button, flag = wx.ALL, border = 10)
    panel.SetSizer(MySizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MyPanel, self).__init__(parent)
    main_sizer = wx.BoxSizer(wx.VERTICAL)
    text = wx.StaticText(self, - 1, "Release Tool v11.0", (130, 20))
    font = wx.Font(18, wx.DECORATIVE, wx.ITALIC, wx.NORMAL)
    text.SetFont(font)
    main_sizer.Add(text, 0, wx.ALL, 5)
    self.button = wx.Button(self, - 1, "Hello", pos = (50, 20))
    self.Bind(wx.EVT_BUTTON, self.OnClick, self.button)
    self.button.SetDefault()
    main_sizer.Add(self.button, 0, wx.ALL, 5)
    self.SetSizer(main_sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35423750_35423825_1_25
35423750_35423869_1_21
Title: averaging integers from an input list of numbers in python 
----------------------------------------

def main() :
INDENT
    total = 0
    evens = []
    odds = []
    numfile = open('mynumbers.txt', 'r')
    line = numfile.readline()
    while line ! = '' :
    INDENT
        numb = int(line)
        print(numb, end = ' ')
        line = numfile.readline()
        if numb % 2 == 0 :
        INDENT
            evens.append(numb)
        DEDENT
        elif numb % 2 == 1 :
        INDENT
            odds.append(numb)
        DEDENT
    DEDENT
    numfile.close()
    e_avg = round(sum(evens) / len(evens), 4)
    o_avg = round(sum(odds) / len(odds), 4)
    print ('\n' + 'Average of the even numbers: ' + e_avg)
    print ('Average of the odd numbers: ' + o_avg)
DEDENT
----------------------------------------

def main() :
INDENT
    total = 0
    numfile = open('mynumbers.txt', 'r')
    line = numfile.readline()
    nums = []
    while line ! = '' :
    INDENT
        numb = int(line)
        print(numb, end = ' ')
        nums.append(numb)
        line = numfile.readline()

    DEDENT
    numfile.close()
    print ('\n' + 'Average of the even numbers:',)
    print ('Average of the odd numbers:',)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3543652_3544061_4_13
3543652_3545435_6_15
Title: Accessing the name of an instance in Python for printing 
----------------------------------------

def __str__(self) :
INDENT
    flocals = sys._getframe(1).f_locals
    for ident in flocals :
    INDENT
        if flocals [ident] is self :
        INDENT
            name = ident
            break
        DEDENT
    DEDENT
    else :
    INDENT
        name = 'roo'
    DEDENT
    return "in {0}'s pouch, there is {1}".format(name, self.pouch_contents)
DEDENT
----------------------------------------

def __str__(self) :
INDENT
    if not hasattr(self, 'name') :
    INDENT
        for k, v in globals().iteritems() :
        INDENT
            if id(v) == id(self) :
            INDENT
                self.name = k
                break
            DEDENT
            else :
            INDENT
                self.name = 'roo'
            DEDENT
        DEDENT
    DEDENT
    return "In %s's pouch there is: %s" % (self.name, self.pouch_contents)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35439598_35443360_14_28
35439598_49908655_5_18
Title: ttk creating and using a custom theme 
----------------------------------------

def __init__(self, master) :
INDENT
    pop_up = self.pop_up = Toplevel(master)
    self.pop_up_frame = ttk.Frame(pop_up, height = 100, width = 100)
    self.pop_up_frame.grid(sticky = E + W + S + N)
    self.s = ttk.Style()
    self.s.theme_create('shadow', parent = 'default')
    print (self.s.theme_names())
    self.c1_button = ttk.Button(pop_up, text = 'Default', command = self.get_default)
    self.c2_button = ttk.Button(pop_up, text = 'Vista', command = self.get_shadow)
    self.c1_button.grid()
    self.c2_button.grid()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    ttk.Frame.__init__(self, master)
    self.main_label = ttk.Label(self, text = "Pointless Text")
    self.main_button = ttk.Button(self, text = "Pointless Button")
    self.main_label.pack(padx = 5, pady = 5)
    self.main_button.pack(padx = 5, pady = 5)

    self.s = ttk.Style()
    self.s.configure('TLabel', foreground = 'red', background = 'grey')
    self.s.configure('TButton', foreground = 'white', background = 'blue')
    self.s.configure('TFrame', background = 'black')

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35442524_35442688_3_9
35442524_35442980_3_9
Title: How do i find the sum of a range of random numbers in python? 
----------------------------------------

def randnums() :
INDENT
    numbers = []
    for count in range(6) :
    INDENT
        number = random.randint(1, 9)
        numbers.append(number)
        print (number)
    DEDENT
    print (sum(numbers))
DEDENT
----------------------------------------

def randnums() :
INDENT
    total = 0
    for count in range(6) :
    INDENT
        number = random.randint(1, 9)
        total += number
    DEDENT
    print (total)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35443972_35444193_1_20
35443972_35444527_1_26
Title: How do I change my code so you can type in keywords? 
----------------------------------------

def troubleshooter() :
INDENT
    problems = ["My phone doesn't turn on",
        "My phone is freezing",
        "The screen is cracked",
        "I dropped my phone in water"]
    print ("""Please choose the problem you are having with your phone (input 1-4):
1) My phone doesn't turn on
2) My phone is freezing
3) The screen is cracked
4) I dropped my phone in water\n""")
    problemselect = input()
    if problemselect == problems [0] :
    INDENT
        not_on()
    DEDENT
    elif problemselect == problems [1] :
    INDENT
        freezing()
    DEDENT
    elif problemselect == problems [2] :
    INDENT
        cracked()
    DEDENT
    elif problemselect == problems [3] :
    INDENT
        water()
    DEDENT
    start()
DEDENT
----------------------------------------

def troubleshooter() :
INDENT
    q = raw_input('Enter you problem : ')
    q = q.lower()
    freeze = ['freeze', 'froze', 'freezing', 'hang', 'hung']
    boot = ['turn on', 'boot', 'off']
    screen = ['cracked', 'crack', 'broke', 'shattered', 'shatter']
    water = ['water', 'liquid']
    freeze_q = sum([q.find(keyword) for keyword in freeze])
    boot_q = sum([q.find(keyword) for keyword in boot])
    screen_q = sum([q.find(keyword) for keyword in screen])
    water_q = sum([q.find(keyword) for keyword in water])
    if freeze_q > - len(freeze) :
    INDENT

        not_on()
    DEDENT
    elif boot_q > - len(boot) :
    INDENT

        freezing()
    DEDENT
    elif screen_q > - len(screen) :
    INDENT

        cracked()
    DEDENT
    elif water_q > - len(water) :
    INDENT

        water()
    DEDENT
    else :
    INDENT
        print 'invalid question'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35469386_35469575_12_16
35469386_35470049_1_6
Title: Send values to Python coroutine without handling StopIteration 
----------------------------------------

def coroutine() :
INDENT
    score = 0
    yield
    for _ in range(3) :
    INDENT
        score = yield score + 1
    DEDENT
DEDENT
----------------------------------------

def coroutine() :
INDENT
    score = 0
    for _ in range(3) :
    INDENT
        score = yield score + 1
        yield
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35494176_35494353_1_14
35494176_35494920_3_17
Title: Display maximum value and items for knapsack python recursion 
----------------------------------------

def knapsack(capacity, itemList, taken) :
INDENT
    if len(itemList) == 0 :
    INDENT
        return (0, taken)
    DEDENT
    elif itemList [- 1] [0] > capacity :
    INDENT
        return (knapsack(capacity, itemList [: - 1]), taken)
    DEDENT
    else :
    INDENT
        return max(
            knapsack(capacity, itemList [: - 1]),
            knapsack(capacity - itemList [- 1] [0], itemList [: - 1]) + itemList [- 1] [1])
    DEDENT
DEDENT
----------------------------------------

def knapsack(capacity, itemList) :
INDENT
    if len(itemList) == 0 :
    INDENT
        return 0
    DEDENT
    elif itemList [- 1] [0] > capacity :
    INDENT
        ans = knapsack(capacity, itemList [: - 1])
        d [(len(itemList), capacity)] = ans
        return ans
    DEDENT
    else :
    INDENT
        ans = max(knapsack(capacity, itemList [: - 1]), knapsack(capacity - itemList [- 1] [0], itemList [: - 1]) + itemList [- 1] [1])
        d [(len(itemList), capacity)] = ans
        return ans
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35508371_35514241_56_65
35508371_35514241_89_97
Title: Python sys.excepthook working only on main process but not on subprocesses 
----------------------------------------

def run(self) :
INDENT
    self.running = True
    while self.running :
    INDENT
        try :
        INDENT
            while True :
            INDENT
                self.handle_message(* self.logger_queue.get(True, 0.1))
            DEDENT
        DEDENT
        except queue.Empty :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    uncaught_error_handler = UncaughtErrorHandler(self.logger_queue)
    try :
    INDENT
        self.do_consumer_work()
    DEDENT
    except :
    INDENT
        uncaught_error_handler.error_handler(* sys.exc_info())
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35540764_35540897_3_15
35540764_35540920_1_23
Title: Can't return the list I want 
----------------------------------------

def calc_averages() :
INDENT
    allprices = [['', '', '', '', 1.0, 2.0, 1.2, 1.3, 1.1, '', '', ''],
        ['', '', '', 1.2, 1.0, 2.0, 1.2, 1.3, 1.1, '', '', ''],
        ['', '', '', 1.2, '', 1.8, 1.3, 1.1, '', '', '', ''],
        ['', '', '', '', 1.0, 2.0, 1.2, 1.2, '', '', '', ''],
        ['', '', '', '', 1.0, 2.0, 1.1, 1.2, 1.4, 1.8, 1.9, 2.2]]
    averages = []
    for prices in zip(* allprices) :
    INDENT
        try :
        INDENT
            averages.append(statistics.mean(p for p in prices if p ! = ''))
        DEDENT
        except statistics.StatisticsError :
        INDENT
            averages.append('')
        DEDENT
    DEDENT
    return averages
DEDENT
----------------------------------------

def calc_averages() :
INDENT
    allprices = [['', '', '', '', 1.0, 2.0, 1.2, 1.3, 1.1, '', '', ''],
        ['', '', '', 1.2, 1.0, 2.0, 1.2, 1.3, 1.1, '', '', ''],
        ['', '', '', 1.2, '', 1.8, 1.3, 1.1, '', '', '', ''],
        ['', '', '', '', 1.0, 2.0, 1.2, 1.2, '', '', '', ''],
        ['', '', '', '', 1.0, 2.0, 1.1, 1.2, 1.4, 1.8, 1.9, 2.2]]

    averages = []
    for outer in allprices :
    INDENT
        counter = 0
        total = 0
        for item in outer :
        INDENT
            if item ! = '' :
            INDENT
                total += item
                counter += 1
            DEDENT
        DEDENT
        if counter == 0 :
        INDENT
            print ('')
        DEDENT
        else :
        INDENT
            averages.append(total / counter)
        DEDENT
    DEDENT
    return averages
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35542165_35542539_23_33
35542165_35556290_24_36
Title: Paraboloid optimization requiring scaling 
----------------------------------------

def linearize(self, params, unknowns, resids) :
INDENT
    x = params ['x']
    y = params ['y']
    J = {}
    J ['f_xy', 'x'] = 2.0 * x - 6.0 + y
    J ['f_xy', 'y'] = 2.0 * y + 8.0 + x
    return J
DEDENT
----------------------------------------

def linearize(self, params, unknowns, resids) :
INDENT
    x = params ['x']
    y = params ['y']
    J = {}

    J ['f_xy', 'x'] = 2000000.0 * x - 6000.0 + 10.0 * y
    J ['f_xy', 'y'] = 0.0002 * y + 0.08 + 10.0 * x
    return J
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
35543012_35543087_13_27
35543012_35543543_6_25
Title: Having trouble with code and program flow 
----------------------------------------

def move(n) :
INDENT
    steps = self.stepPerRev * self.TPI * n
    if steps > self.oldSteps :
    INDENT

        self.oldSteps -= steps
        print 'did %s steps up' % int(steps - oldSteps)
    DEDENT
    if steps < self.oldSteps :
    INDENT

        self.oldSteps -= steps
        print 'did %s steps down' % int(oldSteps - steps)
    DEDENT
DEDENT
----------------------------------------

def move(n) :
INDENT
    global Current_steps
    target_inches = float(n)
    target_steps = int(target_inches * THREADS_PER_INCH * STEPS_PER_REV)
    if target_steps == Current_steps :
    INDENT
        print ("Already here! Nothing to do...")
    DEDENT
    elif target_steps > Current_steps :
    INDENT
        print ("Turn CCW, {} steps".format(target_steps - Current_steps))
    DEDENT
    else :
    INDENT
        print ("Turn CW, {} steps".format(Current_steps - target_steps))
    DEDENT
    Current_steps = target_steps
DEDENT
----------------------------------------
