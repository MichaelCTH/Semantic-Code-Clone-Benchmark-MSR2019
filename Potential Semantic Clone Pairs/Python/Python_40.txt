$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42526413_42527729_110_143
42526413_42527729_60_82
Title: Updating a Matplotlib plot with user imput 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Graph Page!", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    values = ['jet', 'rainbow', 'ocean', 'hot', 'cubehelix', 'gnuplot', 'terrain', 'prism', 'pink']
    button1 = tk.Button(self, text = "Back to Home",
        command = lambda : controller.show_frame(StartPage))
    button1.pack()
    button2 = tk.Button(self, text = "Re-Render",
        command = self.plot)
    button2.pack()
    self.mvar = tk.IntVar()
    self.cbutton = tk.Checkbutton(self, text = "shadow", onvalue = 0, offvalue = 1, variable = self.mvar)
    self.cbutton.pack()
    self.combobox = ttk.Combobox(self, values = values)
    self.combobox.current(0)
    self.combobox.pack(side = tk.TOP)
    self.width, self.height = 10, 10
    fig = Figure(figsize = (self.width, self.height))
    self.ax = fig.add_subplot(111)
    self.canvas = FigureCanvasTkAgg(fig, self)
    self.canvas.show()
    toolbar = NavigationToolbar2TkAgg(self.canvas, self)
    toolbar.update()
    self.canvas.get_tk_widget().pack(side = tk.BOTTOM, fill = tk.BOTH, expand = True)
    self.plot()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "Mandelbrot Renderer")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)

    self.frames = {}
    for F in (StartPage, MainPage) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42526413_42527729_110_143
42526413_42527729_91_101
Title: Updating a Matplotlib plot with user imput 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Graph Page!", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    values = ['jet', 'rainbow', 'ocean', 'hot', 'cubehelix', 'gnuplot', 'terrain', 'prism', 'pink']
    button1 = tk.Button(self, text = "Back to Home",
        command = lambda : controller.show_frame(StartPage))
    button1.pack()
    button2 = tk.Button(self, text = "Re-Render",
        command = self.plot)
    button2.pack()
    self.mvar = tk.IntVar()
    self.cbutton = tk.Checkbutton(self, text = "shadow", onvalue = 0, offvalue = 1, variable = self.mvar)
    self.cbutton.pack()
    self.combobox = ttk.Combobox(self, values = values)
    self.combobox.current(0)
    self.combobox.pack(side = tk.TOP)
    self.width, self.height = 10, 10
    fig = Figure(figsize = (self.width, self.height))
    self.ax = fig.add_subplot(111)
    self.canvas = FigureCanvasTkAgg(fig, self)
    self.canvas.show()
    toolbar = NavigationToolbar2TkAgg(self.canvas, self)
    toolbar.update()
    self.canvas.get_tk_widget().pack(side = tk.BOTTOM, fill = tk.BOTH, expand = True)
    self.plot()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Start Page", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button = tk.Button(self, text = "Lets Begin",
        command = lambda : controller.show_frame(MainPage))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42526413_42527729_60_82
42526413_42527729_91_101
Title: Updating a Matplotlib plot with user imput 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "Mandelbrot Renderer")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)

    self.frames = {}
    for F in (StartPage, MainPage) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Start Page", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button = tk.Button(self, text = "Lets Begin",
        command = lambda : controller.show_frame(MainPage))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42528774_42529654_1_32
42528774_42529930_1_10
Title: Extract lines from a huge text file through two identifier as start and end using python 
----------------------------------------

def start_end_points(file_name) :
INDENT
    wanted_text = ""

    with open(file_name, "r") as f :
    INDENT
        found = False
        for line in f :
        INDENT
            if found :
            INDENT
                if "pi-pi stacking interactions:" in line :
                INDENT
                    break
                DEDENT
                else :
                INDENT
                    wanted_text += line
                DEDENT
            DEDENT
            if "Hydrogen bonds:" in line :
            INDENT
                wanted_text += line
                found = True

            DEDENT
        DEDENT
    DEDENT
    with open(file_name, "r") as f :
    INDENT
        all = f.read().split('\n')
        numbers = [i for i, line in enumerate(all) if "Hydrogen bonds:" in line or "pi-pi stacking interactions:" in line]
        wanted_text = all [numbers [0] : numbers [1]]

    DEDENT
    return wanted_text

DEDENT
----------------------------------------

def start_end_points(file_name) :
INDENT
    with open(file_name) as f :
    INDENT
        found = False
        for line in f :
        INDENT
            if found or ("Hydrogen bonds:" in line) :
            INDENT
                found = True
                print line
            DEDENT
            if "pi-pi stacking interactions:" in line :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42534823_42534870_1_9
42534823_42534892_1_8
Title: SyntaxError: can't assign to function call 
----------------------------------------

def statistics(data) :
INDENT
    stat = {}
    stat('minimum') = data.min()
    stat("maximum") = data.max()
    stat("mean") = data.mean()
    stat("median") = data.median()
    stat("std") = data.std()
    return stat
DEDENT
----------------------------------------

def statistics(data) :
INDENT
    stat = {}
    stat ['minimum'] = data.min()
    stat ["maximum"] = data.max()
    stat ["mean"] = data.mean()
    stat ["median"] = data.median()
    stat ["std"] = data.std()
    return stat
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42535739_42548737_23_42
42535739_42548737_3_10
Title: wxPython : Update the label on Panel with GridBagSizer and Timer 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, size = (0, 0))
    sizer = wx.GridBagSizer(hgap = 5, vgap = - 1)
    bw = BlockWindow(self, label = "Item 1")
    sizer.Add(bw, pos = (4, 2))
    self.block = BlockWindow(self, label = "")
    sizer.Add(self.block, pos = (5, 2))
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    mainSizer.Add(sizer, 0, wx.EXPAND | wx.ALL, 10)
    self.SetSizer(mainSizer)
    self.Fit()
    self.timer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.OnTimer, self.timer)
    self.timer.Start(3000)
DEDENT
----------------------------------------

def __init__(self, parent, ID = - 1, label = "",
pos = wx.DefaultPosition, size = (100, 25)) :
INDENT
    wx.Panel.__init__(self, parent, ID, pos, size,
        wx.RAISED_BORDER, label)
    self.label = label
    self.SetMinSize(size)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42541251_42555002_2_10
42541251_42558604_2_11
Title: "Create stock picking from inherited model action button - Odoo v9 community" 
----------------------------------------

def create_picking(self, vals) :
INDENT
    vals = {
        'x_location_src_id' : self.id,
        'x_location_dest_id' : self.id,
        'product_id' : self.id,
        'product_uom_qty' : self.id}
    res = super(stock_picking, self).create(vals)
    return res
DEDENT
----------------------------------------

def create_picking(self) :
INDENT
    self.ensure_one()
    vals = {
        'x_location_src_id' : self.x_location_src_id.id,
        'x_location_dest_id' : self.x_location_dest_id.id,
        'product_id' : self.product_id.id,
        'product_uom_qty' : self.product_uom_qty}
    picking = self.env ['stock.picking'].create(vals)
    return picking
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42553777_42625063_26_44
42553777_42625063_3_13
Title: wxpython close parent on click button 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Dialog.__init__(self, parent, wx.ID_ANY, "Save", size = (650, 220))
    self.panel = wx.Panel(self, wx.ID_ANY)
    self.lblname = wx.StaticText(self.panel, label = "Connection", pos = (20, 20))
    self.editname = wx.TextCtrl(self.panel, value = "server=127.0.0.1", pos = (110, 20), size = (500, - 1))
    self.lbl_1 = wx.StaticText(self.panel, wx.ID_ANY, ("Spin Control"), pos = (20, 60))
    self.spin = wx.SpinCtrl(self.panel, wx.ID_ANY, "", min = 1, max = 10, pos = (110, 60))
    self.lbl_2 = wx.StaticText(self.panel, wx.ID_ANY, ("Choice"), pos = (20, 100))
    self.choice = wx.Choice(self.panel, wx.ID_ANY, choices = [("Choice 1"), ("Choice 2"), ("Choice 3")], pos = (110, 100))
    self.saveButton = wx.Button(self.panel, label = "Save", pos = (110, 160))
    self.closeButton = wx.Button(self.panel, label = "Cancel", pos = (210, 160))
    self.saveButton.Bind(wx.EVT_BUTTON, self.SaveConnString)
    self.closeButton.Bind(wx.EVT_BUTTON, self.OnQuit)
    self.Bind(wx.EVT_CLOSE, self.OnQuit)
    self.spin.SetValue(0)
    self.choice.SetSelection(0)
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent, - 1, "Dialog Test", size = (500, 400))
    self.panel = wx.Panel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.log = wx.TextCtrl(self.panel, wx.ID_ANY, size = (400, 300), style = wx.TE_MULTILINE | wx.TE_READONLY | wx.VSCROLL)
    self.button = wx.Button(self.panel, label = "Click me")
    sizer.Add(self.log, 0, wx.EXPAND | wx.ALL, 10)
    sizer.Add(self.button, 0, wx.EXPAND | wx.ALL, 10)
    self.panel.SetSizer(sizer)
    self.Bind(wx.EVT_BUTTON, self.OnButton)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42560796_42560840_1_11
42560796_42560930_1_12
Title: Exception : 'unicode' object has no attribute 'readlines' 
----------------------------------------

def validateCSV(filename) :
INDENT
    with open(filename, 'rb') as file :
    INDENT
        print type(filename)
        if not file.readlines() :
        INDENT
            print 'empty file'
        DEDENT
        else :
        INDENT
            reader = csv.reader(file)
            for row in reader :
            INDENT
                print row
            DEDENT
        DEDENT
    DEDENT
    file.close()
DEDENT
----------------------------------------

def validateCSV(filename) :
INDENT
    with open(filename, 'rb') as f :
    INDENT
        reader = csv.reader(f)
        try :
        INDENT
            first_row = next(reader)
        DEDENT
        except StopIteration :
        INDENT
            print ('empty file')
            return
        DEDENT
        else :
        INDENT
            print (first_row)
            for row in reader :
            INDENT
                print row
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42594117_42597608_16_43
42594117_42597608_27_43
Title: (Python) Scrapy - How to scrape a JS dropdown list? 
----------------------------------------

def parse_shoes(self, response) :
INDENT
    data = {}
    data ['name'] = response.xpath('//*[@itemprop="name"]/text()').extract_first()
    data ['price'] = response.xpath('//*[@itemprop="price"]/text()').extract_first()

    sizes_url = "http://store.nike.com/html-services/templateData/pdpData?action=getPage&path=%2Fus%2Fen_us%2Fpd%2Fmagista-opus-ii-tech-craft-2-mens-firm-ground-soccer-cleat%2Fpid-11229710%2Fpgid-11918119&productId=11229710&productGroupId=11918119&catalogId=100701&cache=true&country=US&lang_locale=en_US"
    yield Request(url = sizes_url, callback = self.parse_sizes, meta = {'data' : data})

    def parse_shoes(self, response) :
    INDENT
        resp = json.loads(response.body)
        data = response.meta ['data']
        sizes = resp ['response'] ['pdpData'] ['skuContainer'] ['productSkus']
        sizesArray = []
        for a in sizes :
        INDENT
            sizesArray.extend([a ["displaySize"]])
        DEDENT
        yield {
            'name' : data ['name'],
            'price' : data ['price'],
            'sizes' : sizesArray}
    DEDENT
DEDENT
----------------------------------------

def parse_shoes(self, response) :
INDENT
    resp = json.loads(response.body)
    data = response.meta ['data']
    sizes = resp ['response'] ['pdpData'] ['skuContainer'] ['productSkus']
    sizesArray = []
    for a in sizes :
    INDENT
        sizesArray.extend([a ["displaySize"]])
    DEDENT
    yield {
        'name' : data ['name'],
        'price' : data ['price'],
        'sizes' : sizesArray}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42601812_42605165_10_26
42601812_42605165_33_48
Title: Python requests: URL base in Session 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    argname = 'url'
    argspec = inspect.getargspec(func)
    if argname in kwargs :
    INDENT
        kwargs [argname] = urljoin(base, kwargs [argname])
    DEDENT
    else :
    INDENT
        for i, name in enumerate(argspec [0]) :
        INDENT
            if name == argname :
            INDENT
                args = list(args)
                args [i - 1] = urljoin(base, args [i - 1])
                break
            DEDENT
        DEDENT
    DEDENT
    return func(* args, ** kwargs)
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    argname = 'base_url'
    if argname in kwargs :
    INDENT
        obj = args [0]

        for name, method in inspect.getmembers(obj, inspect.ismethod) :
        INDENT
            argspec = inspect.getargspec(method.__func__)
            if 'url' in argspec [0] :
            INDENT
                setattr(obj, name, _base_url(method, kwargs [argname]))
            DEDENT
        DEDENT
        del kwargs [argname]

    DEDENT
    return func(* args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42615151_42615194_1_12
42615151_42632145_6_29
Title: Return average value of node in binary tree python recursively 
----------------------------------------

def helper(root, total = 0, amount = 0) :
INDENT
    if root ! = None :
    INDENT
        total += root.data
        amount += 1
        _, left_total, left_amount = helper(root.left, total, amount)
        _, right_total, right_amount = helper(root.right, total, amount)
        total += left_total
        total += right_total
        amount += left_amount
        amount += right_amount
    DEDENT
    return (root, total, amount)
DEDENT
----------------------------------------

def helper(node, sum, count) :
INDENT
    if node is None :
    INDENT
        return (0, 0)

    DEDENT
    else :
    INDENT

        (Lsum, Lcount) = helper(node.left, 0, 0)

        (Rsum, Rcount) = helper(node.right, 0, 0)

        return (
            node.data + Lsum + Rsum,
            1 + Lcount + Rcount)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42616098_42616348_1_10
42616098_42647935_1_18
Title: Magic Mock fails when nosetest discovers tests 
----------------------------------------

def test_get_user_facebook_data_1(self) :
INDENT
    facebook_oauth_response = {u'name' : u'Jack Jacker', u'email' : u'jack@jack.jack', u'id' : u'sd5Jtvtk6'}
    with mock.patch('module.path.to.user_service.facepy') as mock_facepy :
    INDENT
        mock_facepy.GraphAPI.return_vaule.get = MagicMock(return_value = facebook_oauth_response)
        user_facebook_data = user_service.get_user_facebook_data('bogus_facebook_oauth_access_token')
        self.assertEquals(user_facebook_data._facebook_oauth_id, u'sd5Jtvtk6')
        self.assertEquals(user_facebook_data._email, u'jack@jack.jack')
        self.assertEquals(user_facebook_data._full_name, u'Jack Jacker')
    DEDENT
DEDENT
----------------------------------------

def test_get_user_facebook_data_1(self) :
INDENT
    facebook_oauth_response = {u'name' : u'Jack Jacker', u'email' : u'jack@jack.jack', u'id' : u'sd5Jtvtk6'}
    with mock.patch('api.services.user_service.facepy') as mock_facepy :
    INDENT
        def getitem(name) :
        INDENT
            return facebook_oauth_response [name]
        DEDENT
        mock_oauth = MagicMock()
        mock_oauth.return_value = facebook_oauth_response
        mock_oauth.__getitem__.side_effect = getitem
        mock_facepy.GraphAPI.return_value.get = mock_oauth
        user_facebook_data = user_service.get_user_facebook_data('bogus_facebook_oauth_access_token')
        self.assertEquals(user_facebook_data._facebook_oauth_id, u'sd5Jtvtk6')
        self.assertEquals(user_facebook_data._email, u'jack@jack.jack')
        self.assertEquals(user_facebook_data._full_name, u'Jack Jacker')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42629028_42629250_6_14
42629028_42630315_3_8
Title: Python decorators with instance level information 
----------------------------------------

def require_debug_mode(function) :
INDENT
    @ functools.wraps(function)
    def _require_debug_mode(self, * args, ** kwargs) :
    INDENT
        assert self.debug_mode, 'Debug mode is required for %r' % function
        return function(self, * args, ** kwargs)
    DEDENT
    return _require_debug_mode
DEDENT
----------------------------------------

def require_debug_mode(f) :
INDENT
    def func_wrapper(self, * args, ** kwargs) :
    INDENT
        if self.debug_mode :
        INDENT
            return f(self, * args)
        DEDENT
    DEDENT
    return func_wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42660887_42687673_41_60
42660887_42687673_63_74
Title: Add picture with ImageTk for Multiple Windows/Frames in Tkinter GUI with Python 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.grid(row = 0)
    arrow1 = tk.Label(self, image = self.controller.arrow)
    arrow2 = tk.Label(self, image = self.controller.arrow)
    arrow1.grid(row = 1, column = 0)
    arrow2.grid(row = 2, column = 0)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Go to Page Two",
        command = lambda : controller.show_frame("PageTwo"))
    button1.grid(row = 1, column = 1)
    button2.grid(row = 2, column = 1)

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 1", font = TITLE_FONT,
        image = self.controller.arrow)
    label.pack(side = "top", fill = "x", pady = 10)
    label.grid(row = 0)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.grid(row = 1, column = 1)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42660887_42687673_41_60
42660887_42687673_77_87
Title: Add picture with ImageTk for Multiple Windows/Frames in Tkinter GUI with Python 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.grid(row = 0)
    arrow1 = tk.Label(self, image = self.controller.arrow)
    arrow2 = tk.Label(self, image = self.controller.arrow)
    arrow1.grid(row = 1, column = 0)
    arrow2.grid(row = 2, column = 0)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Go to Page Two",
        command = lambda : controller.show_frame("PageTwo"))
    button1.grid(row = 1, column = 1)
    button2.grid(row = 2, column = 1)

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 2", font = TITLE_FONT,
        image = self.controller.arrow)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42660887_42687673_41_60
42660887_42687673_9_33
Title: Add picture with ImageTk for Multiple Windows/Frames in Tkinter GUI with Python 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.grid(row = 0)
    arrow1 = tk.Label(self, image = self.controller.arrow)
    arrow2 = tk.Label(self, image = self.controller.arrow)
    arrow1.grid(row = 1, column = 0)
    arrow2.grid(row = 2, column = 0)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Go to Page Two",
        command = lambda : controller.show_frame("PageTwo"))
    button1.grid(row = 1, column = 1)
    button2.grid(row = 2, column = 1)

DEDENT
----------------------------------------

def __init__(self, parent, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, parent, * args, ** kwargs)

    container = tk.Frame(parent)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.arrow = ImageTk.PhotoImage(img)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42660887_42687673_63_74
42660887_42687673_9_33
Title: Add picture with ImageTk for Multiple Windows/Frames in Tkinter GUI with Python 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 1", font = TITLE_FONT,
        image = self.controller.arrow)
    label.pack(side = "top", fill = "x", pady = 10)
    label.grid(row = 0)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.grid(row = 1, column = 1)

DEDENT
----------------------------------------

def __init__(self, parent, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, parent, * args, ** kwargs)

    container = tk.Frame(parent)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.arrow = ImageTk.PhotoImage(img)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42660887_42687673_77_87
42660887_42687673_9_33
Title: Add picture with ImageTk for Multiple Windows/Frames in Tkinter GUI with Python 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 2", font = TITLE_FONT,
        image = self.controller.arrow)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------

def __init__(self, parent, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, parent, * args, ** kwargs)

    container = tk.Frame(parent)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.arrow = ImageTk.PhotoImage(img)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42668115_42820227_44_52
42668115_42820227_8_15
Title: Format individual cell/item rather than entire row in tkinter ttk treeview 
----------------------------------------

def __init__(self, master = None, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.table = GridView(self)
    self.table.pack()
    btn = ttk.Button(self, text = "populate", command = self.populate)
    btn.pack()
    btn = ttk.Button(self, text = "clear", command = self.table.clear)
    btn.pack()
DEDENT
----------------------------------------

def __init__(self, master = None, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.labels = []
    style = ttk.Style()
    style.configure("red.TLabel", background = 'red')
    style.configure("green.TLabel", background = 'green')
    style.configure("header.TLabel", font = '-weight bold')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42671912_42734402_22_50
42671912_42734402_3_13
Title: wxpython-can we add ok button on pybusyinfo dialog? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Dialog.__init__(self, parent, wx.ID_ANY, "Busy", size = (420, 240))
    self.panel = wx.Panel(self, wx.ID_ANY)
    self.label = wx.StaticText(self.panel, label = "Input", pos = (20, 20))
    self.textinput = wx.TextCtrl(self.panel, value = "", pos = (80, 20), size = (300, - 1))
    self.gauge = wx.Gauge(self.panel, size = (300, 20), pos = (80, 80), style = wx.GA_HORIZONTAL)
    self.livelabel = wx.StaticText(self.panel, label = "Time to live:", pos = (80, 110))
    self.lltime = wx.StaticText(self.panel, label = "30", pos = (160, 110))
    self.saveButton = wx.Button(self.panel, label = "Save Input", pos = (80, 160))
    self.closeButton = wx.Button(self.panel, label = "Cancel", pos = (180, 160))
    self.timeoutButton = wx.Button(self.panel, label = "Timer Off", pos = (280, 160))
    self.saveButton.Bind(wx.EVT_BUTTON, self.SaveBusyString)
    self.closeButton.Bind(wx.EVT_BUTTON, self.OnQuit)
    self.timeoutButton.Bind(wx.EVT_BUTTON, self.OnNoTimeout)
    self.Bind(wx.EVT_CLOSE, self.OnQuit)
    self.timer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.OnTimer, self.timer)
    self.lifetimer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.OnLifeTimer, self.lifetimer)
    self.timer.Start(100)
    self.lifetimer.Start(1000)
    self.timeoutbutton_pressed = False
    self.gauge.SetBackgroundColour(wx.Colour(0, 127, 255, 255))
    self.gauge.SetRange(100)
    self.gauge.SetValue(0)
    self.life = 30
    self.direction = 1
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent, - 1, "Busy Dialog", size = (500, 200))
    self.panel = wx.Panel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.log = wx.TextCtrl(self.panel, wx.ID_ANY, size = (400, 100), style = wx.TE_MULTILINE | wx.TE_READONLY | wx.VSCROLL)
    self.button = wx.Button(self.panel, label = "Click me")
    sizer.Add(self.log, 0, wx.EXPAND | wx.ALL, 10)
    sizer.Add(self.button, 0, wx.EXPAND | wx.ALL, 10)
    self.panel.SetSizer(sizer)
    self.Bind(wx.EVT_BUTTON, self.OnButton)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42686491_42686575_3_12
42686491_42687602_4_14
Title: Can't assign to literal in Python turtle 
----------------------------------------

def triangle() :
INDENT
    triangle = (int(bodylength)) / 5 * 3 / 2 / cos(70)
    penup()
    forward(int(bodylength) / 5)
    pendown()
    left(70)
    forward(int(triangle))
    right(140)
    forward(int(triangle))
    forward(int(bodylength) / 5)
DEDENT
----------------------------------------

def triangle(turtle, bodylength) :
INDENT
    distance = bodylength / 5 * 3 / 2 / math.cos(math.radians(70))
    turtle.penup()
    turtle.forward(bodylength / 5)
    turtle.pendown()
    turtle.left(70)
    turtle.forward(distance)
    turtle.right(140)
    turtle.forward(distance)
    turtle.forward(bodylength / 5)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4269605_4269828_20_24
4269605_4269927_7_16
Title: Django. Override save for model 
----------------------------------------

def save(self, * args, ** kwargs) :
INDENT
    if getattr(self, '_image_changed', True) :
    INDENT
        small = rescale_image(self.image, width = 100, height = 100)
        self.image_small = SimpleUploadedFile(name, small_pic)
    DEDENT
    super(Model, self).save(* args, ** kwargs)
DEDENT
----------------------------------------

def save(self, * args, ** kwargs) :
INDENT
    if 'form' in kwargs :
    INDENT
        form = kwargs ['form']
    DEDENT
    else :
    INDENT
        form = None
    DEDENT
    if self.pk is None and form is not None and 'image' in form.changed_data :
    INDENT
        small = rescale_image(self.image, width = 100, height = 100)
        self.image_small = SimpleUploadedFile(name, small_pic)
    DEDENT
    super(Model, self).save(* args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
427152_427234_5_10
427152_427317_3_8
Title: How do I timestamp simultaneous function calls in Python? 
----------------------------------------

def timestampit(func) :
INDENT
    def decorate(* args, ** kwargs) :
    INDENT
        print datetime.datetime.now()
        return func(* args, ** kwargs)
    DEDENT
    return decorate
DEDENT
----------------------------------------

def timestampit(func) :
INDENT
    def decorate(* args, ** kwargs) :
    INDENT
        decorate.timestamp = time.time()
        return func(* args, ** kwargs)
    DEDENT
    return decorate
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4272439_4272477_3_18
4272439_4468012_3_12
Title: "Python - Search for files & ZIP across multiple directories" 
----------------------------------------

def scandirs(path) :
INDENT
    zip_file_path = os.path.join(path, os.path.pardir, "COD.zip")
    cod = zipfile.ZipFile(zip_file_path, "a")
    for currentFile in glob.glob(os.path.join(path, '*')) :
    INDENT
        if os.path.isdir(currentFile) :
        INDENT
            scandirs(currentFile)
        DEDENT
        if fnmatch.fnmatch(currentFile, '*.cod') :
        INDENT
            cod.write(currentFile, os.path.basename(currentFile))
        DEDENT
    DEDENT
    cod.close()
    if not cod.namelist() :
    INDENT
        os.remove(zip_file_path)
    DEDENT
DEDENT
----------------------------------------

def scandirs(path, pattern) :
INDENT
    result = []
    for file in glob.glob(os.path.join(path, pattern)) :
    INDENT
        if os.path.isdir(file) :
        INDENT
            result.extend(scandirs(file, pattern))
        DEDENT
        else :
        INDENT
            result.append(file)
        DEDENT
        return result

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42731608_42731643_8_13
42731608_42731649_1_12
Title: How to create a function that looks at individual letters in a string? 
----------------------------------------

def Complement(DNA) :
INDENT
    result = ""
    for char in DNA.upper() :
    INDENT
        result += di [char]
    DEDENT
    return (result)
DEDENT
----------------------------------------

def Complement(DNA) :
INDENT
    result = ""
    for i in DNA :
    INDENT
        if i == 'A' :
        INDENT
            result = result + 'T'
        DEDENT
        elif i == 'T' :
        INDENT
            result = result + 'A'
        DEDENT
        elif i == 'G' :
        INDENT
            result = result + 'C'
        DEDENT
        else :
        INDENT
            result = result + 'G'
        DEDENT
    DEDENT
    return (result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42731608_42731643_8_13
42731608_42731692_1_14
Title: How to create a function that looks at individual letters in a string? 
----------------------------------------

def Complement(DNA) :
INDENT
    result = ""
    for char in DNA.upper() :
    INDENT
        result += di [char]
    DEDENT
    return (result)
DEDENT
----------------------------------------

def Complement() :
INDENT
    print ("Enter your DNA string: ")
    DNA = str(input())
    result = ''
    for i in DNA :
    INDENT
        if i == 'A' :
        INDENT
            result = result + 'T'
        DEDENT
        elif i == 'T' :
        INDENT
            result = result + 'A'
        DEDENT
        elif i == 'G' :
        INDENT
            result = result + 'C'
        DEDENT
        else :
        INDENT
            result = result + 'G'
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42737252_42737399_1_10
42737252_42737575_1_11
Title: Matlab to Python translation of design matrix function 
----------------------------------------

def design_matrix(x_train, M) :
INDENT
    desm = np.zeros(shape = (len(x_train), M + 1))
    for i in range(0, M + 1) :
    INDENT
        desm [:, i] = x_train.squeeze() ** (i - 1)
    DEDENT
    return desm
DEDENT
----------------------------------------

def design_matrix(x_train, M) :
INDENT
    x_train = np.asarray(x_train)
    desm = np.zeros(shape = (len(x_train), M + 1))
    for i in range(0, M + 1) :
    INDENT
        desm [:, i] = np.power(x_train, i).reshape(x_train.shape [0],)
    DEDENT
    return desm
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42748025_42748050_1_22
42748025_49847935_3_16
Title: Can't convert 'NoneType' object to str implicitly 
----------------------------------------

def userChoice() :
INDENT
    choice = input("Rock (R), Paper (P), Scissors (S)? ")
    if choice.upper() == 'R' or choice.lower() == 'rock' :
    INDENT
        choice = 'Rock'
        return choice
    DEDENT
    elif choice.upper() == 'P' or choice.lower() == 'paper' :
    INDENT
        choice = 'Paper'
        return choice
    DEDENT
    elif choice.upper() == 'S' or choice.lower() == 'scissors' :
    INDENT
        choice = 'Scissors'
        return choice
    DEDENT
    else :
    INDENT
        print ("This was an invalid option, please try again.")
        return userChoice()

    DEDENT
DEDENT
----------------------------------------

def userChoice() :
INDENT
    choice = ""
    while len(choice) < 1 :
    INDENT
        choice = input("Rock (R), Paper (P), or Scissors (S)?\n")
    DEDENT
    if match(r"(?i)^p(aper)?\Z", choice) is not None :
    INDENT
        return "Paper"
    DEDENT
    elif match(r"(?i)^r(ock)?\Z", choice) is not None :
    INDENT
        return "Rock"
    DEDENT
    elif match(r"(?i)^s(cissors)?\Z", choice) is not None :
    INDENT
        return "Scissors"
    DEDENT
    else :
    INDENT
        print (choice + " is not a valid option, please try again.")
        return userChoice()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42774496_42774795_10_19
42774496_42775312_10_17
Title: Python 2 to python 3 
----------------------------------------

def recv(self) :
INDENT
    data = self.sock.recv(2)
    l0 = ord(data [0])
    l1 = ord(data [1])
    plen = l0 + (l1 < < 8)
    data = self.sock.recv(plen)
    if self.debug :
    INDENT
        print ('Recv:'),
        print (':'.join('%02x' % ord(c) for c in data))
    DEDENT
    return data
DEDENT
----------------------------------------

def recv(self) :
INDENT
    l0, l1 = self.sock.recv(2)
    plen = l0 + (l1 < < 8)
    data = self.sock.recv(plen)
    if self.debug :
    INDENT
        print('Recv:', end = '')
        print (':'.join('%02x' % c for c in data))
    DEDENT
    return data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42775969_42776041_1_15
42775969_42776090_1_14
Title: While loop iterating one too many times 
----------------------------------------

def main() :
INDENT
    input_1 = 1
    input_2 = 1
    input_3 = 1
    input_4 = 1
    while input_1 ! = 0 :
    INDENT
        input_1 = int(input('Please enter a value or type 0 to end: '))
        if input_1 ! = 0 :
        INDENT
            input_2 = int(input('Please enter a second value: '))
            input_3 = int(input('Please enter a third value: '))
            input_4 = int(input('Please enter a fourth value: '))
            print('The total amount is: ', end = '')
            print(all_inputs(input_1, input_1, input_1, input_1), end = '')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    keep_going = '';
    while keep_going ! = 'n' :
    INDENT
        input_1 = int(input('Please enter a value: '))
        input_2 = int(input('Please enter a second value: '))
        input_3 = int(input('Please enter a third value: '))
        input_4 = int(input('Please enter a fourth value: '))
        print('The total amount is: ', end = '')
        print(all_inputs(input_1, input_2, input_3, input_4), end = "\n")
        keep_going = input('Keep going? y/n: ')

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42829401_42829715_13_18
42829401_42829715_37_43
Title: Python solving an indentation error 
----------------------------------------

def deposit(self, deposit_amount) :
INDENT
    if deposit_amount < 0 :
    INDENT
        raise RuntimeError('Invalid deposit amount.')
    DEDENT
    self.balance += deposit_amount
    return self.balance
DEDENT
----------------------------------------

def deposit(self, deposit_amount) :
INDENT
    if deposit_amount < 0 :
    INDENT
        raise RuntimeError('Invalid deposit amount.')
    DEDENT
    self.balance += deposit_amount
    return self.balance
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42829401_42829715_19_32
42829401_42829715_44_52
Title: Python solving an indentation error 
----------------------------------------

def withdraw(self, withdraw_amount) :
INDENT
    if self.balance < 500 :
    INDENT
        raise RuntimeError('Cannot withdraw beyond the minimum account balance')
    DEDENT
    if withdraw_amount > self.balance :
    INDENT
        raise RuntimeError('Cannot withdraw beyond the current account balance')
    DEDENT
    if withdraw_amount < 0 :
    INDENT
        raise RuntimeError('Invalid withdraw amount.')
    DEDENT
    self.balance -= withdraw_amount
    return self.balance

DEDENT
----------------------------------------

def withdraw(self, withdraw_amount) :
INDENT
    if withdraw_amount < 0 :
    INDENT
        raise RuntimeError('Invalid withdraw amount')
    DEDENT
    if withdraw_amount > self.balance :
    INDENT
        raise RuntimeError('Cannot withdraw beyond the current account balance')
    DEDENT
    self.balance -= withdraw_amount
    return self.balance
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42852722_42855667_37_57
42852722_42860573_41_138
Title: Iterate through a json feed in python 
----------------------------------------

def scan(item, depth = 0, key = '') :
INDENT
    global msg
    tabs = lambda n : ' ' * n
    if isinstance(item, dict) :
    INDENT
        for key, value in sorted(item.items()) :
        INDENT
            msg.append(tabs(depth) + 'key:   %s' % key)
            scan(value, depth + 2, key)
        DEDENT
    DEDENT
    elif isinstance(item, list) :
    INDENT
        for listitem in item :
        INDENT
            scan(listitem, depth + 2)
        DEDENT
    DEDENT
    else :
    INDENT
        msg.append(tabs(depth) + 'item:   %s\n' % item)
    DEDENT
    return msg

DEDENT
----------------------------------------

def scan(item, depth = 0, key = '') :
INDENT
    global msg
    EPOCH = datetime.datetime(1970, 1, 1, tzinfo = pytz.utc)
    tabs = lambda n : ' ' * n
    if isinstance(item, dict) :
    INDENT
        for key, value in sorted(item.items()) :
        INDENT
            if key.endswith('ArrivalTime') :
            INDENT
                msg.append(tabs(depth) + 'Arrival:   %s  Time: %s' % (key, parse(value)))
                arrival_time = (parse(value) - EPOCH).total_seconds()

            DEDENT
            elif key.endswith('DepartureTime') :
            INDENT
                msg.append(tabs(depth) + 'Departure:   %s  Time: %s' % (key, parse(value)))
                departure_time = (parse(value) - EPOCH).total_seconds()

            DEDENT
            elif key == 'recordedAtTime' :
            INDENT
                msg.append(tabs(depth) + 'recordedAtTime:   %s' % parse(value))
            DEDENT
            elif key.startswith('datedVehicle') :
            INDENT
                msg.append(tabs(depth) + 'Operator:   %s' % value ['value'])
            DEDENT
            elif key == 'originName' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'originName:   %s' % value [0] ['value'])
                DEDENT
            DEDENT
            elif key == 'originRef' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'originRef:   %s' % value ['value'])
                DEDENT
            DEDENT
            elif key == 'directionName' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'directionName:   %s' % value [0] ['value'])
                DEDENT
            DEDENT
            elif key == 'publishedLineName' :
            INDENT
                msg.append(tabs(depth) + 'publishedLineName:   %s' % value [0] ['value'])
            DEDENT
            elif key == 'destinationName' :
            INDENT
                msg.append(tabs(depth) + 'destinationName:   %s' % value [0] ['value'])
            DEDENT
            elif key == 'destinationRef' :
            INDENT
                msg.append(tabs(depth) + 'destinationRef:   %s' % value ['value'])
            DEDENT
            elif key == 'operatorRef' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'operatorRef:   %s' % value ['value'])
                DEDENT
            DEDENT
            elif key == 'vehicleMode' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'vehicleMode:   %s' % value [0])
                DEDENT
            DEDENT
            elif key == 'lineRef' :
            INDENT
                msg.append(tabs(depth) + 'lineRef:   %s' % value ['value'])
            DEDENT
            elif key == 'vehicleJourneyName' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'vehicleJourneyName:   %s' % value [0] ['value'])
                DEDENT
            DEDENT
            elif key == 'firstOrLastJourney' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'firstOrLastJourney:   %s' % value)
                DEDENT
            DEDENT
            elif key == 'stopPointRef' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'stopPointRef:   %s' % value ['value'])
                DEDENT
            DEDENT
            elif key == 'producerRef' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'producerRef:   %s' % value)
                DEDENT
            DEDENT
            elif key.endswith('Timestamp') :
            INDENT
                msg.append(tabs(depth) + '%s:   %s' % (key, parse(value)))
            DEDENT
            elif key == 'status' :
            INDENT
                if len(value) > 0 :
                INDENT
                    msg.append(tabs(depth) + 'status:   %c' % value [0])
                DEDENT
            DEDENT
            elif key == 'value' :
            INDENT
                msg.append(tabs(depth) + 'Value:   %s' % value)
            DEDENT
            else :
            INDENT
                msg.append(tabs(depth) + 'key:   %s' % key)
                scan(value, depth + 2, key)
            DEDENT
        DEDENT
    DEDENT
    elif isinstance(item, list) :
    INDENT
        for listitem in item :
        INDENT
            scan(listitem, depth + 2)
        DEDENT
    DEDENT
    else :
    INDENT
        msg.append(tabs(depth) + 'item:   %s\n' % item)
    DEDENT
    return msg

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42886850_42886877_1_16
42886850_42886909_1_13
Title: NameError: name 'linec' is not defined 
----------------------------------------

def problem3_1(txtfilename) :
INDENT
    linec = 0
    wordct = 0
    charct = 0
    text_file = open(txtfilename)
    for line in text_file :
    INDENT
        linec = linec + 1
        charct = charct + len(line)
        for word in line.split() :
        INDENT
            wordct = wordct + 1
        DEDENT
    DEDENT
    text_file.close()
    return linec, wordct, charct
DEDENT
----------------------------------------

def problem3_1(txtfilename) :
INDENT
    linec = 0
    wordct = 0
    charct = 0
    with open(txtfilename) as text_file :
    INDENT
        for line in text_file :
        INDENT
            linec = linec + 1
            wordct += len(line.split())
            charct += len(line)
        DEDENT
    DEDENT
    return linec, wordct, charct
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42886850_42886909_1_13
42886850_42886990_1_16
Title: NameError: name 'linec' is not defined 
----------------------------------------

def problem3_1(txtfilename) :
INDENT
    linec = 0
    wordct = 0
    charct = 0
    with open(txtfilename) as text_file :
    INDENT
        for line in text_file :
        INDENT
            linec = linec + 1
            wordct += len(line.split())
            charct += len(line)
        DEDENT
    DEDENT
    return linec, wordct, charct
DEDENT
----------------------------------------

def problem3_1(txtfilename) :
INDENT
    linec = 0
    wordct = 0
    charct = 0
    text_file = open(txtfilename)
    for line in text_file :
    INDENT
        linec = linec + 1
    DEDENT
    for word in line.split() :
    INDENT
        wordct = wordct + 1
    DEDENT
    charct = charct + len(line)
    text_file.close()
    print (linec, wordct, charct)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42891203_42907258_15_22
42891203_42907258_26_33
Title: How to find cumulative frequency without group by in pyspark dataframe 
----------------------------------------

def _mapper(partial_sum_stream) :
INDENT
    per_partition_cumulative_sum = dict(partial_sum_stream)
    cumulative_sum = 0
    offset = {}
    for partition_index in range(num_partitions) :
    INDENT
        offset [partition_index] = cumulative_sum
        cumulative_sum += per_partition_cumulative_sum.get(partition_index, 0)
    DEDENT
    return offset
DEDENT
----------------------------------------

def _mapper(partition_index, event_stream) :
INDENT
    local_cumulative_sum = defaultdict(float)
    for event in event_stream :
    INDENT
        local_cumulative_sum ["Count"] += event ["Count"]
        count_cumulative_sum = local_cumulative_sum ["Count"] + global_offset.value ["Count"] [partition_index]
        local_cumulative_sum ["Percent"] += event ["Percent"]
        percentage_cumulative_sum = local_cumulative_sum ["Percent"] + global_offset.value ["Percent"] [partition_index]
        yield Row(CCount = count_cumulative_sum, CPercent = percentage_cumulative_sum, ** event.asDict())
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42908982_42909214_3_16
42908982_42909385_5_15
Title: How to return an argument if a certain condition is met in a loop? 
----------------------------------------

def lottery(lucky_numbers, run) :
INDENT
    i = 0
    min_x = 1
    while i < run :
    INDENT
        x = random.uniform(0, 1)
        numbers = lucky_numbers
        NewNumbers = numbers [- 1 :] + numbers [: - 1]
        lucky_numbers = NewNumbers
        if x < min_x :
        INDENT
            min_x = x
            min_lucky_numbers = lucky_numbers
        DEDENT
        i += 1
    DEDENT
    print (min_lucky_numbers, min_x)
DEDENT
----------------------------------------

def lottery(lucky_numbers, run) :
INDENT
    i = 0
    while i < run :
    INDENT
        x = random.uniform(0, 1)
        numbers = lucky_numbers
        NewNumbers = numbers [- 1 :] + numbers [: - 1]
        print (NewNumbers, x)
        i += 1
        luckiest_num.append(x)
        luckiest_list.append(NewNumbers)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42910622_42911869_1_12
42910622_42912753_13_21
Title: Animation of histograms in subplot 
----------------------------------------

def updateData(curr) :
INDENT
    curr2 = 100 + curr * 5

    ax1.hist(x1 [: curr2], normed = True, bins = 20, alpha = 0.5)
    ax2.hist(x2 [: curr2], normed = True, bins = 20, alpha = 0.5)
    ax3.hist(x3 [: curr2], normed = True, bins = 20, alpha = 0.5)
    ax4.hist(x4 [: curr2], normed = True, bins = 20, alpha = 0.5)
DEDENT
----------------------------------------

def updateData(curr) :
INDENT
    if curr < = 2 : return
    for ax in (ax1, ax2, ax3, ax4) :
    INDENT
        ax.clear()
    DEDENT
    ax1.hist(x1 [: curr], normed = True, bins = np.linspace(- 6, 1, num = 21), alpha = 0.5)
    ax2.hist(x2 [: curr], normed = True, bins = np.linspace(0, 15, num = 21), alpha = 0.5)
    ax3.hist(x3 [: curr], normed = True, bins = np.linspace(7, 20, num = 21), alpha = 0.5)
    ax4.hist(x4 [: curr], normed = True, bins = np.linspace(14, 20, num = 21), alpha = 0.5)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42914927_42915126_12_30
42914927_42915410_1_12
Title: Python - Compare 2 words and check if they are anagram 
----------------------------------------

def check_anagram(str1, str2) :
INDENT
    dic1 = process_str(str1)
    dic2 = process_str(str2)

    for key in dic1 :
    INDENT
        if not key in dic2 :
        INDENT
            return False
        DEDENT
        if not dic1 [key] == dic2 [key] :
        INDENT
            return False

        DEDENT
    DEDENT
    for key in dic2 :
    INDENT
        if not key in dic1 :
        INDENT
            return False
        DEDENT
        if not dic1 [key] == dic2 [key] :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def check_anagram(str1, str2) :
INDENT
    if len(str1) ! = len(str2) :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        string1 = [x for x in str1]
        string2 = [x for x in str2]
        for i in range(0, len(str2), 1) :
        INDENT
            if string1 [i] in string2 :
            INDENT
                string2.remove(string1 [i])
            DEDENT
            else :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42933950_42934273_15_21
42933950_42934384_5_15
Title: Compare Strings Loop Python 
----------------------------------------

def findmd5(pass2check) :
INDENT
    for index, line in enumerate(createmd5list(passwordlist)) :
    INDENT
        if pass2check in line :
        INDENT
            return index
        DEDENT
    DEDENT
    return - 1

DEDENT
----------------------------------------

def findmd5(pass2check) :
INDENT
    result = [password for password in passwordlist
        if hashlib.md5(password).hexdigest() == pass2check
        ]
    if len(result) :
    INDENT
        print ("The answer is")
        for password in result :
        INDENT
            print (password)
        DEDENT
    DEDENT
    else :
    INDENT
        print ("Password not found")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42935107_42935235_1_14
42935107_42935298_1_15
Title: Insert Character at Descending Index Positions within Nested List 
----------------------------------------

def answer(start, length) :
INDENT
    id_arr = list(range(start, start + length ** 2))

    matrix = [id_arr [i : i + length] for i in range(0, len(id_arr), length)]

    for i, row in enumerate(matrix) :
    INDENT
        row.insert(len(matrix) - i, '/')
        print row
    DEDENT
    print len(matrix)
    answer(17, 4)
DEDENT
----------------------------------------

def answer(start, length) :
INDENT
    id_arr = list(range(start, start + length ** 2))

    matrix = [id_arr [i : i + length] for i in range(0, len(id_arr), length)]

    l = len(matrix)
    for row in matrix :
    INDENT
        row.insert(l, '/')
        l -= 1
        print row
    DEDENT
    print len(matrix)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42942171_42943012_2_10
42942171_42947077_2_10
Title: IndexError: tuple index out of range - Odoo v8 to Odoo v10 community 
----------------------------------------

def update_url(self) :
INDENT
    url_obj = self._get_url()
    url_obj.write(
        {'name' : self.url1 or False,
            'url_seniat' : self.url2 and False,
            'url_seniat2' : self.url3 and False})
    return {}
DEDENT
----------------------------------------

def update_url(self) :
INDENT
    for url in self :
    INDENT
        url_obj = url._get_url()
        url_obj.write({
                'name' : url.url1,
                'url_seniat' : url.url2,
                'url_seniat2' : url.url3})
    DEDENT
    return {}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42950991_42952475_1_15
42950991_43151103_1_12
Title: Tensorflow: Using neural network to classify positive or negative phrases 
----------------------------------------

def get_features_for_input(input) :
INDENT
    current_words = word_tokenize(input.lower())
    current_words = [lemmatizer.lemmatize(i) for i in current_words]
    features = np.zeros(len(lexicon))
    for word in current_words :
    INDENT
        if word.lower() in lexicon :
        INDENT
            index_value = lexicon.index(word.lower())
            features [index_value] += 1
        DEDENT
    DEDENT
    features = np.array(list(features))
    batch_features = []
    batch_features [0] = features
    return np.array(batch_features)
DEDENT
----------------------------------------

def get_features_for_input(input) :
INDENT
    current_words = word_tokenize(input.lower())
    current_words = [lemmatizer.lemmatize(i) for i in current_words]
    features = np.zeros((1, len(lexicon)))
    for word in current_words :
    INDENT
        if word.lower() in lexicon :
        INDENT
            index_value = lexicon.index(word.lower())
            features [0, index_value] += 1
        DEDENT
    DEDENT
    return features
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42950991_43151103_1_12
42950991_43185094_1_11
Title: Tensorflow: Using neural network to classify positive or negative phrases 
----------------------------------------

def get_features_for_input(input) :
INDENT
    current_words = word_tokenize(input.lower())
    current_words = [lemmatizer.lemmatize(i) for i in current_words]
    features = np.zeros((1, len(lexicon)))
    for word in current_words :
    INDENT
        if word.lower() in lexicon :
        INDENT
            index_value = lexicon.index(word.lower())
            features [0, index_value] += 1
        DEDENT
    DEDENT
    return features
DEDENT
----------------------------------------

def get_features_for_input(text, lexicon) :
INDENT
    featureset = []
    current_words = word_tokenize(text.lower())
    current_words = [lemmatizer.lemmatize(i) for i in current_words]
    features = np.zeros(len(lexicon))
    for word in current_words :
    INDENT
        if word.lower() in lexicon :
        INDENT
            index_value = lexicon.index(word.lower())
            features [index_value] += 1
        DEDENT
    DEDENT
    featureset.append(features)
    return np.asarray(featureset)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42950998_42951254_7_22
42950998_42951373_12_25
Title: Keep track of multiple elapsed times in python 
----------------------------------------

def check_elapsed_time() :
INDENT
    while True :
    INDENT
        now = time.strftime('%Y-%m-%d %H:%M:%S')
        current_time = datetime.strptime(now, '%Y-%m-%d %H:%M:%S')
        for key in dict :
        INDENT
            component_max_time = datetime.strptime(dict [key], '%Y-%m-%d %H:%M:%S')
            elapsed_time = component_max_time - current_time
            print (key + " " + str(elapsed_time))
            if component_max_time == current_time :
            INDENT
                print ("ALARM!!!")
            DEDENT
        DEDENT
        time.sleep(1)

    DEDENT
DEDENT
----------------------------------------

def check_elapsed_time(min_time) :
INDENT
    while True :
    INDENT
        now = time.strftime('%Y-%m-%d %H:%M:%S')
        current_time = datetime.strptime(now, '%Y-%m-%d %H:%M:%S')
        component_max_time = datetime.strptime(min_time, '%Y-%m-%d %H:%M:%S')
        elapsed_time = component_max_time - current_time
        time.sleep(1)
        print (elapsed_time)
        if (elapsed_time.total_seconds() == 0.0) :
        INDENT
            print "Reached"
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42960995_42961546_2_14
42960995_42963006_2_23
Title: Breaking my code down into a loop 
----------------------------------------

def main() :
INDENT
    board = []
    for i in range(0, 5) :
    INDENT
        board.append(random.randint(1, 50))
        guess = int(input("enter number between 1-50 : "))
        print (board)
        if guess == board [0] :
        INDENT
            print ("hit")
            board [0] = "hit"
        DEDENT
        elif guess ! = board [0] :
        INDENT
            print ("miss")
            board [0] = "miss"
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    board = []
    for i in range(0, 5) :
    INDENT
        board.append(random.randint(1, 50))
    DEDENT
    print (board)
    guesses = []
    try_nr = 0
    while try_nr < 5 :
    INDENT
        try_nr += 1
        guess = int(input("enter number between 1-50"))
        guesses.append(guess)
    DEDENT
    for i in enumerate(guesses) :
    INDENT
        i = i [0]
        if guesses [i] in board :
        INDENT
            print ("hit")
        DEDENT
        else :
        INDENT
            print ("miss")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42962887_42988175_78_85
42962887_42988175_93_104
Title: flask admin edit child objects on click 
----------------------------------------

def __call__(self, form, form_opts = None, field_args = {}) :
INDENT
    _id = getattr(form._obj, self.attribute, None)
    if _id :
    INDENT
        return Markup('<a href="{url}"><![CDATA[{text}</a>'.format(url = url_for(self.endpoint, id = _id), text = self.text))

    DEDENT
DEDENT
----------------------------------------

def __call__(self, form, form_opts = None, field_args = {}) :
INDENT
    _hrefs = []
    _objects = getattr(form._obj, self.relation)
    for _obj in _objects :
    INDENT
        _id = getattr(_obj, self.attribute, None)
        _link = '<a href="{url}"><![CDATA[Edit {text}</a>'.format(url = url_for(self.endpoint, id = _id), text = str(_obj))
        _hrefs.append(_link)
    DEDENT
    return Markup('<br>'.join(_hrefs))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42966655_42966978_11_16
42966655_42967512_18_25
Title: Can I create a list inside of an object 
----------------------------------------

def addStudent() :
INDENT
    studentNum = int(input("How many students do you want to add?: "))
    for n in range(studentNum) :
    INDENT
        newName = input("Student Name: ")
        newGrade = int(input("Student Grade: "))
    DEDENT
DEDENT
----------------------------------------

def addStudent() :
INDENT
    studentNum = int(input("How many students do you want to add?: "))
    for n in range(studentNum) :
    INDENT
        newName = input("Student Name: ")
        newGrade = int(input("Student Grade: "))
        newAvg = random.randrange(50, 100)
        myClass.append(Student(newName, newGrade, newAvg))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42966655_42966978_17_24
42966655_42967512_26_38
Title: Can I create a list inside of an object 
----------------------------------------

def setMark() :
INDENT
    markWho = input("Who are you adding a mark(s) for?: ")
    newMark = int(input("Enter mark: "))
    for i in myClass :
    INDENT
        if (i.name == markWho) :
        INDENT

            i.markDict.append(newMark)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def setMark() :
INDENT
    markWho = input("Who are you adding a mark(s) for?: ")
    iterMark = int(input("How many marks of student you want to add?:"))
    marks = []
    for i in myClass :
    INDENT
        if (i.name == markWho) :
        INDENT
            for item in range(iterMark) :
            INDENT
                newMark = int(input("Enter mark: "))
                marks.append(newMark)
            DEDENT
            i.addMark(marks)
            i.getAvg()
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42974439_42975583_3_13
42974439_42976215_1_26
Title: "In Python how to make a wrapper work for both class and static methods" 
----------------------------------------

def maybe(function) :
INDENT
    if type(function) == types.FunctionType :
    INDENT
        def wrapped_function(* arg, ** kwargs) :
        INDENT
            return function(* arg, ** kwargs) if arg is not None else None
        DEDENT
        return wrapped_function
    DEDENT
    elif type(function) == types.MethodType :
    INDENT
        def wrapped_function(cls, * arg, ** kwargs) :
        INDENT
            return function(cls, * arg, ** kwargs) if arg is not None else None
        DEDENT
        return wrapped_function
    DEDENT
    else :
    INDENT
        raise TypeError("The 'maybe' wrapper can wrap either a function or a method.")
    DEDENT
DEDENT
----------------------------------------

def maybe(wrapped) :
INDENT
    if isinstance(wrapped, classmethod) :
    INDENT
        original_function = wrapped.__func__
        @ classmethod
        def wrapper(cls, arg) :
        INDENT
            if arg is None :
            INDENT
                return None
            DEDENT
            else :
            INDENT
                return original_function(cls, arg)
            DEDENT
        DEDENT
        return wrapper
    DEDENT
    elif isinstance(wrapped, staticmethod) :
    INDENT
        original_function = wrapped.__func__
        @ staticmethod
        def wrapper(arg) :
        INDENT
            if arg is None :
            INDENT
                return None
            DEDENT
            else :
            INDENT
                return original_function(arg)
            DEDENT
        DEDENT
        return wrapper
    DEDENT
    raise TypeError("expected classmethod or staticmethod")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42981930_43002831_10_31
42981930_43196403_15_23
Title: How to solve a system of ODEs with scipy.integrate.odeint with a time-dependent variable 
----------------------------------------

def f(y, t, paras) :
INDENT
    Si = y [0]
    Zi = y [1]
    Ri = y [2]
    try :
    INDENT
        P = paras ['P'].value
        d = paras ['d'].value
        B = paras ['B'].value
        G = paras ['G'].value
        A = paras ['A'].value
    DEDENT
    except :
    INDENT
        P, d, B, G, A = paras
    DEDENT
    f0 = P - B * Si * Zi - d * Si
    f1 = B * Si * Zi + G * Ri - A * Si * Zi
    f2 = d * Si + A * Si * Zi - G * Ri
    return [f0, f1, f2]

DEDENT
----------------------------------------

def f(y, t) :
INDENT
    Zi = y [0]
    Ri = y [1]
    f0 = B * Si * Zi + G * Ri - A * Si * Zi
    f1 = d * Si + A * Si * Zi - G * Ri
    return [f0, f1]

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42987439_42987806_12_23
42987439_42987813_3_20
Title: "Reading data from file adding and finding percentage of data using python" 
----------------------------------------

def main() :
INDENT
    nums = get_nums('numdata.txt')
    if nums :
    INDENT
        total = sum(nums)
        avg = total / len(nums)
        print ('The total: ', total)
        print ('The average: ', avg)
    DEDENT
    else :
    INDENT
        print ('No numbers found in the textfile')
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    nums = []
    with open('numdata.txt', 'r') as data :
    INDENT
        for d in data.readlines() :
        INDENT
            try :
            INDENT
                nums.append(int(d.strip('\n')))
            DEDENT
            except IOError :
            INDENT
                print ("got IOError")
                sys.exit()
            DEDENT
            except ValueError :
            INDENT
                print ("got ValueError")
                sys.exit()
            DEDENT
        DEDENT
    DEDENT
    total = sum(nums)
    average = total / len(nums)
    print ('the total: ', total)
    print ('the average: ', average)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42987650_42987922_1_21
42987650_42988208_1_13
Title: process socket data that ends with a line break 
----------------------------------------

def receive_bar_updates(s) :
INDENT
    global all_bars
    data = ''
    buf = ''
    buffer_size = 4096
    while True :
    INDENT
        if not "\r\n" in data :
        INDENT
            data += s.recv(buffer_size)
        DEDENT
        if not "\r\n" in data :
        INDENT
            continue
        DEDENT
        i = data.rfind("\r\n")
        data, buf = data [: i + 2], data [i + 2 :]
        lines = data.split("\r\n")
        lines = filter(None, lines)
        for line in lines :
        INDENT
            if line.startswith("BH") or line.startswith("BC") :
            INDENT
                symbol = str(line.split(",") [1])
                all_bars [symbol].append(line)
                y = Thread(target = proccess_bars, kwargs = {'symbol' : symbol})
                y.start()
            DEDENT
        DEDENT
        data = buf
    DEDENT
DEDENT
----------------------------------------

def receive_bar_updates(s) :
INDENT
    global all_bars
    data = ''
    buffer_size = 4096
    fd = SocketIO(s)
    for line in fd :
    INDENT
        if should_be_rejected_by_filter(line) : continue
        if line.startswith("BH") or line.startswith("BC") :
        INDENT
            symbol = str(line.split(",") [1])
            all_bars [symbol].append(line)
            y = Thread(target = proccess_bars, kwargs = {'symbol' : symbol})
            y.start()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42987650_42987950_1_19
42987650_42988208_1_13
Title: process socket data that ends with a line break 
----------------------------------------

def receive_bar_updates(s) :
INDENT
    global all_bars
    data = ''
    buffer_size = 4096
    while True :
    INDENT
        data += s.recv(buffer_size)
        if not data :
        INDENT
            break
        DEDENT
        if not data.endswith("\n") :
        INDENT
            continue
        DEDENT
        lines = data.split("\n")
        lines = filter(None, lines)
        for line in lines :
        INDENT
            if line.startswith("BH") or line.startswith("BC") :
            INDENT
                symbol = str(line.split(",") [1])
                all_bars [symbol].append(line)
                y = Thread(target = proccess_bars, kwargs = {'symbol' : symbol})
                y.start()
            DEDENT
        DEDENT
        data = ""
    DEDENT
DEDENT
----------------------------------------

def receive_bar_updates(s) :
INDENT
    global all_bars
    data = ''
    buffer_size = 4096
    fd = SocketIO(s)
    for line in fd :
    INDENT
        if should_be_rejected_by_filter(line) : continue
        if line.startswith("BH") or line.startswith("BC") :
        INDENT
            symbol = str(line.split(",") [1])
            all_bars [symbol].append(line)
            y = Thread(target = proccess_bars, kwargs = {'symbol' : symbol})
            y.start()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42988713_42988773_37_46
42988713_42988773_77_85
Title: Go Fish in Python 
----------------------------------------

def makeTurn(self) :
INDENT
    print '%s\'s hand: %s' % (self.name, self.displayHand())
    chooseCard = raw_input('What card do you ask for? ').strip()
    if chooseCard == 'quit' :
    INDENT
        sys.exit(0)
    DEDENT
    if chooseCard not in self.hand :
    INDENT
        print 'You don\'t have that card. Try again! (or enter quit to exit)'
        chooseCard = self.makeTurn()
    DEDENT
    return chooseCard
DEDENT
----------------------------------------

def makeTurn(self) :
INDENT
    candidates = list(self.opponentHas & set(self.hand.keys()))
    if not candidates :
    INDENT
        candidates = self.hand.keys()
    DEDENT
    move = random.choice(candidates)
    print '%s fishes for %s.' % (self.name, move)
    return move
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43002898_43003063_3_17
43002898_43003247_3_13
Title: How to print all possible combinations of a list that have the same sum as the original list? 
----------------------------------------

def fun(lst, total) :
INDENT
    sum = 0
    for element in lst :
    INDENT
        sum += element
        x = []
        all_possible_combinations = set(itertools.product(lst, repeat = 2))
        for items in all_possible_combinations :
        INDENT
            a = 0
            for i in items :
            INDENT
                a += i
            DEDENT
            if a == total :
            INDENT
                x.append(items)
            DEDENT
        DEDENT
    DEDENT
    print (x)
    print ('These are all combinations:', all_possible_combinations)
DEDENT
----------------------------------------

def fun(lst, total) :
INDENT
    all_possible_combinations = set(itertools.product(lst, repeat = 2))
    for items in all_possible_combinations :
    INDENT
        a = 0
        for i in items :
        INDENT
            a += i
        DEDENT
        if a == total :
        INDENT
            x = items
            print (x)
        DEDENT
    DEDENT
    print ('These are all combinations:', all_possible_combinations)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43004510_43004624_4_20
43004510_43004801_3_14
Title: How to lock part of method in Python 
----------------------------------------

def test(name) :
INDENT
    global lock
    print (name + " - Starting thread")
    print (name + " - Waiting to acquire lock")
    lock.acquire(True)
    try :
    INDENT
        print (name + " - Lock acquired!")
        for i in range(10) :
        INDENT
            print (name + " - " + str(i))
            print ("")
            time.sleep(1)
        DEDENT
    DEDENT
    finally :
    INDENT
        lock.release()
        print (name + " - Lock released")
    DEDENT
DEDENT
----------------------------------------

def test(name, lock) :
INDENT
    print (name + " - Starting thread")
    print (name + " - Waiting to acquire lock")
    with lock :
    INDENT
        print (name + " - Lock acquired!")
        for i in range(10) :
        INDENT
            print (name + " - " + str(i))
            print ("")
            time.sleep(1)
        DEDENT
    DEDENT
    print (name + " - Lock released")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43010397_43010496_5_21
43010397_43010789_3_12
Title: Why this loop stops before it finishes? 
----------------------------------------

def rolling_dices(repetitions) :
INDENT
    a = repetitions
    b = 1
    while b < = a :
    INDENT
        i = (random.randrange(1, 7))
        y = (random.randrange(1, 7))
        b += 1
        print (i, y, "\t =>", int(i + y))
        answer = input("do you want to play again? (Y/N)")
        if answer.lower() == "y" :
        INDENT
            continue
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def rolling_dices(repetitions) :
INDENT
    a = repetitions
    b = 1
    while b < = a :
    INDENT
        i = (random.randrange(1, 7))
        y = (random.randrange(1, 7))
        b += 1
        print (i, y, "\t =>", int(i + y))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43017981_13_23
43017251_43365874_1_15
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    j = first_bad_pair(sequence, - 1)
    if j == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j) == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j + 1) == - 1 :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def almostIncreasingSequence(list) :
INDENT
    removedIdx = []
    for idx, item in enumerate(list) :
    INDENT
        tmp = []
        for i in range(idx - 1, - 1, - 1) :
        INDENT
            if list [idx] < = list [i] :
            INDENT
                tmp.append(i)
            DEDENT
        DEDENT
        if len(tmp) > 1 :
        INDENT
            removedIdx.append(idx)
        DEDENT
        else :
        INDENT
            if len(tmp) > 0 :
            INDENT
                removedIdx.append(tmp [0])
            DEDENT
        DEDENT
    DEDENT
    return len(set(removedIdx)) < = 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43017981_13_23
43017251_43554706_1_30
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    j = first_bad_pair(sequence, - 1)
    if j == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j) == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j + 1) == - 1 :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) < = 2 :
    INDENT
        return True

    DEDENT
    def IncreasingSequence(test_sequence) :
    INDENT
        if len(test_sequence) == 2 :
        INDENT
            if test_sequence [0] < test_sequence [1] :
            INDENT
                return True
            DEDENT
        DEDENT
        else :
        INDENT
            for i in range(0, len(test_sequence) - 1) :
            INDENT
                if test_sequence [i] > = test_sequence [i + 1] :
                INDENT
                    return False
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return True
        DEDENT
    DEDENT
    for i in range(0, len(sequence) - 1) :
    INDENT
        if sequence [i] > = sequence [i + 1] :
        INDENT

            test_seq1 = sequence [: i] + sequence [i + 1 :]
            test_seq2 = sequence [: i + 1] + sequence [i + 2 :]
            if IncreasingSequence(test_seq1) == True :
            INDENT
                return True
            DEDENT
            elif IncreasingSequence(test_seq2) == True :
            INDENT
                return True
            DEDENT
            else :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43017981_13_23
43017251_45536094_1_13
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    j = first_bad_pair(sequence, - 1)
    if j == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j) == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j + 1) == - 1 :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    for i, x in enumerate(sequence) :
    INDENT
        ret = False
        s = sequence [: i] + sequence [i + 1 :]
        for j, y in enumerate(s [1 :]) :
        INDENT
            if s [j + 1] < = s [j] :
            INDENT
                ret = True
                break
            DEDENT
            if ret :
            INDENT
                break
            DEDENT
        DEDENT
        if not ret :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43017981_13_23
43017251_51758345_1_18
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    j = first_bad_pair(sequence, - 1)
    if j == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j) == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j + 1) == - 1 :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    removed_one = False
    prev_maxval = None
    maxval = None
    for s in sequence :
    INDENT
        if not maxval or s > maxval :
        INDENT
            prev_maxval = maxval
            maxval = s
        DEDENT
        elif not prev_maxval or s > prev_maxval :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
            maxval = s
        DEDENT
        else :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43017981_13_23
43017251_51978863_1_12
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    j = first_bad_pair(sequence, - 1)
    if j == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j) == - 1 :
    INDENT
        return True
    DEDENT
    if first_bad_pair(sequence, j + 1) == - 1 :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) == 2 :
    INDENT
        return sequence == sorted(list(sequence))
    DEDENT
    else :
    INDENT
        for i in range(0, len(sequence)) :
        INDENT
            newsequence = sequence [: i] + sequence [i + 1 :]
            if (newsequence == sorted(list(newsequence))) and len(newsequence) == len(set(newsequence)) :
            INDENT
                return True
                break
            DEDENT
            else :
            INDENT
                result = False
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43365874_1_15
43017251_43554706_1_30
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(list) :
INDENT
    removedIdx = []
    for idx, item in enumerate(list) :
    INDENT
        tmp = []
        for i in range(idx - 1, - 1, - 1) :
        INDENT
            if list [idx] < = list [i] :
            INDENT
                tmp.append(i)
            DEDENT
        DEDENT
        if len(tmp) > 1 :
        INDENT
            removedIdx.append(idx)
        DEDENT
        else :
        INDENT
            if len(tmp) > 0 :
            INDENT
                removedIdx.append(tmp [0])
            DEDENT
        DEDENT
    DEDENT
    return len(set(removedIdx)) < = 1
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) < = 2 :
    INDENT
        return True

    DEDENT
    def IncreasingSequence(test_sequence) :
    INDENT
        if len(test_sequence) == 2 :
        INDENT
            if test_sequence [0] < test_sequence [1] :
            INDENT
                return True
            DEDENT
        DEDENT
        else :
        INDENT
            for i in range(0, len(test_sequence) - 1) :
            INDENT
                if test_sequence [i] > = test_sequence [i + 1] :
                INDENT
                    return False
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return True
        DEDENT
    DEDENT
    for i in range(0, len(sequence) - 1) :
    INDENT
        if sequence [i] > = sequence [i + 1] :
        INDENT

            test_seq1 = sequence [: i] + sequence [i + 1 :]
            test_seq2 = sequence [: i + 1] + sequence [i + 2 :]
            if IncreasingSequence(test_seq1) == True :
            INDENT
                return True
            DEDENT
            elif IncreasingSequence(test_seq2) == True :
            INDENT
                return True
            DEDENT
            else :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43365874_1_15
43017251_45536094_1_13
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(list) :
INDENT
    removedIdx = []
    for idx, item in enumerate(list) :
    INDENT
        tmp = []
        for i in range(idx - 1, - 1, - 1) :
        INDENT
            if list [idx] < = list [i] :
            INDENT
                tmp.append(i)
            DEDENT
        DEDENT
        if len(tmp) > 1 :
        INDENT
            removedIdx.append(idx)
        DEDENT
        else :
        INDENT
            if len(tmp) > 0 :
            INDENT
                removedIdx.append(tmp [0])
            DEDENT
        DEDENT
    DEDENT
    return len(set(removedIdx)) < = 1
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    for i, x in enumerate(sequence) :
    INDENT
        ret = False
        s = sequence [: i] + sequence [i + 1 :]
        for j, y in enumerate(s [1 :]) :
        INDENT
            if s [j + 1] < = s [j] :
            INDENT
                ret = True
                break
            DEDENT
            if ret :
            INDENT
                break
            DEDENT
        DEDENT
        if not ret :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43365874_1_15
43017251_51758345_1_18
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(list) :
INDENT
    removedIdx = []
    for idx, item in enumerate(list) :
    INDENT
        tmp = []
        for i in range(idx - 1, - 1, - 1) :
        INDENT
            if list [idx] < = list [i] :
            INDENT
                tmp.append(i)
            DEDENT
        DEDENT
        if len(tmp) > 1 :
        INDENT
            removedIdx.append(idx)
        DEDENT
        else :
        INDENT
            if len(tmp) > 0 :
            INDENT
                removedIdx.append(tmp [0])
            DEDENT
        DEDENT
    DEDENT
    return len(set(removedIdx)) < = 1
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    removed_one = False
    prev_maxval = None
    maxval = None
    for s in sequence :
    INDENT
        if not maxval or s > maxval :
        INDENT
            prev_maxval = maxval
            maxval = s
        DEDENT
        elif not prev_maxval or s > prev_maxval :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
            maxval = s
        DEDENT
        else :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43365874_1_15
43017251_51978863_1_12
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(list) :
INDENT
    removedIdx = []
    for idx, item in enumerate(list) :
    INDENT
        tmp = []
        for i in range(idx - 1, - 1, - 1) :
        INDENT
            if list [idx] < = list [i] :
            INDENT
                tmp.append(i)
            DEDENT
        DEDENT
        if len(tmp) > 1 :
        INDENT
            removedIdx.append(idx)
        DEDENT
        else :
        INDENT
            if len(tmp) > 0 :
            INDENT
                removedIdx.append(tmp [0])
            DEDENT
        DEDENT
    DEDENT
    return len(set(removedIdx)) < = 1
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) == 2 :
    INDENT
        return sequence == sorted(list(sequence))
    DEDENT
    else :
    INDENT
        for i in range(0, len(sequence)) :
        INDENT
            newsequence = sequence [: i] + sequence [i + 1 :]
            if (newsequence == sorted(list(newsequence))) and len(newsequence) == len(set(newsequence)) :
            INDENT
                return True
                break
            DEDENT
            else :
            INDENT
                result = False
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43554706_1_30
43017251_45536094_1_13
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) < = 2 :
    INDENT
        return True

    DEDENT
    def IncreasingSequence(test_sequence) :
    INDENT
        if len(test_sequence) == 2 :
        INDENT
            if test_sequence [0] < test_sequence [1] :
            INDENT
                return True
            DEDENT
        DEDENT
        else :
        INDENT
            for i in range(0, len(test_sequence) - 1) :
            INDENT
                if test_sequence [i] > = test_sequence [i + 1] :
                INDENT
                    return False
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return True
        DEDENT
    DEDENT
    for i in range(0, len(sequence) - 1) :
    INDENT
        if sequence [i] > = sequence [i + 1] :
        INDENT

            test_seq1 = sequence [: i] + sequence [i + 1 :]
            test_seq2 = sequence [: i + 1] + sequence [i + 2 :]
            if IncreasingSequence(test_seq1) == True :
            INDENT
                return True
            DEDENT
            elif IncreasingSequence(test_seq2) == True :
            INDENT
                return True
            DEDENT
            else :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    for i, x in enumerate(sequence) :
    INDENT
        ret = False
        s = sequence [: i] + sequence [i + 1 :]
        for j, y in enumerate(s [1 :]) :
        INDENT
            if s [j + 1] < = s [j] :
            INDENT
                ret = True
                break
            DEDENT
            if ret :
            INDENT
                break
            DEDENT
        DEDENT
        if not ret :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43554706_1_30
43017251_51758345_1_18
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) < = 2 :
    INDENT
        return True

    DEDENT
    def IncreasingSequence(test_sequence) :
    INDENT
        if len(test_sequence) == 2 :
        INDENT
            if test_sequence [0] < test_sequence [1] :
            INDENT
                return True
            DEDENT
        DEDENT
        else :
        INDENT
            for i in range(0, len(test_sequence) - 1) :
            INDENT
                if test_sequence [i] > = test_sequence [i + 1] :
                INDENT
                    return False
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return True
        DEDENT
    DEDENT
    for i in range(0, len(sequence) - 1) :
    INDENT
        if sequence [i] > = sequence [i + 1] :
        INDENT

            test_seq1 = sequence [: i] + sequence [i + 1 :]
            test_seq2 = sequence [: i + 1] + sequence [i + 2 :]
            if IncreasingSequence(test_seq1) == True :
            INDENT
                return True
            DEDENT
            elif IncreasingSequence(test_seq2) == True :
            INDENT
                return True
            DEDENT
            else :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    removed_one = False
    prev_maxval = None
    maxval = None
    for s in sequence :
    INDENT
        if not maxval or s > maxval :
        INDENT
            prev_maxval = maxval
            maxval = s
        DEDENT
        elif not prev_maxval or s > prev_maxval :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
            maxval = s
        DEDENT
        else :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_43554706_1_30
43017251_51978863_1_12
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) < = 2 :
    INDENT
        return True

    DEDENT
    def IncreasingSequence(test_sequence) :
    INDENT
        if len(test_sequence) == 2 :
        INDENT
            if test_sequence [0] < test_sequence [1] :
            INDENT
                return True
            DEDENT
        DEDENT
        else :
        INDENT
            for i in range(0, len(test_sequence) - 1) :
            INDENT
                if test_sequence [i] > = test_sequence [i + 1] :
                INDENT
                    return False
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return True
        DEDENT
    DEDENT
    for i in range(0, len(sequence) - 1) :
    INDENT
        if sequence [i] > = sequence [i + 1] :
        INDENT

            test_seq1 = sequence [: i] + sequence [i + 1 :]
            test_seq2 = sequence [: i + 1] + sequence [i + 2 :]
            if IncreasingSequence(test_seq1) == True :
            INDENT
                return True
            DEDENT
            elif IncreasingSequence(test_seq2) == True :
            INDENT
                return True
            DEDENT
            else :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) == 2 :
    INDENT
        return sequence == sorted(list(sequence))
    DEDENT
    else :
    INDENT
        for i in range(0, len(sequence)) :
        INDENT
            newsequence = sequence [: i] + sequence [i + 1 :]
            if (newsequence == sorted(list(newsequence))) and len(newsequence) == len(set(newsequence)) :
            INDENT
                return True
                break
            DEDENT
            else :
            INDENT
                result = False
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_45536094_1_13
43017251_51758345_1_18
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    for i, x in enumerate(sequence) :
    INDENT
        ret = False
        s = sequence [: i] + sequence [i + 1 :]
        for j, y in enumerate(s [1 :]) :
        INDENT
            if s [j + 1] < = s [j] :
            INDENT
                ret = True
                break
            DEDENT
            if ret :
            INDENT
                break
            DEDENT
        DEDENT
        if not ret :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    removed_one = False
    prev_maxval = None
    maxval = None
    for s in sequence :
    INDENT
        if not maxval or s > maxval :
        INDENT
            prev_maxval = maxval
            maxval = s
        DEDENT
        elif not prev_maxval or s > prev_maxval :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
            maxval = s
        DEDENT
        else :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_45536094_1_13
43017251_51978863_1_12
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    for i, x in enumerate(sequence) :
    INDENT
        ret = False
        s = sequence [: i] + sequence [i + 1 :]
        for j, y in enumerate(s [1 :]) :
        INDENT
            if s [j + 1] < = s [j] :
            INDENT
                ret = True
                break
            DEDENT
            if ret :
            INDENT
                break
            DEDENT
        DEDENT
        if not ret :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) == 2 :
    INDENT
        return sequence == sorted(list(sequence))
    DEDENT
    else :
    INDENT
        for i in range(0, len(sequence)) :
        INDENT
            newsequence = sequence [: i] + sequence [i + 1 :]
            if (newsequence == sorted(list(newsequence))) and len(newsequence) == len(set(newsequence)) :
            INDENT
                return True
                break
            DEDENT
            else :
            INDENT
                result = False
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43017251_51758345_1_18
43017251_51978863_1_12
Title: Solve almostIncreasingSequence (Codefights) 
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    removed_one = False
    prev_maxval = None
    maxval = None
    for s in sequence :
    INDENT
        if not maxval or s > maxval :
        INDENT
            prev_maxval = maxval
            maxval = s
        DEDENT
        elif not prev_maxval or s > prev_maxval :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
            maxval = s
        DEDENT
        else :
        INDENT
            if removed_one :
            INDENT
                return False
            DEDENT
            removed_one = True
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def almostIncreasingSequence(sequence) :
INDENT
    if len(sequence) == 2 :
    INDENT
        return sequence == sorted(list(sequence))
    DEDENT
    else :
    INDENT
        for i in range(0, len(sequence)) :
        INDENT
            newsequence = sequence [: i] + sequence [i + 1 :]
            if (newsequence == sorted(list(newsequence))) and len(newsequence) == len(set(newsequence)) :
            INDENT
                return True
                break
            DEDENT
            else :
            INDENT
                result = False
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43020082_43020152_1_16
43020082_43020190_1_25
Title: A Python program to convert date to numbers 
----------------------------------------

def get_month_english(month) :
INDENT
    months = {
        1 : "January",
        2 : "February",
        3 : "March",
        4 : "April",
        5 : "May",
        6 : "June",
        7 : "July",
        8 : "August",
        9 : "September",
        10 : "October",
        11 : "November",
        12 : "December"}
    return months [month]
DEDENT
----------------------------------------

def get_month_english(month) :
INDENT
    if (month == 1) :
    INDENT
        return "January"
    DEDENT
    elif (month == 2) :
    INDENT
        return "February"
    DEDENT
    elif (month == 3) :
    INDENT
        return "March"
    DEDENT
    elif (month == 4) :
    INDENT
        return "April"
    DEDENT
    elif (month == 5) :
    INDENT
        return "May"
    DEDENT
    elif (month == 6) :
    INDENT
        return "June"
    DEDENT
    elif (month == 7) :
    INDENT
        return "July"
    DEDENT
    elif (month == 8) :
    INDENT
        return "August"
    DEDENT
    elif (month == 9) :
    INDENT
        return "September"
    DEDENT
    elif (month == 10) :
    INDENT
        return "October"
    DEDENT
    elif (month == 11) :
    INDENT
        return "November"
    DEDENT
    else :
    INDENT
        return "December"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43020833_43042104_102_110
43020833_43042104_50_64
Title: Python minesweeper game gtk3 get button value after click 
----------------------------------------

def __init__(self, rows, cols) :
INDENT
    self.window = Gtk.Window()
    self.rows = rows
    self.cols = cols
    self.vbox = Gtk.VBox()
    self.window.add(self.vbox)
    self.create_grid(rows, cols)
    self.window.connect('destroy', Gtk.main_quit)
DEDENT
----------------------------------------

def __init__(self, rows, cols, ratio) :
INDENT
    self.rows = rows
    self.cols = cols
    self.cells = []
    self.ratio = ratio
    Gtk.Grid.__init__(self)
    for row in range(rows) :
    INDENT
        for col in range(cols) :
        INDENT
            cell = Cell()
            self.cells.append(cell)
            self.attach(cell.get_button(), row, col, 1, 1)
        DEDENT
    DEDENT
    self.place_mines()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43031315_43031421_3_12
43031315_43031856_3_12
Title: How to tackle this random number Python homework? 
----------------------------------------

def function(n) :
INDENT
    a = - 2
    b = - 1
    i = 0
    while a ! = b :
    INDENT
        a, b = random.randint(0, n), a
        i += 1
    DEDENT
    return i

DEDENT
----------------------------------------

def function(n) :
INDENT
    a = None
    i = 0
    while True :
    INDENT
        a, b = random.randint(0, n), a
        i += 1
        if a == b :
        INDENT
            return i

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43055903_43056038_3_15
43055903_43056061_1_11
Title: Why is my function returning `None`? 
----------------------------------------

def adding() :
INDENT
    num = input("How many numbers would you like to add? ")
    for x in range(int(num)) :
    INDENT

        sumlist.append(int(input('Number: ')))
        a = 0
        for x in sumlist :
        INDENT
            a = a + x
        DEDENT
    DEDENT
    return a
DEDENT
----------------------------------------

def adding() :
INDENT
    num = int(raw_input("How many numbers would you like to add? "))
    lst = []
    for _ in range(num) :
    INDENT
        lst.append(int(raw_input('Number: ')))
    DEDENT
    a = 0
    for x in lst :
    INDENT
        a += x
    DEDENT
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43060100_43060208_8_35
43060100_43060237_3_16
Title: Assigning 5 different variables from 1 single function 
----------------------------------------

def scoring() :
INDENT
    global scores
    score = random.randint(1, 100)
    if score < 4 :
    INDENT

        scores = ['97', '98', '99', '100']
        scores1 = random.choice(scores)

    DEDENT
    if 3 < score < 7 :
    INDENT

        scores = ['93', '94', '95', '96']
        scores1 = random.choice(scores)

    DEDENT
    if 6 < score < 45 :
    INDENT

        scores = ['83', '86', '87', '89']
        scores1 = random.choice(scores)

    DEDENT
    if 44 < score < 101 :
    INDENT

        scores = ['70', '72', '76', '79']
        scores1 = random.choice(scores)
    DEDENT
    return scores1
DEDENT
----------------------------------------

def scoring(score) :
INDENT
    if 0 < = score < 4 :
    INDENT
        scores = ['97', '98', '99', '100']
        return random.choice(scores)
    DEDENT
    elif 4 < = score < 7 :
    INDENT
        scores = ['93', '94', '95', '96']
        return random.choice(scores)
    DEDENT
    elif 7 < = score < 45 :
    INDENT
        scores = ['83', '86', '87', '89']
        return random.choice(scores)
    DEDENT
    elif 45 < = score < = 100 :
    INDENT
        scores = ['70', '72', '76', '79']
        return random.choice(scores)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43060100_43060237_3_16
43060100_43060302_1_16
Title: Assigning 5 different variables from 1 single function 
----------------------------------------

def scoring(score) :
INDENT
    if 0 < = score < 4 :
    INDENT
        scores = ['97', '98', '99', '100']
        return random.choice(scores)
    DEDENT
    elif 4 < = score < 7 :
    INDENT
        scores = ['93', '94', '95', '96']
        return random.choice(scores)
    DEDENT
    elif 7 < = score < 45 :
    INDENT
        scores = ['83', '86', '87', '89']
        return random.choice(scores)
    DEDENT
    elif 45 < = score < = 100 :
    INDENT
        scores = ['70', '72', '76', '79']
        return random.choice(scores)
    DEDENT
DEDENT
----------------------------------------

def scoring() :
INDENT
    score = random.randint(1, 100)
    if score < 4 :
    INDENT
        scores = ['97', '98', '99', '100']
        score = random.choice(scores)
    DEDENT
    if 3 < score < 7 :
    INDENT
        scores = ['93', '94', '95', '96']
        score = random.choice(scores)
    DEDENT
    if 6 < score < 45 :
    INDENT
        scores = ['83', '86', '87', '89']
        score = random.choice(scores)
    DEDENT
    if 44 < score < 101 :
    INDENT
        scores = ['70', '72', '76', '79']
        score = random.choice(scores)
    DEDENT
    return score
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43075613_43075993_1_27
43075613_43076421_2_21
Title: Refresh stats in a simple time-counting program 
----------------------------------------

def calculate() :
INDENT
    global event
    event = datetime(2017, 3, 28, 16, 0, 0)
    global tday
    tday = datetime.now()
    global str8
    str8 = tday - event
    global seconds
    seconds = str8.total_seconds()
    global minutes
    minutes = str8.total_seconds() / 60
    global hours
    hours = minutes / 60
    global days
    days = hours / 24
    global weeks
    weeks = days / 7
    global years
    years = weeks / 52
DEDENT
----------------------------------------

def calculate() :
INDENT
    event = datetime(2017, 3, 28, 16, 0, 0)
    tday = datetime.now()
    str8 = tday - event
    seconds = str8.total_seconds()
    minutes = str8.total_seconds() / 60
    hours = minutes / 60
    days = hours / 24
    weeks = days / 7
    years = weeks / 52
    return event, tday, str8, seconds, minutes, hours, days, weeks, years
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43075613_43075993_1_27
43075613_43076659_10_24
Title: Refresh stats in a simple time-counting program 
----------------------------------------

def calculate() :
INDENT
    global event
    event = datetime(2017, 3, 28, 16, 0, 0)
    global tday
    tday = datetime.now()
    global str8
    str8 = tday - event
    global seconds
    seconds = str8.total_seconds()
    global minutes
    minutes = str8.total_seconds() / 60
    global hours
    hours = minutes / 60
    global days
    days = hours / 24
    global weeks
    weeks = days / 7
    global years
    years = weeks / 52
DEDENT
----------------------------------------

def calculate() :
INDENT
    event = datetime(2017, 3, 28, 16, 0, 0)
    tday = datetime.now()
    str8 = tday - event
    seconds = str8.total_seconds()
    minutes = str8.total_seconds() / 60
    hours = minutes / 60
    days = hours / 24
    weeks = days / 7
    years = weeks / 52
    return event, tday, str8, seconds, minutes, hours, days, weeks, years
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43084983_43085112_5_9
43084983_43085403_3_10
Title: Retrieve data from json using Python 
----------------------------------------

def geturl(comp) :
INDENT
    for k, v in data.items() :
    INDENT
        if comp in v and 'url' in v [comp] :
        INDENT
            print "%s" % "\n".join(v [comp] ['url'])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def geturl(comp) :
INDENT
    for mainKey in data :
    INDENT
        main = data [mainKey]
        if comp in main :
        INDENT
            urls = main [comp] ['url']
            for url in urls :
            INDENT
                print url
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43088503_43088945_21_33
43088503_43088945_5_13
Title: Mocking open function with mock_open 
----------------------------------------

def parse_sectors_from_csv(rows) :
INDENT
    return [
        {
            'model' : 'sector.sector',
            'id' : index,
            'fields' : {
                'name' : row.get('Sector'),
                'slug' : slugify(row ['Sector']),
                'type_id' : row.get('Type_Id')}} for index, row in enumerate(rows, 1)
        ]
DEDENT
----------------------------------------

def parse_sectors_from_csv() :
INDENT
    file_path = sectors_file_path()
    with open(file_path) as fh :
    INDENT
        return do_parse_sectors_from_csv(fh)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43110600_43112875_2_24
43110600_43116064_2_14
Title: Adding Model field from django views 
----------------------------------------

def my_view(request, id) :
INDENT
    qs = Health.objects.filter(id = id)
    l = len(qs)
    if l > 0 :
    INDENT
        for x in qs :
        INDENT
            df = read_frame(x)
            df ['x-Mean'] = abs(df ['Age'] - df ['Age'].mean())
            df ['1.96*std'] = 1.96 * df ['Age'].std()
            df ['Outlier'] = abs(df ['Age'] - df ['Age'].mean()) > 1.96 * df ['Age'].std()
            df ['BMI'] = df ['Weight'] / (df ['Height'] / 100) ** 2

            x.BMI = df ['BMI']
            x.save()
            a = df.fillna(0)
            a = a.to_dict(orient = 'records')

        DEDENT
    DEDENT
    else :
    INDENT
        print "no rows exists for the query "
    DEDENT
DEDENT
----------------------------------------

def my_view(request, id) :
INDENT
    qs = Health.objects.filter(id = id)
    df = read_frame(qs)
    df ['x-Mean'] = abs(df ['age'] - df ['age'].mean())
    df ['1.96*std'] = 1.96 * df ['age'].std()
    df ['outlier'] = abs(df ['age'] - df ['age'].mean()) > 1.96 * df ['age'].std()
    df ['bmi'] = df ['weight'] / (df ['height'] / 100) ** 2
    for q in qs :
    INDENT
        q.bmi = df ['bmi'] [0]
        q.save()
    DEDENT
    a = df.fillna(0)
    a = a.to_dict(orient = 'records')
    return Response(a)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43125134_43125571_5_16
43125134_43125606_3_13
Title: How to Change Global Variable With Function? 
----------------------------------------

def stepchange() :
INDENT
    global step
    b = step
    while step == b :
    INDENT
        a = Decimal(input())
        if a == 1 :
        INDENT
            step = b + Decimal('.1')
        DEDENT
        if a == 2 :
        INDENT
            step = b + Decimal('.2')
        DEDENT
        if a == 3 :
        INDENT
            step = b + Decimal('.3')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def stepchange() :
INDENT
    global step
    b = step
    a = input()
    if a == "1" :
    INDENT
        step = b + ".1"
    DEDENT
    if a == "2" :
    INDENT
        step = b + ".2"
    DEDENT
    if a == "3" :
    INDENT
        step = b + ".3"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43147456_43147895_1_12
43147456_43148020_1_18
Title: python string splitting with multiple splitting points 
----------------------------------------

def digestfragmentwithenzyme(seqs, enzymes) :
INDENT
    replacements = []
    for enzyme in enzymes :
    INDENT
        replacements.append((enzyme [0], enzyme [0] [0 : enzyme [1]] + '|' + enzyme [0] [enzyme [1] :]))
    DEDENT
    result = []
    for seq in seqs :
    INDENT
        for r in replacements :
        INDENT
            seq = seq.replace(r [0], r [1])
        DEDENT
        result.append(seq.split('|'))
    DEDENT
    return result
DEDENT
----------------------------------------

def digestfragmentwithenzyme(seqs, enzymes) :
INDENT
    out = []
    dic = dict(enzymes)
    for seq in seqs :
    INDENT
        sub = []
        pos1 = 0
        enzstr = '|'.join(enz [0] for enz in enzymes)
        for match in re.finditer('(' + enzstr + ')', seq) :
        INDENT
            index = dic [match.group(0)]
            pos2 = match.start() + index
            sub.append(seq [pos1 : pos2])
            pos1 = pos2
        DEDENT
        sub.append(seq [pos1 :])
        out.append(sub)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43148317_43148651_165_188
43148317_43148651_71_82
Title: How do I call secondary window using a pushbutton 
----------------------------------------

def retranslateUi(self, MainWindow) :
INDENT
    _translate = QtCore.QCoreApplication.translate
    MainWindow.setWindowTitle(_translate("MainWindow", "FEA - Bar 2D"))
    MainWindow.setStatusTip(_translate("MainWindow", "Ready"))
    self.setupPush.setStatusTip(_translate("MainWindow", "Setup"))
    self.setupPush.setText(_translate("MainWindow", "Setup"))
    self.nodePropPush.setStatusTip(_translate("MainWindow", "Input node properties"))
    self.nodePropPush.setText(_translate("MainWindow", "Node Properties"))
    self.elPropLabel.setStatusTip(_translate("MainWindow", "Input element properties"))
    self.elPropLabel.setText(_translate("MainWindow", "Element Properties"))
    self.bcPush.setStatusTip(_translate("MainWindow", "Input boundary conditions"))
    self.bcPush.setText(_translate("MainWindow", "Boundary Conditons"))
    self.solvePush.setStatusTip(_translate("MainWindow", "Solve"))
    self.solvePush.setText(_translate("MainWindow", "Solve"))
    self.resultPush.setStatusTip(_translate("MainWindow", "List solution results"))
    self.resultPush.setText(_translate("MainWindow", "List Results"))
    self.menuFEA.setTitle(_translate("MainWindow", "FEA"))
    self.actionExit.setText(_translate("MainWindow", "Exit"))
    self.actionExit.setStatusTip(_translate("MainWindow", "Exit"))
    self.actionExit.setShortcut(_translate("MainWindow", "Ctrl+Q"))

DEDENT
----------------------------------------

def retranslateUi(self, MainWindow) :
INDENT
    _translate = QtCore.QCoreApplication.translate
    MainWindow.setWindowTitle(_translate("MainWindow", "Main Window"))
    self.nnodeLabel.setText(_translate("MainWindow", "Number of Nodes"))
    self.nelLabel.setText(_translate("MainWindow", "Number of Elements"))
    self.ndofLabel.setText(_translate("MainWindow", "Number of DOF per node"))
    self.mainOkPush.setStatusTip(_translate("MainWindow", "Save and continue"))
    self.mainOkPush.setText(_translate("MainWindow", "OK"))
    self.mainCancelPush.setStatusTip(_translate("MainWindow", "Cancel"))
    self.mainCancelPush.setText(_translate("MainWindow", "Cancel"))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43148317_43148651_4_70
43148317_43148651_84_164
Title: How do I call secondary window using a pushbutton 
----------------------------------------

def setupUi(self, MainWindow) :
INDENT
    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(300, 190)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
    MainWindow.setSizePolicy(sizePolicy)
    MainWindow.setMinimumSize(QtCore.QSize(300, 190))
    MainWindow.setMaximumSize(QtCore.QSize(300, 190))
    self.centralwidget = QtWidgets.QWidget(MainWindow)
    self.centralwidget.setObjectName("centralwidget")
    self.formLayoutWidget = QtWidgets.QWidget(self.centralwidget)
    self.formLayoutWidget.setGeometry(QtCore.QRect(20, 10, 261, 101))
    self.formLayoutWidget.setObjectName("formLayoutWidget")
    self.formLayout = QtWidgets.QFormLayout(self.formLayoutWidget)
    self.formLayout.setContentsMargins(5, 10, 5, 5)
    self.formLayout.setSpacing(10)
    self.formLayout.setObjectName("formLayout")
    self.nnodeLabel = QtWidgets.QLabel(self.formLayoutWidget)
    self.nnodeLabel.setObjectName("nnodeLabel")
    self.formLayout.setWidget(0, QtWidgets.QFormLayout.LabelRole, self.nnodeLabel)
    self.nelLabel = QtWidgets.QLabel(self.formLayoutWidget)
    self.nelLabel.setObjectName("nelLabel")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.LabelRole, self.nelLabel)
    self.ndofLabel = QtWidgets.QLabel(self.formLayoutWidget)
    self.ndofLabel.setObjectName("ndofLabel")
    self.formLayout.setWidget(2, QtWidgets.QFormLayout.LabelRole, self.ndofLabel)
    self.ndof = QtWidgets.QLineEdit(self.formLayoutWidget)
    self.ndof.setObjectName("ndof")
    self.formLayout.setWidget(2, QtWidgets.QFormLayout.FieldRole, self.ndof)
    self.nel = QtWidgets.QLineEdit(self.formLayoutWidget)
    self.nel.setObjectName("nel")
    self.formLayout.setWidget(1, QtWidgets.QFormLayout.FieldRole, self.nel)
    self.nnode = QtWidgets.QLineEdit(self.formLayoutWidget)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Expanding, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(self.nnode.sizePolicy().hasHeightForWidth())
    self.nnode.setSizePolicy(sizePolicy)
    self.nnode.setObjectName("nnode")
    self.formLayout.setWidget(0, QtWidgets.QFormLayout.FieldRole, self.nnode)
    self.ndof.raise_()
    self.nnodeLabel.raise_()
    self.nelLabel.raise_()
    self.nel.raise_()
    self.nnode.raise_()
    self.ndofLabel.raise_()
    self.mainOkPush = QtWidgets.QPushButton(self.centralwidget)
    self.mainOkPush.setGeometry(QtCore.QRect(20, 120, 75, 23))
    self.mainOkPush.setToolTip("")
    self.mainOkPush.setObjectName("mainOkPush")
    self.mainCancelPush = QtWidgets.QPushButton(self.centralwidget)
    self.mainCancelPush.setGeometry(QtCore.QRect(210, 120, 75, 23))
    self.mainCancelPush.setObjectName("mainCancelPush")
    MainWindow.setCentralWidget(self.centralwidget)
    self.menubar = QtWidgets.QMenuBar(MainWindow)
    self.menubar.setGeometry(QtCore.QRect(0, 0, 300, 21))
    self.menubar.setObjectName("menubar")
    MainWindow.setMenuBar(self.menubar)
    self.statusbar = QtWidgets.QStatusBar(MainWindow)
    self.statusbar.setObjectName("statusbar")
    MainWindow.setStatusBar(self.statusbar)
    self.retranslateUi(MainWindow)
    QtCore.QMetaObject.connectSlotsByName(MainWindow)
DEDENT
----------------------------------------

def setupUi(self, MainWindow) :
INDENT
    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(250, 300)
    sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Fixed, QtWidgets.QSizePolicy.Fixed)
    sizePolicy.setHorizontalStretch(0)
    sizePolicy.setVerticalStretch(0)
    sizePolicy.setHeightForWidth(MainWindow.sizePolicy().hasHeightForWidth())
    MainWindow.setSizePolicy(sizePolicy)
    MainWindow.setMinimumSize(QtCore.QSize(250, 300))
    MainWindow.setMaximumSize(QtCore.QSize(250, 300))
    self.centralwidget = QtWidgets.QWidget(MainWindow)
    self.centralwidget.setObjectName("centralwidget")
    self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.centralwidget)
    self.verticalLayout_2.setObjectName("verticalLayout_2")
    self.verticalLayout = QtWidgets.QVBoxLayout()
    self.verticalLayout.setContentsMargins(5, 10, 5, 5)
    self.verticalLayout.setSpacing(10)
    self.verticalLayout.setObjectName("verticalLayout")
    self.setupPush = QtWidgets.QPushButton(self.centralwidget)
    self.setupPush.setObjectName("setupPush")
    self.verticalLayout.addWidget(self.setupPush)
    self.line_5 = QtWidgets.QFrame(self.centralwidget)
    self.line_5.setFrameShape(QtWidgets.QFrame.HLine)
    self.line_5.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_5.setObjectName("line_5")
    self.verticalLayout.addWidget(self.line_5)
    self.nodePropPush = QtWidgets.QPushButton(self.centralwidget)
    self.nodePropPush.setObjectName("nodePropPush")
    self.verticalLayout.addWidget(self.nodePropPush)
    self.line_4 = QtWidgets.QFrame(self.centralwidget)
    self.line_4.setFrameShape(QtWidgets.QFrame.HLine)
    self.line_4.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_4.setObjectName("line_4")
    self.verticalLayout.addWidget(self.line_4)
    self.elPropLabel = QtWidgets.QPushButton(self.centralwidget)
    self.elPropLabel.setObjectName("elPropLabel")
    self.verticalLayout.addWidget(self.elPropLabel)
    self.line_3 = QtWidgets.QFrame(self.centralwidget)
    self.line_3.setFrameShape(QtWidgets.QFrame.HLine)
    self.line_3.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_3.setObjectName("line_3")
    self.verticalLayout.addWidget(self.line_3)
    self.bcPush = QtWidgets.QPushButton(self.centralwidget)
    self.bcPush.setObjectName("bcPush")
    self.verticalLayout.addWidget(self.bcPush)
    self.line_2 = QtWidgets.QFrame(self.centralwidget)
    self.line_2.setFrameShape(QtWidgets.QFrame.HLine)
    self.line_2.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line_2.setObjectName("line_2")
    self.verticalLayout.addWidget(self.line_2)
    self.solvePush = QtWidgets.QPushButton(self.centralwidget)
    self.solvePush.setObjectName("solvePush")
    self.verticalLayout.addWidget(self.solvePush)
    self.line = QtWidgets.QFrame(self.centralwidget)
    self.line.setFrameShape(QtWidgets.QFrame.HLine)
    self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
    self.line.setObjectName("line")
    self.verticalLayout.addWidget(self.line)
    self.resultPush = QtWidgets.QPushButton(self.centralwidget)
    self.resultPush.setObjectName("resultPush")
    self.verticalLayout.addWidget(self.resultPush)
    self.verticalLayout_2.addLayout(self.verticalLayout)
    MainWindow.setCentralWidget(self.centralwidget)
    self.menubar = QtWidgets.QMenuBar(MainWindow)
    self.menubar.setGeometry(QtCore.QRect(0, 0, 250, 21))
    self.menubar.setObjectName("menubar")
    self.menuFEA = QtWidgets.QMenu(self.menubar)
    self.menuFEA.setObjectName("menuFEA")
    MainWindow.setMenuBar(self.menubar)
    self.statusbar = QtWidgets.QStatusBar(MainWindow)
    self.statusbar.setObjectName("statusbar")
    MainWindow.setStatusBar(self.statusbar)
    self.actionExit = QtWidgets.QAction(MainWindow)
    self.actionExit.setObjectName("actionExit")
    self.menuFEA.addAction(self.actionExit)
    self.menubar.addAction(self.menuFEA.menuAction())

    self.retranslateUi(MainWindow)
    QtCore.QMetaObject.connectSlotsByName(MainWindow)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43163105_43163202_1_12
43163105_43163208_4_11
Title: Updating dictionary values of keys from a .txt file 
----------------------------------------

def pm_dict(filename) :
INDENT
    f = open(filename, 'r')
    dict = defaultdict(int)
    for line in f :
    INDENT
        x = line.split(",")
        player = x [0]
        minutes = x [1]
        c = len(minutes) - 2
        minutes = minutes [0 : c]
        dict [player] += int(minutes)
    DEDENT
    return dict
DEDENT
----------------------------------------

def pm_dict(filename) :
INDENT
    D = defaultdict(int)
    with open(filename, 'r', newline = '') as f :
    INDENT
        r = csv.reader(f)
        for key, value in r :
        INDENT
            D [key] += int(value)
        DEDENT
    DEDENT
    return dict(D)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43175324_43175363_8_13
43175324_43175390_5_10
Title: Python Random Number File Writer 
----------------------------------------

def getRandom() :
INDENT
    qty_numbers = int(input('How many random numbers should be written to the file? '))
    for count in range(qty_numbers) :
    INDENT
        number = random.randint(1, 500)
        writeFunction(number)
    DEDENT
DEDENT
----------------------------------------

def getRandom() :
INDENT
    qty_numbers = int(input('How many random numbers should be written to the file? '))
    res = []
    for count in range(qty_numbers) :
    INDENT
        res.append(random.randint(1, 500))
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43175324_43175363_8_13
43175324_43175395_9_16
Title: Python Random Number File Writer 
----------------------------------------

def getRandom() :
INDENT
    qty_numbers = int(input('How many random numbers should be written to the file? '))
    for count in range(qty_numbers) :
    INDENT
        number = random.randint(1, 500)
        writeFunction(number)
    DEDENT
DEDENT
----------------------------------------

def getRandom() :
INDENT
    qty_numbers = int(input('How many random numbers should be written to     the file? '))
    nums = []
    for count in range(qty_numbers) :
    INDENT
        nums.append(random.randint(1, 500))
    DEDENT
    return nums
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43179929_43185539_12_29
43179929_43185539_63_73
Title: How to write result to JSON files in gcs in Dataflow/Beam 
----------------------------------------

def __init__(self,
file_path_prefix,
file_name_suffix = '',
num_shards = 0,
shard_name_template = None,
coder = coders.ToStringCoder(),
compression_type = beam.io.CompressionTypes.AUTO) :
INDENT
    super(_JsonSink, self).__init__(
        file_path_prefix,
        file_name_suffix = file_name_suffix,
        num_shards = num_shards,
        shard_name_template = shard_name_template,
        coder = coder,
        mime_type = 'text/plain',
        compression_type = compression_type)
    self.last_rows = dict()
DEDENT
----------------------------------------

def __init__(self,
file_path_prefix,
file_name_suffix = '',
num_shards = 0,
shard_name_template = None,
coder = coders.ToStringCoder(),
compression_type = beam.io.CompressionTypes.AUTO) :
INDENT
    self._sink = _JsonSink(file_path_prefix, file_name_suffix, num_shards,
        shard_name_template, coder, compression_type)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43196249_43196326_3_10
43196249_43196389_1_13
Title: Find if there are three consecutive indices in a list that ARE NOT equal to zero in python 
----------------------------------------

def is_three_consecutive_non_zero(lst) :
INDENT
    for k, g in groupby(enumerate(lst), lambda p : p [1]) :
    INDENT
        g = list(g)
        if k ! = 0 and len(g) > 2 :
        INDENT
            return True, g [- 1] [0], k

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def is_three_consecutive_non_zero(list) :
INDENT
    if 0 not in list :
    INDENT
        if len(list) > = 3 :
        INDENT
            return True, len(list) - 1, list [len(list) - 1]
        DEDENT
    DEDENT
    consecutiveNonZero = 0
    for index, num in enumerate(list) :
    INDENT
        if num is 0 :
        INDENT
            consecutiveNonZero = 0
        DEDENT
        else :
        INDENT
            consecutiveNonZero = consecutiveNonZero + 1
        DEDENT
        if consecutiveNonZero > = 3 :
        INDENT
            return True, index, num
        DEDENT
    DEDENT
    return False, - 1, - 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43196285_43196301_1_7
43196285_43196310_1_8
Title: "how change ""for"" for ""while"" in python and try say the same" 
----------------------------------------

def arbolNavidad(n) :
INDENT
    a = 1
    while a < = n :
    INDENT
        print (" " * (n - a) + "*" * (2 * a - 1))
        a += 1

    DEDENT
DEDENT
----------------------------------------

def arbolNavidad(n) :
INDENT
    j = 1

    while j < = n :
    INDENT
        print (" " * (n - a) + "*" * (2 * a - 1))
        j += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43210179_43211043_1_20
43210179_43211876_2_24
Title: Conditional Regex Function on Pandas Dataframe 
----------------------------------------

def placement_extract(df = "mediaplan_df", we_search = "we\d{8}", uk_search = "uk\d{8}", new_id_search = "(\d{14})") :
INDENT
    if type(df ['Plan Unique ID']) is str :
    INDENT
        we_match = re.search(we_search, df ['Plan Unique ID'])
        if we_match :
        INDENT
            if we_match.group(0) > "we12720203" :
            INDENT
                return we_match.group(0)
            DEDENT
        DEDENT
        uk_match = re.search(uk_search, df ['Plan Unique ID'])
        if uk_match :
        INDENT
            if uk_match.group(0) > "uk11350200" :
            INDENT
                return uk_match.group(0)

            DEDENT
        DEDENT
        match_new = re.search(new_id_search, df ['Atlas Placement ID'])
        if match_new :
        INDENT
            return match_new.group(0)
        DEDENT
        return 0
    DEDENT
DEDENT
----------------------------------------

def placement_extract(row, we_search = "we12720203", uk_search = "uk11350200") :
INDENT
    plan_id = row ["Plan Unique ID"]

    result = re.match("(we|uk)(.+)", plan_id)
    if result :
    INDENT
        code, numeric = result.groups()

        if code == "we" and plan_id > we_search :
        INDENT
            return_val = plan_id
        DEDENT
        elif code == "uk" and plan_id > uk_search :
        INDENT
            return_val = plan_id
        DEDENT
        else :
        INDENT

            return_val = row ["Atlas Placement ID"]
        DEDENT
    DEDENT
    return return_val
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43232702_43232825_1_9
43232702_43233496_1_13
Title: Removing all instances of the second string from the first 
----------------------------------------

def remove(s1, s2) :
INDENT
    newString = []
    if len(s2) > 2 :
    INDENT
        return "The second argument cannot exceed two characters"
    DEDENT
    for c in s1 :
    INDENT
        if c not in s2 :
        INDENT
            newString.append(c)
        DEDENT
    DEDENT
    return "".join(newString)
DEDENT
----------------------------------------

def remove(l1, l2) :
INDENT
    string1 = l1
    string2 = l2
    ctr = 0
    result = ""
    while ctr < len(string1) :
    INDENT
        if string1 [ctr : ctr + len(string2)] == string2 :
        INDENT
            ctr += len(string2)
        DEDENT
        else :
        INDENT
            result += string1 [ctr]
            ctr += 1
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43240496_43242295_13_51
43240496_43292627_29_36
Title: "Python sqlite3: how to quickly and cleanly interrupt long running query with e.g. KeyboardInterrupt" 
----------------------------------------

def main() :
INDENT
    global conn
    statement = '''
SELECT DISTINCT a.id,a.rand
FROM randint a
     JOIN randint b ON a.id=b.rand
     JOIN randint c ON a.id=c.rand
     JOIN randint d ON a.id=d.rand
     JOIN randint e ON a.id=e.rand
     JOIN randint f ON a.id=f.rand
     JOIN randint g ON a.id=g.rand
     JOIN randint h ON a.id=h.rand
ORDER BY a.id limit 10'''
    conn = sqlite3.connect('randtable.sqlite', 10.0)
    cursor = conn.cursor()
    print ("Executing query")
    try :
    INDENT
        cursor.execute(statement)
    DEDENT
    except Exception as err :
    INDENT
        if str(err) ! = "interrupted" :
        INDENT
            print ("Database error: {0}".format(str(err)))
        DEDENT
        return None
    DEDENT
    rows = cursor.fetchall()
    print ("ROWS:")
    for row in rows :
    INDENT
        print ("  ", row)
    DEDENT
    conn.close()
    conn = None
    return
DEDENT
----------------------------------------

def main() :
INDENT
    conn = sqlite3.connect('foo.db')
    kill_event = threading.Event()
    kill_thread = threading.Thread(target = kill_it, args = (conn, kill_event))
    kill_thread.start()
    big_query(conn, kill_event)
    kill_thread.join()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43250444_43252358_3_26
43250444_43252999_5_25
Title: "PyQT - Multiple ComboBoxes One for Each Function Argument" 
----------------------------------------

def setupUi(self) :
INDENT
    window = QtGui.QMainWindow(self)
    window.table = QtGui.QTableWidget()
    window.table.setRowCount(2)
    window.table.setColumnCount(1)
    window.setCentralWidget(window.table)

    self.combo_x = QtGui.QComboBox()
    self.combo_y = QtGui.QComboBox()
    for i in range(1, 10) :
    INDENT
        self.combo_x.addItem(str(i))
        self.combo_y.addItem(str(i))
    DEDENT
    self.combo_x.activated [int].connect(self.multiply)
    self.combo_y.activated [int].connect(self.multiply)
    window.table.setCellWidget(0, 0, self.combo_x)
    window.table.setCellWidget(1, 0, self.combo_y)
    window.show()
DEDENT
----------------------------------------

def setupUi(self) :
INDENT
    self.table = QtGui.QTableWidget()
    self.table.setRowCount(3)
    self.table.setColumnCount(1)
    self.setCentralWidget(self.table)
    combo_x = QtGui.QComboBox()
    combo_y = QtGui.QComboBox()
    for i in range(1, 10) :
    INDENT
        combo_x.addItem(str(i))
        combo_y.addItem(str(i ** 2))
    DEDENT
    combo_x.activated.connect(self.update)
    combo_y.activated.connect(self.update)
    self.table.setCellWidget(0, 0, combo_x)
    self.table.setCellWidget(1, 0, combo_y)
    self.table.setCellWidget(2, 0, QtGui.QLabel(""))
    self.show()
DEDENT
----------------------------------------
