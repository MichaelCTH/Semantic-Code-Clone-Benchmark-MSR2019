$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40597683_40597767_3_9
40597683_40597816_6_10
Title: Python decorator that let's method run or raise an exception 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if arg :
    INDENT
        return func(* args, ** kwargs)
    DEDENT
    else :
    INDENT
        raise Exception()
    DEDENT
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if kwargs.pop('runit', None) :
    INDENT
        return f(* args, ** kwargs)
    DEDENT
    else :
    INDENT
        raise Exception()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40598494_40852311_24_36
40598494_40852311_5_22
Title: Transfer text from tab to tab using wx.flatnotebook 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.txtOne = wx.TextCtrl(self, - 1, style = wx.TE_PROCESS_ENTER)
    self.btnOne = wx.Button(self, - 1, "Transfer text to Tab 2")
    self.Bind(wx.EVT_BUTTON, self.sendText, self.btnOne)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.txtOne, 0, wx.ALL, 5)
    sizer.Add(self.btnOne, 0, wx.ALL, 5)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Notebook", size = (300, 300))
    panel = wx.Panel(self)
    notebook = wx.Notebook(panel)
    page1 = FirstTab(notebook)
    page2 = SecondTab(notebook)
    notebook.AddPage(page1, "Tab 1")
    notebook.AddPage(page2, "Tab 2")
    sizer = wx.BoxSizer()
    sizer.Add(notebook, 1, wx.ALL | wx.EXPAND, 5)
    panel.SetSizer(sizer)
    self.Layout()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40598494_40852311_42_53
40598494_40852311_5_22
Title: Transfer text from tab to tab using wx.flatnotebook 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    pub.subscribe(self.myListener, "panelListener")
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.txtTwo = wx.TextCtrl(self, - 1, style = wx.TE_PROCESS_ENTER)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.txtTwo, 0, wx.ALL, 5)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Notebook", size = (300, 300))
    panel = wx.Panel(self)
    notebook = wx.Notebook(panel)
    page1 = FirstTab(notebook)
    page2 = SecondTab(notebook)
    notebook.AddPage(page1, "Tab 1")
    notebook.AddPage(page2, "Tab 2")
    sizer = wx.BoxSizer()
    sizer.Add(notebook, 1, wx.ALL | wx.EXPAND, 5)
    panel.SetSizer(sizer)
    self.Layout()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40602900_40603188_1_10
40602900_40603229_6_17
Title: Using a dictionary to correct spelling 
----------------------------------------

def respell(s) :
INDENT
    respellings = {
        'teh' : 'the',
        'relevent' : 'relevant',
        'lite' : 'light',
        'lol' : 'haha'}
    for key in respellings :
    INDENT
        s = s.replace(key, respellings [key])
    DEDENT
    return s
DEDENT
----------------------------------------

def respell(word) :
INDENT
    known_words = set(["the", "man", "relevant", "light", "haha"])
    if word in known_words :
    INDENT
        return word, 1
    DEDENT
    max_similarity = 0
    correct_word = None
    for known_word in known_words :
    INDENT
        similarity_value = similar(known_word, word)
        if max_similarity < similarity_value :
        INDENT
            similarity_value = max_similarity
            correct_word = known_word
        DEDENT
    DEDENT
    return correct_word, max_similarity
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
406121_20740630_8_15
406121_27478225_3_10
Title: Flattening a shallow list in Python 
----------------------------------------

def flatten(seq, predicate = list_or_tuple) :
INDENT
    for i in seq :
    INDENT
        if predicate(seq) :
        INDENT
            for j in flatten(i) :
            INDENT
                yield j
            DEDENT
        DEDENT
        else :
        INDENT
            yield i
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def flatten(o) :
INDENT
    result = []
    for i in o :
    INDENT
        if isinstance(i, collections.Iterable) :
        INDENT
            result.extend(flatten(i))
        DEDENT
        else :
        INDENT
            result.append(i)
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40614238_40614438_1_11
40614238_40614558_3_10
Title: How to read file without getting \n 
----------------------------------------

def number_frequency(filename) :
INDENT
    dic = {}
    with open(filename, "r+") as f :
    INDENT
        for line in f :
        INDENT
            if "\n" in line :
            INDENT
                line = line [: - 1]
            DEDENT
            if line not in dic.keys() :
            INDENT
                dic [line] = int(1)
            DEDENT
            elif line in dic.keys() :
            INDENT
                dic [line] += 1
            DEDENT
        DEDENT
    DEDENT
    return dic
DEDENT
----------------------------------------

def number_frequency(filename) :
INDENT
    dic = defaultdict(int)
    with open(filename, 'r') as f :
    INDENT
        for line in f :
        INDENT
            line = line.rstrip()
            dic [line] += 1
        DEDENT
    DEDENT
    return dic
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40616549_40616724_1_25
40616549_40616765_1_16
Title: Restart Python program if user input to 'run again?' is 'y' 
----------------------------------------

def main() :
INDENT
    total = 0
    num1 = int(input("enter a number"))
    total = total + num1
    num2 = int(input("enter a number"))
    total = total + num2
    num3 = int(input("enter a number"))
    total = total + num3
    if total > 100 :
    INDENT
        print ("That's a big number!")
    DEDENT
    else :
    INDENT
        print ("That's a small number.")
    DEDENT
    print (total)
    answer = raw_input("Run again? (y/n): ")
    if answer not in ('y', 'n') :
    INDENT
        print ("Invalid input.")
    DEDENT
    if answer == 'y' :
    INDENT
        main()
    DEDENT
    else :
    INDENT
        print 'Goodbye'
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    total = 0
    num1 = int(input("enter a number"))
    total = total + num1
    num2 = int(input("enter a number"))
    total = total + num2
    num3 = int(input("enter a number"))
    total = total + num3
    if total > 100 :
    INDENT
        print ("That's a big number!")
    DEDENT
    else :
    INDENT
        print ("That's a small number.")
    DEDENT
    print (total)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40622453_40622627_1_29
40622453_40622643_1_10
Title: Python:Taking the first character without Lists 
----------------------------------------

def create_password(phrase) :
INDENT
    q = "'"
    dq = '"'

    password = ""

    new_word = True

    for char in phrase :
    INDENT
        if char.isalnum and new_word :
        INDENT
            if char ! = q and char ! = dq :
            INDENT
                password += char
                new_word = False

            DEDENT
        DEDENT
        elif char == " " :
        INDENT
            new_word = True
        DEDENT
    DEDENT
    return password
DEDENT
----------------------------------------

def create_password(phrase) :
INDENT
    password = ''
    phrase_list = phrase.split(' ')
    print (phrase_list)
    for i in phrase_list :
    INDENT
        print (i [0])
        password += i [0]
    DEDENT
    return password
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40623234_40623378_3_8
40623234_40623836_9_18
Title: Run one python script from another python script? 
----------------------------------------

def questions() :
INDENT
    if ask1 == "yes" :
    INDENT
        createbid.run()
    DEDENT
    if ask1 == "no" :
    INDENT
        quit()
    DEDENT
DEDENT
----------------------------------------

def questions() :
INDENT
    if ask1.lower() in ('yes', 'y') :
    INDENT
        create.createbd()
    DEDENT
    elif ask1.lower() in ('no', 'n') :
    INDENT
        ask2
    DEDENT
    if ask2.lower() in ('yes', 'y') :
    INDENT
        see.seebd()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40641884_40642090_1_8
40641884_40642561_1_12
Title: "How do I do this ""If n is 3 return `1+..1+2+..1+2+3+..`""" 
----------------------------------------

def nested_increasing_additions(n) :
INDENT
    complete_string = ""
    add_string = ""
    for i in range(1, n + 1) :
    INDENT
        add_string += str(i) + "+"
        complete_string += add_string + ".."
    DEDENT
    return complete_string
DEDENT
----------------------------------------

def nested_increasing_additions(n) :
INDENT
    string = ""
    new_string = ""
    dot = ".."
    for i in range(1, n + 1) :
    INDENT
        new_string += ('{}+'.format(i))
        string = string + new_string + dot
        print (string)
    DEDENT
    return (string)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40642152_46109011_16_24
40642152_46109011_36_49
Title: set matplotlib backend on jupyter for plots that change over the time 
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.left = 10
    self.top = 10
    self.title = 'PyQt5 matplotlib example - pythonspot.com'
    self.width = 640
    self.height = 400
    self.initUI()
DEDENT
----------------------------------------

def __init__(self, parent = None, width = 5, height = 4, dpi = 100) :
INDENT
    fig = Figure(figsize = (width, height), dpi = dpi)
    self.axes = fig.add_subplot(111)
    FigureCanvas.__init__(self, fig)
    self.setParent(parent)
    FigureCanvas.setSizePolicy(self,
        QSizePolicy.Expanding,
        QSizePolicy.Expanding)
    FigureCanvas.updateGeometry(self)
    self.plot()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40672264_40961479_21_30
40672264_40961479_9_14
Title: Python dynamic multiprocessing and signalling issues 
----------------------------------------

def run(self) :
INDENT
    signal(SIGINT, self.handle_signal)
    sub = NormalWorker()
    sub.start()
    print ('%d joining %d' % (self.pid, sub.pid))
    sub.join()
    print ('%d %s joined sub worker' % (self.pid, type(self).__name__))
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        print ('%d %s work' % (self.pid, type(self).__name__))
        sleep(1)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4067520_4067556_1_14
4067520_4067572_1_10
Title: "Python function with too many arguments with default values how to make it cleaner?" 
----------------------------------------

def contact(request, ** kargs) :
INDENT
    try :
    INDENT
        sender = kwargs.pop('sender')
    DEDENT
    except KeyError :
    INDENT
        sender = settings.DEFAULT_FROM_EMAIL
    DEDENT
    try :
    INDENT
        subj_tmpl = kwargs.pop('subj_tmpl')
    DEDENT
    except KeyError :
    INDENT
        subj_tmpl = 'contato/subject.txt'

    DEDENT
DEDENT
----------------------------------------

def contact(request, sender = None, append_message = None, context = None) :
INDENT
    if not sender :
    INDENT
        sender = settings.DEFAULT_FROM_EMAIL

    DEDENT
    subj_tmpl = context.get('subj_tmpl', 'contato/subject.txt')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40688156_40688341_1_18
40688156_49259495_48_58
Title: Python Credit Card Validation 
----------------------------------------

def main() :
INDENT
    filename = input("What is the name of your input file? ")
    infile = open(filename, "r")
    num = cc = (infile.readline().strip())
    print (format("Card Number", "20s"), ("Valid / Invalid"))
    print ("------------------------------------")
    while cc ! = "EXIT" :
    INDENT
        even = checkSecondDigits(num)
        odd = odd_digits(num)
        c_len = c_length(num)
        tot = even + odd
        if c_len == True and tot % 10 == 0 :
        INDENT
            print (format(cc, "20s"), format("Valid", "20s"))
        DEDENT
        else :
        INDENT
            print (format(cc, "20s"), format("Invalid", "20s"))
        DEDENT
        num = cc = (infile.readline().strip())
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    while True :
    INDENT

        result = cardnumber()
        validator(result)

        if not goagain() :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40704821_40705071_8_24
40704821_40705109_6_15
Title: Remove consecutive duplicate characters from a string in python 
----------------------------------------

def find_dups(text) :
INDENT
    s = text
    print s, "in find"
    ln = len(s)
    print ln
    fg = 0
    ind = 0
    if ln == 1 :
    INDENT
        print s, 'len'
        return s
    DEDENT
    for i in range(0, ln - 1) :
    INDENT
        if (s [i] == s [i + 1]) :
        INDENT
            ind = i
            s = remove_dups(s, ind)
            break
        DEDENT
    DEDENT
    print s, 'check'
    return s
DEDENT
----------------------------------------

def find_dups(text, i) :
INDENT
    if len(text) - 1 == i :
    INDENT
        return text
    DEDENT
    if (text [i] == text [i + 1]) :
    INDENT
        text = remove_dups(text, i)
        text = find_dups(text, i)
    DEDENT
    else :
    INDENT
        text = find_dups(text, i + 1)
    DEDENT
    return text
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40705875_41334616_12_17
40705875_41334616_27_32
Title: PyQt4: switch layouts created by Qt Designer 
----------------------------------------

def handleButton(self) :
INDENT
    self.hide()
    if self._window2 is None :
    INDENT
        self._window2 = Window2(self)
    DEDENT
    self._window2.show()
DEDENT
----------------------------------------

def handleButton(self) :
INDENT
    self.hide()
    if self._window1 is None :
    INDENT
        self._window1 = Window1(self)
    DEDENT
    self._window1.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40705875_41334616_19_26
40705875_41334616_4_11
Title: PyQt4: switch layouts created by Qt Designer 
----------------------------------------

def __init__(self, window1 = None) :
INDENT
    super(Window2, self).__init__()
    self.setGeometry(500, 100, 100, 50)
    self.button = QtGui.QPushButton('Go To Window 1', self)
    self.button.clicked.connect(self.handleButton)
    self.setCentralWidget(self.button)
    self._window1 = window1
DEDENT
----------------------------------------

def __init__(self, window2 = None) :
INDENT
    super(Window1, self).__init__()
    self.setGeometry(500, 100, 100, 50)
    self.button = QtGui.QPushButton('Go To Window 2', self)
    self.button.clicked.connect(self.handleButton)
    self.setCentralWidget(self.button)
    self._window2 = window2
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40709056_40709243_1_17
40709056_40709374_1_20
Title: Index words by line number from text file 
----------------------------------------

def lineIndex(fName) :
INDENT
    dic = {}
    i = 0
    with open(fName, 'r') as f :
    INDENT
        while True :
        INDENT
            x = f.readline()
            if not x :
            INDENT
                break
            DEDENT
            i += 1
            for j in x :
            INDENT
                if j in dic :
                INDENT
                    dic [j].add(i)
                DEDENT
                else :
                INDENT
                    dic [j] = set()
                    dic [j].add(i)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    print (dic)
DEDENT
----------------------------------------

def lineIndex(fName) :
INDENT
    d = {}
    with open(fName, 'r') as f :
    INDENT
        content = f.readlines()
        lnc = 0
        result = {}
        for line in content :
        INDENT
            line = line.rstrip()
            words = line.split(" ")
            for word in words :
            INDENT
                tmp = result.get(word)
                if tmp is None :
                INDENT
                    result [word] = []
                DEDENT
                if lnc not in result [word] :
                INDENT
                    result [word].append(lnc)
                DEDENT
            DEDENT
            lnc = lnc + 1
        DEDENT
        return result
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40723549_40724255_23_32
40723549_40724412_25_34
Title: Using open() with Command Line Argument in Python 
----------------------------------------

def merge_csvs(file1, file2) :
INDENT
    a = pd.read_csv(file1)
    b = pd.read_csv(file2)
    print (a)
    print (b)
    merged = b.merge(a, on = 'SWREV')
    merged.to_csv("merged_results.csv", index = False)

DEDENT
----------------------------------------

def merge_csvs() :
INDENT
    a = pd.read_csv(file1)
    b = pd.read_csv(file2)
    print (a)
    print (b)
    merged = b.merge(a, on = 'SWREV')
    merged.to_csv("merged_results.csv", index = False)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40726945_40727028_16_32
40726945_40727968_13_74
Title: Blinking rectangle white pygame with specific frequency 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == QUIT :
            INDENT
                pygame.quit()
                sys.exit()
            DEDENT
        DEDENT
        pygame.draw.rect(fenetre, black, (200, 150, 100, 50))
        pygame.display.update()
        time.sleep(frequency)
        pygame.draw.rect(fenetre, white, (200, 150, 100, 50))
        pygame.display.update()
        time.sleep(frequency)
        clock.tick(30)

    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    pygame.init()
    fenetre = pygame.display.set_mode((500, 400), 0, 32)
    current_time = pygame.time.get_ticks()

    delay = 500

    change_time = current_time + delay
    show = True

    red_change_time = current_time + delay + 150
    red_show = False

    green_change_time = current_time + delay + 300
    green_show = False
    while True :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == pygame.QUIT :
            INDENT
                pygame.quit()
                sys.exit()

            DEDENT
        DEDENT
        current_time = pygame.time.get_ticks()

        if current_time > = change_time :
        INDENT
            change_time = current_time + delay
            show = not show

        DEDENT
        if current_time > = red_change_time :
        INDENT
            red_change_time = current_time + delay
            red_show = not red_show

        DEDENT
        if current_time > = green_change_time :
        INDENT
            green_change_time = current_time + delay
            green_show = not red_show

        DEDENT
        fenetre.fill(BLACK)
        if show :
        INDENT
            pygame.draw.rect(fenetre, WHITE, (200, 150, 100, 50))
        DEDENT
        if red_show :
        INDENT
            pygame.draw.rect(fenetre, RED, (100, 150, 100, 50))
        DEDENT
        if green_show :
        INDENT
            pygame.draw.rect(fenetre, GREEN, (300, 150, 100, 50))
        DEDENT
        pygame.display.update()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40755076_40755098_3_10
40755076_40755209_1_11
Title: How can I make two strings return true or false for every character? 
----------------------------------------

def check_answers(X, Y) :
INDENT
    result = []
    for i, v in enumerate(answerkey) :
    INDENT
        if v == student11 [i] :
        INDENT
            result.append('1')
        DEDENT
        else :
        INDENT
            result.append('0')
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def check_answers(X = 'student', Y = 'answer key') :
INDENT
    result = []
    print ('X: %d, Y: %d' % (len(X), len(Y)))
    for i in range(len(X)) :
    INDENT
        for o in range(len(Y)) :
        INDENT
            print ('i: %d, o: %d' % (i, o))
            if i == o :
            INDENT
                result.append('1')
            DEDENT
            else :
            INDENT
                result.append('0')
            DEDENT
        DEDENT
        return result
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40755076_40755154_4_13
40755076_40755209_1_11
Title: How can I make two strings return true or false for every character? 
----------------------------------------

def check_answers(X, Y) :
INDENT
    result = []
    for i in range(len(X)) :
    INDENT
        if X [i] == Y [i] :
        INDENT
            result.append('1')
        DEDENT
        else :
        INDENT
            result.append('0')
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def check_answers(X = 'student', Y = 'answer key') :
INDENT
    result = []
    print ('X: %d, Y: %d' % (len(X), len(Y)))
    for i in range(len(X)) :
    INDENT
        for o in range(len(Y)) :
        INDENT
            print ('i: %d, o: %d' % (i, o))
            if i == o :
            INDENT
                result.append('1')
            DEDENT
            else :
            INDENT
                result.append('0')
            DEDENT
        DEDENT
        return result
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40755200_40755756_1_16
40755200_40756154_1_41
Title: Python stuck on dictionary writing to file in order 
----------------------------------------

def generateReport(gradebook) :
INDENT
    outfile = open('gradebook.txt', 'w')
    currentstud = []
    for stu in d :
    INDENT
        currentstud.append(d [stu])
    DEDENT
    for grades in currentstud [0] :
    INDENT
        outfile.write(grades + '\t')
    DEDENT
    outfile.write('\n')
    for students in currentstud :
    INDENT
        for val in students.values() :
        INDENT
            outfile.write(str(val) + '\t')
        DEDENT
        outfile.write('\n')
    DEDENT
    outfile.close

DEDENT
----------------------------------------

def generateReport(gradebook) :
INDENT
    outfile = open('gradebook.txt', 'w')

    columns = ('ID', 'Exam1', 'Exam2', 'Homework', 'Attendance',
        'Project1', 'Project2', 'Class Recap',
        'Final Grade', 'Potential Grade')

    header_line = '\t'.join(columns) + '\n'
    outfile.write(header_line)

    sorted_student_ids = sorted(gradebook.keys(), key = int)

    for student_id in sorted_student_ids :
    INDENT

        student_data = gradebook [student_id]

        student_row = []
        for column in columns :
        INDENT

            column = column.replace(' ', '').lower()
            value = str(student_data.get(column, ''))
            student_row.append(value)

        DEDENT
        student_line = '\t'.join(student_row) + '\n'
        outfile.write(student_line)
    DEDENT
    outfile.close()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40755818_40755967_1_8
40755818_40755981_7_20
Title: Creating dictionary from a file? Python 
----------------------------------------

def makemyDict(theFile) :
INDENT
    moodDict = {}
    with open(theFile) as f :
    INDENT
        for line in f :
        INDENT
            (mood, name) = lines.split(",")
            moodDict ['mood'] = name.strip()
        DEDENT
    DEDENT
    return moodDict
DEDENT
----------------------------------------

def makemyDict(theFile) :
INDENT
    moodDict = {}
    for lines in theFile :
    INDENT
        mood, name = lines.split(",")
        moodDict [mood] = name
    DEDENT
    return (moodDict)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40756420_40756825_8_17
40756420_40757365_7_23
Title: Keyerror : 1 python 
----------------------------------------

def rand_center(ip, C) :
INDENT
    if C < 1 :
    INDENT
        return []
    DEDENT
    centers = [random.choice(ip)]
    for i in range(1, min(C, len(ip))) :
    INDENT
        centers.append(random.choice(ip))
        while centers [i] in centers [: i] :
        INDENT
            centers [i] = random.choice(ip)
        DEDENT
    DEDENT
    return centers
DEDENT
----------------------------------------

def rand_center(ip, C) :
INDENT
    centers = {}
    for i in range(C) :
    INDENT
        rand_num = random.choice(X)
        if i > 0 :
        INDENT

            centers [i] = rand_num
            while rand_num ! = centers [i - 1] :
            INDENT
                centers [i] = rand_num
                rand_num = random.choice(X)
            DEDENT
        DEDENT
        else :
        INDENT

            centers [i] = rand_num
        DEDENT
    DEDENT
    return centers
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40759329_40759418_7_11
40759329_40759600_6_11
Title: Assigning a function return as another functions parameter 
----------------------------------------

def new_number(self) :
INDENT
    n = '0000000000'
    while '9' in n [3 : 6] or n [3 : 6] == '000' or n [6] == n [7] == n [8] == n [9] :
    INDENT
        n = str(random.randint(10 ** 9, 10 ** 10 - 1))
    DEDENT
    return n [: 3] + '-' + n [3 : 6] + '-' + n [6 :]
DEDENT
----------------------------------------

def new_number(self) :
INDENT
    n = '0000000000'
    while '9' in n [3 : 6] or n [3 : 6] == '000' or n [6] == n [7] == n [8] == n [9] :
    INDENT
        n = str(random.randint(10 ** 9, 10 ** 10 - 1))
    DEDENT
    num_from_new_number = n [: 3] + '-' + n [3 : 6] + '-' + n [6 :]
    return num_from_new_number
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40765025_40766291_1_14
40765025_40766561_3_20
Title: Find multiple prime factors Python 
----------------------------------------

def prime_factors(n) :
INDENT
    prime_list = []
    job_done = False
    first_prime = 2
    while not job_done :
    INDENT
        for possible_prime in range(first_prime, n + 1) :
        INDENT
            if n % possible_prime == 0 :
            INDENT
                prime_list.append(possible_prime)
                first_prime = possible_prime
                n = int(n / possible_prime)
                if n == 1 :
                INDENT
                    job_done = True
                DEDENT
                break
            DEDENT
        DEDENT
    DEDENT
    return prime_list
DEDENT
----------------------------------------

def prime_factors(n) :
INDENT
    res = []
    while n % 2 == 0 :
    INDENT
        res.append(2)
        n = n / / 2
    DEDENT
    fac = 3
    while fac < int(math.sqrt(n)) + 1 :
    INDENT
        while n % fac == 0 :
        INDENT
            res.append(fac)
            n = n / / fac
        DEDENT
        fac += 2
    DEDENT
    if n > 2 :
    INDENT
        res.append(n)
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40775271_40775436_26_32
40775271_40775654_2_12
Title: Python : Accessing elements of inner most list in nested lists 
----------------------------------------

def evaluate(expression) :
INDENT
    operation, operand1, operand2 = expression
    if isinstance(operand1, list) :
    INDENT
        operand1 = evaluate(operand1)
    DEDENT
    if isinstance(operand1, list) :
    INDENT
        operand2 = evaluate(operand2)
    DEDENT
    return evaluate2(operation, operand1, operand2)
DEDENT
----------------------------------------

def evaluate(expression) :
INDENT
    if isinstance(expression, str) :
    INDENT
        return float(expression)
    DEDENT
    op, operand1, operand2 = expression
    ops = {"*" : operator.mul,
        "+" : operator.add,
        "/" : operator.truediv,
        "-" : operator.sub}
    return ops [op](evaluate(operand1), evaluate(operand2))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40776727_40776749_1_11
40776727_40776860_1_8
Title: "When I print my code I don't want "".."" to print yet" 
----------------------------------------

def nested_increasing_additions(n) :
INDENT
    ans = ""
    n = n + 1
    for i in range(1, (n + 1)) :
    INDENT
        for k in range(1, i) :
        INDENT
            ans = ans + str(k) + "+"
        DEDENT
        if ans :
        INDENT
            ans = ans + ".."
        DEDENT
    DEDENT
    return ans
DEDENT
----------------------------------------

def nested_increasing_additions(n) :
INDENT
    ans = ""
    for i in range(1, (n + 2)) :
    INDENT
        for k in range(1, i + 1) :
        INDENT
            ans = ans + str(k) + "+"
        DEDENT
        ans = ans + ".."
    DEDENT
    return ans
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4077776_20908717_3_20
4077776_23497110_32_37
Title: Custom Django Field to store a list of email addresses 
----------------------------------------

def to_python(self, value) :
INDENT
    if not value :
    INDENT
        return None
    DEDENT
    cleaned_email_list = list()
    email_list = filter(None, re.split(r';|,\s|\n', value))
    for email in email_list :
    INDENT
        if email.strip(' @;,') :
        INDENT
            cleaned_email_list.append(email.strip(' @;,'))
        DEDENT
    DEDENT
    print cleaned_email_list
    cleaned_email_list = list(set(cleaned_email_list))
    return ", ".join(cleaned_email_list)
DEDENT
----------------------------------------

def to_python(self, value) :
INDENT
    if not value :
    INDENT
        return
    DEDENT
    if isinstance(value, self.Presentation) :
    INDENT
        return value
    DEDENT
    return self.Presentation([address.strip() for address in value.split(',')])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40778302_40778352_1_15
40778302_40778414_7_20
Title: Python call the recursive function on every element in the list 
----------------------------------------

def traverseDir(path, all_files = 0, some_files = 0) :
INDENT
    files = os.listdir(path)
    for f in files :
    INDENT

        full_path = os.path.join(path, f)

        rec_all_files, rec_some_files = traverseDir(full_path, all_files, some_files)
        all_files += rec_all_files
        some_files += rec_some_files
    DEDENT
    return all_files, some_files
DEDENT
----------------------------------------

def traverseDir(path) :
INDENT
    allFile = 0
    someFile = 0
    if os.path.isfile(path) :
    INDENT
        allFile += 1
        if path.endswith('.some') :
        INDENT
            someFile += 1
        DEDENT
    DEDENT
    else :
    INDENT
        for file in os.listdir(path) :
        INDENT
            agAllFile, agSomeFile = traverseDir(os.path.join(path, file))
            allFile += agAllFile
            someFile += agSomeFile
        DEDENT
    DEDENT
    return allFile, someFile
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40795636_40795721_1_11
40795636_40795726_2_11
Title: Iterating level by level in python 
----------------------------------------

def myFunc(n, x) :
INDENT
    i = 1
    interim_result = n
    while interim_result > 1 :
    INDENT
        interim_result = n / float(x ** i)
        print "This is loop number: " + str(i) + " with result: " + str(interim_result)
        i = i + 1
    DEDENT
DEDENT
----------------------------------------

def myFunc(n, x) :
INDENT
    global count
    count = count + 1
    result = n / x

    if result < = 1 :
    INDENT
        print result
    DEDENT
    else :
    INDENT
        myFunc(n, x * 2)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40817080_40817126_1_12
40817080_40817180_1_7
Title: Python anti-vowel function - some vowels cannot be removed 
----------------------------------------

def anti_vowel(text) :
INDENT
    a = []
    for i in text :
    INDENT
        a.append(i)
    DEDENT
    b = a [:]
    for item in a :
    INDENT
        if item in "aeiouAEIOU" :
        INDENT
            b.remove(item)
        DEDENT
    DEDENT
    print (''.join(b))
DEDENT
----------------------------------------

def anti_vowel(s) :
INDENT
    if not s :
    INDENT
        return s
    DEDENT
    elif s [0] in "aeiouAEIOU" :
    INDENT
        return anti_vowel(s [1 :])
    DEDENT
    return s [0] + anti_vowel(s [1 :])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40818146_40826505_9_22
40818146_44079180_10_28
Title: pytest nested parametrization with tree-like data 
----------------------------------------

def pytest_generate_tests(metafunc) :
INDENT
    if 'document' in metafunc.fixturenames :
    INDENT
        documents_plain = []
        for document in documents.keys() :
        INDENT
            for chapter in documents [document].keys() :
            INDENT
                for paragraph in documents [document] [chapter].keys() :
                INDENT
                    documents_plain.append({'document' : document, 'chapter' : chapter, 'paragraph' : paragraph})
                DEDENT
            DEDENT
        DEDENT
        metafunc.parametrize(
            'document',
            documents_plain,
            scope = 'session')

    DEDENT
DEDENT
----------------------------------------

def pytest_generate_tests(metafunc) :
INDENT
    if 'document' in metafunc.fixturenames :
    INDENT
        if 'chapter' in metafunc.fixturenames :
        INDENT
            if 'paragraph' in metafunc.fixturenames :
            INDENT
                metafunc.parametrize(
                    ['document', 'chapter', 'paragraph'],
                    [(d, c, p) for d, cs in documents.items()
                        for c, ps in cs.items()
                        for p in ps.keys()
                        ])
            DEDENT
            else :
            INDENT
                metafunc.parametrize(
                    ['document', 'chapter'],
                    [(d, c) for d, cs in documents.items()
                        for c in cs.keys()
                        ])
            DEDENT
        DEDENT
        else :
        INDENT
            metafunc.parametrize(
                'document', documents.keys())
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40829285_40829337_2_6
40829285_40829696_6_11
Title: How to write a recursive function in python 
----------------------------------------

def replicate_recur(times, val) :
INDENT
    if (isinstance(times, int) and times > 0) :
    INDENT
        array.append(val)
        return replicate_recur(times - 1, val)
    DEDENT
    return array
DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if not times or not data :
    INDENT
        return []
    DEDENT
    if isinstance(times, int) and (isinstance(data, int) or isinstance(data, str)) :
    INDENT
        return rep_rec(times, data) if times > 0 else []
    DEDENT
    raise ValueError
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40831893_40832038_1_14
40831893_40841157_3_16
Title: Deciding if two lists are cyclic permutations of eachother 
----------------------------------------

def is_cyc_perm(list1, list2) :
INDENT
    if len(list1) == len(list2) :
    INDENT
        for shift in range(len(list1)) :
        INDENT
            for i in range(len(list1)) :
            INDENT
                if list1 [i] ! = list2 [(i + shift) % len(list1)] :
                INDENT
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                return True
            DEDENT
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    else :
    INDENT
        return False

    DEDENT
DEDENT
----------------------------------------

def is_cyc_perm(seq1, seq2) :
INDENT
    mset1 = collections.Counter(seq1)
    mset2 = collections.Counter(seq2)
    if mset1 ! = mset2 :
    INDENT
        return False
    DEDENT
    size = len(seq1)
    deq1 = collections.deque(seq1)
    deq2 = collections.deque(seq2)
    for _ in range(size) :
    INDENT
        deq2.rotate()
        if deq1 == deq2 :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40841168_40841959_4_15
40841168_40850439_6_18
Title: Changing Backspace effect in Tkinter text widget 
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self, parent)
    self.text = tk.Text(self)
    self.text.pack(fill = "both", expand = True)

    self.text.tag_configure("overstrike", overstrike = True)

    self.text.bind("<BackSpace>", self.handleBackspace)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self, parent)
    self.text = tk.Text(self)
    self.text.pack(fill = "both", expand = True)
    self.text.tag_configure("overstrike", overstrike = True)

    self.text.bind("<Key>", self.eyeout)

    self.text.bind("<BackSpace>", self.handleBackspace)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40845920_40846847_10_17
40845920_40846990_8_15
Title: Updating tkinter label 
----------------------------------------

def init_window(self) :
INDENT
    self.pack(fill = BOTH, expand = 1)
    testButton = Button(self, text = "Press",
        command = lambda win = self : calc(win))
    testButton.pack()
    self.l1 = Label(text = "")
    self.l1.pack()
DEDENT
----------------------------------------

def init_window(self) :
INDENT
    self.pack(fill = BOTH, expand = 1)
    testButton = Button(self, text = "Press", command = self.calc)
    testButton.pack()
    self.ltext = StringVar()
    l1 = Label(textvariable = self.ltext)
    l1.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40855688_40856033_4_10
40855688_40860210_11_17
Title: How to open Microsoft Edge from a Script? 
----------------------------------------

def main() :
INDENT
    rw = RandomWords()
    for i in range(0, 30) :
    INDENT
        word = rw.random_word()
        web.open(word, new = 0)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    rw = RandomWords()
    for i in range(0, 30) :
    INDENT
        word = rw.random_word()
        driver.get(word, new = 0)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40856975_40857209_1_17
40856975_40857230_1_12
Title: "lucky sevens sum of 3 consecutive numbers in array == 7" 
----------------------------------------

def lucky_sevens(numbers) :
INDENT
    if len(numbers) < 3 :
    INDENT
        return False
    DEDENT
    x, y = 0, 3
    sum_of_numbers = sum(numbers [x : y])
    while sum_of_numbers ! = 7 and y < len(numbers) :
    INDENT
        x += 1
        y += 1
        sum_of_numbers = sum(numbers [x : y])
    DEDENT
    if sum_of_numbers == 7 :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def lucky_sevens(numbers) :
INDENT
    result = False
    x, y = 0, 3
    while (y < = len(numbers)) :
    INDENT
        if sum(numbers [x : y]) == 7 :
        INDENT
            result = True
            break
        DEDENT
        x += 1
        y += 1
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40856975_40857209_1_17
40856975_40857906_1_11
Title: "lucky sevens sum of 3 consecutive numbers in array == 7" 
----------------------------------------

def lucky_sevens(numbers) :
INDENT
    if len(numbers) < 3 :
    INDENT
        return False
    DEDENT
    x, y = 0, 3
    sum_of_numbers = sum(numbers [x : y])
    while sum_of_numbers ! = 7 and y < len(numbers) :
    INDENT
        x += 1
        y += 1
        sum_of_numbers = sum(numbers [x : y])
    DEDENT
    if sum_of_numbers == 7 :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def lucky_sevens(numbers) :
INDENT
    x, y = 0, 3
    sum_of_numbers = sum(numbers [x : y])
    while (sum_of_numbers ! = 7) and (y < len(numbers)) :
    INDENT
        x = x + 1
        y = y + 1
        sum_of_numbers = sum(numbers [x : y])
    DEDENT
    if sum_of_numbers == 7 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40856975_40857230_1_12
40856975_40857906_1_11
Title: "lucky sevens sum of 3 consecutive numbers in array == 7" 
----------------------------------------

def lucky_sevens(numbers) :
INDENT
    result = False
    x, y = 0, 3
    while (y < = len(numbers)) :
    INDENT
        if sum(numbers [x : y]) == 7 :
        INDENT
            result = True
            break
        DEDENT
        x += 1
        y += 1
    DEDENT
    return result
DEDENT
----------------------------------------

def lucky_sevens(numbers) :
INDENT
    x, y = 0, 3
    sum_of_numbers = sum(numbers [x : y])
    while (sum_of_numbers ! = 7) and (y < len(numbers)) :
    INDENT
        x = x + 1
        y = y + 1
        sum_of_numbers = sum(numbers [x : y])
    DEDENT
    if sum_of_numbers == 7 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40876816_40877753_1_13
40876816_40877929_1_12
Title: Why does this code not let me just check for an invalid input 
----------------------------------------

def menu_payment() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            burger_count = int(input("burgers: "))
        DEDENT
        except ValueError :
        INDENT
            print ("You must eneter a number for your order. Please try again.")
            continue
        DEDENT
        else :
        INDENT
            if burger_count < = 0 :
            INDENT
                print ("You must eneter a number for your order. Please try again.")
                continue
            DEDENT
            else :
            INDENT
                return burger_count
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def menu_payment() :
INDENT
    burger_count = input("How many burgers would you like:")
    try :
    INDENT
        burger_count = int(burger_count)
        valid_number = 1
    DEDENT
    except :
    INDENT
        print (burger_count, " is not a valid number")
        valid_number = 0
    DEDENT
    if valid_number == 1 and burger_count > 0 :
    INDENT
        print ("I will get your burgers right away")
    DEDENT
    else :
    INDENT
        print ("Please put a valid number and no negetives")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40902081_40902135_4_9
40902081_40906056_4_9
Title: Need help comparing and displaying numbers 
----------------------------------------

def main(list_a, number) :
INDENT
    print ("The Numbers in the list are:", list_a)
    for x in list_a :
    INDENT
        if number < x :
        INDENT
            print (x)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main(list_a, number) :
INDENT
    print ("The numbers in the list are: ", list_a)
    greater_than_x = [x for x in list_a if x > int(number)]
    for y in greater_than_x :
    INDENT
        print (y)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40918917_40918992_6_12
40918917_40919398_10_15
Title: Function That Computes Sum of Squares of Numbers in List 
----------------------------------------

def sum_of_squares(xs) :
INDENT
    sum_of_squares = 0
    for i in (xs) :
    INDENT
        squared = i * i
        sum_of_squares += squared
    DEDENT
    return sum_of_squares
DEDENT
----------------------------------------

def sum_of_squares(xs) :
INDENT
    result = 0
    for i in xs :
    INDENT
        result += i * i
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40922294_40922651_8_28
40922294_40923240_10_26
Title: Dynamic variable from function in Python 
----------------------------------------

def loop_one(self) :
INDENT
    filename = 'Test.csv'
    mycsv = open(filename, 'r')
    mycsv.seek(0, os.SEEK_END)
    while 1 :
    INDENT
        time.sleep(1)
        where = mycsv.tell()
        line = mycsv.readline()
        if not line :
        INDENT
            mycsv.seek(where)
        DEDENT
        else :
        INDENT
            arr_line = line.split(',')
            var1 = arr_line [5]
            mydate = datetime.datetime.now()
            print var1, mydate.strftime("%H:%M:%S:%f")
            return var1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def loop_one(self) :
INDENT
    while 1 :
    INDENT
        time.sleep(1)
        where = self.mycsv.tell()
        line = self.mycsv.readline()
        if not line :
        INDENT
            self.mycsv.seek(where)

        DEDENT
        else :
        INDENT
            arr_line = line.split(',')
            self.var1 = arr_line [5]
            mydate = datetime.datetime.now()
            print self.var1, mydate.strftime("%H:%M:%S:%f")
            return self.var1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40932639_40934044_30_37
40932639_40934044_7_17
Title: pyqt: messagebox automatically closing after few seconds 
----------------------------------------

def __init__(self) :
INDENT
    super(Example, self).__init__()
    btn = QtGui.QPushButton('Button', self)
    btn.resize(btn.sizeHint())
    btn.move(50, 50)
    self.setWindowTitle('Example')
    btn.clicked.connect(self.warning)
DEDENT
----------------------------------------

def __init__(self, timeout = 3, parent = None) :
INDENT
    super(TimerMessageBox, self).__init__(parent)
    self.setWindowTitle("wait")
    self.time_to_wait = timeout
    self.setText("wait (closing automatically in {0} secondes.)".format(timeout))
    self.setStandardButtons(QtGui.QMessageBox.NoButton)
    self.timer = QtCore.QTimer(self)
    self.timer.setInterval(1000)
    self.timer.timeout.connect(self.changeContent)
    self.timer.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40940874_40940953_1_14
40940874_40941319_5_14
Title: Why does the if statement get bypassed? 
----------------------------------------

def nuc_ac_check(string) :
INDENT
    input_string = string.upper()
    rna_letter = ['A', 'C', 'G', 'U']
    dna_letter = ['A', 'C', 'G', 'T']
    if ('D') in input_string :
    INDENT
        return "not an unambigious nucleic acid"
    DEDENT
    elif all(letter in rna_letter for letter in input_string) :
    INDENT
        return "Rna"
    DEDENT
    elif all(letter in dna_letter for letter in input_string) :
    INDENT
        return "Dna"
    DEDENT
    return "Nothing of everything above"
DEDENT
----------------------------------------

def nuc_ac_check(string) :
INDENT
    str_set = set(string.upper())
    if str_set - nucleotide_set ! = set() :
    INDENT
        return "Not an unambiguous nucleic acid"
    DEDENT
    if str_set == rna_set :
    INDENT
        return "RNA"
    DEDENT
    if str_set == dna_set :
    INDENT
        return "DNA"
    DEDENT
    return "Not DNA or RNA"
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40940874_40940953_1_14
40940874_40941551_4_14
Title: Why does the if statement get bypassed? 
----------------------------------------

def nuc_ac_check(string) :
INDENT
    input_string = string.upper()
    rna_letter = ['A', 'C', 'G', 'U']
    dna_letter = ['A', 'C', 'G', 'T']
    if ('D') in input_string :
    INDENT
        return "not an unambigious nucleic acid"
    DEDENT
    elif all(letter in rna_letter for letter in input_string) :
    INDENT
        return "Rna"
    DEDENT
    elif all(letter in dna_letter for letter in input_string) :
    INDENT
        return "Dna"
    DEDENT
    return "Nothing of everything above"
DEDENT
----------------------------------------

def nuc_ac_check(string) :
INDENT
    d_r_na = set(string.upper())
    if d_r_na == DNA :
    INDENT
        return "DNA"
    DEDENT
    elif d_r_na == RNA :
    INDENT
        return "RNA"
    DEDENT
    else :
    INDENT
        return "not an unambiguous nucleotide"

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40940874_40941319_5_14
40940874_40941551_4_14
Title: Why does the if statement get bypassed? 
----------------------------------------

def nuc_ac_check(string) :
INDENT
    str_set = set(string.upper())
    if str_set - nucleotide_set ! = set() :
    INDENT
        return "Not an unambiguous nucleic acid"
    DEDENT
    if str_set == rna_set :
    INDENT
        return "RNA"
    DEDENT
    if str_set == dna_set :
    INDENT
        return "DNA"
    DEDENT
    return "Not DNA or RNA"
DEDENT
----------------------------------------

def nuc_ac_check(string) :
INDENT
    d_r_na = set(string.upper())
    if d_r_na == DNA :
    INDENT
        return "DNA"
    DEDENT
    elif d_r_na == RNA :
    INDENT
        return "RNA"
    DEDENT
    else :
    INDENT
        return "not an unambiguous nucleotide"

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40951199_40951385_1_20
40951199_40951432_1_18
Title: Reading a file into a dictionary python 
----------------------------------------

def read_file(file) :
INDENT
    dic = {}
    lst = []
    with open(file, 'r') as file :
    INDENT
        temp = []
        key = None
        for line in file :
        INDENT
            line = line.strip()
            if line == "<<<END" :
            INDENT
                dic [key].append(tuple([key] + temp))
                temp = []
                continue
            DEDENT
            elif line.endswith(":") :
            INDENT
                key = line.strip(":")
                dic [key] = []
            DEDENT
            else :
            INDENT
                temp.append(line)
            DEDENT
        DEDENT
        return dic

    DEDENT
DEDENT
----------------------------------------

def read_file(file) :
INDENT
    dic = {}
    lst = []
    same_dict = False
    with open(file, 'r') as file :
    INDENT
        for line in file :
        INDENT
            if line.endswith(":\n") :
            INDENT
                a = line.strip(":\n")
                dic [a] = []
            DEDENT
            else :
            INDENT
                if line.strip("\n") == "<<<END" :
                INDENT
                    dic [a].append(tuple([a] + lst))
                    lst = []
                DEDENT
                else :
                INDENT
                    key = line.strip("\n")
                    lst.append(key)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return dic
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40951199_40951385_1_20
40951199_40951749_1_21
Title: Reading a file into a dictionary python 
----------------------------------------

def read_file(file) :
INDENT
    dic = {}
    lst = []
    with open(file, 'r') as file :
    INDENT
        temp = []
        key = None
        for line in file :
        INDENT
            line = line.strip()
            if line == "<<<END" :
            INDENT
                dic [key].append(tuple([key] + temp))
                temp = []
                continue
            DEDENT
            elif line.endswith(":") :
            INDENT
                key = line.strip(":")
                dic [key] = []
            DEDENT
            else :
            INDENT
                temp.append(line)
            DEDENT
        DEDENT
        return dic

    DEDENT
DEDENT
----------------------------------------

def read_file(path) :
INDENT
    d = {}
    with open(path, 'r') as f :
    INDENT
        lines = f.read().splitlines()
        group = None
        parts = []
        for line in lines :
        INDENT
            if line.endswith(":") :
            INDENT
                group = line [: - 1]
                d [group] = []
            DEDENT
            else :
            INDENT
                if line == "<<<END" :
                INDENT

                    d [group].append(tuple(parts))
                    parts = []
                DEDENT
                else :
                INDENT

                    k = line [: - 1]
                    parts.append(line)
                DEDENT
            DEDENT
        DEDENT
        return d
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40963583_40965147_5_13
40963583_40966189_5_13
Title: python code using re or beatifulsoup 
----------------------------------------

def open(url) :
INDENT
    req = urllib2.Request(url)
    req.add_header('User-agent', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:19.0) Gecko/20100101 Firefox/19.0')
    response = urllib2.urlopen(req)
    link = response.read()
    response.close()
    return link

DEDENT
----------------------------------------

def open(url) :
INDENT
    req = urllib2.Request(url)
    req.add_header('User-agent', 'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:19.0) Gecko/20100101 Firefox/19.0')
    response = urllib2.urlopen(req)
    link = response.read()
    response.close()
    return link

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40966908_40970521_44_57
40966908_40970521_60_69
Title: Multiple windows size for multiple frame in tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Go to Page Two",
        command = lambda : controller.show_frame("PageTwo"))
    button1.pack()
    button2.pack()

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 1", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40966908_40970521_44_57
40966908_40970521_72_81
Title: Multiple windows size for multiple frame in tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Go to Page Two",
        command = lambda : controller.show_frame("PageTwo"))
    button1.pack()
    button2.pack()

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 2", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40966908_40970521_44_57
40966908_40970521_8_32
Title: Multiple windows size for multiple frame in tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is the start page", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button1 = tk.Button(self, text = "Go to Page One",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Go to Page Two",
        command = lambda : controller.show_frame("PageTwo"))
    button1.pack()
    button2.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F, geometry in zip((StartPage, PageOne, PageTwo), ('300x300', '500x500', '800x500')) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = (frame, geometry)

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40966908_40970521_60_69
40966908_40970521_8_32
Title: Multiple windows size for multiple frame in tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 1", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F, geometry in zip((StartPage, PageOne, PageTwo), ('300x300', '500x500', '800x500')) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = (frame, geometry)

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40966908_40970521_72_81
40966908_40970521_8_32
Title: Multiple windows size for multiple frame in tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 2", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F, geometry in zip((StartPage, PageOne, PageTwo), ('300x300', '500x500', '800x500')) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = (frame, geometry)

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40974292_40979644_13_23
40974292_40992783_12_44
Title: wxpython panel fullscreen? 
----------------------------------------

def onKey(self, event) :
INDENT
    key_code = event.GetKeyCode()
    if key_code == wx.WXK_ESCAPE :
    INDENT
        self.GetParent().Close()
    DEDENT
    else :
    INDENT
        event.Skip()

    DEDENT
DEDENT
----------------------------------------

def onKey(self, event) :
INDENT
    key_code = event.GetKeyCode()
    parent = self.GetParent()
    width, height = wx.GetDisplaySize()
    if key_code == wx.WXK_ESCAPE :
    INDENT
        self.GetParent().Close()
    DEDENT
    elif key_code == wx.WXK_F1 :
    INDENT
        parent.panel1.SetMinSize((1, 1))
        parent.panel2.SetMinSize((width, height))
        parent.SendSizeEvent()
        parent.Layout()
        parent.Fit()
    DEDENT
    elif key_code == wx.WXK_F2 :
    INDENT
        parent.panel2.SetMinSize((1, 1))
        parent.panel1.SetMinSize((width, height))
        parent.SendSizeEvent()
        parent.Layout()
        parent.Fit()
    DEDENT
    elif key_code == wx.WXK_F3 :
    INDENT
        parent.panel2.SetMinSize((120, 70))
        parent.panel1.SetMinSize((120, 70))
        parent.SendSizeEvent()
        parent.Layout()
        parent.Fit()
    DEDENT
    else :
    INDENT
        event.Skip()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40985421_40985515_1_8
40985421_40985633_1_7
Title: Function for counting words of i or more vowels in Python? 
----------------------------------------

def vowelCount(s) :
INDENT
    vowels = 'aeiou'
    countVowels = 0
    for letter in s.lower() :
    INDENT
        if letter in vowels :
        INDENT
            countVowels += 1
        DEDENT
    DEDENT
    return countVowels
DEDENT
----------------------------------------

def vowelCount(s) :
INDENT
    num_vowels = 0
    for char in s :
    INDENT
        if char in "aeiouAEIOU" :
        INDENT
            num_vowels = num_vowels + 1
        DEDENT
    DEDENT
    return num_vowels
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4099042_4099335_2_8
4099042_4099502_1_15
Title: Sequence of vowels count 
----------------------------------------

def syllables(word) :
INDENT
    word = word.lower()
    if word.endswith('e') :
    INDENT
        word = word [: - 1]
    DEDENT
    count = len(re.findall('[aeiou]+', word))
    return count
DEDENT
----------------------------------------

def syllables(word) :
INDENT
    word = word.lower()
    if word.endswith('e') :
    INDENT
        word = word [: - 1]
    DEDENT
    vowels = 'aeiou'
    in_vowel_group = False
    vowel_groups = 0
    for letter in word :
    INDENT
        if letter in vowels :
        INDENT
            if not in_vowel_group :
            INDENT
                in_vowel_group = True
                vowel_groups += 1
            DEDENT
        DEDENT
        else :
        INDENT
            in_vowel_group = False
        DEDENT
    DEDENT
    return vowel_groups
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
40994583_47448130_1_13
40994583_51709242_5_29
Title: how to implement tensorflow's next_batch for own data 
----------------------------------------

def next_batch(num, data, labels) :
INDENT
    '''
    Return a total of `num` random samples and labels. 
    '''
    idx = np.arange(0, len(data))
    np.random.shuffle(idx)
    idx = idx [: num]
    data_shuffle = data [idx]
    labels_shuffle = labels [idx]
    labels_shuffle = np.asarray(labels_shuffle.values.reshape(len(labels_shuffle), 1))
    return data_shuffle, labels_shuffle
DEDENT
----------------------------------------

def next_batch(batch_size) :
INDENT
    global X_train
    global y_train
    global index_in_epoch
    global epochs_completed
    start = index_in_epoch
    index_in_epoch += batch_size

    if index_in_epoch > num_examples :
    INDENT

        epochs_completed += 1
        perm = np.arange(num_examples)
        np.random.shuffle(perm)
        X_train = X_train [perm]
        y_train = y_train [perm]
        start = 0
        index_in_epoch = batch_size
        assert batch_size < = num_examples
    DEDENT
    end = index_in_epoch
    return X_train [start : end], y_train [start : end]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41005388_41005626_3_12
41005388_41005939_4_12
Title: Reducing the run time of a loop and increasing its efficiency 
----------------------------------------

def choose_letter(words, pattern) :
INDENT
    pattern = set(pattern)
    letters = (letter for word in words
        for letter in word
        if letter not in pattern)
    letters = Counter(letters)
    return letters.most_common(1) [0] [0]

DEDENT
----------------------------------------

def choose_letter(words, pattern = "") :
INDENT
    count_dict = defaultdict(int)
    for c in chain(* words) :
    INDENT
        count_dict [c] += 1
    DEDENT
    filtered = [(char, count) for (char, count) in count_dict.items() if char not in pattern]
    filtered.sort(lambda a, b : - cmp(a [0], b [0]))
    print filtered
    return filtered [0] [0]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41007429_41073030_11_25
41007429_41073030_50_57
Title: "How to create a composite strategy using multiple instruments in Pyalgotrade?" 
----------------------------------------

def onBars(self, bars) :
INDENT
    bar = bars.getBar(self.instrument)
    if bar :
    INDENT
        self.__PPO = talibext.indicator.PPO(self.__prices, len(self.__prices), 12, 26, matype = 1)
        try : slope = talib.LINEARREG_SLOPE(self.__PPO, 3) [- 1]
        except Exception : slope = np.nan
        print ("%s,%s,%s" % (bar.getClose(), self.__PPO [- 1], slope))
        if self.__PPO [- 1] is None :
        INDENT
            return
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def onBars(self, bars) :
INDENT
    self.updateInstManagers(bars)
    for inst in self.__instruments :
    INDENT
        instManager = self.instManagers [inst]
        print inst
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41041661_41042882_46_58
41041661_41042882_60_68
Title: "Node editor adding child QWidget another QWidget at run time" 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Node.__init__(self, parent)
    self.resize(150, 100)
    title = QtGui.QLabel("Hosts")
    getAssigned = QtGui.QRadioButton("Assigned")
    getHostNames = QtGui.QRadioButton("Host Names")
    getHostNames.setLayoutDirection(QtCore.Qt.RightToLeft)
    self.frameLayout.addWidget(title)
    self.frameLayout.addWidget(getAssigned)
    self.frameLayout.addWidget(getHostNames)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMainWindow.__init__(self)
    self.resize(640, 480)
    self.buildMenu()
    self.nodes = []
    self.addHostsTrigger()
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.contextMenuEvent)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41041661_41042882_46_58
41041661_41042882_6_17
Title: "Node editor adding child QWidget another QWidget at run time" 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Node.__init__(self, parent)
    self.resize(150, 100)
    title = QtGui.QLabel("Hosts")
    getAssigned = QtGui.QRadioButton("Assigned")
    getHostNames = QtGui.QRadioButton("Host Names")
    getHostNames.setLayoutDirection(QtCore.Qt.RightToLeft)
    self.frameLayout.addWidget(title)
    self.frameLayout.addWidget(getAssigned)
    self.frameLayout.addWidget(getHostNames)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    widLwayout = QtGui.QVBoxLayout()
    self.setLayout(widLwayout)
    self.frame = QtGui.QFrame()
    self.frameLayout = QtGui.QVBoxLayout()
    self.frame.setLayout(self.frameLayout)
    self.frame.setStyleSheet("background-color: rgb(220, 220, 220)")
    widLwayout.addWidget(self.frame)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41041661_41042882_60_68
41041661_41042882_6_17
Title: "Node editor adding child QWidget another QWidget at run time" 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMainWindow.__init__(self)
    self.resize(640, 480)
    self.buildMenu()
    self.nodes = []
    self.addHostsTrigger()
    self.setContextMenuPolicy(QtCore.Qt.CustomContextMenu)
    self.customContextMenuRequested.connect(self.contextMenuEvent)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    widLwayout = QtGui.QVBoxLayout()
    self.setLayout(widLwayout)
    self.frame = QtGui.QFrame()
    self.frameLayout = QtGui.QVBoxLayout()
    self.frame.setLayout(self.frameLayout)
    self.frame.setStyleSheet("background-color: rgb(220, 220, 220)")
    widLwayout.addWidget(self.frame)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41058952_41064306_36_42
41058952_41064737_56_67
Title: "python: using threading  apply thread timeout" 
----------------------------------------

def scrape() :
INDENT
    queued_links = Date_set
    if len(queued_links) > 0 :
    INDENT
        print (str(len(queued_links)) + ' days in the queue')
        create_jobs()

    DEDENT
DEDENT
----------------------------------------

def scrape() :
INDENT
    queued_links = Date_set
    if len(queued_links) > 0 :
    INDENT
        print (str(len(queued_links)) + ' days in the queue')
        create_jobs()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41069141_41069336_13_21
41069141_41069405_11_18
Title: Pythonic way to return a boolean value and a message 
----------------------------------------

def worker() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            service_string = findService()
        DEDENT
        except NoRunningService :
        INDENT
            print ('Continuing on')
        DEDENT
        else :
        INDENT
            print ('{} found; skipping'.format(service_string))
        DEDENT
        time.sleep(10)
    DEDENT
DEDENT
----------------------------------------

def worker() :
INDENT
    while True :
    INDENT
        service_string = processGroupFound()
        if service_string :
        INDENT
            print ('{} found; skipping'.format(service_string))
        DEDENT
        else :
        INDENT
            print ('Continuing on')
        DEDENT
        time.sleep(10)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41070918_41107588_5_14
41070918_41268967_5_31
Title: Change background color of a Canvas ScaledText 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, * args, ** kwargs)
    self.canvas = FloatCanvas.FloatCanvas(self, BackgroundColor = "black")
    MainSizer = wx.BoxSizer(wx.VERTICAL)
    MainSizer.Add(self.canvas, 4, wx.EXPAND)
    self.SetSizer(MainSizer)
    self.A = self.canvas.AddScaledTextBox('yoda', (0, 0), Position = 'tl', Alignment = 'center', PadSize = 10, Size = 15, Width = 150, BackgroundColor = 'white')
    self.A.Bind(FloatCanvas.EVT_FC_LEFT_DOWN, self.OnRectDown)
    wx.CallAfter(self.canvas.ZoomToBB)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, * args, ** kwargs)
    self.canvas = FloatCanvas.FloatCanvas(self, BackgroundColor = "black")
    MainSizer = wx.BoxSizer(wx.VERTICAL)
    MainSizer.Add(self.canvas, 4, wx.EXPAND)
    self.SetSizer(MainSizer)
    self.box = self.canvas.AddScaledTextBox("A Two Line\nString",
        (0, 10),
        2,
        BackgroundColor = "Yellow",
        LineColor = "Red",
        LineStyle = "Solid",
        PadSize = 5,
        Family = wx.TELETYPE,
        Position = 'bl')
    self.box2 = self.canvas.AddScaledTextBox("Second Box",
        (0, 0),
        2,
        BackgroundColor = "Yellow",
        LineColor = "Red",
        LineStyle = "Solid",
        PadSize = 5,
        Family = wx.TELETYPE,
        Position = 'bl')
    self.box.Bind(FloatCanvas.EVT_FC_LEFT_DOWN, self.OnRectDown)
    wx.CallAfter(self.canvas.ZoomToBB)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41071290_41071961_1_19
41071290_41071973_1_10
Title: Find the first missing positive integer in Python 
----------------------------------------

def firstMissingPositive(A) :
INDENT
    m = max(A)
    ln = len(A)
    print ('max:{}, len:{}'.format(m, ln))
    i = 0
    while i < ln :
    INDENT
        if A [i] > = 1 and A [i] < = ln :
        INDENT
            if A [A [i] - 1] ! = m + 1 :
            INDENT

                v = A [i] - 1
                A [i], A [v] = A [v], m + 1
            DEDENT
            else :
            INDENT
                i += 1
            DEDENT
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
    for i in range(ln) :
    INDENT
        if A [i] ! = m + 1 :
        INDENT
            return i + 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def firstMissingPositive(A) :
INDENT
    for i in range(len(A)) :
    INDENT
        while A [i] ! = i + 1 and 0 < A [i] < len(A) :
        INDENT
            value = A [i] - 1
            A [i], A [value] = A [value], A [i]
        DEDENT
    DEDENT
    for i, value in enumerate(A, 1) :
    INDENT
        if i ! = value :
        INDENT
            return i
        DEDENT
    DEDENT
    return len(A) + 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41071290_41071961_1_19
41071290_41111817_3_13
Title: Find the first missing positive integer in Python 
----------------------------------------

def firstMissingPositive(A) :
INDENT
    m = max(A)
    ln = len(A)
    print ('max:{}, len:{}'.format(m, ln))
    i = 0
    while i < ln :
    INDENT
        if A [i] > = 1 and A [i] < = ln :
        INDENT
            if A [A [i] - 1] ! = m + 1 :
            INDENT

                v = A [i] - 1
                A [i], A [v] = A [v], m + 1
            DEDENT
            else :
            INDENT
                i += 1
            DEDENT
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
    for i in range(ln) :
    INDENT
        if A [i] ! = m + 1 :
        INDENT
            return i + 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def firstMissingPositive(A) :
INDENT
    d = defaultdict(int)
    for i in A :
    INDENT
        d [i] = 1
    DEDENT
    j = 1
    while True :
    INDENT
        if d [j] == 0 :
        INDENT
            return j
        DEDENT
        j += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41071290_41071973_1_10
41071290_41111817_3_13
Title: Find the first missing positive integer in Python 
----------------------------------------

def firstMissingPositive(A) :
INDENT
    for i in range(len(A)) :
    INDENT
        while A [i] ! = i + 1 and 0 < A [i] < len(A) :
        INDENT
            value = A [i] - 1
            A [i], A [value] = A [value], A [i]
        DEDENT
    DEDENT
    for i, value in enumerate(A, 1) :
    INDENT
        if i ! = value :
        INDENT
            return i
        DEDENT
    DEDENT
    return len(A) + 1
DEDENT
----------------------------------------

def firstMissingPositive(A) :
INDENT
    d = defaultdict(int)
    for i in A :
    INDENT
        d [i] = 1
    DEDENT
    j = 1
    while True :
    INDENT
        if d [j] == 0 :
        INDENT
            return j
        DEDENT
        j += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41080985_41087450_15_44
41080985_41087450_53_103
Title: Why I cannot add anything using grid() after the canava plot? and how could I make the plot expand 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.title(self, "mosh_GUI")

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    menubar = tk.Menu(container)
    filemenu = tk.Menu(menubar, tearoff = 0)
    filemenu.add_command(label = "New Experiment", command = lambda : popupmsg("that is not defined yet"))
    filemenu.add_separator()
    filemenu.add_command(label = "Run From a File", command = quit)
    filemenu.add_separator()
    filemenu.add_command(label = "Exit", command = quit)
    menubar.add_cascade(label = "File", menu = filemenu)
    tk.Tk.config(self, menu = menubar)
    self.frames = {}
    for F in (Startpage,) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(Startpage)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)

    button1 = ttk.Button(self, text = "Plot1",
        command = lambda : controller.show_frame(Page1))
    button1.grid(row = 0, column = 0)

    button2 = ttk.Button(self, text = "Plot2",
        command = lambda : controller.show_frame(Page1))
    button2.grid(row = 0, column = 1)

    button3 = ttk.Button(self, text = "Plot3",
        command = lambda : controller.show_frame(Page1))
    button3.grid(row = 0, column = 2)

    button4 = ttk.Button(self, text = "Plot4",
        command = lambda : controller.show_frame(Page1))
    button4.grid(row = 0, column = 3)

    f = Figure(figsize = (5, 4), dpi = 100)
    a = f.add_subplot(111)
    t = arange(0.0, 3.0, 0.01)
    s = sin(2 * pi * t)
    a.plot(t, s)
    fr = tk.Frame(self)
    fr.grid(row = 1, column = 0, columnspan = 4)
    canvas = FigureCanvasTkAgg(f, master = fr)
    canvas.show()
    canvas.get_tk_widget().pack()
    toolbar = NavigationToolbar2TkAgg(canvas, fr)
    toolbar.update()
    canvas._tkcanvas.pack()

    textbox1 = tk.Entry(self, width = 75)
    textbox1.grid(row = 2, column = 0, columnspan = 4)
    textbox1.insert('end', "Hello World! --- Hello Tkinter! --- Hello Matplotlib!")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41082490_41082911_1_33
41082490_41082969_1_37
Title: How do I combine similar elements in a list in python? 
----------------------------------------

def combine_channels(channels, dist) :
INDENT
    result = {}
    replacements = {}
    groups = []
    group = []
    key = None

    for channel, count in sorted((int(k), v) for k, v in channels.items()) :
    INDENT
        if group and channel - key > dist :
        INDENT
            groups.append((key, group))
            group = []
            key = None

        DEDENT
        group.append((channel, count))

        if key is None or channel - group [0] [0] < = dist :
        INDENT
            key = channel

        DEDENT
    DEDENT
    if group :
    INDENT
        groups.append((key, group))
    DEDENT
    for key, group in groups :
    INDENT
        result [key] = sum(x [1] for x in group)
        replacements [key] = [x [0] for x in group if x [0] ! = key]
    DEDENT
    return result, replacements
DEDENT
----------------------------------------

def combine_channels(lst, max_dist) :
INDENT
    colors = list(set(lst))
    counts = dict()
    replacements = dict()
    all_repl = []
    for el in lst :
    INDENT
        counts [el] = counts.get(el, 0) + 1
    DEDENT
    N = len(colors)
    dists = np.zeros((N, N))
    for i in range(N - 1) :
    INDENT
        for j in range(i + 1, N) :
        INDENT
            dist = abs(colors [i] - colors [j])
            dists [i, j] = dist
            if (dist < max_dist) :
            INDENT
                if (colors [i] in all_repl or colors [j] in all_repl) :
                INDENT
                    continue
                DEDENT
                else :
                INDENT
                    if (counts.get(colors [i], 0) > counts.get(colors [j], 0)) :
                    INDENT
                        winner = colors [i]
                        loser = colors [j]
                    DEDENT
                    else :
                    INDENT
                        winner = colors [j]
                        loser = colors [i]
                    DEDENT
                DEDENT
                counts [winner] += counts.get(loser, 0)
                counts [loser] = 0
                if winner not in replacements :
                INDENT
                    replacements [winner] = list()
                DEDENT
                replacements [winner].append(loser)
                all_repl.append(loser)
                if loser not in replacements :
                INDENT
                    continue
                DEDENT
                else :
                INDENT
                    replacements [winner] = replacements [winner].extend(replacements [loser])
                    replacements.pop(loser, None)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    print (replacements)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41086016_41086157_10_17
41086016_41086467_6_21
Title: Getting tkinter.Entry input into if/else statements 
----------------------------------------

def on_button() :
INDENT
    if entry.get() == "Screen" or entry.get() == "screen" :
    INDENT
        slabel = tkinter.Label(root, text = "Screen was entered")
        slabel.pack()
    DEDENT
    else :
    INDENT
        tlabel = tkinter.Label(root, text = "")
        tlabel.pack()
    DEDENT
DEDENT
----------------------------------------

def on_button(event = None) :
INDENT
    answer = entry.get().strip().lower()
    if answer in ("screen", "monitor") :
    INDENT

        label ['text'] = "Your {} is dirty. I can't see you.".format(answer)
    DEDENT
    elif answer in ("mouse", "trackball") :
    INDENT
        label ['text'] = "Your {} is too slow for me".format(answer)
    DEDENT
    else :
    INDENT
        label ['text'] = "{0}? What is {0}?".format(answer)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41099274_41099340_1_19
41099274_41099711_1_41
Title: Python product of infinite generators 
----------------------------------------

def product(gen1, gen2) :
INDENT
    gc1 = GenCacher(gen1)
    gc2 = GenCacher(gen2)
    idx1 = idx2 = 0
    moving_up = True
    while True :
    INDENT
        yield (gc1 [idx1], gc2 [idx2])
        if moving_up and idx1 == 0 :
        INDENT
            idx2 += 1
            moving_up = False
        DEDENT
        elif not moving_up and idx2 == 0 :
        INDENT
            idx1 += 1
            moving_up = True
        DEDENT
        elif moving_up :
        INDENT
            idx1, idx2 = idx1 - 1, idx2 + 1
        DEDENT
        else :
        INDENT
            idx1, idx2 = idx1 + 1, idx2 - 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def product(i, j) :
INDENT
    earlier_values_i = []
    earlier_values_j = []

    next_i = next(i)
    next_j = next(j)
    found_i = found_j = True
    while True :
    INDENT
        if found_i and found_j :
        INDENT
            yield (next_i, next_j)
        DEDENT
        elif not found_i and not found_j :
        INDENT
            break
        DEDENT
        if found_i :
        INDENT
            for jj in earlier_values_j :
            INDENT
                yield (next_i, jj)
            DEDENT
        DEDENT
        if found_j :
        INDENT
            for ii in earlier_values_i :
            INDENT
                yield (ii, next_j)
            DEDENT
        DEDENT
        if found_i :
        INDENT
            earlier_values_i.append(next_i)
        DEDENT
        if found_j :
        INDENT
            earlier_values_j.append(next_j)
        DEDENT
        try :
        INDENT
            next_i = next(i)
            found_i = True
        DEDENT
        except StopIteration :
        INDENT
            found_i = False
        DEDENT
        try :
        INDENT
            next_j = next(j)
            found_j = True
        DEDENT
        except StopIteration :
        INDENT
            found_j = False
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41101662_41103994_24_31
41101662_41103994_37_52
Title: Typewriter Effect Pygame 
----------------------------------------

def __init__(self) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface((WIDTH, HEIGHT))
    self.image.fill((13, 13, 13))
    self.image.set_colorkey((13, 13, 13))
    self.rect = self.image.get_rect()
    self.font = pygame.font.SysFont("monospace", 18)
DEDENT
----------------------------------------

def __init__(self, board) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface((10, 20))
    self.image.fill((0, 255, 0))
    self.text_height = 17
    self.text_width = 10
    self.rect = self.image.get_rect(topleft = (self.text_width, self.text_height))
    self.board = board
    self.text = ''
    self.cooldown = 0
    self.cooldowns = {'.' : 12,
        '[' : 18,
        ']' : 18,
        ' ' : 5,
        '\n' : 30}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41103148_43008266_64_92
41103148_43008266_6_22
Title: Capture webcam video using PyQt 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QWidget.__init__(self)
    self.capture = None
    self.start_button = QtGui.QPushButton('Start')
    self.start_button.clicked.connect(self.startCapture)
    self.quit_button = QtGui.QPushButton('End')
    self.quit_button.clicked.connect(self.endCapture)
    self.end_button = QtGui.QPushButton('Stop')

    self.capture_button = QtGui.QPushButton('Capture')
    self.capture_button.clicked.connect(self.saveCapture)

    vbox = QtGui.QVBoxLayout(self)
    vbox.addWidget(self.start_button)
    vbox.addWidget(self.end_button)
    vbox.addWidget(self.quit_button)

    vbox.addWidget(self.capture_button)

    self.setLayout(vbox)
    self.setWindowTitle('Control Panel')
    self.setGeometry(100, 100, 200, 200)
    self.show()
DEDENT
----------------------------------------

def __init__(self, * args) :
INDENT
    super(QtGui.QWidget, self).__init__()
    self.fps = 24
    self.cap = cv2.VideoCapture(* args)
    self.video_frame = QtGui.QLabel()
    lay = QtGui.QVBoxLayout()
    lay.setMargin(0)
    lay.addWidget(self.video_frame)
    self.setLayout(lay)

    self.isCapturing = False
    self.ith_frame = 1

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41107626_41107694_1_13
41107626_41107951_1_10
Title: Python Check list line by line 
----------------------------------------

def searchWordlist() :
INDENT
    path = str(raw_input(PATH))
    word = str(raw_input(WORD))
    loc = - 1
    with open(path) as f :
    INDENT
        for i, line in enumerate(f) :
        INDENT
            if word in line :
            INDENT
                loc = i
                break
            DEDENT
        DEDENT
    DEDENT
    if loc > = 0 :
    INDENT
        print ("Word found at line {}".format(loc))
    DEDENT
    else :
    INDENT
        print ("Word not found")
    DEDENT
DEDENT
----------------------------------------

def searchWordlist() :
INDENT
    path = str(raw_input(PATH))
    word = str(raw_input(WORD))
    with open(path) as f :
    INDENT
        for line in f :
        INDENT
            if word in line :
            INDENT
                print "Word found"
                return 1
            DEDENT
        DEDENT
    DEDENT
    print "Word not found"
    return 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41107626_41107694_1_13
41107626_41108614_1_11
Title: Python Check list line by line 
----------------------------------------

def searchWordlist() :
INDENT
    path = str(raw_input(PATH))
    word = str(raw_input(WORD))
    loc = - 1
    with open(path) as f :
    INDENT
        for i, line in enumerate(f) :
        INDENT
            if word in line :
            INDENT
                loc = i
                break
            DEDENT
        DEDENT
    DEDENT
    if loc > = 0 :
    INDENT
        print ("Word found at line {}".format(loc))
    DEDENT
    else :
    INDENT
        print ("Word not found")
    DEDENT
DEDENT
----------------------------------------

def searchWordlist() :
INDENT
    found_word = False
    path = str(raw_input(PATH))
    word = str(raw_input(WORD))
    with open(path) as f :
    INDENT
        for line in f :
        INDENT
            if word in line :
            INDENT
                print "Word found"
                found_word = True
            DEDENT
        DEDENT
    DEDENT
    if not found_word :
    INDENT
        print "Word not found!"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41113757_41113838_35_52
41113757_41113838_77_104
Title: "TypeError: list indices must be integers or slices not Coordinate" 
----------------------------------------

def __str__(self) :
INDENT
    if self.fish :
    INDENT
        if self.contains_line :
        INDENT
            result = self.fish [0] + '*'
        DEDENT
        else :
        INDENT
            result = self.fish [0]
        DEDENT
    DEDENT
    else :
    INDENT
        if self.contains_line :
        INDENT
            result = '*'
        DEDENT
        else :
        INDENT
            result = ' '
        DEDENT
    DEDENT
    return result

DEDENT
----------------------------------------

def __str__(self) :
INDENT
    str1 = '  | ' + ' | '.join([str(i) for i in range(len(self.grid [0]))]) + ' |\n'
    str1 += '-' * 12 + '\n'
    for i, k in enumerate(self.grid) :
    INDENT
        str1 += ' {0}| '.format(i)
        for j in k :
        INDENT
            str1 += '{0} | '.format(j)
        DEDENT
        str1 += '\n'
        str1 += '-' * 12 + '\n'
    DEDENT
    return (str1)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41131568_41135290_1_10
41131568_41143190_1_14
Title: Puzzle: Distributing money to a team 
----------------------------------------

def smallest_group(total) :
INDENT
    pile = total
    men = 0
    while True :
    INDENT
        if (pile - 2 ** men) > = 0 :
        INDENT
            pile = pile - 2 ** men
            men += 1
        DEDENT
        else :
        INDENT
            return men
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def smallest_group(total) :
INDENT
    pile = total
    men = 0
    while True :
    INDENT
        if (pile - 2 ** men) > = 0 :
        INDENT
            pile = pile - 2 ** men
            men += 1
        DEDENT
        else :
        INDENT
            lowest = 2 ** (men - 1) + 2 ** (men - 2)
            if pile > = lowest :
            INDENT
                return men
            DEDENT
            else :
            INDENT
                return men
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4114167_17377939_3_14
4114167_4114189_1_13
Title: Checking if a number is a prime number in Python 
----------------------------------------

def is_prime(n) :
INDENT
    if n == 2 :
    INDENT
        return True
    DEDENT
    if n % 2 == 0 or n < = 1 :
    INDENT
        return False
    DEDENT
    sqr = int(math.sqrt(n)) + 1
    for divisor in range(3, sqr, 2) :
    INDENT
        if n % divisor == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def is_prime(a) :
INDENT
    x = True
    for i in range(2, a) :
    INDENT
        if a % i == 0 :
        INDENT
            x = False
            break
        DEDENT
    DEDENT
    if x :
    INDENT
        print "prime"
    DEDENT
    else :
    INDENT
        print "not prime"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41153803_41154400_6_28
41153803_41155020_4_62
Title: Zero padding slice past end of array in numpy 
----------------------------------------

def __getitem__(self, val) :
INDENT
    required_shape = []
    for i in range(2) :
    INDENT
        start = val [i].start
        if not start :
        INDENT
            start = 0
        DEDENT
        required_shape.append(val [i].stop - start)
    DEDENT
    get = self._array [val]

    while get.shape [0] < required_shape [0] :
    INDENT
        get = np.concatenate((get, np.zeros((1, get.shape [1]))))

    DEDENT
    get = get.T
    while get.shape [0] < required_shape [1] :
    INDENT
        get = np.concatenate((get, np.zeros((1, get.shape [1]))))
    DEDENT
    get = get.T
    return get
DEDENT
----------------------------------------

def __getitem__(self, item) :
INDENT
    all_in_slices = []
    pad = []
    for dim in range(self.ndim) :
    INDENT
        try :
        INDENT
            len(item)
        DEDENT
        except TypeError :
        INDENT
            if isinstance(item, int) :
            INDENT
                return super().__getitem__(item)
            DEDENT
            newitem = [slice(None)] * self.ndim
            newitem [0] = item
            item = newitem
        DEDENT
        if dim > = len(item) :
        INDENT
            all_in_slices.append(slice(0, self.shape [dim]))
            pad.append((0, 0))

        DEDENT
        if isinstance(item [dim], int) :
        INDENT
            all_in_slices.append(slice(item [dim], item [dim] + 1))
            pad.append((0, 0))

        DEDENT
        elif isinstance(item [dim], slice) :
        INDENT

            start, stop = 0, self.shape [dim]
            this_pad = [0, 0]
            if item [dim].start is None :
            INDENT
                start = 0
            DEDENT
            else :
            INDENT
                if item [dim].start < 0 :
                INDENT
                    this_pad [0] = - item [dim].start
                    start = 0
                DEDENT
                else :
                INDENT
                    start = item [dim].start
                DEDENT
            DEDENT
            if item [dim].stop is None :
            INDENT
                stop = self.shape [dim]
            DEDENT
            else :
            INDENT
                if item [dim].stop > self.shape [dim] :
                INDENT
                    this_pad [1] = item [dim].stop - self.shape [dim]
                    stop = self.shape [dim]
                DEDENT
                else :
                INDENT
                    stop = item [dim].stop
                DEDENT
            DEDENT
            all_in_slices.append(slice(start, stop))
            pad.append(tuple(this_pad))

        DEDENT
    DEDENT
    ret = super().__getitem__(tuple(all_in_slices))
    ret = np.pad(ret, tuple(pad), mode = 'constant', constant_values = 0)
    return ret
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41156260_41159799_16_28
41156260_41159799_36_62
Title: How to use a Qthread to update a Matplotlib figure with PyQt? 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    self.fig = Figure()
    self.axes = self.fig.add_subplot(111)

    self.axes.hold(False)
    FigureCanvas.__init__(self, self.fig)
    self.setParent(parent)
    FigureCanvas.setSizePolicy(self, QSizePolicy.Expanding, QSizePolicy.Expanding)
    FigureCanvas.updateGeometry(self)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__()
    self.main_widget = QWidget(self)
    self.myplot = MyMplCanvas(self.main_widget)
    self.editor = QLineEdit()
    self.display = QLabel("Vide")
    self.layout = QGridLayout(self.main_widget)
    self.layout.addWidget(self.editor)
    self.layout.addWidget(self.display)
    self.layout.addWidget(self.myplot)
    self.main_widget.setFocus()
    self.setCentralWidget(self.main_widget)
    self.move(500, 500)
    self.show()
    self.editor.returnPressed.connect(self.updatePlot)

    self.plotter = None
    self.thread = None

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4117051_4129838_33_40
4117051_4129838_7_16
Title: Is this the correct way of doing/handling url rewrite in App Engine/ Python? 
----------------------------------------

def get(self, key) :
INDENT
    if key in self.actions :
    INDENT
        action = self.actions [key]
        action()

    DEDENT
DEDENT
----------------------------------------

def get(self) :
INDENT
    user = users.get_current_user()

    quotes = Quote.all()
    path = os.path.join(os.path.dirname(__file__), 'quotery.html')
    template_values = {'quotes' : quotes, 'user' : user, 'login_url' : users.create_login_url('/')}
    self.response.out.write(template.render(path, template_values))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4117051_4129838_33_40
4117051_4129838_89_95
Title: Is this the correct way of doing/handling url rewrite in App Engine/ Python? 
----------------------------------------

def get(self, key) :
INDENT
    if key in self.actions :
    INDENT
        action = self.actions [key]
        action()

    DEDENT
DEDENT
----------------------------------------

def get(self, key) :
INDENT
    if not key or key not in self.actions :
    INDENT
        self.view_all()
    DEDENT
    if key in self.actions :
    INDENT
        action = self.actions [key]
        action()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4117051_4129838_7_16
4117051_4129838_89_95
Title: Is this the correct way of doing/handling url rewrite in App Engine/ Python? 
----------------------------------------

def get(self) :
INDENT
    user = users.get_current_user()

    quotes = Quote.all()
    path = os.path.join(os.path.dirname(__file__), 'quotery.html')
    template_values = {'quotes' : quotes, 'user' : user, 'login_url' : users.create_login_url('/')}
    self.response.out.write(template.render(path, template_values))

DEDENT
----------------------------------------

def get(self, key) :
INDENT
    if not key or key not in self.actions :
    INDENT
        self.view_all()
    DEDENT
    if key in self.actions :
    INDENT
        action = self.actions [key]
        action()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41179798_41187404_36_46
41179798_41187404_7_23
Title: Communication between two independent QWidget 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(FORM2, self).__init__(parent)
    self.button2 = QtGui.QPushButton(self)
    self.button2.setGeometry(QtCore.QRect(50, 50, 100, 30))
    self.button2.setObjectName('Button2')
    self.button2.setText('Button2')
    self.resize(400, 100)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(FORM1, self).__init__(parent)
    self.button1 = QtGui.QPushButton(self)
    self.button1.setGeometry(QtCore.QRect(10, 10, 100, 30))
    self.button1.setObjectName('button1')
    self.button1.setText('Button1')
    self.textEdit = QtGui.QTextEdit(self)
    self.textEdit.setGeometry(QtCore.QRect(10, 50, 400, 100))
    self.textEdit.setObjectName('textEdit')
    self.resize(500, 200)
    self.button1.clicked.connect(self.callForm2)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41181809_41182843_25_35
41181809_41182843_37_49
Title: How to open and close another window with scrollbar in tkinter for python 3.5.? 
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Toplevel.__init__(self, parent)
    self.title('Two')
    scrollbar = tk.Scrollbar(self)
    scrollbar.pack(side = tk.RIGHT, fill = "y")
    listbox = tk.Listbox(self, yscrollcommand = scrollbar.set)
    for i in range(1000) :
    INDENT
        listbox.insert(tk.END, str(i))
    DEDENT
    listbox.pack(side = tk.LEFT, fill = "both")
    scrollbar.config(command = listbox.yview)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Toplevel.__init__(self, parent)
    self.title('Canvas')
    self.geometry('400x600')
    canvas = tk.Canvas(self, bg = 'white', scrollregion = (0, 0, 400, 20000))
    canvas.pack(fill = 'both', expand = True)
    vbar = tk.Scrollbar(canvas, orient = 'vertical')
    vbar.pack(side = 'right', fill = 'y')
    vbar.config(command = canvas.yview)
    canvas.config(yscrollcommand = vbar.set)
    for i in range(1000) :
    INDENT
        canvas.create_text(5, i * 15, anchor = 'nw', text = str(i))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41181809_41182843_25_35
41181809_41182843_5_17
Title: How to open and close another window with scrollbar in tkinter for python 3.5.? 
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Toplevel.__init__(self, parent)
    self.title('Two')
    scrollbar = tk.Scrollbar(self)
    scrollbar.pack(side = tk.RIGHT, fill = "y")
    listbox = tk.Listbox(self, yscrollcommand = scrollbar.set)
    for i in range(1000) :
    INDENT
        listbox.insert(tk.END, str(i))
    DEDENT
    listbox.pack(side = tk.LEFT, fill = "both")
    scrollbar.config(command = listbox.yview)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    label = tk.Label(self, text = "Your choice?")
    label.pack(pady = 10, padx = 10)
    button1 = ttk.Button(self, text = "Open PageTwo", width = 25, command = lambda : self.show_frame(PageTwo))
    button1.pack(pady = 10, padx = 10)
    button2 = ttk.Button(self, text = "Open PageCanvas", width = 25, command = lambda : self.show_frame(PageCanvas))
    button2.pack(pady = 10, padx = 10)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41181809_41182843_37_49
41181809_41182843_5_17
Title: How to open and close another window with scrollbar in tkinter for python 3.5.? 
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Toplevel.__init__(self, parent)
    self.title('Canvas')
    self.geometry('400x600')
    canvas = tk.Canvas(self, bg = 'white', scrollregion = (0, 0, 400, 20000))
    canvas.pack(fill = 'both', expand = True)
    vbar = tk.Scrollbar(canvas, orient = 'vertical')
    vbar.pack(side = 'right', fill = 'y')
    vbar.config(command = canvas.yview)
    canvas.config(yscrollcommand = vbar.set)
    for i in range(1000) :
    INDENT
        canvas.create_text(5, i * 15, anchor = 'nw', text = str(i))
    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    label = tk.Label(self, text = "Your choice?")
    label.pack(pady = 10, padx = 10)
    button1 = ttk.Button(self, text = "Open PageTwo", width = 25, command = lambda : self.show_frame(PageTwo))
    button1.pack(pady = 10, padx = 10)
    button2 = ttk.Button(self, text = "Open PageCanvas", width = 25, command = lambda : self.show_frame(PageCanvas))
    button2.pack(pady = 10, padx = 10)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41188500_41188820_6_15
41188500_41188889_8_21
Title: Check if certain elements of a list are the same 
----------------------------------------

def Choices() :
INDENT
    randomNumber = GetNumber()
    print type(randomNumber), randomNumber
    userChoice = str(input("Enter 4 numbers\n")).strip("\n")
    for a, b in zip(userChoice, randomNumber) :
    INDENT
        if not a == b :
        INDENT
            print "{0} not match {1}".format(a, b)
        DEDENT
    DEDENT
    if userChoice == randomNumber :
    INDENT
        print "Congratulations! You chose the right number"
    DEDENT
DEDENT
----------------------------------------

def Choices() :
INDENT
    randomNumber = GetNumber()
    userChoice = [int(i) for i in list(input("Enter 4 numbers\n"))]
    n = 0
    while userChoice ! = randomNumber :
    INDENT
        hits = [str(i + 1) for i in range(4) if userChoice [i] == randomNumber [i]]
        if hits :
        INDENT
            print ('You got position(s) {} correct'.format(', '.join(hits)))
        DEDENT
        else :
        INDENT
            print ('You got all of them wrong!')
        DEDENT
        userChoice = [int(i) for i in list(input("Enter 4 numbers\n"))]
        n += 1
    DEDENT
    print ("Congratulations! You found the right number in {} turns!!".format(n))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41199948_41200249_1_18
41199948_41201387_19_24
Title: Way to quit the most outer function from an inner function? 
----------------------------------------

def lab() :
INDENT
    letter = prompt()
    def experiment_1() :
    INDENT
        if letter == 1 :
        INDENT
            print ("check")
            return True
        DEDENT
        return False
    DEDENT
    def experiment_2() :
    INDENT
        if letter == 1 :
        INDENT
            print ("check2")
        DEDENT
    DEDENT
    if experiment_1() :
    INDENT
        return
    DEDENT
    experiment_2()
DEDENT
----------------------------------------

def lab() :
INDENT
    try :
    INDENT
        return _lab()
    DEDENT
    except MyError :
    INDENT
        return
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41199948_41201313_1_14
41199948_41201387_19_24
Title: Way to quit the most outer function from an inner function? 
----------------------------------------

def lab() :
INDENT
    letter = prompt()
    def experiment_1() :
    INDENT
        if letter == 1 :
        INDENT
            print ("check")
            return
        DEDENT
    DEDENT
    def experiment_2() :
    INDENT
        if letter == 1 :
        INDENT
            print ("check2")
        DEDENT
    DEDENT
    experiment_1()
    experiment_2()
DEDENT
----------------------------------------

def lab() :
INDENT
    try :
    INDENT
        return _lab()
    DEDENT
    except MyError :
    INDENT
        return
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41206611_41307223_20_33
41206611_41307223_8_16
Title: "How should I handle URL references that are relative to the root of my application without knowing the application's root URL?" 
----------------------------------------

def __call__(self, filename, directories, module_directory = None,
collection_size = - 1) :
INDENT
    key = (tuple(directories), module_directory)
    try :
    INDENT
        lookup = self.lookups [key]
    DEDENT
    except KeyError :
    INDENT
        lookup = TemplateLookup(directories = directories,
            module_directory = module_directory,
            collection_size = collection_size)
        self.lookups [key] = lookup
    DEDENT
    cherrypy.request.lookup = lookup
    cherrypy.request.template = t = lookup.get_template(filename)
    cherrypy.request.handler = MakoHandler(t, cherrypy.request.handler)
DEDENT
----------------------------------------

def __call__(self) :
INDENT
    env = globals().copy()
    env.update(self.next_handler())
    try :
    INDENT
        return self.template.render(** env)
    DEDENT
    except :
    INDENT
        cherrypy.response.status = "500"
        return exceptions.html_error_template().render()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41214022_41224848_31_43
41214022_41224848_8_16
Title: Bind canvas to window when canvas is dragged in pyqt 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(AppWindow, self).__init__(parent)
    self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
    layout = QtGui.QVBoxLayout(self)
    cpu_canvas = GraphCanvas(self)
    layout.addWidget(cpu_canvas)
    self.draggable = True
    self.dragging_threshold = 5
    self.__mousePressPos = None
    self.__mouseMovePos = None
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    self.parent = parent
    self.fig = Figure(figsize = (5, 5), dpi = 100)
    self.ax1 = self.fig.add_subplot(111)
    self.ax1.plot([1, 2, 3], [1, 2, 3], linewidth = 2, color = "#c6463d", label = "line1")
    FigureCanvas.__init__(self, self.fig)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41223744_41224922_1_17
41223744_41230865_16_30
Title: Keeping the initial value of a variable in recursive function 
----------------------------------------

def is_substring(sub, string) :
INDENT
    oldsub = sub
    def is_substringR(sub, string) :
    INDENT
        if sub == "" :
        INDENT
            return True
        DEDENT
        if string == "" :
        INDENT
            return False
        DEDENT
        if oldsub is None :
        INDENT
            oldsub = sub
        DEDENT
        if sub [0] == string [0] :
        INDENT
            return is_substringR(sub [1 :], string [1 :])
        DEDENT
        else :
        INDENT
            return is_substringR(oldsub, string [1 :])
        DEDENT
    DEDENT
    return is_substringR(sub, string)
DEDENT
----------------------------------------

def is_substring(sub, string) :
INDENT
    if sub == "" :
    INDENT
        return True
    DEDENT
    if string == "" :
    INDENT
        return False
    DEDENT
    if sub [0] == string [0] :
    INDENT
        if match_all(sub [1 :], string [1 :]) :
        INDENT
            return True
        DEDENT
    DEDENT
    return is_substring(sub, string [1 :])
DEDENT
----------------------------------------
