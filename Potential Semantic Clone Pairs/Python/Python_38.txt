$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41233352_41233368_1_10
41233352_41233428_1_8
Title: "Python Function That Returns ""Hello"" + Input + ""!"" Except For Two Specific Cases" 
----------------------------------------

def politeGreeting(name) :
INDENT
    if name in ("Lewis", "Clark") :
    INDENT
        return ("Oh, it's you")
    DEDENT
    else :
    INDENT
        return ("Hello," + name + "!")
    DEDENT
    name = input("please enter your name")
    print (politeGreeting(name))
DEDENT
----------------------------------------

def politeGreeting(name) :
INDENT
    if name.lower() in ("lewis", "clark") :
    INDENT
        return ("Oh, it's you " + name.title())
    DEDENT
    else :
    INDENT
        return ("Hello, " + name.title() + "!")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41238173_41238389_9_19
41238173_41239244_1_16
Title: How to make this code small by using a for loop 
----------------------------------------

def triggerexec(df_count, event_df) :
INDENT
    if df_count < = 10000 :
    INDENT
        print ("Input partioned into 2 splits.")
        df_splits = event_df.randomSplit(([1.0, 1.0]))
    DEDENT
    elif df_count < = 50000 :
    INDENT
        print ("Input partioned into 4 splits.")
        df_splits = event_df.randomSplit(([1.0, 1.0, 1.0, 1.0]))
    DEDENT
    else :
    INDENT
        return
    DEDENT
    splits(df_splits)
DEDENT
----------------------------------------

def triggerexec(df_count, event_df) :
INDENT
    if df_count < = 10000 :
    INDENT
        print ("Input partioned into 2 splits.")
        df_splits = event_df.randomSplit(([1.0, 1.0]))
    DEDENT
    elif df_count < = 50000 :
    INDENT
        print ("Input partioned into 4 splits.")
        df_splits = event_df.randomSplit(([1.0, 1.0, 1.0, 1.0]))
    DEDENT
    else :
    INDENT
        df_splits = []
    DEDENT
    for i, split in enumerate(df_splits) :
    INDENT
        if split.rdd.isEmpty() :
        INDENT
            print ("No Data in split Nr. {:d}".format(i))
        DEDENT
        else :
        INDENT
            print ("Input count for split Nr. {:d}: {:s}".format(i, split.count()))
            extract_and_push(split)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4125825_4125976_1_24
4125825_4126920_17_31
Title: python izip which cycles through all iterables until the longest finishes 
----------------------------------------

def izip_cycle(* colls) :
INDENT
    iters = [iter(c) for c in colls]
    count = len(colls)
    saved = [[] for i in range(count)]
    exhausted = [False] * count
    while True :
    INDENT
        r = []
        for i in range(count) :
        INDENT
            if not exhausted [i] :
            INDENT
                try :
                INDENT
                    n = iters [i].next()
                    saved [i].append(n)
                    r.append(n)
                DEDENT
                except StopIteration :
                INDENT
                    exhausted [i] = True
                    if all(exhausted) :
                    INDENT
                        return
                    DEDENT
                    saved [i] = itertools.cycle(saved [i])
                DEDENT
            DEDENT
            if exhausted [i] :
            INDENT
                r.append(saved [i].next())
            DEDENT
        DEDENT
        yield r
    DEDENT
DEDENT
----------------------------------------

def izip_cycle(* iterables) :
INDENT
    def wrap(it) :
    INDENT
        elements = []
        for x in it :
        INDENT
            yield x
            elements.append(x)
        DEDENT
        if not elements : return
        next(counter)
        while True :
        INDENT
            for x in elements : yield x
        DEDENT
    DEDENT
    iterators = [wrap(i) for i in iterables]
    counter = iter(iterators)
    next(counter)
    while True :
    INDENT
        yield [next(i) for i in iterators]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4125825_4126920_18_26
4125825_4126920_2_10
Title: python izip which cycles through all iterables until the longest finishes 
----------------------------------------

def wrap(it) :
INDENT
    elements = []
    for x in it :
    INDENT
        yield x
        elements.append(x)
    DEDENT
    if not elements : return
    next(counter)
    while True :
    INDENT
        for x in elements : yield x
    DEDENT
DEDENT
----------------------------------------

def wrap(it) :
INDENT
    empty = True
    for x in it : empty = yield x
    if empty : return
    next(counter)
    while True :
    INDENT
        empty = True
        for x in it : empty = yield x
        if empty : raise ValueError('cannot cycle iterator in-place')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41259830_41259909_1_18
41259830_41259940_1_9
Title: Python Basic If Statement 
----------------------------------------

def main_loop() :
INDENT
    print "where are you from?"
    loc = raw_input()
    print "so your from " + loc + "?"
    ans = raw_input()

    def isittrue() :
    INDENT
        if ans == "yes" :
        INDENT
            print "We all love " + loc
        DEDENT
        else :
        INDENT
            print "Where did you say you were from again?"
        DEDENT
    DEDENT
    isittrue()

DEDENT
----------------------------------------

def main_loop() :
INDENT
    global ans
    print "where are you from?"
    loc = raw_input()
    print "so your from " + loc + "?"
    ans = raw_input()
    return ans, loc
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41259830_41259909_1_18
41259830_41260035_1_11
Title: Python Basic If Statement 
----------------------------------------

def main_loop() :
INDENT
    print "where are you from?"
    loc = raw_input()
    print "so your from " + loc + "?"
    ans = raw_input()

    def isittrue() :
    INDENT
        if ans == "yes" :
        INDENT
            print "We all love " + loc
        DEDENT
        else :
        INDENT
            print "Where did you say you were from again?"
        DEDENT
    DEDENT
    isittrue()

DEDENT
----------------------------------------

def main_loop() :
INDENT
    print ("where are you from?")
    loc = input()
    print ("so your from " + loc + "?")
    ans = input()
    isittrue(ans, loc)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41259830_41259940_1_9
41259830_41260035_1_11
Title: Python Basic If Statement 
----------------------------------------

def main_loop() :
INDENT
    global ans
    print "where are you from?"
    loc = raw_input()
    print "so your from " + loc + "?"
    ans = raw_input()
    return ans, loc
DEDENT
----------------------------------------

def main_loop() :
INDENT
    print ("where are you from?")
    loc = input()
    print ("so your from " + loc + "?")
    ans = input()
    isittrue(ans, loc)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41283736_41284289_1_18
41283736_41286268_1_12
Title: Binary search using recursion goes into an infinite loop 
----------------------------------------

def binsearch(pylist, element) :
INDENT
    pylist = sorted(pylist)
    if len(pylist) == 0 :
    INDENT
        return False
    DEDENT
    if len(pylist) == 1 :
    INDENT
        if pylist [0] == element :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    else :
    INDENT
        mid = len(pylist) / / 2
        if element == pylist [mid] :
        INDENT
            return True
        DEDENT
        elif element > pylist [mid] :
        INDENT
            return binsearch(pylist [mid :], element)
        DEDENT
        else :
        INDENT
            return binsearch(pylist [: mid], element)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def binsearch(pylist, element) :
INDENT
    if len(pylist) == 0 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        v_mid = len(pylist) / / 2
        if pylist [v_mid] == element :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            if element > pylist [v_mid] :
            INDENT
                return binsearch(pylist [v_mid + 1 :], element)
            DEDENT
            else :
            INDENT
                return binsearch(pylist [: v_mid], element)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41291328_41575987_42_59
41291328_41575987_5_14
Title: Resize Vertical Header of QTableView in PyQt4? 
----------------------------------------

def __init__(self, rows, columns) :
INDENT
    super(Window, self).__init__()
    self.table = QtGui.QTableView(self)
    self.table.setHorizontalHeader(HeaderView(self.table))
    self.table.verticalHeader().setTextElideMode(QtCore.Qt.ElideRight)
    model = QtGui.QStandardItemModel(rows, columns, self.table)
    for row in range(rows) :
    INDENT
        item = QtGui.QStandardItem('FOO_BAR_123_AB_CD_%s' % row)
        item.setToolTip(item.text())
        model.setVerticalHeaderItem(row, item)
        for column in range(columns) :
        INDENT
            item = QtGui.QStandardItem('(%d, %d)' % (row, column))
            item.setTextAlignment(QtCore.Qt.AlignCenter)
            model.setItem(row, column, item)
        DEDENT
    DEDENT
    self.table.setModel(model)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.table)
DEDENT
----------------------------------------

def __init__(self, table) :
INDENT
    super(HeaderView, self).__init__(QtCore.Qt.Horizontal, table)
    self.setClickable(True)
    self.setHighlightSections(True)
    self.setResizeMode(QtGui.QHeaderView.Interactive)
    self._vheader = table.verticalHeader()
    self._resizing = False
    self._start_position = - 1
    self._start_width = - 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41294848_41295065_35_53
41294848_41295065_4_27
Title: Python Sockets: how to connect between two computers on the same wifi 
----------------------------------------

def Main() :
INDENT
    host =
    port = 5000
    mySocket = socket.socket()
    mySocket.connect((host, port))
    message = input(" -> ")
    while message ! = 'q' :
    INDENT
        mySocket.send(message.encode())
        data = mySocket.recv(1024).decode()
        print ('Received from server: ' + data)
        message = input(" -> ")
    DEDENT
    mySocket.close()
DEDENT
----------------------------------------

def Main() :
INDENT
    host = "0.0.0.0"
    port = 5000
    print socket.gethostname()
    mySocket = socket.socket()
    mySocket.bind((host, port))
    mySocket.listen(1)
    conn, addr = mySocket.accept()
    print ("Connection from: " + str(addr))
    while True :
    INDENT
        data = conn.recv(1024).decode()
        if not data :
        INDENT
            break
        DEDENT
        print ("from connected  user: " + str(data))
        data = str(data).upper()
        print ("sending: " + str(data))
        conn.send(data.encode())
    DEDENT
    conn.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41300428_41301671_29_40
41300428_41301671_9_18
Title: PyQt5 QFileDialog stops application from closing 
----------------------------------------

def __init__(self, parent) :
INDENT
    super(EventWidgets, self).__init__(parent)
    self.calendar = QtWidgets.QCalendarWidget(self)
    self.frame = QtWidgets.QFrame()
    self.scrollArea = QtWidgets.QScrollArea()
    self.scrollArea.setWidget(self.frame)
    horizontal_box = QtWidgets.QHBoxLayout()
    horizontal_box.addWidget(self.calendar)
    horizontal_box.addWidget(self.scrollArea)
    self.setLayout(horizontal_box)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.openAction = QtWidgets.QAction('Open', self)
    self.openAction.triggered.connect(self.openDialog)
    menuBar = self.menuBar()
    fileMenu = menuBar.addMenu('&File')
    fileMenu.addAction(self.openAction)
    self.event_widgets = EventWidgets(self)
    self.setCentralWidget(self.event_widgets)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41308447_41308946_101_108
41308447_41310435_106_113
Title: Trying to Optimize Python API read script 
----------------------------------------

def retrieve_all_ext(ext_att_json) :
INDENT
    new_computer = {}

    for computer in ext_att_json :
    INDENT
        new_computer [str(computer ['name'])] = computer ['value']
        add_to_master_list(new_computer)
    DEDENT
DEDENT
----------------------------------------

def retrieve_all_ext(ext_att_json) :
INDENT
    new_computer = {}

    for computer in ext_att_json :
    INDENT
        new_computer [str(computer ['name'])] = computer ['value']
        add_to_master_list(new_computer)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41308447_41308946_17_23
41308447_41310435_32_38
Title: Trying to Optimize Python API read script 
----------------------------------------

def get_creds() :
INDENT
    with open('.cred') as cred_file :
    INDENT
        cred_string = cred_file.read().rstrip()
        return cred_string
        print (cred_string)
    DEDENT
DEDENT
----------------------------------------

def get_creds() :
INDENT
    with open('.cred') as cred_file :
    INDENT
        cred_string = cred_file.read().rstrip()
        return cred_string
        print (cred_string)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41308497_41318715_9_44
41308497_42568486_15_32
Title: PyGi: How to use a GTKListBox with a GTKListStore? 
----------------------------------------

def __init__(self) :
INDENT
    listbox = Gtk.ListBox()
    employee_name_label = Gtk.Label("Henry", xalign = 1)
    combo = Gtk.ComboBoxText()
    combo.set_property("can-focus", True)
    for name in ["bar", "foo", "python"] :
    INDENT
        combo.append('0', name)
    DEDENT
    list_box_row = Gtk.ListBoxRow()
    hbox = Gtk.Box(orientation = Gtk.Orientation.HORIZONTAL, spacing = 5)
    list_box_row.add(hbox)
    switch = Gtk.Switch()
    switch.props.valign = Gtk.Align.CENTER

    project_time_label = Gtk.Label("0:00:00", xalign = 1)
    project_time_label.set_property('width-chars', 8)

    hbox.pack_start(employee_name_label, True, False, 5)
    hbox.pack_end(project_time_label, False, False, 5)
    hbox.pack_end(switch, False, False, 5)
    hbox.pack_end(combo, False, False, 5)

    listbox.add(list_box_row)
    window = Gtk.Window()
    window.add(listbox)
    window.connect("destroy", self.on_window_destroy)
    window.show_all()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    item1 = Item()
    item1.text = "Hello"
    item2 = Item()
    item2.text = "World"
    liststore = Gio.ListStore()
    liststore.append(item1)
    liststore.append(item2)
    listbox = Gtk.ListBox()
    listbox.bind_model(liststore, self.create_widget_func)
    window = Gtk.Window()
    window.add(listbox)
    window.connect("destroy", self.on_window_destroy)
    window.show_all()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41310023_41310284_40_47
41310023_41310284_8_27
Title: PySide popup showing list and multiple select 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Widget, self).__init__(parent = parent)
    self.btn = QPushButton('Select', self)
    self.btn.move(20, 20)
    self.btn.clicked.connect(self.showDialog)
    self.setGeometry(300, 300, 290, 150)
    self.setWindowTitle('Input dialog')
DEDENT
----------------------------------------

def __init__(self, title, message, items, parent = None) :
INDENT
    super(MyDialog, self).__init__(parent = parent)
    form = QFormLayout(self)
    form.addRow(QLabel(message))
    self.listView = QListView(self)
    form.addRow(self.listView)
    model = QStandardItemModel(self.listView)
    self.setWindowTitle(title)
    for item in items :
    INDENT

        standardItem = QStandardItem(item)
        standardItem.setCheckable(True)
        model.appendRow(standardItem)
    DEDENT
    self.listView.setModel(model)
    buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel, Qt.Horizontal, self)
    form.addRow(buttonBox)
    buttonBox.accepted.connect(self.accept)
    buttonBox.rejected.connect(self.reject)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41310365_41310585_6_24
41310365_41310646_7_36
Title: Python count How many Clicks are in a second 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__()
    self.clicks = 0
    self.vbox = QtGui.QVBoxLayout()
    self.setLayout(self.vbox)
    self.label = QtGui.QLabel(str(self.clicks), self)
    self.vbox.addWidget(self.label)
    self.button = QtGui.QPushButton("Click Me!", self)
    self.vbox.addWidget(self.button)

    self.button.clicked.connect(self.on_click)
    self.show()
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(UICPS, self).__init__(parent)
    self.clicks = 0
    self.Back = QPushButton("<- Back", self)
    self.Back.resize(50, 25)
    self.Back.move(0, 425)
    self.ClickedLB = QLabel(str(self.clicks), self)
    self.ClickedLB.resize(400, 20)
    self.ClickedLB.move(200, 100)
    self.ClickedLB2 = QLabel(str(self.clicks), self)
    self.ClickedLB2.resize(400, 20)
    self.ClickedLB2.move(200, 150)
    self.ClickedLB3 = QLabel(str(self.clicks), self)
    self.ClickedLB3.resize(400, 20)
    self.ClickedLB3.move(200, 200)
    self.CPSBTN = QPushButton("Click Me!", self)
    self.CPSBTN.clicked.connect(self.Clicked)
    self.CPSBTN.resize(400, 175)
    self.CPSBTN.move(0, 250)
    self.resize(400, 450)
    self.starting = False
    self.timer = QTimer(self)
    self.timer.timeout.connect(self.updateClock)
    self.counter = 0
    self.isFist = True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41326990_41327138_1_15
41326990_41327654_2_16
Title: How to update mysql data using django? 
----------------------------------------

def update_db_data(request) :
INDENT
    conn = MySQLdb.connect(host = "localhost", user = "test_user", passwd = "test_pwd", db = "myproject")
    cursor = conn.cursor()
    try :
    INDENT
        cursor.execute("UPDATE user SET user_name = 'test'")
        print ("sucess")
        html = "<html><body>sucess</body></html>"
        conn.commit()
    DEDENT
    except :
    INDENT
        print ("fail")
        html = "<html><body>fail</body></html>"
        conn.rollback()
    DEDENT
    finally :
    INDENT
        conn.close()
        return HttpResponse(html)
    DEDENT
DEDENT
----------------------------------------

def update_db_data(request) :
INDENT
    try :
    INDENT
        user_obj = User.objects.get(id = 2)
        user_obj.user_name = "test"
        user_obj.save()
        print ("sucess")
        html = "<html><body>sucess</body></html>"
    DEDENT
    except :
    INDENT
        print ("fail")
        html = "<html><body>fail</body></html>"
    DEDENT
    return HttpResponse(html)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41328586_41328676_1_13
41328586_41328677_1_13
Title: django form not rendering in template. Input fields doesn't shows up 
----------------------------------------

def contact(request) :
INDENT
    if request.method == 'POST' :
    INDENT
        form = ContactForm(request.POST)
        if form.is_valid() :
        INDENT
            return redirect('some-link')
        DEDENT
        else :
        INDENT
            return render(request, 'template.html', dict(form = form))
        DEDENT
    DEDENT
    else :
    INDENT
        form = ContactForm()
        return render(request, 'template.html', dict(form = form))
    DEDENT
DEDENT
----------------------------------------

def contact(request) :
INDENT
    form_class = ContactForm
    if request.method == 'POST' :
    INDENT
        form = form_class(data = request.POST)
    DEDENT
    else :
    INDENT
        form = form_class()
    DEDENT
    return render(request, 'contact.html', {
            'form' : form,
            })
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41339294_41344973_42_56
41339294_41353606_43_65
Title: wxpython threading display images as they are loaded 
----------------------------------------

def update_ui(self, bmp) :
INDENT
    button = wx.Button(self.panel, - 1, "Book cover", style = wx.ALIGN_CENTER, size = wx.Size(100, 100))
    button.SetToolTipString("wx.Button can how have an icon on the left, right,\n"
        "above or below the label.")
    button.SetBitmap(bmp,
        wx.LEFT
        )
    button.SetBitmapMargins((4, 4))
    button.SetFont(wx.Font(8, wx.SWISS, wx.NORMAL, wx.BOLD, False))
    self.wrapSizer.Add(button, 1, wx.EXPAND)
    self.panel.Layout()
DEDENT
----------------------------------------

def update_ui(self, url, bmp = None) :
INDENT
    if bmp is None :
    INDENT

        button = wx.Button(self.panel, - 1, url, style = wx.ALIGN_CENTER, size = wx.Size(100, 100))
        button.SetToolTipString("wx.Button can how have an icon on the left, right,\n"
            "above or below the label.")
        self.wrapSizer.Add(button, 1, wx.EXPAND)
    DEDENT
    else :
    INDENT
        children = self.wrapSizer.GetChildren()
        for widget in children :
        INDENT
            button = widget.GetWindow()
            if isinstance(button, wx.Button) :
            INDENT
                if button.GetLabel() == url :
                INDENT
                    button.SetBitmap(bmp,
                        wx.LEFT
                        )
                    button.SetLabel('')
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    self.panel.Layout()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41339304_41340804_14_17
41339304_41401591_3_13
Title: python fabric erroneous duplicate executions of task 
----------------------------------------

def robot_test() :
INDENT
    with settings(user = "automation1") :
    INDENT
        with cd('/home/automation1/inventory.robot/grid') :
        INDENT
            run('python grid.py')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def robot_test() :
INDENT
    environment_configuration = get_environment_configuration('Selenium')
    nodes = get_node_servers(environment_configuration ['servers'])
    hubs = get_hub_servers(environment_configuration ['servers'])
    execute(start_hub, hosts = hubs)
    execute(start_node, hosts = nodes)
    all = hubs + nodes
    execute(kill_node, hosts = (hubs + nodes))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41341254_41341384_1_10
41341254_41341390_7_20
Title: "Python: Ask to input again if ""Enter"" key is pressed without entering anything" 
----------------------------------------

def dice() :
INDENT
    i = 1;
    while i :
    INDENT
        user = input("Do you want to roll the dice? ")
        if user ! = None :
        INDENT
            i = 0
        DEDENT
    DEDENT
    while user [0].lower() == 'y' :
    INDENT
        num = randrange(1, 7)
        print ("Number produced: ", num)
    DEDENT
DEDENT
----------------------------------------

def dice() :
INDENT
    while True :
    INDENT

        user = input("Do you want to roll the dice? ")
        if user.lower() == 'y' :
        INDENT

            num = random.randrange(1, 7)
            print ("Number produced: ", num)
        DEDENT
        else :
        INDENT
            print ("We don't understand your answer.")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41349635_41369270_13_22
41349635_41369270_29_38
Title: How to detect collision/mouse-over between the mouse and a sprite? 
----------------------------------------

def __init__(self, x, y) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface((230, 310))
    self.image.fill(RED)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y
DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface((230, 310))
    self.image.fill(GREEN)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41352649_41357712_2_13
41352649_41407020_2_13
Title: Loop through changing dataset with inlineCallbacks/yield (python-twisted) 
----------------------------------------

def _get_details(self, dt = None) :
INDENT
    data = self.data
    i = 0
    while i < len(data) :
    INDENT
        e = data [i]
        if needs_update(e) :
        INDENT
            more_detail = yield get_more_detail(e)
            if i < len(data) or data [i] ! = e :
            INDENT
                break
            DEDENT
            do_the_update(e, more_detail)
        DEDENT
        i += 1
    DEDENT
    schedule_future(self._get_details)
DEDENT
----------------------------------------

def _get_details(self, dt = None) :
INDENT
    try :
    INDENT
        data = yield self.data.pop()
    DEDENT
    except IndexError :
    INDENT
        schedule_future(self._get_details)
        defer.returnValue(None)
    DEDENT
    if needs_update(e) :
    INDENT
        more_detail = yield get_more_detail(data)
        do_the_update(data, more_detail)
    DEDENT
    schedule_future(self._get_details)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41353653_41356566_29_42
41353653_41357294_42_53
Title: How do I get the Checked items in a Qlistview? 
----------------------------------------

def print_checked_items(self) :
INDENT
    for index in range(self.model.rowCount()) :
    INDENT
        item = self.model.item(index)
        if item.checkState() == QtCore.Qt.Checked :
        INDENT
            if self.isWritten :
            INDENT
                mode = "a"
            DEDENT
            else :
            INDENT
                mode = "w"
                self.isWritten = True
            DEDENT
            print ('%s' % item.text())
        DEDENT
    DEDENT
    print ("print checked items executed")
DEDENT
----------------------------------------

def print_checked_items(self) :
INDENT
    path = "/home/test1/checked.txt"
    mode = QtCore.QFile.Append if self.isWritten else QtCore.QFile.WriteOnly
    if len(self.items) > 0 :
    INDENT
        file = QtCore.QFile(path)
        if file.open(mode) :
        INDENT
            for item in self.items :
            INDENT
                print ('%s' % item.text())
                file.write(item.text() + "\n")
            DEDENT
        DEDENT
        file.close()
    DEDENT
    print ("print checked items executed")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41353653_41356566_9_28
41353653_41357294_7_35
Title: How do I get the Checked items in a Qlistview? 
----------------------------------------

def __init__(self, parent) :
INDENT
    super(AppRemovalPage, self).__init__(parent)
    self.setTitle('Apps to Remove')
    self.setSubTitle('Listview')
    self.list_view = QListView(self)
    self.list_view.setMinimumSize(465, 200)
    self.isWritten = False
    loo = "/home/test1/file.txt"
    self.model = QtGui.QStandardItemModel(self.list_view)
    for line in ('a', 'b', 'c', 'd', 'e') :
    INDENT
        self.item = QtGui.QStandardItem(line)
        self.item.setCheckable(True)
        self.item.setCheckState(QtCore.Qt.Unchecked)
        self.model.appendRow(self.item)
    DEDENT
    self.list_view.setModel(self.model)
    self.list_view.show()

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(AppRemovalPage, self).__init__(parent = parent)
    self.setTitle('Apps to Remove')
    self.setSubTitle('Listview')
    self.list_view = QtGui.QListView(self)
    self.list_view.setMinimumSize(465, 200)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.list_view)
    self.setLayout(layout)
    self.items = []
    self.isWritten = False
    loo = "/home/test1/file.txt"
    self.model = QtGui.QStandardItemModel(self.list_view)
    self.model.itemChanged.connect(self.setItems)
    file = QtCore.QFile(loo)
    if file.open(QtCore.QFile.ReadOnly | QtCore.QFile.Text) :
    INDENT
        while not file.atEnd() :
        INDENT
            line = bytearray(file.readLine()).decode().strip()
            item = QtGui.QStandardItem(line)
            item.setCheckable(True)
            item.setCheckState(QtCore.Qt.Unchecked)
            self.model.appendRow(item)
        DEDENT
    DEDENT
    self.list_view.setModel(self.model)
    self.list_view.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41369419_41455842_4_10
41369419_41568658_38_50
Title: How to compose two functions whose outer function supplies arguments to the inner function 
----------------------------------------

def parse_code(code) :
INDENT
    _code = code.split('$$')
    if '-' in _code [0] :
    INDENT
        return _parse_secrets(_code [1], * _code [0].split('-'))
    DEDENT
    return _parse_secrets(_code [0], * _code [1].split('-'))

DEDENT
----------------------------------------

def parse_code(code) :
INDENT
    components = parse_common(code)

    parser_info = [s for s in CODE_PARSER_SELECTOR if len(components) == s [0]]
    if parser_info is not None and len(parser_info) > 0 :
    INDENT
        parse_func = parser_info [0] [1]
        return parse_func(code, components)
    DEDENT
    else :
    INDENT
        raise RuntimeError('No parser found for code: %s' % code)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41369680_41369961_3_36
41369680_41370536_1_20
Title: Python 3: List of over 100 indices cycles back around after index 47. why? how do I stop this? 
----------------------------------------

def nthPrime(ind) :
INDENT
    p = {}
    T = 2
    incST = 2
    incEND = incST + 200
    lenfinal = 1
    while lenfinal < ind :
    INDENT
        for i in range(incST, incEND) :
        INDENT
            p [i] = True
        DEDENT
        while T < = math.sqrt(incEND) :
        INDENT
            l = 0
            while l < = incEND :
            INDENT
                p [T ** 2 + (T * l)] = False
                l += 1
                if T ** 2 + (T * l) > incEND :
                INDENT
                    break
                DEDENT
            DEDENT
            for k, v in sorted(p.items()) :
            INDENT
                if v and k > T :
                INDENT
                    T = int(k)
                    break
                DEDENT
            DEDENT
        DEDENT
        incST = incEND + 1
        incEND = incST + 200
        lenfinal = sum(1 for k, v in p.items() if v)

    DEDENT
    final = [k for k, v in sorted(p.items()) if v]
    return final [ind - 2]
DEDENT
----------------------------------------

def nthPrime(ind) :
INDENT
    first_prime = 1
    number = 1
    prime_numbers = [first_prime]
    def findPrimeInPosition(ind, number) :
    INDENT
        if ind > len(prime_numbers) :
        INDENT
            number += 1
            is_prime = True
            for p in prime_numbers [1 :] :
            INDENT
                if not number % p :
                INDENT
                    is_prime = False
                DEDENT
            DEDENT
            if is_prime :
            INDENT
                prime_numbers.append(number)
            DEDENT
            findPrimeInPosition(ind, number)
        DEDENT
        return prime_numbers [- 1]
    DEDENT
    return findPrimeInPosition(ind, number)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41375261_41375760_10_17
41375261_41376051_8_18
Title: Python continuous writing failed 
----------------------------------------

def write_file(contents, fname) :
INDENT
    old_contents = openfile(fname)
    old_contents.insert(1, contents)
    contents = "".join(old_contents)
    f = open(fname, "w")
    f.write(contents)
    f.close()
DEDENT
----------------------------------------

def write_file(contents, f) :
INDENT
    print "WriteFile method- Content received: " + str(contents)
    old_contents = openfile()
    print "Writefile method- Old content read from file: " + str(old_contents)
    old_contents.insert(1, contents)
    print "Writefile method- Old content after insertion: " + str(old_contents)
    contents = "".join(old_contents)
    print "WriteFile method- Content to write: " + str(contents)
    f.write(contents)
    f.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4140437_37172309_39_49
4140437_4140988_6_29
Title: Interactively validating Entry widget content in tkinter 
----------------------------------------

def __init__(self, master, ** kw) :
INDENT
    super().__init__(master, ** kw)
    self.entry = tkinter.Entry(self)
    self.text = tkinter.Text(self, height = 15, width = 50,
        wrap = WORD, state = DISABLED)
    self.entry.grid(row = 0, column = 0, sticky = NSEW)
    self.text.grid(row = 1, column = 0, sticky = NSEW)
    self.grid_rowconfigure(1, weight = 1)
    self.grid_columnconfigure(0, weight = 1)
    on_validate(self.entry, Mode.key, self.validator)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self, parent)

    vcmd = (self.register(self.onValidate),
        '%d', '%i', '%P', '%s', '%S', '%v', '%V', '%W')
    self.entry = tk.Entry(self, validate = "key", validatecommand = vcmd)
    self.text = tk.Text(self, height = 10, width = 40)
    self.entry.pack(side = "top", fill = "x")
    self.text.pack(side = "bottom", fill = "both", expand = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4140908_4140935_1_13
4140908_4141045_1_10
Title: Formatting Pascal's triangle 
----------------------------------------

def mytri(myrange) :
INDENT
    rows = list()
    lr = None
    for i in xrange(myrange + 1) :
    INDENT
        try :
        INDENT
            lr = [1] + [lr [i] + lr [i + 1] for i in range(len(lr) - 1)] + [1]
        DEDENT
        except TypeError :
        INDENT
            lr = [1]
        DEDENT
        rows.append(' '.join(str(v) for v in lr))
    DEDENT
    return rows
DEDENT
----------------------------------------

def mytri(height) :
INDENT
    start = [1]
    for _ in xrange(height) :
    INDENT
        yield start
        next_row = [1]
        for a, b in zip(start, start [1 :]) :
        INDENT
            next_row.append(a + b)
        DEDENT
        next_row.append(1)
        start = next_row
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41410264_41410308_12_20
41410264_41410462_8_14
Title: class attribute doesn't get assigned correctly 
----------------------------------------

def run(self) :
INDENT
    self.ongoing = True
    while True :
    INDENT
        with self.lock :
        INDENT
            if not self.ongoing :
            INDENT
                break
            DEDENT
            self.process = subprocess.Popen(["afplayer", self.file_name])
        DEDENT
        self.process.wait()
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    self.ongoing = True
    while self.ongoing :
    INDENT
        self.process = subprocess.Popen(["afplay", self.file_name])
        self.process.wait()
        self.process = None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41412263_41412702_10_32
41412263_41412702_268_275
Title: How to show an interface to select points in python? 
----------------------------------------

def __init__(self, resolution = (640, 480), caption = None, transparent = False, icon = None, flags = 0) :
INDENT
    self.resolution = resolution
    self.flags = flags
    if caption :
    INDENT
        self.setCaption(caption)
    DEDENT
    if icon :
    INDENT
        self.setIcon(icon)
    DEDENT
    self.monitorCenter = self.getCenterScreen(self.getMonitorSize())
    self.centerScreen()
    self.transparent = transparent
    self.screen = self.setScreen()
DEDENT
----------------------------------------

def __init__(self, screen, size = (16, 16)) :
INDENT
    self.screen = screen
    self.surface = self.screen.screen
    self.size = size
    self.grid = tuple(((x, y) for y in range(0, self.screen.resolution [1], size [1]) for x in range(0, self.screen.resolution [0], size [0])))
    self.elements = self.create_elements()
    self.active_elements = []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41415771_41416442_43_75
41415771_41416442_6_36
Title: Python tkinter make row full weight on screen 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label0 = tk.Label(self, text = '')
    label0.configure(relief = 'raised')
    label0.grid(row = 0, column = 0, columnspan = 12, sticky = "nsew")

    label1 = tk.Label(self, text = '0', width = 10)
    label1.configure(relief = 'raised', bg = 'white')
    label1.grid(row = 1, column = 0, sticky = 'w')
    buttonhlp = tk.Button(self, text = "HELP", command = close_window)
    buttonhlp.grid(row = 1, column = 1, columnspan = 4)
    label1 = tk.Label(self, text = 'xx')
    label1.grid(row = 1, column = 5)
    label1 = tk.Label(self, text = 'tt')
    label1.grid(row = 1, column = 6)
    buttonquit = tk.Button(self, text = "Quit", command = close_window)
    buttonquit.grid(row = 1, column = 7, columnspan = 4)
    label1 = tk.Label(self, text = '11', width = 10)
    label1.configure(relief = 'raised', bg = 'white')
    label1.grid(row = 1, column = 11, sticky = 'e')

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame
        frame.grid(row = 0, column = 0, columnspan = 12, sticky = "nsew")
        frame.grid_columnconfigure(0, weight = 1)
        frame.grid_columnconfigure(1, weight = 1)
        frame.grid_columnconfigure(2, weight = 1)
        frame.grid_columnconfigure(3, weight = 1)
        frame.grid_columnconfigure(4, weight = 1)
        frame.grid_columnconfigure(5, weight = 1)
        frame.grid_columnconfigure(6, weight = 1)
        frame.grid_columnconfigure(7, weight = 1)
        frame.grid_columnconfigure(8, weight = 1)
        frame.grid_columnconfigure(9, weight = 1)
        frame.grid_columnconfigure(10, weight = 1)
        frame.grid_columnconfigure(11, weight = 1)

    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41415771_41416442_43_75
41415771_41416442_78_87
Title: Python tkinter make row full weight on screen 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label0 = tk.Label(self, text = '')
    label0.configure(relief = 'raised')
    label0.grid(row = 0, column = 0, columnspan = 12, sticky = "nsew")

    label1 = tk.Label(self, text = '0', width = 10)
    label1.configure(relief = 'raised', bg = 'white')
    label1.grid(row = 1, column = 0, sticky = 'w')
    buttonhlp = tk.Button(self, text = "HELP", command = close_window)
    buttonhlp.grid(row = 1, column = 1, columnspan = 4)
    label1 = tk.Label(self, text = 'xx')
    label1.grid(row = 1, column = 5)
    label1 = tk.Label(self, text = 'tt')
    label1.grid(row = 1, column = 6)
    buttonquit = tk.Button(self, text = "Quit", command = close_window)
    buttonquit.grid(row = 1, column = 7, columnspan = 4)
    label1 = tk.Label(self, text = '11', width = 10)
    label1.configure(relief = 'raised', bg = 'white')
    label1.grid(row = 1, column = 11, sticky = 'e')

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 1")
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41415771_41416442_43_75
41415771_41416442_90_101
Title: Python tkinter make row full weight on screen 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label0 = tk.Label(self, text = '')
    label0.configure(relief = 'raised')
    label0.grid(row = 0, column = 0, columnspan = 12, sticky = "nsew")

    label1 = tk.Label(self, text = '0', width = 10)
    label1.configure(relief = 'raised', bg = 'white')
    label1.grid(row = 1, column = 0, sticky = 'w')
    buttonhlp = tk.Button(self, text = "HELP", command = close_window)
    buttonhlp.grid(row = 1, column = 1, columnspan = 4)
    label1 = tk.Label(self, text = 'xx')
    label1.grid(row = 1, column = 5)
    label1 = tk.Label(self, text = 'tt')
    label1.grid(row = 1, column = 6)
    buttonquit = tk.Button(self, text = "Quit", command = close_window)
    buttonquit.grid(row = 1, column = 7, columnspan = 4)
    label1 = tk.Label(self, text = '11', width = 10)
    label1.configure(relief = 'raised', bg = 'white')
    label1.grid(row = 1, column = 11, sticky = 'e')

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 2")
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41415771_41416442_6_36
41415771_41416442_78_87
Title: Python tkinter make row full weight on screen 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame
        frame.grid(row = 0, column = 0, columnspan = 12, sticky = "nsew")
        frame.grid_columnconfigure(0, weight = 1)
        frame.grid_columnconfigure(1, weight = 1)
        frame.grid_columnconfigure(2, weight = 1)
        frame.grid_columnconfigure(3, weight = 1)
        frame.grid_columnconfigure(4, weight = 1)
        frame.grid_columnconfigure(5, weight = 1)
        frame.grid_columnconfigure(6, weight = 1)
        frame.grid_columnconfigure(7, weight = 1)
        frame.grid_columnconfigure(8, weight = 1)
        frame.grid_columnconfigure(9, weight = 1)
        frame.grid_columnconfigure(10, weight = 1)
        frame.grid_columnconfigure(11, weight = 1)

    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 1")
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41415771_41416442_6_36
41415771_41416442_90_101
Title: Python tkinter make row full weight on screen 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame
        frame.grid(row = 0, column = 0, columnspan = 12, sticky = "nsew")
        frame.grid_columnconfigure(0, weight = 1)
        frame.grid_columnconfigure(1, weight = 1)
        frame.grid_columnconfigure(2, weight = 1)
        frame.grid_columnconfigure(3, weight = 1)
        frame.grid_columnconfigure(4, weight = 1)
        frame.grid_columnconfigure(5, weight = 1)
        frame.grid_columnconfigure(6, weight = 1)
        frame.grid_columnconfigure(7, weight = 1)
        frame.grid_columnconfigure(8, weight = 1)
        frame.grid_columnconfigure(9, weight = 1)
        frame.grid_columnconfigure(10, weight = 1)
        frame.grid_columnconfigure(11, weight = 1)

    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "This is page 2")
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, text = "Go to the start page",
        command = lambda : controller.show_frame("StartPage"))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4142406_4142496_2_7
4142406_4142956_7_16
Title: How to have data structure with both tuple and dictionary characteristic 
----------------------------------------

def __getitem__(self, key) :
INDENT
    if str(key).isdigit() :
    INDENT
        return self.values() [key]
    DEDENT
    else :
    INDENT
        return super(d, self).get(key)
    DEDENT
DEDENT
----------------------------------------

def __getitem__(self, item) :
INDENT
    if isinstance(item, int) :
    INDENT
        key = self._keys [item]
        return self._d [key]
    DEDENT
    elif isinstance(item, slice) :
    INDENT
        keys = self._keys [item]
        return tuple(self._d [key] for key in keys)
    DEDENT
    else :
    INDENT
        return self._d [key]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41428910_41429051_5_29
41428910_41433152_13_29
Title: How to move text around when using turtle.write in Python? 
----------------------------------------

def draw_bar(t, height) :
INDENT
    t.pendown()
    t.begin_fill()
    t.lt(90)
    t.fd(height)
    t.penup()
    if height < 0 :
    INDENT
        t.fd(- 15)
    DEDENT
    t.write("   " + str(height))
    if height < 0 :
    INDENT
        t.fd(15)
    DEDENT
    t.pendown()
    t.rt(90)
    t.fd(40)
    t.rt(90)
    t.fd(height)
    t.end_fill()
    t.lt(90)
    t.penup()
    t.fd(10)

DEDENT
----------------------------------------

def draw_bar(t, height) :
INDENT
    y_baseline = t.ycor()
    t.turtlesize(abs(height) / STAMP_UNIT, BAR_WIDTH / STAMP_UNIT, 2)
    t.left(90)
    t.forward(height / 2)
    t.right(90)
    t.stamp()
    t.left(90)
    t.forward(height / 2 + (- 3 * FONTSIZE / 2 if height < 0 else 0))
    t.right(90)
    t.write(str(height), align = "center", font = FONT)
    t.forward(BAR_WIDTH + BAR_SPACING)
    t.sety(y_baseline)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41428910_41433152_13_29
41428910_43145283_10_31
Title: How to move text around when using turtle.write in Python? 
----------------------------------------

def draw_bar(t, height) :
INDENT
    y_baseline = t.ycor()
    t.turtlesize(abs(height) / STAMP_UNIT, BAR_WIDTH / STAMP_UNIT, 2)
    t.left(90)
    t.forward(height / 2)
    t.right(90)
    t.stamp()
    t.left(90)
    t.forward(height / 2 + (- 3 * FONTSIZE / 2 if height < 0 else 0))
    t.right(90)
    t.write(str(height), align = "center", font = FONT)
    t.forward(BAR_WIDTH + BAR_SPACING)
    t.sety(y_baseline)
DEDENT
----------------------------------------

def draw_bar(tur_pen, height) :
INDENT
    tur_pen.begin_fill()
    tur_pen.left(90)
    tur_pen.forward(height)
    tur_pen.penup()
    if height < 0 :
    INDENT
        tur_pen.forward(- 15)
    DEDENT
    tur_pen.write('    ' + str(height))
    if height < 0 :
    INDENT
        tur_pen.forward(15)
    DEDENT
    tur_pen.pendown()
    tur_pen.right(90)
    tur_pen.forward(40)
    tur_pen.right(90)
    tur_pen.forward(height)
    tur_pen.left(90)
    tur_pen.end_fill()
    tur_pen.penup()
    tur_pen.forward(10)
    tur_pen.pendown()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41429631_41436271_5_26
41429631_51914785_5_19
Title: How to delete 1 label when adding another - python tkinter 
----------------------------------------

def f(s) :
INDENT
    global w
    if s == "label" :
    INDENT
        if w :
        INDENT
            w.grid_forget()
        DEDENT
        w = l
        w.grid(column = 1, row = 2)
    DEDENT
    elif s == "button" :
    INDENT
        if w :
        INDENT
            w.grid_forget()
        DEDENT
        w = b
        w.grid(column = 1, row = 2)
    DEDENT
    else :
    INDENT
        print ('ERROR: unknow:', s)
    DEDENT
DEDENT
----------------------------------------

def f(s) :
INDENT
    if s == "btn" :
    INDENT

        one = Label(root, text = "one blah blah", width = 20)
        one.grid(column = 1, row = 2)
    DEDENT
    if s == "btn2" :
    INDENT

        two = Label(root, text = "two", width = 20)
        two.grid(column = 1, row = 2)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41432198_41432368_1_19
41432198_41432461_1_15
Title: List not being sorted by BubbleSort 
----------------------------------------

def BubbleSort(logindata) :
INDENT
    NoSwaps = 1
    N = len(logindata)
    while NoSwaps == 1 :
    INDENT
        Count = 1
        NoSwaps = 0
        for Count in range(N - 1) :
        INDENT
            if logindata [Count] [0] > logindata [Count + 1] [0] :
            INDENT
                temp = logindata [Count] [0]
                logindata [Count] [0] = logindata [Count + 1] [0]
                logindata [Count + 1] [0] = temp
                NoSwaps = 1
                temp = logindata [Count] [1]
                logindata [Count] [1] = logindata [Count + 1] [1]
                logindata [Count + 1] [1] = temp
            DEDENT
        DEDENT
    DEDENT
    return logindata
DEDENT
----------------------------------------

def BubbleSort(logindata) :
INDENT
    NoSwaps = 1
    N = len(logindata)
    logindata = list(logindata)
    while NoSwaps == 1 :
    INDENT
        Count = 1
        NoSwaps = 0
        for Count in range(N - 1) :
        INDENT
            if logindata [Count] > logindata [Count + 1] :
            INDENT
                temp = logindata [Count]
                logindata [Count] = logindata [Count + 1]
                logindata [Count + 1] = temp
                NoSwaps = 1
            DEDENT
        DEDENT
    DEDENT
    return tuple(logindata)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41461580_41461716_1_10
41461580_41461841_3_13
Title: Function returns None after wrong input 
----------------------------------------

def inputNumber(prompt) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            number = int(input(prompt))
            if 0 < = number < = 100 :
            INDENT
                print ('%%%', number, '%%%')
                return number
            DEDENT
            prompt = 'Number is wrong, please input number from 0 to 100: '
        DEDENT
        except ValueError :
        INDENT
            prompt = 'It is not a number, please input number from 0 to 100: '
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def inputNumber(answer) :
INDENT
    try :
    INDENT
        number = int(input(answer))
        if number < = 100 and number > = 0 :
        INDENT
            print ('%%%', number, '%%%')
            return number
        DEDENT
        else :
        INDENT
            return inputNumber('Number is wrong, please input number from 0 to 100: ')
        DEDENT
    DEDENT
    except (ValueError) :
    INDENT
        return inputNumber('It is not a number, please input number from 0 to 100: ')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41461580_41461716_1_10
41461580_41461857_3_13
Title: Function returns None after wrong input 
----------------------------------------

def inputNumber(prompt) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            number = int(input(prompt))
            if 0 < = number < = 100 :
            INDENT
                print ('%%%', number, '%%%')
                return number
            DEDENT
            prompt = 'Number is wrong, please input number from 0 to 100: '
        DEDENT
        except ValueError :
        INDENT
            prompt = 'It is not a number, please input number from 0 to 100: '
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def inputNumber(answer) :
INDENT
    try :
    INDENT
        number = int(input(answer))
        if number < = 100 and number > = 0 :
        INDENT
            print ('%%%', number, '%%%')
            return number
        DEDENT
        else :
        INDENT
            inputNumber('Number is wrong, please input number from 0 to 100: ')
        DEDENT
    DEDENT
    except (ValueError, NameError) as e :
    INDENT
        inputNumber('It is not a number, please input number from 0 to 100: ')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41461580_41461841_14_20
41461580_41461857_14_20
Title: Function returns None after wrong input 
----------------------------------------

def checkInput(number2) :
INDENT
    print ('$$$', number2, '$$$')
    if number < 50 :
    INDENT
        return number2
    DEDENT
    else :
    INDENT
        return checkInput(inputNumber('Input number from 0 to 100: '))
    DEDENT
DEDENT
----------------------------------------

def checkInput(number2) :
INDENT
    print ('$$$', number2, '$$$')
    if number < 50 :
    INDENT
        return number2
    DEDENT
    else :
    INDENT
        return checkInput(inputNumber('Input number from 0 to 100: '))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41461580_41461841_3_13
41461580_41461857_3_13
Title: Function returns None after wrong input 
----------------------------------------

def inputNumber(answer) :
INDENT
    try :
    INDENT
        number = int(input(answer))
        if number < = 100 and number > = 0 :
        INDENT
            print ('%%%', number, '%%%')
            return number
        DEDENT
        else :
        INDENT
            return inputNumber('Number is wrong, please input number from 0 to 100: ')
        DEDENT
    DEDENT
    except (ValueError) :
    INDENT
        return inputNumber('It is not a number, please input number from 0 to 100: ')
    DEDENT
DEDENT
----------------------------------------

def inputNumber(answer) :
INDENT
    try :
    INDENT
        number = int(input(answer))
        if number < = 100 and number > = 0 :
        INDENT
            print ('%%%', number, '%%%')
            return number
        DEDENT
        else :
        INDENT
            inputNumber('Number is wrong, please input number from 0 to 100: ')
        DEDENT
    DEDENT
    except (ValueError, NameError) as e :
    INDENT
        inputNumber('It is not a number, please input number from 0 to 100: ')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41479972_41480822_31_39
41479972_41480878_1_21
Title: Thread Getting Stuck At Join 
----------------------------------------

def _worker(method, * args, ** kwargs) :
INDENT
    log = StandardLogger(logger_name = '_worker')

    item = method(* args, ** kwargs)
    with lock :
    INDENT
        method_returns.append(item)
    DEDENT
    _output(item)
DEDENT
----------------------------------------

def _worker() :
INDENT
    log = StandardLogger(logger_name = '_worker')
    while True :
    INDENT
        try :
        INDENT
            method, args = q.get()
        DEDENT
        except :
        INDENT

            q.task_done()
            break
        DEDENT
        if method is None :
        INDENT
            q.task_done()
            break
        DEDENT
        item = method(* args)
        method_returns.append(item)
        _output(item)
        q.task_done()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41480797_41481201_1_14
41480797_41481232_1_14
Title: "Given two 32-bit numbers N and M and two bit positions i and j. Write a method to set all bits between i and j in N equal to M" 
----------------------------------------

def update_bits(n, m, i, j) :
INDENT
    max = ~ 0

    left = max - ((1 < < (j + 1)) - 1)

    right = ((1 < < i) - 1)

    mask = left | right

    return (n & mask) | (m < < i)
DEDENT
----------------------------------------

def update_bits(n, m, i, j) :
INDENT
    max = ~ 0

    left = max - ((1 < < (j + 1)) - 1)

    right = ((1 < < i) - 1)

    mask = left | right

    return (n & mask) | (m < < i)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41529788_41529856_1_11
41529788_41529965_1_10
Title: Python Loop Iteration issue 
----------------------------------------

def search_for_string(a_list, search_term) :
INDENT
    i = 0
    for search_term in a_list :
    INDENT
        i += 1
        if a_list [i] == search_term :
        INDENT
            return 'string found!'
        DEDENT
        elif a_list [i] ! = search_term :
        INDENT
            return 'string not found2'
        DEDENT
    DEDENT
    if len(a_list) == 0 :
    INDENT
        return 'string not found'
    DEDENT
DEDENT
----------------------------------------

def search_for_string(a_list, search_term) :
INDENT
    for index, item in enumerate(a_list) :
    INDENT
        if a_list [index] == search_term :
        INDENT
            return 'string found!'
        DEDENT
        elif len(a_list) == 0 :
        INDENT
            return 'string not found'
        DEDENT
        else :
        INDENT
            continue
        DEDENT
    DEDENT
    return 'string not found2'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41529788_41529856_1_11
41529788_41530405_1_10
Title: Python Loop Iteration issue 
----------------------------------------

def search_for_string(a_list, search_term) :
INDENT
    i = 0
    for search_term in a_list :
    INDENT
        i += 1
        if a_list [i] == search_term :
        INDENT
            return 'string found!'
        DEDENT
        elif a_list [i] ! = search_term :
        INDENT
            return 'string not found2'
        DEDENT
    DEDENT
    if len(a_list) == 0 :
    INDENT
        return 'string not found'
    DEDENT
DEDENT
----------------------------------------

def search_for_string(a_list, search_term) :
INDENT
    if len(a_list) == 0 :
    INDENT
        return False
    DEDENT
    if search_term in a_list :
    INDENT
        return "string found"
    DEDENT
    return "string not found"
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41529788_41529965_1_10
41529788_41530405_1_10
Title: Python Loop Iteration issue 
----------------------------------------

def search_for_string(a_list, search_term) :
INDENT
    for index, item in enumerate(a_list) :
    INDENT
        if a_list [index] == search_term :
        INDENT
            return 'string found!'
        DEDENT
        elif len(a_list) == 0 :
        INDENT
            return 'string not found'
        DEDENT
        else :
        INDENT
            continue
        DEDENT
    DEDENT
    return 'string not found2'
DEDENT
----------------------------------------

def search_for_string(a_list, search_term) :
INDENT
    if len(a_list) == 0 :
    INDENT
        return False
    DEDENT
    if search_term in a_list :
    INDENT
        return "string found"
    DEDENT
    return "string not found"
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41536928_41537004_1_23
41536928_41537203_1_21
Title: Cracking the coding interview #9.3: magic index algorithm 
----------------------------------------

def magic_index(seq, start = None, end = None) :
INDENT
    if start is None :
    INDENT
        start = 0
    DEDENT
    if end is None :
    INDENT
        end = len(seq) - 1
    DEDENT
    if start > end :
    INDENT
        return - 1
    DEDENT
    index = (start + end) / / 2
    if index == seq [index] :
    INDENT
        print ("Equal to index. Value of index = %s" % index)
        return index
    DEDENT
    if index > seq [index] :
    INDENT
        print ("Greater than loop. Value of Index = %s" % index)
        return magic_index(seq, start = index + 1, end = end)
    DEDENT
    else :
    INDENT
        print ("Else part of Greater. Value of index = %s" % index)
        return magic_index(seq, start = start, end = index - 1)

    DEDENT
DEDENT
----------------------------------------

def magic_index(seq, start = None, end = None) :
INDENT
    if start is None :
    INDENT
        start = 0
    DEDENT
    if end is None :
    INDENT
        end = len(seq) - 1
    DEDENT
    if (start > end or start < 0 or end > = len(seq)) :
    INDENT
        return - 1
    DEDENT
    index = (start + end) / / 2
    if (seq [index] == index) :
    INDENT
        print ("Equal to index. Value of index = %d" % index)
        return index
    DEDENT
    if (seq [index] < index) :
    INDENT
        print ("Greater than loop. Value of Index = %d" % index)
        return magic_index(seq, index + 1, index)
    DEDENT
    return magic_index(seq, start, index - 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41538090_41538428_28_36
41538090_41538428_38_48
Title: Avoiding Python globals in Google App/Cloud Engine 
----------------------------------------

def get(self) :
INDENT
    self.response.write("""
        <html><body><form action="/" method="post"><![CDATA[
            Type your name <input type="text" name="the_name"><![CDATA[
            <input type="submit" value="Continue"><![CDATA[
        </form></body></html>
        """)

DEDENT
----------------------------------------

def get(self) :
INDENT
    t_num = self.session.get('a_number')
    t_num += 1
    self.session ['a_number'] = t_num
    self.response.write("""
        <html><body><form action="/main" method="get"><![CDATA[
        Hello, %s! The number is %d. <input type="submit" value="Keep going"><![CDATA[
        </form></body></html>
        """ % (self.session.get('my_name'), t_num))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41542257_41542441_1_12
41542257_41564807_13_36
Title: reverse print an immutable linked list with less than O(n) space 
----------------------------------------

def reverse_print(LL) :
INDENT
    length = 0
    curr = LL
    while curr :
    INDENT
        length += 1
        curr = curr.next
    DEDENT
    for i in range(length, 0, - 1) :
    INDENT
        curr = LL
        for _ in range(i) :
        INDENT
            curr = curr.next
        DEDENT
        print (curr.value)
    DEDENT
DEDENT
----------------------------------------

def reverse_print(self, list_tail) :
INDENT
    list_head = self
    if not self :
    INDENT
        return
    DEDENT
    if not self.next_node() :
    INDENT
        print (self.value)
        return
    DEDENT
    if self == list_tail :
    INDENT
        print (self.value)
        return
    DEDENT
    p0 = self
    p1 = self
    p1_next = p1.next_node()
    p1_next_next = p1_next.next_node()
    while p1_next ! = list_tail and p1_next_next ! = list_tail :
    INDENT
        p1 = p1_next_next
        p0 = p0.next_node()
        p1_next = p1.next_node()
        if p1_next ! = list_tail :
        INDENT
            p1_next_next = p1_next.next_node()
        DEDENT
    DEDENT
    p0.next_node().reverse_print(list_tail)
    self.reverse_print(p0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41551267_41567420_25_40
41551267_41567420_6_19
Title: Tkinter: loading / processing input file in new frame 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    button1 = tk.Button(self, text = 'Browse', command = self.get_filename)
    button1.pack()
    self.filename = tk.StringVar()
    self.filename.set('No File Selected')
    labelFile = tk.Label(self, textvariable = self.filename)
    labelFile.pack()
    button2 = tk.Button(self, text = 'Proceed and process my data', command = lambda : self.start_processing(controller))
    button2.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = 'top', fill = 'both', expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (LoadPage, ProcessPage) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = 'nsew')
    DEDENT
    self.show_frame(LoadPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41551294_41551713_6_23
41551294_41573711_6_38
Title: How can I move the text label of a radiobutton below the button in Python Tkinter? 
----------------------------------------

def __init__(self) :
INDENT
    Tk.__init__(self)
    self.geometry("300x100")
    self.configure(background = "white")
    self.mainframe = ttk.Frame(self, padding = "8 8 12 12")
    self.mainframe.grid(column = 0, row = 0, sticky = (N, W, E, S))
    self.mainframe.columnconfigure(0, weight = 1)
    self.mainframe.rowconfigure(0, weight = 1)
    ttk.Radiobutton(self.mainframe, value = 0).grid(column = 1, row = 2)
    ttk.Label(self.mainframe, text = "Button 1").grid(column = 1, row = 3, padx = 4)
    ttk.Radiobutton(self.mainframe, value = 1).grid(column = 2, row = 2)
    ttk.Label(self.mainframe, text = "Button 2").grid(column = 2, row = 3, padx = 4)
    ttk.Radiobutton(self.mainframe, value = 2).grid(column = 3, row = 2)
    ttk.Label(self.mainframe, text = "Button 3").grid(column = 3, row = 3, padx = 4)
    ttk.Radiobutton(self.mainframe, value = 3).grid(column = 4, row = 2)
    ttk.Label(self.mainframe, text = "Button 4").grid(column = 4, row = 3, padx = 4)
    self.mainloop()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Tk.__init__(self)
    self.geometry("300x100")
    self.configure(background = "white")
    self.mainframe = ttk.Frame(self, padding = "8 8 12 12")
    self.mainframe.grid(column = 0, row = 0, sticky = (N, W, E, S))
    self.mainframe.columnconfigure(0, weight = 1)
    self.mainframe.rowconfigure(0, weight = 1)
    style = ttk.Style(self)
    style.theme_use('clam')
    style.layout('CustomRadiobutton',
        [('Radiobutton.padding',
                {'children' :
                    [('Radiobutton.indicator',
                            {'side' : 'top', 'sticky' : ''}),
                        ('Radiobutton.focus',
                            {'children' : [('Radiobutton.label', {'sticky' : 'nswe'})],
                                'side' : 'top',
                                'sticky' : ''})],
                    'sticky' : 'nswe'})])
    style.configure('TFrame', background = "white")
    style.configure('CustomRadiobutton', background = "white")
    ttk.Radiobutton(self.mainframe, style = 'CustomRadiobutton',
        text = "Button 1", value = 0).grid(column = 1, row = 2, padx = 4)
    ttk.Radiobutton(self.mainframe, style = 'CustomRadiobutton',
        text = "Button 2", value = 1).grid(column = 2, row = 2, padx = 4)
    ttk.Radiobutton(self.mainframe, style = 'CustomRadiobutton',
        text = "Button 3", value = 2).grid(column = 3, row = 2, padx = 4)
    ttk.Radiobutton(self.mainframe, style = 'CustomRadiobutton',
        text = "Button 4", value = 3).grid(column = 4, row = 2, padx = 4)
    self.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41557298_41557661_5_15
41557298_41558245_7_26
Title: Swedish robber translation 
----------------------------------------

def translate(old_string) :
INDENT
    l = len(old_string)
    translated = ""
    for let in old_string [0 : l] :
    INDENT
        if let not in vowels and let ! = " " :
        INDENT
            translated += let + "o" + let
        DEDENT
        else :
        INDENT
            translated += let
        DEDENT
    DEDENT
    return translated
DEDENT
----------------------------------------

def translate(old_string) :
INDENT
    new_string = ''

    for letter in old_string :
    INDENT
        if letter in do_not_expand :
        INDENT

            new_string += letter
        DEDENT
        else :
        INDENT

            new_string += letter + 'o' + letter

        DEDENT
    DEDENT
    return new_string
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4159331_4159646_5_13
4159331_4160577_9_16
Title: Python - Speed up an A Star Pathfinding Algorithm 
----------------------------------------

def retracePath(c) :
INDENT
    def parentgen(c) :
    INDENT
        while c :
        INDENT
            yield c
            c = c.parent
        DEDENT
    DEDENT
    result = [element for element in parentgen(c)]
    result.reverse()
    return result
DEDENT
----------------------------------------

def retracePath(c) :
INDENT
    path = [c]
    while c.parent is not None :
    INDENT
        c = c.parent
        path.append(c)
    DEDENT
    path.reverse()
    return path
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41596111_41596770_34_50
41596111_41596770_8_19
Title: Using tkinter button command from other class 
----------------------------------------

def __init__(self, master) :
INDENT
    tk.Frame.__init__(self, master)
    frame = tk.Frame(master)
    frame.pack()
    self.seldir = SelectDir(self, "Select directory", "D:\\MyPgm\\Python\\Tiles_8")
    button = tk.Button(frame, text = "><![CDATA[>>", command = self.select_dir)
    button.grid(column = 0, row = 0)
    self.act_dir = tk.StringVar()
    self.act_dir.set("D:\\MyPgm\\Python\\Tiles_8")
    entry = tk.Entry(frame, textvariable = self.act_dir, width = 30)
    entry.grid(column = 0, row = 1)
DEDENT
----------------------------------------

def __init__(self, master, title, initial) :
INDENT
    self.master = master
    self.initial = initial
    self.selected = initial
    self.options = {
        'parent' : master,
        'title' : title,
        'initialdir' : initial,
        }
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41597177_41597178_1_11
41597177_42014041_2_13
Title: get aspect ratio of axes 
----------------------------------------

def get_aspect(ax = None) :
INDENT
    if ax is None :
    INDENT
        ax = plt.gca()
    DEDENT
    fig = ax.figure
    ll, ur = ax.get_position() * fig.get_size_inches()
    width, height = ur - ll
    axes_ratio = height / width
    aspect = axes_ratio / ax.get_data_ratio()
    return aspect
DEDENT
----------------------------------------

def get_aspect(ax) :
INDENT
    figW, figH = ax.get_figure().get_size_inches()
    _, _, w, h = ax.get_position().bounds
    disp_ratio = (figH * h) / (figW * w)

    data_ratio = sub(* ax.get_ylim()) / sub(* ax.get_xlim())
    return disp_ratio / data_ratio
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41608497_41609304_1_12
41608497_41609419_11_39
Title: Runtime error - where is the mistake in my code 
----------------------------------------

def invert(y, p) :
INDENT
    test = 10 ** 10
    sign = (- 1) ** (p(2) < p(1))
    while True :
    INDENT
        if p(test) > y :
        INDENT
            test -= sign * (test / / 2)
        DEDENT
        elif p(test) < y :
        INDENT
            test += sign * (test / / 2)
        DEDENT
        else :
        INDENT
            return test
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def invert(y, p, test) :
INDENT
    if p(2) > p(1) :
    INDENT
        if p(test) > y :
        INDENT
            test = test / / 2 + (test % 2)
            return invert(y, p, test)
        DEDENT
        elif p(test) < y :
        INDENT
            test = test + (test / / 2)
            return invert(y, p, test)
        DEDENT
        else :
        INDENT
            return test
        DEDENT
    DEDENT
    if p(2) < p(1) :
    INDENT
        if p(test) < y :
        INDENT
            test = test / / 2 + (test % 2)
            return invert(y, p, test)
        DEDENT
        elif p(test) > y :
        INDENT
            test = test + (test / / 2)
            return invert(y, p, test)
        DEDENT
        else :
        INDENT
            return test
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41608497_41609304_1_12
41608497_41614994_11_21
Title: Runtime error - where is the mistake in my code 
----------------------------------------

def invert(y, p) :
INDENT
    test = 10 ** 10
    sign = (- 1) ** (p(2) < p(1))
    while True :
    INDENT
        if p(test) > y :
        INDENT
            test -= sign * (test / / 2)
        DEDENT
        elif p(test) < y :
        INDENT
            test += sign * (test / / 2)
        DEDENT
        else :
        INDENT
            return test
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def invert(y, p) :
INDENT
    x = 10 ** 10
    while p(x) ! = y :
    INDENT
        if p(x) > y :
        INDENT
            w = x
            x = x / / 2
        DEDENT
        elif p(x) < y :
        INDENT
            x = (x + w) / / 2
        DEDENT
        return x
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41608497_41609419_11_39
41608497_41614994_11_21
Title: Runtime error - where is the mistake in my code 
----------------------------------------

def invert(y, p, test) :
INDENT
    if p(2) > p(1) :
    INDENT
        if p(test) > y :
        INDENT
            test = test / / 2 + (test % 2)
            return invert(y, p, test)
        DEDENT
        elif p(test) < y :
        INDENT
            test = test + (test / / 2)
            return invert(y, p, test)
        DEDENT
        else :
        INDENT
            return test
        DEDENT
    DEDENT
    if p(2) < p(1) :
    INDENT
        if p(test) < y :
        INDENT
            test = test / / 2 + (test % 2)
            return invert(y, p, test)
        DEDENT
        elif p(test) > y :
        INDENT
            test = test + (test / / 2)
            return invert(y, p, test)
        DEDENT
        else :
        INDENT
            return test
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def invert(y, p) :
INDENT
    x = 10 ** 10
    while p(x) ! = y :
    INDENT
        if p(x) > y :
        INDENT
            w = x
            x = x / / 2
        DEDENT
        elif p(x) < y :
        INDENT
            x = (x + w) / / 2
        DEDENT
        return x
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41608497_41609419_2_10
41608497_41614994_2_8
Title: Runtime error - where is the mistake in my code 
----------------------------------------

def poly(x) :
INDENT
    result = 0
    x_n = 1
    for a in reversed(coef) :
    INDENT
        result += a * x_n
        x_n *= x
    DEDENT
    return result
    return poly
DEDENT
----------------------------------------

def poly(x) :
INDENT
    result = 0
    x_n = 1
    for a in reversed(coef) :
    INDENT
        result += a * x_n
        x_n *= x
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41618446_41619195_16_52
41618446_41619343_3_19
Title: How to count fields in a string? 
----------------------------------------

def count_variables(data) :
INDENT
    numbering = Numbering.NONE
    last_variable = 0
    variables = []
    for i in range(len(data)) :
    INDENT
        c = data [i]
        if c == '{' :
        INDENT
            match = re.match(r'(\d|^{|^})*?(?=})', data [i + 1 :])
            if not match :
            INDENT
                raise ValueError('Invalid variable formatting')
            DEDENT
            variable_body = match.group(0)
            if variable_body == '' :
            INDENT
                if numbering == Numbering.MANUAL :
                INDENT
                    raise ValueError('Cannot switch from manual to automatic numbering')
                DEDENT
                numbering = Numbering.AUTOMATIC
                variables.append(last_variable)
                last_variable += 1
            DEDENT
            else :
            INDENT
                if numbering == Numbering.AUTOMATIC :
                INDENT
                    raise ValueError('Cannot switch from automatic to manual numbering')
                DEDENT
                numbering = Numbering.MANUAL
                variables.append(int(variable_body))
            DEDENT
            i += len(variable_body) + 1
            assert data [i] == '}'
        DEDENT
    DEDENT
    if not consecutive_variables(variables) :
    INDENT
        raise ValueError('Variables are not consecutive')
    DEDENT
    return len(variables)
DEDENT
----------------------------------------

def count_variables(fmtstr) :
INDENT
    parser = string.Formatter().parse(fmtstr)
    items = []
    while True :
    INDENT
        try :
        INDENT
            item = next(parser)
            items.append(item)
            literal_text, field_name, format_spec, conversion = item
        DEDENT
        except ValueError as e :
        INDENT
            retval = e
            break
        DEDENT
        except StopIteration :
        INDENT
            retval = len(items)
            break
        DEDENT
    DEDENT
    print fmtstr + ':', retval
    return retval
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41627920_41628344_1_11
41627920_41629155_1_12
Title: Checking if IP address lies within a given range 
----------------------------------------

def match(mask, IP) :
INDENT
    min_ip = mask.split(' - ') [0].split('.')
    print min_ip
    max_ip = mask.split(' - ') [1].split('.')
    print max_ip
    ip = IP.split('.')
    print ip
    for i in range(4) :
    INDENT
        if int(ip [i]) < int(min_ip [i]) or int(ip [i]) > int(max_ip [i]) :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def match(mask, IP) :
INDENT
    min_ip = mask.split(' - ') [0].split('.')
    max_ip = mask.split(' - ') [1].split('.')
    range4 = range(int(min_ip [- 2]), int(max_ip [- 2]) + 1)
    range3 = range(int(min_ip [- 1]), int(max_ip [- 1]) + 1)
    ip = IP.split(".")
    if ((int(ip [- 2]) in range3) and (int(ip [- 1]) in range4)) :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41635162_41635207_1_8
41635162_41635242_1_7
Title: "Python: Help function not producing what I want" 
----------------------------------------

def collatz(number) :
INDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number //= 2
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
        DEDENT
        print (number)
    DEDENT
DEDENT
----------------------------------------

def collatz(starting_value) :
INDENT
    value = starting_value
    while value ! = 1 :
    INDENT
        value = (3 * value + 1) if value % 2 else (value / / 2)
        yield value
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41635162_41635207_1_8
41635162_41635259_1_12
Title: "Python: Help function not producing what I want" 
----------------------------------------

def collatz(number) :
INDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number //= 2
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
        DEDENT
        print (number)
    DEDENT
DEDENT
----------------------------------------

def collatz() :
INDENT
    try :
    INDENT
        number = int(input("Please enter a number: "))
    DEDENT
    except ValueError :
    INDENT
        collatz()
    DEDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number = number / / 2
            print (number)
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
            print (number)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41635162_41635207_1_8
41635162_41635291_1_11
Title: "Python: Help function not producing what I want" 
----------------------------------------

def collatz(number) :
INDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number //= 2
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
        DEDENT
        print (number)
    DEDENT
DEDENT
----------------------------------------

def collatz() :
INDENT
    try :
    INDENT
        number = int(input("Please enter a number: "))
    DEDENT
    except ValueError :
    INDENT
        collatz()
    DEDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number = number / / 2
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
        DEDENT
        print (number)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41635162_41635207_1_8
41635162_41635503_1_14
Title: "Python: Help function not producing what I want" 
----------------------------------------

def collatz(number) :
INDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number //= 2
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
        DEDENT
        print (number)
    DEDENT
DEDENT
----------------------------------------

def collatz() :
INDENT
    number = 0
    while number < 1 :
    INDENT
        try :
        INDENT
            number = int(input("Please enter a number: "))
        DEDENT
        except ValueError, NameError :
        INDENT
            pass
        DEDENT
    DEDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number = number / / 2
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
        DEDENT
        print (number)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41635162_41635242_1_7
41635162_41635259_1_12
Title: "Python: Help function not producing what I want" 
----------------------------------------

def collatz(starting_value) :
INDENT
    value = starting_value
    while value ! = 1 :
    INDENT
        value = (3 * value + 1) if value % 2 else (value / / 2)
        yield value
    DEDENT
DEDENT
----------------------------------------

def collatz() :
INDENT
    try :
    INDENT
        number = int(input("Please enter a number: "))
    DEDENT
    except ValueError :
    INDENT
        collatz()
    DEDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number = number / / 2
            print (number)
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
            print (number)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41635162_41635242_1_7
41635162_41635291_1_11
Title: "Python: Help function not producing what I want" 
----------------------------------------

def collatz(starting_value) :
INDENT
    value = starting_value
    while value ! = 1 :
    INDENT
        value = (3 * value + 1) if value % 2 else (value / / 2)
        yield value
    DEDENT
DEDENT
----------------------------------------

def collatz() :
INDENT
    try :
    INDENT
        number = int(input("Please enter a number: "))
    DEDENT
    except ValueError :
    INDENT
        collatz()
    DEDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number = number / / 2
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
        DEDENT
        print (number)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41635162_41635242_1_7
41635162_41635503_1_14
Title: "Python: Help function not producing what I want" 
----------------------------------------

def collatz(starting_value) :
INDENT
    value = starting_value
    while value ! = 1 :
    INDENT
        value = (3 * value + 1) if value % 2 else (value / / 2)
        yield value
    DEDENT
DEDENT
----------------------------------------

def collatz() :
INDENT
    number = 0
    while number < 1 :
    INDENT
        try :
        INDENT
            number = int(input("Please enter a number: "))
        DEDENT
        except ValueError, NameError :
        INDENT
            pass
        DEDENT
    DEDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number = number / / 2
        DEDENT
        else :
        INDENT
            number = 3 * number + 1
        DEDENT
        print (number)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41636867_41636922_3_8
41636867_41636931_5_10
Title: How to share variable between functions in python? 
----------------------------------------

def fun1(string) :
INDENT
    out = []
    for letter in a :
    INDENT
        out.append(string + letter)
    DEDENT
    return out
DEDENT
----------------------------------------

def fun1(self, string) :
INDENT
    out = []
    for letter in self.a :
    INDENT
        out.append(string + letter)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41636867_41636922_9_14
41636867_41636931_11_16
Title: How to share variable between functions in python? 
----------------------------------------

def fun2(number) :
INDENT
    out = []
    for letter in a :
    INDENT
        out.append(str(number) + letter)
    DEDENT
    return out
DEDENT
----------------------------------------

def fun2(self, number) :
INDENT
    out = []
    for letter in self.a :
    INDENT
        out.append(str(number) + letter)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41638263_41638364_5_12
41638263_41644849_9_16
Title: Crawl a music website to get it lyrics 
----------------------------------------

def parse(self, response) :
INDENT
    yield
    {
        'song' : response.css('.txt-primary h1::text').extract() [0],
        'artist' : response.css('.artist-track-log a::text').extract() [0],
        'genre' : response.css('.genre-track-log::text').extract() [0],
        'lyrics' : response.css('.fn-content::text').extract() [0]}
DEDENT
----------------------------------------

def parse(self, response) :
INDENT
    yield
    {
        'song' : response.css('s.fn-name::text').extract(),
        'artist' : response.css('.inline h2::text').extract_first(),
        'genre' : response.xpath("//div[@class='inline']/h2/a[contains(font.font,'')]//text()").re('[^\n].*\w') [2 :],
        'lyrics' : response.css('.fn-wlyrics.fn-content::text').re('[^\n].*\w+'),
        }
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41643370_41643410_11_29
41643370_41643481_1_11
Title: Global variables in python 3 
----------------------------------------

def rating_system(t1, t2) :
INDENT
    global ta
    global tb
    global tc
    global td
    if t1 < t2 and t2 / t1 < = 4 :
    INDENT
        rating = (t2 / t1) * 0.25
        t1 += rating
        t2 -= rating
    DEDENT
    else :
    INDENT
        rating = (t2 / t1) * 0.4
        t1 += rating
        t2 -= rating
    DEDENT
    print "From Function"
    print (str(t1) + " and " + str(t2))
    ta = t1
    tb = t2
DEDENT
----------------------------------------

def rating_system(t1, t2) :
INDENT
    if t1 < t2 and t2 / t1 < = 4 :
    INDENT
        rating = (t2 / t1) * 0.25
        t1 += rating
        t2 -= rating
    DEDENT
    else :
    INDENT
        rating = (t2 / t1) * 0.4
        t1 += rating
        t2 -= rating
    DEDENT
    return (t1, t2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41645044_41645175_3_20
41645044_41645358_12_19
Title: Changing directory and renaming issues 
----------------------------------------

def rename_files() :
INDENT
    file_list = os.listdir("/Users/bill/Documents/web/LocalServer/prank")
    saved_path = os.getcwd()
    print ("Our current working directory is " + saved_path)
    os.chdir('/Users/bill/Documents/web/LocalServer/prank')
    new_path = os.getcwd()
    print ("Our current working directory is ", new_path)
    for file_name in file_list :
    INDENT

        os.rename(file_name, ''.join([i for i in file_name if not i.isdigit()]))
    DEDENT
    os.chdir(saved_path)
    print ("Our current working directory is ", saved_path)
DEDENT
----------------------------------------

def rename_files(path) :
INDENT
    TRANS_TABLE = str.maketrans(dict.fromkeys(string.digits))
    with temp_cd(path) :
    INDENT
        for file_name in os.listdir(path) :
        INDENT
            if any(ch in file_name for ch in string.digits) :
            INDENT
                print (file_name, '->', file_name.translate(TRANS_TABLE))
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41645044_41645175_3_20
41645044_41645504_3_10
Title: Changing directory and renaming issues 
----------------------------------------

def rename_files() :
INDENT
    file_list = os.listdir("/Users/bill/Documents/web/LocalServer/prank")
    saved_path = os.getcwd()
    print ("Our current working directory is " + saved_path)
    os.chdir('/Users/bill/Documents/web/LocalServer/prank')
    new_path = os.getcwd()
    print ("Our current working directory is ", new_path)
    for file_name in file_list :
    INDENT

        os.rename(file_name, ''.join([i for i in file_name if not i.isdigit()]))
    DEDENT
    os.chdir(saved_path)
    print ("Our current working directory is ", saved_path)
DEDENT
----------------------------------------

def rename_files(directory) :
INDENT
    xlat = str.maketrans('', '', '0123457689')
    file_list = os.listdir(directory)
    for file_name in file_list :
    INDENT
        old_name = os.path.join(directory, file_name)
        new_name = os.path.join(directory, file_name.translate(xlat))
        os.rename(old_name, new_name)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41645044_41645358_12_19
41645044_41645504_3_10
Title: Changing directory and renaming issues 
----------------------------------------

def rename_files(path) :
INDENT
    TRANS_TABLE = str.maketrans(dict.fromkeys(string.digits))
    with temp_cd(path) :
    INDENT
        for file_name in os.listdir(path) :
        INDENT
            if any(ch in file_name for ch in string.digits) :
            INDENT
                print (file_name, '->', file_name.translate(TRANS_TABLE))
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def rename_files(directory) :
INDENT
    xlat = str.maketrans('', '', '0123457689')
    file_list = os.listdir(directory)
    for file_name in file_list :
    INDENT
        old_name = os.path.join(directory, file_name)
        new_name = os.path.join(directory, file_name.translate(xlat))
        os.rename(old_name, new_name)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41651120_41651981_26_32
41651120_45392235_25_31
Title: python tkinter image layers (paste / unpaste image on background) 
----------------------------------------

def cloud(self) :
INDENT
    for idx in range(5) :
    INDENT
        pos_x = randint(1, 220)
        pos_y = randint(1, 220)
        self.mylist.append(self.canvas.create_image(pos_x, pos_y, image = self.mycloud))
    DEDENT
DEDENT
----------------------------------------

def cloud(self) :
INDENT
    for idx in range(5) :
    INDENT
        pos_x = randint(1, 220)
        pos_y = randint(1, 220)
        self.mylist.append(self.canvas.create_image(pos_x, pos_y, image = self.mycloud))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41657571_41658577_9_22
41657571_41659153_9_22
Title: "Only __iter__ implemented as generator-func want to use next()" 
----------------------------------------

def __next__(self) :
INDENT
    while True :
    INDENT
        if self._iterating is not None :
        INDENT
            try :
            INDENT
                return next(self._iterating)
            DEDENT
            except StopIteration :
            INDENT
                self._iterating = None
            DEDENT
        DEDENT
        value = next(self._iterator)
        if isinstance(value, collections.abc.Iterable) :
        INDENT
            self._iterating = iter(value)
        DEDENT
        else :
        INDENT
            return value

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __next__(self) :
INDENT
    while True :
    INDENT
        if self._subiterator is None :
        INDENT
            value = next(self._iterator)
            try :
            INDENT
                self._subiterator = iter(value)
            DEDENT
            except TypeError :
            INDENT
                return value
            DEDENT
        DEDENT
        try :
        INDENT
            return next(self._subiterator)
        DEDENT
        except StopIteraton :
        INDENT
            self._subiterator = None
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41660862_41661076_2_11
41660862_41661792_2_13
Title: Linking a html button with python script 
----------------------------------------

def index() :
INDENT
    message1 = ''
    if request.method == 'POST' :
    INDENT
        message1 = request.form ['Msg']
    DEDENT
    if message1 :
    INDENT
        print (message1)
        msg = Message('Hello', sender = 'Id@gmail.com', recipients = ['Id@gmail.com'])
        msg.body = message1
        mail.send(msg)
    DEDENT
    return render_template("index.html")
DEDENT
----------------------------------------

def index() :
INDENT
    if request.method == 'POST' :
    INDENT
        message1 = request.form ['title'];
    DEDENT
    print ('message1')
    msg = Message('Hello', sender = 'Id@gmail.com', recipients = ['Id@gmail.com'])
    msg.body = message1
    mail.send(msg)
    return render_template("index.html")
    if __name__ == '__main__' :
    INDENT
        app.run()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41661514_41668609_3_19
41661514_41678122_3_23
Title: "Python tkinter: How to identify positions of items in a grid?" 
----------------------------------------

def game(width, height) :
INDENT
    for x in range(width) :
    INDENT

        squares.append([None] * height)
        for y in range(height) :
        INDENT
            squares [- 1] [y] = Button(gameWindow)
            squares [- 1] [y].grid(column = x, row = (y + 1), sticky = (N + S + E + W))
        DEDENT
    DEDENT
    for x in range(width) :
    INDENT

        Grid.columnconfigure(gameWindow, x, weight = 1)
    DEDENT
    for y in range(height) :
    INDENT

        Grid.rowconfigure(gameWindow, (y + 1), weight = 1)
    DEDENT
DEDENT
----------------------------------------

def game(width, height, gameWindow) :
INDENT
    colors = ['green', 'blue', 'yellow', 'white',
        'black', 'brown', 'purple', 'cyan']
    for x in range(width) :
    INDENT
        for y in range(height) :
        INDENT

            color = colors [y]
            print ('color = {}'.format(color))
            square = Button(gameWindow, background = color,
                activebackground = 'gold')
            square.grid(column = x, row = (y + 1), sticky = (N + S + E + W))
        DEDENT
    DEDENT
    for x in range(width) :
    INDENT
        Grid.columnconfigure(gameWindow, x, weight = 1)
    DEDENT
    for y in range(height) :
    INDENT
        Grid.rowconfigure(gameWindow, (y + 1), weight = 1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41677831_41687049_15_20
41677831_41702919_13_18
Title: Decay curve best fit SciPy 
----------------------------------------

def h(time, k) :
INDENT
    result = luminosity_max * ((time - time_min) / k) ** (- 5./ 3.)
    if np.isnan(result) :
    INDENT
        result = luminosity_max
    DEDENT
    return result
DEDENT
----------------------------------------

def h(time, k) :
INDENT
    result = luminosity_max * (max(time - time_min, 5) / k) ** (- 5./ 3.)
    if np.isnan(result) :
    INDENT
        result = luminosity_max
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41679063_41687202_28_36
41679063_41687202_6_13
Title: Live Plotting with PyQtGraph in PyQt4 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(LoginWidget, self).__init__(parent)
    layout = QtGui.QHBoxLayout()
    self.button = QtGui.QPushButton('Start Plotting')
    layout.addWidget(self.button)
    self.plot = pg.PlotWidget()
    layout.addWidget(self.plot)
    self.setLayout(layout)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.central_widget = QtGui.QStackedWidget()
    self.setCentralWidget(self.central_widget)
    self.login_widget = LoginWidget(self)
    self.login_widget.button.clicked.connect(self.plotter)
    self.central_widget.addWidget(self.login_widget)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41710791_41711121_27_32
41710791_41711124_22_31
Title: How to draw a line from mouse to a point in PyQt5? 
----------------------------------------

def paintEvent(self, event) :
INDENT
    if self.pos :
    INDENT
        q = QPainter(self)
        q.drawLine(self.pos.x(), self.pos.y(), 250, 500)

    DEDENT
DEDENT
----------------------------------------

def paintEvent(self, e) :
INDENT
    if not (self.x == - 1 or self.y == - 1) :
    INDENT
        q = QPainter()
        q.begin(self)
        q.drawLine(self.x, self.y, 250, 500)
        q.end()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41721734_41745378_8_76
41721734_50663648_5_36
Title: Take screenshot of full page with Selenium Python with chromedriver 
----------------------------------------

def fullpage_screenshot(driver, file) :
INDENT
    print ("Starting chrome full page screenshot workaround ...")
    total_width = driver.execute_script("return document.body.offsetWidth")
    total_height = driver.execute_script("return document.body.parentNode.scrollHeight")
    viewport_width = driver.execute_script("return document.body.clientWidth")
    viewport_height = driver.execute_script("return window.innerHeight")
    print ("Total: ({0}, {1}), Viewport: ({2},{3})".format(total_width, total_height, viewport_width, viewport_height))
    rectangles = []
    i = 0
    while i < total_height :
    INDENT
        ii = 0
        top_height = i + viewport_height
        if top_height > total_height :
        INDENT
            top_height = total_height
        DEDENT
        while ii < total_width :
        INDENT
            top_width = ii + viewport_width
            if top_width > total_width :
            INDENT
                top_width = total_width
            DEDENT
            print ("Appending rectangle ({0},{1},{2},{3})".format(ii, i, top_width, top_height))
            rectangles.append((ii, i, top_width, top_height))
            ii = ii + viewport_width
        DEDENT
        i = i + viewport_height
    DEDENT
    stitched_image = Image.new('RGB', (total_width, total_height))
    previous = None
    part = 0
    for rectangle in rectangles :
    INDENT
        if not previous is None :
        INDENT
            driver.execute_script("window.scrollTo({0}, {1})".format(rectangle [0], rectangle [1]))
            time.sleep(0.2)
            driver.execute_script("document.getElementById('topnav').setAttribute('style', 'position: absolute; top: 0px;');")
            time.sleep(0.2)
            print ("Scrolled To ({0},{1})".format(rectangle [0], rectangle [1]))
            time.sleep(0.2)
        DEDENT
        file_name = "part_{0}.png".format(part)
        print ("Capturing {0} ...".format(file_name))
        driver.get_screenshot_as_file(file_name)
        screenshot = Image.open(file_name)
        if rectangle [1] + viewport_height > total_height :
        INDENT
            offset = (rectangle [0], total_height - viewport_height)
        DEDENT
        else :
        INDENT
            offset = (rectangle [0], rectangle [1])
        DEDENT
        print ("Adding to stitched image with offset ({0}, {1})".format(offset [0], offset [1]))
        stitched_image.paste(screenshot, offset)
        del screenshot
        os.remove(file_name)
        part = part + 1
        previous = rectangle
    DEDENT
    stitched_image.save(file)
    print ("Finishing chrome full page screenshot workaround...")
    return True

DEDENT
----------------------------------------

def fullpage_screenshot(driver, file, scroll_delay = 0.3) :
INDENT
    device_pixel_ratio = driver.execute_script('return window.devicePixelRatio')
    total_height = driver.execute_script('return document.body.parentNode.scrollHeight')
    viewport_height = driver.execute_script('return window.innerHeight')
    total_width = driver.execute_script('return document.body.offsetWidth')
    viewport_width = driver.execute_script("return document.body.clientWidth")

    assert (viewport_width == total_width)
    offset = 0
    slices = {}
    while offset < total_height :
    INDENT
        if offset + viewport_height > total_height :
        INDENT
            offset = total_height - viewport_height
        DEDENT
        driver.execute_script('window.scrollTo({0}, {1})'.format(0, offset))
        time.sleep(scroll_delay)
        img = Image.open(BytesIO(driver.get_screenshot_as_png()))
        slices [offset] = img
        offset = offset + viewport_height

    DEDENT
    stitched_image = Image.new('RGB', (total_width * device_pixel_ratio, total_height * device_pixel_ratio))
    for offset, image in slices.items() :
    INDENT
        stitched_image.paste(image, (0, offset * device_pixel_ratio))
    DEDENT
    stitched_image.save(file)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41723097_41723284_8_20
41723097_41724649_12_26
Title: How should you review past items from an iterable? 
----------------------------------------

def contains(iterable, sequence) :
INDENT
    length = len(sequence)
    if length > len(iterable) :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        upper_bound = len(iterable) - length
        for i in range(upper_bound + 1) :
        INDENT
            if iterable [i : i + length] == sequence :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
    return False

DEDENT
----------------------------------------

def contains(iterable, sequence) :
INDENT
    offset, length = 0, len(sequence)
    iterator = IteratorWithHistory(iterable, length - 1)
    for item in iterator :
    INDENT
        if item == sequence [offset] :
        INDENT
            offset += 1
            if offset == length :
            INDENT
                return True
            DEDENT
        DEDENT
        elif offset :
        INDENT
            iterator.rewind(offset)
            offset = 0
        DEDENT
    DEDENT
    return False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41723097_41723284_8_20
41723097_41730120_2_22
Title: How should you review past items from an iterable? 
----------------------------------------

def contains(iterable, sequence) :
INDENT
    length = len(sequence)
    if length > len(iterable) :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        upper_bound = len(iterable) - length
        for i in range(upper_bound + 1) :
        INDENT
            if iterable [i : i + length] == sequence :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
    return False

DEDENT
----------------------------------------

def contains(a, b) :
INDENT
    ag = (i for i in a)
    try :
    INDENT

        history = [next(ag) for _ in b]
        while True :
        INDENT
            if not [1 for j, e in zip(history, b) if j ! = e] :
            INDENT
                return True
            DEDENT
            history.pop(0)
            history.append(next(ag))
        DEDENT
    DEDENT
    except StopIteration :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41723097_41724649_12_26
41723097_41730120_2_22
Title: How should you review past items from an iterable? 
----------------------------------------

def contains(iterable, sequence) :
INDENT
    offset, length = 0, len(sequence)
    iterator = IteratorWithHistory(iterable, length - 1)
    for item in iterator :
    INDENT
        if item == sequence [offset] :
        INDENT
            offset += 1
            if offset == length :
            INDENT
                return True
            DEDENT
        DEDENT
        elif offset :
        INDENT
            iterator.rewind(offset)
            offset = 0
        DEDENT
    DEDENT
    return False

DEDENT
----------------------------------------

def contains(a, b) :
INDENT
    ag = (i for i in a)
    try :
    INDENT

        history = [next(ag) for _ in b]
        while True :
        INDENT
            if not [1 for j, e in zip(history, b) if j ! = e] :
            INDENT
                return True
            DEDENT
            history.pop(0)
            history.append(next(ag))
        DEDENT
    DEDENT
    except StopIteration :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41731649_41742560_19_39
41731649_41742560_42_54
Title: How to align widgets contained on several HBoxLayouts? 
----------------------------------------

def __init__(self, value, num_components, max_columns = 4, parent = None, * args, ** kwargs) :
INDENT
    super().__init__(parent, * args, ** kwargs)
    self.components = []
    if num_components > max_columns :
    INDENT
        num_components = max_columns
    DEDENT
    layout = QHBoxLayout(self)
    for i in range(num_components) :
    INDENT
        c = QLineEdit(str(value [i]), self)
        c.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Expanding)
        self.components.append(c)
        layout.addWidget(c, stretch = 1)
    DEDENT
    for i in range(num_components, max_columns) :
    INDENT
        lbl = QLabel('')
        lbl.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Expanding)
        layout.addWidget(lbl, stretch = 1)
    DEDENT
    layout.setContentsMargins(0, 0, 0, 0)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, columns, * args, ** kwargs) :
INDENT
    super(PropertiesWidget, self).__init__(* args, ** kwargs)
    self.model = QStandardItemModel(self)
    self.setModel(self.model)
    self.model.setColumnCount(columns)
    self.model.setHeaderData(0, Qt.Horizontal, "Property")
    self.model.setHeaderData(1, Qt.Horizontal, "Value")
    self.setFocusPolicy(Qt.NoFocus)
    self.last_item = 0
    self.last_item = QStandardItem()
    self.parameters = {}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
417703_417773_1_13
417703_417893_1_5
Title: Python: C++-like stream input 
----------------------------------------

def read_tokens(file) :
INDENT
    while True :
    INDENT
        token = []
        while True :
        INDENT
            c = file.read(1)
            if c not in ['', ' ', '\t', '\n'] :
            INDENT
                token.append(c)
            DEDENT
            elif c in [' ', '\t', '\n'] :
            INDENT
                yield ''.join(token)
                break
            DEDENT
            elif c == '' :
            INDENT
                yield ''.join(token)
                raise StopIteration
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def read_tokens(f) :
INDENT
    for line in f :
    INDENT
        for token in line.split() :
        INDENT
            yield token
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41774551_41776952_5_35
41774551_41777165_5_27
Title: Updating all keys in python OrderDic 
----------------------------------------

def new_increase_color(color_dict) :
INDENT
    new_dict = dict(color_dict)
    for key in color_dict :
    INDENT
        color = str(key)
        color = (color.replace("b'", "", 1))
        color = (color.replace("'", ""))

        n = 2
        rgb = ([str(color) [i : i + n] for i in range(0, len(str(color)), n)])

        index, value = max(enumerate(rgb), key = operator.itemgetter(1))
        print ("value before: %s" % value)

        value = (0xFF - int(value, 16)) / / 2 + int(value, 16)
        rgb [index] = hex(value).replace("0x", "", 1)

        new_key = bytes(''.join(rgb), encoding = 'us-ascii')

        new_dict [new_key] = new_dict [key]
        del new_dict [key]

    DEDENT
    return new_dict
DEDENT
----------------------------------------

def new_increase_color(old_dict) :
INDENT
    new_dict = OrderedDict()
    for key in old_dict :
    INDENT
        color = str(key.decode())

        rgb = [color [i : i + 2] for i in (0, 2, 4)]

        index, value = max(enumerate(rgb), key = operator.itemgetter(1))

        value = int(value, 16)
        value = (0xFF - value) / / 2 + value
        rgb [index] = format(value, '02x')

        new_key = ''.join(rgb)

        new_dict [new_key] = old_dict [key]
    DEDENT
    return new_dict
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41789133_41796717_1_22
41789133_42360236_1_95
Title: What are c_state and m_state in Tensorflow LSTM? 
----------------------------------------

def __call__(self, inputs, state, scope = None) :
INDENT
    with vs.variable_scope(scope or type(self).__name__) :
    INDENT
        if self._state_is_tuple :
        INDENT
            c, h = state
        DEDENT
        else :
        INDENT
            c, h = array_ops.split(1, 2, state)
        DEDENT
        concat = _linear([inputs, h], 4 * self._num_units, True)

        i, j, f, o = array_ops.split(1, 4, concat)
        new_c = (c * sigmoid(f + self._forget_bias) + sigmoid(i) *
            self._activation(j))
        new_h = self._activation(new_c) * sigmoid(o)
        if self._state_is_tuple :
        INDENT
            new_state = LSTMStateTuple(new_c, new_h)
        DEDENT
        else :
        INDENT
            new_state = array_ops.concat(1, [new_c, new_h])
        DEDENT
        return new_h, new_state
    DEDENT
DEDENT
----------------------------------------

def __call__(self, inputs, state, scope = None) :
INDENT
    num_proj = self._num_units if self._num_proj is None else self._num_proj
    if self._state_is_tuple :
    INDENT
        (c_prev, m_prev) = state
    DEDENT
    else :
    INDENT
        c_prev = array_ops.slice(state, [0, 0], [- 1, self._num_units])
        m_prev = array_ops.slice(state, [0, self._num_units], [- 1, num_proj])
    DEDENT
    dtype = inputs.dtype
    input_size = inputs.get_shape().with_rank(2) [1]
    if input_size.value is None :
    INDENT
        raise ValueError("Could not infer input size from inputs.get_shape()[-1]")
    DEDENT
    with vs.variable_scope(scope or "lstm_cell",
        initializer = self._initializer) as unit_scope :
    INDENT
        if self._num_unit_shards is not None :
        INDENT
            unit_scope.set_partitioner(
                partitioned_variables.fixed_size_partitioner(
                    self._num_unit_shards))
        DEDENT
        lstm_matrix = _linear([inputs, m_prev], 4 * self._num_units, bias = True,
            scope = scope)
        i, j, f, o = array_ops.split(
            value = lstm_matrix, num_or_size_splits = 4, axis = 1)

        if self._use_peepholes :
        INDENT
            with vs.variable_scope(unit_scope) as projection_scope :
            INDENT
                if self._num_unit_shards is not None :
                INDENT
                    projection_scope.set_partitioner(None)
                DEDENT
                w_f_diag = vs.get_variable(
                    "w_f_diag", shape = [self._num_units], dtype = dtype)
                w_i_diag = vs.get_variable(
                    "w_i_diag", shape = [self._num_units], dtype = dtype)
                w_o_diag = vs.get_variable(
                    "w_o_diag", shape = [self._num_units], dtype = dtype)
            DEDENT
        DEDENT
        if self._use_peepholes :
        INDENT
            c = (sigmoid(f + self._forget_bias + w_f_diag * c_prev) * c_prev +
                sigmoid(i + w_i_diag * c_prev) * self._activation(j))
        DEDENT
        else :
        INDENT
            c = (sigmoid(f + self._forget_bias) * c_prev + sigmoid(i) *
                self._activation(j))
        DEDENT
        if self._cell_clip is not None :
        INDENT

            c = clip_ops.clip_by_value(c, - self._cell_clip, self._cell_clip)

        DEDENT
        if self._use_peepholes :
        INDENT
            m = sigmoid(o + w_o_diag * c) * self._activation(c)
        DEDENT
        else :
        INDENT
            m = sigmoid(o) * self._activation(c)
        DEDENT
        if self._num_proj is not None :
        INDENT
            with vs.variable_scope("projection") as proj_scope :
            INDENT
                if self._num_proj_shards is not None :
                INDENT
                    proj_scope.set_partitioner(
                        partitioned_variables.fixed_size_partitioner(
                            self._num_proj_shards))
                DEDENT
                m = _linear(m, self._num_proj, bias = False, scope = scope)
            DEDENT
            if self._proj_clip is not None :
            INDENT

                m = clip_ops.clip_by_value(m, - self._proj_clip, self._proj_clip)

            DEDENT
        DEDENT
    DEDENT
    new_state = (LSTMStateTuple(c, m) if self._state_is_tuple else
        array_ops.concat([c, m], 1))
    return m, new_state
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41796138_41796396_35_50
41796138_41796396_9_22
Title: Call a variable from another Class in python 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(SaveDialog, self).__init__(parent)
    vbox = QtGui.QVBoxLayout()

    self.label = QtGui.QLabel(self, text = self.parent().Value)
    vbox.addWidget(self.label)
    self.button = QtGui.QPushButton(self, text = "Update label")
    self.button.clicked.connect(self.button_clicked)
    vbox.addWidget(self.button)
    self.setLayout(vbox)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(DataAcquisition, self).__init__(parent)
    self.startButton = QtGui.QPushButton(self, text = "Show Dialog")
    self.startButton.clicked.connect(self.startButton_clicked)
    self.th = Thread(target = self.runValue)

    self.Value = "Hello World!"

    self.popSave = SaveDialog(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41796800_41797310_60_75
41796800_41797310_77_118
Title: AttributeError: 'FaderWidget' object has no attribute 'pixmap_opacity' 
----------------------------------------

def __init__(self) :
INDENT
    super(editor_, self).__init__()
    editor = QTextEdit()
    editor.setPlainText("Kawabungaaaa! " * 100)
    self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
    self.buttonBox.accepted.connect(self.close)
    layout = QVBoxLayout()
    layout.addWidget(editor)
    layout.addWidget(self.buttonBox)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(mainWidget, self).__init__()
    self.setMinimumSize(500, 300)
    widget1 = QWidget()
    widget2 = QCalendarWidget()
    widget3 = QListView()
    widget4 = editor_()
    grid = QGridLayout()
    allPlates = QPushButton("Calendar")
    singlePlate = QPushButton("ListView")
    allRoto = QPushButton("Editor")
    allLighting = QPushButton("Buttons")
    grid.addWidget(allPlates, 0, 0)
    grid.addWidget(singlePlate, 0, 1)
    grid.addWidget(allRoto, 1, 0)
    grid.addWidget(allLighting, 1, 1)
    widget1.setLayout(grid)
    stack = StackedWidget()
    stack.addWidget(widget1)
    stack.addWidget(widget2)
    stack.addWidget(widget3)
    stack.addWidget(widget4)
    widget4.buttonBox.rejected.connect(stack.setPage1)
    layout = QHBoxLayout()
    layout.addWidget(stack)
    self.setLayout(layout)
    allPlates.clicked.connect(stack.setPage2)
    singlePlate.clicked.connect(stack.setPage3)
    allRoto.clicked.connect(stack.setPage4)
    allLighting.clicked.connect(stack.setPage1)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41796800_41797310_60_75
41796800_41797310_8_23
Title: AttributeError: 'FaderWidget' object has no attribute 'pixmap_opacity' 
----------------------------------------

def __init__(self) :
INDENT
    super(editor_, self).__init__()
    editor = QTextEdit()
    editor.setPlainText("Kawabungaaaa! " * 100)
    self.buttonBox = QDialogButtonBox(QDialogButtonBox.Ok | QDialogButtonBox.Cancel)
    self.buttonBox.accepted.connect(self.close)
    layout = QVBoxLayout()
    layout.addWidget(editor)
    layout.addWidget(self.buttonBox)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, old_widget, new_widget) :
INDENT
    QWidget.__init__(self, new_widget)
    self.old_pixmap = QPixmap(new_widget.size())
    old_widget.render(self.old_pixmap)
    self.pixmap_opacity = 1.0
    self.timeline = QTimeLine()
    self.timeline.valueChanged.connect(self.animate)
    self.timeline.finished.connect(self.close)
    self.timeline.setDuration(333)
    self.timeline.start()
    self.resize(new_widget.size())
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41796800_41797310_77_118
41796800_41797310_8_23
Title: AttributeError: 'FaderWidget' object has no attribute 'pixmap_opacity' 
----------------------------------------

def __init__(self) :
INDENT
    super(mainWidget, self).__init__()
    self.setMinimumSize(500, 300)
    widget1 = QWidget()
    widget2 = QCalendarWidget()
    widget3 = QListView()
    widget4 = editor_()
    grid = QGridLayout()
    allPlates = QPushButton("Calendar")
    singlePlate = QPushButton("ListView")
    allRoto = QPushButton("Editor")
    allLighting = QPushButton("Buttons")
    grid.addWidget(allPlates, 0, 0)
    grid.addWidget(singlePlate, 0, 1)
    grid.addWidget(allRoto, 1, 0)
    grid.addWidget(allLighting, 1, 1)
    widget1.setLayout(grid)
    stack = StackedWidget()
    stack.addWidget(widget1)
    stack.addWidget(widget2)
    stack.addWidget(widget3)
    stack.addWidget(widget4)
    widget4.buttonBox.rejected.connect(stack.setPage1)
    layout = QHBoxLayout()
    layout.addWidget(stack)
    self.setLayout(layout)
    allPlates.clicked.connect(stack.setPage2)
    singlePlate.clicked.connect(stack.setPage3)
    allRoto.clicked.connect(stack.setPage4)
    allLighting.clicked.connect(stack.setPage1)

DEDENT
----------------------------------------

def __init__(self, old_widget, new_widget) :
INDENT
    QWidget.__init__(self, new_widget)
    self.old_pixmap = QPixmap(new_widget.size())
    old_widget.render(self.old_pixmap)
    self.pixmap_opacity = 1.0
    self.timeline = QTimeLine()
    self.timeline.valueChanged.connect(self.animate)
    self.timeline.finished.connect(self.close)
    self.timeline.setDuration(333)
    self.timeline.start()
    self.resize(new_widget.size())
    self.show()
DEDENT
----------------------------------------
