$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47096150_47096640_1_6
47096150_47106518_1_6
Title: Python3: for-loop break and else (if statement) 
----------------------------------------

def validationHelper(myDict, myList) :
INDENT
    for item in myList :
    INDENT
        if item in myDict.values() :
        INDENT
            return ("String is valid")
        DEDENT
    DEDENT
    return ("String is NOT valid")
DEDENT
----------------------------------------

def validationHelper(myDict, myList) :
INDENT
    if any(v in myList for val in myDict.values() for v in val [0]) :
    INDENT
        validationHelper.true = "String is valid"
    DEDENT
    else :
    INDENT
        validationHelper.true = "Warning: String is NOT valid"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47097492_47098743_21_51
47097492_47098770_10_33
Title: Reading words from txt file - Python 
----------------------------------------

def main() :
INDENT
    characters = '!?¿-.:;-,><=*»¡'
    aux = []
    counts = {}
    with open(sys.argv [1], "r") as f :
    INDENT

        contents = f.read().strip().lower()
        contents = replace_special_chars(contents, characters)
        aux = contents.split()

    DEDENT
    if len(sys.argv) > 3 :
    INDENT
        with open(sys.argv [3], "r") as f :
        INDENT

            ignore_words = set(f.read().strip().split())
            """ignore_words is a `set` to allow for very fast inclusion/exclusion checks"""
            aux = (word for word in aux if word not in ignore_words)
        DEDENT
    DEDENT
    counts = contar(aux)
    for word, count in counts.items() :
    INDENT
        if count > int(sys.argv [2]) :
        INDENT
            print word, count
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    characters = '!?¿-.:;-,><=*»¡'
    aux = []
    counts = {}
    with open(sys.argv [1], 'r') as f :
    INDENT
        text = f.read().lower().translate(None, characters)
        aux = text.split()
    DEDENT
    if (len(sys.argv) > 3) :
    INDENT
        with open(sys.argv [3], 'r') as f :
        INDENT
            remove = set(f.read().strip().split())
        DEDENT
    DEDENT
    else :
    INDENT
        remove = []
    DEDENT
    counts = contar(aux)
    for r in remove :
    INDENT
        counts.pop(r, None)
    DEDENT
    for word, count in counts.items() :
    INDENT
        if count > int(sys.argv [2]) :
        INDENT
            print word, count
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47097492_47098743_21_51
47097492_47099503_6_30
Title: Reading words from txt file - Python 
----------------------------------------

def main() :
INDENT
    characters = '!?¿-.:;-,><=*»¡'
    aux = []
    counts = {}
    with open(sys.argv [1], "r") as f :
    INDENT

        contents = f.read().strip().lower()
        contents = replace_special_chars(contents, characters)
        aux = contents.split()

    DEDENT
    if len(sys.argv) > 3 :
    INDENT
        with open(sys.argv [3], "r") as f :
        INDENT

            ignore_words = set(f.read().strip().split())
            """ignore_words is a `set` to allow for very fast inclusion/exclusion checks"""
            aux = (word for word in aux if word not in ignore_words)
        DEDENT
    DEDENT
    counts = contar(aux)
    for word, count in counts.items() :
    INDENT
        if count > int(sys.argv [2]) :
        INDENT
            print word, count
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main(text_file, min_count) :
INDENT
    word_count = {}
    with open(text_file, 'r') as words :
    INDENT

        words = words.read().strip().split(' ')

        pattern = re.compile(r'^[aA-zZ0-9]+$')
        words = filter(pattern.search, words)

        for word in words :
        INDENT
            if word in word_count :
            INDENT
                word_count [word] = word_count [word] + 1
            DEDENT
            else :
            INDENT
                word_count [word] = 1

            DEDENT
        DEDENT
    DEDENT
    for word, count in word_count.items() :
    INDENT
        if count > min_count :
        INDENT
            print ('%s %s' % (word, count))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47097492_47098770_10_33
47097492_47099503_6_30
Title: Reading words from txt file - Python 
----------------------------------------

def main() :
INDENT
    characters = '!?¿-.:;-,><=*»¡'
    aux = []
    counts = {}
    with open(sys.argv [1], 'r') as f :
    INDENT
        text = f.read().lower().translate(None, characters)
        aux = text.split()
    DEDENT
    if (len(sys.argv) > 3) :
    INDENT
        with open(sys.argv [3], 'r') as f :
        INDENT
            remove = set(f.read().strip().split())
        DEDENT
    DEDENT
    else :
    INDENT
        remove = []
    DEDENT
    counts = contar(aux)
    for r in remove :
    INDENT
        counts.pop(r, None)
    DEDENT
    for word, count in counts.items() :
    INDENT
        if count > int(sys.argv [2]) :
        INDENT
            print word, count
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main(text_file, min_count) :
INDENT
    word_count = {}
    with open(text_file, 'r') as words :
    INDENT

        words = words.read().strip().split(' ')

        pattern = re.compile(r'^[aA-zZ0-9]+$')
        words = filter(pattern.search, words)

        for word in words :
        INDENT
            if word in word_count :
            INDENT
                word_count [word] = word_count [word] + 1
            DEDENT
            else :
            INDENT
                word_count [word] = 1

            DEDENT
        DEDENT
    DEDENT
    for word, count in word_count.items() :
    INDENT
        if count > min_count :
        INDENT
            print ('%s %s' % (word, count))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47098384_47208033_21_42
47098384_47208033_9_17
Title: How to bind an event to the checkbox in the objectlistview in wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    self.test_data = [Results("123456789", "50158", "0065", "Patti Jones",
            "111 Centennial Drive"),
        Results("978561236", "90056", "7890", "Brian Wilson",
            "555 Torque Maui"),
        Results("456897852", "70014", "6545", "Mike Love",
            "304 Cali Bvld")]
    self.results_olv = ObjectListView(self,
        style = wx.LC_REPORT | wx.SUNKEN_BORDER)
    self.results_olv.Bind(OLVEvent.EVT_ITEM_CHECKED, self.on_item_checked)
    self.set_results()
    mainSizer.Add(self.results_olv, 1, wx.EXPAND | wx.ALL, 5)
    self.SetSizer(mainSizer)
DEDENT
----------------------------------------

def __init__(self, tin, zip_code, plus4, name, address) :
INDENT
    self.tin = tin
    self.zip_code = zip_code
    self.plus4 = plus4
    self.name = name
    self.address = address

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47116887_47116948_1_19
47116887_47116950_1_12
Title: Code not running properly 
----------------------------------------

def initialLets(keyStr) :
INDENT
    strList = keyStr.split()

    result = {}
    for words in strList :
    INDENT
        if words [0] not in result :
        INDENT

            result [words [0]] = 1
        DEDENT
        else :
        INDENT

            result [words [0]] += 1
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def initialLets(keyStr) :
INDENT
    inLets = {}
    strList = keyStr.split()
    firstLets = []
    for words in strList :
    INDENT
        firstLets.append(words [0])
    DEDENT
    for lets in firstLets :
    INDENT
        inLets [lets] = firstLets.count(lets)
    DEDENT
    return inLets
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47118053_47118091_5_16
47118053_47118183_3_9
Title: "How would I make sure that a string doesn't contain letters and keep the program running if it does?" 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        hours = input("Enter how many hours you work")
        try :
        INDENT
            hours = float(hours)
            break
        DEDENT
        except ValueError :
        INDENT
            print ("pls enter a number")
        DEDENT
    DEDENT
    wage = 7.50
    total = calcwages(wage, hours)
    print ('Wages for {hours} hours at ${wage:.2f} per hour are ${total:.2f}.'.format(** locals()))
DEDENT
----------------------------------------

def main() :
INDENT
    hours = input("Enter how many hours you work")
    while hours.isdigit() == False :
    INDENT
        hours = input("Enter digits only")
    DEDENT
    wage = 7.50
    total = calcwages(wage, hours)
    print ('Wages for {hours} hours at ${wage:.2f} per hour are ${total:.2f}.'.format(** locals()))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47118053_47118091_5_16
47118053_47118266_5_17
Title: "How would I make sure that a string doesn't contain letters and keep the program running if it does?" 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        hours = input("Enter how many hours you work")
        try :
        INDENT
            hours = float(hours)
            break
        DEDENT
        except ValueError :
        INDENT
            print ("pls enter a number")
        DEDENT
    DEDENT
    wage = 7.50
    total = calcwages(wage, hours)
    print ('Wages for {hours} hours at ${wage:.2f} per hour are ${total:.2f}.'.format(** locals()))
DEDENT
----------------------------------------

def main() :
INDENT
    hours = input("Enter how many hours you work ")
    if isdigit(hours) :
    INDENT
        hours = float(hours)
        wage = 7.50
        total = calcwages(wage, hours)
        print ('Wages for {hours} hours at ${wage:.2f} per hour are ${total:.2f}.'.format(** locals()))
    DEDENT
    else :
    INDENT
        print ("please enter numbers only")
        return main()
    DEDENT
    return total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47118053_47118183_3_9
47118053_47118266_5_17
Title: "How would I make sure that a string doesn't contain letters and keep the program running if it does?" 
----------------------------------------

def main() :
INDENT
    hours = input("Enter how many hours you work")
    while hours.isdigit() == False :
    INDENT
        hours = input("Enter digits only")
    DEDENT
    wage = 7.50
    total = calcwages(wage, hours)
    print ('Wages for {hours} hours at ${wage:.2f} per hour are ${total:.2f}.'.format(** locals()))
DEDENT
----------------------------------------

def main() :
INDENT
    hours = input("Enter how many hours you work ")
    if isdigit(hours) :
    INDENT
        hours = float(hours)
        wage = 7.50
        total = calcwages(wage, hours)
        print ('Wages for {hours} hours at ${wage:.2f} per hour are ${total:.2f}.'.format(** locals()))
    DEDENT
    else :
    INDENT
        print ("please enter numbers only")
        return main()
    DEDENT
    return total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47126987_47127454_11_22
47126987_47132180_16_29
Title: Optimization of list's sublist 
----------------------------------------

def query(sliced, left, right) :
INDENT
    index = 0
    count = 0
    while index < len(sliced) :
    INDENT
        if sliced [index] > right :
        INDENT
            count += sub_query(sliced [: index], left, right, 0)
            sliced = sliced [index + 1 :]
            index = 0
        DEDENT
        else :
        INDENT
            index += 1
        DEDENT
    DEDENT
    count += sub_query(sliced, left, right, 0)
    print (count)
DEDENT
----------------------------------------

def query(sliced, left, right) :
INDENT
    ans = 0
    start = 0
    search_for_start = True
    for end in range(len(sliced)) :
    INDENT
        if search_for_start and sliced [end] < = right :
        INDENT
            start = end
            search_for_start = False
        DEDENT
        elif not search_for_start and sliced [end] > right :
        INDENT
            ans += compute(sliced, start, end, left)
            search_for_start = True
        DEDENT
    DEDENT
    if not search_for_start :
    INDENT
        ans += compute(sliced, start, len(sliced), left)
    DEDENT
    return ans
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47127233_47129871_8_20
47127233_47139567_5_21
Title: how increase font size in text widget? 
----------------------------------------

def __init__(self) :
INDENT
    self.top = tk.Tk()
    tk.Label(self.top, text = "Small Font", width = 10, bg = "lightblue",
        font = ('DejaVuSansMono', 10)).grid(row = 1)
    tk.Label(self.top, text = "Large Font", width = 10, bg = "lightyellow",
        font = ('DejaVuSansMono', 30)).grid(row = 2)
    tk.Button(self.top, text = "Quit", bg = "orange",
        command = self.top.quit).grid(row = 20)
    self.top.mainloop()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    root = tk.Tk()
    self.font = tkFont.Font(family = "helvetica", size = 18)
    button = tk.Button(root, text = "Bigger", command = self.bigger)

    text_frame = tk.Frame(root, width = 800, height = 400)
    text_frame.pack_propagate(False)
    text = tk.Text(text_frame, width = 1, height = 1, font = self.font)
    text.pack(side = "top", fill = "both", expand = True)
    button.pack(side = "top")
    text_frame.pack(side = "top", fill = "both", expand = True)
    text.insert("end", "Hello, world!")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47127720_47127793_1_15
47127720_47127946_1_23
Title: simple python calculator won't run 
----------------------------------------

def main() :
INDENT
    operation = operate()
    num1, num2 = get_num()
    if operation == "+" :
    INDENT
        answer = addition(num1, num2)
    DEDENT
    elif operation == "*" :
    INDENT
        answer = multiplication(num1, num2)
    DEDENT
    elif operation == "-" :
    INDENT
        answer = subtraction(num1, num2)
    DEDENT
    elif operation == "/" :
    INDENT
        answer = division(num1, num2)
    DEDENT
    else :
    INDENT
        print ("Invalid Operation")
    DEDENT
    show_answer(answer)
DEDENT
----------------------------------------

def main() :
INDENT
    operator = operation()
    nums = get_num()
    if operator == '+' :
    INDENT
        answer = addition(nums [0], nums [1])
    DEDENT
    elif operator == '*' :
    INDENT
        answer = multiplication(nums [0], nums [1])
    DEDENT
    elif operator == '-' :
    INDENT
        answer = subtraction(nums [0], nums [1])
    DEDENT
    elif operator == '/' :
    INDENT
        answer = division(nums [0], nums [1])
    DEDENT
    else :
    INDENT
        raise ValueError("'" + operator + "' Operand not recognized")
    DEDENT
    answer = str(answer)
    print (str(nums [0]) + operator + str(nums [1]) + " = " + answer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47127720_47127793_39_45
47127720_47127946_53_63
Title: simple python calculator won't run 
----------------------------------------

def division(num1, num2) :
INDENT
    try :
    INDENT
        division = num1 / num2
        return division
    DEDENT
    except ZeroDivisionError :
    INDENT
        print ("Error, cannot be divided by 0")
    DEDENT
DEDENT
----------------------------------------

def division(num1, num2) :
INDENT
    if num2 == 0 :
    INDENT
        raise ValueError("Divistion by zero")
    DEDENT
    division = num1 / num2
    return division

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47138508_47140810_4_25
47138508_47142684_7_27
Title: "How to use a Python script to start and stop a Python script containing ""http.server.serveforever""" 
----------------------------------------

def main() :
INDENT
    def start_process() :
    INDENT
        proc = subprocess.Popen([sys.executable, 'server.py'])
        print ("Started process:")
        print (proc.pid)
        return proc
    DEDENT
    def kill_process(the_process) :
    INDENT
        print ("Killing process:")
        print (the_process.pid)
        the_process.kill()
    DEDENT
    user_input = input("Type something: ")
    if user_input == 'start' :
    INDENT
        process = start_process()
        while process.poll() is None :
        INDENT
            user_input = input()
            if user_input == 'kill' or user_input == 'exit' :
            INDENT
                kill_process(process)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    def start_process() :
    INDENT
        proc = subprocess.Popen([sys.executable, 'server.py'],
            stdin = subprocess.PIPE,
            stdout = subprocess.PIPE)
        print ("Started process:")
        def buf_readerd(proc, inbuf, outbuf) :
        INDENT
            while proc.poll() is None :
            INDENT
                outbuf.write(inbuf.readline())
            DEDENT
        DEDENT
        stdoutd = Thread(target = buf_readerd, args = (proc, proc.stdout, sys.stdout), daemon = True)
        stderrd = Thread(target = buf_readerd, args = (proc, proc.stderr, sys.stderr), daemon = True)
        stdoutd.start()
        stderrd.start()
        print ("started pipe reader daemons")
        print (proc.pid)
        return proc
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47144190_47144375_4_38
47144190_47145659_13_33
Title: Tic Tac Toe school project getting very longwinded with if statements. Is a loop possible? 
----------------------------------------

def main(game, X) :
INDENT
    row1 = ["-", "-", "-"]
    row2 = ["-", "-", "-"]
    row3 = ["-", "-", "-"]
    board = [row1, row2, row3]
    for each in range(0, 3) :
    INDENT
        print(* board [each])
    DEDENT
    table = {'A1' : board [0] [0], 'A2' : board [0] [1], 'A3' : board [0] [2],
        'B1' : board [1] [0], 'B2' : board [1] [1], 'B3' : board [1] [2],
        'C1' : board [2] [0], 'C2' : board [2] [1], 'C3' : board [2] [2]}
    while game == True :
    INDENT
        if X == True :
        INDENT
            value = input("Position in Grid for X: ")
        DEDENT
        if X == False :
        INDENT
            value = input("Position in Grid for O: ")
        DEDENT
        if value in table.keys() :
        INDENT
            if X == True :
            INDENT
                table [value] = "X"
                X = False
            DEDENT
            elif X == False :
            INDENT
                table [value] = "O"
                X = True
            DEDENT
            rows = list(table.values())
            board = [rows [0 : 3], rows [3 : 6], rows [6 : 9]]
            for each in range(0, 3) :
            INDENT
                print(* board [each])
                game = True
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main(game, X) :
INDENT
    while game == True :
    INDENT
        if X == True :
        INDENT
            value = input("Position in Grid for X: ")
        DEDENT
        if X == False :
        INDENT
            value = input("Position in Grid for O: ")

        DEDENT
        col, row = ord(value [0]) - ord("A"), int(value [1]) - 1
        if X == True :
        INDENT
            board [col] [row] = "X"
            X = False
        DEDENT
        elif X == False :
        INDENT
            board [col] [row] = "O"
            X = True
        DEDENT
        for each in range(0, 3) :
        INDENT
            print(* board [each])
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47156861_47157189_1_14
47156861_48062715_10_14
Title: Python: How to test how many times a method is called without replacing the original method? 
----------------------------------------

def test_call_count() :
INDENT
    real_say = Foo.say.im_func
    call_count = [0]
    def patched_say(self, * args, ** kw) :
    INDENT
        call_count [0] += 1
        return real_say(self, * args, ** kw)
    DEDENT
    Foo.say = patched_say
    amount = Foo().say_it()
    Foo.say = real_say
    assert amount == 123
    assert call_count [0] == 1
DEDENT
----------------------------------------

def test_call_count() :
INDENT
    with patch("Foo.say", wraps = Foo.say) as say_call :
    INDENT
        amount = Foo().say_it()
    DEDENT
    assert amount == 123
    assert say_call.call_count == 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47167496_47168359_31_38
47167496_48171158_156_177
Title: 2D intensity map with cursors in matplotlib 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    self.cursor = matplotlib.widgets.Cursor(ax1, useblit = True, ** kwargs)
    self.cid = fig.canvas.mpl_connect("motion_notify_event", self.cursor_move)
    self.cid2 = fig.canvas.mpl_connect("draw_event", self.clear)
    self.bg1 = None
    self.bg2 = None
    self.needclear = False
DEDENT
----------------------------------------

def __init__(self, GUI, index) :
INDENT
    self.GUI = GUI
    self.index = index
    print GUI
    self.lx = GUI.ax1.axhline(color = 'k')
    self.ly = GUI.ax1.axvline(color = 'k')

    self.lx.set_ydata(np.min(self.GUI.scale_y))
    self.ly.set_xdata(np.min(self.GUI.scale_x))

    self.slice_y, = self.GUI.ax3.plot(np.flipud(GUI.data [:, np.argmin(np.abs(self.GUI.scale_x - self.ly.get_xdata()))]), GUI.scale_y)
    self.slice_x, = self.GUI.ax2.plot(self.GUI.scale_x, GUI.data [np.shape(GUI.scale_y) - np.argmin(np.abs(self.GUI.scale_y - self.lx.get_ydata())) - 1, :] [0])

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47167496_47168359_31_38
47167496_48171158_19_34
Title: 2D intensity map with cursors in matplotlib 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    self.cursor = matplotlib.widgets.Cursor(ax1, useblit = True, ** kwargs)
    self.cid = fig.canvas.mpl_connect("motion_notify_event", self.cursor_move)
    self.cid2 = fig.canvas.mpl_connect("draw_event", self.clear)
    self.bg1 = None
    self.bg2 = None
    self.needclear = False
DEDENT
----------------------------------------

def __init__(self, data, scale_x, scale_y, numCur = 1) :
INDENT
    self.choice = 0
    self.numCur = numCur
    self.motion = False
    self.needclear = False
    self.bg1 = None
    self.bg2 = None
    self.bg_main = None
    self.data = data
    self.scale_x = scale_x
    self.scale_y = scale_y
    self.create_fig()
    self.create_events()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47167496_48171158_156_177
47167496_48171158_19_34
Title: 2D intensity map with cursors in matplotlib 
----------------------------------------

def __init__(self, GUI, index) :
INDENT
    self.GUI = GUI
    self.index = index
    print GUI
    self.lx = GUI.ax1.axhline(color = 'k')
    self.ly = GUI.ax1.axvline(color = 'k')

    self.lx.set_ydata(np.min(self.GUI.scale_y))
    self.ly.set_xdata(np.min(self.GUI.scale_x))

    self.slice_y, = self.GUI.ax3.plot(np.flipud(GUI.data [:, np.argmin(np.abs(self.GUI.scale_x - self.ly.get_xdata()))]), GUI.scale_y)
    self.slice_x, = self.GUI.ax2.plot(self.GUI.scale_x, GUI.data [np.shape(GUI.scale_y) - np.argmin(np.abs(self.GUI.scale_y - self.lx.get_ydata())) - 1, :] [0])

DEDENT
----------------------------------------

def __init__(self, data, scale_x, scale_y, numCur = 1) :
INDENT
    self.choice = 0
    self.numCur = numCur
    self.motion = False
    self.needclear = False
    self.bg1 = None
    self.bg2 = None
    self.bg_main = None
    self.data = data
    self.scale_x = scale_x
    self.scale_y = scale_y
    self.create_fig()
    self.create_events()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47168796_47168996_4_13
47168796_47170961_5_14
Title: How to assign values to list in turtle onclick function 
----------------------------------------

def color_change_one(x, y) :
INDENT
    global u_choice
    if t_one.color() == ('grey', 'grey') :
    INDENT
        t_one.color('red')
        u_choice [0] = 'red'
    DEDENT
    elif t_one.color() == ('red', 'red') :
    INDENT
        t_one.color('blue')
        u_choice [0] = 'blue'
    DEDENT
    print u_choice
DEDENT
----------------------------------------

def color_change_one(x, y) :
INDENT
    if t_one.pencolor() == 'grey' :
    INDENT
        t_one.color('red')
    DEDENT
    elif t_one.pencolor() == 'red' :
    INDENT
        t_one.color('blue')
    DEDENT
    elif t_one.pencolor() == 'blue' :
    INDENT
        t_one.color('grey')
    DEDENT
    u_choice [0] = t_one.pencolor()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47179188_47179553_23_29
47179188_47180406_17_21
Title: Multiple django model values depend on choice field value 
----------------------------------------

def save(self, ** kwargs) :
INDENT
    if not self.max_admin_accounts :
    INDENT
        self.max_admin_accounts = get_max_admin_accounts(self.pricing_plan)

    DEDENT
    super().save(** kwargs)
DEDENT
----------------------------------------

def save(self, * args, ** kwargs) :
INDENT
    if getattr(self, "plan_changed", "") :
    INDENT

        self.set_plan(* self.PRICING_CHOICES [self.pricing_plan] [1])
    DEDENT
    super(Organisation, self).save(* args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47192626_47234034_19_25
47192626_47234034_5_11
Title: deceptively simple implementation of topological sorting in python 
----------------------------------------

def recursive_helper(node) :
INDENT
    for neighbor in graph [node] :
    INDENT
        if neighbor not in seen :
        INDENT
            seen.add(neighbor)
            recursive_helper(neighbor)
        DEDENT
    DEDENT
    result.insert(0, node)
DEDENT
----------------------------------------

def recursive_helper(node) :
INDENT
    for neighbor in graph [node] :
    INDENT
        if neighbor not in seen :
        INDENT
            result.append(neighbor)
            seen.add(neighbor)
            recursive_helper(neighbor)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47203589_48021188_13_25
47203589_48021188_2_10
Title: How to remove image in wxPython 
----------------------------------------

def __init__(self, frame) :
INDENT
    wx.Panel.__init__(self, frame)
    self.Bind(wx.EVT_PAINT, self._on_paint)
    cmd_refresh = wx.Button(self, wx.ID_REFRESH)
    cmd_refresh.Bind(wx.EVT_BUTTON, self._on_cmd_refresh_click)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add((500, 300))
    sizer.Add(cmd_refresh, flag = wx.ALL | wx.ALIGN_CENTER, border = 10)
    self.SetSizer(sizer)
    self.x_pos = random.randint(0, 100)
    self.y_pos = random.randint(0, 100)
    self.refresh = False
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Remove image")
    panel = MainPanel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(panel, 1, wx.EXPAND)
    self.SetSizerAndFit(sizer)
    self.Centre()
    self.Show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47215501_47215546_1_10
47215501_47215648_1_14
Title: Python : function to find maximum even digit in string 
----------------------------------------

def maximumeven(st) :
INDENT
    Result = []
    for i in (st) :
    INDENT
        if i.isdigit() :
        INDENT
            if (int(i) % 2 == 0) :
            INDENT
                Result.append(int(i))
            DEDENT
        DEDENT
    DEDENT
    if not len(Result) :
    INDENT
        Result = - 3
    DEDENT
    return Result
DEDENT
----------------------------------------

def maximumeven(st) :
INDENT
    if "8" in st :
    INDENT
        return 8
    DEDENT
    if "6" in st :
    INDENT
        return 6
    DEDENT
    if "4" in st :
    INDENT
        return 4
    DEDENT
    if "2" in st :
    INDENT
        return 2
    DEDENT
    if "0" in st :
    INDENT
        return 0
    DEDENT
    return - 3
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47218970_47219490_17_24
47218970_47219730_28_35
Title: Error in attribute creation and reference Python classes multilevel inheritance 
----------------------------------------

def display(self) :
INDENT
    print ("\n\nName: ", self.name)
    print ("Age: ", self.age)
    print ("Gender: ", self.gender)
    print ("Class Year Group: ", self.stuClass)
    self.totalmarks = self.literature + self.math + self.biology + self.physics
    print ("Total Marks: ", self.literature + self.math + self.biology + self.physics)
DEDENT
----------------------------------------

def display(self) :
INDENT
    print ("\n\nName: ", self.name)
    print ("Age: ", self.age)
    print ("Gender: ", self.gender)
    print ("Class Year Group: ", self.stuClass)
    self.totalmarks = self.literature + self.math + self.biology + self.physics
    print ("Total Marks: ", self.literature + self.math + self.biology + self.physics)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47227445_47227617_1_10
47227445_47227709_1_12
Title: How do I make while loops terminate after using If/ elif statements in python? 
----------------------------------------

def pvalue(num) :
INDENT
    ans = ''
    while num > 0 :
    INDENT
        if num > = 10 :
        INDENT
            ans += 'A'
            num -= 10
        DEDENT
        else :
        INDENT
            ans += 'B'
            num -= 1
        DEDENT
    DEDENT
    return ans
DEDENT
----------------------------------------

def pvalue(num) :
INDENT
    ans = ''
    while num > 0 :
    INDENT
        if 1 < = num < = 9 :
        INDENT
            ans += 'B'
            num -= 1
        DEDENT
        if num > = 10 :
        INDENT
            ans += 'A'
            num -= 10
        DEDENT
        if num < = 0 :
        INDENT
            break
        DEDENT
    DEDENT
    return ans
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47228052_47228275_1_25
47228052_47228463_1_16
Title: How do I get my program to loop back and restart in Python? 
----------------------------------------

def start() :
INDENT
    print ("\nBMI Calculator")
    while True :
    INDENT
        weight = float(input("\nPlease enter your weight in KG: "))
        height = float(input("\nPlease enter your height in metres: "))
        bmi = weight / (height * height)
        if bmi < = 18.5 :
        INDENT
            print ("Your BMI is", bmi, "which means you are underweight.")
        DEDENT
        elif bmi > 18.5 and bmi < 25 :
        INDENT
            print ("Your BMI is: ", bmi, "which means you are normal")
        DEDENT
        elif bmi > 25 and bmi < 30 :
        INDENT
            print ("Your BMI is: ", bmi, "which means you are overweight")
        DEDENT
        elif bmi > 30 :
        INDENT
            print ("Your BMI is: ", bmi, "which means you are obese")
        DEDENT
        else :
        INDENT
            print ("There was an error with your input, Sorry.")
        DEDENT
        answer = input("Would you like to enter another? key y/n: ")
        while answer == "y" :
        INDENT
            start()
            answer = None
        DEDENT
        if answer == "n" :
        INDENT
            exit()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def start() :
INDENT
    print ("\nBMI Calculator")
    weight = float(input("\nPlease enter your weight in KG: "))
    height = float(input("\nPlease enter your height in metres: "))
    bmi = weight / (height * height)
    if bmi < = 18.5 :
    INDENT
        return "Your BMI is : {} which means you are underweight".format(bmi)
    DEDENT
    elif bmi > 18.5 and bmi < 25 :
    INDENT
        return "Your BMI is : {} which means you are normal".format(bmi)
    DEDENT
    elif bmi > 25 and bmi < 30 :
    INDENT
        return "Your BMI is : {} which means you are overweight".format(bmi)
    DEDENT
    elif bmi > 30 :
    INDENT
        return "Your BMI is : {} which means you are obese".format(bmi)
    DEDENT
    else :
    INDENT
        return "There was an error with your input, Sorry."
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47231603_47231913_14_23
47231603_47231928_12_21
Title: Multiplication using only recursion 
----------------------------------------

def mult(a, b) :
INDENT
    temp = 0
    if b == 0 :
    INDENT
        return 0
    DEDENT
    temp = add(a, temp)
    b = decr(b)
    if b ! = 0 :
    INDENT
        temp = add(mult(a, b), temp)
    DEDENT
    return temp
DEDENT
----------------------------------------

def mult(a, b) :
INDENT
    if zero(b) :
    INDENT
        return 0
    DEDENT
    b = decr(b)
    c = mult(a, b)
    return add(a, c)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47232230_47236704_24_39
47232230_47236704_5_22
Title: Calling a Subform of Startup 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent, wx.ID_ANY, "Setup employee data", size = (280, 130))
    self.parent = parent
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.emp_panel = wx.Panel(self, wx.ID_ANY)
    self.employee_name = wx.TextCtrl(self.emp_panel, wx.ID_ANY, "Input Employee Name", size = (200, 25))
    self.emp_button = wx.Button(self.emp_panel, wx.ID_ANY, "Add")
    self.emp_button.Bind(wx.EVT_BUTTON, self.AddEmp)
    close_button = wx.Button(self.emp_panel, wx.ID_ANY, "Close")
    close_button.Bind(wx.EVT_BUTTON, self.OnClose)
    sizer.Add(self.employee_name)
    sizer.Add(self.emp_button)
    sizer.Add(close_button)
    self.emp_panel.SetSizer(sizer)
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    self.no_resize = wx.DEFAULT_FRAME_STYLE & ~ (wx.RESIZE_BORDER | wx.MAXIMIZE_BOX)
    wx.Frame.__init__(self, parent, title = title, size = (500, 450), style = self.no_resize)
    self.panel = wx.Panel(self, size = (250, 270))
    self.emp_list = []
    e_name = 'employees.txt'
    if os.access(e_name, os.R_OK) :
    INDENT
        with open(e_name, 'r') as f_obj :
        INDENT
            for line in f_obj :
            INDENT
                self.emp_list.append(line.strip())
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT

        frame = SetUp(parent = self)
    DEDENT
    self.combo = wx.ComboBox(self.panel, - 1, choices = self.emp_list, pos = (60, 100))
    self.Centre()
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47238822_47239009_1_12
47238822_47239066_1_12
Title: How to use return answer from other function to the next one? 
----------------------------------------

def calculateTableTotal(noPeople) :
INDENT
    if noPeople < = 15 :
    INDENT
        return 1
    DEDENT
    elif 16 < = noPeople < = 35 :
    INDENT
        return 3
    DEDENT
    elif 36 < = noPeople < = 55 :
    INDENT
        return 5
    DEDENT
    elif 56 < = noPeople < = 75 :
    INDENT
        return 7
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def calculateTableTotal(noPeople) :
INDENT
    if noPeople < = 15 :
    INDENT
        return ('Tables:', 1)
    DEDENT
    elif noPeople < = 35 :
    INDENT
        return ('Tables:', 3)
    DEDENT
    elif noPeople < = 55 :
    INDENT
        return ('Tables:', 5)
    DEDENT
    elif noPeople < = 75 :
    INDENT
        return ('Tables:', 7)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47254299_47260328_2_21
47254299_47272233_2_41
Title: Finding the longest palindrome within a string in Python 
----------------------------------------

def longestPalindrome(self, s) :
INDENT
    longest = ""
    i = 0
    l = len(s)
    while i < l :
    INDENT
        end = i
        while end + 1 < l and s [end + 1] == s [i] :
        INDENT
            end += 1
        DEDENT
        candidate = self.get_palindrome(s, i, end)
        if len(candidate) > len(longest) :
        INDENT
            longest = candidate
        DEDENT
        i = end + 1
    DEDENT
    return longest
DEDENT
----------------------------------------

def longestPalindrome(self, s) :
INDENT
    s = '>' + s + '<'

    evn = [i for i, a in enumerate(zip(s, s [1 :])) if a [0] == a [1]]
    odd = [i + 1 for i, a in enumerate(zip(s, s [2 :])) if a [0] == a [1]]

    evn_last, odd_last = [[1], 0], [[1], 1]
    j = 1
    while evn :
    INDENT
        evn_last = (evn, j)
        evn = [e for e in evn if s [e - j] == s [e + j + 1]]
        j += 1
    DEDENT
    j = 1
    while odd :
    INDENT
        odd_last = (odd, j)
        odd = [e for e in odd if s [e - j] == s [e + j]]
        j += 1

    DEDENT
    if 2 * evn_last [1] > 2 * odd_last [1] - 1 :
    INDENT

        cntr = evn_last [0] [0]
        pal = s [cntr] + s [cntr + 1]
        for i in range(1, evn_last [1]) :
        INDENT
            pal = s [cntr - i] + pal + s [cntr + i + 1]
        DEDENT
    DEDENT
    else :
    INDENT
        cntr = odd_last [0] [0]
        pal = s [cntr]
        for i in range(1, odd_last [1]) :
        INDENT
            pal = s [cntr - i] + pal + s [cntr + i]
        DEDENT
    DEDENT
    return pal
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
472575_1212394_1_15
472575_472826_1_12
Title: select single item from a collection : Python 
----------------------------------------

def one(items) :
INDENT
    count = 0
    value = None
    for item in items :
    INDENT
        if count :
        INDENT
            raise Exception('Too many values')
        DEDENT
        count += 1
        value = item
    DEDENT
    if not count :
    INDENT
        raise Exception('No values')
    DEDENT
    return value
DEDENT
----------------------------------------

def one(seq) :
INDENT
    counter = 0
    for elem in seq :
    INDENT
        result = elem
        counter += 1
        if counter > 1 :
        INDENT
            break
        DEDENT
    DEDENT
    if counter == 0 :
    INDENT
        raise Exception('No values')
    DEDENT
    elif counter > 1 :
    INDENT
        raise Exception('Too many values')
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47260193_47260281_1_28
47260193_47260317_4_15
Title: Connect variables of the program with a function 
----------------------------------------

def stats(n) :
INDENT
    L = []
    total = 0
    mathsum = 0
    for i in range(0, n, 1) :
    INDENT
        x = random.randint(1, 20)
        L.append(x)
    DEDENT
    for num in L :
    INDENT
        total += num
    DEDENT
    MO = total / n
    for i in range(0, n) :
    INDENT
        mathsum += (L [i] - MO) ** 2
    DEDENT
    sd = math.sqrt((1 / (n - 1)) * mathsum)
    return {'n' : n,
        'numbers' : L,
        'average' : '{:2.2f}'.format(MO),
        'sd' : '{:2.2f}'.format(sd)}

DEDENT
----------------------------------------

def stats(size) :
INDENT
    L = [random.randint(1, 20) for _ in range(size)]
    total = sum(L)
    MO = total / size
    mathsum = sum((x - MO) ** 2 for x in L)
    sd = math.sqrt((1 / (size - 1)) * mathsum)
    return L, '{:2.2f}'.format(MO), '{:2.2f}'.format(sd)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47267195_47267196_21_41
47267195_47267196_251_269
Title: "In PyQt4 is it possible to detach tabs from a QTabWidget?" 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QTabWidget.__init__(self, parent)
    self.tabBar = self.TabBar(self)
    self.tabBar.onDetachTabSignal.connect(self.detachTab)
    self.tabBar.onMoveTabSignal.connect(self.moveTab)
    self.tabBar.detachedTabDropSignal.connect(self.detachedTabDrop)
    self.setTabBar(self.tabBar)

    self.detachedTabs = {}

    QtGui.qApp.aboutToQuit.connect(self.closeDetachedTabs)

DEDENT
----------------------------------------

def __init__(self, name, contentWidget) :
INDENT
    QtGui.QMainWindow.__init__(self, None)
    self.setObjectName(name)
    self.setWindowTitle(name)
    self.contentWidget = contentWidget
    self.setCentralWidget(self.contentWidget)
    self.contentWidget.show()
    self.windowDropFilter = self.WindowDropFilter()
    self.installEventFilter(self.windowDropFilter)
    self.windowDropFilter.onDropSignal.connect(self.windowDropSlot)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47267195_47267196_21_41
47267195_47267196_325_341
Title: "In PyQt4 is it possible to detach tabs from a QTabWidget?" 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QTabWidget.__init__(self, parent)
    self.tabBar = self.TabBar(self)
    self.tabBar.onDetachTabSignal.connect(self.detachTab)
    self.tabBar.onMoveTabSignal.connect(self.moveTab)
    self.tabBar.detachedTabDropSignal.connect(self.detachedTabDrop)
    self.setTabBar(self.tabBar)

    self.detachedTabs = {}

    QtGui.qApp.aboutToQuit.connect(self.closeDetachedTabs)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QTabBar.__init__(self, parent)
    self.setAcceptDrops(True)
    self.setElideMode(QtCore.Qt.ElideRight)
    self.setSelectionBehaviorOnRemove(QtGui.QTabBar.SelectLeftTab)
    self.dragStartPos = QtCore.QPoint()
    self.dragDropedPos = QtCore.QPoint()
    self.mouseCursor = QtGui.QCursor()
    self.dragInitiated = False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47267195_47267196_251_269
47267195_47267196_325_341
Title: "In PyQt4 is it possible to detach tabs from a QTabWidget?" 
----------------------------------------

def __init__(self, name, contentWidget) :
INDENT
    QtGui.QMainWindow.__init__(self, None)
    self.setObjectName(name)
    self.setWindowTitle(name)
    self.contentWidget = contentWidget
    self.setCentralWidget(self.contentWidget)
    self.contentWidget.show()
    self.windowDropFilter = self.WindowDropFilter()
    self.installEventFilter(self.windowDropFilter)
    self.windowDropFilter.onDropSignal.connect(self.windowDropSlot)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QTabBar.__init__(self, parent)
    self.setAcceptDrops(True)
    self.setElideMode(QtCore.Qt.ElideRight)
    self.setSelectionBehaviorOnRemove(QtGui.QTabBar.SelectLeftTab)
    self.dragStartPos = QtCore.QPoint()
    self.dragDropedPos = QtCore.QPoint()
    self.mouseCursor = QtGui.QCursor()
    self.dragInitiated = False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47276448_47276566_4_9
47276448_47276577_4_12
Title: Print one letter at a time 
----------------------------------------

def type(text, delay) :
INDENT
    for beep in text :
    INDENT
        print(beep, end = "")
        sys.stdout.flush()
        time.sleep(delay)
    DEDENT
DEDENT
----------------------------------------

def type(text, delay) :
INDENT
    i = 0
    amount = len(text)
    while amount < i :
    INDENT
        sys.stdout.write(text [i])
        sys.stdout.flush()
        i += 1
        time.sleep(delay)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47282762_47283080_7_15
47282762_47283161_23_31
Title: Python 3.0 Calling a value from a class function to print 
----------------------------------------

def total(self) :
INDENT
    if self.hours > 40 :
    INDENT
        ot = self.hours - 40
        earned_ot = self.wage * 1.5
        ot_total = ot * earned_ot
        pay = self.wage * 40
        return pay + ot_total
    DEDENT
    else :
    INDENT
        return self.wage * self.hours
    DEDENT
DEDENT
----------------------------------------

def total(self) :
INDENT
    if self.hours > 40 :
    INDENT
        self.ot = self.hours - 40
        self.earned_ot = self.wage * 1.5
        self.ot_total = self.ot * self.earned_ot
        self.pay = self.wage * 40
        return self.pay + self.ot_total
    DEDENT
    else :
    INDENT
        return self.wage * self.hours
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47289116_47289654_9_24
47289116_47354179_8_18
Title: element-wise multiplication with broadcasting in keras custom layer 
----------------------------------------

def build(self, input_shape) :
INDENT
    output_shape = self.compute_output_shape(input_shape)
    weight_shape = (1,) + output_shape [1 :]

    self.kernel = self.add_weight(name = 'kernel',
        shape = weight_shape,
        initializer = 'ones',
        trainable = True)

    super(MyLayer, self).build(input_shape)

DEDENT
----------------------------------------

def build(self, input_shape) :
INDENT
    output_shape = self.compute_output_shape(input_shape)
    self.kernel = self.add_weight(name = 'kernel',
        shape = (1,) + output_shape [1 :],
        initializer = 'ones',
        trainable = True)

    super(MyLayer, self).build(input_shape)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47289944_47289986_1_8
47289944_47290019_1_10
Title: When i add numbers in a list and print them it only adds the first number 
----------------------------------------

def sum(numbers) :
INDENT
    total = 0
    for number in numbers :
    INDENT
        total += number

    DEDENT
    return total
DEDENT
----------------------------------------

def sum(numbers) :
INDENT
    total = 0
    for number in numbers :
    INDENT

        total += number
    DEDENT
    return total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47306156_47306236_4_18
47306156_47306443_15_34
Title: Web scraping and python data types 
----------------------------------------

def bitcoin_scheduler() :
INDENT
    url = "https://coinmarketcap.com/currencies/bitcoin/"
    r = requests.get(url)
    offline_data = r.content
    soup = BeautifulSoup(offline_data, 'html.parser')
    name_box = soup.find('small', attrs = {'class' : 'bold hidden-xs'})
    name = name_box.text.strip()
    price_box = soup.find('span', attrs = {'class' : 'text-large'})
    price = price_box.text.strip()
    print (time.ctime(), name, price.replace('$', ''))
    threading.Timer(5.0, bitcoin_scheduler).start()
DEDENT
----------------------------------------

def bitcoin_scheduler() :
INDENT
    url = "https://coinmarketcap.com/currencies/bitcoin/"
    r = requests.get(url)
    offline_data = r.content
    soup = BeautifulSoup(offline_data, 'html.parser')
    name_box = soup.find('small', attrs = {'class' : 'bold hidden-xs'})
    name = name_box.text.strip()
    price_box = soup.find('span', attrs = {'class' : 'text-large'})
    price = price_box.text.strip('$')
    if isdigit(price) == True :
    INDENT
        price = float(price)
        print (time.ctime(), name, price)
        print (type(price))
    DEDENT
    threading.Timer(5.0, bitcoin_scheduler).start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47312887_47313251_13_20
47312887_47314031_4_12
Title: How to provide code for tkinter toplevel before data can be accessed 
----------------------------------------

def qw(self) :
INDENT
    if self.en1.get() == "2e2c2v" :
    INDENT
        print ("You have visa to Paris")
        self.tp.destroy()
    DEDENT
    else :
    INDENT
        print ("you dont have access to print the data")
    DEDENT
DEDENT
----------------------------------------

def qw() :
INDENT
    global en1, tp
    if en1.get() == "2e2c2v" :
    INDENT
        print ("You have visa to Paris")
        tp.destroy()
    DEDENT
    else :
    INDENT
        print ("you dont have access to print the data")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47312887_47313251_21_28
47312887_47314031_13_22
Title: How to provide code for tkinter toplevel before data can be accessed 
----------------------------------------

def login_toplevel(self) :
INDENT
    self.tp = tk.Toplevel()
    self.tp.geometry("300x300")
    self.en1 = tk.Entry(self.tp)
    self.en1.pack()
    b = tk.Button(self.tp, text = "provide key to print", command = self.qw)
    b.pack()
DEDENT
----------------------------------------

def login_toplevel() :
INDENT
    global en1, tp
    tp = Toplevel()
    tp.geometry("300x300")
    en1 = Entry(tp)
    en1.pack()
    b = Button(tp, text = "provide key to print", command = qw)
    b.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47314158_47314324_3_13
47314158_47315435_3_9
Title: Printing a list after having removed adjacent duplicate elements 
----------------------------------------

def remove_adjacent(nums) :
INDENT
    i = 0
    while i < len(nums) - 1 :
    INDENT
        if nums [i] ! = nums [i + 1] :
        INDENT
            new_list.append(nums [i])
        DEDENT
        else :
        INDENT
            i += 1
            remove_adjacent(nums [i :])
            return
        DEDENT
        i += 1
    DEDENT
DEDENT
----------------------------------------

def remove_adjacent(l) :
INDENT
    new = [l [0]]
    for item in l [1 :] :
    INDENT
        if new [- 1] ! = item :
        INDENT
            new.append(item)
        DEDENT
    DEDENT
    return new
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47314231_47319455_35_51
47314231_47319455_55_69
Title: wxpython add splitter window to notebook page 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    splitter = wx.SplitterWindow(self)
    leftP = LeftPanel(splitter)
    rightP = RightPanel(splitter)
    splitter.SplitVertically(leftP, rightP)
    splitter.SetMinimumPaneSize(20)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(splitter, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Notebook Splitter Tutorial")
    panel = wx.Panel(self)
    notebook = wx.Notebook(panel)
    splitter = SplitterPanel(notebook)
    notebook.AddPage(splitter, 'Splitter')
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(notebook, 1, wx.ALL | wx.EXPAND, 5)
    panel.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47314231_47319455_35_51
47314231_47319455_9_20
Title: wxpython add splitter window to notebook page 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    splitter = wx.SplitterWindow(self)
    leftP = LeftPanel(splitter)
    rightP = RightPanel(splitter)
    splitter.SplitVertically(leftP, rightP)
    splitter.SetMinimumPaneSize(20)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(splitter, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(25, 12)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47314231_47319455_55_69
47314231_47319455_9_20
Title: wxpython add splitter window to notebook page 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Notebook Splitter Tutorial")
    panel = wx.Panel(self)
    notebook = wx.Notebook(panel)
    splitter = SplitterPanel(notebook)
    notebook.AddPage(splitter, 'Splitter')
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(notebook, 1, wx.ALL | wx.EXPAND, 5)
    panel.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(25, 12)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47334488_47334583_3_9
47334488_47334818_18_22
Title: Python 2.7: check if default argument passed with a decorator 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if 'args2' in kwargs :
    INDENT
        kwargs ['args2'] = 'new value'
    DEDENT
    elif len(args) > 1 :
    INDENT
        args = (args [0], 'new value') + args [2 :]
    DEDENT
    rv = func(* args, ** kwargs)
    return rv
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if not 'a' in kwargs and len(args) < = psn :
    INDENT
        print "You really should pass 'a', y'know."
    DEDENT
    rv = func(* args, ** kwargs)
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47334488_47334583_3_9
47334488_47334818_7_11
Title: Python 2.7: check if default argument passed with a decorator 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if 'args2' in kwargs :
    INDENT
        kwargs ['args2'] = 'new value'
    DEDENT
    elif len(args) > 1 :
    INDENT
        args = (args [0], 'new value') + args [2 :]
    DEDENT
    rv = func(* args, ** kwargs)
    return rv
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if not 'a' in sig.bind_partial(* args, ** kwargs).arguments :
    INDENT
        print ("You really should pass 'a', y'know.")
    DEDENT
    rv = func(* args, ** kwargs)
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47334488_47334818_18_22
47334488_47334818_7_11
Title: Python 2.7: check if default argument passed with a decorator 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if not 'a' in kwargs and len(args) < = psn :
    INDENT
        print "You really should pass 'a', y'know."
    DEDENT
    rv = func(* args, ** kwargs)
    return rv
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if not 'a' in sig.bind_partial(* args, ** kwargs).arguments :
    INDENT
        print ("You really should pass 'a', y'know.")
    DEDENT
    rv = func(* args, ** kwargs)
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47337094_47338137_11_23
47337094_47338224_9_26
Title: Data on axis is not in expected order 
----------------------------------------

def create_graph(data) :
INDENT
    months, y = zip(* data)
    plt.plot(range(len(months)), y)
    axes = plt.gca()
    axes.get_yaxis().get_major_formatter().set_scientific(False)
    axes.set_xticks(range(len(months)))
    axes.set_xticklabels(months, rotation = 45, ha = "right")
    for i, j in enumerate(y) :
    INDENT
        plt.annotate(str(j), xy = (i, j))
    DEDENT
    plt.show()

DEDENT
----------------------------------------

def create_graph(data) :
INDENT
    fig, ax = pyplot.subplots()
    _x, y = zip(* data)
    x = [datetime.strptime(month, '%B') for month in _x]
    ax.plot(x, y)
    ax.yaxis.get_major_formatter().set_scientific(False)
    ax.xaxis.set_major_locator(dates.MonthLocator(interval = 1))
    ax.xaxis.set_major_formatter(dates.DateFormatter('%B'))
    for tick in ax.xaxis.get_ticklabels() :
    INDENT
        tick.set_rotation(45)
        tick.set_rotation_mode('anchor')
        tick.set_horizontalalignment('right')
    DEDENT
    for i, j in zip(x, y) :
    INDENT
        ax.annotate(str(j), xy = (i, j))
    DEDENT
    return fig
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47344570_47344968_1_21
47344570_47345745_2_19
Title: Login program from external text file 
----------------------------------------

def login() :
INDENT
    user0 = input("Username: ")
    pass0 = input("Password: ")
    file = open("account.txt", "r")
    foundOne = False
    for line in file :
    INDENT
        details = line.split(",")
        if user0 == details [0] and pass0 == details [1] :
        INDENT
            foundOne = True
            break
        DEDENT
    DEDENT
    if foundOne == True :
    INDENT
        print ("Correct!")
    DEDENT
    else :
    INDENT
        print ("Fail")
    DEDENT
    menu()
DEDENT
----------------------------------------

def login() :
INDENT
    user_dict = {}
    with open("account.txt", "r") as csvfile :
    INDENT
        authfile = csv.reader(csvfile)
        for line in authfile :
        INDENT
            user_dict [line [0]] = line [1 :]
        DEDENT
    DEDENT
    user0 = input("Username: ")
    if user_dict.get(user0) :
    INDENT
        pass0 = input("Password: ")
        if user_dict.get(user0) [1] == pass0 :
        INDENT
            print ("Correct!")
            menu()
        DEDENT
        else :
        INDENT
            print ("Bad Password")
        DEDENT
    DEDENT
    else :
    INDENT
        print ("Bad Username")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47344593_47344851_1_10
47344593_47344925_1_9
Title: Why won't my function return largest even if numbers are negative 
----------------------------------------

def largest_even(list_int) :
INDENT
    large = False
    for i in list_int :
    INDENT
        if i % 2 == 0 :
        INDENT
            large = i
        DEDENT
        for j in list_int :
        INDENT
            if j % 2 == 0 :
            INDENT
                if j > large :
                INDENT
                    large = j
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return large
DEDENT
----------------------------------------

def largest_even(list_int) :
INDENT
    large = 0
    print (list_int)
    for i in list_int :
    INDENT
        if i % 2 == 0 :
        INDENT
            if abs(i) > abs(large) :
            INDENT
                large = i
            DEDENT
        DEDENT
    DEDENT
    return large
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47344593_47344866_1_11
47344593_47344925_1_9
Title: Why won't my function return largest even if numbers are negative 
----------------------------------------

def largest_even(list_int) :
INDENT
    large = False
    print (list_int)
    for i in list_int :
    INDENT
        if i % 2 == 0 :
        INDENT
            large = i
        DEDENT
    DEDENT
    for i in list_int :
    INDENT
        if i % 2 == 0 :
        INDENT
            if i > large :
            INDENT
                large = i
            DEDENT
        DEDENT
    DEDENT
    return large
DEDENT
----------------------------------------

def largest_even(list_int) :
INDENT
    large = 0
    print (list_int)
    for i in list_int :
    INDENT
        if i % 2 == 0 :
        INDENT
            if abs(i) > abs(large) :
            INDENT
                large = i
            DEDENT
        DEDENT
    DEDENT
    return large
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47345776_47346376_15_23
47345776_47346376_2_13
Title: PyQt5 - How to add a scrollbar to a QMessageBox 
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.btn = QPushButton('Show Message', self)
    self.btn.setGeometry(10, 10, 100, 100)
    self.btn.clicked.connect(self.buttonClicked)
    self.lst = [str(i) for i in range(2000)]
    self.show()

DEDENT
----------------------------------------

def __init__(self, l, * args, ** kwargs) :
INDENT
    QMessageBox.__init__(self, * args, ** kwargs)
    scroll = QScrollArea(self)
    scroll.setWidgetResizable(True)
    self.content = QWidget()
    scroll.setWidget(self.content)
    lay = QVBoxLayout(self.content)
    for item in l :
    INDENT
        lay.addWidget(QLabel(item, self))
    DEDENT
    self.layout().addWidget(scroll, 0, 0, 1, self.layout().columnCount())
    self.setStyleSheet("QScrollArea{min-width:300 px; min-height: 400px}")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47345776_47346376_15_23
47345776_52913143_22_42
Title: PyQt5 - How to add a scrollbar to a QMessageBox 
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.btn = QPushButton('Show Message', self)
    self.btn.setGeometry(10, 10, 100, 100)
    self.btn.clicked.connect(self.buttonClicked)
    self.lst = [str(i) for i in range(2000)]
    self.show()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(W, self).__init__()
    self.btn = QPushButton('Show Message', self)
    self.btn.setGeometry(10, 10, 100, 100)
    self.btn.clicked.connect(self.buttonClicked)
    self.message = ("""We have encountered an error.
The following information may be useful in troubleshooting:
1
2
3
4
5
6
7
8
9
10
Here is the bottom.
""")
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47345776_47346376_15_23
47345776_52913143_7_20
Title: PyQt5 - How to add a scrollbar to a QMessageBox 
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.btn = QPushButton('Show Message', self)
    self.btn.setGeometry(10, 10, 100, 100)
    self.btn.clicked.connect(self.buttonClicked)
    self.lst = [str(i) for i in range(2000)]
    self.show()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QMessageBox.__init__(self, * args, ** kwargs)
    chldn = self.children()
    scrll = QScrollArea(self)
    scrll.setWidgetResizable(True)
    grd = self.findChild(QGridLayout)
    lbl = QLabel(chldn [1].text(), self)
    lbl.setWordWrap(True)
    scrll.setWidget(lbl)
    scrll.setMinimumSize(400, 200)
    grd.addWidget(scrll, 0, 1)
    chldn [1].setText('')
    self.exec_()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47345776_47346376_2_13
47345776_52913143_22_42
Title: PyQt5 - How to add a scrollbar to a QMessageBox 
----------------------------------------

def __init__(self, l, * args, ** kwargs) :
INDENT
    QMessageBox.__init__(self, * args, ** kwargs)
    scroll = QScrollArea(self)
    scroll.setWidgetResizable(True)
    self.content = QWidget()
    scroll.setWidget(self.content)
    lay = QVBoxLayout(self.content)
    for item in l :
    INDENT
        lay.addWidget(QLabel(item, self))
    DEDENT
    self.layout().addWidget(scroll, 0, 0, 1, self.layout().columnCount())
    self.setStyleSheet("QScrollArea{min-width:300 px; min-height: 400px}")
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(W, self).__init__()
    self.btn = QPushButton('Show Message', self)
    self.btn.setGeometry(10, 10, 100, 100)
    self.btn.clicked.connect(self.buttonClicked)
    self.message = ("""We have encountered an error.
The following information may be useful in troubleshooting:
1
2
3
4
5
6
7
8
9
10
Here is the bottom.
""")
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47345776_47346376_2_13
47345776_52913143_7_20
Title: PyQt5 - How to add a scrollbar to a QMessageBox 
----------------------------------------

def __init__(self, l, * args, ** kwargs) :
INDENT
    QMessageBox.__init__(self, * args, ** kwargs)
    scroll = QScrollArea(self)
    scroll.setWidgetResizable(True)
    self.content = QWidget()
    scroll.setWidget(self.content)
    lay = QVBoxLayout(self.content)
    for item in l :
    INDENT
        lay.addWidget(QLabel(item, self))
    DEDENT
    self.layout().addWidget(scroll, 0, 0, 1, self.layout().columnCount())
    self.setStyleSheet("QScrollArea{min-width:300 px; min-height: 400px}")
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QMessageBox.__init__(self, * args, ** kwargs)
    chldn = self.children()
    scrll = QScrollArea(self)
    scrll.setWidgetResizable(True)
    grd = self.findChild(QGridLayout)
    lbl = QLabel(chldn [1].text(), self)
    lbl.setWordWrap(True)
    scrll.setWidget(lbl)
    scrll.setMinimumSize(400, 200)
    grd.addWidget(scrll, 0, 1)
    chldn [1].setText('')
    self.exec_()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47345776_52913143_22_42
47345776_52913143_7_20
Title: PyQt5 - How to add a scrollbar to a QMessageBox 
----------------------------------------

def __init__(self) :
INDENT
    super(W, self).__init__()
    self.btn = QPushButton('Show Message', self)
    self.btn.setGeometry(10, 10, 100, 100)
    self.btn.clicked.connect(self.buttonClicked)
    self.message = ("""We have encountered an error.
The following information may be useful in troubleshooting:
1
2
3
4
5
6
7
8
9
10
Here is the bottom.
""")
    self.show()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QMessageBox.__init__(self, * args, ** kwargs)
    chldn = self.children()
    scrll = QScrollArea(self)
    scrll.setWidgetResizable(True)
    grd = self.findChild(QGridLayout)
    lbl = QLabel(chldn [1].text(), self)
    lbl.setWordWrap(True)
    scrll.setWidget(lbl)
    scrll.setMinimumSize(400, 200)
    grd.addWidget(scrll, 0, 1)
    chldn [1].setText('')
    self.exec_()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47354570_47354834_7_19
47354570_47355181_5_24
Title: How to simplify an account code? 
----------------------------------------

def login() :
INDENT
    username = input("Login: >> ")
    password = input("Password: >> ")
    if username in users and password == users [username] :
    INDENT
        print ("Access granted")
        print ("Welcome to the system!")
        return True
    DEDENT
    print ("Access denied")
    print ("Try again!")
    print ()
    return False
DEDENT
----------------------------------------

def login(user = None) :
INDENT
    if not user :
    INDENT
        user = input("Login: >> ").title()
        if not users.get(user) :
        INDENT
            print ("No such user")
            return None

        DEDENT
    DEDENT
    password = input("Password: >> ")
    if password == users [user] :
    INDENT
        print ("Access granted")
        print ("Welcome to the system!")
        return user
    DEDENT
    else :
    INDENT
        print ("Access denied")
        print ("Try again!")
        return login(user = user)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47357612_47357837_1_12
47357612_47357854_3_9
Title: Convert integers inside a list into strings and then a date in python 3.x 
----------------------------------------

def convert(lst) :
INDENT
    string = ''
    new_lst = []
    for x in lst :
    INDENT
        if len(str(x)) < 4 :
        INDENT
            string += str(x) + '/'
        DEDENT
        else :
        INDENT
            string += str(x)
            new_lst.append(string)
            string = ''
        DEDENT
    DEDENT
    return (new_lst)
DEDENT
----------------------------------------

def convert(inputList) :
INDENT
    tempList = []
    for i in range(0, len(inputList), 3) :
    INDENT
        newDate = str(inputList [i]) + "/" + str(inputList [i + 1]) + "/" + str(inputList [i + 2])
        tempList.append(newDate)
    DEDENT
    return tempList
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47359743_47360954_3_10
47359743_48209285_4_13
Title: How to make Min-plus matrix multiplication in python faster? 
----------------------------------------

def min_plus_product(A, B) :
INDENT
    B = np.transpose(B)
    Y = np.zeros((len(B), len(A)))
    for i in range(len(B)) :
    INDENT
        Y [i] = (A + B [i]).min(1)
    DEDENT
    return np.transpose(Y)

DEDENT
----------------------------------------

def min_plus_product(A, B) :
INDENT
    n = A.shape [0]
    C = np.zeros((n, n))
    for i in range(n) :
    INDENT
        for j in range(n) :
        INDENT
            minimum = A [i, 0] + B [0, j]
            for k in range(1, n) :
            INDENT
                minimum = min(A [i, k] + B [k, j], minimum)
            DEDENT
            C [i, j] = minimum
        DEDENT
    DEDENT
    return C
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47360640_47366893_30_40
47360640_47366893_6_24
Title: How to create Tkinter Widgets inside Parent class from Sub class 
----------------------------------------

def __init__(self, master) :
INDENT
    super().__init__(master)
    self.label = tk.Label(self, text = "this is SearchFrame")
    self.label.pack()
    master.label1 = MainApp.create_labels(self, master)
    master.label1.grid()

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    super().__init__(master)

    self.frame1 = tk.Frame(self)
    tk.Label(self.frame1, text = "This is MainApp frame1").pack()
    self.frame1.grid(row = 0, column = 0, sticky = "nsew")

    self.frame2 = SearchFrame(self)
    self.frame2.grid(row = 0, column = 1, sticky = "nsew")

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47361708_47362087_3_10
47361708_47362305_1_9
Title: Making list of unique numbers 
----------------------------------------

def get_numbers(mylist) :
INDENT
    nums = []
    for i in mylist :
    INDENT
        nums.append(map(int, i.split()))

    DEDENT
    return nums
DEDENT
----------------------------------------

def get_numbers(mylist) :
INDENT
    nums = []
    for i in mylist :
    INDENT
        nums.append(i.split())
        for i in range(len(nums)) :
        INDENT
            for j in range(len(nums [0])) :
            INDENT
                nums [i] [j] = int(nums [i] [j])
            DEDENT
        DEDENT
    DEDENT
    return nums
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47363395_47363430_2_11
47363395_47363491_2_12
Title: I need help making a random number generator as a lock in a simple game 
----------------------------------------

def main() :
INDENT
    values = [1, 2, 3, 5, 7, 10]
    a = random.choice(values)
    print (a)
    b = input('Enter a number: ')
    if int(b) == a :
    INDENT
        print ('You have guessed the number!')
    DEDENT
    else :
    INDENT
        print ('Try again')
        main()
    DEDENT
DEDENT
----------------------------------------

def main(a = None) :
INDENT
    if a == None :
    INDENT
        values = [1, 2, 3, 5, 7, 10]
        a = random.choice(values)
        print (a)
    DEDENT
    b = int(input('Enter a number: '))
    if b == a :
    INDENT
        print ('You have guessed the number!')
    DEDENT
    else :
    INDENT
        print ('Try again')
        main(a)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47371450_47398320_32_42
47371450_47398320_49_64
Title: Inherit and add indexes from sqlalchemy mixins 
----------------------------------------

def __table_args__(cls) :
INDENT
    mixin_indexes = list((super(cls, cls).__table_args__))
    mixin_indexes.extend([
            Index('idx__word__apple', 'apple'),
            Index('idx__word__banana', 'banana'),
            ])
    return tuple(mixin_indexes)

DEDENT
----------------------------------------

def __table_args__(cls) :
INDENT
    mixin_indexes = []
    for base_class in cls.__mro__ :
    INDENT
        try :
        INDENT
            mixin_indexes.extend(super(base_class, cls).__table_args__)
        DEDENT
        except AttributeError :
        INDENT
            pass
        DEDENT
    DEDENT
    mixin_indexes.extend([
            Index('idx__letter__a', 'a'),
            Index('idx__letter__b', 'b'),
            ])
    return tuple(mixin_indexes)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47380565_47380599_1_19
47380565_48021537_1_15
Title: "Why does ""if 0 <= Points >= 50:"" always trigger?" 
----------------------------------------

def which_prize(Points) :
INDENT
    y = 1
    x = ''
    if 0 < = Points < = 50 :
    INDENT
        x = "wooden rabbit"
    DEDENT
    elif 151 < = Points < = 180 :
    INDENT
        x = "wafer-thin mint"
    DEDENT
    elif 181 < = Points < = 200 :
    INDENT
        x = "penguin"
    DEDENT
    else :
    INDENT
        y = 0
    DEDENT
    re = "Congratulations! You have won a {}!".format(x)
    if y == 0 :
    INDENT
        re = "Oh dear, no prize this time."
    DEDENT
    return re

DEDENT
----------------------------------------

def which_prize(points) :
INDENT
    prize = None
    if 0 < = points < = 50 :
    INDENT
        prize = "a wooden rabbit"
    DEDENT
    elif 151 < = points < = 180 :
    INDENT
        prize = "a wafer-thin mint"
    DEDENT
    elif 181 < = points < = 200 :
    INDENT
        prize = "a penguin"
    DEDENT
    if prize :
    INDENT
        return "Congratulations! You have won " + prize + "!"
    DEDENT
    else :
    INDENT
        return "Oh dear, no prize this time."
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47385617_47385799_1_24
47385617_47385802_5_25
Title: Using max() and min() unsuccessfully in Python array 
----------------------------------------

def calculationAlgorithm(userYearsTracking) :
INDENT
    totalMonths = 0
    totalRainfall = 0
    maxRainfall = 0
    minRainfall = sys.maxsize
    for currentYear in range(1, userYearsTracking + 1) :
    INDENT
        for currentMonth in range(1, 13) :
        INDENT
            monthlyRainfall = int(input("Inches of rainfall for month " + format(currentMonth, "d",) + " | year " +
                    format(currentYear, "d",) + ": "))
            if monthlyRainfall < 0 :
            INDENT
                print ("Error invalid rainfall entered")
                sys.exit()
            DEDENT
            if monthlyRainfall > maxRainfall :
            INDENT
                maxRainfall = monthlyRainfall
            DEDENT
            if monthlyRainfall < minRainfall :
            INDENT
                minRainfall = monthlyRainfall
            DEDENT
            totalMonths += 1
            totalRainfall += monthlyRainfall
        DEDENT
    DEDENT
    averageRainfall = totalRainfall / totalMonths
    print ("Total months: " + str(totalMonths))
    print ("Total rain:", format(totalRainfall), "(inch)")
    print ("Total average rainfall:", round(averageRainfall, 2), "(inch)")
    print ("Largest input rainfall: " + str(maxRainfall))
    print ("Smallest input rainfall: " + str(minRainfall))
DEDENT
----------------------------------------

def calculationAlgorithm(userYearsTracking) :
INDENT
    totalMonths = 0
    totalRainfall = 0
    rainfallList = []
    for currentYear in range(1, userYearsTracking + 1) :
    INDENT
        for currentMonth in range(1, 13) :
        INDENT
            monthlyRainfall = int(input("Inches of rainfall for month " + format(currentMonth, "d",) + " | year " +
                    format(currentYear, "d",) + ": "))
            totalMonths += 1
            rainfallList.append(monthlyRainfall)
            totalRainfall += monthlyRainfall
        DEDENT
    DEDENT
    averageRainfall = totalRainfall / totalMonths
    print ("Total months: " + str(totalMonths))
    print ("Total rain:", format(totalRainfall), "(inch)")
    print ("Total average rainfall:", round(averageRainfall, 2), "(inch)")
    print ("Min rain:", format(min(rainfallList)), "(inch)")
    print ("Max rain:", format(max(rainfallList)), "(inch)")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47396022_47396253_19_32
47396022_47396533_11_28
Title: python printing from dictionary 
----------------------------------------

def print_data() :
INDENT
    attendees1, attendees2 = data()

    if len(attendees1) > 0 :
    INDENT
        print ('Level 1')
        for i in attendees1 :
        INDENT
            print (i, attendees1 [i])
        DEDENT
    DEDENT
    if len(attendees2) > 0 :
    INDENT
        print ('Level 2')
        for i in attendees2 :
        INDENT
            print (i, attendees2 [i])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def print_data(attendees) :
INDENT
    level_one = []
    level_two = []
    for name, count in attendees.items() :
    INDENT
        if count > = 20 :
        INDENT
            level_one.append((name, count))
        DEDENT
        else :
        INDENT
            level_two.append((name, count))
        DEDENT
    DEDENT
    print ('Level 1')
    for name, count in level_one :
    INDENT
        print (name, count)
    DEDENT
    print ('\nlevel 2')
    for name, count in level_two :
    INDENT
        print (name, count)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47396022_47396253_1_18
47396022_47396533_1_10
Title: python printing from dictionary 
----------------------------------------

def data() :
INDENT
    people = int(input("How many individuals are attending? "))
    attendees1 = {}
    attendees2 = {}
    for i in range(people) :
    INDENT
        name = str(input('Please enter name: '))
        amount = int(input('Number of toys donated:'))
        if amount > 20 :
        INDENT
            attendees1 [name] = amount
        DEDENT
        else :
        INDENT
            attendees2 [name] = amount
        DEDENT
    DEDENT
    return attendees1, attendees2

DEDENT
----------------------------------------

def data() :
INDENT
    people = int(input("How many individuals are attending? "))
    attendees = {}
    for i in range(people) :
    INDENT
        name = str(input('Please enter name: '))
        amount = int(input('Number of toys donated:'))
        attendees [name] = amount
    DEDENT
    return attendees

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47396372_47571289_12_19
47396372_47571289_49_56
Title: Write opencv frames into gstreamer rtsp server pipeline 
----------------------------------------

def __init__(self, ** properties) :
INDENT
    super(SensorFactory, self).__init__(** properties)
    self.cap = cv2.VideoCapture(0)
    self.number_frames = 0
    self.fps = 30
    self.duration = 1 / self.fps * Gst.SECOND
    self.launch_string = 'appsrc name=source is-live=true block=true format=GST_FORMAT_TIME ' 'caps=video/x-raw,format=BGR,width=640,height=480,framerate={}/1 ' '! videoconvert ! video/x-raw,format=I420 ' '! x264enc speed-preset=ultrafast tune=zerolatency ' '! rtph264pay config-interval=1 name=pay0 pt=96'.format(self.fps)
DEDENT
----------------------------------------

def __init__(self, ** properties) :
INDENT
    super(GstServer, self).__init__(** properties)
    self.factory = SensorFactory()
    self.factory.set_shared(True)
    self.get_mount_points().add_factory("/test", self.factory)
    self.attach(None)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
473973_41695576_1_10
473973_53303854_3_11
Title: "Shuffle an array with python randomize array item order with python" 
----------------------------------------

def shuffle(arr) :
INDENT
    for n in range(len(arr) - 1) :
    INDENT
        rnd = random.randint(0, (len(arr) - 1))
        val1 = arr [rnd]
        val2 = arr [rnd - 1]
        arr [rnd - 1] = val1
        arr [rnd] = val2
    DEDENT
    return arr
DEDENT
----------------------------------------

def shuffle(arr) :
INDENT
    a = numpy.arange(len(arr))
    b = numpy.empty(1)
    for i in range(len(arr)) :
    INDENT
        sel = numpy.random.random_integers(0, high = len(a) - 1, size = 1)
        b = numpy.append(b, a [sel])
        a = numpy.delete(a, sel)
    DEDENT
    b = b [1 :].astype(int)
    return arr [b]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47407087_47407831_18_29
47407087_47419805_13_21
Title: My turtle code has an error i cant seem to fix at the end of it 
----------------------------------------

def star(x, y, width, shape_color) :
INDENT
    t.fillcolor(shape_color)
    t.penup()
    t.goto(x, y)
    t.pendown()
    t.begin_fill()
    for s in range(5) :
    INDENT
        t.forward(width)
        t.right(144)
    DEDENT
    t.end_fill()

DEDENT
----------------------------------------

def star(width) :
INDENT
    turtle.begin_poly()
    for _ in range(5) :
    INDENT
        turtle.forward(width)
        turtle.right(144)
    DEDENT
    turtle.end_poly()
    return turtle.get_poly()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4740988_4754141_15_27
4740988_4754141_74_90
Title: Add new navigate modes in matplotlib 
----------------------------------------

def __init__(self, canvas) :
INDENT
    super(NavigationToolbar2WxAgg, self).__init__(canvas)
    self.pan_tool = self.FindById(self._NTB2_PAN)
    self.zoom_tool = self.FindById(self._NTB2_ZOOM)
    self.lasso_tool = self.InsertSimpleTool(5, self.ID_LASSO_TOOL,
        wx.ArtProvider.GetBitmap(wx.ART_ADD_BOOKMARK),
        isToggle = True)
    self.Bind(wx.EVT_TOOL, self.on_toggle_lasso_tool, self.lasso_tool)
    self.Bind(wx.EVT_TOOL, self.on_toggle_pan_zoom, self.zoom_tool)
    self.Bind(wx.EVT_TOOL, self.on_toggle_pan_zoom, self.pan_tool)
DEDENT
----------------------------------------

def __init__(self, parent, ** kwargs) :
INDENT
    self.figure = Figure()
    FigureCanvasWxAgg.__init__(self, parent, - 1, self.figure, ** kwargs)
    self.canvas = self.figure.canvas
    self.SetMinSize((100, 100))
    self.figure.set_facecolor((1, 1, 1))
    self.figure.set_edgecolor((1, 1, 1))
    self.canvas.SetBackgroundColour('white')
    self.subplot = self.figure.add_subplot(111)
    self.navtoolbar = None
    self.lasso = None
    self.redraw()
    self.canvas.mpl_connect('button_press_event', self.on_press)
    self.canvas.mpl_connect('button_release_event', self.on_release)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4740988_4754141_15_27
4740988_4762187_7_19
Title: Add new navigate modes in matplotlib 
----------------------------------------

def __init__(self, canvas) :
INDENT
    super(NavigationToolbar2WxAgg, self).__init__(canvas)
    self.pan_tool = self.FindById(self._NTB2_PAN)
    self.zoom_tool = self.FindById(self._NTB2_ZOOM)
    self.lasso_tool = self.InsertSimpleTool(5, self.ID_LASSO_TOOL,
        wx.ArtProvider.GetBitmap(wx.ART_ADD_BOOKMARK),
        isToggle = True)
    self.Bind(wx.EVT_TOOL, self.on_toggle_lasso_tool, self.lasso_tool)
    self.Bind(wx.EVT_TOOL, self.on_toggle_pan_zoom, self.zoom_tool)
    self.Bind(wx.EVT_TOOL, self.on_toggle_pan_zoom, self.pan_tool)
DEDENT
----------------------------------------

def __init__(self, canvas) :
INDENT
    super(NavigationToolbar2WxAgg, self).__init__(canvas)
    self.pan_tool = self.FindById(self._NTB2_PAN)
    self.zoom_tool = self.FindById(self._NTB2_ZOOM)
    self.Bind(wx.EVT_TOOL, self.on_toggle_pan_zoom, self.zoom_tool)
    self.Bind(wx.EVT_TOOL, self.on_toggle_pan_zoom, self.pan_tool)
    self.user_tools = {}
    self.InsertSeparator(5)
    self.add_user_tool('lasso', 6, icons.lasso_tool.ConvertToBitmap(), True, 'Lasso')
    self.add_user_tool('gate', 7, icons.gate_tool.ConvertToBitmap(), True, 'Gate')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4740988_4754141_28_35
4740988_4762187_35_42
Title: Add new navigate modes in matplotlib 
----------------------------------------

def get_mode(self) :
INDENT
    if self.lasso_tool.IsToggled() :
    INDENT
        return 'lasso'
    DEDENT
    else :
    INDENT
        return self.mode
    DEDENT
DEDENT
----------------------------------------

def get_mode(self) :
INDENT
    for mode, tool in self.user_tools.items() :
    INDENT
        if tool.IsToggled() :
        INDENT
            return mode
        DEDENT
    DEDENT
    return self.mode
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4740988_4754141_74_90
4740988_4762187_7_19
Title: Add new navigate modes in matplotlib 
----------------------------------------

def __init__(self, parent, ** kwargs) :
INDENT
    self.figure = Figure()
    FigureCanvasWxAgg.__init__(self, parent, - 1, self.figure, ** kwargs)
    self.canvas = self.figure.canvas
    self.SetMinSize((100, 100))
    self.figure.set_facecolor((1, 1, 1))
    self.figure.set_edgecolor((1, 1, 1))
    self.canvas.SetBackgroundColour('white')
    self.subplot = self.figure.add_subplot(111)
    self.navtoolbar = None
    self.lasso = None
    self.redraw()
    self.canvas.mpl_connect('button_press_event', self.on_press)
    self.canvas.mpl_connect('button_release_event', self.on_release)
DEDENT
----------------------------------------

def __init__(self, canvas) :
INDENT
    super(NavigationToolbar2WxAgg, self).__init__(canvas)
    self.pan_tool = self.FindById(self._NTB2_PAN)
    self.zoom_tool = self.FindById(self._NTB2_ZOOM)
    self.Bind(wx.EVT_TOOL, self.on_toggle_pan_zoom, self.zoom_tool)
    self.Bind(wx.EVT_TOOL, self.on_toggle_pan_zoom, self.pan_tool)
    self.user_tools = {}
    self.InsertSeparator(5)
    self.add_user_tool('lasso', 6, icons.lasso_tool.ConvertToBitmap(), True, 'Lasso')
    self.add_user_tool('gate', 7, icons.gate_tool.ConvertToBitmap(), True, 'Gate')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4742919_4753465_51_58
4742919_4753588_2_10
Title: "Using python logging package how to insert additional formatting into multiple logger handlers that have their own formatters?" 
----------------------------------------

def indent(self, step = 1) :
INDENT
    "Change the current indent level by the step (use negative to decrease)"
    self._indent_level += step
    if self._indent_level < 0 :
    INDENT
        self._indent_level = 0
    DEDENT
    self._indent_str = self._indent_str_base * self._indent_level

DEDENT
----------------------------------------

def indent(self, step = 1) :
INDENT
    "Change the current indent level by the step (use negative to decrease)"
    self._indent_level += step
    if self._indent_level < 0 :
    INDENT
        self._indent_level = 0
    DEDENT
    self._indent_str = self._indent_str_base * self._indent_level
    for lvl in LEVELS :
    INDENT
        level_name = self._indent_str + LEVELS [lvl]
        logging.addLevelName(lvl, level_name)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47433987_47434191_6_13
47433987_47434585_1_14
Title: Error in converting an array to 2D matrix in Python 
----------------------------------------

def chunk(array, size) :
INDENT
    out = []
    while array :
    INDENT
        t_list = []
        for i in range(size) :
        INDENT
            t_list.append(pop_with_replace(array))
        DEDENT
        out.append(t_list)
    DEDENT
    return out
DEDENT
----------------------------------------

def chunk(inputarray, size) :
INDENT
    array = inputarray [:]
    m_matrix = []

    while len(array) > 0 :
    INDENT
        if len(array [: size]) < size :
        INDENT
            array.extend(['' for j in range(size - len(array [: size]))])
        DEDENT
        m_matrix.append(array [: size])
        del array [: size]

    DEDENT
    return m_matrix
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47454039_47454733_109_122
47454039_47454733_35_60
Title: Trying to code a password checker and generator using Tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    self.var = tk.StringVar()
    self.var.set(gen)
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "Generate a password", font = controller.title_font)
    label1.pack(side = "top", fill = "x", pady = 10)
    label2 = tk.Label(self, textvariable = self.var, font = controller.title_font)
    button = tk.Button(self, text = "Back",
        command = lambda : controller.show_frame("StartPage"))
    label2.pack()
    button.pack()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.title_font = tkfont.Font(family = 'Helvetica', size = 18, weight = "bold", slant = "italic")

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47454039_47454733_109_122
47454039_47454733_67_82
Title: Trying to code a password checker and generator using Tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    self.var = tk.StringVar()
    self.var.set(gen)
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "Generate a password", font = controller.title_font)
    label1.pack(side = "top", fill = "x", pady = 10)
    label2 = tk.Label(self, textvariable = self.var, font = controller.title_font)
    button = tk.Button(self, text = "Back",
        command = lambda : controller.show_frame("StartPage"))
    label2.pack()
    button.pack()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "Password program", font = controller.title_font)
    label.pack(side = "top", fill = "x", pady = 10)
    button1 = tk.Button(self, text = "Check your password strength",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Generate a new password",
        command = self.generate_password)
    button3 = tk.Button(self, text = "quit", command = close)
    button1.pack()
    button2.pack()
    button3.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47454039_47454733_109_122
47454039_47454733_91_107
Title: Trying to code a password checker and generator using Tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    self.var = tk.StringVar()
    self.var.set(gen)
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "Generate a password", font = controller.title_font)
    label1.pack(side = "top", fill = "x", pady = 10)
    label2 = tk.Label(self, textvariable = self.var, font = controller.title_font)
    button = tk.Button(self, text = "Back",
        command = lambda : controller.show_frame("StartPage"))
    label2.pack()
    button.pack()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "Check your password", font = controller.title_font)
    label1.pack(side = "top", fill = "x", pady = 10)
    entry = tk.Entry(self, bd = 6)
    button2 = tk.Button(self, text = "Back",
        command = lambda : controller.show_frame("StartPage"))
    label2 = tk.Label(self, text = "Strength:", font = controller.title_font)
    label3 = tk.Label(self, text = strength, font = controller.title_font)
    entry.pack()
    button2.pack()
    label2.pack()
    label3.pack()
    password = list(entry.get())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47454039_47454733_35_60
47454039_47454733_67_82
Title: Trying to code a password checker and generator using Tkinter 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.title_font = tkfont.Font(family = 'Helvetica', size = 18, weight = "bold", slant = "italic")

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "Password program", font = controller.title_font)
    label.pack(side = "top", fill = "x", pady = 10)
    button1 = tk.Button(self, text = "Check your password strength",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Generate a new password",
        command = self.generate_password)
    button3 = tk.Button(self, text = "quit", command = close)
    button1.pack()
    button2.pack()
    button3.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47454039_47454733_35_60
47454039_47454733_91_107
Title: Trying to code a password checker and generator using Tkinter 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.title_font = tkfont.Font(family = 'Helvetica', size = 18, weight = "bold", slant = "italic")

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame

        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("StartPage")
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "Check your password", font = controller.title_font)
    label1.pack(side = "top", fill = "x", pady = 10)
    entry = tk.Entry(self, bd = 6)
    button2 = tk.Button(self, text = "Back",
        command = lambda : controller.show_frame("StartPage"))
    label2 = tk.Label(self, text = "Strength:", font = controller.title_font)
    label3 = tk.Label(self, text = strength, font = controller.title_font)
    entry.pack()
    button2.pack()
    label2.pack()
    label3.pack()
    password = list(entry.get())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47454039_47454733_67_82
47454039_47454733_91_107
Title: Trying to code a password checker and generator using Tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "Password program", font = controller.title_font)
    label.pack(side = "top", fill = "x", pady = 10)
    button1 = tk.Button(self, text = "Check your password strength",
        command = lambda : controller.show_frame("PageOne"))
    button2 = tk.Button(self, text = "Generate a new password",
        command = self.generate_password)
    button3 = tk.Button(self, text = "quit", command = close)
    button1.pack()
    button2.pack()
    button3.pack()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "Check your password", font = controller.title_font)
    label1.pack(side = "top", fill = "x", pady = 10)
    entry = tk.Entry(self, bd = 6)
    button2 = tk.Button(self, text = "Back",
        command = lambda : controller.show_frame("StartPage"))
    label2 = tk.Label(self, text = "Strength:", font = controller.title_font)
    label3 = tk.Label(self, text = strength, font = controller.title_font)
    entry.pack()
    button2.pack()
    label2.pack()
    label3.pack()
    password = list(entry.get())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47465611_47465689_26_33
47465611_47466973_1_11
Title: Python: i would like to have an error message? 
----------------------------------------

def writeToFile(self) :
INDENT
    if self.E1.get() == self.E2.get() :
    INDENT
        raise EntryException
    DEDENT
    else :
    INDENT
        with open('ttest.csv', 'a') as f :
        INDENT
            w = csv.writer(f, quoting = csv.QUOTE_ALL)
            w.writerow([self.E1.get()])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def writeToFile(self) :
INDENT
    from tkinter import messagebox
    if self.E1.get() == self.E2.get() :
    INDENT
        messagebox.showerror('Error Message', "Both Users have the name '{}'".format(self.E1.get()))
        return
    DEDENT
    with open('ttest.csv', 'a') as f :
    INDENT
        w = csv.writer(f, quoting = csv.QUOTE_ALL)
        w.writerow([self.E1.get(), self.E2.get()])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4747666_4748030_1_20
4747666_4748216_3_31
Title: Optimizing python code 
----------------------------------------

def nextPal(n) :
INDENT
    ns = str(n)
    oddoffset = 0
    if len(ns) % 2 ! = 0 :
    INDENT
        oddoffset = 1
    DEDENT
    leftlen = len(ns) / 2 + oddoffset
    lefts = ns [0 : leftlen]
    right = lefts [: : - 1] [oddoffset :]
    p = int(lefts + right)
    if p < n :
    INDENT

        left = int(lefts)
        left += 1
        lefts = str(left)
        right = lefts [: : - 1] [oddoffset :]
        p = int(lefts + right)
    DEDENT
    return p
DEDENT
----------------------------------------

def nextPal(numstr) :
INDENT
    n = len(numstr)
    h = n / / 2
    guess = numstr [: n - h] + numstr [h - 1 : : - 1]
    if guess > numstr :
    INDENT
        return guess

    DEDENT
    a = array.array('b', numstr)
    zero = ord('0')
    ten = ord('9') + 1
    for i in range(n - h - 1, - 1, - 1) :
    INDENT
        d = a [i] + 1
        if d == ten :
        INDENT
            a [i] = zero
        DEDENT
        else :
        INDENT
            a [i] = d
            break
        DEDENT
    DEDENT
    else :
    INDENT

        a.insert(0, ord('1'))
        n += 1
        h = n / / 2

    DEDENT
    a [n - h :] = a [h - 1 : : - 1]
    return a.tostring()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47498081_47498128_2_12
47498081_47498848_1_12
Title: Incorrect shape pandas DataFrame 
----------------------------------------

def data(symbols) :
INDENT
    dfs = []
    for symbol in symbols :
    INDENT
        df_temp = pd.read_csv('/home/furqan/Desktop/USSP/{}.csv'.format(str(symbol)), usecols = ['Date', 'Price'],
            parse_dates = True, index_col = 'Date', na_values = ['nan'])
        df_temp = df_temp.rename(columns = {'Price' : symbol})
        dfs.append(df_temp)
    DEDENT
    dates = pd.date_range(start_date, end_date)
    return pd.concat(dfs, axis = 1).reindex(dates, method = 'ffill').bfill()
DEDENT
----------------------------------------

def data(symbols) :
INDENT
    dates = pd.date_range(start_date, end_date)
    df = pd.DataFrame(index = dates)
    for symbol in symbols :
    INDENT
        df_temp = pd.read_csv('/home/furqan/Desktop/USSP/{}.csv'.format(str(symbol)), usecols = ['Date', 'Price'],
            parse_dates = True, index_col = 'Date', na_values = ['nan'])
        df_temp = df_temp.rename(columns = {'Price' : symbol})
        df_temp = df_temp.loc [~ df_temp.index.duplicated(keep = 'first')]
        df = df.join(df_temp)
        df = df.fillna(method = 'ffill')
        df = df.fillna(method = 'bfill')
    DEDENT
    return df
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47498558_47498653_1_10
47498558_47498709_1_13
Title: How to get a while statement to work with biggest power smaller than x? 
----------------------------------------

def gond7(n) :
INDENT
    x = 0
    amount = x ** 11
    while amount < = n :
    INDENT
        result = amount
        x += 1
        amount = x ** 11
    DEDENT
    return result

DEDENT
----------------------------------------

def gond7(n) :
INDENT
    x = 0
    amount = x ** 11
    while amount < = n :
    INDENT
        x += 1
        amount = x ** 11
    DEDENT
    if amount > n :
    INDENT
        return (x - 1) ** 11
    DEDENT
    else :
    INDENT
        return amount

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47499255_47499332_1_14
47499255_47499727_1_19
Title: Python permutation with recursion 
----------------------------------------

def perm(lst, lvl = 0) :
INDENT
    if len(lst) == 0 :
    INDENT
        return []
    DEDENT
    if len(lst) == 1 :
    INDENT
        return [lst]
    DEDENT
    l = []
    for i in range(len(lst)) :
    INDENT
        m = [lst [i]]
        for p in perm(lst [: i] + lst [i + 1 :], lvl + 1) :
        INDENT
            l.append(m + p)
        DEDENT
    DEDENT
    if lvl == 0 :
    INDENT
        for p in l :
        INDENT
            print (p)
        DEDENT
    DEDENT
    return l
DEDENT
----------------------------------------

def perm(lst) :
INDENT
    def recurse(lst) :
    INDENT
        print ('recurse', lst)
        if len(lst) == 0 :
        INDENT
            return []
        DEDENT
        if len(lst) == 1 :
        INDENT
            return [lst]
        DEDENT
        l = []
        for i in range(len(lst)) :
        INDENT
            m = lst [i]
            rem = lst [: i] + lst [i + 1 :]
            for p in recurse(rem) :
            INDENT
                l.append([m] + p)
            DEDENT
        DEDENT
        return l
    DEDENT
    l = recurse(lst)
    print (l)
    return l
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47500091_47515184_21_30
47500091_47515184_4_14
Title: Dynamically Disable Checkbox in wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent, - 1, 'Window2', size = (1000, 700))
    self.parent = parent
    self.panel = wx.Panel(self, - 1)
    self.chk = wx.CheckBox(self.panel, - 1, "Apples", (20, 100), (160, - 1))
    self.Bind(wx.EVT_CHECKBOX, self.Check)
    self.SetBackgroundColour(wx.Colour(100, 100, 100))
    self.Centre()
    self.Show()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "My Frame", size = (3000, 3000))
    self.panel = wx.Panel(self, - 1)
    self.a = wx.CheckBox(self.panel, - 1, "Apples", (20, 100), (160, - 1))
    self.b = wx.CheckBox(self.panel, - 1, "Mango", (20, 150), (160, - 1))
    self.c = wx.CheckBox(self.panel, - 1, "Banana", (20, 200), (160, - 1))
    self.d = wx.CheckBox(self.panel, - 1, "Orange", (20, 250), (160, - 1))
    button = wx.Button(self.panel, label = "Child", pos = (800, 400), size = (50, 50))
    self.Bind(wx.EVT_BUTTON, self.newwindow, button)
    self.a.SetValue(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47501708_47502668_21_27
47501708_47502875_18_42
Title: Kivy: Work with events 
----------------------------------------

def on_touch_down(self, touch) :
INDENT
    color = self.palete.act_col
    with self.canvas :
    INDENT
        Color(color [0], color [1], color [2])
        sqr = Rectangle(pos = (touch.x, touch.y), size = (20, 40))
        self.contents.append(sqr)
    DEDENT
DEDENT
----------------------------------------

def on_touch_down(self, touch) :
INDENT
    if self.collide_point(* touch.pos) :
    INDENT
        color = self.palette.act_col
        with self.canvas :
        INDENT
            Color(color [0], color [1], color [2])
            sqr = Rectangle(pos = (touch.x, touch.y), size = (20, 40))
            self.contents.append(sqr)
        DEDENT
        return True
    DEDENT
    return super(Paint, self).on_touch_down(touch)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47501708_47502668_29_52
47501708_47502875_46_67
Title: Kivy: Work with events 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Palete, self).__init__(** kwargs)
    self.act_col = (1, 0, 0)
    self.licol = []
    self.licol.append((1, 0, 0))
    self.licol.append((0, 1, 0))
    self.paint = None
    self.layout = BoxLayout(size_hint = (1, None), height = 50)
    for i in range(0, len(self.licol)) :
    INDENT
        but = Button(id = str(i))
        col = self.licol [i]
        but.background_normal = ''
        but.background_color = (col [0], col [1], col [2], 1)

        act = partial(self.SetColor, but.id)
        but.bind(on_press = act)
        self.layout.add_widget(but)
    DEDENT
    but = Button(text = "<--", on_press = self.ClearContents)
    self.layout.add_widget(but)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Palette, self).__init__(** kwargs)
    self.licol = []
    self.licol.append((1, 0, 0))
    self.licol.append((0, 1, 0))
    self.size_hint = (1, None)
    self.height = 50
    for i in range(0, len(self.licol)) :
    INDENT
        but = Button(id = str(i))
        col = self.licol [i]
        but.background_normal = ''
        but.background_color = (col [0], col [1], col [2], 1)
        but.bind(on_press = self.SetColor)
        self.add_widget(but)
    DEDENT
    but = Button(text = "<--", on_press = self.ClearContents)
    self.add_widget(but)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47501708_47502668_29_52
47501708_47502875_83_93
Title: Kivy: Work with events 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Palete, self).__init__(** kwargs)
    self.act_col = (1, 0, 0)
    self.licol = []
    self.licol.append((1, 0, 0))
    self.licol.append((0, 1, 0))
    self.paint = None
    self.layout = BoxLayout(size_hint = (1, None), height = 50)
    for i in range(0, len(self.licol)) :
    INDENT
        but = Button(id = str(i))
        col = self.licol [i]
        but.background_normal = ''
        but.background_color = (col [0], col [1], col [2], 1)

        act = partial(self.SetColor, but.id)
        but.bind(on_press = act)
        self.layout.add_widget(but)
    DEDENT
    but = Button(text = "<--", on_press = self.ClearContents)
    self.layout.add_widget(but)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Painting, self).__init__(** kwargs)
    self.orientation = "vertical"
    self.palette = Palette()
    self.paint = Paint(palette = self.palette)
    self.add_widget(self.paint)
    self.add_widget(self.palette)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47501708_47502668_58_64
47501708_47502875_73_78
Title: Kivy: Work with events 
----------------------------------------

def ClearContents(self, obj) :
INDENT
    if not self.paint :
    INDENT
        return
    DEDENT
    if self.paint.contents :
    INDENT
        self.paint.canvas.remove(self.paint.contents.pop())

    DEDENT
DEDENT
----------------------------------------

def ClearContents(self, btn) :
INDENT
    if len(self.parent.paint.contents) ! = 0 :
    INDENT

        self.parent.paint.canvas.remove(self.parent.paint.contents.pop())

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47501708_47502875_46_67
47501708_47502875_83_93
Title: Kivy: Work with events 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Palette, self).__init__(** kwargs)
    self.licol = []
    self.licol.append((1, 0, 0))
    self.licol.append((0, 1, 0))
    self.size_hint = (1, None)
    self.height = 50
    for i in range(0, len(self.licol)) :
    INDENT
        but = Button(id = str(i))
        col = self.licol [i]
        but.background_normal = ''
        but.background_color = (col [0], col [1], col [2], 1)
        but.bind(on_press = self.SetColor)
        self.add_widget(but)
    DEDENT
    but = Button(text = "<--", on_press = self.ClearContents)
    self.add_widget(but)

DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Painting, self).__init__(** kwargs)
    self.orientation = "vertical"
    self.palette = Palette()
    self.paint = Paint(palette = self.palette)
    self.add_widget(self.paint)
    self.add_widget(self.palette)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47503531_47503818_39_54
47503531_47503818_7_20
Title: Problems on embedding matplotlib in PyQt4 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.canvas_widget = MyCanvas()
    self.combo = QtGui.QComboBox()
    for key in MyCanvas().case_dict :
    INDENT
        self.combo.addItem(key)
        self.combo.setCurrentIndex(- 1)
    DEDENT
    self.combo.currentIndexChanged.connect(self.showPlot)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.canvas_widget)
    layout.addWidget(self.combo)
DEDENT
----------------------------------------

def __init__(self, parent = None, key = "case 1") :
INDENT
    self.case_dict = {"case 1" : [2, 4, 6, 8, 10],
        "case 2" : [3, 4, 5, 6, 7]}
    self.key = key
    self.fig = Figure()
    self.axes = self.fig.add_subplot(111)
    FigureCanvas.__init__(self, self.fig)
    self.setParent(parent)
    FigureCanvas.updateGeometry(self)
    self.sc = None
    self.compute_initial_figure()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47514605_47517003_10_24
47514605_47517003_41_64
Title: "Python - Initialzing tkinter inside classand what happens when need another gui in another class?" 
----------------------------------------

def __init__(self, fname = '', path = '', ** kwargs) :
INDENT
    if fname == '' and path == '' :
    INDENT
        master = tk.Tk()
        master.withdraw()
        self.filename = askopenfilename(title = 'Select CSV file', filetypes = [('CommaSeperatedFile', '*.csv')])
        master.destroy()
    DEDENT
    else :
    INDENT
        if path ! = '' :
        INDENT
            self.filename = path + '/' + fname
        DEDENT
        else :
        INDENT
            self.filename = fname
        DEDENT
    DEDENT
    self.file_content = []
    self.read_file(kwargs)
    self.out_in_gui()
DEDENT
----------------------------------------

def __init__(self, filename, data = []) :
INDENT
    self.filename = filename
    master = tk.Tk()
    ttk.Frame.__init__(self, master)
    self.grid()

    fname = 'No file loaded'

    self.frame = ttk.LabelFrame(self, text = 'Data set', padding = 10)
    self.frame.grid(row = 0, column = 0, padx = 5, pady = 5)
    self.widgets_frame = ttk.Frame(self)
    self.widgets_frame.grid(row = 1, column = 0)
    self.m, self.row_vars = [], []
    self.exec_gui(data)
    print (data)
    master.mainloop()
DEDENT
----------------------------------------
