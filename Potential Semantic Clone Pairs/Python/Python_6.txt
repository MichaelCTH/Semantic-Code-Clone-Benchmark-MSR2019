$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15469314_15469573_1_10
15469314_15469620_51_70
Title: pygame moving a user controlled object until key is released? 
----------------------------------------

def event_loop(self) :
INDENT
    toon = self.toon
    while True :
    INDENT
        self.event_handle()
        toon.speed [0] *= 0.95
        toon.speed [1] *= 0.95
        toon.update()
        self.draw()
        pygame.time.delay(10)
    DEDENT
DEDENT
----------------------------------------

def event_loop(self) :
INDENT
    toon = self.toon
    friction = 1
    while True :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == QUIT :
            INDENT
                pygame.quit()
                sys.exit()
            DEDENT
            elif event.type == pygame.KEYDOWN :
            INDENT
                deltax, deltay = delta.get(event.key, (0, 0))
                toon.speed [0] += deltax
                toon.speed [1] += deltay
                friction = 1
            DEDENT
            elif event.type == pygame.KEYUP :
            INDENT
                friction = 0.95
            DEDENT
        DEDENT
        toon.speed = [x * friction for x in toon.speed]
        toon.update()
        self.draw()
        pygame.time.delay(10)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15469445_15469502_7_22
15469445_15469558_11_25
Title: This code isn't displaying the correct answer 
----------------------------------------

def part1(dict_filename) :
INDENT
    vowels = 'aeiouy'
    vowelcount = 0
    dictionary = open(dict_filename, 'r')
    for words in dictionary :
    INDENT
        words = words.lower()
        vowelcount = 0
        if len(words) == 8 :
        INDENT
            if 's' not in words :
            INDENT
                for letters in words :
                INDENT
                    if letters in vowels :
                    INDENT
                        vowelcount += 1
                    DEDENT
                DEDENT
                if vowelcount == 1 :
                INDENT
                    print (words)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return words
DEDENT
----------------------------------------

def part1(dictionary) :
INDENT
    words = dictionary.readlines() [0].split(' ')
    words = [word.lower() for word in words]
    vowels = list('aeiou')
    vowel_count = 0
    for word in words :
    INDENT
        if len(word) == 8 and 's' not in word :
        INDENT
            for letter in words :
            INDENT
                if letter in vowels :
                INDENT
                    vowel_count += 1
                DEDENT
            DEDENT
        DEDENT
        if vowel_count == 1 :
        INDENT
            return word

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1547526_1547559_2_15
1547526_1548883_10_27
Title: "Improvizing a drop-in replacement for the ""with"" statement for Python 2.4" 
----------------------------------------

def decorator(f) :
INDENT
    target = man.__enter__()
    exc = True
    try :
    INDENT
        try :
        INDENT
            f(target)
        DEDENT
        except :
        INDENT
            exc = False
            if not man.__exit__(* sys.exc_info()) :
            INDENT
                raise
            DEDENT
        DEDENT
    DEDENT
    finally :
    INDENT
        if exc :
        INDENT
            man.__exit__(None, None, None)
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def decorator(f) :
INDENT
    exit_ = context_manager.__exit__
    enter_ = context_manager.__enter__()
    exc = True
    try :
    INDENT
        try :
        INDENT
            if as_ :
            INDENT
                f(* {as_ : enter_})
            DEDENT
            else :
            INDENT
                f()
            DEDENT
        DEDENT
        except :
        INDENT
            exc = False
            if not exit_(* sys.exc_info()) :
            INDENT
                raise
            DEDENT
        DEDENT
    DEDENT
    finally :
    INDENT
        if exc :
        exit_(None, None, None)
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15488293_15491481_7_21
15488293_15516132_125_134
Title: Render anti-aliased text on transparent surface in pygame 
----------------------------------------

def __init__(self, font = None, size = 300) :
INDENT
    self.font_name = font
    self.font_size = size
    self.color_fg = Color("white")
    self.color_bg = Color("gray20")
    self.aa = True
    self.text = "hi world"
    self.dirty = True
    self.font = pygame.font.Font(font, size)
    self.screen = pygame.display.get_surface()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    self.screen = pygame.display.set_mode((640, 480))
    self.text = Surface([200, 100])
    self.text_wall = TextWall()
    self.toggle_bg = True
    self.text_wall.parse_text(lorem)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15488293_15491481_7_21
15488293_15516132_69_79
Title: Render anti-aliased text on transparent surface in pygame 
----------------------------------------

def __init__(self, font = None, size = 300) :
INDENT
    self.font_name = font
    self.font_size = size
    self.color_fg = Color("white")
    self.color_bg = Color("gray20")
    self.aa = True
    self.text = "hi world"
    self.dirty = True
    self.font = pygame.font.Font(font, size)
    self.screen = pygame.display.get_surface()

DEDENT
----------------------------------------

def __init__(self, font = None, size = 16) :
INDENT
    self.font = font
    self.font_size = size
    self.offset = Rect(20, 20, 1, 1)
    self.screen = pygame.display.get_surface()
    self.dirty = True
    self.text_lines = []
    self._text_paragraph = "Empty\nText"
    self._render()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15488293_15516132_125_134
15488293_15516132_23_37
Title: Render anti-aliased text on transparent surface in pygame 
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    self.screen = pygame.display.set_mode((640, 480))
    self.text = Surface([200, 100])
    self.text_wall = TextWall()
    self.toggle_bg = True
    self.text_wall.parse_text(lorem)
DEDENT
----------------------------------------

def __init__(self, font = None, size = 16, text = "hi world") :
INDENT
    self.font_name = font
    self.font_size = size
    self.color_fg = Color("white")
    self.color_bg = Color("gray20")
    self._aa = True
    self._text = text
    self.font = pygame.font.Font(font, size)
    self.screen = pygame.display.get_surface()
    self.dirty = True
    self.image = None
    self._render()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15488293_15516132_125_134
15488293_15516132_69_79
Title: Render anti-aliased text on transparent surface in pygame 
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    self.screen = pygame.display.set_mode((640, 480))
    self.text = Surface([200, 100])
    self.text_wall = TextWall()
    self.toggle_bg = True
    self.text_wall.parse_text(lorem)
DEDENT
----------------------------------------

def __init__(self, font = None, size = 16) :
INDENT
    self.font = font
    self.font_size = size
    self.offset = Rect(20, 20, 1, 1)
    self.screen = pygame.display.get_surface()
    self.dirty = True
    self.text_lines = []
    self._text_paragraph = "Empty\nText"
    self._render()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15488293_15516132_23_37
15488293_15516132_69_79
Title: Render anti-aliased text on transparent surface in pygame 
----------------------------------------

def __init__(self, font = None, size = 16, text = "hi world") :
INDENT
    self.font_name = font
    self.font_size = size
    self.color_fg = Color("white")
    self.color_bg = Color("gray20")
    self._aa = True
    self._text = text
    self.font = pygame.font.Font(font, size)
    self.screen = pygame.display.get_surface()
    self.dirty = True
    self.image = None
    self._render()
DEDENT
----------------------------------------

def __init__(self, font = None, size = 16) :
INDENT
    self.font = font
    self.font_size = size
    self.offset = Rect(20, 20, 1, 1)
    self.screen = pygame.display.get_surface()
    self.dirty = True
    self.text_lines = []
    self._text_paragraph = "Empty\nText"
    self._render()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15492392_15493124_3_10
15492392_15493434_3_14
Title: Can Decorator + Reflection selectively create object trees representing individual function-call chain? 
----------------------------------------

def Track(func) :
INDENT
    def _tracked(* args, ** kwargs) :
    INDENT
        res = func(* args, ** kwargs)
        c = Call(func.__name__, args, kwargs, res)
        global_list_of_calls.append(c)
        return res
    DEDENT
    return _tracked
DEDENT
----------------------------------------

def Track(func) :
INDENT
    def wrapper(* args, ** kwargs) :
    INDENT
        global shift
        stack.append([])
        el = stack [- 1]
        el.append('%s -- call(name=%s,args=%s,kwargs=%s)' % ('    ' * shift, func.__name__, args, kwargs))
        shift += 1
        res = func(* args, ** kwargs)
        shift -= 1
        el [0] += 'return=%s)' % res
        return res
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1549412_1549430_1_16
1549412_1549467_3_16
Title: Grouping data points into series 
----------------------------------------

def split_series(points, interval) :
INDENT
    series = []
    current_group = []
    marker = points [0] [0]
    for value, data in points :
    INDENT
        if value > = marker + interval :
        INDENT
            series.append(current_group)
            current_group = []
            marker += interval
        DEDENT
        current_group.append(data)
    DEDENT
    if current_group :
    INDENT
        series.append(current_group)
    DEDENT
    return series
DEDENT
----------------------------------------

def split_series(points, interval) :
INDENT
    def interval_key(t) :
    INDENT
        return (t [0] - points [0] [0]) / / interval
    DEDENT
    groups = groupby(points, interval_key)
    for group in groups :
    INDENT
        yield [v for _, v in group [1]]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1549412_1549430_1_16
1549412_1561542_1_11
Title: Grouping data points into series 
----------------------------------------

def split_series(points, interval) :
INDENT
    series = []
    current_group = []
    marker = points [0] [0]
    for value, data in points :
    INDENT
        if value > = marker + interval :
        INDENT
            series.append(current_group)
            current_group = []
            marker += interval
        DEDENT
        current_group.append(data)
    DEDENT
    if current_group :
    INDENT
        series.append(current_group)
    DEDENT
    return series
DEDENT
----------------------------------------

def split_series(points, interval) :
INDENT
    end_of_chunk = interval
    chunk = []
    for marker, item in points :
    INDENT
        if marker > end_of_chunk :
        INDENT
            for end_of_chunk in xrange(end_of_chunk, marker, interval) :
            INDENT
                yield chunk
                chunk = []
            DEDENT
            end_of_chunk += interval
        DEDENT
        chunk.append(item)
    DEDENT
    yield chunk
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1549412_1549467_3_16
1549412_1561542_1_11
Title: Grouping data points into series 
----------------------------------------

def split_series(points, interval) :
INDENT
    def interval_key(t) :
    INDENT
        return (t [0] - points [0] [0]) / / interval
    DEDENT
    groups = groupby(points, interval_key)
    for group in groups :
    INDENT
        yield [v for _, v in group [1]]
    DEDENT
DEDENT
----------------------------------------

def split_series(points, interval) :
INDENT
    end_of_chunk = interval
    chunk = []
    for marker, item in points :
    INDENT
        if marker > end_of_chunk :
        INDENT
            for end_of_chunk in xrange(end_of_chunk, marker, interval) :
            INDENT
                yield chunk
                chunk = []
            DEDENT
            end_of_chunk += interval
        DEDENT
        chunk.append(item)
    DEDENT
    yield chunk
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15509639_15509897_2_11
15509639_15509932_1_13
Title: What is a typical way to add a reverse feature to an insertion sort? 
----------------------------------------

def insertionSort(L, reverse = False) :
INDENT
    lt = operator.gt if reverse else operator.lt
    for j in xrange(1, len(L)) :
    INDENT
        valToInsert = L [j]
        i = j - 1
        while 0 < = i and lt(valToInsert, L [i]) :
        INDENT
            L [i + 1] = L [i]
            i -= 1
        DEDENT
        L [i + 1] = valToInsert
    DEDENT
    return L
DEDENT
----------------------------------------

def insertionSort(L, reverse = False) :
INDENT
    if reverse :
    INDENT
        cmpfunc = lambda a, b : cmp(b, a)
    DEDENT
    else :
    INDENT
        cmpfunc = cmp
    DEDENT
    for j in xrange(1, len(L)) :
    INDENT
        valToInsert = L [j]
        i = j - 1
        while i > = 0 and cmpfunc(L [i], valToInsert) > 0 :
        INDENT
            L [i + 1] = L [i]
            i -= 1
        DEDENT
        L [i + 1] = valToInsert
    DEDENT
    return L
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15525838_15526720_1_18
15525838_15527043_1_23
Title: How do I recursively try different SSH passwords in Python? 
----------------------------------------

def ssh_connection(user, host, passwords) :
INDENT
    err = None
    for password in passwords :
    INDENT
        try :
        INDENT
            shell = spur.SshShell(
                hostname = host,
                port = findport(host),
                username = user,
                password = password,
                private_key_file = expanduser("~") + "/.ssh/id_rsa",
                missing_host_key = spur.ssh.MissingHostKey.accept)
            shell.run(["true"])
            return shell
        DEDENT
        except spur.ssh.ConnectionError as error :
        INDENT
            err = error
        DEDENT
    DEDENT
    if err :
    INDENT
        raise error
    DEDENT
DEDENT
----------------------------------------

def ssh_connection(user, host, password) :
INDENT
    try :
    INDENT
        shell = spur.SshShell(
            hostname = host,
            port = findport(host),
            username = user,
            password = password,
            private_key_file = expanduser("~") + "/.ssh/id_rsa",
            missing_host_key = spur.ssh.MissingHostKey.accept)
        shell.run(["true"])
        return shell
    DEDENT
    except spur.ssh.ConnectionError as error :
    INDENT
        print error
        return
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15525838_15527043_1_23
15525838_15527567_9_26
Title: How do I recursively try different SSH passwords in Python? 
----------------------------------------

def ssh_connection(user, host, password) :
INDENT
    try :
    INDENT
        shell = spur.SshShell(
            hostname = host,
            port = findport(host),
            username = user,
            password = password,
            private_key_file = expanduser("~") + "/.ssh/id_rsa",
            missing_host_key = spur.ssh.MissingHostKey.accept)
        shell.run(["true"])
        return shell
    DEDENT
    except spur.ssh.ConnectionError as error :
    INDENT
        print error
        return
    DEDENT
DEDENT
----------------------------------------

def ssh_connection(user, host, passw) :
INDENT
    err = None
    for password in passw :
    INDENT
        try :
        INDENT
            shell = spur.SshShell(
                hostname = host,
                port = findport(host),
                username = user,
                password = password,
                private_key_file = expanduser("~") + "/.ssh/id_rsa",
                missing_host_key = spur.ssh.MissingHostKey.accept)
            shell.run(["true"])
            return shell
        DEDENT
        except spur.ssh.ConnectionError as error :
        INDENT
            err = error
        DEDENT
    DEDENT
    if err :
    INDENT
        raise error
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15536902_15537013_1_28
15536902_15537069_1_16
Title: Python: Simplify many if-statements 
----------------------------------------

def treeToList(root, order = Order.INORDER) :
INDENT
    ret = list()
    def inorder_traversal(node) :
    INDENT
        if node is not None :
        INDENT
            inorder_traversal(node.right)
            ret.append(node.data)
            inorder_traversal(node.down)
        DEDENT
    DEDENT
    def preorder_traversal(node) :
    INDENT
        if node is not None :
        INDENT
            ret.append(node.data)
            preorder_traversal(node.right)
            preorder_traversal(node.down)
        DEDENT
    DEDENT
    def postorder_traversal(node) :
    INDENT
        if node is not None :
        INDENT
            postorder_traversal(node.right)
            postorder_traversal(node.down)
            ret.append(node.data)
        DEDENT
    DEDENT
    if order == Order.PREORDER :
    INDENT
        preorder_traversal(node)
    DEDENT
    elif order == Order.INORDER :
    INDENT
        inorder_traversal(node)
    DEDENT
    else :
    INDENT
        postorder_traversal(node)
    DEDENT
    return ret
DEDENT
----------------------------------------

def treeToList(node, order = Order.INORDER) :
INDENT
    if node is None :
    INDENT
        return []
    DEDENT
    right = treeToList(node.right, order)
    down = treeToList(node.down, order)
    current = [node.data]
    if order == Order.PREORDER :
    INDENT
        return current + right + down
    DEDENT
    if order == Order.INORDER :
    INDENT
        return right + current + down
    DEDENT
    if order == Order.POSTORDER :
    INDENT
        return right + down + current
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15564844_15580406_15_25
15564844_32088756_16_25
Title: Locally run all of the spiders in Scrapy 
----------------------------------------

def run(self, args, opts) :
INDENT
    settings = get_project_settings()
    for spider_name in self.crawler.spiders.list() :
    INDENT
        crawler = Crawler(settings)
        crawler.configure()
        spider = crawler.spiders.create(spider_name)
        crawler.crawl(spider)
        crawler.start()
    DEDENT
    self.crawler.start()
DEDENT
----------------------------------------

def run(self, args, opts) :
INDENT
    settings = get_project_settings()
    crawler_process = CrawlerProcess(settings)
    for spider_name in crawler_process.spider_loader.list() :
    INDENT
        if spider_name in self.excludes :
        INDENT
            continue
        DEDENT
        spider_cls = crawler_process.spider_loader.load(spider_name)
        crawler_process.crawl(spider_cls)
    DEDENT
    crawler_process.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15576798_15650213_1_20
15576798_22414465_4_34
Title: Create 32bit float wav file in python? 
----------------------------------------

def float32_wav_file(sample_array, sample_rate) :
INDENT
    byte_count = (len(sample_array)) * 4
    wav_file = ""
    wav_file += struct.pack('<ccccIccccccccIHHIIHH',
        'R', 'I', 'F', 'F',
        byte_count + 0x2c - 8,
        'W', 'A', 'V', 'E', 'f', 'm', 't', ' ',
        0x10,
        3,
        1,
        sample_rate,
        sample_rate * 4,
        4,
        32)
    wav_file += struct.pack('<ccccI',
        'd', 'a', 't', 'a', byte_count)
    for sample in sample_array :
    INDENT
        wav_file += struct.pack("<f", sample)
    DEDENT
    return wav_file
DEDENT
----------------------------------------

def float32_wav_file(file_name, sample_array, sample_rate) :
INDENT
    (M, N) = sample_array.shape
    byte_count = M * N * 4
    wav_file = ""
    wav_file += struct.pack('<ccccIccccccccIHHIIHH',
        'R', 'I', 'F', 'F',
        byte_count + 0x2c - 8,
        'W', 'A', 'V', 'E', 'f', 'm', 't', ' ',
        0x10,
        3,
        M,
        sample_rate,
        sample_rate * 4,
        4,
        32)
    wav_file += struct.pack('<ccccI',
        'd', 'a', 't', 'a', byte_count)
    print "packing..."
    for j in range(0, N) :
    INDENT
        for k in range(0, M) :
        INDENT
            wav_file += struct.pack("<f", sample_array [k, j])
        DEDENT
    DEDENT
    print "saving..."
    fi = open(file_name, 'wb')
    for value in wav_file :
    INDENT
        fi.write(value)
    DEDENT
    fi.close()
    return wav_file
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15583625_15583820_22_29
15583625_15583825_1_12
Title: Need Assistance with my Encryption Program 
----------------------------------------

def MethodMenu() :
INDENT
    print 'Which method would you like to use?'
    print '<c>aesarian fixed offset'
    print '<p>seudo-random offset'
    print '<s>ubstitution cipher'
    user_choice = GetChoice('cps')
    return user_choice
DEDENT
----------------------------------------

def MethodMenu() :
INDENT
    print 'Which method would you like to use?'
    print '<c>aesarian fixed offset'
    print '<p>seudo-random offset'
    print '<s>ubstitution cipher'
    a = None
    while a not in ('c', 'p', 's') :
    INDENT
        if a :
        INDENT
            print "Error: You must type c, p, or s"
        DEDENT
        a = raw_input("")
        if a == 'c' or a == 'p' or a == 's' :
        INDENT
            print 'Coming Soon'
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15606143_15622787_12_25
15606143_15622787_50_71
Title: Move(dragg) a QLabel inside a QFrame 
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MyLabel, self).__init__(parent)
    self.setStyleSheet("""
            background-color: black;
            color: white;
            font: bold;
            padding: 6px;
            border-width: 2px;
            border-style: solid;
            border-radius: 16px;
            border-color: white;
        """)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyFrame, self).__init__(parent)
    self.setStyleSheet("""
            background-color: lightgray;
            border-width: 2px;
            border-style: solid;
            border-color: black;
            margin: 2px;
        """)
    y = 6
    for labelNumber in range(6) :
    INDENT
        label = MyLabel(self)
        label.setText("Label #{0}".format(labelNumber))
        label.move(6, y)
        label.show()
        y += label.height() + 2
    DEDENT
    self.setAcceptDrops(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15615782_15616517_5_16
15615782_15616557_4_11
Title: how to set label of dynamically created StaticText in wxpython? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent = parent)
    self.panel = wx.Panel(self)
    self.label = {}
    for i in range(5) :
    INDENT
        button = wx.Button(
            self.panel, - 1, label = 'b' + str(i), pos = (20, 30 * i))
        button.Bind(wx.EVT_BUTTON, self.on_button)
        label = wx.StaticText(self.panel, - 1, label = 'label' + str(
                i), pos = (120, 30 * i), name = 'label' + str(i))
        self.label [button] = label
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent = parent)
    self.panel = wx.Panel(self)
    for i in range(5) :
    INDENT
        self.button = wx.Button(self.panel, - 1, label = 'b' + str(i), pos = (20, 30 * i))
        self.button.Bind(wx.EVT_BUTTON, self.on_button)
        self.label = wx.StaticText(self.panel, - 1, label = 'label' + str(i), pos = (120, 30 * i), name = 'label' + str(i))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15617869_22358392_1_14
15617869_42642793_1_17
Title: "CondingBat Python puzzle results in ""Timed out""" 
----------------------------------------

def make_chocolate(small, big, goal) :
INDENT
    bigbars = goal / / 5
    if bigbars < = big :
    INDENT
        smallgoal = goal - (bigbars * 5)
        if smallgoal > = 0 and smallgoal < = small :
        INDENT
            return smallgoal
        DEDENT
        if smallgoal > small :
        INDENT
            return - 1
        DEDENT
    DEDENT
    if bigbars > big :
    INDENT
        smallgoal = goal - (big * 5)
        if smallgoal < = small :
        INDENT
            return smallgoal
        DEDENT
        if smallgoal > small :
        INDENT
            return - 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def make_chocolate(small, big, goal) :
INDENT
    s = small * 1
    b = big * 5
    mod = goal % 5
    if b < goal :
    INDENT
        if s + b == goal :
        INDENT
            return s
        DEDENT
        elif s + b > goal :
        INDENT
            return goal - b
        DEDENT
        elif s + b < goal :
        INDENT
            return - 1
        DEDENT
    DEDENT
    elif b > goal :
    INDENT
        if s < mod :
        INDENT
            return - 1
        DEDENT
        return mod
    DEDENT
    elif b == goal :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15629098_15629190_1_35
15629098_15629193_1_35
Title: TypeError: cannot concatenate 'str' and 'float' objects 
----------------------------------------

def main() :
INDENT
    temperature = raw_input("Please enter an integer followed by a single space then either a F for Fahrenheit, C for Celsius, K for Kelvin, or R for Rankine: ")
    temp, unit = float(temperature.split(' ') [0]), temperature [- 1]
    if unit == "F" :
    INDENT
        K = (temp + (459.67) * (5.0 / 9.0))
        print K
        C = (temp - 32) * (5.0 / 9.0)
        print C
        R = (temperature [: - 1] + 459.67)
        print R
    DEDENT
    elif unit == "C" :
    INDENT
        K = (temp + 273.15)
        print K
        F = (temp * (9.0 / 5.0) + 32)
        print F
        R = (temp + 273.15) * (9.0 / 5.0)
        print R
    DEDENT
    elif unit == "K" :
    INDENT
        C = (temp - 273.15)
        print C
        F = (temp * (9.0 / 5.0) - 459.67)
        print F
        R = (temp * (9.0 / 5.0))
        print R
    DEDENT
    elif temperature [- 1] == "R" :
    INDENT
        F = (temp - 459.67)
        print F
        C = (temp - 491.67) * (5.0 / 9.0)
        print C
        K = (temp * (5.0 / 9.0))
        print K
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    temperature = raw_input("Please enter an integer followed by a single space then either a F for Fahrenheit, C for Celsius, K for Kelvin, or R for Rankine: ")
    temperature = float(temperature.split(' ') [0]), temperature.split(' ') [1]
    if temperature [- 1] == "F" :
    INDENT
        K = (temperature [0] + (459.67) * (5.0 / 9.0))
        print K
        C = (temperature [0] - 32) * (5.0 / 9.0)
        print C
        R = (temperature [0] + 459.67)
        print R
    DEDENT
    elif temperature [- 1] == "C" :
    INDENT
        K = (temperature [0] + 273.15)
        print K
        F = (temperature [0] * (9.0 / 5.0) + 32)
        print F
        R = (temperature [0] + 273.15) * (9.0 / 5.0)
        print R
    DEDENT
    elif temperature [- 1] == "K" :
    INDENT
        C = (temperature [0] - 273.15)
        print C
        F = (temperature [0] * (9.0 / 5.0) - 459.67)
        print F
        R = (temperature [0] * (9.0 / 5.0))
        print R
    DEDENT
    elif temperature [- 1] == "R" :
    INDENT
        F = (temperature [0] - 459.67)
        print F
        C = (temperature [0] - 491.67) * (5.0 / 9.0)
        print C
        K = (temperature [0] * (5.0 / 9.0))
        print K
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15663695_15665502_3_14
15663695_30174874_2_25
Title: shutil.copytree without files 
----------------------------------------

def create_empty_dirtree(srcdir, dstdir, onerror = None) :
INDENT
    srcdir = os.path.abspath(srcdir)
    srcdir_prefix = len(srcdir) + len(os.path.sep)
    os.makedirs(dstdir)
    for root, dirs, files in os.walk(srcdir, onerror = onerror) :
    INDENT
        for dirname in dirs :
        INDENT
            dirpath = os.path.join(dstdir, root [srcdir_prefix :], dirname)
            try :
            INDENT
                os.mkdir(dirpath)
            DEDENT
            except OSError as e :
            INDENT
                if onerror is not None :
                INDENT
                    onerror(e)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def create_empty_dirtree(src, dest, onerror = None) :
INDENT
    src = os.path.abspath(src)
    src_prefix = len(src) + len(os.path.sep)
    for root, dirs, files in os.walk(src, onerror = onerror) :
    INDENT
        for pattern in ignorePatterns :
        INDENT
            if pattern in root :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            for dirname in dirs :
            INDENT
                for pattern in ignorePatterns :
                INDENT
                    if pattern in dirname :
                    INDENT
                        break
                    DEDENT
                DEDENT
                else :
                INDENT

                    dirpath = os.path.join(dest, root [src_prefix :], dirname)
                    try :
                    INDENT
                        os.makedirs(dirpath, exist_ok = True)
                    DEDENT
                    except OSError as e :
                    INDENT
                        if onerror is not None :
                        INDENT
                            onerror(e)
                        DEDENT
                    DEDENT
                DEDENT
                continue;
            DEDENT
        DEDENT
        continue;
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15672770_15731116_29_63
15672770_15731116_7_26
Title: update multiple views on multiple dialogs connected to a single data model 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__(parent)
    self.modelSource = QtGui.QStandardItemModel(self)
    for rowNumber in range(3) :
    INDENT
        items = []
        for columnNumber in range(3) :
        INDENT
            item = QtGui.QStandardItem()
            item.setText("row: {0} column {1}".format(rowNumber, columnNumber))
            items.append(item)
        DEDENT
        self.modelSource.appendRow(items)
    DEDENT
    self.labelDialogs = QtGui.QLabel(self)
    self.labelDialogs.setText("Select a number of dialogs to create:")
    self.spinBoxDialogs = QtGui.QSpinBox(self)
    self.spinBoxDialogs.setValue(3)
    self.pushButtonShow = QtGui.QPushButton(self)
    self.pushButtonShow.setText("Show Dialogs!")
    self.pushButtonShow.clicked.connect(self.on_pushButtonShow_clicked)
    self.pushButtonClose = QtGui.QPushButton(self)
    self.pushButtonClose.setText("Close Dialogs")
    self.pushButtonClose.clicked.connect(self.on_pushButtonClose_clicked)
    self.layoutHorizontal = QtGui.QHBoxLayout(self)
    self.layoutHorizontal.addWidget(self.labelDialogs)
    self.layoutHorizontal.addWidget(self.spinBoxDialogs)
    self.layoutHorizontal.addWidget(self.pushButtonShow)
    self.layoutHorizontal.addWidget(self.pushButtonClose)
DEDENT
----------------------------------------

def __init__(self, modelSource, parent = None) :
INDENT
    super(MyDialog, self).__init__(parent)
    self.tableView = QtGui.QTableView(self)
    self.tableView.horizontalHeader().setStretchLastSection(True)
    self.tableView.setModel(modelSource)
    self.listView = QtGui.QListView(self)
    self.listView.setModel(modelSource)
    self.listView.setModelColumn(0)
    self.comboBox = QtGui.QComboBox(self)
    self.comboBox.setModel(modelSource)
    self.comboBox.setModelColumn(1)
    self.layoutGrid = QtGui.QGridLayout(self)
    self.layoutGrid.addWidget(self.comboBox, 0, 0, 1, 2)
    self.layoutGrid.addWidget(self.listView, 1, 0, 1, 1)
    self.layoutGrid.addWidget(self.tableView, 1, 1, 1, 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15672770_15731116_29_63
15672770_15752288_12_22
Title: update multiple views on multiple dialogs connected to a single data model 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__(parent)
    self.modelSource = QtGui.QStandardItemModel(self)
    for rowNumber in range(3) :
    INDENT
        items = []
        for columnNumber in range(3) :
        INDENT
            item = QtGui.QStandardItem()
            item.setText("row: {0} column {1}".format(rowNumber, columnNumber))
            items.append(item)
        DEDENT
        self.modelSource.appendRow(items)
    DEDENT
    self.labelDialogs = QtGui.QLabel(self)
    self.labelDialogs.setText("Select a number of dialogs to create:")
    self.spinBoxDialogs = QtGui.QSpinBox(self)
    self.spinBoxDialogs.setValue(3)
    self.pushButtonShow = QtGui.QPushButton(self)
    self.pushButtonShow.setText("Show Dialogs!")
    self.pushButtonShow.clicked.connect(self.on_pushButtonShow_clicked)
    self.pushButtonClose = QtGui.QPushButton(self)
    self.pushButtonClose.setText("Close Dialogs")
    self.pushButtonClose.clicked.connect(self.on_pushButtonClose_clicked)
    self.layoutHorizontal = QtGui.QHBoxLayout(self)
    self.layoutHorizontal.addWidget(self.labelDialogs)
    self.layoutHorizontal.addWidget(self.spinBoxDialogs)
    self.layoutHorizontal.addWidget(self.pushButtonShow)
    self.layoutHorizontal.addWidget(self.pushButtonClose)
DEDENT
----------------------------------------

def __init__(self, model, parent = None) :
INDENT
    super(Form_2, self).__init__(parent)
    self.model = model
    self.combo = QListView()
    self.combo.setModel(self.model)
    layout = QVBoxLayout()
    layout.addWidget(self.combo)
    self.setLayout(layout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15672770_15731116_29_63
15672770_15752288_25_41
Title: update multiple views on multiple dialogs connected to a single data model 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__(parent)
    self.modelSource = QtGui.QStandardItemModel(self)
    for rowNumber in range(3) :
    INDENT
        items = []
        for columnNumber in range(3) :
        INDENT
            item = QtGui.QStandardItem()
            item.setText("row: {0} column {1}".format(rowNumber, columnNumber))
            items.append(item)
        DEDENT
        self.modelSource.appendRow(items)
    DEDENT
    self.labelDialogs = QtGui.QLabel(self)
    self.labelDialogs.setText("Select a number of dialogs to create:")
    self.spinBoxDialogs = QtGui.QSpinBox(self)
    self.spinBoxDialogs.setValue(3)
    self.pushButtonShow = QtGui.QPushButton(self)
    self.pushButtonShow.setText("Show Dialogs!")
    self.pushButtonShow.clicked.connect(self.on_pushButtonShow_clicked)
    self.pushButtonClose = QtGui.QPushButton(self)
    self.pushButtonClose.setText("Close Dialogs")
    self.pushButtonClose.clicked.connect(self.on_pushButtonClose_clicked)
    self.layoutHorizontal = QtGui.QHBoxLayout(self)
    self.layoutHorizontal.addWidget(self.labelDialogs)
    self.layoutHorizontal.addWidget(self.spinBoxDialogs)
    self.layoutHorizontal.addWidget(self.pushButtonShow)
    self.layoutHorizontal.addWidget(self.pushButtonClose)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Form_1, self).__init__(parent)
    self.model = Model()
    self.listView = QListView()
    self.listView.setModel(self.model)
    self.combo = QComboBox()
    self.combo.setModel(self.model)
    self.form2_button = QPushButton("Open Form_2")
    layout = QVBoxLayout()
    layout.addWidget(self.listView)
    layout.addWidget(self.combo)
    layout.addWidget(self.form2_button)
    self.setLayout(layout)
    self.connect(self.form2_button, SIGNAL("clicked()"), self.form_2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15672770_15731116_7_26
15672770_15752288_12_22
Title: update multiple views on multiple dialogs connected to a single data model 
----------------------------------------

def __init__(self, modelSource, parent = None) :
INDENT
    super(MyDialog, self).__init__(parent)
    self.tableView = QtGui.QTableView(self)
    self.tableView.horizontalHeader().setStretchLastSection(True)
    self.tableView.setModel(modelSource)
    self.listView = QtGui.QListView(self)
    self.listView.setModel(modelSource)
    self.listView.setModelColumn(0)
    self.comboBox = QtGui.QComboBox(self)
    self.comboBox.setModel(modelSource)
    self.comboBox.setModelColumn(1)
    self.layoutGrid = QtGui.QGridLayout(self)
    self.layoutGrid.addWidget(self.comboBox, 0, 0, 1, 2)
    self.layoutGrid.addWidget(self.listView, 1, 0, 1, 1)
    self.layoutGrid.addWidget(self.tableView, 1, 1, 1, 1)
DEDENT
----------------------------------------

def __init__(self, model, parent = None) :
INDENT
    super(Form_2, self).__init__(parent)
    self.model = model
    self.combo = QListView()
    self.combo.setModel(self.model)
    layout = QVBoxLayout()
    layout.addWidget(self.combo)
    self.setLayout(layout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15672770_15731116_7_26
15672770_15752288_25_41
Title: update multiple views on multiple dialogs connected to a single data model 
----------------------------------------

def __init__(self, modelSource, parent = None) :
INDENT
    super(MyDialog, self).__init__(parent)
    self.tableView = QtGui.QTableView(self)
    self.tableView.horizontalHeader().setStretchLastSection(True)
    self.tableView.setModel(modelSource)
    self.listView = QtGui.QListView(self)
    self.listView.setModel(modelSource)
    self.listView.setModelColumn(0)
    self.comboBox = QtGui.QComboBox(self)
    self.comboBox.setModel(modelSource)
    self.comboBox.setModelColumn(1)
    self.layoutGrid = QtGui.QGridLayout(self)
    self.layoutGrid.addWidget(self.comboBox, 0, 0, 1, 2)
    self.layoutGrid.addWidget(self.listView, 1, 0, 1, 1)
    self.layoutGrid.addWidget(self.tableView, 1, 1, 1, 1)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Form_1, self).__init__(parent)
    self.model = Model()
    self.listView = QListView()
    self.listView.setModel(self.model)
    self.combo = QComboBox()
    self.combo.setModel(self.model)
    self.form2_button = QPushButton("Open Form_2")
    layout = QVBoxLayout()
    layout.addWidget(self.listView)
    layout.addWidget(self.combo)
    layout.addWidget(self.form2_button)
    self.setLayout(layout)
    self.connect(self.form2_button, SIGNAL("clicked()"), self.form_2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15672770_15752288_12_22
15672770_15752288_25_41
Title: update multiple views on multiple dialogs connected to a single data model 
----------------------------------------

def __init__(self, model, parent = None) :
INDENT
    super(Form_2, self).__init__(parent)
    self.model = model
    self.combo = QListView()
    self.combo.setModel(self.model)
    layout = QVBoxLayout()
    layout.addWidget(self.combo)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Form_1, self).__init__(parent)
    self.model = Model()
    self.listView = QListView()
    self.listView.setModel(self.model)
    self.combo = QComboBox()
    self.combo.setModel(self.model)
    self.form2_button = QPushButton("Open Form_2")
    layout = QVBoxLayout()
    layout.addWidget(self.listView)
    layout.addWidget(self.combo)
    layout.addWidget(self.form2_button)
    self.setLayout(layout)
    self.connect(self.form2_button, SIGNAL("clicked()"), self.form_2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15697431_15697475_1_6
15697431_15697477_7_12
Title: Loop function in python 
----------------------------------------

def loop(x, y, * args) :
INDENT
    a = 0
    while (a < x + 1) :
    INDENT
        a = a + 1
        y(* args)
    DEDENT
DEDENT
----------------------------------------

def loop(x, y) :
INDENT
    a = 0
    while (a < x + 1) :
    INDENT
        a = a + 1
        y()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15711019_15711176_1_21
15711019_15716449_15_24
Title: How to detect if a 2D array is inside another 2D array? 
----------------------------------------

def find_needle(needle, haystack, tolerance =.80) :
INDENT
    needle = np.asarray(needle.convert('L'))
    haystack = np.asarray(haystack.convert('L'))
    h, w = needle.shape
    H, W = haystack.shape
    L = haystack.max()
    best = (None, None, 1)
    rows, cols = np.where((haystack - needle [0, 0]) / L < tolerance)
    for row, col in zip(rows, cols) :
    INDENT
        if row + h > H or col + w > W : continue
        diff = np.mean(haystack [row : row + h, col : col + w] - needle) / L
        if diff < best [- 1] :
        INDENT
            best = (diff, row, col)
        DEDENT
    DEDENT
    return best if best [- 1] < tolerance else None
DEDENT
----------------------------------------

def find_needle(haystack, needle, n = 10) :
INDENT
    haystack = haystack.astype(np.float) - 128
    needle = needle.astype(np.float) - 128
    target = np.sum(np.sum(needle * needle, axis = 0), axis = 0)
    corr_hn = cross_corr(haystack, needle)
    delta = np.sum(np.abs(corr_hn - target), axis = - 1)
    return np.unravel_index(np.argsort(delta, axis = None) [: n],
        dims = haystack.shape [: 2])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15736530_15736974_6_14
15736530_37577230_6_14
Title: Python Tkinter rotate image animation 
----------------------------------------

def __init__(self, master, filename, ** kwargs) :
INDENT
    self.master = master
    self.filename = filename
    self.canvas = tk.Canvas(master, width = 500, height = 500)
    self.canvas.pack()
    self.update = self.draw().__next__
    master.after(100, self.update)
DEDENT
----------------------------------------

def __init__(self, master, filename, ** kwargs) :
INDENT
    self.master = master
    self.filename = filename
    self.canvas = tkinter.Canvas(master, width = 500, height = 500)
    self.canvas.pack()
    self.process_next_frame = self.draw().__next__
    master.after(1, self.process_next_frame)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15747287_15752371_12_22
15747287_15752371_25_41
Title: "single model connected to multiple views on multiple dialogs not updating" 
----------------------------------------

def __init__(self, model, parent = None) :
INDENT
    super(Form_2, self).__init__(parent)
    self.model = model
    self.combo = QListView()
    self.combo.setModel(self.model)
    layout = QVBoxLayout()
    layout.addWidget(self.combo)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Form_1, self).__init__(parent)
    self.model = Model()
    self.listView = QListView()
    self.listView.setModel(self.model)
    self.combo = QComboBox()
    self.combo.setModel(self.model)
    self.form2_button = QPushButton("Open Form_2")
    layout = QVBoxLayout()
    layout.addWidget(self.listView)
    layout.addWidget(self.combo)
    layout.addWidget(self.form2_button)
    self.setLayout(layout)
    self.connect(self.form2_button, SIGNAL("clicked()"), self.form_2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15750522_15751135_20_31
15750522_22584754_22_28
Title: Class properties and __setattr__ 
----------------------------------------

def __setattr__(self, a, v) :
INDENT
    propobj = getattr(self.__class__, a, None)
    if isinstance(propobj, property) :
    INDENT
        print "setting attr %s using property's fset" % a
        if propobj.fset is None :
        INDENT
            raise AttributeError("can't set attribute")
        DEDENT
        propobj.fset(self, v)
    DEDENT
    else :
    INDENT
        print "setting attr %s" % a
        super(Test, self).__setattr__(a, v)

    DEDENT
DEDENT
----------------------------------------

def __setattr__(self, key, value) :
INDENT
    try :
    INDENT
        return getattr(self, 'set_' + key)(value)
    DEDENT
    except AttributeError :
    INDENT
        return super(SmartSetter, self).__setattr__(key, value)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15788725_15788988_15_23
15788725_15789365_4_15
Title: How to determine the closest common ancestor class 
----------------------------------------

def clcoancl(cls1, cls2) :
INDENT
    ancl1 = ancl(cls1)
    ancl2 = ancl(cls2)
    while len(ancl1) > 0 and len(ancl2) > 0 and ancl1 [- 1] == ancl2 [- 1] :
    INDENT
        ret = ancl1.pop(- 1)
        ancl2.pop(- 1)
    DEDENT
    return ret
DEDENT
----------------------------------------

def clcoancl(* cls_list) :
INDENT
    mros = [list(inspect.getmro(cls)) for cls in cls_list]
    track = defaultdict(int)
    while mros :
    INDENT
        for mro in mros :
        INDENT
            cur = mro.pop(0)
            track [cur] += 1
            if track [cur] == len(cls_list) :
            INDENT
                return cur
            DEDENT
            if len(mro) == 0 :
            INDENT
                mros.remove(mro)
            DEDENT
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15789611_15789706_1_7
15789611_15790243_1_7
Title: Python: What is Wrong with these two Functions? 
----------------------------------------

def passwordLength(password) :
INDENT
    if (len(password) < 4) or (len(password) > 15) :
    INDENT
        print ("Error from server: Your password must be at least four and at most fifteen characters long.")
        return False
    DEDENT
    return True

DEDENT
----------------------------------------

def passwordLength(password) :
INDENT
    if (len(password) < 4) or (len(password) > 15) :
    INDENT
        print ("Error from server: Your password must be at least four and at most fifteen characters long.")
        return False
    DEDENT
    else : return True

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15789611_15789706_8_15
15789611_15789825_7_13
Title: Python: What is Wrong with these two Functions? 
----------------------------------------

def enterPasswords() :
INDENT
    password = input("Input password: ")
    while not passwordLength(password) :
    INDENT
        password = input("Input password: ")
    DEDENT
    print (password)
    password2 = input("Re-enter password: ")
    print (password, password2)
DEDENT
----------------------------------------

def enterPasswords() :
INDENT
    pw = getPw()
    while not passwordLength(pw) :
    INDENT
        print ("Incorrect password length.")
        pw = getPw()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15789611_15789825_7_13
15789611_15790243_8_16
Title: Python: What is Wrong with these two Functions? 
----------------------------------------

def enterPasswords() :
INDENT
    pw = getPw()
    while not passwordLength(pw) :
    INDENT
        print ("Incorrect password length.")
        pw = getPw()

    DEDENT
DEDENT
----------------------------------------

def enterPasswords() :
INDENT
    passwordOK = False
    while not passwordOK :
    INDENT
        password = input("Input password: ")
        passwordOK = passwordLength(password)
    DEDENT
    print (password)
    password2 = input("Re-enter password: ")
    print (password, password2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15800251_15800282_1_10
15800251_15800288_1_10
Title: recursive technique rather than lists technique in python 
----------------------------------------

def positive_negative(list_changes) :
INDENT
    if len(list_changes) == 0 :
    INDENT
        return 0.0, 0.0
    DEDENT
    else :
    INDENT
        pos, neg = positive_negative(list_changes [1 :])
        if list_changes [0] > 0.0 :
        INDENT
            pos += list_changes [0]
        DEDENT
        else :
        INDENT
            neg += list_changes [0]
        DEDENT
        return pos, neg
    DEDENT
DEDENT
----------------------------------------

def positive_negative(list_changes, psum = 0, nsum = 0) :
INDENT
    if len(list_changes) == 0 :
    INDENT
        return psum, nsum
    DEDENT
    if list_changes [0] < 0 :
    INDENT
        nsum += list_changes [0]
    DEDENT
    else :
    INDENT
        psum += list_changes [0]
    DEDENT
    return positive_negative(list_changes [1 :], psum, nsum)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15808009_15808163_1_10
15808009_15808757_1_23
Title: How to parse an inputted string to extract individual numbers 
----------------------------------------

def main() :
INDENT
    op = input("Enter an operation: ")
    i = op [1]
    n = int(op [0])
    y = int(op [2])
    if i == "+" :
    INDENT
        result = add(n, y)
    DEDENT
    print ("Result: ", result)
    print ("Bye")
DEDENT
----------------------------------------

def main() :
INDENT
    while True :
    INDENT

        not_ok = False
        inp = input("Enter an operation: ")
        inp = inp.replace('\t', ' ')
        for char in inp :
        INDENT
            if char not in '\n1234567890/\\+-*().' :
            INDENT
                print 'invalid input'
                not_ok = True
                break
            DEDENT
        DEDENT
        if not_ok :
        INDENT
            continue
        DEDENT
        try :
        INDENT
            print 'Result: {}'.format(eval(inp))
        DEDENT
        except Exception :
        INDENT
            print 'invalid input'
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1581799_1582896_3_14
1581799_26158702_5_15
Title: How to draw a bitmap real quick in python using Tk only? 
----------------------------------------

def __init__(self, t) :
INDENT
    self.i = Tkinter.PhotoImage(width = 100, height = 100)
    colors = [[random.randint(0, 255) for i in range(0, 3)] for j in range(0, 10000)]
    row = 0; col = 0
    for color in colors :
    INDENT
        self.i.put('#%02x%02x%02x' % tuple(color), (row, col))
        col += 1
        if col == 100 :
        INDENT
            row += 1; col = 0
        DEDENT
    DEDENT
    c = Tkinter.Canvas(t, width = 100, height = 100); c.pack()
    c.create_image(0, 0, image = self.i, anchor = Tkinter.NW)
DEDENT
----------------------------------------

def __init__(self, t) :
INDENT
    self.width = 320
    self.height = 200
    self.i = Tkinter.PhotoImage(width = self.width, height = self.height)
    rgb_colors = ([random.randint(0, 255) for i in range(0, 3)] for j in range(0, self.width * self.height))
    pixels = " ".join(("{" + " ".join(('#%02x%02x%02x' %
                    tuple(next(rgb_colors)) for i in range(self.width))) + "}" for j in range(self.height)))
    self.i.put(pixels, (0, 0, self.width - 1, self.height - 1))
    c = Tkinter.Canvas(t, width = self.width, height = self.height); c.pack()
    c.create_image(0, 0, image = self.i, anchor = Tkinter.NW)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15825165_16261045_210_231
15825165_16261045_71_80
Title: Antialiasing of Curves by Discrete Pre-filtering 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, wx.DefaultPosition, wx.Size(700, 700))
    self.Centre()
    self.Bind(wx.EVT_TOOL, self.OnExit, id = 4)
    bmp = wx.EmptyBitmap(700, 700)
    global pd
    global pixels
    pd = wx.NativePixelData(bmp, wx.Point(0, 0), wx.Size(700, 700))
    width, height = pd.GetWidth(), pd.GetHeight()
    pixels = pd.GetPixels()
    for x in xrange(width) :
    INDENT
        for y in xrange(height) :
        INDENT
            pixels.MoveTo(pd, x, y)
            pixels.Set(255, 255, 255)
        DEDENT
    DEDENT
    cProfile.run('timer()')
    wx.StaticBitmap(self, wx.ID_ANY, bmp)
DEDENT
----------------------------------------

def __init__(self, x1, y1, x2, y2, x3, y3, x4, y4) :
INDENT
    self.p1 = BezierPoint(x1, y1)
    self.p2 = BezierPoint(x2, y2)
    self.p3 = BezierPoint(x3, y3)
    self.p4 = BezierPoint(x4, y4)
    self._minx = min(x1, x2, x3, x4)
    self._maxx = max(x1, x2, x3, x4)
    self._miny = min(y1, y2, y3, y4)
    self._maxy = max(y1, y2, y3, y4)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15825201_15835050_15_43
15825201_15835050_5_13
Title: Trying to get a panel on wxPython to change a TextCtrl on another panel 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Notebook Remove Pages Example")
    pannel = wx.Panel(self)
    vbox = wx.BoxSizer(wx.VERTICAL)
    hbox = wx.BoxSizer(wx.HORIZONTAL)
    self.buttonRemove = wx.Button(pannel, id = - 1, label = "DELETE")
    self.buttonRemove.Bind(wx.EVT_BUTTON, self.onButtonRemove)
    hbox.Add(self.buttonRemove)
    self.buttonInsert = wx.Button(pannel, id = - 1, label = "CREATE")
    self.buttonInsert.Bind(wx.EVT_BUTTON, self.onButtonInsert)
    hbox.Add(self.buttonInsert)
    self.buttonMessage = wx.Button(pannel, id = - 1, label = "Message")
    self.buttonMessage.Bind(wx.EVT_BUTTON, self.onButtonMessage)
    hbox.Add(self.buttonMessage)
    vbox.Add(hbox, 0, wx.ALL, 7)
    self.notebook3 = wx.Notebook(pannel)
    vbox.Add(self.notebook3, 1, wx.EXPAND | wx.ALL, 7)
    pannel.SetSizer(vbox)
    self.pageCounter = 0
    self.addPage()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.textCtrl = wx.TextCtrl(self, - 1, "THIS IS A PAGE OBJECT ",
        style = wx.TE_MULTILINE | wx.BORDER_NONE)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(self.textCtrl, 1, wx.EXPAND)
    self.SetSizer(vbox)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15840550_15840729_9_15
15840550_39218992_17_25
Title: running script multiple times simultaniously in python 2.7 
----------------------------------------

def my_execute(filename) :
INDENT
    if '.htm' in filename :
    INDENT
        name = filename.strip('.htm')
        dbfolder = "C:/newscript/db/" + name
        os.makedirs(dbfolder)
        execution.run_main_with_args(filename, name, str(today), dbfolder)
    DEDENT
DEDENT
----------------------------------------

def my_execute(filename) :
INDENT
    if '.txt' in filename :
    INDENT
        name = filename.strip('.txt')
        dbfolder = "db/" + name
        if not os.path.exists(dbfolder) : os.makedirs(dbfolder)
        execution.run_main_with_args(filename, name, str(today), dbfolder)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15856637_15880461_100_109
15856637_15880461_138_149
Title: WxPython demo code- passing a logger object 
----------------------------------------

def OnGetItemImage(self, indices, which) :
INDENT
    if which in [wx.TreeItemIcon_Normal, wx.TreeItemIcon_Selected] :
    INDENT
        if self.model.GetChildrenCount(indices) :
        INDENT
            return 0
        DEDENT
        else :
        INDENT
            return 2
        DEDENT
    DEDENT
    else :
    INDENT
        return 1
    DEDENT
DEDENT
----------------------------------------

def OnGetItemImage(self, indices, which, column = 0) :
INDENT
    if column == 0 :
    INDENT
        return super(VirtualTreeListCtrl, self).OnGetItemImage(indices,
            which)
    DEDENT
    elif self.OnGetChildrenCount(indices) :
    INDENT
        return 4
    DEDENT
    else :
    INDENT
        return 3

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15856637_15880461_125_133
15856637_15880461_182_193
Title: WxPython demo code- passing a logger object 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    kwargs ['style'] = wx.TR_DEFAULT_STYLE | wx.TR_FULL_ROW_HIGHLIGHT
    super(VirtualTreeListCtrl, self).__init__(* args, ** kwargs)
    self.AddColumn('Column 0')
    self.AddColumn('Column 1')
    for art in wx.ART_TIP, wx.ART_WARNING :
    INDENT
        self.imageList.Add(wx.ArtProvider.GetBitmap(art, wx.ART_OTHER,
                (16, 16)))
    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    treemodel = kwargs.pop('treemodel')
    super(TreeNotebook, self).__init__(* args, ** kwargs)
    self.trees = []
    for class_, title in [(VirtualTreeCtrl, 'TreeCtrl'),
        (VirtualTreeListCtrl, 'TreeListCtrl'),
        (VirtualCustomTreeCtrl, 'CustomTreeCtrl')] :
    INDENT
        tree = class_(self, treemodel = treemodel)
        self.trees.append(tree)
        self.AddPage(tree, title)
    DEDENT
    self.Bind(wx.EVT_NOTEBOOK_PAGE_CHANGED, self.OnPageChanged)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15863784_15863857_5_11
15863784_15864085_2_12
Title: """self.data"" usage in python" 
----------------------------------------

def __call__(self, num) :
INDENT
    if num is None :
    INDENT
        return self.data

    DEDENT
    else :
    INDENT
        self.data += num
    DEDENT
DEDENT
----------------------------------------

def __call__(self, num) :
INDENT
    try :
    INDENT
        self.data
    DEDENT
    except :
    INDENT
        self.data = 0
    DEDENT
    if num is None :
    INDENT
        return self.data

    DEDENT
    else :
    INDENT
        self.data += num
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15869158_16512082_13_19
15869158_16512082_38_48
Title: Python Socket Listening 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        self.data = self.data + self.conn.recv(1024)
        if self.data.endswith(u"\r\n") :
        INDENT
            print self.data
            self.data = ""
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        conn, address = self.s.accept()
        c = client(conn)
        c.start()
        c.send_msg(u"\r\n")
        self.clients.append(c)
        print '[+] Client connected: {0}'.format(address [0])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15885201_15900958_13_20
15885201_21792562_7_12
Title: "Django uploads: Discard uploaded duplicates use existing file (md5 based check)" 
----------------------------------------

def _save(self, name, content) :
INDENT
    if self.exists(name) :
    INDENT
        return name
    DEDENT
    return super(MediaFileSystemStorage, self)._save(name, content)

DEDENT
----------------------------------------

def _save(self, name, content) :
INDENT
    if self.exists(name) :
    INDENT
        raise ValidationError('File already exists: %s' % name)
    DEDENT
    return super(
        FailOnDuplicateFileSystemStorage, self)._save(name, content)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15890104_15890268_13_21
15890104_16045898_19_31
Title: flask with wtforms how to improve my code with either pluggable views or decorators or other? 
----------------------------------------

def dispatch_request(self) :
INDENT
    form = self.form_class()
    if form.validate_on_submit() :
    INDENT
        self.on_validate(form)
        return redirect(self.success_url)
    DEDENT
    self.on_invalidate(form)
    return render_template(self.template, form = form)
DEDENT
----------------------------------------

def dispatch_request(self) :
INDENT
    form = self.form_class()
    if self.sfield :
    INDENT
        form = self.on_sfield(form)
    DEDENT
    if request.method == 'GET' :
    INDENT
        return render_template(self.template, form = form)
    DEDENT
    if request.method == 'POST' :
    INDENT
        if form.validate_on_submit() :
        INDENT
            self.on_validate(form)
            return redirect(url_for(self.success_url))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15916599_15916824_20_40
15916599_15916833_3_10
Title: Python Bubble sort 
----------------------------------------

def bubble_sort(orig_lst) :
INDENT
    lst = [(x, "blue") for x in orig_lst]
    n = len(lst) - 1
    t.pensize(3)
    draw(lst, width)
    swapped = True
    while swapped :
    INDENT
        swapped = False
        for i in range(n) :
        INDENT
            if lst [i + 1] [0] < lst [i] [0] :
            INDENT
                lst [i], lst [i + 1] = lst [i + 1], lst [i]
                lst [i] = (lst [i] [0], "green")
                swapped = True
                next = raw_input("hit any key to continue ")
                t.home()
                t.clear()
                draw(lst, width)
            DEDENT
        DEDENT
    DEDENT
    newLst = [x [0] for x in lst]
    return newLst

DEDENT
----------------------------------------

def bubble_sort(lst) :
INDENT
    assert (type(lst) == types.ListType)
    for index in range(1, len(lst)) :
    INDENT
        while index > 0 and lst [index - 1] > lst [index] :
        INDENT
            lst [index - 1], lst [index] = lst [index], lst [index - 1]
            index -= 1
        DEDENT
    DEDENT
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15938605_35320751_1_27
15938605_40953864_1_40
Title: "Python Difflib - How to Get SDiff Sequences with ""Change"" Op" 
----------------------------------------

def sdiffer(s1, s2) :
INDENT
    differ = difflib.Differ()
    diffs = list(differ.compare(s1, s2))
    i = 0
    sdiffs = []
    length = len(diffs)
    while i < length :
    INDENT
        line = diffs [i] [2 :]
        if diffs [i].startswith('  ') :
        INDENT
            sdiffs.append(('u', line))
        DEDENT
        elif diffs [i].startswith('+ ') :
        INDENT
            sdiffs.append(('+', line))
        DEDENT
        elif diffs [i].startswith('- ') :
        INDENT
            if i + 1 < length and diffs [i + 1].startswith('? ') :
            INDENT
                sdiffs.append(('c', line))
                i += 3 if i + 3 < length and diffs [i + 3].startswith('? ') else 2
            DEDENT
            elif diffs [i + 1].startswith('+ ') and i + 2 < length and diffs [i + 2].startswith('? ') :
            INDENT
                sdiffs.append(('c', line))
                i += 2
            DEDENT
            else :
            INDENT
                sdiffs.append(('-', line))
            DEDENT
        DEDENT
        i += 1
    DEDENT
    return sdiffs
DEDENT
----------------------------------------

def sdiffer(s1, s2) :
INDENT
    differ = difflib.Differ()
    diffs = list(differ.compare(s1, s2))
    i = 0
    sdiffs = []
    length = len(diffs)
    sequence = 0
    while i < length :
    INDENT
        line = diffs [i] [2 :]
        if diffs [i].startswith('  ') :
        INDENT
            sequence += 1
            sdiffs.append((sequence, 'u', line))
        DEDENT
        elif diffs [i].startswith('+ ') :
        INDENT
            sequence += 1
            sdiffs.append((sequence, '+', line))
        DEDENT
        elif diffs [i].startswith('- ') :
        INDENT
            sequence += 1
            sdiffs.append((sequence, '-', diffs [i] [2 :]))
            if i + 1 < length and diffs [i + 1].startswith('? ') :
            INDENT
                if diffs [i + 3].startswith('?') and i + 3 < length :
                INDENT
                    sequence += 1
                    sdiffs.append((sequence, '+', diffs [i + 2] [2 :]))
                    i += 3
                DEDENT
                elif diffs [i + 2].startswith('?') and i + 2 < length :
                INDENT
                    sequence += 1
                    sdiffs.append((sequence, '+', diffs [i + 2] [2 :]))
                    i += 2
                DEDENT
            DEDENT
            elif diffs [i + 1].startswith('+ ') and i + 2 < length and diffs [i + 2].startswith('? ') :
            INDENT
                sequence += 1
                sdiffs.append((sequence, '+', diffs [i + 1] [2 :]))
                i += 2
            DEDENT
            else :
            INDENT
                sequence += 1
                sdiffs.append((sequence, '+', diffs [i + 1] [2 :]))
                i += 1
            DEDENT
        DEDENT
        i += 1
    DEDENT
    return sdiffs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16025932_16026045_2_7
16025932_38972732_8_16
Title: Methods to protect a bottle.py webapplication against XSS and CSRF? 
----------------------------------------

def csrf_protect() :
INDENT
    if request.method == "POST" :
    INDENT
        token = session.pop('_csrf_token', None)
        if not token or token ! = request.form.get('_csrf_token') :
        INDENT
            abort(403)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def csrf_protect() :
INDENT
    if request.method == 'POST' :
    INDENT
        sess = request.environ ['beaker.session']
        req_token = request.forms.get('csrf_token')

        if 'csrf_token' not in sess or sess ['csrf_token'] ! = req_token :
        INDENT
            abort(403)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16043183_16043408_1_15
16043183_16043430_1_12
Title: Python - how to compare all items within list 
----------------------------------------

def groupItemsFromList(self, itemList) :
INDENT
    tmp = itemList [:]
    allGroups = []
    while tmp :
    INDENT
        it = tmp.pop(0)
        currentGroup = [it]
        i = len(tmp) - 1
        while i > = 0 :
        INDENT
            if any(x.collidesWithItem(tmp [i]) for x in currentGroup) :
            INDENT
                currentGroup.append(tmp.pop(i))
                i = len(tmp) - 1
            DEDENT
            else :
            INDENT
                i -= 1
            DEDENT
        DEDENT
        allGroups.append(currentGroup)
    DEDENT
    return allGroups
DEDENT
----------------------------------------

def groupItemsFromList(self, itemList) :
INDENT
    def collision_indexes(i, target) :
    INDENT
        return [i] + [j for j, item in enumerate(itemList [i + 1 :], start = i + 1) if item.collidesWithItem(target)]
    DEDENT
    processed = set()
    results = []
    for i, target in enumerate(itemList) :
    INDENT
        if i not in processed :
        INDENT
            indexes = collision_indexes(i, target)
            processed.update(indexes)
            results.append([itemList [j] for j in indexes])
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16054348_16055411_13_19
16054348_16055411_27_47
Title: remove the use of shouldStop variable in python producer thread 
----------------------------------------

def run(self) :
INDENT
    for i in range(5) :
    INDENT
        if self._shutdown_event.is_set() :
        INDENT
            return
        DEDENT
        else :
        INDENT
            self._work_queue.put(i)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            data = self._work_queue.get(timeout = 1)
        DEDENT
        except Queue.Empty :
        INDENT
            if self._shutdown_event.is_set() :
            INDENT
                print 'returning from thread; queue is empty and ' 'shutdown_event.is_set() is True'
                return
            DEDENT
            else :
            INDENT
                continue
            DEDENT
        DEDENT
        if self._shutdown_event.is_set() :
        INDENT
            print 'returning from thread; shutdown_event.is_set() is True'
            return
        DEDENT
        else :
        INDENT
            print "%s got %s. Sleeping for %s seconds. %s" % (
                self.getName(), data, data, time.time())
            time.sleep(1.0 + data / 10)
            print "%s woke up from sleep after %s seconds %s" % (
                self.getName(), str(1.0 + data / 10), time.time())
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16054983_16059498_32_42
16054983_16059498_5_24
Title: Making top window inaccessible in wx.python 
----------------------------------------

def __init__(self) :
INDENT
    style = (wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX |
        wx.CLIP_CHILDREN | wx.FRAME_FLOAT_ON_PARENT)
    wx.Frame.__init__(self, wx.GetApp().TopWindow, title = self.title,
        size = (400, 250), style = style)
    self.CenterOnParent()
    self.GetParent().Disable()
    self.Bind(wx.EVT_CLOSE, self.onClose)
DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    style = (wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX |
        wx.CLIP_CHILDREN)
    wx.Frame.__init__(self, parent, title = title, size = (400, 320),
        style = style)

    filemenu = wx.Menu()
    set_m = filemenu.Append(wx.ID_PREFERENCES, 'Settings', 'Settings')
    filemenu.AppendSeparator()
    exit_m = filemenu.Append(wx.ID_EXIT)

    menubar = wx.MenuBar()
    menubar.Append(filemenu, 'Menu')
    self.SetMenuBar(menubar)
    self.Bind(wx.EVT_MENU, self.OnSettings, set_m)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16054983_16059498_32_42
16054983_16063045_4_20
Title: Making top window inaccessible in wx.python 
----------------------------------------

def __init__(self) :
INDENT
    style = (wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX |
        wx.CLIP_CHILDREN | wx.FRAME_FLOAT_ON_PARENT)
    wx.Frame.__init__(self, wx.GetApp().TopWindow, title = self.title,
        size = (400, 250), style = style)
    self.CenterOnParent()
    self.GetParent().Disable()
    self.Bind(wx.EVT_CLOSE, self.onClose)
DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (400, 320), style = (wx.MINIMIZE_BOX | wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX | wx.CLIP_CHILDREN))

    filemenu = wx.Menu()
    set_m = filemenu.Append(wx.ID_PREFERENCES, 'Settings', 'Settings')
    filemenu.AppendSeparator()
    exit_m = filemenu.Append(wx.ID_EXIT)

    menubar = wx.MenuBar()
    menubar.Append(filemenu, 'Menu')
    self.SetMenuBar(menubar)
    self.Bind(wx.EVT_MENU, self.OnSettings, set_m)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16067193_16067230_3_10
16067193_16067274_4_13
Title: I want an error to pop up before user is asked to input something again 
----------------------------------------

def get_currency(msg) :
INDENT
    while True :
    INDENT
        user_input = input(msg).lower()
        if user_input not in currencies :
        INDENT
            print ('Invalid currency')
        DEDENT
        else :
        INDENT
            return user_input
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_currency(msg) :
INDENT
    input_valid = input(msg).lower()
    while input_valid not in valid :
    INDENT
        print ("Invalid Input, Try again")
        input_valid = input(msg).lower()
    DEDENT
    return input_valid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16068673_16068850_4_12
16068673_16069360_2_12
Title: python log exceptions decorator for non stable functions 
----------------------------------------

def deco(func) :
INDENT
    def wrapper(* args, ** kwargs) :
    INDENT
        try :
        INDENT
            result = func(* args, ** kwargs)
        DEDENT
        except exception as err :
        INDENT
            logger.exception(err)
        DEDENT
        else :
        INDENT
            return result
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def deco(func) :
INDENT
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        try :
        INDENT
            return func(* args, ** kwargs)
        DEDENT
        except Exception as e :
        INDENT
            with open(log_path, 'a') as log :
            INDENT
                log.write('{} {} {} {} {}\n'.format(datetime.datetime.now(),
                        type(e), e, args, kwargs))
            DEDENT
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16068673_16068850_5_11
16068673_16069360_4_11
Title: python log exceptions decorator for non stable functions 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    try :
    INDENT
        result = func(* args, ** kwargs)
    DEDENT
    except exception as err :
    INDENT
        logger.exception(err)
    DEDENT
    else :
    INDENT
        return result
    DEDENT
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    try :
    INDENT
        return func(* args, ** kwargs)
    DEDENT
    except Exception as e :
    INDENT
        with open(log_path, 'a') as log :
        INDENT
            log.write('{} {} {} {} {}\n'.format(datetime.datetime.now(),
                    type(e), e, args, kwargs))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16092153_16092771_1_20
16092153_16093544_1_6
Title: How does find procedure work in python 
----------------------------------------

def find(x, string, backward = False, ignore_case = False) :
INDENT
    x = str(x)
    string = str(string)
    if ignore_case :
    INDENT
        x = x.lower()
        string = string.lower()
    DEDENT
    str_list = [i for i in string]
    x_list = [i for i in x]
    if backward :
    INDENT
        x_list.reverse()
        str_list.reverse()
    DEDENT
    x = ''.join(x_list)
    string = ''.join(str_list)
    lenx = len(x)
    ans = []
    for i in range(len(str_list) - lenx) :
    INDENT
        if x == string [i : i + lenx] :
        INDENT
            ans.append(i)
        DEDENT
    DEDENT
    return ans
DEDENT
----------------------------------------

def find(s, sub) :
INDENT
    for i, _ in enumerate(s) :
    INDENT
        if s.startswith(sub, i) :
        INDENT
            return i
        DEDENT
    DEDENT
    return - 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16110234_16111218_3_15
16110234_16111939_5_14
Title: Mutually exclusive random sampling from a list. Python 
----------------------------------------

def random_generator(array, x, y) :
INDENT
    random.shuffle(array)
    result = []
    count = 0
    while count < x :
    INDENT
        section = []
        y1 = y * count
        y2 = y * (count + 1)
        for i in range(y1, y2) :
        INDENT
            section.append(array [i])
        DEDENT
        result.append(section)
        count += 1
    DEDENT
    return result
DEDENT
----------------------------------------

def random_generator(seq, n, m) :
INDENT
    rand_seq = seq [:]
    random.shuffle(rand_seq)
    lists = []
    limit = n - 1
    for i, group in enumerate(itertools.izip(* ([iter(rand_seq)] * m))) :
    INDENT
        lists.append(group)
        if i == limit : break
    DEDENT
    return lists
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16115378_25121623_25_33
16115378_25121623_8_16
Title: "Tkinter example code for multiple windows why won't buttons load correctly?" 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(master)
    master.title("a")
    self.quitButton = tk.Button(self.frame, text = 'Quit', width = 25, command = self.close_window)
    self.quitButton.pack()
    self.frame.pack()

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(master)
    self.lbl = Label(master, text = "Label")
    self.lbl.pack()
    self.btn = Button(master, text = "Button", command = self.command)
    self.btn.pack()
    self.frame.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16147243_16148866_2_13
16147243_16157811_1_34
Title: Useful default __repr__ for nested class instances 
----------------------------------------

def __repr__(self, indent = 2) :
INDENT
    result = self.__class__.__name__ + '\n'
    for k, v in self.__dict__.iteritems() :
    INDENT
        if k.startswith('__') :
        INDENT
            continue
        DEDENT
        if isinstance(v, AbstractBase) :
        INDENT
            vStr = v.__repr__(indent + 2)
        DEDENT
        else :
        INDENT
            vStr = str(v)
        DEDENT
        result += ' ' * indent + k + ': ' + vStr
    DEDENT
    result += '\n'
    return result
DEDENT
----------------------------------------

def __repr__(self, indent = 2) :
INDENT
    result = self.__class__.__name__ + '\n'
    items = self.__dict__.items()
    for i, (k, v) in enumerate(items) :
    INDENT
        if '__' in k :
        INDENT
            continue
        DEDENT
        if isinstance(v, AbstractBase) :
        INDENT
            vStr = '\n' + ' ' * (indent + 2) + v.__repr__(indent + 4)
        DEDENT
        elif isinstance(v, collections.Iterable) :
        INDENT
            s = str(v)
            bstart = s [0]
            bend = s [- 1]
            newIndent = indent + 3
            vStr = '\n' + ' ' * (newIndent - 1) + bstart
            for j, item in enumerate(v) :
            INDENT
                if isinstance(item, AbstractBase) :
                INDENT
                    if j :
                    INDENT
                        vStr += ' ' * newIndent
                    DEDENT
                    vStr += item.__repr__(newIndent + 2)
                DEDENT
                else :
                INDENT
                    vStr += repr(item)
                DEDENT
                vStr += ',\n'
            DEDENT
            vStr += ' ' * (newIndent - 1) + bend
        DEDENT
        else :
        INDENT
            vStr = str(v)
        DEDENT
        result += ' ' * indent + k + ': ' + vStr
        if i ! = len(items) - 1 :
        INDENT
            result += '\n'
        DEDENT
    DEDENT
    result = re.sub('\n+', '\n', result)
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16172011_16172132_3_10
16172011_52159482_2_16
Title: Json in Python: Receive/Check duplicate key error 
----------------------------------------

def dupe_checking_hook(pairs) :
INDENT
    result = dict()
    for key, val in pairs :
    INDENT
        if key in result :
        INDENT
            raise KeyError("Duplicate key specified: %s" % key)
        DEDENT
        result [key] = val
    DEDENT
    return result
DEDENT
----------------------------------------

def dupe_checking_hook(pairs) :
INDENT
    result = dict()
    for key, val in pairs :
    INDENT
        if key in result :
        INDENT
            if (type(result [key]) == dict) :
            INDENT
                temp = []
                temp.append(result [key])
                temp.append(val)
                result [key] = temp
            DEDENT
            else :
            INDENT
                result [key].append(val)
            DEDENT
        DEDENT
        else :
        INDENT
            result [key] = val
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16210314_16210362_10_16
16210314_16210388_8_14
Title: Python global variable and class functionality 
----------------------------------------

def delete(self, i) :
INDENT
    if i > = len(store) :
    INDENT
        raise IndexError
    DEDENT
    else :
    INDENT
        del self.store [i]
        self.message_count -= 1
    DEDENT
DEDENT
----------------------------------------

def delete(self, i) :
INDENT
    if i > len(store - 1) :
    INDENT
        print ("Index does not exist")
    DEDENT
    else :
    INDENT
        global message_count
        del store [i]
        message_count -= 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16249736_16255680_18_34
16249736_49374931_1_28
Title: How to import data from mongodb to pandas? 
----------------------------------------

def read_mongo(db, collection, query = {}, host = 'localhost', port = 27017, username = None, password = None, no_id = True) :
INDENT
    db = _connect_mongo(host = host, port = port, username = username, password = password, db = db)

    cursor = db [collection].find(query)

    df = pd.DataFrame(list(cursor))

    if no_id :
    INDENT
        del df ['_id']

    DEDENT
    return df
DEDENT
----------------------------------------

def read_mongo(

collection, query = None,

chunksize = 100, page_num = 1, no_id = True) :
INDENT
    db = _connect_mongo(host = host, port = port, username = username, password = password, db = db)

    skips = chunksize * (page_num - 1)

    if not query :
    INDENT
        query = {}

    DEDENT
    cursor = db [collection].find(query).skip(skips).limit(chunksize)

    df = pd.DataFrame(list(cursor))

    if no_id :
    INDENT
        del df ['_id']

    DEDENT
    return df
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16260620_16260762_1_18
16260620_16260855_1_16
Title: How can i search and replace using python regex 
----------------------------------------

def myfunc(h) :
INDENT
    myarray = [
        ("\\", r"\textbackslash"),
        ("{", r"\{"),
        ("}", r"\}"),
        ("#", r"\#"),
        ("$", r"\$"),
        ("%", r"\%"),
        ("&", r"\&"),
        ("~", r"\~{}"),
        ("_", r"\_"),
        ("^", r"\^{}")]
    for (val, replacement) in myarray :
    INDENT
        h = h.replace(val, replacement)
    DEDENT
    h = h.replace(r"\textbackslash", r"\textbackslash{}", h)
    return h
DEDENT
----------------------------------------

def myfunc(h) :
INDENT
    rules = {
        "#" : r"\#",
        "$" : r"\$",
        "%" : r"\%",
        "&" : r"\&",
        "~" : r"\~{}",
        "_" : r"\_",
        "^" : r"\^{}",
        "\\" : r"\textbackslash{}",
        "{" : r"\{",
        "}" : r"\}"}
    pattern = '[%s]' % re.escape(''.join(rules.keys()))
    new = re.sub(pattern, lambda m : rules [m.group()], h)
    return new
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16312822_18455848_55_74
16312822_18455848_9_29
Title: Creating Notebook tabs for MDIChildFrame 
----------------------------------------

def __init__(self, parent, count) :
INDENT
    wx.aui.AuiMDIChildFrame.__init__(self, parent, - 1,
        title = "Child: %d" % count)
    mb = parent.MakeMenuBar()
    menu = wx.Menu()
    item = menu.Append(- 1, "This is child %d's menu" % count)
    mb.Append(menu, "&Child")
    self.SetMenuBar(mb)
    p = wx.Panel(self)
    wx.StaticText(p, - 1, "This is child %d" % count, (10, 10))
    p.SetBackgroundColour('light blue')
    sizer = wx.BoxSizer()
    sizer.Add(p, 1, wx.EXPAND)
    self.SetSizer(sizer)
    wx.CallAfter(self.Layout)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.aui.AuiMDIParentFrame.__init__(self, parent, - 1,
        title = "AuiMDIParentFrame",
        size = (640, 480),
        style = wx.DEFAULT_FRAME_STYLE)
    self.count = 0

    mb = self.MakeMenuBar()
    self.SetMenuBar(mb)

    self.statusbar = self.CreateStatusBar(2, wx.ST_SIZEGRIP)
    self.statusbar.SetStatusWidths([- 2, - 3])
    self.statusbar.SetStatusText("Ready", 0)
    self.statusbar.SetStatusText("Welcome To wxPython!", 1)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16315732_16316032_12_51
16315732_21348043_11_39
Title: How do you set the position of a grid using Tkinter? 
----------------------------------------

def initUI(self) :
INDENT
    self.parent.title("Contact Manager")
    self.pack(fill = BOTH, expand = 1)

    Label(self, text = "New Contact").grid(row = 0, column = 2, columnspan = 2, sticky = W)
    Label(self, text = "First Name:").grid(row = 1, column = 1, sticky = E)
    Label(self, text = "Last Name:").grid(row = 2, column = 1, sticky = E)
    Label(self, text = "Phone#").grid(row = 3, column = 1, sticky = E)
    self.entry1 = Entry(self)
    self.entry2 = Entry(self)
    self.entry3 = Entry(self)
    self.entry1.grid(row = 1, column = 2)
    self.entry2.grid(row = 2, column = 2)
    self.entry3.grid(row = 3, column = 2)
    friend_check = IntVar()
    self.friend_check = Checkbutton(self, variable = friend_check,
        command = self.friend_box,
        text = "Friend")
    self.friend_check.grid(row = 4, column = 2, columnspan = 2)
    Label(self, text = "Email:").grid(row = 5, column = 1, sticky = E)
    Label(self, text = "Birthday:").grid(row = 6, column = 1, sticky = E)
    self.entry4 = Entry(self)
    self.entry5 = Entry(self)
    self.entry4.grid(row = 5, column = 2)
    self.entry5.grid(row = 6, column = 2)

    Label(self, text = "Contact List").grid(row = 0)
    contact_lb = Listbox(self)
    for i in contacts :
    INDENT
        contact_lb.insert(END, i)
    DEDENT
    contact_lb.bind("<<ListboxSelect>>", self.onSelect)
    contact_lb.grid(row = 1, rowspan = 5)
DEDENT
----------------------------------------

def initUI(self) :
INDENT
    self.parent.title("Windows")

    Label(text = "Contact List").grid(row = 0, column = 0, columnspan = 2)
    Text(width = 30, height = 15).grid(row = 1, rowspan = 9, column = 0, columnspan = 2, padx = 20)
    Button(text = "Display Contact").grid(row = 10, column = 0, columnspan = 2, pady = 10)
    Label(text = "Last Name:").grid(row = 11, column = 0, pady = 10)
    Entry().grid(row = 11, column = 1)
    Button(text = "Search").grid(row = 12, column = 0, columnspan = 2)

    Label(text = "New Contact").grid(row = 0, column = 2, columnspan = 2)
    Label(text = "First Name:").grid(row = 1, column = 2, sticky = E)
    Entry().grid(row = 1, column = 3)
    Label(text = "Last Name:").grid(row = 2, column = 2, sticky = E)
    Entry().grid(row = 2, column = 3)
    Label(text = "Phone #:").grid(row = 3, column = 2, sticky = E)
    Entry().grid(row = 3, column = 3)
    friend_check = IntVar()
    Checkbutton(variable = friend_check, command = self.friend_box, text = "Friend").grid(row = 4, column = 3, sticky = W)
    Label(text = "Email:").grid(row = 5, column = 2, sticky = E)
    Entry().grid(row = 5, column = 3)
    Label(text = "Birthday:").grid(row = 6, column = 2, sticky = E)
    Entry().grid(row = 6, column = 3)
    Button(text = "Add Contact").grid(row = 7, column = 3, sticky = E)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16360471_16361552_6_21
16360471_16400765_31_39
Title: Is there something like a wxpython TextCtrl flush method? 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title)
    panel = wx.Panel(self)
    self.counter = 1
    self.txtu = wx.TextCtrl(panel)
    btnco = wx.Button(panel, - 1, "Rotate", pos = (0, 30))
    self.Bind(wx.EVT_BUTTON, self.OnCo, id = btnco.GetId())
    self.tinyTimer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.updateTextCtrl, self.tinyTimer)
    self.sixtyTimer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.onSixty, self.sixtyTimer)

DEDENT
----------------------------------------

def __init__(self, notify_window) :
INDENT
    Thread.__init__(self)
    self._notify_window = notify_window
    self.chars = cycle(('|', '/', '-', '\\'))
    self.tinyTimer = wx.Timer(notify_window)
    notify_window.Bind(wx.EVT_TIMER, self.updateTextCtrl, self.tinyTimer)
    self.tinyTimer.Start(100)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16360471_16361552_6_21
16360471_16400765_64_78
Title: Is there something like a wxpython TextCtrl flush method? 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title)
    panel = wx.Panel(self)
    self.counter = 1
    self.txtu = wx.TextCtrl(panel)
    btnco = wx.Button(panel, - 1, "Rotate", pos = (0, 30))
    self.Bind(wx.EVT_BUTTON, self.OnCo, id = btnco.GetId())
    self.tinyTimer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.updateTextCtrl, self.tinyTimer)
    self.sixtyTimer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.onSixty, self.sixtyTimer)

DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, 'Thread Test')
    self.start_button = wx.Button(self, - 1, 'Start', pos = (0, 0))
    self.progress = wx.TextCtrl(self, - 1, '', pos = (0, 50))
    self.status = wx.StaticText(self, - 1, '', pos = (0, 100))
    self.Bind(wx.EVT_BUTTON, self.OnStart, self.start_button)

    EVT_RESULT(self, self.OnResult)
    EVT_PROGRESSUPDATE(self, self.OnProgressUpdate)

    self.worker = None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16360471_16400765_31_39
16360471_16400765_64_78
Title: Is there something like a wxpython TextCtrl flush method? 
----------------------------------------

def __init__(self, notify_window) :
INDENT
    Thread.__init__(self)
    self._notify_window = notify_window
    self.chars = cycle(('|', '/', '-', '\\'))
    self.tinyTimer = wx.Timer(notify_window)
    notify_window.Bind(wx.EVT_TIMER, self.updateTextCtrl, self.tinyTimer)
    self.tinyTimer.Start(100)
DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, 'Thread Test')
    self.start_button = wx.Button(self, - 1, 'Start', pos = (0, 0))
    self.progress = wx.TextCtrl(self, - 1, '', pos = (0, 50))
    self.status = wx.StaticText(self, - 1, '', pos = (0, 100))
    self.Bind(wx.EVT_BUTTON, self.OnStart, self.start_button)

    EVT_RESULT(self, self.OnResult)
    EVT_PROGRESSUPDATE(self, self.OnProgressUpdate)

    self.worker = None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16360910_16368646_84_92
16360910_16369224_16_26
Title: Is it possible to create a variable as a placeholder for 'current' value of a class in python? 
----------------------------------------

def __call__(self, ** kw) :
INDENT
    for key, val in kw.iteritems() :
    INDENT
        if isinstance(val, Expr) :
        INDENT
            current = self.a
            new_val = val(current)
            setattr(self, key, new_val)
        DEDENT
        else :
        INDENT
            setattr(self, key, val)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __call__(self, ** kwargs) :
INDENT
    for keyword, value in kwargs.iteritems() :
    INDENT
        try :
        INDENT
            expression = value.exp
            try :
            INDENT
                value = expression(vars(self) [keyword], value.val)
            DEDENT
            except AttributeError :
            INDENT
                value = expression(vars(self) [keyword])
            DEDENT
        DEDENT
        except AttributeError :
        INDENT
            value = value
        DEDENT
        setattr(self, keyword, value)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16415759_16415894_13_20
16415759_16415907_1_8
Title: Breaking down a function into more manageable segments 
----------------------------------------

def print_monthly_totals(input_csv_filename) :
INDENT
    with open(input_csv_filename) as fh :
    INDENT
        for line in fh :
        INDENT
            month, days = parse_line(line)
            print ('Rainfall totals for each month')
            trf = rainfall_total(columns, num_days)
            print ('Month {:2}: {:.1f}'.format(month, trf))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def print_monthly_totals(input_csv_filename) :
INDENT
    with open(input_csv_filename) as csv_file :
    INDENT
        data = csv_file.readlines()
        print ('Rainfall totals for each month')
        for line in data :
        INDENT
            manage_line(line)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16415759_16415894_13_20
16415759_16416412_1_14
Title: Breaking down a function into more manageable segments 
----------------------------------------

def print_monthly_totals(input_csv_filename) :
INDENT
    with open(input_csv_filename) as fh :
    INDENT
        for line in fh :
        INDENT
            month, days = parse_line(line)
            print ('Rainfall totals for each month')
            trf = rainfall_total(columns, num_days)
            print ('Month {:2}: {:.1f}'.format(month, trf))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def print_monthly_totals(input_csv_filename) :
INDENT
    import csv
    print ('Rainfall totals for each month')
    with open(input_csv_filename) as csv_file :
    INDENT
        for row in csv.reader(csv_file) :
        INDENT
            print_row(row)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16415759_16415894_7_12
16415759_16415907_16_21
Title: Breaking down a function into more manageable segments 
----------------------------------------

def rainfall_total(columns, num_days) :
INDENT
    total_rainfall = 0
    for col in columns [2 : 2 + num_days] :
    INDENT
        total_rainfall += float(col)
    DEDENT
    return total_rainfall
DEDENT
----------------------------------------

def rainfall_total(columns, num_days) :
INDENT
    total_rainfall = 0
    for col in columns [2 : 2 + num_days] :
    INDENT
        total_rainfall += float(col)
    DEDENT
    return total_rainfall
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16425166_16425424_3_9
16425166_16425474_3_9
Title: Accumulate items in a list of tuples 
----------------------------------------

def accumulate(lst) :
INDENT
    sums = defaultdict(int)
    for item in lst :
    INDENT
        for index, subitem in enumerate(item) :
        INDENT
            sums [index] += subitem
        DEDENT
        yield [sums [index] for index in xrange(len(sums))]
    DEDENT
DEDENT
----------------------------------------

def accumulate(the_list) :
INDENT
    the_item = iter(the_list)
    accumulator = next(the_item)
    while True :
    INDENT
        yield accumulator
        accumulator = tuple(x + y for (x, y) in zip(accumulator, next(the_item)))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16453184_16453271_1_7
16453184_16453385_8_14
Title: Python more functions 
----------------------------------------

def print_monthly_totals(input_csv_filename) :
INDENT
    months, rainfall_totals = get_rainfall_data(input_csv_filename)
    print ('Rainfall totals for each month')
    for month, total_rainfall in zip(months, rainfall_totals) :
    INDENT
        print ('Month {:2}: {:.1f}'.format(month, total_rainfall))
    DEDENT
DEDENT
----------------------------------------

def print_monthly_totals(input_csv_filename) :
INDENT
    data = open(input_csv_filename).readlines()
    print ('Rainfall totals for each month')
    for line in data :
    INDENT
        month, daily_rainfalls = line_to_rainfall(line)
        total_rainfall = sum(daily_rainfalls)
        print ('Month {:2}: {:.1f}'.format(month, total_rainfall))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16490263_16594951_32_56
16490263_16594951_64_79
Title: Attach/Detach two frames in wxpython 
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    kwds ["style"] = wx.DEFAULT_FRAME_STYLE
    if kwds.has_key("panel") :
    INDENT
        self.panel = kwds ["panel"]
        del kwds ["panel"]
    DEDENT
    else :
    INDENT
        self.panel = None
    DEDENT
    wx.Frame.__init__(self, * args, ** kwds)
    if self.panel is None :
    INDENT
        self.panel = SubFramePanel(self)
    DEDENT
    else :
    INDENT
        self.panel.Reparent(self)
    DEDENT
    self.SetTitle(_("Sub Frame"))
    self.SetSize((291, 93))
    subFrameSizer = wx.BoxSizer(wx.VERTICAL)
    subFrameSizer.Add(self.panel, 1, wx.EXPAND | wx.LEFT, 5)
    self.SetSizer(subFrameSizer)
    self.Layout()
    pub.subscribe(self.OnClose, "show.subframe.OnClose")
DEDENT
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    kwds ["style"] = wx.DEFAULT_FRAME_STYLE
    wx.Frame.__init__(self, * args, ** kwds)
    self.text_ctrl_1 = wx.TextCtrl(self, wx.ID_ANY, "", style = wx.TE_MULTILINE)
    pub.subscribe(self.OnAddText, "show.mainframe.addText")
    pub.subscribe(self.OnAttach, "show.mainframe.OnAttach")
    pub.subscribe(self.OnDetach, "show.mainframe.OnDetach")
    self.SetTitle(_("Main Frame"))
    self.SetSize((492, 271))
    self.mainFrameSizer = wx.BoxSizer(wx.VERTICAL)
    self.mainFrameSizer.Add(self.text_ctrl_1, 1, wx.ALL | wx.EXPAND, 5)
    self.SetSizer(self.mainFrameSizer)
    self.Layout()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16490263_16594951_32_56
16490263_16594951_6_16
Title: Attach/Detach two frames in wxpython 
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    kwds ["style"] = wx.DEFAULT_FRAME_STYLE
    if kwds.has_key("panel") :
    INDENT
        self.panel = kwds ["panel"]
        del kwds ["panel"]
    DEDENT
    else :
    INDENT
        self.panel = None
    DEDENT
    wx.Frame.__init__(self, * args, ** kwds)
    if self.panel is None :
    INDENT
        self.panel = SubFramePanel(self)
    DEDENT
    else :
    INDENT
        self.panel.Reparent(self)
    DEDENT
    self.SetTitle(_("Sub Frame"))
    self.SetSize((291, 93))
    subFrameSizer = wx.BoxSizer(wx.VERTICAL)
    subFrameSizer.Add(self.panel, 1, wx.EXPAND | wx.LEFT, 5)
    self.SetSizer(subFrameSizer)
    self.Layout()
    pub.subscribe(self.OnClose, "show.subframe.OnClose")
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, wx.ID_ANY)
    self.attachDetachButton = wx.Button(self, wx.ID_ANY, _("Attach"))
    self.sayHelloButton = wx.Button(self, wx.ID_ANY, _("Say Hello"))
    subPanelSizer = wx.BoxSizer(wx.HORIZONTAL)
    subPanelSizer.Add(self.attachDetachButton, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
    subPanelSizer.Add(self.sayHelloButton, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL, 0)
    self.SetSizer(subPanelSizer)
    self.attachDetachButton.Bind(wx.EVT_BUTTON, self.OnAttachDetachButton)
    self.sayHelloButton.Bind(wx.EVT_BUTTON, self.OnSayHelloButton)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16490263_16594951_64_79
16490263_16594951_6_16
Title: Attach/Detach two frames in wxpython 
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    kwds ["style"] = wx.DEFAULT_FRAME_STYLE
    wx.Frame.__init__(self, * args, ** kwds)
    self.text_ctrl_1 = wx.TextCtrl(self, wx.ID_ANY, "", style = wx.TE_MULTILINE)
    pub.subscribe(self.OnAddText, "show.mainframe.addText")
    pub.subscribe(self.OnAttach, "show.mainframe.OnAttach")
    pub.subscribe(self.OnDetach, "show.mainframe.OnDetach")
    self.SetTitle(_("Main Frame"))
    self.SetSize((492, 271))
    self.mainFrameSizer = wx.BoxSizer(wx.VERTICAL)
    self.mainFrameSizer.Add(self.text_ctrl_1, 1, wx.ALL | wx.EXPAND, 5)
    self.SetSizer(self.mainFrameSizer)
    self.Layout()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, wx.ID_ANY)
    self.attachDetachButton = wx.Button(self, wx.ID_ANY, _("Attach"))
    self.sayHelloButton = wx.Button(self, wx.ID_ANY, _("Say Hello"))
    subPanelSizer = wx.BoxSizer(wx.HORIZONTAL)
    subPanelSizer.Add(self.attachDetachButton, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
    subPanelSizer.Add(self.sayHelloButton, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL, 0)
    self.SetSizer(subPanelSizer)
    self.attachDetachButton.Bind(wx.EVT_BUTTON, self.OnAttachDetachButton)
    self.sayHelloButton.Bind(wx.EVT_BUTTON, self.OnSayHelloButton)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16502788_16503001_4_11
16502788_16503139_7_13
Title: Sequence of elements in a list satisfying a condition 
----------------------------------------

def sub_seq(li, n) :
INDENT
    d = defaultdict(list)
    rle = [(k, len(list(g))) for k, g in groupby(li)]
    endpoints = accumulate(size for k, size in rle)
    for end_index, (value, count) in zip(endpoints, rle) :
    INDENT
        for index in range(end_index - count, end_index - n + 1) :
        INDENT
            d [value].append(index)
        DEDENT
    DEDENT
    return dict(d)
DEDENT
----------------------------------------

def sub_seq(li, n) :
INDENT
    res = defaultdict(list)
    for k, g in groupby(enumerate(li), itemgetter(1)) :
    INDENT
        l = list(map(itemgetter(0), g))
        if n < = len(l) : res [k] += l [0 : len(l) - n + 1]
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16505010_16512073_31_43
16505010_21950728_40_57
Title: wx.Python: Passing control between multiple panels 
----------------------------------------

def create_controls(self) :
INDENT
    self.h_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.v_sizer = wx.BoxSizer(wx.VERTICAL)
    self.button = wx.Button(self, label = "Press me!")
    self.v_sizer.Add(self.button, 0)
    self.v_sizer.Add(self.h_sizer, 0, wx.EXPAND)
    self.SetSizer(self.v_sizer)

DEDENT
----------------------------------------

def create_controls(self) :
INDENT
    self.h_sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.v_sizer = wx.BoxSizer(wx.VERTICAL)
    self.bbutton = wx.Button(self, label = "Got dem blues?!")
    self.bbutton.Bind(wx.EVT_BUTTON, self.blues_button_pressed)
    self.hbutton = wx.Button(self, label = "Happy happy!")
    self.hbutton.Bind(wx.EVT_BUTTON, self.happy_button_pressed)
    self.v_sizer.Add(self.bbutton, 0)
    self.v_sizer.Add(self.hbutton, 0)
    self.v_sizer.Add(self.h_sizer, 0, wx.EXPAND)
    self.SetSizer(self.v_sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16505010_16512073_46_63
16505010_16512073_9_20
Title: wx.Python: Passing control between multiple panels 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "DB Viewer", size = (350, 250))
    splitter = wx.SplitterWindow(self)
    leftP = LeftPanel(splitter)
    self.rightP = RightPanel(splitter)
    splitter.SplitVertically(leftP, self.rightP)
    splitter.SetMinimumPaneSize(20)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(splitter, 1, wx.EXPAND)
    self.SetSizer(sizer)
    leftP.button.Bind(wx.EVT_BUTTON, self.on_button_pressed)
    self.Layout()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(5, 5)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16505010_16512073_46_63
16505010_21950728_10_23
Title: wx.Python: Passing control between multiple panels 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "DB Viewer", size = (350, 250))
    splitter = wx.SplitterWindow(self)
    leftP = LeftPanel(splitter)
    self.rightP = RightPanel(splitter)
    splitter.SplitVertically(leftP, self.rightP)
    splitter.SetMinimumPaneSize(20)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(splitter, 1, wx.EXPAND)
    self.SetSizer(sizer)
    leftP.button.Bind(wx.EVT_BUTTON, self.on_button_pressed)
    self.Layout()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(5, 5)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)
    pub.subscribe(self.changeColourEvent, "MOOD_CHANGE")

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16505010_16512073_9_20
16505010_21950728_10_23
Title: wx.Python: Passing control between multiple panels 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(5, 5)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(5, 5)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)
    pub.subscribe(self.changeColourEvent, "MOOD_CHANGE")

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16505010_16512073_9_20
16505010_21950728_68_81
Title: wx.Python: Passing control between multiple panels 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(5, 5)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "DB Viewer", size = (350, 250))
    splitter = wx.SplitterWindow(self)
    leftP = LeftPanel(splitter)
    rightP = RightPanel(splitter)
    splitter.SplitVertically(leftP, rightP)
    splitter.SetMinimumPaneSize(20)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(splitter, 1, wx.EXPAND)
    self.SetSizer(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16505010_21950728_10_23
16505010_21950728_68_81
Title: wx.Python: Passing control between multiple panels 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(5, 5)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)
    pub.subscribe(self.changeColourEvent, "MOOD_CHANGE")

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "DB Viewer", size = (350, 250))
    splitter = wx.SplitterWindow(self)
    leftP = LeftPanel(splitter)
    rightP = RightPanel(splitter)
    splitter.SplitVertically(leftP, rightP)
    splitter.SetMinimumPaneSize(20)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(splitter, 1, wx.EXPAND)
    self.SetSizer(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16510111_41264060_16_26
16510111_41274306_48_55
Title: computing determinant of a matrix (nxn) recursively 
----------------------------------------

def det(M) :
INDENT
    X = 0
    if len(M) ! = len(M [0]) :
    INDENT
        print ('matrice non carrée')
    DEDENT
    else :
    INDENT
        if len(M) < = 2 :
        INDENT
            return M [0] [0] * M [1] [1] - M [0] [1] * M [1] [0]
        DEDENT
        else :
        INDENT
            for i in range(len(M)) :
            INDENT
                X = X + ((- 1) ** (i)) * M [0] [i] * det(submatrix(M, i))
            DEDENT
        DEDENT
    DEDENT
    return X
DEDENT
----------------------------------------

def det(self, i = 0) :
INDENT
    n = self.dim
    if n == 1 :
    INDENT
        return self [0, 0]
    DEDENT
    d = 0
    for j in range(n) :
    INDENT
        d += ((- 1) ** (i + j)) * (self [i, j]) * ((self.minor(i, j)).det())
    DEDENT
    return d
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16519400_16519633_1_12
16519400_16519826_5_13
Title: How to change list into HTML table ? (Python) 
----------------------------------------

def test2(string) :
INDENT
    bye = defaultdict(int)
    print "<table>"
    for i in hello :
    INDENT
        print "<tr>"
        bye [i] = bye [i] + 1
        print "<td>"
        print bye [i]
        print '</td>'
        print "</tr>"
        print "</table>"
        return bye
    DEDENT
DEDENT
----------------------------------------

def test2(strList) :
INDENT
    d = defaultdict(int)
    for k in strList :
    INDENT
        d [k] += 1
    DEDENT
    print ('<table>')
    for i in d.items() :
    INDENT
        print ('<tr><td>{0[0]}</td><td>{0[1]}</td></tr>'.format(i))
    DEDENT
    print ('</table>')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16535941_16536065_2_15
16535941_16538213_1_11
Title: Prime number detector failing on some numbers? 
----------------------------------------

def is_prime(x) :
INDENT
    count = 0
    if x < 0 :
    INDENT
        return False
    DEDENT
    elif x == 1 :
    INDENT
        return False
    DEDENT
    elif x == 2 :
    INDENT
        return True
    DEDENT
    for n in range(1, int(math.ceil(math.sqrt(x))) + 1) :
    INDENT
        if not x % n :
        INDENT
            count += 1
        DEDENT
        if count > 1 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def is_prime(n) :
INDENT
    i = 2
    sq_root_n = n ** 0.5
    if n < = 0 :
    INDENT
        return False
    DEDENT
    while i < sq_root_n :
    INDENT
        if n % i == 0 :
        INDENT
            return False
        DEDENT
        i += 1
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16535941_16536065_2_15
16535941_19678436_1_13
Title: Prime number detector failing on some numbers? 
----------------------------------------

def is_prime(x) :
INDENT
    count = 0
    if x < 0 :
    INDENT
        return False
    DEDENT
    elif x == 1 :
    INDENT
        return False
    DEDENT
    elif x == 2 :
    INDENT
        return True
    DEDENT
    for n in range(1, int(math.ceil(math.sqrt(x))) + 1) :
    INDENT
        if not x % n :
        INDENT
            count += 1
        DEDENT
        if count > 1 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def is_prime(x) :
INDENT
    maxdiv = x - 1
    if x < 2 :
    INDENT
        return False
    DEDENT
    elif x == 2 :
    INDENT
        return True
    DEDENT
    elif x > = 2 :
    INDENT
        for n in range(2, maxdiv) :
        INDENT
            if x % n == 0 :
            INDENT
                print '%d is not prime. I divided it by %d' % (x, n)
                return False
            DEDENT
        DEDENT
        else :
        INDENT
            return True
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16535941_16538213_1_11
16535941_19678436_1_13
Title: Prime number detector failing on some numbers? 
----------------------------------------

def is_prime(n) :
INDENT
    i = 2
    sq_root_n = n ** 0.5
    if n < = 0 :
    INDENT
        return False
    DEDENT
    while i < sq_root_n :
    INDENT
        if n % i == 0 :
        INDENT
            return False
        DEDENT
        i += 1
    DEDENT
    return True
DEDENT
----------------------------------------

def is_prime(x) :
INDENT
    maxdiv = x - 1
    if x < 2 :
    INDENT
        return False
    DEDENT
    elif x == 2 :
    INDENT
        return True
    DEDENT
    elif x > = 2 :
    INDENT
        for n in range(2, maxdiv) :
        INDENT
            if x % n == 0 :
            INDENT
                print '%d is not prime. I divided it by %d' % (x, n)
                return False
            DEDENT
        DEDENT
        else :
        INDENT
            return True
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16569255_16569338_1_10
16569255_16569395_1_12
Title: If-statement confusion 
----------------------------------------

def checklist(argument) :
INDENT
    data = [["sky", '79'],
        ["sky high", '30'],
        ["sky sky", '50'],
        ["sky high", '19']]
    ans = [x [1] for x in data if x [0] == argument]
    return ", ".join(ans) if ans else 0
DEDENT
----------------------------------------

def checklist(argument) :
INDENT
    data = {
        "sky" : ['79'],
        "sky high" : ['30', '19'],
        "sky sky" : ['50']}
    results = data.get(argument)
    if results is None :
    INDENT
        print 0
    DEDENT
    else :
    INDENT
        print ('\n'.join(results))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16569255_16569338_1_10
16569255_16569443_1_14
Title: If-statement confusion 
----------------------------------------

def checklist(argument) :
INDENT
    data = [["sky", '79'],
        ["sky high", '30'],
        ["sky sky", '50'],
        ["sky high", '19']]
    ans = [x [1] for x in data if x [0] == argument]
    return ", ".join(ans) if ans else 0
DEDENT
----------------------------------------

def checklist(argument) :
INDENT
    data = [["sky", '79'],
        ["sky high", '30'],
        ["sky sky", '50'],
        ["sky high", '19']]
    result = ''
    for row in data :
    INDENT
        if argument == row [0] :
        INDENT
            result += row [0] + ','
        DEDENT
    DEDENT
    if result :
    INDENT
        print result [: - 1]
    DEDENT
    else :
    INDENT
        print '0'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16569255_16569395_1_12
16569255_16569443_1_14
Title: If-statement confusion 
----------------------------------------

def checklist(argument) :
INDENT
    data = {
        "sky" : ['79'],
        "sky high" : ['30', '19'],
        "sky sky" : ['50']}
    results = data.get(argument)
    if results is None :
    INDENT
        print 0
    DEDENT
    else :
    INDENT
        print ('\n'.join(results))
    DEDENT
DEDENT
----------------------------------------

def checklist(argument) :
INDENT
    data = [["sky", '79'],
        ["sky high", '30'],
        ["sky sky", '50'],
        ["sky high", '19']]
    result = ''
    for row in data :
    INDENT
        if argument == row [0] :
        INDENT
            result += row [0] + ','
        DEDENT
    DEDENT
    if result :
    INDENT
        print result [: - 1]
    DEDENT
    else :
    INDENT
        print '0'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1657570_1657597_5_17
1657570_1658018_5_17
Title: Google Search from a Python App 
----------------------------------------

def showsome(searchfor) :
INDENT
    query = urllib.urlencode({'q' : searchfor})
    url = 'http://ajax.googleapis.com/ajax/services/search/web?v=1.0&%s' % query
    search_response = urllib.urlopen(url)
    search_results = search_response.read()
    results = json.loads(search_results)
    data = results ['responseData']
    print 'Total results: %s' % data ['cursor'] ['estimatedResultCount']
    hits = data ['results']
    print 'Top %d hits:' % len(hits)
    for h in hits : print ' ', h ['url']
    print 'For more results, see %s' % data ['cursor'] ['moreResultsUrl']
DEDENT
----------------------------------------

def showsome(searchfor) :
INDENT
    query = urllib.parse.urlencode({'q' : searchfor})
    url = 'http://ajax.googleapis.com/ajax/services/search/web?v=1.0&%s' % query
    search_response = urllib.request.urlopen(url)
    search_results = search_response.read().decode("utf8")
    results = json.loads(search_results)
    data = results ['responseData']
    print ('Total results: %s' % data ['cursor'] ['estimatedResultCount'])
    hits = data ['results']
    print ('Top %d hits:' % len(hits))
    for h in hits : print (' ', h ['url'])
    print ('For more results, see %s' % data ['cursor'] ['moreResultsUrl'])
DEDENT
----------------------------------------
