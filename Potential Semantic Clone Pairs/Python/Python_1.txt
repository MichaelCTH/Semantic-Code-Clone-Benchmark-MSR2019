$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11175022_11175084_1_9
11175022_11175313_1_9
Title: Can you help me with this python exercise? 
----------------------------------------

def count(list1) :
INDENT
    x = 0
    total = 0
    while x < len(list1) :
    INDENT
        total += list [x]
        print total
        x = x + 1
    DEDENT
    return total
DEDENT
----------------------------------------

def count(list1) :
INDENT
    total = 0
    old = 0
    for position, x in enumerate(list1) :
    INDENT
        total = x + old
        old = x
        print total
    DEDENT
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11175131_17177868_1_14
11175131_17376821_4_11
Title: Code for Greatest Common Divisor in Python 
----------------------------------------

def gcd(a, b) :
INDENT
    if a > b :
    INDENT
        r = a % b
        if r == 0 :
        INDENT
            return b
        DEDENT
        else :
        INDENT
            return gcd(b, r)
        DEDENT
    DEDENT
    if a < b :
    INDENT
        r = b % a
        if r == 0 :
        INDENT
            return a
        DEDENT
        else :
        INDENT
            return gcd(a, r)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def gcd(m, n) :
INDENT
    z = abs(m - n)
    if (m - n) == 0 :
    INDENT
        return n
    DEDENT
    else :
    INDENT
        return gcd(z, min(m, n))

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11218272_11219445_3_9
11218272_11219825_43_47
Title: Plone: reacting to object removal 
----------------------------------------

def redirect_to_trial(trans, obj = None, parent = None) :
INDENT
    if obj.id not in parent :
    INDENT
        request = getattr(obj, 'REQUEST', None)
        if request :
        INDENT
            trial_url = obj.__parent__.__parent__.absolute_url()
            request.response.redirect(trial_url)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def redirect_to_trial(obj, event) :
INDENT
    request = getattr(obj, 'REQUEST', None)
    if request :
    INDENT
        trial_url = obj.__parent__.__parent__.absolute_url()
        transaction.get().join(RedirectDataManager(request, trial_url))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11232230_11233293_5_17
11232230_31695996_1_13
Title: Logging to two files with different settings 
----------------------------------------

def setup_logger(name, log_file, level = logging.INFO) :
INDENT
    handler = logging.FileHandler(log_file)
    handler.setFormatter(formatter)
    logger = logging.getLogger(name)
    logger.setLevel(level)
    logger.addHandler(handler)
    return logger

DEDENT
----------------------------------------

def setup_logger(logger_name, log_file, level = logging.INFO) :
INDENT
    l = logging.getLogger(logger_name)
    formatter = logging.Formatter('%(message)s')
    fileHandler = logging.FileHandler(log_file, mode = 'w')
    fileHandler.setFormatter(formatter)
    streamHandler = logging.StreamHandler()
    streamHandler.setFormatter(formatter)
    l.setLevel(level)
    l.addHandler(fileHandler)
    l.addHandler(streamHandler)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11235944_11246045_26_36
11235944_11246045_61_75
Title: "how do i start a wxPython program with a dialogbox then pop another dialog and then make a basic canvas" 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)

    dlg = MyDlg()
    dlg.ShowModal()
    dlg.Destroy()
    self.Bind(wx.EVT_PAINT, self.OnPaint)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Example frame")

    style = wx.OK | wx.ICON_INFORMATION
    dlg = wx.MessageDialog(parent = None,
        message = "Hello from the frame's init",
        caption = "Information", style = style)
    dlg.ShowModal()
    dlg.Destroy()

    panel = MyPanel(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11235944_11246045_26_36
11235944_11246045_8_21
Title: "how do i start a wxPython program with a dialogbox then pop another dialog and then make a basic canvas" 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)

    dlg = MyDlg()
    dlg.ShowModal()
    dlg.Destroy()
    self.Bind(wx.EVT_PAINT, self.OnPaint)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Dialog.__init__(self, None, title = "I'm a dialog!")
    lbl = wx.StaticText(self, label = "Hi from the panel's init!")
    btn = wx.Button(self, id = wx.ID_OK, label = "Close me")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(lbl, 0, wx.ALL, 5)
    sizer.Add(btn, 0, wx.ALL, 5)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11235944_11246045_61_75
11235944_11246045_8_21
Title: "how do i start a wxPython program with a dialogbox then pop another dialog and then make a basic canvas" 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Example frame")

    style = wx.OK | wx.ICON_INFORMATION
    dlg = wx.MessageDialog(parent = None,
        message = "Hello from the frame's init",
        caption = "Information", style = style)
    dlg.ShowModal()
    dlg.Destroy()

    panel = MyPanel(self)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Dialog.__init__(self, None, title = "I'm a dialog!")
    lbl = wx.StaticText(self, label = "Hi from the panel's init!")
    btn = wx.Button(self, id = wx.ID_OK, label = "Close me")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(lbl, 0, wx.ALL, 5)
    sizer.Add(btn, 0, wx.ALL, 5)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1123855_5789428_14_20
1123855_5789473_24_32
Title: """select"" on multiple Python multiprocessing Queues?" 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        data = self.inq.get()
        print ("thread reads data=", data)
        result = (self.inq, data)
        self.sharedq.put(result)
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    q_run = True
    while q_run :
    INDENT
        data = self.inq.get()
        result = (self.inq, data)
        self.sharedq.put(result)
        if data is EndOfQueueMarker :
        INDENT
            q_run = False
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1123855_5789428_22_27
1123855_5789473_34_41
Title: """select"" on multiple Python multiprocessing Queues?" 
----------------------------------------

def __init__(self, list_of_queues) :
INDENT
    queue.Queue.__init__(self)
    for q in list_of_queues :
    INDENT
        qr = queue_reader(q, self)
        qr.start()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, list_of_queues) :
INDENT
    queue.Queue.__init__(self)
    self.qList = list_of_queues
    self.qrList = []
    for q in list_of_queues :
    INDENT
        qr = queue_reader(q, self)
        qr.start()
        self.qrList.append(qr)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11249966_11250205_1_15
11249966_11251597_1_13
Title: Delete a row from a text file with Python 
----------------------------------------

def DeleteToDo() :
INDENT
    print ("Which Item Do You Want To Delete?")
    DeleteItem = raw_input("><![CDATA[")
    print ("Are You Sure You Want To Delete Number" + DeleteItem + "(y/n)")
    DeleteItem = int(DeleteItem)
    VerifyDelete = str.lower(raw_input("><![CDATA["))
    if VerifyDelete == "y" :
    INDENT
        FILE = open('data.txt', "r")
        lines = [x.strip() for x in FILE if int(x [: x.index('.')]) ! = DeleteItem]
        FILE.close()
        FILE = open('data.txt', "w")
        for x in lines : FILE.write(x + '\n')
    DEDENT
    else :
    INDENT
        print ("Nothing Deleted")
    DEDENT
DEDENT
----------------------------------------

def DeleteToDo(self) :
INDENT
    print "Which Item Do You Want To Delete?"
    DeleteItem = int(raw_input("><![CDATA[")) - 1
    print "Are You Sure You Want To Delete Number" + str(DeleteItem) + "(y/n)"
    VerifyDelete = str.lower(raw_input("><![CDATA["))
    if VerifyDelete == "y" :
    INDENT
        with open(ToDo.filename, "r") as f :
        INDENT
            lines = ''.join([a for i, a in enumerate(f) if i ! = DeleteItem])
        DEDENT
        with open(ToDo.filename, "w") as f :
        INDENT
            f.write(lines)
        DEDENT
    DEDENT
    else :
    INDENT
        print "Nothing Deleted"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11282218_16056443_6_14
11282218_19749945_6_29
Title: Bottle web framework - How to stop? 
----------------------------------------

def run(self, handler) :
INDENT
    from wsgiref.simple_server import make_server, WSGIRequestHandler
    if self.quiet :
    INDENT
        class QuietHandler(WSGIRequestHandler) :
        INDENT
            def log_request(* args, ** kw) : pass
        DEDENT
        self.options ['handler_class'] = QuietHandler
    DEDENT
    self.server = make_server(self.host, self.port, handler, ** self.options)
    self.server.serve_forever()
DEDENT
----------------------------------------

def run(self, app) :
INDENT
    from wsgiref.simple_server import WSGIRequestHandler, WSGIServer
    from wsgiref.simple_server import make_server
    import socket
    class FixedHandler(WSGIRequestHandler) :
    INDENT
        def address_string(self) :
        INDENT
            return self.client_address [0]
        DEDENT
        def log_request(* args, ** kw) :
        INDENT
            if not self.quiet :
            INDENT
                return WSGIRequestHandler.log_request(* args, ** kw)
            DEDENT
        DEDENT
    DEDENT
    handler_cls = self.options.get('handler_class', FixedHandler)
    server_cls = self.options.get('server_class', WSGIServer)
    if ':' in self.host :
    INDENT
        if getattr(server_cls, 'address_family') == socket.AF_INET :
        INDENT
            class server_cls(server_cls) :
            INDENT
                address_family = socket.AF_INET6
            DEDENT
        DEDENT
    DEDENT
    srv = make_server(self.host, self.port, app, server_cls, handler_cls)
    self.srv = srv
    srv.serve_forever()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1131430_1133605_21_28
1131430_1133605_40_48
Title: Are Generators Threadsafe? 
----------------------------------------

def worker() :
INDENT
    try :
    INDENT
        for i in it :
        INDENT
            pass
        DEDENT
    DEDENT
    except Exception, e :
    INDENT
        print e
        raise
    DEDENT
DEDENT
----------------------------------------

def worker() :
INDENT
    try :
    INDENT
        while True :
        INDENT
            item = q.get()
            q.task_done()
        DEDENT
    DEDENT
    except Exception, e :
    INDENT
        print e
        raise
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1131926_1133358_10_19
1131926_1134567_10_17
Title: Chain FormEncode Validators 
----------------------------------------

def _to_python(self, value, state) :
INDENT
    try :
    INDENT
        values = str(value).split(self.delimiter)
    DEDENT
    except AttributeError :
    INDENT
        values = str(value).split(',')
    DEDENT
    returnValues = []
    emailValidator = Email()
    for value in values :
    INDENT
        returnValues.append(emailValidator._to_python(value.strip(), state))
    DEDENT
    return values
DEDENT
----------------------------------------

def _to_python(self, value, state) :
INDENT
    try :
    INDENT
        values = str(value).split(self.delimiter)
    DEDENT
    except AttributeError :
    INDENT
        values = str(value).split(',')
    DEDENT
    validator = formencode.ForEach(validators.Email())
    validator.to_python(values, state)
    return [value.strip() for value in values]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11331071_11331784_1_11
11331071_11346297_3_8
Title: Get contents by class names using Beautiful Soup 
----------------------------------------

def match_class(target) :
INDENT
    target = target.split()
    def do_match(tag) :
    INDENT
        try :
        INDENT
            classes = dict(tag.attrs) ["class"]
        DEDENT
        except KeyError :
        INDENT
            classes = ""
        DEDENT
        classes = classes.split()
        return all(c in classes for c in target)
    DEDENT
    return do_match
DEDENT
----------------------------------------

def match_class(target) :
INDENT
    def do_match(tag) :
    INDENT
        classes = tag.get('class', [])
        return all(c in classes for c in target)
    DEDENT
    return do_match
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11331440_11331466_5_10
11331440_11332360_1_12
Title: Implementation of a function 
----------------------------------------

def update_hand(word, hand) :
INDENT
    for token in word :
    INDENT
        if hand [token] == 0 :
        INDENT
            del hand [token]
        DEDENT
        else :
        INDENT
            hand [token] -= 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def update_hand(hand, word) :
INDENT
    for letter in word :
    INDENT
        count = hand.get(letter, 0)
        if count > 1 :
        INDENT

            hand [letter] = count - 1
        DEDENT
        else :
        INDENT
            del hand [letter]

        DEDENT
    DEDENT
    return hand
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11358598_11361048_3_12
11358598_11371914_3_14
Title: "Remove code duplication from RLE pattern without resorting to Haskell?" 
----------------------------------------

def rle(seq) :
INDENT
    ret = []
    sentinel = object()
    enum = enumerate(chain(seq, [sentinel]))
    start, last = next(enum)
    for i, c in enum :
    INDENT
        if c ! = last :
        INDENT
            ret.append((last, i - start))
            start, last = i, c
        DEDENT
    DEDENT
    return ret
DEDENT
----------------------------------------

def rle(xs) :
INDENT
    def g() :
    INDENT
        last = object()
        n = 0
        for x in xs :
        INDENT
            if x ! = last :
            INDENT
                yield last, n
                last = x
                n = 0
            DEDENT
            n += 1
        DEDENT
    DEDENT
    return list(g()) [1 :]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11359570_11359647_1_17
11359570_11359969_3_12
Title: Changing a file line - Python 
----------------------------------------

def test() :
INDENT
    fn = 'users.txt.txt'
    f = open(fn)
    output = []
    changeuser = 'peterpeter'
    userinfo = 'HeIsTall'
    for line in f :
    INDENT
        if line.strip().split(':') [0] ! = changeuser :
        INDENT
            output.append(line)
        DEDENT
        else :
        INDENT
            output.append(changeuser + ":" + userinfo + "\n")
        DEDENT
    DEDENT
    f.close()
    f = open(fn, 'w')
    f.writelines(output)
    f.close()
DEDENT
----------------------------------------

def test() :
INDENT
    fn = 'users.txt'
    changeuser = 'peterpeter'
    newinfo = 'HeIsTall'
    for line in fileinput.input(fn, inplace = 1) :
    INDENT
        user, oldinfo = line.split(':')
        print '%s:%s' % (user, newinfo if user == changeuser else oldinfo.replace('\n', ''))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11371309_11378241_3_21
11371309_11379721_24_35
Title: Method overloading decorator 
----------------------------------------

def overload(funcOrType, map = {}, type = None) :
INDENT
    if not inspect.isclass(funcOrType) :
    INDENT
        if (type) :
        INDENT
            map [type] = funcOrType
        DEDENT
        else :
        INDENT
            map ['default_function'] = funcOrType
        DEDENT
    DEDENT
    else :
    INDENT
        def overloadWithType(func) :
        INDENT
            return overload(func, map, funcOrType)
        DEDENT
        return overloadWithType
    DEDENT
    def doOverload(* args, ** kwargs) :
    INDENT
        for type in [t for t in map.keys() if t ! = 'default_function'] :
        INDENT
            if isinstance(args [1], type) :
            INDENT
                return map [type](* args, ** kwargs)
            DEDENT
        DEDENT
        return map ['default_function'](* args, ** kwargs)
    DEDENT
    return doOverload
DEDENT
----------------------------------------

def overload(self, * types) :
INDENT
    def wrapper(f) :
    INDENT
        for type_seq in types :
        INDENT
            if type(type_seq) == tuple :
            INDENT
                type_seq = tuple(type_seq)
            DEDENT
            else :
            INDENT
                type_seq = (type_seq,)
            DEDENT
            self.map [type_seq] = f
        DEDENT
        return self
    DEDENT
    return wrapper

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1137161_27724915_1_19
1137161_45164364_1_17
Title: What is the correct way to document a **kwargs parameter? 
----------------------------------------

def some_function(first, second = "two", ** kwargs) :
INDENT
    r"""Fetches and returns this thing

    :param first:
        The first parameter
    :type first: ``int``
    :param second:
        The second parameter
    :type second: ``str``
    :param \**kwargs:
        See below

    :Keyword Arguments:
        * *extra* (``list``) --
          Extra stuff
        * *supplement* (``dict``) --
          Additional content

    """
DEDENT
----------------------------------------

def some_function(first, second = "two", ** kwargs) :
INDENT
    """Fetches and returns this thing

    Parameters
    ----------
    first : `int`
        The first parameter
    second : `str`, optional
        The second parameter

    Other Parameters
    ----------------
    extra : `list`, optional
        Extra stuff. Default ``[]``.
    suplement : `dict`, optional
        Additional content. Default ``{'key' : 42}``.
    """
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11381315_11381456_17_24
11381315_11381476_1_15
Title: How can I end while loop and skip for loop? 
----------------------------------------

def remove() :
INDENT
    coname = raw_input('What company do you want to remove? ')
    f = open('codilist.txt')
    tmpfile = open('codilist.tmp', 'w')
    find_and_remove(f, coname, tmpfile)
    f.close()
    tmpfile.close()
    os.rename('codilist.tmp', 'codilist.txt')
DEDENT
----------------------------------------

def remove() :
INDENT
    coname = raw_input('What company do you want to remove? ')
    f = open('codilist.txt')
    tmpfile = open('codilist.tmp', 'w')
    for line in f :
    INDENT
        if coname.upper() in line :
        INDENT
            answer = get_yes_or_no('Are you sure you want to remove ' + line.upper() + '?')
        DEDENT
        else :
        INDENT
            tmpfile.write(line)
        DEDENT
    DEDENT
    else :
    INDENT
        print 'Company name is not listed.'
    DEDENT
    f.close()
    tmpfile.close()
    os.rename('codilist.tmp', 'codilist.txt')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11381315_11381456_17_24
11381315_11381490_4_28
Title: How can I end while loop and skip for loop? 
----------------------------------------

def remove() :
INDENT
    coname = raw_input('What company do you want to remove? ')
    f = open('codilist.txt')
    tmpfile = open('codilist.tmp', 'w')
    find_and_remove(f, coname, tmpfile)
    f.close()
    tmpfile.close()
    os.rename('codilist.tmp', 'codilist.txt')
DEDENT
----------------------------------------

def remove() :
INDENT
    coname = raw_input('What company do you want to remove? ')
    f = open('codilist.txt')
    tmpfile = open('codilist.tmp', 'w')
    try :
    INDENT
        for line in f :
        INDENT
            if coname.upper() in line :
            INDENT
                while True :
                INDENT
                    answer = raw_input('Are you sure you want to remove ' + line.upper() + '?')
                    if answer == 'yes' :
                    INDENT
                        print line.upper() + '...has been removed.'
                    DEDENT
                    elif answer == 'no' :
                    INDENT
                        raise Breakout()
                    DEDENT
                    else :
                    INDENT
                        print 'Please choose yes or no.'
                    DEDENT
                DEDENT
            DEDENT
            else :
            INDENT
                tmpfile.write(line)
            DEDENT
        DEDENT
        else :
        INDENT
            print 'Company name is not listed.'
        DEDENT
    DEDENT
    except Breakout :
    INDENT
        pass
    DEDENT
    f.close()
    tmpfile.close()
    os.rename('codilist.tmp', 'codilist.txt')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11381315_11381476_1_15
11381315_11381490_4_28
Title: How can I end while loop and skip for loop? 
----------------------------------------

def remove() :
INDENT
    coname = raw_input('What company do you want to remove? ')
    f = open('codilist.txt')
    tmpfile = open('codilist.tmp', 'w')
    for line in f :
    INDENT
        if coname.upper() in line :
        INDENT
            answer = get_yes_or_no('Are you sure you want to remove ' + line.upper() + '?')
        DEDENT
        else :
        INDENT
            tmpfile.write(line)
        DEDENT
    DEDENT
    else :
    INDENT
        print 'Company name is not listed.'
    DEDENT
    f.close()
    tmpfile.close()
    os.rename('codilist.tmp', 'codilist.txt')
DEDENT
----------------------------------------

def remove() :
INDENT
    coname = raw_input('What company do you want to remove? ')
    f = open('codilist.txt')
    tmpfile = open('codilist.tmp', 'w')
    try :
    INDENT
        for line in f :
        INDENT
            if coname.upper() in line :
            INDENT
                while True :
                INDENT
                    answer = raw_input('Are you sure you want to remove ' + line.upper() + '?')
                    if answer == 'yes' :
                    INDENT
                        print line.upper() + '...has been removed.'
                    DEDENT
                    elif answer == 'no' :
                    INDENT
                        raise Breakout()
                    DEDENT
                    else :
                    INDENT
                        print 'Please choose yes or no.'
                    DEDENT
                DEDENT
            DEDENT
            else :
            INDENT
                tmpfile.write(line)
            DEDENT
        DEDENT
        else :
        INDENT
            print 'Company name is not listed.'
        DEDENT
    DEDENT
    except Breakout :
    INDENT
        pass
    DEDENT
    f.close()
    tmpfile.close()
    os.rename('codilist.tmp', 'codilist.txt')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11410896_11410935_3_13
11410896_37079737_1_15
Title: Python: How json dumps None to empty string 
----------------------------------------

def scrub(x) :
INDENT
    ret = copy.deepcopy(x)
    if isinstance(x, dict) :
    INDENT
        for k, v in ret.items() :
        INDENT
            ret [k] = scrub(v)
        DEDENT
    DEDENT
    if x == None :
    INDENT
        ret = ''
    DEDENT
    return ret
DEDENT
----------------------------------------

def scrub(x) :
INDENT
    ret = copy.deepcopy(x)
    if isinstance(x, dict) :
    INDENT
        for k, v in ret.items() :
        INDENT
            ret [k] = scrub(v)
        DEDENT
    DEDENT
    if isinstance(x, (list, tuple)) :
    INDENT
        for k, v in enumerate(ret) :
        INDENT
            ret [k] = scrub(v)
        DEDENT
    DEDENT
    if x is None :
    INDENT
        ret = ''
    DEDENT
    return ret
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11414743_11627901_22_68
11414743_11628877_13_48
Title: pygame.display.update() causing periodic lag spikes 
----------------------------------------

def run_game() :
INDENT
    pygame.init()
    clock = pygame.time.Clock()
    screen = pygame.display.set_mode((500, 500))

    stars = [(randint(0, 500), randint(0, 500), randint(2, 6)) for i in range(50)]
    stars_prev = stars
    accumulator = 0
    frametime = clock.tick()
    play = True
    while play :
    INDENT
        frametime = clock.tick() / 1000
        if frametime > MAX_FRAMETIME :
        INDENT
            frametime = MAX_FRAMETIME
        DEDENT
        accumulator += frametime

        for e in pygame.event.get() :
        INDENT
            if e.type == pygame.QUIT :
            INDENT
                play = False
            DEDENT
            elif e.type == pygame.KEYDOWN :
            INDENT
                if e.key == pygame.K_ESCAPE :
                INDENT
                    play = False
                DEDENT
            DEDENT
        DEDENT
        while accumulator > = DT :
        INDENT
            stars_prev = stars [:]
            for i, (x, y, r) in enumerate(stars) :
            INDENT
                stars [i] = (x - r * 50 * DT, y, r) if x > - 20 else (520, randint(0, 500), r)
            DEDENT
            accumulator -= DT
        DEDENT
        alpha = accumulator / DT
        stars_inter = [interpolate(s1, s2, alpha) for s1, s2 in zip(stars_prev, stars)]

        screen.fill(pygame.Color('black'))

        for x, y, r in stars_inter :
        INDENT
            pygame.draw.circle(screen, pygame.Color('white'), (int(x), y), r)
        DEDENT
        pygame.display.update()
    DEDENT
DEDENT
----------------------------------------

def run_game() :
INDENT
    pygame.init()
    screen = pygame.display.set_mode((500, 500))
    pygame.time.set_timer(USEREVENT + 1, updaterate)
    def mainloop() :
    INDENT
        global lasttime
        global rectx
        global recty
        screen.fill(pygame.Color("white"))
        screen.fill(pygame.Color("red"), pygame.Rect(rectx, recty, 20, 20))
        screen.fill(pygame.Color("blue"), pygame.Rect(480 - rectx, 480 - recty, 20, 20))
        screen.fill(pygame.Color("green"), pygame.Rect(rectx, 480 - recty, 20, 20))
        screen.fill(pygame.Color("yellow"), pygame.Rect(480 - rectx, recty, 20, 20))
        rectx += 5
        if rectx > 500 :
        INDENT
            rectx = 0
            recty += 20
        DEDENT
        beforerender = time.clock()
        pygame.display.update()
        afterrender = time.clock()
        renderdelta = afterrender - beforerender
        framedelta = beforerender - lasttime
        lasttime = beforerender
        if renderdelta > 0.01 :
        INDENT
            print "render time: {0}".format(renderdelta)
            print "frame delta: {0}".format(framedelta)
            print "-------------------------------------"
        DEDENT
    DEDENT
    while (1) :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == USEREVENT + 1 :
            INDENT
                mainloop()
            DEDENT
            if event.type == QUIT :
            INDENT
                pygame.quit()
                return
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11414743_11627901_22_68
11414743_32352768_11_45
Title: pygame.display.update() causing periodic lag spikes 
----------------------------------------

def run_game() :
INDENT
    pygame.init()
    clock = pygame.time.Clock()
    screen = pygame.display.set_mode((500, 500))

    stars = [(randint(0, 500), randint(0, 500), randint(2, 6)) for i in range(50)]
    stars_prev = stars
    accumulator = 0
    frametime = clock.tick()
    play = True
    while play :
    INDENT
        frametime = clock.tick() / 1000
        if frametime > MAX_FRAMETIME :
        INDENT
            frametime = MAX_FRAMETIME
        DEDENT
        accumulator += frametime

        for e in pygame.event.get() :
        INDENT
            if e.type == pygame.QUIT :
            INDENT
                play = False
            DEDENT
            elif e.type == pygame.KEYDOWN :
            INDENT
                if e.key == pygame.K_ESCAPE :
                INDENT
                    play = False
                DEDENT
            DEDENT
        DEDENT
        while accumulator > = DT :
        INDENT
            stars_prev = stars [:]
            for i, (x, y, r) in enumerate(stars) :
            INDENT
                stars [i] = (x - r * 50 * DT, y, r) if x > - 20 else (520, randint(0, 500), r)
            DEDENT
            accumulator -= DT
        DEDENT
        alpha = accumulator / DT
        stars_inter = [interpolate(s1, s2, alpha) for s1, s2 in zip(stars_prev, stars)]

        screen.fill(pygame.Color('black'))

        for x, y, r in stars_inter :
        INDENT
            pygame.draw.circle(screen, pygame.Color('white'), (int(x), y), r)
        DEDENT
        pygame.display.update()
    DEDENT
DEDENT
----------------------------------------

def run_game() :
INDENT
    pygame.init()
    screen = pygame.display.set_mode((500, 500))
    pygame.time.set_timer(USEREVENT + 1, updaterate)
    def mainloop() :
    INDENT
        global lasttime
        global rectx
        global recty
        screen.fill(pygame.Color("white"))
        screen.fill(pygame.Color("red"), pygame.Rect(rectx, recty, 20, 20))
        screen.fill(pygame.Color("blue"), pygame.Rect(480 - rectx, 480 - recty, 20, 20))
        screen.fill(pygame.Color("green"), pygame.Rect(rectx, 480 - recty, 20, 20))
        screen.fill(pygame.Color("yellow"), pygame.Rect(480 - rectx, recty, 20, 20))
        rectx += 5
        if rectx > 500 :
        INDENT
            rectx = 0
            recty += 20
        DEDENT
        beforerender = time.clock()
        pygame.display.update()
        afterrender = time.clock()
        renderdelta = afterrender - beforerender
        framedelta = beforerender - lasttime
        lasttime = beforerender
        if renderdelta > 0.01 :
        INDENT
            print ("render time: {0}").format(renderdelta)
            print ("frame delta: {0}").format(framedelta)
            print ("-------------------------------------")
        DEDENT
    DEDENT
    while (1) :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == USEREVENT + 1 :
            INDENT
                mainloop()
            DEDENT
            if event.type == QUIT :
            INDENT
                pygame.quit()
                return
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11414743_11628877_18_40
11414743_32352768_15_38
Title: pygame.display.update() causing periodic lag spikes 
----------------------------------------

def mainloop() :
INDENT
    global lasttime
    global rectx
    global recty
    screen.fill(pygame.Color("white"))
    screen.fill(pygame.Color("red"), pygame.Rect(rectx, recty, 20, 20))
    screen.fill(pygame.Color("blue"), pygame.Rect(480 - rectx, 480 - recty, 20, 20))
    screen.fill(pygame.Color("green"), pygame.Rect(rectx, 480 - recty, 20, 20))
    screen.fill(pygame.Color("yellow"), pygame.Rect(480 - rectx, recty, 20, 20))
    rectx += 5
    if rectx > 500 :
    INDENT
        rectx = 0
        recty += 20
    DEDENT
    beforerender = time.clock()
    pygame.display.update()
    afterrender = time.clock()
    renderdelta = afterrender - beforerender
    framedelta = beforerender - lasttime
    lasttime = beforerender
    if renderdelta > 0.01 :
    INDENT
        print "render time: {0}".format(renderdelta)
        print "frame delta: {0}".format(framedelta)
        print "-------------------------------------"
    DEDENT
DEDENT
----------------------------------------

def mainloop() :
INDENT
    global lasttime
    global rectx
    global recty
    screen.fill(pygame.Color("white"))
    screen.fill(pygame.Color("red"), pygame.Rect(rectx, recty, 20, 20))
    screen.fill(pygame.Color("blue"), pygame.Rect(480 - rectx, 480 - recty, 20, 20))
    screen.fill(pygame.Color("green"), pygame.Rect(rectx, 480 - recty, 20, 20))
    screen.fill(pygame.Color("yellow"), pygame.Rect(480 - rectx, recty, 20, 20))
    rectx += 5
    if rectx > 500 :
    INDENT
        rectx = 0
        recty += 20
    DEDENT
    beforerender = time.clock()
    pygame.display.update()
    afterrender = time.clock()
    renderdelta = afterrender - beforerender
    framedelta = beforerender - lasttime
    lasttime = beforerender
    if renderdelta > 0.01 :
    INDENT
        print ("render time: {0}").format(renderdelta)
        print ("frame delta: {0}").format(framedelta)
        print ("-------------------------------------")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11444328_11453819_15_24
11444328_11453819_26_35
Title: wxpython widgets within not responding to events 
----------------------------------------

def __init__(self, parent, seed) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = wx.ID_ANY)
    self.SetBackgroundColour('green')
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.RegisterList = wx.Choicebook(self, wx.ID_ANY)
    sizer.Add(self.RegisterList, 1, wx.ALL | wx.EXPAND, 5)
    for i in range(seed) :
    INDENT
        self.RegisterList.AddPage(ChoicePanelTwo(self.RegisterList, seed * 50), str(i))
    DEDENT
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent, seed) :
INDENT
    wx.Panel.__init__(self, parent, id = wx.ID_ANY)
    self.SetBackgroundColour('cyan')
    self.Choicbook = wx.Choicebook(self, wx.ID_ANY)
    for i in range(seed) :
    INDENT
        self.Choicbook.AddPage(ChoicePanelOne(self.Choicbook, seed * 2), str(i))
    DEDENT
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.Choicbook, 1, wx.ALL | wx.EXPAND, 5)
    self.SetSizer(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11444328_11453819_15_24
11444328_11453819_4_13
Title: wxpython widgets within not responding to events 
----------------------------------------

def __init__(self, parent, seed) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = wx.ID_ANY)
    self.SetBackgroundColour('green')
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.RegisterList = wx.Choicebook(self, wx.ID_ANY)
    sizer.Add(self.RegisterList, 1, wx.ALL | wx.EXPAND, 5)
    for i in range(seed) :
    INDENT
        self.RegisterList.AddPage(ChoicePanelTwo(self.RegisterList, seed * 50), str(i))
    DEDENT
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent, seed) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = wx.ID_ANY)
    self.SetBackgroundColour('blue')
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.List = wx.ListCtrl(self, - 1, style = wx.LC_REPORT)
    for i in range(seed) :
    INDENT
        self.List.InsertStringItem(i, str(i))
    DEDENT
    sizer.Add(self.List, 1, wx.ALL | wx.EXPAND, 5)
    self.SetSizer(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11444328_11453819_26_35
11444328_11453819_4_13
Title: wxpython widgets within not responding to events 
----------------------------------------

def __init__(self, parent, seed) :
INDENT
    wx.Panel.__init__(self, parent, id = wx.ID_ANY)
    self.SetBackgroundColour('cyan')
    self.Choicbook = wx.Choicebook(self, wx.ID_ANY)
    for i in range(seed) :
    INDENT
        self.Choicbook.AddPage(ChoicePanelOne(self.Choicbook, seed * 2), str(i))
    DEDENT
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.Choicbook, 1, wx.ALL | wx.EXPAND, 5)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent, seed) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = wx.ID_ANY)
    self.SetBackgroundColour('blue')
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.List = wx.ListCtrl(self, - 1, style = wx.LC_REPORT)
    for i in range(seed) :
    INDENT
        self.List.InsertStringItem(i, str(i))
    DEDENT
    sizer.Add(self.List, 1, wx.ALL | wx.EXPAND, 5)
    self.SetSizer(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11454374_11454931_31_51
11454374_11454931_8_27
Title: wxPython and add Options Menu when select in Menu Bar 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "wx.Menu Tutorial")

    self.panel = wx.Panel(self, wx.ID_ANY)
    menuBar = wx.MenuBar()
    fileMenu = wx.Menu()
    optionsItem = fileMenu.Append(wx.NewId(), "Options",
        "Show an Options Dialog")
    self.Bind(wx.EVT_MENU, self.onOptions, optionsItem)
    exitMenuItem = fileMenu.Append(wx.NewId(), "Exit",
        "Exit the application")
    self.Bind(wx.EVT_MENU, self.onExit, exitMenuItem)
    menuBar.Append(fileMenu, "&File")
    self.SetMenuBar(menuBar)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Dialog.__init__(self, None, title = "Options")
    radio1 = wx.RadioButton(self, - 1, " Radio1 ", style = wx.RB_GROUP)
    radio2 = wx.RadioButton(self, - 1, " Radio2 ")
    radio3 = wx.RadioButton(self, - 1, " Radio3 ")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(radio1, 0, wx.ALL, 5)
    sizer.Add(radio2, 0, wx.ALL, 5)
    sizer.Add(radio3, 0, wx.ALL, 5)
    for i in range(3) :
    INDENT
        chk = wx.CheckBox(self, label = "Checkbox #%s" % (i + 1))
        sizer.Add(chk, 0, wx.ALL, 5)
    DEDENT
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1147581_1147996_5_35
1147581_1157267_4_21
Title: Scrolling through a `wx.ScrolledPanel` with the mouse wheel and arrow keys 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, * args, ** kwargs)
    main_panel = wx.Panel(self, - 1)
    main_panel.SetBackgroundColour((150, 100, 100))
    self.main_panel = main_panel
    scrolled_panel = wx.lib.scrolledpanel.ScrolledPanel(parent = main_panel, id = - 1)
    scrolled_panel.SetupScrolling()
    self.scrolled_panel = scrolled_panel
    cpanel = wx.Panel(main_panel, - 1)
    cpanel.SetBackgroundColour((100, 150, 100))
    b = wx.Button(cpanel, - 1, size = (40, 40))
    self.Bind(wx.EVT_BUTTON, self.OnClick, b)
    self.b = b
    text = "Ooga booga\n" * 50
    static_text = wx.StaticText(scrolled_panel, - 1, text)
    main_sizer = wx.BoxSizer(wx.VERTICAL)
    main_sizer.Add(scrolled_panel, 1, wx.EXPAND)
    main_sizer.Add(cpanel, 1, wx.EXPAND)
    main_panel.SetSizer(main_sizer)
    text_sizer = wx.BoxSizer(wx.VERTICAL)
    text_sizer.Add(static_text, 1, wx.EXPAND)
    scrolled_panel.SetSizer(text_sizer)
    self.main_panel.SetFocus()
    self.Show()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, * args, ** kwargs)
    self.panel = scrolled_panel = wx.lib.scrolledpanel.ScrolledPanel(parent = self, id = - 1)
    scrolled_panel.SetupScrolling()
    text = "Ooga booga\n" * 50
    static_text = wx.StaticText(scrolled_panel, - 1, text)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(static_text, wx.EXPAND, 0)
    scrolled_panel.SetSizer(sizer)
    self.Show()
    self.panel.SetFocus()
    scrolled_panel.Bind(wx.EVT_SET_FOCUS, self.onFocus)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11485636_11485820_16_49
11485636_11485989_1_14
Title: python: adding/appending dynamic keys:value pairs inside a dynamic dictionary 
----------------------------------------

def cached_execution(function, n) :
INDENT
    if function in cache.keys() :
    INDENT
        if n in cache [function].keys() :
        INDENT
            return cache [function] [n]
        DEDENT
        else :
        INDENT
            if function == 'factorial' :
            INDENT
                cache ['factorial'] [n] = factorial(n)
                return cache ['factorial'] [n]
            DEDENT
            elif function == 'square' :
            INDENT
                cache ['square'] [n] = square(n)
                return cache ['square'] [n]
            DEDENT
            elif function == 'sum' :
            INDENT
                cache ['sum'] [n] = sum(n)
                return cache ['sum'] [n]
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        cache [function] = {}
        if function == 'factorial' :
        INDENT
            cache ['factorial'] = {}
            cache ['factorial'] [n] = factorial(n)
            return cache ['factorial'] [n]
        DEDENT
        elif function == 'square' :
        INDENT
            cache ['square'] = {}
            cache ['square'] [n] = square(n)
            return cache ['square'] [n]
        DEDENT
        elif function == 'sum' :
        INDENT
            cache ['sum'] = {}
            cache ['sum'] [n] = sum(n)
            return cache ['sum'] [n]
        DEDENT
        else :
        INDENT
            cache [function] = {}
            cache [function] [n] = "Define_function"
            return cache [function] [n]

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def cached_execution(cache) :
INDENT
    def cached_exec_decorator(func) :
    INDENT
        def check_cache(x) :
        INDENT
            try :
            INDENT
                result = cache [func.__name__] [x]
            DEDENT
            except KeyError :
            INDENT
                result = func(x)
                if func.__name__ not in cache :
                INDENT
                    cache [func.__name__] = {x : result}
                DEDENT
                else :
                INDENT
                    cache [func.__name__] [x] = result
                DEDENT
            DEDENT
            return result
        DEDENT
        return check_cache
    DEDENT
    return cached_exec_decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11485636_11485820_3_8
11485636_11485886_1_7
Title: python: adding/appending dynamic keys:value pairs inside a dynamic dictionary 
----------------------------------------

def factorial(n) :
INDENT
    result = 1
    for i in range(2, n + 1) :
    INDENT
        result += 1
    DEDENT
    return result
DEDENT
----------------------------------------

def factorial(x) :
INDENT
    result = 1
    for i in range(2, x + 1) :
    INDENT
        result *= i
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11491835_11491914_2_13
11491835_11491919_1_16
Title: get nth line of string in python 
----------------------------------------

def getLine(data, line_no) :
INDENT
    buffer = io.StringIO(data)
    for i in range(line_no - 1) :
    INDENT
        try :
        INDENT
            next(buffer)
        DEDENT
        except StopIteration :
        INDENT
            return ''
        DEDENT
    DEDENT
    try :
    INDENT
        return next(buffer)
    DEDENT
    except StopIteration :
    INDENT
        return ''
    DEDENT
DEDENT
----------------------------------------

def getLine(data, line_no) :
INDENT
    n = 0
    lastPos = - 1
    for i in range(0, len(data) - 1) :
    INDENT
        if data [i] == "\n" :
        INDENT
            n = n + 1
            if n == line_no :
            INDENT
                return data [lastPos + 1 : i]
            DEDENT
            else :
            INDENT
                lastPos = i;
            DEDENT
        DEDENT
    DEDENT
    if (n == line_no - 1) :
    INDENT
        return data [lastPos + 1 :]
    DEDENT
    return ""
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11493068_11505857_28_56
11493068_11546224_32_51
Title: Information is not written to text file from twitter in python 2.7 
----------------------------------------

def on_status(self, status) :
INDENT
    try :
    INDENT
        print '\nStatus : %s' % (status.text)
        print '\nAuthor : %s' % (status.author.screen_name)
        print '\nDate/Time : %s' % (status.created_at)
        print '\nSource : %s' % (status.source)
        print '\nGeo : %s' % (status.geo)
        print '\n\n\n-----------------------------------------------------------------------------\n\n\n'
        l1 = '\nStatus : %s' % (status.text)
        l2 = '\nAuthor : %s' % (status.author.screen_name)
        l3 = '\nDate/Time : %s' % (status.created_at)
        l4 = '\nSource : %s' % (status.source)
        l5 = '\nGeo : %s' % (status.geo)
        l6 = '\n\n\n-----------------------------------------------------------------------------\n\n\n'
        target.write(l1)
        target.write(l2)
        target.write(l3)
        target.write(l4)
        target.write(l5)
        target.write(l6)
    DEDENT
    except UnicodeDecodeError :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def on_status(self, status) :
INDENT
    try :
    INDENT
        msg = OUT_STR % {
            'text' : status.text,
            'author' : status.author.screen_name,
            'date' : status.created_at,
            'source' : status.source,
            'geo' : status.geo,
            }
        print msg
        self.target.write(msg)

    DEDENT
    except UnicodeDecodeError :
    INDENT
        print "Record Skipped"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11493068_11505857_70_84
11493068_11546224_59_77
Title: Information is not written to text file from twitter in python 2.7 
----------------------------------------

def main() :
INDENT
    username = raw_input('Twitter username: ')
    password = getpass('Twitter password: ')
    stock = raw_input('Name of Stocks(comma seperated): ')
    stock_list = [u for u in stock.split(',')]

    stream = tweepy.Stream(username, password, StockTweetListener(target), timeout = None)
    stream.filter(None, stock_list)

DEDENT
----------------------------------------

def main() :
INDENT
    username = raw_input('Twitter username: ')
    password = getpass('Twitter password: ')
    stock = raw_input('Name of Stocks(comma seperated): ')
    stock_list = [u for u in stock.split(',')]
    follow_list = None

    with open('results.txt', 'w') as f :
    INDENT
        while True :
        INDENT
            stream = tweepy.Stream(
                username, password,
                StockTweetListener(f),
                timeout = None)
            stream.filter(follow_list, stock_list)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1150332_1150408_4_11
1150332_3318747_11_15
Title: Source interface with Python and urllib2 
----------------------------------------

def connect(self) :
INDENT
    self.sock = socket.socket()
    self.sock.bind((self.source_ip, 0))
    if isinstance(self.timeout, float) :
    INDENT
        self.sock.settimeout(self.timeout)
    DEDENT
    self.sock.connect((self.host, self.port))
DEDENT
----------------------------------------

def connect(self, * args, ** kwargs) :
INDENT
    if self.family == socket.AF_INET :
    INDENT
        if self.getsockname() [0] == "0.0.0.0" and _ip_address :
        INDENT
            self.bind((_ip_address, 0))
        DEDENT
    DEDENT
    s.connect(self, * args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11528682_11529199_1_23
11528682_11530579_6_41
Title: "In python how can I count the times a condition is met within a function?" 
----------------------------------------

def isInScreen(w, t) :
INDENT
    leftBound = - w.window_width() / 2
    rightBound = w.window_width() / 2
    topBound = w.window_height() / 2
    bottomBound = - w.window_height() / 2
    turtleX = t.xcor()
    turtleY = t.ycor()

    stillIn = True
    if turtleX > rightBound or turtleX < leftBound :
    INDENT
        t.dot()
        t.right(180)
        t.forward(50)
        isInScreen.outs += 1
        print (isInScreen.outs)
        return isInScreen.outs

    DEDENT
DEDENT
----------------------------------------

def isInScreen(self, w, t) :
INDENT
    leftBound = - w.window_width() / 2
    rightBound = w.window_width() / 2
    topBound = w.window_height() / 2
    bottomBound = - w.window_height() / 2
    turtleX = t.xcor()
    turtleY = t.ycor()
    stillIn = True
    if turtleX > rightBound or turtleX < leftBound :
    INDENT
        t.dot()
        t.right(180)
        t.forward(50)
        self.outs += 1
        print (self.outs)
        return outs
    DEDENT
    if turtleY > topBound or turtleY < bottomBound :
    INDENT
        t.dot()
        t.right(180)
        t.forward(50)
        self.outs += 1
        print (self.outs)
        return outs
    DEDENT
    if self.outs == 4 :
    INDENT
        stillIn = False

    DEDENT
    return stillIn
    return outs

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11531567_11533427_10_28
11531567_11533427_30_63
Title: Trouble with scrolling through several panels in wxpython 
----------------------------------------

def __init__(self, parent, color = 'black') :
INDENT
    wx.Panel.__init__(self, parent, size = (800, 100))

    self.SetMinSize((800, 100))
    self.SetBackgroundColour(color)
    widget1 = wx.TextCtrl(self, style = wx.TE_MULTILINE)
    widget2 = wx.TextCtrl(self, style = wx.TE_MULTILINE)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(widget1, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(widget2, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, size = (800, 800))

    panel0 = Panel(self, 'black')
    panel1 = Panel(self, 'red')
    panel2 = Panel(self, 'green')
    panel3 = Panel(self, 'blue')
    panel4 = Panel(self, 'white')
    panel5 = Panel(self, 'purple')
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(panel0, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel1, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel2, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel3, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel4, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel5, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11531567_11533427_10_28
11531567_11533427_65_79
Title: Trouble with scrolling through several panels in wxpython 
----------------------------------------

def __init__(self, parent, color = 'black') :
INDENT
    wx.Panel.__init__(self, parent, size = (800, 100))

    self.SetMinSize((800, 100))
    self.SetBackgroundColour(color)
    widget1 = wx.TextCtrl(self, style = wx.TE_MULTILINE)
    widget2 = wx.TextCtrl(self, style = wx.TE_MULTILINE)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(widget1, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(widget2, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    scrolled.ScrolledPanel.__init__(self, parent, size = (400, 400))

    bigpanel = BigPanel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(bigpanel, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)
    self.SetAutoLayout(1)
    self.SetupScrolling()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11531567_11533427_10_28
11531567_11533427_81_92
Title: Trouble with scrolling through several panels in wxpython 
----------------------------------------

def __init__(self, parent, color = 'black') :
INDENT
    wx.Panel.__init__(self, parent, size = (800, 100))

    self.SetMinSize((800, 100))
    self.SetBackgroundColour(color)
    widget1 = wx.TextCtrl(self, style = wx.TE_MULTILINE)
    widget2 = wx.TextCtrl(self, style = wx.TE_MULTILINE)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(widget1, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(widget2, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, parent = wx.GetApp().GetTopWindow(),
        title = 'Trouble with scrolling through several panels in wxpython',
        size = (500, 400))
    scroll = ScrolledPanel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(scroll, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11531567_11533427_30_63
11531567_11533427_65_79
Title: Trouble with scrolling through several panels in wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, size = (800, 800))

    panel0 = Panel(self, 'black')
    panel1 = Panel(self, 'red')
    panel2 = Panel(self, 'green')
    panel3 = Panel(self, 'blue')
    panel4 = Panel(self, 'white')
    panel5 = Panel(self, 'purple')
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(panel0, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel1, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel2, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel3, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel4, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel5, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    scrolled.ScrolledPanel.__init__(self, parent, size = (400, 400))

    bigpanel = BigPanel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(bigpanel, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)
    self.SetAutoLayout(1)
    self.SetupScrolling()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11531567_11533427_30_63
11531567_11533427_81_92
Title: Trouble with scrolling through several panels in wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, size = (800, 800))

    panel0 = Panel(self, 'black')
    panel1 = Panel(self, 'red')
    panel2 = Panel(self, 'green')
    panel3 = Panel(self, 'blue')
    panel4 = Panel(self, 'white')
    panel5 = Panel(self, 'purple')
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(panel0, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel1, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel2, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel3, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel4, 1, wx.ALL | wx.EXPAND, 15)
    sizer.Add(panel5, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, parent = wx.GetApp().GetTopWindow(),
        title = 'Trouble with scrolling through several panels in wxpython',
        size = (500, 400))
    scroll = ScrolledPanel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(scroll, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11531567_11533427_65_79
11531567_11533427_81_92
Title: Trouble with scrolling through several panels in wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    scrolled.ScrolledPanel.__init__(self, parent, size = (400, 400))

    bigpanel = BigPanel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(bigpanel, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)
    self.SetAutoLayout(1)
    self.SetupScrolling()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, parent = wx.GetApp().GetTopWindow(),
        title = 'Trouble with scrolling through several panels in wxpython',
        size = (500, 400))
    scroll = ScrolledPanel(self)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(scroll, 1, wx.ALL | wx.EXPAND, 15)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11548682_11549600_15_21
11548682_11549600_32_39
Title: twisted get body of POST request 
----------------------------------------

def dataReceived(self, bytes) :
INDENT
    if self.remaining :
    INDENT
        display = bytes [: self.remaining]
        print 'Some data received:'
        print display
        self.remaining -= len(display)
    DEDENT
DEDENT
----------------------------------------

def dataReceived(self, bytes) :
INDENT
    if self.remaining :
    INDENT
        display = bytes [: self.remaining]
        self.outfile.write(display)
        self.remaining -= len(display)
    DEDENT
    else :
    INDENT
        self.outfile.close()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11557241_11564323_1_24
11557241_11564769_1_18
Title: Python: sorting a dependency list 
----------------------------------------

def topological_sort(source) :
INDENT
    pending = [(name, set(deps)) for name, deps in source]
    emitted = []
    while pending :
    INDENT
        next_pending = []
        next_emitted = []
        for entry in pending :
        INDENT
            name, deps = entry
            deps.difference_update(emitted)
            if deps :
            INDENT
                next_pending.append(entry)
            DEDENT
            else :
            INDENT
                yield name
                emitted.append(name)
                next_emitted.append(name)
            DEDENT
        DEDENT
        if not next_emitted :
        INDENT
            raise ValueError("cyclic or missing dependancy detected: %r" % (next_pending,))
        DEDENT
        pending = next_pending
        emitted = next_emitted
    DEDENT
DEDENT
----------------------------------------

def topological_sort(items) :
INDENT
    provided = set()
    while items :
    INDENT
        remaining_items = []
        emitted = False
        for item, dependencies in items :
        INDENT
            if dependencies.issubset(provided) :
            INDENT
                yield item
                provided.add(item)
                emitted = True
            DEDENT
            else :
            INDENT
                remaining_items.append((item, dependencies))
            DEDENT
        DEDENT
        if not emitted :
        INDENT
            raise TopologicalSortFailure()
        DEDENT
        items = remaining_items
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11557241_11564323_1_24
11557241_35018138_1_29
Title: Python: sorting a dependency list 
----------------------------------------

def topological_sort(source) :
INDENT
    pending = [(name, set(deps)) for name, deps in source]
    emitted = []
    while pending :
    INDENT
        next_pending = []
        next_emitted = []
        for entry in pending :
        INDENT
            name, deps = entry
            deps.difference_update(emitted)
            if deps :
            INDENT
                next_pending.append(entry)
            DEDENT
            else :
            INDENT
                yield name
                emitted.append(name)
                next_emitted.append(name)
            DEDENT
        DEDENT
        if not next_emitted :
        INDENT
            raise ValueError("cyclic or missing dependancy detected: %r" % (next_pending,))
        DEDENT
        pending = next_pending
        emitted = next_emitted
    DEDENT
DEDENT
----------------------------------------

def topological_sort(items) :
INDENT
    provided = set()
    while items :
    INDENT
        remaining_items = []
        emitted = False
        for item, dependencies in items :
        INDENT
            if provided.issuperset(dependencies) :
            INDENT
                yield item
                provided.add(item)
                emitted = True
            DEDENT
            else :
            INDENT
                remaining_items.append((item, dependencies))
            DEDENT
        DEDENT
        if not emitted :
        INDENT
            raise TopologicalSortFailure()
        DEDENT
        items = remaining_items
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11567164_11567265_1_15
11567164_11568786_1_17
Title: Yield Only Once Per Iteration 
----------------------------------------

def type_convert(data) :
INDENT
    for item in data :
    INDENT
        try :
        INDENT
            yield int(item)
            continue
        DEDENT
        except (ValueError, TypeError) as WrongTypeError :
        INDENT
            pass
        DEDENT
        try :
        INDENT
            yield float(item)
            continue
        DEDENT
        except (ValueError, TypeError) as WrongTypeError :
        INDENT
            pass
        DEDENT
        yield item

    DEDENT
DEDENT
----------------------------------------

def type_convert(* args) :
INDENT
    datatypes = []
    for arg in args :
    INDENT
        if type(arg) == type(type) :
        INDENT
            datatypes += [arg]
        DEDENT
        else :
        INDENT
            data = arg
        DEDENT
    DEDENT
    for item in data :
    INDENT
        for datatype in datatypes :
        INDENT
            try :
            INDENT
                yield datatype(item)
                break
            DEDENT
            except (ValueError, TypeError) as WrongTypeError :
            INDENT
                pass
            DEDENT
        DEDENT
        else :
        INDENT
            yield item
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11567164_11567353_1_13
11567164_11568786_1_17
Title: Yield Only Once Per Iteration 
----------------------------------------

def type_convert(data) :
INDENT
    for item in data :
    INDENT
        try :
        INDENT
            yield int(item)
            continue
        DEDENT
        except (ValueError, TypeError) as WrongTypeError :
        INDENT
            pass
        DEDENT
        try :
        INDENT
            yield float(item)
            continue
        DEDENT
        except (ValueError, TypeError) as WrongTypeError :
        INDENT
            pass
        DEDENT
        yield item
    DEDENT
DEDENT
----------------------------------------

def type_convert(* args) :
INDENT
    datatypes = []
    for arg in args :
    INDENT
        if type(arg) == type(type) :
        INDENT
            datatypes += [arg]
        DEDENT
        else :
        INDENT
            data = arg
        DEDENT
    DEDENT
    for item in data :
    INDENT
        for datatype in datatypes :
        INDENT
            try :
            INDENT
                yield datatype(item)
                break
            DEDENT
            except (ValueError, TypeError) as WrongTypeError :
            INDENT
                pass
            DEDENT
        DEDENT
        else :
        INDENT
            yield item
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11588289_11588427_1_15
11588289_11593950_23_30
Title: python late binding - dynamically put locals in scope 
----------------------------------------

def m_chain(* fns, ** kwargs) :
INDENT
    def bind(v, f) :
    INDENT
        return f(v),
    DEDENT
    def unit(v) :
    INDENT
        return v
    DEDENT
    if "monad" in kwargs :
    INDENT
        monad = kwargs ["monad"]
        bind = monad.get("bind", bind)
        unit = monad.get("unit", unit)
    DEDENT
    def m_chain_link(chain_expr, step) :
    INDENT
        return lambda v : bind(chain_expr(v), step)
    DEDENT
    return reduce(m_chain_link, fns, unit)
DEDENT
----------------------------------------

def m_chain(* fns) :
INDENT
    def m_chain_link(chain_expr, step) :
    INDENT
        return lambda v : bind(chain_expr(v), step)
    DEDENT
    return reduce(m_chain_link, fns, unit)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11588289_11588427_1_15
11588289_11608694_35_41
Title: python late binding - dynamically put locals in scope 
----------------------------------------

def m_chain(* fns, ** kwargs) :
INDENT
    def bind(v, f) :
    INDENT
        return f(v),
    DEDENT
    def unit(v) :
    INDENT
        return v
    DEDENT
    if "monad" in kwargs :
    INDENT
        monad = kwargs ["monad"]
        bind = monad.get("bind", bind)
        unit = monad.get("unit", unit)
    DEDENT
    def m_chain_link(chain_expr, step) :
    INDENT
        return lambda v : bind(chain_expr(v), step)
    DEDENT
    return reduce(m_chain_link, fns, unit)
DEDENT
----------------------------------------

def m_chain(* fns, ** kwargs) :
INDENT
    m = kwargs.get("m", m_identity)
    def m_chain_link(chain_expr, step) :
    INDENT
        return lambda v : m.bind(chain_expr(v), step)
    DEDENT
    return reduce(m_chain_link, fns, m.unit)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11588289_11593950_23_30
11588289_11608694_35_41
Title: python late binding - dynamically put locals in scope 
----------------------------------------

def m_chain(* fns) :
INDENT
    def m_chain_link(chain_expr, step) :
    INDENT
        return lambda v : bind(chain_expr(v), step)
    DEDENT
    return reduce(m_chain_link, fns, unit)

DEDENT
----------------------------------------

def m_chain(* fns, ** kwargs) :
INDENT
    m = kwargs.get("m", m_identity)
    def m_chain_link(chain_expr, step) :
    INDENT
        return lambda v : m.bind(chain_expr(v), step)
    DEDENT
    return reduce(m_chain_link, fns, m.unit)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1163429_1163532_1_14
1163429_1164783_1_11
Title: Non-recursive means of printing a list in Python 
----------------------------------------

def print_list(the_list, indent_level = 0) :
INDENT
    stack = [iter(the_list)]
    while stack :
    INDENT
        try :
        INDENT
            item = stack [- 1].next()
        DEDENT
        except StopIteration :
        INDENT
            stack.pop()
            indent_level -= 1
            continue
        DEDENT
        if isinstance(item, list) :
        INDENT
            indent_level += 1
            stack.append(iter(item))
        DEDENT
        else :
        INDENT
            print "\t" * indent_level, item
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def print_list(the_list) :
INDENT
    stack = [iter(the_list)]
    while stack :
    INDENT
        for item in stack [- 1] :
        INDENT
            if isinstance(item, (list, tuple)) :
            INDENT
                stack.append(iter(item))
                break
            DEDENT
            else :
            INDENT
                print '\t' * (len(stack) - 1), item
            DEDENT
        DEDENT
        else :
        INDENT
            stack.pop()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11659591_11659625_1_12
11659591_11659668_1_13
Title: Python: Simple Loop program 
----------------------------------------

def Lottery(Cash = 200) :
INDENT
    YourNumber = randint(1, 10)
    while YourNumber ! = WinningNumber :
    INDENT
        Cash = Cash - 10
        if Cash < 0 :
        INDENT
            print ("You are out of money!")
            break
        DEDENT
        YourNumber = randint(1, 10)
    DEDENT
    else :
    INDENT
        Cash = Cash + 100
        Lottery(Cash)
    DEDENT
DEDENT
----------------------------------------

def Lottery() :
INDENT
    Cash = 200
    YourNumber = randint(1, 10)
    while 1 :
    INDENT
        if YourNumber ! = WinningNumber :
        INDENT
            Cash = Cash - 10
            if Cash < = 0 :
            INDENT
                print ("You are out of money!")
                break
            DEDENT
            YourNumber = randint(1, 10)
        DEDENT
        else :
        INDENT
            Cash = Cash + 100
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11659988_11660234_5_10
11659988_11660717_3_9
Title: Replacing macro-style class method with a decorator? 
----------------------------------------

def wrapped() :
INDENT
    res = None
    with PDFMineWrapper(pdf_doc, passwd) as doc :
    INDENT
        res = f()
    DEDENT
    return res
    return wrapper
DEDENT
----------------------------------------

def wrapped(self, * args) :
INDENT
    print "wrapper(): Calling %s with" % fn, args
    result = None
    with PDFMinerWrapper(self.pdf_doc) as doc :
    INDENT
        if doc.is_extractable :
        INDENT
            result = fn(self, doc, * args)
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11677499_11749847_24_56
11677499_11749847_8_22
Title: "PySide Qt: Auto vertical growth for TextEdit Widget and spacing between widgets in a vertical layout" 
----------------------------------------

def __init__(self) :
INDENT
    Qt.QFrame.__init__(self)
    layout = Qt.QHBoxLayout()
    layout.setMargin(10)
    self.te = Qt.QLabel()
    self.te.setStyleSheet("QLabel { background : rgb(245,245,245) }")
    self.te.setFrameStyle(Qt.QFrame.Panel | Qt.QFrame.Sunken)
    self.te.setLineWidth(1)
    self._post_meta = PostMeta()
    layout.addWidget(self._post_meta)
    vline = Qt.QFrame()
    vline.setFrameShape(Qt.QFrame.VLine)
    layout.addWidget(vline)
    layout.addWidget(self.te)
    self.te.setText(
        """            line one
            line two
            line three
            line four
            line five
            line six
            line seven
            line eight
            line nine
            line ten
            line eleven
            line twelve
            line thirteen""")
    self.setLayout(layout)
    self.setFrameStyle(Qt.QFrame.Box)
    self.setLineWidth(2)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Qt.QWidget.__init__(self)
    self._posted_by_label = Qt.QLabel()
    self._posted_at_label = Qt.QLabel()
    layout = Qt.QVBoxLayout()
    layout.setMargin(0)
    layout.setSpacing(5)
    layout.addWidget(self._posted_by_label)
    layout.addWidget(self._posted_at_label)
    layout.addStretch()
    self.setLayout(layout)
    self._posted_by_label.setText(PostMeta.posted_by_base_text)
    self._posted_at_label.setText(PostMeta.posted_at_base_text)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11677499_11749847_24_56
11677499_11764475_3_26
Title: "PySide Qt: Auto vertical growth for TextEdit Widget and spacing between widgets in a vertical layout" 
----------------------------------------

def __init__(self) :
INDENT
    Qt.QFrame.__init__(self)
    layout = Qt.QHBoxLayout()
    layout.setMargin(10)
    self.te = Qt.QLabel()
    self.te.setStyleSheet("QLabel { background : rgb(245,245,245) }")
    self.te.setFrameStyle(Qt.QFrame.Panel | Qt.QFrame.Sunken)
    self.te.setLineWidth(1)
    self._post_meta = PostMeta()
    layout.addWidget(self._post_meta)
    vline = Qt.QFrame()
    vline.setFrameShape(Qt.QFrame.VLine)
    layout.addWidget(vline)
    layout.addWidget(self.te)
    self.te.setText(
        """            line one
            line two
            line three
            line four
            line five
            line six
            line seven
            line eight
            line nine
            line ten
            line eleven
            line twelve
            line thirteen""")
    self.setLayout(layout)
    self.setFrameStyle(Qt.QFrame.Box)
    self.setLineWidth(2)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.resize(600, 400)
    self.mainLayout = QtGui.QVBoxLayout(self)
    self.mainLayout.setMargin(10)
    self.scroll = QtGui.QScrollArea()
    self.scroll.setWidgetResizable(True)
    self.scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
    self.mainLayout.addWidget(self.scroll)
    scrollContents = QtGui.QWidget()
    self.scroll.setWidget(scrollContents)
    self.textLayout = QtGui.QVBoxLayout(scrollContents)
    self.textLayout.setMargin(10)
    for _ in xrange(5) :
    INDENT
        text = GrowingTextEdit()
        text.setMinimumHeight(50)
        self.textLayout.addWidget(text)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11677499_11749847_8_22
11677499_11764475_3_26
Title: "PySide Qt: Auto vertical growth for TextEdit Widget and spacing between widgets in a vertical layout" 
----------------------------------------

def __init__(self) :
INDENT
    Qt.QWidget.__init__(self)
    self._posted_by_label = Qt.QLabel()
    self._posted_at_label = Qt.QLabel()
    layout = Qt.QVBoxLayout()
    layout.setMargin(0)
    layout.setSpacing(5)
    layout.addWidget(self._posted_by_label)
    layout.addWidget(self._posted_at_label)
    layout.addStretch()
    self.setLayout(layout)
    self._posted_by_label.setText(PostMeta.posted_by_base_text)
    self._posted_at_label.setText(PostMeta.posted_at_base_text)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.resize(600, 400)
    self.mainLayout = QtGui.QVBoxLayout(self)
    self.mainLayout.setMargin(10)
    self.scroll = QtGui.QScrollArea()
    self.scroll.setWidgetResizable(True)
    self.scroll.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOn)
    self.mainLayout.addWidget(self.scroll)
    scrollContents = QtGui.QWidget()
    self.scroll.setWidget(scrollContents)
    self.textLayout = QtGui.QVBoxLayout(scrollContents)
    self.textLayout.setMargin(10)
    for _ in xrange(5) :
    INDENT
        text = GrowingTextEdit()
        text.setMinimumHeight(50)
        self.textLayout.addWidget(text)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11679855_11679968_3_10
11679855_19890945_3_12
Title: introducing mutations in a DNA string in python 
----------------------------------------

def mismatch(word, letters, num_mismatches) :
INDENT
    for locs in itertools.combinations(range(len(word)), num_mismatches) :
    INDENT
        this_word = [[char] for char in word]
        for loc in locs :
        INDENT
            orig_char = word [loc]
            this_word [loc] = [l for l in letters if l ! = orig_char]
        DEDENT
        for poss in itertools.product(* this_word) :
        INDENT
            yield ''.join(poss)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def mismatch(word, i = 2) :
INDENT
    for d in range(i + 1) :
    INDENT
        for locs in combinations(range(len(word)), d) :
        INDENT
            thisWord = [[char] for char in word]
            for loc in locs :
            INDENT
                origChar = word [loc]
                thisWord [loc] = [l for l in "ACGT" if l ! = origChar]
            DEDENT
            for poss in product(* thisWord) :
            INDENT
                yield "".join(poss)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11709366_11709380_1_8
11709366_11710415_1_8
Title: Can a def function break a while loop? 
----------------------------------------

def CardsAssignment() :
INDENT
    Cards += 1
    print (Cards)
    if want_to_break_while_loop :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        return True
    DEDENT
DEDENT
----------------------------------------

def CardsAssignment() :
INDENT
    global Cards
    while True :
    INDENT
        Cards += 1
        print (Cards)
        yield not time_to_quit
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11709366_11709405_1_8
11709366_11710415_1_8
Title: Can a def function break a while loop? 
----------------------------------------

def CardsAssignment() :
INDENT
    Cards += 1
    print (Cards)
    if (break_it) :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        return True
    DEDENT
DEDENT
----------------------------------------

def CardsAssignment() :
INDENT
    global Cards
    while True :
    INDENT
        Cards += 1
        print (Cards)
        yield not time_to_quit
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11731136_16358316_5_10
11731136_36944992_4_9
Title: Python class method decorator with self arguments? 
----------------------------------------

def wrapper(f) :
INDENT
    @ wraps(f)
    def wrapped(self, * f_args, ** f_kwargs) :
    INDENT
        if callable(_lambda) and search(pattern, (_lambda(self) or '')) :
        INDENT
            f(self, * f_args, ** f_kwargs)
        DEDENT
    DEDENT
    return wrapped
DEDENT
----------------------------------------

def wrapper(method) :
INDENT
    @ wraps(method)
    def _impl(self, * method_args, ** method_kwargs) :
    INDENT
        return method(self, * method_args, ** method_kwargs) + "!"
    DEDENT
    return _impl
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11751836_11765220_50_63
11751836_11765220_6_48
Title: Drag file from list to desktop python 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, - 1, title)
    panel = wx.Panel(self)
    p1 = MyListCtrl(panel, - 1)
    p1.Bind(wx.EVT_LIST_BEGIN_DRAG, self.onDrag)
    sizer = wx.BoxSizer()
    sizer.Add(p1, 1, wx.EXPAND)
    panel.SetSizer(sizer)
    self.Center()
    self.Show(True)

DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.ListCtrl.__init__(self, parent, id, style = wx.LC_REPORT)
    files = os.listdir('.')
    self.InsertColumn(0, 'Name')
    self.InsertColumn(1, 'Ext')
    self.InsertColumn(2, 'Size', wx.LIST_FORMAT_RIGHT)
    self.InsertColumn(3, 'Modified')
    self.SetColumnWidth(0, 220)
    self.SetColumnWidth(1, 70)
    self.SetColumnWidth(2, 100)
    self.SetColumnWidth(3, 420)
    j = 0
    for i in files :
    INDENT
        (name, ext) = os.path.splitext(i)
        ex = ext [1 :]
        size = os.path.getsize(i)
        sec = os.path.getmtime(i)
        self.InsertStringItem(j, "%s%s" % (name, ext))
        self.SetStringItem(j, 1, ex)
        self.SetStringItem(j, 2, str(size) + ' B')
        self.SetStringItem(j, 3, time.strftime('%Y-%m-%d %H:%M',
                time.localtime(sec)))
        if os.path.isdir(i) :
        INDENT
            self.SetItemImage(j, 1)
        DEDENT
        elif ex == 'py' :
        INDENT
            self.SetItemImage(j, 2)
        DEDENT
        elif ex == 'jpg' :
        INDENT
            self.SetItemImage(j, 3)
        DEDENT
        elif ex == 'pdf' :
        INDENT
            self.SetItemImage(j, 4)
        DEDENT
        else :
        INDENT
            self.SetItemImage(j, 0)
        DEDENT
        if (j % 2) == 0 :
        INDENT
            self.SetItemBackgroundColour(j, '#e6f1f5')
        DEDENT
        j = j + 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11752898_19554779_19_28
11752898_22951787_70_124
Title: Threaded FFT in Enthought Python 
----------------------------------------

def ifft2(a) :
INDENT
    Desc_Handle = c_void_p(0)
    dims = (c_int * 2)(* a.shape)
    mkl.DftiCreateDescriptor(byref(Desc_Handle), DFTI_DOUBLE, DFTI_COMPLEX, 2, dims)
    mkl.DftiCommitDescriptor(Desc_Handle)
    mkl.DftiComputeBackward(Desc_Handle, a.ctypes.data_as(c_void_p))
    mkl.DftiFreeDescriptor(byref(Desc_Handle))
    return a
DEDENT
----------------------------------------

def ifft2(a, out = None) :
INDENT
    assert a.dtype == _np.complex128
    assert len(a.shape) == 2
    inplace = False
    if out is a :
    INDENT
        inplace = True
    DEDENT
    elif out is not None :
    INDENT
        assert out.dtype == _np.complex128
        assert a.shape == out.shape
        assert not _np.may_share_memory(a, out)
    DEDENT
    else :
    INDENT
        out = _np.empty_like(a)
    DEDENT
    Desc_Handle = _ctypes.c_void_p(0)
    dims = (_ctypes.c_int * 2)(* a.shape)
    mkl.DftiCreateDescriptor(_ctypes.byref(Desc_Handle), _DFTI_DOUBLE, _DFTI_COMPLEX, _ctypes.c_int(2), dims)

    if not a.flags ['C_CONTIGUOUS'] :
    INDENT
        in_strides = (_ctypes.c_int * 3)(0, a.strides [0] / 16, a.strides [1] / 16)
        mkl.DftiSetValue(Desc_Handle, _DFTI_INPUT_STRIDES, _ctypes.byref(in_strides))
    DEDENT
    if inplace :
    INDENT

        mkl.DftiCommitDescriptor(Desc_Handle)
        mkl.DftiComputeBackward(Desc_Handle, a.ctypes.data_as(_ctypes.c_void_p))
    DEDENT
    else :
    INDENT

        mkl.DftiSetValue(Desc_Handle, _DFTI_PLACEMENT, _DFTI_NOT_INPLACE)

        if not out.flags ['C_CONTIGUOUS'] :
        INDENT
            out_strides = (_ctypes.c_int * 3)(0, out.strides [0] / 16, out.strides [1] / 16)
            mkl.DftiSetValue(Desc_Handle, _DFTI_OUTPUT_STRIDES, _ctypes.byref(out_strides))
        DEDENT
        mkl.DftiCommitDescriptor(Desc_Handle)
        mkl.DftiComputeBackward(Desc_Handle, a.ctypes.data_as(_ctypes.c_void_p), out.ctypes.data_as(_ctypes.c_void_p))
    DEDENT
    mkl.DftiFreeDescriptor(_ctypes.byref(Desc_Handle))
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11752898_19554779_8_18
11752898_22951787_14_69
Title: Threaded FFT in Enthought Python 
----------------------------------------

def fft2(a) :
INDENT
    Desc_Handle = c_void_p(0)
    dims = (c_int * 2)(* a.shape)
    mkl.DftiCreateDescriptor(byref(Desc_Handle), DFTI_DOUBLE, DFTI_COMPLEX, 2, dims)
    mkl.DftiCommitDescriptor(Desc_Handle)
    mkl.DftiComputeForward(Desc_Handle, a.ctypes.data_as(c_void_p))
    mkl.DftiFreeDescriptor(byref(Desc_Handle))
    return a
DEDENT
----------------------------------------

def fft2(a, out = None) :
INDENT
    assert a.dtype == _np.complex128
    assert len(a.shape) == 2
    inplace = False
    if out is a :
    INDENT
        inplace = True
    DEDENT
    elif out is not None :
    INDENT
        assert out.dtype == _np.complex128
        assert a.shape == out.shape
        assert not _np.may_share_memory(a, out)
    DEDENT
    else :
    INDENT
        out = _np.empty_like(a)
    DEDENT
    Desc_Handle = _ctypes.c_void_p(0)
    dims = (_ctypes.c_int * 2)(* a.shape)
    mkl.DftiCreateDescriptor(_ctypes.byref(Desc_Handle), _DFTI_DOUBLE, _DFTI_COMPLEX, _ctypes.c_int(2), dims)

    if not a.flags ['C_CONTIGUOUS'] :
    INDENT
        in_strides = (_ctypes.c_int * 3)(0, a.strides [0] / 16, a.strides [1] / 16)
        mkl.DftiSetValue(Desc_Handle, _DFTI_INPUT_STRIDES, _ctypes.byref(in_strides))
    DEDENT
    if inplace :
    INDENT

        mkl.DftiCommitDescriptor(Desc_Handle)
        mkl.DftiComputeForward(Desc_Handle, a.ctypes.data_as(_ctypes.c_void_p))
    DEDENT
    else :
    INDENT

        mkl.DftiSetValue(Desc_Handle, _DFTI_PLACEMENT, _DFTI_NOT_INPLACE)

        if not out.flags ['C_CONTIGUOUS'] :
        INDENT
            out_strides = (_ctypes.c_int * 3)(0, out.strides [0] / 16, out.strides [1] / 16)
            mkl.DftiSetValue(Desc_Handle, _DFTI_OUTPUT_STRIDES, _ctypes.byref(out_strides))
        DEDENT
        mkl.DftiCommitDescriptor(Desc_Handle)
        mkl.DftiComputeForward(Desc_Handle, a.ctypes.data_as(_ctypes.c_void_p), out.ctypes.data_as(_ctypes.c_void_p))
    DEDENT
    mkl.DftiFreeDescriptor(_ctypes.byref(Desc_Handle))
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1182315_1182350_6_18
1182315_1182364_8_27
Title: Python: Multicore processing? 
----------------------------------------

def main() :
INDENT
    my_list = range(1000000)
    q = Queue()
    p1 = Process(target = do_sum, args = (q, my_list [: 500000]))
    p2 = Process(target = do_sum, args = (q, my_list [500000 :]))
    p1.start()
    p2.start()
    r1 = q.get()
    r2 = q.get()
    print r1 + r2
DEDENT
----------------------------------------

def main() :
INDENT
    start = 0
    chunk = 500 * 1000
    queue = Queue()
    NP = 0
    subprocesses = []
    while start < len(thelist) :
    INDENT
        p = Process(target = f, args = (queue, thelist [start : start + chunk]))
        NP += 1
        print 'delegated %s:%s to subprocess %s' % (start, start + chunk, NP)
        p.start()
        start += chunk
        subprocesses.append(p)
    DEDENT
    total = 0
    for i in range(NP) :
    INDENT
        total += queue.get()
    DEDENT
    print "total is", total, '=', sum(thelist)
    while subprocesses :
    INDENT
        subprocesses.pop().join()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11826858_11884020_53_68
11826858_11884020_8_34
Title: block pixel shifting in Python/GTK 
----------------------------------------

def __init__(self) :
INDENT
    super(PyApp, self).__init__()
    self.modify_bg(gtk.STATE_NORMAL, gtk.gdk.Color(0, 0, 0))
    self.connect("destroy", gtk.main_quit)
    self.set_title("side scroller")

    scroller_screen = Scroller('Breaking News - scrolling text works! More soon....Olympic Games in London are highly entertaining. No more please!')
    self.add(scroller_screen)
    self.set_size_request(1000, 100)
    self.show_all()
    scroller_screen.initscreen
    glib.timeout_add(20, scroller_screen.update_display)
DEDENT
----------------------------------------

def __init__(self, TextString) :
INDENT
    super(Scroller, self).__init__()
    self.offset_x = 0
    self.offset_y = 0
    self.screen_x = 1000
    self.screen_y = 0
    self.p = self.create_pango_layout(TextString)
    self.p.set_font_description(pango.FontDescription('Sans 36'))
    attr = pango.AttrList()
    attr.insert(pango.AttrForeground(60535, 60535, 0, 0, - 1))
    self.p.set_attributes(attr)
    self.p.set_width(- 1)
    self.text_width, self.text_height = self.p.get_size()
    self.text_width = self.text_width / pango.SCALE
    self.text_height = self.text_height / pango.SCALE

    self.pixelbuffer = gtk.gdk.Pixbuf(gtk.gdk.COLORSPACE_RGB, False, 8, self.text_width, self.text_height)
    self.pixelbuffer.fill(0)
    pixmap, _ = self.pixelbuffer.render_pixmap_and_mask()
    self.pgc = pixmap.new_gc()
    pixmap.draw_layout(self.pgc, 0, 0, self.p)
    self.pixelbuffer.get_from_drawable(pixmap, pixmap.get_colormap(), 0, 0, 0, 0, - 1, - 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11872560_11872933_10_23
11872560_24423890_10_26
Title: How to pass Django request object in user_passes_test decorator callable function 
----------------------------------------

def _wrapped_view(request, * args, ** kwargs) :
INDENT
    if test_func(request.user) :
    INDENT
        return view_func(request, * args, ** kwargs)
    DEDENT
    path = request.build_absolute_uri()

    login_scheme, login_netloc = urlparse.urlparse(login_url or
        settings.LOGIN_URL) [: 2]
    current_scheme, current_netloc = urlparse.urlparse(path) [: 2]
    if ((not login_scheme or login_scheme == current_scheme) and
        (not login_netloc or login_netloc == current_netloc)) :
    INDENT
        path = request.get_full_path()
    DEDENT
    from django.contrib.auth.views import redirect_to_login
    return redirect_to_login(path, login_url, redirect_field_name)
DEDENT
----------------------------------------

def _wrapped_view(request, * args, ** kwargs) :
INDENT
    if test_func(request) :
    INDENT
        return view_func(request, * args, ** kwargs)
    DEDENT
    path = request.build_absolute_uri()
    resolved_login_url = force_str(
        resolve_url(login_url or settings.LOGIN_URL))

    login_scheme, login_netloc = urlparse(resolved_login_url) [: 2]
    current_scheme, current_netloc = urlparse(path) [: 2]
    if ((not login_scheme or login_scheme == current_scheme) and
        (not login_netloc or login_netloc == current_netloc)) :
    INDENT
        path = request.get_full_path()
    DEDENT
    from django.contrib.auth.views import redirect_to_login
    return redirect_to_login(
        path, resolved_login_url, redirect_field_name)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11872560_11872933_8_24
11872560_24423890_8_27
Title: How to pass Django request object in user_passes_test decorator callable function 
----------------------------------------

def decorator(view_func) :
INDENT
    @ wraps(view_func, assigned = available_attrs(view_func))
    def _wrapped_view(request, * args, ** kwargs) :
    INDENT
        if test_func(request.user) :
        INDENT
            return view_func(request, * args, ** kwargs)
        DEDENT
        path = request.build_absolute_uri()

        login_scheme, login_netloc = urlparse.urlparse(login_url or
            settings.LOGIN_URL) [: 2]
        current_scheme, current_netloc = urlparse.urlparse(path) [: 2]
        if ((not login_scheme or login_scheme == current_scheme) and
            (not login_netloc or login_netloc == current_netloc)) :
        INDENT
            path = request.get_full_path()
        DEDENT
        from django.contrib.auth.views import redirect_to_login
        return redirect_to_login(path, login_url, redirect_field_name)
    DEDENT
    return _wrapped_view
DEDENT
----------------------------------------

def decorator(view_func) :
INDENT
    @ wraps(view_func, assigned = available_attrs(view_func))
    def _wrapped_view(request, * args, ** kwargs) :
    INDENT
        if test_func(request) :
        INDENT
            return view_func(request, * args, ** kwargs)
        DEDENT
        path = request.build_absolute_uri()
        resolved_login_url = force_str(
            resolve_url(login_url or settings.LOGIN_URL))

        login_scheme, login_netloc = urlparse(resolved_login_url) [: 2]
        current_scheme, current_netloc = urlparse(path) [: 2]
        if ((not login_scheme or login_scheme == current_scheme) and
            (not login_netloc or login_netloc == current_netloc)) :
        INDENT
            path = request.get_full_path()
        DEDENT
        from django.contrib.auth.views import redirect_to_login
        return redirect_to_login(
            path, resolved_login_url, redirect_field_name)
    DEDENT
    return _wrapped_view
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11873448_12077063_3_29
11873448_12098955_16_34
Title: Building Self-Referencing Tuples 
----------------------------------------

def self_reference(array, index) :
INDENT
    if not isinstance(array, tuple) :
    INDENT
        raise TypeError("array must be a tuple")
    DEDENT
    if not 0 < = index < len(array) :
    INDENT
        raise IndexError("tuple assignment index out of range")
    DEDENT
    arrayobj = ctypes.py_object(array)

    refcnt = ctypes.pythonapi.Py_DecRef(arrayobj)
    for i in range(refcnt - 1) :
    INDENT
        ctypes.pythonapi.Py_DecRef(arrayobj)
    DEDENT
    try :
    INDENT
        ret = ctypes.pythonapi.PyTuple_SetItem(arrayobj, ctypes.c_ssize_t(index), arrayobj)
        if ret ! = 0 :
        INDENT
            raise RuntimeError("PyTuple_SetItem failed")
        DEDENT
    DEDENT
    except :
    INDENT
        raise SystemError("FATAL: PyTuple_SetItem failed: tuple probably unusable")
    DEDENT
    for i in range(refcnt + 1) :
    INDENT
        ctypes.pythonapi.Py_IncRef(arrayobj)
    DEDENT
DEDENT
----------------------------------------

def self_reference(cls, array, index) :
INDENT
    if not isinstance(array, tuple) :
    INDENT
        raise TypeError('array must be a tuple')
    DEDENT
    if not isinstance(index, int) :
    INDENT
        raise TypeError('index must be an int')
    DEDENT
    if not 0 < = index < len(array) :
    INDENT
        raise ValueError('index is out of range')
    DEDENT
    GIL.acquire()
    try :
    INDENT
        obj = ctypes.py_object(array)
        ob_refcnt = ctypes.cast(id(array), ob_refcnt_p).contents.value
        for _ in range(ob_refcnt - 1) :
        INDENT
            Ref.dec(obj)
        DEDENT
        if cls.setitem(obj, ctypes.c_ssize_t(index), obj) :
        INDENT
            raise SystemError('PyTuple_SetItem was not successful')
        DEDENT
        for _ in range(ob_refcnt) :
        INDENT
            Ref.inc(obj)
        DEDENT
    DEDENT
    finally :
    INDENT
        GIL.release()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11892521_11893324_32_44
11892521_11894636_5_36
Title: Tkinter custom window 
----------------------------------------

def __init__(self) :
INDENT
    tk.Tk.__init__(self)
    self.wm_overrideredirect(True)
    gradient_frame = GradientFrame(self)
    gradient_frame.pack(side = "top", fill = "both", expand = True)
    inner_frame = tk.Frame(gradient_frame)
    inner_frame.pack(side = "top", fill = "both", expand = True, padx = 8, pady = (16, 8))
    b1 = tk.Button(inner_frame, text = "Close", command = self.destroy)
    t1 = tk.Text(inner_frame, width = 40, height = 10)
    b1.pack(side = "top")
    t1.pack(side = "top", fill = "both", expand = True)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    tk.Tk.__init__(self)
    self.overrideredirect(True)
    self.mCan = tk.Canvas(self, height = 768, width = 768)
    self.mCan.pack()

    self.lFrame = self.mCan.create_rectangle(0, 0, 9, 769,
        outline = 'lightgrey', fill = 'lightgrey')
    self.rFrame = self.mCan.create_rectangle(760, 0, 769, 769,
        outline = 'lightgrey', fill = 'lightgrey')
    self.bFrame = self.mCan.create_rectangle(0, 760, 769, 769,
        outline = 'lightgrey', fill = 'lightgrey')
    self.titleBar = self.mCan.create_rectangle(0, 0, 769, 20,
        outline = 'lightgrey', fill = 'lightgrey')
    self.closeButton = self.mCan.create_rectangle(750, 4, 760, 18,
        activefill = 'red', fill = 'darkgrey')

    self.bind('<1>', self.left_mouse)
    self.bind('<Escape>', self.close_win)

    self.update_idletasks()
    xp = (self.winfo_screenwidth() / 2) - (self.winfo_width() / 2)
    yp = (self.winfo_screenheight() / 2) - (self.winfo_height() / 2)
    self.geometry('{0}x{1}+{2}+{3}'.format(self.winfo_width(),
            self.winfo_height(),
            xp, yp))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11905606_11905805_1_13
11905606_11906331_1_25
Title: Changing the number of iterations in a for loop 
----------------------------------------

def adjustable_range(start, stop = None, step = None) :
INDENT
    if stop is None :
    INDENT
        start, stop = 0, start
    DEDENT
    if step is None : step = 1
    i = start
    while i < stop :
    INDENT
        change_bound = (yield i)
        if change_bound is None :
        INDENT
            i += step
        DEDENT
        else :
        INDENT
            stop = change_bound
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def adjustable_range(start, stop = None, step = None) :
INDENT
    if not isinstance(start, int) :
    INDENT
        raise TypeError('start')
    DEDENT
    if stop is None :
    INDENT
        start, stop = 0, start
    DEDENT
    elif not isinstance(stop, int) :
    INDENT
        raise TypeError('stop')
    DEDENT
    direction = stop - start
    positive, negative = direction > 0, direction < 0
    if step is None :
    INDENT
        step = + 1 if positive else - 1
    DEDENT
    else :
    INDENT
        if not isinstance(step, int) :
        INDENT
            raise TypeError('step')
        DEDENT
        if positive and step < 0 or negative and step > 0 :
        INDENT
            raise ValueError('step')
        DEDENT
    DEDENT
    if direction :
    INDENT
        valid = (lambda a, b : a < b) if positive else (lambda a, b : a > b)
        while valid(start, stop) :
        INDENT
            message = yield start
            if message is not None :
            INDENT
                if not isinstance(message, int) :
                INDENT
                    raise ValueError('message')
                DEDENT
                stop = message
            DEDENT
            start += step
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11906925_11910555_334_342
11906925_42522175_92_97
Title: Python simulate keydown 
----------------------------------------

def main() :
INDENT
    time.sleep(5)
    for event in keyboard_stream('o2E^uXh#:SHn&HQ+t]YF') :
    INDENT
        SendInput(event)
        time.sleep(0.1)

    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    time.sleep(3)
    for char in u'O\nשש2E6UXoשש2E^uXh#:SHn&HQ' :
    INDENT
        press(char)
        time.sleep(0.5)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11920401_11921579_18_29
11920401_11921579_7_15
Title: PyQt: Accesing Main Window's Data from a dialog? 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QDialog.__init__(self, None)
    self.resize(QtCore.QSize(320, 240))
    self.setWindowTitle('Main window')
    self.logText = QtGui.QPlainTextEdit()
    searchButton = QtGui.QPushButton('Search')
    layout = QtGui.QVBoxLayout()
    layout.addWidget(self.logText)
    layout.addWidget(searchButton)
    self.setLayout(layout)
    searchButton.clicked.connect(self.showSearchDialog)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QDialog.__init__(self, parent)
    self.setWindowTitle('Search')
    self.searchEdit = QtGui.QLineEdit()
    layout = QtGui.QVBoxLayout()
    layout.addWidget(self.searchEdit)
    self.setLayout(layout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11927178_11927547_9_22
11927178_25696991_21_32
Title: Mouse events on text in Python using wxPython 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, - 1, title)
    html = wx.html.HtmlWindow(self)

    html.SetStandardFonts()
    html.SetPage(
        "<style>a {text-decoration: none;color: #000; }</style>"
        "<a href=\"word1\"><![CDATA[Word1</a> <a href=\"word2\"><![CDATA[word 2</a> <a href=\"wizard of oz\"><![CDATA[wizard of oz</a>.")
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    if rt.RichTextBuffer.FindHandlerByType(rt.RICHTEXT_TYPE_HTML) is not None :
    INDENT
        return
    DEDENT
    rt.RichTextBuffer.AddHandler(rt.RichTextHTMLHandler())
    rt.RichTextBuffer.AddHandler(rt.RichTextXMLHandler())
    wx.FileSystem.AddHandler(wx.MemoryFSHandler())
    self.win = RichTextFrame(self, - 1, "wx.richtext.RichTextCtrl",
        size = (700, 500),
        style = wx.DEFAULT_FRAME_STYLE)
    self.win.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11946764_11946832_1_13
11946764_34568724_1_12
Title: Countletters(sorted) 
----------------------------------------

def countLetters(word) :
INDENT
    word = list(word)
    word.sort()
    trans = []
    for j in word :
    INDENT
        row = []
        a = word.count(j)
        row.append(j)
        row.append(a)
        trans.append(tuple(row))
    DEDENT
    ans = list(set(trans))
    ans.sort()
    return ans
DEDENT
----------------------------------------

def countLetters(word) :
INDENT
    k = []
    Listing = []
    Cororo = []
    for warm in word :
    INDENT
        if warm not in k :
        INDENT
            k.append(warm)
        DEDENT
    DEDENT
    for cold in range(len(k)) :
    INDENT
        word.count(k [cold])
        Listing.append(word.count(k [cold]))
        Cororo.append((k [cold], Listing [cold]))
    DEDENT
    return sorted(Cororo)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11952667_11953563_1_20
11952667_11953646_1_13
Title: Returning a list of values from a tree recursion 
----------------------------------------

def within_radius(self, point, radius, result = []) :
INDENT
    d = self.discriminator
    temp = []
    if in_circle(point, radius, self.data) :
    INDENT
        temp = [self.data]

    DEDENT
    if point [d] - radius < self.data [d] and self.l_child :
    INDENT
        temp += self.l_child.within_radius(point, radius, result)
    DEDENT
    if point [d] + radius > self.data [d] and self.r_child :
    INDENT
        temp += self.r_child.within_radius(point, radius, result)
    DEDENT
    return result + temp
DEDENT
----------------------------------------

def within_radius(self, point, radius, result = None) :
INDENT
    d = self.discriminator
    result = set() if result is None else result
    if in_circle(point, radius, self.data) :
    INDENT
        result.add(self.data)
    DEDENT
    if point [d] - radius < self.data [d] and self.l_child :
    INDENT
        self.l_child.within_radius(point, radius, result)
    DEDENT
    if point [d] + radius > self.data [d] and self.r_child :
    INDENT
        self.r_child.within_radius(point, radius, result)
    DEDENT
    return list(result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11964895_11965077_13_18
11964895_12610526_12_18
Title: "In Python count the number of variables in a class or prevent adding new class variables" 
----------------------------------------

def _setattr(self, attr, value) :
INDENT
    disallow_declarations = not getattr(self, "_allow_declarations", False)
    if disallow_declarations and attr ! = "_allow_declarations" :
    INDENT
        if not hasattr(self, attr) :
        INDENT
            raise AttributeError("You shall not set attributes!")
        DEDENT
    DEDENT
    super(cls, self).__setattr__(attr, value)
DEDENT
----------------------------------------

def _setattr(self, attr, value) :
INDENT
    if getattr(self, "freeze", None) :
    INDENT
        if attr == "freeze" or not hasattr(self, attr) :
        INDENT
            raise AttributeError("You shall not create attributes!")
        DEDENT
        if hasattr(type(self), attr) :
        INDENT
            raise AttributeError("You shall not modify immutable attributes!")
        DEDENT
    DEDENT
    super(cls, self).__setattr__(attr, value)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
119802_119963_6_14
119802_120225_4_9
Title: Using **kwargs with SimpleXMLRPCServer in python 
----------------------------------------

def __call__(self, * args, ** kwargs) :
INDENT
    if args and kwargs :
    INDENT
        raise TypeError, "Can't pass both positional and keyword args"
    DEDENT
    args = list(args)
    for key in kwargs :
    INDENT
        args.append('-%s' % key.upper())
        args.append(kwargs [key])
    DEDENT
    return _orig_Method.__call__(self, * args)
DEDENT
----------------------------------------

def __call__(self, * args, ** kwargs) :
INDENT
    args = list(args)
    if kwargs :
    INDENT
        args.append(("kwargs", kwargs))
    DEDENT
    return _orig_Method.__call__(self, * args)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11995454_11995738_3_15
11995454_12002011_5_18
Title: Exception while handling generator.send() in try...except block 
----------------------------------------

def tail(filename) :
INDENT
    fd = open(filename)
    while True :
    INDENT
        line = fd.readline()
        if not line :
        INDENT
            continue
        DEDENT
        else :
        INDENT
            x = (yield line)
            if (x == 'uh') :
            INDENT
                print 'Returning f to close the file'
                yield fd

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def tail(filename) :
INDENT
    fd = open(filename)
    while True :
    INDENT
        try :
        INDENT
            line = fd.readline()
        DEDENT
        except KeyboardInterrupt :
        INDENT
            print 'keyboard interrupt here'
            yield fd
        DEDENT
        if not line :
        INDENT
            continue
        DEDENT
        else :
        INDENT
            yield line

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12022049_12022050_17_25
12022049_12022050_31_38
Title: Variations of function decorators in Python 
----------------------------------------

def __init__(self, f) :
INDENT
    def host_wrapper(* arg, ** kwargs) :
    INDENT
        print ("Inside decorator-class, WITHOUT arg.")
        return f(test_class(), * arg, ** kwargs)
    DEDENT
    self.f = host_wrapper
DEDENT
----------------------------------------

def __init__(self, dec_arg) :
INDENT
    def decorator(host_method) :
    INDENT
        def host_wrapper(host_obj, * arg, ** kwargs) :
        INDENT
            print ("Inside decorator-class, WITH arg: %s" % (dec_arg))
            return host_method(host_obj, * arg, ** kwargs)
        DEDENT
        return host_wrapper
    DEDENT
    self.f = decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12022049_12022050_17_25
12022049_12022050_56_63
Title: Variations of function decorators in Python 
----------------------------------------

def __init__(self, f) :
INDENT
    def host_wrapper(* arg, ** kwargs) :
    INDENT
        print ("Inside decorator-class, WITHOUT arg.")
        return f(test_class(), * arg, ** kwargs)
    DEDENT
    self.f = host_wrapper
DEDENT
----------------------------------------

def __init__(self, dec_arg) :
INDENT
    def decorator(host_method) :
    INDENT
        def host_wrapper(* arg, ** kwargs) :
        INDENT
            print ("Inside decorator-on-function class, with arg: %s" % (dec_arg))
            return host_method(* arg, ** kwargs)
        DEDENT
        return host_wrapper
    DEDENT
    self.f = decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12022049_12022050_32_36
12022049_12022050_57_61
Title: Variations of function decorators in Python 
----------------------------------------

def decorator(host_method) :
INDENT
    def host_wrapper(host_obj, * arg, ** kwargs) :
    INDENT
        print ("Inside decorator-class, WITH arg: %s" % (dec_arg))
        return host_method(host_obj, * arg, ** kwargs)
    DEDENT
    return host_wrapper
DEDENT
----------------------------------------

def decorator(host_method) :
INDENT
    def host_wrapper(* arg, ** kwargs) :
    INDENT
        print ("Inside decorator-on-function class, with arg: %s" % (dec_arg))
        return host_method(* arg, ** kwargs)
    DEDENT
    return host_wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12080277_12081184_1_16
12080277_12101156_11_18
Title: parse nested conditional statements 
----------------------------------------

def parse(lines) :
INDENT
    result = []
    while lines :
    INDENT
        if lines [0].startswith('#if') :
        INDENT
            block = [lines.pop(0).split() [1], parse(lines)]
            if lines [0].startswith('#else') :
            INDENT
                lines.pop(0)
                block.append(parse(lines))
            DEDENT
            lines.pop(0)
            result.append(block)
        DEDENT
        elif not lines [0].startswith(('#else', '#endif')) :
        INDENT
            result.append(lines.pop(0))
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def parse(text) :
INDENT
    pattern = r'#if\s*(\S*)\s*((?:.(?!#if|#endif))*.)#endif'
    regex = re.compile(pattern, re.DOTALL)
    while True :
    INDENT
        if not regex.search(text) : break
        text = regex.sub(eval_conditional, text)
    DEDENT
    return text
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12097543_12102073_24_45
12097543_12102073_58_74
Title: How to rebuild panels in wxpython in function of a variable? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.hbox = wx.BoxSizer(wx.HORIZONTAL)
    self.vbox = wx.BoxSizer(wx.VERTICAL)
    self.listbox = wx.ListBox(self, - 1)
    self.hbox.Add(self.listbox, 1, wx.EXPAND | wx.ALL, 20)
    self.btnPanel = wx.Panel(self, - 1)
    self.new = wx.Button(self.btnPanel, label = 'Add', size = (90, 30))
    self.new.Bind(wx.EVT_BUTTON, self.NewItem)
    self.vbox.Add((- 1, 20))
    self.vbox.Add(self.new)
    self.btnPanel.SetSizer(self.vbox)
    self.hbox.Add(self.btnPanel, 0.6, wx.EXPAND | wx.RIGHT, 20)
    self.SetSizer(self.hbox)
    self.Bind(wx.EVT_LISTBOX, self.onSelect)
DEDENT
----------------------------------------

def __init__(self, parent, id, title, * args, ** kw) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 300))
    self.splitter = wx.SplitterWindow(self, - 1, style = wx.SP_3D)
    Publisher().subscribe(self.OnSelect, "ListBox")
    self.lc1 = PanelB(self.splitter)
    self.lc2 = PanelA(self.splitter)
    self.splitter.SplitVertically(self.lc1, self.lc2)
    self.sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.sizer.Add(self.splitter, 1, wx.EXPAND)
    self.SetSizer(self.sizer)
    self.Layout()
    self.Centre()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12097543_12102073_24_45
12097543_12102073_6_14
Title: How to rebuild panels in wxpython in function of a variable? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.hbox = wx.BoxSizer(wx.HORIZONTAL)
    self.vbox = wx.BoxSizer(wx.VERTICAL)
    self.listbox = wx.ListBox(self, - 1)
    self.hbox.Add(self.listbox, 1, wx.EXPAND | wx.ALL, 20)
    self.btnPanel = wx.Panel(self, - 1)
    self.new = wx.Button(self.btnPanel, label = 'Add', size = (90, 30))
    self.new.Bind(wx.EVT_BUTTON, self.NewItem)
    self.vbox.Add((- 1, 20))
    self.vbox.Add(self.new)
    self.btnPanel.SetSizer(self.vbox)
    self.hbox.Add(self.btnPanel, 0.6, wx.EXPAND | wx.RIGHT, 20)
    self.SetSizer(self.hbox)
    self.Bind(wx.EVT_LISTBOX, self.onSelect)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.hbox = wx.BoxSizer(wx.HORIZONTAL)
    self.vbox = wx.BoxSizer(wx.VERTICAL)
    name = "none, please select an item"
    self.txt = wx.StaticText(self, - 1, "You have selected " + name,
        (50, 100))
    self.hbox.Add(self.txt, 1, wx.EXPAND | wx.ALL, 30)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12097543_12102073_58_74
12097543_12102073_6_14
Title: How to rebuild panels in wxpython in function of a variable? 
----------------------------------------

def __init__(self, parent, id, title, * args, ** kw) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 300))
    self.splitter = wx.SplitterWindow(self, - 1, style = wx.SP_3D)
    Publisher().subscribe(self.OnSelect, "ListBox")
    self.lc1 = PanelB(self.splitter)
    self.lc2 = PanelA(self.splitter)
    self.splitter.SplitVertically(self.lc1, self.lc2)
    self.sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.sizer.Add(self.splitter, 1, wx.EXPAND)
    self.SetSizer(self.sizer)
    self.Layout()
    self.Centre()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.hbox = wx.BoxSizer(wx.HORIZONTAL)
    self.vbox = wx.BoxSizer(wx.VERTICAL)
    name = "none, please select an item"
    self.txt = wx.StaticText(self, - 1, "You have selected " + name,
        (50, 100))
    self.hbox.Add(self.txt, 1, wx.EXPAND | wx.ALL, 30)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12143101_12146162_21_29
12143101_12146162_4_13
Title: How to get files opened during a django page request 
----------------------------------------

def __init__(self) :
INDENT
    self.oldfile = __builtin__.file
    self.openfiles = set()
    self.newfile = newFileClassFactory(self.oldfile, self.openfiles)
    self.oldopen = __builtin__.open
    def newopen(* args) :
    INDENT
        return self.newfile(* args)
    DEDENT
    self.newopen = newopen
DEDENT
----------------------------------------

def __init__(self, * args) :
INDENT
    self.thepath = args [0]
    print "### OPENING %s ###" % str(self.thepath)
    try :
    INDENT
        oldfile.__init__(self, * args)
    DEDENT
    except Exception, e :
    INDENT
        print e
        raise
    DEDENT
    openfiles.add(self.thepath)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12148093_12148290_1_11
12148093_44303585_8_17
Title: inplace quick sort implementation 
----------------------------------------

def partition(array, left, right, pivotIndex) :
INDENT
    pivotValue = array [pivotIndex]
    swap(array, pivotIndex, right)
    storeIndex = left
    for i in range(left, right) :
    INDENT
        if array [i] < = pivotValue :
        INDENT
            swap(array, i, storeIndex)
            storeIndex = storeIndex + 1
            print array, i
        DEDENT
    DEDENT
    swap(array, storeIndex, right)
    return storeIndex
DEDENT
----------------------------------------

def partition(a, left, right) :
INDENT
    pivotIndex = right
    for i in range(left, right) :
    INDENT
        if a [i] > a [pivotIndex] :
        INDENT
            swap(a, i, pivotIndex)

        DEDENT
    DEDENT
    return pivotIndex
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12148503_12148760_32_37
12148503_12148760_39_46
Title: Can the same @property present both scalar and collection behavior in SQLAlchemy? 
----------------------------------------

def value(self) :
INDENT
    if self.str_value is not None :
    INDENT
        return self.str_value
    DEDENT
    else :
    INDENT
        return self.list_proxy
    DEDENT
DEDENT
----------------------------------------

def value(self, value) :
INDENT
    if isinstance(value, basestring) :
    INDENT
        self.str_value = value
    DEDENT
    elif isinstance(value, list) :
    INDENT
        self.list_proxy = value
    DEDENT
    else :
    INDENT
        assert False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12213391_12219643_4_34
12213391_42284921_6_30
Title: Python PyQt: How can I move my widgets on the window with mouse? 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyFrame, self).__init__(parent)
    scene = QtGui.QGraphicsScene()
    self.setScene(scene)

    x = 0
    y = 0
    w = 45
    h = 45
    pen = QtGui.QPen(QtGui.QColor(QtCore.Qt.green))
    brush = QtGui.QBrush(pen.color().darker(150))
    item = scene.addEllipse(x, y, w, h, pen, brush)
    item.setFlag(QtGui.QGraphicsItem.ItemIsMovable)

    path = QtGui.QPainterPath()
    path.moveTo(- w, - h)
    path.lineTo(- w, h)
    path.lineTo(w, h)
    path.lineTo(w, - h)
    clr = QtGui.QColor('blue')
    clr.setAlpha(120)
    brush = QtGui.QBrush(clr)
    pen = QtGui.QPen(QtCore.Qt.NoPen)
    fill_item = scene.addRect(- w, y, w * 2, h, pen, brush)
    path_item = scene.addPath(path)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super().__init__(parent)
    self.sx = 635
    self.sy = 475
    scene = QGraphicsScene(0, 0, self.sx, self.sy)
    self.setScene(scene)
    self.x = 0
    self.y = 0
    self.w = 30
    self.h = 30
    pen = QPen(QColor('dodgerblue'))
    brush = QBrush(pen.color())

    self.dot = scene.addEllipse(self.x, self.y, self.w, self.h, pen, brush)
    self.dot.setFlag(QGraphicsItem.ItemIsMovable)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12238511_12238725_16_31
12238511_12238725_42_48
Title: Preprocessing function text in runtime bofore compilation 
----------------------------------------

def remove_1(f) :
INDENT
    global _blocked
    if _blocked :
    INDENT
        return f
    DEDENT
    import inspect
    source = inspect.getsource(f)
    new_source = comment_1(source)
    env = sys.modules [f.__module__].__dict__
    _blocked = True
    try :
    INDENT
        exec new_source in env
    DEDENT
    finally :
    INDENT
        _blocked = False
    DEDENT
    return env [f.__name__]

DEDENT
----------------------------------------

def remove_1(f) :
INDENT
    import inspect
    source = inspect.getsource(f)
    new_source = comment_1(source)
    env = sys.modules [f.__module__].__dict__.copy()
    exec new_source in env
    return env [f.__name__]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12238511_12238725_16_31
12238511_12240203_13_43
Title: Preprocessing function text in runtime bofore compilation 
----------------------------------------

def remove_1(f) :
INDENT
    global _blocked
    if _blocked :
    INDENT
        return f
    DEDENT
    import inspect
    source = inspect.getsource(f)
    new_source = comment_1(source)
    env = sys.modules [f.__module__].__dict__
    _blocked = True
    try :
    INDENT
        exec new_source in env
    DEDENT
    finally :
    INDENT
        _blocked = False
    DEDENT
    return env [f.__name__]

DEDENT
----------------------------------------

def remove_1(f) :
INDENT
    global _blocked
    if _blocked :
    INDENT
        return f
    DEDENT
    import inspect
    source = inspect.getsource(f)
    a = ast.parse(source)
    class Transformer(ast.NodeTransformer) :
    INDENT
        '''Will delete all expressions containing 'a' functions at the top level'''
        def visit_Expr(self, node) :
        INDENT
            try :
            INDENT
                if node.value.func.id == 'a' :
                INDENT
                    return None
                DEDENT
            DEDENT
            except (ValueError) :
            INDENT
                pass
            DEDENT
            return node
        DEDENT
    DEDENT
    transformer = Transformer()
    a_new = transformer.visit(a)
    f_new_compiled = compile(a_new, '<string>', 'exec')
    env = sys.modules [f.__module__].__dict__
    _blocked = True
    try :
    INDENT
        exec (f_new_compiled, env)
    DEDENT
    finally :
    INDENT
        _blocked = False
    DEDENT
    return env [f.__name__]

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12238511_12238725_42_48
12238511_12240203_13_43
Title: Preprocessing function text in runtime bofore compilation 
----------------------------------------

def remove_1(f) :
INDENT
    import inspect
    source = inspect.getsource(f)
    new_source = comment_1(source)
    env = sys.modules [f.__module__].__dict__.copy()
    exec new_source in env
    return env [f.__name__]
DEDENT
----------------------------------------

def remove_1(f) :
INDENT
    global _blocked
    if _blocked :
    INDENT
        return f
    DEDENT
    import inspect
    source = inspect.getsource(f)
    a = ast.parse(source)
    class Transformer(ast.NodeTransformer) :
    INDENT
        '''Will delete all expressions containing 'a' functions at the top level'''
        def visit_Expr(self, node) :
        INDENT
            try :
            INDENT
                if node.value.func.id == 'a' :
                INDENT
                    return None
                DEDENT
            DEDENT
            except (ValueError) :
            INDENT
                pass
            DEDENT
            return node
        DEDENT
    DEDENT
    transformer = Transformer()
    a_new = transformer.visit(a)
    f_new_compiled = compile(a_new, '<string>', 'exec')
    env = sys.modules [f.__module__].__dict__
    _blocked = True
    try :
    INDENT
        exec (f_new_compiled, env)
    DEDENT
    finally :
    INDENT
        _blocked = False
    DEDENT
    return env [f.__name__]

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12273889_13034063_2_11
12273889_51874656_9_16
Title: Calculate execution time for every page in Python's Flask 
----------------------------------------

def after_request(response) :
INDENT
    diff = time.time() - g.start
    if app.debug :
    INDENT
        print "Exec time: %s" % str(diff)
    DEDENT
    if (response.response) :
    INDENT
        response.response [0] = response.response [0].replace('__EXECUTION_TIME__', str(diff))
        response.headers ["content-length"] = len(response.response [0])
    DEDENT
    return response
DEDENT
----------------------------------------

def after_request(response) :
INDENT
    diff = time.time() - g.start
    if ((response.response) and
        (200 < = response.status_code < 300) and
        (response.content_type.startswith('text/html'))) :
    INDENT
        response.set_data(response.get_data().replace(
                b'__EXECUTION_TIME__', bytes(str(diff), 'utf-8')))
    DEDENT
    return response
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1229525_1229823_31_40
1229525_1229823_6_18
Title: Opening a wx.Frame in Python via a new thread 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent)
    time.sleep(3)
    parent.Hide()

    self.Bind(wx.EVT_CLOSE, lambda e : wx.GetApp().ExitMainLoop())

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)
    self.btn1 = wx.Button(self, label = "Option 1")
    self.btn2 = wx.Button(self, label = "Option 2")
    sizer.Add(self.btn1, flag = wx.EXPAND)
    sizer.Add(self.btn2, flag = wx.EXPAND)
    self.btn1.Bind(wx.EVT_BUTTON, self.OnOption1)
    self.btn2.Bind(
        wx.EVT_BUTTON, lambda e : wx.MessageBox("There is no option 2"))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12295699_12296172_23_33
12295699_12296172_8_15
Title: Pyramid traversal is doing my head in 
----------------------------------------

def __getitem__(self, key) :
INDENT
    db = findDatabase(self.request)
    if db.exists(key) :
    INDENT
        data = db.load(key)
        art = Article(data)
        art.__name__ = key
        art.__parent__ = self
        return art
    DEDENT
    raise KeyError(key)
DEDENT
----------------------------------------

def __getitem__(self, key) :
INDENT
    if key == 'articles' :
    INDENT
        dispatch = ArticleDispatcher(self.request)
        dispatch.__name__ = key
        dispatch.__parent__ = self
        return dispatch
    DEDENT
    raise KeyError(key)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12310733_12310794_3_11
12310733_12310797_3_10
Title: Invalid syntax when creating lists 
----------------------------------------

def createlist(a) :
INDENT
    blist = []
    count = 0
    while count < = a :
    INDENT
        blist.append(random.randint(1, 1000000))
        count = count + 1
    DEDENT
    return blist
DEDENT
----------------------------------------

def createlist(a) :
INDENT
    blist = []
    for x in xrange(a) :
    INDENT
        blist.append(random.randint(1, 1000000))
    DEDENT
    return blist
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12317940_12318307_3_13
12317940_36806825_4_14
Title: Python threading: can I sleep on two threading.Event()s simultaneously? 
----------------------------------------

def __init__(self, ev_list = None) :
INDENT
    self._trigger = Event()
    if ev_list :
    INDENT

        self._t_list = [
            Thread(target = self._triggerer, args = (ev,)) for ev in ev_list
            ]
    DEDENT
    else :
    INDENT
        self._t_list = []
    DEDENT
DEDENT
----------------------------------------

def __init__(self, events_list, condition) :
INDENT
    _Event.__init__(self)
    self.event_list = events_list
    self.condition = condition
    for e in events_list :
    INDENT
        self._setup(e, self._state_changed)
    DEDENT
    self._state_changed()
DEDENT
----------------------------------------
