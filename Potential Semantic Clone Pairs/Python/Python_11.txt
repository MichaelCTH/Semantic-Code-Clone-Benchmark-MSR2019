$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19966094_19966608_10_30
19966094_19966608_116_127
Title: Space Invaders project 
----------------------------------------

def __init__(self, screen_rect) :
INDENT
    self.image = pygame.image.load("ball1.png")
    self.image = pygame.transform.scale(self.image, (100, 50))
    self.rect = self.image.get_rect()

    self.rect.bottom = screen_rect.bottom
    self.rect.centerx = screen_rect.centerx
    self.move_x = 0
    self.shots = []
    self.shots_count = 0
    self.max_shots = 2

DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    self.image = pygame.image.load("ball3.png")
    self.rect = self.image.get_rect()
    self.rect.centerx = x
    self.rect.centery = y
    self.is_alive = True

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19966094_19966608_10_30
19966094_19966608_145_166
Title: Space Invaders project 
----------------------------------------

def __init__(self, screen_rect) :
INDENT
    self.image = pygame.image.load("ball1.png")
    self.image = pygame.transform.scale(self.image, (100, 50))
    self.rect = self.image.get_rect()

    self.rect.bottom = screen_rect.bottom
    self.rect.centerx = screen_rect.centerx
    self.move_x = 0
    self.shots = []
    self.shots_count = 0
    self.max_shots = 2

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    w, h = 800, 800
    self.screen = pygame.display.set_mode((w, h))
    pygame.mouse.set_visible(False)
    self.ship = Ship(self.screen.get_rect())
    self.enemies = []
    for i in range(100, 800, 100) :
    INDENT
        self.enemies.append(Enemy(i, 100))
    DEDENT
    font = pygame.font.SysFont("", 72)
    self.text_paused = font.render("PAUSED", True, (255, 0, 0))
    self.text_paused_rect = self.text_paused.get_rect(center = self.screen.get_rect().center)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19966094_19966608_10_30
19966094_19966608_85_98
Title: Space Invaders project 
----------------------------------------

def __init__(self, screen_rect) :
INDENT
    self.image = pygame.image.load("ball1.png")
    self.image = pygame.transform.scale(self.image, (100, 50))
    self.rect = self.image.get_rect()

    self.rect.bottom = screen_rect.bottom
    self.rect.centerx = screen_rect.centerx
    self.move_x = 0
    self.shots = []
    self.shots_count = 0
    self.max_shots = 2

DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    self.image = pygame.image.load("ball2.png")
    self.image = pygame.transform.scale(self.image, (25, 25))
    self.rect = self.image.get_rect()
    self.rect.centerx = x
    self.rect.centery = y
    self.is_alive = True

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19966094_19966608_116_127
19966094_19966608_145_166
Title: Space Invaders project 
----------------------------------------

def __init__(self, x, y) :
INDENT
    self.image = pygame.image.load("ball3.png")
    self.rect = self.image.get_rect()
    self.rect.centerx = x
    self.rect.centery = y
    self.is_alive = True

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    w, h = 800, 800
    self.screen = pygame.display.set_mode((w, h))
    pygame.mouse.set_visible(False)
    self.ship = Ship(self.screen.get_rect())
    self.enemies = []
    for i in range(100, 800, 100) :
    INDENT
        self.enemies.append(Enemy(i, 100))
    DEDENT
    font = pygame.font.SysFont("", 72)
    self.text_paused = font.render("PAUSED", True, (255, 0, 0))
    self.text_paused_rect = self.text_paused.get_rect(center = self.screen.get_rect().center)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19966094_19966608_116_127
19966094_19966608_85_98
Title: Space Invaders project 
----------------------------------------

def __init__(self, x, y) :
INDENT
    self.image = pygame.image.load("ball3.png")
    self.rect = self.image.get_rect()
    self.rect.centerx = x
    self.rect.centery = y
    self.is_alive = True

DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    self.image = pygame.image.load("ball2.png")
    self.image = pygame.transform.scale(self.image, (25, 25))
    self.rect = self.image.get_rect()
    self.rect.centerx = x
    self.rect.centery = y
    self.is_alive = True

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19966094_19966608_145_166
19966094_19966608_85_98
Title: Space Invaders project 
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    w, h = 800, 800
    self.screen = pygame.display.set_mode((w, h))
    pygame.mouse.set_visible(False)
    self.ship = Ship(self.screen.get_rect())
    self.enemies = []
    for i in range(100, 800, 100) :
    INDENT
        self.enemies.append(Enemy(i, 100))
    DEDENT
    font = pygame.font.SysFont("", 72)
    self.text_paused = font.render("PAUSED", True, (255, 0, 0))
    self.text_paused_rect = self.text_paused.get_rect(center = self.screen.get_rect().center)

DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    self.image = pygame.image.load("ball2.png")
    self.image = pygame.transform.scale(self.image, (25, 25))
    self.rect = self.image.get_rect()
    self.rect.centerx = x
    self.rect.centery = y
    self.is_alive = True

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19966094_19966608_48_63
19966094_19966608_99_107
Title: Space Invaders project 
----------------------------------------

def update(self) :
INDENT
    self.rect.x += self.move_x
    for s in self.shots :
    INDENT
        s.update()
    DEDENT
    for i in range(len(self.shots) - 1, - 1, - 1) :
    INDENT
        print "debug: Ship.update: testing bullet ", i
        if not self.shots [i].is_alive :
        INDENT
            print "debug: Ship.update: removing bullet ", i
            del self.shots [i]

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    self.rect.y -= 15
    if self.rect.y < 0 :
    INDENT
        self.is_alive = False

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19969529_19969556_1_9
19969529_19969558_1_10
Title: How can I make this python function start at the beginning if a positive number is entered? 
----------------------------------------

def factorial(number) :
INDENT
    number = int(number)
    if number > 0 :
    INDENT
        return number * factorial(number - 1)
    DEDENT
    elif number == 0 or number == 1 :
    INDENT
        return 1
    DEDENT
    else :
    INDENT
        return ('TRY AGAIN')
    DEDENT
DEDENT
----------------------------------------

def factorial(number) :
INDENT
    number = int(number)
    if number in (0, 1) :
    INDENT
        return 1
    DEDENT
    elif number < 0 :
    INDENT
        return ('TRY AGAIN')
    DEDENT
    else :
    INDENT
        return number * factorial(number - 1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19989910_19990227_1_14
19989910_19990371_1_21
Title: Recursion binary search in Python 
----------------------------------------

def binary_search(list, element, min = 0, max = None) :
INDENT
    max = max or len(list) - 1
    if max < min :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        mid = min + (max - min) / 2
    DEDENT
    if mid > element :
    INDENT
        return binary_search(list, element, min, mid - 1)
    DEDENT
    elif mid < element :
    INDENT
        return binary_search(list, element, mid + 1, max)
    DEDENT
    else :
    INDENT
        return mid
    DEDENT
DEDENT
----------------------------------------

def binary_search(value, items, low = 0, high = None) :
INDENT
    high = len(items) if high is None else high
    pos = low + (high - low) / len(items)
    if pos == len(items) :
    INDENT
        return False
    DEDENT
    elif items [pos] == value :
    INDENT
        return pos
    DEDENT
    elif high == low :
    INDENT
        return False
    DEDENT
    elif items [pos] < value :
    INDENT
        return binary_search(value, items, pos + 1, high)
    DEDENT
    else :
    INDENT
        assert items [pos] > value
        return binary_search(value, items, low, pos)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19989910_19990227_1_14
19989910_24501846_1_16
Title: Recursion binary search in Python 
----------------------------------------

def binary_search(list, element, min = 0, max = None) :
INDENT
    max = max or len(list) - 1
    if max < min :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        mid = min + (max - min) / 2
    DEDENT
    if mid > element :
    INDENT
        return binary_search(list, element, min, mid - 1)
    DEDENT
    elif mid < element :
    INDENT
        return binary_search(list, element, mid + 1, max)
    DEDENT
    else :
    INDENT
        return mid
    DEDENT
DEDENT
----------------------------------------

def binary_search(array, element, mini = 0, maxi = None) :
INDENT
    maxi = len(array) - 1 if maxi is None else maxi
    if mini == maxi :
    INDENT
        return array [mini] == element
    DEDENT
    else :
    INDENT
        median = (maxi + mini) / 2
        if array [median] == element :
        INDENT
            return True
        DEDENT
        elif array [median] > element :
        INDENT
            return binary_search(array, element, mini, median)
        DEDENT
        else :
        INDENT
            return binary_search(array, element, median + 1, maxi)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19989910_19990227_1_14
19989910_41270921_1_17
Title: Recursion binary search in Python 
----------------------------------------

def binary_search(list, element, min = 0, max = None) :
INDENT
    max = max or len(list) - 1
    if max < min :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        mid = min + (max - min) / 2
    DEDENT
    if mid > element :
    INDENT
        return binary_search(list, element, min, mid - 1)
    DEDENT
    elif mid < element :
    INDENT
        return binary_search(list, element, mid + 1, max)
    DEDENT
    else :
    INDENT
        return mid
    DEDENT
DEDENT
----------------------------------------

def binary_search(item, arr) :
INDENT
    def _binary_search(item, first, last, arr) :
    INDENT
        if last < first :
        INDENT
            return False
        DEDENT
        if last == first :
        INDENT
            return arr [last] == item
        DEDENT
        mid = (first + last) / / 2
        if arr [mid] > item :
        INDENT
            last = mid
            return _binary_search(item, first, last, arr)
        DEDENT
        elif arr [mid] < item :
        INDENT
            first = mid + 1
            return _binary_search(item, first, last, arr)
        DEDENT
        else :
        INDENT
            return arr [mid] == item
        DEDENT
        return _binary_search(item, 0, len(arr) - 1, arr)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19989910_19990371_1_21
19989910_24501846_1_16
Title: Recursion binary search in Python 
----------------------------------------

def binary_search(value, items, low = 0, high = None) :
INDENT
    high = len(items) if high is None else high
    pos = low + (high - low) / len(items)
    if pos == len(items) :
    INDENT
        return False
    DEDENT
    elif items [pos] == value :
    INDENT
        return pos
    DEDENT
    elif high == low :
    INDENT
        return False
    DEDENT
    elif items [pos] < value :
    INDENT
        return binary_search(value, items, pos + 1, high)
    DEDENT
    else :
    INDENT
        assert items [pos] > value
        return binary_search(value, items, low, pos)
    DEDENT
DEDENT
----------------------------------------

def binary_search(array, element, mini = 0, maxi = None) :
INDENT
    maxi = len(array) - 1 if maxi is None else maxi
    if mini == maxi :
    INDENT
        return array [mini] == element
    DEDENT
    else :
    INDENT
        median = (maxi + mini) / 2
        if array [median] == element :
        INDENT
            return True
        DEDENT
        elif array [median] > element :
        INDENT
            return binary_search(array, element, mini, median)
        DEDENT
        else :
        INDENT
            return binary_search(array, element, median + 1, maxi)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19989910_19990371_1_21
19989910_41270921_1_17
Title: Recursion binary search in Python 
----------------------------------------

def binary_search(value, items, low = 0, high = None) :
INDENT
    high = len(items) if high is None else high
    pos = low + (high - low) / len(items)
    if pos == len(items) :
    INDENT
        return False
    DEDENT
    elif items [pos] == value :
    INDENT
        return pos
    DEDENT
    elif high == low :
    INDENT
        return False
    DEDENT
    elif items [pos] < value :
    INDENT
        return binary_search(value, items, pos + 1, high)
    DEDENT
    else :
    INDENT
        assert items [pos] > value
        return binary_search(value, items, low, pos)
    DEDENT
DEDENT
----------------------------------------

def binary_search(item, arr) :
INDENT
    def _binary_search(item, first, last, arr) :
    INDENT
        if last < first :
        INDENT
            return False
        DEDENT
        if last == first :
        INDENT
            return arr [last] == item
        DEDENT
        mid = (first + last) / / 2
        if arr [mid] > item :
        INDENT
            last = mid
            return _binary_search(item, first, last, arr)
        DEDENT
        elif arr [mid] < item :
        INDENT
            first = mid + 1
            return _binary_search(item, first, last, arr)
        DEDENT
        else :
        INDENT
            return arr [mid] == item
        DEDENT
        return _binary_search(item, 0, len(arr) - 1, arr)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19989910_24501846_1_16
19989910_41270921_1_17
Title: Recursion binary search in Python 
----------------------------------------

def binary_search(array, element, mini = 0, maxi = None) :
INDENT
    maxi = len(array) - 1 if maxi is None else maxi
    if mini == maxi :
    INDENT
        return array [mini] == element
    DEDENT
    else :
    INDENT
        median = (maxi + mini) / 2
        if array [median] == element :
        INDENT
            return True
        DEDENT
        elif array [median] > element :
        INDENT
            return binary_search(array, element, mini, median)
        DEDENT
        else :
        INDENT
            return binary_search(array, element, median + 1, maxi)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def binary_search(item, arr) :
INDENT
    def _binary_search(item, first, last, arr) :
    INDENT
        if last < first :
        INDENT
            return False
        DEDENT
        if last == first :
        INDENT
            return arr [last] == item
        DEDENT
        mid = (first + last) / / 2
        if arr [mid] > item :
        INDENT
            last = mid
            return _binary_search(item, first, last, arr)
        DEDENT
        elif arr [mid] < item :
        INDENT
            first = mid + 1
            return _binary_search(item, first, last, arr)
        DEDENT
        else :
        INDENT
            return arr [mid] == item
        DEDENT
        return _binary_search(item, 0, len(arr) - 1, arr)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19989910_40851015_1_12
19989910_46080558_1_13
Title: Recursion binary search in Python 
----------------------------------------

def binary_search_recursive(list1, element) :
INDENT
    if len(list1) == 0 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        mid = len(list1) / / 2
        if (element == list1 [mid]) :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            if element > list1 [mid] :
            INDENT
                return binary_search_recursive(list1 [mid + 1 :], element)
            DEDENT
            else :
            INDENT
                return binary_search_recursive(list1 [: mid], element)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def binary_search_recursive(arr, elem, start = 0, end = None) :
INDENT
    if end is None :
    INDENT
        end = len(arr) - 1
    DEDENT
    if start > end :
    INDENT
        return False
    DEDENT
    mid = (start + end) / / 2
    if elem == arr [mid] :
    INDENT
        return mid
    DEDENT
    if elem < arr [mid] :
    INDENT
        return binary_search_recursive(arr, elem, start, mid - 1)
    DEDENT
    return binary_search_recursive(arr, elem, mid + 1, end)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19989910_40851015_1_12
19989910_51846058_1_26
Title: Recursion binary search in Python 
----------------------------------------

def binary_search_recursive(list1, element) :
INDENT
    if len(list1) == 0 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        mid = len(list1) / / 2
        if (element == list1 [mid]) :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            if element > list1 [mid] :
            INDENT
                return binary_search_recursive(list1 [mid + 1 :], element)
            DEDENT
            else :
            INDENT
                return binary_search_recursive(list1 [: mid], element)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def binary_search_recursive(list_of_numbers, number, start = 0, end = None) :
INDENT
    if end is None :
    INDENT
        end = len(list_of_numbers) - 1
    DEDENT
    if start > end :
    INDENT
        raise ValueError('Number not in list')
    DEDENT
    mid = (start + end) / / 2
    if number == list_of_numbers [mid] :
    INDENT
        return mid
    DEDENT
    if number < list_of_numbers [mid] :
    INDENT
        return binary_search_recursive(list_of_numbers, number, start, mid - 1)

    DEDENT
    return binary_search_recursive(list_of_numbers, number, mid + 1, end)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19990861_19992230_1_9
19990861_36622432_1_12
Title: Checking for sublist in list 
----------------------------------------

def isSublist(list_, sublist) :
INDENT
    if not isinstance(list_, list) :
    INDENT
        list_ = list(list_)
    DEDENT
    sublen = len(sublist)
    for i in xrange(len(list_) - sublen + 1) :
    INDENT
        if list_ [i : i + sublen] == sublist :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def isSublist(x, y) :
INDENT
    occ = [i for i, a in enumerate(x) if a == y [0]]
    for b in occ :
    INDENT
        if x [b : b + len(y)] == y :
        INDENT
            print 'YES-- SUBLIST at : ', b
            return True
        DEDENT
        else :
        INDENT
            pass
        DEDENT
        if len(occ) - 1 == occ.index(b) :
        INDENT
            print 'NO SUBLIST'
            return False
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19993078_19993079_160_200
19993078_19993079_69_121
Title: Looking for a simple OpenGL (3.2+) Python example that uses GLFW 
----------------------------------------

def __init__(self) :
INDENT
    cwd = os.getcwd()

    glfw.Init()

    os.chdir(cwd)

    glfw.WindowHint(glfw.CONTEXT_VERSION_MAJOR, 3)
    glfw.WindowHint(glfw.CONTEXT_VERSION_MINOR, 3)
    glfw.WindowHint(glfw.OPENGL_FORWARD_COMPAT, GL_TRUE)
    glfw.WindowHint(glfw.OPENGL_PROFILE, glfw.OPENGL_CORE_PROFILE)

    self.width, self.height = 640, 480
    self.aspect = self.width / float(self.height)
    self.win = glfw.CreateWindow(self.width, self.height, "test")
    glfw.MakeContextCurrent(self.win)

    glViewport(0, 0, self.width, self.height)
    glEnable(GL_DEPTH_TEST)
    glClearColor(0.5, 0.5, 0.5, 1.0)

    glfw.SetMouseButtonCallback(self.win, self.onMouseButton)
    glfw.SetKeyCallback(self.win, self.onKeyboard)
    glfw.SetWindowSizeCallback(self.win, self.onSize)

    self.scene = Scene()

    self.exitNow = False

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.program = glutils.loadShaders(strVS, strFS)
    glUseProgram(self.program)
    self.pMatrixUniform = glGetUniformLocation(self.program,
        'uPMatrix')
    self.mvMatrixUniform = glGetUniformLocation(self.program,
        "uMVMatrix")
    self.colorU = glGetUniformLocation(self.program, "uColor")

    self.col0 = [1.0, 0.0, 0.0, 1.0]

    self.tex2D = glGetUniformLocation(self.program, "tex2D")

    quadV = [
        - 0.5, - 0.5, 0.0,
        0.5, - 0.5, 0.0,
        - 0.5, 0.5, 0.0,
        0.5, 0.5, 0.0]

    self.vao = glGenVertexArrays(1)
    glBindVertexArray(self.vao)
    self.vertexBuffer = glGenBuffers(1)
    glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
    vertexData = numpy.array(quadV, numpy.float32)
    glBufferData(GL_ARRAY_BUFFER, 4 * len(vertexData), vertexData,
        GL_STATIC_DRAW)
    glEnableVertexAttribArray(0)
    glBindBuffer(GL_ARRAY_BUFFER, self.vertexBuffer)
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, None)
    glBindVertexArray(0)

    self.t = 0

    self.texId = glutils.loadTexture('test.png')

    self.showCircle = False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1999727_2000143_4_21
1999727_2000783_1_14
Title: Find the type of an attribute in a class 
----------------------------------------

def populate_object_properties(values_as_strings,
object_to_populate,
properties_to_populate) :
INDENT
    for k in properties_to_populate :
    INDENT
        value = values_as_strings.get(k)

        if value :
        INDENT
            setattr(object_to_populate, k, value)
        DEDENT
        else :
        INDENT
            setattr(object_to_populate, k, None)

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def populate_object_properties(values_as_strings,
object_to_populate,
properties_to_populate) :
INDENT
    model_properties = object_to_populate.properties()
    for k in properties_to_populate :
    INDENT
        value = values_as_strings.get(k)
        model_property = model_properties.get(k)
        if value :
        INDENT
            if isinstance(model_property, StringProperty) :
            INDENT
                setattr(object_to_populate, k, str(value))
            DEDENT
            elif isinstance(model_property, IntegerProperty) :
            INDENT
                setattr(object_to_populate, k, int(value))
            DEDENT
        DEDENT
        else :
        INDENT
            setattr(object_to_populate, k, None)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20005173_20005318_1_17
20005173_20006230_1_16
Title: "Maximum minimum and total numbers" 
----------------------------------------

def maxmin() :
INDENT
    minimum = None
    maximum = None
    num = None
    while True :
    INDENT
        num = input('Please enter a number, or -10 to stop: ')
        if num == - 10 :
        INDENT
            break
        DEDENT
        if (minimum) is None or (num < minimum) :
        INDENT
            minimum = num
        DEDENT
        if (maximum) is None or (num > maximum) :
        INDENT
            maximum = num
        DEDENT
    DEDENT
    print ("Maximum: ", maximum)
    print ("Minimum: ", minimum)
DEDENT
----------------------------------------

def maxmin() :
INDENT
    minimum, maximum, total = None, None, 0
    while (True) :
    INDENT
        number = input('Please enter a number, or -10 to stop: ')
        num = int(number)
        if num == - 10 :
        INDENT
            break
        DEDENT
        if total == 0 :
        INDENT
            minimum, maximum, total = num, num, 1
            continue
        DEDENT
        total += 1
        if num < minimum :
        INDENT
            minimum = num
        DEDENT
        elif num > maximum :
        INDENT
            maximum = num
        DEDENT
    DEDENT
    print ("Output : total ={}, minimum={}, maximum ={}".format(total, minimum, maximum))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20005173_20005397_1_16
20005173_20006230_1_16
Title: "Maximum minimum and total numbers" 
----------------------------------------

def maxmin() :
INDENT
    minimum = None
    maximum = None
    while True :
    INDENT
        num = input('Please enter a number, or -10 to stop: ')
        if num == - 10 :
        INDENT
            break
        DEDENT
        if (minimum) is None or (num < minimum) :
        INDENT
            minimum = num
        DEDENT
        if (maximum) is None or (num > maximum) :
        INDENT
            maximum = num
        DEDENT
    DEDENT
    print ("Maximum: ", maximum)
    print ("Minimum: ", minimum)
DEDENT
----------------------------------------

def maxmin() :
INDENT
    minimum, maximum, total = None, None, 0
    while (True) :
    INDENT
        number = input('Please enter a number, or -10 to stop: ')
        num = int(number)
        if num == - 10 :
        INDENT
            break
        DEDENT
        if total == 0 :
        INDENT
            minimum, maximum, total = num, num, 1
            continue
        DEDENT
        total += 1
        if num < minimum :
        INDENT
            minimum = num
        DEDENT
        elif num > maximum :
        INDENT
            maximum = num
        DEDENT
    DEDENT
    print ("Output : total ={}, minimum={}, maximum ={}".format(total, minimum, maximum))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20023045_20023236_4_11
20023045_20023299_1_17
Title: python recursion jumping to last cell 
----------------------------------------

def is_solvable(pos, board, seen) :
INDENT
    if pos < 0 or pos > = len(board) or pos in seen :
    INDENT
        return False
    DEDENT
    if board [pos] == 0 :
    INDENT
        return True
    DEDENT
    seen.append(pos)
    return is_solvable(pos + board [pos], board, seen) or is_solvable(pos + board [pos], board, seen)
DEDENT
----------------------------------------

def is_solvable(index, board, visited = None) :
INDENT
    if visited is None :
    INDENT
        visited = []
    DEDENT
    if index == len(board) - 1 :
    INDENT
        return True
    DEDENT
    elif index in visited :
    INDENT
        return False
    DEDENT
    elif index < 0 or index > = len(board) :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        visited.append(index)
        value = board [index]
        left = is_solvable(index - value, board, visited)
        right = is_solvable(index + value, board, visited)
        return left or right
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20053552_20054001_148_172
20053552_20054001_81_111
Title: why is my code still displaying the old panes? 
----------------------------------------

def event_handler(self, event) :
INDENT
    textToReturn = None

    for key in self.Keys :
    INDENT
        key.event_handler(event)
    DEDENT
    if event.type == pygame.MOUSEBUTTONUP :
    INDENT
        posx, posy = event.pos
        for key in self.Keys :
        INDENT
            if key.test_coordinates(posx, posy) :
            INDENT
                textToReturn = key.text()
                print textToReturn
            DEDENT
        DEDENT
        if textToReturn == 'Q' :
        INDENT
            self.onKeyQ(textToReturn)
        DEDENT
    DEDENT
    return textToReturn

DEDENT
----------------------------------------

def event_handler(self, event) :
INDENT
    self.currentFgColor = self.fgColor
    self.currentBgColor = self.bgColor

    if event.type == pygame.MOUSEMOTION :
    INDENT
        if self.rect.collidepoint(event.pos) :
        INDENT
            self.currentBgColor = self.mouseoverBgColor
            if self.is_movable and self.is_moving :
            INDENT
                self.rect.move_ip(event.rel)
                self.currentBgColor = (0, 0, 255)
            DEDENT
        DEDENT
    DEDENT
    elif event.type == pygame.MOUSEBUTTONDOWN :
    INDENT
        if self.rect.collidepoint(event.pos) :
        INDENT
            if self.is_movable :
            INDENT
                pygame.event.post(pygame.event.Event(evt_type.PANE, {'code' : evt_code.PANE_CLICKED, 'widget' : self}))
            DEDENT
            self.currentBgColor = (255, 0, 0)
            self.is_moving = True
        DEDENT
    DEDENT
    elif event.type == pygame.MOUSEBUTTONUP :
    INDENT
        if self.rect.collidepoint(event.pos) :
        INDENT
            self.currentBgColor = self.mouseoverBgColor
        DEDENT
        self.is_moving = False

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20053552_20054001_203_218
20053552_20054001_32_53
Title: why is my code still displaying the old panes? 
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    pygame.display.set_caption('Box Test')
    self.font = pygame.font.SysFont('Arial', 25)
    self.screen = pygame.display.set_mode((1366, 768), 0, 32)
    self.show_panes = True
    self.createPanes()
    self.keyboard = Keyboard(self.screen)

DEDENT
----------------------------------------

def __init__(self, textToDisplay, rect, screen, fgColor = (0, 0, 0), bgColor = (255, 255, 255), mouseoverBgColor = (255, 255, 0)) :
INDENT
    self.textToDisplay = textToDisplay
    self.rect = pygame.Rect(* rect)
    self.screen = screen

    self.fgColor = fgColor
    self.bgColor = bgColor
    self.mouseoverBgColor = mouseoverBgColor
    self.currentFgColor = self.fgColor
    self.currentBgColor = self.bgColor
    self.font = pygame.font.SysFont('Palace Script MT', 25)
    self.is_movable = True
    self.is_moving = False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20053552_20054001_268_291
20053552_20054001_81_111
Title: why is my code still displaying the old panes? 
----------------------------------------

def event_handler(self, event) :
INDENT
    textToReturn = None

    for pane in self.Panes :
    INDENT
        pane.event_handler(event)
    DEDENT
    if event.type == pygame.MOUSEBUTTONUP :
    INDENT
        posx, posy = event.pos
        for pane in self.Panes :
        INDENT
            if pane.test_coordinates(posx, posy) :
            INDENT
                textToReturn = pane.text()
                if textToReturn == "Keyboard" :
                INDENT
                    self.keyboard.visible = True
                    self.show_panes = False
                DEDENT
                print textToReturn
            DEDENT
        DEDENT
    DEDENT
    return textToReturn

DEDENT
----------------------------------------

def event_handler(self, event) :
INDENT
    self.currentFgColor = self.fgColor
    self.currentBgColor = self.bgColor

    if event.type == pygame.MOUSEMOTION :
    INDENT
        if self.rect.collidepoint(event.pos) :
        INDENT
            self.currentBgColor = self.mouseoverBgColor
            if self.is_movable and self.is_moving :
            INDENT
                self.rect.move_ip(event.rel)
                self.currentBgColor = (0, 0, 255)
            DEDENT
        DEDENT
    DEDENT
    elif event.type == pygame.MOUSEBUTTONDOWN :
    INDENT
        if self.rect.collidepoint(event.pos) :
        INDENT
            if self.is_movable :
            INDENT
                pygame.event.post(pygame.event.Event(evt_type.PANE, {'code' : evt_code.PANE_CLICKED, 'widget' : self}))
            DEDENT
            self.currentBgColor = (255, 0, 0)
            self.is_moving = True
        DEDENT
    DEDENT
    elif event.type == pygame.MOUSEBUTTONUP :
    INDENT
        if self.rect.collidepoint(event.pos) :
        INDENT
            self.currentBgColor = self.mouseoverBgColor
        DEDENT
        self.is_moving = False

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20068945_20072906_7_26
20068945_23035464_2_23
Title: "Detect if image is color grayscale or black and white with Python/PIL" 
----------------------------------------

def detect_color_image(file) :
INDENT
    v = ImageStat.Stat(Image.open(file)).var
    is_monochromatic = reduce(lambda x, y : x and y < MONOCHROMATIC_MAX_VARIANCE, v, True)
    print file, '-->\t',
    if is_monochromatic :
    INDENT
        print "Monochromatic image",
    DEDENT
    else :
    INDENT
        if len(v) == 3 :
        INDENT
            maxmin = abs(max(v) - min(v))
            if maxmin > COLOR :
            INDENT
                print "Color\t\t\t",
            DEDENT
            elif maxmin > MAYBE_COLOR :
            INDENT
                print "Maybe color\t",
            DEDENT
            else :
            INDENT
                print "grayscale\t\t",
            DEDENT
            print "(", maxmin, ")"
        DEDENT
        elif len(v) == 1 :
        INDENT
            print "Black and white"
        DEDENT
        else :
        INDENT
            print "Don't know..."
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def detect_color_image(file, thumb_size = 40, MSE_cutoff = 22, adjust_color_bias = True) :
INDENT
    pil_img = Image.open(file)
    bands = pil_img.getbands()
    if bands == ('R', 'G', 'B') or bands == ('R', 'G', 'B', 'A') :
    INDENT
        thumb = pil_img.resize((thumb_size, thumb_size))
        SSE, bias = 0, [0, 0, 0]
        if adjust_color_bias :
        INDENT
            bias = ImageStat.Stat(thumb).mean [: 3]
            bias = [b - sum(bias) / 3 for b in bias]
        DEDENT
        for pixel in thumb.getdata() :
        INDENT
            mu = sum(pixel) / 3
            SSE += sum((pixel [i] - mu - bias [i]) * (pixel [i] - mu - bias [i]) for i in [0, 1, 2])
        DEDENT
        MSE = float(SSE) / (thumb_size * thumb_size)
        if MSE < = MSE_cutoff :
        INDENT
            print "grayscale\t",
        DEDENT
        else :
        INDENT
            print "Color\t\t\t",
        DEDENT
        print "( MSE=", MSE, ")"
    DEDENT
    elif len(bands) == 1 :
    INDENT
        print "Black and white", bands
    DEDENT
    else :
    INDENT
        print "Don't know...", bands
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2007195_2007515_8_17
2007195_9404645_28_35
Title: Piston customize response representation 
----------------------------------------

def read(self, request, zip_code) :
INDENT
    try :
    INDENT
        points = DeliveryPoint.objects.filter(zip_code = zip_code).order_by("name")
        dps = []
        for p in points :
        INDENT
            name = p.name if (len(p.name) < = 16) else p.name [: 16] + "..."
            dps.append({'name' : name, 'zone' : p.zone, 'price' : p.price})
        DEDENT
        return {'length' : len(dps), 'dps' : dps}
    DEDENT
    except Exception, e :
    INDENT
        return {'length' : 0, "error" : e}
    DEDENT
DEDENT
----------------------------------------

def read(self, request, id = None) :
INDENT
    if id :
    INDENT
        try :
        INDENT
            return Choice.objects.get(id = id)
        DEDENT
        except Choice.DoesNotExist, e :
        INDENT
            return {}
        DEDENT
    DEDENT
    else :
    INDENT
        return Choice.objects.all()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2007786_2007941_6_19
2007786_2008827_7_37
Title: Python decorator with instantiation-time variable? 
----------------------------------------

def dec(f) :
INDENT
    def new(self, * args, ** kwargs) :
    INDENT
        print self.initiated
        return f(self, * args, ** kwargs)
    DEDENT
    try :
    INDENT
        d = inspect.getsourcelines(f)
    DEDENT
    except IOError :
    INDENT
        d = "<unable to fetch definition>"
    DEDENT
    else :
    INDENT
        d = d [0] [1].rstrip('\n').rstrip(':').lstrip(' ').lstrip('def')
    DEDENT
    new.__doc__ = d + "\n" + (f.__doc__ or '')
    return new
DEDENT
----------------------------------------

def dec(func) :
INDENT
    sig = []
    @ wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        ret = None
        if args and getattr(args [0], func.__name__, None) :
        INDENT
            instance, args = args [0], args [1 :]
            if not hasattr(instance, "sig") :
            INDENT
                instance.sig = []
            DEDENT
            ret = func(instance, * args, ** kwargs)
            print "Sig of %s is %s" % (func.__name__, id(instance.sig))
        DEDENT
        else :
        INDENT
            ret = func(* args, ** kwargs)
            print "Sig of %s is %s" % (func.__name__, id(sig))
        DEDENT
        return ret

    DEDENT
    try :
    INDENT
        docs = inspect.getsourcelines(func)
    DEDENT
    except :
    INDENT
        docs = "<unable to fetch defintion>"
    DEDENT
    else :
    INDENT
        docs = docs [0] [1].rstrip('\n').rstrip(':').lstrip(' ').lstrip('def')
    DEDENT
    wrapper.__doc__ = docs + "\n" + (func.__doc__ or '')
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2007786_2007941_6_19
2007786_2010159_6_60
Title: Python decorator with instantiation-time variable? 
----------------------------------------

def dec(f) :
INDENT
    def new(self, * args, ** kwargs) :
    INDENT
        print self.initiated
        return f(self, * args, ** kwargs)
    DEDENT
    try :
    INDENT
        d = inspect.getsourcelines(f)
    DEDENT
    except IOError :
    INDENT
        d = "<unable to fetch definition>"
    DEDENT
    else :
    INDENT
        d = d [0] [1].rstrip('\n').rstrip(':').lstrip(' ').lstrip('def')
    DEDENT
    new.__doc__ = d + "\n" + (f.__doc__ or '')
    return new
DEDENT
----------------------------------------

def dec(cls = None) :
INDENT
    def subdec(func) :
    INDENT
        obj = []
        @ wraps(func)
        def wrapper(* args, ** kwargs) :
        INDENT
            if (args and type(args [0]) == cls) :
            INDENT
                instance = args [0]

                if not hasattr(instance, "_objs") :
                INDENT
                    instance._objs = {}
                DEDENT
                if func.__name__ not in instance._objs :
                INDENT
                    instance._objs [func.__name__] = []
                DEDENT
                func(* args, ** kwargs)

                print "obj of %s.%s is %s" % (
                    instance,
                    func.__name__,
                    id(instance._objs [func.__name__]))
            DEDENT
            else :
            INDENT

                func(* args, ** kwargs)
                print "obj of %s is %s" % (func.__name__, id(obj))
            DEDENT
        DEDENT
        try :
        INDENT
            doc = inspect.getsourcelines(func)
        DEDENT
        except IOError :
        INDENT
            line = "<unable to fetch definition>"
        DEDENT
        else :
        INDENT
            line = '@'
            i = 0
            while line.lstrip(' ').startswith("@") :
            INDENT
                try :
                INDENT
                    line = doc [0] [i]
                DEDENT
                except IndexError :
                INDENT
                    line = "<unable to fetch definition>"
                DEDENT
                i += 1
            DEDENT
        DEDENT
        line = line.rstrip('\n').rstrip(':').lstrip(' ').lstrip('def')
        wrapper.__doc__ = line + "\n" + (func.__doc__ or '')
        return wrapper
    DEDENT
    return subdec
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2007786_2008827_12_28
2007786_2010159_13_41
Title: Python decorator with instantiation-time variable? 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    ret = None
    if args and getattr(args [0], func.__name__, None) :
    INDENT
        instance, args = args [0], args [1 :]
        if not hasattr(instance, "sig") :
        INDENT
            instance.sig = []
        DEDENT
        ret = func(instance, * args, ** kwargs)
        print "Sig of %s is %s" % (func.__name__, id(instance.sig))
    DEDENT
    else :
    INDENT
        ret = func(* args, ** kwargs)
        print "Sig of %s is %s" % (func.__name__, id(sig))
    DEDENT
    return ret

DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    if (args and type(args [0]) == cls) :
    INDENT
        instance = args [0]

        if not hasattr(instance, "_objs") :
        INDENT
            instance._objs = {}
        DEDENT
        if func.__name__ not in instance._objs :
        INDENT
            instance._objs [func.__name__] = []
        DEDENT
        func(* args, ** kwargs)

        print "obj of %s.%s is %s" % (
            instance,
            func.__name__,
            id(instance._objs [func.__name__]))
    DEDENT
    else :
    INDENT

        func(* args, ** kwargs)
        print "obj of %s is %s" % (func.__name__, id(obj))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2007786_2008827_7_37
2007786_2010159_6_60
Title: Python decorator with instantiation-time variable? 
----------------------------------------

def dec(func) :
INDENT
    sig = []
    @ wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        ret = None
        if args and getattr(args [0], func.__name__, None) :
        INDENT
            instance, args = args [0], args [1 :]
            if not hasattr(instance, "sig") :
            INDENT
                instance.sig = []
            DEDENT
            ret = func(instance, * args, ** kwargs)
            print "Sig of %s is %s" % (func.__name__, id(instance.sig))
        DEDENT
        else :
        INDENT
            ret = func(* args, ** kwargs)
            print "Sig of %s is %s" % (func.__name__, id(sig))
        DEDENT
        return ret

    DEDENT
    try :
    INDENT
        docs = inspect.getsourcelines(func)
    DEDENT
    except :
    INDENT
        docs = "<unable to fetch defintion>"
    DEDENT
    else :
    INDENT
        docs = docs [0] [1].rstrip('\n').rstrip(':').lstrip(' ').lstrip('def')
    DEDENT
    wrapper.__doc__ = docs + "\n" + (func.__doc__ or '')
    return wrapper
DEDENT
----------------------------------------

def dec(cls = None) :
INDENT
    def subdec(func) :
    INDENT
        obj = []
        @ wraps(func)
        def wrapper(* args, ** kwargs) :
        INDENT
            if (args and type(args [0]) == cls) :
            INDENT
                instance = args [0]

                if not hasattr(instance, "_objs") :
                INDENT
                    instance._objs = {}
                DEDENT
                if func.__name__ not in instance._objs :
                INDENT
                    instance._objs [func.__name__] = []
                DEDENT
                func(* args, ** kwargs)

                print "obj of %s.%s is %s" % (
                    instance,
                    func.__name__,
                    id(instance._objs [func.__name__]))
            DEDENT
            else :
            INDENT

                func(* args, ** kwargs)
                print "obj of %s is %s" % (func.__name__, id(obj))
            DEDENT
        DEDENT
        try :
        INDENT
            doc = inspect.getsourcelines(func)
        DEDENT
        except IOError :
        INDENT
            line = "<unable to fetch definition>"
        DEDENT
        else :
        INDENT
            line = '@'
            i = 0
            while line.lstrip(' ').startswith("@") :
            INDENT
                try :
                INDENT
                    line = doc [0] [i]
                DEDENT
                except IndexError :
                INDENT
                    line = "<unable to fetch definition>"
                DEDENT
                i += 1
            DEDENT
        DEDENT
        line = line.rstrip('\n').rstrip(':').lstrip(' ').lstrip('def')
        wrapper.__doc__ = line + "\n" + (func.__doc__ or '')
        return wrapper
    DEDENT
    return subdec
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20091154_20138665_9_24
20091154_24042221_1_20
Title: sharing a namespace across multiple ipython notebooks 
----------------------------------------

def start_kernel(self, ** kwargs) :
INDENT
    kernel_id = kwargs.pop('kernel_id', str(uuid.uuid4()))
    if self.km is None :
    INDENT
        self.km = self.kernel_manager_factory(connection_file = os.path.join(
                self.connection_dir, "kernel-%s.json" % kernel_id),
            parent = self, autorestart = True, log = self.log)
    DEDENT
    if not self.km.is_alive() :
    INDENT
        self.log.info("starting single kernel")
        self.km.start_kernel(** kwargs)
    DEDENT
    else :
    INDENT
        self.log.info("reusing existing kernel")
    DEDENT
    self._kernels [kernel_id] = self.km
    return kernel_id
DEDENT
----------------------------------------

def start_kernel(self, kernel_id = None, path = None, ** kwargs) :
INDENT
    global saved_kernel_id
    if saved_kernel_id :
    INDENT
        return saved_kernel_id
    DEDENT
    if kernel_id is None :
    INDENT
        kwargs ['extra_arguments'] = self.kernel_argv
        if path is not None :
        INDENT
            kwargs ['cwd'] = self.cwd_for_path(path)
        DEDENT
        kernel_id = super(MappingKernelManager, self).start_kernel(** kwargs)
        self.log.info("Kernel started: %s" % kernel_id)
        self.log.debug("Kernel args: %r" % kwargs)
        self.add_restart_callback(kernel_id,
            lambda : self._handle_kernel_died(kernel_id),
            'dead',
            )
    DEDENT
    else :
    INDENT
        self._check_kernel_id(kernel_id)
        self.log.info("Using existing kernel: %s" % kernel_id)
    DEDENT
    saved_kernel_id = kernel_id
    return kernel_id
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20111758_20156856_4_14
20111758_45032701_4_14
Title: How to insert newline in python logging? 
----------------------------------------

def log_newline(self, how_many_lines = 1) :
INDENT
    self.removeHandler(self.console_handler)
    self.addHandler(self.blank_handler)
    for i in range(how_many_lines) :
    INDENT
        self.info('')

    DEDENT
    self.removeHandler(self.blank_handler)
    self.addHandler(self.console_handler)
DEDENT
----------------------------------------

def log_newline(self, how_many_lines = 1) :
INDENT
    self.handler.setFormatter(self.blank_formatter)
    for i in range(how_many_lines) :
    INDENT
        self.info('')

    DEDENT
    self.handler.setFormatter(self.formatter)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20136398_20136655_1_17
20136398_20136807_3_10
Title: Finding max element in a list 
----------------------------------------

def majority(li) :
INDENT
    count = dict()
    tgt = len(li) / / 2 + 1
    for key in li :
    INDENT
        if key in count :
        INDENT
            count [key] += 1
        DEDENT
        else :
        INDENT
            count [key] = 1
        DEDENT
    DEDENT
    print count
    for k, v in count.items() :
    INDENT
        if v > = tgt :
        INDENT
            return k
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def majority(iterable) :
INDENT
    c = Counter(iterable)
    value, count = c.most_common(1) [0]
    target = (len(iterable) / / 2) + 1
    if (count > = target) :
    INDENT
        return value
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
201461_201550_1_12
201461_201771_7_21
Title: Shortest Sudoku Solver in Python - How does it work? 
----------------------------------------

def r(a) :
INDENT
    i = a.find('0')
    ~ i or exit(a)
    inner_lexp = [(i - j) % 9 * (i / 9 ^ j / 9) * (i / 27 ^ j / 27 | i % 9 / 3 ^ j % 9 / 3) or a [j] for j in range(81)]

    [m in inner_lexp or r(a [: i] + m + a [i + 1 :]) for m in '%d' % 5 ** 18]

DEDENT
----------------------------------------

def r(a) :
INDENT
    i = a.find('0')
    if i == - 1 :
    INDENT
        sys.exit(a)
    DEDENT
    excluded_numbers = set()
    for j in range(81) :
    INDENT
        if same_row(i, j) or same_col(i, j) or same_block(i, j) :
        INDENT
            excluded_numbers.add(a [j])
        DEDENT
    DEDENT
    for m in '123456789' :
    INDENT
        if m not in excluded_numbers :
        INDENT

            r(a [: i] + m + a [i + 1 :])
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20146741_20146767_10_55
20146741_53209538_1_13
Title: Django per user view caching 
----------------------------------------

def cache_per_user(ttl = None, prefix = None, cache_post = False) :
INDENT
    def decorator(function) :
    INDENT
        def apply_cache(request, * args, ** kwargs) :
        INDENT
            if request.user.is_anonymous() :
            INDENT
                user = 'anonymous'
            DEDENT
            else :
            INDENT
                user = request.user.id

            DEDENT
            if prefix :
            INDENT
                CACHE_KEY = '%s_%s' % (prefix, user)
            DEDENT
            else :
            INDENT
                CACHE_KEY = 'view_cache_%s_%s' % (function.__name__, user)

            DEDENT
            if not cache_post and request.method == 'POST' :
            INDENT
                can_cache = False
            DEDENT
            else :
            INDENT
                can_cache = True
            DEDENT
            if can_cache :
            INDENT
                response = cache.get(CACHE_KEY, None)
            DEDENT
            else :
            INDENT
                response = None
            DEDENT
            if not response :
            INDENT
                response = function(request, * args, ** kwargs)
                if can_cache :
                INDENT
                    cache.set(CACHE_KEY, response, ttl)
                DEDENT
            DEDENT
            return response
        DEDENT
        return apply_cache
    DEDENT
    return decorator
DEDENT
----------------------------------------

def cache_per_user(timeout) :
INDENT
    def decorator(view_func) :
    INDENT
        @ wraps(view_func, assigned = available_attrs(view_func))
        def _wrapped_view(request, * args, ** kwargs) :
        INDENT
            user_id = 'not_auth'
            if request.user.is_authenticated :
            INDENT
                user_id = request.user.id
            DEDENT
            return cache_page(timeout, key_prefix = "_user_{}_".format(user_id))(view_func)(request, * args, ** kwargs)
        DEDENT
        return _wrapped_view
    DEDENT
    return decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20146741_20146767_24_54
20146741_34403173_17_39
Title: Django per user view caching 
----------------------------------------

def decorator(function) :
INDENT
    def apply_cache(request, * args, ** kwargs) :
    INDENT
        if request.user.is_anonymous() :
        INDENT
            user = 'anonymous'
        DEDENT
        else :
        INDENT
            user = request.user.id

        DEDENT
        if prefix :
        INDENT
            CACHE_KEY = '%s_%s' % (prefix, user)
        DEDENT
        else :
        INDENT
            CACHE_KEY = 'view_cache_%s_%s' % (function.__name__, user)

        DEDENT
        if not cache_post and request.method == 'POST' :
        INDENT
            can_cache = False
        DEDENT
        else :
        INDENT
            can_cache = True
        DEDENT
        if can_cache :
        INDENT
            response = cache.get(CACHE_KEY, None)
        DEDENT
        else :
        INDENT
            response = None
        DEDENT
        if not response :
        INDENT
            response = function(request, * args, ** kwargs)
            if can_cache :
            INDENT
                cache.set(CACHE_KEY, response, ttl)
            DEDENT
        DEDENT
        return response
    DEDENT
    return apply_cache
DEDENT
----------------------------------------

def decorator(function) :
INDENT
    def apply_cache(request, * args, ** kwargs) :
    INDENT
        CACHE_KEY = cache_key(request)
        if prefix :
        INDENT
            CACHE_KEY = '%s_%s' % (prefix, CACHE_KEY)
        DEDENT
        if not cache_post and request.method == 'POST' :
        INDENT
            can_cache = False
        DEDENT
        else :
        INDENT
            can_cache = True
        DEDENT
        if can_cache :
        INDENT
            response = core_cache.get(CACHE_KEY, None)
        DEDENT
        else :
        INDENT
            response = None
        DEDENT
        if not response :
        INDENT
            response = function(request, * args, ** kwargs)
            if can_cache :
            INDENT
                core_cache.set(CACHE_KEY, response, ttl)
            DEDENT
        DEDENT
        return response
    DEDENT
    return apply_cache
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20146741_20146767_24_54
20146741_53209538_2_12
Title: Django per user view caching 
----------------------------------------

def decorator(function) :
INDENT
    def apply_cache(request, * args, ** kwargs) :
    INDENT
        if request.user.is_anonymous() :
        INDENT
            user = 'anonymous'
        DEDENT
        else :
        INDENT
            user = request.user.id

        DEDENT
        if prefix :
        INDENT
            CACHE_KEY = '%s_%s' % (prefix, user)
        DEDENT
        else :
        INDENT
            CACHE_KEY = 'view_cache_%s_%s' % (function.__name__, user)

        DEDENT
        if not cache_post and request.method == 'POST' :
        INDENT
            can_cache = False
        DEDENT
        else :
        INDENT
            can_cache = True
        DEDENT
        if can_cache :
        INDENT
            response = cache.get(CACHE_KEY, None)
        DEDENT
        else :
        INDENT
            response = None
        DEDENT
        if not response :
        INDENT
            response = function(request, * args, ** kwargs)
            if can_cache :
            INDENT
                cache.set(CACHE_KEY, response, ttl)
            DEDENT
        DEDENT
        return response
    DEDENT
    return apply_cache
DEDENT
----------------------------------------

def decorator(view_func) :
INDENT
    @ wraps(view_func, assigned = available_attrs(view_func))
    def _wrapped_view(request, * args, ** kwargs) :
    INDENT
        user_id = 'not_auth'
        if request.user.is_authenticated :
        INDENT
            user_id = request.user.id
        DEDENT
        return cache_page(timeout, key_prefix = "_user_{}_".format(user_id))(view_func)(request, * args, ** kwargs)
    DEDENT
    return _wrapped_view
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20146741_20146767_25_53
20146741_34403173_18_38
Title: Django per user view caching 
----------------------------------------

def apply_cache(request, * args, ** kwargs) :
INDENT
    if request.user.is_anonymous() :
    INDENT
        user = 'anonymous'
    DEDENT
    else :
    INDENT
        user = request.user.id

    DEDENT
    if prefix :
    INDENT
        CACHE_KEY = '%s_%s' % (prefix, user)
    DEDENT
    else :
    INDENT
        CACHE_KEY = 'view_cache_%s_%s' % (function.__name__, user)

    DEDENT
    if not cache_post and request.method == 'POST' :
    INDENT
        can_cache = False
    DEDENT
    else :
    INDENT
        can_cache = True
    DEDENT
    if can_cache :
    INDENT
        response = cache.get(CACHE_KEY, None)
    DEDENT
    else :
    INDENT
        response = None
    DEDENT
    if not response :
    INDENT
        response = function(request, * args, ** kwargs)
        if can_cache :
        INDENT
            cache.set(CACHE_KEY, response, ttl)
        DEDENT
    DEDENT
    return response
DEDENT
----------------------------------------

def apply_cache(request, * args, ** kwargs) :
INDENT
    CACHE_KEY = cache_key(request)
    if prefix :
    INDENT
        CACHE_KEY = '%s_%s' % (prefix, CACHE_KEY)
    DEDENT
    if not cache_post and request.method == 'POST' :
    INDENT
        can_cache = False
    DEDENT
    else :
    INDENT
        can_cache = True
    DEDENT
    if can_cache :
    INDENT
        response = core_cache.get(CACHE_KEY, None)
    DEDENT
    else :
    INDENT
        response = None
    DEDENT
    if not response :
    INDENT
        response = function(request, * args, ** kwargs)
        if can_cache :
        INDENT
            core_cache.set(CACHE_KEY, response, ttl)
        DEDENT
    DEDENT
    return response
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20146741_34403173_17_39
20146741_53209538_2_12
Title: Django per user view caching 
----------------------------------------

def decorator(function) :
INDENT
    def apply_cache(request, * args, ** kwargs) :
    INDENT
        CACHE_KEY = cache_key(request)
        if prefix :
        INDENT
            CACHE_KEY = '%s_%s' % (prefix, CACHE_KEY)
        DEDENT
        if not cache_post and request.method == 'POST' :
        INDENT
            can_cache = False
        DEDENT
        else :
        INDENT
            can_cache = True
        DEDENT
        if can_cache :
        INDENT
            response = core_cache.get(CACHE_KEY, None)
        DEDENT
        else :
        INDENT
            response = None
        DEDENT
        if not response :
        INDENT
            response = function(request, * args, ** kwargs)
            if can_cache :
            INDENT
                core_cache.set(CACHE_KEY, response, ttl)
            DEDENT
        DEDENT
        return response
    DEDENT
    return apply_cache
DEDENT
----------------------------------------

def decorator(view_func) :
INDENT
    @ wraps(view_func, assigned = available_attrs(view_func))
    def _wrapped_view(request, * args, ** kwargs) :
    INDENT
        user_id = 'not_auth'
        if request.user.is_authenticated :
        INDENT
            user_id = request.user.id
        DEDENT
        return cache_page(timeout, key_prefix = "_user_{}_".format(user_id))(view_func)(request, * args, ** kwargs)
    DEDENT
    return _wrapped_view
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20147286_20155615_15_32
20147286_20158643_2_9
Title: issues with socket programming - python 
----------------------------------------

def __init__(self, server_address, HandlerClass, config) :
INDENT
    socketserver.BaseServer.__init__(self, server_address, HandlerClass)
    self.address_family = socket.AF_INET6
    self.connected = []
    self.logger = config ['logger']
    self.config = config
    self.socket = socket.socket(self.address_family, self.socket_type)
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    sc = Context(TLSv1_METHOD)
    sc.set_verify(VERIFY_PEER | VERIFY_FAIL_IF_NO_PEER_CERT, _sni.verify_cb)
    sc.set_tlsext_servername_callback(_sni.pick_certificate)
    self.sc = sc
    self.server_bind()
    self.server_activate()
DEDENT
----------------------------------------

def __init__(self, server_address, HandlerClass) :
INDENT
    socketserver.BaseServer.__init__(self, server_address, HandlerClass)
    self.address_family = socket.AF_INET
    self.socket = socket.socket(self.address_family, self.socket_type)
    self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    self.server_bind()
    self.server_activate()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20169137_31868210_15_30
20169137_38445233_4_55
Title: OpenCV with Python specific filter not same 
----------------------------------------

def kirsch_filter(img) :
INDENT
    if img.ndim > 2 :
    INDENT
        img = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)
    DEDENT
    fimg = numpy.maximum(cv2.filter2D(img, cv2.CV_8U, KIRSCH_K1),
        numpy.maximum(cv2.filter2D(img, cv2.CV_8U, KIRSCH_K2),
            numpy.maximum(cv2.filter2D(img, cv2.CV_8U, KIRSCH_K3),
                numpy.maximum(cv2.filter2D(img, cv2.CV_8U, KIRSCH_K4),
                    numpy.maximum(cv2.filter2D(img, cv2.CV_8U, KIRSCH_K5),
                        numpy.maximum(cv2.filter2D(img, cv2.CV_8U, KIRSCH_K6),
                            numpy.maximum(cv2.filter2D(img, cv2.CV_8U, KIRSCH_K7),
                                cv2.filter2D(img, cv2.CV_8U, KIRSCH_K8),
                                )))))))
    return (fimg)

DEDENT
----------------------------------------

def kirsch_filter(gray) :
INDENT
    if gray.ndim > 2 :
    INDENT
        raise Exception("illegal argument: input must be a single channel image (gray)")
    DEDENT
    kernelG1 = np.array([[5, 5, 5],
            [- 3, 0, - 3],
            [- 3, - 3, - 3]], dtype = np.float32)
    kernelG2 = np.array([[5, 5, - 3],
            [5, 0, - 3],
            [- 3, - 3, - 3]], dtype = np.float32)
    kernelG3 = np.array([[5, - 3, - 3],
            [5, 0, - 3],
            [5, - 3, - 3]], dtype = np.float32)
    kernelG4 = np.array([[- 3, - 3, - 3],
            [5, 0, - 3],
            [5, 5, - 3]], dtype = np.float32)
    kernelG5 = np.array([[- 3, - 3, - 3],
            [- 3, 0, - 3],
            [5, 5, 5]], dtype = np.float32)
    kernelG6 = np.array([[- 3, - 3, - 3],
            [- 3, 0, 5],
            [- 3, 5, 5]], dtype = np.float32)
    kernelG7 = np.array([[- 3, - 3, 5],
            [- 3, 0, 5],
            [- 3, - 3, 5]], dtype = np.float32)
    kernelG8 = np.array([[- 3, 5, 5],
            [- 3, 0, 5],
            [- 3, - 3, - 3]], dtype = np.float32)
    g1 = cv2.normalize(cv2.filter2D(gray, cv2.CV_32F, kernelG1), None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8UC1)
    g2 = cv2.normalize(cv2.filter2D(gray, cv2.CV_32F, kernelG2), None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8UC1)
    g3 = cv2.normalize(cv2.filter2D(gray, cv2.CV_32F, kernelG3), None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8UC1)
    g4 = cv2.normalize(cv2.filter2D(gray, cv2.CV_32F, kernelG4), None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8UC1)
    g5 = cv2.normalize(cv2.filter2D(gray, cv2.CV_32F, kernelG5), None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8UC1)
    g6 = cv2.normalize(cv2.filter2D(gray, cv2.CV_32F, kernelG6), None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8UC1)
    g7 = cv2.normalize(cv2.filter2D(gray, cv2.CV_32F, kernelG7), None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8UC1)
    g8 = cv2.normalize(cv2.filter2D(gray, cv2.CV_32F, kernelG8), None, 0, 255, cv2.NORM_MINMAX, cv2.CV_8UC1)
    magn = cv2.max(
        g1, cv2.max(
            g2, cv2.max(
                g3, cv2.max(
                    g4, cv2.max(
                        g5, cv2.max(
                            g6, cv2.max(
                                g7, g8)))))))
    return magn
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20175380_20175449_1_13
20175380_27994051_15_25
Title: quick sort python recursion 
----------------------------------------

def partition(lst, start, end) :
INDENT
    pos = start

    for i in range(start, end) :
    INDENT
        if lst [i] < lst [end] :
        INDENT
            lst [i], lst [pos] = lst [pos], lst [i]
            pos += 1
        DEDENT
    DEDENT
    lst [pos], lst [end] = lst [end], lst [pos]
    return pos
DEDENT
----------------------------------------

def partition(A, p, r) :
INDENT
    x = A [r]
    i = p - 1
    for j in range(p, r) :
    INDENT
        if A [j] < = x :
        INDENT
            i = i + 1
            a, b = A.index(A [i]), A.index(A [j])
            A [a], A [b] = A [b], A [a]
        DEDENT
    DEDENT
    d, c = A.index(A [i + 1]), A.index(A [r])
    A [c], A [d] = A [d], A [c]
    return i + 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20180594_20183823_11_25
20180594_20183823_124_135
Title: Pygame: Collision by Sides of Sprite 
----------------------------------------

def __init__(self, x = 0, y = 0, width = 150, height = 150) :
INDENT
    self.rect = pygame.Rect(x, y, width, height)
    self.speed_x = 5
    self.speed_y = 5
    self.move_x = 0
    self.move_y = 0
    self.collision = [False] * 9
    self.font = pygame.font.SysFont("", 32)
    self.text = "";
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    self.screen = pygame.display.set_mode((800, 600))
    pygame.display.set_caption("Side Collision")
    self.player = Player()
    self.enemy = Player()
    self.enemy.set_center(self.screen)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20187118_20187297_20_25
20187118_20187297_6_12
Title: Getting values from a dictionary 
----------------------------------------

def __init__(self) :
INDENT
    self.xy = []
    for i in X :
    INDENT
        for j in Y :
        INDENT
            self.xy.append(Combination(i, j))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    if (x in X) and (y in Y) :
    INDENT
        self.x = x
        self.y = y
    DEDENT
    else :
    INDENT
        print "WRONG!!"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20202922_20203112_3_13
20202922_20203723_7_14
Title: finding cosine using python 
----------------------------------------

def cos(a) :
INDENT
    d = 1
    c = 1
    for i in range(2, 20, 2) :
    INDENT
        d *= i * (i - 1)
        sign = - 1 if i % 4 else 1
        print ('adding {} * a ** {} / {}'.format(sign, i, d))
        c += sign * a ** i / d
        print ('cosine is now {}'.format(c))
    DEDENT
    return c
DEDENT
----------------------------------------

def cos(x, reps = 10) :
INDENT
    final_val = 1
    neg = - 1
    for n in range(2, reps * 2, 2) :
    INDENT
        final_val += neg * (x ** n) / factorial(n)
        neg *= - 1
    DEDENT
    return final_val
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20244096_20245666_21_40
20244096_20245666_2_7
Title: How do I deal with a logical expression in Python? 
----------------------------------------

def __init__(self, elt1, elt2 = None, op = "NOT") :
INDENT
    id1 = elt1.id
    if isinstance(elt1, CombinedElement) :
    INDENT
        id1 = '(' + id1 + ')'
    DEDENT
    if elt2 is not None :
    INDENT
        id2 = elt2.id
        if isinstance(elt2, CombinedElement) :
        INDENT
            id2 = '(' + id2 + ')'
        DEDENT
    DEDENT
    if op == "NOT" and elt2 is None :
    INDENT
        elt_id = "~" + id1
    DEDENT
    elif op == "OR" :
    INDENT
        elt_id = id1 + " v " + id2
    DEDENT
    elif op == "AND" :
    INDENT
        elt_id = id1 + " ^ " + id2
    DEDENT
    super(CombinedElement, self).__init__(elt_id)
DEDENT
----------------------------------------

def __init__(self, elt_id, elt_description = None) :
INDENT
    self.id = elt_id
    self.description = elt_description
    if self.description is None :
    INDENT
        self.description = self.id
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2024660_37158431_2_13
2024660_40706050_7_11
Title: Django | sort dict in template 
----------------------------------------

def listsort(value) :
INDENT
    if isinstance(value, dict) :
    INDENT
        a = []
        key_list = sorted(value.keys())
        for key in key_list :
        INDENT
            a.append((key, value [key]))
        DEDENT
        return a
    DEDENT
    elif isinstance(value, list) :
    INDENT
        return sorted(value)
    DEDENT
    else :
    INDENT
        return value
    DEDENT
DEDENT
----------------------------------------

def listsort(value) :
INDENT
    if isinstance(value, ItemsView) or isinstance(value, list) :
    INDENT
        return sorted(value)
    DEDENT
    else :
    INDENT
        return value
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2024660_40706050_7_11
2024660_8048313_7_18
Title: Django | sort dict in template 
----------------------------------------

def listsort(value) :
INDENT
    if isinstance(value, ItemsView) or isinstance(value, list) :
    INDENT
        return sorted(value)
    DEDENT
    else :
    INDENT
        return value
    DEDENT
DEDENT
----------------------------------------

def listsort(value) :
INDENT
    if isinstance(value, dict) :
    INDENT
        new_dict = SortedDict()
        key_list = sorted(value.keys())
        for key in key_list :
        INDENT
            new_dict [key] = value [key]
        DEDENT
        return new_dict
    DEDENT
    elif isinstance(value, list) :
    INDENT
        return sorted(value)
    DEDENT
    else :
    INDENT
        return value
    DEDENT
    listsort.is_safe = True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20294966_20295176_1_12
20294966_20295206_2_9
Title: How do I write a function that looks like it takes a list of function names and variable arguments for each function_name 
----------------------------------------

def master(mandatory_arg, * args) :
INDENT
    func = None
    funcArgs = []
    for a in args :
    INDENT
        if callable(a) :
        INDENT
            if func is not None : func(* funcArgs)
            func = a
            funcArgs = []
        DEDENT
        else :
        INDENT
            funcArgs.append(a)
        DEDENT
    DEDENT
    if func is not None : func(* funcArgs)
DEDENT
----------------------------------------

def master(mandatory_arg, * args) :
INDENT
    args = list(args)
    while args :
    INDENT
        f = args.pop(0)
        n = len(inspect.getargspec(f).args)
        p, args = args [: n], args [n :]
        f(* p)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20301857_20303515_118_127
20301857_20303515_61_99
Title: Pygame - AttributeError: 'int' object has no attribute 'y' 
----------------------------------------

def update(self, surface_rect) :
INDENT
    if self.direction_left :
    INDENT
        self.rect.x -= 1
        if self.rect.left < = surface_rect.left :
        INDENT
            self.direction_left = not self.direction_left
        DEDENT
    DEDENT
    else :
    INDENT
        self.rect.x += 1
        if self.rect.right > = surface_rect.right :
        INDENT
            self.direction_left = not self.direction_left
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def update(self, ground) :
INDENT
    self.vSpeed -= self.gravity
    if self.vSpeed > self.maxVspeed :
    INDENT
        self.vSpeed = self.maxVspeed
    DEDENT
    self.rect.y -= self.vSpeed
    if self.isJumping :
    INDENT
        self.vSpeed -= self.jumpForce
    DEDENT
    if self.rect.bottom > = ground.y :
    INDENT
        self.vSpeed = 0
        self.rect.bottom = ground.y
        self.isJumping = False

    DEDENT
    if self.timeNum == self.timeTarget :
    INDENT
        self.currentImage += 1
        if self.currentImage > = self.maxImage :
        INDENT
            self.currentImage = 0
        DEDENT
        self.timeNum = 0
    DEDENT
    self.rect.centerx += self.velX
    self.rect.centery += self.velY

    if self.rect.right > 1280 :
    INDENT
        self.rect.left = 0
    DEDENT
    elif self.rect.left < 0 :
    INDENT
        self.rect.right = 1280

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20301857_20303515_148_177
20301857_20303515_7_39
Title: Pygame - AttributeError: 'int' object has no attribute 'y' 
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()

    self.gravity =.50
    self.ground = pygame.Rect(0, 720, 0, 0)

    size = (1280, 720)
    self.screen = pygame.display.set_mode(size)
    pygame.display.set_caption('Moon Survival!')

    self.moon = Background()

    self.zombies = []
    for i in range(10) :
    INDENT
        self.zombies.append(Zombie(random.randint(0, 1280), random.randint(0, 720)))

    DEDENT
    self.player = Player(25, 320, self.gravity)

    self.font = pygame.font.SysFont(None, 72)

    self.pause_text = self.font.render("PAUSE", - 1, (255, 0, 0))
    self.pause_rect = self.pause_text.get_rect(center = self.screen.get_rect().center)
DEDENT
----------------------------------------

def __init__(self, x, y, gravity) :
INDENT
    self.gravity = gravity

    self.images = []
    self.images.append(pygame.image.load('images/soldier.png'))
    self.images.append(pygame.image.load('images/soldier2.png'))

    self.maxImage = len(self.images)
    self.currentImage = 0

    self.rect = self.images [0].get_rect()
    self.rect.x = x
    self.rect.y = y
    self.timeTarget = 10
    self.timeNum = 0
    self.velX = 0
    self.velY = 0

    self.vSpeed = 1
    self.jumpForce = 8
    self.maxVspeed = 3
    self.isJumping = False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20302350_20302640_1_24
20302350_20302835_1_25
Title: Appending list as an object to an existing list 
----------------------------------------

def convert(string) :
INDENT
    string = " " + string
    lst = []
    i = 0
    while i < len(string) - 1 :
    INDENT
        if string [i] == "(" :
        INDENT
            p = 0
            i2 = 0
            for i2 in range(i + 1, len(string)) :
            INDENT
                if string [i2] == ")" and p == 0 :
                INDENT
                    break
                DEDENT
                elif string [i2] == "(" :
                INDENT
                    p += 1
                DEDENT
                elif string [i2] == ")" and p > 0 :
                INDENT
                    p -= 1
                DEDENT
            DEDENT
            lst += [convert(string [i + 1 : i2])]
            i = i2
        DEDENT
        if string [i] == " " and string [i + 1] ! = "(" :
        INDENT
            try :
            INDENT
                lst += [getWord(string [i : :])]
            DEDENT
            except :
            INDENT
                pass
            DEDENT
        DEDENT
        i += 1
    DEDENT
    return lst
DEDENT
----------------------------------------

def convert(string) :
INDENT
    rc = []
    cstr = ''
    idx = 0
    while idx < len(string) :
    INDENT
        if string [idx] == '(' :
        INDENT
            rc.append(convert(string [idx + 1 :]))
            inc = string [idx + 1 :].find(')')
            if inc > = 0 :
            INDENT
                idx += (inc + 1)
            DEDENT
        DEDENT
        elif string [idx] == ')' :
        INDENT
            if len(cstr) :
            INDENT
                rc.append(cstr)
                cstr = ''
            DEDENT
            return rc
        DEDENT
        elif string [idx] == ' ' :
        INDENT
            if len(cstr) :
            INDENT
                rc.append(cstr)
                cstr = ''
            DEDENT
        DEDENT
        else :
        INDENT
            cstr += string [idx]
        DEDENT
        idx += 1
    DEDENT
    if len(cstr) :
    INDENT
        rc.append(cstr)
    DEDENT
    return rc
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2031559_2031591_5_11
2031559_2034646_46_55
Title: Python: Very confused about decorators 
----------------------------------------

def __call__(self, functionToBeDecorated) :
INDENT
    def wrapper(* args, ** kwargs) :
    INDENT
        if any(necessary not in kwargs ["ticket_params"] for necessary in self.l) :
        INDENT
            raise MyCustomException
        DEDENT
        return functionToBeDecorated(* args, ** kwargs)
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def __call__(self, params) :
INDENT
    def wrapper(params) :
    INDENT
        missing = self.required.difference(params)
        if missing :
        INDENT
            raise TypeError('Missing from "params" argument: %s' % ', '.join(sorted(missing)))
        DEDENT
    DEDENT
    return wrapper

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2031559_2031646_12_22
2031559_2034646_46_55
Title: Python: Very confused about decorators 
----------------------------------------

def __call__(self, functionToBeDecorated) :
INDENT
    def wrapper(* args, ** kwargs) :
    INDENT
        if "ticket_params" not in kwargs or any(necessary not in kwargs ["ticket_params"] for necessary in self.l) :
        INDENT
            raise MyCustomException
        DEDENT
        return functionToBeDecorated(* args, ** kwargs)
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def __call__(self, params) :
INDENT
    def wrapper(params) :
    INDENT
        missing = self.required.difference(params)
        if missing :
        INDENT
            raise TypeError('Missing from "params" argument: %s' % ', '.join(sorted(missing)))
        DEDENT
    DEDENT
    return wrapper

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20326898_20327257_24_31
20326898_20327257_4_14
Title: Implementing a Password Dialog with Tkinter 
----------------------------------------

def __init__(self, root) :
INDENT
    tk.Frame.__init__(self, root)
    self.password = None
    self.button = tk.Button(self)
    self.button ["text"] = "Password"
    self.button ["command"] = self.GetPassword
    self.button.pack()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Toplevel.__init__(self)
    self.parent = parent
    self.entry = tk.Entry(self, show = '*')
    self.entry.bind("<KeyRelease-Return>", self.StorePassEvent)
    self.entry.pack()
    self.button = tk.Button(self)
    self.button ["text"] = "Submit"
    self.button ["command"] = self.StorePass
    self.button.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20327017_20333772_1_23
20327017_22065785_1_14
Title: "Shorten a number of lists based on a collective max length moving excess to new lists" 
----------------------------------------

def shortenLists(maxLength, * input_lists) :
INDENT
    new_lists = [list(l) for l in input_lists]
    overflows = [[] for n in input_lists]

    for index, l in enumerate(new_lists) :
    INDENT
        overflows [index] = new_lists [index] [maxLength :]
        new_lists [index] = new_lists [index] [: maxLength]
        overflows [index].reverse()

    DEDENT
    while sum(len(l) for l in new_lists) > maxLength :
    INDENT

        index = max(enumerate(new_lists), key = lambda tup : len(tup [1])) [0]

        overflows [index].append(new_lists [index].pop())

    DEDENT
    [o.reverse() for o in overflows]
    return zip(new_lists, overflows)
DEDENT
----------------------------------------

def shortenLists(maxLength, * input_lists) :
INDENT
    overflows = [[] for n in input_lists]
    result_lists = [[] for n in input_lists]
    for i in xrange(len(input_lists)) :
    INDENT
        remaining = [l for idx, l in enumerate(input_lists) if not len(result_lists [idx])]
        shortestList = min(remaining, key = len)
        idxSL = input_lists.index(shortestList)
        numElems = int(math.floor(maxLength / len(remaining)))
        toCopy = min(numElems, len(shortestList))
        result_lists [idxSL] = shortestList [: toCopy]
        if numElems < len(shortestList) :
        INDENT
            overflows [idxSL] = shortestList [numElems :]
        DEDENT
        maxLength -= toCopy
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_106_113
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_118_123
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_128_133
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_138_145
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_150_157
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_162_169
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_174_179
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_184_189
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20331004_1_12
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(list) :
INDENT
    v = list [0]
    if len(list) > 1 :
    INDENT
        del list [0]
        dreh(list)
    DEDENT
    else :
    INDENT
        del list [0]

    DEDENT
    list.append(v)
    return list
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_118_123
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_128_133
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_138_145
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_150_157
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_162_169
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_174_179
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_184_189
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_106_113
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
        return LIST
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_118_123
20330480_20338108_138_145
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_118_123
20330480_20338108_150_157
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_118_123
20330480_20338108_162_169
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_118_123
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_118_123
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_118_123
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_118_123
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_118_123
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)]
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_128_133
20330480_20338108_162_169
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_128_133
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_128_133
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_128_133
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_128_133
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_128_133
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_138_145
20330480_20338108_174_179
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_138_145
20330480_20338108_184_189
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
