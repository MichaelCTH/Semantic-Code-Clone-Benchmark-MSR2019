$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38549822_38549939_1_18
38549822_38549959_1_13
Title: code passes all the tests but fails in other tests.. please follow the link 
----------------------------------------

def sum67(nums) :
INDENT
    total = 0
    n = 0
    while n < len(nums) :
    INDENT
        if nums [n] == 6 :
        INDENT
            while n < len(nums) and nums [n] ! = 7 :
            INDENT
                n += 1
            DEDENT
        DEDENT
        else :
        INDENT
            total += nums [n]

        DEDENT
        n += 1
    DEDENT
    return total
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    skip = False
    total = 0
    for x in nums :
    INDENT
        if skip :
        INDENT
            if x == 7 :
            INDENT
                skip = False
            DEDENT
        DEDENT
        elif x == 6 :
        INDENT
            skip = True
        DEDENT
        else :
        INDENT
            total += x
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38574025_38597031_19_30
38574025_38597031_2_17
Title: OOP techniques with Python GUI (PySide) elements 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Form, self).__init__(parent)
    self.pressure_line = LineItem('Pressure:', 'psi', self)
    self.temperature_line = LineItem('Temperature:', 'oC', self)
    layout = QHBoxLayout()
    layout.addWidget(self.pressure_line)
    layout.addWidget(self.temperature_line)
    self.setLayout(layout)
DEDENT
----------------------------------------

def __init__(self, label_text, unit_text, parent = None) :
INDENT
    super(LineItem, self).__init__(parent)
    self.label_field = QLabel(label_text)
    self.value_field = QLabel()
    self.units_field = QLabel(unit_text)
    layout = QVBoxLayout()
    layout.setContentsMargins(0, 0, 0, 0)
    layout.addWidget(self.label_field)
    layout.addWidget(self.value_field)
    layout.addWidget(self.units_field)
    self.setLayout(layout)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38584550_38607016_3_36
38584550_48269550_104_110
Title: Customizing the QScrollbar in PyQt 
----------------------------------------

def __init__(self) :
INDENT
    super(Main, self).__init__()
    self.resize(300, 200)
    self.index = QWidget()
    self.index.setMinimumHeight(1000)
    self.index.setMinimumWidth(500)

    self.setWidget(self.index)
    self.setWidgetResizable(True)
    with open('a.qss', 'r') as f :
    INDENT
        self.a_text = f.read()
        self.setStyleSheet(self.a_text)
    DEDENT
    with open('b.qss', 'r') as f :
    INDENT
        self.b_text = f.read()
    DEDENT
    with open('c.qss', 'r') as f :
    INDENT
        self.c_text = f.read()

    DEDENT
    self.value = 0
    self.pre_value = 0

    self.pauseCond = True
    self.timer = QTimer()
    self.timer.timeout.connect(self.timerout)
    self.verticalScrollBar().actionTriggered.connect(self.change)
    self.timer.start(300)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyScrollArea, self).__init__(parent)
    w = QtWidgets.QWidget()
    w.setFixedSize(640, 480)
    self.setWidget(w)
    vScrollBar = CustomScrollBar(QtCore.Qt.Vertical)
    self.setVerticalScrollBar(vScrollBar)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38584550_38607016_3_36
38584550_48269550_2_71
Title: Customizing the QScrollbar in PyQt 
----------------------------------------

def __init__(self) :
INDENT
    super(Main, self).__init__()
    self.resize(300, 200)
    self.index = QWidget()
    self.index.setMinimumHeight(1000)
    self.index.setMinimumWidth(500)

    self.setWidget(self.index)
    self.setWidgetResizable(True)
    with open('a.qss', 'r') as f :
    INDENT
        self.a_text = f.read()
        self.setStyleSheet(self.a_text)
    DEDENT
    with open('b.qss', 'r') as f :
    INDENT
        self.b_text = f.read()
    DEDENT
    with open('c.qss', 'r') as f :
    INDENT
        self.c_text = f.read()

    DEDENT
    self.value = 0
    self.pre_value = 0

    self.pauseCond = True
    self.timer = QTimer()
    self.timer.timeout.connect(self.timerout)
    self.verticalScrollBar().actionTriggered.connect(self.change)
    self.timer.start(300)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QtWidgets.QScrollBar.__init__(self, * args, ** kwargs)
    self.baseSheet = '''
            QScrollBar {{
                width: 45px;
                margin: 45px 0 45px 0;
                background: #32CC99;
            }}

            QScrollBar::handle {{
                border: 10px solid grey;
                background: white;
                min-height: 10px;
            }}

            QScrollBar::add-line:vertical {{
                border: 2px solid grey;
                background: none;
                height: 45px;
                subcontrol-position: bottom;
                subcontrol-origin: margin;
            }}

            QScrollBar::sub-line:vertical {{
                border: 2px solid grey;
                background: none;
                height: 45px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }}

            QScrollBar::up-arrow:vertical {{
                subcontrol-position: bottom;
                subcontrol-origin: margin;
                {upArrow}
            }}

            QScrollBar::down-arrow:vertical {{
                subcontrol-position: bottom;
                subcontrol-origin: margin;
                {downArrow}
            }}

            QScrollBar::left-arrow:vertical {{
                subcontrol-position: bottom;
                subcontrol-origin: margin;
                {leftArrow}
            }}

            QScrollBar::right-arrow:vertical {{
                subcontrol-position: bottom;
                subcontrol-origin: margin;
                {rightArrow}
            }}
            '''
    self.arrowNormal = '''
                border-top: 5px solid lightgray;
                border-left: 5px solid lightgray;
                border-right: 5px solid gray;
                border-bottom: 5px solid gray;
            '''
    self.arrowPressed = '''
                border: 5px solid darkgray;
            '''
    self.setStyleSheet(self.baseSheet.format(
            upArrow = self.arrowNormal,
            downArrow = self.arrowNormal,
            leftArrow = self.arrowNormal,
            rightArrow = self.arrowNormal))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38584550_48269550_104_110
38584550_48269550_2_71
Title: Customizing the QScrollbar in PyQt 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyScrollArea, self).__init__(parent)
    w = QtWidgets.QWidget()
    w.setFixedSize(640, 480)
    self.setWidget(w)
    vScrollBar = CustomScrollBar(QtCore.Qt.Vertical)
    self.setVerticalScrollBar(vScrollBar)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QtWidgets.QScrollBar.__init__(self, * args, ** kwargs)
    self.baseSheet = '''
            QScrollBar {{
                width: 45px;
                margin: 45px 0 45px 0;
                background: #32CC99;
            }}

            QScrollBar::handle {{
                border: 10px solid grey;
                background: white;
                min-height: 10px;
            }}

            QScrollBar::add-line:vertical {{
                border: 2px solid grey;
                background: none;
                height: 45px;
                subcontrol-position: bottom;
                subcontrol-origin: margin;
            }}

            QScrollBar::sub-line:vertical {{
                border: 2px solid grey;
                background: none;
                height: 45px;
                subcontrol-position: top;
                subcontrol-origin: margin;
            }}

            QScrollBar::up-arrow:vertical {{
                subcontrol-position: bottom;
                subcontrol-origin: margin;
                {upArrow}
            }}

            QScrollBar::down-arrow:vertical {{
                subcontrol-position: bottom;
                subcontrol-origin: margin;
                {downArrow}
            }}

            QScrollBar::left-arrow:vertical {{
                subcontrol-position: bottom;
                subcontrol-origin: margin;
                {leftArrow}
            }}

            QScrollBar::right-arrow:vertical {{
                subcontrol-position: bottom;
                subcontrol-origin: margin;
                {rightArrow}
            }}
            '''
    self.arrowNormal = '''
                border-top: 5px solid lightgray;
                border-left: 5px solid lightgray;
                border-right: 5px solid gray;
                border-bottom: 5px solid gray;
            '''
    self.arrowPressed = '''
                border: 5px solid darkgray;
            '''
    self.setStyleSheet(self.baseSheet.format(
            upArrow = self.arrowNormal,
            downArrow = self.arrowNormal,
            leftArrow = self.arrowNormal,
            rightArrow = self.arrowNormal))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38594636_38594958_12_21
38594636_38594958_47_56
Title: "Kivy: Label with text from previous screen using ScreenManager" 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(ScreenOne, self).__init__(** kwargs)
    self.my_box1 = BoxLayout(orientation = 'vertical')
    self.my_label1 = TextInput(text = "BlaBlaBla on scr 1", font_size = '24dp')
    self.my_button1 = Button(text = "Go to screen 2", size_hint_y = None, size_y = 100)
    self.my_button1.bind(on_press = self.changer)
    self.my_box1.add_widget(self.my_label1)
    self.my_box1.add_widget(self.my_button1)
    self.add_widget(self.my_box1)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(MyApp, self).__init__(** kwargs)
    self.sm = ScreenManager()
    self.sm.test = StringProperty("test")
    self.sm.add_widget(ScreenOne(name = "screen1"))
    self.sm.add_widget(ScreenTwo(name = "screen2"))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38594636_38594958_30_40
38594636_38594958_47_56
Title: "Kivy: Label with text from previous screen using ScreenManager" 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(ScreenTwo, self).__init__(** kwargs)
    self.my_box1 = BoxLayout(orientation = 'vertical')
    self.my_label1 = Label(text = "BlaBlaBla on screen 2", font_size = '24dp')
    self.my_button1 = Button(text = "Go to screen 1", size_hint_y = None, size_y = 100)
    self.my_button1.bind(on_press = self.changer)
    self.my_box1.add_widget(self.my_label1)
    self.my_box1.add_widget(self.my_button1)
    self.add_widget(self.my_box1)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(MyApp, self).__init__(** kwargs)
    self.sm = ScreenManager()
    self.sm.test = StringProperty("test")
    self.sm.add_widget(ScreenOne(name = "screen1"))
    self.sm.add_widget(ScreenTwo(name = "screen2"))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38596069_38596898_6_15
38596069_45471868_4_10
Title: Python: prevent signals to propagate to child threads 
----------------------------------------

def worker(i) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            print (i)
            time.sleep(10)
            break
        DEDENT
        except Exception as msg :
        INDENT
            print (msg)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def worker() :
INDENT
    while True :
    INDENT
        print ('Worker working')
        time.sleep(0.5)
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38602219_38602647_11_18
38602219_38602913_11_18
Title: python tornado json render to html script 
----------------------------------------

def __init__(self) :
INDENT
    base_dir = os.path.dirname(__file__)
    settings = {
        }
    tornado.web.Application.__init__(self, [
            tornado.web.url(r"/", MainHandler, name = "main"),
            ], ** settings)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    base_dir = os.path.dirname(__file__)
    settings = {
        }
    tornado.web.Application.__init__(self, [
            tornado.web.url(r"/", MainHandler, name = "main"),
            ], ** settings)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38624168_38630095_1_18
38624168_38642936_43_64
Title: Kivy and Matplotlib trying to update plot on button callback 
----------------------------------------

def callback(instance) :
INDENT
    plt.clf()
    X = np.arange(- 508, 510, 203.2)
    Y = np.arange(- 508, 510, 203.2)
    X, Y = np.meshgrid(X, Y)
    Z = np.random.rand(6, 6)
    plt.contourf(X, Y, Z, 100, zdir = 'z', offset = 1.0, cmap = cm.hot)
    plt.colorbar()
    ax.set_ylabel('Y [mm]')
    ax.set_title('NAILS surface')
    ax.set_xlabel('X [mm]')
    canvas.draw_idle()
DEDENT
----------------------------------------

def callback(instance) :
INDENT
    global fig, ax
    X = np.arange(- 508, 510, 203.2)
    Y = np.arange(- 508, 510, 203.2)
    X, Y = np.meshgrid(X, Y)
    Z = 1000 * np.random.rand(6, 6)
    plt.clf()
    plt.contourf(X, Y, Z, 100, zdir = 'z', offset = 1.0, cmap = cm.hot)
    plt.colorbar()

    canvas.draw()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38625587_38625668_1_15
38625587_38627532_23_37
Title: clean function causing .is_valid() method to return false when used in form django 1.9.8 
----------------------------------------

def clean(self) :
INDENT
    super(login_form, self).clean()
    username = self.cleaned_data.get('username', None)
    password = self.cleaned_data.get('password', None)
    if username is not None :
    INDENT
        try :
        INDENT
            user_obj = User.objects.get(username = username)
            if password_validation.validate_password(password, user_obj) is not None :
            INDENT
                self.errors ['password'] = [u'Password is incorrect. Please try again.']
            DEDENT
        DEDENT
        except User.DoesNotExist :
        INDENT
            self.errors ['username'] = [u'User does not exist. Please use valid credentials.']
        DEDENT
    DEDENT
    else :
    INDENT
        self.errors ['username'] = [u'Please type a valid username.']
    DEDENT
    return self.cleaned_data
DEDENT
----------------------------------------

def clean(self, * args, ** kwargs) :
INDENT
    username = self.cleaned_data.get('username')
    password = self.cleaned_data.get('password')
    try :
    INDENT
        user_obj = User.objects.get(username = username)
        if not user_obj.check_password(password) :
        INDENT
            raise ValidationError(
                'Password is incorrect. Please try again',
                code = 'incorrect')
        DEDENT
    DEDENT
    except User.DoesNotExist :
    INDENT
        raise ValidationError(
            'User does not exist. Please use valid credentials.',
            code = 'invalid')
    DEDENT
    return super(login_form, self).clean(* args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38633995_38634447_29_46
38633995_38634447_6_15
Title: Tkinter Show webcam view in second window 
----------------------------------------

def __init__(self, parent) :
INDENT
    self.lmain = tk.Label(parent)
    self.lmain.pack()
    self.test_frame = None
    frame = tk.Frame.__init__(self, parent)
    a = tk.Label(text = 'hello!').pack()
    b = tk.Button(frame, text = 'open', command = self.load_window)
    b.pack()
    width, height = 800, 600
    self.cap = cv2.VideoCapture(0)
    self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, width)
    self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, height)
    self.do_stuff()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    self.parent = parent
    self.window = tk.Toplevel(parent)
    self.lmain2 = tk.Label(self.window)
    self.lmain2.pack()
    self.window.protocol("WM_DELETE_WINDOW", self.close)
    self.show_frame()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38641619_38877800_17_28
38641619_38877800_75_86
Title: EC2 Spot Instance Termination & Python 2.7 
----------------------------------------

def run(self) :
INDENT
    print ("Polling for termination")
    while True :
    INDENT
        for i in range(30) :
        INDENT
            time.sleep(5)
            if i == 2 :
            INDENT
                print ("Recieve Termination Poll!")
                print ("Pretend we returned the message to the queue.")
                print ("Now Kill the entire program.")
                os._exit(1)
            DEDENT
        DEDENT
        print ("Well now, this is embarassing!")
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        func, args, kargs = self.tasks.get()
        try :
        INDENT
            func(* args, ** kargs)
        DEDENT
        except Exception, e :
        INDENT
            print ("Exception " + str(e))
            error = {'exception' : e}
            self.errors.put(error)
        DEDENT
        self.tasks.task_done()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38645674_38766800_14_42
38645674_38766800_60_72
Title: Issues with PyQt5's OpenGL module and versioning (calls for incorrect _QOpenGLFunctions_(ver)) 
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.glWidget = GLWidget()
    self.xSlider = self.createSlider()
    self.ySlider = self.createSlider()
    self.zSlider = self.createSlider()
    self.xSlider.valueChanged.connect(self.glWidget.setXRotation)
    self.glWidget.xRotationChanged.connect(self.xSlider.setValue)
    self.ySlider.valueChanged.connect(self.glWidget.setYRotation)
    self.glWidget.yRotationChanged.connect(self.ySlider.setValue)
    self.zSlider.valueChanged.connect(self.glWidget.setZRotation)
    self.glWidget.zRotationChanged.connect(self.zSlider.setValue)
    mainLayout = QHBoxLayout()
    mainLayout.addWidget(self.glWidget)
    mainLayout.addWidget(self.xSlider)
    mainLayout.addWidget(self.ySlider)
    mainLayout.addWidget(self.zSlider)
    self.setLayout(mainLayout)
    self.xSlider.setValue(15 * 16)
    self.ySlider.setValue(345 * 16)
    self.zSlider.setValue(0 * 16)
    self.setWindowTitle("Hello GL")
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(GLWidget, self).__init__(parent)
    self.object = 0
    self.xRot = 0
    self.yRot = 0
    self.zRot = 0
    self.lastPos = QPoint()
    self.trolltechGreen = QColor.fromCmykF(0.40, 0.0, 1.0, 0.0)
    self.trolltechPurple = QColor.fromCmykF(0.39, 0.39, 0.0, 0.0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38656201_38656365_19_28
38656201_38656365_38_49
Title: Using a dynamic array python multi-threads 
----------------------------------------

def run(self) :
INDENT
    count = 0
    logging.debug('Starting run')
    while count < = self.max_count :
    INDENT
        q.put(count)
        logging.debug('Putting idx {0} in queue, queue length = {1}'.format(count, q.qsize()))
        count += 1
        time.sleep(self.delay)
    DEDENT
    logging.debug('Finished run')
DEDENT
----------------------------------------

def run(self) :
INDENT
    logging.debug('Starting run')
    while True :
    INDENT
        try :
        INDENT
            work = q.get(True, self.timeout)
        DEDENT
        except Queue.Empty :
        INDENT
            logging.debug('Queue still empty after {0} giving up'.format(self.timeout))
            break
        DEDENT
        logging.debug('Received idx {0} from queue, queue length = {1}'.format(work, q.qsize()))
        time.sleep(self.delay)
    DEDENT
    logging.debug('Finished run')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38661438_38663035_21_28
38661438_38663035_38_45
Title: python super() - two argument version in context of __new__ 
----------------------------------------

def __init__(self, name) :
INDENT
    print ('initializing a Sister with name: {!r}'.format(name))
    parent = super(Sister, self)
    print (type(parent))
    print (parent)
    print ('Calling super __init__')
    parent.__init__(name)
DEDENT
----------------------------------------

def __init__(self, name) :
INDENT
    print ('initializing a Brother with name: {!r}'.format(name))
    parent = super(Brother, self)
    print (type(parent))
    print (parent)
    print ('Calling super __init__')
    parent.__init__(name)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38661438_38663035_21_28
38661438_38663579_2_20
Title: python super() - two argument version in context of __new__ 
----------------------------------------

def __init__(self, name) :
INDENT
    print ('initializing a Sister with name: {!r}'.format(name))
    parent = super(Sister, self)
    print (type(parent))
    print (parent)
    print ('Calling super __init__')
    parent.__init__(name)
DEDENT
----------------------------------------

def __init__(self, klass, object_or_klass) :
INDENT
    if isinstance(object_or_klass, klass) :
    INDENT
        mro = type(object_or_klass).__mro__
        self.obj_type = type(object_or_klass)
        self.obj = object_or_klass
    DEDENT
    elif issubclass(object_or_klass, klass) :
    INDENT
        mro = object_or_klass.__mro__
        self.obj_type = object_or_klass
        self.obj = None
    DEDENT
    else :
    INDENT
        raise TypeError
    DEDENT
    self.searchlist = mro [mro.index(klass) + 1 :]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38661438_38663035_38_45
38661438_38663579_2_20
Title: python super() - two argument version in context of __new__ 
----------------------------------------

def __init__(self, name) :
INDENT
    print ('initializing a Brother with name: {!r}'.format(name))
    parent = super(Brother, self)
    print (type(parent))
    print (parent)
    print ('Calling super __init__')
    parent.__init__(name)
DEDENT
----------------------------------------

def __init__(self, klass, object_or_klass) :
INDENT
    if isinstance(object_or_klass, klass) :
    INDENT
        mro = type(object_or_klass).__mro__
        self.obj_type = type(object_or_klass)
        self.obj = object_or_klass
    DEDENT
    elif issubclass(object_or_klass, klass) :
    INDENT
        mro = object_or_klass.__mro__
        self.obj_type = object_or_klass
        self.obj = None
    DEDENT
    else :
    INDENT
        raise TypeError
    DEDENT
    self.searchlist = mro [mro.index(klass) + 1 :]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38667611_38689077_10_27
38667611_38689077_29_42
Title: wxPython dynamically add pages to wizard 
----------------------------------------

def __init__(self) :
INDENT
    wizard = wx.wizard.Wizard(None, - 1, "Simple Wizard")
    self.pageList = [TitledPage(wizard, "Page 1"),
        TitledPage(wizard, "Page 2"),
        TitledPage(wizard, "Page 3"),
        TitledPage(wizard, "Page 4"),
        AddPage(wizard, self)]
    for i in range(len(self.pageList) - 1) :
    INDENT
        wx.wizard.WizardPageSimple.Chain(self.pageList [i], self.pageList [i + 1])
    DEDENT
    wizard.FitToPage(self.pageList [0])
    wizard.RunWizard(self.pageList [0])
    wizard.Destroy()

DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wiz.WizardPageSimple.__init__(self, parent)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)
    title = wx.StaticText(self, - 1, title)
    title.SetFont(wx.Font(18, wx.SWISS, wx.NORMAL, wx.BOLD))
    sizer.Add(title, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    sizer.Add(wx.StaticLine(self, - 1), 0, wx.EXPAND | wx.ALL, 5)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38667611_38689077_10_27
38667611_38689077_44_62
Title: wxPython dynamically add pages to wizard 
----------------------------------------

def __init__(self) :
INDENT
    wizard = wx.wizard.Wizard(None, - 1, "Simple Wizard")
    self.pageList = [TitledPage(wizard, "Page 1"),
        TitledPage(wizard, "Page 2"),
        TitledPage(wizard, "Page 3"),
        TitledPage(wizard, "Page 4"),
        AddPage(wizard, self)]
    for i in range(len(self.pageList) - 1) :
    INDENT
        wx.wizard.WizardPageSimple.Chain(self.pageList [i], self.pageList [i + 1])
    DEDENT
    wizard.FitToPage(self.pageList [0])
    wizard.RunWizard(self.pageList [0])
    wizard.Destroy()

DEDENT
----------------------------------------

def __init__(self, parent, dynawiz) :
INDENT
    self.parent = parent
    self.dynawiz = dynawiz
    """Constructor"""
    wiz.WizardPageSimple.__init__(self, parent)

    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)
    self.numPageAdd = wx.TextCtrl(self, - 1, "")
    self.verifyButton = wx.Button(self, id = wx.ID_ANY, label = "Confirm", name = "confirm")
    self.verifyButton.Bind(wx.EVT_BUTTON, self.append_pages)
    sizer.Add(self.numPageAdd, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    sizer.Add(self.verifyButton, 0, wx.ALIGN_CENTER | wx.ALL, 5)
    sizer.Add(wx.StaticLine(self, - 1), 0, wx.EXPAND | wx.ALL, 5)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38667611_38689077_29_42
38667611_38689077_44_62
Title: wxPython dynamically add pages to wizard 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wiz.WizardPageSimple.__init__(self, parent)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)
    title = wx.StaticText(self, - 1, title)
    title.SetFont(wx.Font(18, wx.SWISS, wx.NORMAL, wx.BOLD))
    sizer.Add(title, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    sizer.Add(wx.StaticLine(self, - 1), 0, wx.EXPAND | wx.ALL, 5)

DEDENT
----------------------------------------

def __init__(self, parent, dynawiz) :
INDENT
    self.parent = parent
    self.dynawiz = dynawiz
    """Constructor"""
    wiz.WizardPageSimple.__init__(self, parent)

    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)
    self.numPageAdd = wx.TextCtrl(self, - 1, "")
    self.verifyButton = wx.Button(self, id = wx.ID_ANY, label = "Confirm", name = "confirm")
    self.verifyButton.Bind(wx.EVT_BUTTON, self.append_pages)
    sizer.Add(self.numPageAdd, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    sizer.Add(self.verifyButton, 0, wx.ALIGN_CENTER | wx.ALL, 5)
    sizer.Add(wx.StaticLine(self, - 1), 0, wx.EXPAND | wx.ALL, 5)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38672401_38674465_3_12
38672401_38681955_20_25
Title: django rest framework how to define required fields per ViewSet action 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(UserSerializer, self).__init__(* args, ** kwargs)
    require_password = kwargs.get('require_password', False)
    require_email = kwargs.get('require_email', False)
    if require_password :
    INDENT
        self.fields ['password'].required = True
    DEDENT
    if require_email :
    INDENT
        self.fields ['email'].required = True
    DEDENT
DEDENT
----------------------------------------

def __init__(self, keys) :
INDENT
    self.keys = []
    for key in keys :
    INDENT
        if hasattr(key, 'upper') :
        INDENT
            self.keys.append(key.lower())
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38673583_38673856_1_36
38673583_38674235_1_9
Title: python: list index out of range error in code 
----------------------------------------

def check_code() :
INDENT
    while True :
    INDENT

        nricno = input("Please enter your NRIC(numbers only). If you don't type an nric number, this code will restart.")
        if len(nricno) == 7 and nricno.digits == True :
        INDENT
            print ("Works")
            continue
        DEDENT
        else :
        INDENT
            print ("Error, 7 digit number was not inputted and/or letters and other characters were inputted.")
        DEDENT
    DEDENT
    a = NRIC [0] * 2
    b = NRIC [1] * 7
    c = NRIC [2] * 6
    d = NRIC [3] * 5
    e = NRIC [4] * 4
    f = NRIC [5] * 3
    g = NRIC [6] * 2
    SUM = int(a + b + c + d + e + f + g)
    remainder = int(SUM % 11)
    print (remainder)
    leftovers = int(11 - remainder)
    rightovers = leftovers - 1
    Alphabet = "ABCDEFGHIZJ"
    checkcode = chr(ord('a') + rightovers)
    print (checkcode.upper())
DEDENT
----------------------------------------

def check_code(nric) :
INDENT
    if len(nric) ! = 7 or not nric.isdigit() :
    INDENT
        raise ValueError("Bad NRIC: {!r}".format(nric))
    DEDENT
    weights = (2, 7, 6, 5, 4, 3, 2)
    n = sum(int(c) * w for c, w in zip(nric, weights))
    return "ABCDEFGHIZJ" [10 - n % 11]

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38680111_38680137_1_14
38680111_38680158_2_11
Title: using count method to count a certain word in text file 
----------------------------------------

def word_count(filename) :
INDENT
    try :
    INDENT
        word_count = 0
        with open(filename) as f_obj :
        INDENT
            contents = f_obj.readlines()
            for line in contents :
            INDENT
                word_count += line.lower().count('the')
            DEDENT
            print (word_count)
        DEDENT
    DEDENT
    except FileNotFoundError :
    INDENT
        msg = "Sorry, the file you entered, " + filename + ", could not be     found."
    DEDENT
    print (msg)
DEDENT
----------------------------------------

def word_count(filename) :
INDENT
    if os.path.exists(filename) :
    INDENT
        if not os.path.isdir(filename) :
        INDENT
            with open(filename) as f_obj :
            INDENT
                print (f_obj.read().lower().count('t'))
            DEDENT
        DEDENT
        else :
        INDENT
            print ("is path to folder, not to file '%s'" % filename)
        DEDENT
    DEDENT
    else :
    INDENT
        print ("path not found '%s'" % filename)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38681226_38681360_1_11
38681226_38749399_1_24
Title: frequency of desired characters in the given string 
----------------------------------------

def freq(st, n) :
INDENT
    dct = {}
    for c in st :
    INDENT
        dct [c] = dct.get(c, 0) + 1
    DEDENT
    ar = [(key, val) for key, val in dct.iteritems()]
    ar.sort(key = lambda x : x [1])
    return ar [: n]
DEDENT
----------------------------------------

def freq(word, n) :
INDENT
    l1 = list(word)
    l3 = []
    l2 = []
    l4 = []
    s = set(l1)
    l2 = list(s)
    def count(p) :
    INDENT
        c = 0
        for a in word :
        INDENT
            if a in word :
            INDENT
                c = c + p.count(a)
            DEDENT
        DEDENT
        l3.append(c)
        return c
    DEDENT
    l2.sort(key = count)
    l3.sort()
    l4 = list(zip(l2, l3))
    l4.reverse()
    l4.sort(key = lambda l4 : ((l4 [1]), (l4 [0])), reverse = True)
    return l4 [0 : n]
    pass
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38697865_38699370_4_10
38697865_38854954_5_21
Title: How to store incoming files with new names in Python? 
----------------------------------------

def open_next_file(template = 'incomingData{serial}.tar') :
INDENT
    for filename in (template.format(serial = serial) for serial in count()) :
    INDENT
        try :
        INDENT
            return open(filename, 'xb')
        DEDENT
        except OSError :
        INDENT
            if not os.path.exists(filename) :
            INDENT
                raise
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def open_next_file(template = 'incomingData{}.txt') :
INDENT
    for serial in range(10) :
    INDENT
        if not path.exists(template.format(serial)) :
        INDENT
            with open(template.format(serial), 'w') as f :
            INDENT
                f.write("hello %s \n" % str(serial))
            DEDENT
            break
        DEDENT
        else :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38703907_38705319_5_17
38703907_38717759_5_18
Title: Modify a list in Multiprocessing pool's manager dict 
----------------------------------------

def spammer_task(d, my_list) :
INDENT
    d ['task'] = {
        'processed_list' : []}
    for ele in my_list :
    INDENT

        foo = d ['task']
        foo ['processed_list'].append(ele)
        d ['task'] = foo
    DEDENT
    return
DEDENT
----------------------------------------

def spammer_task(my_list) :
INDENT
    out = {
        'processed_list' : []}
    for ele in my_list :
    INDENT

        out ['processed_list'].append(ele)
    DEDENT
    return 'task', out

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38725269_38750543_14_22
38725269_38751057_9_17
Title: __reversed__ Magic method 
----------------------------------------

def __next__(self) :
INDENT
    if self.current is None :
    INDENT
        self.current = self.mystart
    DEDENT
    if self.current > self.myend :
    INDENT
        raise StopIteration
    DEDENT
    else :
    INDENT
        self.current += 1
        return self.current - 1
    DEDENT
DEDENT
----------------------------------------

def __next__(self) :
INDENT
    if self.current == self.myend + self.step :
    INDENT
        raise StopIteration
    DEDENT
    else :
    INDENT
        self.current += self.step
        return self.current - self.step

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38759184_38761046_3_9
38759184_38761387_9_18
Title: select doesn't work for pipe in python? 
----------------------------------------

def check_parent_select(fh) :
INDENT
    (rlist, wlist, xlist) = select.select([], [], [fh], 1)
    if fh in xlist :
    INDENT
        print "parent exit"
    DEDENT
    else :
    INDENT
        print "parent OK"
    DEDENT
DEDENT
----------------------------------------

def check_parent_select(fh) :
INDENT
    (rlist, wlist, xlist) = select.select([fh], [fh], [fh], 1)
    print (rlist, wlist, xlist)
    if fh in rlist :
    INDENT
        print "oh i'm just writing. error"
    DEDENT
    if fh in xlist :
    INDENT
        print "parent exit"
    DEDENT
    else :
    INDENT
        print "parent OK"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38775804_38837666_22_30
38775804_38837666_6_20
Title: wxPython return value from Wizard to calling Frame 
----------------------------------------

def __init__(self, parent, a) :
INDENT
    wizard = wx.wizard.Wizard(None, - 1, "Simple Wizard")
    page1 = WizPage(wizard)
    wizard.FitToPage(page1)
    wizard.RunWizard(page1)
    pub.sendMessage('valPass', a = page1.answer)
    wizard.Destroy()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    self.answer = 3
    wiz.WizardPageSimple.__init__(self, parent)
    sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(sizer)
    title = wx.StaticText(self, - 1, "Wizard Page")
    title.SetFont(wx.Font(18, wx.SWISS, wx.NORMAL, wx.BOLD))

    sizer.Add(title, 0, wx.ALIGN_CENTRE | wx.ALL, 5)
    sizer.Add(wx.StaticLine(self, - 1), 0, wx.EXPAND | wx.ALL, 5)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38812557_38812613_23_28
38812557_38812613_6_14
Title: Method inheritance issue 
----------------------------------------

def __str__(self) :
INDENT
    rep = self.name + "\t" + super(BJ_hand, self).__str__()
    if self.total :
    INDENT
        rep += "(" + str(self.total) + ")"
    DEDENT
    return rep
DEDENT
----------------------------------------

def __str__(self) :
INDENT
    if self.cards :
    INDENT
        rep = ""
        for card in self.cards :
        INDENT
            rep += str(card) + "\t"
        DEDENT
    DEDENT
    else :
    INDENT
        rep = "<empty>"
    DEDENT
    return rep
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38814924_38815221_1_17
38814924_38815921_8_20
Title: Set part of a lambda function in advance to avoid repeated code 
----------------------------------------

def sort_view_items(self) :
INDENT
    def key_func(vi) :
    INDENT
        name = vi.name if self.settings.case_sensitive else vi.name.lower()
        if self.settings.sort_by_file_name :
        INDENT
            return name(vi), vi.group, vi.tab
        DEDENT
        elif self.settings.sort_by_folder :
        INDENT
            return vi.folder, name(vi)
        DEDENT
        elif self.settings.sort_by_syntax :
        INDENT
            return vi.syntax, name(vi)
        DEDENT
        elif self.settings.sort_by_indexes :
        INDENT
            return vi.group, vi.tab
        DEDENT
    DEDENT
    self.view_items.sort(key = key_func)
DEDENT
----------------------------------------

def sort_view_items(self) :
INDENT
    name_field = "name" if self.settings.case_sensitive else "lower_name"
    if self.settings.sort_by_file_name :
    INDENT
        fields = (name_field, "group", "tab")
    DEDENT
    elif self.settings.sort_by_folder :
    INDENT
        fields = ("folder", name_field)
    DEDENT
    elif self.settings.sort_by_syntax :
    INDENT
        fields = ("syntax", name_field)
    DEDENT
    elif self.settings.sort_by_indexes :
    INDENT
        fields = ("group", "tab")
    DEDENT
    self.view_items.sort(key = attrgetter(* fields))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38824634_45181054_1_12
38824634_46024675_3_13
Title: Automate the boring stuff with Python: Comma Code 
----------------------------------------

def commacode(passedlist) :
INDENT
    stringy = ''
    try :
    INDENT
        for i in range(len(passedlist) - 1) :
        INDENT
            stringy += str(passedlist [i]) + ', '
        DEDENT
        stringy += 'and ' + str(passedlist [len(passedlist) - 1])
        return stringy
    DEDENT
    except IndexError :
    INDENT
        return ''
    DEDENT
DEDENT
----------------------------------------

def commacode(words) :
INDENT
    x = len(words)
    if x == 1 :
    INDENT
        print (str(words [0]))
    DEDENT
    else :
    INDENT
        for i in range(x - 1) :
        INDENT
            print((str(words [i]) + ','), end = ' ')
        DEDENT
        print (('and ' + str(words [- 1])))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834005_1_10
38833819_38834134_1_13
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(str) :
INDENT
    count = 0
    for i in str :
    INDENT
        if i == "(" :
        INDENT
            count += 1
        DEDENT
        elif i == ")" :
        INDENT
            count -= 1
        DEDENT
        if count < 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return count == 0
DEDENT
----------------------------------------

def matched(str) :
INDENT
    ope = []
    clo = []
    for i in range(0, len(str)) :
    INDENT
        l = str [i]
        if l == "(" :
        INDENT
            ope = ope + ["("]
        DEDENT
        elif l == ")" :
        INDENT
            clo = clo + [")"]
        DEDENT
    DEDENT
    if len(ope) == len(clo) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834005_1_10
38833819_38834251_1_14
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(str) :
INDENT
    count = 0
    for i in str :
    INDENT
        if i == "(" :
        INDENT
            count += 1
        DEDENT
        elif i == ")" :
        INDENT
            count -= 1
        DEDENT
        if count < 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return count == 0
DEDENT
----------------------------------------

def matched(s) :
INDENT
    p_list = []
    for i in range(0, len(s)) :
    INDENT
        if s [i] == '(' :
        INDENT
            p_list.append('(')
        DEDENT
        elif s [i] == ')' :
        INDENT
            if not p_list :
            INDENT
                return False
            DEDENT
            else :
            INDENT
                p_list.pop()
            DEDENT
        DEDENT
    DEDENT
    if not p_list :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834005_1_10
38833819_49548737_1_12
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(str) :
INDENT
    count = 0
    for i in str :
    INDENT
        if i == "(" :
        INDENT
            count += 1
        DEDENT
        elif i == ")" :
        INDENT
            count -= 1
        DEDENT
        if count < 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return count == 0
DEDENT
----------------------------------------

def matched(str) :
INDENT
    diffCounter = 0
    length = len(str)
    for i in range(length) :
    INDENT
        if str [i] == '(' :
        INDENT
            diffCounter += 1
        DEDENT
        elif str [i] == ')' :
        INDENT
            diffCounter -= 1
        DEDENT
    DEDENT
    if diffCounter == 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834005_1_10
38833819_51908688_1_15
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(str) :
INDENT
    count = 0
    for i in str :
    INDENT
        if i == "(" :
        INDENT
            count += 1
        DEDENT
        elif i == ")" :
        INDENT
            count -= 1
        DEDENT
        if count < 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return count == 0
DEDENT
----------------------------------------

def matched(s) :
INDENT
    count = 0
    for i in s :
    INDENT
        if i is "(" :
        INDENT
            count += 1
        DEDENT
        elif i is ")" :
        INDENT
            if count ! = 0 :
            INDENT
                count -= 1
            DEDENT
            else :
            INDENT
                return (False)
            DEDENT
        DEDENT
    DEDENT
    if count == 0 :
    INDENT
        return (True)
    DEDENT
    else :
    INDENT
        return (False)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834134_1_13
38833819_38834251_1_14
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(str) :
INDENT
    ope = []
    clo = []
    for i in range(0, len(str)) :
    INDENT
        l = str [i]
        if l == "(" :
        INDENT
            ope = ope + ["("]
        DEDENT
        elif l == ")" :
        INDENT
            clo = clo + [")"]
        DEDENT
    DEDENT
    if len(ope) == len(clo) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def matched(s) :
INDENT
    p_list = []
    for i in range(0, len(s)) :
    INDENT
        if s [i] == '(' :
        INDENT
            p_list.append('(')
        DEDENT
        elif s [i] == ')' :
        INDENT
            if not p_list :
            INDENT
                return False
            DEDENT
            else :
            INDENT
                p_list.pop()
            DEDENT
        DEDENT
    DEDENT
    if not p_list :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834134_1_13
38833819_49548737_1_12
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(str) :
INDENT
    ope = []
    clo = []
    for i in range(0, len(str)) :
    INDENT
        l = str [i]
        if l == "(" :
        INDENT
            ope = ope + ["("]
        DEDENT
        elif l == ")" :
        INDENT
            clo = clo + [")"]
        DEDENT
    DEDENT
    if len(ope) == len(clo) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def matched(str) :
INDENT
    diffCounter = 0
    length = len(str)
    for i in range(length) :
    INDENT
        if str [i] == '(' :
        INDENT
            diffCounter += 1
        DEDENT
        elif str [i] == ')' :
        INDENT
            diffCounter -= 1
        DEDENT
    DEDENT
    if diffCounter == 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834134_1_13
38833819_51908688_1_15
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(str) :
INDENT
    ope = []
    clo = []
    for i in range(0, len(str)) :
    INDENT
        l = str [i]
        if l == "(" :
        INDENT
            ope = ope + ["("]
        DEDENT
        elif l == ")" :
        INDENT
            clo = clo + [")"]
        DEDENT
    DEDENT
    if len(ope) == len(clo) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def matched(s) :
INDENT
    count = 0
    for i in s :
    INDENT
        if i is "(" :
        INDENT
            count += 1
        DEDENT
        elif i is ")" :
        INDENT
            if count ! = 0 :
            INDENT
                count -= 1
            DEDENT
            else :
            INDENT
                return (False)
            DEDENT
        DEDENT
    DEDENT
    if count == 0 :
    INDENT
        return (True)
    DEDENT
    else :
    INDENT
        return (False)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834251_1_14
38833819_49548737_1_12
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(s) :
INDENT
    p_list = []
    for i in range(0, len(s)) :
    INDENT
        if s [i] == '(' :
        INDENT
            p_list.append('(')
        DEDENT
        elif s [i] == ')' :
        INDENT
            if not p_list :
            INDENT
                return False
            DEDENT
            else :
            INDENT
                p_list.pop()
            DEDENT
        DEDENT
    DEDENT
    if not p_list :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def matched(str) :
INDENT
    diffCounter = 0
    length = len(str)
    for i in range(length) :
    INDENT
        if str [i] == '(' :
        INDENT
            diffCounter += 1
        DEDENT
        elif str [i] == ')' :
        INDENT
            diffCounter -= 1
        DEDENT
    DEDENT
    if diffCounter == 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_38834251_1_14
38833819_51908688_1_15
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(s) :
INDENT
    p_list = []
    for i in range(0, len(s)) :
    INDENT
        if s [i] == '(' :
        INDENT
            p_list.append('(')
        DEDENT
        elif s [i] == ')' :
        INDENT
            if not p_list :
            INDENT
                return False
            DEDENT
            else :
            INDENT
                p_list.pop()
            DEDENT
        DEDENT
    DEDENT
    if not p_list :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def matched(s) :
INDENT
    count = 0
    for i in s :
    INDENT
        if i is "(" :
        INDENT
            count += 1
        DEDENT
        elif i is ")" :
        INDENT
            if count ! = 0 :
            INDENT
                count -= 1
            DEDENT
            else :
            INDENT
                return (False)
            DEDENT
        DEDENT
    DEDENT
    if count == 0 :
    INDENT
        return (True)
    DEDENT
    else :
    INDENT
        return (False)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38833819_49548737_1_12
38833819_51908688_1_15
Title: Python program to check matching of simple parentheses 
----------------------------------------

def matched(str) :
INDENT
    diffCounter = 0
    length = len(str)
    for i in range(length) :
    INDENT
        if str [i] == '(' :
        INDENT
            diffCounter += 1
        DEDENT
        elif str [i] == ')' :
        INDENT
            diffCounter -= 1
        DEDENT
    DEDENT
    if diffCounter == 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def matched(s) :
INDENT
    count = 0
    for i in s :
    INDENT
        if i is "(" :
        INDENT
            count += 1
        DEDENT
        elif i is ")" :
        INDENT
            if count ! = 0 :
            INDENT
                count -= 1
            DEDENT
            else :
            INDENT
                return (False)
            DEDENT
        DEDENT
    DEDENT
    if count == 0 :
    INDENT
        return (True)
    DEDENT
    else :
    INDENT
        return (False)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38853789_38853951_1_10
38853789_38854557_1_13
Title: Determines the first integer that is evenly divisible by all other integers in a list of integers 
----------------------------------------

def divisible(a) :
INDENT
    for i in a :
    INDENT
        found = True
        for j in a :
        INDENT
            if i % j :
            INDENT
                found = False
                break
            DEDENT
        DEDENT
        if found :
        INDENT
            return i
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def divisible(input_list) :
INDENT
    if 0 in input_list :
    INDENT
        return 0
    DEDENT
    candidate = max(map(abs, input_list))
    if all([0 == candidate % x for x in input_list]) :
    INDENT
        return candidate
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38853789_38853961_1_17
38853789_38854557_1_13
Title: Determines the first integer that is evenly divisible by all other integers in a list of integers 
----------------------------------------

def divisible(input_list) :
INDENT
    result = None
    if 0 in input_list :
    INDENT
        return result
    DEDENT
    for i in input_list :
    INDENT
        ok = True
        for j in input_list :
        INDENT
            if i ! = j and i % j ! = 0 :
            INDENT
                ok = False
                break
            DEDENT
        DEDENT
        if ok :
        INDENT
            return i
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def divisible(input_list) :
INDENT
    if 0 in input_list :
    INDENT
        return 0
    DEDENT
    candidate = max(map(abs, input_list))
    if all([0 == candidate % x for x in input_list]) :
    INDENT
        return candidate
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38862399_38862473_1_25
38862399_38862487_1_20
Title: list not entering first input 
----------------------------------------

def ask() :
INDENT
    user_input = raw_input("Enter a number: ")
    user_input_array = []
    count = 0
    quits = 'done'
    while user_input ! = quits :
    INDENT
        user_input = raw_input("Enter a number: ")
        try :
        INDENT
            if type(user_input) == str :
            INDENT
                num = int(user_input)
                user_input_array.append(num)
                count = count + 1
            DEDENT
        DEDENT
        except :
        INDENT
            if user_input == quits :
            INDENT
                print ("done")
                print ('Count: ', count)
                print (user_input_array)
            DEDENT
            else :
            INDENT
                print ("Invalid input")
            DEDENT
        DEDENT
    DEDENT
    ask()
DEDENT
----------------------------------------

def ask() :
INDENT
    user_input_array = []
    while True :
    INDENT

        user_input = raw_input("Enter a number: ")
        if user_input == 'done' :
        INDENT
            break
        DEDENT
        try :
        INDENT
            user_input_array.append(int(user_input))
        DEDENT
        except ValueError :
        INDENT
            print ("Invalid input")
        DEDENT
    DEDENT
    print ("done")
    print ('Count: ', len(user_input_array))
    print (user_input_array)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38864711_38915996_12_22
38864711_38953909_14_26
Title: How to optimize multiprocessing in Python 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        image = self.tasks_q.get()
        time.sleep(1)
        self.results_q.put("text")

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        frameNum, frameData = self.task_queue.get()

        m = random.randint(0, 1000000)
        while m > = 0 :
        INDENT
            m -= 1
        DEDENT
        self.result_queue.put("result from image " + str(frameNum))
    DEDENT
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38882132_38882236_1_9
38882132_38882264_1_7
Title: How to sum all integer after running a loop 
----------------------------------------

def multiples(n, high) :
INDENT
    i = 0
    res = 0
    while i < = high :
    INDENT
        res = res + (n + i)
        i = i + 1
    DEDENT
    print res
    return res
DEDENT
----------------------------------------

def multiples(k, n) :
INDENT
    res = 0
    for i in range(n) :
    INDENT
        res += (k + i)
    DEDENT
    print (res)
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38887226_38887422_1_10
38887226_38887745_3_13
Title: The returned value not defined 
----------------------------------------

def getGuess(maxNum) :
INDENT
    if maxNum == "10" :
    INDENT
        guess = - 1
        while guess > 10 or guess < 0 :
        INDENT
            try :
            INDENT
                guess = int(input("Guess?"))
            DEDENT
            except :
            INDENT
                print ("Please enter valid input")
            DEDENT
        DEDENT
        return guess
    DEDENT
DEDENT
----------------------------------------

def getGuess(maxNum) :
INDENT
    guess = - 1
    while guess < 1 or guess > maxNum :
    INDENT
        try :
        INDENT
            guess = int(input("Guess? "))
        DEDENT
        except ValueError :
        INDENT
            print ("Please enter valid input")
        DEDENT
    DEDENT
    return guess
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38903023_38903067_1_9
38903023_38903079_1_11
Title: Variable Scope Issue in Python 
----------------------------------------

def collatz(num, ctr) :
INDENT
    if (num ! = 1) :
    INDENT
        ctr += 1
        if (num % 2 == 0) :
        INDENT
            ctr = collatz(num / 2, ctr)
        DEDENT
        else :
        INDENT
            ctr = collatz(num * 3 + 1, ctr)
        DEDENT
    DEDENT
    return ctr
DEDENT
----------------------------------------

def collatz(number) :
INDENT
    if number % 2 == 0 :
    INDENT
        print (number / / 2)
        return number / / 2
    DEDENT
    elif number % 2 == 1 :
    INDENT
        result = 3 * number + 1
        print (result)
        return result
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38912480_38912840_3_34
38912480_38913541_3_57
Title: How to fill the form if query returns None 
----------------------------------------

def post() :
INDENT
    caseid = Masterlist.query.filter_by(Ip = request.args.get('Ip')).first()
    if caseid :
    INDENT
        form = RepairForm(request.form)
        print request.form
        if request.form.get("submit") :
        INDENT
            repair = Repair(Ip = form.ip.data, Series = form.series.data, Hostname = form.hostname.data,
                ManagerIp = form.managerip.data, Comp = form.comp.data, Discription = form.discription.data,
                Model = form.model.data, Location = form.location.data, Box = form.box.data,
                Important = form.important.data, Faultype = form.faultype.data, Source = form.source.data,
                Subject = form.subject.data, Body = form.body.data, Classify = form.classify.data,
                Status = form.status.data, auth_id = current_user._get_current_object().id,
                Owner = current_user._get_current_object().username,)
            db.session.add(repair)
            db.session.commit()
            flash('')
            return redirect(url_for('.index'))
        DEDENT
        form.ip.data = caseid.Ip
        form.hostname.data = caseid.Hostname
        form.managerip.data = caseid.Managerip
        form.comp.data = caseid.Comp
        form.model.data = caseid.Model
        form.location.data = caseid.Location
        form.box.data = caseid.Box
        form.classify.data = caseid.Classify
        form.series.data = caseid.Series
        form.discription.data = caseid.Discription
        return render_template('post.html', form = form)
    DEDENT
    else :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def post() :
INDENT
    caseid = Masterlist.query.filter_by(Ip = request.args.get('Ip')).first()
    form = RepairForm(request.form)
    if caseid :
    INDENT
        print request.form
        if request.form.get("submit") :
        INDENT
            repair = Repair(Ip = form.ip.data, Series = form.series.data, Hostname = form.hostname.data,
                ManagerIp = form.managerip.data, Comp = form.comp.data, Discription = form.discription.data,
                Model = form.model.data, Location = form.location.data, Box = form.box.data,
                Important = form.important.data, Faultype = form.faultype.data, Source = form.source.data,
                Subject = form.subject.data, Body = form.body.data, Classify = form.classify.data,
                Status = form.status.data, auth_id = current_user._get_current_object().id,
                Owner = current_user._get_current_object().username,)
            db.session.add(repair)
            db.session.commit()
            flash('')
            return redirect(url_for('.index'))
        DEDENT
        form.ip.data = caseid.Ip
        form.hostname.data = caseid.Hostname
        form.managerip.data = caseid.Managerip
        form.comp.data = caseid.Comp
        form.model.data = caseid.Model
        form.location.data = caseid.Location
        form.box.data = caseid.Box
        form.classify.data = caseid.Classify
        form.series.data = caseid.Series
        form.discription.data = caseid.Discription
        return render_template('post.html', form = form)
    DEDENT
    else :
    INDENT
        if request.form.get("submit") :
        INDENT
            repair = Repair(Ip = form.ip.data, Series = form.series.data, Hostname = form.hostname.data,
                ManagerIp = form.managerip.data, Comp = form.comp.data, Discription = form.discription.data,
                Model = form.model.data, Location = form.location.data, Box = form.box.data,
                Important = form.important.data, Faultype = form.faultype.data, Source = form.source.data,
                Subject = form.subject.data, Body = form.body.data, Classify = form.classify.data,
                Status = form.status.data, auth_id = current_user._get_current_object().id,
                Owner = current_user._get_current_object().username,)
            db.session.add(repair)
            db.session.commit()
            flash('')
            return redirect(url_for('.index'))
        DEDENT
        return render_template('postmanual.html')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38924421_38924631_1_29
38924421_38924686_1_10
Title: Is there a standard way to partition an interable into equivalence classes given a relation in python? 
----------------------------------------

def equivalence_partition(iterable, relation) :
INDENT
    classes = []
    partitions = {}
    for o in iterable :
    INDENT

        found = False
        for c in classes :
        INDENT
            if relation(next(iter(c)), o) :
            INDENT
                c.add(o)
                partitions [o] = c
                found = True
                break
            DEDENT
        DEDENT
        if not found :
        INDENT
            classes.append(set([o]))
            partitions [o] = classes [- 1]
        DEDENT
    DEDENT
    return classes, partitions

DEDENT
----------------------------------------

def equivalence_partition(iterable, relation) :
INDENT
    classes = defaultdict(set)
    for element in iterable :
    INDENT
        for sample, known in classes.items() :
        INDENT
            if relation(sample, element) :
            INDENT
                known.add(element)
                break
            DEDENT
        DEDENT
        else :
        INDENT
            classes [element].add(element)
        DEDENT
    DEDENT
    return list(classes.values())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38930396_38946341_9_16
38930396_42283917_1_26
Title: Define Python function that returns True if the values in the input list alternately go up and down(in a strict manner) 
----------------------------------------

def alternating(seq) :
INDENT
    last = None
    for a, b in pairwise(seq) :
    INDENT
        if a == b or (a < b) == last :
        INDENT
            return False
        DEDENT
        else :
        INDENT
            last = a < b
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def alternating(l) :
INDENT
    a = b = c = d = 0
    if len(l) == 0 or len(l) == 1 or (len(l) == 2 and l [0] ! = l [1]) :
    INDENT
        return ("True")
    DEDENT
    for i in range(0, len(l) - 1, 2) :
    INDENT
        if (l [i] < l [i + 1]) :
        INDENT
            a += 1
        DEDENT
        if (l [i] > l [i + 1]) :
        INDENT
            b += 1
        DEDENT
    DEDENT
    if a ! = len(l) / / 2 and b ! = len(l) / / 2 :
    INDENT
        return ("False")
    DEDENT
    for i in range(1, len(l) - 1, 2) :
    INDENT
        if (l [i] < l [i + 1]) :
        INDENT
            c += 1
        DEDENT
        if (l [i] > l [i + 1]) :
        INDENT
            d += 1
        DEDENT
    DEDENT
    if c ! = (len(l) - 1) / / 2 and d ! = (len(l) - 1) / / 2 :
    INDENT
        return ("False")
    DEDENT
    if a == d or b == c :
    INDENT
        return ("True")
    DEDENT
    return ("False")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3894265_3894289_3_14
3894265_3894623_5_14
Title: example function in Python: counting words 
----------------------------------------

def countWords(target, source, env) :
INDENT
    words = defaultdict(int)
    if (len(target) == 1 and len(source) == 1) :
    INDENT
        with open(str(source [0]), 'r') as fin :
        INDENT
            for line in fin :
            INDENT
                for word in line.split() :
                INDENT
                    words [word] += 1
                DEDENT
            DEDENT
        DEDENT
        with open(str(target [0]), 'w') as fout :
        INDENT
            for word in sorted(words, key = words.__getitem__, reverse = True) :
            INDENT
                fout.write('%s\n' % word)
            DEDENT
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def countWords(target, source, env = '') :
INDENT
    inputstring = open(source).read()
    words = sorted(word.strip(drop) for word in inputstring.lower().replace('--', ' ').split())
    wordlist = sorted([(word, len(list(occurances))) for word, occurances in it.groupby(words, lambda x : x)],
        key = lambda x : x [1],
        reverse = True)
    with open(target, 'w') as results :
    INDENT
        results.write('\n'.join('%16s : %s' % word for word in wordlist))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38966779_38968099_11_27
38966779_38987486_18_35
Title: How to return correctly formatted pandas dataframe from apply? 
----------------------------------------

def get_custom_summary(group) :
INDENT
    gt_200 = group.days_to_complete > 200
    lt_200 = group.days_to_complete < 200
    avg_days_gt200 = group [gt_200].days_to_complete.mean()
    avg_cost_gt200 = group [gt_200].cost_in_millions.mean()
    avg_days_lt200 = group [lt_200].days_to_complete.mean()
    avg_cost_lt200 = group [lt_200].cost_in_millions.mean()
    lt_200_prop = (lt_200).sum() / ((gt_200).sum() + (lt_200).sum())
    return pd.DataFrame({
            'gt_200' : {'AVG_DAYS' : avg_days_gt200, 'AVG_COST' : avg_cost_gt200},
            'lt_200' : {'AVG_DAYS' : avg_days_lt200, 'AVG_COST' : avg_cost_lt200},
            'lt_200_prop' : lt_200_prop})
DEDENT
----------------------------------------

def get_custom_summary(group) :
INDENT
    gt_200 = group.days_to_complete > 200
    lt_200 = group.days_to_complete < 200
    avg_days_gt_200 = group [gt_200].days_to_complete.mean()
    avg_cost_gt_200 = group [gt_200].cost_in_millions.mean()
    avg_days_lt_200 = group [lt_200].days_to_complete.mean()
    avg_cost_lt_200 = group [lt_200].cost_in_millions.mean()
    lt_200_prop = lt_200.sum() / (gt_200.sum() + lt_200.sum())
    ordered_dict = OrderedDict()
    ordered_dict ['first'] = ['lt_200', 'lt_200', 'gt_200', 'gt_200', 'lt_200_prop']
    ordered_dict ['second'] = ['avg_cost', 'avg_days', 'AVG_COST', 'AVG_DAYS', 'prop']
    data = [[avg_cost_lt_200, avg_days_lt_200, avg_cost_gt_200, avg_days_gt_200, lt_200_prop]]
    return pd.DataFrame(data, columns = get_multi_index(ordered_dict))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38998035_38998284_1_14
38998035_38998704_1_21
Title: Why does my nested loop throw an exception in Python? 
----------------------------------------

def door_traversal() :
INDENT
    arr = []
    for i in range(100) :
    INDENT
        arr.append(0)
    DEDENT
    for i in range(1, 100) :
    INDENT
        for j in range(i, 100, i) :
        INDENT
            arr [j] = not arr [j]
        DEDENT
    DEDENT
    count = 0
    for i in range(0, 100) :
    INDENT
        if arr [i] == 1 :
        INDENT
            count += 1
        DEDENT
    DEDENT
    return count
DEDENT
----------------------------------------

def door_traversal() :
INDENT
    arr = list(0 for _ in range(101))
    arr = [0 for _ in range(101)]

    for i in range(1, 101) :
    INDENT
        for j in range(i, 101, i) :
        INDENT
            arr [j] = not arr [j]
        DEDENT
    DEDENT
    count = 0
    for i in range(1, 101, 1) :
    INDENT
        if arr [i] == 1 :
        INDENT
            count += 1
        DEDENT
    DEDENT
    return count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39027187_39027452_1_17
39027187_39027480_1_21
Title: Appending miniature lists to a larger list 
----------------------------------------

def calcpossiblemoves(self, currentbid, totalnoofdice) :
INDENT
    possiblemoves = []
    numberof, value = currentbid
    while numberOf < = totalnoofdice :
    INDENT
        while value < 6 :
        INDENT
            value += 1
            possiblemoves.append((numberOf, value))

        DEDENT
        numberof += 1
        value = 1
    DEDENT
    return self.possiblemoves
DEDENT
----------------------------------------

def calcpossiblemoves(currentbid, totalnoofdice) :
INDENT
    possiblemoves = []
    bid = currentbid
    available_bid = None
    while bid [0] < = totalnoofdice :
    INDENT
        while bid [1] < 6 :
        INDENT
            bid [1] += 1
            available_bid = [bid [0], bid [1]]
            possiblemoves.append(available_bid)
            print (possiblemoves)
        DEDENT
        bid [0] += 1
        bid [1] = 1
    DEDENT
    return possiblemoves
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39043552_39044129_1_9
39043552_39044588_1_13
Title: Combinations of restricted set of integers 
----------------------------------------

def combinations(allowed_ints, goal) :
INDENT
    if goal > 0 :
    INDENT
        for i in allowed_ints :
        INDENT
            for p in combinations(allowed_ints, goal - i) :
            INDENT
                if sum([i] + p) == goal :
                INDENT
                    yield [i] + p
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        yield []
    DEDENT
DEDENT
----------------------------------------

def combinations(allowed_ints, list, goal) :
INDENT
    if sum(list) == goal :
    INDENT
        print list
    DEDENT
    elif sum(list) > goal :
    INDENT
        pass
    DEDENT
    else :
    INDENT
        for i in allowed_ints :
        INDENT
            new_list = list [:]
            new_list.append(i)
            combinations(allowed_ints, new_list, goal)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39046059_39052495_12_19
39046059_39064225_12_20
Title: PyQt - Location of the window 
----------------------------------------

def location_on_the_screen(self) :
INDENT
    screen = QDesktopWidget().screenGeometry()
    widget = self.geometry()
    x = screen.width() - widget.width()
    y = screen.height() - widget.height()
    self.move(x, y)

DEDENT
----------------------------------------

def location_on_the_screen(self) :
INDENT
    ag = QDesktopWidget().availableGeometry()
    sg = QDesktopWidget().screenGeometry()
    widget = self.geometry()
    x = ag.width() - widget.width()
    y = 2 * ag.height() - sg.height() - widget.height()
    self.move(x, y)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39055156_39055583_1_14
39055156_39061048_1_12
Title: user profile of other user shows up 
----------------------------------------

def profile(request, profile_id) :
INDENT
    if profile_id is "0" :
    INDENT
        userProfile = get_object_or_404(UserProfile, pk = (profile_id + 1))
    DEDENT
    else :
    INDENT
        userProfile = get_object_or_404(UserProfile, pk = (profile_id + 1))
        user_restaurant = userProfile.restaurant.all()
        user_order = userProfile.order_history.all()
        total_purchase = 0
        for ur in user_order :
        INDENT
            total_purchase += ur.get_cost()
        DEDENT
    DEDENT
    return render(request, 'userprofiles/profile.html', {'userProfile' : userProfile,
            'user_restaurant' : user_restaurant,
            'user_order' : user_order,
            'total_purchase' : total_purchase})
DEDENT
----------------------------------------

def profile(request, profile_slug) :
INDENT
    if profile_slug is None :
    INDENT
        userprofile = get_object_or_404(UserProfile, slug = profile_slug)
    DEDENT
    else :
    INDENT
        userprofile = get_object_or_404(UserProfile, slug = profile_slug)
        user_restaurant = userprofile.restaurant.all()
        user_order = userprofile.order_history.all()
        total_purchase = userprofile.total_purchase
    DEDENT
    return render(request, 'userprofiles/profile.html', {'userprofile' : userprofile,
            'user_restaurant' : user_restaurant,
            'user_order' : user_order,
            'total_purchase' : total_purchase})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39079044_39079543_1_12
39079044_39092768_5_21
Title: Index out of range error in scrapy 
----------------------------------------

def product(self, response) :
INDENT
    products = response.xpath('descendant::*[@class="product_list_ul"]')
    products = response.xpath('//*[@class="product_list_ul"]')
    for prod in products :
    INDENT
        item = Item()
        item ['link'] = prod.xpath('.//*[@class="product-image"]//a/@href').extract()
        item ['name'] = prod.xpath('.//*[@class="product-name"]//a/@title').extract()
        item ['unit'] = prod.xpath('.//*[@class="unit"]/p/text()').extract()
        item ['price'] = prod.xpath('.//*[@class="price"]/text()').extract()
        item ['image_url'] = prod.xpath('.//*[@class="product-image"]//a//img/@src').extract()
        yield item
    DEDENT
DEDENT
----------------------------------------

def product(self, response) :
INDENT
    products = response.xpath('descendant::*[@class="product_list_ul"]')
    item = Item()
    i = 0
    while i < 20 :
    INDENT
        item ['link'] = products.xpath(
            'descendant::*[@class="product-image"]//a/@href').extract() [i]
        item ['name'] = products.xpath(
            'descendant::*[@class="product-name"]//a/@title').extract() [i]
        item ['unit'] = products.xpath(
            'descendant::*[@class="unit"]/p/text()').extract() [i]
        item ['price'] = products.xpath(
            'descendant::*[@class="price"]/text()').extract() [i]
        item ['image_url'] = products.xpath(
            'descendant::*[@class="product-image"]//a//img/@src').extract() [i]
        i += 1
        yield item
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39093920_39094539_1_29
39093920_39327738_1_38
Title: Counter not working 
----------------------------------------

def fix_shapes() :
INDENT
    all_geos = cmds.ls(sl = True)
    counter = 0
    for geo in all_geos :
    INDENT
        shapes = cmds.listRelatives(geo, fullPath = True, shapes = True)
        if len(shapes) == 1 :
        INDENT
            continue
        DEDENT
        new_listing = []
        listing.append(shapes [: 1])
        multi_shapes = shapes [1 :]
        for multi_shape in multi_shapes :
        INDENT
            new_transform = cmds.duplicate(multi_shape, parentOnly = True)
            new_geos = cmds.parent(multi_shape, new_transform, addObject = True, shape = True)
            listing.append(new_geos)

            cmds.parent(multi_shape, removeObject = True, shape = True)

        DEDENT
        new_group_name = cmds.group(em = True, name = 'TEST_' + str(counter + 1) + '_GRP')
        for item in new_listing :
        INDENT
            new_geos_parent_name = cmds.listRelatives(item, parent = True)
            cmds.parent(new_geos_parent_name, new_group_name)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def fix_shapes() :
INDENT
    all_geos = cmds.ls(sl = True)
    counter = 0
    for geo in all_geos :
    INDENT
        shapes = cmds.listRelatives(geo, fullPath = True, shapes = True)
        if len(shapes) == 1 :
        INDENT
            continue
        DEDENT
        new_listing = []
        new_listing.append(shapes [: 1])
        multi_shapes = shapes [1 :]
        for multi_shape in multi_shapes :
        INDENT
            new_transform = cmds.duplicate(multi_shape, parentOnly = True)
            new_geos = cmds.parent(multi_shape, new_transform, addObject = True, shape = True)
            new_listing.append(new_geos)

            cmds.parent(multi_shape, removeObject = True, shape = True)

        DEDENT
        new_grp_id = "TEST_{0}_GRP".format(counter)
        if not cmds.objExists(new_grp_id) :
        INDENT
            new_group_name = cmds.group(em = True, name = new_grp_id)
            counter += 1
        DEDENT
        else :
        INDENT
            for o in reversed(xrange(100)) :
            INDENT
                if cmds.objExists("TEST_{0}_GRP".format(o)) :
                INDENT
                    counter = o + 1
                    break
                DEDENT
            DEDENT
            new_group_name = cmds.group(em = True, name = "TEST_{0}_GRP".format(counter))
            counter += 1
        DEDENT
        for item in new_listing :
        INDENT
            new_geos_parent_name = cmds.listRelatives(item, parent = True)
            cmds.parent(new_geos_parent_name, new_group_name)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39093920_39296911_1_30
39093920_39327738_1_38
Title: Counter not working 
----------------------------------------

def fix_shapes() :
INDENT
    all_geos = cmds.ls(sl = True)
    counter = 0
    for geo in all_geos :
    INDENT
        shapes = cmds.listRelatives(geo, fullPath = True, shapes = True)
        if len(shapes) == 1 :
        INDENT
            continue
        DEDENT
        listing = []
        listing.append(shapes [: 1])
        multi_shapes = shapes [1 :]
        for multi_shape in multi_shapes :
        INDENT
            new_transform = cmds.duplicate(multi_shape, parentOnly = True)
            new_geos = cmds.parent(multi_shape, new_transform, addObject = True, shape = True)
            listing.append(new_geos)

            cmds.parent(multi_shape, removeObject = True, shape = True)

        DEDENT
        new_group_name = cmds.group(em = True, name = 'TEST_' + str(counter + 1) + '_GRP')
        counter += 1
        for item in listing :
        INDENT
            new_geos_parent_name = cmds.listRelatives(item, parent = True)
            cmds.parent(new_geos_parent_name, new_group_name)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def fix_shapes() :
INDENT
    all_geos = cmds.ls(sl = True)
    counter = 0
    for geo in all_geos :
    INDENT
        shapes = cmds.listRelatives(geo, fullPath = True, shapes = True)
        if len(shapes) == 1 :
        INDENT
            continue
        DEDENT
        new_listing = []
        new_listing.append(shapes [: 1])
        multi_shapes = shapes [1 :]
        for multi_shape in multi_shapes :
        INDENT
            new_transform = cmds.duplicate(multi_shape, parentOnly = True)
            new_geos = cmds.parent(multi_shape, new_transform, addObject = True, shape = True)
            new_listing.append(new_geos)

            cmds.parent(multi_shape, removeObject = True, shape = True)

        DEDENT
        new_grp_id = "TEST_{0}_GRP".format(counter)
        if not cmds.objExists(new_grp_id) :
        INDENT
            new_group_name = cmds.group(em = True, name = new_grp_id)
            counter += 1
        DEDENT
        else :
        INDENT
            for o in reversed(xrange(100)) :
            INDENT
                if cmds.objExists("TEST_{0}_GRP".format(o)) :
                INDENT
                    counter = o + 1
                    break
                DEDENT
            DEDENT
            new_group_name = cmds.group(em = True, name = "TEST_{0}_GRP".format(counter))
            counter += 1
        DEDENT
        for item in new_listing :
        INDENT
            new_geos_parent_name = cmds.listRelatives(item, parent = True)
            cmds.parent(new_geos_parent_name, new_group_name)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39094524_39138502_6_31
39094524_39141934_1_17
Title: Odoo: _get_state() takes at least 4 arguments (4 given) in xml view 
----------------------------------------

def _get_state(self, cr, uid, context = None) :
INDENT
    idemployee = ""
    ids = self.search(cr, uid, [], context = context)
    for adv in self.browse(cr, uid, ids, context = context) :
    INDENT
        id_employee = adv.id_employee
        if id_employee is None :
        INDENT
            idemployee = self._default_employee(cr, uid, ids, context = None)
        DEDENT
        else :
        INDENT
            idemployee = id_employee.id
        DEDENT
    DEDENT
    sql = " SELECT C.id AS id, C.sequence, C.name \
                   FROM wf_group_member A \
           LEFT JOIN wf_group B ON B.id = A.group_id \
           LEFT JOIN wf_process BB ON BB.id = B.process_id \
           LEFT JOIN wf_state C ON C.group_id = B.id \
           LEFT JOIN hr_employee D ON D.id = A.member_id \
           WHERE LOWER(code) = 'ca' AND member_id = %s ORDER BY sequence "
    res = []
    cr.execute(sql, [(idemployee)])
    ardata = cr.fetchall()
    for data in ardata :
    INDENT
        res.append((data [1], data [2]))
    DEDENT
    return res
DEDENT
----------------------------------------

def _get_state(self, cr, uid, ids, context = None) :
INDENT
    current_record = self.browse(cr, uid, ids)
    idemployee = current_record [0].id_employee
    sql = " SELECT C.id AS id, C.sequence, C.name \
                   FROM wf_group_member A \
           LEFT JOIN wf_group B ON B.id = A.group_id \
           LEFT JOIN wf_process BB ON BB.id = B.process_id \
           LEFT JOIN wf_state C ON C.group_id = B.id \
           LEFT JOIN hr_employee D ON D.id = A.member_id \
           WHERE LOWER(code) = 'ca' AND member_id = %s ORDER BY sequence "
    res = []
    cr.execute(sql, [(idemployee)])
    ardata = cr.fetchall()
    for data in ardata :
    INDENT
        res.append((data [1], data [2]))
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39096799_39102441_30_61
39096799_39119543_5_15
Title: Python XML DOM collecting elements data 
----------------------------------------

def getPayLoad(dom) :
INDENT
    dict = {}
    index = 1
    indexRecord = 1
    for i in dom.getElementsByTagNameNS('*', 'situation') :
    INDENT
        print (str.format("Situation ID: {0} numero {1}", getAttributeID(i), index))
        print (getText(dom.getElementsByTagNameNS('*', 'confidentiality') [index].firstChild))
        print (getText(dom.getElementsByTagNameNS('*', 'informationStatus') [index].firstChild))
        for record in dom.getElementsByTagNameNS('*', 'situation') [index].childNodes :
        INDENT
            if record.nodeType ! = record.TEXT_NODE :
            INDENT
                print (str.format("SituationRecord ID: {0} numero {1}", getAttributeID(record), indexRecord))
                print (getText(dom.getElementsByTagNameNS('*', 'situationRecordCreationReference') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'situationRecordCreationTime') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'situationRecordVersion') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'situationRecordVersionTime') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'situationRecordFirstSupplierVersionTime') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'probabilityOfOccurrence') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'sourceCountry') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'sourceIdentification') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'validityStatus') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'overallStartTime') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'overallEndTime') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'impactOnTraffic') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'locationDescriptor') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'tpegDirection') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'latitude') [indexRecord].firstChild))
                print (getText(dom.getElementsByTagNameNS('*', 'longitude') [indexRecord].firstChild))
                print (str.format("VALUE FIELD: {0}", getText(dom.getElementsByTagNameNS('*', 'descriptor') [indexRecord].firstChild)))
                indexRecord = indexRecord + 1
            DEDENT
        DEDENT
        index = index + 1
    DEDENT
DEDENT
----------------------------------------

def getPayLoad(dom) :
INDENT
    attrs = ['confidentiality', 'informationStatus', 'situationRecordCreationReference', 'situationRecordCreationTime', 'situationRecordVersion', 'situationRecordVersionTime', 'situationRecordFirstSupplierVersionTime', 'probabilityOfOccurrence', 'sourceCountry', 'sourceIdentification', 'validityStatus', 'overallStartTime', 'overallEndTime', 'impactOnTraffic', 'locationDescriptor', 'tpegDirection', 'latitude', 'longitude', 'tpegDescriptorType', 'from']
    for index, node in enumerate(dom.getElementsByTagNameNS('*', 'situation'), 1) :
    INDENT
        print ("\nSituation ID: {0} numero {1}".format(getAttributeID(node), index))
        for attr in attrs :
        INDENT
            key = node.getElementsByTagNameNS('*', attr)
            if key :
            INDENT
                value = getText(key [0].firstChild)
                if value :
                INDENT
                    print ('{0}: {1}'.format(attr, value))
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39096933_39097108_1_10
39096933_39097456_10_16
Title: Is there any shorter way to write this method? 
----------------------------------------

def check(line) :
INDENT
    spec = [
        ['0', '1'],
        ['0', '1', 'None'],
        ['0', '1', 'None'],
        ['R', 'L'],
        ['0', '1']]
    return len(line) == len(spec) and all(ln in spc for ln, spc in zip(line, spec))
DEDENT
----------------------------------------

def check() :
INDENT
    for l, item in enumerate(line) :
    INDENT
        if not item in check_list [l] :
        INDENT
            return False
        DEDENT
        elif l == 4 :
        INDENT
            return True
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39105532_39105714_1_15
39105532_39107742_1_16
Title: Python raw input function for tax calculation 
----------------------------------------

def taxes(salary) :
INDENT
    salary > = 0
    tax = 0
    if salary < 11000 :
    INDENT
        tax = 0
    DEDENT
    elif salary > 11000 and salary < 43000 :
    INDENT
        tax = (0.2 * income) - 2200
    DEDENT
    elif salary > 43000 and salary < 150000 :
    INDENT
        tax = (0.4 * (salary - 43000)) + 6400
    DEDENT
    elif salary > 150000 :
    INDENT
        tax = ((salary - 150000) * 0.45) + 6400 + 42800
    DEDENT
    print ("Value of tax is: " + str(tax))
    return tax
DEDENT
----------------------------------------

def taxes(salary, tax_bands, tax_amts) :
INDENT
    tax_list = [(pct * (salary - band)) for (band, pct) in zip(tax_bands, tax_amts)]
    max_tax = []
    for index, sal in enumerate(tax_bands [: - 1]) :
    INDENT
        max_tax.append(tax_bands [index + 1] - sal)
    DEDENT
    max_tax = [segment * tax for segment, tax in zip(max_tax, tax_amts [: - 1])]
    for index, value in enumerate(tax_list) :
    INDENT
        try :
        INDENT
            if value > max_tax [index] :
            INDENT
                tax_list [index] = max_tax [index]
            DEDENT
        DEDENT
        except :
        INDENT
            pass
        DEDENT
        tax_to_pay = sum([x for x in tax_list if x > 0])
    DEDENT
    return tax_to_pay
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39105532_39105770_6_20
39105532_39107742_1_16
Title: Python raw input function for tax calculation 
----------------------------------------

def taxes(salary) :
INDENT
    salary > = 0
    while true :
    INDENT
        if salary < 11000 :
        INDENT
            tax = 0
        DEDENT
        elif salary > 11000 and salary < 43000 :
        INDENT
            tax = (0.2 * income) - 2200
        DEDENT
        elif salary > 43000 and salary < 150000 :
        INDENT
            tax = (0.4 * (salary - 43000)) + 6400
        DEDENT
        elif salary > 150000 :
        INDENT
            tax = ((salary - 150000) * 0.45) + 6400 + 42800
        DEDENT
        else :
        INDENT
            tax = undefined
        DEDENT
    DEDENT
    return tax
DEDENT
----------------------------------------

def taxes(salary, tax_bands, tax_amts) :
INDENT
    tax_list = [(pct * (salary - band)) for (band, pct) in zip(tax_bands, tax_amts)]
    max_tax = []
    for index, sal in enumerate(tax_bands [: - 1]) :
    INDENT
        max_tax.append(tax_bands [index + 1] - sal)
    DEDENT
    max_tax = [segment * tax for segment, tax in zip(max_tax, tax_amts [: - 1])]
    for index, value in enumerate(tax_list) :
    INDENT
        try :
        INDENT
            if value > max_tax [index] :
            INDENT
                tax_list [index] = max_tax [index]
            DEDENT
        DEDENT
        except :
        INDENT
            pass
        DEDENT
        tax_to_pay = sum([x for x in tax_list if x > 0])
    DEDENT
    return tax_to_pay
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39105532_39105995_6_18
39105532_39107742_1_16
Title: Python raw input function for tax calculation 
----------------------------------------

def taxes(salary) :
INDENT
    while true :
    INDENT
        if salary < 11000 :
        INDENT
            tax = 0
        DEDENT
        elif 11000 < salary < 43000 :
        INDENT
            tax = (0.2 * income) - 2200
        DEDENT
        elif salary > 43000 and salary < 150000 :
        INDENT
            tax = (0.4 * (salary - 43000)) + 6400
        DEDENT
        elif salary > 150000 :
        INDENT
            tax = ((salary - 150000) * 0.45) + 6400 + 42800
        DEDENT
    DEDENT
    return tax
DEDENT
----------------------------------------

def taxes(salary, tax_bands, tax_amts) :
INDENT
    tax_list = [(pct * (salary - band)) for (band, pct) in zip(tax_bands, tax_amts)]
    max_tax = []
    for index, sal in enumerate(tax_bands [: - 1]) :
    INDENT
        max_tax.append(tax_bands [index + 1] - sal)
    DEDENT
    max_tax = [segment * tax for segment, tax in zip(max_tax, tax_amts [: - 1])]
    for index, value in enumerate(tax_list) :
    INDENT
        try :
        INDENT
            if value > max_tax [index] :
            INDENT
                tax_list [index] = max_tax [index]
            DEDENT
        DEDENT
        except :
        INDENT
            pass
        DEDENT
        tax_to_pay = sum([x for x in tax_list if x > 0])
    DEDENT
    return tax_to_pay
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39119500_39119569_8_20
39119500_39120536_1_18
Title: How to I list down the results of a function (python) 
----------------------------------------

def add() :
INDENT
    userSelect = input("Do You Want to Add?"
        "\n(Y) Yes ; (N) No"
        "\n")
    while userSelect ! = "Y" and userSelect ! = "N" :
    INDENT
        print ("Error")
        add()
    DEDENT
    if userSelect == "Y" :
    INDENT
        numberA()
        add()
    DEDENT
    else :
    INDENT
        print ("Bye")
    DEDENT
DEDENT
----------------------------------------

def add() :
INDENT
    ask = True
    res = []
    while ask :
    INDENT
        num1 = int(input("Enter First Number : "))
        num2 = int(input("Enter Second Number : "))
        total = num1 + num2
        userSelect = input("Do You Want to Add?"
            "\n(Y) Yes ; (N) No"
            "\n")
        if userSelect not in ['Y', 'N'] :
        INDENT
            print "Error"
        DEDENT
        elif userSelect == 'Y' :
        INDENT
            ask = True
        DEDENT
        else :
        INDENT
            ask = False
        DEDENT
        res.append(total)
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39120783_39121003_2_8
39120783_39121239_3_8
Title: Replacing all numeric value to formatted string 
----------------------------------------

def repl(match) :
INDENT
    chunks = match.group(1).split(".")
    if len(chunks) == 2 :
    INDENT
        return "FLT_{}".format(len(chunks [1]))
    DEDENT
    else :
    INDENT
        return "INT_{}".format(len(chunks [0]))
    DEDENT
DEDENT
----------------------------------------

def repl(m) :
INDENT
    if m.group(1) is None :
    INDENT
        return ("INT_%i" % len(m.group(2)))
    DEDENT
    else :
    INDENT
        return ("FLT_%i" % (len(m.group(2))))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39131025_39153251_15_30
39131025_39153251_43_52
Title: zooming with NavigationToolbar does not work in matplotlib with pyqt 
----------------------------------------

def __init__(self, parent = None, width = 5, height = 4, dpi = 100) :
INDENT
    fig = Figure(figsize = (width, height), dpi = dpi)
    self.fig = fig
    self.axes = fig.add_subplot(111)
    self.axes.hold(False)
    self.compute_initial_figure()
    FigureCanvas.__init__(self, fig)
    self.setParent(parent)
    FigureCanvas.setSizePolicy(self,
        QSizePolicy.Expanding,
        QSizePolicy.Expanding)
    FigureCanvas.updateGeometry(self)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QWidget.__init__(self)
    self.plot_layout = QVBoxLayout(self)
    self.plot_canvas = MyStaticMplCanvas(self, width = 5, height = 4, dpi = 100)
    self.navi_toolbar = NavigationToolbar(self.plot_canvas, self)
    self.plot_layout.addWidget(self.plot_canvas)
    self.plot_layout.addWidget(self.navi_toolbar)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39139935_39140062_11_17
39139935_39140114_12_18
Title: Settin general defaults for named arguments in python 
----------------------------------------

def CreatePointEntity(ID, Name, Solver, P1, Move = MOVE, Perimeter = 0.0, Gap = 'yes') :
INDENT
    SetValues(ID, {'Name' : Name})
    SetValues(ID, {'P1' : P1})
    SetValues(ID, {'Solver' : Solver})
    SetValues(ID, {'Move' : Move})
    SetValues(ID, {'Perim' : Perimeter})
    SetValues(ID, {'Gap' : Gap})
DEDENT
----------------------------------------

def CreatePointEntity(ID, Name, Solver, P1, Move = MOVE, Perimeter = PERIMETER, Gap = GAP) :
INDENT
    SetValues(ID, {'Name' : Name})
    SetValues(ID, {'P1' : P1})
    SetValues(ID, {'Solver' : Solver})
    SetValues(ID, {'Move' : Move})
    SetValues(ID, {'Perim' : Perimeter})
    SetValues(ID, {'Gap' : Gap})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39190815_39191074_3_26
39190815_39197064_3_15
Title: How to make perfect power algorithm more efficient? 
----------------------------------------

def isPP(n) :
INDENT
    ln = int(math.log(n) / math.log(2)) + 1
    y = []
    for i in range(n + 1) :
    INDENT
        if (i < = 1) :
        INDENT
            continue
        DEDENT
        li = int(math.log(i) / math.log(2))
        mxi = ln / li + 1
        for it in range(mxi) :
        INDENT
            if (it < = 1) :
            INDENT
                continue
            DEDENT
            if i ** it == n :
            INDENT
                y.append((i, it))

            DEDENT
        DEDENT
    DEDENT
    if len(y) < 1 :
    INDENT
        return None
    DEDENT
    else :
    INDENT
        return list(y [0])
    DEDENT
DEDENT
----------------------------------------

def isPP(n) :
INDENT
    range = math.log(n) / math.log(2)
    range = (int)(range)
    result = []
    for i in xrange(n) :
    INDENT
        if (i < = 1) :
        INDENT
            continue
        DEDENT
        exponent = (int)(math.log(n) / math.log(i))
        for j in [exponent - 1, exponent, exponent + 1] :
        INDENT
            if i ** j == n :
            INDENT
                result.append([i, j])
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39211867_41708226_19_25
39211867_41708226_8_15
Title: Tkinter - Preload window? 
----------------------------------------

def main(cls) :
INDENT
    with cls.setup_root('Tkinter Program') as root :
    INDENT
        root.resizable(False, False)
        frame = cls(root)
        frame.setup_frame('Hello, world!', ' ' * 50)
        frame.grid()
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    root = tkinter.Tk()
    frame = Application(root)
    frame.setup_frame('Hello, world!', ' ' * 50)
    frame.grid()
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
392160_19865575_4_11
392160_393368_2_12
Title: What are some (concrete) use-cases for metaclasses? 
----------------------------------------

def __init__(cls, classname, bases, dict_) :
INDENT
    table = 'p012'
    for i in range(1, 49) :
    INDENT
        fname = "%s%03d" % (table, i)
        dict_ [fname] = Column(Integer)
        setattr(cls, fname, dict_ [fname])
    DEDENT
    super(CensusTableMeta, cls).__init__(classname, bases, dict_)
DEDENT
----------------------------------------

def __init__(cls, name, bases, d) :
INDENT
    super(_Interactify, cls).__init__(name, bases, d)
    for base in bases :
    INDENT
        for attrname in dir(base) :
        INDENT
            if attrname in d : continue
            attr = getattr(cls, attrname)
            if type(attr) == types.MethodType :
            INDENT
                if attrname.startswith("add_") :
                INDENT
                    setattr(cls, attrname, wrap_pylab_newplot(attr))
                DEDENT
                elif attrname.startswith("set_") :
                INDENT
                    setattr(cls, attrname, wrap_pylab_show(attr))
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
392349_3399159_4_16
392349_392372_1_10
Title: Modify bound variables of a closure in Python 
----------------------------------------

def foo() :
INDENT
    st = State()
    st.var_a = 2
    st.var_b = 3
    def _closure(x) :
    INDENT
        return st.var_a + st.var_b + x
    DEDENT
    def _set_a(a) :
    INDENT
        st.var_a = a
    DEDENT
    return _closure, _set_a

DEDENT
----------------------------------------

def foo() :
INDENT
    var_b = 3
    def _closure(x) :
    INDENT
        return _closure.var_a + var_b + x
    DEDENT
    _closure.func_dict ['var_a'] = 2
    return _closure

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
392349_3399159_4_16
392349_8792493_1_9
Title: Modify bound variables of a closure in Python 
----------------------------------------

def foo() :
INDENT
    st = State()
    st.var_a = 2
    st.var_b = 3
    def _closure(x) :
    INDENT
        return st.var_a + st.var_b + x
    DEDENT
    def _set_a(a) :
    INDENT
        st.var_a = a
    DEDENT
    return _closure, _set_a

DEDENT
----------------------------------------

def foo() :
INDENT
    var_a = 2
    var_b = 3
    def _closure(x) :
    INDENT
        return var_a + var_b + x
    DEDENT
    return _closure
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39241704_3_28
39240884_39307567_1_47
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(income_input) :
INDENT
    for item in income_input :
    INDENT
        income = income_input [item]

        if (income > = 0) and (income < = 1000) :
        INDENT
            tax = (0 * income)
        DEDENT
        elif (income > 1000) and (income < = 10000) :
        INDENT
            tax = (0.1 * (income - 1000))
        DEDENT
        elif (income > 10000) and (income < = 20200) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
        DEDENT
        elif (income > 20200) and (income < = 30750) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
        DEDENT
        elif (income > 30750) and (income < = 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
        DEDENT
        elif (income > 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
        DEDENT
        else :
        INDENT
            pass
        DEDENT
        income_input [item] = int(tax)
    DEDENT
    return income_input
DEDENT
----------------------------------------

def calculate_tax(people) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            iterating_people = people.keys()
            for key in iterating_people :
            INDENT
                earning = people [key]
                if earning < = 1000 :
                INDENT
                    people [key] = 0
                DEDENT
                elif earning in range(1001, 10001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * (earning - 1000)
                    total_tax = tax1 + tax2
                    people [key] = total_tax
                DEDENT
                elif earning in range(10001, 20201) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * (earning - 10000)
                    total_tax = tax1 + tax2 + tax3
                    people [key] = total_tax
                DEDENT
                elif earning in range(20201, 30751) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * (earning - 20200)
                    total_tax = tax1 + tax2 + tax3 + tax4
                    people [key] = total_tax
                DEDENT
                elif earning in range(30751, 50001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * (earning - 30750)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5
                    people [key] = total_tax
                DEDENT
                elif earning > 50000 :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * 19250
                    tax6 = 0.3 * (earning - 50000)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5 + tax6
                    people [key] = total_tax
                DEDENT
            DEDENT
            return people
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39241704_3_28
39240884_39313120_1_24
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(income_input) :
INDENT
    for item in income_input :
    INDENT
        income = income_input [item]

        if (income > = 0) and (income < = 1000) :
        INDENT
            tax = (0 * income)
        DEDENT
        elif (income > 1000) and (income < = 10000) :
        INDENT
            tax = (0.1 * (income - 1000))
        DEDENT
        elif (income > 10000) and (income < = 20200) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
        DEDENT
        elif (income > 20200) and (income < = 30750) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
        DEDENT
        elif (income > 30750) and (income < = 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
        DEDENT
        elif (income > 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
        DEDENT
        else :
        INDENT
            pass
        DEDENT
        income_input [item] = int(tax)
    DEDENT
    return income_input
DEDENT
----------------------------------------

def calculate_tax(payroll) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            for key in payroll.keys() :
            INDENT
                income = payroll [key]
                if income < = 1000 or income < 0 :
                INDENT
                    payroll [key] = 0
                DEDENT
                elif income in range(1001, 10001) :
                INDENT
                    payroll [key] = 0.1 * (payroll [key] - 1000)
                DEDENT
                elif income in range(10001, 20201) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (payroll [key] - 10000)))
                DEDENT
                elif income in range(20201, 30751) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (payroll [key] - 20200)))
                DEDENT
                elif income in range(30751, 50001) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (payroll [key] - 30750)))
                DEDENT
                elif income > 50000 :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (payroll [key] - 50000)))
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return payroll
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39241704_3_28
39240884_39889225_1_36
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(income_input) :
INDENT
    for item in income_input :
    INDENT
        income = income_input [item]

        if (income > = 0) and (income < = 1000) :
        INDENT
            tax = (0 * income)
        DEDENT
        elif (income > 1000) and (income < = 10000) :
        INDENT
            tax = (0.1 * (income - 1000))
        DEDENT
        elif (income > 10000) and (income < = 20200) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
        DEDENT
        elif (income > 20200) and (income < = 30750) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
        DEDENT
        elif (income > 30750) and (income < = 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
        DEDENT
        elif (income > 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
        DEDENT
        else :
        INDENT
            pass
        DEDENT
        income_input [item] = int(tax)
    DEDENT
    return income_input
DEDENT
----------------------------------------

def calculate_tax(d) :
INDENT
    d1 = {}
    income = 0
    """cheking for Key pairs"""
    while True :
    INDENT
        try :
        INDENT
            d1 = d.keys()
            for keys in d.keys() :
            INDENT
                income = d [keys]
                if (income > = 0) and (income < = 1000) :
                INDENT
                    tax = (0 * income)
                    d [keys] = tax
                DEDENT
                elif (income > 1000) and (income < = 10000) :
                INDENT
                    tax = (0.1 * (income - 1000))
                    d [keys] = tax
                DEDENT
                elif (income > 10000) and (income < = 20200) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
                    d [keys] = tax
                DEDENT
                elif (income > 20200) and (income < = 30750) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
                    d [keys] = tax
                DEDENT
                elif (income > 30750) and (income < = 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
                    d [keys] = tax
                DEDENT
                elif (income > 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
                    d [keys] = tax
                    """updating d1 dictionary"""
                    d [keys] = tax
                DEDENT
                return d1
                break
            DEDENT
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The input provided is not A dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39241704_3_28
39240884_42536719_1_42
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(income_input) :
INDENT
    for item in income_input :
    INDENT
        income = income_input [item]

        if (income > = 0) and (income < = 1000) :
        INDENT
            tax = (0 * income)
        DEDENT
        elif (income > 1000) and (income < = 10000) :
        INDENT
            tax = (0.1 * (income - 1000))
        DEDENT
        elif (income > 10000) and (income < = 20200) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
        DEDENT
        elif (income > 20200) and (income < = 30750) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
        DEDENT
        elif (income > 30750) and (income < = 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
        DEDENT
        elif (income > 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
        DEDENT
        else :
        INDENT
            pass
        DEDENT
        income_input [item] = int(tax)
    DEDENT
    return income_input
DEDENT
----------------------------------------

def calculate_tax(taxpayer) :
INDENT
    if taxpayer == {} : return {}
    try :
    INDENT
        isinstance(taxpayer, dict)
        output = {}
        for k in taxpayer.keys() :
        INDENT
            try :
            INDENT
                isinstance(taxpayer [k], int)
                payer = k
                salary = taxpayer [k]
                ceilings = (1000, 10000, 20200, 30750, 50000)
                rates = {
                    1000 : {'rate' : 0, 'tax' : 0},
                    10000 : {'rate' : 0.1, 'tax' : 900},
                    20200 : {'rate' : 0.15, 'tax' : 1530},
                    30750 : {'rate' : 0.2, 'tax' : 2110.0},
                    50000 : {'rate' : 0.25, 'tax' : 4812.5}}
                tax = ceiling = tax_on_remnant = 0
                if salary > 50000 :
                INDENT
                    excess = salary - 50000
                    tax_on_remnant = excess * 0.3
                    ceiling = 50000
                    blocks = ceilings [: ceilings.index(ceiling) + 1]
                DEDENT
                else :
                INDENT
                    for k in ceilings :
                    INDENT
                        if salary < = k :
                        INDENT
                            ceiling = k
                            break
                        DEDENT
                    DEDENT
                    floor = ceilings [ceilings.index(ceiling) - 1]
                    remnant = salary - floor
                    tax_on_remnant = remnant * rates [ceiling] ['rate']
                    blocks = ceilings [: ceilings.index(ceiling)]
                DEDENT
                for block in blocks :
                INDENT
                    tax += rates [block] ['tax']
                DEDENT
                tax = tax + tax_on_remnant
                output [payer] = tax
            DEDENT
            except (TypeError) :
            INDENT
                raise ValueError('Allow only numeric input')
            DEDENT
        DEDENT
        return output
    DEDENT
    except (AttributeError, TypeError) :
    INDENT
        raise ValueError('The provided input is not a dictionary')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39297741_1_27
39240884_39307567_1_47
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(income_input = "dictionary", data = {"Alex" : 500, "James" : 20500, "Kinuthia" : 70000}) :
INDENT
    for item in income_input() :
    INDENT
        if (income_input > = 0) and (income_input < = 1000) :
        INDENT
            tax = (0 * income_input)
        DEDENT
        elif (income_input > 1000) and (income_input < = 10000) :
        INDENT
            tax = (0.1 * (income_input - 1000))
        DEDENT
        elif (income_input > 10000) and (income_input < = 20200) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (income_input - 10000)))
        DEDENT
        elif (income_input > 20200) and (income_input < = 30750) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (income_input - 20200)))
        DEDENT
        elif (income_input > 30750) and (income_input < = 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (30750 - 20200)) + (0.25 * (income_input - 30750)))
        DEDENT
        elif (income_input > 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) +
                (0.3 * (income_input - 50000)))
        DEDENT
        else :
        INDENT
            pass
            keys = set(data)
            return income_input, keys
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(people) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            iterating_people = people.keys()
            for key in iterating_people :
            INDENT
                earning = people [key]
                if earning < = 1000 :
                INDENT
                    people [key] = 0
                DEDENT
                elif earning in range(1001, 10001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * (earning - 1000)
                    total_tax = tax1 + tax2
                    people [key] = total_tax
                DEDENT
                elif earning in range(10001, 20201) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * (earning - 10000)
                    total_tax = tax1 + tax2 + tax3
                    people [key] = total_tax
                DEDENT
                elif earning in range(20201, 30751) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * (earning - 20200)
                    total_tax = tax1 + tax2 + tax3 + tax4
                    people [key] = total_tax
                DEDENT
                elif earning in range(30751, 50001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * (earning - 30750)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5
                    people [key] = total_tax
                DEDENT
                elif earning > 50000 :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * 19250
                    tax6 = 0.3 * (earning - 50000)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5 + tax6
                    people [key] = total_tax
                DEDENT
            DEDENT
            return people
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39297741_1_27
39240884_39313120_1_24
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(income_input = "dictionary", data = {"Alex" : 500, "James" : 20500, "Kinuthia" : 70000}) :
INDENT
    for item in income_input() :
    INDENT
        if (income_input > = 0) and (income_input < = 1000) :
        INDENT
            tax = (0 * income_input)
        DEDENT
        elif (income_input > 1000) and (income_input < = 10000) :
        INDENT
            tax = (0.1 * (income_input - 1000))
        DEDENT
        elif (income_input > 10000) and (income_input < = 20200) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (income_input - 10000)))
        DEDENT
        elif (income_input > 20200) and (income_input < = 30750) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (income_input - 20200)))
        DEDENT
        elif (income_input > 30750) and (income_input < = 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (30750 - 20200)) + (0.25 * (income_input - 30750)))
        DEDENT
        elif (income_input > 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) +
                (0.3 * (income_input - 50000)))
        DEDENT
        else :
        INDENT
            pass
            keys = set(data)
            return income_input, keys
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(payroll) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            for key in payroll.keys() :
            INDENT
                income = payroll [key]
                if income < = 1000 or income < 0 :
                INDENT
                    payroll [key] = 0
                DEDENT
                elif income in range(1001, 10001) :
                INDENT
                    payroll [key] = 0.1 * (payroll [key] - 1000)
                DEDENT
                elif income in range(10001, 20201) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (payroll [key] - 10000)))
                DEDENT
                elif income in range(20201, 30751) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (payroll [key] - 20200)))
                DEDENT
                elif income in range(30751, 50001) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (payroll [key] - 30750)))
                DEDENT
                elif income > 50000 :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (payroll [key] - 50000)))
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return payroll
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39297741_1_27
39240884_39889225_1_36
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(income_input = "dictionary", data = {"Alex" : 500, "James" : 20500, "Kinuthia" : 70000}) :
INDENT
    for item in income_input() :
    INDENT
        if (income_input > = 0) and (income_input < = 1000) :
        INDENT
            tax = (0 * income_input)
        DEDENT
        elif (income_input > 1000) and (income_input < = 10000) :
        INDENT
            tax = (0.1 * (income_input - 1000))
        DEDENT
        elif (income_input > 10000) and (income_input < = 20200) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (income_input - 10000)))
        DEDENT
        elif (income_input > 20200) and (income_input < = 30750) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (income_input - 20200)))
        DEDENT
        elif (income_input > 30750) and (income_input < = 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (30750 - 20200)) + (0.25 * (income_input - 30750)))
        DEDENT
        elif (income_input > 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) +
                (0.3 * (income_input - 50000)))
        DEDENT
        else :
        INDENT
            pass
            keys = set(data)
            return income_input, keys
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(d) :
INDENT
    d1 = {}
    income = 0
    """cheking for Key pairs"""
    while True :
    INDENT
        try :
        INDENT
            d1 = d.keys()
            for keys in d.keys() :
            INDENT
                income = d [keys]
                if (income > = 0) and (income < = 1000) :
                INDENT
                    tax = (0 * income)
                    d [keys] = tax
                DEDENT
                elif (income > 1000) and (income < = 10000) :
                INDENT
                    tax = (0.1 * (income - 1000))
                    d [keys] = tax
                DEDENT
                elif (income > 10000) and (income < = 20200) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
                    d [keys] = tax
                DEDENT
                elif (income > 20200) and (income < = 30750) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
                    d [keys] = tax
                DEDENT
                elif (income > 30750) and (income < = 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
                    d [keys] = tax
                DEDENT
                elif (income > 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
                    d [keys] = tax
                    """updating d1 dictionary"""
                    d [keys] = tax
                DEDENT
                return d1
                break
            DEDENT
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The input provided is not A dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39297741_1_27
39240884_42536719_1_42
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(income_input = "dictionary", data = {"Alex" : 500, "James" : 20500, "Kinuthia" : 70000}) :
INDENT
    for item in income_input() :
    INDENT
        if (income_input > = 0) and (income_input < = 1000) :
        INDENT
            tax = (0 * income_input)
        DEDENT
        elif (income_input > 1000) and (income_input < = 10000) :
        INDENT
            tax = (0.1 * (income_input - 1000))
        DEDENT
        elif (income_input > 10000) and (income_input < = 20200) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (income_input - 10000)))
        DEDENT
        elif (income_input > 20200) and (income_input < = 30750) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (income_input - 20200)))
        DEDENT
        elif (income_input > 30750) and (income_input < = 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (30750 - 20200)) + (0.25 * (income_input - 30750)))
        DEDENT
        elif (income_input > 50000) :
        INDENT
            tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) +
                (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) +
                (0.3 * (income_input - 50000)))
        DEDENT
        else :
        INDENT
            pass
            keys = set(data)
            return income_input, keys
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(taxpayer) :
INDENT
    if taxpayer == {} : return {}
    try :
    INDENT
        isinstance(taxpayer, dict)
        output = {}
        for k in taxpayer.keys() :
        INDENT
            try :
            INDENT
                isinstance(taxpayer [k], int)
                payer = k
                salary = taxpayer [k]
                ceilings = (1000, 10000, 20200, 30750, 50000)
                rates = {
                    1000 : {'rate' : 0, 'tax' : 0},
                    10000 : {'rate' : 0.1, 'tax' : 900},
                    20200 : {'rate' : 0.15, 'tax' : 1530},
                    30750 : {'rate' : 0.2, 'tax' : 2110.0},
                    50000 : {'rate' : 0.25, 'tax' : 4812.5}}
                tax = ceiling = tax_on_remnant = 0
                if salary > 50000 :
                INDENT
                    excess = salary - 50000
                    tax_on_remnant = excess * 0.3
                    ceiling = 50000
                    blocks = ceilings [: ceilings.index(ceiling) + 1]
                DEDENT
                else :
                INDENT
                    for k in ceilings :
                    INDENT
                        if salary < = k :
                        INDENT
                            ceiling = k
                            break
                        DEDENT
                    DEDENT
                    floor = ceilings [ceilings.index(ceiling) - 1]
                    remnant = salary - floor
                    tax_on_remnant = remnant * rates [ceiling] ['rate']
                    blocks = ceilings [: ceilings.index(ceiling)]
                DEDENT
                for block in blocks :
                INDENT
                    tax += rates [block] ['tax']
                DEDENT
                tax = tax + tax_on_remnant
                output [payer] = tax
            DEDENT
            except (TypeError) :
            INDENT
                raise ValueError('Allow only numeric input')
            DEDENT
        DEDENT
        return output
    DEDENT
    except (AttributeError, TypeError) :
    INDENT
        raise ValueError('The provided input is not a dictionary')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39307567_1_47
39240884_39313120_1_24
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(people) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            iterating_people = people.keys()
            for key in iterating_people :
            INDENT
                earning = people [key]
                if earning < = 1000 :
                INDENT
                    people [key] = 0
                DEDENT
                elif earning in range(1001, 10001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * (earning - 1000)
                    total_tax = tax1 + tax2
                    people [key] = total_tax
                DEDENT
                elif earning in range(10001, 20201) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * (earning - 10000)
                    total_tax = tax1 + tax2 + tax3
                    people [key] = total_tax
                DEDENT
                elif earning in range(20201, 30751) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * (earning - 20200)
                    total_tax = tax1 + tax2 + tax3 + tax4
                    people [key] = total_tax
                DEDENT
                elif earning in range(30751, 50001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * (earning - 30750)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5
                    people [key] = total_tax
                DEDENT
                elif earning > 50000 :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * 19250
                    tax6 = 0.3 * (earning - 50000)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5 + tax6
                    people [key] = total_tax
                DEDENT
            DEDENT
            return people
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(payroll) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            for key in payroll.keys() :
            INDENT
                income = payroll [key]
                if income < = 1000 or income < 0 :
                INDENT
                    payroll [key] = 0
                DEDENT
                elif income in range(1001, 10001) :
                INDENT
                    payroll [key] = 0.1 * (payroll [key] - 1000)
                DEDENT
                elif income in range(10001, 20201) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (payroll [key] - 10000)))
                DEDENT
                elif income in range(20201, 30751) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (payroll [key] - 20200)))
                DEDENT
                elif income in range(30751, 50001) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (payroll [key] - 30750)))
                DEDENT
                elif income > 50000 :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (payroll [key] - 50000)))
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return payroll
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39307567_1_47
39240884_39889225_1_36
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(people) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            iterating_people = people.keys()
            for key in iterating_people :
            INDENT
                earning = people [key]
                if earning < = 1000 :
                INDENT
                    people [key] = 0
                DEDENT
                elif earning in range(1001, 10001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * (earning - 1000)
                    total_tax = tax1 + tax2
                    people [key] = total_tax
                DEDENT
                elif earning in range(10001, 20201) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * (earning - 10000)
                    total_tax = tax1 + tax2 + tax3
                    people [key] = total_tax
                DEDENT
                elif earning in range(20201, 30751) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * (earning - 20200)
                    total_tax = tax1 + tax2 + tax3 + tax4
                    people [key] = total_tax
                DEDENT
                elif earning in range(30751, 50001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * (earning - 30750)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5
                    people [key] = total_tax
                DEDENT
                elif earning > 50000 :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * 19250
                    tax6 = 0.3 * (earning - 50000)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5 + tax6
                    people [key] = total_tax
                DEDENT
            DEDENT
            return people
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(d) :
INDENT
    d1 = {}
    income = 0
    """cheking for Key pairs"""
    while True :
    INDENT
        try :
        INDENT
            d1 = d.keys()
            for keys in d.keys() :
            INDENT
                income = d [keys]
                if (income > = 0) and (income < = 1000) :
                INDENT
                    tax = (0 * income)
                    d [keys] = tax
                DEDENT
                elif (income > 1000) and (income < = 10000) :
                INDENT
                    tax = (0.1 * (income - 1000))
                    d [keys] = tax
                DEDENT
                elif (income > 10000) and (income < = 20200) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
                    d [keys] = tax
                DEDENT
                elif (income > 20200) and (income < = 30750) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
                    d [keys] = tax
                DEDENT
                elif (income > 30750) and (income < = 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
                    d [keys] = tax
                DEDENT
                elif (income > 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
                    d [keys] = tax
                    """updating d1 dictionary"""
                    d [keys] = tax
                DEDENT
                return d1
                break
            DEDENT
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The input provided is not A dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39307567_1_47
39240884_42536719_1_42
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(people) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            iterating_people = people.keys()
            for key in iterating_people :
            INDENT
                earning = people [key]
                if earning < = 1000 :
                INDENT
                    people [key] = 0
                DEDENT
                elif earning in range(1001, 10001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * (earning - 1000)
                    total_tax = tax1 + tax2
                    people [key] = total_tax
                DEDENT
                elif earning in range(10001, 20201) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * (earning - 10000)
                    total_tax = tax1 + tax2 + tax3
                    people [key] = total_tax
                DEDENT
                elif earning in range(20201, 30751) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * (earning - 20200)
                    total_tax = tax1 + tax2 + tax3 + tax4
                    people [key] = total_tax
                DEDENT
                elif earning in range(30751, 50001) :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * (earning - 30750)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5
                    people [key] = total_tax
                DEDENT
                elif earning > 50000 :
                INDENT
                    tax1 = 0 * 1000
                    tax2 = 0.1 * 9000
                    tax3 = 0.15 * 10200
                    tax4 = 0.20 * 10550
                    tax5 = 0.25 * 19250
                    tax6 = 0.3 * (earning - 50000)
                    total_tax = tax1 + tax2 + tax3 + tax4 + tax5 + tax6
                    people [key] = total_tax
                DEDENT
            DEDENT
            return people
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(taxpayer) :
INDENT
    if taxpayer == {} : return {}
    try :
    INDENT
        isinstance(taxpayer, dict)
        output = {}
        for k in taxpayer.keys() :
        INDENT
            try :
            INDENT
                isinstance(taxpayer [k], int)
                payer = k
                salary = taxpayer [k]
                ceilings = (1000, 10000, 20200, 30750, 50000)
                rates = {
                    1000 : {'rate' : 0, 'tax' : 0},
                    10000 : {'rate' : 0.1, 'tax' : 900},
                    20200 : {'rate' : 0.15, 'tax' : 1530},
                    30750 : {'rate' : 0.2, 'tax' : 2110.0},
                    50000 : {'rate' : 0.25, 'tax' : 4812.5}}
                tax = ceiling = tax_on_remnant = 0
                if salary > 50000 :
                INDENT
                    excess = salary - 50000
                    tax_on_remnant = excess * 0.3
                    ceiling = 50000
                    blocks = ceilings [: ceilings.index(ceiling) + 1]
                DEDENT
                else :
                INDENT
                    for k in ceilings :
                    INDENT
                        if salary < = k :
                        INDENT
                            ceiling = k
                            break
                        DEDENT
                    DEDENT
                    floor = ceilings [ceilings.index(ceiling) - 1]
                    remnant = salary - floor
                    tax_on_remnant = remnant * rates [ceiling] ['rate']
                    blocks = ceilings [: ceilings.index(ceiling)]
                DEDENT
                for block in blocks :
                INDENT
                    tax += rates [block] ['tax']
                DEDENT
                tax = tax + tax_on_remnant
                output [payer] = tax
            DEDENT
            except (TypeError) :
            INDENT
                raise ValueError('Allow only numeric input')
            DEDENT
        DEDENT
        return output
    DEDENT
    except (AttributeError, TypeError) :
    INDENT
        raise ValueError('The provided input is not a dictionary')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39313120_1_24
39240884_39889225_1_36
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(payroll) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            for key in payroll.keys() :
            INDENT
                income = payroll [key]
                if income < = 1000 or income < 0 :
                INDENT
                    payroll [key] = 0
                DEDENT
                elif income in range(1001, 10001) :
                INDENT
                    payroll [key] = 0.1 * (payroll [key] - 1000)
                DEDENT
                elif income in range(10001, 20201) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (payroll [key] - 10000)))
                DEDENT
                elif income in range(20201, 30751) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (payroll [key] - 20200)))
                DEDENT
                elif income in range(30751, 50001) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (payroll [key] - 30750)))
                DEDENT
                elif income > 50000 :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (payroll [key] - 50000)))
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return payroll
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(d) :
INDENT
    d1 = {}
    income = 0
    """cheking for Key pairs"""
    while True :
    INDENT
        try :
        INDENT
            d1 = d.keys()
            for keys in d.keys() :
            INDENT
                income = d [keys]
                if (income > = 0) and (income < = 1000) :
                INDENT
                    tax = (0 * income)
                    d [keys] = tax
                DEDENT
                elif (income > 1000) and (income < = 10000) :
                INDENT
                    tax = (0.1 * (income - 1000))
                    d [keys] = tax
                DEDENT
                elif (income > 10000) and (income < = 20200) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
                    d [keys] = tax
                DEDENT
                elif (income > 20200) and (income < = 30750) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
                    d [keys] = tax
                DEDENT
                elif (income > 30750) and (income < = 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
                    d [keys] = tax
                DEDENT
                elif (income > 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
                    d [keys] = tax
                    """updating d1 dictionary"""
                    d [keys] = tax
                DEDENT
                return d1
                break
            DEDENT
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The input provided is not A dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39313120_1_24
39240884_42536719_1_42
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(payroll) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            for key in payroll.keys() :
            INDENT
                income = payroll [key]
                if income < = 1000 or income < 0 :
                INDENT
                    payroll [key] = 0
                DEDENT
                elif income in range(1001, 10001) :
                INDENT
                    payroll [key] = 0.1 * (payroll [key] - 1000)
                DEDENT
                elif income in range(10001, 20201) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (payroll [key] - 10000)))
                DEDENT
                elif income in range(20201, 30751) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (payroll [key] - 20200)))
                DEDENT
                elif income in range(30751, 50001) :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (payroll [key] - 30750)))
                DEDENT
                elif income > 50000 :
                INDENT
                    payroll [key] = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (payroll [key] - 50000)))
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            return payroll
            break
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The provided input is not a dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(taxpayer) :
INDENT
    if taxpayer == {} : return {}
    try :
    INDENT
        isinstance(taxpayer, dict)
        output = {}
        for k in taxpayer.keys() :
        INDENT
            try :
            INDENT
                isinstance(taxpayer [k], int)
                payer = k
                salary = taxpayer [k]
                ceilings = (1000, 10000, 20200, 30750, 50000)
                rates = {
                    1000 : {'rate' : 0, 'tax' : 0},
                    10000 : {'rate' : 0.1, 'tax' : 900},
                    20200 : {'rate' : 0.15, 'tax' : 1530},
                    30750 : {'rate' : 0.2, 'tax' : 2110.0},
                    50000 : {'rate' : 0.25, 'tax' : 4812.5}}
                tax = ceiling = tax_on_remnant = 0
                if salary > 50000 :
                INDENT
                    excess = salary - 50000
                    tax_on_remnant = excess * 0.3
                    ceiling = 50000
                    blocks = ceilings [: ceilings.index(ceiling) + 1]
                DEDENT
                else :
                INDENT
                    for k in ceilings :
                    INDENT
                        if salary < = k :
                        INDENT
                            ceiling = k
                            break
                        DEDENT
                    DEDENT
                    floor = ceilings [ceilings.index(ceiling) - 1]
                    remnant = salary - floor
                    tax_on_remnant = remnant * rates [ceiling] ['rate']
                    blocks = ceilings [: ceilings.index(ceiling)]
                DEDENT
                for block in blocks :
                INDENT
                    tax += rates [block] ['tax']
                DEDENT
                tax = tax + tax_on_remnant
                output [payer] = tax
            DEDENT
            except (TypeError) :
            INDENT
                raise ValueError('Allow only numeric input')
            DEDENT
        DEDENT
        return output
    DEDENT
    except (AttributeError, TypeError) :
    INDENT
        raise ValueError('The provided input is not a dictionary')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39240884_39889225_1_36
39240884_42536719_1_42
Title: An Income Tax program in Python 
----------------------------------------

def calculate_tax(d) :
INDENT
    d1 = {}
    income = 0
    """cheking for Key pairs"""
    while True :
    INDENT
        try :
        INDENT
            d1 = d.keys()
            for keys in d.keys() :
            INDENT
                income = d [keys]
                if (income > = 0) and (income < = 1000) :
                INDENT
                    tax = (0 * income)
                    d [keys] = tax
                DEDENT
                elif (income > 1000) and (income < = 10000) :
                INDENT
                    tax = (0.1 * (income - 1000))
                    d [keys] = tax
                DEDENT
                elif (income > 10000) and (income < = 20200) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (income - 10000)))
                    d [keys] = tax
                DEDENT
                elif (income > 20200) and (income < = 30750) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (income - 20200)))
                    d [keys] = tax
                DEDENT
                elif (income > 30750) and (income < = 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (income - 30750)))
                    d [keys] = tax
                DEDENT
                elif (income > 50000) :
                INDENT
                    tax = ((0.1 * (10000 - 1000)) + (0.15 * (20200 - 10000)) + (0.2 * (30750 - 20200)) + (0.25 * (50000 - 30750)) + (0.3 * (income - 50000)))
                    d [keys] = tax
                    """updating d1 dictionary"""
                    d [keys] = tax
                DEDENT
                return d1
                break
            DEDENT
        DEDENT
        except (AttributeError, TypeError) :
        INDENT
            raise ValueError('The input provided is not A dictionary')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculate_tax(taxpayer) :
INDENT
    if taxpayer == {} : return {}
    try :
    INDENT
        isinstance(taxpayer, dict)
        output = {}
        for k in taxpayer.keys() :
        INDENT
            try :
            INDENT
                isinstance(taxpayer [k], int)
                payer = k
                salary = taxpayer [k]
                ceilings = (1000, 10000, 20200, 30750, 50000)
                rates = {
                    1000 : {'rate' : 0, 'tax' : 0},
                    10000 : {'rate' : 0.1, 'tax' : 900},
                    20200 : {'rate' : 0.15, 'tax' : 1530},
                    30750 : {'rate' : 0.2, 'tax' : 2110.0},
                    50000 : {'rate' : 0.25, 'tax' : 4812.5}}
                tax = ceiling = tax_on_remnant = 0
                if salary > 50000 :
                INDENT
                    excess = salary - 50000
                    tax_on_remnant = excess * 0.3
                    ceiling = 50000
                    blocks = ceilings [: ceilings.index(ceiling) + 1]
                DEDENT
                else :
                INDENT
                    for k in ceilings :
                    INDENT
                        if salary < = k :
                        INDENT
                            ceiling = k
                            break
                        DEDENT
                    DEDENT
                    floor = ceilings [ceilings.index(ceiling) - 1]
                    remnant = salary - floor
                    tax_on_remnant = remnant * rates [ceiling] ['rate']
                    blocks = ceilings [: ceilings.index(ceiling)]
                DEDENT
                for block in blocks :
                INDENT
                    tax += rates [block] ['tax']
                DEDENT
                tax = tax + tax_on_remnant
                output [payer] = tax
            DEDENT
            except (TypeError) :
            INDENT
                raise ValueError('Allow only numeric input')
            DEDENT
        DEDENT
        return output
    DEDENT
    except (AttributeError, TypeError) :
    INDENT
        raise ValueError('The provided input is not a dictionary')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39245032_39245566_1_13
39245032_39262531_1_10
Title: Python: Generic/Templated getters 
----------------------------------------

def get_user(self, user_id = 0, username = '', role = '', company = '') :
INDENT
    if user_id :
    INDENT
        stmt = self.users.select().where(self.users.c.user_id == user_id)
        return self.connection.execute(stmt)
    DEDENT
    elif username :
    INDENT
        stmt = self.users.select().where(self.users.c.username == username)
        return self.connection.execute(stmt)
    DEDENT
    elif role and company :
    INDENT
        stmt = self.users.select().where(self.users.c.role == role).where(self.users.c.company == company)
        return self.connection.execute(stmt)
    DEDENT
    else :
    INDENT
        print ('Not adequate information given. Please enter "ID" or "USERNAME", or "ROLE"&"COMPANY"')
        return
    DEDENT
DEDENT
----------------------------------------

def get_user(self, ** kwargs) :
INDENT
    stmt = self.users.select()

    for field, value in kwargs.items() :
    INDENT
        stmt = stmt.where(getattr(self.users.c, field) == value)
    DEDENT
    return self.connection.execute(stmt)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39249704_39268045_11_17
39249704_39359007_9_15
Title: Tensorflow : ValueError Duplicate feature column key found for column 
----------------------------------------

def monkey_embedding_column(sparse_id_column,
dimension,
combiner = "mean",
initializer = None,
ckpt_to_load_from = None,
tensor_name_in_ckpt = None) :
INDENT
    return _MonkeyEmbeddingColumn(sparse_id_column, dimension, combiner, initializer, ckpt_to_load_from, tensor_name_in_ckpt)
DEDENT
----------------------------------------

def monkey_embedding_column(sparse_id_column,
dimension,
combiner = "mean",
initializer = None,
ckpt_to_load_from = None,
tensor_name_in_ckpt = None) :
INDENT
    return _MonkeyEmbeddingColumn(sparse_id_column, dimension)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39255523_39255636_1_13
39255523_39255678_1_11
Title: How to determine the dimensions of a mix of lists and arrays? 
----------------------------------------

def dimens(x) :
INDENT
    s = shape(x)
    if len(s) == 0 :
    INDENT
        return 0
    DEDENT
    s2 = shape(x [0])
    if len(s2) == 0 :
    INDENT
        return 1
    DEDENT
    else :
    INDENT
        if len(s2) == 1 :
        INDENT
            if len(shape(s2 [0])) == 0 :
            INDENT
                return 2
            DEDENT
        DEDENT
        return 3
    DEDENT
DEDENT
----------------------------------------

def dimens(l) :
INDENT
    try :
    INDENT
        size = len(l)
    DEDENT
    except TypeError :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        if size :
        INDENT
            return 1 + max(map(dimens, l))
        DEDENT
        else :
        INDENT
            return 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39256233_39256531_1_18
39256233_39256799_4_23
Title: User login read from file failing compared to user input 
----------------------------------------

def user_login() :
INDENT
    with open('username.txt', 'a+') as f :
    INDENT
        if f.readline() is "" :
        INDENT
            username = raw_input("First login, enter a username to use: ")
            f.seek(0)
            f.write(username)
        DEDENT
        else :
        INDENT
            login_id = raw_input("Enter username: ")
            f.seek(0)
            if login_id == f.readline() :
            INDENT
                return True
            DEDENT
            else :
            INDENT
                print "Invalid username."
                return False

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def user_login() :
INDENT
    fname = 'username.txt'
    """ Login and create a username, maybe """
    if os.path.getsize(fname) == 0 :
    INDENT
        with open(fname, 'w') as f :
        INDENT
            username = raw_input("First login, enter a username to use: ")
            f.write(username)
            return True
        DEDENT
    DEDENT
    else :
    INDENT
        with open(fname, 'r') as f :
        INDENT
            login_id = raw_input("Enter username: ")
            if login_id == f.readline().rstrip() :
            INDENT
                return True
            DEDENT
            else :
            INDENT
                print >> sys.stderr, "Invalid username."
                return False

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39257319_39318073_43_56
39257319_39318073_6_61
Title: How can i insert a scrollbar in my Tk window? 
----------------------------------------

def __init__(self) :
INDENT
    main_s.update()
    i = Label(main_s, text = "**********")
    i.pack()
    self.rotation = Entry(main_s)
    self.rotation.pack()
    i1 = Label(main_s, text = "*************")
    i1.pack()
    self.xshift = Entry(main_s)
    self.xshift.pack()
    i2 = Label(main_s, text = "**************")
    i2.pack()
    self.yshift = Entry(main_s)
    self.yshift.pack()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    def proceed() :
    INDENT
        main_s.update()
        main_s.config(bg = "yellow")
        Label(main_s, text = "Choose your curve", fg = "red", font = ("arial", 20)).pack()
        var = IntVar()
        r1 = Radiobutton(main_s, text = "Circle", variable = var, value = 1, command = curves)
        r2 = Radiobutton(main_s, text = "Parabola", variable = var, value = 2, command = curves)
        r3 = Radiobutton(main_s, text = "Ellipse", variable = var, value = 3, command = curves)
        r4 = Radiobutton(main_s, text = "Line", variable = var, value = 4, command = curves)
        r5 = Radiobutton(main_s, text = "Hyperbola", variable = var, value = 5, command = curves)
        r1.pack()
        r2.pack()
        r3.pack()
        r4.pack()
        r5.pack()

    DEDENT
    self.frame = Frame(main_s)
    self.scr = Canvas(self.frame, width = 1000, height = 200, scrollregion = (0, 0, 0, 500))
    self.bar = Scrollbar(self.frame, orient = "vertical")
    self.scr.grid(row = 0, column = 1)
    self.bar.grid(row = 0, column = 0, sticky = "ns")
    self.scr.config(yscrollcommand = self.bar.set)
    self.bar.config(command = self.scr.yview)
    self.frame.pack()

    self.scr.create_image(0, 0, image = fundo, anchor = 'nw')
    main_s.config(bg = "orange")
    main_s.title("*********")
    btn = Button(main_s, text = "*********", fg = "orange", command = proceed)
    btn.pack()
    def curves() :
    INDENT
        class Curves :
        INDENT
            def __init__(self) :
            INDENT
                main_s.update()
                i = Label(main_s, text = "**********")
                i.pack()
                self.rotation = Entry(main_s)
                self.rotation.pack()
                i1 = Label(main_s, text = "*************")
                i1.pack()
                self.xshift = Entry(main_s)
                self.xshift.pack()
                i2 = Label(main_s, text = "**************")
                i2.pack()
                self.yshift = Entry(main_s)
                self.yshift.pack()
            DEDENT
        DEDENT
        t = Curves()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3927166_3927345_23_36
3927166_3927410_6_13
Title: Automatically expiring variable 
----------------------------------------

def __getitem__(self, key) :
INDENT
    c = self.cache [key]
    n = datetime.now()
    if (n - c ['timestamp']) < c ['expireTime'] or not self.processExpires :
    INDENT
        return c ['data']
    DEDENT
    del self.cache [key]

    if self.dbg :
    INDENT
        print "DataCache: Key %s expired" % repr(key)
    DEDENT
    raise KeyExpiredError(key)
DEDENT
----------------------------------------

def __getitem__(self, index) :
INDENT
    t = time.time()
    print t - self.created
    if t - self.created > self.expires_time :
    INDENT
        self.created += self.expires_time
        self.pop(index)
        self.__getitem__(index)
    DEDENT
    return list.__getitem__(self, index)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39298794_39298899_10_23
39298794_39298908_11_22
Title: Selenium Python: What are the errors in my code? 
----------------------------------------

def logindetails(self, username, password) :
INDENT
    driver = self.driver
    driver.maximize_window()
    driver.get("https://miclaro.claro.com.ar/")
    driver.implicitly_wait(30)
    driver.find_element_by_id("_58_login_movil").send_keys(username)
    driver.find_element_by_id("_58_password_movil").send_keys(password)
    driver.find_element_by_id("btn-home-login").click()

DEDENT
----------------------------------------

def logindetails(self, username, password) :
INDENT
    self.driver.maximize_window()
    self.driver.get("https://miclaro.claro.com.ar/")
    self.driver.implicitly_wait(30)
    self.driver.find_element_by_id("_58_login_movil").send_keys(username)
    self.driver.find_element_by_id("_58_password_movil").send_keys(password)
    self.driver.find_element_by_id("btn-home-login").click()
DEDENT
----------------------------------------
