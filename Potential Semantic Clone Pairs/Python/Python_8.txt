$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17465110_17465384_1_17
17465110_17465822_1_14
Title: "Whatâ€™s the most Pythonic way of handling different mutually-exclusive function inputs?" 
----------------------------------------

def relations(** kwargs) :
INDENT
    if 'a' in kwargs :
    INDENT
        a = kwargs ['a']
    DEDENT
    elif 'b' in kwargs :
    INDENT
        a = kwargs ['b'] - 1
    DEDENT
    elif 'c' in kwargs :
    INDENT
        a = kwargs ['c'] * 2
    DEDENT
    elif 'd' in kwargs :
    INDENT
        a = kwargs ['d'] ** 2
    DEDENT
    else :
    INDENT
        raise TypeError('missing an argument')
    DEDENT
    b = 1 + a
    c = 0.5 * a
    d = a ** 0.5
    return a, b, c, d
DEDENT
----------------------------------------

def relations(** kwargs) :
INDENT
    if len(kwargs) ! = 1 or not set('abcd').intersection(kwargs) :
    INDENT
        raise ValueError('Invalid parameters')
    DEDENT
    vtype, v = kwargs.popitem()
    functions = {
        'a' : lambda x : x, 'b' : lambda x : x - 1,
        'c' : lambda x : x * 2, 'd' : lambda x : x ** 2}
    a = functions [vtype](v)
    b = 1 + a
    c = 0.5 * a
    d = a ** 0.5
    return a, b, c, d
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17483688_17525026_17_44
17483688_17525026_6_13
Title: In Tkinter How do I make a child window that closes the parent but shows all the widgets in the child? 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, * args, ** kwargs)

    self.current = None
    self.screens = []

    container = tk.Frame(self)
    toolbar = tk.Frame(self)
    toolbar.pack(side = "top", fill = "x")
    container.pack(side = "bottom", fill = "both", expand = True)

    for i in range(10) :
    INDENT
        screen = Screen(container, "screen %s" % i)
        screen.place(x = 0, y = 0, anchor = "nw", relwidth = 1.0, relheight = 1.0)
        self.screens.append(screen)

    DEDENT
    next = tk.Button(toolbar, text = "next", command = self.next)
    next.pack(side = "right")

    self.show(0)
DEDENT
----------------------------------------

def __init__(self, parent, label) :
INDENT
    tk.Frame.__init__(self, parent)
    l = tk.Label(self, text = label)
    self.entry = tk.Entry(self)
    l.pack(side = "top", fill = "x")
    self.entry.pack(side = "top", fill = "x", padx = 20)
    self.entry.insert(0, "this is the entry for " + label)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17499592_29122156_16_21
17499592_49532219_8_30
Title: "Learn Python the Hard Way Exercise 48" 
----------------------------------------

def scan(words) :
INDENT
    words = words.split()
    to_return = []
    for i in words :
    INDENT
        to_return.append(check(i))
    DEDENT
    return to_return
DEDENT
----------------------------------------

def scan(sentence) :
INDENT
    results = []
    words = sentence.split()
    for word in words :
    INDENT
        found = False
        for category in vocabulary :
        INDENT
            if word.lower() in category [0] :
            INDENT
                results.append((category [1], word))
                found = True
            DEDENT
            else :
            INDENT
                pass
            DEDENT
        DEDENT
        if found is False and isInt_str(word) is True :
        INDENT
            results.append(('number', int(word)))
        DEDENT
        elif found is False and isInt_str(word) is False :
        INDENT
            results.append(('error', word))
        DEDENT
        elif found is True :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            print ("I'm terribly sorry, but something you entered is neither a word nor a number.")
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17505010_17505040_4_13
17505010_17505470_4_16
Title: Copying lists in python 
----------------------------------------

def new_function(value) :
INDENT
    global list_one
    for i in range(value) :
    INDENT
        list_copy = list_one [:]
        blank.append(list_copy)
        x = random.choice(blank [i])
        y = blank [i].index(x)
        blank [i] [y] = x + 1
        list_one = list_copy
    DEDENT
    return blank
DEDENT
----------------------------------------

def new_function(value) :
INDENT
    blank = []
    blank.append(list_one)
    new_list = []
    for i in range(value) :
    INDENT
        new_list = new_list [:] if new_list else list_one [:]
        new_list [choice(new_list)] += 1
        blank.append(new_list)
    DEDENT
    return blank
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17518085_17525274_1_78
17518085_17528230_16_63
Title: Python Real Time Plotting Memory Leak 
----------------------------------------

def main() :
INDENT
    fig = plt.figure()
    ax1 = fig.add_subplot(1, 1, 1, axisbg = 'black')
    ax1.set_title('Blip Current vs. Time', color = 'blue')
    ax1.set_xlabel('Time (hrs)', color = 'blue')
    ax1.set_ylabel('Blip Current', color = 'blue')
    for t in ax1.xaxis.get_ticklines() : t.set_color('yellow')
    for t in ax1.xaxis.get_ticklabels() : t.set_color('yellow')
    for t in ax1.yaxis.get_ticklines() : t.set_color('white')
    for t in ax1.yaxis.get_ticklabels() : t.set_color('purple')
    plt.ion()
    plt.show(False)
    i = 0

    times = []
    hr = float(time.strftime('%H'))
    mins = time.strftime('%M')
    secs = time.strftime('%S')
    secadj = float(secs) / 3600
    minadj = float(mins) / 60
    currenttime = float(hr + minadj + secadj)
    times.append(currenttime)
    if currenttime > = 0 and currenttime < 0.22 :
    INDENT
        xmin = 0
        xmax = currenttime +.01
    DEDENT
    else :
    INDENT
        xmin = currenttime -.22
        xmax = currenttime +.01

    DEDENT
    blipcur = []
    blip = Popen('adoIf -vo -6 lxf.blip_b3 dataBarM', shell = True, stdout = PIPE).communicate() [0]
    try :
    INDENT
        blip = float(blip)
    DEDENT
    except ValueError :
    INDENT
        blip = 0.0
    DEDENT
    blipcur.append(blip)

    line1, = ax1.plot(times, blipcur, 'g-', marker = 'o')

    while True :
    INDENT
        hr = float(time.strftime('%H'))
        mins = time.strftime('%M')
        secs = time.strftime('%S')
        secadj = float(secs) / 3600
        minadj = float(mins) / 60
        currenttime = float(hr + minadj + secadj)
        times.append(currenttime)
        if currenttime > = 0 and currenttime < 0.22 :
        INDENT
            xmin = 0
            xmax = currenttime +.01
        DEDENT
        else :
        INDENT
            xmin = currenttime -.22
            xmax = currenttime +.01
        DEDENT
        blip = Popen('adoIf -vo -6 lxf.blip_b3 dataBarM', shell = True, stdout = PIPE).communicate() [0]
        try :
        INDENT
            blip = float(blip)
        DEDENT
        except ValueError :
        INDENT
            blip = 0.0
        DEDENT
        blipcur.append(blip)
        if i > 285 :
        INDENT
            del blipcur [0]
            del times [0]
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
        line1.set_xdata(times)
        plt.axis([xmin, xmax, - 2, 50])
        line1.set_ydata(blipcur)
        fig.canvas.draw()
        time.sleep(2.6)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    def animate(data, pathcol) :
    INDENT
        xvals, yvals, colors = data
        assert len(xvals) < = 300
        if len(xvals) > 1 :
        INDENT
            ax.set_xlim(xvals.min(), xvals.max())
        DEDENT
        pathcol.set_array(colors)
        pathcol.set_offsets(np.column_stack([xvals, yvals]))
    DEDENT
    def step() :
    INDENT
        xvals = collections.deque([], maxlen = N)
        yvals = collections.deque([], maxlen = N)
        colors = collections.deque([], maxlen = N)
        fudge = 0
        while True :
        INDENT
            blip = np.random.random() * 10
            xvals.append(currenttime() + fudge)
            yvals.append(blip)
            colors.append(1 if blip > 6 else 0)
            yield np.asarray(xvals), np.asarray(yvals), np.asarray(colors)
            fudge += 0.0001

        DEDENT
    DEDENT
    N = 300
    fig = plt.figure()
    ax = fig.add_subplot(
        1, 1, 1, axisbg = 'black')
    ax.set_title('Blip Current vs. Time', color = 'blue')
    ax.set_xlabel('Time (hrs)', color = 'blue')
    ax.set_ylabel('Blip Current', color = 'blue')
    for t in ax.xaxis.get_ticklines() :
    INDENT
        t.set_color('yellow')
    DEDENT
    for t in ax.xaxis.get_ticklabels() :
    INDENT
        t.set_color('yellow')
    DEDENT
    for t in ax.yaxis.get_ticklines() :
    INDENT
        t.set_color('white')
    DEDENT
    for t in ax.yaxis.get_ticklabels() :
    INDENT
        t.set_color('purple')
    DEDENT
    pathcol = ax.scatter([0, 24], [0, 10],
        c = [0, 1], s = 100,
        cmap = plt.get_cmap('RdYlGn'), vmin = 0, vmax = 1)
    ani = animation.FuncAnimation(
        fig, animate, step, interval = 20, fargs = (pathcol,))
    plt.show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17536842_17538656_5_17
17536842_17552883_12_22
Title: Python photo animation trouble 
----------------------------------------

def __init__(self, master) :
INDENT
    self.xRes = 500
    self.yRes = 500
    master.geometry(str(self.xRes) + "x" + str(self.yRes))
    myImage = ImageTk.PhotoImage(Image.open("image.jpg"))
    self.photoFrame = Label(master, image = myImage, width = 300, height = 300)
    self.photoFrame.place(x = - 310, y = 0)
    self.photoFrame.image = myImage
    self.photoFrame.focus_set()
    self.photoFrame.bind("<Left>", self.animate)

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, * args, ** kwargs)
    self.canvas = tk.Canvas(self)
    self.canvas.pack(side = "bottom", fill = "both", expand = True)
    self.image = tk.PhotoImage(data = imagedata)
    image_id = self.canvas.create_image(0, 0, anchor = "nw", image = self.image)
    self.move_to_center(image_id)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17564804_17565516_10_21
17564804_17565819_48_73
Title: How to wait until only the first thread is finished in Python 
----------------------------------------

def main() :
INDENT
    q = queue.Queue()
    threads = [threading.Thread(target = func, args = (i, q)) for i in range(5)]
    for th in threads :
    INDENT
        th.daemon = True
        th.start()
    DEDENT
    result1 = q.get()
    result2 = q.get()
    print ("Second result: {}".format(result2))
DEDENT
----------------------------------------

def main() :
INDENT
    print 'testing this stuff'
    def func(i) :
    INDENT
        import time, random
        sleeptime = (random.random() * 2) + 1
        print 'thread', i, 'starting - sleep for', sleeptime
        time.sleep(sleeptime)
        print 'thread', i, 'finished'
    DEDENT
    threads = [MWThread(target = func, args = (i,)) for i in range(3)]
    for th in threads :
    INDENT
        th.start()
    DEDENT
    i = 0
    while i < 3 :
    INDENT
        print 'main: wait up to .5 sec'
        th = wait_for_thread(.5)
        if th :
        INDENT
            print 'main: got', th
            th.join()
            i += 1
        DEDENT
        else :
        INDENT
            print 'main: timeout'
        DEDENT
    DEDENT
    print 'I think I collected them all'
    print 'result of wait_for_thread():'
    print wait_for_thread()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1756992_1757073_4_10
1756992_1757104_6_11
Title: removing the oldest element from a dictionary in python 
----------------------------------------

def add(key, value) :
INDENT
    print len(dict)
    if len(dict) == MAXSIZE :
    INDENT
        old = history.pop(0)
        del dict [old]
    DEDENT
    history.append(key)
    dict [key] = value
DEDENT
----------------------------------------

def add(self, key, value) :
INDENT
    self.data [key] = value
    self.lru.append(key)
    if len(self.lru) > self.maxcount :
    INDENT
        dead = self.lru.pop(0)
        del (self.data [dead])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1756992_1757073_4_10
1756992_1757113_4_10
Title: removing the oldest element from a dictionary in python 
----------------------------------------

def add(key, value) :
INDENT
    print len(dict)
    if len(dict) == MAXSIZE :
    INDENT
        old = history.pop(0)
        del dict [old]
    DEDENT
    history.append(key)
    dict [key] = value
DEDENT
----------------------------------------

def add(key, value) :
INDENT
    stack.append((key, value))
    if len(stack) > MAXSIZE :
    INDENT
        stack.pop(0)
    DEDENT
    print stack
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1756992_1757104_6_11
1756992_1757113_4_10
Title: removing the oldest element from a dictionary in python 
----------------------------------------

def add(self, key, value) :
INDENT
    self.data [key] = value
    self.lru.append(key)
    if len(self.lru) > self.maxcount :
    INDENT
        dead = self.lru.pop(0)
        del (self.data [dead])
    DEDENT
DEDENT
----------------------------------------

def add(key, value) :
INDENT
    stack.append((key, value))
    if len(stack) > MAXSIZE :
    INDENT
        stack.pop(0)
    DEDENT
    print stack
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17580218_17581364_7_16
17580218_47813310_8_14
Title: Changing the options of a OptionMenu when clicking a Button 
----------------------------------------

def refresh() :
INDENT
    var.set('')
    network_select ['menu'].delete(0, 'end')

    new_choices = ('one', 'two', 'three')
    for choice in new_choices :
    INDENT
        network_select ['menu'].add_command(label = choice, command = tk._setit(var, choice))
    DEDENT
DEDENT
----------------------------------------

def refresh(l) :
INDENT
    var.set('')
    menu.delete(0, 'end')
    for i in l :
    INDENT
        menu.add_command(label = i, command = lambda x = i : show(x))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17590783_17595370_42_49
17590783_17628921_6_75
Title: How to scrape more than first instance of triple-nested list of links in Python? 
----------------------------------------

def scrape_table(root) :
INDENT
    links = root.cssselect("div.link-wrapper a")
    for link in links :
    INDENT
        print link.text_content()
        linkurl = link.attrib.get("href")
        print linkurl
        scrape_page('http://www.italaw.com' + linkurl)
    DEDENT
DEDENT
----------------------------------------

def scrape_table(root) :
INDENT
    rows = root.cssselect("h2")
    counter = 0
    for row in rows :
    INDENT
        table_cells = row.cssselect("h2 a")
        for cell in table_cells :
        INDENT
            table_cellsurls = table_cells [0].cssselect("a")
            caselinkurl = urllib.urlopen('http://www.italaw.com/' + table_cellsurls [0].attrib.get('href')).read()
            caseroots = lxml.html.fromstring(caselinkurl)
            pars = caseroots.cssselect("span.'case-doc-details' a")
            record = {}
            if len(pars) == 0 :
            INDENT
                record ['DetailsURL'] = "None"
                record ['Count'] = counter
                print record, '------------'
                scraperwiki.sqlite.save(['Count'], record)
                counter += 1
            DEDENT
            else :
            INDENT
                for i in range(0, len(pars)) :
                INDENT
                    record ['Count'] = counter
                    caselinkurl2 = urllib.urlopen('http://www.italaw.com/' + pars [i].attrib.get('href')).read()
                    caseroots2 = lxml.html.fromstring(caselinkurl2)
                    record ['DetailsURL'] = pars [i].attrib.get('href')
                    title = caseroots2.cssselect("h2")
                    record ['Title'] = title [1].text_content()
                    rules = caseroots2.cssselect("div.'field-name-field-arbitration-rules'")
                    if len(rules) == 0 :
                    INDENT
                        record ['Rules'] = "None"
                    DEDENT
                    else :
                    INDENT
                        record ['Rules'] = rules [0].text_content()
                    DEDENT
                    treaty = caseroots2.cssselect("div.'field-name-field-case-treaties'")
                    if len(treaty) == 0 :
                    INDENT
                        record ['Treaty'] = "None"
                    DEDENT
                    else :
                    INDENT
                        record ['Treaty'] = treaty [0].text_content()
                    DEDENT
                    pars2 = caseroots2.cssselect("div.'field-name-field-case-document-date'")
                    if len(pars2) == 0 :
                    INDENT
                        record ['Doc Date'] = "None"
                    DEDENT
                    else :
                    INDENT
                        record ['Doc Date'] = pars2 [0].text_content()
                    DEDENT
                    pars3 = caseroots2.cssselect("div.'field-name-field-case-doc-file' span.'file' a")
                    if len(pars3) == 0 :
                    INDENT
                        record ['Doc Type Link'] = "None"
                        record ['Doc Type'] = "None"
                    DEDENT
                    else :
                    INDENT
                        record ['Doc Type Link'] = pars3 [0].attrib.get('href')
                        record ['Doc Type'] = pars3 [0].text_content()
                    DEDENT
                    pars4 = caseroots2.cssselect("div.'field-name-field-arbitrator-claimant'")
                    if len(pars4) == 0 :
                    INDENT
                        record ['Claimant Nominee'] = "None"
                    DEDENT
                    else :
                    INDENT
                        record ['Claimant Nominee'] = pars4 [0].text_content()
                    DEDENT
                    pars5 = caseroots2.cssselect("div.'field-name-field-arbitrator-respondent'")
                    if len(pars5) == 0 :
                    INDENT
                        record ['Respondent Nominee'] = "None"
                    DEDENT
                    else :
                    INDENT
                        record ['Respondent Nominee'] = pars5 [0].text_content()
                    DEDENT
                    pars6 = caseroots2.cssselect("div.'field-name-field-arbitrator-chair'")
                    if len(pars6) == 0 :
                    INDENT
                        record ['President'] = "None"
                    DEDENT
                    else :
                    INDENT
                        record ['President'] = pars6 [0].text_content()
                    DEDENT
                    print record, '------------'
                    scraperwiki.sqlite.save(['Count'], record)
                    counter += 1
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17605898_17606051_10_15
17605898_17606526_4_14
Title: Sudoku Checker in Python 
----------------------------------------

def check_sudoku(grid) :
INDENT
    if len(grid) ! = 9 : return False
    if sum(len(row) == 9 for row in grid) ! = 9 : return False
    for row in grid :
    INDENT
        if not check_dups(row) : return False
    DEDENT
    return True
DEDENT
----------------------------------------

def check_sudoku(grid) :
INDENT
    bad_rows = [row for row in grid if not sudoku_ok(row)]
    grid = list(zip(* grid))
    bad_cols = [col for col in grid if not sudoku_ok(col)]
    squares = []
    for i in range(9, step = 3) :
    INDENT
        for j in range(9, step = 3) :
        INDENT
            square = list(itertools.chain(row [j : j + 3] for row in grid [i : i + 3]))
            squares.append(square)
        DEDENT
    DEDENT
    bad_squares = [square for square in squares if not sudoku_ok(square)]
    return not (bad_rows or bad_cols or bad_squares)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17605898_17606051_10_15
17605898_33704920_1_26
Title: Sudoku Checker in Python 
----------------------------------------

def check_sudoku(grid) :
INDENT
    if len(grid) ! = 9 : return False
    if sum(len(row) == 9 for row in grid) ! = 9 : return False
    for row in grid :
    INDENT
        if not check_dups(row) : return False
    DEDENT
    return True
DEDENT
----------------------------------------

def check_sudoku(grid) :
INDENT
    for row in range(len(grid)) :
    INDENT
        for col in range(len(grid)) :
        INDENT
            if grid [row] [col] < 1 or type(grid [row] [col]) is not type(1) :
            INDENT
                return False

            DEDENT
            elif grid [row] [col] > len(grid) :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    for row in grid :
    INDENT
        if sorted(list(set(row))) ! = sorted(row) :
        INDENT
            return False
        DEDENT
    DEDENT
    cols = []
    for col in range(len(grid)) :
    INDENT
        for row in grid :
        INDENT
            cols += [row [col]]

        DEDENT
        if sorted(list(set(cols))) ! = sorted(cols) :
        INDENT
            return False
        DEDENT
        cols = []
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17605898_17606526_4_14
17605898_33704920_1_26
Title: Sudoku Checker in Python 
----------------------------------------

def check_sudoku(grid) :
INDENT
    bad_rows = [row for row in grid if not sudoku_ok(row)]
    grid = list(zip(* grid))
    bad_cols = [col for col in grid if not sudoku_ok(col)]
    squares = []
    for i in range(9, step = 3) :
    INDENT
        for j in range(9, step = 3) :
        INDENT
            square = list(itertools.chain(row [j : j + 3] for row in grid [i : i + 3]))
            squares.append(square)
        DEDENT
    DEDENT
    bad_squares = [square for square in squares if not sudoku_ok(square)]
    return not (bad_rows or bad_cols or bad_squares)
DEDENT
----------------------------------------

def check_sudoku(grid) :
INDENT
    for row in range(len(grid)) :
    INDENT
        for col in range(len(grid)) :
        INDENT
            if grid [row] [col] < 1 or type(grid [row] [col]) is not type(1) :
            INDENT
                return False

            DEDENT
            elif grid [row] [col] > len(grid) :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    for row in grid :
    INDENT
        if sorted(list(set(row))) ! = sorted(row) :
        INDENT
            return False
        DEDENT
    DEDENT
    cols = []
    for col in range(len(grid)) :
    INDENT
        for row in grid :
        INDENT
            cols += [row [col]]

        DEDENT
        if sorted(list(set(cols))) ! = sorted(cols) :
        INDENT
            return False
        DEDENT
        cols = []
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17628182_17629554_43_60
17628182_17638712_9_18
Title: telnet Connection closed when I use yield in diesel 
----------------------------------------

def chat_server(addr) :
INDENT
    server_recv = socket_thread()
    my_nick = until_eol().strip()
    data = []
    server_recv.start()
    while True :
    INDENT
        server_recv.event.wait()
        data = server_recv.readlines()
        if (data) :
        INDENT
            shouted_message = my_nick + ":" + data
            diesel.send(shouted_message)
        DEDENT
        server_recv.event.clear()
        my_message = until_eol()
        other_message = wait('chat_message')
        if my_message :
        INDENT
            fire('chat_message', (my_nick, my_message.strip()))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def chat_server(addr) :
INDENT
    my_nick = until_eol().strip()
    while True :
    INDENT
        evt, data = first(until_eol = True, waits = ['chat_message'])
        if evt == 'until_eol' :
        INDENT
            fire('chat_message', (my_nick, data.strip()))
        DEDENT
        else :
        INDENT
            nick, message = data
            send("<%s> %s\r\n" % (nick, message))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17628241_17634461_34_45
17628241_17634461_96_114
Title: How can i use gtk3 and opengl together? 
----------------------------------------

def __init__(self) :
INDENT
    self.add_attribute(GLX.GLX_RGBA, True)
    self.add_attribute(GLX.GLX_RED_SIZE, 1)
    self.add_attribute(GLX.GLX_GREEN_SIZE, 1)
    self.add_attribute(GLX.GLX_BLUE_SIZE, 1)
    self.add_attribute(GLX.GLX_DOUBLEBUFFER, 0)
    xvinfo = GLX.glXChooseVisual(self.xdisplay, self.display.get_default_screen(), self.get_attributes())
    configs = GLX.glXChooseFBConfig(self.xdisplay, 0, None, byref(c_int()))
    self.context = GLX.glXCreateContext(self.xdisplay, xvinfo, None, True)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.window = Gtk.Window()
    self.window.realize()
    self.window.resize(self.glwrap.width, self.glwrap.height)
    self.window.set_resizable(True)
    self.window.set_reallocate_redraws(True)
    self.window.set_title("GTK3 with opengl")
    self.window.connect('delete_event', Gtk.main_quit)
    self.window.connect('destroy', lambda quit : Gtk.main_quit())
    self.drawing_area = Gtk.DrawingArea()
    self.drawing_area.connect('configure_event', self.on_configure_event)
    self.drawing_area.connect('draw', self.on_draw)
    self.drawing_area.set_double_buffered(False)
    self.drawing_area.set_size_request(self.glwrap.width, self.glwrap.height)
    self.window.add(self.drawing_area)
    self.window.show_all()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17631031_17636747_11_33
17631031_17636747_41_54
Title: Example for Client socket that try to connect to the server for 2 seconds 
----------------------------------------

def run(self) :
INDENT
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.bind((self.TCP_IP, self.TCP_PORT))
    s.listen(1)
    conn, addr = s.accept()
    (ip, port) = addr
    sys.stdout.write("%s connection address: IP %s on Port %d\n" % (self.__class__.__name__, ip, port))
    data = True
    while data :
    INDENT

        data = conn.recv(self.BUFFER_SIZE)
        if data :
        INDENT
            sys.stdout.write("%s received data: %s\n" % (self.__class__.__name__, data))
            send_data = data.upper()
            sys.stdout.write("%s sending data: %s\n" % (self.__class__.__name__, send_data))
            conn.send(send_data)
        DEDENT
    DEDENT
    conn.close()
DEDENT
----------------------------------------

def run(self) :
INDENT
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(self.TIMEOUT)
    s.connect((self.TCP_IP, self.TCP_PORT))
    sys.stdout.write("%s sending data: %s\n" % (self.__class__.__name__, self.MESSAGE))
    s.send(self.MESSAGE)
    data = s.recv(self.BUFFER_SIZE)
    s.close()
    if data :
    INDENT
        sys.stdout.write("%s received data: %s\n" % (self.__class__.__name__, data))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1765848_16144379_1_17
1765848_3225671_3_18
Title: Remove a tag using BeautifulSoup but keep its contents 
----------------------------------------

def strip_tags(html, whitelist = []) :
INDENT
    soup = BeautifulSoup(html)
    for tag in soup.findAll(True) :
    INDENT
        if tag.name not in whitelist :
        INDENT
            tag.append(' ')
            tag.replaceWithChildren()
        DEDENT
    DEDENT
    result = unicode(soup)

    result = re.sub(' +', ' ', result)
    result = re.sub(r' (<[^>]*> )', r'\1', result)
    return result.strip()
DEDENT
----------------------------------------

def strip_tags(html, invalid_tags) :
INDENT
    soup = BeautifulSoup(html)
    for tag in soup.findAll(True) :
    INDENT
        if tag.name in invalid_tags :
        INDENT
            s = ""
            for c in tag.contents :
            INDENT
                if not isinstance(c, NavigableString) :
                INDENT
                    c = strip_tags(unicode(c), invalid_tags)
                DEDENT
                s += unicode(c)
            DEDENT
            tag.replaceWith(s)
        DEDENT
    DEDENT
    return soup
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17659974_17661351_1_11
17659974_17661354_7_17
Title: Having difficulty in implementing QuickSort 
----------------------------------------

def Partition(A, p, r) :
INDENT
    m = A [p]
    A [p], A [r] = A [r], A [p]
    i = p
    for j in range(p, r) :
    INDENT
        if A [j] < m :
        INDENT
            A [j], A [i] = A [i], A [j]
            i += 1
        DEDENT
    DEDENT
    A [r], A [i] = A [i], A [r]
    return i
DEDENT
----------------------------------------

def Partition(A, p, r) :
INDENT
    m = A [p]
    i = p + 1
    for j in range(p + 1, r) :
    INDENT
        if A [j] < m :
        INDENT
            A [j], A [i] = A [i], A [j]
        DEDENT
        i = i + 1
    DEDENT
    A [p], A [i - 1] = A [i - 1], A [p]
    return i - 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17665043_17665044_9_27
17665043_17665608_5_19
Title: How can I keep track of equivalent functions in different programming languages? 
----------------------------------------

def getCorrespondingValue(valueToRetrieve, valueCorrespondsTo, mainArray = correspondingFunctionDatabase, printMessages = False) :
INDENT
    i = 0
    correspondingValues = []
    while (i < len(mainArray)) :
    INDENT
        if (containsAll(containsAllOfThese = valueCorrespondsTo, containingArray = mainArray [i])) :
        INDENT
            if (printMessages == True) :
            INDENT
                print ("The elements of the array:\n", valueCorrespondsTo)
                print ("Are contained in the array:\n", str(mainArray [i]) + "\n")
            DEDENT
            j = 0
            while (j < len(mainArray [i])) :
            INDENT
                if (mainArray [i] [j] [0] == valueToRetrieve) :
                INDENT
                    print (mainArray [i] [j])
                    correspondingValues += [mainArray [i] [j] [1]]
                DEDENT
                j += 1
            DEDENT
        DEDENT
        i += 1
    DEDENT
    print ("The retrieved values for", valueToRetrieve, "from", valueCorrespondsTo, "are", correspondingValues)
    return correspondingValues
DEDENT
----------------------------------------

def getCorrespondingValue(lang, construct) :
INDENT
    ds = [d for d in cfDicts if lang in d and
        construct [0] in d and
        d [construct [0]] == construct [1]]
    if len(ds) == 0 :
    INDENT
        return None
    DEDENT
    else :
    INDENT
        assert len(ds) == 1, 'Multiple entries for' + str(construct)
        return ds [0] [lang]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1767910_1769267_5_10
1767910_20721559_11_18
Title: checksum udp calculation python 
----------------------------------------

def checksum(msg) :
INDENT
    s = 0
    for i in range(0, len(msg), 2) :
    INDENT
        w = ord(msg [i]) + (ord(msg [i + 1]) < < 8)
        s = carry_around_add(s, w)
    DEDENT
    return ~ s & 0xffff
DEDENT
----------------------------------------

def checksum(pkt) :
INDENT
    if len(pkt) % 2 == 1 :
    INDENT
        pkt += "\0"
    DEDENT
    s = sum(array.array("H", pkt))
    s = (s >> 16) + (s & 0xffff)
    s += s >> 16
    s = ~ s
    return (((s >> 8) & 0xff) | s < < 8) & 0xffff
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1767910_1769267_5_10
1767910_20721559_2_9
Title: checksum udp calculation python 
----------------------------------------

def checksum(msg) :
INDENT
    s = 0
    for i in range(0, len(msg), 2) :
    INDENT
        w = ord(msg [i]) + (ord(msg [i + 1]) < < 8)
        s = carry_around_add(s, w)
    DEDENT
    return ~ s & 0xffff
DEDENT
----------------------------------------

def checksum(pkt) :
INDENT
    if len(pkt) % 2 == 1 :
    INDENT
        pkt += "\0"
    DEDENT
    s = sum(array.array("H", pkt))
    s = (s >> 16) + (s & 0xffff)
    s += s >> 16
    s = ~ s
    return s & 0xffff
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17720099_18037281_2_7
17720099_18794958_18_26
Title: asyncore.dispatcher in python: when are the handle_closed and handle_read executed? 
----------------------------------------

def handle_read(self) :
INDENT
    data = self.recv(1024)
    if not data :
    INDENT
        return
    DEDENT
    print "Received:", data
DEDENT
----------------------------------------

def handle_read(self) :
INDENT
    buffer = str(self.recv(8))
    if buffer ! = '' : size = int(buffer)
    else : return
    data = self.recv(size)
    if data :
    INDENT
        self.DATA += data
        self.is_writable = True
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17720099_18794958_2_11
17720099_18794958_45_57
Title: asyncore.dispatcher in python: when are the handle_closed and handle_read executed? 
----------------------------------------

def __init__(self, conn_sock, client_address, server) :
INDENT
    self.SERVER = server
    self.CA = client_address
    self.DATA = ''
    self.out_buffer = ''
    self.BUFFER = 1024
    self.is_writable = False
    asyncore.dispatcher.__init__(self, conn_sock)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.HANDLER = Handler
    self.HOST = "localhost"
    self.PORT = 50007
    self.QUEUE = 5
    self.REUSE = False
    self.dispatch()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17748998_17749219_1_6
17748998_17749239_1_6
Title: passing variables between two python decorators 
----------------------------------------

def decobar(f) :
INDENT
    def wrap() :
    INDENT
        return f() + "bar"
    DEDENT
    wrap.decobar = True
    return wrap
DEDENT
----------------------------------------

def decobar(f) :
INDENT
    def wrap() :
    INDENT
        return f() + "bar"
    DEDENT
    wrap.decobar_applied = True
    return wrap
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17748998_17749219_7_11
17748998_17749239_7_13
Title: passing variables between two python decorators 
----------------------------------------

def decofu(f) :
INDENT
    def wrap() :
    INDENT
        print 'decobar!' if getattr(f, 'decobar') else 'not decobar'
        return f() + "fu"
    DEDENT
    return wrap
DEDENT
----------------------------------------

def decofu(f) :
INDENT
    def wrap() :
    INDENT
        if hasattr(f, 'decobar_applied') and f.decobar_applied :
        INDENT
            print decobar_present()
        DEDENT
        return f() + "fu"
    DEDENT
    return wrap
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17748998_17749219_7_11
17748998_17749445_25_31
Title: passing variables between two python decorators 
----------------------------------------

def decofu(f) :
INDENT
    def wrap() :
    INDENT
        print 'decobar!' if getattr(f, 'decobar') else 'not decobar'
        return f() + "fu"
    DEDENT
    return wrap
DEDENT
----------------------------------------

def decofu(f) :
INDENT
    @ functools.wraps(f)
    def wrap() :
    INDENT
        print decobar.present(f)
        return f() + "fu"
    DEDENT
    return wrap
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17748998_17749239_7_13
17748998_17749445_25_31
Title: passing variables between two python decorators 
----------------------------------------

def decofu(f) :
INDENT
    def wrap() :
    INDENT
        if hasattr(f, 'decobar_applied') and f.decobar_applied :
        INDENT
            print decobar_present()
        DEDENT
        return f() + "fu"
    DEDENT
    return wrap
DEDENT
----------------------------------------

def decofu(f) :
INDENT
    @ functools.wraps(f)
    def wrap() :
    INDENT
        print decobar.present(f)
        return f() + "fu"
    DEDENT
    return wrap
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17773516_17773584_22_34
17773516_22859647_30_42
Title: In-place QuickSort in Python 
----------------------------------------

def quicksort(array, start = 0, end = None) :
INDENT
    if end is None :
    INDENT
        end = len(array) - 1
    DEDENT
    if end - start < 1 :
    INDENT
        return
    DEDENT
    idx_pivot = random.randint(start, end)
    i = sub_partition(array, start, end, idx_pivot)
    quicksort(array, start, i - 1)
    quicksort(array, i + 1, end)
DEDENT
----------------------------------------

def quicksort(array, left, right) :
INDENT
    if left > = right :
    INDENT
        return
    DEDENT
    if right - left == 1 :
    INDENT
        if array [right] < array [left] :
        INDENT
            array [right], array [left] = array [left], array [right]
            return
        DEDENT
    DEDENT
    pivot = partition(array, left, right)
    quicksort(array, left, pivot - 1)
    quicksort(array, pivot + 1, right)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17773516_17773584_22_34
17773516_31634564_22_26
Title: In-place QuickSort in Python 
----------------------------------------

def quicksort(array, start = 0, end = None) :
INDENT
    if end is None :
    INDENT
        end = len(array) - 1
    DEDENT
    if end - start < 1 :
    INDENT
        return
    DEDENT
    idx_pivot = random.randint(start, end)
    i = sub_partition(array, start, end, idx_pivot)
    quicksort(array, start, i - 1)
    quicksort(array, i + 1, end)
DEDENT
----------------------------------------

def quicksort(a) :
INDENT
    if len(a) > 1 :
    INDENT
        return part(a, 0, len(a) - 1)
    DEDENT
    else :
    INDENT
        return a
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17773516_17773584_22_34
17773516_53078151_1_20
Title: In-place QuickSort in Python 
----------------------------------------

def quicksort(array, start = 0, end = None) :
INDENT
    if end is None :
    INDENT
        end = len(array) - 1
    DEDENT
    if end - start < 1 :
    INDENT
        return
    DEDENT
    idx_pivot = random.randint(start, end)
    i = sub_partition(array, start, end, idx_pivot)
    quicksort(array, start, i - 1)
    quicksort(array, i + 1, end)
DEDENT
----------------------------------------

def quicksort(arr) :
INDENT
    lesser = []
    equal = []
    greater = []
    if len(arr) > 1 :
    INDENT
        pivot = arr [len(arr) - 1]
        start = 0
        while start < len(arr) :
        INDENT
            if arr [start] > pivot :
            INDENT
                greater.append(arr.pop(start))
            DEDENT
            elif arr [start] < pivot :
            INDENT
                lesser.append(arr.pop(start))
            DEDENT
            else :
            INDENT
                start = start + 1
            DEDENT
        DEDENT
        return (quicksort(lesser) + arr + quicksort(greater))
    DEDENT
    else :
    INDENT
        return (arr)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17773516_22859647_30_42
17773516_31634564_22_26
Title: In-place QuickSort in Python 
----------------------------------------

def quicksort(array, left, right) :
INDENT
    if left > = right :
    INDENT
        return
    DEDENT
    if right - left == 1 :
    INDENT
        if array [right] < array [left] :
        INDENT
            array [right], array [left] = array [left], array [right]
            return
        DEDENT
    DEDENT
    pivot = partition(array, left, right)
    quicksort(array, left, pivot - 1)
    quicksort(array, pivot + 1, right)
DEDENT
----------------------------------------

def quicksort(a) :
INDENT
    if len(a) > 1 :
    INDENT
        return part(a, 0, len(a) - 1)
    DEDENT
    else :
    INDENT
        return a
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17773516_22859647_30_42
17773516_53078151_1_20
Title: In-place QuickSort in Python 
----------------------------------------

def quicksort(array, left, right) :
INDENT
    if left > = right :
    INDENT
        return
    DEDENT
    if right - left == 1 :
    INDENT
        if array [right] < array [left] :
        INDENT
            array [right], array [left] = array [left], array [right]
            return
        DEDENT
    DEDENT
    pivot = partition(array, left, right)
    quicksort(array, left, pivot - 1)
    quicksort(array, pivot + 1, right)
DEDENT
----------------------------------------

def quicksort(arr) :
INDENT
    lesser = []
    equal = []
    greater = []
    if len(arr) > 1 :
    INDENT
        pivot = arr [len(arr) - 1]
        start = 0
        while start < len(arr) :
        INDENT
            if arr [start] > pivot :
            INDENT
                greater.append(arr.pop(start))
            DEDENT
            elif arr [start] < pivot :
            INDENT
                lesser.append(arr.pop(start))
            DEDENT
            else :
            INDENT
                start = start + 1
            DEDENT
        DEDENT
        return (quicksort(lesser) + arr + quicksort(greater))
    DEDENT
    else :
    INDENT
        return (arr)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17773516_31634564_22_26
17773516_53078151_1_20
Title: In-place QuickSort in Python 
----------------------------------------

def quicksort(a) :
INDENT
    if len(a) > 1 :
    INDENT
        return part(a, 0, len(a) - 1)
    DEDENT
    else :
    INDENT
        return a
    DEDENT
DEDENT
----------------------------------------

def quicksort(arr) :
INDENT
    lesser = []
    equal = []
    greater = []
    if len(arr) > 1 :
    INDENT
        pivot = arr [len(arr) - 1]
        start = 0
        while start < len(arr) :
        INDENT
            if arr [start] > pivot :
            INDENT
                greater.append(arr.pop(start))
            DEDENT
            elif arr [start] < pivot :
            INDENT
                lesser.append(arr.pop(start))
            DEDENT
            else :
            INDENT
                start = start + 1
            DEDENT
        DEDENT
        return (quicksort(lesser) + arr + quicksort(greater))
    DEDENT
    else :
    INDENT
        return (arr)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17773516_31634564_5_21
17773516_34936481_6_17
Title: In-place QuickSort in Python 
----------------------------------------

def part(a, p, r) :
INDENT
    k = a [r]
    j, q = p, p
    if p < r :
    INDENT
        for i in range(p, r + 1) :
        INDENT
            if a [i] < = k :
            INDENT
                t = a [q]
                a [q] = a [j]
                a [j] = t
                if i ! = r :
                INDENT
                    q += 1
                DEDENT
                j += 1
            DEDENT
            else :
            INDENT
                j += 1
            DEDENT
        DEDENT
        part(a, p, q - 1)
        part(a, q + 1, r)
    DEDENT
    return a
DEDENT
----------------------------------------

def part(alist, start, end) :
INDENT
    pivot = alist [end]
    border = start
    if start < end :
    INDENT
        for i in range(start, end + 1) :
        INDENT
            if alist [i] < = pivot :
            INDENT
                alist [border], alist [i] = alist [i], alist [border]
                if i ! = end :
                INDENT
                    border += 1
                DEDENT
            DEDENT
        DEDENT
        part(alist, start, border - 1)
        part(alist, border + 1, end)
    DEDENT
    return alist
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1777435_1912686_7_14
1777435_4025461_5_12
Title: Django MultiWidget Phone Number Field 
----------------------------------------

def __init__(self, attrs = None) :
INDENT
    widgets = (
        forms.TextInput(attrs = {'size' : '3', 'maxlength' : '3', 'class' : 'phone'}),
        forms.TextInput(attrs = {'size' : '3', 'maxlength' : '3', 'class' : 'phone'}),
        forms.TextInput(attrs = {'size' : '4', 'maxlength' : '4', 'class' : 'phone'}),
        )
    super(USPhoneNumberMultiWidget, self).__init__(widgets, attrs)
DEDENT
----------------------------------------

def __init__(self, attrs = None) :
INDENT
    widgets = (
        forms.TextInput(attrs = {'size' : '3', 'maxlength' : '3', 'class' : 'phone'}),
        forms.TextInput(attrs = {'size' : '3', 'maxlength' : '3', 'class' : 'phone'}),
        forms.TextInput(attrs = {'size' : '4', 'maxlength' : '4', 'class' : 'phone'}),
        )
    super(USPhoneNumberMultiWidget, self).__init__(widgets, attrs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17785451_17786052_16_25
17785451_17786634_9_28
Title: Django Crispy Form Split Field Layouts 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(layout1Form, self).__init__(* args, ** kwargs)
    self.helper = FormHelper(self)
    self.helper.layout = Layout(
        Field('answer', css_class = "field span8"),
        ButtonHolder(
            Submit('submit', 'Submit', css_class = 'btn-primary pull-right')))
    self.helper.form_tag = False
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Form, self).__init__(* args, ** kwargs)
    helper1 = FormHelper()
    helper1.form_tag = False
    helper1.layout = Layout(
        Div(
            Field('field_1a'),
            Field('field_1b')))
    helper2 = FormHelper()
    helper2.form_tag = False
    helper2.disable_csrf = True
    helper2.layout = Layout(
        Div(
            Field('field_2a'),
            Field('field_2b')))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17785451_17786052_4_14
17785451_17786634_9_28
Title: Django Crispy Form Split Field Layouts 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(layout1Form, self).__init__(* args, ** kwargs)
    self.helper = FormHelper(self)
    self.helper.layout = Layout(
        Field('answer', css_class = "field span8"),
        ButtonHolder(
            Submit('submit', 'Submit', css_class = 'btn-primary pull-right')))
    self.helper.form_tag = False
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Form, self).__init__(* args, ** kwargs)
    helper1 = FormHelper()
    helper1.form_tag = False
    helper1.layout = Layout(
        Div(
            Field('field_1a'),
            Field('field_1b')))
    helper2 = FormHelper()
    helper2.form_tag = False
    helper2.disable_csrf = True
    helper2.layout = Layout(
        Div(
            Field('field_2a'),
            Field('field_2b')))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17794665_17795142_14_22
17794665_17795142_1_29
Title: How to convert text format list into a python list 
----------------------------------------

def parse(content) :
INDENT
    if (content.startswith("\"")) :
    INDENT
        return parseString(content)
    DEDENT
    elif (content.startswith("[")) :
    INDENT
        return parseList(content)
    DEDENT
    elif (content.isdigit()) :
    INDENT
        return parseNumber(content)

    DEDENT
DEDENT
----------------------------------------

def parse(content) :
INDENT
    def parseList(content) :
    INDENT
        listed = content.strip("[]").split(",")
        return map(parse, listed)
    DEDENT
    def parseString(content) :
    INDENT
        return content.strip("\"")
    DEDENT
    def parseNumber(content) :
    INDENT
        return int(content)
    DEDENT
    def parse(content) :
    INDENT
        if (content.startswith("\"")) :
        INDENT
            return parseString(content)
        DEDENT
        elif (content.startswith("[")) :
        INDENT
            return parseList(content)
        DEDENT
        elif (content.isdigit()) :
        INDENT
            return parseNumber(content)

        DEDENT
    DEDENT
    result = {}
    for line in content.splitlines() :
    INDENT
        key, value = line.split("=", 1)
        result [key] = parse(value)
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17800979_17820060_26_37
17800979_17820060_6_18
Title: wxpython ListBox not updating correctly in another frame/class 
----------------------------------------

def __init__(self, dirname, filename = 'boo.txt') :
INDENT
    super(SubWindow, self).__init__(None, size = (400, 200))
    self.CreateInteriorWindowComponents()
    path = os.path.join(dirname, filename)
    print path
    with open(path) as textfile :
    INDENT
        data = textfile.read()
    DEDENT
    self.control.SetValue(data)
    textfile.close()
DEDENT
----------------------------------------

def __init__(self, dirname) :
INDENT
    wx.Frame.__init__(self, None, title = 'List Directory', size = (600, 400))
    panel = wx.Panel(self)
    self.dirname = dirname
    kk = os.listdir(dirname)
    self.yard = wx.ListBox(panel, - 1, (100, 50), (400, 120), kk, wx.LB_SINGLE)
    self.PcuRestart = wx.Button(panel, 1, 'Show File', pos = (0, 30), size = (60, - 1))
    self.PcuRestart.Bind(wx.EVT_BUTTON, self.pcurestart)
    self.yard.SetSelection(7)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1781173_1787636_66_74
1781173_1794265_6_13
Title: PyQt: removeChild/addChild QGroupBox 
----------------------------------------

def addwidget_centralwdg(self, MainWindow) :
INDENT
    self.centralwidget = QtGui.QWidget(MainWindow)
    self.centralwidget.setObjectName("centralwidget")
    self.selectBox()
    self.addBox()
    self.connectEvent()
    MainWindow.setCentralWidget(self.centralwidget)
DEDENT
----------------------------------------

def addwidget_centralwdg(self, MainWindow) :
INDENT
    self.centralwidget = QtGui.QWidget(MainWindow)
    self.globalMainWindow = MainWindow
    self.centralwidget.setObjectName("centralwidget")
    self.selectBox()
    self.addBox()
    self.connectEvent()
    MainWindow.setCentralWidget(self.centralwidget)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17812938_17814754_20_31
17812938_45076549_15_22
Title: Retrieving the selected values from a CheckButtons object in matplotlib 
----------------------------------------

def __init__(self) :
INDENT
    colourax = plt.axes([0.5, 0.4, 0.09, 0.2])
    measurementax = plt.axes([0.5, 0.6, 0.09, 0.2])
    clabels, cvals = ('Red', 'Green', 'Blue'), (False,) * 3
    mlabels, mvals = ('1', '2', '3'), (False,) * 3
    self.cstates = dict(zip(clabels, cvals))
    self.mstates = dict(zip(mlabels, mvals))
    self.colours = CheckButtons(colourax, clabels, cvals)
    self.colours.on_clicked(self.onColor)
    self.measurements = CheckButtons(measurementax, mlabels, mvals)
    self.measurements.on_clicked(self.onMeasurement)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    colourax = plt.axes([0.5, 0.4, 0.09, 0.2])
    measurementax = plt.axes([0.5, 0.6, 0.09, 0.2])
    self.colours = CheckButtons(colourax, ('Red', 'Green', 'Blue'), (False, False, False))
    self.measurements = CheckButtons(measurementax, ('1', '2', '3'), (False, False, False))
    self.colours.on_clicked(self.updateChart)
    self.measurements.on_clicked(self.updateChart)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17862185_17862336_1_20
17862185_31956399_3_12
Title: How to inject variable into scope with a decorator? 
----------------------------------------

def decorator_factory(value) :
INDENT
    def msg_decorator(f) :
    INDENT
        def inner_dec(* args, ** kwargs) :
        INDENT
            g = f.__globals__
            sentinel = object()
            oldvalue = g.get('var', sentinel)
            g ['var'] = value
            try :
            INDENT
                res = f(* args, ** kwargs)
            DEDENT
            finally :
            INDENT
                if oldvalue is sentinel :
                INDENT
                    del g ['var']
                DEDENT
                else :
                INDENT
                    g ['var'] = oldvalue
                DEDENT
            DEDENT
            return res
        DEDENT
        return inner_dec
    DEDENT
    return msg_decorator
DEDENT
----------------------------------------

def decorator_factory(value) :
INDENT
    def msg_decorator(f) :
    INDENT
        def inner_dec(* args, ** kwargs) :
        INDENT
            res = f(value, * args, ** kwargs)
            return res
        DEDENT
        inner_dec.__name__ = f.__name__
        inner_dec.__doc__ = f.__doc__
        return inner_dec
    DEDENT
    return msg_decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17862185_17862336_2_19
17862185_31956399_4_10
Title: How to inject variable into scope with a decorator? 
----------------------------------------

def msg_decorator(f) :
INDENT
    def inner_dec(* args, ** kwargs) :
    INDENT
        g = f.__globals__
        sentinel = object()
        oldvalue = g.get('var', sentinel)
        g ['var'] = value
        try :
        INDENT
            res = f(* args, ** kwargs)
        DEDENT
        finally :
        INDENT
            if oldvalue is sentinel :
            INDENT
                del g ['var']
            DEDENT
            else :
            INDENT
                g ['var'] = oldvalue
            DEDENT
        DEDENT
        return res
    DEDENT
    return inner_dec
DEDENT
----------------------------------------

def msg_decorator(f) :
INDENT
    def inner_dec(* args, ** kwargs) :
    INDENT
        res = f(value, * args, ** kwargs)
        return res
    DEDENT
    inner_dec.__name__ = f.__name__
    inner_dec.__doc__ = f.__doc__
    return inner_dec
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17888312_17888439_1_8
17888312_17888462_1_10
Title: Taking things out of one list and putting them in another (python) 
----------------------------------------

def Hit(player_number, target_player, target_rank, pHands) :
INDENT
    try :
    INDENT
        while True :
        INDENT
            pHands [player_number].append(pHands [target_player].pop(pHands.index(target_rank)))
        DEDENT
        print pHands [player_number]
        print pHands [target_player]
    DEDENT
    except ValueError :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def Hit(player_number, target_player, target_rank, pHands) :
INDENT
    new_target_hand = []
    for card in pHands [target_player] :
    INDENT
        if target_rank == card :
        INDENT
            pHands [player_number].append(card)
        DEDENT
        else :
        INDENT
            new_target_hand.append(card)
        DEDENT
    DEDENT
    pHands [target_player] = new_target_hand
    print pHands [player_number]
    print pHands [target_player]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17915587_17915617_10_23
17915587_17915617_34_40
Title: The CLI seems to ignore my function and go to another! (Python) 
----------------------------------------

def enter(self, * args) :
INDENT
    if not self.choices :
    INDENT
        print (args [0])
        exit(0)
    DEDENT
    print ('\n\n{}\n{}'.format('*' * 20, self.welcome))
    while True :
    INDENT
        print ()
        print (self.menu)
        print ('\n'.join('{}: {}'.format(index + 1, text) for index, text in enumerate(choice [0] for choice in self.choices)))
        try :
        INDENT
            choice = int(input())
            return self.choices [choice - 1] [1 :]
        DEDENT
        except : pass
    DEDENT
DEDENT
----------------------------------------

def enter(bananaphone) :
INDENT
    room = World.locations ['Beginning']
    params = []
    while True :
    INDENT
        room, params = room.enter(* params)
        room = World.locations [room]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17920816_17920888_8_18
17920816_17920900_7_16
Title: How to give a function a value from another function in Python 
----------------------------------------

def solve_quad_eq(self) :
INDENT
    if self.solution is None :
    INDENT
        D = self.b ** 2 - 4 * self.a * self.c
        if D > = 0 :
        INDENT
            x1 = (- self.b - math.sqrt(D)) / 2 * self.a
            x2 = (- self.b + math.sqrt(D)) / 2 * self.a
            self.solution = [x1, x2]
        DEDENT
        else :
        INDENT
            self.solution = 0
        DEDENT
    DEDENT
    return self.solution
DEDENT
----------------------------------------

def solve_quad_eq(self) :
INDENT
    D = self.b ** 2 - 4 * self.a * self.c
    if D > = 0 :
    INDENT
        x1 = (- self.b - math.sqrt(D)) / 2 * self.a
        x2 = (- self.b + math.sqrt(D)) / 2 * self.a
        answer = [x1, x2]
        return answer
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17928629_17933159_28_49
17928629_17933159_7_15
Title: How do I auto fit a Matplotlib figure inside a PySide QFrame? 
----------------------------------------

def __init__(self, name, title, graph_title, parent = None) :
INDENT
    super(GraphView, self).__init__(parent)
    self.name = name
    self.graph_title = graph_title
    self.dpi = 100
    self.fig = Figure((5.0, 3.0), dpi = self.dpi, facecolor = (1, 1, 1), edgecolor = (0, 0, 0))
    self.axes = self.fig.add_subplot(111)
    self.canvas = FigureCanvas(self.fig)
    self.canvas.setParent(self)
    self.Title = QtGui.QLabel(self)
    self.Title.setText(title)
    self.layout = QtGui.QVBoxLayout()
    self.layout.addWidget(self.Title)
    self.layout.addWidget(self.canvas)
    self.layout.setStretchFactor(self.canvas, 1)
    self.setLayout(self.layout)
    self.canvas.show()
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.fft_frame = FftFrame(self)
    self.layout = QtGui.QVBoxLayout()
    self.layout.addWidget(self.fft_frame)
    self.setLayout(self.layout)
    self.setCentralWidget(self.fft_frame)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17941385_17941494_6_13
17941385_28485058_6_12
Title: Integer field prefix zero not displaying 
----------------------------------------

def clean_number1(self) :
INDENT
    n = self.cleaned_data.get('number1')
    for allowednondigit in '- ./' :
    INDENT
        n.replace(allowednondigit, '')
    DEDENT
    for char in n :
    INDENT
        if char not in '0123456789' :
        INDENT
            raise forms.ValidationError("Please only use digits, spaces, dots, slash and dash characters")
        DEDENT
    DEDENT
    return n
DEDENT
----------------------------------------

def clean_number1(self) :
INDENT
    n = self.cleaned_data.get('number1')
    allowed_characters = '0123456789- ./'
    for char in n :
    INDENT
        if char not in allowed_characters :
        INDENT
            raise forms.ValidationError("Please only use digits, spaces, dots, slash and dash characters")
        DEDENT
    DEDENT
    return n
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17979655_17979656_2_10
17979655_29124414_3_14
Title: How to implement autoretry for Celery tasks 
----------------------------------------

def real_decorator(func) :
INDENT
    @ task(* args_task, ** kwargs_task)
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        try :
        INDENT
            func(* args, ** kwargs)
        DEDENT
        except kwargs_task.get('autoretry_on', Exception), exc :
        INDENT
            wrapper.retry(exc = exc)
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def real_decorator(func) :
INDENT
    sup = super(MyCelery, self).task
    @ sup(* args_task, ** opts_task)
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        try :
        INDENT
            func(* args, ** kwargs)
        DEDENT
        except opts_task.get('autoretry_on', Exception) as exc :
        INDENT
            logger.info('Yo! We did it!')
            wrapper.retry(exc = exc, args = args, kwargs = kwargs)
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17979655_17979656_2_10
17979655_51860450_39_54
Title: How to implement autoretry for Celery tasks 
----------------------------------------

def real_decorator(func) :
INDENT
    @ task(* args_task, ** kwargs_task)
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        try :
        INDENT
            func(* args, ** kwargs)
        DEDENT
        except kwargs_task.get('autoretry_on', Exception), exc :
        INDENT
            wrapper.retry(exc = exc)
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def real_decorator(func) :
INDENT
    @ super_method(* args_task, ** opts_task)
    @ functools.wraps(func)
    def wrapper(* func_args, ** func_kwargs) :
    INDENT
        try :
        INDENT
            return func(* func_args, ** func_kwargs)
        DEDENT
        except autoretry_for as exc :
        INDENT
            if retry_backoff :
            INDENT
                retry_kwargs ['countdown'] = get_exponential_backoff_interval(
                    factor = retry_backoff,
                    retries = wrapper.request.retries,
                    maximum = retry_backoff_max,
                    full_jitter = retry_jitter,
                    )
            DEDENT
            raise wrapper.retry(exc = exc, ** retry_kwargs)
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17979655_17979656_5_9
17979655_29124414_8_13
Title: How to implement autoretry for Celery tasks 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    try :
    INDENT
        func(* args, ** kwargs)
    DEDENT
    except kwargs_task.get('autoretry_on', Exception), exc :
    INDENT
        wrapper.retry(exc = exc)
    DEDENT
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    try :
    INDENT
        func(* args, ** kwargs)
    DEDENT
    except opts_task.get('autoretry_on', Exception) as exc :
    INDENT
        logger.info('Yo! We did it!')
        wrapper.retry(exc = exc, args = args, kwargs = kwargs)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17979655_17979656_5_9
17979655_51860450_42_53
Title: How to implement autoretry for Celery tasks 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    try :
    INDENT
        func(* args, ** kwargs)
    DEDENT
    except kwargs_task.get('autoretry_on', Exception), exc :
    INDENT
        wrapper.retry(exc = exc)
    DEDENT
DEDENT
----------------------------------------

def wrapper(* func_args, ** func_kwargs) :
INDENT
    try :
    INDENT
        return func(* func_args, ** func_kwargs)
    DEDENT
    except autoretry_for as exc :
    INDENT
        if retry_backoff :
        INDENT
            retry_kwargs ['countdown'] = get_exponential_backoff_interval(
                factor = retry_backoff,
                retries = wrapper.request.retries,
                maximum = retry_backoff_max,
                full_jitter = retry_jitter,
                )
        DEDENT
        raise wrapper.retry(exc = exc, ** retry_kwargs)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17979655_29124414_2_15
17979655_51860450_25_66
Title: How to implement autoretry for Celery tasks 
----------------------------------------

def task(self, * args_task, ** opts_task) :
INDENT
    def real_decorator(func) :
    INDENT
        sup = super(MyCelery, self).task
        @ sup(* args_task, ** opts_task)
        @ functools.wraps(func)
        def wrapper(* args, ** kwargs) :
        INDENT
            try :
            INDENT
                func(* args, ** kwargs)
            DEDENT
            except opts_task.get('autoretry_on', Exception) as exc :
            INDENT
                logger.info('Yo! We did it!')
                wrapper.retry(exc = exc, args = args, kwargs = kwargs)
            DEDENT
        DEDENT
        return wrapper
    DEDENT
    return real_decorator
DEDENT
----------------------------------------

def task(self, * args, ** opts) :
INDENT
    super_method = super(Celery, self).task
    def inner_create_task_cls(* args_task, ** opts_task) :
    INDENT
        autoretry_for = tuple(opts_task.get('autoretry_for', ()))
        retry_backoff = int(opts_task.get('retry_backoff', False))
        retry_backoff_max = int(opts_task.get('retry_backoff_max', 600))
        retry_jitter = opts_task.get('retry_jitter', True)
        retry_kwargs = opts_task.get('retry_kwargs', {})
        def real_decorator(func) :
        INDENT
            @ super_method(* args_task, ** opts_task)
            @ functools.wraps(func)
            def wrapper(* func_args, ** func_kwargs) :
            INDENT
                try :
                INDENT
                    return func(* func_args, ** func_kwargs)
                DEDENT
                except autoretry_for as exc :
                INDENT
                    if retry_backoff :
                    INDENT
                        retry_kwargs ['countdown'] = get_exponential_backoff_interval(
                            factor = retry_backoff,
                            retries = wrapper.request.retries,
                            maximum = retry_backoff_max,
                            full_jitter = retry_jitter,
                            )
                    DEDENT
                    raise wrapper.retry(exc = exc, ** retry_kwargs)
                DEDENT
            DEDENT
            return wrapper
        DEDENT
        return real_decorator

    DEDENT
    if len(args) == 1 :
    INDENT
        if callable(args [0]) :
        INDENT
            return inner_create_task_cls(** opts)(* args)
        DEDENT
        raise TypeError('argument 1 to @task() must be a callable')
    DEDENT
    if args :
    INDENT
        raise TypeError(
            '@task() takes exactly 1 argument ({0} given)'.format(
                sum([len(args), len(opts)])))
    DEDENT
    return inner_create_task_cls(** opts)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17979655_29124414_3_14
17979655_51860450_39_54
Title: How to implement autoretry for Celery tasks 
----------------------------------------

def real_decorator(func) :
INDENT
    sup = super(MyCelery, self).task
    @ sup(* args_task, ** opts_task)
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        try :
        INDENT
            func(* args, ** kwargs)
        DEDENT
        except opts_task.get('autoretry_on', Exception) as exc :
        INDENT
            logger.info('Yo! We did it!')
            wrapper.retry(exc = exc, args = args, kwargs = kwargs)
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def real_decorator(func) :
INDENT
    @ super_method(* args_task, ** opts_task)
    @ functools.wraps(func)
    def wrapper(* func_args, ** func_kwargs) :
    INDENT
        try :
        INDENT
            return func(* func_args, ** func_kwargs)
        DEDENT
        except autoretry_for as exc :
        INDENT
            if retry_backoff :
            INDENT
                retry_kwargs ['countdown'] = get_exponential_backoff_interval(
                    factor = retry_backoff,
                    retries = wrapper.request.retries,
                    maximum = retry_backoff_max,
                    full_jitter = retry_jitter,
                    )
            DEDENT
            raise wrapper.retry(exc = exc, ** retry_kwargs)
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17979655_29124414_8_13
17979655_51860450_42_53
Title: How to implement autoretry for Celery tasks 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    try :
    INDENT
        func(* args, ** kwargs)
    DEDENT
    except opts_task.get('autoretry_on', Exception) as exc :
    INDENT
        logger.info('Yo! We did it!')
        wrapper.retry(exc = exc, args = args, kwargs = kwargs)
    DEDENT
DEDENT
----------------------------------------

def wrapper(* func_args, ** func_kwargs) :
INDENT
    try :
    INDENT
        return func(* func_args, ** func_kwargs)
    DEDENT
    except autoretry_for as exc :
    INDENT
        if retry_backoff :
        INDENT
            retry_kwargs ['countdown'] = get_exponential_backoff_interval(
                factor = retry_backoff,
                retries = wrapper.request.retries,
                maximum = retry_backoff_max,
                full_jitter = retry_jitter,
                )
        DEDENT
        raise wrapper.retry(exc = exc, ** retry_kwargs)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17980691_17981097_4_30
17980691_17981117_6_30
Title: wxpython layout with sizers 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent)
    self.panel = wx.Panel(self)
    main_sizer = wx.BoxSizer(wx.VERTICAL)

    self.centred_text = wx.StaticText(self.panel, label = "Title")
    main_sizer.Add(self.centred_text, 0, wx.ALIGN_CENTRE | wx.ALL, 3)

    content_sizer = wx.BoxSizer(wx.HORIZONTAL)
    grid_1 = wx.GridSizer(12, 2, 0, 0)
    grid_1.AddMany(wx.StaticText(self.panel, label = str(i)) for i in xrange(24))
    content_sizer.Add(grid_1, 1, wx.EXPAND | wx.ALL, 3)
    grid_2 = wx.GridSizer(10, 3, 0, 0)
    grid_2.AddMany(wx.StaticText(self.panel, label = str(i)) for i in xrange(30))
    content_sizer.Add(grid_2, 1, wx.EXPAND | wx.ALL, 3)
    main_sizer.Add(content_sizer, 1, wx.EXPAND)
    self.panel.SetSizer(main_sizer)
    self.Show()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Test Stretching!!")
    p1 = wx.Panel(self, - 1, size = (500, 100))
    p1.SetMinSize((500, 100))
    p1.SetBackgroundColour(wx.GREEN)
    hsz = wx.BoxSizer(wx.HORIZONTAL)
    p2 = wx.Panel(self, - 1, size = (200, 400))
    p2.SetMinSize((200, 400))
    p2.SetBackgroundColour(wx.RED)
    p3 = wx.Panel(self, - 1, size = (300, 400))
    p3.SetMinSize((300, 400))
    p3.SetBackgroundColour(wx.BLUE)
    hsz.Add(p2, 1, wx.EXPAND)
    hsz.Add(p3, 1, wx.EXPAND)
    sz = wx.BoxSizer(wx.VERTICAL)
    sz.Add(p1, 0, wx.EXPAND)
    sz.Add(hsz, 1, wx.EXPAND)
    self.SetSizer(sz)
    self.Layout()
    self.Fit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17980691_17981097_4_30
17980691_17981624_8_39
Title: wxpython layout with sizers 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent)
    self.panel = wx.Panel(self)
    main_sizer = wx.BoxSizer(wx.VERTICAL)

    self.centred_text = wx.StaticText(self.panel, label = "Title")
    main_sizer.Add(self.centred_text, 0, wx.ALIGN_CENTRE | wx.ALL, 3)

    content_sizer = wx.BoxSizer(wx.HORIZONTAL)
    grid_1 = wx.GridSizer(12, 2, 0, 0)
    grid_1.AddMany(wx.StaticText(self.panel, label = str(i)) for i in xrange(24))
    content_sizer.Add(grid_1, 1, wx.EXPAND | wx.ALL, 3)
    grid_2 = wx.GridSizer(10, 3, 0, 0)
    grid_2.AddMany(wx.StaticText(self.panel, label = str(i)) for i in xrange(30))
    content_sizer.Add(grid_2, 1, wx.EXPAND | wx.ALL, 3)
    main_sizer.Add(content_sizer, 1, wx.EXPAND)
    self.panel.SetSizer(main_sizer)
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    hSizer = wx.BoxSizer(wx.HORIZONTAL)
    leftGridSizer = wx.GridSizer(rows = 10, cols = 12, vgap = 5, hgap = 5)
    rightGridSizer = wx.GridSizer(rows = 10, cols = 3, vgap = 5, hgap = 5)

    title = wx.StaticText(self, label = "Main title")
    mainSizer.Add(wx.StaticText(self), 0, wx.EXPAND)
    mainSizer.Add(title, 0, wx.CENTER, wx.ALL, 10)
    for row in range(1, 11) :
    INDENT
        for col in range(1, 13) :
        INDENT
            lbl = "Row%s Col%s" % (row, col)
            leftGridSizer.Add(wx.StaticText(self, label = lbl))
        DEDENT
    DEDENT
    hSizer.Add(leftGridSizer, 0, wx.ALL, 20)
    for row in range(1, 11) :
    INDENT
        for col in range(1, 4) :
        INDENT
            lbl = "Row%s Col%s" % (row, col)
            rightGridSizer.Add(wx.StaticText(self, label = lbl))
        DEDENT
    DEDENT
    hSizer.Add(rightGridSizer, 0, wx.ALL, 20)
    mainSizer.Add(hSizer)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17980691_17981117_6_30
17980691_17981624_8_39
Title: wxpython layout with sizers 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Test Stretching!!")
    p1 = wx.Panel(self, - 1, size = (500, 100))
    p1.SetMinSize((500, 100))
    p1.SetBackgroundColour(wx.GREEN)
    hsz = wx.BoxSizer(wx.HORIZONTAL)
    p2 = wx.Panel(self, - 1, size = (200, 400))
    p2.SetMinSize((200, 400))
    p2.SetBackgroundColour(wx.RED)
    p3 = wx.Panel(self, - 1, size = (300, 400))
    p3.SetMinSize((300, 400))
    p3.SetBackgroundColour(wx.BLUE)
    hsz.Add(p2, 1, wx.EXPAND)
    hsz.Add(p3, 1, wx.EXPAND)
    sz = wx.BoxSizer(wx.VERTICAL)
    sz.Add(p1, 0, wx.EXPAND)
    sz.Add(hsz, 1, wx.EXPAND)
    self.SetSizer(sz)
    self.Layout()
    self.Fit()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    hSizer = wx.BoxSizer(wx.HORIZONTAL)
    leftGridSizer = wx.GridSizer(rows = 10, cols = 12, vgap = 5, hgap = 5)
    rightGridSizer = wx.GridSizer(rows = 10, cols = 3, vgap = 5, hgap = 5)

    title = wx.StaticText(self, label = "Main title")
    mainSizer.Add(wx.StaticText(self), 0, wx.EXPAND)
    mainSizer.Add(title, 0, wx.CENTER, wx.ALL, 10)
    for row in range(1, 11) :
    INDENT
        for col in range(1, 13) :
        INDENT
            lbl = "Row%s Col%s" % (row, col)
            leftGridSizer.Add(wx.StaticText(self, label = lbl))
        DEDENT
    DEDENT
    hSizer.Add(leftGridSizer, 0, wx.ALL, 20)
    for row in range(1, 11) :
    INDENT
        for col in range(1, 4) :
        INDENT
            lbl = "Row%s Col%s" % (row, col)
            rightGridSizer.Add(wx.StaticText(self, label = lbl))
        DEDENT
    DEDENT
    hSizer.Add(rightGridSizer, 0, wx.ALL, 20)
    mainSizer.Add(hSizer)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17982197_18330701_24_42
17982197_18330701_5_18
Title: Communication between mianwindow and dialog in python 
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__()
    self.setWindowTitle(self.tr("Main window"))
    self.button1 = QtGui.QPushButton()
    self.button2 = QtGui.QPushButton()
    self.button1.setText("Open dialog")
    self.button2.setText("Dummy")
    layout = QtGui.QVBoxLayout()
    layout.addWidget(self.button1)
    layout.addWidget(self.button2)
    self.window = QtGui.QWidget()
    self.window.setLayout(layout)
    self.setCentralWidget(self.window);
    self.connect(self.button1, QtCore.SIGNAL("clicked()"), self.showDialog)
    self.resize(360, 145)
DEDENT
----------------------------------------

def __init__(self, mainWin) :
INDENT
    QtGui.QDialog.__init__(self, mainWin)
    self.setWindowTitle(self.tr("Dialog window"))
    self.main = mainWin
    button = QtGui.QPushButton()
    button.setText("Save (disable dummy button)")
    layout = QtGui.QVBoxLayout()
    layout.addWidget(button)
    self.setLayout(layout)
    self.connect(button, QtCore.SIGNAL("clicked()"), self.save)
    self.resize(200, 100)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18016274_18018325_105_127
18016274_18018325_10_103
Title: wxnotebook scrolling off to area monitor 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "Scroll", (1, 1), (600, 600))

    s = scrolled.ScrolledPanel(self, style = wx.TAB_TRAVERSAL | wx.SUNKEN_BORDER)
    s.SetupScrolling()
    nb = wx.Notebook(s)

    page1 = PageOne(nb)

    nb.AddPage(page1, "Page 1")

    sizer = wx.BoxSizer()
    sizer.Add(nb, 1, 0)
    s.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    font = wx.Font(10, wx.ROMAN, wx.NORMAL, wx.NORMAL)

    self.name1 = wx.TextCtrl(self, - 1, '', (10, 35), (70, - 1))
    self.name2 = wx.TextCtrl(self, - 1, '', (10, 35 + 30), (70, - 1))
    self.name3 = wx.TextCtrl(self, - 1, '', (10, 35 + 60), (70, - 1))
    self.name4 = wx.TextCtrl(self, - 1, '', (10, 35 + 90), (70, - 1))
    self.name5 = wx.TextCtrl(self, - 1, '', (10, 35 + 120), (70, - 1))
    self.name6 = wx.TextCtrl(self, - 1, '', (10, 35 + 150), (70, - 1))
    self.name7 = wx.TextCtrl(self, - 1, '', (10, 35 + 180), (70, - 1))
    self.name8 = wx.TextCtrl(self, - 1, '', (10, 35 + 210), (70, - 1))
    self.name9 = wx.TextCtrl(self, - 1, '', (10, 35 + 240), (70, - 1))
    self.name10 = wx.TextCtrl(self, - 1, '', (10, 35 + 270), (70, - 1))
    self.name11 = wx.TextCtrl(self, - 1, '', (10, 35 + 300), (70, - 1))
    self.name12 = wx.TextCtrl(self, - 1, '', (10, 35 + 330), (70, - 1))
    self.name13 = wx.TextCtrl(self, - 1, '', (10, 35 + 360), (70, - 1))
    self.name14 = wx.TextCtrl(self, - 1, '', (10, 35 + 390), (70, - 1))
    self.name15 = wx.TextCtrl(self, - 1, '', (10, 35 + 420), (70, - 1))
    self.name16 = wx.TextCtrl(self, - 1, '', (10, 35 + 450), (70, - 1))
    self.name17 = wx.TextCtrl(self, - 1, '', (10, 35 + 480), (70, - 1))
    self.name18 = wx.TextCtrl(self, - 1, '', (10, 35 + 510), (70, - 1))

    self.to1 = wx.TextCtrl(self, - 1, '', (90, 35), (40, - 1))
    self.to2 = wx.TextCtrl(self, - 1, '', (90, 35 + 30), (40, - 1))
    self.to3 = wx.TextCtrl(self, - 1, '', (90, 35 + 60), (40, - 1))
    self.to4 = wx.TextCtrl(self, - 1, '', (90, 35 + 90), (40, - 1))
    self.to5 = wx.TextCtrl(self, - 1, '', (90, 35 + 120), (40, - 1))
    self.to6 = wx.TextCtrl(self, - 1, '', (90, 35 + 150), (40, - 1))
    self.to7 = wx.TextCtrl(self, - 1, '', (90, 35 + 180), (40, - 1))
    self.to8 = wx.TextCtrl(self, - 1, '', (90, 35 + 210), (40, - 1))
    self.to9 = wx.TextCtrl(self, - 1, '', (90, 35 + 240), (40, - 1))
    self.to10 = wx.TextCtrl(self, - 1, '', (90, 35 + 270), (40, - 1))
    self.to11 = wx.TextCtrl(self, - 1, '', (90, 35 + 300), (40, - 1))
    self.to12 = wx.TextCtrl(self, - 1, '', (90, 35 + 330), (40, - 1))
    self.to13 = wx.TextCtrl(self, - 1, '', (90, 35 + 360), (40, - 1))
    self.to14 = wx.TextCtrl(self, - 1, '', (90, 35 + 390), (40, - 1))
    self.to15 = wx.TextCtrl(self, - 1, '', (90, 35 + 420), (40, - 1))
    self.to16 = wx.TextCtrl(self, - 1, '', (90, 35 + 450), (40, - 1))
    self.to17 = wx.TextCtrl(self, - 1, '', (90, 35 + 480), (40, - 1))
    self.to18 = wx.TextCtrl(self, - 1, '', (90, 35 + 510), (40, - 1))

    self.topc1 = wx.TextCtrl(self, - 1, '', (140, 35), (40, - 1))
    self.topc2 = wx.TextCtrl(self, - 1, '', (140, 35 + 30), (40, - 1))
    self.topc3 = wx.TextCtrl(self, - 1, '', (140, 35 + 60), (40, - 1))
    self.topc4 = wx.TextCtrl(self, - 1, '', (140, 35 + 90), (40, - 1))
    self.topc5 = wx.TextCtrl(self, - 1, '', (140, 35 + 120), (40, - 1))
    self.topc6 = wx.TextCtrl(self, - 1, '', (140, 35 + 150), (40, - 1))
    self.topc7 = wx.TextCtrl(self, - 1, '', (140, 35 + 180), (40, - 1))
    self.topc8 = wx.TextCtrl(self, - 1, '', (140, 35 + 210), (40, - 1))
    self.topc9 = wx.TextCtrl(self, - 1, '', (140, 35 + 240), (40, - 1))
    self.topc10 = wx.TextCtrl(self, - 1, '', (140, 35 + 270), (40, - 1))
    self.topc11 = wx.TextCtrl(self, - 1, '', (140, 35 + 300), (40, - 1))
    self.topc12 = wx.TextCtrl(self, - 1, '', (140, 35 + 330), (40, - 1))
    self.topc13 = wx.TextCtrl(self, - 1, '', (140, 35 + 360), (40, - 1))
    self.topc14 = wx.TextCtrl(self, - 1, '', (140, 35 + 390), (40, - 1))
    self.topc15 = wx.TextCtrl(self, - 1, '', (140, 35 + 420), (40, - 1))
    self.topc16 = wx.TextCtrl(self, - 1, '', (140, 35 + 450), (40, - 1))
    self.topc17 = wx.TextCtrl(self, - 1, '', (140, 35 + 480), (40, - 1))
    self.topc18 = wx.TextCtrl(self, - 1, '', (140, 35 + 510), (40, - 1))

    panel = wx.Panel(self, - 1, (195, 35), (5, 630), style = wx.SUNKEN_BORDER)
    wx.ToggleButton(self, 1, '', (210, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 40, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 80, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 120, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 160, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 200, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 240, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 280, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 320, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 360, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 400, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 440, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 480, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 520, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 560, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 600, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 640, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 680, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 720, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 760, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 800, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 840, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 880, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 920, 35), (30, 20))
    wx.ToggleButton(self, 1, '', (210 + 960, 35), (30, 20))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18023350_18023520_8_16
18023350_43357939_8_14
Title: Django unittest and mocking the requests module 
----------------------------------------

def test_some_function(self) :
INDENT
    user = self.user = Mock()
    user.email = 'user@example.com'
    with patch('utils.requests') as mock_requests :
    INDENT
        mock_requests.get.return_value = mock_response = Mock()
        mock_response.status_code = 200
        mock_response.json.return_value = {"UserId" : "123456"}
        results = utils.some_function(self.user)
        self.assertEqual(results ['UserId'], '123456')
    DEDENT
DEDENT
----------------------------------------

def test_some_function(self) :
INDENT
    mock_response = Mock()
    mock_response.status_code = 200
    mock_response.json.return_value = {"UserId" : "123456"}
    with patch('utils.requests.get') as mock_requests :
    INDENT
        results = utils.some_function(self.user)
        self.assertEqual(results ['UserId'], '123456')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18035688_18035971_31_39
18035688_18035971_40_58
Title: Lazy variable lookup in Jinja templates 
----------------------------------------

def new_context(self, vars = None, shared = False, locals = None,
context_class = CustomContextWrapper) :
INDENT
    context = new_context(self.environment, self.name, self.blocks,
        vars, shared, self.globals, locals,
        context_class = context_class)
    context.set_custom_context(self.__custom_context)
    return context

DEDENT
----------------------------------------

def new_context(environment, template_name, blocks, vars = None,
shared = None, globals = None, locals = None,
context_class = CustomContextWrapper) :
INDENT
    if vars is None :
    INDENT
        vars = {}
    DEDENT
    if shared :
    INDENT
        parent = vars
    DEDENT
    else :
    INDENT
        parent = dict(globals or (), ** vars)
    DEDENT
    if locals :
    INDENT
        if shared :
        INDENT
            parent = dict(parent)
        DEDENT
        for key, value in iteritems(locals) :
        INDENT
            if key [: 2] == 'l_' and value is not missing :
            INDENT
                parent [key [2 :]] = value
            DEDENT
        DEDENT
    DEDENT
    return context_class(environment, parent, template_name, blocks)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1803710_1803757_1_14
1803710_1803901_1_12
Title: Python: Can you make this __eq__ easy to understand? 
----------------------------------------

def __eq__(self, other) :
INDENT
    for attr in self.metainfo :
    INDENT
        if attr in self.__dict__ :
        INDENT
            if attr not in other.__dict__ :
            INDENT
                return False
            DEDENT
            if getattr(self, attr) ! = getattr(other, attr) :
            INDENT
                return False
            DEDENT
            continue
        DEDENT
        else :
        INDENT
            if attr in other.__dict__ :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def __eq__(self, other) :
INDENT
    if set(metainfo) ! = set(other.metainfo) :
    INDENT
        return False
    DEDENT
    sentinel = object()
    for attr in self.metainfo :
    INDENT
        if getattr(self, attr, sentinel) ! = getattr(other, attr, sentinel) :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18050933_18051492_1_10
18050933_18053099_1_9
Title: Sorting an list that only contains 0s and 1s using recursion 
----------------------------------------

def sort(list, fromIndex, toIndex) :
INDENT
    if fromIndex == toIndex :
    INDENT
        return list
    DEDENT
    if list [fromIndex] == 0 :
    INDENT
        return sort(list, fromIndex + 1, toIndex)
    DEDENT
    else :
    INDENT
        list [fromIndex] = list [toIndex]
        list [toIndex] = 1
        return sort(list, fromIndex, toIndex - 1)
    DEDENT
DEDENT
----------------------------------------

def sort(arr) :
INDENT
    leftside = []
    rightside = []
    for elem in arr :
    INDENT
        leftside.append(elem) if elem == 0 else rightside.append(elem)
    DEDENT
    return leftside + rightside

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18063249_18063364_18_34
18063249_18063455_1_14
Title: Randomly walking turtle function not doing what I want it to 
----------------------------------------

def randomWalk(t, w) :
INDENT
    counter = 0
    while True :
    INDENT
        while isInScreen(w, t) :
        INDENT
            coin = random.randrange(0, 2)
            if coin == 0 :
            INDENT
                t.left(90)
            DEDENT
            else :
            INDENT
                t.right(90)
            DEDENT
            t.forward(50)
        DEDENT
        t.left(180)
        t.forward(50)
        counter += 1
        if counter == 4 :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def randomWalk(t, w) :
INDENT
    counter = 0
    while counter < 4 :
    INDENT
        if not isInScreen(w, t) :
        INDENT
            t.left(180)
            counter += 1
        DEDENT
        else :
        INDENT
            coin = random.randrange(0, 2)
            if coin == 0 :
            INDENT
                t.left(90)
            DEDENT
            else :
            INDENT
                t.right(90)
            DEDENT
        DEDENT
        t.forward(50)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18071285_18326146_15_22
18071285_45504923_16_23
Title: Numba slow when assigning to an array? 
----------------------------------------

def sum_arr(arr, z) :
INDENT
    M = len(arr)
    for i in range(M) :
    INDENT
        z [i] += arr [i]
    DEDENT
    return z
DEDENT
----------------------------------------

def sum_arr(arr) :
INDENT
    z = arr.copy()
    M = len(arr)
    for i in range(M) :
    INDENT
        z [i] += arr [i]
    DEDENT
    return z
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18071285_18326146_7_14
18071285_45504923_8_15
Title: Numba slow when assigning to an array? 
----------------------------------------

def fast_sum_arr(arr, z) :
INDENT
    M = len(arr)
    for i in range(M) :
    INDENT
        z [i] += arr [i]
    DEDENT
    return z
DEDENT
----------------------------------------

def fast_sum_arr(arr) :
INDENT
    z = arr.copy()
    M = len(arr)
    for i in range(M) :
    INDENT
        z [i] += arr [i]
    DEDENT
    return z
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18092354_18092547_2_21
18092354_43137914_1_16
Title: Python split string without splitting escaped character 
----------------------------------------

def escaped_split(s, delim) :
INDENT
    escaped_delim = '\\' + delim
    sections = [p.split(delim) for p in s.split(escaped_delim)]
    ret = []
    prev = None
    for parts in sections :
    INDENT
        if prev is None :
        INDENT
            if len(parts) > 1 :
            INDENT

                ret.append(parts [0])
            DEDENT
        DEDENT
        else :
        INDENT

            ret.append(escaped_delim.join([prev, parts [0]]))
        DEDENT
        for part in parts [1 : - 1] :
        INDENT

            ret.append(part)
        DEDENT
        prev = parts [- 1]
    DEDENT
    return ret
DEDENT
----------------------------------------

def escaped_split(str, ch) :
INDENT
    if len(ch) > 1 :
    INDENT
        raise ValueError('Expected split character. Found string!')
    DEDENT
    out = []
    part = ''
    escape = False
    for i in range(len(str)) :
    INDENT
        if not escape and str [i] == ch :
        INDENT
            out.append(part)
            part = ''
        DEDENT
        else :
        INDENT
            part += str [i]
            escape = not escape and str [i] == '\\'
        DEDENT
    DEDENT
    if len(part) :
    INDENT
        out.append(part)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18102883_18103822_4_8
18102883_18104656_5_10
Title: Python multiprocessing closes too early 
----------------------------------------

def pr1() :
INDENT
    while 1 :
    INDENT
        winsound.MessageBeep()
        print ('its working')
        time.sleep(0.5)
    DEDENT
DEDENT
----------------------------------------

def pr1() :
INDENT
    while 1 :
    INDENT
        winsound.MessageBeep()
        print ('its working')
        time.sleep(0.5)
        sys.stdout.flush()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18115637_18116359_26_31
18115637_18116359_9_16
Title: Global Function block? 
----------------------------------------

def prompt(self) :
INDENT
    choice = raw_input(self.Name + ": ")
    if choice == 'help' :
    INDENT
        self.help()
    DEDENT
    if choice == 'go north' :
    INDENT
        return self.Exits ['north']
    DEDENT
DEDENT
----------------------------------------

def prompt(self) :
INDENT
    choice = raw_input(self.Name + ": ")
    if choice == 'help' :
    INDENT
        self.help()

    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18116650_36816953_10_17
18116650_37427453_11_18
Title: Is it possible to play FLAC files in Phonon? 
----------------------------------------

def __init__(self, f, * args, ** kwargs) :
INDENT
    self.seg = AudioSegment.from_file(f)
    self.__is_paused = True
    self.p = PyAudio()
    print self.seg.frame_rate
    Thread.__init__(self, * args, ** kwargs)
    self.start()
DEDENT
----------------------------------------

def __init__(self, f, * args, ** kwargs) :
INDENT
    self.seg = AudioSegment.from_file(f)
    self.__is_paused = True
    self.p = PyAudio()
    print (self.seg.frame_rate)
    Thread.__init__(self, * args, ** kwargs)
    self.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18116650_36816953_30_45
18116650_37427453_31_42
Title: Is it possible to play FLAC files in Phonon? 
----------------------------------------

def run(self) :
INDENT
    stream = self.__get_stream()
    chunk_count = 0
    chunks = make_chunks(self.seg, 100)
    while chunk_count < = len(chunks) :
    INDENT
        if not self.__is_paused :
        INDENT
            data = (chunks [chunk_count])._data
            chunk_count += 1
        DEDENT
        else :
        INDENT
            free = stream.get_write_available()
            data = chr(0) * free
        DEDENT
        stream.write(data)
    DEDENT
    stream.stop_stream()
    self.p.terminate()
DEDENT
----------------------------------------

def run(self) :
INDENT
    stream = self.__get_stream()
    chunk_count = 0
    chunks = make_chunks(self.seg, 100)
    while chunk_count < len(chunks) and not self.__is_paused :
    INDENT
        data = (chunks [chunk_count])._data
        chunk_count += 1
        stream.write(data)
    DEDENT
    stream.stop_stream()
    self.p.terminate()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18150434_18158612_37_47
18150434_18158612_7_25
Title: "Convert from kilometers (km) to decimal degrees" 
----------------------------------------

def __init__(self, degrees = 0, ** kwargs) :
INDENT
    if (kwargs) :
    INDENT
        if (kwargs.has_key("degrees")) :
        INDENT
            self.degrees = kwargs ["degrees"] % 360
            self._hash = self.encode()
        DEDENT
        elif (kwargs.has_key("hash")) :
        INDENT
            self._hash = kwargs ["hash"] % ((2 < < 31) - 1)
            self.degrees = self.decode()
        DEDENT
    DEDENT
    else :
    INDENT
        self.degrees = degrees % 360
        self._hash = self.encode()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, longitude = None, latitude = None, ** kwargs) :
INDENT
    if (kwargs) :
    INDENT
        if (kwargs.has_key("longitude ") and kwargs.has_key("latitude ")) :
        INDENT
            self.longitude = geohash(degrees = kwargs ["degrees"])
            self.latitude = geohash(degrees = kwargs ["hash"])
        DEDENT
    DEDENT
    else :
    INDENT
        if (longitude == None or latitude == None) :
        INDENT
            self.longitude = geohash(degrees = 0)
            self.latitude = geohash(degrees = 0)
        DEDENT
        else :
        INDENT
            self.longitude = geohash(degrees = longitude)
            self.latitude = geohash(degrees = latitude)
        DEDENT
    DEDENT
    long_hash = self.longitude.bin_hash
    lat_hash = self.latitude.bin_hash
    hash_str = ""
    if (len(long_hash) == len(lat_hash)) :
    INDENT
        for i in range(len(long_hash)) :
        INDENT
            hash_str += (long_hash [i] + lat_hash [i])
        DEDENT
    DEDENT
    self.bin_hash = hash_str
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18150434_18158612_37_47
18150434_18158612_91_110
Title: "Convert from kilometers (km) to decimal degrees" 
----------------------------------------

def __init__(self, degrees = 0, ** kwargs) :
INDENT
    if (kwargs) :
    INDENT
        if (kwargs.has_key("degrees")) :
        INDENT
            self.degrees = kwargs ["degrees"] % 360
            self._hash = self.encode()
        DEDENT
        elif (kwargs.has_key("hash")) :
        INDENT
            self._hash = kwargs ["hash"] % ((2 < < 31) - 1)
            self.degrees = self.decode()
        DEDENT
    DEDENT
    else :
    INDENT
        self.degrees = degrees % 360
        self._hash = self.encode()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, ihash = None, iparent = None) :
INDENT
    def set_helper(iparent, cur_hex, hex_list) :
    INDENT
        ret_bin_tree = self.__class__(None, iparent)
        if (hex_list) :
        INDENT
            ret_bin_tree.set_child(cur_hex, set_helper(ret_bin_tree, hex_list [0], hex_list [1 :]))
            return ret_bin_tree
        DEDENT
        elif (cur_hex) :
        INDENT
            ret_bin_tree.set_child(cur_hex, ihash)
            return ret_bin_tree
        DEDENT
    DEDENT
    self.parent = self
    self.left = None
    self.right = None
    if (iparent ! = None) :
    INDENT
        self.parent = iparent
    DEDENT
    if (isinstance(ihash, self.hash_type)) :
    INDENT
        ilist = list(ihash.bin_hash)
        if (len(ilist) > 1) :
        INDENT
            ret_bin_tree = set_helper(self, ilist [1], ilist [2 :])
        DEDENT
        if (ret_bin_tree) :
        INDENT
            self.set_child(ilist [0], ret_bin_tree)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18150434_18158612_7_25
18150434_18158612_91_110
Title: "Convert from kilometers (km) to decimal degrees" 
----------------------------------------

def __init__(self, longitude = None, latitude = None, ** kwargs) :
INDENT
    if (kwargs) :
    INDENT
        if (kwargs.has_key("longitude ") and kwargs.has_key("latitude ")) :
        INDENT
            self.longitude = geohash(degrees = kwargs ["degrees"])
            self.latitude = geohash(degrees = kwargs ["hash"])
        DEDENT
    DEDENT
    else :
    INDENT
        if (longitude == None or latitude == None) :
        INDENT
            self.longitude = geohash(degrees = 0)
            self.latitude = geohash(degrees = 0)
        DEDENT
        else :
        INDENT
            self.longitude = geohash(degrees = longitude)
            self.latitude = geohash(degrees = latitude)
        DEDENT
    DEDENT
    long_hash = self.longitude.bin_hash
    lat_hash = self.latitude.bin_hash
    hash_str = ""
    if (len(long_hash) == len(lat_hash)) :
    INDENT
        for i in range(len(long_hash)) :
        INDENT
            hash_str += (long_hash [i] + lat_hash [i])
        DEDENT
    DEDENT
    self.bin_hash = hash_str
DEDENT
----------------------------------------

def __init__(self, ihash = None, iparent = None) :
INDENT
    def set_helper(iparent, cur_hex, hex_list) :
    INDENT
        ret_bin_tree = self.__class__(None, iparent)
        if (hex_list) :
        INDENT
            ret_bin_tree.set_child(cur_hex, set_helper(ret_bin_tree, hex_list [0], hex_list [1 :]))
            return ret_bin_tree
        DEDENT
        elif (cur_hex) :
        INDENT
            ret_bin_tree.set_child(cur_hex, ihash)
            return ret_bin_tree
        DEDENT
    DEDENT
    self.parent = self
    self.left = None
    self.right = None
    if (iparent ! = None) :
    INDENT
        self.parent = iparent
    DEDENT
    if (isinstance(ihash, self.hash_type)) :
    INDENT
        ilist = list(ihash.bin_hash)
        if (len(ilist) > 1) :
        INDENT
            ret_bin_tree = set_helper(self, ilist [1], ilist [2 :])
        DEDENT
        if (ret_bin_tree) :
        INDENT
            self.set_child(ilist [0], ret_bin_tree)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18216829_18255835_22_33
18216829_18255835_8_20
Title: Interacting with MatplotlibWidget created with Qt Designer in python code 
----------------------------------------

def __init__(self, parent = None, title = 'Title', xlabel = 'x label', ylabel = 'y label', dpi = 100, hold = False) :
INDENT
    super(MatplotlibWidget, self).__init__(Figure())
    self.setParent(parent)
    self.figure = Figure(dpi = dpi)
    self.canvas = Canvas(self.figure)
    self.theplot = self.figure.add_subplot(111)
    self.theplot.set_title(title)
    self.theplot.set_xlabel(xlabel)
    self.theplot.set_ylabel(ylabel)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    MainWindow.__init__(self)
    x = [0, 10, 100]
    y = [3, 4, 5]
    self.mplwidget = MatplotlibWidget(self.centralwidget)
    self.mplwidget.setGeometry(QtCore.QRect(70, 50, 600, 500))
    self.mplwidget.setObjectName("mplwidget")
    self.mplwidget.plotDataPoints(x, y)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18217455_18217789_6_17
18217455_18217960_6_17
Title: Calling a method within another method in the context of @property 
----------------------------------------

def grade(self) :
INDENT
    grade = self.failure
    if 60 < = self.score < 70 :
    INDENT
        grade = 'D'
    DEDENT
    elif 70 < = self.score < 80 :
    INDENT
        grade = 'C'
    DEDENT
    elif 80 < = self.score < 90 :
    INDENT
        grade = 'B'
    DEDENT
    elif 90 < = self.score < 100 :
    INDENT
        grade = 'A'
    DEDENT
    return grade
DEDENT
----------------------------------------

def grade(self) :
INDENT
    if self.failure :
    INDENT
        return 'F'
    DEDENT
    if 60 < = self.score < 70 :
    INDENT
        return 'D'
    DEDENT
    if 70 < = self.score < 80 :
    INDENT
        return 'C'
    DEDENT
    if 80 < = self.score < 90 :
    INDENT
        return 'B'
    DEDENT
    if 90 < = self.score < 100 :
    INDENT
        return 'A'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18219508_18219575_12_16
18219508_18220785_1_12
Title: "In Python how do you execute objects that are functions from a list?" 
----------------------------------------

def updateEnv(ctx) :
INDENT
    for actionVal, actionDesc, actionFunctions in validActions :
    INDENT
        if ctx ["newAction"] == actionVal :
        INDENT
            for action_function in actionFunctions :
            INDENT
                action_function()
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def updateEnv(ctx) :
INDENT
    for actionVal, actionDesc, actionFunctions in validActions :
    INDENT
        if ctx ["newAction"] == actionVal :
        INDENT
            try :
            INDENT
                [func() for func in actionFunctions]
            DEDENT
            except TypeError :
            INDENT

                actionFunctions()
            DEDENT
            except Exception as e :
            INDENT
                print e
                pass
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18219508_18219584_11_15
18219508_18220785_1_12
Title: "In Python how do you execute objects that are functions from a list?" 
----------------------------------------

def updateEnv(ctx) :
INDENT
    for actionVal, actionDesc, actionFunctions in validActions :
    INDENT
        if ctx ["newAction"] == actionVal :
        INDENT
            for func in actionFunctions :
            INDENT
                func()
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def updateEnv(ctx) :
INDENT
    for actionVal, actionDesc, actionFunctions in validActions :
    INDENT
        if ctx ["newAction"] == actionVal :
        INDENT
            try :
            INDENT
                [func() for func in actionFunctions]
            DEDENT
            except TypeError :
            INDENT

                actionFunctions()
            DEDENT
            except Exception as e :
            INDENT
                print e
                pass
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1823293_1823365_4_11
1823293_1823442_3_10
Title: Optimized method for calculating cosine distance in Python 
----------------------------------------

def cosine_distance(a, b) :
INDENT
    if len(a) ! = len(b) :
    INDENT
        raise ValueError, "a and b must be same length"
    DEDENT
    numerator = sum(tup [0] * tup [1] for tup in izip(a, b))
    denoma = sum(avalue ** 2 for avalue in a)
    denomb = sum(bvalue ** 2 for bvalue in b)
    result = 1 - numerator / (sqrt(denoma) * sqrt(denomb))
    return result
DEDENT
----------------------------------------

def cosine_distance(a, b) :
INDENT
    assert len(a) == len(b)
    ab_sum, a_sum, b_sum = 0, 0, 0
    for ai, bi in izip(a, b) :
    INDENT
        ab_sum += ai * bi
        a_sum += ai * ai
        b_sum += bi * bi
    DEDENT
    return 1 - ab_sum / sqrt(a_sum * b_sum)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18243119_18243464_3_24
18243119_18243518_1_27
Title: Python/Regex - Expansion of Parentheses and Slashes 
----------------------------------------

def expand(s) :
INDENT
    ''' Group 1 contains the string inside the parenthesis
        Group 2 contains the digit or character `s` after the closing parenthesis

    '''
    match = re.search(r'\(([^()]*)\)(\d|s)', s)
    if match :
    INDENT
        group0 = match.group()
        group1 = match.group(1)
        group2 = match.group(2)
        if group2.isdigit() :
        INDENT

            s = s.replace(group0, ((group1 + '/') * int(group2)) [: - 1])
        DEDENT
        else :
        INDENT
            s = s.replace(group0, '/'.join(group1.split('/') + group1.split('/') [: : - 1]))
        DEDENT
    DEDENT
    if '(' in s :
    INDENT
        return expand(s)
    DEDENT
    return s
DEDENT
----------------------------------------

def expand(string) :
INDENT
    level = 0
    buffer = ""
    container = []
    for char in string :
    INDENT
        if char == "/" :
        INDENT
            if level == 0 :
            INDENT
                container.append(buffer)
                buffer = ""
            DEDENT
            else :
            INDENT
                buffer += char
            DEDENT
        DEDENT
        elif char == "(" :
        INDENT
            level += 1
            buffer += char
        DEDENT
        elif char == ")" :
        INDENT
            level -= 1
            buffer += char
        DEDENT
        else :
        INDENT
            buffer += char
        DEDENT
    DEDENT
    if buffer ! = "" :
    INDENT
        container.append(buffer)
    DEDENT
    return container
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18265961_18266173_1_14
18265961_18266213_1_14
Title: Walk recursively through childs of a list in Python 
----------------------------------------

def traverse(l, al = "", comps = []) :
INDENT
    if isinstance(l, dict) :
    INDENT
        if not al :
        INDENT
            al += l.get("kw")
        DEDENT
        else :
        INDENT
            al += ", %s" % l.get("kw")
        DEDENT
        traverse(l.get("childs"), al, comps)
    DEDENT
    elif isinstance(l, list) :
    INDENT
        for i in l :
        INDENT
            traverse(i, al, comps)
        DEDENT
    DEDENT
    else :
    INDENT
        comps.append(al)
    DEDENT
    return comps
DEDENT
----------------------------------------

def traverse(d, l, s = None) :
INDENT
    kw = d.get('kw')
    c = d.get('childs')
    if (s == None) :
    INDENT
        s = kw
    DEDENT
    else :
    INDENT
        s = s + " " + kw
    DEDENT
    if c :
    INDENT
        for cc in c :
        INDENT
            l = traverse(cc, l, s)
        DEDENT
    DEDENT
    else :
    INDENT
        l.append(s)
    DEDENT
    return l
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18279775_29332856_15_20
18279775_39194627_14_20
Title: Implementing Stack with Python 
----------------------------------------

def pop(self) :
INDENT
    if (self.top == None) :
    INDENT
        return (None)
    DEDENT
    r = self.top.getObj()
    self.top = self.top.getNext()
    return (r)
DEDENT
----------------------------------------

def pop(self) :
INDENT
    if not self.isEmpty() :
    INDENT
        self.arrList [len(self.arrList) - 1]
        self.arrList = self.arrList [: len(self.arrList) - 1]
    DEDENT
    else :
    INDENT
        print "Stack is empty"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18293171_18293737_5_19
18293171_18294787_1_17
Title: User-specified csv reading and printing in Python 3 
----------------------------------------

def main() :
INDENT
    parser = argparse.ArgumentParser()
    parser.add_argument('filename', help = 'Name of the file you want to load')
    args = parser.parse_args()
    result = []
    with io.open(args.filename, 'r', encoding = 'utf-8') as f :
    INDENT
        reader = csv.reader(f)
        for row in reader :
        INDENT
            result.append([row [0], row [1]])
        DEDENT
    DEDENT
    for item in result :
    INDENT
        print ('{0}, {1}'.format(* item))
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    parser = ArgumentParser()
    parser.add_argument('infiles', nargs = '+')
    args = parser.parse_args()
    try :
    INDENT
        data = [(line.rstrip()).split(',') for line in fileinput.input(args.infiles)]
    DEDENT
    except IOError as detail :
    INDENT
        print(detail, file = sys.stderr)
        sys.exit(2)
    DEDENT
    '''kept these lines in just to make sure the data is in the same format as when it worked before'''
    t = [float(row [0]) for row in data]
    m = [float(row [1]) for row in data]
    result = [[a, b] for a, b in zip(t, m)]
    for line in result :
    INDENT
        print (', '.join(str(x) for x in line))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
183042_19935248_18_23
183042_30604002_37_43
Title: How can I use UUIDs in SQLAlchemy? 
----------------------------------------

def process_result_value(self, value, dialect = None) :
INDENT
    if value :
    INDENT
        return uuid.UUID(bytes = value)
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def process_result_value(self, value, dialect) :
INDENT
    if value is None :
    INDENT
        return value
    DEDENT
    if dialect.name == 'postgresql' :
    INDENT
        return uuid.UUID(value)
    DEDENT
    else :
    INDENT
        return uuid.UUID(bytes = value)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
183042_19935248_8_17
183042_30604002_21_36
Title: How can I use UUIDs in SQLAlchemy? 
----------------------------------------

def process_bind_param(self, value, dialect = None) :
INDENT
    if value and isinstance(value, uuid.UUID) :
    INDENT
        return value.bytes
    DEDENT
    elif value and isinstance(value, basestring) :
    INDENT
        return uuid.UUID(value).bytes
    DEDENT
    elif value :
    INDENT
        raise ValueError('value %s is not a valid uuid.UUId' % value)
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def process_bind_param(self, value, dialect) :
INDENT
    if value is None :
    INDENT
        return value
    DEDENT
    else :
    INDENT
        if not isinstance(value, uuid.UUID) :
        INDENT
            if isinstance(value, bytes) :
            INDENT
                value = uuid.UUID(bytes = value)
            DEDENT
            elif isinstance(value, int) :
            INDENT
                value = uuid.UUID(int = value)
            DEDENT
            elif isinstance(value, str) :
            INDENT
                value = uuid.UUID(value)
            DEDENT
        DEDENT
    DEDENT
    if dialect.name == 'postgresql' :
    INDENT
        return str(value)
    DEDENT
    else :
    INDENT
        return value.bytes
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
183042_19935248_8_17
183042_812363_13_20
Title: How can I use UUIDs in SQLAlchemy? 
----------------------------------------

def process_bind_param(self, value, dialect = None) :
INDENT
    if value and isinstance(value, uuid.UUID) :
    INDENT
        return value.bytes
    DEDENT
    elif value and isinstance(value, basestring) :
    INDENT
        return uuid.UUID(value).bytes
    DEDENT
    elif value :
    INDENT
        raise ValueError('value %s is not a valid uuid.UUId' % value)
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def process_bind_param(self, value, dialect = None) :
INDENT
    if value and isinstance(value, uuid.UUID) :
    INDENT
        return value.bytes
    DEDENT
    elif value and not isinstance(value, uuid.UUID) :
    INDENT
        raise ValueError, 'value %s is not a valid uuid.UUID' % value
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
183042_30604002_21_36
183042_812363_13_20
Title: How can I use UUIDs in SQLAlchemy? 
----------------------------------------

def process_bind_param(self, value, dialect) :
INDENT
    if value is None :
    INDENT
        return value
    DEDENT
    else :
    INDENT
        if not isinstance(value, uuid.UUID) :
        INDENT
            if isinstance(value, bytes) :
            INDENT
                value = uuid.UUID(bytes = value)
            DEDENT
            elif isinstance(value, int) :
            INDENT
                value = uuid.UUID(int = value)
            DEDENT
            elif isinstance(value, str) :
            INDENT
                value = uuid.UUID(value)
            DEDENT
        DEDENT
    DEDENT
    if dialect.name == 'postgresql' :
    INDENT
        return str(value)
    DEDENT
    else :
    INDENT
        return value.bytes
    DEDENT
DEDENT
----------------------------------------

def process_bind_param(self, value, dialect = None) :
INDENT
    if value and isinstance(value, uuid.UUID) :
    INDENT
        return value.bytes
    DEDENT
    elif value and not isinstance(value, uuid.UUID) :
    INDENT
        raise ValueError, 'value %s is not a valid uuid.UUID' % value
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
183042_30604002_37_43
183042_812363_21_26
Title: How can I use UUIDs in SQLAlchemy? 
----------------------------------------

def process_result_value(self, value, dialect) :
INDENT
    if value is None :
    INDENT
        return value
    DEDENT
    if dialect.name == 'postgresql' :
    INDENT
        return uuid.UUID(value)
    DEDENT
    else :
    INDENT
        return uuid.UUID(bytes = value)
    DEDENT
DEDENT
----------------------------------------

def process_result_value(self, value, dialect = None) :
INDENT
    if value :
    INDENT
        return uuid.UUID(bytes = value)
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18317416_18320343_1_11
18317416_18325444_2_18
Title: How to move the Tastypie meta information out to the http headers 
----------------------------------------

def create_response(self, request, data, response_class = HttpResponse, ** response_kwargs) :
INDENT
    stripped_data = data.get('objects') or data
    desired_format = self.determine_format(request)
    serialized = self.serialize(request, stripped_data, desired_format)
    response = response_class(content = serialized,
        content_type = build_content_type(desired_format),
        ** response_kwargs)
    for name, value in data.get('meta', {}).items() :
    INDENT
        response [name] = str(value)
    DEDENT
    return response
DEDENT
----------------------------------------

def create_response(self, request, data, response_class = HttpResponse, ** response_kwargs) :
INDENT
    try :
    INDENT
        stripped_data = data.get('objects')
    DEDENT
    except AttributeError :
    INDENT
        stripped_data = data
    DEDENT
    desired_format = self.determine_format(request)
    serialized = self.serialize(request, stripped_data, desired_format)
    response = response_class(content = serialized,
        content_type = build_content_type(desired_format),
        ** response_kwargs)
    try :
    INDENT
        for name, value in data.get('meta', {}).items() :
        INDENT
            response ['Meta-' + name.title().replace('_', '-')] = str(value)
        DEDENT
    DEDENT
    except AttributeError :
    INDENT
        response ['Meta-Empty'] = True
    DEDENT
    return response
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18325705_18325998_11_20
18325705_51807681_7_19
Title: Printing the number of days in a given month and year [Python] 
----------------------------------------

def days_in_month(year, month) :
INDENT
    if is_leap_year(year) and month == "February" :
    INDENT
        return 28
    DEDENT
    try :
    INDENT
        return days_in_month_dict [month]
    DEDENT
    except KeyError :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def days_in_month(month, year) :
INDENT
    if month == 'September' or month == 'April' or month == 'June' or month == 'November' :
    INDENT
        result = 30
    DEDENT
    elif month == 'January' or month == 'March' or month == 'May' or month == 'July' or month == 'August' or month == 'October' or month == 'December' :
    INDENT
        result = 31
    DEDENT
    elif month == 'February' and output.is_leap_year == True :
    INDENT
        result = 29
    DEDENT
    elif month == 'February' and output.is_leap_year == False :
    INDENT
        result = 28
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18328513_18328587_1_10
18328513_18328608_1_12
Title: To update the value of variable? 
----------------------------------------

def funct(h, l) :
INDENT
    r1 = []; r2 = []
    for i in range(len(l)) :
    INDENT
        if (l [i] < h) :
        INDENT
            r1.append(l [i])
        DEDENT
        else :
        INDENT
            r2.append(l [i])
        DEDENT
    DEDENT
    print r1
    print r2
DEDENT
----------------------------------------

def funct(h) :
INDENT
    l = [21, 23, 25, 30, 33, 45, 56, 67, 70, 77]
    r1 = []; r2 = []
    for x in l :
    INDENT
        if x < h :
        INDENT
            r1.append(x)
        DEDENT
        else :
        INDENT
            r2.append(x)
        DEDENT
    DEDENT
    print r1
    print r2
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18329376_18339394_22_29
18329376_18339394_2_10
Title: pyinstaller exe with pubsub 
----------------------------------------

def __init__(self, threadNum, asset, window) :
INDENT
    threading.Thread.__init__(self)
    self.threadNum = threadNum
    self.window = window
    self.asset = asset
    self.signal = True
    self.status = None
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Frame, self).__init__(* args, ** kwargs)
    self.InitUI()
    self.SetSize((380, 340))
    self.Show()
    self.count = 0
    self.threads = []
    pub.subscribe(self.__StatusChanged, 'status.changed')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18341867_18342240_8_27
18341867_18378540_8_27
Title: how to put a image as a background in wxpython 
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Panel.__init__(self, parent, id)
    try :
    INDENT

        image_file = 'roses.jpg'
        bmp1 = wx.Image(image_file, wx.BITMAP_TYPE_ANY).ConvertToBitmap()
        self.bitmap1 = wx.StaticBitmap(self, - 1, bmp1, (0, 0))
        str1 = "%s  %dx%d" % (image_file, bmp1.GetWidth(), bmp1.GetHeight())
        parent.SetTitle(str1)
    DEDENT
    except IOError :
    INDENT
        print "Image file %s not found" % imageFile
        raise SystemExit
    DEDENT
    self.button1 = wx.Button(self.bitmap1, id = - 1, label = 'Button1', pos = (8, 8))
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
    self.frame = parent
    sizer = wx.BoxSizer(wx.VERTICAL)
    hSizer = wx.BoxSizer(wx.HORIZONTAL)
    for num in range(4) :
    INDENT
        label = "Button %s" % num
        btn = wx.Button(self, label = label)
        sizer.Add(btn, 0, wx.ALL, 5)
    DEDENT
    hSizer.Add((1, 1), 1, wx.EXPAND)
    hSizer.Add(sizer, 0, wx.TOP, 100)
    hSizer.Add((1, 1), 0, wx.ALL, 75)
    self.SetSizer(hSizer)
    self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18351507_18352412_6_17
18351507_18353364_6_25
Title: recursive search of File Extension in File 
----------------------------------------

def parse_file_extension(gold_deck, depth) :
INDENT
    extention_list = ["lvs", "cir", "spx"]
    fspi = open(gold_deck, 'r+')
    for data in fspi :
    INDENT
        if data.startswith('.include') :
        INDENT
            data = data.split()
            netlist_file, netlist_file_extension = splitext(data [1].strip("'"))
            if netlist_file_extension not in extention_list :
            INDENT
                netlist_file = parse_file_extension(netlist_file, depth + 1)
            DEDENT
            return netlist_file
        DEDENT
    DEDENT
    fspi.close()
DEDENT
----------------------------------------

def parse_file_extension(gold_deck, found, count) :
INDENT
    extention_list = ["lvs", "cir", "spx"]
    with open(gold_deck, 'r+') as fspi :
    INDENT
        while 1 :
        INDENT
            data = fspi.readline()
            if not data :
            INDENT
                break
            DEDENT
            if data.startswith('.include') :
            INDENT
                data = data.split()
                netlist_file_extension = data [1].split(".") [- 1].strip("'")
                count = count + 1
                if netlist_file_extension in extention_list :
                INDENT
                    found = True
                    netlist_file = os.path.basename(data [1]).strip("'")
                    return netlist_file
                DEDENT
                else :
                INDENT
                    gold_deck = os.path.basename(data [1]).strip("'")
                    netlist_file = parse_file_extension(gold_deck, found, count)
                    return netlist_file
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18386391_39678356_12_17
18386391_49328607_7_16
Title: python making my own lower case converter 
----------------------------------------

def lowerString(string) :
INDENT
    result = ""
    for i in range(0, len(string)) :
    INDENT
        result = result + lowerChar(ord(string [i]))
    DEDENT
    return result
DEDENT
----------------------------------------

def lowerString(string) :
INDENT
    result = ""
    x = 0
    for i in string :
    INDENT
        while x < len(string) :
        INDENT
            result = result + lowerChar(string [x])
            x += 1
        DEDENT
        return result
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18386391_39678356_3_11
18386391_49328607_1_6
Title: python making my own lower case converter 
----------------------------------------

def lowerChar(char) :
INDENT
    if char > = 65 and char < = 90 :
    INDENT
        char = chr(char + 32)
        return char
    DEDENT
    else :
    INDENT
        char = chr(char)
        return char

    DEDENT
DEDENT
----------------------------------------

def lowerChar(c) :
INDENT
    if 'A' < = c < = 'Z' :
    INDENT
        return chr(ord(c) - ord('A') + ord('a'))
    DEDENT
    else :
    INDENT
        return c
    DEDENT
DEDENT
----------------------------------------
