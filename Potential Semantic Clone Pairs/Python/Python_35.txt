$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3931627_3931710_1_8
3931627_3932122_1_14
Title: How to build a decorator with optional parameters? 
----------------------------------------

def d(msg = 'my default message') :
INDENT
    def decorator(func) :
    INDENT
        def newfn() :
        INDENT
            print msg
            return func()
        DEDENT
        return newfn
    DEDENT
    return decorator
DEDENT
----------------------------------------

def d(arg) :
INDENT
    if callable(arg) :
    INDENT
        def newfn() :
        INDENT
            print 'my default message'
            return arg()
        DEDENT
        return newfn
    DEDENT
    else :
    INDENT
        def d2(fn) :
        INDENT
            def newfn() :
            INDENT
                print arg
                return fn()
            DEDENT
            return newfn
        DEDENT
        return d2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3931627_3931710_2_6
3931627_4408489_14_22
Title: How to build a decorator with optional parameters? 
----------------------------------------

def decorator(func) :
INDENT
    def newfn() :
    INDENT
        print msg
        return func()
    DEDENT
    return newfn
DEDENT
----------------------------------------

def decorator(method) :
INDENT
    def wrap(self) :
    INDENT
        private_attribute = get_attribute(method.__name__)
        try :
        INDENT
            return getattr(self, private_attribute)
        DEDENT
        except AttributeError :
        INDENT
            setattr(self, private_attribute, method(self))
            return getattr(self, private_attribute)
        DEDENT
    DEDENT
    return property(wrap)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39322137_39322649_29_48
39322137_39322649_9_16
Title: Python GTK: Add a button to a GUI with another button 
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self, title = "RGB 3, 2, 1... GO!")
    self.set_border_width(10)
    self.set_size_request(450, 150)
    grid = Gtk.Grid()
    self.add(grid)
    self.draw_button = Gtk.Button(label = "Draw Card")
    self.draw_button.connect("clicked", self.on_draw_button_clicked)
    grid.attach(self.draw_button, 0, 0, 1, 1)
    end_button = Gtk.Button(label = "End Game")
    end_button.connect("clicked", self.on_stop_button_clicked)
    grid.attach_next_to(end_button, self.draw_button, Gtk.PositionType.RIGHT, 1, 1)
    update_button = Gtk.Button(label = "Update")
    update_button.connect("clicked", self.update, grid)
    grid.attach_next_to(update_button, end_button, Gtk.PositionType.RIGHT, 1, 1)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    deck = []
    self.color_list = ["red", "green", "blue"]
    for color in self.color_list :
    INDENT
        for i in range(1, 2) :
        INDENT
            deck.append((color, i))
        DEDENT
    DEDENT
    self.deck = deck
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39337652_39337750_1_14
39337652_39337824_1_11
Title: C function to Python (different results) 
----------------------------------------

def whiten(data, whitenCoeff) :
INDENT
    idx = len(data)
    while (idx > 0) :
    INDENT
        m = 0x01
        for i in range(0, 8) :
        INDENT
            if (whitenCoeff & 0x80) :
            INDENT
                whitenCoeff ^= 0x11
                data [- idx] ^= m
            DEDENT
            whitenCoeff = (whitenCoeff < < 1) & 0xFF
            m <<= 0x01
        DEDENT
        idx = idx - 1

    DEDENT
DEDENT
----------------------------------------

def whiten(data, whitenCoeff) :
INDENT
    for index in range(len(data)) :
    INDENT
        for i in range(8) :
        INDENT
            if (whitenCoeff & 0x80) :
            INDENT
                whitenCoeff ^= 0x11
                data [index] ^= (1 < < i)
            DEDENT
            whitenCoeff = (whitenCoeff < < 1) & 0xff
        DEDENT
    DEDENT
    return data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39359390_39360463_15_29
39359390_39361580_15_31
Title: How to use yaml.load_all with fileinput.input? 
----------------------------------------

def read(self, size = - 1) :
INDENT
    while True :
    INDENT
        data = self.fd.read(size)
        if data :
        INDENT
            break
        DEDENT
        else :
        INDENT
            try :
            INDENT
                self.fd = self.fditer.next()
            DEDENT
            except StopIteration :
            INDENT
                self.fd = None
                break
            DEDENT
        DEDENT
    DEDENT
    return data
DEDENT
----------------------------------------

def read(self, size) :
INDENT
    if len(self._buf) > = size :
    INDENT

        tmp, self._buf = self._buf [: size], self._buf [size :]
        return tmp
    DEDENT
    for line in self._fip :
    INDENT
        self._buf += line
        if len(self._buf) > size :
        INDENT
            break
        DEDENT
    DEDENT
    else :
    INDENT

        tmp, self._buf = self._buf, ''
        return tmp
    DEDENT
    tmp, self._buf = self._buf [: size], self._buf [size :]
    return tmp

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39359599_39359689_3_18
39359599_39364477_13_27
Title: How can I reverse parts of sentence in python? 
----------------------------------------

def main(sentence, ignores) :
INDENT
    ignores = frozenset(ignores)

    pat = r'|'.join(map(re.escape, ignores)) + r'|\S+|\s+'

    parts = re.findall(pat, sentence)

    return ''.join(p if p in ignores else p [: : - 1] for p in parts)
DEDENT
----------------------------------------

def main(sentence, ignores) :
INDENT
    spans = sorted(
        [[m.span() for m in re.finditer(p, sentence)] [0] for p in ignores if p in sentence])
    spans = [s for s in _span_combiner(spans)]
    ignores = [sentence [s [0] : s [1]] for s in spans]
    for phrase in ignores :
    INDENT
        reversed_phrase = ' '.join([word [: : - 1] for word in phrase.split()])
        sentence = sentence.replace(phrase, reversed_phrase)
    DEDENT
    return ' '.join(word [: : - 1] for word in sentence.split())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39363195_39413644_1_14
39363195_46996910_1_35
Title: To check if a list of numbers is arithmetic or geometric with python 
----------------------------------------

def arith_geo(list_n) :
INDENT
    if len(list_n) == 0 :
    INDENT
        return 0
    DEDENT
    diff = list_n [1] - list_n [0]
    div = list_n [1] / list_n [0]
    for num in range(1, len(list_n)) :
    INDENT
        if list_n [num] - list_n [num - 1] == diff :
        INDENT
            counter = 'Arithmetic'
        DEDENT
        elif list_n [num] / list_n [num - 1] == div :
        INDENT
            counter = 'Geometric'
        DEDENT
        else :
        INDENT
            counter = - 1
            break
        DEDENT
    DEDENT
    return counter
DEDENT
----------------------------------------

def arith_geo(list_n) :
INDENT
    if len(list_n) < 2 :
    INDENT
        return "Not a progression - the list is too short"

    DEDENT
    states = ['Arithmetic', 'Geometric']
    b1, b2 = list_n [: 2]
    adj_elements = list(zip(list_n [1 :], list_n [2 :]))

    if not all(y - x == b2 - b1 for x, y in adj_elements) :
    INDENT
        states.remove('Arithmetic')

    DEDENT
    if b1 * b2 == 0 or not all(y / x == b2 / b1 for x, y in adj_elements) :
    INDENT
        states.remove('Geometric')

    DEDENT
    state_message = {0 : "Neither arithmetic nor geometric",
        2 : "Both arithmetic and geometric",
        1 : (states + ['']) [0]}
    return state_message [len(states)]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39390157_39390508_12_23
39390157_39390515_9_15
Title: Can't pass a list as class attribute 
----------------------------------------

def __next__(self) :
INDENT
    if self.index > = len(self.ingredient_list) :
    INDENT
        raise StopIteration
    DEDENT
    ingredient = self.ingredient_list [self.index]
    self.index += 1
    if ingredient in Vegan.NONE_VEGAN_INGREDIENT :
    INDENT
        return ('{} is a vegan ingredient'.format(ingredient))
    DEDENT
    else :
    INDENT
        return ('{} is NOT a vegan ingredient'.format(ingredient))
    DEDENT
DEDENT
----------------------------------------

def __next__(self) :
INDENT
    ingredient = next(self.ingredient_iter)
    if ingredient in Vegan.NONE_VEGAN_INGREDIENT :
    INDENT
        return '{} is a vegan ingredient'.format(ingredient)
    DEDENT
    return '{} is NOT a vegan ingredient'.format(ingredient)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39390157_39390515_9_15
39390157_39390832_12_20
Title: Can't pass a list as class attribute 
----------------------------------------

def __next__(self) :
INDENT
    ingredient = next(self.ingredient_iter)
    if ingredient in Vegan.NONE_VEGAN_INGREDIENT :
    INDENT
        return '{} is a vegan ingredient'.format(ingredient)
    DEDENT
    return '{} is NOT a vegan ingredient'.format(ingredient)

DEDENT
----------------------------------------

def __next__(self) :
INDENT
    if self.index == len(self.ingredient_list) - 1 :
    INDENT
        raise StopIteration
    DEDENT
    self.index += 1
    if self.ingredient_list [self.index] in Vegan.NONE_VEGAN_INGREDIENT :
    INDENT
        return ('{} is a vegan ingredient'.format(self.ingredient_list [self.index]))
    DEDENT
    else :
    INDENT
        return ('{} is NOT a vegan ingredient'.format(self.ingredient_list [self.index]))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39390418_39391133_3_15
39390418_39391238_3_9
Title: Python: How can I enable use of kwargs when calling from command line? (perhaps with argparse) 
----------------------------------------

def main(foo, bar, * args) :
INDENT
    print "Called my script with"
    print "foo = %s" % foo
    print "bar = %s" % bar
    for arg in args :
    INDENT
        k = arg.split("=") [0]
        v = arg.split("=") [1]
        print "Keyword argument: %s = %s" % (k, v)
    DEDENT
DEDENT
----------------------------------------

def main(foo, bar, ** kwargs) :
INDENT
    print ('Called myscript with:')
    print ('foo = {}'.format(foo))
    print ('bar = {}'.format(bar))
    for k, v in kwargs.items() :
    INDENT
        print ('keyword argument: {} = {}'.format(k, v))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39391007_39392144_1_36
39391007_39392602_1_20
Title: Finding craters [descending/ ascending ints] in a python list of ints 
----------------------------------------

def find_crater(my_list) :
INDENT
    previous = None
    current_crater = []
    crater_list = []
    for elem in my_list :
    INDENT
        if not previous :
        INDENT
            previous = elem
            continue
        DEDENT
        if len(current_crater) == 0 :
        INDENT
            if elem > previous :
            INDENT
                previous = elem
            DEDENT
            else :
            INDENT
                current_crater.append(previous)
                previous = elem
            DEDENT
        DEDENT
        else :
        INDENT
            if elem > current_crater [0] :
            INDENT
                current_crater.append(previous)
                crater_list.append(current_crater)
                current_crater = []
                previous = elem
            DEDENT
            else :
            INDENT
                current_crater.append(previous)
                previous = elem
            DEDENT
        DEDENT
    DEDENT
    if len(current_crater) ! = 0 :
    INDENT
        if elem > current_crater [0] :
        INDENT
            current_crater.append(previous)
            crater_list.append(current_crater)
        DEDENT
        else :
        INDENT
            current_crater.append(previous)
            crater_list.append(current_crater)
        DEDENT
    DEDENT
    return crater_list
DEDENT
----------------------------------------

def find_crater(l) :
INDENT
    result = []
    start_index = 0
    for i in range(start_index + 1, len(l)) :
    INDENT
        start = l [start_index]
        if i == len(l) - 1 and l [i] ! = start :
        INDENT
            result = l [start_index : i + 1]
            print result
        DEDENT
        elif l [i] == start :
        INDENT
            end_index = i + 1
            result = l [start_index : end_index]
            start_index = end_index + 1
            if len(result) > 1 :
            INDENT
                print result
            DEDENT
        DEDENT
        elif l [i] > start :
        INDENT
            end_index = i
            result = l [start_index : end_index]
            start_index = end_index
            if len(result) > 1 :
            INDENT
                print result
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39432551_39432663_1_10
39432551_39432675_1_12
Title: Error: Unsupported Operand Types 
----------------------------------------

def dot(L, K) :
INDENT
    if L + K == [] or len(L) ! = len(K) :
    INDENT
        return 0
    DEDENT
    return dot_recurse(L, K)
    def dot_recurse(L, K) :
    INDENT
        if len(L) > 0 :
        INDENT
            return L [- 1] * K [- 1] + dot_recurse(L [: - 1], K [: - 1])
        DEDENT
        else :
        INDENT
            return 0;
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def dot(L, K) :
INDENT
    if len(L) ! = len(K) :
    INDENT
        raise ValueError('Can not perform dot product on two differently sized lists')
    DEDENT
    elif len(L) + len(K) == 0 :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        return L [- 1] * K [- 1] + dot(L [: - 1], K [: - 1])

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39433761_39433958_9_21
39433761_39434124_10_23
Title: How can I make a while loop only run a limited number of times? 
----------------------------------------

def roll() :
INDENT
    global yscore
    global ascore
    if deal == "!" :
    INDENT
        print (ydeal)
        print (adeal)
        if ydeal > adeal :
        INDENT
            yscore += 1
        DEDENT
        elif ydeal < adeal :
        INDENT
            ascore += 1
        DEDENT
        print (yscore, ascore)
    DEDENT
DEDENT
----------------------------------------

def roll() :
INDENT
    global yscore, ascore, draw
    if deal == "Deal" :
    INDENT
        for x in range(52) :
        INDENT
            yydeal = ydeal()
            aadeal = adeal()
            if yydeal > aadeal :
            INDENT
                yscore += 1
            DEDENT
            elif yydeal < aadeal :
            INDENT
                ascore += 1
            DEDENT
            else :
            INDENT
                draw += 1
            DEDENT
            print ("Score:", yscore, ascore, draw)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39433761_39434124_10_23
39433761_39434202_7_22
Title: How can I make a while loop only run a limited number of times? 
----------------------------------------

def roll() :
INDENT
    global yscore, ascore, draw
    if deal == "Deal" :
    INDENT
        for x in range(52) :
        INDENT
            yydeal = ydeal()
            aadeal = adeal()
            if yydeal > aadeal :
            INDENT
                yscore += 1
            DEDENT
            elif yydeal < aadeal :
            INDENT
                ascore += 1
            DEDENT
            else :
            INDENT
                draw += 1
            DEDENT
            print ("Score:", yscore, ascore, draw)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def roll() :
INDENT
    global yscore
    global ascore
    if deal == "!" :
    INDENT
        while (yscore < max_score and ascore < max_score) :
        INDENT
            ydeal = random.randint(1, 9)
            adeal = random.randint(1, 9)
            print (ydeal)
            print (adeal)
            if ydeal > adeal :
            INDENT
                yscore += 1
            DEDENT
            elif ydeal < adeal :
            INDENT
                ascore += 1
            DEDENT
            print (yscore, ascore)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39442058_39442266_5_27
39442058_39442352_6_34
Title: Scraping several pages with BeautifulSoup 
----------------------------------------

def category_crawler() :
INDENT
    pager = 1
    while pager < 11 :
    INDENT
        theurl = "http://www.worldofquotes.com/topic/Art/" + str(pager) + "/index.html"
        thepage = requests.get(theurl, allow_redirects = False).text
        soup = BeautifulSoup(thepage, "html.parser")
        for link in soup.find_all('blockquote') :
        INDENT
            sanitized = link.find('p').text.strip()
            spantext = link.find('a')
            writer = spantext.find('span').text
            if not sanitized :
            INDENT
                break
            DEDENT
            print (sanitized)
            print (writer)
            print ('---------------------------------------------------------')
        DEDENT
        pager += 1
    DEDENT
DEDENT
----------------------------------------

def category_crawler() :
INDENT
    urlarchive = [];
    pager = 1
    while True :
    INDENT
        theurl = "http://www.worldofquotes.com/topic/Nature/" + str(pager) + "/index.html"
        thepage = None;
        try :
        INDENT
            thepage = urllib.request.urlopen(theurl)
            if thepage.geturl() in urlarchive :
            INDENT
                break;
            DEDENT
            else :
            INDENT
                urlarchive.append(thepage.geturl());
                print (pager);
            DEDENT
        DEDENT
        except :
        INDENT
            break;
        DEDENT
        soup = BeautifulSoup(thepage, "html.parser")
        for link in soup.findAll('blockquote') :
        INDENT
            sanitized = link.find('p').text.strip()
            spantext = link.find('a')
            writer = spantext.find('span').text
            print (sanitized)
            print (writer)
            print ('---------------------------------------------------------')
        DEDENT
        pager += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39445818_39446360_7_21
39445818_39446446_1_21
Title: Python: reference variable in nested function's outer scope (not global) 
----------------------------------------

def get_path(root, data, path) :
INDENT
    def pre_order(tree, path) :
    INDENT
        if tree is None :
        INDENT
            return
        DEDENT
        path.append(tree ['val'])
        if tree ['val'] == data :
        INDENT
            return path
        DEDENT
        return pre_order(tree ['left'], path [:]) or pre_order(tree ['right'], path [:])
    DEDENT
    desired_result = pre_order(root, [])
    return desired_result
DEDENT
----------------------------------------

def get_path(root, data, path) :
INDENT
    def pre_order(tree) :
    INDENT
        if not tree :
        INDENT
            return []
        DEDENT
        elif tree ['val'] == data :
        INDENT
            return [data]
        DEDENT
        else :
        INDENT

            path = pre_order(tree ['left']) or pre_order(tree ['right'])
            if path :
            INDENT

                path.append(tree ['val'])
            DEDENT
            return path
        DEDENT
    DEDENT
    final_path = pre_order(root)
    final_path.reverse()
    print ('finalpath', final_path)
    return final_path
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39445818_39446360_9_18
39445818_39446446_3_17
Title: Python: reference variable in nested function's outer scope (not global) 
----------------------------------------

def pre_order(tree, path) :
INDENT
    if tree is None :
    INDENT
        return
    DEDENT
    path.append(tree ['val'])
    if tree ['val'] == data :
    INDENT
        return path
    DEDENT
    return pre_order(tree ['left'], path [:]) or pre_order(tree ['right'], path [:])
DEDENT
----------------------------------------

def pre_order(tree) :
INDENT
    if not tree :
    INDENT
        return []
    DEDENT
    elif tree ['val'] == data :
    INDENT
        return [data]
    DEDENT
    else :
    INDENT

        path = pre_order(tree ['left']) or pre_order(tree ['right'])
        if path :
        INDENT

            path.append(tree ['val'])
        DEDENT
        return path
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456289_1_7
39456149_39456450_1_7
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_iter(times, data) :
INDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data for _ in range(times)]
DEDENT
----------------------------------------

def replicate_iter(times, data) :
INDENT
    result = []
    for _ in range(times) :
    INDENT
        result.append(data)
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456289_1_7
39456149_39459754_1_12
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_iter(times, data) :
INDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data for _ in range(times)]
DEDENT
----------------------------------------

def replicate_iter(times, data) :
INDENT
    if ((not isinstance(times, int)) or (not isinstance(data, (int, float, long, complex, str)))) :
    INDENT
        raise ValueError("Invalid arguments")
    DEDENT
    elif (times < = 0) :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        array = []
        for x in range(times) :
        INDENT
            array.append(data)
        DEDENT
        return array

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456289_1_7
39456149_41632013_1_12
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_iter(times, data) :
INDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data for _ in range(times)]
DEDENT
----------------------------------------

def replicate_iter(times, data) :
INDENT
    Array = []
    if type(times) ! = int or not isinstance(data, (int, float, complex, str)) :
    INDENT
        raise ValueError('Invalid Value')
    DEDENT
    elif times < 0 :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        for x in range(times) :
        INDENT
            Array.append(data)
        DEDENT
        return Array

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456289_8_13
39456149_39456450_8_13
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data] + replicate_recur(times - 1, data)
DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data] + replicate_recur(times - 1, data)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456289_8_13
39456149_39459754_13_19
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data] + replicate_recur(times - 1, data)
DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if ((not isinstance(times, int)) or (not isinstance(data, (int, float, long, complex, str)))) :
    INDENT
        raise ValueError("Invalid arguments")
    DEDENT
    elif (times < = 0) :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        return ([data] + replicate_recur((times - 1), data))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456289_8_13
39456149_39462465_1_12
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data] + replicate_recur(times - 1, data)
DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    def f(n, value) :
    INDENT
        if n < 1 :
        INDENT
            return []
        DEDENT
        result = f(n / / 2, value) * 2
        if n % 2 > 0 :
        INDENT
            result += [value]
        DEDENT
        return result
    DEDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    return f(times, data)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456289_8_13
39456149_41632013_13_22
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data] + replicate_recur(times - 1, data)
DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    Array = []
    if type(times) ! = int or not isinstance(data, (int, float, complex, str)) :
    INDENT
        raise ValueError('Invalid Value')
    DEDENT
    elif times < = 0 :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        Array = replicate_recur(times - 1, data)
        Array.append(data)
    DEDENT
    return Array
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456450_1_7
39456149_39459754_1_12
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_iter(times, data) :
INDENT
    result = []
    for _ in range(times) :
    INDENT
        result.append(data)
    DEDENT
    return result

DEDENT
----------------------------------------

def replicate_iter(times, data) :
INDENT
    if ((not isinstance(times, int)) or (not isinstance(data, (int, float, long, complex, str)))) :
    INDENT
        raise ValueError("Invalid arguments")
    DEDENT
    elif (times < = 0) :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        array = []
        for x in range(times) :
        INDENT
            array.append(data)
        DEDENT
        return array

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456450_1_7
39456149_41632013_1_12
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_iter(times, data) :
INDENT
    result = []
    for _ in range(times) :
    INDENT
        result.append(data)
    DEDENT
    return result

DEDENT
----------------------------------------

def replicate_iter(times, data) :
INDENT
    Array = []
    if type(times) ! = int or not isinstance(data, (int, float, complex, str)) :
    INDENT
        raise ValueError('Invalid Value')
    DEDENT
    elif times < 0 :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        for x in range(times) :
        INDENT
            Array.append(data)
        DEDENT
        return Array

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456450_8_13
39456149_39459754_13_19
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data] + replicate_recur(times - 1, data)

DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if ((not isinstance(times, int)) or (not isinstance(data, (int, float, long, complex, str)))) :
    INDENT
        raise ValueError("Invalid arguments")
    DEDENT
    elif (times < = 0) :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        return ([data] + replicate_recur((times - 1), data))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456450_8_13
39456149_39462465_1_12
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data] + replicate_recur(times - 1, data)

DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    def f(n, value) :
    INDENT
        if n < 1 :
        INDENT
            return []
        DEDENT
        result = f(n / / 2, value) * 2
        if n % 2 > 0 :
        INDENT
            result += [value]
        DEDENT
        return result
    DEDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    return f(times, data)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39456450_8_13
39456149_41632013_13_22
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if times < = 0 :
    INDENT
        return []
    DEDENT
    return [data] + replicate_recur(times - 1, data)

DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    Array = []
    if type(times) ! = int or not isinstance(data, (int, float, complex, str)) :
    INDENT
        raise ValueError('Invalid Value')
    DEDENT
    elif times < = 0 :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        Array = replicate_recur(times - 1, data)
        Array.append(data)
    DEDENT
    return Array
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39459754_13_19
39456149_39462465_1_12
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if ((not isinstance(times, int)) or (not isinstance(data, (int, float, long, complex, str)))) :
    INDENT
        raise ValueError("Invalid arguments")
    DEDENT
    elif (times < = 0) :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        return ([data] + replicate_recur((times - 1), data))
    DEDENT
DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    def f(n, value) :
    INDENT
        if n < 1 :
        INDENT
            return []
        DEDENT
        result = f(n / / 2, value) * 2
        if n % 2 > 0 :
        INDENT
            result += [value]
        DEDENT
        return result
    DEDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    return f(times, data)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39459754_13_19
39456149_41632013_13_22
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    if ((not isinstance(times, int)) or (not isinstance(data, (int, float, long, complex, str)))) :
    INDENT
        raise ValueError("Invalid arguments")
    DEDENT
    elif (times < = 0) :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        return ([data] + replicate_recur((times - 1), data))
    DEDENT
DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    Array = []
    if type(times) ! = int or not isinstance(data, (int, float, complex, str)) :
    INDENT
        raise ValueError('Invalid Value')
    DEDENT
    elif times < = 0 :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        Array = replicate_recur(times - 1, data)
        Array.append(data)
    DEDENT
    return Array
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39456149_39462465_1_12
39456149_41632013_13_22
Title: Python Recursion vs Iteration 
----------------------------------------

def replicate_recur(times, data) :
INDENT
    def f(n, value) :
    INDENT
        if n < 1 :
        INDENT
            return []
        DEDENT
        result = f(n / / 2, value) * 2
        if n % 2 > 0 :
        INDENT
            result += [value]
        DEDENT
        return result
    DEDENT
    if not isinstance(data, int) and not isinstance(data, str) :
    INDENT
        raise ValueError('Must be int or str')
    DEDENT
    return f(times, data)
DEDENT
----------------------------------------

def replicate_recur(times, data) :
INDENT
    Array = []
    if type(times) ! = int or not isinstance(data, (int, float, complex, str)) :
    INDENT
        raise ValueError('Invalid Value')
    DEDENT
    elif times < = 0 :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        Array = replicate_recur(times - 1, data)
        Array.append(data)
    DEDENT
    return Array
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39473259_39473611_1_13
39473259_39473735_3_14
Title: How to append even and odd chars python 
----------------------------------------

def encrypt(plain) :
INDENT
    alphabet = 'abcdefghijklmnopqrwstuvwxyz'
    answer = ''
    for letter in plain :
    INDENT
        try :
        INDENT
            if alphabet.index(letter.lower()) % 2 == 0 :
            INDENT
                answer += pycipher.Affine(7, 6).encipher(letter)
            DEDENT
            else :
            INDENT
                answer += pycipher.Affine(3, 0).encipher(letter)
            DEDENT
        DEDENT
        except :
        INDENT
            answer += letter
        DEDENT
    DEDENT
    return answer
DEDENT
----------------------------------------

def encrypt(plain) :
INDENT
    fs = [pycipher.Affine(3, 0).encipher,
        pycipher.Affine(7, 6).encipher]
    is_even = True
    d = dict()
    for ch in string.ascii_lowercase :
    INDENT
        f = fs [is_even]
        d [ch] = f(ch)
        is_even = not is_even
    DEDENT
    return ''.join([d [ch] for ch in plain])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39515934_39516690_1_18
39515934_39516742_1_15
Title: Cryptography: converting C function to python 
----------------------------------------

def Encrypt(key, pPlainBuffer) :
INDENT
    nKeyPos = 0
    KeyA = 0
    if pPlainBuffer is not None :
    INDENT
        pCipherBuffer = []
        for n in range(20) :
        INDENT
            KeyA = KeyA ^ key [n]
        DEDENT
        nKeyPos = KeyA % 20
        for n in range(len(pPlainBuffer)) :
        INDENT
            pCipherBuffer.append(pPlainBuffer [n] ^ (key [nKeyPos] * KeyA))
            KeyA += pCipherBuffer [n]
            nKeyPos = pCipherBuffer [n] % 20
        DEDENT
        return pCipherBuffer

    DEDENT
DEDENT
----------------------------------------

def Encrypt(plainText, key) :
INDENT
    keyA = 0
    for letter in key :
    INDENT
        keyA ^= ord(letter)
    DEDENT
    keyA = keyA & 0xFF
    key = itertools.cycle(key)
    codedText = ""
    for letter, keyCode in zip(plainText, key) :
    INDENT
        xorVal = (ord(keyCode) * keyA) & 0xFF
        newLetter = chr((ord(letter) ^ xorVal) & 0xFF)
        codedText += newLetter
        keyA += ord(newLetter)
        keyA = keyA & 0xFF
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3953216_3953232_1_17
3953216_3954113_1_8
Title: Getting local variables of function 
----------------------------------------

def needs_privilege(privilege, project = None) :
INDENT
    def validate(func, self, * args, ** kwargs) :
    INDENT
        try : check(self.user, privilege, project)
        except AccessDenied :
        INDENT
            return abort(status_code = 401)
        DEDENT
        else :
        INDENT
            return func(self, privilege, * args, ** kwargs)
        DEDENT
    DEDENT
    return decorator(validate)
DEDENT
----------------------------------------

def needs_privilege(privilege, project = None) :
INDENT
    def validate(func) :
    INDENT
        def _validate(self, * args, ** kwargs) :
        INDENT
            return func(self, * args, ** kwargs)
        DEDENT
        _validate.decorator_args = (privilege, project)
        return _validate
    DEDENT
    return validate
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3953216_3953232_8_15
3953216_3953412_8_14
Title: Getting local variables of function 
----------------------------------------

def validate(func, self, * args, ** kwargs) :
INDENT
    try : check(self.user, privilege, project)
    except AccessDenied :
    INDENT
        return abort(status_code = 401)
    DEDENT
    else :
    INDENT
        return func(self, privilege, * args, ** kwargs)
    DEDENT
DEDENT
----------------------------------------

def validate(func, self, * args, ** kwargs) :
INDENT
    try : check(self.user, privilege, project)
    except AccessDenied :
    INDENT
        return abort(status_code = 401)
    DEDENT
    else :
    INDENT
        return func(self, * args, ** kwargs)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3953216_3953232_8_15
3953216_3954113_2_6
Title: Getting local variables of function 
----------------------------------------

def validate(func, self, * args, ** kwargs) :
INDENT
    try : check(self.user, privilege, project)
    except AccessDenied :
    INDENT
        return abort(status_code = 401)
    DEDENT
    else :
    INDENT
        return func(self, privilege, * args, ** kwargs)
    DEDENT
DEDENT
----------------------------------------

def validate(func) :
INDENT
    def _validate(self, * args, ** kwargs) :
    INDENT
        return func(self, * args, ** kwargs)
    DEDENT
    _validate.decorator_args = (privilege, project)
    return _validate
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3953216_3953412_1_16
3953216_3954113_1_8
Title: Getting local variables of function 
----------------------------------------

def needs_privilege(privilege, project = None) :
INDENT
    def validate(func, self, * args, ** kwargs) :
    INDENT
        try : check(self.user, privilege, project)
        except AccessDenied :
        INDENT
            return abort(status_code = 401)
        DEDENT
        else :
        INDENT
            return func(self, * args, ** kwargs)
        DEDENT
    DEDENT
    validate.privelege = privelege
    return decorator(validate)
DEDENT
----------------------------------------

def needs_privilege(privilege, project = None) :
INDENT
    def validate(func) :
    INDENT
        def _validate(self, * args, ** kwargs) :
        INDENT
            return func(self, * args, ** kwargs)
        DEDENT
        _validate.decorator_args = (privilege, project)
        return _validate
    DEDENT
    return validate
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3953216_3953412_8_14
3953216_3954113_2_6
Title: Getting local variables of function 
----------------------------------------

def validate(func, self, * args, ** kwargs) :
INDENT
    try : check(self.user, privilege, project)
    except AccessDenied :
    INDENT
        return abort(status_code = 401)
    DEDENT
    else :
    INDENT
        return func(self, * args, ** kwargs)
    DEDENT
DEDENT
----------------------------------------

def validate(func) :
INDENT
    def _validate(self, * args, ** kwargs) :
    INDENT
        return func(self, * args, ** kwargs)
    DEDENT
    _validate.decorator_args = (privilege, project)
    return _validate
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3953749_3953827_3_8
3953749_3955269_4_11
Title: Python Fibonacci Generator 
----------------------------------------

def fib() :
INDENT
    a, b = 0, 1
    while 1 :
    INDENT
        yield a
        a, b = b, a + b
    DEDENT
DEDENT
----------------------------------------

def fib() :
INDENT
    a, b = 0, 1
    while True :
    INDENT
        yield a
        b = a + b
        yield b
        a = a + b
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39594436_39721556_229_245
39594436_39721556_28_48
Title: A diagram for fluxes and stores of a hydrological model 
----------------------------------------

def __init__(self, name, grid_size, from_storage, to_storage, amount = 0) :
INDENT
    self.name = name
    self.from_storage = from_storage
    self.to_storage = to_storage
    self.amount = amount
    self.grid_size = grid_size
    self.x_start, self.y_start, self.x_end, self.y_end, self.dx, self.dy = (
        self.calc_start_end_dx_dy())
DEDENT
----------------------------------------

def __init__(self, max_flux, max_storage, grid_size = 20, storages = None,
fluxes = None) :
INDENT
    if storages == None :
    INDENT
        self.storages = []
    DEDENT
    if fluxes == None :
    INDENT
        self.fluxes = []
    DEDENT
    self.max_flux = max_flux
    self.max_storage = max_storage
    self.grid_size = grid_size
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39594436_39721556_229_245
39594436_39721556_352_370
Title: A diagram for fluxes and stores of a hydrological model 
----------------------------------------

def __init__(self, name, grid_size, from_storage, to_storage, amount = 0) :
INDENT
    self.name = name
    self.from_storage = from_storage
    self.to_storage = to_storage
    self.amount = amount
    self.grid_size = grid_size
    self.x_start, self.y_start, self.x_end, self.y_end, self.dx, self.dy = (
        self.calc_start_end_dx_dy())
DEDENT
----------------------------------------

def __init__(self, name, grid_size, number, amount = 0, order = 0,
offset = 0) :
INDENT
    self.name = name
    self.amount = amount
    self.number = number
    self.order = order
    self.offset = offset
    self.grid_size = grid_size
    self.x, self.y = self.calculate_xy()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39594436_39721556_28_48
39594436_39721556_352_370
Title: A diagram for fluxes and stores of a hydrological model 
----------------------------------------

def __init__(self, max_flux, max_storage, grid_size = 20, storages = None,
fluxes = None) :
INDENT
    if storages == None :
    INDENT
        self.storages = []
    DEDENT
    if fluxes == None :
    INDENT
        self.fluxes = []
    DEDENT
    self.max_flux = max_flux
    self.max_storage = max_storage
    self.grid_size = grid_size
DEDENT
----------------------------------------

def __init__(self, name, grid_size, number, amount = 0, order = 0,
offset = 0) :
INDENT
    self.name = name
    self.amount = amount
    self.number = number
    self.order = order
    self.offset = offset
    self.grid_size = grid_size
    self.x, self.y = self.calculate_xy()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39599085_39599372_5_27
39599085_39599608_5_17
Title: Writing multiple lists to CSV rows in python 
----------------------------------------

def urls() :
INDENT
    urls = []
    titles = []
    counts = []
    last = []
    conn = sqlite3.connect('C:\Users\username\Desktop\History.sql')
    cursor = conn.execute("SELECT url, title, visit_count, last_visit_time from urls")
    for row in cursor :
    INDENT

        urls.append(row [0])
        titles.append(row [1])
        counts.append(row [2])
        last.append(row [3])
    DEDENT
    df = pandas.DataFrame({'URL' : urls,
            'Title' : titles,
            'Visit Count' : counts,
            'Last visit Time' : last})
    df.to_csv('historyulrs.csv', encoding = 'utf-8', index = False)
    conn.close()
DEDENT
----------------------------------------

def urls() :
INDENT
    conn = sqlite3.connect('C:\Users\username\Desktop\History.sql')
    c = conn.cursor()
    query = "SELECT url, title FROM urls"
    c.execute(query)
    data = c.fetchall()
    if data :
    INDENT
        with open("C:\Users\username\Desktop\\historyulrs.csv", 'w') as outfile :
        INDENT
            writer = csv.writer(outfile)
            writer.writerow(['URL', 'Title'])
            for entry in data :
            INDENT
                writer.writerow([str(entry [0]), str(entry [1])])
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39604193_39604696_11_20
39604193_39604696_1_7
Title: (python and jes) How to find the position of a character in a string if 2 characters are the same? 
----------------------------------------

def sumNumbers1(num1, num2) :
INDENT
    sum = num1 + num2
    pos = 1
    print ("the sum is", sum)
    for e in str(sum) :
    INDENT
        print ("digit", pos, "is", e)
        pos += 1

    DEDENT
DEDENT
----------------------------------------

def sumNumbers1(num1, num2) :
INDENT
    sum = num1 + num2
    print ("the sum is", sum)
    s = str(sum)
    for digit, i in enumerate(s, start = 1) :
    INDENT
        print ("digit ", digit, "is", i)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39635480_39636809_31_42
39635480_39637697_1_14
Title: Updating already existing json file python 
----------------------------------------

def updateJsonFile(filename, counter) :
INDENT
    with open('md5.json', 'r') as f :
    INDENT
        data = json.load(f)
    DEDENT
    subdata = data ['md5s']

    subdata [counter] ['filename'] = filename
    with open('md5.json', 'w') as f :
    INDENT
        f.write(json.dumps(data))
    DEDENT
DEDENT
----------------------------------------

def updateJsonFile(filename) :
INDENT
    jsonFile = open("md5.json", "r")
    data = json.load(jsonFile)
    jsonFile.close()
    for tmp in data ["md5s"] :
    INDENT
        if len(tmp ['filename']) == 0 :
        INDENT
            tmp ['filename'] = filename
            break
        DEDENT
    DEDENT
    else :
    INDENT
        data ["md5s"].append({'md5' : '', 'timestamp' : '', 'filename' : filename})
    DEDENT
    jsonFile = open("m.json", "w")
    json.dump(data, jsonFile)
    jsonFile.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39641229_39641852_1_10
39641229_39648238_1_11
Title: How to find a given element in nested lists? 
----------------------------------------

def exists(key, arg) :
INDENT
    for item in arg :
    INDENT
        if isinstance(item, list) :
        INDENT
            if exists(key, item) :
            INDENT
                return True
            DEDENT
        DEDENT
        else :
        INDENT
            if item == key :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def exists(key, seq) :
INDENT
    if not seq :
    INDENT
        return False
    DEDENT
    elif seq [0] == key :
    INDENT
        return True
    DEDENT
    if isinstance(seq [0], list) :
    INDENT
        return (exists(key, seq [0]) or exists(key, seq [1 :]))
    DEDENT
    else :
    INDENT
        return exists(key, seq [1 :])
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39641430_39641541_1_16
39641430_39641561_1_10
Title: open conditional python files but read data from one 
----------------------------------------

def bb(fname, species) :
INDENT
    if species in ('yeast', 'sc') :
    INDENT
        fname2 = 'file.txt'
    DEDENT
    elif species in ('human', 'hs') :
    INDENT
        fname2 = 'file2.txt'
    DEDENT
    else :
    INDENT
        raise ValueError("species received illegal value")
    DEDENT
    with open(fname2, 'rU') as pm :
    INDENT
        for line in pm :
        INDENT
            line = line.split()
            with open(fname, 'rU') as user :
            INDENT
                for e in user :
                INDENT
                    e = e.split()
                    if e [0] in line :
                    INDENT
                        print (line)
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def bb(fname, species) :
INDENT
    if species in ['yeast', 'sc', 'human', 'hs'] :
    INDENT
        pm = open('file.txt', 'rU')
        for line in pm :
        INDENT
            line = line.split()
            with open(fname, 'rU') as user :
            INDENT
                for e in user :
                INDENT
                    e = e.split()
                    if e [0] in line :
                    INDENT
                        print (line)
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39644748_39644792_4_33
39644748_39646218_2_31
Title: Notation for intervals? 
----------------------------------------

def __init__(self, interval) :
INDENT
    if isinstance(interval, Interval) :
    INDENT
        self.begin, self.end = interval.begin, interval.end
        self.begin_included = interval.begin_included
        self.end_included = interval.end_included
        return
    DEDENT
    number_re = '-?[0-9]+(?:.[0-9]+)?'
    interval_re = ('^\s*'
        + '(\[|\()'
        + '\s*'
        + '(' + number_re + ')'
        + '\s*,\s*'
        + '(' + number_re + ')'
        + '\s*'
        + '(\]|\))'
        + '\s*$')
    match = re.search(interval_re, interval)
    if match is None :
    INDENT
        raise ValueError('Got an incorrect string representation of an interval: {!r}'.format(interval))
    DEDENT
    opening_brecket, begin, end, closing_brecket = match.groups()
    self.begin, self.end = float(begin), float(end)
    if self.begin > = self.end :
    INDENT
        raise ValueError("Interval's begin shoud be smaller than it's end")
    DEDENT
    self.begin_included = opening_brecket == '['
    self.end_included = closing_brecket == ']'

DEDENT
----------------------------------------

def __init__(self, left_bracket, a, b, right_bracket) :
INDENT
    if len(left_bracket) ! = 1 or left_bracket not in '[(' :
    INDENT
        raise ValueError(
            'Unknown left bracket character: {!r}'.format(left_bracket))
    DEDENT
    if len(right_bracket) ! = 1 or right_bracket not in '])' :
    INDENT
        raise ValueError(
            'Unknown right bracket character: {!r}'.format(right_bracket))
    DEDENT
    if a < b :
    INDENT
        self.lower, self.upper = a, b
    DEDENT
    else :
    INDENT
        self.lower, self.upper = b, a
    DEDENT
    self.left_bracket, self.right_bracket = left_bracket, right_bracket
    if left_bracket == '[' :
    INDENT
        if right_bracket == ']' :
        INDENT
            self._contains = (
                lambda self, val : self.lower < = val < = self.upper)
        DEDENT
        else :
        INDENT
            self._contains = (
                lambda self, val : self.lower < = val < self.upper)
        DEDENT
    DEDENT
    else :
    INDENT
        if right_bracket == ']' :
        INDENT
            self._contains = (
                lambda self, val : self.lower < val < = self.upper)
        DEDENT
        else :
        INDENT
            self._contains = (
                lambda self, val : self.lower < val < self.upper)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39647583_39647979_1_18
39647583_39648209_1_14
Title: Tips for wrapping files faster 
----------------------------------------

def athwrap(athfpath, savefpath, fdirection) :
INDENT
    ath = []
    with open(athfpath, 'r') as file :
    INDENT
        for __ in range(7) :
        INDENT
            line = next(file)
        DEDENT
        nets = int(line [5 : 12])
        dt = float(line [17 : 25])
        ath = np.array((fdirection, npts, dt))

        for line in file :
        INDENT
            uys = [float(n) for n in line.split()]
            ath = np.hstack((ath, uys))
            if not os.path.isdir(savefpath) :
            INDENT
                os.makedirs(savefpath, exist_ok = True)
            DEDENT
            np.savetxt(savefpath + f [i, 15] + '.txt', ath, fmt = '%s')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def athwrap(athfpath, savefpath, fdirection) :
INDENT
    ath = []
    with open(athfpath, 'r') as file :
    INDENT
        for j, line in enumerate(file) :
        INDENT
            if j == 6 :
            INDENT
                npts = int(line [5 : 12])
                dt = float(line [17 : 25])
                ath = np.array((fdirection, npts, dt))
            DEDENT
            elif j > 6 :
            INDENT
                uys = [float(n) for n in line.split()]
                ath = np.hstack((ath, uys))
            DEDENT
        DEDENT
    DEDENT
    if not os.path.isdir(savefpath) :
    INDENT
        os.makedirs(savefpath, exist_ok = True)
    DEDENT
    np.savetxt(savefpath + f [i, 15] + '.txt', ath, fmt = '%s')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39650940_39663721_10_35
39650940_39663721_44_55
Title: How can I make the FigureCanvas fill the entire Figure in a matplotlib widget embedded in a pyqt GUI? 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    try :
    INDENT
        super(Terminal, self).__init__(parent)
        self.resize(1000, 800)
        self.figure = plt.figure(facecolor = 'black')

        self.myComboBox = QtGui.QComboBox()
        self.plotButton = QtGui.QPushButton('Plot')
        self.xMplWidget = MatplotlibWidget()
        self.plotButton.clicked.connect(self.plotCircles)
        layout = QtGui.QVBoxLayout()

        layout.addWidget(self.xMplWidget)
        layout.addWidget(self.myComboBox)
        layout.addWidget(self.plotButton)
        self.setLayout(layout)
    DEDENT
    except Exception as err :
    INDENT
        print ("Error in Terminal.init: Other - ", err)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent = None, title = 'Title', xlabel = 'x label', ylabel = 'y label', dpi = 100, hold = False) :
INDENT
    super(MatplotlibWidget, self).__init__(Figure())
    self.setParent(parent)
    self.figure = Figure(dpi = dpi)
    self.canvas = FigureCanvas(self.figure)
    self.theplot = self.figure.add_subplot(111)
    self.theplot.set_title(title)
    self.theplot.set_xlabel(xlabel)
    self.theplot.set_ylabel(ylabel)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39654153_39654967_1_16
39654153_39655255_3_17
Title: Can't figure out why this code runs perfect for input of 3 and breaks on 5. {homework} 
----------------------------------------

def middle1(size) :
INDENT
    count_middle1 = 0
    size_m1 = (size * 2)
    mid_1 = 1
    mid_2 = 1
    dots_a = int(size_m1 / 2)
    bslsh = "\\"
    fslsh = "/"
    while (count_middle1 ! = size) :
    INDENT
        print ("|" + ("." * dots_a) + ((fslsh + bslsh) * mid_1) + ("." * size_m1) + ((fslsh + bslsh) * mid_2) + ("." * dots_a) + "|")
        mid_1 += 1
        mid_2 += 1
        count_middle1 += 1
        dots_a -= 1
        size_m1 -= 2
    DEDENT
    print ("\n")
DEDENT
----------------------------------------

def middle1() :
INDENT
    count_middle1 = 0
    size_m1 = (size - 1) * 2
    mid_1 = 2
    mid_2 = 2
    dots_a = size - 1
    bslsh = "\\"
    fslsh = "/"
    while (count_middle1 < size) :
    INDENT
        print ("|" + ("." * (dots_a)) + ((fslsh + bslsh) * (mid_1 - 1)) + ("." * size_m1) + ((fslsh + bslsh) * (mid_2 - 1)) + ("." * (dots_a)) + "|")
        mid_1 += 1
        mid_2 += 1
        count_middle1 += 1
        dots_a -= 1
        size_m1 -= 2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3966303_16970862_4_12
3966303_3968517_5_13
Title: "TkInter slider: how to trigger the event only when the iteraction is complete?" 
----------------------------------------

def __init__(self) :
INDENT
    self.root = tk.Tk()
    self.slider = tk.Scale(self.root, from_ = 0, to = 256,
        orient = "horizontal")
    self.slider.bind("<ButtonRelease-1>", self.updateValue)
    self.slider.pack()
    self.root.mainloop()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = tk.Tk()
    self._job = None
    self.slider = tk.Scale(self.root, from_ = 0, to = 256,
        orient = "horizontal",
        command = self.updateValue)
    self.slider.pack()
    self.root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39672692_39672777_1_10
39672692_39672813_1_6
Title: Power Function using Loops 
----------------------------------------

def power_function(decimal, integer) :
INDENT
    num = 1
    if integer > 0 :
    INDENT
        for function in range(integer) :
        INDENT
            num = num * decimal
        DEDENT
    DEDENT
    if integer < 0 :
    INDENT
        num = 1.0
        for function in range(- integer) :
        INDENT
            num = num / decimal
        DEDENT
    DEDENT
    return num
DEDENT
----------------------------------------

def power_function(decimal, integer) :
INDENT
    num = 1
    for function in range(abs(integer)) :
    INDENT
        num = num * decimal if integer > 0 else num / decimal
    DEDENT
    return num
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39672692_39672777_1_10
39672692_41978151_1_15
Title: Power Function using Loops 
----------------------------------------

def power_function(decimal, integer) :
INDENT
    num = 1
    if integer > 0 :
    INDENT
        for function in range(integer) :
        INDENT
            num = num * decimal
        DEDENT
    DEDENT
    if integer < 0 :
    INDENT
        num = 1.0
        for function in range(- integer) :
        INDENT
            num = num / decimal
        DEDENT
    DEDENT
    return num
DEDENT
----------------------------------------

def power_function(decimal, integer) :
INDENT
    num = 1
    for function in range(abs(integer)) :
    INDENT
        if integer > 0 :
        INDENT
            num *= decimal
        DEDENT
        if integer < 0 :
        INDENT
            num *= 1.0 / decimal
        DEDENT
        if integer == 0 :
        INDENT
            num = 1
        DEDENT
    DEDENT
    return num
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39672692_39672813_1_6
39672692_41978151_1_15
Title: Power Function using Loops 
----------------------------------------

def power_function(decimal, integer) :
INDENT
    num = 1
    for function in range(abs(integer)) :
    INDENT
        num = num * decimal if integer > 0 else num / decimal
    DEDENT
    return num
DEDENT
----------------------------------------

def power_function(decimal, integer) :
INDENT
    num = 1
    for function in range(abs(integer)) :
    INDENT
        if integer > 0 :
        INDENT
            num *= decimal
        DEDENT
        if integer < 0 :
        INDENT
            num *= 1.0 / decimal
        DEDENT
        if integer == 0 :
        INDENT
            num = 1
        DEDENT
    DEDENT
    return num
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39691619_39691829_60_70
39691619_39691829_90_98
Title: "Python 3.4 tkinter not clearing frame after selecting a option from a menu" 
----------------------------------------

def mhello() :
INDENT
    oneMtext = oneMent.get()
    twoMtext = twoMent.get()
    threeMtext = threeMent.get()
    mtext = 0
    mtext = oneMtext + twoMtext
    mtext /= 2
    mtext *= threeMtext
    mlabel2 = Label(mGui, text = mtext).pack()
DEDENT
----------------------------------------

def mhello() :
INDENT
    oneMtext = oneMent.get()
    twoMtext = twoMent.get()
    mtext = 0
    mtext = oneMtext * twoMtext
    mtext /= 2
    mlabel2 = Label(mGui, text = mtext).pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39697245_39697655_3_16
39697245_39697692_3_17
Title: Append duplicate items at the end of list whithout changing the order 
----------------------------------------

def duplicate(alist) :
INDENT
    filtered, duplicates = [], []
    for element in alist :
    INDENT
        if element in filtered :
        INDENT
            duplicates.append(element)
            continue
        DEDENT
        filtered.append(element)
    DEDENT
    if not duplicates :
    INDENT
        print "No duplicate item found"
        return alist
    DEDENT
    return filtered + duplicates
DEDENT
----------------------------------------

def duplicate(a_list) :
INDENT
    list_length = len(a_list)
    duplicate = False
    checked = []
    for i in range(list_length) :
    INDENT
        if a_list.count(a_list [i]) > 1 :
        INDENT
            if a_list [i] not in checked :
            INDENT
                duplicate = True
                a_list.append(a_list [i])
                checked.append(a_list [i])
            DEDENT
        DEDENT
    DEDENT
    if duplicate == False :
    INDENT
        print ("No duplicate item found")
        return None
    DEDENT
    return a_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39697634_39713672_10_18
39697634_39713672_49_58
Title: Python Turtle Wait for Click 
----------------------------------------

def __init__(self, shape = turtle._CFG ["shape"], undobuffersize = turtle._CFG ["undobuffersize"], visible = turtle._CFG ["visible"]) :
INDENT
    if QueuedTurtle._screen is None :
    INDENT
        QueuedTurtle._screen = turtle.Screen()
    DEDENT
    self._screen.onclick(lambda * args : self.queue_pop())
    turtle.RawTurtle.__init__(self, QueuedTurtle._screen, shape = shape, undobuffersize = undobuffersize, visible = visible)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.t = QueuedTurtle()
    self.t.left(90)
    self.t.up()
    self.t.backward(100)
    self.t.down()
    self.t.color("green")
    self.tree(75)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
397125_36706549_316_336
397125_36706549_55_76
Title: Reading the target of a .lnk file in Python? 
----------------------------------------

def __init__(self, scContent, linkContentPos) :
INDENT
    self._networkProviderType = None
    self._deviceName = None
    self._netName = None
    (linkSize, flags, netNameOffset,
        devNameOffset, self._networkProviderType) = struct.unpack('IIIII', scContent [linkContentPos : linkContentPos + 20])

    if netNameOffset > 0x014 :
    INDENT
        (netNameOffsetUnicode, devNameOffsetUnicode) = struct.unpack('II', scContent [linkContentPos + 20 : linkContentPos + 28])
        self._netName = UnpackUnicodeZ('z', scContent [linkContentPos + netNameOffsetUnicode :]) [0]
        self._netName = self._netName.decode('utf-16')
        self._deviceName = UnpackUnicodeZ('z', scContent [linkContentPos + devNameOffsetUnicode :]) [0]
        self._deviceName = self._deviceName.decode('utf-16')
    DEDENT
    else :
    INDENT
        self._netName = UnpackZ('z', scContent [linkContentPos + netNameOffset :]) [0].decode('ascii')
        self._deviceName = UnpackZ('z', scContent [linkContentPos + devNameOffset :]) [0].decode('ascii')
    DEDENT
DEDENT
----------------------------------------

def __init__(self, scPath) :
INDENT
    self.scPath = Path(scPath)
    self._clsid = None
    self._lnkFlags = None
    self._lnkInfoFlags = None
    self._localBasePath = None
    self._commonPathSuffix = None
    self._commonNetworkRelativeLink = None
    self._name = None
    self._relativePath = None
    self._workingDir = None
    self._commandLineArgs = None
    self._iconLocation = None
    self._envTarget = None
    self._ParseLnkFile(self.scPath)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39715933_39716337_1_14
39715933_39723697_1_44
Title: How do I run a binary search for words that start with a certain letter? 
----------------------------------------

def binary_search(seq, t) :
INDENT
    min = 0
    max = len(seq) - 1
    while True :
    INDENT
        if max < min :
        INDENT
            return - 1
        DEDENT
        m = (min + max) / / 2
        if seq [m] [0] < t :
        INDENT
            min = m + 1
        DEDENT
        elif seq [m] [0] > t :
        INDENT
            max = m - 1
        DEDENT
        else :
        INDENT
            return m
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def binary_search(list, item) :
INDENT
    low_b = 0
    up_b = len(list) - 1
    found = False
    midPos = ((low_b + up_b) / / 2)
    if list [low_b] [0] == item :
    INDENT
        midPos = low_b
        found = True
    DEDENT
    elif list [up_b] [0] == item :
    INDENT
        midPos = up_b
        found = True
    DEDENT
    while True :
    INDENT
        if found :
        INDENT
            break;
        DEDENT
        if list [low_b] [0] > item :
        INDENT
            break
        DEDENT
        if list [up_b] [0] < item :
        INDENT
            break
        DEDENT
        if up_b < low_b :
        INDENT
            break;
        DEDENT
        midPos = ((low_b + up_b) / / 2)
        if list [midPos] [0] < item :
        INDENT
            low_b = midPos + 1
        DEDENT
        elif list [midPos] > item :
        INDENT
            up_b = midPos - 1
        DEDENT
        else :
        INDENT
            found = True
            break
        DEDENT
    DEDENT
    if found :
    INDENT
        while True :
        INDENT
            if midPos > 0 :
            INDENT
                if list [midPos] [0] == item :
                INDENT
                    midPos = midPos - 1
                    continue
                DEDENT
            DEDENT
            break;
        DEDENT
        while True :
        INDENT
            if midPos < len(list) :
            INDENT
                if list [midPos] [0] == item :
                INDENT
                    print list [midPos]
                    midPos = midPos + 1
                    continue
                DEDENT
            DEDENT
            break
        DEDENT
    DEDENT
    else :
    INDENT
        print ("The name was not in the list.")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3972158_15715828_12_22
3972158_15715828_35_51
Title: How to plot on my GUI 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MatplotlibWidget, self).__init__(parent)
    self.figure = Figure()
    self.canvas = FigureCanvasQTAgg(self.figure)
    self.axis = self.figure.add_subplot(111)
    self.layoutVertical = QtGui.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.canvas)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__(parent)
    self.pushButtonPlot = QtGui.QPushButton(self)
    self.pushButtonPlot.setText("Plot")
    self.pushButtonPlot.clicked.connect(self.on_pushButtonPlot_clicked)
    self.matplotlibWidget = MatplotlibWidget(self)
    self.layoutVertical = QtGui.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.pushButtonPlot)
    self.layoutVertical.addWidget(self.matplotlibWidget)
    self.threadSample = ThreadSample(self)
    self.threadSample.newSample.connect(self.on_threadSample_newSample)
    self.threadSample.finished.connect(self.on_threadSample_finished)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3972158_15715828_12_22
3972158_44720864_13_23
Title: How to plot on my GUI 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MatplotlibWidget, self).__init__(parent)
    self.figure = Figure()
    self.canvas = FigureCanvasQTAgg(self.figure)
    self.axis = self.figure.add_subplot(111)
    self.layoutVertical = QtGui.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.canvas)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MatplotlibWidget, self).__init__(parent)
    self.figure = Figure()
    self.canvas = FigureCanvasQTAgg(self.figure)
    self.axis = self.figure.add_subplot(111)
    self.layoutVertical = QtWidgets.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.canvas)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3972158_15715828_12_22
3972158_44720864_36_52
Title: How to plot on my GUI 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MatplotlibWidget, self).__init__(parent)
    self.figure = Figure()
    self.canvas = FigureCanvasQTAgg(self.figure)
    self.axis = self.figure.add_subplot(111)
    self.layoutVertical = QtGui.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.canvas)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__(parent)
    self.pushButtonPlot = QtWidgets.QPushButton(self)
    self.pushButtonPlot.setText("Plot")
    self.pushButtonPlot.clicked.connect(self.on_pushButtonPlot_clicked)
    self.matplotlibWidget = MatplotlibWidget(self)
    self.layoutVertical = QtWidgets.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.pushButtonPlot)
    self.layoutVertical.addWidget(self.matplotlibWidget)
    self.threadSample = ThreadSample(self)
    self.threadSample.newSample.connect(self.on_threadSample_newSample)
    self.threadSample.finished.connect(self.on_threadSample_finished)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3972158_15715828_35_51
3972158_44720864_13_23
Title: How to plot on my GUI 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__(parent)
    self.pushButtonPlot = QtGui.QPushButton(self)
    self.pushButtonPlot.setText("Plot")
    self.pushButtonPlot.clicked.connect(self.on_pushButtonPlot_clicked)
    self.matplotlibWidget = MatplotlibWidget(self)
    self.layoutVertical = QtGui.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.pushButtonPlot)
    self.layoutVertical.addWidget(self.matplotlibWidget)
    self.threadSample = ThreadSample(self)
    self.threadSample.newSample.connect(self.on_threadSample_newSample)
    self.threadSample.finished.connect(self.on_threadSample_finished)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MatplotlibWidget, self).__init__(parent)
    self.figure = Figure()
    self.canvas = FigureCanvasQTAgg(self.figure)
    self.axis = self.figure.add_subplot(111)
    self.layoutVertical = QtWidgets.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.canvas)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3972158_44720864_13_23
3972158_44720864_36_52
Title: How to plot on my GUI 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MatplotlibWidget, self).__init__(parent)
    self.figure = Figure()
    self.canvas = FigureCanvasQTAgg(self.figure)
    self.axis = self.figure.add_subplot(111)
    self.layoutVertical = QtWidgets.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.canvas)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyWindow, self).__init__(parent)
    self.pushButtonPlot = QtWidgets.QPushButton(self)
    self.pushButtonPlot.setText("Plot")
    self.pushButtonPlot.clicked.connect(self.on_pushButtonPlot_clicked)
    self.matplotlibWidget = MatplotlibWidget(self)
    self.layoutVertical = QtWidgets.QVBoxLayout(self)
    self.layoutVertical.addWidget(self.pushButtonPlot)
    self.layoutVertical.addWidget(self.matplotlibWidget)
    self.threadSample = ThreadSample(self)
    self.threadSample.newSample.connect(self.on_threadSample_newSample)
    self.threadSample.finished.connect(self.on_threadSample_finished)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39734045_39734180_1_10
39734045_39734676_1_9
Title: How to view variables within a function when warning is thrown pdb in python? 
----------------------------------------

def validate_cds(record, feature) :
INDENT
    import pdb; pdb.set_trace()
    saved_record = record
    saved_feature = feature
    protein_in_file = str(feature.qualifiers.get('translation', 'no_translation')).strip('\'[]')
    cds_to_protein = str(feature.extract(record).seq.translate(to_stop = True))
    return
DEDENT
----------------------------------------

def validate_cds(record, feature) :
INDENT
    try :
    INDENT

        protein_in_file = str(feature.qualifiers.get('translation', 'no_translation')).strip('\'[]')
        cds_to_protein = str(feature.extract(record).seq.translate(to_stop = True))
    DEDENT
    except :
    INDENT
        print record.id
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39736280_39736596_1_10
39736280_39737314_1_11
Title: Have to display coins used in makeChange function? 
----------------------------------------

def change(amount, coins) :
INDENT
    if not coins or amount < = 0 :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        return min((change(amount - coin, coins) + [coin] for coin in coins if amount > = coin), key = len)
    DEDENT
DEDENT
----------------------------------------

def change(amount, coins) :
INDENT
    if amount == 0 :
    INDENT
        return [0, []]
    DEDENT
    if coins == [] or amount < 0 :
    INDENT
        return [float('inf'), []]
    DEDENT
    else :
    INDENT
        loseIt = change(amount, coins [1 :])
        useIt = change(amount - coins [0], coins [1 :])
    DEDENT
    useIt = [useIt [0] + 1, useIt [1] + [coins [0]]]
    return min(useIt, loseIt)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39737196_39737272_1_14
39737196_39737775_1_17
Title: Replace Duplicate String Characters 
----------------------------------------

def duplicate_encode(word) :
INDENT
    from collections import Counter
    word = word.lower()
    counter = Counter(word)
    new_word = ''
    for char in word :
    INDENT
        if counter [char] > 1 :
        INDENT

            new_word += ')'
        DEDENT
        else :
        INDENT
            new_word += '('
        DEDENT
    DEDENT
    return new_word
DEDENT
----------------------------------------

def duplicate_encode(word) :
INDENT
    word_dict = {}
    new_word = ""
    for i in set(word) :
    INDENT
        word_count = word.count(i)
        word_dict [i] = word_count
    DEDENT
    for i in word :
    INDENT
        if word_dict [i] > 1 :
        INDENT
            new_word += ")"
        DEDENT
        else :
        INDENT
            new_word += "("
        DEDENT
    DEDENT
    print new_word
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39737728_39737818_1_11
39737728_39737860_6_15
Title: Print random number of lines after read a file 
----------------------------------------

def function() :
INDENT
    fo = open("1.txt", "r")
    print "Name of the file: ", fo.name
    lines = fo.readlines()
    start_index = 0
    while True :
    INDENT
        length = randint(1, len(lines) - start_index)
        for line in lines [start_index : start_index + length] :
        INDENT
            print (line)
        DEDENT
        start_index += length
        time.sleep(randint(1, 3))
    DEDENT
DEDENT
----------------------------------------

def function() :
INDENT
    fo = open("1.txt", "r")
    print "Name of the file: ", fo.name
    lines = fo.readlines()
    while lines :
    INDENT
        toSend = ""
        for i in range(0, random.randint(x, y)) :
        INDENT
            toSend += lines.pop(0)
        DEDENT
        print (toSend)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39744587_39749214_2_11
39744587_43223478_2_12
Title: Serve protected media files with django 
----------------------------------------

def serve_protected_document(request, file) :
INDENT
    document = get_object_or_404(ProtectedDocument, file = "protected/documents/" + file)

    path, file_name = os.path.split(file)
    response = FileResponse(document.file,)
    response ["Content-Disposition"] = "attachment; filename=" + file_name
    return response
DEDENT
----------------------------------------

def serve_protected_document(request, file) :
INDENT
    document = get_object_or_404(ProtectedDocument, file = "protected/documents/" + file)

    path, file_name = os.path.split(file)
    response = HttpResponse()
    response ["Content-Disposition"] = "attachment; filename=" + file_name
    response ["X-Accel-Redirect"] = document.name
    return response
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39755669_39788667_7_20
39755669_51723840_1_10
Title: Overriding update( ) Django rest framework 
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    print (validated_data)
    instance.categorie = validated_data.get('categorie', instance.categorie)
    instance.titre = validated_data.get('titre', instance.titre)
    instance.description = validated_data.get('description', instance.description)
    instance.photo_principal = validated_data.get('photo_principal', instance.photo_principal)
    instance.photo_1 = validated_data.get('photo_1', instance.photo_1)
    instance.photo_2 = validated_data.get('photo_2', instance.photo_2)
    instance.photo_3 = validated_data.get('photo_3', instance.photo_3)
    instance.prix = validated_data.get('prix', instance.prix)
    instance.new_prix = validated_data.get('new_prix', instance.new_prix)
    instance.save()
    return instance
DEDENT
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    fields = instance._meta.fields
    exclude = []
    for field in fields :
    INDENT
        field = field.name.split('.') [- 1]
        if field in exclude :
        INDENT
            continue
        DEDENT
        exec ("instance.%s = validated_data.get(field, instance.%s)" % (field, field))
    DEDENT
    instance.save()
    return instance
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39761908_39762118_8_13
39761908_39762299_1_11
Title: Python: How to assign function name dynamically in Class 
----------------------------------------

def iter_n(self) :
INDENT
    self.a, self.b = self.b, self.a + self.b
    if self.a > 10 :
    INDENT
        raise StopIteration();
    DEDENT
    return self.a
DEDENT
----------------------------------------

def iter_n(self) :
INDENT
    self.a, self.b = self.b, self.a + self.b
    if self.a > 10 :
    INDENT
        raise StopIteration();
    DEDENT
    return self.a
    if sys.version_info [0] == 2 :
    INDENT
        next = iter_n
    DEDENT
    else :
    INDENT
        __next__ = iter_n
    DEDENT
    del iter_n
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39775536_39775560_1_16
39775536_47378161_12_19
Title: Python switch case 
----------------------------------------

def switchcase(num, cc) :
INDENT
    def fa(num) :
    INDENT
        return num * 1.1;
    DEDENT
    def fb(num) :
    INDENT
        return num * 2.2;
    DEDENT
    def fc(num) :
    INDENT
        return num * 3.3;
    DEDENT
    def fd(num) :
    INDENT
        return num * 4.4;
    DEDENT
    options = {
        "a" : fa(num),
        "b" : fb(num),
        "c" : fc(num),
        "d" : fd(num)}
    return options [cc];
DEDENT
----------------------------------------

def switchcase(cc) :
INDENT
    return {
        "a" : fa,
        "b" : fb,
        "c" : fc,
        "d" : fd,
        }.get(cc, f_default)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39778404_39778627_1_11
39778404_39778777_1_11
Title: How to change value inside function 
----------------------------------------

def bearing(x) :
INDENT
    for item in x :
    INDENT
        item = item % 360
        if item > 270 :
        INDENT
            print (360 - item)
        DEDENT
        elif item > 180 :
        INDENT
            print (item - 180)
        DEDENT
        elif item > 90 :
        INDENT
            print (180 - item)
        DEDENT
        else :
        INDENT
            print (item)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def bearing(x) :
INDENT
    for i in range(len(x)) :
    INDENT
        while x [i] > = 360 :
        INDENT
            x [i] -= 360
        DEDENT
        if x [i] > 270 :
        INDENT
            x [i] = 360 - x [i]
        DEDENT
        elif x [i] > 180 :
        INDENT
            x [i] -= 180
        DEDENT
        elif x [i] > 90 :
        INDENT
            x [i] = 180 - x [i]
        DEDENT
    DEDENT
    print (x)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39782278_39782394_17_22
39782278_39782439_6_13
Title: Loop through categories recursively 
----------------------------------------

def loop(categories, depth) :
INDENT
    for category in categories :
    INDENT
        items.append((category ['id'], '-' * depth + ' ' + category ['name']))
        if category.get('children') :
        INDENT
            loop(category ['children'], depth + 1)
        DEDENT
    DEDENT
    return items
DEDENT
----------------------------------------

def loop(categories, count) :
INDENT
    for category in categories :
    INDENT
        items.append((category.id, '-' * count, category.name))
        if category.children :
        INDENT
            count += 1
            return loop(category.children, count)
        DEDENT
    DEDENT
    return items
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39782278_39782394_2_26
39782278_39782439_1_14
Title: Loop through categories recursively 
----------------------------------------

def build_choice_tree2() :
INDENT
    categories = [{
            'id' : 1,
            'name' : 'root',
            'children' : [{
                    'id' : 2,
                    'name' : 'child1',
                    'children' : [{
                            'id' : 3,
                            'name' : 'child2',
                            }]}]}]
    items = []
    def loop(categories, depth) :
    INDENT
        for category in categories :
        INDENT
            items.append((category ['id'], '-' * depth + ' ' + category ['name']))
            if category.get('children') :
            INDENT
                loop(category ['children'], depth + 1)
            DEDENT
        DEDENT
        return items
    DEDENT
    result = loop(categories, 0)
    print (result)
    return result
DEDENT
----------------------------------------

def build_choice_tree2() :
INDENT
    categories = Category.query.get(1).children
    items = []
    count = 1
    def loop(categories, count) :
    INDENT
        for category in categories :
        INDENT
            items.append((category.id, '-' * count, category.name))
            if category.children :
            INDENT
                count += 1
                return loop(category.children, count)
            DEDENT
        DEDENT
        return items
    DEDENT
    return loop(categories, count)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39797552_39797746_1_10
39797552_39798666_3_14
Title: Basic Anagram VS more advanced one 
----------------------------------------

def is_anagram(a, b) :
INDENT
    test = sorted(a) == sorted(b)
    testset = b in a
    testset1 = a in b
    if testset == True :
    INDENT
        return True
    DEDENT
    if testset1 == True :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def is_anagram(a, b) :
INDENT
    b_dict = defaultdict(int)
    for char in b :
    INDENT
        b_dict [char] += 1
    DEDENT
    for char in a :
    INDENT
        b_dict [char] -= 1
        if b_dict [char] < 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39801516_39801677_7_17
39801516_39801680_7_12
Title: create a list but getting a string? 
----------------------------------------

def read_nodes(gfile) :
INDENT
    allNodes = []
    for line in gfile.split() :
    INDENT
        nodes = line.split(":") [1].replace(';', ',').split(',')
        for node in nodes :
        INDENT
            allNodes.append(node)
        DEDENT
    DEDENT
    return allNodes
DEDENT
----------------------------------------

def read_nodes(gfile) :
INDENT
    nodes = []
    for line in gfile.split() :
    INDENT
        nodes += line.split(":") [1].replace(';', ',').split(',')
    DEDENT
    return nodes
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39821015_39821359_1_10
39821015_39851738_1_14
Title: Python MIT 6.00.1X 
----------------------------------------

def applyF_filterG(L, f, g) :
INDENT
    L_temp = L [:]
    for i in L_temp :
    INDENT
        if g(f(i)) == False :
        INDENT
            L.remove(i)
        DEDENT
    DEDENT
    if len(L) == 0 :
    INDENT
        return - 1
    DEDENT
    else :
    INDENT
        return max(L)
    DEDENT
DEDENT
----------------------------------------

def applyF_filterG(L, f, g) :
INDENT
    l = []
    if len(L) > 0 :
    INDENT
        for i in L :
        INDENT
            if (g(f(i)) == True) :
            INDENT
                l.append(i)
            DEDENT
        DEDENT
        L [:] = l
        if len(L) > 0 :
        INDENT
            return max(L)
        DEDENT
        else :
        INDENT
            return - 1
        DEDENT
    DEDENT
    else :
    INDENT
        L [:] = l
        return - 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39831915_39831996_8_13
39831915_39832009_8_13
Title: How do I transfer varibles through functions in Python 
----------------------------------------

def read() :
INDENT
    a = input("Nr: ")
    while not IsInteger(a) :
    INDENT
        a = input("Give a number: ")
    DEDENT
    return a
DEDENT
----------------------------------------

def read() :
INDENT
    global a
    a = input("Nr: ")
    while (IsInteger(a) ! = True) :
    INDENT
        a = input("Give a number: ")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39837160_39837500_8_13
39837160_39845975_1_34
Title: Changing a global variable in a function without using global keyword 
----------------------------------------

def applyF_filterG(L, f, g) :
INDENT
    for val in L [:] :
    INDENT
        if not g(f(val)) :
        INDENT
            L.remove(val)
        DEDENT
    DEDENT
    return - 1 if not L else max(L)
DEDENT
----------------------------------------

def applyF_filterG(L, f, g) :
INDENT
    i = len(L) - 1
    largestnum = 0
    if (len(L) == 0) :
    INDENT
        return - 1
    DEDENT
    else :
    INDENT
        while i > = 0 :
        INDENT
            if not g(f(L [i])) :
            INDENT
                del L [i]
            DEDENT
            i -= 1

        DEDENT
    DEDENT
    if not L :
    INDENT
        return - 1
    DEDENT
    if (len(L) == 1) :
    INDENT
        return L [0]
    DEDENT
    else :
    INDENT
        for num in range(len(L) - 1) :
        INDENT
            if (L [num] > L [num + 1]) :
            INDENT
                largestnum = L [num]
            DEDENT
            else :
            INDENT
                largestnum = L [num + 1]
            DEDENT
        DEDENT
        return largestnum
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39839535_39840248_1_14
39839535_39861647_1_25
Title: "My function closest_power(base num) failing some test cases" 
----------------------------------------

def closest_power(base, num) :
INDENT
    exp = 1
    while base ** exp < num :
    INDENT
        exp += 1
    DEDENT
    return exp if base ** exp - num < num - base ** (exp - 1) else exp - 1
DEDENT
----------------------------------------

def closest_power(base, num) :
INDENT
    bevaluate = True
    exponent = 0
    vale = 0
    older = 0
    olders = 0
    while bevaluate :
    INDENT
        vale = base ** exponent
        if vale < num :
        INDENT
            older = num - vale
            exponent += 1
        DEDENT
        else :
        INDENT
            olders = vale - num
            if older == olders :
            INDENT
                if num == 1 :
                INDENT
                    exponent = 0
                DEDENT
                else :
                INDENT
                    exponent -= 1
                DEDENT
                break
            DEDENT
            elif older < olders :
            INDENT
                exponent -= 1
                break
            DEDENT
            bevaluate = False
        DEDENT
    DEDENT
    return exponent
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3984003_34188344_40_56
3984003_9067235_5_45
Title: How to extract PDF fields from a filled out form in Python? 
----------------------------------------

def main() :
INDENT
    args = parse_cli()
    form = load_form(args.file)
    if args.out :
    INDENT
        with open(args.out, 'w') as outfile :
        INDENT
            if args.pickle :
            INDENT
                pickle.dump(form, outfile)
            DEDENT
            else :
            INDENT
                pp = pprint.PrettyPrinter(indent = 2)
                file.write(pp.pformat(form))
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        if args.pickle :
        INDENT
            print pickle.dumps(form)
        DEDENT
        else :
        INDENT
            pp = pprint.PrettyPrinter(indent = 2)
            pp.pprint(form)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    print "Calling PDFDUMP.py"
    os.system("dumppdf.py -a FILE.pdf > out.xml")

    print "Screening the file"
    o = open("output.xml", "w")
    for line in open("out.xml") :
    INDENT
        line = line.replace("&#", "Invalid_XML")
        o.write(line)
    DEDENT
    o.close()
    print "Opening XML output"
    tree = ElementTree.parse('output.xml')
    lastnode = ""
    lastnode2 = ""
    list = {}
    entry = {}
    for node in tree.iter() :
    INDENT
        if node.tag == "key" and node.text == "T" :
        INDENT
            lastnode = node.tag + node.text
        DEDENT
        elif lastnode == "keyT" :
        INDENT
            for child in node.iter() :
            INDENT
                entry ["ID"] = child.text
            DEDENT
            lastnode = ""
        DEDENT
        if node.tag == "key" and node.text == "V" :
        INDENT
            lastnode2 = node.tag + node.text
        DEDENT
        elif lastnode2 == "keyV" :
        INDENT
            for child in node.iter() :
            INDENT
                if child.tag == "string" :
                INDENT
                    if entry.has_key("ID") :
                    INDENT
                        entry ["Value"] = child.text
                        list [entry ["ID"]] = entry ["Value"]
                        entry = {}
                    DEDENT
                DEDENT
            DEDENT
            lastnode2 = ""
        DEDENT
    DEDENT
    pprint(list)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39844473_39844742_1_12
39844473_39846442_4_35
Title: Find the subset of a set of integers that has the maximum product 
----------------------------------------

def find(l) :
INDENT
    if len(l) < = 2 and 0 in l :
    INDENT
        return max(l)
    DEDENT
    l = [e for e in l if e ! = 0]
    r = 1
    for e in l :
    INDENT
        r *= e
    DEDENT
    if r < 0 :
    INDENT
        l.remove(max([e for e in l if e < 0]))
        r = find(l)
    DEDENT
    return r
DEDENT
----------------------------------------

def find(array) :
INDENT
    negative = []
    positive = []
    zero = None
    removed = None
    def string_product(iterable) :
    INDENT
        return str(reduce(mul, iterable, 1))
    DEDENT
    for number in array :
    INDENT
        if number < 0 :
        INDENT
            negative.append(number)
        DEDENT
        elif number > 0 :
        INDENT
            positive.append(number)
        DEDENT
        else :
        INDENT
            zero = str(number)
        DEDENT
    DEDENT
    if negative :
    INDENT
        if len(negative) % 2 == 0 :
        INDENT
            return string_product(negative + positive)
        DEDENT
        removed = max(negative)
        negative.remove(removed)
        if negative :
        INDENT
            return string_product(negative + positive)
        DEDENT
    DEDENT
    if positive :
    INDENT
        return string_product(positive)
    DEDENT
    return zero or str(removed)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39853005_39857545_18_40
39853005_46754459_22_42
Title: "Drawing a fractal tree in Python not sure how to proceed" 
----------------------------------------

def draw_tree(l, level) :
INDENT
    width = t.width()
    t.width(width * 3.0 / 4.0)
    l = 3.0 / 4.0 * l
    t.lt(s)
    t.fd(l)
    if level < lv :
    INDENT
        draw_tree(l, level + 1)
    DEDENT
    t.bk(l)
    t.rt(2 * s)
    t.fd(l)
    if level < lv :
    INDENT
        draw_tree(l, level + 1)
    DEDENT
    t.bk(l)
    t.lt(s)
    t.width(width)
DEDENT
----------------------------------------

def draw_tree(self, branch_length, level) :
INDENT
    width = self.width()
    self.width(width * 3./ 4.)
    branch_length *= 3./ 4.
    self.left(ROTATION_LENGTH)
    self.forward(branch_length)
    if level > 0 :
    INDENT
        self.draw_tree(branch_length, level - 1)
    DEDENT
    self.back(branch_length)
    self.right(2 * ROTATION_LENGTH)
    self.forward(branch_length)
    if level > 0 :
    INDENT
        self.draw_tree(branch_length, level - 1)
    DEDENT
    self.back(branch_length)
    self.left(ROTATION_LENGTH)
    self.width(width)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39855889_39856175_9_22
39855889_39857046_15_26
Title: Readable Time Format (w/ Good Grammar!) 
----------------------------------------

def format_duration(seconds, granularity = 2) :
INDENT
    intervals = (('hours', 3600), ('minutes', 60), ('seconds', 1))
    human_time = []
    for name, count in intervals :
    INDENT
        value = seconds / / count
        if value :
        INDENT
            seconds -= value * count
            if value == 1 :
            INDENT
                name = name.rstrip('s')
            DEDENT
            human_time.append("{} {}".format(value, name))
        DEDENT
    DEDENT
    if not human_time :
    INDENT
        return "now"
    DEDENT
    human_time = human_time [: granularity]
    return prettyList(human_time)
DEDENT
----------------------------------------

def format_duration(seconds, granularity = 3) :
INDENT
    intervals = get_intervals(seconds)
    human_time = []
    for name, value in intervals :
    INDENT
        if value == 0 :
        INDENT
            continue
        DEDENT
        elif value == 1 :
        INDENT
            human_time.append("{} {}".format(value, name))
        DEDENT
        else :
        INDENT
            human_time.append("{} {}s".format(value, name))
        DEDENT
    DEDENT
    return (pretty_list(human_time [: granularity])) if len(human_time) ! = 0 else "now"
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39855889_39857046_15_26
39855889_39857391_9_22
Title: Readable Time Format (w/ Good Grammar!) 
----------------------------------------

def format_duration(seconds, granularity = 3) :
INDENT
    intervals = get_intervals(seconds)
    human_time = []
    for name, value in intervals :
    INDENT
        if value == 0 :
        INDENT
            continue
        DEDENT
        elif value == 1 :
        INDENT
            human_time.append("{} {}".format(value, name))
        DEDENT
        else :
        INDENT
            human_time.append("{} {}s".format(value, name))
        DEDENT
    DEDENT
    return (pretty_list(human_time [: granularity])) if len(human_time) ! = 0 else "now"
DEDENT
----------------------------------------

def format_duration(seconds, granularity = 4) :
INDENT
    intervals = (('years', 29030400), ('months', 2419200), ('weeks', 604800), ('days', 86400), ('hours', 3600), ('minutes', 60), ('seconds', 1))
    human_time = []
    for name, count in intervals :
    INDENT
        value = seconds / / count
        if value :
        INDENT
            seconds -= value * count
            if value == 1 :
            INDENT
                name = name.rstrip('s')
            DEDENT
            human_time.append("{} {}".format(value, name))
        DEDENT
    DEDENT
    if not human_time :
    INDENT
        return "now"
    DEDENT
    human_time = human_time [: granularity]
    return prettyList(human_time)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39856372_39876776_22_43
39856372_39876776_6_16
Title: How to link into new page using button in wxPython 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Notebook Tutorial",
        size = (600, 400))
    panel = wx.Panel(self)
    notebook = wx.Notebook(panel)
    tabOne = TabPanel(notebook)
    notebook.AddPage(tabOne, "Tab 1")
    tabTwo = TabPanel(notebook)
    notebook.AddPage(tabTwo, "Tab 2")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(notebook, 1, wx.ALL | wx.EXPAND, 5)
    panel.SetSizer(sizer)
    self.Layout()
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    colors = ["red", "blue", "gray", "yellow", "green"]
    self.SetBackgroundColour(random.choice(colors))
    btn = wx.Button(self, label = "Press Me")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(btn, 0, wx.ALL, 10)
    self.SetSizer(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39901031_39901647_1_18
39901031_39912697_1_11
Title: Python - Gathering File Information Recursively Leads to Memory Error 
----------------------------------------

def get_file_sizes_folder(starting_folder) :
INDENT
    data_dicts = []
    for entry in os.scandir(starting_folder) :
    INDENT
        if not entry.name.startswith('.') :
        INDENT
            if entry.is_file() :
            INDENT
                size = entry.stat().st_size
                filename = entry.name
                folder = os.path.dirname(entry.path)
                temp_dict = {'filename' : filename, 'size' : size, 'folder' : folder}
                data_dicts.append(temp_dict)
            DEDENT
            else :
            INDENT
                print (entry.path)
                data_dicts.extend(get_file_sizes_folder(entry.path))
            DEDENT
        DEDENT
    DEDENT
    return data_dicts
DEDENT
----------------------------------------

def get_file_sizes_folder(starting_folder) :
INDENT
    data_dicts = list()
    for root, _, files in os.walk(starting_folder) :
    INDENT
        data_dicts.extend({
                'filename' : f,
                'size' : os.path.getsize(os.path.join(root, f)),
                'folder' : root,
                } for f in files)
    DEDENT
    return data_dicts
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39902546_39903723_13_25
39902546_39903723_4_11
Title: "how to insert a widget to another if they are from different classes. and how to create a universal function of closing the child widgets?" 
----------------------------------------

def __init__(self, parent) :
INDENT
    tkinter.Frame.__init__(self, parent)
    self.label = tkinter.Label(self, height = 20, width = 30, bg = 'Red', fg = 'white', text = 'Hello')
    self.exit_button = tkinter.Button(self, command = self.destroy)

    self.exit_button.pack(side = "right")
    self.label.pack(side = "left", fill = "both", expand = True)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = tkinter.Tk()
    self.main = tkinter.Canvas(self.root, width = 200, height = 400)
    self.main.place(x = 0, y = 0, relwidth = 1, relheight = 1)
    self.main.config(bg = 'green')
    self.root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39903222_39905159_1_14
39903222_39905489_26_40
Title: Python: Create file from list of dictionaries 
----------------------------------------

def create_csv(dict_list) :
INDENT
    with open('dict.csv', 'w') as csv_file :
    INDENT

        csvwriter = csv.DictWriter(csv_file, fieldnames = dict_list [0].keys(), extrasaction = 'raise', dialect = 'excel')

        csvwriter.writeheader()

        for row in dict_list :
        INDENT

            csvwriter.writerow(row)
        DEDENT
    DEDENT
    return csv_file
DEDENT
----------------------------------------

def create_csv(self) :
INDENT
    with open('dict.csv', 'wb') as csv_file :
    INDENT
        csvwriter = csv.DictWriter(
            csv_file,
            fieldnames = ['userid', 'ipaddr', 'event_time', 'usage_in_mb'],
            extrasaction = 'raise',
            dialect = 'excel')
        csvwriter.writeheader()
        for row in dict_list :
        INDENT
            try :
            INDENT
                csvwriter.writerow(row)
            DEDENT
            except Exception as e :
            INDENT
                print e
            DEDENT
        DEDENT
    DEDENT
    return csv_file
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39905916_39906819_22_45
39905916_39906819_8_19
Title: Python Program Expecting a Return 
----------------------------------------

def __init__(self, parent) :
INDENT
    super(TableWidget, self).__init__(parent)

    parent.setWindowTitle("test_table")
    parent.resize(400, 250)

    self.setRowCount(4)
    self.setColumnCount(2)

    self.setItem(0, 0, QTableWidgetItem("Item (1,1)"))
    self.setItem(0, 1, QTableWidgetItem("Item (1,2)"))
    self.setItem(1, 0, QTableWidgetItem("Item (2,1)"))
    self.setItem(1, 1, QTableWidgetItem("Item (2,2)"))
    self.setItem(2, 0, QTableWidgetItem("Item (3,1)"))
    self.setItem(2, 1, QTableWidgetItem("Item (3,2)"))
    self.setItem(3, 0, QTableWidgetItem("Item (4,1)"))
    self.setItem(3, 1, QTableWidgetItem("Item (4,2)"))
    self.setItem(3, 0, QTableWidgetItem("Item (4,1)"))
    self.setItem(3, 1, QTableWidgetItem("Item (4,2)"))

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyMainWindow, self).__init__(parent)
    self.table_widget = TableWidget(self)
    self.setCentralWidget(self.table_widget)

    self.show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39905916_39906819_8_19
39905916_39907189_3_25
Title: Python Program Expecting a Return 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyMainWindow, self).__init__(parent)
    self.table_widget = TableWidget(self)
    self.setCentralWidget(self.table_widget)

    self.show()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(TableWidget, self).__init__(parent)
    table = QTableWidget()
    tableItem = QTableWidgetItem()
    table.setRowCount(4)
    table.setColumnCount(2)

    table.setItem(0, 0, QTableWidgetItem("Item (1,1)"))
    table.setItem(0, 1, QTableWidgetItem("Item (1,2)"))
    table.setItem(1, 0, QTableWidgetItem("Item (2,1)"))
    table.setItem(1, 1, QTableWidgetItem("Item (2,2)"))
    table.setItem(2, 0, QTableWidgetItem("Item (3,1)"))
    table.setItem(2, 1, QTableWidgetItem("Item (3,2)"))
    table.setItem(3, 0, QTableWidgetItem("Item (4,1)"))
    table.setItem(3, 1, QTableWidgetItem("Item (4,2)"))
    table.setItem(3, 0, QTableWidgetItem("Item (4,1)"))
    table.setItem(3, 1, QTableWidgetItem("Item (4,2)"))
    layout = QVBoxLayout(self)
    layout.addWidget(table)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39925069_39925134_11_31
39925069_39925357_13_27
Title: Having problems parsing numerical command-line arguments 
----------------------------------------

def transform() :
INDENT
    if len(sys.argv) < 3 :
    INDENT

        usage()
    DEDENT
    else :
    INDENT
        try :
        INDENT
            command = int(sys.argv [1])
            odd = int(''.join(map(str, eventarray(sys.argv [2]))))
            even = int(''.join(map(str, oddtarray(sys.argv [2]))))
            if command == 1 :
            INDENT
                print (odd)
            DEDENT
            elif command == 2 :
            INDENT
                print (even)
            DEDENT
            else :
            INDENT
                usage()
            DEDENT
        DEDENT
        except ValueError as e :
        INDENT
            print (str(e))
            usage()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def transform() :
INDENT
    if len(sys.argv) == 3 :
    INDENT
        try :
        INDENT
            if sys.argv [1] == "1" :
            INDENT
                print oddtarray(sys.argv [2])
            DEDENT
            elif sys.argv [1] == "2" :
            INDENT
                print eventarray(sys.argv [2])
            DEDENT
            else :
            INDENT
                usage()
            DEDENT
        DEDENT
        except ValueError :
        INDENT
            usage()
        DEDENT
    DEDENT
    else :
    INDENT
        usage()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39931798_39931879_1_12
39931798_39932051_1_10
Title: Issue with pattern program using loops 
----------------------------------------

def greet(lines, cheers) :
INDENT
    i = 0
    line_str = ""
    while i < cheers :
    INDENT
        i += 1
        line_str += "GO" if i == cheers else "GO BUDDY "
    DEDENT
    i = 0
    while i < lines :
    INDENT
        print (" " * (i * 3) + line_str)
        i += 1
    DEDENT
DEDENT
----------------------------------------

def greet(lines, cheers) :
INDENT
    for i in range(lines) :
    INDENT
        output = (" ") * i + "Go"
        for j in range(cheers) :
        INDENT
            if cheers == 1 :
            INDENT
                print output
                break
            DEDENT
            output += "Budddy Go"
        DEDENT
        print output
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39933884_39933925_1_17
39933884_39934083_1_30
Title: Some cases cause my binary search to enter into an Infinite loop 
----------------------------------------

def binary_search(a_list, item, start = 0, end = None) :
INDENT
    end = end or len(a_list)
    if start == end :
    INDENT
        if a_list [start] == item :
        INDENT
            return start
        DEDENT
        return False
    DEDENT
    mid = start + ((end - start) / / 2)
    if a_list [mid] == item :
    INDENT
        return mid
    DEDENT
    elif a_list [mid] > item :
    INDENT
        return binary_search(a_list, item, start = start, end = mid)
    DEDENT
    elif a_list [mid] < item :
    INDENT
        return binary_search(a_list, item, start = mid + 1, end = end)
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def binary_search(a_list, item) :
INDENT
    if not a_list :
    INDENT
        return False
    DEDENT
    mid = len(a_list) / / 2
    print "Middle is: {}".format(a_list [mid])
    print a_list
    while len(a_list) > 0 :
    INDENT
        if len(a_list) == 1 and a_list [mid] ! = item :
        INDENT
            return False
        DEDENT
        elif a_list [mid] == item :
        INDENT
            return mid
        DEDENT
        elif a_list [mid] > item :
        INDENT
            return binary_search(a_list [: mid], item)

        DEDENT
        elif a_list [mid] < item :
        INDENT
            index = binary_search(a_list [mid :], item)
            if not index :
            INDENT
                return False
            DEDENT
            else :
            INDENT
                return index + mid
            DEDENT
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39933884_39933925_1_17
39933884_39934554_3_25
Title: Some cases cause my binary search to enter into an Infinite loop 
----------------------------------------

def binary_search(a_list, item, start = 0, end = None) :
INDENT
    end = end or len(a_list)
    if start == end :
    INDENT
        if a_list [start] == item :
        INDENT
            return start
        DEDENT
        return False
    DEDENT
    mid = start + ((end - start) / / 2)
    if a_list [mid] == item :
    INDENT
        return mid
    DEDENT
    elif a_list [mid] > item :
    INDENT
        return binary_search(a_list, item, start = start, end = mid)
    DEDENT
    elif a_list [mid] < item :
    INDENT
        return binary_search(a_list, item, start = mid + 1, end = end)
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def binary_search(a_list, item) :
INDENT
    if not a_list :
    INDENT
        return False
    DEDENT
    mid = len(a_list) / / 2
    print "Middle is: {}".format(a_list [mid])
    print a_list
    print a_list, item
    pdb.set_trace()
    while len(a_list) > 0 :
    INDENT
        if a_list [mid] == item :
        INDENT
            return mid
        DEDENT
        elif a_list [mid] > item :
        INDENT
            return binary_search(a_list [: mid], item)
        DEDENT
        elif a_list [mid] < item :
        INDENT
            return binary_search(a_list [mid :], item) + mid
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39933884_39934083_1_30
39933884_39934554_3_25
Title: Some cases cause my binary search to enter into an Infinite loop 
----------------------------------------

def binary_search(a_list, item) :
INDENT
    if not a_list :
    INDENT
        return False
    DEDENT
    mid = len(a_list) / / 2
    print "Middle is: {}".format(a_list [mid])
    print a_list
    while len(a_list) > 0 :
    INDENT
        if len(a_list) == 1 and a_list [mid] ! = item :
        INDENT
            return False
        DEDENT
        elif a_list [mid] == item :
        INDENT
            return mid
        DEDENT
        elif a_list [mid] > item :
        INDENT
            return binary_search(a_list [: mid], item)

        DEDENT
        elif a_list [mid] < item :
        INDENT
            index = binary_search(a_list [mid :], item)
            if not index :
            INDENT
                return False
            DEDENT
            else :
            INDENT
                return index + mid
            DEDENT
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def binary_search(a_list, item) :
INDENT
    if not a_list :
    INDENT
        return False
    DEDENT
    mid = len(a_list) / / 2
    print "Middle is: {}".format(a_list [mid])
    print a_list
    print a_list, item
    pdb.set_trace()
    while len(a_list) > 0 :
    INDENT
        if a_list [mid] == item :
        INDENT
            return mid
        DEDENT
        elif a_list [mid] > item :
        INDENT
            return binary_search(a_list [: mid], item)
        DEDENT
        elif a_list [mid] < item :
        INDENT
            return binary_search(a_list [mid :], item) + mid
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
DEDENT
----------------------------------------
