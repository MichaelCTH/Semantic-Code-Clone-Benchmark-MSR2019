$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48333610_48333909_13_50
48333610_48334914_4_27
Title: float members in C structures not working: Code::blocks IDE issue 
----------------------------------------

int main (void) {
    struct book b [NBOOKS] = {{"", 0.0, 0}};
    int i;
    for (i = 0; i < NBOOKS; i++) {
        size_t len = 0;
        char buf [MAXC] = "";
        printf ("book[%d] enter name: ", i + 1);
        if (!fgets (b[i].name, MAXC, stdin)) {
            fprintf (stderr, "error: invalid input for name.\n");
            return 1;
        }
        len = strlen (b[i].name);
        if (len && b[i].name[len - 1] == '\n')
            b[i].name[len - 1] = 0;
        printf ("book[%d] enter price & pages: ", i + 1);
        if (!fgets (buf, MAXC, stdin)) {
            fprintf (stderr, "error: invalid input for price & pages.\n");
            return 1;
        }
        if (sscanf (buf, "%f %d", &b[i].price, &b[i].pages) != 2) {
            fprintf (stderr, "error: invalid input price & pages.\n");
            return 1;
        }
    }
    putchar ('\n');
    for (i = 0; i < NBOOKS; i++)
        printf ("%-24s %7.2f     %d\n", b[i].name, b[i].price, b[i].pages);
    return 0;
}
----------------------------------------

int main (void) {
    struct book {
        char name;
        float price;
        int pages;
    };
    struct book b [3];
    int i;
    char c;
    for (i = 0; i < 3; i++) {
        printf ("\n Enter name, price and pages: \t\t");
        scanf ("%c %f %d", & b [i].name, & b [i].price, & b [i].pages);
        while ((c = getchar ()) != '\n' && c != EOF)
            ;
    }
    for (i = 0; i < 3; i++) {
        printf ("\n%c, %f, %d", b [i].name, b [i].price, b [i].pages);
    }
    getchar ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48345704_48346267_1_21
48345704_48346285_3_15
Title: Why does my program crash after entering an integer? - C 
----------------------------------------

int main (void) {
    int ru [1000];
    int read = 0;
    int nums;
    int counts;
    printf ("Enter integers, press 0 to end user input \n");
    scanf ("%d", & nums);
    while ((nums > 0) && (read < 1000)) {
        ru[read++] = nums;
        scanf ("%d", & nums);
    }
    for (counts = 0; counts < read; counts++) {
        printf ("%d ", ru [counts]);
    }
    printf ("\n");
    system ("pause>nul");
    return 0;
}
----------------------------------------

int main () {
    int ru [1000];
    int i = 0;
    printf ("Enter integers, press 0 to end user input \n");
    do {
        scanf ("%d", & ru [i]);
    }
    while (ru[i] != 0 && i++ < 1000);
    for (i = 0; ru[i] != 0; i++)
        printf ("%d ", ru[i]);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48378100_48378141_4_27
48378100_48378874_5_20
Title: Why do my string values get overwritten? 
----------------------------------------

int main (void) {
    char *names [3];
    char name [20];
    for (size_t i = 0; i < sizeof (names) / sizeof (names[0]); i++) {
        printf ("Enter your name\n");
        if (scanf ("%19s", name) != 1) {
            fprintf (stderr, "%s\n", "Error in input");
            exit (EXIT_FAILURE);
        }
        names[i] = malloc (strlen (name) +1);
        if (names[i] == NULL) {
            perror ("malloc");
            exit (EXIT_FAILURE);
        }
        strcpy (names [i], name);
    }
    printf ("Printing the names\n");
    for (size_t i = 0; i < sizeof (names) / sizeof (names[0]); i++) {
        printf ("%s\n", names [i]);
    }
    for (size_t i = 0; i < sizeof (names) / sizeof (names[0]); i++)
        free (names[i]);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *names [3];
    char name [20];
    int i;
    for (i = 0; i < 3; i++) {
        printf ("Enter your name\n");
        scanf ("%s", name);
        names[i] = (char *) malloc (strlen (name) +1);
        strcpy (names [i], name);
    }
    printf ("Printing the names\n");
    for (i = 0; i < 3; i++) {
        printf ("%s\n", names [i]);
        free (names [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48401361_48402120_1_20
48401361_48526595_5_21
Title: C Help exercise 
----------------------------------------

int main () {
    int a [6] = {2, 8, 15, 31, 46, 75};
    int b [6] = {1, 8, 17, 21, 31, 75};
    int i = 0, j = 0, N = 6, c [6], k = 0;
    while (i < N && j < N) {
        if (a[i] < b[j]) {
            i++;
        }
        else if (a[i] > b[j]) {
            j++;
        }
        else {
            c[k] = a[i];
            k++;
            i++;
            j++;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    int a [N] = {2, 8, 15, 31, 46, 75};
    int b [N] = {1, 8, 17, 21, 31, 75};
    int i = 0, int j = 0, int n = 0;
    while (j + i < (N + N)) {
        n = (b [j] - a [i]) & 0x80000000 printf ("%d\n", n ? b [j ++] : a [i ++]);
        while (j == N && i != N)
            printf ("%d\n", a[i++]);
        while (i == N && j != N)
            printf ("%d\n", b[j++]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48413895_48414004_5_74
48413895_48438099_4_19
Title: How do I read a file line by line in C from the terminal? 
----------------------------------------

int main (int argc, char *argv []) {
    char *line = (char *) malloc (BUFSIZE);
    if (!line) {
        printf ("malloc buffer failed...\n");
        return 1;
    }
    memset (line, 0, sizeof (line));
    FILE *fp;
    FILE *writefp;
    int c;
    int count = 0;
    int count_buf = BUFSIZE;
    char scanf_answer;
    if (argc != 3) {
        printf ("./myprogram <input.txt> output.txt\n");
        return 1;
    }
    fp = fopen (argv[1], "r");
    for (;;) {
        c = getc (fp);
        if (c == '\n') {
            printf ("%s\n", line);
            printf ("<Did you want to write this line to [%s]?>", argv [2]);
            scanf ("%c", & scanf_answer);
            if (scanf_answer == 'Y' || scanf_answer == 'y') {
                writefp = fopen (argv[2], "a+");
                fprintf (writefp, "%s\n", line);
                fclose (writefp);
            }
            memset (line, 0, sizeof (line));
        }
        else if (c == EOF) {
            printf ("%s\n", line);
            printf ("<Did you want to write this line to [%s]?>", argv [2]);
            scanf ("%c", & scanf_answer);
            if (scanf_answer == 'Y' || scanf_answer == 'y') {
                writefp = fopen (argv[2], "a+");
                fprintf (writefp, "%s\n", line);
                fclose (writefp);
            }
            printf ("End of file\n");
            break;
        }
        if (count >= count_buf) {
            line = realloc (line, BUFSIZE);
            count_buf += BUFSIZE;
            if (!line) {
                printf ("realloc buffer failed...\s");
                return 1;
            }
            count = 0;
        }
        sprintf (line, "%c%c", line, c);
        ++count;
    }
    fclose (fp);
    return 0;
}
----------------------------------------

int main () {
    char *buffer = 0;
    size_t buffer_size = 0;
    ssize_t bytes_read;
    while ((bytes_read = getline (&buffer, &buffer_size, stdin)) != -1) {
        printf ("%s", buffer);
    }
    free (buffer);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48436258_48438013_4_24
48436258_48438240_1_14
Title: My C program is recursing infinitely and I cannot figure out why 
----------------------------------------

void reversedWord (char input [], int size) {
    static int count = 0;
    static int count2;
    if (count == 0) {
        count2 = size;
    }
    count2 = count2 - 1;
    char store;
    store = input[count2];
    input[count2] = input[count];
    input[count] = store;
    count = count + 1;
    if (count > size) {
        return;
    }
    reversedWord (input, size);
    return;
}
----------------------------------------

void reversedWord (char input [], int start, int end) {
    end = end - 1;
    char store;
    store = input[end];
    input[end] = input[start];
    input[start] = store;
    start = start + 1;
    if (start >= end) {
        return;
    }
    return reversedWord (input, start, end);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48436844_48436934_5_33
48436844_48437968_7_45
Title: Convert hexadecimal numbers to decimal numbers 
----------------------------------------

int main () {
    char numbers_str [] = "1 -2 3.1 0xf 0xcc";
    int ints [10];
    double doubles [10];
    int ints_idx = 0, doubles_idx = 0;
    const char delims [] = " ";
    char *it = strtok (numbers_str, delims);
    while (it != NULL) {
        char *dot_it = strchr (it, '.');
        if (dot_it)
            doubles[doubles_idx++] = strtod (it, NULL);
        else
            ints[ints_idx++] = strtol (it, NULL, 0);
        it = strtok (NULL, delims);
    }
    printf ("Integers found: \n");
    for (int i = 0; i < ints_idx; ++i)
        printf ("%d\n", ints[i]);
    printf ("Double numbers found: \n");
    for (int i = 0; i < doubles_idx; ++i)
        printf ("%f\n", doubles[i]);
}
----------------------------------------

int main (int argc, char **argv) {
    int i, n = 0;
    double v [VECSZ] = {0.0};
    char buf [BUFSIZ] = "";
    FILE *fp = argc > 1 ? fopen (argv[1], "r") : stdin;
    if (!fp) {
        fprintf (stderr, "error: file open failed '%s'.\n", argv [1]);
        return 1;
    }
    while (n < VECSZ && fgets (buf, BUFSIZ, fp)) {
        char *p = buf, *ep;
        while (n < VECSZ) {
            double tmp = strtod (p, &ep);
            if (p != ep) {
                if (!errno)
                    v[n++] = tmp;
                p = ep;
            }
            else {
                fprintf (stderr, "error: no digits converted.\n");
                while (*p && *p != '-' && *p != '+' && (*p < '1' || '9' < *p))
                    p++;
                if (*p)
                    continue;
                break;
            }
        }
    }
    if (fp != stdin)
        fclose (fp);
    for (i = 0; i < n; i++)
        printf ("v[%d]=% g\n", i, v[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48438949_48439591_4_27
48438949_48442160_4_23
Title: Encryption process working half 
----------------------------------------

int main () {
    char inpusr [100];
    int i, length, key;
    length = 100;
    memset (inpusr, 0, sizeof (inpusr));
    scanf ("%[^\n]s", inpusr);
    scanf ("%d", & key);
    printf ("%s\n", inpusr);
    for (i = 0; i <= length; i++) {
        if (inpusr[i] >= 97 && inpusr[i] <= 122) {
            inpusr[i] = (((inpusr[i] - 97 + key) % 26) + 97);
        }
        else if ((inpusr[i] >= 65 && inpusr[i] <= 90)) {
            inpusr[i] = (((inpusr[i] - 65 + key) % 26) + 65);
        }
    }
    printf ("%s\n", inpusr);
    return 0;
}
----------------------------------------

int main () {
    char inpusr [100];
    char key_input [3];
    int key = 0;
    int len = 100;
    fgets (inpusr, len, stdin);
    printf ("%s\n", inpusr);
    fgets (key_input, 3, stdin);
    key = atoi (key_input);
    printf ("%d\n", key);
    while (len--) {
        if (inpusr[len] >= 97 && inpusr[len] <= 122)
            inpusr[len] = (inpusr[len] - 97 + (key % 26) + 26) % 26 + 97;
    }
    printf ("%s\n", inpusr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48438949_48439804_1_23
48438949_48442160_4_23
Title: Encryption process working half 
----------------------------------------

int main () {
    char inpusr [100];
    int i, length, key;
    length = 100;
    scanf ("%[^\n]s", inpusr);
    scanf ("%d", & key);
    printf ("%s\n", inpusr);
    for (i = 0; i <= length; i++) {
        if (inpusr[i] >= 97 && inpusr[i] <= 122) {
            int encoded_char;
            encoded_char = inpusr[i] + key;
            if (encoded_char > 122) {
                encoded_char = (encoded_char - 122) + 96;
            }
            inpusr[i] = encoded_char;
        }
    }
    printf ("%s\n", inpusr);
    return 0;
}
----------------------------------------

int main () {
    char inpusr [100];
    char key_input [3];
    int key = 0;
    int len = 100;
    fgets (inpusr, len, stdin);
    printf ("%s\n", inpusr);
    fgets (key_input, 3, stdin);
    key = atoi (key_input);
    printf ("%d\n", key);
    while (len--) {
        if (inpusr[len] >= 97 && inpusr[len] <= 122)
            inpusr[len] = (inpusr[len] - 97 + (key % 26) + 26) % 26 + 97;
    }
    printf ("%s\n", inpusr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48447689_48449952_22_75
48447689_48451169_44_59
Title: "c obtaining a special random number" 
----------------------------------------

int main (void) {
    int pop = 0;
    unsigned v = 0, n = NBITS;
    size_t its = 1;
    srand (time (NULL));
    v |= 1u << (NBITS - 1 - rand_int (sizeof v + 1));
    pop++;
    while (pop < BPOP) {
        if (++its >= LIMIT) {
            pop = its = 1;
            v = 0;
            v |= 1u << (NBITS - 1 - rand_int (sizeof v + 1));
        }
        unsigned shift = rand_int (NBITS);
        if (v & (1u << shift))
            continue;
        if ((shift + 2) < NBITS && v & (1u << (shift + 2)))
            continue;
        if ((int) (shift - 2) >= 0 && v & (1u << (shift - 2)))
            continue;
        if ((shift + 1) < NBITS && v & (1u << (shift + 1)))
            continue;
        if ((int) (shift - 1) >= 0 && v & (1u << (shift - 1)))
            continue;
        v |= 1u << shift;
        pop++;
    }
    printf ("\nv : 0x%08x\n", v);
    while (n--) {
        if (n + 1 < NBITS && (n + 1) % 4 == 0)
            putchar ('-');
        putchar ((v >> n & 1) ? '1' : '0');
    }
    putchar ('\n');
    return 0;
}
----------------------------------------

int main () {
    int i;
    uint32_t val = 01111111111;
    srand (time (NULL));
    for (i = 0; i < 4; i++) {
        int p = rand () % 11;
        printf ("p=%d\n", p);
        val = insert (val, p);
    }
    binprint (val);
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48461705_48461900_17_30
48461705_48463130_1_11
Title: "For loop gets stuck in a function call in C (cygwin) very weird behavior i couldn't understand" 
----------------------------------------

char *someoneDidSomething (void) {
    char *message = malloc (256);
    message[0] = '\0';
    strcat (message, "Bob");
    strcat (message, " ");
    strcat (message, "jumped");
    strcat (message, " ");
    strcat (message, "high");
    strcat (message, ".");
    return message;
}
----------------------------------------

char *someoneDidSomething () {
    char message [255];
    strcat (message, getPerson ());
    strcat (message, " ");
    strcat (message, getVerb ());
    strcat (message, " ");
    strcat (message, getSomething ());
    strcat (message, ".");
    return message;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48474249_48475196_1_29
48474249_48476268_3_28
Title: How to count odd digits in unsigned long number in C 
----------------------------------------

int check_odd (unsigned long n) {
    if ((n / 1000) == 0) {
        if (((n % 10) != ((n % 100) / 10)) && (n % 10) != ((n % 1000) / 100) && ((n % 100) / 10) != ((n % 1000) / 100) && (n % 10) % 2 != 0 && ((n % 100) / 10) % 2 != 0 && ((n % 1000) / 100) % 2 != 0) {
            return 0;
        }
        else
            return 1;
    }
    else {
        if ((n % 10) % 2 == 0) {
            return check_odd (n / 10);
        }
        else {
            int i = 100;
            while ((n % 10) % 2) {
                if (((n % i) / (i / 10)) % 2 == 0) {
                    unsigned long temp = n / i;
                    n = (temp * (i / 10)) + (n % (i / 10));
                    return check_odd (n);
                }
                else if (((n % 10)) == ((n % i) / (i / 10))) {
                    return check_odd (n / 10);
                }
                i = i * 10;
            }
        }
    }
    return 0;
}
----------------------------------------

int check_odd (unsigned long n) {
    int d1, d2, d3, n2;
    if (n < 100)
        return 1;
    d1 = n % 10;
    d2 = (n / 10) % 10;
    d3 = (n / 100) % 10;
    n2 = n / 1000;
    if ((d3 & 1) == 1)
        n2 = n2 * 10 + d3;
    if ((d2 & 1) == 1 && d2 != d3)
        n2 = n2 * 10 + d2;
    if ((d1 & 1) == 1 && d1 != d2 && d1 != d3)
        n2 = n2 * 10 + d1;
    if (n == n2)
        return 0;
    return check_odd (n2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48480629_48481825_8_78
48480629_48482264_8_68
Title: saving to a string from a pipe 
----------------------------------------

int main () {
    FILE *fp;
    int status;
    char path [PATH_LEN];
    int i, j = 0;
    size_t nr_of_elements = MAX_NR_OF_ENTRIES;
    char **old_arr;
    char **new_arr;
    char **s = calloc (nr_of_elements, sizeof (char *));
    fp = popen ("/bin/ls -l", "r");
    if (fp == NULL) {
        printf ("fp error\n");
    }
    while (fgets (path, PATH_LEN, fp) != NULL) {
        printf ("%s\n", path);
        char *str = malloc (strlen (path) +1);
        strcpy (str, path);
        s[i] = str;
        i++;
        if (i >= nr_of_elements) {
            printf ("resizing\n");
            size_t old_size = nr_of_elements;
            nr_of_elements = 4 * nr_of_elements;
            old_arr = s;
            new_arr = calloc (nr_of_elements, sizeof (char *));
            if (!new_arr) {
                perror ("new calloc failed");
                exit (EXIT_FAILURE);
            }
            memcpy (new_arr, old_arr, sizeof (char *) * old_size);
            free (old_arr);
            s = new_arr;
        }
    }
    status = pclose (fp);
    if (status == -1) {
        printf ("pclose error");
    }
    else {
        printf ("pclose was fine!\n");
    }
    for (j = 0; j < i; j++) {
        printf ("%s\n", s [j]);
        free (s [j]);
    }
    free (s);
    return 0;
}
----------------------------------------

int main () {
    size_t i, n = 0, nfiles = NFILES;
    char path [PATH_MAX] = "", **files = NULL;
    FILE *fp = popen ("/bin/ls -l", "r");
    if (fp == NULL) {
        perror ("popen");
        return 1;
    }
    if (!(files = malloc (nfiles * sizeof *files))) {
        perror ("malloc - files");
        return 1;
    }
    while (fgets (path, PATH_MAX, fp)) {
        size_t len = strlen (path);
        if (len && path[len - 1] == '\n')
            path[--len] = 0;
        else if (len + 1 == PATH_MAX) {
            fprintf (stderr, "error: path too long.\n");
        }
        if (!(files[n] = malloc (len +1))) {
            perror ("malloc - files[n]");
            break;
        }
        strcpy (files [n ++], path);
        if (n == nfiles) {
            void *tmp = realloc (files, nfiles *2 * sizeof *files);
            if (!tmp) {
                perror ("realloc");
                break;
            }
            files = tmp;
            nfiles *= 2;
        }
    }
    if (pclose (fp) == -1)
        perror ("pclose");
    for (i = 0; i < n; i++) {
        printf ("%s\n", files [i]);
        free (files [i]);
    }
    free (files);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48482427_48482634_53_67
48482427_48483107_35_54
Title: Expanding size of array to growing number of variables 
----------------------------------------

int append (Array *array, char *elem) {
    if (array == NULL || elem == NULL)
        return 0;
    if (array->used >= array->size) {
        if (!resize_array (array, array->size + 2))
            return 0;
    }
    array->words[array->used++] = strdup (elem);
    return 1;
}
----------------------------------------

void append (arr *array, char *elem) {
    if (array->used >= array->size) {
        void *tmp = realloc (array->pointer, array->size * 2 * sizeof *array->pointer);
        if (!tmp) {
            perror ("realloc - array->pointer");
            return;
        }
        array->pointer = tmp;
        array->size *= 2;
    }
    if (strlen (elem) + 1 < sizeof *array->pointer) {
        strcpy (array -> pointer [array -> used], elem);
        array->used++;
    }
    else
        fprintf (stderr, "error: token too long.\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48482427_48482634_7_23
48482427_48483107_14_33
Title: Expanding size of array to growing number of variables 
----------------------------------------

Array *createArray (size_t size) {
    Array *array = malloc (sizeof *array);
    if (array == NULL)
        return NULL;
    array->used = 0;
    array->size = size;
    array->words = calloc (size, sizeof *array->words);
    if (array->words == NULL) {
        free (array);
        return NULL;
    }
    return array;
}
----------------------------------------

arr *createArray (int start_size) {
    arr *array = malloc (sizeof *array);
    if (!array) {
        perror ("malloc - array");
        exit (EXIT_FAILURE);
    }
    array->used = 0;
    array->size = start_size;
    array->pointer = malloc (start_size * sizeof *array->pointer);
    if (!array->pointer) {
        perror ("malloc - array->pointer");
        exit (EXIT_FAILURE);
    }
    return array;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48488927_48490717_5_58
48488927_48491502_7_50
Title: Loading strings divided by delimiter to array 
----------------------------------------

int main () {
    char **arrayValues = malloc (sizeof (char *));
    char str [] = "value1;value2;value3\n";
    char *p1 = str;
    char *p2 = str;
    int n = 0;
    size_t len = strlen (str);
    if (len > 0)
        if (str[len - 1] == '\n')
            str[len - 1] = 0;
    while (p1 != NULL) {
        p1 = strchr (p1, ';');
        if (p1 != NULL) {
            arrayValues[n] = p2;
            *p1 = 0;
            n++;
            arrayValues = realloc (arrayValues, (n + 1) * sizeof (char *));
            p2 = p1 + 1;
            p1 = p1 + 1;
        }
        else {
            arrayValues[n] = p2;
            n++;
        }
    }
    for (int j = 0; j < n; j++) {
        printf ("%s \n", arrayValues [j]);
    }
    printf ("------");
    free (arrayValues);
    return 0;
}
----------------------------------------

int main (void) {
    char str [] = "value0;value1;value2;value3;\n", **array = NULL, *p = str, *delim = ";\n";
    int i, n = 0, nptrs = MAXS;
    if (!(array = malloc (nptrs * sizeof *array))) {
        perror ("malloc pointers failed");
        exit (EXIT_FAILURE);
    }
    p = strtok (p, delim);
    while (p) {
        if (!(array[n] = malloc (strlen (p) +1))) {
            perror ("malloc failed");
            exit (EXIT_FAILURE);
        }
        strcpy (array [n ++], p);
        if (n == nptrs) {
            void *tmp = realloc (array, nptrs *2 * sizeof *array);
            if (!tmp) {
                perror ("realloc - pointers");
                goto memfull;
            }
            array = tmp;
            nptrs *= 2;
        }
        p = strtok (NULL, delim);
    }
memfull :
    ;
    for (i = 0; i < n; i++) {
        printf ("array[%2d] : %s\n", i, array [i]);
        free (array [i]);
    }
    free (array);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48492259_48492421_5_23
48492259_48492423_1_40
Title: String Arrays: Delete original array and then return copy 
----------------------------------------

char **adding_string (char **array, const char *str) {
    size_t num = strlen (str) + 1;
    char *final = (char *) malloc (num);
    strncpy (final, str, num);
    int i = 0;
    for (i = 0; array[i] != NULL; i++) {
    }
    array[i] = final;
    i++;
    char **new_array = calloc (1 + i, sizeof (char *));
    memcpy (new_array, array, sizeof (char *) * i);
    free (array);
    return new_array;
}
----------------------------------------

char **adding_string (char **array, const char *str) {
    char **tmp;
    if (str == NULL)
        return NULL;
    size_t len = strlen (str);
    char *strcopy = malloc (len +1);
    if (strcopy == NULL)
        return NULL;
    strcpy (strcopy, str);
    size_t size = 0;
    if (array) {
        tmp = array;
        while (*(tmp++))
            size++;
    }
    tmp = realloc (array, (size + 2) * sizeof *tmp);
    if (tmp == NULL) {
        free (strcopy);
        return NULL;
    }
    tmp[size] = strcopy;
    tmp[size + 1] = NULL;
    return tmp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48516962_48517225_43_57
48516962_48517226_16_29
Title: returning result or fault to the caller of the function 
----------------------------------------

int main () {
    err_t err;
    int result;
    result = division (4, 2, NULL);
    printf ("%d\n", result);
    result = division (4, 0, &err);
    if (err.code != ERR_NONE) {
        error_handler (& err);
    }
    printf ("%d\n", result);
}
----------------------------------------

int main () {
    Error err;
    int retValue = div (4, 2, &err);
    if (retValue < 0) {
        printf ("Code: %d, Message: %s\n", err -> code, err -> message);
    }
    else {
        printf ("%d\n", retValue);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48527814_48528010_3_29
48527814_48528760_9_66
Title: User defined array elements and array size in C 
----------------------------------------

int main () {
    int *arr = malloc (1 * sizeof (int));
    int counter = 2;
    while (1) {
        printf ("Enter element %d: ", a);
        arr = realloc (arr, counter * sizeof (int));
        counter++;
        scanf ("%d", & arr [counter]);
        if (getchar () == 'q')
            break;
    }
    printf ("Array: [");
    for (int a = 0; a < counter - 1; a++) {
        printf ("%d, ", array [a]);
    }
    printf ("%d]", array [counter]);
    printf ("\nArray length: %d\n", counter);
    return 0;
}
----------------------------------------

int main (void) {
    size_t sz = 0, tsz = MAXLEN;
    int *arr = malloc (sizeof *arr * MAXLEN);
    if (!arr) {
        perror ("malloc:");
        exit (EXIT_FAILURE);
    }
    char s [MAXBUFF];
    while (fgets (s, MAXBUFF, stdin) != NULL) {
        if (strstr (s, "q") != NULL) {
            break;
        }
        else {
            char *t;
            errno = 0;
            long n = strtol (s, &t, 10);
            if ((errno == ERANGE && (n == LONG_MAX || n == LONG_MIN)) || (errno != 0 && n == 0)) {
                perror ("strtol");
                exit (EXIT_FAILURE);
            }
            if (t == s) {
                fprintf (stderr, "No digits were found\n");
                exit (EXIT_FAILURE);
            }
            if (n >= INT_MIN && n <= INT_MAX) {
                arr[sz++] = (int) n;
            }
            else {
                fprintf (stderr, "Too big/small a number\n");
                exit (EXIT_FAILURE);
            }
        }
        if (sz == tsz) {
            int *p = realloc (arr, sizeof *p * (tsz + MAXLEN));
            if (!p) {
                perror ("Realloc:");
                exit (EXIT_FAILURE);
            }
            arr = p;
            tsz += MAXLEN;
        }
    }
    int *p = realloc (arr, sizeof *p * sz);
    if (!p) {
        perror ("Realloc:");
        exit (EXIT_FAILURE);
    }
    arr = p;
    printf ("Numbers entered = %zu\n", sz);
    for (size_t i = 0; i < sz; i++)
        printf ("a[%zu]=%d\n", i, arr[i]);
    free (arr);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48529073_48529163_3_33
48529073_48529289_5_23
Title: Count how many integers are in the text file using fscanf 
----------------------------------------

int main () {
    int temp;
    int count = 0;
    FILE *file = fopen ("file1.txt", "r");
    if (file == NULL) {
        printf ("Could not open specified file");
        return -1;
    }
    while (fscanf (file, "%d", &temp) == 1) {
        count++;
    }
    printf ("%d", count);
    if (count == 0) {
        fclose (file);
    }
    else {
        int array [count];
        rewind (file);
        for (int i = 0; i < count; i++) {
            fscanf (file, "%d", & array [count]);
        }
        fclose (file);
    }
    return 0;
}
----------------------------------------

int main () {
    FILE *fd;
    int counter, c, tmp;
    if ((fd = fopen ("PathToFile", "r")) != NULL) {
        do {
            c = getc (fd);
            if (isDigit (c))
                tmp = 1;
            else if (tmp == 1 && !isDigit (c)) {
                counter++, tmp = 0;
            }
        }
        while (c != EOF);
    }
    else {
        printf ("Couldn't find File!");
        return 1;
    }
    fclose (fd);
    printf ("%i", counter);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48532407_48532501_3_13
48532407_48532502_1_10
Title: How to pass a 2D Char array to another function? 
----------------------------------------

void read_files (char *names) {
    char newName1 [4] = "mary";
    char newName2 [4] = "anna";
    for (int i = 0; i < 5; i++) {
        names[i] = newName1[i];
    }
    int offset = 25;
    for (int i = 0; i < 5; i++) {
        names[i + offset] = newName2[i];
    }
}
----------------------------------------

void read_files (char (*names) [25]) {
    char newName1 [5] = "mary";
    char newName2 [5] = "anna";
    for (int i = 0; i < 5; i++) {
        names[0][i] = newName1[i];
    }
    for (int i = 0; i < 5; i++) {
        names[1][i] = newName2[i];
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48532957_48533067_20_66
48532957_48533489_6_25
Title: Writing a string to hex convertor 
----------------------------------------

int main (void) {
    char hex [] = "6162636465";
    char *tmp_hex = NULL;
    uint8_t *in;
    size_t hexlen = strlen (hex);
    size_t in_size = hexlen / 2;
    if (hexlen % 2) {
        tmp_hex = calloc (hexlen +2, 1);
        if (tmp_hex == NULL)
            return 1;
        *tmp_hex = '0';
        strcat (tmp_hex, hex);
        in_size++;
    }
    else
        tmp_hex = hex;
    in = calloc (in_size, sizeof *in);
    if (in == NULL) {
        if (tmp_hex != hex)
            free (tmp_hex);
        return 1;
    }
    for (size_t i = 0; i < hexlen; i = i + 2)
        in[i / 2] = 16 * hexchar_to_dec (tmp_hex[i]) + hexchar_to_dec (tmp_hex[i + 1]);
    for (size_t i = 0; i < in_size; ++i)
        printf ("in[%lu] = 0x%02x\n", i, in[i]);
    free (in);
    if (tmp_hex != hex)
        free (tmp_hex);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    if (argc < 2) {
        fprintf (stderr, "error: insufficient input, %s <hexval>\n", argv [0]);
        return 1;
    }
    char *s = argv[1];
    size_t i = 0, len = strlen (s);
    uint8_t bytes [len];
    for (i = 0; i < len; i++)
        bytes[i] = s[i];
    for (i = 0; i < len; i++)
        printf (" 0x%02" PRIx8, bytes[i]);
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48541338_49259604_16_54
48541338_49261339_18_54
Title: Does POSIX specify that only one signal can interrupt pselect? 
----------------------------------------

int main (int argc, char **argv) {
    sigset_t mask;
    sigemptyset (& mask);
    sigaddset (& mask, SIGUSR1);
    sigaddset (& mask, SIGUSR2);
    sigprocmask (SIG_SETMASK, & mask, NULL);
    sigfillset (& mask);
    sigdelset (& mask, SIGUSR1);
    sigdelset (& mask, SIGUSR2);
    sigdelset (& mask, SIGTERM);
    signal (SIGUSR1, handle);
    signal (SIGUSR2, handle);
    pid_t t = fork ();
    switch (t) {
    default :
        while (1) {
            pselect (0, NULL, NULL, NULL, NULL, & mask);
            write (1, ".", 1);
        }
        break;
    case 0 :
        t = getppid ();
        for (int i = 0; i < 4; i++) {
            kill (t, SIGUSR1);
            kill (t, SIGUSR2);
            write (1, "^", 1);
            sleep (5);
        }
        kill (t, SIGTERM);
        break;
    case -1 :
        perror ("fork\n");
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    sigset_t curmask;
    sigemptyset (& curmask);
    sigaddset (& curmask, SIGUSR1);
    sigaddset (& curmask, SIGUSR2);
    sigprocmask (SIG_SETMASK, & curmask, NULL);
    sigset_t mask;
    sigfillset (& mask);
    sigdelset (& mask, SIGUSR1);
    sigdelset (& mask, SIGUSR2);
    struct sigaction action;
    action.sa_sigaction = handle_usr1;
    sigfillset (& action.sa_mask);
    action.sa_flags = SA_SIGINFO;
    sigaction (SIGUSR1, & action, NULL);
    action.sa_sigaction = handle_usr2;
    sigaction (SIGUSR2, & action, NULL);
    raise (SIGUSR1);
    raise (SIGUSR2);
    pselect (0, NULL, NULL, NULL, NULL, & mask);
    int count = got_usr1 + got_usr2;
    printf ("Handled %d signals while in pselect.\n", count);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48594599_48594941_4_18
48594599_48595034_2_18
Title: My program does not detect the last character while printing the line with its line number in c language? 
----------------------------------------

int main (void) {
    char str [2048];
    int ln = 0;
    printf ("%5d) ", ++ ln);
    while (fgets (str, sizeof str, stdin)) {
        printf ("%s", str);
        if (strchr (str, '\n')) {
            printf ("%5d) ", ++ ln);
        }
    }
    puts ("EOF");
    return 0;
}
----------------------------------------

int main (void) {
    int ch;
    long long line_count = 0;
    long long column_position = 0;
    printf ("Enter the line :\n");
    while ((ch = getchar ()) != EOF) {
        if (column_position == 0) {
            printf ("%lld\t", ++ line_count);
        }
        column_position++;
        putchar (ch);
        if (ch == '\n') {
            column_position = 0;
        }
    }
    fflush (stdout);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48596609_48597073_10_32
48596609_48597086_36_52
Title: Remove a word from a sentence (string) 
----------------------------------------

int main (void) {
    const char word_to_delete [] = "boy";
    fputs ("Enter string: ", stdout);
    char buf [256];
    fgets (buf, sizeof (buf), stdin);
    if (delete_word (buf, word_to_delete)) {
        printf ("Word %s deleted from buf: ", word_to_delete);
        puts (buf);
    }
    else {
        printf ("Word %s not found in buf: ", word_to_delete);
        puts (buf);
    }
    system ("PAUSE");
    return 0;
}
----------------------------------------

int main () {
    char stringFirst [102];
    char stringSecond [22];
    printf ("Type your text here, up to 100 characters:\n");
    if (!input (stringFirst, sizeof stringFirst))
        return 1;
    printf ("\nInsert the word you wish to remove from your text: ");
    if (!input (stringSecond, sizeof stringSecond))
        return 1;
    printf ("\nAfter removing the word, the text looks like this now: %s\n", remove_word (stringFirst, stringSecond));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48597692_48597730_1_10
48597692_48597771_1_12
Title: Program failed in executing step by step 
----------------------------------------

int binaryToDecimal (long binarynum) {
    int decimalnum = 0, temp = 0, remainder;
    while (binarynum != 0) {
        remainder = binarynum % 10;
        remainder = binarynum / 10;
        decimalnum = decimalnum + remainder * pow (2, temp);
        temp++;
    }
    return decimalnum;
}
----------------------------------------

int binaryToDecimal (long n) {
    int decimalNumber = 0, i = 0, remainder;
    while (n != 0) {
        remainder = n % 10;
        n /= 10;
        decimalNumber += remainder * pow (2, i);
        ++i;
    }
    return decimalNumber;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48601541_48602289_50_89
48601541_48603157_56_91
Title: iterate a dynamically allocated char array 
----------------------------------------

int main (int argc, char *argv []) {
    str_size = 10;
    strings = malloc (str_size * sizeof (char *));
    if (strings == NULL) {
        printf ("Error: Allocation failure in \"main\"!\n");
        exit (EXIT_FAILURE);
    }
    installString ("2234");
    installString ("2222");
    installString ("3223");
    installString ("2222");
    while (--argc) {
        char *id = *(++argv);
        int index;
        index = indexOf (id);
        if (index > -1) {
            printf ("The User ID \"%s\" exists at index %d!\n", id, index);
        }
        else {
            installString (id);
            printf ("Installed \"%s\"!\n", id);
        }
    }
    for (int i = 0; i < str_idx; i++) {
        free (strings [i]);
    }
    free (strings);
    return EXIT_SUCCESS;
}
----------------------------------------

int main (int argc, char **argv) {
    int nptrs = argc > 1 ? (int) strtol (argv[1], NULL, 0) : NREDUCR, ndx = 0, i;
    char user [MAXC] = "";
    char **users = NULL;
    users = malloc (nptrs * sizeof *users);
    if (!users) {
        perror ("malloc - users");
        exit (EXIT_FAILURE);
    }
    while (fgets (user, MAXC, stdin)) {
        size_t len = strlen (user);
        if (len && user[len - 1] == '\n')
            user[--len] = 0;
        else if (len - 1 == MAXC) {
            fprintf (stderr, "error: ID too long.\n");
            exit (EXIT_FAILURE);
        }
        users = adduser (users, user, &ndx, &nptrs);
    }
    putchar ('\n');
    for (i = 0; i < ndx; i++) {
        printf ("user[%2d] : %s\n", i, users [i]);
        free (users [i]);
    }
    free (users);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48605835_48605978_1_26
48605835_48606403_6_50
Title: read complex file content to 2D array (matrix) C language 
----------------------------------------

int main (void) {
    FILE *fp = fopen ("test.txt", "r");
    char pattern [5] [5];
    int size = 0;
    fscanf (fp, "%d\n", & size);
    char buf [100];
    int i = 0;
    while (fgets (buf, sizeof (buf), fp)) {
        for (int j = 0; j < 5; j++) {
            pattern[i][j] = buf[j];
            printf ("%c", pattern [i] [j]);
        }
        printf ("\n");
        i++;
        if (i == size)
            break;
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int i, j, n = 0;
    char buf [MAXC] = "";
    FILE *fp = argc > 1 ? fopen (argv[1], "r") : stdin;
    if (!fp) {
        fprintf (stderr, "error: file open failed '%s'.\n", argv [1]);
        return 1;
    }
    if (!fgets (buf, MAXC, fp)) {
        fprintf (stderr, "error: no number on line 1.\n");
        return 1;
    }
    if (sscanf (buf, "%d", &n) != 1) {
        fprintf (stderr, "error: num rows not parsed from 1st line.\n");
        return 1;
    }
    char array [n] [n];
    for (i = 0; i < n; i++) {
        if (!fgets (buf, MAXC, fp)) {
            fprintf (stderr, "error: read failed at line %d\n", i + 1);
            return 1;
        }
        if (strlen (buf) == MAXC - 1) {
            fprintf (stderr, "error: line %d too long.\n", i + 1);
            return 1;
        }
        for (j = 0; j < n; j++)
            array[i][j] = buf[j];
    }
    if (fp != stdin)
        fclose (fp);
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++)
            putchar (array[i][j]);
        putchar ('\n');
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48611174_48611193_18_73
48611174_48611366_15_50
Title: C pointers in arrays 
----------------------------------------

int main (void) {
    struct A *a1;
    struct A *a2;
    struct A *a3;
    struct A *a_array [3];
    struct B *b_imp;
    short i;
    a1 = malloc (sizeof (struct A));
    a2 = malloc (sizeof (struct A));
    a3 = malloc (sizeof (struct A));
    if (!a1 || !a2 || !a3) {
        perror ("malloc");
        exit (EXIT_FAILURE);
    }
    a1->val = 1;
    a2->val = 2;
    a3->val = 3;
    a_array[0] = a1;
    a_array[1] = a2;
    a_array[2] = a3;
    b_imp = malloc (sizeof (struct B));
    if (!b_imp) {
        perror ("malloc");
        exit (EXIT_FAILURE);
    }
    b_imp->ptr = calloc (ARRAYSIZE, sizeof (struct A *));
    if (!b_imp->ptr) {
        perror ("calloc");
        exit (EXIT_FAILURE);
    }
    b_imp->iter = 0;
    for (i = 0; i < ARRAYSIZE; i++) {
        b_imp->ptr[b_imp->iter++] = a_array[i];
    }
    a3->val = 5;
    for (i = 0; i < b_imp->iter; i++) {
        printf ("Value: %d\n", b_imp -> ptr [i] -> val);
    }
    for (i = 0; i < b_imp->iter; i++) {
        free (a_array [i]);
        b_imp->ptr[i] = NULL;
    }
    free (b_imp -> ptr);
    free (b_imp);
    return 0;
}
----------------------------------------

int main () {
    struct A *a1;
    struct A *a2;
    struct A *a3;
    struct A *a_array [ARRAYSIZE];
    struct B *b_imp;
    short i;
    a1 = (struct A *) malloc (sizeof (struct A));
    a2 = (struct A *) malloc (sizeof (struct A));
    a3 = (struct A *) malloc (sizeof (struct A));
    a1->val = 1;
    a2->val = 2;
    a3->val = 3;
    a_array[0] = a1;
    a_array[1] = a2;
    a_array[2] = a3;
    b_imp = (struct B *) malloc (sizeof (struct B));
    b_imp->ptr = (struct A **) calloc (ARRAYSIZE, sizeof (struct A *));
    b_imp->iter = 0;
    for (i = 0; i < ARRAYSIZE; i++) {
        b_imp->ptr[b_imp->iter++] = a_array[i];
    }
    a3->val = 5;
    for (i = 0; i < b_imp->iter; i++) {
        printf ("Value: %d\n", b_imp -> ptr [i] -> val);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48613946_48614188_5_28
48613946_48614204_3_24
Title: "I have to ask user to input an array a1 of length n. Then use a function to print every third element in an array" 
----------------------------------------

int main (void) {
    int n, i;
    printf ("Enter the length of the array: ");
    scanf ("%d", & n);
    int a1 [n];
    printf ("Enter %d numbers: \n", n);
    for (i = 0; i < n; i++) {
        printf ("Enter a number: ");
        scanf ("%d", & a1 [i]);
    }
    int a2 [n / 3];
    decimate_by3 (a1, n, a2);
    for (i = 0; i < n / 3; i++) {
        printf ("%d ", a2 [i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    int n;
    printf ("Enter the length of the array: ");
    scanf ("%d", & n);
    if (n <= 0)
        return 0;
    int a1 [n];
    printf ("Enter %d numbers: ", n);
    for (int i = 0; i < n; i++)
        scanf ("%d", &a1[i]);
    int a2 [n / 3 + 1];
    decimate_by3 (a1, n, a2);
    printf ("Output: ");
    for (int j = 0; j < n / 3 + 1; j++)
        printf ("%i ", a2[j]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48631075_48631157_1_12
48631075_48631396_5_17
Title: string issue with strstr() 
----------------------------------------

int count_substr (const char *str, const char *sub) {
    int cnt = 0;
    char *found;
    while (found = strstr (str, sub)) {
        cnt++;
        str = found + 1;
    }
    return cnt;
}
----------------------------------------

int count_substr (const char *str, const char *sub) {
    int i = 0;
    size_t sub_len = strlen (sub);
    const char *res = strstr (str, sub);
    while (res) {
        i++;
        str = res + sub_len;
        res = strstr (str, sub);
    }
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48631075_48631157_1_12
48631075_48631577_18_37
Title: string issue with strstr() 
----------------------------------------

int count_substr (const char *str, const char *sub) {
    int cnt = 0;
    char *found;
    while (found = strstr (str, sub)) {
        cnt++;
        str = found + 1;
    }
    return cnt;
}
----------------------------------------

int count_substr (const char *str, const char *sub) {
    int count = 0;
    int index = 0;
    char *oldres = NULL;
    char *newres = NULL;
    do {
        newres = strstr (&str[index], sub);
        index++;
        if (newres != oldres && newres)
            count++;
        oldres = newres;
    }
    while (oldres);
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48631075_48631396_5_17
48631075_48631577_18_37
Title: string issue with strstr() 
----------------------------------------

int count_substr (const char *str, const char *sub) {
    int i = 0;
    size_t sub_len = strlen (sub);
    const char *res = strstr (str, sub);
    while (res) {
        i++;
        str = res + sub_len;
        res = strstr (str, sub);
    }
    return i;
}
----------------------------------------

int count_substr (const char *str, const char *sub) {
    int count = 0;
    int index = 0;
    char *oldres = NULL;
    char *newres = NULL;
    do {
        newres = strstr (&str[index], sub);
        index++;
        if (newres != oldres && newres)
            count++;
        oldres = newres;
    }
    while (oldres);
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48638619_48638717_3_26
48638619_48638806_2_20
Title: issue with string copying 
----------------------------------------

int es_cat (char *dst, const char *src) {
    const char *orig_dst = dst;
    while (*dst != '\0' && *dst != '?') {
        ++dst;
    }
    while (*src != '\0' && *src != '?') {
        *dst++ = *src++;
    }
    *dst = '\0';
    return dst - orig_dst;
}
----------------------------------------

int es_cat (char *dst, char *src) {
    char c [STRING_SIZE * 2];
    int i = 0;
    while (*dst != '?') {
        c[i] = *dst;
        dst++;
        i++;
    }
    while (*src != '?') {
        c[i] = *src;
        src++;
        i++;
    }
    c[i] = '?';
    memcpy (dst, c, i);
    dst[i + 1] = '\0';
    printf ("\n%s", dst);
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48641491_48641783_1_15
48641491_48642410_1_28
Title: Changing character in a string to two characters 
----------------------------------------

void antikorso (char *dest, const char *src) {
    const char *p = src;
    int i;
    for (i = 0; *p != '\0'; i++, p++) {
        if (*p != 'x') {
            dest[i] = *p;
        }
        else {
            dest[i++] = 'k';
            dest[i] = 's';
        }
    }
    dest[i] = '\0';
    printf ("\n%s", dest);
}
----------------------------------------

size_t antikorso (char *dest, size_t length, const char *src) {
    char *d = dest;
    char *end = d + length;
    for (; *src; ++src, ++d) {
        if (d == end)
            break;
        *d = *src;
        if (*d == 'x') {
            * d = 'k' if (++ d == end) break;
            *d = 's';
        }
    }
    d -= d == end;
    *d = 0;
    return d - dest;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48662517_48662991_1_21
48662517_48663491_4_16
Title: Long Long Decimal Binary Representation using C 
----------------------------------------

int main () {
    char bits [64];
    int i = 0;
    unsigned long long number;
    scanf ("%lld", & number);
    while (number > 0) {
        bits[i++] = number & 1;
        number >>= 1;
    }
    if (i == 0)
        printf ("0");
    for (; i > 0; i--)
        printf ("%d", bits[i]);
    printf ("\n");
}
----------------------------------------

int main () {
    unsigned long long number;
    int binaryRepresentation [70], remainder, counter, count = 0;
    scanf ("%llu", & number);
    while (number > 0) {
        remainder = number % 2;
        binaryRepresentation[count++] = remainder;
        number = number / 2;
    }
    for (counter = count - 1; counter >= 0; counter--) {
        printf ("%d", binaryRepresentation [counter]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48671271_48677596_5_32
48671271_48681897_7_58
Title: Copying usernames and password from a file onto another in C 
----------------------------------------

int main (void) {
    FILE *passwords = fopen ("/Users/mcicco/Desktop/passwords.txt", "r");
    FILE *usernames = fopen ("/Users/mcicco/Desktop/usernames.txt ", "r");
    FILE *merged_file = fopen ("/Users/mcicco/Desktop/merged.txt", "w");
    if (usernames == NULL || passwords == NULL || merged_file == NULL) {
        printf ("Cannot open file \n");
        return (-1);
    }
    char username [1024];
    char password [1024];
    while (1) {
        if (!fgets (username, sizeof (username), usernames))
            break;
        if (!fgets (password, sizeof (password), passwords))
            break;
        username[strcspn (username, "\n")] = 0;
        password[strcspn (password, "\n")] = 0;
        fprintf (merged_file, "%s\n%s\n", username, password);
    }
    fclose (usernames);
    fclose (passwords);
    fclose (merged_file);
    return 0;
}
----------------------------------------

int main (void) {
    FILE *usernames;
    FILE *passwords;
    FILE *merged_file;
    if (NULL == (passwords = fopen ("/Users/mcicco/Desktop/passwords.txt", "r"))) {
        perror ("fopen to read passwords.txt failed");
        exit (EXIT_FAILURE);
    }
    if (NULL == (usernames = fopen ("/Users/mcicco/Desktop/usernames.txt", "r"))) {
        perror ("fopen to read usernames.txt failed");
        fclose (passwords);
        exit (EXIT_FAILURE);
    }
    if (NULL == (merged_file = fopen ("/Users/mcicco/Desktop/merged.txt", "w"))) {
        perror ("fopen to write merged.txt failed");
        fclose (passwords);
        fclose (usernames);
        exit (EXIT_FAILURE);
    }
    char passwordsBuffer [BUFF_SIZE];
    char usernamesBuffer [BUFF_SIZE];
    while (fgets (passwordsBuffer, sizeof passwordsBuffer, passwords) && fgets (usernamesBuffer, sizeof usernamesBuffer, usernames)) {
        char *newline;
        if (NULL != (newline = strchr (passwordsBuffer, '\n'))) {
            *newline = '\0';
        }
        if (NULL != (newline = strchr (usernamesBuffer, '\n'))) {
            *newline = '\0';
        }
        fprintf (merged_file, "%s %s\n", usernamesBuffer, passwordsBuffer);
    }
    fclose (usernames);
    fclose (passwords);
    fclose (merged_file);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48701437_48701783_1_11
48701437_48702049_5_21
Title: Unix based OS: Coding Bug 
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    printf ("number of arguments : %d ", argc);
    for (i = 0; i < argc; i++) {
        printf ("argument number %d : %s", i, argv [i]);
    }
    printf ("\n");
    exit (0);
}
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    write (1, "user space: ", 12);
    for (i = 1; i < argc; i++) {
        size_t len = strlen (argv[i]);
        write (1, argv [i], len);
        write (1, " ", 1);
    }
    write (1, "\n", 1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48743930_48744384_59_72
48743930_48744798_20_33
Title: singly linked linked list C reverse data reading 
----------------------------------------

int main (void) {
    node *head = (node *) malloc (sizeof (node));
    head->x = 0;
    head->next = NULL;
    createList (head, 10);
    PrintList (head);
    printf ("Now we are reversing the list\n");
    head = reverseList (head);
    PrintList (head);
    deleteList (head);
    head = NULL;
    return 0;
}
----------------------------------------

int main (void) {
    node a [NNODES] = {{
            .x = 0,
            .next = NULL
        }
    };
    for (int i = 0; i < NNODES; i++) {
        a[i].x = i + 1;
        if (i < NNODES - 1)
            a[i].next = &a[i + 1];
    }
    prn (a);
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48746999_48747227_3_12
48746999_48747349_8_20
Title: Swap without worrying about the data type 
----------------------------------------

int main (void) {
    char *a = "home";
    char *b = "root";
    char *c = a, *d = b;
    printf ("%s %s\n", a, b);
    a = d;
    b = c;
    printf ("%s %s \n", a, b);
    return 0;
}
----------------------------------------

int main (void) {
    char a [] = "home";
    char b [] = "door";
    printf ("%s %s\n", a, b);
    int ret = swap (a, b, sizeof (a), sizeof (b));
    if (ret) {
        printf ("%s %s \n", a, b);
    }
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48748511_48748539_2_17
48748511_48748612_2_12
Title: how do i print range of a sequence except one with while loop in c 
----------------------------------------

int main () {
    int n = 0;
    while (1) {
        n++;
        if (n == 998)
            continue;
        if (n > 1000)
            break;
        printf ("%d\n", n);
    }
    return 0;
}
----------------------------------------

int main () {
    for (int i = 1; i <= 1000; i++) {
        if (i == 998) {
            continue;
        }
        printf ("%d\n", i);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48748511_48748539_2_17
48748511_48748626_3_16
Title: how do i print range of a sequence except one with while loop in c 
----------------------------------------

int main () {
    int n = 0;
    while (1) {
        n++;
        if (n == 998)
            continue;
        if (n > 1000)
            break;
        printf ("%d\n", n);
    }
    return 0;
}
----------------------------------------

int main () {
    int n = 1;
    while (1) {
        if (n != 998) {
            printf ("%d\n", n);
        }
        n++;
        if (n > 1000) {
            break;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48748511_48748612_2_12
48748511_48748626_3_16
Title: how do i print range of a sequence except one with while loop in c 
----------------------------------------

int main () {
    for (int i = 1; i <= 1000; i++) {
        if (i == 998) {
            continue;
        }
        printf ("%d\n", i);
    }
    return 0;
}
----------------------------------------

int main () {
    int n = 1;
    while (1) {
        if (n != 998) {
            printf ("%d\n", n);
        }
        n++;
        if (n > 1000) {
            break;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48758176_48758246_1_17
48758176_48758256_14_27
Title: How to retrieve array from void function and pass to other functions in Main? 
----------------------------------------

int main (int argc, char *argv []) {
    int *grade = malloc ((argc - 1) * sizeof (int));
    getGrade (grade, argc - 1, argv);
    int max = findMaximum (grade, argc -1);
    int min = findMinimum (grade, argc -1);
    float avg = calculateAverage (grade, argc -1);
    results (max, min, avg);
    free (grade);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int grades [argc - 1];
    size_t len = argc - 1;
    getGrade (grades, len, argv);
    int max = findMaximum (grades, len);
    int min = findMinimum (grades, len);
    float avg = calculateAverage (grades, len);
    print results (max, min, avg);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48775151_48777428_4_24
48775151_48778260_3_28
Title: Trying to get a user input to make a 2-D array multiplication table 
----------------------------------------

int main () {
    int range, i, j;
    printf ("Enter size of the multiplication table:\n");
    scanf ("%d", & range);
    int **output = (int **) malloc (sizeof (int *) * (long unsigned int) range);
    for (i = 0; i <= range; ++i) {
        output[i] = (int *) malloc (sizeof (int) * (long unsigned int) range);
        for (j = 0; j <= range; ++j)
            printf ("%3d ", !i ? j : !j ? i : (output[i - 1][j - 1] = i * j));
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int range, i, j;
    printf ("Input size of multiplication table: ");
    if (scanf ("%i", &range) != 1) {
        fprintf (stderr, "error: invalid input.\n");
        return 1;
    }
    int output [range] [range];
    for (i = 0; i < range; i++) {
        for (j = 0; j < range; j++) {
            output[i][j] = (i + 1) * (j + 1);
        }
    }
    for (i = 0; i < range; i++) {
        for (j = 0; j < range; j++)
            printf (" %3d", output[i][j]);
        putchar ('\n');
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48797172_48797380_1_12
48797172_48797881_1_10
Title: Calculate a sequence of percentages using while loop in C 
----------------------------------------

int main () {
    double current = 0;
    double toAdd = 30;
    for (int i = 0; i < 5; i++) {
        for (int j = 0; j < 3; j++) {
            current += toAdd;
            printf ("%lf\n", current);
        }
        toAdd /= 10;
    }
}
----------------------------------------

int main (void) {
    double power10 = 1.0;
    for (int power = -1; power >= -5; power--) {
        power10 *= 10.0;
        for (int digit = 3; digit <= 9; digit += 3) {
            int dif = 10 - digit;
            printf ("%g%%\n", (1.0 - dif / power10) * 100.0);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48807085_48807245_35_48
48807085_48808566_35_55
Title: C code function calling not working 
----------------------------------------

int numero (int *array, int size) {
    int count = 0;
    int j;
    for (j = 0; j < size; j++) {
        if (array[j] < 0) {
            count++;
        }
    }
    return count;
}
----------------------------------------

int numero (int array [], int size, int count, int j) {
    if (j <= size - 1) {
        if (array[j] < 0) {
            count++;
            j++;
            numero (array, size, count, j);
        }
        else {
            j++;
            numero (array, size, count, j);
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48807085_48807245_35_48
48807085_48825200_21_32
Title: C code function calling not working 
----------------------------------------

int numero (int *array, int size) {
    int count = 0;
    int j;
    for (j = 0; j < size; j++) {
        if (array[j] < 0) {
            count++;
        }
    }
    return count;
}
----------------------------------------

int numero (int *array, int size) {
    int count = 0;
    for (int j = 0; j < size; j++) {
        if (array[j] < 0) {
            count++;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48807085_48807245_8_33
48807085_48807958_8_32
Title: C code function calling not working 
----------------------------------------

int main () {
    int vektor [100];
    int *vekt_ptr = &vektor[0];
    int i, madhesia;
    int counter;
    counter = 0;
    printf ("Madhesia e vektorit: ");
    scanf ("%d", & madhesia);
    printf ("Elementet: ");
    for (i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    recursive_count (vekt_ptr, madhesia, & counter);
    int ret = counter;
    printf ("\nTotal negative elements in array = %d", ret);
    return 0;
}
----------------------------------------

int main (void) {
    int vektor [N];
    size_t madhesia = 0;
    printf ("Madhesia e vektorit: ");
    scanf ("%zu", & madhesia);
    if (N < madhesia)
        madhesia = N;
    printf ("Elementet: ");
    for (size_t i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    size_t ret = iterative_numero (vektor, madhesia);
    printf ("\nTotal negative elements in array = %zu\n", ret);
    ret = recursive_numero (vektor, madhesia);
    printf ("Total negative elements in array = %zu\n", ret);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48807085_48807245_8_33
48807085_48808566_3_33
Title: C code function calling not working 
----------------------------------------

int main () {
    int vektor [100];
    int *vekt_ptr = &vektor[0];
    int i, madhesia;
    int counter;
    counter = 0;
    printf ("Madhesia e vektorit: ");
    scanf ("%d", & madhesia);
    printf ("Elementet: ");
    for (i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    recursive_count (vekt_ptr, madhesia, & counter);
    int ret = counter;
    printf ("\nTotal negative elements in array = %d", ret);
    return 0;
}
----------------------------------------

int main () {
    int vektor [100];
    int i, madhesia;
    printf ("Madhesia e vektorit: ");
    scanf ("%d", & madhesia);
    printf ("\nElementet: ");
    for (i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    printf ("\nno of elements:%d", madhesia);
    printf ("\n");
    for (i = 0; i < madhesia; i++) {
        printf ("%d", vektor [i]);
    }
    printf ("\n");
    i = 0;
    int ret = numero (vektor, madhesia, 0, i);
    printf ("\nTotal negative elements in array = %d", ret);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48807085_48807958_8_32
48807085_48808566_3_33
Title: C code function calling not working 
----------------------------------------

int main (void) {
    int vektor [N];
    size_t madhesia = 0;
    printf ("Madhesia e vektorit: ");
    scanf ("%zu", & madhesia);
    if (N < madhesia)
        madhesia = N;
    printf ("Elementet: ");
    for (size_t i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    size_t ret = iterative_numero (vektor, madhesia);
    printf ("\nTotal negative elements in array = %zu\n", ret);
    ret = recursive_numero (vektor, madhesia);
    printf ("Total negative elements in array = %zu\n", ret);
    return 0;
}
----------------------------------------

int main () {
    int vektor [100];
    int i, madhesia;
    printf ("Madhesia e vektorit: ");
    scanf ("%d", & madhesia);
    printf ("\nElementet: ");
    for (i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    printf ("\nno of elements:%d", madhesia);
    printf ("\n");
    for (i = 0; i < madhesia; i++) {
        printf ("%d", vektor [i]);
    }
    printf ("\n");
    i = 0;
    int ret = numero (vektor, madhesia, 0, i);
    printf ("\nTotal negative elements in array = %d", ret);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48807085_48807958_8_32
48807085_48825200_5_19
Title: C code function calling not working 
----------------------------------------

int main (void) {
    int vektor [N];
    size_t madhesia = 0;
    printf ("Madhesia e vektorit: ");
    scanf ("%zu", & madhesia);
    if (N < madhesia)
        madhesia = N;
    printf ("Elementet: ");
    for (size_t i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    size_t ret = iterative_numero (vektor, madhesia);
    printf ("\nTotal negative elements in array = %zu\n", ret);
    ret = recursive_numero (vektor, madhesia);
    printf ("Total negative elements in array = %zu\n", ret);
    return 0;
}
----------------------------------------

int main () {
    int vektor [100];
    int i, madhesia;
    printf ("Madhesia e vektorit: ");
    scanf ("%d", & madhesia);
    printf ("Elementet: ");
    for (i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    int ret = numero (vektor, madhesia);
    printf ("\nTotal negative elements in array = %d", ret);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48807085_48808566_35_55
48807085_48825200_21_32
Title: C code function calling not working 
----------------------------------------

int numero (int array [], int size, int count, int j) {
    if (j <= size - 1) {
        if (array[j] < 0) {
            count++;
            j++;
            numero (array, size, count, j);
        }
        else {
            j++;
            numero (array, size, count, j);
        }
    }
    return count;
}
----------------------------------------

int numero (int *array, int size) {
    int count = 0;
    for (int j = 0; j < size; j++) {
        if (array[j] < 0) {
            count++;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48807085_48808566_3_33
48807085_48825200_5_19
Title: C code function calling not working 
----------------------------------------

int main () {
    int vektor [100];
    int i, madhesia;
    printf ("Madhesia e vektorit: ");
    scanf ("%d", & madhesia);
    printf ("\nElementet: ");
    for (i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    printf ("\nno of elements:%d", madhesia);
    printf ("\n");
    for (i = 0; i < madhesia; i++) {
        printf ("%d", vektor [i]);
    }
    printf ("\n");
    i = 0;
    int ret = numero (vektor, madhesia, 0, i);
    printf ("\nTotal negative elements in array = %d", ret);
    return 0;
}
----------------------------------------

int main () {
    int vektor [100];
    int i, madhesia;
    printf ("Madhesia e vektorit: ");
    scanf ("%d", & madhesia);
    printf ("Elementet: ");
    for (i = 0; i < madhesia; i++) {
        scanf ("%d", & vektor [i]);
    }
    int ret = numero (vektor, madhesia);
    printf ("\nTotal negative elements in array = %d", ret);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4880819_4881108_3_22
4880819_4881704_3_17
Title: Logic for padding of an image array 
----------------------------------------

void pad_image (int img [], int n_cols, int n_rows) {
    int row;
    if (n_cols < 3 || n_rows < 3)
        return;
    for (row = 1; row < (n_rows - 1); row++) {
        img[row * n_cols] = img[row * n_cols + 1];
        img[row * n_cols + n_cols - 1] = img[row * n_cols + n_cols - 2];
    }
    memcpy (& img [0 * n_cols], & img [1 * n_cols], n_cols * sizeof img [0]);
    memcpy (& img [(n_rows - 1) * n_cols], & img [(n_rows - 2) * n_cols], n_cols * sizeof img [0]);
}
----------------------------------------

void pad_image (int *img, int cols, int rows) {
    for (int i = 0; i < cols; ++i) {
        img[i] = img[i + cols];
        img[i + cols * (rows - 1)] = img[i + cols * (rows - 1) - cols];
    }
    for (int j = 0; j < rows; ++j) {
        img[j * cols] = img[j * cols + 1];
        img[j * cols + cols - 1] = img[j * cols + cols - 2];
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48817180_48817377_6_15
48817180_48819597_13_38
Title: treating a one dimensional array as a two dimensional array for sorting 
----------------------------------------

int main (int argc, char *argv []) {
    for (int i = 0; i < 100; i += 1)
        a1[i] = i + 1;
    for (int i = 0; i < 10; i += 1) {
        for (int j = 0; j < 10; j += 1) {
            printf ("%2d ", a2 [i] [j]);
        }
        printf ("\n");
    }
}
----------------------------------------

int main (void) {
    char s [NROW * NCOL] = "";
    strcpy (s, "my");
    strcpy (s + NROW, "dog");
    strcpy (s + NROW * 2, "has");
    strcpy (s + NROW * 3, "fleas");
    strcpy (s + NROW * 4, "but");
    strcpy (s + NROW * 5, "the");
    strcpy (s + NROW * 6, "cat");
    strcpy (s + NROW * 7, "doesn't");
    strcpy (s + NROW * 8, "have");
    strcpy (s + NROW * 9, "any");
    printf ("unsorted:\n");
    for (int i = 0; i < NROW; i++)
        printf ("  s[%2d] : %s\n", i, &s[i * NCOL]);
    qsort (s, NCOL, NROW, cmpstrings);
    printf ("\nsorted:\n");
    for (int i = 0; i < NROW; i++)
        printf ("  s[%2d] : %s\n", i, &s[i * NCOL]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48823166_48825048_1_25
48823166_48826579_1_20
Title: Dynamically allocated array of strings memory doesn't seem to be working 
----------------------------------------

char **storewords (char *line) {
    char **tmp;
    char **newArr = malloc (sizeof (char *));
    char *word;
    int count = 0;
    word = strtok (line, " ");
    while (word != NULL) {
        tmp = realloc (newArr, sizeof (char *) * (count + 2));
        if (tmp == NULL) {
            exit (1);
        }
        newArr = tmp;
        newArr[count] = malloc (strlen (word) * sizeof (char) + 1);
        sscanf (word, "%s", newArr [count]);
        count++;
        word = strtok (NULL, " ");
    }
    newArr[count] = NULL;
    return newArr;
}
----------------------------------------

char **storewords (char *line) {
    char **newArr = (char **) malloc (sizeof (char *));
    char *word;
    int count = 1;
    word = strtok (line, " ");
    *newArr = word;
    while (word != NULL) {
        newArr = (char **) realloc (newArr, sizeof (char *) * (count + 1));
        word = strtok (NULL, " ");
        *(newArr + count) = word;
        count++;
    }
    *(newArr + count) = NULL;
    free (word);
    return newArr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48847095_48847805_11_56
48847095_48848426_14_60
Title: Inserting node in linked list 
----------------------------------------

int main () {
    struct Node *head = (struct Node *) malloc (sizeof (struct Node));
    struct Node *tail = (struct Node *) malloc (sizeof (struct Node));
    head->data = INT_MAX;
    head->qnext = tail;
    head->qprev = NULL;
    tail->data = INT_MIN;
    tail->qprev = head;
    tail->qnext = NULL;
    int key = 20;
    struct Node *curr = head;
    struct Node *prev;
    while (curr->data >= key && curr->qnext != NULL) {
        curr = curr->qnext;
    }
    prev = curr->qprev;
    printf ("head %p, data is %d, next is %p, prev is %p\n", head, head -> data, (void *) head -> qnext, (void *) head -> qprev);
    printf ("tail %p, data is %d, next is %p, prev is %p\n", tail, tail -> data, (void *) tail -> qnext, (void *) tail -> qprev);
    printf ("prev of new node %p, data is %d, next is %p, prev is %p\n", prev, prev -> data, (void *) prev -> qnext, (void *) prev -> qprev);
    printf ("--------------------\n\n");
    struct Node *new_node = (struct Node *) malloc (sizeof (struct Node));
    new_node->data = key;
    new_node->qnext = prev->qnext;
    prev->qnext = new_node;
    new_node->qprev = prev;
    if (new_node->qnext != NULL)
        new_node->qnext->qprev = new_node;
    else
        tail = new_node;
    printf ("head %p, data is %d, next is %p, prev is %p\n", head, head -> data, (void *) head -> qnext, (void *) head -> qprev);
    printf ("new_node %p, data is %d, next is %p, prev is %p\n", new_node, new_node -> data, (void *) new_node -> qnext, (void *) new_node -> qprev);
    printf ("tail %p, data is %d, next is %p, prev is %p\n", tail, tail -> data, (void *) tail -> qnext, (void *) tail -> qprev);
    return 0;
}
----------------------------------------

int main (void) {
    struct Node head = {
        .data = INT_MAX
    }, tail = {
        .data = INT_MIN
    }, *curr, *new_node;
    qllentry[0] = head;
    qllentry[1] = tail;
    head.qnext = &tail;
    tail.qprev = &head;
    int key = 20;
    curr = &head;
    while (curr->qnext && curr->qnext->data > key)
        curr = curr->qnext;
    if (!(new_node = malloc (sizeof *new_node))) {
        perror ("malloc - new_node");
        exit (EXIT_FAILURE);
    }
    new_node->data = key;
    new_node->qprev = curr;
    new_node->qnext = curr->qnext;
    curr->qnext->qprev = new_node;
    curr->qnext = new_node;
    curr = &head;
    while (curr) {
        printf ("%d\n", curr -> data);
        struct Node *victim = curr;
        curr = curr->qnext;
        if (victim != &head && victim != &tail) {
            free (victim);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48848283_48848448_13_53
48848283_48848835_1_30
Title: Difficulty with array - seg fault after just 2 assignments 
----------------------------------------

int main () {
    FILE *Distances_File = fopen ("Distances.txt", "r");
    LineBuffer *City1;
    LineBuffer *City2;
    int *Distances;
    char File_Line [LINE_SIZE];
    int Line_Count = 0;
    City1 = (LineBuffer *) malloc (sizeof (LineBuffer) * Max_Lines);
    City2 = (LineBuffer *) malloc (sizeof (LineBuffer) * Max_Lines);
    Distances = (int *) malloc (Max_Lines);
    if (!Distances_File) {
        printf ("File could not open");
        return 1;
    }
    if (Distances_File != NULL) {
        printf ("This is a program that will calculate the shortest distance between selected \ncities.");
        printf ("\nSo wish me luck :(\n \n");
        while (fgets (File_Line, sizeof (File_Line), Distances_File) && Line_Count < Max_Lines) {
            sscanf (File_Line, "%s%s%d", City1 [Line_Count], City2 [Line_Count], Distances [Line_Count]);
            printf ("%s\n%s\n%d\n\n", City1 [Line_Count], City2 [Line_Count], Distances [Line_Count]);
            Line_Count++;
            printf ("%d", Line_Count);
        }
    }
    free (City1);
    free (City2);
    free (Distances);
}
----------------------------------------

int main () {
    FILE *Distances_File = fopen ("Distances.txt", "r");
    if (!Distances_File) {
        printf ("File could not open");
        return 1;
    }
    char City1 [Max_Lines] [LINE_SIZE];
    char City2 [Max_Lines] [LINE_SIZE];
    int Distances [Max_Lines];
    char File_Line [LINE_SIZE];
    int Line_Count = 0;
    printf ("This is a program that will calculate the shortest distance between selected \ncities.");
    printf ("\nSo wish me luck :(\n \n");
    while (fgets (File_Line, sizeof (File_Line), Distances_File)) {
        printf ("Line number : %d\n", Line_Count + 1);
        sscanf (File_Line, "%s%s%d", City1 [Line_Count], City2 [Line_Count], & Distances [Line_Count]);
        printf ("%s\n%s\n%d\n\n", City1 [Line_Count], City2 [Line_Count], Distances [Line_Count]);
        Line_Count++;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48857603_48857634_3_13
48857603_48857847_3_16
Title: Trying to write a code that outputs a checkerboard in C 
----------------------------------------

int main (void) {
    for (int a = 1; a <= 10; a += 1) {
        if (a % 2 == 0)
            printf (" * * * * * * * * * \n");
        else
            printf ("* * * * * * * * * *\n");
    }
    return 0;
}
----------------------------------------

int main () {
    for (int a = 0; a < 10; ++a) {
        if (a % 2) {
            printf (" * * * * * * * * * \n");
        }
        else {
            printf ("* * * * * * * * * *\n");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48876393_48876451_19_44
48876393_48876459_29_54
Title: Appending two strings 
----------------------------------------

int main (void) {
    char str1 [30] = "Hello ";
    char str2 [30] = "World!";
    printf ("mystrcat(\"%s\", \"%s\") = %s\n", str1, str2, mystrcat (str1, str2, sizeof str1));
    char str3 [100] = "This is a long sentence";
    printf ("mystrcat(\"%s\", \"%s\") = %s\n", str1, str3, mystrcat (str1, str3, sizeof str1));
    char line [100];
    printf ("Enter some text: ");
    fflush (stdout);
    fgets (line, sizeof line, stdin);
    line[strcspn (line, "\n")] = 0;
    strcpy (str3, "User input was: ");
    printf ("mystrcat: %s\n", mystrcat (str3, line, sizeof str3));
    return 0;
}
----------------------------------------

int main () {
    char first_string [10];
    char second_string [10];
    char concatenated_string [20];
    fprintf (stdout, "str1 = ");
    fgets (first_string, sizeof (first_string), stdin);
    fprintf (stdout, "str2 = ");
    fgets (second_string, sizeof (second_string), stdin);
    const char *tmp = concatenate (concatenated_string, sizeof (concatenated_string), first_string, second_string);
    if (!tmp) {
        fprintf (stderr, "would overflow\n");
    }
    else {
        fprintf (stdout, "concatenated: %s\n", concatenated_string);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48882788_48882856_1_12
48882788_48882889_3_15
Title: Use ellipsis (...) in recurent function calls 
----------------------------------------

void writetolog (const char *format, ... ) {
    FILE * const file = fopen (LOG_FILE, "a");
    if (file != NULL) {
        va_list args;
        va_start (args, format);
        vfprintf (file, format, args);
        va_end (args);
        fclose (file);
    }
}
----------------------------------------

void writetolog (char *format, ... ) {
    FILE *file;
    if ((file = fopen (LOG_FILE, "a")) != NULL) {
        va_list args;
        va_start (args, format);
        vfprintf (file, format, args);
        fclose (file);
        va_end (args);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48905449_48915641_9_63
48905449_48916815_4_14
Title: Changing the case of the first letter of the word in a file using C 
----------------------------------------

int main (void) {
    enum state currentState = notInWord;
    int ch;
    FILE *fp1 = fopen ("asiftext.txt", "r+");
    if (!fp1) {
        perror ("fopen failed");
        exit (EXIT_FAILURE);
    }
    while ((ch = fgetc (fp1)) != EOF) {
        if (notInWord == currentState) {
            if (isalpha (ch)) {
                currentState = InWord;
                if (fseek (fp1, -1, SEEK_CUR)) {
                    perror ("fseek failed");
                    fclose (fp1);
                    exit (EXIT_FAILURE);
                }
                fputc (toupper (ch), fp1);
            }
            else {
                currentState = notInWord;
            }
        }
        else {
            if (!isalpha (ch)) {
                currentState = notInWord;
            }
        }
    }
    fclose (fp1);
}
----------------------------------------

int main (void) {
    int c, lastc = '\n';
    while ((c = getchar ()) != EOF) {
        if (!isalpha (lastc))
            c = toupper (c);
        putchar (c);
        lastc = c;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48919256_48919808_7_20
48919256_48920492_1_12
Title: "c function convert ""fffoootoo"" to ""foto"" (leaves out following repeating characters)" 
----------------------------------------

void my_unique (char *first, char *last) {
    int size = last - first;
    int i = 0, j = 0, k = 0;
    for (; i < size; i++, j++) {
        first[j] = first[i];
        while (i + 1 < size && (first[i] == first[i + 1]))
            i++;
    }
    first[j] = '\0';
    return;
}
----------------------------------------

void my_unique (char *first, char *last) {
    char *ret = first;
    for (int i = 0; first + i != last; i++) {
        if (first[i] == first[i + 1]) {
            for (int j = i; first + j != last; j++)
                first[j] = first[j + 1];
            last--;
            i--;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48964531_48965421_25_48
48964531_48966797_23_71
Title: C Programming - Sorting Last Iteration doesnt change anything 
----------------------------------------

void sort (int *arr, size_t n) {
    int temp, MSB = 0, LSB = 0;
    for (size_t i = 0; i < n; i++) {
        if (((arr[MSB] & 1) == 0) && ((arr[n - 1 + LSB] & 1) == 1)) {
            temp = arr[MSB];
            arr[MSB] = arr[n - 1 + LSB];
            arr[n - 1 + LSB] = temp;
        }
        if (((arr[MSB] & 1) == 0) && ((arr[n - 1 + LSB] & 1) == 0)) {
            LSB--;
        }
        if (((arr[MSB] & 1) == 1) && ((arr[n - 1 + LSB] & 1) == 0)) {
            MSB++;
        }
    }
}
----------------------------------------

void sort (int *arr, int n) {
    int temp, i, MSB = 0, LSB = 0;
    cout << "START ";
    for (int i = 0; i < n; i++) {
        cout << arr[i];
        cout << " ";
    }
    cout << " | ";
    cout << MSB;
    cout << " ... ";
    cout << LSB;
    cout << "\n";
    while (MSB - LSB < n) {
        if (((arr[MSB]) % 2 == 0) && ((arr[n - 1 + LSB]) % 2) != 0) {
            temp = arr[MSB];
            arr[MSB] = arr[n - 1 + LSB];
            arr[n - 1 + LSB] = temp;
            MSB++;
            LSB--;
        }
        else if (((arr[MSB] % 2) == 0) && (((arr[n - 1 + LSB]) % 2) == 0)) {
            LSB--;
        }
        else if (((arr[MSB] % 2) != 0) && (((arr[n - 1 + LSB]) % 2) != 0)) {
            MSB++;
        }
        else {
            MSB++;
            LSB--;
        }
        for (int i = 0; i < n; i++) {
            cout << arr[i];
            cout << " ";
        }
        cout << " | ";
        cout << MSB;
        cout << " ... ";
        cout << LSB;
        cout << "\n";
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48964531_48965421_5_23
48964531_48966797_8_21
Title: C Programming - Sorting Last Iteration doesnt change anything 
----------------------------------------

int main () {
    int arr [] = {6, -10, 11, 4, -3, 21, 40, 16, -2, 7};
    size_t len = sizeof arr / sizeof *arr;
    for (size_t i = 0; i < len; ++i)
        printf ("%d ", arr[i]);
    putchar ('\n');
    sort (arr, len);
    for (size_t i = 0; i < len; ++i)
        printf ("%d ", arr[i]);
    putchar ('\n');
    return 0;
}
----------------------------------------

int main () {
    int n = 10, arr [] = {6, -10, 11, 4, -3, 21, 40, 16, -2, 7};
    sort (arr, n);
    for (int i = 0; i < n; i++) {
        cout << arr[i];
        cout << " ";
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48975680_48975850_1_60
48975680_48977097_195_229
Title: Delete struct node using pointer-to-pointer 
----------------------------------------

int main (void) {
    struct node head = {
        .next = NULL
    };
    {
        struct node *n = malloc (sizeof *n);
        n->data = 23;
        slist_add (n, & head);
    }
    {
        struct node *n = malloc (sizeof *n);
        n->data = 42;
        slist_add (n, & head);
    }
    assert (head.next != NULL);
    assert (head.next -> data == 42);
    assert (head.next -> next != NULL);
    assert (head.next -> next -> data == 23);
    assert (head.next -> next -> next == NULL);
    {
        struct node **ptr = slist_search (&head, 42);
        assert (ptr != NULL);
        assert (* ptr != NULL);
        assert ((* ptr) -> data == 42);
        if (ptr) {
            struct node *n = *ptr;
            slist_remove (ptr);
            free (n);
        }
    }
    {
        struct node **ptr = slist_search (&head, 23);
        assert (ptr != NULL);
        assert (* ptr != NULL);
        assert ((* ptr) -> data == 23);
        if (ptr) {
            struct node *n = *ptr;
            slist_remove (ptr);
            free (n);
        }
    }
    assert (head.next == NULL);
}
----------------------------------------

int main () {
    node *head = NULL;
    printf ("head: %p\n", head);
    node *n1 = node_new (1);
    node *n2 = node_new (2);
    node *n3 = node_new (3);
    print_nodes (& head);
    add_node (& head, n1);
    add_node (& head, n2);
    add_node (& head, n3);
    printf ("head points to:  %p\n", head);
    print_nodes (& head);
    delete (& head, 3);
    print_nodes (& head);
    delete (& head, 1);
    print_nodes (& head);
    delete (& head, 2);
    print_nodes (& head);
    printf ("head points to: %p\n", head);
    print_nodes (& head);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48978170_48978234_1_10
48978170_48978246_3_25
Title: C function to print maximum and minimum numbers 
----------------------------------------

void max_num (float num_arr [], int size) {
    if (size > 0) float max = num_arr [0];
    for (int k = 0; k <= size; k++) {
        if (max < num_arr[k]) {
            max = num_arr[k];
        }
    }
    printf ("The maximum number is %f\n", max);
}
----------------------------------------

float max_num (float *array, size_t len) {
    if (array == NULL) {
        fprintf (stderr, "invalid argument, array == NULL\n");
        return 0;
    }
    if (len == 0) {
        fprintf (stderr, "Invalid array size, cannot be 0\n");
        return 0;
    }
    float max = array[0];
    for (size_t i = 0; i < len; ++i) {
        if (array[i] > max)
            max = array[i];
    }
    return max;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4899221_26126313_1_22
4899221_4900830_1_23
Title: Substitute or workaround for asprintf on AIX 
----------------------------------------

int vasprintf (char **dst, const char *pcFormat, va_list ap) {
    int len = 512;
    int allocated = 0;
    va_list ap_copy;
    char *buff = NULL;
    while (len >= allocated) {
        free (buff);
        buff = malloc (len +1);
        if (buff) {
            allocated = len + 1;
            va_copy (ap_copy, ap);
            len = vsnprintf (buff, len +1, pcFormat, ap_copy);
            va_end (ap_copy);
        }
        else
            return -1;
    }
    *dst = buff;
    return len;
}
----------------------------------------

int vasprintf (char **ret, const char *format, va_list args) {
    va_list copy;
    va_copy (copy, args);
    *ret = NULL;
    int count = vsnprintf (NULL, 0, format, args);
    if (count >= 0) {
        char *buffer = malloc (count +1);
        if (buffer == NULL)
            count = -1;
        else if ((count = vsnprintf (buffer, count +1, format, copy)) < 0)
            free (buffer);
        else
            *ret = buffer;
    }
    va_end (copy);
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48992388_48992447_1_18
48992388_48994004_5_22
Title: "C help: Compiler gives me a ""makes pointer from integer without cast"" when using strlen()" 
----------------------------------------

int main () {
    char *userInput = malloc (20);
    int stringLength;
    printf ("Hello. Please enter a string: \n");
    fgets (userInput, 20, stdin);
    size_t stringLength = strlen (userInput);
    printf ("This is your input:, %s \n", userInput);
    printf ("Length: %d \n", stringLength);
    return 0;
}
----------------------------------------

int main () {
    char *userInput = malloc (sizeof (20));
    unsigned int stringLength;
    printf ("Hello. Please enter a string: \n");
    fgets (userInput, 20, stdin);
    stringLength = strlen (userInput);
    printf ("This is your input:, %s \n", userInput);
    printf ("Length: %u \n", stringLength);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48992388_48992447_1_18
48992388_48994837_5_25
Title: "C help: Compiler gives me a ""makes pointer from integer without cast"" when using strlen()" 
----------------------------------------

int main () {
    char *userInput = malloc (20);
    int stringLength;
    printf ("Hello. Please enter a string: \n");
    fgets (userInput, 20, stdin);
    size_t stringLength = strlen (userInput);
    printf ("This is your input:, %s \n", userInput);
    printf ("Length: %d \n", stringLength);
    return 0;
}
----------------------------------------

int main () {
    char *userInput = malloc (20 * sizeof (char));
    size_t stringLength;
    printf ("Hello. Please enter a string: \n");
    fgets (userInput, 20, stdin);
    stringLength = strlen (userInput);
    printf ("This is your input: %sand it has length: %zu. The sizeof(20) is %zu \n", userInput, stringLength, sizeof (20));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48992388_48994004_5_22
48992388_48994837_5_25
Title: "C help: Compiler gives me a ""makes pointer from integer without cast"" when using strlen()" 
----------------------------------------

int main () {
    char *userInput = malloc (sizeof (20));
    unsigned int stringLength;
    printf ("Hello. Please enter a string: \n");
    fgets (userInput, 20, stdin);
    stringLength = strlen (userInput);
    printf ("This is your input:, %s \n", userInput);
    printf ("Length: %u \n", stringLength);
    return 0;
}
----------------------------------------

int main () {
    char *userInput = malloc (20 * sizeof (char));
    size_t stringLength;
    printf ("Hello. Please enter a string: \n");
    fgets (userInput, 20, stdin);
    stringLength = strlen (userInput);
    printf ("This is your input: %sand it has length: %zu. The sizeof(20) is %zu \n", userInput, stringLength, sizeof (20));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49021019_49021097_4_36
49021019_49021142_4_27
Title: C Programming: Removing Unnecessary Commas From Result of Prefix Sum Code 
----------------------------------------

int main () {
    int x = 0;
    int sum = 0;
    int i = -1;
    int ret;
    while (1) {
        i++;
        ret = scanf ("%d", &x);
        if (ret != 1)
            break;
        sum += x;
        if (x != 0) {
            if (i == 0)
                printf ("%d", sum);
            else
                printf (",%d", sum);
        }
        else {
            break;
        }
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main () {
    int x, sum;
    sum = 0;
    comma = 0;
    while (x) {
        scanf ("%d", & x);
        sum += x;
        if (x != 0) {
            if (comma != 0) {
                printf (",");
            }
            printf ("%d", sum);
            comma = 1;
        }
        else {
            break;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49021019_49021097_4_36
49021019_49021145_4_17
Title: C Programming: Removing Unnecessary Commas From Result of Prefix Sum Code 
----------------------------------------

int main () {
    int x = 0;
    int sum = 0;
    int i = -1;
    int ret;
    while (1) {
        i++;
        ret = scanf ("%d", &x);
        if (ret != 1)
            break;
        sum += x;
        if (x != 0) {
            if (i == 0)
                printf ("%d", sum);
            else
                printf (",%d", sum);
        }
        else {
            break;
        }
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    int sum = 0;
    int x;
    const char *pad = "";
    while (scanf ("%d", &x) == 1 && x != 0) {
        sum += x;
        printf ("%s%d", pad, sum);
        pad = ",";
    }
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49021019_49021142_4_27
49021019_49021145_4_17
Title: C Programming: Removing Unnecessary Commas From Result of Prefix Sum Code 
----------------------------------------

int main () {
    int x, sum;
    sum = 0;
    comma = 0;
    while (x) {
        scanf ("%d", & x);
        sum += x;
        if (x != 0) {
            if (comma != 0) {
                printf (",");
            }
            printf ("%d", sum);
            comma = 1;
        }
        else {
            break;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    int sum = 0;
    int x;
    const char *pad = "";
    while (scanf ("%d", &x) == 1 && x != 0) {
        sum += x;
        printf ("%s%d", pad, sum);
        pad = ",";
    }
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49023583_49024540_3_21
49023583_49025660_3_31
Title: Minimum sum of two elements from two arrays such that indices are not same 
----------------------------------------

int twinArrays (int ar1_size, int *ar1, int ar2_size, int *ar2) {
    int min1 = INT_MAX, min2 = INT_MAX;
    for (int i = 0; i < ar1_size; i++)
        min1 = ar1[i] < min1 ? ar[1] : min1;
    for (int i = 0; i < ar2_size; i++)
        min2 = ar2[i] < min2 ? ar2[1] : min2;
    if (min1 > 0 && min2 > INT_MAX - min1) {
        return INT_MAX;
    }
    else if (min1 < 0 && min2 < INT_MIN - min1) {
        return INT_MIN;
    }
    return min1 + min2;
}
----------------------------------------

int twinArrays (int ar1_size, int *ar1, int ar2_size, int *ar2) {
    int sum_min = INT_MAX;
    for (int i = 0; i < ar1_size; i++) {
        for (int j = 0; j < ar2_size; t++) {
            if (i != j) {
                int sum = ar1[i] + ar2[j];
                if (sum < sum_min) {
                    sum_min = sum;
                }
            }
        }
    }
    return sum_min;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49056424_49056671_4_27
49056424_49056709_1_36
Title: Read more than 1 line csv file in C 
----------------------------------------

int main (void) {
    char nama [100], gaji [100], zakat [100], bersih [100];
    FILE *f = fopen ("2.csv", "r");
    while (fscanf (f, "%s %s %s %s", nama, gaji, zakat, bersih) != EOF) {
        size_t len = strlen (gaji);
        size_t len1 = strlen (nama);
        size_t len2 = strlen (zakat);
        gaji[len - 1] = '\0';
        nama[len1 - 1] = '\0';
        zakat[len2 - 1] = '\0';
        printf ("%s \t %s \t %s \t %s \n", nama, gaji, zakat, bersih);
    }
    fclose (f);
    return 0;
}
----------------------------------------

int main (void) {
    FILE *f = fopen ("2.csv", "r");
    if (f == NULL) {
        fprintf (stderr, "Cannot open file\n");
        return 1;
    }
    char line [1024];
    size_t lineno = 0;
    const char *delim = ",\n";
    while (fgets (line, sizeof line, stdin)) {
        lineno++;
        char *token = strtok (line, delim);
        if (token == NULL) {
            fprintf (stderr, "format error on line %zu\n", lineno);
            continue;
        }
        printf ("line %zu:");
        do {
            printf ("-%s- ", token);
        }
        while ((token = strtok (NULL, delim)));
        putchar ('\n');
    }
    fclose (f);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49060300_49060364_3_28
49060300_49060607_3_38
Title: C Program - How to deny any non-numerical input 
----------------------------------------

int main (void) {
    int ret, num;
    char line [1024];
    do {
        printf ("Enter a number: ");
        fflush (stdout);
        if (fgets (line, sizeof line, stdin) == NULL) {
            fprintf (stderr, "Cannot read from stdin anymore\n");
            return 1;
        }
        ret = sscanf (line, "%d", &num);
        if (ret != 1)
            fprintf (stderr, "That was not a number! Try again.\n");
    }
    while (ret != 1);
    printf ("The number you entered is: %d\n", num);
    return 0;
}
----------------------------------------

int main (void) {
    long int num = 0;
    char line [40] = "";
    char *parsed = NULL;
    printf ("Please enter any number? \t");
    fflush (stdout);
    while (fgets (line, 40, stdin)) {
        parsed = line;
        num = strtol (line, &parsed, 10);
        if (parsed == line) {
            printf ("Please enter a number? \t");
            printf ("\nTry again:\t");
            fflush (stdout);
            continue;
        }
        if ('\n' != *parsed) {
            printf ("Please enter only a number? \t");
            printf ("\nTry again:\t");
            fflush (stdout);
        }
        else {
            break;
        }
    }
    if (!parsed || '\n' != *parsed) {
        fprintf (stderr, "problem fgets\n");
        return 0;
    }
    printf ("\n%ld is nice number, thank you! \n\n", num);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49074222_49074287_1_14
49074222_49074682_1_15
Title: C pointer assignment inside a function 
----------------------------------------

int get_by_id (int id, Lookup **lp) {
    int status = 1;
    for (int i = 0; i < 128; i++) {
        *lp = &ltable[i];
        if (id == (*lp)->id) {
            status = 0;
            break;
        }
    }
    return status;
}
----------------------------------------

int get_by_id (int id, Lookup *lp) {
    int status = 1;
    for (int i = 0; i < 128; i++) {
        *lp = ltable[i];
        if (id == lp->id) {
            status = 0;
            printf ("lp=%X\n", lp);
            break;
        }
    }
    return status;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49083173_49083237_3_17
49083173_49083563_3_16
Title: C string is not running 
----------------------------------------

int main () {
    int i = 4;
    double d = 4.0;
    char s [] = "HackerRank ";
    int ie;
    double de;
    char re [1000];
    char *lf;
    fgets (re, sizeof (re), stdin);
    sscanf (re, "%d", & ie);
    fgets (re, sizeof (re), stdin);
    sscanf (re, "%lf", & de);
    fgets (re, sizeof (re), stdin);
    if ((lf = strchr (re, '\n')) != NULL)
        *lf = '\0';
    printf ("%d\n%f\n%s", (ie + i), (de + d), s);
    printf ("%s\n", re);
    return 0;
}
----------------------------------------

int main () {
    int i = 4;
    double d = 4.0;
    char s [] = "HackerRank ";
    int x;
    double y;
    char z [50];
    scanf (" %d %lf\n%[^\n]", & x, & y, z);
    printf ("%d\n", x + i);
    printf ("%.1lf\n", y + d);
    printf ("%s", s);
    printf ("%s", z);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49083861_49084071_3_43
49083861_49085089_3_19
Title: Reproducing atoi() without external functions 
----------------------------------------

int my_atoi (const char *input) {
    int accumulator = 0, curr_val = 0, sign = 1;
    size_t i = 0;
    if (input[0] == '-') {
        sign = -1;
        i++;
    }
    if (input[0] == '+')
        i++;
    while (input[i] != '\0') {
        curr_val = (int) (input[i] - '0');
        if (curr_val < 0 || curr_val > 9)
            return accumulator;
        accumulator = accumulator * 10 + curr_val;
        i++;
    }
    return sign * accumulator;
}
----------------------------------------

long long int my_atoi (const char *c) {
    long long int value = 0;
    int sign = 1;
    if (*c == '+' || *c == '-') {
        if (*c == '-')
            sign = -1;
        c++;
    }
    while (*c >= '0' && *c <= '9') {
        value *= 10;
        value += (int) (*c - '0');
        c++;
    }
    return (value * sign);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49083861_49084071_46_59
49083861_49085089_21_34
Title: Reproducing atoi() without external functions 
----------------------------------------

int main () {
    char test1 [] = "234";
    char test2 [] = "+6543";
    char test3 [] = "-1234";
    char test4 [] = "9B123";
    int a = my_atoi (test1);
    int b = my_atoi (test2);
    int c = my_atoi (test3);
    int d = my_atoi (test4);
    printf ("%d, %d, %d, %d\n", a, b, c, d);
    return 0;
}
----------------------------------------

int main () {
    char test1 [] = "1234567890123456789";
    char test2 [] = "+7654312345678901234";
    char test3 [] = "-932112345678901234";
    char test4 [] = "9A123123456789012";
    long long int a = my_atoi (test1);
    long long int b = my_atoi (test2);
    long long int c = my_atoi (test3);
    long long int d = my_atoi (test4);
    printf (" %lld\n %lld\n %lld\n %lld\n", a, b, c, d);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49091380_49092174_6_68
49091380_49092195_5_37
Title: C language - counting number of different vowels with no pointers or additional functions 
----------------------------------------

int main (void) {
    char line [1024];
    int lookup_vowels [1 << CHAR_BIT] = {0};
    lookup_vowels['a'] = lookup_vowels['e'] = lookup_vowels['i'] = lookup_vowels['o'] = lookup_vowels['u'] = 1;
    const char *delim = " \t\r\n";
    int num_of_words = 0;
    printf ("Enter some text, to end input press ENTER and then CTRL+D\n");
    while (1) {
        if (fgets (line, sizeof line, stdin) == NULL)
            break;
        char *word = strtok (line, delim);
        if (word == NULL)
            continue;
        do {
            int present [1 << CHAR_BIT] = {0};
            size_t len = strlen (word);
            for (size_t i = 0; i < len; ++i) {
                int c = tolower (word[i]);
                if (lookup_vowels[c])
                    present[c] = 1;
            }
            int count = present['a'] + present['e'] + present['i'] + present['o'] + present['u'];
            if (count > 2) {
                printf ("'%s' has more than three distinct vowels\n", word);
                num_of_words++;
            }
        }
        while ((word = strtok (NULL, delim)));
    }
    printf ("The number of word with three or more distinct vowels: %d\n", num_of_words);
    return 0;
}
----------------------------------------

int main (void) {
    char word [MAXC] = "";
    size_t wordcnt = 0;
    printf ("enter a word(s) below, [ctrl+d on blank line to end]\n");
    for (;;) {
        int vowels [NVOWEL] = {0}, vowelcnt = 0, rtn;
        if ((rtn = scanf ("%127s", word)) == EOF)
            break;
        for (int i = 0; word[i]; i++) {
            if ('A' <= word[i] && word[i] <= 'Z')
                word[i] ^= 'a' - 'A';
            switch (word[i]) {
            case 'a' :
                vowels[0] = 1;
                break;
            case 'e' :
                vowels[1] = 1;
                break;
            case 'i' :
                vowels[2] = 1;
                break;
            case 'o' :
                vowels[3] = 1;
                break;
            case 'u' :
                vowels[4] = 1;
                break;
            }
        }
        for (int i = 0; i < NVOWEL; i++)
            if (vowels[i])
                vowelcnt++;
        if (vowelcnt >= NREQD)
            wordcnt++;
    }
    printf ("\nThere are %zu words with %d different vowels.\n", wordcnt, NREQD);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49107181_49108033_3_23
49107181_49125406_3_18
Title: The most efficient way to find mode in an array? 
----------------------------------------

int main () {
    vector < unsigned int > frequency (NUM_FREQ);
    vector < unsigned int > samples [10] = {1, 6, 5, 99, 1, 12, 50, 50, 244, 50};
    int highest = 0;
    int i, j, k;
    for (size_t i = 0; i < samples.size (); i++) {
        assert (samples [i] < NUM_FREQ && "value in samples is bigger than expected");
        frequency[samples[i]]++;
        if (frequency[samples[i]] > highest)
            highest = frequency[samples[i]];
    }
    printf ("The mode in the array : ");
    for (size_t i = 0; i < frequency.size (); i++)
        if (frequency[i] == highest)
            printf ("%d ", i);
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    int x [10] = {1, 6, 5, 99, 1, 12, 50, 50, 244, 50};
    map < int, int > freq;
    int highiest = 0;
    for (int i = 0; i < 10; i++) {
        freq[x[i]] += 1;
    }
    for (int i = 0; i < sizeof (freq); i++) {
        if (freq[i] > highiest)
            highiest = i;
    }
    cout << highiest << endl;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49119667_49119757_1_12
49119667_49120884_27_52
Title: C - Initializing struct member - array of pointers. Second element has incorrect value 
----------------------------------------

int initConfig (configuration *config) {
    config->paramListSize = 0;
    config->paramList = calloc (3, sizeof (parameter));
    config->paramList[0] = &config->param1;
    config->paramList[1] = &config->param2;
    config->paramList[2] = &config->param3;
    initParameter (& config -> param1, 100, & config -> paramListSize);
    initParameter (& config -> param2, 200, & config -> paramListSize);
    initParameter (& config -> param3, 300, & config -> paramListSize);
}
----------------------------------------

int initConfig (configuration *config) {
    config->paramListSize = 0;
    parameter *test [] = {initParameter (&config->param1, 100, &config->paramListSize), initParameter (&config->param2, 200, &config->paramListSize), initParameter (&config->param3, 300, &config->paramListSize)};
    config->paramList = (parameter **) calloc (config->paramListSize, sizeof (parameter));
    if (config->paramList == NULL)
        return -1;
    for (int i = 0; i < config->paramListSize; i++) {
        config->paramList[i] = test[i];
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49121452_49121521_3_17
49121452_49124641_3_17
Title: assigning a value within a char array pointer 
----------------------------------------

void parseString (char *str, size_t len) {
    printf ("%s\n", str);
    for (size_t i = 0; i < len; i++) {
        if (str[i] == 'a') {
            printf ("%c\n", str [i]);
            str[i] = '0';
            printf ("%c\n", str [i]);
        }
    }
}
----------------------------------------

void parseString (char *pstr) {
    char *str = pstr;
    printf ("%s\n", str);
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == 'a') {
            printf ("%c\n", str [i]);
            str[i] = '0';
            printf ("%c\n", str [i]);
        }
    }
    printf ("%s\n", pstr);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49124356_49124562_2_13
49124356_49204646_1_16
Title: function_tester.exe has stopped working 
----------------------------------------

int main (void) {
    puts ("Enter any number and it will return all the numbers from 1 to your number added together.");
    int num;
    scanf ("%i", & num);
    int sum = 0;
    while (num > 0) {
        sum += num;
        num -= 1;
    }
    printf ("%i\n", sum);
    return 0;
}
----------------------------------------

int main () {
    puts ("Enter any number and it will return all the numbers from 1 to your number added together.");
    int num;
    int i;
    while (num != 0) {
        scanf ("%i", & num);
        for (i = num - 1; i > 0; i--) {
            num = num + i;
        }
        printf ("%i\n", num);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49144925_49146197_3_18
49144925_49148304_4_12
Title: Reversing a string in C not working 
----------------------------------------

void main () {
    char str [50], temp;
    int i, j, len;
    puts ("enter a string");
    gets (str);
    len = strlen (str);
    for (i = 0, j = len - 1; i < j; i++, j--) {
        temp = str[i];
        str[i] = str[j];
        str[j] = temp;
    }
    printf ("Reverse string is %s", str);
}
----------------------------------------

void main () {
    printf ("Enter your string here: ");
    scanf ("%s", & original);
    for (i = 0; i < 8; i++, t--) {
        printf ("%c\n", original [i]);
        new[t] = original[i];
    }
    printf ("Your new string is %s\n", new);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49152350_49152910_7_25
49152350_49153321_1_10
Title: Array of HEX Values to Decimal 
----------------------------------------

int main (void) {
    int i;
    for (i = 0; i < sizeof fileSize; i++)
        printf ("%02x ", fileSize[i]);
    printf ("\n");
    for (i = 0; i < sizeof fileSize2; i++)
        printf ("%02x ", fileSize2[i]);
    printf ("\n");
    printf ("%u\n", * (int *) fileSize);
    printf ("%u\n", * (int *) fileSize2);
}
----------------------------------------

int main () {
    char data [] = {0xce, 0xee, 0, 0};
    int *ptr;
    ptr = data;
    printf ("%d\n", * ptr);
    int x = *ptr;
    printf ("%d\n", x);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49153113_49153757_7_19
49153113_49153868_1_28
Title: recursive find number in between in C 
----------------------------------------

int within (int a [], int N, int lower, int upper, int result []) {
    if (a[0] <= upper && a[0] >= lower) {
        result[0]++;
        result[result[0]] = a[0];
    }
    if (N == 0) {
        return result[0];
    }
    else {
        result[0] = within (&a[1], N -1, lower, upper, result);
        return result[0];
    }
}
----------------------------------------

int within (int *a, int rngH, int rngL, int length) {
    int len = length;
    static int i = 0;
    static int found = 0;
    if (len <= 0) {
        return i;
    }
    if (*a == rngH) {
        printf ("%d,", * a);
        i++;
        found = 1;
        within (++ a, rngH, rngL, -- len);
    }
    else if (*a == rngL && found > 0) {
        printf ("%d,", * a);
        i++;
        within (++ a, rngH, rngL, -- len);
    }
    else {
        within (++ a, rngH, rngL, -- len);
    }
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49153113_49154026_28_43
49153113_49154457_18_29
Title: recursive find number in between in C 
----------------------------------------

int main () {
    int in [N] = {4, 1, 3, 1, 3, 2};
    int out [N] = {0};
    int num_found = find_in_range (out, in, N, 2, 3);
    for (int i = 0; i < num_found; ++i) {
        printf ("%d ", out [i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main () {
    int arr [] = {1, 3, 3, 6, 4, 6, 7, 8};
    int key [] = {1, 4};
    recFind (arr, key);
    printf (" { ");
    for (int i = 0; i < 4; i++) {
        printf ("%d ", result [i]);
    }
    printf ("}\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49153113_49154026_28_43
49153113_49154696_33_54
Title: recursive find number in between in C 
----------------------------------------

int main () {
    int in [N] = {4, 1, 3, 1, 3, 2};
    int out [N] = {0};
    int num_found = find_in_range (out, in, N, 2, 3);
    for (int i = 0; i < num_found; ++i) {
        printf ("%d ", out [i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    int a [] = {1, 2, 3, 4, 5, 4, 3, 2, 1};
    const size_t N = sizeof (a) / sizeof (*a);
    int lower = 2, high = 3;
    int *out;
    size_t n = get_range (a, N, lower, high, &out);
    for (size_t i = 0; i < n; i++) {
        printf ("%d ", out [i]);
    }
    putchar ('\n');
    free (out);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49153113_49154457_18_29
49153113_49154696_33_54
Title: recursive find number in between in C 
----------------------------------------

int main () {
    int arr [] = {1, 3, 3, 6, 4, 6, 7, 8};
    int key [] = {1, 4};
    recFind (arr, key);
    printf (" { ");
    for (int i = 0; i < 4; i++) {
        printf ("%d ", result [i]);
    }
    printf ("}\n");
}
----------------------------------------

int main (void) {
    int a [] = {1, 2, 3, 4, 5, 4, 3, 2, 1};
    const size_t N = sizeof (a) / sizeof (*a);
    int lower = 2, high = 3;
    int *out;
    size_t n = get_range (a, N, lower, high, &out);
    for (size_t i = 0; i < n; i++) {
        printf ("%d ", out [i]);
    }
    putchar ('\n');
    free (out);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49154802_49155074_26_49
49154802_49156632_5_61
Title: How to find the difference between two arrays in C? 
----------------------------------------

int main (void) {
    int arr1 [] = {1, 2, 3, 4, 7, 8, 9};
    int arr2 [] = {3, 4, 5};
    size_t s1 = sizeof (arr1) / sizeof (*arr1);
    size_t s2 = sizeof (arr2) / sizeof (*arr2);
    int arr3 [s1];
    int s3 = 0;
    for (size_t i = 0; i < s1; ++i) {
        if (!IsNumberInArray (arr1[i], arr2, s2)) {
            arr3[s3] = arr1[i];
            s3++;
        }
    }
    DumpArrayContent (arr1, s1, "arr1");
    DumpArrayContent (arr2, s2, "arr2");
    DumpArrayContent (arr3, s3, "arr3");
    return 0;
}
----------------------------------------

int main (void) {
    size_t i, j, k;
    int s3;
    int arr1 [] = {1, 2, 3, 4, 7, 8, 9};
    int arr2 [] = {3, 4, 5};
    size_t s1 = sizeof (arr1) / sizeof (int);
    size_t s2 = sizeof (arr2) / sizeof (int);
    int arr3 [s1];
    int e;
    int found = 0;
    k = 0;
    for (i = 0; i < s1; i++) {
        e = arr1[i];
        found = 0;
        for (j = 0; j < s2; j++) {
            if (e == arr2[j]) {
                found = 1;
                break;
            }
        }
        if (found == 0) {
            arr3[k] = e;
            k++;
        }
    }
    printf ("arr1 has %d elements:\n", s1);
    for (i = 0; i < s1; i++) {
        printf ("%d ", arr1 [i]);
    }
    printf ("\narr2 has %d elements:\n", s2);
    for (i = 0; i < s2; i++) {
        printf ("%d ", arr2 [i]);
    }
    printf ("\narr3 has %d elements:\n", k);
    for (i = 0; i < k; i++) {
        printf ("%d ", arr3 [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49174719_49176745_6_34
49174719_49176752_7_55
Title: Error with manually copying string using pointers 
----------------------------------------

int main () {
    const char *slogan = "Comp10120 is my favourite module";
    char *slogan_copy = malloc ((strlen (slogan) + 1) * sizeof (char));
    const char *p = slogan;
    int offset = 0;
    while (*p != '\0') {
        char c = toupper (*p++);
        if (! isalpha (c) || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||) slogan_copy [offset ++] = c;
    }
    slogan_copy[offset] = '\0';
    printf ("Origianl String: %s\n", slogan);
    printf ("Modified String: %s\n", slogan_copy);
    return 0;
}
----------------------------------------

int main (void) {
    char *slogan = "Comp10120 is my favourite module";
    char *p = slogan;
    char *slogan_copy;
    int offset = 0;
    int slogan_size = 0;
    while (*p++ != '\0')
        slogan_size++;
    slogan_copy = malloc ((slogan_size + 1) * sizeof (char));
    slogan_copy[slogan_size] = '\0';
    p = slogan;
    while (*p != '\0') {
        if ((!(*p == 'a' || *p == 'e' || *p == 'i' || *p == 'o' || *p == 'u')) && (((*p > 'a') && (*p < 'z')) || ((*p > 'A') && (*p < 'Z'))))
            p++;
        else {
            slogan_copy[offset] = *p;
            slogan_copy[offset] = toupper (slogan_copy[offset]);
            *p++;
            offset++;
        }
    }
    slogan_copy[offset] = '\0';
    printStrings ("Origianl String: %s\n", slogan);
    printStrings ("Modified String: %s\n", slogan_copy);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49174719_49176745_6_34
49174719_49177043_5_36
Title: Error with manually copying string using pointers 
----------------------------------------

int main () {
    const char *slogan = "Comp10120 is my favourite module";
    char *slogan_copy = malloc ((strlen (slogan) + 1) * sizeof (char));
    const char *p = slogan;
    int offset = 0;
    while (*p != '\0') {
        char c = toupper (*p++);
        if (! isalpha (c) || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U' ||) slogan_copy [offset ++] = c;
    }
    slogan_copy[offset] = '\0';
    printf ("Origianl String: %s\n", slogan);
    printf ("Modified String: %s\n", slogan_copy);
    return 0;
}
----------------------------------------

int main () {
    const char *slogan = "Comp10120 is my favourite module";
    char *slogan_copy = NULL;
    int slogan_size = 0;
    while (slogan[slogan_size] != '\0')
        slogan_size++;
    slogan_copy = malloc (slogan_size +1);
    const char *p = slogan;
    int offset = 0;
    while (*p != '\0') {
        int c = toupper ((unsigned char) *p++);
        if (!isalpha (c) || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {
            slogan_copy[offset++] = c;
        }
    }
    slogan_copy[offset] = '\0';
    printf ("Original string: %s\n", slogan);
    printf ("Modified string: %s\n", slogan_copy);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49174719_49176752_7_55
49174719_49177043_5_36
Title: Error with manually copying string using pointers 
----------------------------------------

int main (void) {
    char *slogan = "Comp10120 is my favourite module";
    char *p = slogan;
    char *slogan_copy;
    int offset = 0;
    int slogan_size = 0;
    while (*p++ != '\0')
        slogan_size++;
    slogan_copy = malloc ((slogan_size + 1) * sizeof (char));
    slogan_copy[slogan_size] = '\0';
    p = slogan;
    while (*p != '\0') {
        if ((!(*p == 'a' || *p == 'e' || *p == 'i' || *p == 'o' || *p == 'u')) && (((*p > 'a') && (*p < 'z')) || ((*p > 'A') && (*p < 'Z'))))
            p++;
        else {
            slogan_copy[offset] = *p;
            slogan_copy[offset] = toupper (slogan_copy[offset]);
            *p++;
            offset++;
        }
    }
    slogan_copy[offset] = '\0';
    printStrings ("Origianl String: %s\n", slogan);
    printStrings ("Modified String: %s\n", slogan_copy);
    return 0;
}
----------------------------------------

int main () {
    const char *slogan = "Comp10120 is my favourite module";
    char *slogan_copy = NULL;
    int slogan_size = 0;
    while (slogan[slogan_size] != '\0')
        slogan_size++;
    slogan_copy = malloc (slogan_size +1);
    const char *p = slogan;
    int offset = 0;
    while (*p != '\0') {
        int c = toupper ((unsigned char) *p++);
        if (!isalpha (c) || c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U') {
            slogan_copy[offset++] = c;
        }
    }
    slogan_copy[offset] = '\0';
    printf ("Original string: %s\n", slogan);
    printf ("Modified string: %s\n", slogan_copy);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49179337_49180137_5_20
49179337_49180959_7_62
Title: Determine the length of a string inside a file 
----------------------------------------

int main (void) {
    FILE *file = fopen ("your_file_here.txt", "r");
    fseek (file, 0, SEEK_END);
    long filesize = ftell (file);
    fseek (file, 0, SEEK_SET);
    char *buffer = malloc (filesize +1);
    assert (buffer);
    fread (content, 1, filesize, file);
    free (buffer);
    fclose (file);
}
----------------------------------------

int main (int argc, char **argv) {
    size_t ndx = 0, nptrs = NPTR, n = 0;
    ssize_t nchr = 0;
    char *line = NULL, **lines = NULL;
    FILE *fp = argc > 1 ? fopen (argv[1], "r") : stdin;
    if (!fp) {
        fprintf (stderr, "error: file open failed '%s'.\n", argv [1]);
        return 1;
    }
    if (!(lines = calloc (nptrs, sizeof *lines))) {
        perror ("calloc-lines");
        return 1;
    }
    while ((nchr = getline (&line, &n, fp)) != -1) {
        if (nchr && line[nchr - 1] == '\n')
            line[--nchr] = 0;
        char *buf = strdup (line);
        if (!buf) {
            fprintf (stderr, "error: strdup allocation failed.\n");
            break;
        }
        lines[ndx++] = buf;
        if (ndx == nptrs) {
            void *tmp = realloc (lines, sizeof *lines * nptrs * 2);
            if (!tmp) {
                perror ("realloc-lines");
                break;
            }
            lines = tmp;
            memset (lines + nptrs, 0, nptrs * sizeof * lines);
            nptrs *= 2;
        }
    }
    free (line);
    if (fp != stdin)
        fclose (fp);
    for (size_t i = 0; i < ndx; i++) {
        printf ("line[%3zu] : %s\n", i, lines [i]);
        free (lines [i]);
    }
    free (lines);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
49183054_49183158_1_15
49183054_49183660_9_27
Title: sorting 2-d array based on the first column 
----------------------------------------

int compare (const void *a, const void *b) {
    const struct data_t *m = a;
    const struct data_t *n = b;
    if (m->x == n->x) {
        if (m->y == n->y) {
            if (m->z == n->z) {
                return m->k > n->k;
            }
            return m->z > n->z;
        }
        return m->y > n->y;
    }
    return m->x > n->x;
}
----------------------------------------

int compare (const void *a, const void *b) {
    const struct data_t *m = a;
    const struct data_t *n = b;
    if (m->x != n->x)
        return (m->x > n->x) ? 1 : -1;
    if (m->y != n->y)
        return m->y - n->y;
    if (m->z != n->z)
        return (m->z > n->z) ? 1 : -1;
    if (m->k != n->k)
        return (m->k > n->k) ? 1 : -1;
    return 0;
}
----------------------------------------
