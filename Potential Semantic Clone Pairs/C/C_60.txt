$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5422061_12773678_12_29
5422061_5422227_9_35
Title: malloc implementation? 
----------------------------------------

void *malloc (size_t size) {
    size = (size + sizeof (free_block) + (align_to - 1)) & ~(align_to - 1);
    free_block *block = free_block_list_head.next;
    free_block **head = &(free_block_list_head.next);
    while (block != 0) {
        if (block->size >= size) {
            *head = block->next;
            return ((char *) block) + sizeof (free_block);
        }
        head = &(block->next);
        block = block->next;
    }
    block = (free_block *) sbrk (size);
    block->size = size;
    return ((char *) block) + sizeof (free_block);
}
----------------------------------------

void *malloc (size_t size) {
    void *return_ptr = NULL;
    int i;
    if (dictionary == NULL) {
        dictionary = sbrk (1024 * sizeof (mem_dictionary));
        memset (dictionary, 0, 1024 * sizeof (mem_dictionary));
    }
    for (i = 0; i < dictionary_ct; i++)
        if (dictionary[i].size >= size && dictionary[i].freed) {
            dictionary[i].freed = 0;
            return dictionary[i].addr;
        }
    return_ptr = sbrk (size);
    dictionary[dictionary_ct].addr = return_ptr;
    dictionary[dictionary_ct].size = size;
    dictionary[dictionary_ct].freed = 0;
    dictionary_ct++;
    return return_ptr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5422061_5422227_9_35
5422061_5422447_10_27
Title: malloc implementation? 
----------------------------------------

void *malloc (size_t size) {
    void *return_ptr = NULL;
    int i;
    if (dictionary == NULL) {
        dictionary = sbrk (1024 * sizeof (mem_dictionary));
        memset (dictionary, 0, 1024 * sizeof (mem_dictionary));
    }
    for (i = 0; i < dictionary_ct; i++)
        if (dictionary[i].size >= size && dictionary[i].freed) {
            dictionary[i].freed = 0;
            return dictionary[i].addr;
        }
    return_ptr = sbrk (size);
    dictionary[dictionary_ct].addr = return_ptr;
    dictionary[dictionary_ct].size = size;
    dictionary[dictionary_ct].freed = 0;
    dictionary_ct++;
    return return_ptr;
}
----------------------------------------

void *malloc (size_t size) {
    size = (size + sizeof (size_t) + (align_to - 1)) & ~(align_to - 1);
    free_block *block = free_block_list_head.next;
    free_block **head = &(free_block_list_head.next);
    while (block != 0) {
        if (block->size >= size) {
            *head = block->next;
            return ((char *) block) + sizeof (size_t);
        }
        head = &(block->next);
        block = block->next;
    }
    block = (free_block *) sbrk (size);
    block->size = size;
    return ((char *) block) + sizeof (size_t);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5432515_5432584_3_12
5432515_5432687_1_12
Title: big endian or little endian? 
----------------------------------------

int main () {
    long x = 0x44434241;
    char *y = (char *) &x;
    if (strncmp (y, "ABCD", 4)) {
        printf ("Big Endian\n");
    }
    else {
        printf ("little Endian\n");
    }
}
----------------------------------------

int main () {
    unsigned int i = 0x12345678;
    unsigned char *pc = &i;
    if (*pc == 0x12)
        printf ("Big Endian. i = 0x%x, *pc = 0x%x\n", i, *pc);
    else if (*pc == 0x78)
        printf ("Little Endian. i = 0x%x, *pc = 0x%x\n", i, *pc);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5441323_14735240_3_33
5441323_21870919_40_58
Title: Finding the largest and smallest integers in C 
----------------------------------------

int main (void) {
    int a, b, c, d, min1, max1, min2, max2, min, max;
    scanf ("%d %d %d %d", & a, & b, & c, & d);
    if (a > b) {
        max1 = a;
        min1 = b;
    }
    else {
        max1 = b;
        min1 = a;
    }
    if (c > d) {
        max2 = c;
        min2 = d;
    }
    else {
        max2 = d;
        min2 = c;
    }
    if (min1 < min2)
        min = min1;
    else
        min = min2;
    if (max1 > max2)
        max = max1;
    else
        max = max2;
    printf ("%d %d", max, min);
    return 0;
}
----------------------------------------

int main (void) {
    int a1, a2, a3, a4;
    printf ("Enter four integers : ");
    scanf ("%d %d %d %d", & a1, & a2, & a3, & a4);
    if (a1 > a2) {
        int temp1 = a1;
        a1 = a2;
        a2 = temp1;
    }
    if (a3 > a4) {
        int temp2 = a3;
        a3 = a4;
        a4 = temp2;
    }
    if (a1 > a3) {
        int temp3 = a1;
        a1 = a3;
        a3 = temp3;
    }
    if (a2 > a4) {
        int temp4 = a2;
        a2 = a4;
        a4 = temp4;
    }
    printf ("Largest : %d\n", a4);
    printf ("Smallest : %d\n", a1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5441323_14735240_3_33
5441323_23876348_3_23
Title: Finding the largest and smallest integers in C 
----------------------------------------

int main (void) {
    int a, b, c, d, min1, max1, min2, max2, min, max;
    scanf ("%d %d %d %d", & a, & b, & c, & d);
    if (a > b) {
        max1 = a;
        min1 = b;
    }
    else {
        max1 = b;
        min1 = a;
    }
    if (c > d) {
        max2 = c;
        min2 = d;
    }
    else {
        max2 = d;
        min2 = c;
    }
    if (min1 < min2)
        min = min1;
    else
        min = min2;
    if (max1 > max2)
        max = max1;
    else
        max = max2;
    printf ("%d %d", max, min);
    return 0;
}
----------------------------------------

int main (void) {
    int no1, no2, no3, no4;
    int max1, max2, max3, min1, min2, min3;
    printf ("Enter four integers:");
    scanf_s ("%d %d %d %d", & no1, & no2, & no3, & no4);
    if (no1 > no2 || no1 < no2 && no3 > no4 || no3 < no4) {
        no1 > no2 ? (max1 = no1) : (max1 = no2);
        no1 > no2 ? (min1 = no2) : (min1 = no1);
        no3 > no4 ? (max2 = no3) : (max2 = no4);
        no3 > no4 ? (min2 = no4) : (min2 = no3);
    }
    if (max1 > max2 || max1 < max2 && min1 > min2 || min1 < min2) {
        max1 > max2 ? (max3 = max1) : (max3 = max2);
        min1 > min2 ? (min3 = min2) : (min3 = min1);
    }
    printf ("The largest number is %d \n", max3);
    printf ("The smallest number is %d \n", min3);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5441323_21870919_40_58
5441323_23876348_3_23
Title: Finding the largest and smallest integers in C 
----------------------------------------

int main (void) {
    int a1, a2, a3, a4;
    printf ("Enter four integers : ");
    scanf ("%d %d %d %d", & a1, & a2, & a3, & a4);
    if (a1 > a2) {
        int temp1 = a1;
        a1 = a2;
        a2 = temp1;
    }
    if (a3 > a4) {
        int temp2 = a3;
        a3 = a4;
        a4 = temp2;
    }
    if (a1 > a3) {
        int temp3 = a1;
        a1 = a3;
        a3 = temp3;
    }
    if (a2 > a4) {
        int temp4 = a2;
        a2 = a4;
        a4 = temp4;
    }
    printf ("Largest : %d\n", a4);
    printf ("Smallest : %d\n", a1);
}
----------------------------------------

int main (void) {
    int no1, no2, no3, no4;
    int max1, max2, max3, min1, min2, min3;
    printf ("Enter four integers:");
    scanf_s ("%d %d %d %d", & no1, & no2, & no3, & no4);
    if (no1 > no2 || no1 < no2 && no3 > no4 || no3 < no4) {
        no1 > no2 ? (max1 = no1) : (max1 = no2);
        no1 > no2 ? (min1 = no2) : (min1 = no1);
        no3 > no4 ? (max2 = no3) : (max2 = no4);
        no3 > no4 ? (min2 = no4) : (min2 = no3);
    }
    if (max1 > max2 || max1 < max2 && min1 > min2 || min1 < min2) {
        max1 > max2 ? (max3 = max1) : (max3 = max2);
        min1 > min2 ? (min3 = min2) : (min3 = min1);
    }
    printf ("The largest number is %d \n", max3);
    printf ("The smallest number is %d \n", min3);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5452318_5452492_31_47
5452318_5456025_34_50
Title: C Options Good Style? 
----------------------------------------

int main (int argc, char *argv []) {
    enum option options = processOpts (argc, argv);
    if (options & OPTION_a) {
    }
    if (options & OPTION_b) {
    }
    if (options & OPTION_c) {
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    struct option options = processOpts (argc, argv);
    if (options.OptionA) {
    }
    if (options.OptionB) {
    }
    if (options.OptionC) {
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5455866_5455887_3_15
5455866_5455962_2_10
Title: error: invalid type argument of ‘unary *’ (have ‘int’) 
----------------------------------------

int main (void) {
    int b = 10;
    int *a = NULL;
    int **c = NULL;
    a = &b;
    c = &a;
    printf ("%d", * * c);
    return 0;
}
----------------------------------------

int main () {
    int b = 10;
    int *a;
    a = &b;
    int **c;
    c = &a;
    printf ("%d", (* * c));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5468580_5468649_1_11
5468580_5468728_2_12
Title: Y is not incremented 
----------------------------------------

void main () {
    int *x, *y;
    int a = 23, b = 56;
    x = &a;
    y = &b;
    printf ("%d\t%d", * x, * y);
    (*x)++;
    (*y)++;
    printf ("\n%d\t%d", * x, * y);
    return 0;
}
----------------------------------------

void main () {
    int *x = NULL;
    int *y = NULL;
    int a = 23, b = 56;
    x = &a;
    y = &b;
    printf ("%x\t%x", x, y);
    x++;
    y++;
    printf ("\n%x\t%x", x, y);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5468580_5468667_2_12
5468580_5468728_2_12
Title: Y is not incremented 
----------------------------------------

int main (int argc, char *argv []) {
    int *x, *y;
    int a = 23, b = 56;
    x = &a;
    y = &b;
    printf ("%d\t\t%d", * x, * y);
    (*x)++;
    (*y)++;
    printf ("\n%d\t\t%d", * x, * y);
    return 0;
}
----------------------------------------

void main () {
    int *x = NULL;
    int *y = NULL;
    int a = 23, b = 56;
    x = &a;
    y = &b;
    printf ("%x\t%x", x, y);
    x++;
    y++;
    printf ("\n%x\t%x", x, y);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5500898_5500926_1_13
5500898_5500958_4_16
Title: Convert small letter to capital letter 
----------------------------------------

int main () {
    char str [10];
    int i = 0;
    scanf ("%s", str);
    while (str[i] != 0) {
        str[i] += -32;
        i++;
    }
    printf ("%s", str);
    return 0;
}
----------------------------------------

int main () {
    int i = 0;
    char str [] = "Test String.\n";
    char c;
    while (str[i]) {
        c = str[i];
        putchar (toupper (c));
        i++;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5500898_5500958_4_16
5500898_5501239_1_13
Title: Convert small letter to capital letter 
----------------------------------------

int main () {
    int i = 0;
    char str [] = "Test String.\n";
    char c;
    while (str[i]) {
        c = str[i];
        putchar (toupper (c));
        i++;
    }
    return 0;
}
----------------------------------------

int main () {
    char str [10];
    int i = 0;
    scanf ("%s", & str);
    while (str[i] != '\0' && i < 10) {
        str[i] += -32;
        printf ("%c", str [i]);
        i++;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5512234_5512305_1_16
5512234_5512711_1_15
Title: memcpy and pointers 
----------------------------------------

void f2_int_ptr () {
    int i = 0;
    void *elements = malloc (size * sizeof (int *));
    for (i = 0; i < size; i++) {
        int *v = malloc (sizeof (int));
        memcpy (v, & i, sizeof (int));
        memcpy (INDEX (i), & v, sizeof (int *));
    }
    for (i = 0; i < size; i++) {
        int *v;
        memcpy (& v, INDEX (i), sizeof (int *));
        printf ("%d\n", * v);
    }
}
----------------------------------------

void f2_int_ptr () {
    int i = 0;
    void *elements = (void *) malloc (size * sizeof (int *));
    for (i = 0; i < size; i++) {
        int *v = (int *) malloc (sizeof (int));
        memcpy (v, & i, sizeof (int));
        memcpy (INDEX (i), v, sizeof (int *));
    }
    for (i = 0; i < size; i++) {
        int *v = (int *) malloc (sizeof (int *));
        memcpy (v, INDEX (i), sizeof (int *));
        printf ("%d\n", * v);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5520754_5520857_13_34
5520754_5522303_19_36
Title: C and dynamic structure element access 
----------------------------------------

int main () {
    example = malloc (sizeof (STRUCT) * 10);
    int i = 0, j = 0;
    for (; i < 10; i++) {
        example[i].a = i;
        example[i].z = malloc (sizeof (SUB) * 5);
        for (j = 0; j < 5; j++)
            example[i].z[j].x = example[i].z[j].y = j;
    }
    int my_x = example[3].z[2].x;
    printf ("%d", my_x);
    for (i = 0; i < 10; i++) {
        printf ("%d |\n", example [i].a);
        for (j = 0; j < 5; j++)
            printf ("%d %d\n", example[i].z[j].x, example[i].z[j].y);
        free (example [i].z);
    }
    free (example);
}
----------------------------------------

void main (void) {
    clrscr ();
    printf ("Sample problem..\n\n");
    STRUCT *example;
    int i;
    example = (STRUCT *) malloc (sizeof (STRUCT));
    example->z = (SUB *) malloc (NUM * sizeof (SUB));
    for (i = 0; i < NUM; i++) {
        example->z[i].x = i + 1;
        example->z[i].y = (example->z[i].x) + 1;
        printf ("i = %d: x:%d y:%d\n", i, example -> z [i].x, example -> z [i].y);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5561138_5561266_3_16
5561138_5561331_1_14
Title: Interview Question : Trim multiple consecutive spaces from a string 
----------------------------------------

int main (void) {
    char str [] = "I    Like    StackOverflow a      lot";
    int i, j = 0, lastSpace = 0;
    for (i = 0; str[i]; i++) {
        if (!lastSpace || str[i] != ' ') {
            str[j] = str[i];
            j++;
        }
        lastSpace = (str[i] == ' ');
    }
    str[j] = 0;
    puts (str);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *f, *b, arr [] = "  This        is    a test.                ";
    f = b = arr;
    if (f)
        do {
            while (*f == ' ' && *(f + 1) == ' ')
                f++;
        }
        while (*b++ = *f++);
    printf ("%s", arr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5589136_5589140_7_25
5589136_5589450_11_28
Title: Copy struct to buffer 
----------------------------------------

int main (int argc, char **argv) {
    data my_data;
    my_data.num1 = 64;
    my_data.num2 = 65;
    my_data.num3 = 66;
    char buffer [20];
    memcpy (buffer, & my_data, sizeof (data));
    data copy_data;
    memcpy (& copy_data, buffer, sizeof (data));
    printf ("the numbers : %d - %d - %d \n", copy_data.num1, copy_data.num2, copy_data.mum3);
    return 0;
}
----------------------------------------

int main () {
    struct data ob1;
    struct data *buffer = (struct data *) malloc (sizeof (struct data));
    if (buffer == NULL) {
        printf ("Memory allocation failed\n");
        return;
    }
    ob1.num1 = 1;
    ob1.num2 = 2;
    ob1.num3 = 3;
    ob1.num4 = 4;
    memcpy (buffer, & ob1, sizeof (struct data));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5597513_5597593_1_16
5597513_5597639_4_32
Title: Line by line reading in C and C++? 
----------------------------------------

int main () {
    string line;
    ifstream myfile ("example.txt");
    if (myfile.is_open ()) {
        while (myfile.good ()) {
            getline (myfile, line);
            cout << line << endl;
        }
        myfile.close ();
    }
    else
        cout << "Unable to open file";
    return 0;
}
----------------------------------------

int main () {
    FILE *pFile;
    const int n = 5;
    char mystring [n];
    int lineLength = 0;
    pFile = fopen ("myfile.txt", "r");
    if (pFile == NULL) {
        perror ("Error opening file");
    }
    else {
        do {
            fgets (mystring, n, pFile);
            puts (mystring);
            lineLength += strlen (mystring);
        }
        while (mystring[strlen (mystring) - 1] != '\n' && !feof (pFile));
        fclose (pFile);
    }
    printf ("Line Length: %d\n", lineLength);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5627673_5627855_22_38
5627673_5627909_18_37
Title: Return an array with all integers from a to b 
----------------------------------------

int main (void) {
    int *array;
    int i, a = 42, b = 50;
    array = create_array (a, b);
    for (i = 0; i < b - a + 1; ++i)
        printf ("%d\n", array[i]);
    free (array);
    return 0;
}
----------------------------------------

int main (void) {
    int a, b, i, *ar;
    printf ("Give first integer: ");
    scanf ("%d", & a);
    printf ("Give second integer: ");
    scanf ("%d", & b);
    ar = exc (a, b);
    for (i = 0; i < (b - a + 1); i++) {
        printf ("%d ", ar [i]);
    }
    free (ar);
    system ("pause");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5641483_5647943_130_149
5641483_5650358_136_219
Title: thread grabs other threads IPC message from queue (Linux) 
----------------------------------------

int main (void) {
    ipcMickey = ftok ("./mqmickey", 63);
    mqMickeyid = msgget (ipcMickey, IPC_CREAT | 0666);
    printf ("mqMickeyid=%d\n", mqMickeyid);
    ipcDonald = ftok ("./mqdonald", 69);
    mqDonaldid = msgget (ipcDonald, IPC_CREAT | 0666);
    printf ("mqDonaldid=%d\n", mqDonaldid);
    pthread_create (& t1, NULL, MICKEYthreadFunc, "Mickey sends\n");
    pthread_create (& t2, NULL, MINNIEthreadFunc, "Minnie replies\n");
    pthread_create (& t3, NULL, DONALDthreadFunc, "Donald sends\n");
    pthread_create (& t4, NULL, PLUTOthreadFunc, "Pluto replies\n");
    while (1) {
        sleep (5);
    }
}
----------------------------------------

int main (void) {
    fMickeypointer = fopen (MQMICKEY, "a");
    if (fMickeypointer == NULL) {
        printf ("Failed to create Mickey queue file.\n");
        setlogmask (LOG_UPTO (LOG_NOTICE));
        openlog ("MickeyDonald", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
        syslog (LOG_NOTICE, "Failed to create Mickey queue file.");
        closelog ();
        exit (91);
    }
    fDonaldpointer = fopen (MQDONALD, "a");
    if (fDonaldpointer == NULL) {
        printf ("Failed to create Donald queue file.\r\n");
        setlogmask (LOG_UPTO (LOG_NOTICE));
        openlog ("MickeyDonald", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
        syslog (LOG_NOTICE, "Failed to create Donald queue file.");
        closelog ();
        exit (92);
    }
    ipcMickey = 0;
    ipcDonald = 0;
    while (ipcMickey == ipcDonald) {
        ipcMickey = ftok (MQMICKEY, 63);
        if (-1 == ipcMickey) {
            printf ("ipcMickey does not exist.\r\n");
            setlogmask (LOG_UPTO (LOG_NOTICE));
            openlog ("MickeyDonald", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
            syslog (LOG_NOTICE, "Failed to ftok Mickey file.");
            closelog ();
            exit (93);
        }
        ipcDonald = ftok (MQDONALD, 69);
        if (-1 == ipcDonald) {
            printf ("ipcDonald does not exist.\r\n");
            setlogmask (LOG_UPTO (LOG_NOTICE));
            openlog ("MickeyDonald", LOG_CONS | LOG_PID | LOG_NDELAY, LOG_LOCAL1);
            syslog (LOG_NOTICE, "Failed to ftok Donald file.");
            closelog ();
            exit (94);
        }
    }
    mqMickeyid = msgget (ipcMickey, IPC_CREAT | 0666);
    mqDonaldid = msgget (ipcDonald, IPC_CREAT | 0666);
    pthread_create (& t1, NULL, MICKEYthreadFunc, "Mickey sends\n");
    pthread_create (& t2, NULL, MINNIEthreadFunc, "Minnie replies\n");
    pthread_create (& t3, NULL, DONALDthreadFunc, "Donald sends\n");
    pthread_create (& t4, NULL, PLUTOthreadFunc, "Pluto replies\n");
    long exitcounter = 0;
    while (exitcounter < 100000) {
        exitcounter += 1;
        usleep (100);
    }
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5656530_22557543_10_56
5656530_36244366_5_40
Title: How to use shared memory with Linux in C 
----------------------------------------

int main (int argc, char *argv []) {
    key_t key;
    int shmid;
    char *data;
    int mode;
    if (argc > 2) {
        fprintf (stderr, "usage: shmdemo [data_to_write]\n");
        exit (1);
    }
    if ((key = ftok ("hello.txt", 'R')) == -1) {
        perror ("ftok");
        exit (1);
    }
    if ((shmid = shmget (key, SHM_SIZE, 0644 | IPC_CREAT)) == -1) {
        perror ("shmget");
        exit (1);
    }
    data = shmat (shmid, (void *) 0, 0);
    if (data == (char *) (-1)) {
        perror ("shmat");
        exit (1);
    }
    if (argc == 2) {
        printf ("writing to segment: \"%s\"\n", argv [1]);
        strncpy (data, argv [1], SHM_SIZE);
    }
    else
        printf ("segment contains: \"%s\"\n", data);
    if (shmdt (data) == -1) {
        perror ("shmdt");
        exit (1);
    }
    return 0;
}
----------------------------------------

int main () {
    int segment_id;
    char *shared_memory;
    struct shmid_ds shmbuffer;
    int segment_size;
    const int shared_segment_size = 0x6400;
    segment_id = shmget (IPC_PRIVATE, shared_segment_size, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
    shared_memory = (char *) shmat (segment_id, 0, 0);
    printf ("shared memory attached at address %p\n", shared_memory);
    shmctl (segment_id, IPC_STAT, & shmbuffer);
    segment_size = shmbuffer.shm_segsz;
    printf ("segment size: %d\n", segment_size);
    sprintf (shared_memory, "Hello, world.");
    shmdt (shared_memory);
    shared_memory = (char *) shmat (segment_id, (void *) 0x5000000, 0);
    printf ("shared memory reattached at address %p\n", shared_memory);
    printf ("%s\n", shared_memory);
    shmdt (shared_memory);
    shmctl (segment_id, IPC_RMID, 0);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5695984_5696105_3_27
5695984_5696114_6_39
Title: Read File Element wise 
----------------------------------------

int main () {
    FILE *file;
    int array [4] [4];
    int y;
    int x;
    file = fopen ("matrix.txt", "r");
    for (y = 0; y < 4; y++) {
        for (x = 0; x < 4; x++) {
            fscanf (file, "%d", & (array [x] [y]));
        }
        fscanf (file, "\n");
    }
    fclose (file);
    for (y = 0; y < 4; y++) {
        for (x = 0; x < 4; x++) {
            printf ("%d ", array [x] [y]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    FILE *file = fopen ("input.txt", "r");
    if (!file)
        perror ("Can't open input");
    int matrix [4] [4] = {{0, 0, 0, 0,}, {0, 0, 0, 0,}, {0, 0, 0, 0,}, {0, 0, 0, 0,},};
    int i;
    for (i = 0; i < 4; i++) {
        int n = fscanf (file, "%i %i %i %i", &matrix[i][0], &matrix[i][1], &matrix[i][2], &matrix[i][3]);
        if (n != 4) {
            if (errno != 0)
                perror ("scanf");
            else
                fprintf (stderr, "No matching characters\n");
        }
    }
    for (i = 0; i < 4; i++)
        printf ("%i %i %i %i\n", matrix[i][0], matrix[i][1], matrix[i][2], matrix[i][3]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5711268_18206370_6_42
5711268_5712326_18_30
Title: passing dynamic 2D arrays to function 
----------------------------------------

int main () {
    int i, j, k, n = 10;
    int ***Array = (int ***) malloc (n * sizeof (int **));
    for (i = 0; i < n; i++) {
        Array[i] = (int **) malloc (n * sizeof (int *));
        for (j = 0; j < n; j++) {
            Array[i][j] = (int *) malloc (n * sizeof (int));
        }
    }
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            for (k = 0; k < n; k++) {
                Array[i][j][k] = i * j + k;
            }
        }
    }
    printf ("%d\n", Array [4] [5] [6]);
    Function (Array);
    printf ("%d\n", Array [4] [5] [6]);
    return 0;
}
----------------------------------------

int main () {
    float *a, *b, *ans;
    a = malloc (sizeof (float) * n * n);
    input (& a);
    b = malloc (sizeof (float) * n * n);
    input (& b);
    ans = multiply (a, b);
    output (ans);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5744089_5744126_13_28
5744089_5744130_3_13
Title: How to make cursor rotate 
----------------------------------------

int main () {
    while (1) {
        printf ("\\\b");
        delay (mydelay);
        printf ("|\b");
        delay (mydelay);
        printf ("/\b");
        delay (mydelay);
        printf ("_\b");
        delay (mydelay);
    }
    return 0;
}
----------------------------------------

int main () {
    while (1) {
        printf ("\\");
        printf ("%c", 8);
        printf ("|");
        printf ("%c", 8);
        printf ("/");
        printf ("%c", 8);
        printf ("_");
        printf ("%c", 8);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5744089_5744126_13_28
5744089_5744191_4_21
Title: How to make cursor rotate 
----------------------------------------

int main () {
    while (1) {
        printf ("\\\b");
        delay (mydelay);
        printf ("|\b");
        delay (mydelay);
        printf ("/\b");
        delay (mydelay);
        printf ("_\b");
        delay (mydelay);
    }
    return 0;
}
----------------------------------------

int main (void) {
    fprintf (stderr, "Here we are:  ");
    while (1) {
        fprintf (stderr, "\b\\");
        sleep (1);
        fprintf (stderr, "\b|");
        sleep (1);
        fprintf (stderr, "\b/");
        sleep (1);
        fprintf (stderr, "\b-");
        sleep (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5744089_5744126_13_28
5744089_5744396_4_13
Title: How to make cursor rotate 
----------------------------------------

int main () {
    while (1) {
        printf ("\\\b");
        delay (mydelay);
        printf ("|\b");
        delay (mydelay);
        printf ("/\b");
        delay (mydelay);
        printf ("_\b");
        delay (mydelay);
    }
    return 0;
}
----------------------------------------

int main () {
    while (1) {
        printf ("\\\b");
        sleep (1);
        printf ("|\b");
        sleep (1);
        printf ("/\b");
        sleep (1);
        printf ("_\b");
        sleep (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5744089_5744130_3_13
5744089_5744191_4_21
Title: How to make cursor rotate 
----------------------------------------

int main () {
    while (1) {
        printf ("\\");
        printf ("%c", 8);
        printf ("|");
        printf ("%c", 8);
        printf ("/");
        printf ("%c", 8);
        printf ("_");
        printf ("%c", 8);
    }
    return 0;
}
----------------------------------------

int main (void) {
    fprintf (stderr, "Here we are:  ");
    while (1) {
        fprintf (stderr, "\b\\");
        sleep (1);
        fprintf (stderr, "\b|");
        sleep (1);
        fprintf (stderr, "\b/");
        sleep (1);
        fprintf (stderr, "\b-");
        sleep (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5744089_5744130_3_13
5744089_5744396_4_13
Title: How to make cursor rotate 
----------------------------------------

int main () {
    while (1) {
        printf ("\\");
        printf ("%c", 8);
        printf ("|");
        printf ("%c", 8);
        printf ("/");
        printf ("%c", 8);
        printf ("_");
        printf ("%c", 8);
    }
    return 0;
}
----------------------------------------

int main () {
    while (1) {
        printf ("\\\b");
        sleep (1);
        printf ("|\b");
        sleep (1);
        printf ("/\b");
        sleep (1);
        printf ("_\b");
        sleep (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5744089_5744191_4_21
5744089_5744396_4_13
Title: How to make cursor rotate 
----------------------------------------

int main (void) {
    fprintf (stderr, "Here we are:  ");
    while (1) {
        fprintf (stderr, "\b\\");
        sleep (1);
        fprintf (stderr, "\b|");
        sleep (1);
        fprintf (stderr, "\b/");
        sleep (1);
        fprintf (stderr, "\b-");
        sleep (1);
    }
    return 0;
}
----------------------------------------

int main () {
    while (1) {
        printf ("\\\b");
        sleep (1);
        printf ("|\b");
        sleep (1);
        printf ("/\b");
        sleep (1);
        printf ("_\b");
        sleep (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5755181_5755202_4_16
5755181_5755214_11_26
Title: Need help applying timer in C in Linux 
----------------------------------------

int main () {
    int a = 10;
    int num = 20;
    int c = time (0);
    while (n--) {
        printf ("%d\n", a);
        while (!(time (0) - c))
            ;
        c = time (0);
    }
    return 0;
}
----------------------------------------

int main (void) {
    time_t rawtime, ini_time, now;
    struct tm *ptm;
    time (& ini_time);
    for (;;) {
        time (& rawtime);
        now = rawtime - ini_time;
        ptm = gmtime (&now);
        printf ("%2d:%02d:%02d\n", ptm -> tm_hour, ptm -> tm_min, ptm -> tm_sec);
        delay_sec (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5755181_5755202_4_16
5755181_5758217_16_30
Title: Need help applying timer in C in Linux 
----------------------------------------

int main () {
    int a = 10;
    int num = 20;
    int c = time (0);
    while (n--) {
        printf ("%d\n", a);
        while (!(time (0) - c))
            ;
        c = time (0);
    }
    return 0;
}
----------------------------------------

int main () {
    signal (SIGALRM, alarm_handler);
    alarm (1);
    for (;;) {
        select (0, NULL, NULL, NULL, NULL);
        if (print_variable) {
            printf ("Variable = %u\n", variable);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5755181_5755202_4_16
5755181_5758939_9_23
Title: Need help applying timer in C in Linux 
----------------------------------------

int main () {
    int a = 10;
    int num = 20;
    int c = time (0);
    while (n--) {
        printf ("%d\n", a);
        while (!(time (0) - c))
            ;
        c = time (0);
    }
    return 0;
}
----------------------------------------

int main () {
    struct timeval t;
    while (1) {
        t.tv_sec = 1;
        t.tv_usec = 0;
        select (0, NULL, NULL, NULL, & t);
        your_callback ();
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5755181_5755214_11_26
5755181_5758217_16_30
Title: Need help applying timer in C in Linux 
----------------------------------------

int main (void) {
    time_t rawtime, ini_time, now;
    struct tm *ptm;
    time (& ini_time);
    for (;;) {
        time (& rawtime);
        now = rawtime - ini_time;
        ptm = gmtime (&now);
        printf ("%2d:%02d:%02d\n", ptm -> tm_hour, ptm -> tm_min, ptm -> tm_sec);
        delay_sec (1);
    }
    return 0;
}
----------------------------------------

int main () {
    signal (SIGALRM, alarm_handler);
    alarm (1);
    for (;;) {
        select (0, NULL, NULL, NULL, NULL);
        if (print_variable) {
            printf ("Variable = %u\n", variable);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5755181_5755214_11_26
5755181_5758939_9_23
Title: Need help applying timer in C in Linux 
----------------------------------------

int main (void) {
    time_t rawtime, ini_time, now;
    struct tm *ptm;
    time (& ini_time);
    for (;;) {
        time (& rawtime);
        now = rawtime - ini_time;
        ptm = gmtime (&now);
        printf ("%2d:%02d:%02d\n", ptm -> tm_hour, ptm -> tm_min, ptm -> tm_sec);
        delay_sec (1);
    }
    return 0;
}
----------------------------------------

int main () {
    struct timeval t;
    while (1) {
        t.tv_sec = 1;
        t.tv_usec = 0;
        select (0, NULL, NULL, NULL, & t);
        your_callback ();
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5755181_5758217_16_30
5755181_5758939_9_23
Title: Need help applying timer in C in Linux 
----------------------------------------

int main () {
    signal (SIGALRM, alarm_handler);
    alarm (1);
    for (;;) {
        select (0, NULL, NULL, NULL, NULL);
        if (print_variable) {
            printf ("Variable = %u\n", variable);
        }
    }
}
----------------------------------------

int main () {
    struct timeval t;
    while (1) {
        t.tv_sec = 1;
        t.tv_usec = 0;
        select (0, NULL, NULL, NULL, & t);
        your_callback ();
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5760302_34929384_8_32
5760302_8471682_7_20
Title: "When i do getaddrinfo for localhost I don't receive 127.0.0.1" 
----------------------------------------

int main () {
    char addr_buf [64];
    struct addrinfo *feed_server = NULL;
    memset (addr_buf, 0, sizeof (addr_buf));
    getaddrinfo ("localhost", NULL, NULL, & feed_server);
    struct addrinfo *res;
    for (res = feed_server; res != NULL; res = res->ai_next) {
        if (res->ai_family == AF_INET) {
            inet_ntop (AF_INET, & ((struct sockaddr_in *) res -> ai_addr) -> sin_addr, addr_buf, sizeof (addr_buf));
        }
        else {
            inet_ntop (AF_INET6, & ((struct sockaddr_in6 *) res -> ai_addr) -> sin6_addr, addr_buf, sizeof (addr_buf));
        }
        printf ("hostname: %s\n", addr_buf);
    }
    return 0;
}
----------------------------------------

int main () {
    struct addrinfo hints;
    memset (& hints, 0, sizeof (struct addrinfo));
    hints.ai_family = AF_INET;
    getaddrinfo ("localhost", NULL, & hints, & feed_server);
    struct addrinfo *res;
    for (res = feed_server; res != NULL; res = res->ai_next) {
        struct sockaddr_in *saddr = (struct sockaddr_in *) res->ai_addr;
        printf ("hostname: %s\n", inet_ntoa (saddr -> sin_addr))
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5772193_29522172_8_25
5772193_5772312_6_15
Title: How can I store 4 char into an unsigned int using bitwise operation? 
----------------------------------------

int main () {
    int i;
    int x;
    char e = 'E';
    char t = 'T';
    char n = 'N';
    char a = 'A';
    ((char *) &x)[0] = e;
    ((char *) &x)[1] = t;
    ((char *) &x)[2] = n;
    ((char *) &x)[3] = a;
    for (i = 0; i < 4; i++)
        printf ("%c\n", ((char *) &x)[i]);
    return 0;
}
----------------------------------------

int main (int argc, char const *argv []) {
    union int_chars c;
    c.a = 10;
    c.b[0] = 1;
    c.b[1] = 2;
    c.b[2] = 3;
    c.b[3] = 4;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
578202_38074162_3_20
578202_50086119_7_27
Title: """register"" keyword in C?" 
----------------------------------------

int main (int argc, char **argv) {
    register int numIterations = 20000;
    register int i = 0;
    unsigned long val = 0;
    for (i; i < numIterations + 1; i++) {
        register int j = 0;
        for (j; j < i; j++) {
            val = j + i;
        }
    }
    printf ("%d", val);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    uint64_t cps, cycle1, cycle2, ncycles;
    double sec;
    register int a = 0, b = 1, c = 3, i;
    cycle1 = ClockCycles ();
    for (i = 0; i < 100000000; i++)
        a = ((a + b + c) * c) / 2;
    cycle2 = ClockCycles ();
    ncycles = cycle2 - cycle1;
    printf ("%lld cycles elapsed\n", ncycles);
    cps = SYSPAGE_ENTRY (qtime)->cycles_per_sec;
    printf ("This system has %lld cycles per second\n", cps);
    sec = (double) ncycles / cps;
    printf ("The cycles in seconds is %f\n", sec);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5791117_25693212_2_22
5791117_5791277_2_23
Title: How to detect a new line of any file using C program 
----------------------------------------

void main () {
    FILE *p;
    int n;
    int s = 0;
    int a [10];
    p = fopen ("C:\\numb.txt", "r");
    if (p != NULL)
        printf ("file opened");
    while ((n = getc (p)) != EOF) {
        if (n != NULL && n != '\n') {
            printf ("\n%d", n);
            a[s] = n;
            ++s;
        }
    }
    fclose (p);
    getchar ();
}
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp = fopen ("d:\\abc.txt", "r");
    char line [1024];
    char ch = getc (fp);
    int index = 0;
    while (ch != EOF) {
        if (ch != '\n') {
            line[index++] = ch;
        }
        else {
            line[index] = '\0';
            index = 0;
            printf ("%s\n", line);
        }
        ch = getc (fp);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5797548_5797561_1_18
5797548_5797652_1_36
Title: C linked list inserting node at the end 
----------------------------------------

int addNodeBottom (int val, node *head) {
    node *current = head;
    node *newNode = (node *) malloc (sizeof (node));
    if (newNode == NULL) {
        printf ("malloc failed\n");
        exit (- 1);
    }
    newNode->value = val;
    newNode->next = NULL;
    while (current->next) {
        current = current->next;
    }
    current->next = newNode;
    return 0;
}
----------------------------------------

int addNodeBottom (int val, node *head) {
    node *newNode = (node *) malloc (sizeof (node));
    if (newNode == NULL) {
        fprintf (stderr, "Unable to allocate memory for new node\n");
        exit (- 1);
    }
    newNode->value = val;
    newNode->next = NULL;
    if (head->next == NULL) {
        head->next = newNode;
        printf ("added at beginning\n");
    }
    else {
        node *current = head;
        while (true) {
            if (current->next == NULL) {
                current->next = newNode;
                printf ("added later\n");
                break;
            }
            current = current->next;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5838764_5838781_5_20
5838764_5838864_6_26
Title: How can I stop scanf-ing input after a certain character? 
----------------------------------------

int main (int argc, char *argv []) {
    if (argc != 2) {
        fprintf (stderr, "Usage: %s path\n", argv [0]);
        exit (EXIT_FAILURE);
    }
    char *saveptr = NULL;
    for (char *str = argv[1];; str = NULL) {
        char *token = strtok_r (str, "/", &saveptr);
        if (token == NULL)
            break;
        printf ("%s\n", token);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int len;
    char *cp;
    char *token;
    regex_t preg;
    regmatch_t match;
    if (regcomp (&preg, argv[1], REG_EXTENDED) != 0) {
        return 0;
    }
    for (cp = argv[2]; *cp != '\0'; cp += len) {
        len = (regexec (&preg, cp, 1, &match, 0) == 0) ? match.rm_eo : strlen (cp);
        token = malloc (len);
        strncpy (token, cp, len);
        printf ("%s\n", token);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5850500_5850592_1_14
5850500_5850727_61_74
Title: C - join arrays 
----------------------------------------

int Join (set arr1 [], int arr1_size, set arr2 [], int arr2_size, set arr3 [], int arr3_size) {
    int i;
    int j = 0;
    for (i = 0; i < arr1_size; i++) {
        arr3[i] = arr1[i];
    }
    for (i = 0; i < arr2_size; i++) {
        if (!in_arr (arr2[i], arr3, arr3_size)) {
            arr3[j + arr1_size] = arr2[i];
            j++;
        }
    }
}
----------------------------------------

static int Join (set arr1 [], int arr1_size, set arr2 [], int arr2_size, set arr3 [], int arr3_size) {
    int i;
    int k;
    for (i = 0; i < arr1_size; i++)
        arr3[k++] = arr1[i];
    for (i = 0; i < arr2_size; i++) {
        if (!in_arr (arr2[i], arr3, arr3_size))
            arr3[k++] = arr2[i];
    }
    assert (k <= arr3_size);
    return k;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5858646_5864371_1_38
5858646_5864602_3_36
Title: Optimizing variable-length encoding 
----------------------------------------

size_t compress_unsigned_int (unsigned int n, char *data) {
    size_t size;
    if (n < 0x00000080U) {
        size = 1;
        goto b1;
    }
    if (n < 0x00004000U) {
        size = 2;
        goto b2;
    }
    if (n < 0x00200000U) {
        size = 3;
        goto b3;
    }
    if (n < 0x10000000U) {
        size = 4;
        goto b4;
    }
    size = 5;
    *data++ = (n & 0x7f) | 0x80;
    n >>= 7;
b4 :
    *data++ = (n & 0x7f) | 0x80;
    n >>= 7;
b3 :
    *data++ = (n & 0x7f) | 0x80;
    n >>= 7;
b2 :
    *data++ = (n & 0x7f) | 0x80;
    n >>= 7;
b1 :
    *data = n;
    return size;
}
----------------------------------------

size_t compress_unsigned_int (unsigned int n, char *data) {
    if (n < (1U << 14)) {
        if (n < (1U << 7)) {
            data[0] = n;
            return 1;
        }
        else {
            data[0] = (n >> 7) | 0x80;
            data[1] = n & 0x7f;
            return 2;
        }
    }
    else if (n < (1U << 28)) {
        if (n < (1U << 21)) {
            data[0] = (n >> 14) | 0x80;
            data[1] = ((n >> 7) & 0x7f) | 0x80;
            data[2] = n & 0x7f;
            return 3;
        }
        else {
            data[0] = (n >> 21) | 0x80;
            data[1] = ((n >> 14) & 0x7f) | 0x80;
            data[2] = ((n >> 7) & 0x7f) | 0x80;
            data[3] = n & 0x7f;
            return 4;
        }
    }
    else {
        data[0] = (n >> 28) | 0x80;
        data[1] = ((n >> 21) & 0x7f) | 0x80;
        data[2] = ((n >> 14) & 0x7f) | 0x80;
        data[3] = ((n >> 7) & 0x7f) | 0x80;
        data[4] = n & 0x7f;
        return 5;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5858646_5864371_1_38
5858646_8680022_1_12
Title: Optimizing variable-length encoding 
----------------------------------------

size_t compress_unsigned_int (unsigned int n, char *data) {
    size_t size;
    if (n < 0x00000080U) {
        size = 1;
        goto b1;
    }
    if (n < 0x00004000U) {
        size = 2;
        goto b2;
    }
    if (n < 0x00200000U) {
        size = 3;
        goto b3;
    }
    if (n < 0x10000000U) {
        size = 4;
        goto b4;
    }
    size = 5;
    *data++ = (n & 0x7f) | 0x80;
    n >>= 7;
b4 :
    *data++ = (n & 0x7f) | 0x80;
    n >>= 7;
b3 :
    *data++ = (n & 0x7f) | 0x80;
    n >>= 7;
b2 :
    *data++ = (n & 0x7f) | 0x80;
    n >>= 7;
b1 :
    *data = n;
    return size;
}
----------------------------------------

size_t compress_unsigned_int (unsigned int n, char *data) {
    size_t size = 0;
    while (n > 127) {
        ++size;
        *data++ = (n & 127) | 128;
        n >>= 7;
    }
    *data++ = n;
    return ++size;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5858646_5864602_3_36
5858646_8680022_1_12
Title: Optimizing variable-length encoding 
----------------------------------------

size_t compress_unsigned_int (unsigned int n, char *data) {
    if (n < (1U << 14)) {
        if (n < (1U << 7)) {
            data[0] = n;
            return 1;
        }
        else {
            data[0] = (n >> 7) | 0x80;
            data[1] = n & 0x7f;
            return 2;
        }
    }
    else if (n < (1U << 28)) {
        if (n < (1U << 21)) {
            data[0] = (n >> 14) | 0x80;
            data[1] = ((n >> 7) & 0x7f) | 0x80;
            data[2] = n & 0x7f;
            return 3;
        }
        else {
            data[0] = (n >> 21) | 0x80;
            data[1] = ((n >> 14) & 0x7f) | 0x80;
            data[2] = ((n >> 7) & 0x7f) | 0x80;
            data[3] = n & 0x7f;
            return 4;
        }
    }
    else {
        data[0] = (n >> 28) | 0x80;
        data[1] = ((n >> 21) & 0x7f) | 0x80;
        data[2] = ((n >> 14) & 0x7f) | 0x80;
        data[3] = ((n >> 7) & 0x7f) | 0x80;
        data[4] = n & 0x7f;
        return 5;
    }
}
----------------------------------------

size_t compress_unsigned_int (unsigned int n, char *data) {
    size_t size = 0;
    while (n > 127) {
        ++size;
        *data++ = (n & 127) | 128;
        n >>= 7;
    }
    *data++ = n;
    return ++size;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
589389_589410_2_30
589389_589425_1_15
Title: What is the correct way to declare and use a FILE * pointer in C/C++? 
----------------------------------------

int main (void) {
    FILE *fin, *fout;
    int c;
    if ((fin = fopen ("input.txt", "r")) == NULL) {
        fprintf (stderr, "Cannot read from input.txt");
        return 1;
    }
    if ((fout = fopen ("output.txt", "w")) == NULL) {
        fprintf (stderr, "Cannot write to output.txt");
        fclose (fin);
        return 1;
    }
    while ((c = fgetc (fin)) >= 0) {
        fputc (c, fout);
    }
    fclose (fin);
    fclose (fout);
    return 0;
}
----------------------------------------

int main (void) {
    char c;
    FILE *read;
    read = fopen ("myfile", "r");
    if (read == NULL) {
        perror ("Error: could not open \"myfile\" for reading.\n");
        exit (1);
    }
    c = fgetc (read);
    fclose (read);
    printf ("The first character of myfile is %c.\n", c);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5918079_21628181_3_20
5918079_50864345_4_29
Title: fgets doesn't work after scanf 
----------------------------------------

int main () {
    printf ("Please enter your name\n");
    char string [10];
    scanf ("%s", string);
    printf ("Hello %s\n", string);
    printf ("Please enter your name again\n");
    fgets (string, 10, stdin);
    printf ("Hello again %s", string);
    getchar ();
}
----------------------------------------

int main () {
    int i, age;
    char phone [10];
    char name [100];
    printf ("ENTER YOUR NAME:");
    fgets (name, 100, stdin);
    printf ("ENTER YOUR AGE:");
    scanf ("%d", & age);
    printf ("ENTER YOUR PHONE NUMBER:");
    scanf (" ");
    fgets (phone, 10, stdin);
    printf ("\nStudent detail\n");
    printf ("Name: ");
    fputs (name, stdout);
    printf ("Age: %d\n", age);
    printf ("Phone Number: ");
    puts (phone);
    printf ("----\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5952512_5952598_1_14
5952512_5952834_1_11
Title: "Memcpy string and terminator" 
----------------------------------------

int writebuff (char *buffer, int length) {
    string text = "123456789012345";
    if (length <= 0)
        return text.size ();
    if (text.size () < length) {
        memcpy (buffer, text.c_str (), text.size () + 1);
        return text.size ();
    }
    memcpy (buffer, text.c_str (), length - 1);
    buffer[length - 1] = '\0';
    return length - 1;
}
----------------------------------------

int writebuff (char *buffer, int length) {
    string text = "123456789012345";
std :
    : fill_n (buffer, length, 0);
    text.copy (buffer, length);
    if (length < text.size ())
        buffer[length - 1] = 0;
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5957621_5957657_1_12
5957621_5957676_1_14
Title: A function that returns a digit within a number 
----------------------------------------

int getDigit (int value, int positionFromLeft) {
    if (value < 0)
        positionFromLeft++;
std :
    : stringstream ss;
    ss << value;
std :
    : string s = ss.str ();
    if (positionFromLeft >= 1 && positionFromLeft <= s.length ())
        return s[positionFromLeft - 1] - '0';
    else throw std : : runtime_error ("invalid digit position");
}
----------------------------------------

int getDigit (int value, int positionFromLeft) {
    int posFromRight = 1;
    {
        int v = value;
        while (v /= 10)
            ++posFromRight;
    }
    posFromRight -= positionFromLeft - 1;
    while (--posFromRight)
        value /= 10;
    value %= 10;
    return value > 0 ? value : -value;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5957621_5957657_1_12
5957621_5957777_1_19
Title: A function that returns a digit within a number 
----------------------------------------

int getDigit (int value, int positionFromLeft) {
    if (value < 0)
        positionFromLeft++;
std :
    : stringstream ss;
    ss << value;
std :
    : string s = ss.str ();
    if (positionFromLeft >= 1 && positionFromLeft <= s.length ())
        return s[positionFromLeft - 1] - '0';
    else throw std : : runtime_error ("invalid digit position");
}
----------------------------------------

int getDigit (unsigned int original, unsigned int positionFromLeft) {
    if (original == 0 && positionFromLeft == 1) {
        return 0;
    }
    unsigned int expon = 0;
    unsigned int power = 1;
    for (unsigned int quotient = original; quotient; quotient /= 10, ++expon) {
        if (expon >= positionFromLeft) {
            power *= 10;
        }
    }
    if (positionFromLeft > expon) {
        return -1;
    }
    return (original / power) % 10;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5957621_5957676_1_14
5957621_5957777_1_19
Title: A function that returns a digit within a number 
----------------------------------------

int getDigit (int value, int positionFromLeft) {
    int posFromRight = 1;
    {
        int v = value;
        while (v /= 10)
            ++posFromRight;
    }
    posFromRight -= positionFromLeft - 1;
    while (--posFromRight)
        value /= 10;
    value %= 10;
    return value > 0 ? value : -value;
}
----------------------------------------

int getDigit (unsigned int original, unsigned int positionFromLeft) {
    if (original == 0 && positionFromLeft == 1) {
        return 0;
    }
    unsigned int expon = 0;
    unsigned int power = 1;
    for (unsigned int quotient = original; quotient; quotient /= 10, ++expon) {
        if (expon >= positionFromLeft) {
            power *= 10;
        }
    }
    if (positionFromLeft > expon) {
        return -1;
    }
    return (original / power) % 10;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5990305_5990539_4_25
5990305_5990771_4_20
Title: Ambiguity in number comparisons (in C)? 
----------------------------------------

int main (int argc, char **argv) {
    uint8_t a = 100;
    uint8_t b = 200;
    a = a + b;
    if (a > b) {
        printf ("%u > %u", a, b);
    }
    else if (a < b) {
        printf ("%u < %u", a, b);
    }
    else {
        printf ("%u == %u", a, b);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int a = nanf (NULL);
    int b = nanf (NULL);
    if (a < b)
        printf ("<\n");
    if (a > b)
        printf ("><![CDATA[\n");
    if (a == b)
        printf ("==\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6026377_6026451_1_17
6026377_6026487_1_27
Title: Desperately seeking the answer to my pointer problem 
----------------------------------------

void pushCategory (GJCType *menu, CategoryTypePtr category) {
    CategoryTypePtr current;
    if (menu->headCategory == NULL) {
        menu->headCategory = category;
    }
    else {
        current = menu->headCategory;
        while (current->nextCategory != NULL) {
            current = current->nextCategory;
        }
        current->nextCategory = category;
    }
    menu->numCategories++;
}
----------------------------------------

void pushCategory (GJCType *menu, CategoryTypePtr category) {
    CategoryTypePtr newCategory;
    CategoryTypePtr current;
    if ((newCategory = malloc (sizeof (CategoryType))) == NULL) {
        fprintf (stderr, "can't malloc enough memory for new category pointer.\n");
        exit (EXIT_FAILURE);
    }
    newCategory->headItem = NULL;
    strncpy (newCategory -> categoryID, category -> categoryID, ID_LEN);
    if (menu->headCategory == NULL) {
        menu->headCategory = new;
    }
    else {
        current = menu->headCategory;
        while (current->nextCategory != NULL) {
            current = current->nextCategory;
        }
        current->nextCategory = newCategory;
    }
    menu->numCategories++;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6036787_6036946_3_17
6036787_6037509_4_23
Title: manual split function in C 
----------------------------------------

int main (int argc, char *argv []) {
    char asshat [] = "456,747";
    char *first = asshat, *second = asshat, *c = asshat;
    while (*c) {
        if (*c == ',') {
            *c = '\0';
            second = ++c;
        }
        else
            c++;
    }
    printf ("first: %s\nsecond: %s\n", first, second);
    return 0;
}
----------------------------------------

int main (void) {
    char asshat [] = "455,747";
    char first [4] = "";
    char second [4] = "";
    char *destination [] = {first, second, NULL};
    size_t i = 0;
    char *token = strtok (asshat, ",");
    while (token && destination[i]) {
        strcpy (destination [i ++], token);
        token = strtok (NULL, ",");
    }
    printf ("first = %s\n", first);
    printf ("second = %s\n", second);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6075013_6075480_4_19
6075013_8255487_160_189
Title: How to detect the launching of programs on Linux? 
----------------------------------------

int main (int argc, char **argv) {
    char buf [256];
    struct inotify_event *event;
    int fd, wd;
    fd = inotify_init ();
    assert (fd > - 1);
    assert ((wd = inotify_add_watch (fd, "/lib/ld-linux.so.2", IN_OPEN)) > 0);
    printf ("Watching for events, wd is %x\n", wd);
    while (read (fd, buf, sizeof (buf))) {
        event = (void *) buf;
        printf ("watch %d mask %x name(len %d)=\"%s\"\n", event -> wd, event -> mask, event -> len, event -> name);
    }
    inotify_rm_watch (fd, wd);
    return 0;
}
----------------------------------------

int main (int argc, const char *argv []) {
    int nl_sock;
    int rc = EXIT_SUCCESS;
    signal (SIGINT, & on_sigint);
    siginterrupt (SIGINT, true);
    nl_sock = nl_connect ();
    if (nl_sock == -1)
        exit (EXIT_FAILURE);
    rc = set_proc_ev_listen (nl_sock, true);
    if (rc == -1) {
        rc = EXIT_FAILURE;
        goto out;
    }
    rc = handle_proc_ev (nl_sock);
    if (rc == -1) {
        rc = EXIT_FAILURE;
        goto out;
    }
    set_proc_ev_listen (nl_sock, false);
out :
    close (nl_sock);
    exit (rc);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
609376_609736_13_30
609376_609749_20_40
Title: Geting xml data using xml parser expat 
----------------------------------------

void start_element (void *data, const char *element, const char **attribute) {
    int i;
    for (i = 0; i < depth; i++) {
        printf (" ");
    }
    printf ("%s", element);
    for (i = 0; attribute[i]; i += 2) {
        printf (" %s= '%s'", attribute [i], attribute [i + 1]);
    }
    printf ("\n");
    depth++;
}
----------------------------------------

void start_element (void *data, const char *element, const char **attribute) {
    process_char_data_buffer ();
    reset_char_data_buffer ();
    if (strcmp ("item", element) == 0) {
        size_t matched = 0;
        for (size_t i = 0; attribute[i]; i += 2) {
            if ((strcmp ("name", attribute[i]) == 0) && (strcmp ("frame", attribute[i + 1]) == 0))
                ++matched;
            if ((strcmp ("type", attribute[i]) == 0) && (strcmp ("int16", attribute[i + 1]) == 0))
                ++matched;
        }
        if (matched == 2) {
            printf ("this is the element you are looking for\n");
            grab_next_value = true;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6097892_6097960_1_13
6097892_6105364_1_17
Title: Accessing an Array of Structures through a pointer 
----------------------------------------

int readfile (FILE *fptr, PERSON *rptr) {
    int v = 0, i, j;
    for (i = 0;
    i < MAXR;
    i ++) {j = i;
    if (fscanf (fptr, "%c\n%d\n%19s\n%d\n%19s\n%d\n%19s\n%19s\n%d\n%d\n%19s\n\n", rptr[j]->gender, rptr[j]->ssn, rptr[j]->name, rptr[j]->age, rptr[j]->job, rptr[j]->income, rptr[j]->major, rptr[j]->minor, rptr[j]->height, rptr[j]->weight, rptr[j]->religion) == EOF)
        i = MAXR;
    if (rptr[MAXR]->ssn == rptr[j]->ssn)
        v = j;
}
----------------------------------------

int readfile (FILE *fptr, PERSON rptr []) {
    int v = 0, i;
    for (i = 0; i < MAXR; i++) {
        if (fscanf (fptr, "%c\n%d\n%19s\n%d\n%19s\n%d\n%19s\n%19s\n%d\n%d\n%19s\n\n", &rptr[i]->gender, &rptr[i]->ssn, rptr[i]->name, &rptr[i]->age, rptr[i]->job, &rptr[i]->income, rptr[i]->major, rptr[i]->minor, &rptr[i]->height, &rptr[i]->weight, rptr[i]->religion) < 11)
            break;
        if (rptr[MAXR]->ssn == rptr[i]->ssn)
            v = i + 1;
    }
    return v;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6105513_6105572_1_12
6105513_6105688_1_15
Title: Need help using qsort with an array of structs 
----------------------------------------

int compare (const void *p1, const void *p2) {
    const struct profile *elem1 = p1;
    const struct profile *elem2 = p2;
    if (elem1->soc < elem2->soc)
        return -1;
    else if (elem1->soc > elem2->soc)
        return 1;
    else
        return 0;
}
----------------------------------------

int compare (const void *v1, const void *v2) {
    const struct profile *p1 = v1;
    const struct profile *p2 = v2;
    if (p1->gender > p2->gender)
        return (+1);
    else if (p1->gender < p2->gender)
        return (-1);
    else if (p1->soc > p2->soc)
        return (+1);
    else if (p1->soc < p2->soc)
        return (-1);
    else
        return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6117056_6117145_1_12
6117056_6117225_1_24
Title: How would I go about sending bit-fields through a socket? 
----------------------------------------

int sendToServer (int sock, char *msg, int flags) {
    size_t siz = strlen (msg) + 1;
    unsigned char *buf = malloc_or_die (siz +1);
    buf[0] = flags;
    memcpy (buf + 1, msg, size);
    send (sock, msg, strlen (msg), 0);
    free (buf);
    return 0;
}
----------------------------------------

int sendToServer (char *msg, int bitfields) {
    unsigned int bits = bswap32 (bitfields);
    size_t len = strlen (msg);
    size_t nlen = bswap64 (len);
    iovec data [3];
    data[0].iov_base = &nlen;
    data[0].iov_len = sizeof (nlen);
    data[1].iov_base = msg;
    data[1].iov_len = len;
    data[2].iov_base = &bits;
    data[2].iov_len = sizeof (bits);
    writev (fd, & data, sizeof (data) / sizeof (data [0]));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6118146_46389229_5_23
6118146_6118193_4_22
Title: how to put in mathematical equation in C 
----------------------------------------

int main () {
    int da, db, dc;
    double x, a, b, c;
    printf ("Enter three integers: ");
    scanf ("%d %d %d", & da, & db, & dc);
    a = (double) da;
    b = (double) db;
    c = (double) dc;
    x = (double) (-b + sqrt (b *b) - 4 * a * c) / (2 * a);
    printf ("The value of x is %g \n", x);
    return 0;
}
----------------------------------------

int main () {
    double x, x1, x2, a, b, c;
    cout << "Input values of a, b, and c.";
    cin >> a >> b >> c;
    if ((b * b - 4 * a * c) > 0)
        cout << "x1 = (-b + sqrt(b * b - 4 * a * c)) / (2 * a)" && cout << "x2 = (-b + sqrt(b * b - 4 * a * c)) / (2 * a)";
    if else ((b * b - 4 * a * c) = 0) cout << "x = ((-b + sqrt(b * b - 4 * a * c)) / (2 * a)" if else ((b * b - 4 * a * c) < 0) cout << "x1 = ((-b + sqrt(b * b - 4 * a * c) * sqrt (-1)) / (2 * a) &&
    cout << " x2 = ((- b + sqrt (b * b - 4 * a * c) * sqrt (- 1)) / (2 * a);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6154539_30916969_12_25
6154539_6155499_12_27
Title: How can I wait for any/all pthreads to complete? 
----------------------------------------

int main () {
    int i;
    pthread_t thread [NUM_THREADS];
    thread_count = NUM_THREADS;
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_create (& thread [i], 0L, threadfunc, & thread [i]);
    }
    do {
        __sync_synchronize ();
    }
    while (thread_count);
    printf ("All threads done\n");
}
----------------------------------------

int main () {
    for (i = 0; i < num_threads; i++) {
        pthread_mutex_lock (& running_mutex);
        running_threads++;
        pthread_mutex_unlock (& running_mutex);
    }
    while (running_threads > 0) {
        sleep (1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6154539_30916969_12_25
6154539_6156106_32_49
Title: How can I wait for any/all pthreads to complete? 
----------------------------------------

int main () {
    int i;
    pthread_t thread [NUM_THREADS];
    thread_count = NUM_THREADS;
    for (i = 0; i < NUM_THREADS; i++) {
        pthread_create (& thread [i], 0L, threadfunc, & thread [i]);
    }
    do {
        __sync_synchronize ();
    }
    while (thread_count);
    printf ("All threads done\n");
}
----------------------------------------

int main () {
    int i = 4;
    for (; i; --i) {
        pthread_t *tcb = malloc (sizeof (*tcb));
        pthread_create (tcb, NULL, threadfunc, (void *) i);
    }
    sleep (40);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6154539_6155499_12_27
6154539_6156106_32_49
Title: How can I wait for any/all pthreads to complete? 
----------------------------------------

int main () {
    for (i = 0; i < num_threads; i++) {
        pthread_mutex_lock (& running_mutex);
        running_threads++;
        pthread_mutex_unlock (& running_mutex);
    }
    while (running_threads > 0) {
        sleep (1);
    }
}
----------------------------------------

int main () {
    int i = 4;
    for (; i; --i) {
        pthread_t *tcb = malloc (sizeof (*tcb));
        pthread_create (tcb, NULL, threadfunc, (void *) i);
    }
    sleep (40);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6170411_24983794_16_83
6170411_32620432_3_36
Title: Problem determining if a number is an Armstrong Number 
----------------------------------------

int main () {
    int temp, rem, val, max, temp1, count;
    int num;
    val = 0;
    num = 1;
    printf ("What is the maximum limit of Armstrong Number Required: ");
    scanf ("%d", & max);
    printf ("\nSo the list of Armstrong Numbers Before the number %d are: \n", max);
    while (num <= max) {
        count = 0;
        temp1 = num;
        while (temp1 != 0) {
            temp1 = temp1 / 10;
            count++;
        }
        if (count < 3)
            count = 3;
        temp = num;
        val = 0;
        while (temp > 0) {
            rem = temp % 10;
            val = val + pow (rem, count);
            temp = temp / 10;
        }
        if (val == num) {
            printf ("\n%d", num);
        }
        num++;
    }
    return 0;
}
----------------------------------------

void main () {
A :
    int n, n1, rem, ans;
    clrscr ();
    printf ("\nEnter No. :: ");
    scanf ("%d", & n);
    n1 = n;
    ans = 0;
    while (n > 0) {
        rem = n % 10;
        ans = ans + (rem * rem * rem);
        n = n / 10;
    }
    if (n1 == ans) {
        printf ("\n Your Entered No. is Armstrong...");
    }
    else {
        printf ("\n Your Entered No. is not Armstrong...");
    }
    printf ("\n\nPress 0 to Continue...");
    if (getch () == '0') {
        goto A;
    }
    printf ("\n\n\tThank You...");
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6170411_24983794_16_83
6170411_6170511_35_50
Title: Problem determining if a number is an Armstrong Number 
----------------------------------------

int main () {
    int temp, rem, val, max, temp1, count;
    int num;
    val = 0;
    num = 1;
    printf ("What is the maximum limit of Armstrong Number Required: ");
    scanf ("%d", & max);
    printf ("\nSo the list of Armstrong Numbers Before the number %d are: \n", max);
    while (num <= max) {
        count = 0;
        temp1 = num;
        while (temp1 != 0) {
            temp1 = temp1 / 10;
            count++;
        }
        if (count < 3)
            count = 3;
        temp = num;
        val = 0;
        while (temp > 0) {
            rem = temp % 10;
            val = val + pow (rem, count);
            temp = temp / 10;
        }
        if (val == num) {
            printf ("\n%d", num);
        }
        num++;
    }
    return 0;
}
----------------------------------------

int main (void) {
    while (1) {
        int a;
        printf ("Enter the number you want to identify as an Armstrong number or not: ");
        if (scanf ("%d", &a) != 1 || a <= 0)
            break;
        else if (isArmstrongNumber (a))
            printf ("%d is an Armstrong number\n", a);
        else
            printf ("%d is not an Armstrong number\n", a);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6170411_24983794_16_83
6170411_6170520_11_35
Title: Problem determining if a number is an Armstrong Number 
----------------------------------------

int main () {
    int temp, rem, val, max, temp1, count;
    int num;
    val = 0;
    num = 1;
    printf ("What is the maximum limit of Armstrong Number Required: ");
    scanf ("%d", & max);
    printf ("\nSo the list of Armstrong Numbers Before the number %d are: \n", max);
    while (num <= max) {
        count = 0;
        temp1 = num;
        while (temp1 != 0) {
            temp1 = temp1 / 10;
            count++;
        }
        if (count < 3)
            count = 3;
        temp = num;
        val = 0;
        while (temp > 0) {
            rem = temp % 10;
            val = val + pow (rem, count);
            temp = temp / 10;
        }
        if (val == num) {
            printf ("\n%d", num);
        }
        num++;
    }
    return 0;
}
----------------------------------------

int main () {
    int input;
    int digit;
    int sumofdigits = 0;
    printf ("enter the number you want to identify as an Armstrong or not:");
    scanf ("%d", & input);
    int candidate = input;
    int digitcount = numberofdigits (input);
    for (int i = 1; i <= digitcount; i++) {
        digit = candidate % 10;
        sumofdigits = sumofdigits + power (digit, digitcount);
        candidate = candidate / 10;
    }
    if (sumofdigits == input)
        printf ("\n %d is an Armstrong number", input);
    else
        printf ("\n %d is NOT an Armstrong number", input);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6170411_32620432_3_36
6170411_6170511_35_50
Title: Problem determining if a number is an Armstrong Number 
----------------------------------------

void main () {
A :
    int n, n1, rem, ans;
    clrscr ();
    printf ("\nEnter No. :: ");
    scanf ("%d", & n);
    n1 = n;
    ans = 0;
    while (n > 0) {
        rem = n % 10;
        ans = ans + (rem * rem * rem);
        n = n / 10;
    }
    if (n1 == ans) {
        printf ("\n Your Entered No. is Armstrong...");
    }
    else {
        printf ("\n Your Entered No. is not Armstrong...");
    }
    printf ("\n\nPress 0 to Continue...");
    if (getch () == '0') {
        goto A;
    }
    printf ("\n\n\tThank You...");
    getch ();
}
----------------------------------------

int main (void) {
    while (1) {
        int a;
        printf ("Enter the number you want to identify as an Armstrong number or not: ");
        if (scanf ("%d", &a) != 1 || a <= 0)
            break;
        else if (isArmstrongNumber (a))
            printf ("%d is an Armstrong number\n", a);
        else
            printf ("%d is not an Armstrong number\n", a);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6170411_32620432_3_36
6170411_6170520_11_35
Title: Problem determining if a number is an Armstrong Number 
----------------------------------------

void main () {
A :
    int n, n1, rem, ans;
    clrscr ();
    printf ("\nEnter No. :: ");
    scanf ("%d", & n);
    n1 = n;
    ans = 0;
    while (n > 0) {
        rem = n % 10;
        ans = ans + (rem * rem * rem);
        n = n / 10;
    }
    if (n1 == ans) {
        printf ("\n Your Entered No. is Armstrong...");
    }
    else {
        printf ("\n Your Entered No. is not Armstrong...");
    }
    printf ("\n\nPress 0 to Continue...");
    if (getch () == '0') {
        goto A;
    }
    printf ("\n\n\tThank You...");
    getch ();
}
----------------------------------------

int main () {
    int input;
    int digit;
    int sumofdigits = 0;
    printf ("enter the number you want to identify as an Armstrong or not:");
    scanf ("%d", & input);
    int candidate = input;
    int digitcount = numberofdigits (input);
    for (int i = 1; i <= digitcount; i++) {
        digit = candidate % 10;
        sumofdigits = sumofdigits + power (digit, digitcount);
        candidate = candidate / 10;
    }
    if (sumofdigits == input)
        printf ("\n %d is an Armstrong number", input);
    else
        printf ("\n %d is NOT an Armstrong number", input);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6170411_6170511_35_50
6170411_6170520_11_35
Title: Problem determining if a number is an Armstrong Number 
----------------------------------------

int main (void) {
    while (1) {
        int a;
        printf ("Enter the number you want to identify as an Armstrong number or not: ");
        if (scanf ("%d", &a) != 1 || a <= 0)
            break;
        else if (isArmstrongNumber (a))
            printf ("%d is an Armstrong number\n", a);
        else
            printf ("%d is not an Armstrong number\n", a);
    }
    return 0;
}
----------------------------------------

int main () {
    int input;
    int digit;
    int sumofdigits = 0;
    printf ("enter the number you want to identify as an Armstrong or not:");
    scanf ("%d", & input);
    int candidate = input;
    int digitcount = numberofdigits (input);
    for (int i = 1; i <= digitcount; i++) {
        digit = candidate % 10;
        sumofdigits = sumofdigits + power (digit, digitcount);
        candidate = candidate / 10;
    }
    if (sumofdigits == input)
        printf ("\n %d is an Armstrong number", input);
    else
        printf ("\n %d is NOT an Armstrong number", input);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6197408_6197520_1_22
6197408_6211190_16_42
Title: how to add a newly created node to linklist? 
----------------------------------------

struct recordNode *createRecord (char *name, char *event, float time) {
    temp = (struct recordNode *) malloc (sizeof (struct recordNode));
    strcpy (temp -> name, name);
    strcpy (temp -> event, event);
    temp->time = time;
    temp->next = NULL;
    if (aRecordPointer == NULL) {
        aRecordPointer = temp;
    }
    else {
        aRecordPointer->next = temp;
        aRecordPointer = temp;
    }
    return aRecordPointer;
}
----------------------------------------

struct recordNode *createRecord (char *name, char *event, float time) {
    struct recordNode *ToTraverseTheLinkedList;
    temp = (struct recordNode *) malloc (sizeof (struct recordNode));
    strcpy (temp -> name, name);
    strcpy (temp -> event, event);
    temp->time = time;
    temp->next = NULL;
    if (aRecordPointer == NULL) {
        aRecordPointer = temp;
    }
    else {
        ToTraverseTheLinkedList = aRecordPointer;
        while (ToTraverseTheLinkedList->next != NULL) {
            ToTraverseTheLinkedList = ToTraverseTheLinkedList->next;
        }
        ToTraverseTheLinkedList->next = temp;
    }
    return aRecordPointer;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6223216_6223274_11_24
6223216_6223335_15_26
Title: C language and multithread programming 
----------------------------------------

int main () {
    int t1, t2;
    struct th_arg [2];
    int codes [2];
    pthread_create (& t1, NULL, th_work, th_arg + 0, th_arg + 0);
    pthread_create (& t2, NULL, th_work, th_arg + 1, th_arg + 1);
    pthread_join (t1, codes + 0);
    pthread_join (t2, codes + 1);
    if (codes[0] == EXIT_SUCCESS && codes[1] == EXIT_SUCCESS) {
        ...
    }
}
----------------------------------------

int main () {
    pthread_t t1;
    struct arguments my_args;
    my_args.something = 5;
    my_args.anotherArg = "Hello there";
    my_args.stillAnotherArg = 42;
    pthread_create (& t1, NULL, fun, & my_args);
    ...
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6234533_24731095_1_10
6234533_45822589_1_17
Title: How To Find The Leading Number Of Zero's In a Number using C 
----------------------------------------

int clz (unsigned int i) {
    int zeros;
    if ((i & 0xffff) == 0)
        zeros = 16, i >>= 16;
    else
        zeroes = 0;
    if ((i & 0xff) == 0)
        zeros += 8, i >>= 8;
    if ((i & 0xf) == 0)
        zeros += 4, i >>= 4;
    if ((i & 0x3) == 0)
        zeros += 2, i >>= 2;
    if ((i & 0x1) == 0)
        zeros += 1, i >>= 1;
    return zeroes + i;
}
----------------------------------------

unsigned long clz (unsigned long n) {
    unsigned long result = 0;
    unsigned long mask = 0;
    mask = ~mask;
    auto size = sizeof (n) * 8;
    auto shift = size / 2;
    mask >>= shift;
    while (shift >= 1) {
        if (n <= mask) {
            result += shift;
            n <<= shift;
        }
        shift /= 2;
        mask <<= shift;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6243758_6243819_1_11
6243758_6243911_1_11
Title: Strange problem about a function that gets the machine word 
----------------------------------------

unsigned machineword () {
    int i = 1;
    unsigned temp = 1;
    while (temp > 0) {
        i++;
        temp = (unsigned) (((unsigned long long) ~(0U)) >> i);
    }
    return i;
}
----------------------------------------

unsigned machineword () {
    unsigned i = 0;
    unsigned temp = ~0U;
    while (temp > 0) {
        i++;
        temp >>= 1;
    }
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6271603_6271713_6_31
6271603_6271830_5_27
Title: Grab all integers from irregular strings in C 
----------------------------------------

int main (int argc, char **argv) {
    char *input = "pt112par0ah salin10n m5:isstupid::42$%&%^*%7first3";
    int length = strlen (input);
    int value = 0;
    int i;
    bool gotnumber = false;
    for (i = 0; i < length; i++) {
        if (input[i] >= '0' && input[i] <= '9') {
            gotnumber = true;
            value = value * 10;
            value += input[i] - '0';
        }
        else if (gotnumber) {
            printf ("Value: %d \n", value);
            value = 0;
            gotnumber = false;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    const char data [] = "pt112parah salin10n m5:isstupid::42$%&%^*%7first3";
    long results [100];
    int nresult = 0;
    const char *s = data;
    char c;
    while ((c = *s++) != '\0') {
        if (isdigit (c)) {
            char *end;
            results[nresult++] = strtol (s -1, &end, 10);
            s = end;
        }
    }
    for (int i = 0; i < nresult; i++)
        printf ("%d: %ld\n", i, results[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6271603_6271713_6_31
6271603_6271866_5_17
Title: Grab all integers from irregular strings in C 
----------------------------------------

int main (int argc, char **argv) {
    char *input = "pt112par0ah salin10n m5:isstupid::42$%&%^*%7first3";
    int length = strlen (input);
    int value = 0;
    int i;
    bool gotnumber = false;
    for (i = 0; i < length; i++) {
        if (input[i] >= '0' && input[i] <= '9') {
            gotnumber = true;
            value = value * 10;
            value += input[i] - '0';
        }
        else if (gotnumber) {
            printf ("Value: %d \n", value);
            value = 0;
            gotnumber = false;
        }
    }
    return 0;
}
----------------------------------------

int main () {
    char str [] = "pt112parah salin10n m5:isstupid::42$%&%^*%7first3";
    char *pch;
    printf ("Splitting string \"%s\" into tokens:\n", str);
    pch = strtok (str, " abcdefghijklmnopqrstuvwxyz:$%&^*");
    while (pch != NULL) {
        printf ("%s\n", pch);
        pch = strtok (NULL, " abcdefghijklmnopqrstuvwxyz:$%&^*");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6271603_6271713_6_31
6271603_6271868_5_28
Title: Grab all integers from irregular strings in C 
----------------------------------------

int main (int argc, char **argv) {
    char *input = "pt112par0ah salin10n m5:isstupid::42$%&%^*%7first3";
    int length = strlen (input);
    int value = 0;
    int i;
    bool gotnumber = false;
    for (i = 0; i < length; i++) {
        if (input[i] >= '0' && input[i] <= '9') {
            gotnumber = true;
            value = value * 10;
            value += input[i] - '0';
        }
        else if (gotnumber) {
            printf ("Value: %d \n", value);
            value = 0;
            gotnumber = false;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *input = "pt112par0ah salin10n m5:isstupid::42$%&%^*%7first3";
    char *pos = input;
    int integers [strlen (input) / 2];
    unsigned int numInts = 0;
    while ((pos = strpbrk (pos, "0123456789")) != NULL) {
        sscanf (pos, "%u", & (integers [numInts]));
        if (integers[numInts] == 0)
            pos++;
        else
            pos += (int) log10 (integers[numInts]) + 1;
        numInts++;
    }
    for (int i = 0; i < numInts; i++)
        printf ("%d ", integers[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6271603_6271830_5_27
6271603_6271866_5_17
Title: Grab all integers from irregular strings in C 
----------------------------------------

int main (void) {
    const char data [] = "pt112parah salin10n m5:isstupid::42$%&%^*%7first3";
    long results [100];
    int nresult = 0;
    const char *s = data;
    char c;
    while ((c = *s++) != '\0') {
        if (isdigit (c)) {
            char *end;
            results[nresult++] = strtol (s -1, &end, 10);
            s = end;
        }
    }
    for (int i = 0; i < nresult; i++)
        printf ("%d: %ld\n", i, results[i]);
    return 0;
}
----------------------------------------

int main () {
    char str [] = "pt112parah salin10n m5:isstupid::42$%&%^*%7first3";
    char *pch;
    printf ("Splitting string \"%s\" into tokens:\n", str);
    pch = strtok (str, " abcdefghijklmnopqrstuvwxyz:$%&^*");
    while (pch != NULL) {
        printf ("%s\n", pch);
        pch = strtok (NULL, " abcdefghijklmnopqrstuvwxyz:$%&^*");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6271603_6271830_5_27
6271603_6271868_5_28
Title: Grab all integers from irregular strings in C 
----------------------------------------

int main (void) {
    const char data [] = "pt112parah salin10n m5:isstupid::42$%&%^*%7first3";
    long results [100];
    int nresult = 0;
    const char *s = data;
    char c;
    while ((c = *s++) != '\0') {
        if (isdigit (c)) {
            char *end;
            results[nresult++] = strtol (s -1, &end, 10);
            s = end;
        }
    }
    for (int i = 0; i < nresult; i++)
        printf ("%d: %ld\n", i, results[i]);
    return 0;
}
----------------------------------------

int main (void) {
    char *input = "pt112par0ah salin10n m5:isstupid::42$%&%^*%7first3";
    char *pos = input;
    int integers [strlen (input) / 2];
    unsigned int numInts = 0;
    while ((pos = strpbrk (pos, "0123456789")) != NULL) {
        sscanf (pos, "%u", & (integers [numInts]));
        if (integers[numInts] == 0)
            pos++;
        else
            pos += (int) log10 (integers[numInts]) + 1;
        numInts++;
    }
    for (int i = 0; i < numInts; i++)
        printf ("%d ", integers[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6271603_6271866_5_17
6271603_6271868_5_28
Title: Grab all integers from irregular strings in C 
----------------------------------------

int main () {
    char str [] = "pt112parah salin10n m5:isstupid::42$%&%^*%7first3";
    char *pch;
    printf ("Splitting string \"%s\" into tokens:\n", str);
    pch = strtok (str, " abcdefghijklmnopqrstuvwxyz:$%&^*");
    while (pch != NULL) {
        printf ("%s\n", pch);
        pch = strtok (NULL, " abcdefghijklmnopqrstuvwxyz:$%&^*");
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *input = "pt112par0ah salin10n m5:isstupid::42$%&%^*%7first3";
    char *pos = input;
    int integers [strlen (input) / 2];
    unsigned int numInts = 0;
    while ((pos = strpbrk (pos, "0123456789")) != NULL) {
        sscanf (pos, "%u", & (integers [numInts]));
        if (integers[numInts] == 0)
            pos++;
        else
            pos += (int) log10 (integers[numInts]) + 1;
        numInts++;
    }
    for (int i = 0; i < numInts; i++)
        printf ("%d ", integers[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6280224_6280315_1_10
6280224_6281235_1_35
Title: Problem when typecasting a void * pointer used inside a structure to an int * pointer! 
----------------------------------------

int main () {
    struct data *d = (struct data *) malloc (sizeof (struct data));
    int *ptr;
    int key = 10000;
    d->b = &key;
    ptr = (int *) d->b;
    printf ("%d\n", * ptr);
    free (d);
}
----------------------------------------

int main () {
    struct data *d;
    int *ptr;
    d = malloc (sizeof (struct data));
    int key = 10000;
    d->b = &key;
    ptr = (int *) d->b;
    printf ("%d\n", * ptr);
    free (d);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6305052_6307002_3_42
6305052_6307671_6_22
Title: How to read Bios date and time? 
----------------------------------------

void main () {
    char *Day [7] = {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"};
    char *Month [12] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
    char *Suffix [] = {"st", "nd", "rd", "th"};
    int i = 3;
    struct tm *OurT = NULL;
    time_t Tval = 0;
    Tval = time (NULL);
    OurT = localtime (&Tval);
    switch (OurT->tm_mday) {
    case 1 :
    case 21 :
    case 31 :
        i = 0;
        break;
    case 2 :
    case 22 :
        i = 1;
        break;
    case 3 :
    case 23 :
        i = 2;
        break;
    default :
        i = 3;
        break;
    }
    printf ("\nToday is %s the %d%s %s %d", Day [OurT -> tm_wday], OurT -> tm_mday, Suffix [i], Month [OurT -> tm_mon], 1900 + OurT -> tm_year);
    printf ("\nThe time is %d : %d : %d", OurT -> tm_hour, OurT -> tm_min, OurT -> tm_sec);
}
----------------------------------------

void main () {
    long ticks;
    ticks = biostime (0, 0L);
    printf ("Ticks since midnight is %d\n", ticks);
    printf ("The seconds since midnight is %d\n", ticks * 18.2);
    int allSeconds = ticks * 18.2;
    int hours = allSeconds / 3600;
    int minutes = allSeconds / 60 - hours * 60;
    int seconds = allSeconds % 60;
    printf ("The bios time is %02d:%02d:%02d\n", hours, minutes, seconds);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6334514_6335263_2_15
6334514_6338377_1_20
Title: To find largest element smaller than K in a BST 
----------------------------------------

int findNum (Node *tree, int K) {
    int val = K;
    while (tree)
        if (tree->data >= K)
            tree = tree->left;
        else {
            val = tree->data;
            tree = tree->right;
        }
    return val;
}
----------------------------------------

int findNum (Node *node, int K) {
    Node *last_right_move = NULL;
    while (node) {
        if (K <= node->data)
            node = node->left;
        else {
            last_right_move = node;
            node = node->right;
        }
    }
    if (last_right_move)
        return last_right_move->data;
    else
        return NOT_FOUND;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6334514_6335263_2_15
6334514_6842678_1_11
Title: To find largest element smaller than K in a BST 
----------------------------------------

int findNum (Node *tree, int K) {
    int val = K;
    while (tree)
        if (tree->data >= K)
            tree = tree->left;
        else {
            val = tree->data;
            tree = tree->right;
        }
    return val;
}
----------------------------------------

int findNum (node root, int K) {
    if (root == null)
        return -1;
    if (K > root.val) {
        if (root.right != null)
            return findNum (root.right, K);
        else
            return root.val;
    }
    return findNum (root.left, K);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6334514_6338377_1_20
6334514_6842678_1_11
Title: To find largest element smaller than K in a BST 
----------------------------------------

int findNum (Node *node, int K) {
    Node *last_right_move = NULL;
    while (node) {
        if (K <= node->data)
            node = node->left;
        else {
            last_right_move = node;
            node = node->right;
        }
    }
    if (last_right_move)
        return last_right_move->data;
    else
        return NOT_FOUND;
}
----------------------------------------

int findNum (node root, int K) {
    if (root == null)
        return -1;
    if (K > root.val) {
        if (root.right != null)
            return findNum (root.right, K);
        else
            return root.val;
    }
    return findNum (root.left, K);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6338787_6338824_1_17
6338787_6339273_1_13
Title: How to make sure that malloc/free fopen/fclose are matching? 
----------------------------------------

int foo () {
    FILE *fp = fopen ("test.in", "r");
    int i, result;
    result = 0;
    for (i = 0; i < NUM; i++) {
        if (Match (fp, i)) {
            result = i;
            break;
        }
    }
    fclose (fp);
    return result;
}
----------------------------------------

int foo (FILE *fp) {
    int i;
    for (i = 0; i < NUM; i++) {
        if (Match (fp, i)) {
            return i;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6353173_6353208_1_13
6353173_6353258_4_13
Title: Conversion of infinite for loop to finite for loop 
----------------------------------------

int main () {
    int a;
    a = 0;
    for (;;) {
        if (a > 10)
            break;
        printf ("%d", a);
        a ++
    }
    getch ();
}
----------------------------------------

int main () {
    int a = 0;
    for (;;)
        if ((++a) <= 10)
            printf ("%d", a);
        else
            break;
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6353173_6353208_1_13
6353173_6353441_3_21
Title: Conversion of infinite for loop to finite for loop 
----------------------------------------

int main () {
    int a;
    a = 0;
    for (;;) {
        if (a > 10)
            break;
        printf ("%d", a);
        a ++
    }
    getch ();
}
----------------------------------------

int main () {
    int a;
    a = 1;
m :
    for (;;) {
        if (a <= 10) {
            printf ("%d\n", a);
            a++;
        }
        if (a < 10) {
            goto m;
        }
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6353173_6353258_4_13
6353173_6353441_3_21
Title: Conversion of infinite for loop to finite for loop 
----------------------------------------

int main () {
    int a = 0;
    for (;;)
        if ((++a) <= 10)
            printf ("%d", a);
        else
            break;
    getch ();
}
----------------------------------------

int main () {
    int a;
    a = 1;
m :
    for (;;) {
        if (a <= 10) {
            printf ("%d\n", a);
            a++;
        }
        if (a < 10) {
            goto m;
        }
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6357031_11667128_9_30
6357031_26337692_1_34
Title: How do you convert a byte array to a hexadecimal string in C? 
----------------------------------------

main (int argc, char *argv []) {
    char *str = malloc (50);
    char *tmp;
    char *tmp2;
    int i = 0;
    while (i < (argc - 1)) {
        tmp = hex_str[*(argv[i]) & l_word];
        tmp2 = hex_str[*(argv[i]) & u_word];
        if (i == 0) {
            memcpy (str, tmp2, 1);
            strcat (str, tmp);
        }
        else {
            strcat (str, tmp2);
            strcat (str, tmp);
        }
        i++;
    }
    printf ("\n*********  %s  *************** \n", str);
}
----------------------------------------

main () {
    int value = 16;
    char hex [] = {0, 0, '\0'};
    char *hex_p = hex;
    int TEMP_int = 0;
    TEMP_int = value / 16;
    if (TEMP_int < 10) {
        *hex_p = 48 + TEMP_int;
    }
    else {
        *hex_p = 55 + TEMP_int;
    }
    hex_p++;
    TEMP_int = value % 16;
    if (TEMP_int < 10) {
        *hex_p = 48 + TEMP_int;
    }
    else {
        *hex_p = 55 + TEMP_int;
    }
    printf ("%i , 0x%s", value, hex);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63776_5036813_6_19
63776_74332_4_21
Title: "Bit reversal of an integer ignoring integer size and endianness" 
----------------------------------------

foo_t reverse (foo_t x) {
    int shift = sizeof (x) * CHAR_BIT / 2;
    foo_t mask = (1 << shift) - 1;
    int i;
    for (i = 0; shift; i++) {
        x = ((x & mask) << shift) | ((x & ~mask) >> shift);
        shift >>= 1;
        mask ^= (mask << shift);
    }
    return x;
}
----------------------------------------

TYPE reverse (TYPE x, int bits) {
    TYPE m = ~0;
    switch (bits) {
    case 64 :
        x = (x & 0xFFFFFFFF00000000 & m) >> 16 | (x & 0x00000000FFFFFFFF & m) << 16;
    case 32 :
        x = (x & 0xFFFF0000FFFF0000 & m) >> 16 | (x & 0x0000FFFF0000FFFF & m) << 16;
    case 16 :
        x = (x & 0xFF00FF00FF00FF00 & m) >> 8 | (x & 0x00FF00FF00FF00FF & m) << 8;
    case 8 :
        x = (x & 0xF0F0F0F0F0F0F0F0 & m) >> 4 | (x & 0x0F0F0F0F0F0F0F0F & m) << 4;
        x = (x & 0xCCCCCCCCCCCCCCCC & m) >> 2 | (x & 0x3333333333333333 & m) << 2;
        x = (x & 0xAAAAAAAAAAAAAAAA & m) >> 1 | (x & 0x5555555555555555 & m) << 1;
    }
    return x;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63776_64626_3_25
63776_74332_23_40
Title: "Bit reversal of an integer ignoring integer size and endianness" 
----------------------------------------

int main (int argc, char **argv) {
    int32_t x;
    if (argc != 2) {
        printf ("Usage: %s hexadecimal\n", argv [0]);
        return 1;
    }
    sscanf (argv [1], "%x", & x);
    x = (x & 0xAAAAAAAA) >> 1 | (x & 0x55555555) << 1;
    x = (x & 0xCCCCCCCC) >> 2 | (x & 0x33333333) << 2;
    x = (x & 0xF0F0F0F0) >> 4 | (x & 0x0F0F0F0F) << 4;
    x = (x & 0xFF00FF00) >> 8 | (x & 0x00FF00FF) << 8;
    x = (x & 0xFFFF0000) >> 16 | (x & 0x0000FFFF) << 16;
    printf ("0x%x\n", x);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    TYPE x;
    TYPE b = (TYPE) -1;
    int bits;
    if (argc != 2) {
        printf ("Usage: %s hexadecimal\n", argv [0]);
        return 1;
    }
    for (bits = 1; b; b <<= 1, bits++)
        ;
    --bits;
    printf ("TYPE has %d bits\n", bits);
    sscanf (argv [1], "%x", & x);
    printf ("0x%x\n", reverse (x, bits));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63776_64949_3_36
63776_70906_8_32
Title: "Bit reversal of an integer ignoring integer size and endianness" 
----------------------------------------

TYPE reverser (TYPE n) {
    TYPE k = 1, nrev = 0, i, nrevbit1, nrevbit2;
    int count;
    for (i = 0; !i || (1 << i && (1 << i) != 1); i += 2) {
        k = 1 << i;
        count = 0;
        while (k << 1 && k << 1 != 1) {
            k <<= 1;
            count++;
        }
        nrevbit1 = n & (1 << (i / 2));
        nrevbit1 <<= count;
        nrevbit2 = n & 1 << ((i / 2) + count);
        nrevbit2 >>= count;
        nrev |= nrevbit1;
        nrev |= nrevbit2;
    }
    return nrev;
}
----------------------------------------

TYPE reverser (TYPE n) {
    TYPE nrev = 0, i, bit1, bit2;
    int count;
    for (i = 0; i < TYPE_BITS; i += 2) {
        count = TYPE_BITS - i - 1;
        bit1 = n & (1 << (i / 2));
        bit1 <<= count;
        bit2 = n & 1 << ((i / 2) + count);
        bit2 >>= count;
        nrev |= bit1;
        nrev |= bit2;
    }
    return nrev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6418232_18574495_5_43
6418232_6419762_4_12
Title: How to use select() to read input from keyboard in C 
----------------------------------------

int main (int argc, char *argv []) {
    fd_set rfds;
    struct timeval tv;
    int retval, len;
    char buff [255] = {0};
    FD_ZERO (& rfds);
    FD_SET (0, & rfds);
    tv.tv_sec = 5;
    tv.tv_usec = 0;
    retval = select (1, &rfds, NULL, NULL, &tv);
    if (retval == -1) {
        perror ("select()");
        exit (EXIT_FAILURE);
    }
    else if (retval) {
        fgets (buff, sizeof (buff), stdin);
        len = strlen (buff) - 1;
        if (buff[len] == '\n')
            buff[len] = '\0';
        printf ("'%s' was read from stdin.\n", buff);
    }
    else
        printf ("No data within five seconds.\n");
    exit (EXIT_SUCCESS);
}
----------------------------------------

int main (void) {
    fd_set s_rd, s_wr, s_ex;
    FD_ZERO (& s_rd);
    FD_ZERO (& s_wr);
    FD_ZERO (& s_ex);
    FD_SET (fileno (stdin), & s_rd);
    select (fileno (stdin) + 1, & s_rd, & s_wr, & s_ex, NULL);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6418807_20758666_4_23
6418807_33469695_5_21
Title: How to work with complex numbers in C? 
----------------------------------------

int main () {
    int negNum;
    printf ("Calculate negative square roots:\n" "Enter negative number:");
    scanf ("%d", & negNum);
    double complex negSqrt = csqrt (negNum);
    double pReal = creal (negSqrt);
    double pImag = cimag (negSqrt);
    printf ("\nReal part %f, imaginary part %f" ", for negative square root.(%d)", pReal, pImag, negNum);
    return 0;
}
----------------------------------------

int main (void) {
    double complex z1 = 1./ 4.* M_PI + 1./ 4.* M_PI * I;
    double complex z2, z3, z4, z5;
    z2 = exp (z1);
    z3 = sin (z1);
    z4 = sqrt (z1);
    z5 = log (z1);
    printf ("exp(z1)=%lf + %lf I\n", creal (z2), cimag (z2));
    printf ("sin(z1)=%lf + %lf I\n", creal (z3), cimag (z3));
    printf ("sqrt(z1)=%lf + %lf I\n", creal (z4), cimag (z4));
    printf ("log(z1)=%lf + %lf I\n", creal (z5), cimag (z5));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6418807_20758666_4_23
6418807_9860772_4_29
Title: How to work with complex numbers in C? 
----------------------------------------

int main () {
    int negNum;
    printf ("Calculate negative square roots:\n" "Enter negative number:");
    scanf ("%d", & negNum);
    double complex negSqrt = csqrt (negNum);
    double pReal = creal (negSqrt);
    double pImag = cimag (negSqrt);
    printf ("\nReal part %f, imaginary part %f" ", for negative square root.(%d)", pReal, pImag, negNum);
    return 0;
}
----------------------------------------

int main () {
    double complex z1 = 1.0 + 3.0 * I;
    double complex z2 = 1.0 - 4.0 * I;
    printf ("Working with complex numbers:\n\v");
    printf ("Starting values: Z1 = %.2f + %.2fi\tZ2 = %.2f %+.2fi\n", creal (z1), cimag (z1), creal (z2), cimag (z2));
    double complex sum = z1 + z2;
    printf ("The sum: Z1 + Z2 = %.2f %+.2fi\n", creal (sum), cimag (sum));
    double complex difference = z1 - z2;
    printf ("The difference: Z1 - Z2 = %.2f %+.2fi\n", creal (difference), cimag (difference));
    double complex product = z1 * z2;
    printf ("The product: Z1 x Z2 = %.2f %+.2fi\n", creal (product), cimag (product));
    double complex quotient = z1 / z2;
    printf ("The quotient: Z1 / Z2 = %.2f %+.2fi\n", creal (quotient), cimag (quotient));
    double complex conjugate = conj (z1);
    printf ("The conjugate of Z1 = %.2f %+.2fi\n", creal (conjugate), cimag (conjugate));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6418807_33469695_5_21
6418807_9860772_4_29
Title: How to work with complex numbers in C? 
----------------------------------------

int main (void) {
    double complex z1 = 1./ 4.* M_PI + 1./ 4.* M_PI * I;
    double complex z2, z3, z4, z5;
    z2 = exp (z1);
    z3 = sin (z1);
    z4 = sqrt (z1);
    z5 = log (z1);
    printf ("exp(z1)=%lf + %lf I\n", creal (z2), cimag (z2));
    printf ("sin(z1)=%lf + %lf I\n", creal (z3), cimag (z3));
    printf ("sqrt(z1)=%lf + %lf I\n", creal (z4), cimag (z4));
    printf ("log(z1)=%lf + %lf I\n", creal (z5), cimag (z5));
    return 0;
}
----------------------------------------

int main () {
    double complex z1 = 1.0 + 3.0 * I;
    double complex z2 = 1.0 - 4.0 * I;
    printf ("Working with complex numbers:\n\v");
    printf ("Starting values: Z1 = %.2f + %.2fi\tZ2 = %.2f %+.2fi\n", creal (z1), cimag (z1), creal (z2), cimag (z2));
    double complex sum = z1 + z2;
    printf ("The sum: Z1 + Z2 = %.2f %+.2fi\n", creal (sum), cimag (sum));
    double complex difference = z1 - z2;
    printf ("The difference: Z1 - Z2 = %.2f %+.2fi\n", creal (difference), cimag (difference));
    double complex product = z1 * z2;
    printf ("The product: Z1 x Z2 = %.2f %+.2fi\n", creal (product), cimag (product));
    double complex quotient = z1 / z2;
    printf ("The quotient: Z1 / Z2 = %.2f %+.2fi\n", creal (quotient), cimag (quotient));
    double complex conjugate = conj (z1);
    printf ("The conjugate of Z1 = %.2f %+.2fi\n", creal (conjugate), cimag (conjugate));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6464073_6464268_5_18
6464073_6464325_7_23
Title: Is there any alternative API for getcwd to get the working direcory of process 
----------------------------------------

int main (int argc, char *argv []) {
    char buf [PATH_MAX];
    ssize_t r = readlink ("/proc/self/cwd", buf, sizeof (buf));
    if (r < 0) {
        perror ("readlink /proc/self/cwd failed");
        return 1;
    }
    else {
        buf[PATH_MAX - 1] = '\0';
        printf ("/proc/self/cwd reports: %s\n", buf);
    }
    return 0;
}
----------------------------------------

int main () {
    char path [256];
    char buf [BUFSIZ];
    mkdir ("/tmp/foo", 0755);
    chdir ("/tmp/foo");
    rmdir ("/tmp/foo");
    sprintf (path, "/proc/%d/cwd", getpid ());
    if (readlink (path, buf, sizeof (buf)) != -1) {
        char *stop = buf + strlen (buf) - 10;
        if (!strcmp (stop, " (deleted)")) {
            *stop = 0;
        }
        printf ("[%s]\n", buf);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6478895_6478980_13_34
6478895_6479228_44_63
Title: Efficient way to translate a char* to an enum value 
----------------------------------------

int main (void) {
    char tmp [10];
    printf ("Enter day of the week: ");
    fflush (stdout);
    if (fgets (tmp, sizeof tmp, stdin)) {
        enum Weekdays enumvalue = tmp[0] + tmp[1] + tmp[2];
        switch (enumvalue) {
        default :
            printf ("Ohoh\n");
            break;
        case Sun :
            printf ("Sun: %d\n", Sun);
            break;
        case Mon :
            printf ("Mon: %d\n", Mon);
            break;
        case Tue :
            printf ("Tue: %d\n", Tue);
            break;
        case Wed :
            printf ("Wed: %d\n", Wed);
            break;
        case Thu :
            printf ("Thu: %d\n", Thu);
            break;
        case Fri :
            printf ("Fri: %d\n", Fri);
            break;
        case Sat :
            printf ("Sat: %d\n", Sat);
            break;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *map [N];
    int count;
    map_add (map, & count, "Monday");
    map_add (map, & count, "Tuesday");
    map_add (map, & count, "Thursday");
    map_add (map, & count, "Wednesday");
    map_add (map, & count, "Friday");
    map_add (map, & count, "Sunday");
    map_add (map, & count, "Saturday");
    for (int i = 0; i < count; ++i)
        printf ("[%d] = %s\n", i, map_int_to_string (map, count, i));
    printf ("Monday is %d\n", map_string_to_int (map, count, "Monday"));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6485174_6485251_43_61
6485174_6485387_43_51
Title: "Interview Question... Trying to work it out but couldn't get an efficient solution" 
----------------------------------------

int main () {
    cin >> n;
    a.resize (n);
    b.resize (n);
    c.resize (n);
    int i;
    for (i = 0; i < n; ++i)
        cin >> a[i];
    for (i = 0; i < n; ++i)
        cin >> b[i];
    if (!solve ())
        cout << "Impossible";
    else
        for (i = 0; i < n; ++i)
            cout << c[i] << ' ';
    cout << endl;
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    if (!doit (a, b, c, sizeof (a) / sizeof (int))) {
        printf ("no solution");
    }
    else {
        for (size_t i = 0; i < sizeof (a) / sizeof (int); ++i)
            printf ("c[%zu] = %d\n", i, c[i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6485174_6485251_43_61
6485174_6486096_5_84
Title: "Interview Question... Trying to work it out but couldn't get an efficient solution" 
----------------------------------------

int main () {
    cin >> n;
    a.resize (n);
    b.resize (n);
    c.resize (n);
    int i;
    for (i = 0; i < n; ++i)
        cin >> a[i];
    for (i = 0; i < n; ++i)
        cin >> b[i];
    if (!solve ())
        cout << "Impossible";
    else
        for (i = 0; i < n; ++i)
            cout << c[i] << ' ';
    cout << endl;
    return 0;
}
----------------------------------------

int main () {
    int a [] = {1, 2, 3};
    int b [] = {1, -1, -1};
    int c [] = {EMPTY, EMPTY, EMPTY};
    int n = sizeof (a) / sizeof (int);
    int l = 0, r = n - 1;
    int i, j;
    for (i = 0, j = n - 1; i < n; ++i, --j) {
        if (b[i] == 0) {
            c[i] = a[i];
            while (l <= i && c[l] != EMPTY)
                ++l;
        }
        else if (b[i] == -1) {
            if (i <= l)
                break;
            c[l] = a[i];
            do
                ++l;
            while (l <= i && c[l] != EMPTY);
        }
        if (b[j] == 0) {
            c[j] = a[j];
            while (r >= j && c[r] != EMPTY)
                --r;
        }
        else if (b[j] == 1) {
            if (j >= r)
                break;
            c[r] = a[j];
            do
                --r;
            while (r >= j && c[r] != EMPTY);
        }
        if (l > r) {
            l = n;
            r = -1;
        }
    }
    if (i < n)
        printf ("Unsolvable");
    else {
        for (i = 0; i < n; ++i)
            printf ("%d ", c[i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------
