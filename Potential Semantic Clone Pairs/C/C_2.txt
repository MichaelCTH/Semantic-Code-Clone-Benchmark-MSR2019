$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12461808_12461872_1_35
12461808_12461883_1_12
Title: Printing the Child Number After Fork() 
----------------------------------------

int main () {
    int i;
    printf ("hello before fork \n");
    printf ("i : %d\n", i);
    i = fork ();
    printf ("\n");
    if (i == 0) {
        printf ("Child has started\n\n");
        printf ("child printing first time \n");
        printf ("getpid : %d getppid : %d \n", getpid (), getppid ());
        sleep (5);
        printf ("\nchild printing second time \n");
        printf ("getpid : %d getppid : %d \n", getpid (), getppid ());
    }
    else {
        printf ("parent has started\n");
        printf ("getpid : %d  getppid : %d \n", getpid (), getppid ());
        printf ("\n");
    }
    printf ("Hi after fork i : %d\n", i);
    return 0;
}
----------------------------------------

int main () {
    pid_t pid;
    int i = 1;
    pid = fork ();
    pid = fork ();
    pid = fork ();
    pid = fork ();
    if (pid == 0) {
        printf ("the child %d, got %d\n", getpid (), i);
        i++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12480168_12480466_1_13
12480168_12484372_5_20
Title: How do you verify user input in C? 
----------------------------------------

int main (void) {
    float input;
    if (scanf ("%f", &input) == 1) {
        printf ("OK, I could read your float: %f.\n", input);
    }
    else {
        printf ("Not OK, I couldn't read your float.\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    char line [100];
    char *err;
    int intval;
    printf ("Enter a number:\n");
    fgets (line, sizeof line, stdin);
    errno = 0;
    intval = strtol (line, &err, 10);
    if (errno)
        ;
    if (*err != '\n')
        ;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12486011_12487193_5_58
12486011_12487595_16_29
Title: Calculating expression with multiple fork() children? 
----------------------------------------

int main () {
    int a = 1;
    int b = 2;
    int c = 3;
    int d = 4;
    int e = 15;
    int f = 6;
    int a_plus_b_pid;
    int c_plus_d_pid;
    int e_div_f_pid;
    int a_plus_b;
    int c_plus_d;
    int e_div_f;
    a_plus_b_pid = fork ();
    if (a_plus_b_pid) {
        c_plus_d_pid = fork ();
        if (c_plus_d_pid) {
            e_div_f_pid = fork ();
            if (e_div_f_pid) {
                waitpid (a_plus_b_pid, & a_plus_b, 0);
                waitpid (c_plus_d_pid, & c_plus_d, 0);
                waitpid (e_div_f_pid, & e_div_f, 0);
                a_plus_b >>= 8;
                c_plus_d >>= 8;
                e_div_f >>= 8;
                printf ("%d %d %d %d\n", a_plus_b, c_plus_d, e_div_f, a_plus_b * c_plus_d - e_div_f);
            }
            else {
                exit (e / f);
            }
        }
        else {
            exit (c + d);
        }
    }
    else {
        exit (a + b);
    }
}
----------------------------------------

int main () {
    pthread_t ab_thread, cd_thread, ef_thread;
    pthread_create (& ab_thread, NULL, calc_ab, NULL);
    pthread_create (& cd_thread, NULL, calc_cd, NULL);
    pthread_create (& ef_thread, NULL, calc_ef, NULL);
    pthread_join (ab_thread, NULL);
    pthread_join (cd_thread, NULL);
    pthread_join (ef_thread, NULL);
    int result = a_b * c_d - e_f;
    printf ("Result is %d\n", result);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12486011_12487193_5_58
12486011_12498199_19_95
Title: Calculating expression with multiple fork() children? 
----------------------------------------

int main () {
    int a = 1;
    int b = 2;
    int c = 3;
    int d = 4;
    int e = 15;
    int f = 6;
    int a_plus_b_pid;
    int c_plus_d_pid;
    int e_div_f_pid;
    int a_plus_b;
    int c_plus_d;
    int e_div_f;
    a_plus_b_pid = fork ();
    if (a_plus_b_pid) {
        c_plus_d_pid = fork ();
        if (c_plus_d_pid) {
            e_div_f_pid = fork ();
            if (e_div_f_pid) {
                waitpid (a_plus_b_pid, & a_plus_b, 0);
                waitpid (c_plus_d_pid, & c_plus_d, 0);
                waitpid (e_div_f_pid, & e_div_f, 0);
                a_plus_b >>= 8;
                c_plus_d >>= 8;
                e_div_f >>= 8;
                printf ("%d %d %d %d\n", a_plus_b, c_plus_d, e_div_f, a_plus_b * c_plus_d - e_div_f);
            }
            else {
                exit (e / f);
            }
        }
        else {
            exit (c + d);
        }
    }
    else {
        exit (a + b);
    }
}
----------------------------------------

int main () {
    int shmid = shmget (key, sizeof (struct shared), 0666 | IPC_CREAT);
    if (shmid == -1)
        exit (EXIT_FAILURE);
    pab = fork ();
    if (pab == 0) {
        shared_mem = shmat (shmid, (void *) 0, 0);
        if (shared_mem == (void *) -1)
            exit (EXIT_FAILURE);
        struct shared *shared_data = (struct shared *) shared_mem;
        shared_data->a_b = a + b;
        if (shmdt (shared_mem) == -1)
            exit (EXIT_FAILURE);
        exit (EXIT_SUCCESS);
    }
    else {
        pcd = fork ();
        if (pcd == 0) {
            shared_mem = shmat (shmid, (void *) 0, 0);
            if (shared_mem == (void *) -1)
                exit (EXIT_FAILURE);
            struct shared *shared_data = (struct shared *) shared_mem;
            shared_data->c_d = c + d;
            if (shmdt (shared_mem) == -1)
                exit (EXIT_FAILURE);
            exit (EXIT_SUCCESS);
        }
        else {
            pef = fork ();
            if (pef == 0) {
                shared_mem = shmat (shmid, (void *) 0, 0);
                if (shared_mem == (void *) -1)
                    exit (EXIT_FAILURE);
                struct shared *shared_data = (struct shared *) shared_mem;
                shared_data->e_f = e / f;
                if (shmdt (shared_mem) == -1)
                    exit (EXIT_FAILURE);
                exit (EXIT_SUCCESS);
            }
        }
    }
    int status_ab, status_cd, status_ef;
    waitpid (pab, & status_ab, 0);
    waitpid (pcd, & status_cd, 0);
    waitpid (pef, & status_ef, 0);
    if (!WIFEXITED (status_ab) || !WIFEXITED (status_cd) || !WIFEXITED (status_ef)) {
        exit (EXIT_FAILURE);
    }
    shared_mem = shmat (shmid, (void *) 0, 0);
    if (shared_mem == (void *) -1)
        exit (EXIT_FAILURE);
    struct shared *shared_data = (struct shared *) shared_mem;
    int result = (shared_data->a_b) * (shared_data->c_d) - (shared_data->e_f);
    printf ("Result is %d\n", result);
    if (shmdt (shared_mem) == -1)
        exit (EXIT_FAILURE);
    if (shmctl (shmid, IPC_RMID, 0) == -1)
        exit (EXIT_FAILURE);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12486011_12487595_16_29
12486011_12498199_19_95
Title: Calculating expression with multiple fork() children? 
----------------------------------------

int main () {
    pthread_t ab_thread, cd_thread, ef_thread;
    pthread_create (& ab_thread, NULL, calc_ab, NULL);
    pthread_create (& cd_thread, NULL, calc_cd, NULL);
    pthread_create (& ef_thread, NULL, calc_ef, NULL);
    pthread_join (ab_thread, NULL);
    pthread_join (cd_thread, NULL);
    pthread_join (ef_thread, NULL);
    int result = a_b * c_d - e_f;
    printf ("Result is %d\n", result);
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    int shmid = shmget (key, sizeof (struct shared), 0666 | IPC_CREAT);
    if (shmid == -1)
        exit (EXIT_FAILURE);
    pab = fork ();
    if (pab == 0) {
        shared_mem = shmat (shmid, (void *) 0, 0);
        if (shared_mem == (void *) -1)
            exit (EXIT_FAILURE);
        struct shared *shared_data = (struct shared *) shared_mem;
        shared_data->a_b = a + b;
        if (shmdt (shared_mem) == -1)
            exit (EXIT_FAILURE);
        exit (EXIT_SUCCESS);
    }
    else {
        pcd = fork ();
        if (pcd == 0) {
            shared_mem = shmat (shmid, (void *) 0, 0);
            if (shared_mem == (void *) -1)
                exit (EXIT_FAILURE);
            struct shared *shared_data = (struct shared *) shared_mem;
            shared_data->c_d = c + d;
            if (shmdt (shared_mem) == -1)
                exit (EXIT_FAILURE);
            exit (EXIT_SUCCESS);
        }
        else {
            pef = fork ();
            if (pef == 0) {
                shared_mem = shmat (shmid, (void *) 0, 0);
                if (shared_mem == (void *) -1)
                    exit (EXIT_FAILURE);
                struct shared *shared_data = (struct shared *) shared_mem;
                shared_data->e_f = e / f;
                if (shmdt (shared_mem) == -1)
                    exit (EXIT_FAILURE);
                exit (EXIT_SUCCESS);
            }
        }
    }
    int status_ab, status_cd, status_ef;
    waitpid (pab, & status_ab, 0);
    waitpid (pcd, & status_cd, 0);
    waitpid (pef, & status_ef, 0);
    if (!WIFEXITED (status_ab) || !WIFEXITED (status_cd) || !WIFEXITED (status_ef)) {
        exit (EXIT_FAILURE);
    }
    shared_mem = shmat (shmid, (void *) 0, 0);
    if (shared_mem == (void *) -1)
        exit (EXIT_FAILURE);
    struct shared *shared_data = (struct shared *) shared_mem;
    int result = (shared_data->a_b) * (shared_data->c_d) - (shared_data->e_f);
    printf ("Result is %d\n", result);
    if (shmdt (shared_mem) == -1)
        exit (EXIT_FAILURE);
    if (shmctl (shmid, IPC_RMID, 0) == -1)
        exit (EXIT_FAILURE);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12489_12506_6_23
12489_47539331_27_39
Title: How do you get a directory listing in C? 
----------------------------------------

int main (void) {
    DIR *dp;
    struct dirent *ep;
    dp = opendir ("./");
    if (dp != NULL) {
        while (ep = readdir (dp))
            puts (ep->d_name);
        (void) closedir (dp);
    }
    else
        perror ("Couldn't open the directory");
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int counter = 1;
    if (argc == 1)
        listdir (".");
    while (++counter <= argc) {
        printf ("\nListing %s...\n", argv [counter - 1]);
        listdir (argv [counter - 1]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12499745_12500089_7_47
12499745_23860740_24_100
Title: Pass the value from child to parent process 
----------------------------------------

int main (int argc, char *argv []) {
    int pipefd [2];
    pid_t cpid;
    char buf;
    if (argc != 2) {
        fprintf (stderr, "Usage: %s <string>\n", argv [0]);
        exit (EXIT_FAILURE);
    }
    if (pipe (pipefd) == -1) {
        perror ("pipe");
        exit (EXIT_FAILURE);
    }
    cpid = fork ();
    if (cpid == -1) {
        perror ("fork");
        exit (EXIT_FAILURE);
    }
    if (cpid == 0) {
        close (pipefd [1]);
        while (read (pipefd[0], &buf, 1) > 0)
            write (STDOUT_FILENO, &buf, 1);
        write (STDOUT_FILENO, "\n", 1);
        close (pipefd [0]);
        _exit (EXIT_SUCCESS);
    }
    else {
        close (pipefd [0]);
        write (pipefd [1], argv [1], strlen (argv [1]));
        close (pipefd [1]);
        wait (NULL);
        exit (EXIT_SUCCESS);
    }
}
----------------------------------------

int main (int argc, char *argv []) {
    pid_t childPID;
    int status;
    int shm_fd;
    int *shared_memory;
    int msize;
    const char *name = "FIBONACCI_SERIES";
    int n;
    if (argc != 2) {
        fprintf (stderr, "usage: %s <Fibonacci number to be generated>\n", argv [0]);
        return -1;
    }
    n = atoi (argv[1]);
    if (n < 0) {
        fprintf (stderr, "Illegal fibonacci number: %s\n", argv [1]);
        return -2;
    }
    msize = (n + 2) * sizeof (int);
    shm_fd = shm_open (name, O_CREAT | O_EXCL | O_RDWR, S_IRWXU | S_IRWXG);
    if (shm_fd < 0) {
        fprintf (stderr, "Error in shm_open()");
        return -3;
    }
    printf ("Created shared memory object %s\n", name);
    ftruncate (shm_fd, msize);
    printf ("shmat returned\n");
    shared_memory = (int *) mmap (NULL, msize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_memory == NULL) {
        fprintf (stderr, "Error in mmap()");
        return -3;
    }
    printf ("Shared memory segment allocated correctly (%d bytes).\n", msize);
    shared_memory[0] = n;
    childPID = fork ();
    if (childPID == -1) {
        fprintf (stderr, "Cannot proceed. fork() error");
        return -4;
    }
    if (childPID == 0) {
        computeFibo (shared_memory [0], shared_memory + 1);
        exit (0);
    }
    else {
        wait (& status);
        printFibo (shared_memory [0], shared_memory + 1);
        shm_unlink (name);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12499745_12500089_7_47
12499745_38022272_6_21
Title: Pass the value from child to parent process 
----------------------------------------

int main (int argc, char *argv []) {
    int pipefd [2];
    pid_t cpid;
    char buf;
    if (argc != 2) {
        fprintf (stderr, "Usage: %s <string>\n", argv [0]);
        exit (EXIT_FAILURE);
    }
    if (pipe (pipefd) == -1) {
        perror ("pipe");
        exit (EXIT_FAILURE);
    }
    cpid = fork ();
    if (cpid == -1) {
        perror ("fork");
        exit (EXIT_FAILURE);
    }
    if (cpid == 0) {
        close (pipefd [1]);
        while (read (pipefd[0], &buf, 1) > 0)
            write (STDOUT_FILENO, &buf, 1);
        write (STDOUT_FILENO, "\n", 1);
        close (pipefd [0]);
        _exit (EXIT_SUCCESS);
    }
    else {
        close (pipefd [0]);
        write (pipefd [1], argv [1], strlen (argv [1]));
        close (pipefd [1]);
        wait (NULL);
        exit (EXIT_SUCCESS);
    }
}
----------------------------------------

int main (int argc, char *argv []) {
    pid_t pid = fork ();
    if (pid == 0) {
        int sum = 5 + 7;
        exit (sum);
    }
    else {
        int childval = -1;
        wait (& childval);
        printf ("%d", childval / 255);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12499745_23860740_24_100
12499745_38022272_6_21
Title: Pass the value from child to parent process 
----------------------------------------

int main (int argc, char *argv []) {
    pid_t childPID;
    int status;
    int shm_fd;
    int *shared_memory;
    int msize;
    const char *name = "FIBONACCI_SERIES";
    int n;
    if (argc != 2) {
        fprintf (stderr, "usage: %s <Fibonacci number to be generated>\n", argv [0]);
        return -1;
    }
    n = atoi (argv[1]);
    if (n < 0) {
        fprintf (stderr, "Illegal fibonacci number: %s\n", argv [1]);
        return -2;
    }
    msize = (n + 2) * sizeof (int);
    shm_fd = shm_open (name, O_CREAT | O_EXCL | O_RDWR, S_IRWXU | S_IRWXG);
    if (shm_fd < 0) {
        fprintf (stderr, "Error in shm_open()");
        return -3;
    }
    printf ("Created shared memory object %s\n", name);
    ftruncate (shm_fd, msize);
    printf ("shmat returned\n");
    shared_memory = (int *) mmap (NULL, msize, PROT_READ | PROT_WRITE, MAP_SHARED, shm_fd, 0);
    if (shared_memory == NULL) {
        fprintf (stderr, "Error in mmap()");
        return -3;
    }
    printf ("Shared memory segment allocated correctly (%d bytes).\n", msize);
    shared_memory[0] = n;
    childPID = fork ();
    if (childPID == -1) {
        fprintf (stderr, "Cannot proceed. fork() error");
        return -4;
    }
    if (childPID == 0) {
        computeFibo (shared_memory [0], shared_memory + 1);
        exit (0);
    }
    else {
        wait (& status);
        printFibo (shared_memory [0], shared_memory + 1);
        shm_unlink (name);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    pid_t pid = fork ();
    if (pid == 0) {
        int sum = 5 + 7;
        exit (sum);
    }
    else {
        int childval = -1;
        wait (& childval);
        printf ("%d", childval / 255);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12512184_12512242_9_18
12512184_12512280_16_29
Title: Wrong result when copying an array of strings 
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    for (i = 0; i < argc && i < 256; i += 2) {
        user[i] = strdup (argv[i]);
        passwd[i] = strdup (argv[i + 1]);
    }
    test (argc);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    nr = argc;
    user = malloc (argc * sizeof (char *));
    for (i = 0; i < argc; i++) {
        user[i] = strdup (argv[i]);
    }
    test (argc);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12528267_12528315_1_11
12528267_12528364_12_22
Title: how can i know that a stack is empty if i use this method to pop elements? 
----------------------------------------

int pop (Node **top, int *value) {
    if (*top == NULL) {
        printf ("Error: Stack is empty!\n");
        return 0;
    }
    *value = (*top)->iData;
    *top = (*top)->next;
    return 1;
}
----------------------------------------

int pop (Node **top) {
    if (*top == NULL) {
        printf ("Error: Stack is empty!\n");
        return;
    }
    int temp = (*top)->iData;
    *top = (*top)->next;
    return temp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12528267_12528315_1_11
12528267_12528396_9_22
Title: how can i know that a stack is empty if i use this method to pop elements? 
----------------------------------------

int pop (Node **top, int *value) {
    if (*top == NULL) {
        printf ("Error: Stack is empty!\n");
        return 0;
    }
    *value = (*top)->iData;
    *top = (*top)->next;
    return 1;
}
----------------------------------------

int pop (Node **top) {
    if (*top == NULL) {
        printf ("Error: Stack is empty!\n");
        return 0;
    }
    Node *tmp = *top;
    int temp = tmp->iData;
    *top = tmp->next;
    free (tmp);
    return temp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12528267_12528364_12_22
12528267_12528396_9_22
Title: how can i know that a stack is empty if i use this method to pop elements? 
----------------------------------------

int pop (Node **top) {
    if (*top == NULL) {
        printf ("Error: Stack is empty!\n");
        return;
    }
    int temp = (*top)->iData;
    *top = (*top)->next;
    return temp;
}
----------------------------------------

int pop (Node **top) {
    if (*top == NULL) {
        printf ("Error: Stack is empty!\n");
        return 0;
    }
    Node *tmp = *top;
    int temp = tmp->iData;
    *top = tmp->next;
    free (tmp);
    return temp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12528412_12528669_1_23
12528412_12530597_7_35
Title: Finding the longest string from a list of ten strings in C? 
----------------------------------------

int main () {
    char **array;
    char *str;
    int x = 0;
    int shortest;
    array = malloc (sizeof (char *) * 10);
    while (x < 10) {
        scanf ("%s", str)
        array [x] = strdup (str);
        x++;
    }
    x = 0;
    shortest = x;
    while (x < 10) {
        if (strlen (array[x]) > strlen (shortest))
            shortest = x;
        x++;
    }
    return (0);
}
----------------------------------------

int main (int argc, char **argv) {
    char str_final [MAX_STR_LEN];
    char str_temp [MAX_STR_LEN];
    unsigned int i, j, len_str;
    unsigned int num_string = 10;
    unsigned int len_max = 0;
    for (i = 0; i < num_string; i++) {
        printf ("Enter string number: %d\n", i);
        gets (str_temp);
        for (j = 0; str_temp[j]; j++)
            ;
        len_str = j;
        if (len_str > len_max) {
            len_max = len_str;
            memset (str_final, 0, MAX_STR_LEN);
            memcpy (str_final, str_temp, len_str);
        }
        else {
            memset (str_temp, 0, MAX_STR_LEN);
        }
    }
    printf ("The biggest string is: %s\n", str_final);
    printf ("It's size is: %d\n", len_max);
    exit (EXIT_SUCCESS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12529725_12529889_1_20
12529725_12530465_1_20
Title: find out char's sequences in array 
----------------------------------------

void splitString (char *from, char start, char end, char *into) {
    int k = 0;
    int size = strlen (from);
    for (int i = 0; i < size; i++) {
        if (from[i] == start) {
            for (int j = i + 1, k = 0; j < size; j++, k++) {
                if (from[j] != end)
                    into[k] = from[j];
                else
                    break;
            }
        }
        break;
    }
    into[k] = '\0';
}
----------------------------------------

void splitString (char *from, char start, char end, char *into) {
    *into = '\0';
    while (*from && *from++ != start)
        ;
    if (!*from)
        return;
    while (*from && *from != end)
        *into++ = *from++;
    *into = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12534778_12534810_3_14
12534778_12535198_11_33
Title: Repeating the loop from user input in C 
----------------------------------------

int main () {
    char n = 'Y';
    while (n == 'Y') {
        printf ("Add Next Y/N: ");
        n = getc (stdin);
        getchar ();
    }
    printf ("n = %c", n);
}
----------------------------------------

int main () {
    struct item e;
    char line [200];
    char next = 'Y';
    while (toupper (next) == 'Y') {
        printf ("Model name ");
        fgets (line, sizeof (line), stdin);
        line[strlen (line) - 1] = '\0';
        strcpy (e.name, line);
        printf ("\nAverage ");
        fgets (line, sizeof (line), stdin);
        e.avg = atoi (line);
        printf ("\nPrice ");
        fgets (line, sizeof (line), stdin);
        e.cost = atof (line);
        printf ("you input %s %d %f\n", e.name, e.avg, e.cost);
        printf ("Add Next (Y/N): ");
        next = getc (stdin);
        getchar ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12541810_12541895_5_17
12541810_12542239_4_20
Title: Weird behaving of pointers and arrays 
----------------------------------------

int main () {
    char *line = NULL;
    size_t linesiz = 0;
    if (getline (&line, &linesiz, stdin) > 0) {
        char *space = strchr (line, ' ');
        if (space) {
            *space = (char) 0;
            printf ("first chunk is %s\n", line);
            printf ("after space have %s\n", space + 1);
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char line_array [260];
    char *line, *p;
    fgets (line_array, sizeof (line_array), stdin);
    line = strdup (line_array);
    p = strtok (line, " ");
    while (p) {
        puts (p);
        p = strtok (NULL, " ");
    }
    free (line);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12550086_12550132_1_15
12550086_12551075_1_40
Title: Iteratively inserting into a binary tree 
----------------------------------------

BST Insert (int x, BST T) {
    BST temp_node = T;
    while (T != NULL) {
        if (x < T->Element)
            T = T->Left;
        else if (x >= T->Element)
            T = T->Right;
    }
    T = newNode (x);
    return temp_node;
}
----------------------------------------

BST Insert (int x, BST T) {
    BST temp = T;
    BST node = (BST) malloc (sizeof (struct TreeNode));
    node->Element = x;
    node->Left = NULL;
    node->Right = NULL;
    if (T == NULL) {
        T = node;
        return (T);
    }
    else {
        while (1) {
            if (temp->Element >= node->Element && temp->Left == NULL) {
                temp->Left = node;
                break;
            }
            else if (temp->Element >= node->Element && temp->Left != NULL) {
                temp = temp->Left;
            }
            else if (temp->Element < node->Element && temp->Right == NULL) {
                temp->Right = node;
                break;
            }
            else {
                temp = temp->Right;
            }
        }
        return (T);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12566445_12570212_17_107
12566445_12572615_6_68
Title: C pipes not communicating 
----------------------------------------

int main (int argc, char **argv) {
    int master_input;
    int ring_pid = 0;
    if (argc != 2) {
        fprintf (stdout, "Argument error!\n");
        fflush (stdout);
        exit (- 1);
    }
    int total_processes = atoi (argv[1]);
    if (pipe (input_pipe) || pipe (output_pipe)) {
        fprintf (stdout, "Cannot create pipes at master. Program exits.\n");
        fflush (stdout);
        exit (- 1);
    }
    else {
        pid_t pid = fork ();
        if (pid) {
            int input_fd = dup (input_pipe[0]);
            int output_fd = dup (output_pipe[1]);
            close (input_pipe [0]);
            close (input_pipe [1]);
            close (output_pipe [0]);
            close (output_pipe [1]);
            fprintf (stdout, "Send message to downstream: %s", msg);
            fflush (stdout);
            write (output_fd, msg, str_len + 1);
            read (input_fd, buf, BUF_LEN);
            fprintf (stdout, "Recieve message from upstream: %s", buf);
            fflush (stdout);
            waitpid (pid, & status, 0);
        }
        else {
            master_input = dup (input_pipe[1]);
            int input_fd = dup (output_pipe[0]);
            int output_fd = -1;
            while (++ring_pid < total_processes) {
                int tmp_pipe [2];
                if (pipe (tmp_pipe)) {
                    fprintf (stdout, "Cannot create pipes at master. Program exits.\n");
                    fflush (stdout);
                    exit (- 1);
                }
                else {
                    pid_t spid = fork ();
                    if (spid) {
                        close (tmp_pipe [0]);
                        if (ring_pid == total_processes - 1) {
                            output_fd = dup (master_input);
                        }
                        else {
                            output_fd = dup (tmp_pipe[1]);
                        }
                        close (tmp_pipe [1]);
                        read (input_fd, buf, BUF_LEN);
                        fprintf (stdout, "Read from upstream: %s", buf);
                        fprintf (stdout, "Write to downstream: %s", buf);
                        write (output_fd, buf, BUF_LEN);
                        waitpid (spid, & status, 0);
                        break;
                    }
                    else {
                        input_fd = dup (tmp_pipe[0]);
                        close (tmp_pipe [0]);
                    }
                }
            }
        }
    }
}
----------------------------------------

int main () {
    int pipefd [MAXCHILD + 1] [2];
    int noofchildren = 0;
    int nchild = NO_OF_CHILDREN;
    int ret;
    int i;
    char buf [MAXBUF];
    for (i = 0; i <= nchild; i++) {
        ret = pipe (pipefd[i]);
        if (0 > ret) {
            printf ("Pipe Creation failed\n");
            exit (1);
        }
    }
    printf ("Pipes created\n");
    for (i = 0; i < nchild; i++) {
        ret = fork ();
        if (0 == ret) {
            child (pipefd [i] [0], pipefd [i + 1] [1]);
        }
        close (pipefd [i] [0]);
        close (pipefd [i + 1] [1]);
    }
    printf ("%d Children  Created\n", nchild);
    while (1) {
        printf ("Enter Some data\n");
        fgets (buf, MAXBUF, stdin);
        write (pipefd [0] [1], buf, strlen (buf) + 1);
        read (pipefd [nchild] [0], buf, MAXBUF);
        printf ("Master Read from the pipe - %s\n", buf);
        if (strcmp (buf, "exit\n") == 0) {
            break;
        }
    }
    while (1) {
        ret = wait (NULL);
        if (0 > ret) {
            break;
        }
        noofchildren++;
    }
    printf ("My %d children terminated! Now I am exiting", noofchildren);
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12575826_12602633_2_18
12575826_32435968_3_21
Title: Using execv (C language) to run commands from a linux command prompt 
----------------------------------------

int main (int argc, char *argv []) {
    int pid;
    pid = fork ();
    if (pid == 0) {
        printf ("Child's PID is %d. Parent's PID is %d\n", (int) getpid, (int) getppid ());
        execv (argv [1], argv + 1);
    }
    else {
        wait (NULL);
        exit (0);
    }
    return 0;
}
----------------------------------------

int main () {
    int ret = fork ();
    if (ret == 0) {
        char *params [4] = {"/bin/ls", "-l", 0};
        int res = execv ("/bin/ls", params);
        printf ("\n child exiting (%d) .. \n", res);
    }
    else {
        waitpid (ret, 1, 0);
        printf ("parent exiting\n");
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12579719_12579863_4_19
12579719_12580127_3_34
Title: dynamic allocation of array of pointers 
----------------------------------------

int main (void) {
    int **ptr;
    int x;
    x = 5;
    ptr = malloc (sizeof (int *) * 10);
    ptr[0] = &x;
    printf ("%d\n", * ptr [0]);
    free (ptr);
    return 0;
}
----------------------------------------

int main () {
    int *sdimen, i;
    sdimen = malloc (10 * sizeof (int));
    sdimen[0] = 10;
    sdimen[1] = 20;
    printf ("\n.. %d... %d ", sdimen [0], sdimen [1]);
    int **twodimen;
    twodimen = malloc (sizeof (int *) * 10);
    for (i = 0; i < 10; i++) {
        twodimen[i] = malloc (sizeof (int) * 5);
    }
    twodimen[0][0] = 10;
    twodimen[0][3] = 30;
    twodimen[2][3] = 50;
    printf ("\n %d ... %d.... %d ", twodimen [0] [0], twodimen [0] [3], twodimen [2] [3]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12579719_12579863_4_19
12579719_44651639_1_12
Title: dynamic allocation of array of pointers 
----------------------------------------

int main (void) {
    int **ptr;
    int x;
    x = 5;
    ptr = malloc (sizeof (int *) * 10);
    ptr[0] = &x;
    printf ("%d\n", * ptr [0]);
    free (ptr);
    return 0;
}
----------------------------------------

int main () {
    int **ptr;
    int *val;
    int x = 7;
    val = &x;
    ptr = (int **) malloc (sizeof (int **));
    *ptr = (int *) malloc (10 * sizeof (*val));
    *ptr[0] = *val;
    printf ("%d\n", * ptr [0]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12579719_12580127_3_34
12579719_44651639_1_12
Title: dynamic allocation of array of pointers 
----------------------------------------

int main () {
    int *sdimen, i;
    sdimen = malloc (10 * sizeof (int));
    sdimen[0] = 10;
    sdimen[1] = 20;
    printf ("\n.. %d... %d ", sdimen [0], sdimen [1]);
    int **twodimen;
    twodimen = malloc (sizeof (int *) * 10);
    for (i = 0; i < 10; i++) {
        twodimen[i] = malloc (sizeof (int) * 5);
    }
    twodimen[0][0] = 10;
    twodimen[0][3] = 30;
    twodimen[2][3] = 50;
    printf ("\n %d ... %d.... %d ", twodimen [0] [0], twodimen [0] [3], twodimen [2] [3]);
    return 0;
}
----------------------------------------

int main () {
    int **ptr;
    int *val;
    int x = 7;
    val = &x;
    ptr = (int **) malloc (sizeof (int **));
    *ptr = (int *) malloc (10 * sizeof (*val));
    *ptr[0] = *val;
    printf ("%d\n", * ptr [0]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12625898_12625993_5_23
12625898_12631444_12_101
Title: create a new process to execute ls command 
----------------------------------------

void main (void) {
    pid_t pid;
    pid = fork ();
    if (pid == 0) {
        int i;
        printf ("Executing command ls...\n");
        i = system ("ls");
        printf ("The value returned was: %d.\n", i);
    }
    else {
        int status = 0 wait (&status);
        printf ("Child process is returned with: %d.\n", status);
    }
}
----------------------------------------

int main (int argc, char *argv []) {
    char *input_arg [2];
    char *input_str = NULL;
    size_t input_len = 0;
    char **args;
    ssize_t len;
    size_t n;
    pid_t child, p;
    int status;
    if (argc < 2) {
        len = getline (&input_str, &input_len, stdin);
        if (len > (ssize_t) 0)
            n = strcspn (input_str, "\r\n");
        else
            n = 0;
        if (n > (size_t) 0) {
            input_str[n] = '\0';
        }
        else {
            fprintf (stderr, "No input, no command.\n");
            return 1;
        }
        input_arg[0] = input_str;
        input_arg[1] = NULL;
        args = input_arg;
    }
    else {
        argv[argc] = NULL;
        args = argv + 1;
    }
    child = fork ();
    if (child == (pid_t) -1) {
        fprintf (stderr, "Cannot fork: %s.\n", strerror (errno));
        return 1;
    }
    if (!child) {
        errno = ENOENT;
        execvp (args [0], args);
        fprintf (stderr, "%s: %s.\n", args [0], strerror (errno));
        exit (127);
    }
    do {
        p = waitpid (child, &status, 0);
    }
    while (p == (pid_t) -1 && errno == EINTR);
    if (p == (pid_t) -1) {
        fprintf (stderr, "Lost child process: %s.\n", strerror (errno));
        return 127;
    }
    if (p != child) {
        fprintf (stderr, "waitpid() library bug occurred.\n");
        return 127;
    }
    if (WIFEXITED (status)) {
        if (!WEXITSTATUS (status))
            fprintf (stderr, "Command successful.\n");
        else
            fprintf (stderr, "Command failed with exit status %d.\n", WEXITSTATUS (status));
        return WEXITSTATUS (status);
    }
    if (WIFSIGNALED (status)) {
        fprintf (stderr, "Command died by signal %s.\n", strsignal (WTERMSIG (status)));
        return 126;
    }
    fprintf (stderr, "Command died from unknown causes.\n");
    return 125;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12647767_12648361_1_13
12647767_12648659_1_16
Title: Valgrind informs me of a memory leak in C that I'm pretty sure I fixed 
----------------------------------------

void DestroyLinkedList (LinkedLists *ListPtr) {
    LinkedListNodes *curNode = ListPtr->FrontPtr;
    LinkedListNodes *nextNode = curNode->Next;
    while (curNode != NULL) {
        free (curNode -> data -> word);
        free (curNode -> data);
        free (curNode);
        curNode = nextNode;
        if (curNode != NULL) {
            nextNode = curNode->Next;
        }
    }
}
----------------------------------------

void DestroyLinkedList (LinkedLists *ListPtr) {
    if (!ListPtr)
        return;
    LinkedListNodes *curNode = ListPtr->FrontPtr;
    while (curNode) {
        LinkedListNodes *nextNode = curNode->Next;
        free (curNode -> WHATEVER);
        free (curNode);
        curNode = nextNode;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12647842_12647945_1_16
12647842_12648013_1_15
Title: What is wrong with my linked list implementation? 
----------------------------------------

void addToLast (linkedList *head, int data) {
    linkedList *ptr = head;
    linkedList *last = null;
    last = (linkedList *) malloc (sizeof (linkedList));
    if (last == NULL)
        printf ("DAFUQ Null\n");
    last->num = data;
    last->next = NULL;
    while (ptr->next != null)
        ptr = ptr->next;
    ptr->next = last;
}
----------------------------------------

void addToLast (linkedList *head, int data) {
    linkedList *ptr = head, *last;
    while (ptr) {
        last = ptr;
        ptr = ptr->next;
    }
    ptr = (linkedList *) malloc (sizeof (linkedList));
    if (ptr == NULL)
        printf ("DAFUQ Null\n");
    ptr->num = data;
    ptr->next = NULL;
    last->next = ptr;
    return;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12647842_12647945_1_16
12647842_12648047_1_25
Title: What is wrong with my linked list implementation? 
----------------------------------------

void addToLast (linkedList *head, int data) {
    linkedList *ptr = head;
    linkedList *last = null;
    last = (linkedList *) malloc (sizeof (linkedList));
    if (last == NULL)
        printf ("DAFUQ Null\n");
    last->num = data;
    last->next = NULL;
    while (ptr->next != null)
        ptr = ptr->next;
    ptr->next = last;
}
----------------------------------------

void addToLast (linkedList **head, int data) {
    linkedList *temp, *r;
    temp = *head;
    if (*head == NULL) {
        temp = malloc (sizeof (linkedList));
        temp->num = data;
        temp->next = NULL;
        *head = temp;
    }
    else {
        while (temp->next != NULL)
            temp = temp->next;
        r = malloc (sizeof (linkedList));
        r->num = data;
        r->next = NULL;
        temp->link = r;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12647842_12648013_1_15
12647842_12648047_1_25
Title: What is wrong with my linked list implementation? 
----------------------------------------

void addToLast (linkedList *head, int data) {
    linkedList *ptr = head, *last;
    while (ptr) {
        last = ptr;
        ptr = ptr->next;
    }
    ptr = (linkedList *) malloc (sizeof (linkedList));
    if (ptr == NULL)
        printf ("DAFUQ Null\n");
    ptr->num = data;
    ptr->next = NULL;
    last->next = ptr;
    return;
}
----------------------------------------

void addToLast (linkedList **head, int data) {
    linkedList *temp, *r;
    temp = *head;
    if (*head == NULL) {
        temp = malloc (sizeof (linkedList));
        temp->num = data;
        temp->next = NULL;
        *head = temp;
    }
    else {
        while (temp->next != NULL)
            temp = temp->next;
        r = malloc (sizeof (linkedList));
        r->num = data;
        r->next = NULL;
        temp->link = r;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12664242_12664323_5_19
12664242_32175860_3_34
Title: Converting decimal to binary in C 
----------------------------------------

int main () {
    int digit, number = 4;
    long long scale, bin = 0LL;
    scale = 1;
    while (number > 0) {
        digit = number % 2;
        bin += digit * scale;
        number /= 2;
        scale *= 10;
    }
    printf ("%lld ", bin);
    getch ();
}
----------------------------------------

int main () {
    long long decimal, tempDecimal, binary;
    int rem, place = 1;
    binary = 0;
    printf ("Enter any decimal number: ");
    scanf ("%lld", & decimal);
    tempDecimal = decimal;
    while (tempDecimal != 0) {
        rem = tempDecimal % 2;
        binary = (rem * place) + binary;
        tempDecimal /= 2;
        place *= 10;
    }
    printf ("\nDecimal number = %lld\n", decimal);
    printf ("Binary number = %lld", binary);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12698836_12699032_1_19
12698836_12699134_4_21
Title: Counting words in a string - c programming 
----------------------------------------

int words (const char *sentence) {
    int count = 0, i, len;
    char lastC;
    len = strlen (sentence);
    if (len > 0) {
        lastC = sentence[0];
    }
    for (i = 0; i <= len; i++) {
        if ((sentence[i] == ' ' || sentence[i] == '\0') && lastC != ' ') {
            count++;
        }
        lastC = sentence[i];
    }
    return count;
}
----------------------------------------

int words (const char sentence []) {
    int counted = 0;
    const char *it = sentence;
    int inword = 0;
    do
        switch (*it) {
        case '\0' :
        case ' ' :
        case '\t' :
        case '\n' :
        case '\r' :
            if (inword) {
                inword = 0;
                counted++;
            }
            break;
        default :
            inword = 1;
        }
    while (*it++);
    return counted;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12698836_12699032_1_19
12698836_13039534_3_17
Title: Counting words in a string - c programming 
----------------------------------------

int words (const char *sentence) {
    int count = 0, i, len;
    char lastC;
    len = strlen (sentence);
    if (len > 0) {
        lastC = sentence[0];
    }
    for (i = 0; i <= len; i++) {
        if ((sentence[i] == ' ' || sentence[i] == '\0') && lastC != ' ') {
            count++;
        }
        lastC = sentence[i];
    }
    return count;
}
----------------------------------------

int words (const char *s) {
    const char *sep = " \t\n\r\v\f";
    int word = 0;
    size_t len;
    s += strspn (s, sep);
    while ((len = strcspn (s, sep)) > 0) {
        ++word;
        s += len;
        s += strspn (s, sep);
    }
    return word;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12698836_12699134_4_21
12698836_13039534_3_17
Title: Counting words in a string - c programming 
----------------------------------------

int words (const char sentence []) {
    int counted = 0;
    const char *it = sentence;
    int inword = 0;
    do
        switch (*it) {
        case '\0' :
        case ' ' :
        case '\t' :
        case '\n' :
        case '\r' :
            if (inword) {
                inword = 0;
                counted++;
            }
            break;
        default :
            inword = 1;
        }
    while (*it++);
    return counted;
}
----------------------------------------

int words (const char *s) {
    const char *sep = " \t\n\r\v\f";
    int word = 0;
    size_t len;
    s += strspn (s, sep);
    while ((len = strcspn (s, sep)) > 0) {
        ++word;
        s += len;
        s += strspn (s, sep);
    }
    return word;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12698836_18580655_10_22
12698836_22476275_3_17
Title: Counting words in a string - c programming 
----------------------------------------

int main () {
    char string [1000];
    int wordsNum;
    printf ("Unesi nisku: ");
    gets (string);
    wordsNum = countWords (string);
    printf ("Broj reci: %d\n", wordsNum);
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    char str [50];
    int i, count = 1;
    printf ("Enter a string:\n");
    gets (str);
    for (i = 0; str[i] != '\0'; i++) {
        if (str[i] == ' ') {
            count++;
        }
    }
    printf ("%i\n", count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12698836_29147112_8_34
12698836_47166608_3_46
Title: Counting words in a string - c programming 
----------------------------------------

int wordCount (char *string) {
    char *s = string;
    bool inWord = false;
    int i = 0;
    while (*s) {
        if (isWhiteSpace (*s)) {
            inWord = false;
            while (isWhiteSpace (*s))
                s++;
        }
        else {
            if (!inWord) {
                inWord = true;
                i++;
            }
            s++;
        }
    }
    return i;
}
----------------------------------------

char wordCount (char array []) {
    char *pointer;
    pointer = &array[0];
    int count;
    count = 0;
    long len;
    len = strlen (array);
    for (int i = 0; i < len; i++) {
        if (ispunct (*(pointer)) == 1) {
            pointer += 1;
            continue;
        }
        if (isalpha (*(pointer)) == 1) {
            pointer += 1;
            continue;
        }
        count++;
        if (*(pointer) == ' ') {
            do {
                pointer += 1;
            }
            while (*(pointer) == ' ');
        }
        if (*pointer == '\0' || *pointer == '\n') {
            count++;
            return (count);
        }
    }
    count++;
    return (count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12701393_12703283_4_40
12701393_12704926_12_69
Title: Can I bundle two MPI messages? 
----------------------------------------

int main () {
    MPI_Init (NULL, NULL);
    int rank = 0;
    int size = 1;
    MPI_Comm_rank (MPI_COMM_WORLD, & rank);
    MPI_Comm_size (MPI_COMM_WORLD, & size);
    if (rank == size - 1) {
        float data [size - 1];
        MPI_Request request [size - 1];
        for (int tag = 0; tag < size - 1; ++tag) {
            printf ("Receiver for id %d\n", tag);
            MPI_Irecv (data + tag, 1, MPI_FLOAT, MPI_ANY_SOURCE, tag, MPI_COMM_WORLD, & request [tag]);
        }
        printf ("Waiting...\n");
        MPI_Waitall (size - 1, request, MPI_STATUSES_IGNORE);
        for (size_t i = 0; i < size - 1; ++i) {
            printf ("%f\n", data [i]);
        }
    }
    else {
        int id = rank;
        float data = rank;
        printf ("Sending {%d}{%f}\n", id, data);
        MPI_Send (& data, 1, MPI_FLOAT, size - 1, id, MPI_COMM_WORLD);
    }
    return MPI_Finalize ();
}
----------------------------------------

int main () {
    MPI_Init (NULL, NULL);
    int rank = -1;
    int size = -1;
    MPI_Comm_rank (MPI_COMM_WORLD, & rank);
    MPI_Comm_size (MPI_COMM_WORLD, & size);
    data buffer;
    int blocklength [2];
    MPI_Aint displacement [2];
    MPI_Datatype datatypes [2];
    MPI_Datatype mpi_tdata;
    MPI_Aint startid, startarray;
    MPI_Get_address (& (buffer.id), & startid);
    MPI_Get_address (& (buffer.array [0]), & startarray);
    blocklength[0] = 1;
    blocklength[1] = asize;
    displacement[0] = 0;
    displacement[1] = startarray - startid;
    datatypes[0] = MPI_INT;
    datatypes[1] = MPI_FLOAT;
    MPI_Type_create_struct (2, blocklength, displacement, datatypes, & mpi_tdata);
    MPI_Type_commit (& mpi_tdata);
    if (rank == 0) {
        int count = 0;
        MPI_Status status;
        while (count < size - 1) {
            printf ("Receiving message %d\n", count);
            MPI_Recv (& buffer, 1, mpi_tdata, MPI_ANY_SOURCE, 0, MPI_COMM_WORLD, & status);
            printf ("Message tag %d, first entry %g\n", buffer.id, buffer.array [0]);
            count++;
        }
    }
    else {
        buffer.id = rank;
        for (int ii = 0; ii < size; ii++) {
            buffer.array[ii] = 10 * rank + ii;
        }
        MPI_Send (& buffer, 1, mpi_tdata, 0, 0, MPI_COMM_WORLD);
    }
    MPI_Type_free (& mpi_tdata);
    MPI_Finalize ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12707278_36505752_8_22
12707278_42161755_13_39
Title: Reversing a string in c with recursion 
----------------------------------------

void main () {
    char *src = (char *) malloc (SIZE);
    char *dest = (char *) malloc (SIZE);
    strcpy_s (dest, SIZE, "");
    strcpy_s (src, SIZE, STRING);
    reverseString (dest, src, strlen (src));
    free (src);
    free (dest);
}
----------------------------------------

int main () {
    char *sstr = NULL;
    char *dstr = NULL;
    sstr = malloc (16);
    if (!sstr) {
        printf ("no memory . . .\n");
        return 0;
    }
    strcpy (sstr, "hello world !");
    printf ("sstr: %s\n", sstr);
    dstr = malloc (16);
    if (!dstr) {
        printf ("no memory . . .\n");
        return 0;
    }
    revstr_rec (sstr, dstr, strlen (sstr));
    printf ("dstr(recursive): %s\n", dstr);
    free (sstr);
    free (dstr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12747731_12747836_1_19
12747731_12748345_15_29
Title: Ways to create dynamic matrix in C? 
----------------------------------------

int main () {
    int i, j, lines, columns, *intMatrix;
    printf ("Type the matrix lines:\t");
    scanf ("%d", & lines);
    printf ("Type the matrix columns:\t");
    scanf ("%d", & columns);
    intMatrix = (int *) malloc (lines *columns * sizeof (int));
    for (i = 0; i < lines; ++i) {
        for (j = 0;
        j < columns;
        ++ j) {printf ("Type a number for <line: %d, column: %d>\t", i + 1, j + 1);
        scanf ("%d", & intMatrix [i * lines + j]);
    }
}
----------------------------------------

int main () {
    int lines, columns;
    printf ("Type the matrix lines:\t");
    scanf ("%d", & lines);
    printf ("Type the matrix columns:\t");
    scanf ("%d", & columns);
    {
        int intMatrix [lines] [columns];
        readData (lines, columns, intMatrix);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12762040_12769452_79_125
12762040_16787554_4_17
Title: Get the maximum value of a variable in C 
----------------------------------------

int main (void) {
    signed char sc = 1;
    char c = 2;
    unsigned char uc = 3;
    short ss = 4;
    unsigned short us = 5;
    int si = 6;
    unsigned int ui = 7;
    long sl = 8;
    unsigned long ul = 9;
    long long sll = 10;
    unsigned long long ull = 11;
    PRINT_VARS ();
    TEST_VAR (sc);
    TEST_VAR (c);
    TEST_VAR (uc);
    TEST_VAR (ss);
    TEST_VAR (us);
    TEST_VAR (si);
    TEST_VAR (ui);
    TEST_VAR (sl);
    TEST_VAR (ul);
    TEST_VAR (sll);
    TEST_VAR (ull);
    PRINT_VARS ();
    return 0;
}
----------------------------------------

int main (void) {
    printf ("Max value of char: %d\n", CHAR_MAX);
    printf ("Min value of char: %d\n", CHAR_MIN);
    printf ("Max value of short: %d\n", SHRT_MAX);
    printf ("Min value of short: %d\n", SHRT_MIN);
    printf ("Max value of int: %d\n", INT_MAX);
    printf ("Min value of int: %d\n", INT_MIN);
    printf ("\n\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12767485_12768124_1_15
12767485_12768237_1_33
Title: Array of structs in C that are passed into a function 
----------------------------------------

void loopTokens (PInfo *p, char *textLine) {
    char *buffer;
    int index = 0;
    p->Name = malloc (80);
    buffer = strtok (textLine, "|");
    while (buffer != NULL && strcmp (textLine, "\n")) {if (index == 0) {p -> Name = buffer;
    buffer = strtok (NULL, "|");
    index++;
}
----------------------------------------

void loopTokens (PInfo *p, char *textLine) {
    char *tok;
    int index = 0;
    if (!strcmp (textLine, "\n"))
        return;
    for (tok = strtok (textLine, "|"); tok; tok = strtok (NULL, "|")) {
        switch (index++) {
        case 0 :
            p->Name = strdup (tok);
            break;
        case 1 :
            p->Phone = strdup (tok);
            break;
        case 2 :
            p->address = strdup (tok);
            break;
        case 3 :
            p->city = strdup (tok);
            break;
        case 4 :
            p->state = strdup (tok);
            break;
        case 5 :
            p->zip = 0;
            p->zip = atoi (tok);
            break;
        default :
            return;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12767892_12768465_3_27
12767892_12769684_4_23
Title: Ignore first word from the line in c 
----------------------------------------

int main () {
    char rest [1000];
    scanf ("%*s%*[ ]");
    fgets (rest, sizeof (rest), stdin);
    printf ("%s", rest);
    scanf ("%*s ");
    fgets (rest, sizeof (rest), stdin);
    printf ("%s", rest);
    scanf ("%*s");
    fgets (rest, sizeof (rest), stdin);
    printf ("%s", rest);
    return 0;
}
----------------------------------------

int main () {
    char buffer [80];
    char storage [80];
    fgets (buffer, 80, stdin);
    char *rest = strchr (buffer, ' ');
    printf ("rest:   »%s«\n", rest);
    printf ("buffer: »%s«\n", buffer);
    strncpy (storage, rest, 80);
    printf ("storage: »%s«\n", storage);
    char *rest2 = buffer;
    rest2 += strcspn (buffer, " \t\r\n");
    printf ("rest2:  »%s«\n", rest2);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12771276_12771353_4_18
12771276_12771354_2_21
Title: Heap corruption from memory allocation using malloc: why did it happen? 
----------------------------------------

void *MYmemmove (void *destination, const void *source, size_t num) {
    char *Source = source, *Destination = destination;
    char *Middle = malloc (sizeof (char) * num);
    for (int i = 0; i < num; i++) {
        Middle[i] = Destination[i];
    }
    for (int i = 0; i < num; i++) {
        Destination[i] = Middle[i];
    }
    free (Middle);
    return destination;
}
----------------------------------------

void *MYmemmove (void *destination, const void *source, size_t num) {
    char *midbuf = (char *) malloc (num);
    char *refdes = (char *) destination;
    char *refsrc = (char *) source;
    for (int i = 0; i < num; i++) {
        midbuf[i] = *(refsrc + i);
    }
    for (int i = 0; i < num; i++) {
        refdes[i] = *(midbuf + i);
    }
    free (midbuf);
    return destination;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12778672_12779249_1_36
12778672_20718760_1_57
Title: Killing process that has been created with popen2 
----------------------------------------

pid_t popen2 (const char **command, int *infp, int *outfp) {
    int p_stdin [2], p_stdout [2];
    pid_t pid;
    if (pipe (p_stdin) != 0 || pipe (p_stdout) != 0)
        return -1;
    pid = fork ();
    if (pid < 0)
        return pid;
    else if (pid == 0) {
        close (p_stdin [WRITE]);
        dup2 (p_stdin [READ], READ);
        close (p_stdout [READ]);
        dup2 (p_stdout [WRITE], WRITE);
        execvp (* command, command);
        perror ("execvp");
        exit (1);
    }
    if (infp == NULL)
        close (p_stdin[WRITE]);
    else
        *infp = p_stdin[WRITE];
    if (outfp == NULL)
        close (p_stdout[READ]);
    else
        *outfp = p_stdout[READ];
    return pid;
}
----------------------------------------

pid_t popen2 (char *command, int *in_fd, int *out_fd) {
    int pin [2], pout [2];
    pid_t pid;
    char cmd [strlen (command) + 10];
    if (out_fd != NULL) {
        if (pipe (pin) != 0)
            return (-1);
    }
    if (in_fd != NULL) {
        if (pipe (pout) != 0) {
            if (out_fd != NULL) {
                close (pin [0]);
                close (pin [1]);
            }
            return (-1);
        }
    }
    pid = fork ();
    if (pid < 0) {
        if (out_fd != NULL) {
            close (pin [0]);
            close (pin [1]);
        }
        if (in_fd != NULL) {
            close (pout [0]);
            close (pout [1]);
        }
        return pid;
    }
    if (pid == 0) {
        if (out_fd != NULL) {
            close (pin [1]);
            dup2 (pin [0], 0);
        }
        if (in_fd != NULL) {
            close (pout [0]);
            dup2 (pout [1], 1);
        }
        sprintf (cmd, "exec %s", command);
        execlp ("sh", "sh", "-c", cmd, NULL);
        fprintf (stderr, "%s:%d: Exec failed in popen2. ", __FILE__, __LINE__);
        perror ("Error:");
        exit (1);
    }
    if (in_fd != NULL) {
        close (pout [1]);
        *in_fd = pout[0];
    }
    if (out_fd != NULL) {
        close (pin [0]);
        *out_fd = pin[1];
    }
    return pid;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12791077_14016925_60_75
12791077_14017719_9_24
Title: atoi implementation in C 
----------------------------------------

int main (int argc, char **argv) {
    int result;
    printf ("INT_MIN=%d will be output when number too high or too low, and errno set\n", INT_MIN);
    printf ("string=%s, int=%d\n", "563", atoi ("563"));
    printf ("string=%s, int=%d\n", "-563", atoi ("-563"));
    printf ("string=%s, int=%d\n", "-5a3", atoi ("-5a3"));
    if (argc > 1) {
        result = atoi (argv[1]);
        printf ("atoi(%s)=%d %s", argv [1], result, (result == INT_MIN) ? ", errno=" : "", errno, strerror (errno));
        if (errno)
            printf ("%d - %s\n", errno, strerror (errno));
        else
            printf ("\n");
    }
    return (errno);
}
----------------------------------------

int main (int argc, char **argv) {
    char *str1 = "3.14159", *str2 = "3", *str3 = "0.707106", *str4 = "-5.2";
    double f1, f2, f3, f4;
    if (debug)
        printf ("convert %s, %s, %s, %s\n", str1, str2, str3, str4);
    f1 = atof (str1);
    f2 = atof (str2);
    f3 = atof (str3);
    f4 = atof (str4);
    if (debug)
        printf ("converted values=%f, %f, %f, %f\n", f1, f2, f3, f4);
    if (argc > 1) {
        printf ("string %s is floating point %f\n", argv [1], atof (argv [1]));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12791077_14016925_9_58
12791077_52906058_1_40
Title: atoi implementation in C 
----------------------------------------

int atoi (const char *c) {
    int previous_result = 0, result = 0;
    int multiplier = 1;
    if (debug)
        printf ("converting %s to integer\n", c ? c : "");
    if (c && *c == '-') {
        multiplier = -1;
        c++;
    }
    else {
        multiplier = 1;
    }
    if (debug)
        printf ("multiplier = %d\n", multiplier);
    while (*c) {
        if (*c < '0' || *c > '9') {
            return result * multiplier;
        }
        result *= 10;
        if (result < previous_result) {
            if (debug)
                printf ("number overflowed - return INT_MIN, errno=%d\n", errno);
            errno = EOVERFLOW;
            return (INT_MIN);
        }
        else {
            previous_result *= 10;
        }
        if (debug)
            printf ("%c\n", *c);
        result += *c - '0';
        if (result < previous_result) {
            if (debug)
                printf ("number overflowed - return MIN_INT\n");
            errno = EOVERFLOW;
            return (INT_MIN);
        }
        else {
            previous_result += *c - '0';
        }
        c++;
    }
    return (result * multiplier);
}
----------------------------------------

int atoi (char *s) {
    int c = 1, a = 0, sign, start, end, base = 1;
    if (s[0] == '-')
        sign = -1;
    else if (s[0] <= '9' && s[0] >= '0')
        sign = 1;
    else if (s[0] == '+')
        sign = 2;
    else
        return 0;
    while (s[c] != '\n' && s[c] <= '9' && s[c] >= '0')
        c++;
    start = c - 1;
    if (sign == -1)
        end = 1;
    else if (sign == 1)
        end = 0;
    else {
        end = 1;
        sign = 1;
    }
    for (int i = start; i >= end; i--) {
        a += (s[i] - '0') * base;
        base *= 10;
    }
    return sign * a;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12801700_12801814_6_16
12801700_12802090_6_21
Title: How can I merge 3 variable in to one variable 
----------------------------------------

int main () {
    int a = 10;
    int b = 12;
    int c = 2;
    stringstream ss;
    ss << a << b << c;
    int merge;
    ss >> merge;
    cout << merge << endl;
    return 0;
}
----------------------------------------

int main () {
    int var1 = 1;
    int var2 = 2;
    int var3 = 3;
    ostringstream oss;
    string result;
    oss << var1 << var2 << var3;
    result = oss.str ();
    cout << result << endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1284581_1284638_3_25
1284581_1284747_23_34
Title: Finding a bit pattern in a 32bit unsigned integer 
----------------------------------------

int main (void) {
    unsigned int number = 0xa2;
    unsigned int pattern = 0x02;
    unsigned int pattern_mask = 0x03;
    int count = 0;
    while (number > 0) {
        if (!((number ^ pattern) & pattern_mask)) {
            ++count;
            printf ("%x\n", number);
        }
        number >>= 1;
    }
    printf ("\ncount:  %d\n", count);
    return 0;
}
----------------------------------------

int main () {
    long haystack = 55;
    long needle1 = 2;
    long needle2 = 3;
    cout << "10 occurs " << count (haystack, needle1, 2) << " times in 110111." << endl;
    cout << "11 occurs " << count (haystack, needle2, 2) << " times in 110111." << endl;
    system ("PAUSE");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12862497_12862874_4_23
12862497_12862882_4_26
Title: How do you determine the smallest and largest positive integer inputs when the user can give as many inputs as they want in c? 
----------------------------------------

int main () {
    int integer, largest_int = INT_MIN, smallest_int = INT_MAX;
    int count_positive = 0;
    for (;;) {
        printf ("Please enter a positive integer: \n");
        scanf ("%d", & integer);
        if (integer == 0 && count_positive > 1)
            break;
        else if (integer > 0) {
            count_positive = count_positive > 1 ? 2 : count_positive + 1;
            if (largest_int < integer)
                largest_int = integer;
            if (smallest_int > integer)
                smallest_int = integer;
        }
    }
    printf ("%d %d\n", smallest_int, largest_int);
    return 0;
}
----------------------------------------

int main (void) {
    int integer, largest_int = INT_MIN, smallest_int = INT_MAX;
    do {
        printf ("Enter a positive integer: ");
        scanf ("%d", & integer);
        if (integer < 0)
            continue;
        else if (integer == 0)
            break;
        else {
            if (integer > largest_int)
                largest_int = integer;
            if (integer < smallest_int)
                smallest_int = integer;
        }
    }
    while (1);
    printf ("Largest integer is %d\nSmallest integer is %d", largest_int, smallest_int);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12872565_12872905_2_20
12872565_12873038_3_24
Title: Print matrix on one line 
----------------------------------------

int main (void) {
    char matrix [4] [5] = {{'1', '2', '3', '4', '5'}, {'6', '7', '8', '9', 'A'}, {'B', 'C', 'D', 'E', 'F'}, {'0', '1', '2', '3', '4'}};
    int cols = 5;
    int rows = 4;
    int i = 0;
    for (i = 0; i < cols + rows - 2; i++) {
        int j = 0;
        while (j <= i) {
            int k = i - j;
            if (k < rows && j < cols) {
                printf ("%c ", matrix [k] [j]);
            }
            j++;
        }
    }
}
----------------------------------------

int main (int argc, char **argv) {
    char m [4] [5] = {{'1', '2', '3', '4', '5'}, {'6', '7', '8', '9', 'A'}, {'B', 'C', 'D', 'E', 'F'}, {'0', '1', '2', '3', '4'}};
    for (int i = 0; i <= 3; ++i) {
        for (int j = 0; j <= i; ++j) {
        std :
            : cout << m [i - j] [j] << " ";
        }
    }
    for (int i = 4; i <= 7; ++i) {
        for (int j = i - 3; j <= 4; ++j) {
        std :
            : cout << m [i - j] [j] << " ";
        }
    }
std :
    : cout << std : : endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12886685_12886800_1_14
12886685_19126355_1_38
Title: Modifying fields in a struct in a linked list 
----------------------------------------

int updateStockOfCar (Record *head, const char *make, int year, int newStock) {
    Record *p = head;
    while (p) {
        if ((p->year == year) && !strcmp (p->make, make)) {
            p->stock = newStock;
            break;
        }
        p = p->next;
    }
    return (p ? 1 : 0);
}
----------------------------------------

int updateStockOfCar (Record **head, char *make, int year, int newStock) {
    if (*head == NULL) {
        printf ("The list is empty\n");
        return 0;
    }
    Record *matching = malloc (sizeof (Record));
    matching->make = make;
    matching->year = year;
    if (strcmp ((*head)->make, matching->make) == 0) {
        if ((*head)->year == matching->year) {
            (*head)->stock = newStock;
            return 1;
        }
    }
    Record *current = (*head)->next;
    while (current != NULL) {
        if (strcmp (current->make, matching->make) == 0 && current->year == matching->year) {
            current->stock = newStock;
            return 1;
        }
        else {
            current = current->next;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12890008_12890054_1_10
12890008_12890107_2_21
Title: Replacing character in a string 
----------------------------------------

char *replace (char *st, char *orig, char *repl) {
    static char buffer [4096];
    char *ch;
    if (!(ch = strstr (st, orig)))
        return st;
    strncpy (buffer, st, ch - st);
    buffer[ch - st] = 0;
    sprintf (buffer + (ch - st), "%s%s", repl, ch + strlen (orig));
    return buffer;
}
----------------------------------------

char *replace (const char *s, char ch, const char *repl) {
    int count = 0;
    const char *t;
    for (t = s; *t; t++)
        count += (*t == ch);
    size_t rlen = strlen (repl);
    char *res = malloc (strlen (s) +(rlen - 1) * count + 1);
    char *ptr = res;
    for (t = s; *t; t++) {
        if (*t == ch) {
            memcpy (ptr, repl, rlen);
            ptr += rlen;
        }
        else {
            *ptr++ = *t;
        }
    }
    *ptr = 0;
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12890008_12890139_3_26
12890008_12890168_3_26
Title: Replacing character in a string 
----------------------------------------

int main (void) {
    char s [20] = "aaabaa";
    char s1 [1024];
    int i, j, n;
    for (i = 0, n = 0; s[i] != '\0'; i++) {
        if (s[i] == 'b') {
            for (j = 0; j < 5; j++) {
                s1[n] = 'c';
                n++;
            }
        }
        else {
            s1[n] = s[i];
            n++;
        }
    }
    s1[n] = '\0';
    printf ("%s\n", s1);
}
----------------------------------------

int main (void) {
    char s [20] = "aaabaa";
    char temp [20] = "";
    int i, j, k;
    k = 0;
    for (i = 0; s[i] != '\0'; i++) {
        if (s[i] == 'b') {
            for (j = 0; j < 5; j++) {
                temp[k] = 'c';
                k++;
            }
        }
        else {
            temp[k] = s[i];
            k ++
        }
    }
    printf ("%s\n", temp);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12890008_12890139_3_26
12890008_12892177_4_24
Title: Replacing character in a string 
----------------------------------------

int main (void) {
    char s [20] = "aaabaa";
    char s1 [1024];
    int i, j, n;
    for (i = 0, n = 0; s[i] != '\0'; i++) {
        if (s[i] == 'b') {
            for (j = 0; j < 5; j++) {
                s1[n] = 'c';
                n++;
            }
        }
        else {
            s1[n] = s[i];
            n++;
        }
    }
    s1[n] = '\0';
    printf ("%s\n", s1);
}
----------------------------------------

int main (void) {
    char temp [20];
    char s [20] = "aaabaa";
    int i, j;
    for (i = 0; s[i] != '\0'; i++) {
        if (s[i] == 'b') {
            strcpy (temp, s [i + 1]);
            for (j = 0; j < 5; j++) {
                s[i + j] = 'c';
            }
            s[i + j] = '\0';
            strcat (s, temp);
        }
    }
    printf ("%s\n", s);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12890008_12890168_3_26
12890008_12892177_4_24
Title: Replacing character in a string 
----------------------------------------

int main (void) {
    char s [20] = "aaabaa";
    char temp [20] = "";
    int i, j, k;
    k = 0;
    for (i = 0; s[i] != '\0'; i++) {
        if (s[i] == 'b') {
            for (j = 0; j < 5; j++) {
                temp[k] = 'c';
                k++;
            }
        }
        else {
            temp[k] = s[i];
            k ++
        }
    }
    printf ("%s\n", temp);
}
----------------------------------------

int main (void) {
    char temp [20];
    char s [20] = "aaabaa";
    int i, j;
    for (i = 0; s[i] != '\0'; i++) {
        if (s[i] == 'b') {
            strcpy (temp, s [i + 1]);
            for (j = 0; j < 5; j++) {
                s[i + j] = 'c';
            }
            s[i + j] = '\0';
            strcat (s, temp);
        }
    }
    printf ("%s\n", s);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12911299_12911465_18_30
12911299_28321635_109_134
Title: Read .CSV file in C 
----------------------------------------

int main () {
    FILE *stream = fopen ("input", "r");
    char line [1024];
    while (fgets (line, 1024, stream)) {
        char *tmp = strdup (line);
        printf ("Field 3 would be %s\n", getfield (tmp, 3));
        free (tmp);
    }
}
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp;
    long errcount = 0L;
    long lines = 0L;
    if (argc != 3) {
        printf ("Usage: %s csvfilepath delimiter\n", basename (argv [0]));
        return (RET_FAIL);
    }
    if ((delim = argv[2][0]) == '\0') {
        fprintf (stderr, "delimiter must be specified\n");
        return (RET_FAIL);
    }
    fp = fopen (argv[1], "r");
    if (fp == NULL) {
        fprintf (stderr, "Error opening file: %d\n", errno);
        return (RET_FAIL);
    }
    lines = loadFile (fp, &errcount);
    fclose (fp);
    printf ("Processed %ld lines, encountered %ld error(s)\n", lines, errcount);
    if (errcount > 0)
        return (RET_FAIL);
    return (RET_OK);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12911299_12911465_18_30
12911299_31732566_89_134
Title: Read .CSV file in C 
----------------------------------------

int main () {
    FILE *stream = fopen ("input", "r");
    char line [1024];
    while (fgets (line, 1024, stream)) {
        char *tmp = strdup (line);
        printf ("Field 3 would be %s\n", getfield (tmp, 3));
        free (tmp);
    }
}
----------------------------------------

int main () {
    char in_line [] = "Arg1;;Th;s is not Del;m;ter;;Arg3;;;;Final";
    char delim [] = ";;";
    char **columns;
    int i;
    printf ("Example1:\n");
    columns = NULL;
    int cols_found = getcols (in_line, delim, &columns);
    for (i = 0; i < cols_found; i++)
        printf ("Column[ %d ] = %s\n", i, columns[i]);
    free (columns);
    columns = NULL;
    printf ("\n\nExample2, Nested:\n\n");
    char example_file [] = "ID;Day;Month;Year;Telephone;email;Date of registration\n" "1;Sunday;january;2009;123-124-456;jitter@go.xyz;2015-05-13\n" "2;Monday;March;2011;(+30)333-22-55;buffer@wl.it;2009-05-23";
    char **rows;
    int j;
    rows = NULL;
    getcols (example_file, "\n", & rows);
    for (i = 0; rows[i]; i++) {
        {
            printf ("Line[ %d ] = %s\n", i, rows [i]);
            char **columnX = NULL;
            getcols (rows [i], ";", & columnX);
            for (j = 0; columnX[j]; j++)
                printf ("  Col[ %d ] = %s\n", j, columnX[j]);
            free (columnX);
        }
    }
    free (rows);
    rows = NULL;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12911299_12911465_18_30
12911299_39296507_6_84
Title: Read .CSV file in C 
----------------------------------------

int main () {
    FILE *stream = fopen ("input", "r");
    char line [1024];
    while (fgets (line, 1024, stream)) {
        char *tmp = strdup (line);
        printf ("Field 3 would be %s\n", getfield (tmp, 3));
        free (tmp);
    }
}
----------------------------------------

int main (int argc, char *argv []) {
    FILE *pfinput;
    unsigned int nSkipLines, currentLine, lenLongestValue;
    char *pTempValHolder;
    int c;
    unsigned int vcpm;
    int QuotationOnOff;
    nSkipLines = atoi (argv[2]);
    lenLongestValue = atoi (argv[3]);
    pTempValHolder = (char *) malloc (lenLongestValue);
    if (pfinput = fopen (argv[1], "r")) {
        rewind (pfinput);
        currentLine = 1;
        vcpm = 0;
        QuotationOnOff = 0;
        while ((c = fgetc (pfinput)) != EOF) {
            switch (c) {
            case ',' :
                if (!QuotationOnOff && currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = '\0';
                    printf ("%s,", pTempValHolder);
                    vcpm = 0;
                }
                break;
            case '\n' :
                if (currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = '\0';
                    printf ("%s\n", pTempValHolder);
                    vcpm = 0;
                }
                currentLine++;
                break;
            case '\"' :
                if (currentLine > nSkipLines) {
                    if (!QuotationOnOff) {
                        QuotationOnOff = 1;
                        pTempValHolder[vcpm] = c;
                        vcpm++;
                    }
                    else {
                        QuotationOnOff = 0;
                        pTempValHolder[vcpm] = c;
                        vcpm++;
                    }
                }
                break;
            default :
                if (currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = c;
                    vcpm++;
                }
                break;
            }
        }
        fclose (pfinput);
        free (pTempValHolder);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12911299_28321635_109_134
12911299_31732566_89_134
Title: Read .CSV file in C 
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp;
    long errcount = 0L;
    long lines = 0L;
    if (argc != 3) {
        printf ("Usage: %s csvfilepath delimiter\n", basename (argv [0]));
        return (RET_FAIL);
    }
    if ((delim = argv[2][0]) == '\0') {
        fprintf (stderr, "delimiter must be specified\n");
        return (RET_FAIL);
    }
    fp = fopen (argv[1], "r");
    if (fp == NULL) {
        fprintf (stderr, "Error opening file: %d\n", errno);
        return (RET_FAIL);
    }
    lines = loadFile (fp, &errcount);
    fclose (fp);
    printf ("Processed %ld lines, encountered %ld error(s)\n", lines, errcount);
    if (errcount > 0)
        return (RET_FAIL);
    return (RET_OK);
}
----------------------------------------

int main () {
    char in_line [] = "Arg1;;Th;s is not Del;m;ter;;Arg3;;;;Final";
    char delim [] = ";;";
    char **columns;
    int i;
    printf ("Example1:\n");
    columns = NULL;
    int cols_found = getcols (in_line, delim, &columns);
    for (i = 0; i < cols_found; i++)
        printf ("Column[ %d ] = %s\n", i, columns[i]);
    free (columns);
    columns = NULL;
    printf ("\n\nExample2, Nested:\n\n");
    char example_file [] = "ID;Day;Month;Year;Telephone;email;Date of registration\n" "1;Sunday;january;2009;123-124-456;jitter@go.xyz;2015-05-13\n" "2;Monday;March;2011;(+30)333-22-55;buffer@wl.it;2009-05-23";
    char **rows;
    int j;
    rows = NULL;
    getcols (example_file, "\n", & rows);
    for (i = 0; rows[i]; i++) {
        {
            printf ("Line[ %d ] = %s\n", i, rows [i]);
            char **columnX = NULL;
            getcols (rows [i], ";", & columnX);
            for (j = 0; columnX[j]; j++)
                printf ("  Col[ %d ] = %s\n", j, columnX[j]);
            free (columnX);
        }
    }
    free (rows);
    rows = NULL;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12911299_28321635_109_134
12911299_39296507_6_84
Title: Read .CSV file in C 
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp;
    long errcount = 0L;
    long lines = 0L;
    if (argc != 3) {
        printf ("Usage: %s csvfilepath delimiter\n", basename (argv [0]));
        return (RET_FAIL);
    }
    if ((delim = argv[2][0]) == '\0') {
        fprintf (stderr, "delimiter must be specified\n");
        return (RET_FAIL);
    }
    fp = fopen (argv[1], "r");
    if (fp == NULL) {
        fprintf (stderr, "Error opening file: %d\n", errno);
        return (RET_FAIL);
    }
    lines = loadFile (fp, &errcount);
    fclose (fp);
    printf ("Processed %ld lines, encountered %ld error(s)\n", lines, errcount);
    if (errcount > 0)
        return (RET_FAIL);
    return (RET_OK);
}
----------------------------------------

int main (int argc, char *argv []) {
    FILE *pfinput;
    unsigned int nSkipLines, currentLine, lenLongestValue;
    char *pTempValHolder;
    int c;
    unsigned int vcpm;
    int QuotationOnOff;
    nSkipLines = atoi (argv[2]);
    lenLongestValue = atoi (argv[3]);
    pTempValHolder = (char *) malloc (lenLongestValue);
    if (pfinput = fopen (argv[1], "r")) {
        rewind (pfinput);
        currentLine = 1;
        vcpm = 0;
        QuotationOnOff = 0;
        while ((c = fgetc (pfinput)) != EOF) {
            switch (c) {
            case ',' :
                if (!QuotationOnOff && currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = '\0';
                    printf ("%s,", pTempValHolder);
                    vcpm = 0;
                }
                break;
            case '\n' :
                if (currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = '\0';
                    printf ("%s\n", pTempValHolder);
                    vcpm = 0;
                }
                currentLine++;
                break;
            case '\"' :
                if (currentLine > nSkipLines) {
                    if (!QuotationOnOff) {
                        QuotationOnOff = 1;
                        pTempValHolder[vcpm] = c;
                        vcpm++;
                    }
                    else {
                        QuotationOnOff = 0;
                        pTempValHolder[vcpm] = c;
                        vcpm++;
                    }
                }
                break;
            default :
                if (currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = c;
                    vcpm++;
                }
                break;
            }
        }
        fclose (pfinput);
        free (pTempValHolder);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12911299_31732566_89_134
12911299_39296507_6_84
Title: Read .CSV file in C 
----------------------------------------

int main () {
    char in_line [] = "Arg1;;Th;s is not Del;m;ter;;Arg3;;;;Final";
    char delim [] = ";;";
    char **columns;
    int i;
    printf ("Example1:\n");
    columns = NULL;
    int cols_found = getcols (in_line, delim, &columns);
    for (i = 0; i < cols_found; i++)
        printf ("Column[ %d ] = %s\n", i, columns[i]);
    free (columns);
    columns = NULL;
    printf ("\n\nExample2, Nested:\n\n");
    char example_file [] = "ID;Day;Month;Year;Telephone;email;Date of registration\n" "1;Sunday;january;2009;123-124-456;jitter@go.xyz;2015-05-13\n" "2;Monday;March;2011;(+30)333-22-55;buffer@wl.it;2009-05-23";
    char **rows;
    int j;
    rows = NULL;
    getcols (example_file, "\n", & rows);
    for (i = 0; rows[i]; i++) {
        {
            printf ("Line[ %d ] = %s\n", i, rows [i]);
            char **columnX = NULL;
            getcols (rows [i], ";", & columnX);
            for (j = 0; columnX[j]; j++)
                printf ("  Col[ %d ] = %s\n", j, columnX[j]);
            free (columnX);
        }
    }
    free (rows);
    rows = NULL;
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    FILE *pfinput;
    unsigned int nSkipLines, currentLine, lenLongestValue;
    char *pTempValHolder;
    int c;
    unsigned int vcpm;
    int QuotationOnOff;
    nSkipLines = atoi (argv[2]);
    lenLongestValue = atoi (argv[3]);
    pTempValHolder = (char *) malloc (lenLongestValue);
    if (pfinput = fopen (argv[1], "r")) {
        rewind (pfinput);
        currentLine = 1;
        vcpm = 0;
        QuotationOnOff = 0;
        while ((c = fgetc (pfinput)) != EOF) {
            switch (c) {
            case ',' :
                if (!QuotationOnOff && currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = '\0';
                    printf ("%s,", pTempValHolder);
                    vcpm = 0;
                }
                break;
            case '\n' :
                if (currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = '\0';
                    printf ("%s\n", pTempValHolder);
                    vcpm = 0;
                }
                currentLine++;
                break;
            case '\"' :
                if (currentLine > nSkipLines) {
                    if (!QuotationOnOff) {
                        QuotationOnOff = 1;
                        pTempValHolder[vcpm] = c;
                        vcpm++;
                    }
                    else {
                        QuotationOnOff = 0;
                        pTempValHolder[vcpm] = c;
                        vcpm++;
                    }
                }
                break;
            default :
                if (currentLine > nSkipLines) {
                    pTempValHolder[vcpm] = c;
                    vcpm++;
                }
                break;
            }
        }
        fclose (pfinput);
        free (pTempValHolder);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12914917_43081001_109_142
12914917_45829947_113_152
Title: Using pointers to remove item from singly-linked list 
----------------------------------------

int main () {
    const int match_val = 2;
    {
        const int arr [] = {0, 1, 2, 3};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {0, 2, 2, 3};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {2, 7, 8, 2};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {2, 2, 3, 3};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {0, 0, 2, 2};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {2, 2, 2, 2};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    return 0;
}
----------------------------------------

int main () {
    LinkedList list;
    init_list (& list);
    Employee *samuel = (Employee *) malloc (sizeof (Employee));
    strcpy (samuel -> name, "Samuel");
    samuel->age = 23;
    Employee *sally = (Employee *) malloc (sizeof (Employee));
    strcpy (sally -> name, "Sally");
    sally->age = 19;
    Employee *susan = (Employee *) malloc (sizeof (Employee));
    strcpy (susan -> name, "Susan");
    susan->age = 14;
    Employee *jessie = (Employee *) malloc (sizeof (Employee));
    strcpy (jessie -> name, "Jessie");
    jessie->age = 18;
    add_head (& list, samuel);
    add_head (& list, sally);
    add_head (& list, susan);
    add_tail (& list, jessie);
    display_list (& list, (DISPLAY) display_employee);
    NODE *n = get_node (&list, (COMPARE) compare_employee, sally);
    printf ("name is %s, age is %d.\n", ((Employee *) n -> data) -> name, ((Employee *) n -> data) -> age);
    printf ("\n");
    delete_node (& list, samuel);
    display_list (& list, (DISPLAY) display_employee);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12914917_43081001_109_142
12914917_48846270_56_69
Title: Using pointers to remove item from singly-linked list 
----------------------------------------

int main () {
    const int match_val = 2;
    {
        const int arr [] = {0, 1, 2, 3};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {0, 2, 2, 3};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {2, 7, 8, 2};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {2, 2, 3, 3};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {0, 0, 2, 2};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {2, 2, 2, 2};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    {
        const int arr [] = {};
        CREATELIST_REMOVEMATCHELEMS_PRINT (arr, match_val);
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    node_t *head;
    head = create_list ();
    print_list (head);
    remove_from_list (8, & head);
    print_list (head);
    destroy_list (& head);
    assert (head == NULL);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12914917_43081001_34_46
12914917_48846270_10_24
Title: Using pointers to remove item from singly-linked list 
----------------------------------------

list_entry *create_list (const int arr [], size_t len) {
    if (len == 0) {
        return NULL;
    }
    list_entry *node = NULL;
    list_entry *head = node = new_node (node, arr[0]);
    for (size_t i = 1; i < len; ++i) {
        node = new_node (node, arr[i]);
    }
    return head;
}
----------------------------------------

node_t *create_list () {
    int test_values [] = {28, 1, 8, 70, 56};
    node_t *new_node, *head = NULL;
    int i;
    for (i = 0; i < 5; i++) {
        new_node = (node_t *) malloc (sizeof (struct node_t));
        assert (new_node);
        new_node->value = test_values[i];
        new_node->next = head;
        head = new_node;
    }
    return head;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12914917_45829947_113_152
12914917_48846270_56_69
Title: Using pointers to remove item from singly-linked list 
----------------------------------------

int main () {
    LinkedList list;
    init_list (& list);
    Employee *samuel = (Employee *) malloc (sizeof (Employee));
    strcpy (samuel -> name, "Samuel");
    samuel->age = 23;
    Employee *sally = (Employee *) malloc (sizeof (Employee));
    strcpy (sally -> name, "Sally");
    sally->age = 19;
    Employee *susan = (Employee *) malloc (sizeof (Employee));
    strcpy (susan -> name, "Susan");
    susan->age = 14;
    Employee *jessie = (Employee *) malloc (sizeof (Employee));
    strcpy (jessie -> name, "Jessie");
    jessie->age = 18;
    add_head (& list, samuel);
    add_head (& list, sally);
    add_head (& list, susan);
    add_tail (& list, jessie);
    display_list (& list, (DISPLAY) display_employee);
    NODE *n = get_node (&list, (COMPARE) compare_employee, sally);
    printf ("name is %s, age is %d.\n", ((Employee *) n -> data) -> name, ((Employee *) n -> data) -> age);
    printf ("\n");
    delete_node (& list, samuel);
    display_list (& list, (DISPLAY) display_employee);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    node_t *head;
    head = create_list ();
    print_list (head);
    remove_from_list (8, & head);
    print_list (head);
    destroy_list (& head);
    assert (head == NULL);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12948699_12948741_1_15
12948699_12948802_1_23
Title: Warning: return from incompatible pointer type in C 
----------------------------------------

char *filename (void) {
    const size_t max_fn = 16;
    char *dum;
    if ((dum = malloc (max_fn)) != NULL) {
        if (fgets (dum, max_fn, stdin) != dum) {
            free (dum);
            dum = NULL;
        }
    }
    return dum;
}
----------------------------------------

char *filename (int *i1) {
    char input [16];
    char *dum = (char *) malloc (16 * sizeof (char));
    if (dum == NULL) {
        printf ("Memory could not be allocated \n");
    }
    else {
        printf ("Memory was allocated – remember to free\n \n");
        *i1 = 1;
        fputs ("Input filename = ", stdout);
        fflush (stdout);
        fgets (input, sizeof (input), stdin);
        printf ("Filename = \"%s\"\n", input);
        return i1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12975022_12975180_1_19
12975022_12979321_12_43
Title: strtok_r for MinGW 
----------------------------------------

char *strtok_r (char *str, const char *delim, char **save) {
    char *res, *last;
    if (!save)
        return strtok (str, delim);
    if (!str && !(str = *save))
        return NULL;
    last = str + strlen (str);
    if ((*save = res = strtok (str, delim))) {
        *save += strlen (res);
        if (*save < last)
            (*save)++;
        else
            *save = NULL;
    }
    return res;
}
----------------------------------------

char *strtok_r (char *str, const char *delim, char **nextp) {
    char *ret;
    if (str == NULL) {
        str = *nextp;
    }
    str += strspn (str, delim);
    if (*str == '\0') {
        return NULL;
    }
    ret = str;
    str += strcspn (str, delim);
    if (*str) {
        *str++ = '\0';
    }
    *nextp = str;
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13011571_13011776_32_45
13011571_13012434_21_37
Title: Why is there an extra number? 
----------------------------------------

int main () {
    int day, month, year;
    printf ("Enter date in dd mm yyyy format: ");
    scanf ("%d %d %d", & day, & month, & year);
    getDay (day);
    getMonth (month);
    year;
    printf ("%d", year);
    fflush (stdin);
    getchar ();
}
----------------------------------------

int main () {
    int day;
    int month;
    int year;
    printf ("Enter date in dd mm yyyy format: ");
    scanf ("%d %d %d", & day, & month, & year);
    getchar ();
    printf ("%d%s ", day, get_day_str (day));
    printf ("%s ", get_month_str (month));
    printf ("%d", year);
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13011571_13011848_32_42
13011571_13012434_21_37
Title: Why is there an extra number? 
----------------------------------------

int main () {
    int day, month, year;
    printf ("Enter date in dd mm yyyy format: ");
    scanf ("%d %d %d", & day, & month, & year);
    getDay (day);
    getMonth (month);
    printf ("%d", year);
    fflush (stdin);
    getchar ();
}
----------------------------------------

int main () {
    int day;
    int month;
    int year;
    printf ("Enter date in dd mm yyyy format: ");
    scanf ("%d %d %d", & day, & month, & year);
    getchar ();
    printf ("%d%s ", day, get_day_str (day));
    printf ("%s ", get_month_str (month));
    printf ("%d", year);
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13012594_13012738_1_12
13012594_13012849_1_12
Title: Sorting with pointers instead of indexes 
----------------------------------------

void sort (int *pointer, int size) {
    int i, j, temp;
    for (i = 0; i < size; i++) {
        for (j = i + 1; j < size; j++) {
            if (*(pointer + j) < *(pointer + i)) {
                temp = *(pointer + j);
                *(pointer + j) = *(pointer + i);
                *(pointer + i) = temp;
            }
        }
    }
}
----------------------------------------

void sort (int *pointer, int size) {
    int *i, *j, temp;
    for (i = pointer; i < pointer + size; i++) {
        for (j = i + 1; j < pointer + size; j++) {
            if (*j < *i) {
                temp = *j;
                *j = *i;
                *i = temp;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13018224_13018501_3_17
13018224_43427603_1_20
Title: C: Getting Bad access upon trying to read int from .dat file 
----------------------------------------

int main (int argc, char *argv []) {
    FILE *fr = (FILE *) fopen ("test.dat", "r");
    int output;
    if (!feof (fr)) {
        do {fscanf (fr, "%d", & output);
        printf ("%d", output);
    }
    while (!feof (fr))
        ;
    fclose (fr);
    return 0;
}
----------------------------------------

enter code here int main (int argc, char *argv []) {
    int output;
    FILE *fr = fopen ("test.dat", "rb");
    if (ferror (fr) != 0) {
        fprintf (stderr, "Error in reading file.\n");
        exit (EXIT_FAILURE);
    }
    while (feof (fr) == 0) {
        fread (& output, sizeof (int), 1, fr);
        printf ("%d\n", output);
    }
    fclose (fr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13023384_13023452_11_21
13023384_13023456_6_18
Title: Changing int to double changes my result to zero 
----------------------------------------

int main (void) {
    int tableau [4] = {30, 50, 50};
    int x = 0;
    double average = 0;
    const int tailleTab = 4;
    sommeTableau (tableau, tailleTab, & x, & average);
    printf ("The average is %lf\n", average);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int tableau [4] = {30, 50, 50};
    int x = 0;
    double average = 0;
    const int tailleTab = 4;
    sommeTableau (tableau, tailleTab, & x, & average);
    printf ("The average is %lf\n", average);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13023384_13023452_11_21
13023384_13023501_6_18
Title: Changing int to double changes my result to zero 
----------------------------------------

int main (void) {
    int tableau [4] = {30, 50, 50};
    int x = 0;
    double average = 0;
    const int tailleTab = 4;
    sommeTableau (tableau, tailleTab, & x, & average);
    printf ("The average is %lf\n", average);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int tableau [4] = {30, 50, 50};
    int x = 0;
    int average = 0;
    const int tailleTab = 4;
    sommeTableau (tableau, tailleTab, & x, & average);
    printf ("The average is %d\n", average);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13023384_13023456_6_18
13023384_13023501_6_18
Title: Changing int to double changes my result to zero 
----------------------------------------

int main (int argc, char *argv []) {
    int tableau [4] = {30, 50, 50};
    int x = 0;
    double average = 0;
    const int tailleTab = 4;
    sommeTableau (tableau, tailleTab, & x, & average);
    printf ("The average is %lf\n", average);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int tableau [4] = {30, 50, 50};
    int x = 0;
    int average = 0;
    const int tailleTab = 4;
    sommeTableau (tableau, tailleTab, & x, & average);
    printf ("The average is %d\n", average);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13024450_13024681_12_46
13024450_13024842_10_39
Title: Tokenized string of char to ints using atoi 
----------------------------------------

int main (int argc, char *argv []) {
    char str [StrSZE];
    int maxChars = StrSZE - 1, cont = 1, numOfToken = 0, i = 0;
    int *data;
    char *tokenArray [50];
    strInput (str, maxChars);
    tokenArray[i] = strtok (str, " \t");
    while (tokenArray[i]) {
        printf ("token: %s\n", tokenArray [i]);
        i++;
        tokenArray[i] = strtok (NULL, " \t");
        numOfToken++;
    }
    data = (int *) malloc (numOfToken * sizeof (int));
    custatoi (tokenArray, data, numOfToken);
    printf ("data\n");
    for (i = 0; i < numOfToken; i++) {
        printf (" %d\n", data [i]);
    }
    system ("PAUSE");
    return 0;
}
----------------------------------------

int main (void) {
    char str [StrSZE];
    char **tokenArray;
    int numOfToken = 0, i;
    int *data;
    strcpy (str, "1 345 44 23");
    tokenArray = malloc (sizeof (char *));
    tokenArray[numOfToken] = strtok (str, " \t");
    while (tokenArray[numOfToken] != NULL) {
        printf ("token: %s\n", tokenArray [numOfToken]);
        numOfToken++;
        tokenArray = realloc (tokenArray, sizeof (char *) * (numOfToken + 1));
        tokenArray[numOfToken] = strtok (NULL, " \t");
    }
    data = malloc (numOfToken * sizeof (int));
    custatoi (tokenArray, data, numOfToken);
    for (i = 0; i < numOfToken; i++)
        printf ("data[%d]=%d\n", i, data[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13040037_13040109_3_12
13040037_13040135_3_15
Title: Making Variable Argument List function 
----------------------------------------

int lcdPrintf (char *format, ... ) {
    if (*format) {
        printf ("format is not NULL.\r\n");
    }
    else {
        printf ("format is NULL.\r\n");
    }
    return 1;
}
----------------------------------------

int lcdPrintf (char *format, ... ) {
    if (*format) {
        printf ("format is not NULL.\r\n");
    }
    else {
        printf ("format is NULL.\r\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1304387_1304426_1_14
1304387_1304565_1_16
Title: Pass-by-reference in C - downsides? 
----------------------------------------

int findChar (char ch, char *in, int *pos) {
    int i = 0;
    for (i = 0; in[i] != '\0'; i++) {
        if (in[i] == ch) {
            *pos = i;
            return 1;
        }
    }
    return 0;
}
----------------------------------------

int findChar (char ch, char const * const in, unsigned int * const index) {
    if (in != NULL && index != NULL) {
        unsigned int i;
        for (i = 0; in[i]; i++) {
            if (in[i] == ch) {
                *index = i;
                return EXIT_SUCCESS;
            }
        }
    }
    return EXIT_FAILURE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13099252_13099270_1_11
13099252_48140740_1_11
Title: Decimal to Binary on C library 
----------------------------------------

void dec2bin (int c) {
    int i = 0;
    for (i = 31; i >= 0; i--) {
        if ((c & (1 << i)) != 0) {
            printf ("1");
        }
        else {
            printf ("0");
        }
    }
}
----------------------------------------

int dec2bin (int n) {
    static int bin, osn = 1, c;
    if (n == 0)
        return 0;
    else {
        c = n % 2;
        bin += c * osn;
        osn *= 10;
        dec2bin (n / 2);
    }
    return bin;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13102277_13102448_30_42
13102277_13102624_29_49
Title: Sort an array by an index array in C 
----------------------------------------

int main () {
    char *items [] = {"D", "B", "E", "A", "C"};
    int sortedIndices [] = {3, 1, 4, 0, 2};
    int size = 5;
    sortItemsBasedOnIndices (items, sortedIndices, size);
    for (int i = 0; i < size; i++) {
        puts (items [i]);
    }
}
----------------------------------------

int main (void) {
    unsigned idx;
    char *array [5] = {"D", "A", "B", "E", "C"};
    int index [5] = {1, 2, 4, 0, 3};
    fprintf (stdout, "Original:\n");
    for (idx = 0; idx < 5; idx++) {
        fprintf (stdout, "[%u]:%s\n", idx, array [idx]);
    }
    fprintf (stdout, "Shuffle:\n");
    shuffle (array, index, 5);
    fprintf (stdout, "After shuffle:\n");
    for (idx = 0; idx < 5; idx++) {
        fprintf (stdout, "[%u]:%s\n", idx, array [idx]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13106108_13107554_13_26
13106108_13108436_4_31
Title: strcmp() and New Line Characters from Text File 
----------------------------------------

void process_file (const char *inp_file, FILE *otp_fp) {
    char line [256];
    FILE *inp_fp = fopen (inp_file, "r");
    if (inp_fp == NULL) {
        return;
    }
    while (fgets (line, 256, inp_fp) != NULL) {
        if (!str_is_whitespace (line)) {
            fprintf (otp_fp, "%s", line);
        }
    }
    fclose (inp_fp);
}
----------------------------------------

void process_file (const char *inp_file, FILE *otp_fp) {
    char line [256];
    FILE *inp_fp;
    size_t len;
    inp_fp = fopen (inp_file, "r");
    if (!inp_fp)
        return;
    while (fgets (line, 256, inp_fp) != NULL) {
        len = strlen (line);
        while (len && (line[len - 1] == '\n' || line[len - 1] == '\r')) {
            line[--len] = 0;
        }
        if (!len)
            continue;
        fprintf (otp_fp, "%s\n", line);
    }
    fclose (inp_fp);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13110693_13110756_7_13
13110693_13110775_8_20
Title: displaying words from a txt file in c/c++ 
----------------------------------------

int main () {
std :
    : ifstream file ("test.txt");
std :
    : istream_iterator < std : : string > begin (file), end;
    for (; begin != end; ++begin)
    std :
    : cout << * begin << '\n';
}
----------------------------------------

int main () {
    clrscr ();
    string s;
    ifstream in ("file.txt");
    while (in >> s) {
        cout << s << endl;
    }
    in.close ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13112797_13113285_20_72
13112797_13113354_55_68
Title: Creating a binary search tree in C99 
----------------------------------------

int main (int argc, char **argv) {
    FILE *in = NULL;
    int num_read, count = 0, array_size = 0;
    if (argc != 2) {
        printf ("hw3 <input-file>\n");
        return 1;
    }
    in = fopen (argv[1], "r");
    if (in == NULL) {
        printf ("File can not be opened.\n");
        return 2;
    }
    fscanf (in, "%d", & array_size);
    int array [array_size];
    while (count < array_size && fscanf (in, "%d", &num_read) == 1)
        array[count++] = num_read;
    fclose (in);
    if (array_size != count) {
        printf ("data error. Make sure the first line specifies the correct number of elements.");
        return 3;
    }
    for (int i = 0; i < array_size; i++)
        printf ("%d: %d\n", i, array[i]);
    Node *root1 = NULL;
    printf ("=== task1: construct a bst from the unsorted array ===\n");
    for (int i = 0; i < array_size; i++) {
        root1 = bstInsert (root1, array[i]);
        displayTree (root1, 0);
    }
    displayTree (root1, 0);
    return 0;
}
----------------------------------------

int main () {
    size_t n = sizeof (nums) / sizeof (*nums);
    int i;
    node *tree = NULL;
    for (i = 0; i < n; i++) {
        insert (& tree, node_new (nums [i]));
    }
    dump (tree, 0);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13114301_13114354_5_14
13114301_13129698_9_22
Title: raw terminal mode - how to take in input? 
----------------------------------------

int main (int argc, char **argv) {
    while (1) {
        char *line = readline ("><![CDATA[ ");
        if (!line)
            break;
        if (*line)
            add_history (line);
    }
}
----------------------------------------

int main (void) {
    int ch;
    changemode (1);
    while (!kbhit ())
        ;
    ch = getchar ();
    printf ("\nGot %c\n", ch);
    changemode (0);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13116483_13116622_1_15
13116483_23724500_5_26
Title: concatenate each value of argv with a string 
----------------------------------------

int main (int argc, char *argv []) {
    char *buffer;
    char command [512];
    int i = 1;
    for (i = 1; i < argc; i++) {
        buffer = malloc (strlen (argv[i]) + 5);
        strcpy (buffer, argv [i]);
        strcat (buffer, ".txt");
        sprintf (command, "touch %s\0", buffer);
        system (command);
        free (buffer);
    }
    return 0;
}
----------------------------------------

int main (int argc, int *argv []) {
    if (argc == 1) {
        printf ("You have not entered anything!\n");
        return 0;
    }
    char *arr = malloc (1000 * sizeof (char));
    int i;
    strcat (arr, argv [0]);
    strcat (arr, " ");
    for (i = 0; i < argc - 1; i++) {
        strcat (arr, argv [i + 1]);
        strcat (arr, ".txt");
        strcat (arr, " ");
        strcat (arr, "\0");
    }
    printf ("%s\n", arr);
    free (arr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13128584_13128744_4_26
13128584_13128891_3_15
Title: Small bug in my short C code. Why? 
----------------------------------------

int main (void) {
    float fchange = 0.00;
    int change = 0;
    printf ("How much change is owed? ");
    fchange = GetFloat ();
    change = (int) roundf (fchange *100.0);
    int quarters = change / 25;
    change = change % 25;
    int dimes = change / 10;
    change = change % 10;
    int nickels = change / 5;
    change = change % 5;
    printf ("%d quarters, %d dimes, %d nickels, %d pennies\n", quarters, dimes, nickels, change);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    float change = atof (argv[1]);
    int work = (int) (100 * change + 0.5);
    int quarters, dimes, nickels, pennies;
    quarters = work / 25;
    work %= 25;
    dimes = work / 10;
    work %= 10;
    nickels = work / 5;
    work %= 5;
    pennies = work;
    printf ("%.2f dollars = %d quarters, %d dimes, %d nickels and %d pennies: %d coins total\n", change, quarters, dimes, nickels, pennies, quarters + dimes + nickels + pennies);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13134310_13136146_1_12
13134310_13136421_4_26
Title: Digit-increasing number test 
----------------------------------------

bool isDigitIncreasing (const int num) {
    int n = 1;
    int sum = 1;
    while (n <= num) {
        if (num % n == 0 && n * 10 > num)
            return true;
        sum = sum * 10 + 1;
        n += sum;
    }
    return false;
}
----------------------------------------

public bool isDigitIncreasing (int input_number) {
    int n = get_number_of_digit (input_number);
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum = sum * 10 + 1;
        count = count + sum;
    }
    for (int i = 1; i <= 9; i++) {
        if ((input_number) == count * i) {
            flag = true;
            break;
        }
        else
            flag = false;
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13134310_13136146_1_12
13134310_13320849_1_26
Title: Digit-increasing number test 
----------------------------------------

bool isDigitIncreasing (const int num) {
    int n = 1;
    int sum = 1;
    while (n <= num) {
        if (num % n == 0 && n * 10 > num)
            return true;
        sum = sum * 10 + 1;
        n += sum;
    }
    return false;
}
----------------------------------------

public boolean isDigitIncreasing (int number) {
    int sum;
    int size = calculateNumberOfDigits (number);
    for (int i = 1; i <= 9; i++) {
        sum = 0;
        int temp = size;
        while (temp >= 1) {
            for (int j = temp; j <= 1; j--) {
                sum = sum + i * (int) Math.pow (10, j -1);
            }
            temp--;
        }
        if (sum == number) {
            return true;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13134310_13136146_1_12
13134310_49370284_1_24
Title: Digit-increasing number test 
----------------------------------------

bool isDigitIncreasing (const int num) {
    int n = 1;
    int sum = 1;
    while (n <= num) {
        if (num % n == 0 && n * 10 > num)
            return true;
        sum = sum * 10 + 1;
        n += sum;
    }
    return false;
}
----------------------------------------

public static int isDigitIncreasing (int n) {
    if (n < 10) {
        return 1;
    }
    for (int i = 1; i <= 9; i++) {
        int tempsum = i;
        int previous = i;
        while (tempsum <= n) {
            previous = previous * 10 + i;
            tempsum = tempsum + previous;
            if (tempsum == n) {
                return 1;
            }
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13134310_13136421_4_26
13134310_13320849_1_26
Title: Digit-increasing number test 
----------------------------------------

public bool isDigitIncreasing (int input_number) {
    int n = get_number_of_digit (input_number);
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum = sum * 10 + 1;
        count = count + sum;
    }
    for (int i = 1; i <= 9; i++) {
        if ((input_number) == count * i) {
            flag = true;
            break;
        }
        else
            flag = false;
    }
    return flag;
}
----------------------------------------

public boolean isDigitIncreasing (int number) {
    int sum;
    int size = calculateNumberOfDigits (number);
    for (int i = 1; i <= 9; i++) {
        sum = 0;
        int temp = size;
        while (temp >= 1) {
            for (int j = temp; j <= 1; j--) {
                sum = sum + i * (int) Math.pow (10, j -1);
            }
            temp--;
        }
        if (sum == number) {
            return true;
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13134310_13136421_4_26
13134310_49370284_1_24
Title: Digit-increasing number test 
----------------------------------------

public bool isDigitIncreasing (int input_number) {
    int n = get_number_of_digit (input_number);
    int sum = 0;
    for (int i = 0; i < n; i++) {
        sum = sum * 10 + 1;
        count = count + sum;
    }
    for (int i = 1; i <= 9; i++) {
        if ((input_number) == count * i) {
            flag = true;
            break;
        }
        else
            flag = false;
    }
    return flag;
}
----------------------------------------

public static int isDigitIncreasing (int n) {
    if (n < 10) {
        return 1;
    }
    for (int i = 1; i <= 9; i++) {
        int tempsum = i;
        int previous = i;
        while (tempsum <= n) {
            previous = previous * 10 + i;
            tempsum = tempsum + previous;
            if (tempsum == n) {
                return 1;
            }
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13134310_13320849_1_26
13134310_49370284_1_24
Title: Digit-increasing number test 
----------------------------------------

public boolean isDigitIncreasing (int number) {
    int sum;
    int size = calculateNumberOfDigits (number);
    for (int i = 1; i <= 9; i++) {
        sum = 0;
        int temp = size;
        while (temp >= 1) {
            for (int j = temp; j <= 1; j--) {
                sum = sum + i * (int) Math.pow (10, j -1);
            }
            temp--;
        }
        if (sum == number) {
            return true;
        }
    }
    return false;
}
----------------------------------------

public static int isDigitIncreasing (int n) {
    if (n < 10) {
        return 1;
    }
    for (int i = 1; i <= 9; i++) {
        int tempsum = i;
        int previous = i;
        while (tempsum <= n) {
            previous = previous * 10 + i;
            tempsum = tempsum + previous;
            if (tempsum == n) {
                return 1;
            }
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13141352_13167592_5_28
13141352_47970830_3_20
Title: "How to iterate over the series: 0 1 2 3 4 4 5 6 7 7 8 7 8 8 9 … without using recursion?" 
----------------------------------------

int main () {
    int ik, it, icount = 0, ih, temp, ig = 1;
    int aisum [100];
    aisum[0] = 0;
    scanf ("%d", & in);
    printf ("0\n");
    it = 1;
    ih = 0;
    temp = 2;
    for (icount = 0, ig = 1; icount <= in; icount++) {
        for (ik = 0; ik < 2; ik++) {
            aisum[ig] = aisum[icount] + it + ik;
            printf ("%d ", aisum [ig]);
            ig++;
        }
        if (aisum[icount] == ih) {
            printf ("\n");
            it++;
            ih += temp;
            temp++;
        }
    }
    return 0;
}
----------------------------------------

int main () {
    int start = 1, end = 2, count = 1;
    cout << 0 << " ";
    while (count < 5) {
        cout << start << " ";
        for (int i = start + 1; i < end; i++) {
            cout << i << " " << i << " ";
        }
        cout << end << " ";
        count++;
        start = end + 1;
        end = start + count;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13148061_13148159_1_20
13148061_13148246_6_15
Title: easier way to write loops 
----------------------------------------

int main () {
    int i, j;
    for (i = 0; i <= 5; ++i) {
        for (j = 0; j <= i; ++j)
            printf ("%d", j);
        printf ("\n");
    }
    for (i = 4; i >= 0; --i) {
        for (j = 0; j <= i; ++j)
            printf ("%d", j);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i, j;
    for (i = 0; i < 2 * MAX_VAL; i++) {
        for (j = 0; j < MAX_VAL - abs (MAX_VAL -i); j++) {
            printf ("%d", j);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13148061_13148159_1_20
13148061_13148553_4_18
Title: easier way to write loops 
----------------------------------------

int main () {
    int i, j;
    for (i = 0; i <= 5; ++i) {
        for (j = 0; j <= i; ++j)
            printf ("%d", j);
        printf ("\n");
    }
    for (i = 4; i >= 0; --i) {
        for (j = 0; j <= i; ++j)
            printf ("%d", j);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int j = 0, m = 0, dec = 0;
    while (m >= 0 && m <= MAX) {
        for (j = 0; j <= m; j++)
            printf ("%d", j);
        printf ("\n");
        if (m == MAX)
            dec = 1;
        (dec) ? m-- : m++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13148061_13148246_6_15
13148061_13148553_4_18
Title: easier way to write loops 
----------------------------------------

int main (void) {
    int i, j;
    for (i = 0; i < 2 * MAX_VAL; i++) {
        for (j = 0; j < MAX_VAL - abs (MAX_VAL -i); j++) {
            printf ("%d", j);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int j = 0, m = 0, dec = 0;
    while (m >= 0 && m <= MAX) {
        for (j = 0; j <= m; j++)
            printf ("%d", j);
        printf ("\n");
        if (m == MAX)
            dec = 1;
        (dec) ? m-- : m++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13162464_13163087_8_22
13162464_13170112_1_15
Title: Writing MIPS machine instructions and executing them from C 
----------------------------------------

void inc () {
    int i = 41;
    uint32_t *addone = malloc (sizeof (*addone) * 2);
    *(addone) = 0x20820001;
    *(addone + 1) = 0x23e00000;
    pagesize = sysconf (_SC_PAGESIZE);
    mprotect (PALIGN (addone), PALIGN (addone + 1) - PALIGN (addone) + pagesize, PROT_READ | PROT_WRITE | PROT_EXEC);
    cacheflush (addone, 2 * sizeof (* addone), ICACHE | DCACHE);
    int (*f) (int x) = addone;
    i = (*f) (i);
    printf ("%d", i);
}
----------------------------------------

int inc () {
    volatile int i = 41;
    volatile int *addone = malloc (sizeof (*addone) * 8);
    *(addone) = 0x20820001;
    *(addone + 1) = 0x23e00000;
    asm volatile ("synci 0(%0)"
        :
        : "r" (addone)
    ) volatile int (*f) (int x) = addone;
    int j = (*f) (i);
    return j;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13189201_13190273_6_21
13189201_13190544_2_19
Title: "Decimal To Octal Converter last digit issue" 
----------------------------------------

int main () {
    int n, x, y, p;
    double s = 0;
    printf ("Enter a decimal number ");
    scanf ("%d", & x);
    p = 0;
    while (x != 0) {y = x % 8;
    s = s + (double) y * pow (10, p);
    x = (x - y) / 8;
    p = p + 1;
}
----------------------------------------

int main () {
    int d_num = 0;
    int o_num = 0;
    int factor = 1;
    printf ("Enter a decimal number: ");
    scanf ("%d", & d_num);
    while (d_num > 0) {
        o_num += d_num % 8 * factor;
        d_num /= 8;
        factor *= 10;
    }
    printf ("Octal equivalent: %d\n", o_num);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13204876_13204992_1_13
13204876_13205311_4_17
Title: Convert comma separated string to double 
----------------------------------------

int main () {
    char str [] = "- This, a sample string.";
    char *pch;
    printf ("Splitting string \"%s\" into tokens:\n", str);
    pch = strtok (str, " ,.-");
    while (pch != NULL) {
        printf ("%s\n", pch);
        pch = strtok (NULL, " ,.-");
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *p;
    double val;
    char str [] = "  102.33, 220.44";
    int n = sscanf (str, "%lf", &val);
    printf ("Value = %lf  sscanf returned %d\n", val, n);
    val = strtod (str, &p);
    printf ("Value = %lf  p points to: '%s'\n", val, p);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13207541_13207742_1_38
13207541_13207752_1_34
Title: Pointer address is not incrementing 
----------------------------------------

char *squeeze (char *str, int start_index, int end_index, char *ref_str) {
    char *substr = substring (str, start_index, end_index);
    char *squeezed_str;
    squeezed_str = malloc (strlen (str) +1);
    if (squeezed_str == NULL) {
        printf ("Unable to allocate memory!\n");
        exit (EXIT_FAILURE);
    }
    int substr_len = strlen (substr);
    int refstr_len = strlen (ref_str);
    int squeezeStrIdx = 0;
    for (int i = 0; i < substr_len; i++) {
        char chr1 = substr[i];
        char chr2 = '\0';
        for (int j = 0; j < refstr_len; j++) {
            chr2 = ref_str[j];
            if (chr1 == chr2) {
                break;
            }
        }
        if (chr1 != chr2) {
            squeezed_str[squeezeStrIdx] = chr1;
            squeezeStrIdx++;
        }
    }
    squeezed_str[squeezeStrIdx] = '\0';
    return squeezed_str;
}
----------------------------------------

char *squeeze (const char *str, size_t start_index, size_t end_index, const char *ref_str) {
    char *substr;
    char *squeezed_str = malloc (sizeof (*squeezed_str));
    if (!squeezed_str) {
        fprintf (stderr, "Unable to allocate memory!\n");
        exit (EXIT_FAILURE);
    }
    substr = substring (str, start_index, end_index);
    size_t substr_len = strlen (substr);
    size_t refstr_len = strlen (ref_str);
    char chr1 = 0, chr2 = 0;
    char *squeezed_copy = squeezed_str;
    for (size_t i = 0; i < substr_len; i++) {
        chr1 = substr[i];
        for (size_t j = 0; j < refstr_len; j++) {
            chr2 = ref_str[j];
            if (chr1 == chr2) {
                break;
            }
        }
        if (chr1 != chr2)
            *squeezed_copy++ = substr[i];
    }
    *squeezed_copy++ = 0;
    return squeezed_str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13213422_19565575_6_29
13213422_30994603_10_27
Title: Count the number of occurrences of each letter in string 
----------------------------------------

int main () {
    FILE *fp;
    int count [26] = {0}, i, c;
    char ch;
    char alpha [27] = "abcdefghijklmnopqrstuwxyz";
    fp = fopen (filename, "r");
    if (fp == NULL)
        printf ("file not found\n");
    while ((ch = fgetc (fp)) != EOF) {
        c = 0;
        while (alpha[c] != '\0') {
            if (alpha[c] == ch) {
                count[c]++;
            }
            c++;
        }
    }
    for (i = 0; i < 26; i++) {
        printf ("character %c occured %d number of times\n", alpha [i], count [i]);
    }
    return 0;
}
----------------------------------------

int main () {
    char string [100];
    int count [26] = {0};
    int i;
    printf ("Input a string: ");
    if (!fgets (string, sizeof string, stdin))
        return 1;
    find_frequency (string, count);
    printf ("Character Counts\n");
    for (i = 0; i < 26; i++) {
        printf ("%c\t%d\n", letters [i], count [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13213422_19565575_6_29
13213422_35369008_1_24
Title: Count the number of occurrences of each letter in string 
----------------------------------------

int main () {
    FILE *fp;
    int count [26] = {0}, i, c;
    char ch;
    char alpha [27] = "abcdefghijklmnopqrstuwxyz";
    fp = fopen (filename, "r");
    if (fp == NULL)
        printf ("file not found\n");
    while ((ch = fgetc (fp)) != EOF) {
        c = 0;
        while (alpha[c] != '\0') {
            if (alpha[c] == ch) {
                count[c]++;
            }
            c++;
        }
    }
    for (i = 0; i < 26; i++) {
        printf ("character %c occured %d number of times\n", alpha [i], count [i]);
    }
    return 0;
}
----------------------------------------

void main () {
    int i, j;
    int c [26], count = 0;
    char a [] = "shahid";
    clrscr ();
    for (i = 0; i < 26; i++) {
        count = 0;
        for (j = 0; j < strlen (a); j++) {
            if (a[j] == 97 + i) {
                count++;
            }
        }
        c[i] = count;
    }
    for (i = 0; i < 26; i++) {
        j = 97 + i;
        if (c[i] != 0) {
            printf ("%c of %d times\n", j, c [i]);
        }
    }
    getch ();
}
----------------------------------------
