$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23255608_23255742_4_13
23255608_23256031_17_32
Title: How to have an array of functions that returns pointers of ints 
----------------------------------------

int main (void) {
    int * (*fx [2]) (void);
    fx[0] = first;
    fx[1] = second;
    if (fx[0] () == fx[1] ()) {
        printf ("Calling both functions returns the same value.\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i;
    mathOps[ADD] = add_;
    mathOps[SUB] = sub_;
    mathOps[MUL] = mul_;
    mathOps[DIV] = div_;
    for (i = ADD; i <= DIV; i++) {
        printf ("results are: %d\n", mathOps [i] (3, 3));
    }
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23257216_23257481_7_17
23257216_23257593_7_43
Title: How to replace a substring in C when the substring is similar to the replacement string? 
----------------------------------------

char *searchAndReplace (char *text, char *search, char *replace) {
    char buffer [MAX_L];
    char *ptr;
    if (!(ptr = strstr (text, search))) {
        return NULL;
    }
    strncpy (buffer, text, ptr - text);
    sprintf (buffer + (ptr - text), "%s%s", replace, ptr + strlen (search));
    strcpy (text, buffer);
    return ptr + strlen (search);
}
----------------------------------------

char *searchAndReplace (char *text, char *search, char *replace) {
    char buffer [MAX_L];
    char *ptr;
    char *modText = NULL;
    buffer[0] = '\0';
    while (ptr = strstr (text, search)) {
        strncat (buffer, text, ptr - text);
        strcat (buffer, replace);
        text = ptr + 1;
    }
    strcat (buffer, text);
    modText = malloc (strlen (buffer) +1);
    strcpy (modText, buffer);
    return modText;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23269143_23269732_50_59
23269143_30816418_40_59
Title: c program that converts numbers to roman numerals 
----------------------------------------

int main () {
    int i, number [] = {25, 13, 93, 66};
    char buff [16];
    for (i = 0; i < 4; ++i) {
        if (roman (number[i], buff))
            printf ("%d is %s\n", number[i], buff);
    }
    return 0;
}
----------------------------------------

int main (int argc, char const *argv []) {
    int number;
    char *result;
    printf ("Input a decimal number: ");
    scanf ("%d", & number);
    if (number < 0 || number > 3999) {
        printf ("Input must be within the range from 1 to 3999.\n");
        return -1;
    }
    result = intToRoman (number);
    puts (result);
    free (result);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23277840_23277886_1_14
23277840_23278046_1_17
Title: Is there a O(n) way to draw a 2-D array grid instead of O(nÂ²) in C? 
----------------------------------------

void ShowGrid () {
    const int H = grid.height;
    const int W = grid.width;
    int n;
    for (n = 0; n < H * W; ++n) {
        int y = n / W;
        int x = n % W;
        printf ("%d", arr2_get (& grid, x, y));
        printf ("\n")
        if x == W - 1;
    }
}
----------------------------------------

void ShowGrid (void) {
    int i;
    for (i = 0; i < grid.width * grid.height; i++) {
        int x = i % grid.width;
        int y = i / grid.width;
        printf ("%d", arr2_get (& grid, x, y));
        if (x == grid.width - 1)
            printf ("\n");
    }
    printf ("\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23280119_23280538_4_37
23280119_23280658_7_63
Title: Get substrings from string in C 
----------------------------------------

int main (int argc, char *argv []) {
    char path [] = "./home/user/dir1/dir2";
    char *start = path;
    char *end = start + strlen (path);
    while (start < end) {
        char *slash = strchr (start, '/');
        if (slash) {
            if (slash > path && *(slash - 1) == '\\') {
                start = slash + 1;
                continue;
            }
            *slash = 0;
        }
        if (strcmp (start, ".") != 0) {
            printf ("going to make %s\n", path);
        }
        if (!slash) {
            break;
        }
        *slash = '/';
        start = slash + 1;
    }
    return 0;
}
----------------------------------------

int main () {
    char s [] = "./home/user/dir1/dir2/";
    char **tmp;
    int i, j;
    int size = 0;
    char *token;
    char c = s[0];
    int count = 0;
    i = 0;
    while (c != '\0') {
        if (s[i] == '/')
            count++;
        i++;
        c = s[i];
    }
    size = i;
    tmp = (char **) malloc (count);
    for (i = 0; i < count; i++) {
        tmp[i] = (char *) malloc (BUF_SIZE);
        for (j = 0; j < BUF_SIZE; ++j)
            tmp[i][j] = '\0';
    }
    tmp[0][0] = '.';
    tmp[0][1] = '/';
    i = 0;
    token = strtok (s, "./");
    while (token != NULL) {
        if (i > 0)
            strcat (tmp[i], tmp[i - 1]);
        strcat (tmp [i], token);
        strcat (tmp [i], "/");
        printf ("%s\n", tmp [i]);
        token = strtok (NULL, "/");
        i++;
    }
    for (i = 0; i < count; i++)
        free (tmp[i]);
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23280119_23280538_4_37
23280119_23280808_17_36
Title: Get substrings from string in C 
----------------------------------------

int main (int argc, char *argv []) {
    char path [] = "./home/user/dir1/dir2";
    char *start = path;
    char *end = start + strlen (path);
    while (start < end) {
        char *slash = strchr (start, '/');
        if (slash) {
            if (slash > path && *(slash - 1) == '\\') {
                start = slash + 1;
                continue;
            }
            *slash = 0;
        }
        if (strcmp (start, ".") != 0) {
            printf ("going to make %s\n", path);
        }
        if (!slash) {
            break;
        }
        *slash = '/';
        start = slash + 1;
    }
    return 0;
}
----------------------------------------

int main () {
    char path [] = "./home/user/dir1/dir2/";
    size_t count = countInstances (path, '/');
    char **dirs = malloc (sizeof (*dirs) * count);
    char *dir;
    size_t i = 0;
    dir = strtok (path, "/");
    while (dir && i < count) {
        dirs[i] = dir;
        printf ("%s\n", dir);
        dir = strtok (NULL, "/");
        i++;
    }
    free (dirs);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23280119_23280658_7_63
23280119_23280808_17_36
Title: Get substrings from string in C 
----------------------------------------

int main () {
    char s [] = "./home/user/dir1/dir2/";
    char **tmp;
    int i, j;
    int size = 0;
    char *token;
    char c = s[0];
    int count = 0;
    i = 0;
    while (c != '\0') {
        if (s[i] == '/')
            count++;
        i++;
        c = s[i];
    }
    size = i;
    tmp = (char **) malloc (count);
    for (i = 0; i < count; i++) {
        tmp[i] = (char *) malloc (BUF_SIZE);
        for (j = 0; j < BUF_SIZE; ++j)
            tmp[i][j] = '\0';
    }
    tmp[0][0] = '.';
    tmp[0][1] = '/';
    i = 0;
    token = strtok (s, "./");
    while (token != NULL) {
        if (i > 0)
            strcat (tmp[i], tmp[i - 1]);
        strcat (tmp [i], token);
        strcat (tmp [i], "/");
        printf ("%s\n", tmp [i]);
        token = strtok (NULL, "/");
        i++;
    }
    for (i = 0; i < count; i++)
        free (tmp[i]);
    getchar ();
    return 0;
}
----------------------------------------

int main () {
    char path [] = "./home/user/dir1/dir2/";
    size_t count = countInstances (path, '/');
    char **dirs = malloc (sizeof (*dirs) * count);
    char *dir;
    size_t i = 0;
    dir = strtok (path, "/");
    while (dir && i < count) {
        dirs[i] = dir;
        printf ("%s\n", dir);
        dir = strtok (NULL, "/");
        i++;
    }
    free (dirs);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2328258_23119456_1_43
2328258_2329269_3_24
Title: Cumulative Normal Distribution Function in C/C++ 
----------------------------------------

double phi (double x) {
    static const double RT2PI = sqrt (4.0 * acos (0.0));
    static const double SPLIT = 7.07106781186547;
    static const double N0 = 220.206867912376;
    static const double N1 = 221.213596169931;
    static const double N2 = 112.079291497871;
    static const double N3 = 33.912866078383;
    static const double N4 = 6.37396220353165;
    static const double N5 = 0.700383064443688;
    static const double N6 = 3.52624965998911e-02;
    static const double M0 = 440.413735824752;
    static const double M1 = 793.826512519948;
    static const double M2 = 637.333633378831;
    static const double M3 = 296.564248779674;
    static const double M4 = 86.7807322029461;
    static const double M5 = 16.064177579207;
    static const double M6 = 1.75566716318264;
    static const double M7 = 8.83883476483184e-02;
    const double z = fabs (x);
    double c = 0.0;
    if (z <= 37.0) {
        const double e = exp (-z * z / 2.0);
        if (z < SPLIT) {
            const double n = (((((N6 * z + N5) * z + N4) * z + N3) * z + N2) * z + N1) * z + N0;
            const double d = ((((((M7 * z + M6) * z + M5) * z + M4) * z + M3) * z + M2) * z + M1) * z + M0;
            c = e * n / d;
        }
        else {
            const double f = z + 1.0 / (z + 2.0 / (z + 3.0 / (z + 4.0 / (z + 13.0 / 20.0))));
            c = e / (RT2PI * f);
        }
    }
    return x <= 0.0 ? c : 1 - c;
}
----------------------------------------

double phi (double x) {
    double a1 = 0.254829592;
    double a2 = -0.284496736;
    double a3 = 1.421413741;
    double a4 = -1.453152027;
    double a5 = 1.061405429;
    double p = 0.3275911;
    int sign = 1;
    if (x < 0)
        sign = -1;
    x = fabs (x) / sqrt (2.0);
    double t = 1.0 / (1.0 + p * x);
    double y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * exp (-x * x);
    return 0.5 * (1.0 + sign * y);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23317893_23318205_7_32
23317893_23319163_6_36
Title: Reading Text In C 
----------------------------------------

int main () {
    int JourneyId;
    char Date [MAX];
    int Hour;
    char BusDriver [MAX];
    char Departure [MAX];
    char Destination [MAX];
    int BusCapacity;
    FILE *file;
    file = fopen ("Journey.txt", "rt");
    if (file) {
        while (fscanf (file, "%d,%11[^,],%d,%20[^,],%20[^,],%20[^,],%d", &JourneyId, Date, &Hour, BusDriver, Departure, Destination, &BusCapacity) != EOF) {
            printf ("%d,", JourneyId);
            printf ("%s", BusDriver);
        }
    }
    else {
        printf ("Error");
    }
    return 1;
}
----------------------------------------

int main () {
    int JourneyId;
    char Date [MAX];
    int Hour;
    char BusDriver [MAX];
    char Departure [MAX];
    char Destination [MAX];
    int BusCapacity;
    FILE *file;
    file = fopen ("Journey.txt", "rt");
    if (file) {
        char buf [MAX * 4 + 20 * 3 + 6 * 1 + 3];
        while (fgets (buf, sizeof buf, stdin) != NULL) {
            int cnt = sscanf (buf, "%d,%499[^,],%d,%499[^,],%499[^,],%499[^,],%d", &JourneyId, Date, &Hour, BusDriver, Departure, Destination, &BusCapacity);
            if (cnt != 7) {
                printf ("Unexpected input \"%s\"", buf);
                break;
            }
            printf ("%d,", JourneyId);
            printf ("%s\n", BusDriver);
        }
        fclose (file);
    }
    else {
        printf ("Error opening\n");
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23351053_23351186_60_72
23351053_23351194_1_19
Title: Cannot get input from user to work in place of manual strings entered in code 
----------------------------------------

int main (void) {
    struct llist *root = NULL;
    char string;
    while ((string = getchar ()) != '\n') {
        add (& root, string, compare);
    }
    display (root);
    return 0;
}
----------------------------------------

int main (void) {
    struct llist *root = NULL;
    char string [2];
    string[1] = '\0';
    printf ("Please enter a string to be sorted alphabetically and displayed with a character count: ");
    string[0] = getchar ();
    while (string != '\n') {
        add (& root, string, compare);
        string[0] = getchar ();
    }
    display (root);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23351053_23351186_60_72
23351053_23353769_48_65
Title: Cannot get input from user to work in place of manual strings entered in code 
----------------------------------------

int main (void) {
    struct llist *root = NULL;
    char string;
    while ((string = getchar ()) != '\n') {
        add (& root, string, compare);
    }
    display (root);
    return 0;
}
----------------------------------------

int main (void) {
    struct llist *root = NULL;
    char string [2];
    string[1] = '\0';
    printf ("Please enter a string to be sorted alphabetically" " and displayed with a character count: ");
    int ch;
    while ((ch = getchar ()) != EOF && ch != '\n' && ch != '\0') {
        string[0] = ch;
        add (& root, string, compare);
    }
    display (root);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23351053_23351194_1_19
23351053_23353769_48_65
Title: Cannot get input from user to work in place of manual strings entered in code 
----------------------------------------

int main (void) {
    struct llist *root = NULL;
    char string [2];
    string[1] = '\0';
    printf ("Please enter a string to be sorted alphabetically and displayed with a character count: ");
    string[0] = getchar ();
    while (string != '\n') {
        add (& root, string, compare);
        string[0] = getchar ();
    }
    display (root);
    return 0;
}
----------------------------------------

int main (void) {
    struct llist *root = NULL;
    char string [2];
    string[1] = '\0';
    printf ("Please enter a string to be sorted alphabetically" " and displayed with a character count: ");
    int ch;
    while ((ch = getchar ()) != EOF && ch != '\n' && ch != '\0') {
        string[0] = ch;
        add (& root, string, compare);
    }
    display (root);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2336242_20634902_1_14
2336242_9210960_1_12
Title: Recursive mkdir() system call on Unix 
----------------------------------------

int mkpath (char *dir, mode_t mode) {
    if (!dir) {
        errno = EINVAL;
        return 1;
    }
    if (strlen (dir) == 1 && dir[0] == '/')
        return 0;
    mkpath (dirname (strdupa (dir)), mode);
    return mkdir (dir, mode);
}
----------------------------------------

int mkpath (char *file_path, mode_t mode) {
    assert (file_path && * file_path);
    char *p;
    for (p = strchr (file_path +1, '/'); p; p = strchr (p +1, '/')) {
        *p = '\0';
        if (mkdir (file_path, mode) == -1) {
            if (errno != EEXIST) {
                *p = '/';
                return -1;
            }
        }
        *p = '/';
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23364684_23365089_12_21
23364684_23366334_40_53
Title: How to copy a multidimentional string in C 
----------------------------------------

int main () {
    char (*d) [10] [10] [100] = simar ();
    printf ("\n%s", (* d) [0] [0]);
    printf ("\n%s", (* d) [0] [1]);
    printf ("\n%s", (* d) [0] [2]);
    printf ("\n%s", (* d) [1] [0]);
    free (d);
    return 0;
}
----------------------------------------

int main () {
    int a [] = {1, 2, 3};
    int b [] = {4, 5, 6};
    char ***d = simar (a, b);
    printf ("\n%s", * (* (d + 0) + 0));
    printf ("\n%s", * (* (d + 0) + 1));
    printf ("\n%s", * (* (d + 0) + 2));
    printf ("\n%s", * (* (d + 1) + 0));
    printf ("\n%s", * (* (d + 1) + 1));
    printf ("\n%s", * (* (d + 1) + 2));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23376338_23377682_40_132
23376338_23386749_45_76
Title: Align text by 16 characters 
----------------------------------------

char *align_text (char *text) {
    int col, row;
    char *fit_text, *ret_text;
    char *np;
    char line [cols + 1];
    char *ptext;
    ptext = malloc (strlen (text) +1);
    strcpy (ptext, text);
    ret_text = fit_text = malloc (cols *rows + 1);
    line[col = 0] = '\0';
    row = 0;
    for (np = strtok (ptext, " "); (np != NULL) && (row < rows); np = strtok (NULL, " ")) {
        if ((col + strlen (np)) < cols) {
            col += strlen (np);
            strcat (line, np);
            if (col < cols)
                line[col++] = ' ';
            line[col] = '\0';
            if (col == cols) {
                memcpy (fit_text, line, col);
                fit_text += cols;
                line[col = 0] = '\0';
                row += 1;
            }
        }
        else {
            if (col > 0) {
                format_line (fit_text, line, col);
                fit_text += cols;
            }
            while (strlen (np) >= cols) {
                memcpy (fit_text, np, cols);
                fit_text += cols;
                np += cols;
                row += 1;
            }
            strcpy (line, np);
            col = strlen (np);
            line[col++] = ' ';
            line[col] = '\0';
            row += 1;
        }
    }
    if ((col > 0) && (row < rows)) {
        format_line (fit_text, line, col);
        fit_text += cols;
    }
    *fit_text = '\0';
    return ret_text;
}
----------------------------------------

char *align_text (const char *str) {
    static const int row = 8;
    static const int col = 16;
    static const char *delimiter = " \t\n";
    char *text = strdup (str);
    char *words [col], *p, *cat;
    int wc, total_len, r;
    char *buff = malloc (row *col * sizeof (char) + 1);
    for (r = total_len = wc = 0, p = strtok (text, delimiter); p; p = strtok (NULL, delimiter)) {
        int len = strlen (p);
        words[wc++] = p;
        total_len += len;
        if (total_len + wc - 1 > col) {
            cat = join (' ', wc -1, words);
            puton (buff + col * r ++, col, center, cat);
            free (cat);
            words[0] = words[wc - 1];
            wc = 1;
            total_len = len;
        }
    }
    cat = join (' ', wc, words);
    puton (buff + col * r ++, col, center, cat);
    free (cat);
    free (text);
    return buff;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23393067_23393409_3_15
23393067_23396286_26_53
Title: C: how to store into a int array each line of a text file with different size? 
----------------------------------------

int main (void) {
    int lines;
    int mostInts;
    int **array = 0;
    lines = GetParamsOfFile ("place your path here", &mostInts);
    array = Create2D (array, lines, mostInts);
    free2DInt (array, mostInts);
    return 0;
}
----------------------------------------

int main () {
    FILE *f;
    int i, j;
    char s [100];
    char *ss;
    f = fopen ("mygraph.txt", "r");
    i = 0;
    while (!feof (f)) {
        fgets (s, 99, f);
        j = countitems (s);
        if (j > i)
            i = j;
    }
    printf ("you need %d columns\n", i);
    rewind (f);
    while (!feof (f)) {
        fgets (s, 99, f);
        ss = skipblanks (s);
        while (*ss) {
            sscanf (ss, "%d", & j);
            printf ("%d ", j);
            ss = nextitem (ss);
        }
        printf ("\n");
    }
    fclose (f);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23422909_23423241_11_22
23422909_23423285_7_24
Title: How to replace the last index of a string using C language? 
----------------------------------------

int main (void) {
    char *s = malloc (MAX);
    strcpy (s, "1_1_90");
    printf ("%s\n", s);
    find_next_lable (s);
    printf ("%s\n", s);
    free (s);
    return 0;
}
----------------------------------------

int main () {
    char *s = malloc (MAX_LEN);
    char *n;
    int i;
    strcpy (s, "1_1_9");
    printf ("%s\n", s);
    n = strrchr (s, '_');
    n++;
    i = atoi (n);
    sprintf (n, "%d", i + 1);
    printf ("%s\n", s);
    free (s);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23430040_23430212_3_15
23430040_23433742_1_10
Title: What does scanf REMOVES from input after scanning? 
----------------------------------------

int main (void) {
    int i, j = 0;
    char c;
    scanf ("%d", & i);
    getchar ();
    printf ("%d\n", i);
    while ((c = getchar ()) != '\n') {
        printf ("%c-", c);
    }
    return 0;
}
----------------------------------------

int main () {
    int i;
    char c;
    scanf ("%d", & i);
    if (getchar () == '\r')
        getchar ();
    while ((c = getchar ()) != '\n') {
        printf ("%c\n", c);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23448396_23448556_9_56
23448396_23449697_1_64
Title: How can I putting dynamically string into array using C 
----------------------------------------

char **do_ls (const char * const dirname) {
    DIR *dir_ptr;
    struct dirent *direntp;
    char **strArray;
    size_t count = 0;
    if ((strArray = malloc (sizeof (*strArray))) == NULL) {
        fprintf (stderr, "ls1: couldn't allocate memory");
        exit (EXIT_FAILURE);
    }
    strArray[0] = NULL;
    if ((dir_ptr = opendir (dirname)) == NULL) {
        fprintf (stderr, "ls1: cannot open %s\n", dirname);
        exit (EXIT_FAILURE);
    }
    else {
        while ((direntp = readdir (dir_ptr)) != NULL) {
            if (strchr (direntp->d_name, '.') == NULL) {
                strArray[count] = strdup (direntp->d_name);
                if (strArray[count] == NULL) {
                    fprintf (stderr, "ls1: couldn't allocate memory");
                    exit (EXIT_FAILURE);
                }
                printf ("Table1: %s\n", strArray [count ++]);
                printf ("Count: %zu\n\n", count);
                strArray = realloc (strArray, sizeof (*strArray) * (count + 1));
                if (strArray == NULL) {
                    fprintf (stderr, "ls1: couldn't reallocate memory");
                    exit (EXIT_FAILURE);
                }
                strArray[count] = NULL;
            }
        }
        for (size_t s = 0; s < count; ++s) {
            printf ("Table3: %s\n", strArray [s]);
        }
        printf ("Number of elements: %zu\n\n", count);
        closedir (dir_ptr);
    }
    return strArray;
}
----------------------------------------

char **do_ls (const char *dirname) {
    DIR *dir_ptr = NULL;
    int tmp;
    char **strArray = NULL;
    int count = 0;
    dir_ptr = opendir (dirname);
    if (NULL == dir_ptr) {
        fprintf (stderr, "ls1: cannot open %s\n", dirname);
        goto CLEANUP;
    }
    while ((direntp = readdir (dir_ptr))) {
        struct dirent *direntp;
        char **tmp;
        if (strchr (direntp->d_name, '.'))
            continue;
        tmp = realloc (strArray, count +1 * sizeof (*strArray));
        if (NULL == tmp) {
            fprintf (stderr, "realloc() failed.\n");
            goto CLEANUP;
        }
        strArray = tmp;
        strArray[count] = strdup (direntp->d_name);
        count++;
    }
    for (tmp = 0; tmp < count; ++tmp)
        printf ("Slot #%d: %s\n", tmp, strArray[tmp]);
    tmp = realloc (strArray, count +1 * sizeof (*strArray));
    if (NULL == tmp) {
        fprintf (stderr, "realloc() failed.\n");
        goto CLEANUP;
    }
    strArray = tmp;
    strArray[count] = NULL;
CLEANUP :
    if (dir_ptr)
        closedir (dir_ptr);
    return (strArray);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23482355_23491915_1_66
23482355_23497000_41_97
Title: Pipes between child processes 
----------------------------------------

int main (int argc, char *argv []) {
    if (argc != 3) {
        error ("Wrong number of arguments\n");
    }
    int nrch;
    nrch = atoi (argv[1]);
    char *msg = argv[2];
    printf ("Parent: erhalten: %s\n", msg);
    int i = 0;
    msg = modify (argv[2]);
    printf ("Parent: weiter: %s\n", msg);
    pid_t pids [10];
    int fd [2];
    for (i = 0; i < nrch; ++i) {
        if ((pids[i] = fork ()) < 0) {
            error ("Can't fork process");
        }
        if (pipe (fd) == -1) {
            error ("Can't create the pipe");
        }
        if (pids[i] == 0) {
            if (dup2 (fd[0], 0) == -1) {
                error ("Can't dup2 (A)");
            }
            close (fd [1]);
            fgets (msg, 255, stdin);
            printf ("child%d: erhalten: %s\n", (i + 1), msg);
            modify (msg);
            printf ("child%d: weiter: %s\n", (i + 1), msg);
            fprintf (stdout, msg);
        }
        else {
            if (dup2 (fd[1], 0) == -1) {
                error ("Can't dup2 (B)");
            }
            close (fd [0]) exit (0);
        }
    }
    int status;
    pid_t pid;
    while (nrch > 0) {
        pid = wait (&status);
        if (pid > -1)
            printf ("Child with PID %ld exited with status 0x%x.\n", (long) pid, status);
        --nrch;
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc != 3)
        error ("Usage: %s number 'message'", argv[0]);
    srand (time (NULL));
    int nrch = atoi (argv[1]);
    char *msg = argv[2];
    size_t len = strlen (msg);
    printf ("Parent: erhalten: %s\n", msg);
    modify (msg);
    printf ("Parent: weiter: %s\n", msg);
    int fd [2];
    if (pipe (fd) == -1)
        error ("Can't create the pipe");
    if (write (fd[1], msg, len) != (ssize_t) len)
        error ("Failed to write to pipe");
    for (int i = 0; i < nrch; ++i) {
        int pid;
        if ((pid = fork ()) < 0)
            error ("Can't fork process");
        else if (pid == 0) {
            char buffer [255];
            int nbytes = read_pipe (fd[0], buffer, sizeof (buffer));
            printf ("child%d: erhalten (%d): %s\n", (i + 1), nbytes, buffer);
            modify (buffer);
            printf ("child%d: weiter (%d): %s\n", (i + 1), nbytes, buffer);
            write (fd [1], buffer, nbytes);
            exit (0);
        }
        else
            printf ("Random: %d\n", rand ());
    }
    while (nrch > 0) {
        int status;
        pid_t pid = wait (&status);
        printf ("Child with PID %ld exited with status 0x%.4X.\n", (long) pid, status);
        --nrch;
    }
    char buffer [255];
    int nbytes = read_pipe (fd[0], buffer, sizeof (buffer));
    printf ("Parent: weiter (%d): %s\n", nbytes, buffer);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23482691_23483128_6_43
23482691_23499205_50_60
Title: Calculate (x exponent 0.19029) with low memory using lookup table? 
----------------------------------------

int main (void) {
    int i, as_int;
    double as_real, low, high, delta, approx, calcd, diff;
    printf ("calculating and storing:\n");
    for (i = 0; i <= 101; i++) {
        as_real = pow (i / 100.0, 0.19029);
        as_int = (int) round (65536 * as_real);
        powers[i] = as_real;
        diff = 100 * as_real / (as_int / 65536.0);
        printf ("%.5f %.5f %.5f ~ %.3f\n", i / 100.0, as_real, as_int / 65536.0, diff);
    }
    printf ("\n");
    printf ("-- interpolating in 1/10ths:\n");
    for (i = 0; i < 1000; i++) {
        as_real = i / 1000.0;
        low = powers[i / 10];
        high = powers[1 + i / 10];
        delta = (high - low) / 10.0;
        approx = low + (i % 10) * delta;
        calcd = pow (as_real, 0.19029);
        diff = 100.0 * approx / calcd;
        printf ("%.5f ~ %.5f = %.5f +/- %.5f%%\n", as_real, approx, calcd, diff);
    }
    return 0;
}
----------------------------------------

int main () {
    int i;
    double x = 0.0;
    for (i = 0; i < 1000; i++) {
        x = 1e-2 * i;
        printf ("%f %f %f \n", x, my_019029 (x), pow (x, 0.19029));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2348374_15380261_1_31
2348374_2348395_1_17
Title: Merging two sorted linked lists 
----------------------------------------

Node *merge (Node *list1, Node *list2) {
    if (!list1)
        return list2;
    if (!list2)
        return list1;
    Node *tmp;
    if (list1->val > list2->val) {
        tmp = list2;
        list2 = list1;
        list1 = tmp;
    }
    Node *tail = list1;
    do {
        while (tail->next && (tail->next->val <= list2->val)) {
            tail = tail->next;
        }
        tmp = tail->next;
        tail->next = list2;
        tail = list2;
        list2 = tmp;
    }
    while (list2);
    return list1;
}
----------------------------------------

Node *merge (Node *list1, Node *list2) {
    Node *merged = null;
    Node **tail = &merged;
    while (list1 && list2) {
        if (list1->data < list2->data) {
            *tail = list1;
            list1 = list1->next;
        }
        else {
            *tail = list2;
            list2 = list2->next;
        }
        tail = &((*tail)->next);
    }
    *tail = list1 ? list1 : list2;
    return merged;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2348374_2348438_3_22
2348374_2348577_23_35
Title: Merging two sorted linked lists 
----------------------------------------

Node *MergeLists (Node *list1, Node *list2) {
    Node *list = NULL, **pnext = &list;
    if (list2 == NULL)
        return list1;
    while (list1 != NULL) {
        if (list1->data > list2->data)
            SWAP_PTRS (list1, list2);
        *pnext = list1;
        pnext = &list1->next;
        list1 = *pnext;
    }
    *pnext = list2;
    return list;
}
----------------------------------------

Node *MergeLists (Node *list1, Node *list2) {
    Node *t, **xt;
    for (xt = &t; list1 || list2;) {
        Node **z = list1 == NULL ? &list2 : list2 == NULL ? &list1 : list1->data < list2->data ? &list1 : &list2;
        *xt = *z;
        xt = &(*z)->next;
        *z = *xt;
    }
    *xt = NULL;
    return t;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2348374_2348438_3_22
2348374_39523692_1_18
Title: Merging two sorted linked lists 
----------------------------------------

Node *MergeLists (Node *list1, Node *list2) {
    Node *list = NULL, **pnext = &list;
    if (list2 == NULL)
        return list1;
    while (list1 != NULL) {
        if (list1->data > list2->data)
            SWAP_PTRS (list1, list2);
        *pnext = list1;
        pnext = &list1->next;
        list1 = *pnext;
    }
    *pnext = list2;
    return list;
}
----------------------------------------

Node *MergeLists (Node *headA, Node *headB) {
    if (headA == NULL) {
        return headB;
    }
    else if (headB == NULL) {
        return headA;
    }
    Node *head = NULL;
    if (headA->data <= headB->data) {
        head = headA;
        head->next = MergeLists (headA->next, headB);
    }
    else {
        head = headB;
        head->next = MergeLists (headA, headB->next);
    }
    return head;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2348374_2348577_23_35
2348374_39523692_1_18
Title: Merging two sorted linked lists 
----------------------------------------

Node *MergeLists (Node *list1, Node *list2) {
    Node *t, **xt;
    for (xt = &t; list1 || list2;) {
        Node **z = list1 == NULL ? &list2 : list2 == NULL ? &list1 : list1->data < list2->data ? &list1 : &list2;
        *xt = *z;
        xt = &(*z)->next;
        *z = *xt;
    }
    *xt = NULL;
    return t;
}
----------------------------------------

Node *MergeLists (Node *headA, Node *headB) {
    if (headA == NULL) {
        return headB;
    }
    else if (headB == NULL) {
        return headA;
    }
    Node *head = NULL;
    if (headA->data <= headB->data) {
        head = headA;
        head->next = MergeLists (headA->next, headB);
    }
    else {
        head = headB;
        head->next = MergeLists (headA, headB->next);
    }
    return head;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23493359_23493802_1_25
23493359_23560785_1_15
Title: Veryfying if a certain key is in a hash table 
----------------------------------------

int hash_exists (hash_table td, const char *key) {
    element *temp = NULL;
    int i = 0;
    if (td == NULL)
        return INVALID_HASHTABLE;
    i = td->hfunc (key, td->size);
    for (i = 0; i < td->size; i++) {
        temp = td->elements[i];
        while (temp != NULL) {
            if (!strcmp (temp->obj->key, key)) {
                return EXISTING_HASHTABLE;
            }
            temp = temp->next;
        }
        return INEXISTENT_HASHTABLE;
    }
}
----------------------------------------

int hash_exists (hash_table td, const char *key) {
    element *temp = NULL;
    int i;
    if (td == NULL)
        return INVALID_HASHTABLE;
    i = td->hfunc (key, td->size);
    for (temp = td->elements[i]; temp; temp = temp->next) {
        if (!strcmp (temp->obj->key, key))
            return EXISTING_HASHTABLE;
    }
    return INEXISTENT_HASHTABLE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23493359_23493883_1_25
23493359_23560785_1_15
Title: Veryfying if a certain key is in a hash table 
----------------------------------------

int hash_exists (hash_table td, const char *key) {
    element *temp = NULL;
    int i = 0;
    if (td == NULL)
        return INVALID_HASHTABLE;
    i = td->hfunc (key, td->size);
    for (i = 0; i < td->size; i++) {
        temp = td->elements[i];
        while (temp != NULL) {
            if (!strcmp (temp->obj->key, key))
                return EXISTING_HASHTABLE;
            else
                temp = temp->next;
        }
    }
    return INEXISTENT_HASHTABLE;
}
----------------------------------------

int hash_exists (hash_table td, const char *key) {
    element *temp = NULL;
    int i;
    if (td == NULL)
        return INVALID_HASHTABLE;
    i = td->hfunc (key, td->size);
    for (temp = td->elements[i]; temp; temp = temp->next) {
        if (!strcmp (temp->obj->key, key))
            return EXISTING_HASHTABLE;
    }
    return INEXISTENT_HASHTABLE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23510378_23510473_7_37
23510378_23510626_5_34
Title: String Replacement in C 
----------------------------------------

int main () {
    char src [] = ".>1220and.<300";
    char dstBuf [64] = "ERROR";
    char *num1 = NULL;
    char *num2 = NULL;
    char *ptr = src;
    int indigit = 0;
    for (; *ptr; ptr++) {
        if (isdigit (*ptr)) {
            if (indigit == 0) {
                if (num1 == NULL)
                    num1 = ptr;
                else
                    num2 = ptr;
                indigit = 1;
            }
        }
        else {
            indigit = 0;
        }
    }
    if (num1 != NULL && num2 != NULL) {
        int n1 = strtoll (num1, NULL, 10);
        int n2 = strtoll (num2, NULL, 10);
        sprintf (dstBuf, "%d:%d", MIN (n1, n2), MAX (n1, n2));
    }
    else if (num1 != NULL) {
        sprintf (dstBuf, "%s", num1);
    }
    printf ("%s\n", dstBuf);
}
----------------------------------------

int main () {
    char s [] = ".>=0 and .<=280";
    char *ptr = s;
    int num;
    unsigned char equals, gt, lt;
    while (*ptr) {
        equals = gt = lt = 0;
        while (*ptr && !isdigit (*ptr)) {
            switch (*ptr) {
            case '=' :
                equals = 1;
                break;
            case '<' :
                lt = 1;
                break;
            case '>' :
                gt = 1;
                break;
            }
            ptr++;
        }
        num = atoi (ptr);
        while (*ptr && isdigit (*ptr))
            ptr++;
        printf ("found comparison: gt=%d lt=%d equals=%d num=%d\n", gt, lt, equals, num);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23521660_23522299_3_110
23521660_23523095_55_70
Title: How to find contigious elements in a 2D array using C 
----------------------------------------

int main () {
    const int N = 4;
    const int M = 5;
    int a [4] [5] = {{1, 0, 0, 0, 0}, {0, 0, 1, 1, 0}, {0, 1, 0, 0, 0}, {0, 0, 0, 0, 0}};
    int i, j, k, z, len;
    int max_len = -1;
    for (i = 0; i < N; ++i) {
        for (j = 0; j < M; ++j) {
            if (a[i][j] == 0) {
                k = i;
                z = j;
                len = 0;
                while (z < M) {
                    if (a[k][z++] == 0)
                        len++;
                    else
                        break;
                }
                if (len > max_len)
                    max_len = len;
                k = i;
                z = j;
                len = 0;
                while (k < N) {
                    if (a[k++][z] == 0)
                        len++;
                    else
                        break;
                }
                if (len > max_len)
                    max_len = len;
                k = i;
                z = j;
                len = 0;
                while (k < N && z < M) {
                    if (a[k++][z++] == 0)
                        len++;
                    else
                        break;
                }
                if (len > max_len)
                    max_len = len;
                k = i;
                z = j;
                len = 0;
                while (k >= 0) {
                    if (a[k--][z] == 0)
                        len++;
                    else
                        break;
                }
                if (len > max_len)
                    max_len = len;
                k = i;
                z = j;
                len = 0;
                while (k >= 0 && z < M) {
                    if (a[k++][z++] == 0)
                        len++;
                    else
                        break;
                }
                if (len > max_len)
                    max_len = len;
            }
        }
    }
    printf ("max_length = %d\n", max_len);
    return 0;
}
----------------------------------------

int main (void) {
    int dims [] = {3, 9};
    char land [3] [9] = {\ {0, 1, 1, 0, 1, 0, 0, 0, 1}, \ {0, 1, 0, 1, 0, 0, 0, 0, 0}, \ {1, 1, 1, 1, 1, 0, 0, 1, 1}};
    char **lp;
    int ii, jj;
    lp = twoDchar (3, 9);
    for (ii = 0; ii < 3; ii++)
        for (jj = 0; jj < 9; jj++) {
            lp[ii][jj] = land[ii][jj];
        }
    printf ("biggest mass is %d\n", largestSize (dims, lp));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2353955_30501487_17_28
2353955_36633187_3_25
Title: How do I detect a palindrome in C? 
----------------------------------------

int main () {
    char str1 [100];
    int temp;
    printf ("Enter the string\n");
    gets (str1);
    temp = is_pali (str1);
    if (temp == 0)
        printf ("the given string is not palindrome\n");
    else
        printf ("the given string is palindrome\n");
}
----------------------------------------

int main () {
    char str [20];
    int i, j, k, m, n;
    printf ("enter the string\n");
    scanf ("%s", str);
    printf ("%s", str);
    k = strlen (str);
    printf ("\nthe lenght of string is %d", k);
    for (i = 0; i < k / 2; i++) {
        m = str[i];
        n = str[k - 1 - i];
    }
    if (m == n) {
        printf ("\nthe given string is palindrome");
    }
    else {printf ("\nthe given string is not a palindrome");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23546658_23546837_1_16
23546658_23547444_4_21
Title: Get whole number from input using only getchar() and convert to int 
----------------------------------------

int main (void) {
    int i = 0;
    int ch;
    printf ("voer een getal in: ");
    while ((ch = getchar ()) != '\n') {
        if (ch > '9' || ch < '0')
            continue;
        i *= 10;
        i += ch - '0';
    }
    printf ("het ingevoerde getal is: %d\n", i);
    return EXIT_SUCCES;
}
----------------------------------------

int main (void) {
    int i = 0;
    char ch, first_ch;
    printf ("voer een getal in: ");
    ch = first_ch = getchar ();
    while (ch != '\n') {
        if (ch >= '0' && ch <= '9')
            i = 10 * i + (ch - '0');
        ch = getchar ();
    }
    if (first_ch == '-')
        i *= -1;
    printf ("het ingevoerde getal is: %d\n", i);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23546658_23546837_1_16
23546658_23548762_1_17
Title: Get whole number from input using only getchar() and convert to int 
----------------------------------------

int main (void) {
    int i = 0;
    int ch;
    printf ("voer een getal in: ");
    while ((ch = getchar ()) != '\n') {
        if (ch > '9' || ch < '0')
            continue;
        i *= 10;
        i += ch - '0';
    }
    printf ("het ingevoerde getal is: %d\n", i);
    return EXIT_SUCCES;
}
----------------------------------------

int main () {
    int i = 0;
    char c;
    char sign = 43;
    printf ("voer een getal in:\n");
    c = getchar ();
    if (c == 45)
        sign = 45;
    for (; (c < 48 || c > 57); c = getchar ())
        ;
    for (; c > 47 && c < 58; c = getchar ()) {
        i = (i << 1) + (i << 3) + c - 48;
    }
    printf ("het ingevoerde getal is: %c%d\n", sign, i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23546658_23547444_4_21
23546658_23548762_1_17
Title: Get whole number from input using only getchar() and convert to int 
----------------------------------------

int main (void) {
    int i = 0;
    char ch, first_ch;
    printf ("voer een getal in: ");
    ch = first_ch = getchar ();
    while (ch != '\n') {
        if (ch >= '0' && ch <= '9')
            i = 10 * i + (ch - '0');
        ch = getchar ();
    }
    if (first_ch == '-')
        i *= -1;
    printf ("het ingevoerde getal is: %d\n", i);
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    int i = 0;
    char c;
    char sign = 43;
    printf ("voer een getal in:\n");
    c = getchar ();
    if (c == 45)
        sign = 45;
    for (; (c < 48 || c > 57); c = getchar ())
        ;
    for (; c > 47 && c < 58; c = getchar ()) {
        i = (i << 1) + (i << 3) + c - 48;
    }
    printf ("het ingevoerde getal is: %c%d\n", sign, i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23587423_23587758_5_64
23587423_23589083_5_41
Title: Trying to tokenize a string by spaces and quotes 
----------------------------------------

int main (void) {
    char **tokens = NULL;
    int i, count = 0, strcount;
    char **temp, *iterate;
    char *input = "this \"is a\" very \"very complex\" test";
    iterate = input;
    if (iterate) {
        while (*iterate) {
            while (*iterate == ' ')
                iterate++;
            if (!*iterate)
                break;
            temp = realloc (tokens, sizeof (char *) * (count + 1));
            if (temp == NULL) {
                fprintf (stderr, "Error in parsing: ran out of memory\n");
                return -1;
            }
            tokens = temp;
            if (*iterate == '\"') {
                iterate++;
                strcount = 0;
                while (iterate[strcount] && iterate[strcount] != '\"')
                    strcount++;
                tokens[count] = malloc (strcount +1);
                strncpy (tokens [count], iterate, strcount);
                tokens[count][strcount] = 0;
                count++;
                iterate += strcount;
                if (*iterate == '\"')
                    iterate++;
            }
            else {
                strcount = 0;
                while (iterate[strcount] && iterate[strcount] != ' ' && iterate[strcount] != '\"')
                    strcount++;
                tokens[count] = malloc (strcount +1);
                strncpy (tokens [count], iterate, strcount);
                tokens[count][strcount] = 0;
                count++;
                iterate += strcount;
            }
        }
        while (*iterate)
            ;
    }
    for (i = 0; i < count; i++)
        printf ("\t%i: %s\n", i, tokens[i]);
    return 0;
}
----------------------------------------

int main () {
    char input_string [] = "this \"is a\" very \"very complex\" test";
    char **tokens = NULL;
    int token_count = 0;
    char *ptr = input_string;
    int i;
    char *next_ptr = ptr;
    while (*ptr && next_ptr) {
        while (*ptr == ' ')
            ptr++;
        tokens = realloc (tokens, ++token_count * sizeof (char *));
        if (tokens == NULL)
            return -1;
        if (*ptr == '"')
            next_ptr = strchr (ptr +1, '"');
        else
            next_ptr = strpbrk (ptr, " \"");
        if (next_ptr) {
            tokens[token_count - 1] = malloc (sizeof (char) * (next_ptr - (ptr + (*ptr == '"'))) + 1);
            if (tokens[token_count - 1] == NULL)
                return -1;
            strncpy (tokens [token_count - 1], (ptr + (* ptr == '"')), next_ptr - (ptr + (* ptr == '"')));
            tokens[token_count - 1][next_ptr - (ptr + (*ptr == '"'))] = 0;
            ptr = next_ptr + (*ptr == '"');
        }
        else
            tokens[token_count - 1] = strdup (ptr +(*ptr == '"'));
    }
    for (i = 0; i < token_count; ++i)
        printf ("[%d]: %s\n", i, tokens[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23587776_23590725_13_51
23587776_23592912_33_43
Title: How to exchange characters in string for enumaration string? 
----------------------------------------

int main () {
    MAP_ITEM **map;
    int height = 3;
    int width = 21;
    int i;
    map = malloc (height * sizeof (MAP_ITEM *));
    for (i = 0; i < height; ++i)
        map[i] = malloc (width * sizeof (MAP_ITEM));
    char *raw_map = "-----#####-----------|-----#@$.#-----------|-----#####-----------";
    int r, c;
    for (r = c = i = 0; raw_map[i] != '\0'; ++i) {
        switch (raw_map[i]) {
        case '-' :
        case '@' :
            map[r][c++] = EMPTY;
            break;
        case '#' :
            map[r][c++] = WALL;
            break;
        case '$' :
            map[r][c++] = BOX;
            break;
        case '.' :
            map[r][c++] = DESTINATION;
            break;
        case '|' :
            ++r;
            c = 0;
            break;
        default :
            ;
        }
    }
    if (map[1][7] == BOX)
        printf ("map(1,7) is BOX\n");
    return 0;
}
----------------------------------------

int main () {
    LEVEL level;
    level.name = "chicago";
    level.password = "addie";
    level.description = "story begins here";
    level.raw_map = "-----#####-----------|-----#@$.#-----------|-----#####-----------";
    GAME *game;
    game = init_game (&level);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2368384_38344636_19_152
2368384_7627757_6_17
Title: Write a C program to measure time spent in context switch in Linux OS 
----------------------------------------

int main () {
    cpu_set_t set;
    struct sched_param prio_param;
    int prio_max;
    CPU_ZERO (& set);
    CPU_SET (0, & set);
    memset (& prio_param, 0, sizeof (struct sched_param));
    if (sched_setaffinity (getpid (), sizeof (cpu_set_t), &set)) {
        perror ("sched_setaffinity");
        exit (EXIT_FAILURE);
    }
    if ((prio_max = sched_get_priority_max (SCHED_FIFO)) < 0) {
        perror ("sched_get_priority_max");
    }
    prio_param.sched_priority = prio_max;
    if (sched_setscheduler (getpid (), SCHED_FIFO, &prio_param) < 0) {
        perror ("sched_setscheduler");
        exit (EXIT_FAILURE);
    }
    int ret = -1;
    int firstpipe [2];
    int secondpipe [2];
    int timepipe [2];
    int nbytes;
    char string [] = "Hello, world!\n";
    char temp [] = "Sumit Gemini!\n";
    char readbuffer [80];
    char tempbuffer [80];
    int i = 0;
    struct timeval start, end;
    if (pipe (firstpipe) == -1) {
        fprintf (stderr, "parent: Failed to create pipe\n");
        return -1;
    }
    if (pipe (secondpipe) == -1) {
        fprintf (stderr, "parent: Failed to create second pipe\n");
        return -1;
    }
    if (pipe (timepipe) == -1) {
        fprintf (stderr, "parent: Failed to create time pipe\n");
        return -1;
    }
    if ((ret = fork ()) == -1)
        perror ("fork");
    else if (ret == 0) {
        int n = -1;
        printf ("Child  ----> %d\n", getpid ());
        for (n = 0; n < 5; n++) {
            nbytes = read (firstpipe[0], readbuffer, sizeof (readbuffer));
            printf ("Received string: %s", readbuffer);
            write (secondpipe [1], temp, strlen (temp) + 1);
        }
        gettimeofday (& end, 0);
        n = sizeof (struct timeval);
        if (write (timepipe[1], &end, sizeof (struct timeval)) != n) {
            fprintf (stderr, "child: Failed to write in time pipe\n");
            exit (EXIT_FAILURE);
        }
    }
    else {
        double switch_time;
        int n = -1;
        printf ("Parent  ----> %d\n", getpid ());
        gettimeofday (& start, 0);
        for (n = 0; n < 5; n++) {
            write (firstpipe [1], string, strlen (string) + 1);
            read (secondpipe [0], tempbuffer, sizeof (tempbuffer));
            printf ("Received temp: %s", tempbuffer);
        }
        n = sizeof (struct timeval);
        if (read (timepipe[0], &end, sizeof (struct timeval)) != n) {
            fprintf (stderr, "Parent: Failed to read from time pipe\n");
            exit (EXIT_FAILURE);
        }
        wait (NULL);
        switch_time = ((end.tv_sec - start.tv_sec) * 1000000 + (end.tv_usec - start.tv_usec)) / 1000.0;
        printf ("context switch between two processes: %0.6lfms\n", switch_time / (5 * 2));
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    struct timeval tv, tvt;
    int diff;
    gettimeofday (& tv, 0);
    diff = tvt.tv_usec - tv.tv_usec;
    if (fork () != 0) {
        gettimeofday (& tvt, 0);
        diff = tvt.tv_usec - tv.tv_usec;
        printf ("%d\n", diff);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2371292_2376176_8_56
2371292_2378520_2_26
Title: Buffered reading from stdin using fread in C 
----------------------------------------

int main (void) {
    int n;
    int divisor;
    int answer = 0;
    int current_buffer_size = INITIAL_BUFFER_SIZE;
    char *line = malloc (current_buffer_size);
    if (line == NULL) {
        return EXIT_FAILURE;
    }
    setvbuf (stdin, (char *) NULL, _IOFBF, 0);
    scanf ("%d%d\n", & n, & divisor);
    while (n > 0) {
        unsigned long dividend;
        char *endp;
        int offset = 0;
        while (fgets (line +offset, current_buffer_size, stdin)) {
            if (line[strlen (line) - 1] == '\n') {
                break;
            }
            else {
                int new_buffer_size = 2 * current_buffer_size;
                char *tmp = realloc (line, new_buffer_size);
                if (tmp) {
                    line = tmp;
                    offset = current_buffer_size - 1;
                    current_buffer_size = new_buffer_size;
                }
                else {
                    break;
                }
            }
        }
        errno = 0;
        dividend = strtoul (line, &endp, 10);
        if (!((endp == line) || errno)) {
            if (dividend % divisor == 0) {
                answer += 1;
            }
        }
        n -= 1;
    }
    printf ("%d\n", answer);
    return 0;
}
----------------------------------------

int main () {
    int lines, number = 0, dividend, ans = 0, i, chars_read;
    char buf [BUFSIZE + 1] = {0};
    scanf ("%d%d\n", & lines, & dividend);
    while ((chars_read = fread (buf, 1, BUFSIZE, stdin)) > 0) {
        for (i = 0; i < chars_read; i++) {
            if (buf[i] != '\n')
                number = buf[i] - '0' + 10 * number;
            else {
                if (number % dividend == 0)
                    ans += 1;
                lines -= 1;
                number = 0;
            }
        }
        if (lines == 0)
            break;
    }
    printf ("%d are divisible by %d \n", ans, dividend);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2371292_2376176_8_56
2371292_2382113_23_55
Title: Buffered reading from stdin using fread in C 
----------------------------------------

int main (void) {
    int n;
    int divisor;
    int answer = 0;
    int current_buffer_size = INITIAL_BUFFER_SIZE;
    char *line = malloc (current_buffer_size);
    if (line == NULL) {
        return EXIT_FAILURE;
    }
    setvbuf (stdin, (char *) NULL, _IOFBF, 0);
    scanf ("%d%d\n", & n, & divisor);
    while (n > 0) {
        unsigned long dividend;
        char *endp;
        int offset = 0;
        while (fgets (line +offset, current_buffer_size, stdin)) {
            if (line[strlen (line) - 1] == '\n') {
                break;
            }
            else {
                int new_buffer_size = 2 * current_buffer_size;
                char *tmp = realloc (line, new_buffer_size);
                if (tmp) {
                    line = tmp;
                    offset = current_buffer_size - 1;
                    current_buffer_size = new_buffer_size;
                }
                else {
                    break;
                }
            }
        }
        errno = 0;
        dividend = strtoul (line, &endp, 10);
        if (!((endp == line) || errno)) {
            if (dividend % divisor == 0) {
                answer += 1;
            }
        }
        n -= 1;
    }
    printf ("%d\n", answer);
    return 0;
}
----------------------------------------

int main () {
    int n, k, tmp, ans = 0, i = 0, countNL = 0;
    char *endp = 0;
    setvbuf (stdin, (char *) NULL, _IOFBF, 0);
    scanf ("%d%d\n", & n, & k);
    char singlechar = 0;
    char intbuf [BUFSIZE + 1] = {0};
    while (fread (&singlechar, 1, 1, stdin)) {
        if (singlechar == '\n') {
            countNL++;
            intbuf[i] = '\0';
            tmp = strtoul (intbuf, &endp, 10);
            if (tmp % k == 0)
                ++ans;
            i = 0;
        }
        else {
            intbuf[i] = singlechar;
            i++;
        }
        if (countNL == n)
            break;
    }
    printf ("%d integers are divisible by %d.\n", ans, k);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2371292_2376176_8_56
2371292_2393361_51_81
Title: Buffered reading from stdin using fread in C 
----------------------------------------

int main (void) {
    int n;
    int divisor;
    int answer = 0;
    int current_buffer_size = INITIAL_BUFFER_SIZE;
    char *line = malloc (current_buffer_size);
    if (line == NULL) {
        return EXIT_FAILURE;
    }
    setvbuf (stdin, (char *) NULL, _IOFBF, 0);
    scanf ("%d%d\n", & n, & divisor);
    while (n > 0) {
        unsigned long dividend;
        char *endp;
        int offset = 0;
        while (fgets (line +offset, current_buffer_size, stdin)) {
            if (line[strlen (line) - 1] == '\n') {
                break;
            }
            else {
                int new_buffer_size = 2 * current_buffer_size;
                char *tmp = realloc (line, new_buffer_size);
                if (tmp) {
                    line = tmp;
                    offset = current_buffer_size - 1;
                    current_buffer_size = new_buffer_size;
                }
                else {
                    break;
                }
            }
        }
        errno = 0;
        dividend = strtoul (line, &endp, 10);
        if (!((endp == line) || errno)) {
            if (dividend % divisor == 0) {
                answer += 1;
            }
        }
        n -= 1;
    }
    printf ("%d\n", answer);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char *data;
    char *src;
    char *end;
    unsigned long k;
    unsigned long n;
    unsigned long answer = 0;
    size_t i;
    arg0 = argv[0];
    data = memory_map (0);
    src = data;
    n = read_integer (src, &end);
    src = end;
    k = read_integer (src, &end);
    src = end;
    for (i = 0; i < n; i++, src = end) {
        unsigned long v = read_integer (src, &end);
        if (v % k == 0)
            answer++;
    }
    printf ("%lu\n", answer);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2371292_2378520_2_26
2371292_2382113_23_55
Title: Buffered reading from stdin using fread in C 
----------------------------------------

int main () {
    int lines, number = 0, dividend, ans = 0, i, chars_read;
    char buf [BUFSIZE + 1] = {0};
    scanf ("%d%d\n", & lines, & dividend);
    while ((chars_read = fread (buf, 1, BUFSIZE, stdin)) > 0) {
        for (i = 0; i < chars_read; i++) {
            if (buf[i] != '\n')
                number = buf[i] - '0' + 10 * number;
            else {
                if (number % dividend == 0)
                    ans += 1;
                lines -= 1;
                number = 0;
            }
        }
        if (lines == 0)
            break;
    }
    printf ("%d are divisible by %d \n", ans, dividend);
    return 0;
}
----------------------------------------

int main () {
    int n, k, tmp, ans = 0, i = 0, countNL = 0;
    char *endp = 0;
    setvbuf (stdin, (char *) NULL, _IOFBF, 0);
    scanf ("%d%d\n", & n, & k);
    char singlechar = 0;
    char intbuf [BUFSIZE + 1] = {0};
    while (fread (&singlechar, 1, 1, stdin)) {
        if (singlechar == '\n') {
            countNL++;
            intbuf[i] = '\0';
            tmp = strtoul (intbuf, &endp, 10);
            if (tmp % k == 0)
                ++ans;
            i = 0;
        }
        else {
            intbuf[i] = singlechar;
            i++;
        }
        if (countNL == n)
            break;
    }
    printf ("%d integers are divisible by %d.\n", ans, k);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2371292_2378520_2_26
2371292_2393361_51_81
Title: Buffered reading from stdin using fread in C 
----------------------------------------

int main () {
    int lines, number = 0, dividend, ans = 0, i, chars_read;
    char buf [BUFSIZE + 1] = {0};
    scanf ("%d%d\n", & lines, & dividend);
    while ((chars_read = fread (buf, 1, BUFSIZE, stdin)) > 0) {
        for (i = 0; i < chars_read; i++) {
            if (buf[i] != '\n')
                number = buf[i] - '0' + 10 * number;
            else {
                if (number % dividend == 0)
                    ans += 1;
                lines -= 1;
                number = 0;
            }
        }
        if (lines == 0)
            break;
    }
    printf ("%d are divisible by %d \n", ans, dividend);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char *data;
    char *src;
    char *end;
    unsigned long k;
    unsigned long n;
    unsigned long answer = 0;
    size_t i;
    arg0 = argv[0];
    data = memory_map (0);
    src = data;
    n = read_integer (src, &end);
    src = end;
    k = read_integer (src, &end);
    src = end;
    for (i = 0; i < n; i++, src = end) {
        unsigned long v = read_integer (src, &end);
        if (v % k == 0)
            answer++;
    }
    printf ("%lu\n", answer);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2371292_2382113_23_55
2371292_2393361_51_81
Title: Buffered reading from stdin using fread in C 
----------------------------------------

int main () {
    int n, k, tmp, ans = 0, i = 0, countNL = 0;
    char *endp = 0;
    setvbuf (stdin, (char *) NULL, _IOFBF, 0);
    scanf ("%d%d\n", & n, & k);
    char singlechar = 0;
    char intbuf [BUFSIZE + 1] = {0};
    while (fread (&singlechar, 1, 1, stdin)) {
        if (singlechar == '\n') {
            countNL++;
            intbuf[i] = '\0';
            tmp = strtoul (intbuf, &endp, 10);
            if (tmp % k == 0)
                ++ans;
            i = 0;
        }
        else {
            intbuf[i] = singlechar;
            i++;
        }
        if (countNL == n)
            break;
    }
    printf ("%d integers are divisible by %d.\n", ans, k);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char *data;
    char *src;
    char *end;
    unsigned long k;
    unsigned long n;
    unsigned long answer = 0;
    size_t i;
    arg0 = argv[0];
    data = memory_map (0);
    src = data;
    n = read_integer (src, &end);
    src = end;
    k = read_integer (src, &end);
    src = end;
    for (i = 0; i < n; i++, src = end) {
        unsigned long v = read_integer (src, &end);
        if (v % k == 0)
            answer++;
    }
    printf ("%lu\n", answer);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23715090_23715516_5_25
23715090_23715824_4_27
Title: How queue a Hex array in an int array in C? 
----------------------------------------

int main () {
    int rCode = 0;
    uint8_t id [] = {0xBB, 0x50, 0x60, 0x9E, 0x99};
    uint32_t message [2];
    char *cp;
    int nCnt;
    memset (message, 0, sizeof (message));
    cp = (char *) message;
    for (nCnt = sizeof (id); nCnt; --nCnt)
        *cp++ = id[nCnt - 1];
    printf ("message[0] = 0x%08X\n", message [0]);
    printf ("message[1] = 0x%08X\n", message [1]);
    return (rCode);
}
----------------------------------------

int main () {
    uint8_t id [] = {0xBB, 0x50, 0x60, 0x9E, 0x99};
    uint32_t message [2];
    int msgi = 0;
    int idi = sizeof (id);
    for (msgi = 0; msgi < sizeof (message); msgi++) {
        int shift = 0;
        message[msgi] = 0;
        for (shift = 0; shift < 32 && idi > 0; shift += 8) {
            idi--;
            message[msgi] |= id[idi] << shift;
        }
    }
    printf ("message[0] = 0x%08X\n", message [0]);
    printf ("message[1] = 0x%08X\n", message [1]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23769011_23769110_4_18
23769011_23769279_6_67
Title: "C-string memory allocation table of C-strings" 
----------------------------------------

int main () {
    int i;
    int noOfStrings = 100;
    int eachStringLenght = 16;
    char **t;
    t = (char **) malloc (noOfStrings * sizeof (char *));
    for (i = 0; i < noOfStrings; i++) {
        t[i] = (char *) malloc (eachStringLenght * sizeof (char));
    }
    return 0;
}
----------------------------------------

int main (int I__argC, char *I__argV []) {
    int rCode = 0;
    int i;
    char **t = NULL;
    size_t arraySize;
    if (2 != I__argC) {
        rCode = EINVAL;
        printf ("USAGE: %s {dynamic array size}\n", I__argV [0]);
        goto CLEANUP;
    }
    arraySize = strtoul (I__argV[1], NULL, 0);
    if (0 == arraySize) {
        rCode = EINVAL;
        fprintf (stderr, "Cannot allocate a dynamic array of size zero.\n");
        goto CLEANUP;
    }
    errno = 0;
    t = malloc (arraySize * sizeof (*t));
    if (NULL == t) {
        rCode = errno ? errno : ENOMEM;
        fprintf (stderr, "malloc() failed.\n");
        goto CLEANUP;
    }
    memset (t, 0, arraySize * sizeof (* t));
    for (i = 0; i < arraySize; i++) {
        errno = 0;
        t[i] = strdup ("A string");
        if (NULL == t[i]) {
            rCode = errno ? errno : ENOMEM;
            fprintf (stderr, "strdup() failed.\n");
            goto CLEANUP;
        }
    }
CLEANUP :
    if (t) {
        for (i = 0; i < arraySize; i++) {
            if (t[i])
                free (t[i]);
        }
        free (t);
    }
    return (rCode);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23769011_23769110_4_18
23769011_23769408_3_34
Title: "C-string memory allocation table of C-strings" 
----------------------------------------

int main () {
    int i;
    int noOfStrings = 100;
    int eachStringLenght = 16;
    char **t;
    t = (char **) malloc (noOfStrings * sizeof (char *));
    for (i = 0; i < noOfStrings; i++) {
        t[i] = (char *) malloc (eachStringLenght * sizeof (char));
    }
    return 0;
}
----------------------------------------

int main () {
    int n = 16;
    int m = 16;
    char **t = (char **) malloc (n * sizeof (char *));
    for (int i = 0; i < n; ++i) {
        t[i] = (char *) malloc (m * sizeof (char));
        for (int j = 0; j < m; ++j)
            t[i][m] = 'a';
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j)
            printf ("%c ", t[i][m]);
        printf ("\n");
    }
    for (int i = 0; i < n; ++i)
        free (t[i]);
    free (t);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23769011_23769279_6_67
23769011_23769408_3_34
Title: "C-string memory allocation table of C-strings" 
----------------------------------------

int main (int I__argC, char *I__argV []) {
    int rCode = 0;
    int i;
    char **t = NULL;
    size_t arraySize;
    if (2 != I__argC) {
        rCode = EINVAL;
        printf ("USAGE: %s {dynamic array size}\n", I__argV [0]);
        goto CLEANUP;
    }
    arraySize = strtoul (I__argV[1], NULL, 0);
    if (0 == arraySize) {
        rCode = EINVAL;
        fprintf (stderr, "Cannot allocate a dynamic array of size zero.\n");
        goto CLEANUP;
    }
    errno = 0;
    t = malloc (arraySize * sizeof (*t));
    if (NULL == t) {
        rCode = errno ? errno : ENOMEM;
        fprintf (stderr, "malloc() failed.\n");
        goto CLEANUP;
    }
    memset (t, 0, arraySize * sizeof (* t));
    for (i = 0; i < arraySize; i++) {
        errno = 0;
        t[i] = strdup ("A string");
        if (NULL == t[i]) {
            rCode = errno ? errno : ENOMEM;
            fprintf (stderr, "strdup() failed.\n");
            goto CLEANUP;
        }
    }
CLEANUP :
    if (t) {
        for (i = 0; i < arraySize; i++) {
            if (t[i])
                free (t[i]);
        }
        free (t);
    }
    return (rCode);
}
----------------------------------------

int main () {
    int n = 16;
    int m = 16;
    char **t = (char **) malloc (n * sizeof (char *));
    for (int i = 0; i < n; ++i) {
        t[i] = (char *) malloc (m * sizeof (char));
        for (int j = 0; j < m; ++j)
            t[i][m] = 'a';
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < m; ++j)
            printf ("%c ", t[i][m]);
        printf ("\n");
    }
    for (int i = 0; i < n; ++i)
        free (t[i]);
    free (t);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23787749_23788663_6_74
23787749_23790715_6_56
Title: How do I store (scanf) a randomly generated number? ( Code inside) 
----------------------------------------

int main (int argc, char **argv) {
    int prevRandomNumber = rand () % 10;
    int continuePlaying = 1;
    while (continuePlaying == 1) {
        int randomNumber = rand () % 10;
        int userSelection = 0;
        char lineBuffer [LENGTH_OF_BUFFER];
        printf ("Previous random number %d\n", prevRandomNumber);
        while (userSelection == 0) {
            printf ("higher or lower?");
            gets (lineBuffer);
            if (strcmp ("higher", lineBuffer) == 0) {
                userSelection = 1;
                printf ("You selected higher!\n");
            }
            else if (strcmp ("lower", lineBuffer) == 0) {
                userSelection = -1;
                printf ("You selected lower!\n");
            }
            else {
                printf ("Sorry, I didn't understand you, please check your input and try again!\n");
            }
        }
        if (userSelection == 1) {
            if (randomNumber > prevRandomNumber) {
                printf ("Correct, you really are a marvel!\n");
            }
            else {
                printf ("Incorrect, I pity you!\n");
            }
        }
        else if (userSelection == -1) {
            if (randomNumber < prevRandomNumber) {
                printf ("Correct, you really are a marvel!\n");
            }
            else {
                printf ("Incorrect, I pity you!\n");
            }
        }
        printf ("Number was %d\n", randomNumber);
        printf ("Care to play again?\n");
        gets (lineBuffer);
        prevRandomNumber = randomNumber;
        if (strcmp ("yes", lineBuffer) != 0) {
            continuePlaying = 0;
        }
    }
}
----------------------------------------

int main () {
    char *bet, cmd;
    long random_number, new_random_number;
    while (1) {
        srand (time (NULL));
        random_number = rand ();
        printf ("%d\n", random_number);
        printf ("bet if the next number is bigger (+) or lower (-): ");
        scanf ("%s", bet);
        srand (time (NULL));
        new_random_number = rand ();
        printf ("%d\n", new_random_number);
        if (bet[0] == '+') {
            if (new_random_number >= random_number) {
                printf ("yeah! you are right\n");
                printf ("\nlet's play again!!\n");
                continue;
            }
            else {
                printf ("trololol :P That was wrong\n");
                printf ("\nlet's play again!!\n");
                continue;
            }
        }
        if (bet[0] == '-') {
            if (new_random_number < random_number) {
                printf ("yeah! you are right\n");
                printf ("\nlet's play again!!\n");
                continue;
            }
            else {
                printf ("trololol :P That was wrong\n");
                printf ("\nlet's play again!!\n");
                continue;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23796987_23797185_18_31
23796987_23798326_222_272
Title: Run command through string in C 
----------------------------------------

int main () {
    char cmdBuff [100], *name, *params;
    Node *root;
    while (scanf ("%100s", cmdBuff) != EOF) {
        name = strstr (cmdBuff, "(")
        );
        if (name) {
            *name = '\0';
            params = name + 1;
            GetFunction (root, name) (int1, int2);
        }
    }
}
----------------------------------------

int main () {
    int rCode = 0;
    char *command = NULL;
    int done = CMD_FALSE;
    while (!done) {
        rCode = CMD_Fetch (&command);
        switch (rCode) {
        case 0 :
            break;
        case ENOENT :
            rCode = 0;
            done = CMD_TRUE;
            printf ("Done.\n");
            continue;
        default :
            fprintf (stderr, "CMD_Fetch() reports: %d\n", rCode);
            goto CLEANUP;
        }
        rCode = CMD_Execute (command);
        switch (rCode) {
        case 0 :
            break;
        case ENOENT :
            fprintf (stderr, "No such command: [%s]\n", command);
            continue;
        default :
            fprintf (stderr, "CMD_Execute() reports: %d\n", rCode);
            goto CLEANUP;
        }
        free (command);
        command = NULL;
    }
CLEANUP :
    if (command)
        free (command);
    return (rCode);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23799776_23802292_23_36
23799776_23803942_48_71
Title: how to build spiral square matrix using recursion? 
----------------------------------------

int main () {
    int size;
    printf ("input size : ");
    scanf ("%d", & size);
    int a [size] [size];
    build_matrix (size, a, size, 1);
    for (int r = 0; r < size; ++r) {
        for (int c = 0; c < size; ++c)
            printf ("%3d ", a[r][c]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int i, j;
    int k, ret;
    int a [N] [N] = {0};
    k = N / 2 + N % 2;
    build_matrix (a, i, i, right);
    for (i = 0; i < N; i++) {
        for (j = 0; j < N; j++) {
            if (!(a[i][j] < 100))
                printf ("%3d ", a[i][j]);
            else if (a[i][j] < 10)
                printf ("00%d ", a[i][j]);
            else
                printf ("0%d ", a[i][j]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23799776_23802292_3_21
23799776_23803942_16_46
Title: how to build spiral square matrix using recursion? 
----------------------------------------

void build_matrix (int msize, int a [msize] [msize], int size, int value) {
    int i, row, col;
    if (size < 1)
        return;
    row = col = (msize - size) / 2;
    if (size == 1) {
        a[row][col] = value;
        return;
    }
    for (i = 0; i < size - 1; ++i)
        a[row][col++] = value++;
    for (i = 0; i < size - 1; ++i)
        a[row++][col] = value++;
    for (i = 0; i < size - 1; ++i)
        a[row][col--] = value++;
    for (i = 0; i < size - 1; ++i)
        a[row--][col] = value++;
    build_matrix (msize, a, size - 2, value);
}
----------------------------------------

int build_matrix (int a [N] [N], int i, int j, c_flag flag) {
    int ret;
    if (i < 0 || i >= N || j < 0 || j >= N || s[i][j] == true)
        return false;
    if (s[i][j] == false && a[i][j] == 0) {
        s[i][j] = true;
        a[i][j] = ++counter;
    }
    if (flag == right)
        ret = build_matrix (a, i, j +1, right);
    flag = down;
    if (flag == down)
        ret = build_matrix (a, i +1, j, down);
    flag = left;
    if (flag == left)
        ret = build_matrix (a, i, j -1, left);
    flag = up;
    if (flag == up)
        ret = build_matrix (a, i -1, j, up);
    flag = right;
    if (flag == right)
        ret = build_matrix (a, i, j +1, right);
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23820713_23950503_1_33
23820713_24029797_29_106
Title: Getting flite to output audio with PortAudio 
----------------------------------------

static int playCallback (const void *inputBuffer, void *outputBuffer, unsigned long framesPerBuffer, const PaStreamCallbackTimeInfo *timeInfo, PaStreamCallbackFlags statusFlags, void *userData) {
    cst_wave *data = (cst_wave *) userData;
    short *rptr = &data->samples[data->frameIndex * data->num_channels];
    short *wptr = (short *) outputBuffer;
    int finished;
    unsigned int framesLeft = data->maxFrameIndex - data->frameIndex;
    (void) inputBuffer;
    (void) timeInfo;
    (void) statusFlags;
    (void) userData;
    if (framesLeft < framesPerBuffer) {
        memcpy (wptr, rptr, sizeof (* wptr) * data -> num_channels * framesLeft);
        memset (wptr, sizeof (* wptr) * data -> num_channels * framesPerBuffer, 0);
        data->frameIndex += framesLeft;
        finished = paComplete;
    }
    else {
        memcpy (wptr, rptr, sizeof (* wptr) * data -> num_channels * framesPerBuffer);
        data->frameIndex += framesPerBuffer;
        finished = paContinue;
    }
    return finished;
}
----------------------------------------

static int playCallback (const void *inputBuffer, void *outputBuffer, unsigned long framesPerBuffer, const PaStreamCallbackTimeInfo *timeInfo, PaStreamCallbackFlags statusFlags, void *userData) {
    (void) inputBuffer;
    (void) timeInfo;
    (void) statusFlags;
    (void) userData;
    cst_wave *data;
    short *rptr;
    short *wptr;
    unsigned int framesLeft, frames, framesPad, samples, samplesPad, numBytes, numBytesPad;
    int finalBuffer;
    data = (cst_wave *) userData;
    rptr = &data->samples[cst_wave_frameIndex (data) * cst_wave_num_channels (data)];
    wptr = (short *) outputBuffer;
    framesLeft = cst_wave_maxFrameIndex (data) - cst_wave_frameIndex (data);
    finalBuffer = framesLeft <= framesPerBuffer;
    frames = finalBuffer ? framesLeft : framesPerBuffer;
    framesPad = framesPerBuffer - frames;
    samples = frames * cst_wave_num_channels (data);
    samplesPad = framesPad * cst_wave_num_channels (data);
    numBytes = samples * sizeof (short);
    numBytesPad = samplesPad * sizeof (short);
    printf ("framesLeft in callback: %u\n", framesLeft);
    printf ("framesPerBuffer in callback: %lu\n", framesPerBuffer);
    printf ("frames in callback: %u\n", frames);
    printf ("frameIndex in callback: %d\n", cst_wave_frameIndex (data));
    printf ("maxFrameIndex in callback: %d\n", cst_wave_maxFrameIndex (data));
    printf ("numChannels in callback: %d\n", cst_wave_num_channels (data));
    printf ("numSamples in callback: %d\n", cst_wave_num_samples (data));
    printf ("sampleRate in callback: %d\n\n", cst_wave_sample_rate (data));
    memcpy (wptr, rptr, numBytes);
    wptr += samples;
    rptr += samples;
    cst_wave_set_frameIndex (data, cst_wave_frameIndex (data) + frames);
    memset (wptr, 0, numBytesPad);
    wptr += samplesPad;
    rptr += samplesPad;
    return finalBuffer ? paComplete : paContinue;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23829290_23830496_21_32
23829290_23852060_28_39
Title: Compress mask using AVX intrinsics 
----------------------------------------

int main () {
    __m256d v0 = _mm256_set_pd (0.0, 1.0, 2.0, 3.0);
    __m256d v1 = _mm256_set_pd (3.0, 2.0, 1.0, 0.0);
    __m256d vcmp0 = _mm256_cmp_pd (v0, v1, 1);
    __m256d vcmp1 = _mm256_cmp_pd (v1, v0, 1);
    __m256 vcmp = _mm256_set_m128 (_mm256_cvtpd_ps (vcmp0), _mm256_cvtpd_ps (vcmp1));
    printvd ("vcmp0", vcmp0);
    printvd ("vcmp1", vcmp1);
    printvf ("vcmp ", vcmp);
    return 0;
}
----------------------------------------

int main (void) {
    __m256d v0, v1, vr;
    v0 = _mm256_castsi256_pd (_mm256_set_epi32 (0xffffffff, 0xd0000000, 0xffffffff, 0xc0000000, 0xffffffff, 0xb0000000, 0xffffffff, 0xa0000000));
    v1 = _mm256_castsi256_pd (_mm256_set_epi32 (0xffffffff, 0xd0000001, 0xffffffff, 0xc0000001, 0xffffffff, 0xb0000001, 0xffffffff, 0xa0000001));
    vr = function1 (v0, v1);
    printf ("v0=");
    dump (& v0);
    printf ("v1=");
    dump (& v1);
    printf ("vr=");
    dump (& vr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23835186_23835737_6_70
23835186_23836095_4_35
Title: Dynamic string array in C with malloc and realloc won't exit a loop 
----------------------------------------

int main () {
    int rCode = 0;
    char *buf = NULL;
    size_t bufSize = 0;
    int done = 0;
    errno = 0;
    buf = malloc (bufSize +1);
    if (NULL == buf) {
        rCode = errno ? errno : ENOMEM;
        fprintf (stderr, "malloc() failed. errno=%d\n", errno);
        goto CLEANUP;
    }
    ++bufSize;
    buf[0] = '\0';
    while (!done) {
        char *tmp;
        int ch = getche ();
        switch (ch) {
        case '\r' :
        case '\n' :
            done = (-1);
            continue;
        default :
            buf[bufSize] = ch;
            errno = 0;
            tmp = realloc (buf, bufSize +1);
            if (NULL == tmp) {
                rCode = errno ? errno : ENOMEM;
                fprintf (stderr, "realloc() failed.  errno:%d\n", errno);
                goto CLEANUP;
            }
            buf = tmp;
            buf[bufSize++] = '\0';
            break;
        }
    }
    printf ("Input Sentence Is: %s\n", buf);
CLEANUP :
    if (buf)
        free (buf);
    return (rCode);
}
----------------------------------------

int main () {
    char *ch1 = calloc (1, 1), *tmp;
    size_t x = 1;
    int c;
    if (!ch1) {
        perror ("Failed to allocate string buffer.");
        exit (EXIT_FAILURE);
    }
    while ((c = getchar ()) != EOF && c != '\r' && c != '\n') {
        tmp = realloc (ch1, x +1);
        if (!tmp) {
            perror ("Failed to resize string buffer.");
            break;
        }
        ch1 = tmp;
        ch1[x - 1] = c;
        ch1[x++] = 0;
    }
    printf ("Input Sentence: %s\n", ch1);
    free (ch1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2383554_2383624_3_13
2383554_2384244_1_14
Title: A combined function for fprintf and write in c/c++ 
----------------------------------------

int fdprintf (int fd, const char *fmt, ... ) {
    char buffer [4096] = {0};
    int cc;
    va_list args;
    va_start (args, fmt);
    if ((cc = vsnprintf (buffer, 4096, fmt, args)) > 0) {
        write (fd, buffer, cc);
    }
    va_end (args);
    return cc;
}
----------------------------------------

int fdprintf (int fd, const char *fmt, ... ) {
    int cc;
    va_list args;
    va_start (args, fmt);
    int len = _vscprintf (fmt, args) + 1;
    char * buffer = new char [len];
    buffer[len] = 0;
    if ((cc = vsprintf_s (buffer, len -1, fmt, args)) > 0) {
        write (fd, buffer, cc);
    }
    va_end (args);
    delete [] buffer;
    return cc;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
238603_2003824_121_141
238603_246855_5_21
Title: How can I get a file's size in C? 
----------------------------------------

int main (int argc, const char *argv []) {
    int i;
    if (argc < 2) {
        printf ("%s <file1> <file2>...\n", argv [0]);
        exit (0);
    }
    for (i = 1; i < argc; i++) {
        seek_filesize (argv [i]);
        stat_filesize (argv [i]);
        fstat_filesize (argv [i]);
        fseek_filesize (argv [i]);
    }
    return 0;
}
----------------------------------------

int main () {
    int i;
    char a [MAXNUMBER];
    FILE *fp = popen ("du -b  /bin/bash", "r");
    while ((a[i++] = getc (fp)) != 9)
        ;
    a[i] = '\0';
    printf (" a is %s\n", a);
    pclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23862082_23862236_1_14
23862082_23895747_4_21
Title: ERROR in understanding bit-wise operations 
----------------------------------------

int main () {
    short s1, s2, s3 = 0;
    unsigned int addr = 4194624;
    s1 = f (addr, 20, 31);
    s2 = f (addr, 8, 19);
    s3 = f (addr, 0, 7);
    printf ("%d\n", s1);
    printf ("%d\n", s2);
    printf ("%d\n", s3);
    return 0;
}
----------------------------------------

void main () {
    unsigned long a = 4194624, e;
    int b, c, d;
    e = a;
    e = e >> 20;
    b = e;
    e = a;
    e = e << 12;
    e = e >> 20;
    c = e;
    e = a;
    e = e << 24;
    e = e >> 24;
    d = e;
    printf (" %d %d %d ", b, c, d);
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23863033_23863431_3_28
23863033_23864083_3_53
Title: How to convert binary to sentence 
----------------------------------------

int main () {
    char buf = 0;
    int bufi = 0;
    int bit;
    FILE *fp;
    fp = fopen ("bin", "r");
    if (!fp) {
        printf ("%s", "input file failed to open\n");
        return -1;
    }
    while ((bit = getc (fp)) != EOF) {
        if (bit == '0')
            bit = 0;
        else
            bit = 1;
        buf = buf | (bit << (7 - bufi));
        bufi++;
        if (bufi == 8) {
            printf ("%c", buf);
            bufi = buf = 0;
            int i;
        }
    }
    printf ("%s", "\n");
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int ch1 = 0;
    int ch2 = 0;
    int count = 0;
    char *file = argv[1];
    FILE *in = fopen (file, "r");
    if (in == NULL) {
        printf ("Unable to open file %s\n", file);
        return 1;
    }
    while ((ch1 = fgetc (in)) != EOF) {
        if (ch1 == '\n') {
            ch2 = 0;
            count = 0;
            fputc (ch1, stdout);
        }
        else if (ch1 == ':') {
            fputc (ch1, stdout);
        }
        else {
            ch2 <<= 1;
            if (ch1 == '1') {
                ch2 += 1;
            }
            count++;
            if (count == 8) {
                fputc (ch2, stdout);
                count = 0;
            }
        }
    }
    fputc ('\n', stdout);
    fclose (in);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23918559_23919630_25_38
23918559_23919646_5_20
Title: 32 bit binary-to-decimal conversion 
----------------------------------------

int main (int argc, char const *argv []) {
    char *x = malloc (33 * sizeof (char));
    setStr (x, "111");
    while (strlen (x) < 31) {
        prepend (x, "0");
    }
    printf ("%s\n", x);
    int i = strtol (x, NULL, 2);
    printf ("%d\n", i);
    free (x);
    return 0;
}
----------------------------------------

int main () {
    const char * const string_to_convert = "1010" int result = 0;
    for (int i = strlen (string_to_convert) - 1; i >= 0; --i) {
        if (string_to_convert[i] == '1') {
            result += (int) pow (10.0 d, (double) i)
        }
    }
    fprintf (stdout, "%d", result);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23924728_23924952_4_28
23924728_23926171_6_29
Title: Finding duplicate chars in argv[] 
----------------------------------------

int main (int argc, char *argv []) {
    int letters [26];
    for (int i = 0; i < 26; i++) {
        letters[i] = 0;
    }
    for (int i = 1; i < argc; i++) {
        cout << "processing word: " << argv[i] << endl;
        char *word = argv[i];
        for (int j = 0; j < strlen (word); j++) {
            cout << "\tprocessing letter: " << word[j] << endl;
            letters[(int) word[j] - 97]++;
        }
    }
    cout << "Letters that appear only once: " << endl;
    for (int i = 0; i < 26; i++) {
        if (letters[i] == 1)
            cout << (char) (i + 97) << endl;
    }
    return 0;
}
----------------------------------------

int main (int argC, char *argV []) {
    int arg;
    char *cp;
    int counters [256];
    memset (counters, 0, sizeof (counters));
    for (arg = 1; arg < argC; ++arg)
        for (cp = argV[arg]; *cp; ++cp)
            ++counters[(int) *cp];
    printf ("Duplicate character list: ");
    for (arg = 0; arg < 256; ++arg)
        if (counters[arg] > 1)
            printf ("%c ", arg);
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23933673_23933878_4_29
23933673_23933926_1_18
Title: C - how to rearrange a string 
----------------------------------------

void validate (char *input) {
    char four [4];
    size_t len = strlen (input);
    if (len < 5)
        return;
    memcpy (four, input, 4);
    memmove (input, & (input [4]), len - 4);
    memcpy (& (input [len - 4]), four, 4);
}
----------------------------------------

void validate (char *input) {
    char temp [10];
    strncpy (temp, input, 4);
    temp = '\0';
    for (i = 0; i < strlen (input) - 4; i++) {
        input[i] = input[i + 4];
    }
    for (i = strlen (input) - 4, j = 0; i < strlen (input); i++) {
        input[i] = temp[j];
        j++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23963747_23963977_9_80
23963747_23964293_5_27
Title: Reading strings from stdin 
----------------------------------------

int main (void) {
    char buffer [MAX_BUFFER];
    if (!fgets (buffer, MAX_BUFFER, stdin)) {
        fprintf (stderr, "Couldn't get input.\n");
        return EXIT_FAILURE;
    }
    else {
        size_t length = strlen (buffer);
        if (length && buffer[length - 1] == '\n') {
            buffer[length - 1] = '\0';
        }
    }
    char *my_strings [MAX_STRINGS + 1] = {NULL};
    int read_strings = 0;
    char *buf_ptr = buffer;
    while (*buf_ptr && read_strings < MAX_STRINGS) {
        char temp_buf [MAX_BUFFER] = {0};
        char *temp_ptr = temp_buf;
        while (*buf_ptr && isspace (*buf_ptr)) {
            ++buf_ptr;
        }
        if (*buf_ptr) {
            if (*buf_ptr == '"') {
                ++buf_ptr;
                while (*buf_ptr && *buf_ptr != '"') {
                    *temp_ptr++ = *buf_ptr++;
                }
                if (*buf_ptr) {
                    ++buf_ptr;
                }
            }
            else {
                while (*buf_ptr && !isspace (*buf_ptr)) {
                    *temp_ptr++ = *buf_ptr++;
                }
            }
            my_strings[read_strings] = malloc (strlen (temp_buf) +1);
            if (!my_strings[read_strings]) {
                fprintf (stderr, "Couldn't allocate memory.\n");
                return EXIT_FAILURE;
            }
            strcpy (my_strings [read_strings ++], temp_buf);
        }
    }
    for (size_t i = 0; my_strings[i]; ++i) {
        printf ("String %zu: %s\n", i + 1, my_strings [i]);
        free (my_strings [i]);
    }
    return 0;
}
----------------------------------------

int main () {
    char line [128] = "Boston \"New York\" \"San Francisco\" Memphis\n";
    char array [10] [32];
    char *p;
    int i, n, len;
    n = 0;
    for (p = line; *p; p += len) {
        while (isspace (*p))
            ++p;
        if (!*p)
            break;
        if (*p == '"') {
            sscanf (p, "\"%31[^\"]\"%n", array [n ++], & len);
        }
        else {
            sscanf (p, "%31s%n", array [n ++], & len);
        }
    }
    for (i = 0; i < n; ++i) {
        printf ("%s\n", array [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23965468_23965700_6_18
23965468_23965963_1_34
Title: Most efficient way to calculate lexicographic index 
----------------------------------------

int lexic_ix (int *arr, int N) {
    int output = 0;
    int fact = factorial (N);
    for (int i = 0; i < N - 1; i++) {
        int order = arr[i];
        for (int j = 0; j < i; j++)
            order -= arr[j] < arr[i];
        output += order * (fact /= N - i);
    }
    return output;
}
----------------------------------------

int lexic_ix (int arr [], int N) {
std :
    : unique_ptr < int [] > coeff_arr = std : : make_unique < int [] > (N);
    for (int i = 0; i < N - 1; i++) {
        int order = arr[i];
        for (int j = 0; j < i; j++)
            order -= arr[j] < arr[i];
        coeff_arr[i] = order;
    }
    long fac = 1;
    long sn = 0;
    for (int i = 1; i < N; ++i) {
        fac *= i;
        if (coeff_arr[N - 1 - i])
            sn += coeff_arr[N - 1 - i] * fac;
    }
    return sn;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2397792_13045126_6_27
2397792_35465092_3_21
Title: "Difference between ""pointer to int"" and ""pointer to array of ints""" 
----------------------------------------

int main () {
    int i, j, k = 1;
    int (*q) [MAXCOL];
    q = (int (*)[MAXCOL]) malloc (MAXROW * sizeof (*q));
    for (i = 0; i < MAXROW; i++)
        for (j = 0; j < MAXCOL; j++)
            q[i][j] = k++;
    for (i = 0; i < MAXROW; i++) {
        for (j = 0; j < MAXCOL; j++)
            printf (" %2d ", q[i][j]);
        printf ("\n");
    }
}
----------------------------------------

int main (void) {
    int (*x) [6];
    int y [6] = {11, 22, 33, 44, 55, 66};
    int *z;
    int i;
    z = y;
    for (i = 0; i < 6; i++)
        printf ("%d ", z[i]);
    printf ("\n");
    x = &y;
    for (int j = 0; j < 6; j++)
        printf ("%d ", *(x[0] + j));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2397792_13045126_6_27
2397792_39260146_1_15
Title: "Difference between ""pointer to int"" and ""pointer to array of ints""" 
----------------------------------------

int main () {
    int i, j, k = 1;
    int (*q) [MAXCOL];
    q = (int (*)[MAXCOL]) malloc (MAXROW * sizeof (*q));
    for (i = 0; i < MAXROW; i++)
        for (j = 0; j < MAXCOL; j++)
            q[i][j] = k++;
    for (i = 0; i < MAXROW; i++) {
        for (j = 0; j < MAXCOL; j++)
            printf (" %2d ", q[i][j]);
        printf ("\n");
    }
}
----------------------------------------

int main () {
    int arr [5] = {4, 5, 6, 7, 8};
    int (*pa) [5] = &arr;
    int *pi = arr;
    for (int i = 0; i < 5; i++) {
        printf ("\n%d %d", arr [i], (* pa) [i]);
    }
    printf ("\n0x%x -- 0x%x", pi, pa);
    pi++;
    pa++;
    printf ("\n0x%x -- 0x%x", pi, pa);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2397792_35465092_3_21
2397792_39260146_1_15
Title: "Difference between ""pointer to int"" and ""pointer to array of ints""" 
----------------------------------------

int main (void) {
    int (*x) [6];
    int y [6] = {11, 22, 33, 44, 55, 66};
    int *z;
    int i;
    z = y;
    for (i = 0; i < 6; i++)
        printf ("%d ", z[i]);
    printf ("\n");
    x = &y;
    for (int j = 0; j < 6; j++)
        printf ("%d ", *(x[0] + j));
    return 0;
}
----------------------------------------

int main () {
    int arr [5] = {4, 5, 6, 7, 8};
    int (*pa) [5] = &arr;
    int *pi = arr;
    for (int i = 0; i < 5; i++) {
        printf ("\n%d %d", arr [i], (* pa) [i]);
    }
    printf ("\n0x%x -- 0x%x", pi, pa);
    pi++;
    pa++;
    printf ("\n0x%x -- 0x%x", pi, pa);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2398905_2398908_2_17
2398905_2419149_10_40
Title: Reserve RAM in C 
----------------------------------------

int main (int argc, char *argv []) {
    int bytesToAllocate;
    char *bytesReserved = NULL;
    bytesReserved = malloc (bytesToAllocate);
    if (bytesReserved == NULL) {
    }
    free (bytesReserved);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    void *reserve;
    unsigned int amount;
    if (argc < 2) {
        fprintf (stderr, "usage: %s <megabytes>\n", argv [0]);
        return EXIT_FAILURE;
    }
    amount = atoi (argv[1]);
    printf ("About to reserve %ld MB (%ld Bytes) of RAM...\n", amount, amount * MULTIPLICATOR);
    reserve = calloc (amount *MULTIPLICATOR, 1);
    if (reserve == NULL) {
        fprintf (stderr, "Couldn't allocate memory\n");
        return EXIT_FAILURE;
    }
    printf ("Allocated. Press any key to release the memory.\n");
    getchar ();
    free (reserve);
    printf ("Deallocated reserved memory\n");
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23990616_23990836_4_25
23990616_23990961_3_33
Title: Find common value from two arrays 
----------------------------------------

int main (void) {
    int A [5], B [8], i, j, s = 1;
    int *c;
    c = (int *) malloc (s * sizeof (int));
    for (i = 0; i < 5; i++) {
        scanf ("\t %d", & A [i]);
    }
    printf ("\n");
    for (j = 0; j < 8; j++) {
        scanf ("\t %d", & B [j]);
    }
    for (i = 0; i < 5; i++) {
        for (j = 0; j < 8; j++) {
            if (A[i] == B[j]) {
                c[s - 1] = A[i];
                printf ("\n %d", c [s - 1]);
                s++;
                c = (int *) realloc (c, s * sizeof (int));
            }
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    int A [5], B [8], C [8];
    for (int i = 0; i < 5; i++)
        scanf (" %d ", &A[i]);
    printf ("\n");
    for (int i = 0; i < 8; i++)
        scanf (" %d ", &B[i]);
    int ci = 0;
    for (int ai = 0; ai < 5; ai++) {
        for (int bi = 0; bi < 8; bi++) {
            if (A[ai] == B[bi]) {
                C[ci] = A[ai];
                ci++;
                break;
            }
        }
    }
    C[ci] = 0;
    printf ("Common chars: %s\n", C);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24005270_24005421_22_49
24005270_24005442_22_49
Title: How to reverse a multidimensional array in C? 
----------------------------------------

int main () {
    char *array = malloc (WIDTH *HEIGHT);
    int i, j;
    for (i = 0; i < HEIGHT; i++) {
        for (j = 0; j < WIDTH; j++) {
            *(array + (i * WIDTH) +j) = (i * WIDTH) +j + 'a';
        }
    }
    print (array);
    char tmp;
    for (i = 0; i < HEIGHT; i++) {
        for (j = 0; j < WIDTH / 2; j++) {
            tmp = *(array + (i * WIDTH) +j);
            *(array + (i * WIDTH) +j) = *(array + (i * WIDTH) +(WIDTH - 1 - j));
            *(array + (i * WIDTH) +(WIDTH - 1 - j)) = tmp;
        }
    }
    printf ("PRINTING RESULT!\n");
    print (array);
}
----------------------------------------

int main () {
    char *array = malloc (WIDHT *HEIGHT);
    int i, j;
    for (i = 0; i < HEIGHT; i++) {
        for (j = 0; j < WIDHT; j++) {
            *(array + (i * WIDHT) +j) = (i * WIDHT) +j + 'a';
        }
    }
    print (array);
    char *tmp = malloc (WIDHT);
    for (i = 0; i < HEIGHT; i++) {
        for (j = 0; j < WIDHT / 2; j++) {
            *tmp = *(array + (i * WIDHT) +j);
            *(array + (i * WIDHT) +j) = *(array + (i * WIDHT) +(WIDHT - j - 1));
            *(array + (i * WIDHT) +(WIDHT - j - 1)) = *tmp;
        }
    }
    printf ("PRINTING RESULT!\n");
    print (array);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24005270_24005421_6_18
24005270_24005442_6_18
Title: How to reverse a multidimensional array in C? 
----------------------------------------

void print (char *imprimir) {
    int i, j;
    for (i = 0; i < HEIGHT; i++) {
        for (j = 0; j < WIDTH; j++) {
            printf ("%2c", * (imprimir + (i * WIDTH) + j));
        }
        printf ("\n");
    }
}
----------------------------------------

void print (char *imprimir) {
    int i, j;
    for (i = 0; i < HEIGHT; i++) {
        for (j = 0; j < WIDHT; j++) {
            printf ("%2c", * (imprimir + (i * WIDHT) + j));
        }
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24057354_24057696_8_24
24057354_24057784_11_28
Title: linked list in c programming language 
----------------------------------------

void create (int n, struct node **ref) {
    struct node *temp, *newnode;
    newnode = (struct node *) calloc (1, sizeof (struct node));
    newnode->val = n;
    newnode->next = NULL;
    if (*ref == NULL) {
        *ref = newnode;
    }
    else {
        lastnode->next = newnode;
    }
    lastnode = newnode;
    return;
}
----------------------------------------

void create (int n, struct node **ref) {
    static struct node *temp;
    struct node *newnode;
    newnode = (struct node *) calloc (1, sizeof (struct node));
    newnode->val = n;
    newnode->next = NULL;
    if (*ref == NULL) {
        *ref = newnode;
        temp = newnode;
    }
    else {
        temp->next = newnode;
        temp = newnode;
    }
    return;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24099073_24099129_13_25
24099073_24099932_37_73
Title: String Search Operation in C 
----------------------------------------

int main () {
    char s [SIZE];
    char *months [] = {"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"};
    int result;
    printf ("enter the month : ");
    gets (s);
    result = get_month (s, months);
    if (result)
        printf ("%s - %d.  is the month of the year.\n", s, result);
    else
        printf ("%s invalid\n", s);
    return 0;
}
----------------------------------------

int main (void) {
    int result = 0;
    char s [21] = {0};
    printf ("Enter a month: ");
    if (fgets (s, 20, stdin) == NULL) {
        return EXIT_FAILURE;
    }
    for (int idx = 0; idx < 21; ++idx) {
        if (!isalpha (s[idx])) {
            s[idx] = '\0';
        }
    }
    result = get_month_number (s);
    if (result < 0) {
        printf ("%s is an invalid argument.\n", s);
    }
    else {
        char a [3] = {0};
        switch (result) {
        case 1 :
            a[0] = 's';
            a[1] = 't';
            break;
        case 2 :
            a[0] = 'n';
            a[1] = 'd';
            break;
        case 3 :
            a[0] = 'r';
            a[1] = 'd';
            break;
        default :
            a[0] = 't';
            a[1] = 'h';
            break;
        }
        printf ("%s is the %d%s month of the year.\n", s, result, a);
    }
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24125039_24125076_1_18
24125039_24125417_1_18
Title: Pointers and enum in C 
----------------------------------------

void ChangeState (int *state, int NewState) {
    *state = NewState;
    if (*state == TITLE) {
    }
    else if (*state == PLAY) {
    }
    else if (*state == LOST) {
    }
}
----------------------------------------

void ChangeState (int *state, int NewState) {
    *state = NewState;
    switch (*state) {
    case TITLE :
        break;
    case PLAY :
        break;
    case LOST :
        break;
    default :
        break;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24127117_24127286_5_23
24127117_48902540_5_21
Title: Using fopen_s in C 
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp;
    if (argc != 2) {
        fprintf (stderr, "usage: %s filename\n", argv [0]);
        return 2;
    }
    fp = fopen (argv[1], "rb");
    if (!fp) {
        fprintf (stderr, "opening %s: %s\n", argv [1], strerror (errno));
        return 1;
    }
    return 0;
}
----------------------------------------

int main () {
    int score = 10;
    FILE *fp;
    errno_t err;
    if ((err = fopen_s (&fp, "C:\\Users\\achea\\Desktop\\File.txt", "w+")) != 0) {
        printf ("File was not opened\n");
    }
    else {
        fprintf (fp, "Date: %s, Time: %s, Score: %i \n", __DATE__, __TIME__, score);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24132393_24132510_3_23
24132393_24133460_4_23
Title: Read two whole numbers and find all the positive multiples of the first that are less than the second 
----------------------------------------

int main () {
    int a, b;
    int num = 0;
    printf ("\nIntroduce the first number:");
    scanf ("%d", & a);
    printf ("\nIntroduce the second number:");
    scanf ("%d", & b);
    for (a = 1; a <= 10; a++) {
        for (b = 20; b <= 50; b++) {
            while (a < b)
                num = a * a;
            printf ("\n%d", num);
        }
    }
    getch ();
    return 0;
}
----------------------------------------

int main () {
    int a, b;
    int i;
    int num = 0;
    printf ("\nIntroduce the first number:");
    scanf ("%d", & a);
    printf ("\nIntroduce the second number:");
    scanf ("%d", & b);
    for (i = 1;; i++) {
        num = a * i;
        if (num > b)
            break;
        printf ("%d ", num);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24133850_24134219_1_18
24133850_24134939_1_11
Title: Reversing a linked list (by recursion) not working 
----------------------------------------

void reverselinklist (struct node **head_ref) {
    struct node *first;
    struct node *rest;
    first = *head_ref;
    rest = first->next;
    if (rest == NULL)
        return;
    reverselinklist (& rest);
    first->next->next = first;
    first->next = NULL;
    *head_ref = rest;
}
----------------------------------------

void reverselinklist (struct node **headreverse) {
    struct node *p = *headreverse;
    if (p->next == NULL) {
        return;
    }
    *headreverse = p->next;
    reverselinklist (headreverse);
    p->next->next = p;
    p->next = NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24158482_24159612_4_51
24158482_24162657_4_74
Title: Comparing substring of a character array with another character array in C 
----------------------------------------

int main () {
    char e [1000] = "somet\n\nhing";
    char pi [1000] = "some other t\nhing\t som\neth\n\ning";
    int longestlen = 0;
    int longestx = 0;
    int pix = 0;
    int ex = 0;
    int piwhitespace = 0;
    int ewhitespace = 0;
    while (pix + ex + piwhitespace < 1000) {
        while (iswhitespace (e[ex + ewhitespace]))
            ewhitespace++;
        while (iswhitespace (pi[pix + ex + piwhitespace]))
            piwhitespace++;
        if (e[ex + ewhitespace] != '\0' && pi[pix + ex + piwhitespace] != '\0' && pi[pix + ex + piwhitespace] == e[ex + ewhitespace]) {
            if (ex == 0) {
                pix += piwhitespace;
                piwhitespace = 0;
            }
            ex++;
        }
        else {
            if (ex > longestlen) {
                longestlen = ex;
                longestx = pix;
            }
            pix += piwhitespace + 1;
            piwhitespace = 0;
            ex = 0;
            ewhitespace = 0;
        }
    }
    printf ("Longest sqn is %d chars long starting at %d", longestlen, longestx + 1);
    putchar (10);
    return 0;
}
----------------------------------------

int main () {
    FILE *e;
    FILE *pi;
    if ((e = fopen ("e", "r")) == NULL) {
        printf ("failure at line %d\n", __LINE__);
        return -1;
    }
    if ((pi = fopen ("pi", "r")) == NULL) {
        printf ("failure at line %d\n", __LINE__);
        return -1;
    }
    int curre = fgetc (e);
    int currpi = fgetc (pi);
    int currentlength = 0;
    int longestlength = 0;
    int longestindex = 0;
    int whitespaces = 0;
    fpos_t startpoint;
    if (curre == EOF || currpi == EOF) {
        printf ("either one of the files are empty\n");
        return -1;
    }
    while (1) {
        while (iswhitespace (currpi))
            currpi = fgetc (pi);
        while (iswhitespace (curre))
            curre = fgetc (e);
        if (curre == currpi && currpi != EOF) {
            if (currentlength == 0 && fgetpos (pi, &startpoint)) {
                printf ("failure at line %d\n", __LINE__);
                return -1;
            }
            currentlength++;
            curre = fgetc (e);
        }
        else if (currentlength != 0) {
            if (currentlength > longestlength) {
                longestlength = currentlength;
                longestindex = startpoint;
            }
            if (curre == EOF) {
                printf ("Complete match!\n");
                break;
            }
            fsetpos (pi, & startpoint);
            rewind (e);
            curre = fgetc (e);
            currentlength = 0;
        }
        if (currpi == EOF)
            break;
        currpi = fgetc (pi);
    }
    printf ("Longest sequence is %d characters long starting at %d", longestlength, longestindex);
    putchar (10);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24181878_24183842_15_29
24181878_24194464_5_36
Title: How to random flip binary bit of char in C/C++ 
----------------------------------------

void main () {
    char input [] = "0A F5 6D 02";
    char data [4] = {};
    scanf ("%2x %2x %2x %2x", & data [0], & data [1], & data [2], & data [3]);
    int * x = reinterpret_cast < int * > (data);
    int y = rand ();
    while (count_1s (y) != 5) {
        y = rand ();
    }
    *x ^= y;
    printf ("%2x %2x %2x %2x" data [0], data [1], data [2], data [3]);
    return 0;
}
----------------------------------------

int main (void) {
    char *hexToDec_lookup = "0123456789ABCDEF";
    char hexstr [] = "0A F5 6D 02";
    srand (time (0));
    int i;
    for (i = 0; i < 5; i++) {
        int hexdigit = rand () & 7;
        hexdigit += (hexdigit >> 1);
        int hexvalue = hexstr[hexdigit] > '9' ? hexstr[hexdigit] - 'A' + 10 : hexstr[hexdigit] - '0';
        hexvalue ^= 1 << (rand () & 3);
        hexstr[hexdigit] = hexToDec_lookup[hexvalue];
        printf ("[%s]\n", hexstr);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24195200_24196053_5_36
24195200_24198768_3_23
Title: Finding biggest and smallest numbers using user input 
----------------------------------------

int main () {
    int num;
    int i;
    int maxi = 0;
    int minim = INT_MAX;
    int cont = 0;
    printf ("\nQuantity of numbers?: ");
    scanf ("%d", & num);
    if (num > 0) {
        while (num > 0) {
            printf ("\nEnter number:");
            if (scanf ("%d", &i) == 1 && !(i < 0)) {
                if (minim > i)
                    minim = i;
                if (maxi < i)
                    maxi = i;
                ++cont;
                --num;
            }
            else {
            }
            scanf ("%*[^\n]%*c");
        }
        printf ("\nBiggest number is : %d", maxi);
        printf ("\nSmallest number is : %d\n", minim);
    }
    getch ();
    return 0;
}
----------------------------------------

int main () {
    int num;
    int maxi = INT_MIN;
    int mini = INT_MAX;
    int temp;
    scanf ("%d", & num);
    while (num--) {
        scanf ("%d", & temp);
        if (temp > maxi)
            maxi = temp;
        if (temp < mini)
            mini = temp;
    }
    printf ("\nMaxi is:\t%d\nMini is:\t%d\n", maxi, mini);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24198726_24198820_4_13
24198726_24198967_4_17
Title: Find the numbers that are multiples of 3 between 100 and 40 
----------------------------------------

int main () {
    int n = 3;
    int i = 100;
    for (i = 100; i >= 40; i--)
        if ((i % n) == 0)
            printf (" %d ", i);
    getch ();
    return 0;
}
----------------------------------------

int main () {
    int i;
    for (i = 100; i >= 40; i--) {
        if (i % 3 == 0)
            printf ("%d\n", i);
    }
    getch ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24215449_24215512_1_58
24215449_24215529_1_40
Title: Memory cleanup in functions with many return points 
----------------------------------------

int some_func (size_t len1, size_t len2, size_t len3) {
    int rCode = 0;
    char *a = NULL;
    struct someStruct *p1 = NULL;
    struct otherStruct *p2 = NULL;
    if ((0 == len1) || (0 == len2) || (0 == len3)) {
        printf ("Must give positive parameters.");
        rCode = EINVAL;
        goto CLEANUP;
    }
    errno = 0;
    a = malloc (len1);
    if (NULL == a) {
        rCode = errno ? errno : ENOMEM;
        printf ("malloc failed.  errno:%d", errno);
        goto CLEANUP;
    }
    errno = 0;
    p1 = malloc (len2);
    if (NULL == p1) {
        rCode = errno ? errno : ENOMEM;
        printf ("malloc failed.  errno:%d", errno);
        goto CLEANUP;
    }
    errno = 0;
    p2 = malloc (len2);
    if (NULL == p2) {
        rCode = errno ? errno : ENOMEM;
        printf ("malloc failed.  errno:%d", errno);
        goto CLEANUP;
    }
CLEANUP :
    if (a)
        free (a);
    if (p1)
        free (p1);
    if (p2)
        free (p2);
    return (rCode);
}
----------------------------------------

int some_func (size_t len1, size_t len2, size_t len3) {
    char *a;
    struct someStruct *p1;
    struct otherStruct *p2;
    int success = 1;
    if ((len1 == 0) || (len2 == 0) || (len3 == 0)) {
        printf ("Must give positive parameters.");
        return -1;
    }
    a = malloc (len1);
    if (a == NULL)
        success = 0;
    p1 = malloc (len2);
    if (p1 == NULL)
        success = 0;
    p2 = malloc (len2);
    if (p2 == NULL)
        success = 0;
    if (success) {
        return 0;
    }
    printf ("malloc() failed.\n");
    free (a);
    free (p1);
    free (p2);
    return -1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2422742_2422766_1_21
2422742_2422788_6_39
Title: Filter string in C 
----------------------------------------

int main (int argc, char **argv) {
    char *name = argv[1];
    char strippedName [200];
    int iIn, iOut;
    iIn = iOut = 0;
    while (name[iIn] != '\0' && iOut < (sizeof (strippedName) + 1)) {
        if (isalnum (name[iIn]) || name[iIn] == '_')
            strippedName[iOut++] = name[iIn];
        iIn++;
    }
    strippedName[iOut++] = '\0';
    printf ("%s", strippedName);
}
----------------------------------------

int main (int argc, char **argv) {
    char *name, *inp, *outp;
    if (argc < 2) {
        fprintf (stderr, "Insufficient arguments.\n");
        return 1;
    }
    inp = argv[1];
    name = malloc (strlen (inp) +1);
    outp = name;
    if (!name) {
        fprintf (stderr, "Out of memory.\n");
        return 2;
    }
    while (*inp) {
        if (islower ((unsigned char) *inp) || isdigit ((unsigned char) *inp) || *inp == '_')
            *outp++ = *inp;
        inp++;
    }
    *outp = '\0';
    puts (name);
    free (name);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2422742_2422766_1_21
2422742_2422866_4_16
Title: Filter string in C 
----------------------------------------

int main (int argc, char **argv) {
    char *name = argv[1];
    char strippedName [200];
    int iIn, iOut;
    iIn = iOut = 0;
    while (name[iIn] != '\0' && iOut < (sizeof (strippedName) + 1)) {
        if (isalnum (name[iIn]) || name[iIn] == '_')
            strippedName[iOut++] = name[iIn];
        iIn++;
    }
    strippedName[iOut++] = '\0';
    printf ("%s", strippedName);
}
----------------------------------------

int main (int argc, char **argv) {
    int i;
    char *p;
    if (argc > 1) {
        for (p = argv[1]; *p != '\0'; p++) {
            if (islower (*p) || isdigit (*p) || *p == '_') {
                putchar (*p);
            }
        }
        putchar ('\n');
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2422742_2422788_6_39
2422742_2422866_4_16
Title: Filter string in C 
----------------------------------------

int main (int argc, char **argv) {
    char *name, *inp, *outp;
    if (argc < 2) {
        fprintf (stderr, "Insufficient arguments.\n");
        return 1;
    }
    inp = argv[1];
    name = malloc (strlen (inp) +1);
    outp = name;
    if (!name) {
        fprintf (stderr, "Out of memory.\n");
        return 2;
    }
    while (*inp) {
        if (islower ((unsigned char) *inp) || isdigit ((unsigned char) *inp) || *inp == '_')
            *outp++ = *inp;
        inp++;
    }
    *outp = '\0';
    puts (name);
    free (name);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int i;
    char *p;
    if (argc > 1) {
        for (p = argv[1]; *p != '\0'; p++) {
            if (islower (*p) || isdigit (*p) || *p == '_') {
                putchar (*p);
            }
        }
        putchar ('\n');
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24232575_26285124_5_85
24232575_41022697_12_79
Title: DFA is not accepting strings 
----------------------------------------

int main () {
    int a, b, i, j, k, state, ch;
    char s [10] [10], *st, v [10], ss [10];
    printf ("Enter the number of state:\n");
    scanf ("%d", & a);
    printf ("Enter State :\n");
    for (i = 0; i < a; i++) {
        fflush (stdin);
        scanf ("%c", & ss [i]);
    }
    printf ("Enter th no. of var..:\n");
    scanf ("%d", & b);
    printf ("Enter variable :\n");
    for (i = 0; i < b; i++) {
        fflush (stdin);
        scanf ("%c", & v [i]);
    }
    printf ("Enter table:\n");
    for (i = 0; i < a; i++) {
        for (j = 0; j < b; j++) {
            fflush (stdin);
            scanf ("%c", & s [i] [j]);
        }
    }
    printf ("Enter string :\n");
    fflush (stdin);
    gets (st);
    i = 0;
    state = 0;
    while (st[i] != '\0') {
        for (j = 0; j < b; j++) {
            if (st[i] == v[j]) {
                if (s[state][j] == '-') {
                    goto check;
                }
                else {
                    for (k = 0; k < a; k++) {
                        if (s[state][j] == ss[k]) {
                            printf ("State:%c\n", s [state] [j]);
                            state = k;
                            goto o;
                        }
                    }
                }
            o :
            }
        }
        i++;
    }
check :
    ch = 1;
    for (i = 0; i < b; i++) {
        if (s[state][i] != '-') {
            ch = 0;
        }
    }
    if (ch == 1) {
        printf ("String is matching..");
    }
    else {
        printf ("String is not matching..");
    }
    getch ();
    return 0;
}
----------------------------------------

int main () {
    int nstates, nfinals;
    int f [10];
    int i, j, s = 0, final = 0;
    printf ("enter the number of states that your dfa consist of \n");
    scanf ("%d", & nstates);
    printf ("enter the number of input symbol that dfa have \n");
    scanf ("%d", & ninputs);
    printf ("\nenter input symbols");
    for (i = 0; i < ninputs;) {
        bb = i;
        printf ("\n %d input", bb + 1);
        scanf (" %c", & c [i]);
        i++;
    }
    printf ("\n\nenter number of final states\t");
    scanf ("%d", & nfinals);
    for (i = 0; i < nfinals; i++) {
        printf ("\n\nFinal state %d : q", i + 1);
        scanf ("%d", & f [i]);
    }
    printf ("-----------------------------------------------------------------------");
    printf ("\n\ndefine transition rule as (initial state, input symbol ) = final state\n");
    for (i = 0; i < ninputs; i++) {
        for (j = 0; j < nstates; j++) {
            printf ("\n(q%d , %c ) = q", j, c [i]);
            scanf ("%d", & dfa [i] [j]);
        }
    }
    do {
        i = 0;
        printf ("\n\nEnter Input String.. ");
        scanf ("%s", string);
        while (string[i] != '\0')
            if ((s = check (string[i++], s)) < 0)
                break;
        for (i = 0; i < nfinals; i++)
            if (f[i] == s)
                final = 1;
        if (final == 1)
            printf ("\n valid string");
        else
            printf ("invalid string");
        printf ("\nDo you want to continue.?  \n(y/n) ");
    }
    while (b == 'y');
    scanf (" %c", & b);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24233141_24233205_1_12
24233141_24233406_4_20
Title: C: Scan array with Integers 
----------------------------------------

void main () {
    int *arr = (int *) malloc (0);
    int size = 0;
    int val;
    for (size = 0; scanf ("%d", &val) != EOF; size++) {
        arr = (int *) realloc (arr, size +1);
        arr[size] = val;
    }
    free (arr);
}
----------------------------------------

int main () {
    int *ar, i, j, h;
    scanf ("%d", & i);
    ar = (int *) malloc (sizeof (int) * i);
    for (j = 0; j < i; j++) {
        scanf ("%d", & h);
        *(ar + j) = h;
    }
    for (j = 0; j < i; j++)
        printf ("%d\n", ar[j]);
    free (ar);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24235136_24235370_3_21
24235136_24243900_4_20
Title: Trying to scan a list of names into a double pointer 
----------------------------------------

static int insert_data (char **strings, const char *filename, int size) {
    int j = 0;
    FILE *file = fopen (filename, "r");
    if (file == NULL) {
        fprintf (stderr, "File %s could not be opened\n", filename);
        return 0;
    }
    for (j = 0; j < size; j++) {
        if (fscanf (file, "%s", strings[j]) != 1)
            return j;
        printf ("%s\n", strings [j]);
    }
    fclose (file);
    return size;
}
----------------------------------------

void insert_data (char **strings, const char *filename, int size) {
    int j = 0;
    FILE *file = fopen (filename, "r");
    if (file == NULL) {
        printf ("File could not be opened");
        return;
    }
    for (j = 0; j < size; j++) {
        fscanf (file, "%" S (MAX_STRING_LEN) "s", strings [j]);
        printf ("%s\n", strings [j]);
    }
    fclose (file);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24235990_24236013_1_11
24235990_24257663_1_11
Title: Linked list help requested 
----------------------------------------

Lista destroi_lista_res (Lista lista) {
    Lista temp_ptr;
    while (lista != NULL) {
        temp_ptr = lista;
        lista = lista->next;
        free (temp_ptr);
    }
    return NULL;
}
----------------------------------------

Lista destroi_lista_res (Lista lista) {
    Lista temp_ptr;
    while (lista != NULL) {
        temp_ptr = lista;
        lista = lista->next;
        free (temp_ptr);
    }
    return NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24249238_24249477_3_27
24249238_24269713_3_25
Title: error: âparent_windowâ undeclared 
----------------------------------------

int main (int argc, char *argv []) {
    GtkWidget *dialog;
    gtk_init (& argc, & argv);
    dialog = gtk_file_chooser_dialog_new ("Open File", NULL, GTK_FILE_CHOOSER_ACTION_OPEN, "_Cancel", GTK_RESPONSE_CANCEL, "_Open", GTK_RESPONSE_ACCEPT, NULL);
    if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
        char *filename;
        GtkFileChooser *chooser = GTK_FILE_CHOOSER (dialog);
        filename = gtk_file_chooser_get_filename (chooser);
        g_message ("File selected: %s", filename);
        g_free (filename);
    }
    gtk_widget_destroy (dialog);
    gtk_main ();
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    GtkWidget *dialog;
    gtk_init (& argc, & argv);
    dialog = gtk_file_chooser_dialog_new ("Open File", NULL, GTK_FILE_CHOOSER_ACTION_OPEN, GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL, GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT, NULL);
    if (gtk_dialog_run (GTK_DIALOG (dialog)) == GTK_RESPONSE_ACCEPT) {
        char *filename;
        filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
        printf ("Selected file: %s\n", filename);
    }
    else {
        gtk_widget_destroy (dialog);
        return 0;
    }
    gtk_main ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24250519_24250803_1_19
24250519_24252106_49_61
Title: Find a two digit number with recursion 
----------------------------------------

int calcPair (int a, int b) {
    int number;
    if (a < 10 && b < 10) {
        number = a * 10 + b;
    }
    else {
        int digita = a % 10;
        int digitb = b % 10;
        number = calcPair (a / 10, b / 10);
        if (digita > number / 10) {
            number = digita * 10 + number % 10;
        }
        if (digitb < number % 10) {
            number = (number / 10) * 10 + digitb;
        }
    }
    return number;
}
----------------------------------------

int calcPair (int a, int b) {
    char big [10] = {""}, small [10] = {""};
    char Big, Small;
    char result [3] = {""};
    sprintf (big, "%d", a);
    sprintf (small, "%d", b);
    Big = getMaxDigit (big);
    Small = getMinDigit (small);
    sprintf (result, "%c%c", Big, Small);
    return atoi (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
242665_244310_1_20
242665_245335_9_43
Title: Understanding engine initialization in OpenSSL 
----------------------------------------

int main () {
    unsigned char *key = (unsigned char *) "Jefe";
    unsigned char *data = (unsigned char *) "what do ya want for nothing?";
    unsigned char *expected = (unsigned char *) "5bdcc146bf60754e6a042426089575c75a003f089d2739839dec58b964ec3843";
    unsigned char *result;
    unsigned int result_len = 32;
    int i;
    static char res_hexstring [32];
    result = HMAC (EVP_sha256 (), key, 4, data, 28, NULL, NULL);
    for (i = 0; i < result_len; i++) {
        sprintf (& (res_hexstring [i * 2]), "%02x", result [i]);
    }
    if (strcmp ((char *) res_hexstring, (char *) expected) == 0) {
        printf ("Test ok, result length %d\n", result_len);
    }
    else {
        printf ("Got %s instead of %s\n", res_hexstring, expected);
    }
}
----------------------------------------

int main (void) {
    unsigned char *key = (unsigned char *) "\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b";
    unsigned char *data = (unsigned char *) "\x48\x69\x20\x54\x68\x65\x72\x65";
    unsigned char *expected = (unsigned char *) "\x49\x2c\xe0\x20\xfe\x25\x34\xa5\x78\x9d\xc3\x84\x88\x06\xc7\x8f\x4f\x67\x11\x39\x7f\x08\xe7\xe7\xa1\x2c\xa5\xa4\x48\x3c\x8a\xa6";
    unsigned char *result;
    unsigned int result_len = 32;
    int i;
    HMAC_CTX ctx;
    result = (unsigned char *) malloc (sizeof (char) * result_len);
    ENGINE_load_builtin_engines ();
    ENGINE_register_all_complete ();
    HMAC_CTX_init (& ctx);
    HMAC_Init_ex (& ctx, key, 16, EVP_sha256 (), NULL);
    HMAC_Update (& ctx, data, 8);
    HMAC_Final (& ctx, result, & result_len);
    HMAC_CTX_cleanup (& ctx);
    for (i = 0; i != result_len; i++) {
        if (expected[i] != result[i]) {
            printf ("Got %02X instead of %02X at byte %d!\n", result [i], expected [i], i);
            break;
        }
    }
    if (i == result_len) {
        printf ("Test ok!\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24274627_24274658_1_11
24274627_24274712_15_26
Title: Value of Passed-By-Value Struct Does Not Change 
----------------------------------------

void addNode (int num, struct test **tester) {
    struct test *example = malloc (sizeof (struct test));
    if (NULL == example)
        exit (0);
    example->num = num;
    if (NULL == *tester)
        *tester = example;
    else
        (*tester)->next = example;
}
----------------------------------------

void addNode (int num, struct test **tester) {
    / * wrong, check next item * / assert (tester != NULL);
    struct test example = malloc (sizeof (struct test));
    example->num = num;
    if (*tester == NULL) {
        *tester = example;
    }
    else {
        (*tester)->next = example;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24276817_24276878_4_22
24276817_24276884_3_20
Title: C: Store a list of ints in Array 
----------------------------------------

int main (void) {
    int i, j, arr [40];
    int flg = 0;
    for (i = 2; i < 40; i++) {
        for (j = 2; j < i; j++) {
            if (i % j == 0)
                flg = 1;
        }
        if (flg == 0)
            arr[i] = i;
        else
            arr[i] = 0;
        flg = 0;
        printf ("%d\n", arr [i]);
    }
}
----------------------------------------

int main (void) {
    int i, j, arr [40] = {0};
    for (i = 2; i < 40; i++) {
        for (j = 2; j < i; j++) {
            if (i % j == 0) {
                arr[i] = 0;
                break;
            }
            arr[i] = i;
        }
    }
    for (i = 1; i < 40; i++)
        printf ("%d\n", arr[i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24276817_24276878_4_22
24276817_24277092_10_23
Title: C: Store a list of ints in Array 
----------------------------------------

int main (void) {
    int i, j, arr [40];
    int flg = 0;
    for (i = 2; i < 40; i++) {
        for (j = 2; j < i; j++) {
            if (i % j == 0)
                flg = 1;
        }
        if (flg == 0)
            arr[i] = i;
        else
            arr[i] = 0;
        flg = 0;
        printf ("%d\n", arr [i]);
    }
}
----------------------------------------

void main () {
    int i, p, index, arr [40];
    for (i = 2; index = 0, i <= 40; i++, index++) {
        p = prime (i);
        if (p == 1)
            arr[index] = i;
        else
            arr[index] = 0;
        printf ("%d\n", arr [index]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24276817_24276884_3_20
24276817_24277092_10_23
Title: C: Store a list of ints in Array 
----------------------------------------

int main (void) {
    int i, j, arr [40] = {0};
    for (i = 2; i < 40; i++) {
        for (j = 2; j < i; j++) {
            if (i % j == 0) {
                arr[i] = 0;
                break;
            }
            arr[i] = i;
        }
    }
    for (i = 1; i < 40; i++)
        printf ("%d\n", arr[i]);
}
----------------------------------------

void main () {
    int i, p, index, arr [40];
    for (i = 2; index = 0, i <= 40; i++, index++) {
        p = prime (i);
        if (p == 1)
            arr[index] = i;
        else
            arr[index] = 0;
        printf ("%d\n", arr [index]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24278377_24278819_4_22
24278377_24281291_5_27
Title: 2D pointer array to 2d array 
----------------------------------------

int main (void) {
    char *s [] = {"to err is human", "but to really mess things up ", "one needs to know c!!", '\0'};
    int i = 0;
    char SA [100] [100];
    while (s[i] != '\0') {
        strcpy (SA [i], s [i]);
        i++;
    }
    SA
    [i] = '\0' printf ("SA[1][1] : %c\n", SA [1] [1]);
    return 0;
}
----------------------------------------

int main (void) {
    char *s [] = {"to err is human", "but to really mess things up ", "one needs to know c!!"};
    int i, size = sizeof (s) / sizeof (*s);
    char ns [size] [50];
    for (i = 0; i < size; ++i) {
        memset (ns [i], 0, 50);
        strcpy (ns [i], s [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2427909_2428565_70_91
2427909_2428697_6_35
Title: C: How to convert a string of ints into actual ints and store them in an array? 
----------------------------------------

int main (void) {
    int values [5];
    char *str = "14 22 33 48 5q";
    size_t converted;
    stringToIntList (str, values, sizeof values / sizeof values [0], & converted);
    if (converted > 0) {
        size_t i;
        printf ("Converted %lu items from \"%s\":\n", (unsigned long) converted, str);
        for (i = 0; i < converted; i++)
            printf ("arr[%lu] = %d\n", (unsigned long) i, arr[i]);
    }
    else {
        printf ("Could not convert any of \"%s\" to equivalent integer values\n", str);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    const char *str = "14 22 33 48";
    int array [ARRAY_SIZE];
    size_t index = 0;
    char *pos = (char *) str;
    while (*pos && index < ARRAY_SIZE) {
        long value = strtol (pos, &pos, 10);
        if (*pos != ' ' && *pos != '\0') {
            fprintf (stderr, "Invalid character at %s\n", pos);
            break;
        }
        array[index] = (int) value;
        index++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2427909_2428565_70_91
2427909_32489941_5_17
Title: C: How to convert a string of ints into actual ints and store them in an array? 
----------------------------------------

int main (void) {
    int values [5];
    char *str = "14 22 33 48 5q";
    size_t converted;
    stringToIntList (str, values, sizeof values / sizeof values [0], & converted);
    if (converted > 0) {
        size_t i;
        printf ("Converted %lu items from \"%s\":\n", (unsigned long) converted, str);
        for (i = 0; i < converted; i++)
            printf ("arr[%lu] = %d\n", (unsigned long) i, arr[i]);
    }
    else {
        printf ("Could not convert any of \"%s\" to equivalent integer values\n", str);
    }
    return 0;
}
----------------------------------------

void main () {
    char arr1 [1000];
    int array [1000];
    gets (arr1);
    int i = 0, j, k = 0;
    while (i < strlen (arr1)) {
        j = i + 1;
        while (*(arr1 + j) != ' ')
            j++;
        *(array + k) = atoi1 (arr1, i, j -1);
        i = j + 1;
        k++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2427909_2428697_6_35
2427909_32489941_5_17
Title: C: How to convert a string of ints into actual ints and store them in an array? 
----------------------------------------

int main (int argc, char *argv []) {
    const char *str = "14 22 33 48";
    int array [ARRAY_SIZE];
    size_t index = 0;
    char *pos = (char *) str;
    while (*pos && index < ARRAY_SIZE) {
        long value = strtol (pos, &pos, 10);
        if (*pos != ' ' && *pos != '\0') {
            fprintf (stderr, "Invalid character at %s\n", pos);
            break;
        }
        array[index] = (int) value;
        index++;
    }
}
----------------------------------------

void main () {
    char arr1 [1000];
    int array [1000];
    gets (arr1);
    int i = 0, j, k = 0;
    while (i < strlen (arr1)) {
        j = i + 1;
        while (*(arr1 + j) != ' ')
            j++;
        *(array + k) = atoi1 (arr1, i, j -1);
        i = j + 1;
        k++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24301552_24302365_10_29
24301552_24302578_27_49
Title: How to undo changes to an array after passing to a function 
----------------------------------------

int main (void) {
    int array [5] = {1, 2, 3, 4, 5};
    save ("save_2", & array [2], sizeof (int));
    function (array);
    undo ("save_2");
    save ("save_all", array, sizeof (array));
    function (array);
    undo ("save_all");
    for (int i = 0; i < 5; ++i)
        printf ("%d\n", array[i]);
    remove ("save_2");
    remove ("save_all");
    return 0;
}
----------------------------------------

int main (void) {
    t_undo *undo;
    int array [] = {1, 2, 3, 4, 5};
    size_t i, j = 0, n = sizeof (array) / sizeof (array[0]);
    undo = malloc (sizeof (*undo));
    undo->value = NULL;
    undo->length = 0;
    function (undo, array, 2, 20);
    puts ("After function:");
    printarr (array, n);
    for (i = 0; i < n; i++) {
        if (array[i] < 0)
            array[i] = undo->value[j++];
    }
    puts ("Original values:");
    printarr (array, n);
    free (undo -> value);
    free (undo);
    return 0;
}
----------------------------------------
