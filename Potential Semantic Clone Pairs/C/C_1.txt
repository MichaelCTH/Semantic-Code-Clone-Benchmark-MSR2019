$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11219587_11220352_4_23
11219587_11220527_3_19
Title: Using sscanf() to output only 2 tokens from a line 
----------------------------------------

int main (void) {
    char buff [50];
    char *token;
    int number = 0;
    while (fgets (buff, sizeof (buff), stdin) != NULL) {
        if ((token = strtok (buff, " ")) != NULL) {
            ++number;
            while ((token = strtok (NULL, " ")) != NULL)
                ++number;
        }
        if (number == 2)
            printf ("Current line has two tokens\n");
        else
            printf ("current line has %d tokens\n", number);
        number = 0;
    }
    return 0;
}
----------------------------------------

int main (void) {
    char buff [50];
    char token1 [50];
    char token2 [50];
    char token3 [50];
    while (fgets (buff, sizeof (buff), stdin) != NULL) {
        if (sscanf (buff, "%s%s%s", token1, token2, token3) == 2) {
            printf ("%s %s\n", token1, token2);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11219587_11220368_3_16
11219587_11220527_3_19
Title: Using sscanf() to output only 2 tokens from a line 
----------------------------------------

int main (void) {
    char buff [50];
    char token1 [50], token2 [50];
    while (fgets (buff, sizeof (buff), stdin) != NULL) {
        if (sscanf (buff, "%s %s", token1, token2) == 2) {
            printf ("%s ", buff);
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char buff [50];
    char token1 [50];
    char token2 [50];
    char token3 [50];
    while (fgets (buff, sizeof (buff), stdin) != NULL) {
        if (sscanf (buff, "%s%s%s", token1, token2, token3) == 2) {
            printf ("%s %s\n", token1, token2);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11269792_11271061_43_64
11269792_11271231_21_38
Title: convert csv string to array of floats 
----------------------------------------

int main () {
    char my_string [] = "1.0,2.0,3.0";
    float *my_array;
    char **strs;
    size_t count;
    strs = split (my_string, ", \t", &count);
    my_array = (float *) malloc (sizeof (float) * count);
    {
        int i;
        for (i = 0; i < count; ++i)
            my_array[i] = (float) atof (strs[i]);
        free4split (strs);
    }
    {
        int i;
        for (i = 0; i < count; ++i)
            printf ("%f\n", my_array[i]);
    }
    return 0;
}
----------------------------------------

int main () {
    char my_string [] = "1.0,2.0,3.0";
    float *my_array = NULL;
    char *word, *p = my_string;
    int count = 0;
    while (NULL != (word = getToken (&p, ','))) {
        my_array = (float *) realloc (my_array, sizeof (float) * (++count));
        my_array[count - 1] = (float) atof (word);
        free (word);
    }
    {
        int i;
        for (i = 0; i < count; ++i)
            printf ("%f\n", my_array[i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11273591_11273647_1_11
11273591_11273677_4_25
Title: Function to get a string and return same after processing in C 
----------------------------------------

void getstring (char str [], char rtn []) {
    int i = 0, j = 0;
    while (i < strlen (str)) {
        if (str[i] != ' ' && str[i] != '$')
            rtn[j++] = str[i];
        i++;
    }
    rtn[j] = '\0';
}
----------------------------------------

void getstring (char *str) {
    int j, i = 0, len = strlen (str);
    while (i < len) {
        char ch = str[i];
        if (ch == ' ' || ch == '$') {
            for (j = i; j < len + 1; j++) {
                str[j] = str[j + 1];
            }
            len--;
            i--;
        }
        i++;
    }
    str[len] = 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11277641_11277936_2_28
11277641_11277973_3_21
Title: input data validation in C 
----------------------------------------

int main (int argc, char **argv) {
    double num = -1;
    char input [80];
    char *cp, badc;
    int n;
    printf ("Enter a positive number:");
    while (num < 0) {
        cp = fgets (input, sizeof (input), stdin);
        if (cp == input) {
            n = sscanf (input, "%lf %c", &num, &badc);
            if (n != 1) {
                printf ("Error! Please enter a number:");
                num = -1;
            }
            else if (num < 0)
                printf ("Error! Please enter a POSITIVE number:");
        }
    }
    printf ("num = %f\n", num);
    return 0;
}
----------------------------------------

int main () {
    int ret = 0;
    double num = -1;
    printf ("Enter a positive number:");
    ret = scanf ("%lf", &num);
    while (num < 0) {
        if (ret != 1) {
            while (getchar () != '\n')
                ;
            printf ("Error! Please enter a number: ");
        }
        else {
            printf ("Error! Please enter a positive number: ");
        }
        ret = scanf ("%lf", &num);
    }
    printf ("Your number is %.2lf", num);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11278675_11278873_6_25
11278675_12812689_1_51
Title: Bug in my C code to reverse words in a string 
----------------------------------------

int main (int argc, char **argv) {
    char st [] = "hello world";
    int i = 0, j = 0;
    while (st[j]) {
        if (st[j] == ' ') {
            reverse (& st [i], j - i - 1);
            i = ++j;
        }
        else {
            j++;
        }
    }
    reverse (& st [i], j - i - 1);
    printf ("%s\n", st);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *p, st [] = "hello world";
    char buf [12] = {0};
    char fstr [12] = {0};
    int i = 0, j = 0, k = 0, l = 0;
    for (p = st; *p != '\0'; p++) {
        buf[i++] = *p;
        if (*p == ' ' || *(p + 1) == '\0') {
            buf[i] = '\0';
            j = i - 1;
            i = 0;
            if (k) {
                while (j >= i) {
                    fstr[l++] = buf[j--];
                }
                k = 0;
            }
            else {
                while (i <= j) {
                    fstr[l++] = buf[i++];
                }
                i = 0;
                k = 1;
            }
        }
    }
    fstr[l] = '\0';
    printf ("%s\n", fstr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11281577_11281742_1_17
11281577_11290387_6_31
Title: Exercise on recursion in C 
----------------------------------------

char *repeat (char *str, int n) {
    char *ret_str, *new_str;
    if (n == 0) {
        ret_str = strdup ("");
        return ret_str;
    }
    ret_str = repeat (str, n -1);
    new_str = malloc (sizeof (char) * strlen (str) * (n + 1));
    new_str[0] = '\0';
    strcpy (new_str, ret_str);
    strcat (new_str, str);
    free (ret_str);
    return new_str;
}
----------------------------------------

char *repeat (char *s, int n) {
    static char *sret = NULL;
    static int isnew = 1;
    if (!s || !s[0]) {
        if (sret) {
            free (sret);
            sret = NULL;
        }
        return "";
    }
    if (n <= 0)
        return "";
    if (isnew) {
        int nbuf = strlen (s) * n + 1;
        sret = (char *) realloc (sret, nbuf);
        memset (sret, 0, nbuf);
        isnew = 0;
    }
    strcat (sret, s);
    repeat (s, n - 1);
    isnew = 1;
    return sret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11291154_11291863_39_49
11291154_41473985_62_76
Title: save file listing into array or something else C 
----------------------------------------

int main (int argc, char **argv) {
    char **files;
    size_t count;
    int i;
    count = file_list ("/home/rgerganov", &files);
    for (i = 0; i < count; i++) {
        printf ("%s\n", files [i]);
    }
}
----------------------------------------

int main (void) {
    struct dirent *result;
    size_t size;
    if (get_dirent_dir (".", &result, &size) != 0) {
        perror ("get_file_dir()");
    }
    qsort (result, size, sizeof * result, & cmp_dirent);
    for (size_t i = 0; i < size; i++) {
        printf ("%s\n", result [i].d_name);
    }
    free (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1131625_1131700_5_17
1131625_1132239_5_30
Title: "How do you create a UTC time in C for a specific day month and year?" 
----------------------------------------

int main (void) {
    struct tm *local;
    time_t t;
    t = time (NULL);
    local = localtime (&t);
    printf ("Local time and date: %s\n", asctime (local));
    local = gmtime (&t);
    printf ("UTC time and date: %s\n", asctime (local));
    return 0;
}
----------------------------------------

int main (void) {
    struct tm future;
    time_t t;
    future.tm_sec = 0;
    future.tm_min = 0;
    future.tm_hour = 0;
    future.tm_mday = 1;
    future.tm_mon = 6;
    future.tm_year = 2038 - 1900;
    future.tm_isdst = 0;
    t = mktime (&future);
    if (-1 == t) {
        printf ("Error converting 1 July 2038 to time_t time since Epoch\n");
        return EXIT_FAILURE;
    }
    printf ("UTC time and date: %s\n", asctime (& future));
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11322514_11322565_1_12
11322514_17362325_2_15
Title: Reverse an array without using iteration 
----------------------------------------

void reverse (int a [], int start, int end) {
    int temp;
    temp = a[start];
    a[start] = a[end];
    a[end] = temp;
    if (start == end || start == end - 1)
        return;
    reverse (a, start + 1, end - 1);
}
----------------------------------------

function reverse (a) {
    if (a.length == undefined || a.length < 2) {
        return a;
    }
    b = [];
    b.push (reverse (copyChop (a)));
    b.push (a[0]);
    return b;
    function copyChop (a) {
        b = a.slice (1);
        return b;
    }}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11334595_11334667_4_23
11334595_11334719_4_23
Title: comparing length of strings C 
----------------------------------------

int main (int argc, char *argv []) {
    int i, max_length, max_index;
    max_index = 0;
    max_length = strlen (argv[0]);
    for (i = 1; i < argc; i++) {
        if (strlen (argv[i]) > max_length) {
            max_length = strlen (argv[i]);
            max_index = i;
        }
    }
    printf ("The longest is: %s with length equal: %d\n", argv [max_index], max_length);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int i, length;
    for (i = 0; i < argc - 1; i++) {
        length = strlen (argv[i]);
        printf ("%s %d\n", argv [i], length);
        if (strlen (argv[i]) < strlen (argv[i + 1])) {
            printf ("%s is the biggest \n", argv [i + 1]);
        }
        else {
            printf ("%s is the biggest \n", argv [i]);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11343885_11343918_6_30
11343885_11343951_17_84
Title: function and pointers 
----------------------------------------

int main (void) {
    float cel;
    float celcius;
    float fahren;
    float fah;
    char ch [25];
    float number;
    scanf ("%s %f", ch, & number);
    if (strcmp (ch, "-f") == 0) {
        f2c (number);
        celcius = f2c (number);
        printf ("%f", celcius);
    }
    else {
        c2f (number);
        fahren = c2f (number);
        printf ("%f", fahren);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    const char *label_f = "Fahrenheit";
    const char *label_c = "Celcius";
    const char *from, *to;
    double (*conversion) (double);
    from = label_c;
    to = label_f;
    conversion = c2f;
    for (i = 1; i < argc; ++i) {
        if (0 == strcmp (argv[i], "-f")) {
            from = label_f;
            to = label_c;
            conversion = f2c;
        }
        else if (0 == strcmp (argv[i], "-c")) {
            from = label_c;
            to = label_f;
            conversion = c2f;
        }
        else {
            char *suffix = NULL;
            double temp_in;
            errno = 0;
            temp_in = strtod (argv[i], &suffix);
            if (ERANGE == errno) {
                if (HUGE_VAL == temp_in) {
                    fprintf (stderr, "%s is too big", argv [i]);
                    return 1;
                }
                else {
                    assert (- HUGE_VAL == temp_in);
                    fprintf (stderr, "%s is too small", argv [i]);
                    return 1;
                }
            }
            else if (errno != 0 && (suffix == argv[i])) {
                fprintf (stderr, "%s is not a number", argv [i]);
                return 1;
            }
            else if (*suffix) {
                fprintf (stderr, "Expected a number but saw '%s'\n", argv [i]);
                return 1;
            }
            else {
                const double temp_out = (*conversion) (temp_in);
                printf ("%f %s is %f %s.\n", temp_in, from, temp_out, to);
            }
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11360044_11360373_1_25
11360044_11360631_1_19
Title: optimization of gcd calculation 
----------------------------------------

Integer gcd (Integer a, Integer b) {
    const Integer mask_a = a >> (sizeof (Integer) * 8 - 1);
    a = (a + mask_a) ^ mask_a;
    const Integer mask_b = b >> (sizeof (Integer) * 8 - 1);
    b = (b + mask_b) ^ mask_b;
    int shift = 0;
    while (a != 0 && a != b) {
        if (~a & 1) {
            a >>= 1;
            if (!(b & 1)) {
                b >>= 1;
                shift++;
            }
        }
        else if (~b & 1) {
            b >>= 1;
        }
        else if (a > b) {
            a = (a - b) >> 1;
        }
        else {
            b = (b - a) >> 1;
        }
    }
    return b << shift;
}
----------------------------------------

Integer gcd (Integer a, Integer b) {
    if (a == b)
        return a;
    if (a == 0)
        return b;
    if (b == 0)
        return a;
    while (b != 0) {
        Integer t = b;
        b = a % b;
        a = t;
    }
    return a;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11399964_11400055_1_27
11399964_18720035_1_31
Title: Binary insertion sort of array not working (Code in C) 
----------------------------------------

void binaryInsertionSort (int a [], int n) {
    register int i, m;
    int hi, lo, tmp;
    for (i = 1; i < n; i++) {
        lo = 0, hi = i;
        m = i / 2;
        do {
            if (a[i] > a[m]) {
                lo = m + 1;
            }
            else if (a[i] < a[m]) {
                hi = m;
            }
            else
                break;
            m = lo + ((hi - lo) / 2);
        }
        while (lo < hi);
        if (m < i) {
            tmp = a[i];
            memmove (a + m + 1, a + m, sizeof (int) * (i - m));
            a[m] = tmp;
        }
    }
}
----------------------------------------

void binaryInsertionSort (int *array, size_t size) {
    register int i, middle;
    int high, low, tmp;
    static int comparisonCount = 0, swapCount = 0;
    i = 1;
    while (i < size) {
        low = 0, high = i;
        middle = i / 2;
        do {
            if (array[i] > array[middle]) {
                low = middle + 1;
            }
            else if (array[i] < array[middle]) {
                high = middle;
            }
            else
                break;
            middle = low + ((high - low) / 2);
        }
        while (low < high);
        comparisonCount++;
        if (middle < i) {
            tmp = array[i];
            memmove (array + middle + 1, array + middle, sizeof (int) * (i - middle));
            swapCount++;
            array[middle] = tmp;
        }
        i++;
    }
    printf ("Comparison:%d Swap: %d\n", comparisonCount, swapCount);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1145_1163_1_25
1145_220594_1_18
Title: Why am I getting a double free error with realloc()? 
----------------------------------------

char *strrep (char *string, const char *search, const char *replace) {
    char *p = strstr (string, search);
    if (p) {
        int occurrence = p - string;
        int stringlength = strlen (string);
        int searchlength = strlen (search);
        int replacelength = strlen (replace);
        if (replacelength > searchlength) {
            string = (char *) realloc (string, strlen (string) +replacelength - searchlength + 1);
        }
        if (replacelength != searchlength) {
            memmove (string + occurrence + replacelength, string + occurrence + searchlength, stringlength - occurrence - searchlength + 1);
        }
        strncpy (string + occurrence, replace, replacelength);
    }
    return string;
}
----------------------------------------

char *strrep (char *input, char *search, char *replace) {
    int searchLen = strlen (search);
    int replaceLen = strlen (replace);
    int delta = replaceLen - searchLen;
    char *find = input;
    while ((find = strstr (find, search)) != 0) {
        if (delta > 0) {
            input = realloc (input, strlen (input) +delta + 1);
            find = strstr (input, search);
        }
        memmove (find + replaceLen, find + searchLen, strlen (input) + 1 - (find - input));
        memmove (find, replace, replaceLen);
    }
    return (input);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11463455_11463511_1_31
11463455_11463529_17_25
Title: C programming initialize 2D array dynamically 
----------------------------------------

int main (int argc, char *argv []) {
    int xSize, ySize;
    int **board;
    xSize = ySize = 5;
    printf ("X: %u; Y: %u\n", xSize, ySize);
    board = calloc (xSize, sizeof (int *));
    printf ("%p\n", board);
    int **temp = board;
    for (i = 0; i < xSize; i++) {
        board[i] = calloc (ySize, sizeof (int));
        printf ("%d %p\n", i, board [i]);
    }
    initializeBoard (board, xSize, ySize);
    temp = board;
    for (i = 0; i < xSize; i++) {
        free (*temp);
        (temp)++;
    }
    free (board);
    return 0;
}
----------------------------------------

void main () {
    double **dataA;
    int dim = 10;
    init_data (& dataA, dim, dim);
    int i, j;
    for (i = 0; i < dim; i++)
        for (j = 0; j < dim; j++)
            printf ("%f\n", dataA[i][j]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11463455_11463511_1_31
11463455_11463632_20_35
Title: C programming initialize 2D array dynamically 
----------------------------------------

int main (int argc, char *argv []) {
    int xSize, ySize;
    int **board;
    xSize = ySize = 5;
    printf ("X: %u; Y: %u\n", xSize, ySize);
    board = calloc (xSize, sizeof (int *));
    printf ("%p\n", board);
    int **temp = board;
    for (i = 0; i < xSize; i++) {
        board[i] = calloc (ySize, sizeof (int));
        printf ("%d %p\n", i, board [i]);
    }
    initializeBoard (board, xSize, ySize);
    temp = board;
    for (i = 0; i < xSize; i++) {
        free (*temp);
        (temp)++;
    }
    free (board);
    return 0;
}
----------------------------------------

int main (void) {
    double **dataA;
    int i, j, dim = 10;
    dataA = init_data (dim, dim);
    for (i = 0; i < dim; i++)
        for (j = 0; j < dim; j++)
            printf ("%f\n", dataA[i][j]);
    for (i = 0; i < dim; i++)
        free (dataA[i]);
    free (dataA);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11463455_11463523_1_17
11463455_11463632_4_18
Title: C programming initialize 2D array dynamically 
----------------------------------------

double **init_data (int dim_x, int dim_y) {
    {
        int i, j, k;
        double **data = (double **) malloc (sizeof (double) * dim_x);
        for (k = 0; k < dim_y; k++) {
            data[k] = (double *) malloc (sizeof (double) * dim_y);
        }
        for (i = 0; i < dim_x; i++) {
            for (j = 0;
            j < dim_y;
            j ++) {data [i] [j] = ((double) rand () / (double) RAND_MAX);
        }
    }
    return data;
}
----------------------------------------

double **init_data (int dim_x, int dim_y) {
    int i, j, k;
    double **data = malloc (sizeof (*data) * dim_x);
    for (k = 0; k < dim_x; k++) {
        data[k] = malloc (sizeof (**data) * dim_y);
    }
    for (i = 0; i < dim_y; i++) {
        for (j = 0; j < dim_y; j++) {
            data[i][j] = ((double) rand () / (double) RAND_MAX);
        }
    }
    return data;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11463455_11463529_17_25
11463455_11463632_20_35
Title: C programming initialize 2D array dynamically 
----------------------------------------

void main () {
    double **dataA;
    int dim = 10;
    init_data (& dataA, dim, dim);
    int i, j;
    for (i = 0; i < dim; i++)
        for (j = 0; j < dim; j++)
            printf ("%f\n", dataA[i][j]);
}
----------------------------------------

int main (void) {
    double **dataA;
    int i, j, dim = 10;
    dataA = init_data (dim, dim);
    for (i = 0; i < dim; i++)
        for (j = 0; j < dim; j++)
            printf ("%f\n", dataA[i][j]);
    for (i = 0; i < dim; i++)
        free (dataA[i]);
    free (dataA);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11463455_11463529_1_15
11463455_11468586_1_18
Title: C programming initialize 2D array dynamically 
----------------------------------------

void init_data (double ***data_ptr, int dim_x, int dim_y) {
    int i, j, k;
    double **data;
    data = (double **) malloc (sizeof (double *) * dim_x);
    for (k = 0; k < dim_x; k++) {
        data[k] = (double *) malloc (sizeof (double) * dim_y);
    }
    for (i = 0; i < dim_x; i++) {
        for (j = 0; j < dim_y; j++) {
            data[i][j] = ((double) rand () / (double) RAND_MAX);
        }
    }
    *data_ptr = data;
}
----------------------------------------

void init_data (double ***data, int dim_x, int dim_y) {
    int i, j, k;
    *data = (double **) malloc (sizeof (double *) * dim_x);
    for (k = 0; k < dim_y; k++) {
        ((*data) + k) = (double *) malloc (sizeof (double) * dim_y);
    }
    for (i = 0; i < dim_x; i++) {
        for (j = 0; j < dim_y; j++) {
            (((*data) + i) + j) = ((double) rand () / (double) RAND_MAX);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11487412_11487471_1_13
11487412_11487476_5_15
Title: String pointer behaviour I am trying to understand 
----------------------------------------

char *replacechar (char *s, char ch1, char ch2) {
    char *tmpstr;
    tmpstr = s;
    while (*tmpstr) {
        if (*tmpstr == ch1)
            *tmpstr = ch2;
        tmpstr++;
    }
    return s;
}
----------------------------------------

char *replacechar (char *s, char ch1, char ch2) {
    char *t = s;
    while (*s) {
        if (*s == ch1)
            *s = ch2;
        *s++;
    }
    return t;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11488681_11488777_13_37
11488681_11489017_8_66
Title: Digit Validation - Endless Loop 
----------------------------------------

int main () {
    int a;
    int r;
    printf ("Please enter a value: ");
    for (;;) {
        r = scanf ("%d", &a);
        if (r == EOF)
            return EXIT_FAILURE;
        if (r != 1) {
            printf ("Number must be numeric!\n");
            skip_input (stdin);
        }
        else if (a < 0) {
            printf ("Number must be postive\n");
            skip_input (stdin);
        }
        else {
            printf ("Everything is goood\n");
            break;
        }
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    long result;
    long len;
    int is_valid = 0;
    char buf [128];
    char *arg;
    char *end;
    while (!is_valid) {
        printf ("Enter a non-negative integer: ");
        if (fgets (buf, sizeof (buf), stdin) == NULL) {
            printf ("Giving up so soon?\n");
            break;
        }
        len = strlen (buf);
        if (buf[len] != '\n') {
            printf ("Input buffer length exceeded - aborting.\n");
            exit (1);
        }
        for (arg = buf; isspace (*arg); arg++)
            ;
        errno = 0;
        result = strtol (arg, &end, 10);
        if (errno == EINVAL) {
            printf ("Please enter a numeric value.\n");
            continue;
        }
        if (errno == ERANGE) {
            printf ("Numeric value out of range.\n");
            continue;
        }
        for (; isspace (*end); end++)
            ;
        if (*end != '\0') {
            printf ("Please enter a numeric value.\n");
            continue;
        }
        if (result < 0) {
            printf ("Please enter a positive value.\n");
            continue;
        }
        printf ("Excellent!\n");
        is_valid = 1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1149929_1150180_40_62
1149929_12458186_15_26
Title: How to add two numbers without using ++ or + or another arithmetic operator 
----------------------------------------

int multiply (int x, int y) {
    int result = 0;
    if (x < 0 && y < 0) {
        return multiply (negate (x), negate (y));
    }
    if (x >= 0 && y < 0) {
        return multiply (y, x);
    }
    while (y > 0) {
        if (is_even (y)) {
            x = multiply_by_two (x);
            y = divide_by_two (y);
        }
        else {
            result = add (result, x);
            y = add (y, -1);
        }
    }
    return result;
}
----------------------------------------

int multiply (int a, int b) {
    int res = 0;
    int i = 0;
    int large = a > b ? a : b;
    int small = a < b ? a : b;
    for (i = 0; i < small; i++) {
        res = add (large, res);
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1149929_1150180_5_18
1149929_1157571_27_102
Title: How to add two numbers without using ++ or + or another arithmetic operator 
----------------------------------------

int add (int x, int y) {
    int carry = 0;
    int result = 0;
    int i;
    for (i = 0; i < 32; ++i) {
        int a = (x >> i) & 1;
        int b = (y >> i) & 1;
        result |= ((a ^ b) ^ carry) << i;
        carry = (a & b) | (b & carry) | (carry & a);
    }
    return result;
}
----------------------------------------

unsigned int add (unsigned int a, unsigned int b) {
    unsigned int sum;
    unsigned int carry;
    byte * const aBytes = (byte *) &a;
    byte * const bBytes = (byte *) &b;
    byte * const sumBytes = (byte *) &sum;
    byte * const carryBytes = (byte *) &carry;
    byte const test [4] = {0x12, 0x34, 0x56, 0x78};
    byte BYTE_0, BYTE_1, BYTE_2, BYTE_3;
    if (0x12345678 == *(unsignedint*) test) {
        BYTE_0 = 3;
        BYTE_1 = 2;
        BYTE_2 = 1;
        BYTE_3 = 0;
    }
    else {
        BYTE_0 = 0;
        BYTE_1 = 1;
        BYTE_2 = 2;
        BYTE_3 = 3;
    }
    add_byte (aBytes [BYTE_0], bBytes [BYTE_0], & sumBytes [BYTE_0], & carryBytes [BYTE_0]);
    add_byte (aBytes [BYTE_1], bBytes [BYTE_1], & sumBytes [BYTE_1], & carryBytes [BYTE_1]);
    if (carryBytes[BYTE_0] == 1) {
        if (sumBytes[BYTE_1] == 255) {
            sumBytes[BYTE_1] = 0;
            carryBytes[BYTE_1] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_1], 1, & sumBytes [BYTE_1], & carryBytes [BYTE_0]);
        }
    }
    add_byte (aBytes [BYTE_2], bBytes [BYTE_2], & sumBytes [BYTE_2], & carryBytes [BYTE_2]);
    if (carryBytes[BYTE_1] == 1) {
        if (sumBytes[BYTE_2] == 255) {
            sumBytes[BYTE_2] = 0;
            carryBytes[BYTE_2] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_2], 1, & sumBytes [BYTE_2], & carryBytes [BYTE_1]);
        }
    }
    add_byte (aBytes [BYTE_3], bBytes [BYTE_3], & sumBytes [BYTE_3], & carryBytes [BYTE_3]);
    if (carryBytes[BYTE_2] == 1) {
        if (sumBytes[BYTE_3] == 255) {
            sumBytes[BYTE_3] = 0;
            carryBytes[BYTE_3] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_3], 1, & sumBytes [BYTE_3], & carryBytes [BYTE_2]);
        }
    }
    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1149929_1150180_5_18
1149929_12458186_3_14
Title: How to add two numbers without using ++ or + or another arithmetic operator 
----------------------------------------

int add (int x, int y) {
    int carry = 0;
    int result = 0;
    int i;
    for (i = 0; i < 32; ++i) {
        int a = (x >> i) & 1;
        int b = (y >> i) & 1;
        result |= ((a ^ b) ^ carry) << i;
        carry = (a & b) | (b & carry) | (carry & a);
    }
    return result;
}
----------------------------------------

unsigned int add (unsigned int x, unsigned int y) {
    int carry = 0;
    while (y != 0) {
        carry = x & y;
        x = x ^ y;
        y = carry << 1;
    }
    return x;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1149929_1150180_5_18
1149929_3758542_3_12
Title: How to add two numbers without using ++ or + or another arithmetic operator 
----------------------------------------

int add (int x, int y) {
    int carry = 0;
    int result = 0;
    int i;
    for (i = 0; i < 32; ++i) {
        int a = (x >> i) & 1;
        int b = (y >> i) & 1;
        result |= ((a ^ b) ^ carry) << i;
        carry = (a & b) | (b & carry) | (carry & a);
    }
    return result;
}
----------------------------------------

int add (int x, int y) {
    int a, b;
    do {
        a = x & y;
        b = x ^ y;
        x = a << 1;
        y = b;
    }
    while (a);
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1149929_1150180_64_86
1149929_7615306_6_29
Title: How to add two numbers without using ++ or + or another arithmetic operator 
----------------------------------------

int main (int argc, char **argv) {
    int from = -100, to = 100;
    int i, j;
    for (i = from; i <= to; ++i) {
        assert (0 - i == negate (i));
        assert (((i % 2) == 0) == is_even (i));
        assert (i * 2 == multiply_by_two (i));
        if (is_even (i)) {
            assert (i / 2 == divide_by_two (i));
        }
    }
    for (i = from; i <= to; ++i) {
        for (j = from; j <= to; ++j) {
            assert (i + j == add (i, j));
            assert (i - j == subtract (i, j));
            assert (i * j == multiply (i, j));
        }
    }
    return 0;
}
----------------------------------------

void main () {
    int sub, a, b, carry, temp, c, d;
    clrscr ();
    printf ("enter a and b:");
    scanf ("%d%d", & a, & b);
    c = a;
    d = b;
    while (b) {
        carry = a & b;
        a = a ^ b;
        b = carry << 1;
    }
    printf ("add(%d,%d):%d\n", c, d, a);
    temp = ~d + 1;
    sub = c + temp;
    printf ("diff(%d,%d):%d\n", c, d, temp);
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1149929_1157571_27_102
1149929_12458186_3_14
Title: How to add two numbers without using ++ or + or another arithmetic operator 
----------------------------------------

unsigned int add (unsigned int a, unsigned int b) {
    unsigned int sum;
    unsigned int carry;
    byte * const aBytes = (byte *) &a;
    byte * const bBytes = (byte *) &b;
    byte * const sumBytes = (byte *) &sum;
    byte * const carryBytes = (byte *) &carry;
    byte const test [4] = {0x12, 0x34, 0x56, 0x78};
    byte BYTE_0, BYTE_1, BYTE_2, BYTE_3;
    if (0x12345678 == *(unsignedint*) test) {
        BYTE_0 = 3;
        BYTE_1 = 2;
        BYTE_2 = 1;
        BYTE_3 = 0;
    }
    else {
        BYTE_0 = 0;
        BYTE_1 = 1;
        BYTE_2 = 2;
        BYTE_3 = 3;
    }
    add_byte (aBytes [BYTE_0], bBytes [BYTE_0], & sumBytes [BYTE_0], & carryBytes [BYTE_0]);
    add_byte (aBytes [BYTE_1], bBytes [BYTE_1], & sumBytes [BYTE_1], & carryBytes [BYTE_1]);
    if (carryBytes[BYTE_0] == 1) {
        if (sumBytes[BYTE_1] == 255) {
            sumBytes[BYTE_1] = 0;
            carryBytes[BYTE_1] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_1], 1, & sumBytes [BYTE_1], & carryBytes [BYTE_0]);
        }
    }
    add_byte (aBytes [BYTE_2], bBytes [BYTE_2], & sumBytes [BYTE_2], & carryBytes [BYTE_2]);
    if (carryBytes[BYTE_1] == 1) {
        if (sumBytes[BYTE_2] == 255) {
            sumBytes[BYTE_2] = 0;
            carryBytes[BYTE_2] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_2], 1, & sumBytes [BYTE_2], & carryBytes [BYTE_1]);
        }
    }
    add_byte (aBytes [BYTE_3], bBytes [BYTE_3], & sumBytes [BYTE_3], & carryBytes [BYTE_3]);
    if (carryBytes[BYTE_2] == 1) {
        if (sumBytes[BYTE_3] == 255) {
            sumBytes[BYTE_3] = 0;
            carryBytes[BYTE_3] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_3], 1, & sumBytes [BYTE_3], & carryBytes [BYTE_2]);
        }
    }
    return sum;
}
----------------------------------------

unsigned int add (unsigned int x, unsigned int y) {
    int carry = 0;
    while (y != 0) {
        carry = x & y;
        x = x ^ y;
        y = carry << 1;
    }
    return x;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1149929_1157571_27_102
1149929_3758542_3_12
Title: How to add two numbers without using ++ or + or another arithmetic operator 
----------------------------------------

unsigned int add (unsigned int a, unsigned int b) {
    unsigned int sum;
    unsigned int carry;
    byte * const aBytes = (byte *) &a;
    byte * const bBytes = (byte *) &b;
    byte * const sumBytes = (byte *) &sum;
    byte * const carryBytes = (byte *) &carry;
    byte const test [4] = {0x12, 0x34, 0x56, 0x78};
    byte BYTE_0, BYTE_1, BYTE_2, BYTE_3;
    if (0x12345678 == *(unsignedint*) test) {
        BYTE_0 = 3;
        BYTE_1 = 2;
        BYTE_2 = 1;
        BYTE_3 = 0;
    }
    else {
        BYTE_0 = 0;
        BYTE_1 = 1;
        BYTE_2 = 2;
        BYTE_3 = 3;
    }
    add_byte (aBytes [BYTE_0], bBytes [BYTE_0], & sumBytes [BYTE_0], & carryBytes [BYTE_0]);
    add_byte (aBytes [BYTE_1], bBytes [BYTE_1], & sumBytes [BYTE_1], & carryBytes [BYTE_1]);
    if (carryBytes[BYTE_0] == 1) {
        if (sumBytes[BYTE_1] == 255) {
            sumBytes[BYTE_1] = 0;
            carryBytes[BYTE_1] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_1], 1, & sumBytes [BYTE_1], & carryBytes [BYTE_0]);
        }
    }
    add_byte (aBytes [BYTE_2], bBytes [BYTE_2], & sumBytes [BYTE_2], & carryBytes [BYTE_2]);
    if (carryBytes[BYTE_1] == 1) {
        if (sumBytes[BYTE_2] == 255) {
            sumBytes[BYTE_2] = 0;
            carryBytes[BYTE_2] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_2], 1, & sumBytes [BYTE_2], & carryBytes [BYTE_1]);
        }
    }
    add_byte (aBytes [BYTE_3], bBytes [BYTE_3], & sumBytes [BYTE_3], & carryBytes [BYTE_3]);
    if (carryBytes[BYTE_2] == 1) {
        if (sumBytes[BYTE_3] == 255) {
            sumBytes[BYTE_3] = 0;
            carryBytes[BYTE_3] = 1;
        }
        else {
            add_byte (sumBytes [BYTE_3], 1, & sumBytes [BYTE_3], & carryBytes [BYTE_2]);
        }
    }
    return sum;
}
----------------------------------------

int add (int x, int y) {
    int a, b;
    do {
        a = x & y;
        b = x ^ y;
        x = a << 1;
        y = b;
    }
    while (a);
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1149929_12458186_3_14
1149929_3758542_3_12
Title: How to add two numbers without using ++ or + or another arithmetic operator 
----------------------------------------

unsigned int add (unsigned int x, unsigned int y) {
    int carry = 0;
    while (y != 0) {
        carry = x & y;
        x = x ^ y;
        y = carry << 1;
    }
    return x;
}
----------------------------------------

int add (int x, int y) {
    int a, b;
    do {
        a = x & y;
        b = x ^ y;
        x = a << 1;
        y = b;
    }
    while (a);
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11508427_43070161_10_44
11508427_50150506_16_29
Title: "Linux C: upon receiving a signal is it possible to know the PID of the sender?" 
----------------------------------------

int main (int argc, char *argv []) {
    sigset_t mask;
    int sfd;
    struct signalfd_siginfo fdsi;
    ssize_t s;
    sigemptyset (& mask);
    sigaddset (& mask, SIGINT);
    sigaddset (& mask, SIGQUIT);
    if (sigprocmask (SIG_BLOCK, &mask, NULL) == -1)
        handle_error ("sigprocmask");
    sfd = signalfd (-1, &mask, 0);
    if (sfd == -1)
        handle_error ("signalfd");
    for (;;) {
        s = read (sfd, &fdsi, sizeof (struct signalfd_siginfo));
        if (s != sizeof (struct signalfd_siginfo))
            handle_error ("read");
        if (fdsi.ssi_signo == SIGINT) {
            printf ("Got SIGINT\n");
        }
        else if (fdsi.ssi_signo == SIGQUIT) {
            printf ("Got SIGQUIT\n");
            exit (EXIT_SUCCESS);
        }
        else {
            printf ("Read unexpected signal\n");
        }
    }
}
----------------------------------------

int main (void) {
    struct sigaction sa;
    memset (& sa, 0, sizeof (sa));
    sa.sa_flags = SA_SIGINFO;
    sa.sa_sigaction = sigusr1;
    if (sigaction (SIGUSR1, &sa, 0) == -1) {
        fprintf (stderr, "%s: %s\n", "sigaction", strerror (errno));
    }
    printf ("Pid %lu waiting for SIGUSR1\n", (unsigned long) getpid ());
    for (;;) {
        sleep (10);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11534679_11534738_4_19
11534679_11534764_4_21
Title: error in implementation of file i/o 
----------------------------------------

int main () {
    FILE *fp;
    int id, q, p, r, a;
    fp = fopen ("g-ip.txt", "r");
    if (!fp)
        perror ("g-ip.txt"), exit (1);
    while (!feof (fp)) {
        id = q = p = r = a = 0;
        if (fscanf (fp, " %d %d %d %d %d", &id, &q, &p, &r, &a) < 5)
            exit (1);
        printf ("%d %d %d %d %d\n", id, q, p, r, a);
    }
    fclose (fp);
    return 0;
}
----------------------------------------

int main () {
    FILE *fp;
    int id, q, p, r, a;
    int scanned;
    char buffer [256] = {0};
    fp = fopen ("g-ip.txt", "r");
    while (fgets (buffer, sizeof (buffer) - 1, fp)) {
        scanned = sscanf (buffer, "%d %d %d %d %d", & id, & q, & p, & r, & a)
        );
        if (scanned == 5)
            printf ("%d %d %d %d %d\n", id, q, p, r, a);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11534679_11534738_4_19
11534679_11537458_4_27
Title: error in implementation of file i/o 
----------------------------------------

int main () {
    FILE *fp;
    int id, q, p, r, a;
    fp = fopen ("g-ip.txt", "r");
    if (!fp)
        perror ("g-ip.txt"), exit (1);
    while (!feof (fp)) {
        id = q = p = r = a = 0;
        if (fscanf (fp, " %d %d %d %d %d", &id, &q, &p, &r, &a) < 5)
            exit (1);
        printf ("%d %d %d %d %d\n", id, q, p, r, a);
    }
    fclose (fp);
    return 0;
}
----------------------------------------

int main () {
    FILE *fp = fopen ("g-ip.txt", "r");
    char enorbuf [2048];
    int errors = 0;
    while (fgets (enorbuf, sizeof (enorbuf), fp) != NULL) {
        int id, q, p, r, a;
        if (sscanf (enorbuf, "%d\t%d\t%d\t\t%d\t\t%d", &id, &q, &p, &r, &a) != 5) {
            printf ("Invalid input line: %s", enorbuf);
            errors = 1;
        }
        else {
            printf ("%d %d %d %d %d\n", id, q, p, r, a);
        }
    }
    fclose (fp);
    return errors ? EXIT_FAILURE : EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11534679_11534764_4_21
11534679_11537458_4_27
Title: error in implementation of file i/o 
----------------------------------------

int main () {
    FILE *fp;
    int id, q, p, r, a;
    int scanned;
    char buffer [256] = {0};
    fp = fopen ("g-ip.txt", "r");
    while (fgets (buffer, sizeof (buffer) - 1, fp)) {
        scanned = sscanf (buffer, "%d %d %d %d %d", & id, & q, & p, & r, & a)
        );
        if (scanned == 5)
            printf ("%d %d %d %d %d\n", id, q, p, r, a);
    }
    fclose (fp);
    return 0;
}
----------------------------------------

int main () {
    FILE *fp = fopen ("g-ip.txt", "r");
    char enorbuf [2048];
    int errors = 0;
    while (fgets (enorbuf, sizeof (enorbuf), fp) != NULL) {
        int id, q, p, r, a;
        if (sscanf (enorbuf, "%d\t%d\t%d\t\t%d\t\t%d", &id, &q, &p, &r, &a) != 5) {
            printf ("Invalid input line: %s", enorbuf);
            errors = 1;
        }
        else {
            printf ("%d %d %d %d %d\n", id, q, p, r, a);
        }
    }
    fclose (fp);
    return errors ? EXIT_FAILURE : EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11570909_11570961_5_24
11570909_11573641_54_77
Title: String Search and format in C 
----------------------------------------

int main () {
    char buffer [255] = "CODE=12345 MODE-12453 CODE=12355";
    int i;
    int codes [256];
    char *pos = buffer;
    size_t current = 0;
    while ((pos = strstr (pos, "CODE")) != NULL) {
        if (sscanf (pos, "CODE = %d", codes +current))
            ++current;
        pos += 4;
    }
    for (i = 0; i < current; i++)
        printf ("%d\n", codes[i]);
    return 0;
}
----------------------------------------

int main () {
    char *code;
    code = getcode ("CODE=12345-MODE-12453-CODE1-12355", "CODE=*****");
    printf ("\"%s\"\n", code);
    free (code);
    code = getcode (" CODE = 12345-MODE-12453-CODE1-12355", "CODE=*****");
    printf ("\"%s\"\n", code);
    free (code);
    code = getcode ("CODE-12345-MODE-12453-CODE1-12355", "CODE=*****");
    if (code == NULL)
        printf ("not match\n");
    code = getcode ("CODE=12345-MODE-12453-CODE=12355", "CODE=*****");
    printf ("\"%s\"\n", code);
    free (code);
    code = getcode (NULL, "CODE=*****");
    printf ("\"%s\"\n", code);
    free (code);
    code = getcode ("CODE=12345-MODE-12453-CODE1-12355", "CODE=*****");
    printf ("\"%s\"\n", code);
    free (code);
    code = getcode (NULL, "CODE1-*****");
    printf ("\"%s\"\n", code);
    free (code);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11570909_11571301_5_62
11570909_11573641_5_52
Title: String Search and format in C 
----------------------------------------

char *getcode (const char *input, size_t limit) {
    char *p = (char *) input, *buf, *pbuf;
    size_t i = 0;
    while (*p != '\0') {
        if (strncmp (p, "CODE", 3) == 0) {
            NSTRIP (p, 4);
            TRIMSPACES (p);
            if (*p != '=')
                return NULL;
            STRIP (p);
            TRIMSPACES (p);
            if (*p == '\0')
                return NULL;
            if ((buf = malloc (limit)) == NULL)
                return NULL;
            pbuf = buf;
            while (*p != '\0' && *p != '-' && i < limit) {
                *pbuf++ = *p++;
                i++;
            }
            *pbuf++ = '\0';
            return buf;
        }
        p++;
    }
    return NULL;
}
----------------------------------------

char *getcode (const char *str, const char *pattern) {
    static const char *p = NULL;
    char *retbuf, *pat;
    int i, match, skip, patlen;
    if (str != NULL)
        p = str;
    if (p == NULL || *p == '\0')
        return NULL;
    if (NULL == (retbuf = (char *) malloc ((strlen (p) + 1) * sizeof (char))))
        return NULL;
    pat = (char *) pattern;
    patlen = strlen (pat);
    i = match = skip = 0;
    while (*p) {
        if (isspace (*p)) {
            ++p;
            ++skip;
            continue;
        }
        if (*pat) {
            if (*p == *pat) {
                ++match;
                ++p;
                ++pat;
            }
            else if (*pat == '*') {
                ++match;
                retbuf[i++] = *p++;
                ++pat;
            }
            else {
                if (match) {
                    pat = (char *) pattern;
                    p -= match + skip - 1;
                    i = match = skip = 0;
                }
                else
                    ++p;
            }
        }
        else {
            break;
        }
    }
    if (i) {
        retbuf[i++] = '\0';
        retbuf = realloc (retbuf, i);
        return retbuf;
    }
    else {
        free (retbuf);
        return NULL;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11575174_11575324_2_16
11575174_11575642_2_18
Title: How to store arrays in an array and to do comparision 
----------------------------------------

int main () {
    unsigned char a [3];
    unsigned char b [3];
    unsigned char *l [2];
    a[0] = 0;
    a[1] = 1;
    a[2] = 2;
    b[0] = 3;
    b[1] = 4;
    b[2] = 5;
    l[0] = a;
    l[1] = b;
    if (strncmp (l[0], l[1], 3) != 0) {
        printf ("Compared not same");
    }
    return 0;
}
----------------------------------------

int main () {
    unsigned char a [3];
    unsigned char b [3];
    unsigned char *l [2];
    a[0] = '3';
    a[1] = '4';
    a[2] = '\0';
    b[0] = '3';
    b[1] = '4';
    b[2] = '\0';
    l[0] = a;
    l[1] = b;
    if (strcmp (l[0], l[1]) != 0) {
        printf ("Compared not same");
    }
    else {
        printf ("Compared same");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11583613_11583709_2_27
11583613_11584000_1_23
Title: Fastest way to convert 2D-array into char* array and copy a char into end of string 
----------------------------------------

char *join (int c, size_t arrsize, const char *arr []) {
    char *buf;
    size_t i, len, total = 0;
    for (i = 0; i < arrsize; ++i) {
        total += strlen (arr[i]);
    }
    buf = malloc (total +arrsize);
    if (!buf)
        return NULL;
    total = 0;
    for (i = 0; i < arrsize; ++i) {
        len = strlen (arr[i]);
        memcpy (buf + total, arr [i], len);
        total += len;
        buf[total++] = (i == arrsize - 1) ? '\0' : c;
    }
    return buf;
}
----------------------------------------

char *join (int c, size_t arrsize, const char *arr []) {
    char *buffer;
    size_t i, vsize;
    char *b;
    buffer = malloc (2048);
    b = buffer;
    vsize = 0;
    for (i = 0; i < arrsize; ++i) {
        char *p = arr[i];
        while (*p) {
            *b = *p;
            b++;
            p++;
            vsize++;
        }
        *b = c;
        b++;
    }
    buffer[vsize++] = '\0';
    return realloc (buffer, vsize);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11583613_11583709_2_27
11583613_11584077_5_20
Title: Fastest way to convert 2D-array into char* array and copy a char into end of string 
----------------------------------------

char *join (int c, size_t arrsize, const char *arr []) {
    char *buf;
    size_t i, len, total = 0;
    for (i = 0; i < arrsize; ++i) {
        total += strlen (arr[i]);
    }
    buf = malloc (total +arrsize);
    if (!buf)
        return NULL;
    total = 0;
    for (i = 0; i < arrsize; ++i) {
        len = strlen (arr[i]);
        memcpy (buf + total, arr [i], len);
        total += len;
        buf[total++] = (i == arrsize - 1) ? '\0' : c;
    }
    return buf;
}
----------------------------------------

char *join (char c, size_t arrsize, const char *arr []) {
    size_t i, total, len [arrsize];
    char *buff, *ret;
    for (total = i = 0; i < arrsize; ++i)
        total += (len[i] = strlen (arr[i]));
    if (NULL == (ret = buff = (char *) malloc ((total + arrsize) * sizeof (char))))
        return NULL;
    for (i = 0; i < arrsize; ++i) {
        memcpy (buff, arr [i], len [i]);
        buff += len[i];
        *buff++ = c;
    }
    *--buff = '\0';
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11583613_11583709_2_27
11583613_11584117_5_47
Title: Fastest way to convert 2D-array into char* array and copy a char into end of string 
----------------------------------------

char *join (int c, size_t arrsize, const char *arr []) {
    char *buf;
    size_t i, len, total = 0;
    for (i = 0; i < arrsize; ++i) {
        total += strlen (arr[i]);
    }
    buf = malloc (total +arrsize);
    if (!buf)
        return NULL;
    total = 0;
    for (i = 0; i < arrsize; ++i) {
        len = strlen (arr[i]);
        memcpy (buf + total, arr [i], len);
        total += len;
        buf[total++] = (i == arrsize - 1) ? '\0' : c;
    }
    return buf;
}
----------------------------------------

char *join (char delimiter, size_t arrsize, const char *arr []) {
    size_t i;
    size_t total;
    char *joined;
    for (i = total = 0; i < arrsize; i++) {
        if (arr[i] != NULL)
            total += strlen (arr[i]) + 1;
    }
    joined = (char *) malloc (sizeof (char) * total);
    if (joined != NULL) {
        joined[0] = '\0';
        for (i = 0; i < arrsize; i++) {
            if (arr[i] != NULL) {
                strcat (joined, arr [i]);
                if ((i + 1) != arrsize)
                    strncat (joined, &delimiter, 1);
            }
        }
        return joined;
    }
    int main (int argc, char **argv) {
        const char *foo [] = {"aasdasd", "bgsfsdf", "asdasisc"};
        char *baa = join (' ', 3, foo);
        if (baa != NULL) {
            printf ("%s\n", baa);
            free (baa);
        }
        else {printf ("No memory\n");
    } return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11583613_11584000_1_23
11583613_11584077_5_20
Title: Fastest way to convert 2D-array into char* array and copy a char into end of string 
----------------------------------------

char *join (int c, size_t arrsize, const char *arr []) {
    char *buffer;
    size_t i, vsize;
    char *b;
    buffer = malloc (2048);
    b = buffer;
    vsize = 0;
    for (i = 0; i < arrsize; ++i) {
        char *p = arr[i];
        while (*p) {
            *b = *p;
            b++;
            p++;
            vsize++;
        }
        *b = c;
        b++;
    }
    buffer[vsize++] = '\0';
    return realloc (buffer, vsize);
}
----------------------------------------

char *join (char c, size_t arrsize, const char *arr []) {
    size_t i, total, len [arrsize];
    char *buff, *ret;
    for (total = i = 0; i < arrsize; ++i)
        total += (len[i] = strlen (arr[i]));
    if (NULL == (ret = buff = (char *) malloc ((total + arrsize) * sizeof (char))))
        return NULL;
    for (i = 0; i < arrsize; ++i) {
        memcpy (buff, arr [i], len [i]);
        buff += len[i];
        *buff++ = c;
    }
    *--buff = '\0';
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11583613_11584000_1_23
11583613_11584117_5_47
Title: Fastest way to convert 2D-array into char* array and copy a char into end of string 
----------------------------------------

char *join (int c, size_t arrsize, const char *arr []) {
    char *buffer;
    size_t i, vsize;
    char *b;
    buffer = malloc (2048);
    b = buffer;
    vsize = 0;
    for (i = 0; i < arrsize; ++i) {
        char *p = arr[i];
        while (*p) {
            *b = *p;
            b++;
            p++;
            vsize++;
        }
        *b = c;
        b++;
    }
    buffer[vsize++] = '\0';
    return realloc (buffer, vsize);
}
----------------------------------------

char *join (char delimiter, size_t arrsize, const char *arr []) {
    size_t i;
    size_t total;
    char *joined;
    for (i = total = 0; i < arrsize; i++) {
        if (arr[i] != NULL)
            total += strlen (arr[i]) + 1;
    }
    joined = (char *) malloc (sizeof (char) * total);
    if (joined != NULL) {
        joined[0] = '\0';
        for (i = 0; i < arrsize; i++) {
            if (arr[i] != NULL) {
                strcat (joined, arr [i]);
                if ((i + 1) != arrsize)
                    strncat (joined, &delimiter, 1);
            }
        }
        return joined;
    }
    int main (int argc, char **argv) {
        const char *foo [] = {"aasdasd", "bgsfsdf", "asdasisc"};
        char *baa = join (' ', 3, foo);
        if (baa != NULL) {
            printf ("%s\n", baa);
            free (baa);
        }
        else {printf ("No memory\n");
    } return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11583613_11584077_22_32
11583613_11584117_34_44
Title: Fastest way to convert 2D-array into char* array and copy a char into end of string 
----------------------------------------

int main () {
    const char *foo [] = {"a", "b", "c"};
    char *baa = join (' ', sizeof (foo) / sizeof (char *), foo);
    if (baa) {
        printf ("\"%s\"\n", baa);
        free (baa);
    }
    else {
        printf ("No memory\n");
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    const char *foo [] = {"aasdasd", "bgsfsdf", "asdasisc"};
    char *baa = join (' ', 3, foo);
    if (baa != NULL) {
        printf ("%s\n", baa);
        free (baa);
    }
    else {printf ("No memory\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11583613_11584077_5_20
11583613_11584117_5_47
Title: Fastest way to convert 2D-array into char* array and copy a char into end of string 
----------------------------------------

char *join (char c, size_t arrsize, const char *arr []) {
    size_t i, total, len [arrsize];
    char *buff, *ret;
    for (total = i = 0; i < arrsize; ++i)
        total += (len[i] = strlen (arr[i]));
    if (NULL == (ret = buff = (char *) malloc ((total + arrsize) * sizeof (char))))
        return NULL;
    for (i = 0; i < arrsize; ++i) {
        memcpy (buff, arr [i], len [i]);
        buff += len[i];
        *buff++ = c;
    }
    *--buff = '\0';
    return ret;
}
----------------------------------------

char *join (char delimiter, size_t arrsize, const char *arr []) {
    size_t i;
    size_t total;
    char *joined;
    for (i = total = 0; i < arrsize; i++) {
        if (arr[i] != NULL)
            total += strlen (arr[i]) + 1;
    }
    joined = (char *) malloc (sizeof (char) * total);
    if (joined != NULL) {
        joined[0] = '\0';
        for (i = 0; i < arrsize; i++) {
            if (arr[i] != NULL) {
                strcat (joined, arr [i]);
                if ((i + 1) != arrsize)
                    strncat (joined, &delimiter, 1);
            }
        }
        return joined;
    }
    int main (int argc, char **argv) {
        const char *foo [] = {"aasdasd", "bgsfsdf", "asdasisc"};
        char *baa = join (' ', 3, foo);
        if (baa != NULL) {
            printf ("%s\n", baa);
            free (baa);
        }
        else {printf ("No memory\n");
    } return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11680056_11682696_38_51
11680056_11685575_18_30
Title: Find the beginning of the first word that is a palindrom 
----------------------------------------

int main () {
    char b [] = "fasdg";
    char c [] = "Hello, mom and dad, how is it going?";
    char d [] = "Hello , mom and dad, how is it going?";
    char *result = findlong (c);
    if (result)
        printf ("%s\n", result);
    return 0;
}
----------------------------------------

int main () {
    const char *data = "Hello mom and dad, how is it going?";
    char *p, *src;
    p = src = strdup (data);
    for (; NULL != (p = strtok (p, " \t\n,.!?")); p = NULL) {
        if (isPalindrome (p)) {
            printf ("%s\n", p);
            break;
        }
    }
    free (src);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11696768_11696895_6_22
11696768_11697571_3_62
Title: Parsing command line input string into char array 
----------------------------------------

int main (void) {
    char *input = "0x1234aabb";
    unsigned long num = strtoul (input, NULL, 16);
    unsigned char bytes [NUM_BYTES];
    unsigned i;
    printf ("The number is: 0x%lx\n", num);
    for (i = 0; i < NUM_BYTES; i++) {
        bytes[i] = (num >> 8 * i) & 0xFF;
        printf ("Byte %u: 0x%x\n", i + 1, bytes [i]);
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char *input;
    int len;
    int num;
    char *a;
    int i;
    int tmp;
    if (argv < 2) {
        printf ("No input specified!\n");
        return 0;
    }
    input = argv[1];
    if (strncmpi (input, "0x", 2) != 0) {
        printf ("Bad input!\n");
        return 0;
    }
    printf ("Input: %s\n", input);
    input += 2;
    len = strlen (input);
    num = (len / 2) + (len % 2);
    if (num < 1) {
        printf ("Bad input!\n");
        return 0;
    }
    printf ("Number of bytes: %d\n", num);
    a = (char *) calloc (num, sizeof (char));
    if (a == NULL) {
        printf ("Cannot allocate memory for bytes!\n");
        return 0;
    }
    for (i = 0; i < num; ++i) {
        if (sscanf (input, "%2x", &tmp) != 1) {
            printf ("Byte %d: Illegal byte value '%02s'\n", i + 1, input);
            break;
        }
        a[i] = (char) tmp;
        printf ("Byte %d: 0x%02x\n", i + 1, a [i]);
        input += 2;
    }
    free (a);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11708192_11708328_5_19
11708192_11711154_5_23
Title: C: extract numbers from a string 
----------------------------------------

int main () {
    int arr [10], idx = 0, d, l = 0;
    char *p, *str = "Trim(2714,8256)++Trim(10056,26448)++Trim(28248,49165)";
    for (p = str; *p != 0; p += l) {
        l = 1;
        if (isdigit (*p)) {
            sscanf (p, "%d%n", & d, & l);
            arr[idx++] = d;
        }
    }
    for (l = 0; l < idx; l++) {
        printf ("%d\n", arr [l]);
    }
    return 0;
}
----------------------------------------

int main () {
    int array [8], count = 0, data;
    const char *s = "Trim(+2714,8256)++Trim(10056,26448)++Trim(28248,49165)";
    char *p;
    while (*s) {
        if (isdigit (*s) || *s == '-' && isdigit (s[1])) {
            data = strtol (s, &p, 10);
            s = p;
            array[count++] = data;
        }
        else
            ++s;
    }
    {
        int i;
        for (i = 0; i < count; ++i)
            printf ("%d\n", array[i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11713699_11713834_1_22
11713699_11739936_3_16
Title: pointer substrings arrays 
----------------------------------------

char *getSub (const char *orig, int start, int count, char *res) {
    char *from = orig, *to = res;
    for (; start > 0; --start, ++from) {
        if (*from == 0) {
            res[0] = 0;
            return res;
        }
    }
    for (; count > 0 && *from; --count) {
        *to++ = *from++;
    }
    *to = 0;
    return res;
}
----------------------------------------

char *getSub (const char *orig, int start, int count, char *res) {
    int i, j, len = strlen (orig), limit = start + count;
    if (res == NULL)
        return NULL;
    if (start >= len || start < 0 || orig == NULL) {
        *res = '\0';
        return res;
    }
    for (j = 0, i = start; i < len && i < limit; ++i) {
        res[j++] = orig[i];
    }
    res[j] = '\0';
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11718573_11718680_4_16
11718573_11718711_4_12
Title: snprintf in a loop does not work on linux 
----------------------------------------

int main (int argc, char **argv) {
    char buffer [255] = {0};
    char fmtbuf [64];
    int i;
    for (i = 0; i < 10; i++) {
        snprintf (fmtbuf, 64, "%x", fmtbuf, i);
        strcat (buffer, fmtbuf);
    }
    printf ("BUFFER  = %s\n", buffer);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char buffer [255] = {0};
    int offset = 0;
    for (int i = 0; i < 10; i++) {
        offset += snprintf (buffer +offset, 255 - offset, ":%x\0", i);
    }
    printf ("BUFFER  = %s\n", buffer);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11718573_11718680_4_16
11718573_11718814_5_15
Title: snprintf in a loop does not work on linux 
----------------------------------------

int main (int argc, char **argv) {
    char buffer [255] = {0};
    char fmtbuf [64];
    int i;
    for (i = 0; i < 10; i++) {
        snprintf (fmtbuf, 64, "%x", fmtbuf, i);
        strcat (buffer, fmtbuf);
    }
    printf ("BUFFER  = %s\n", buffer);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char buffer [255] = {0};
    for (int i = 0; i < 10; i++) {
        char tmp [255] = {0};
        strcpy (tmp, buffer);
        snprintf (buffer, 255, "%s:%x\0", tmp, i);
        printf ("BUFFER  = %s\n", buffer);
    }
    printf ("BUFFER  = %s\n", buffer);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11718573_11718711_4_12
11718573_11718814_5_15
Title: snprintf in a loop does not work on linux 
----------------------------------------

int main (int argc, char **argv) {
    char buffer [255] = {0};
    int offset = 0;
    for (int i = 0; i < 10; i++) {
        offset += snprintf (buffer +offset, 255 - offset, ":%x\0", i);
    }
    printf ("BUFFER  = %s\n", buffer);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char buffer [255] = {0};
    for (int i = 0; i < 10; i++) {
        char tmp [255] = {0};
        strcpy (tmp, buffer);
        snprintf (buffer, 255, "%s:%x\0", tmp, i);
        printf ("BUFFER  = %s\n", buffer);
    }
    printf ("BUFFER  = %s\n", buffer);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11765838_11808933_76_106
11765838_30622980_107_119
Title: How to implement segment trees with lazy propagation? 
----------------------------------------

int main () {
    lazy_segment_node *test = NULL;
    initialize (& test, 1, 10);
    printf ("Lazy evaluation test\n");
    printf ("test->lower_value: %i\n", test -> lower_value);
    printf ("test->upper_value: %i\n", test -> upper_value);
    printf ("\nNode not propagated\n");
    printf ("test->left_child: %p\n", test -> left_child);
    printf ("test->right_child: %p\n", test -> right_child);
    printf ("\nNode propagated with access:\n");
    printf ("access(test)->left_child: %p\n", access (test) -> left_child);
    printf ("access(test)->right_child: %p\n", access (test) -> right_child);
    printf ("\nNode propagated with access, but subchilds are not:\n");
    printf ("access(test)->left_child->left_child: %p\n", access (test) -> left_child -> left_child);
    printf ("access(test)->left_child->right_child: %p\n", access (test) -> left_child -> right_child);
    printf ("\nCan use access on subchilds:\n");
    printf ("access(test->left_child)->left_child: %p\n", access (test -> left_child) -> left_child);
    printf ("access(test->left_child)->right_child: %p\n", access (test -> left_child) -> right_child);
    printf ("\nIt's possible to chain:\n");
    printf ("access(access(access(test)->right_child)->right_child)->lower_value: %i\n", access (access (access (test) -> right_child) -> right_child) -> lower_value);
    printf ("access(access(access(test)->right_child)->right_child)->upper_value: %i\n", access (access (access (test) -> right_child) -> right_child) -> upper_value);
    free_lazy_segment_tree (test);
    return 0;
}
----------------------------------------

int main () {
    for (int i = 0; i < N; i++)
        arr[i] = 1;
    build_tree (1, 0, N - 1);
    memset (lazy, 0, sizeof lazy);
    update_tree (1, 0, N - 1, 0, 6, 5);
    update_tree (1, 0, N - 1, 7, 10, 12);
    update_tree (1, 0, N - 1, 10, N - 1, 100);
    cout << query_tree (1, 0, N -1, 0, N -1) << endl;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11805874_30575254_25_41
11805874_33939415_2_19
Title: counting number of swaps in insertion sort 
----------------------------------------

int main () {
    int t, n, i, res;
    int arr [100000];
    cin >> t;
    while (t--) {
        cin >> n;
        for (i = 0; i < n; i++) {
            cin >> arr[i];
        }
        res = insertionsort (arr, n);
        cout << res << endl;
    }
    return 0;
}
----------------------------------------

int main () {
    int N, swaps, temp [100], i, j;
    scanf ("%d", & N);
    int arr [N];
    swaps = 0;
    for (i = 0; i < N; i++) {
        scanf ("%d", & temp [i]);
        j = i;
        while (j > 0 && arr[j - 1] > temp[i]) {
            arr[j] = arr[j - 1];
            ++swaps;
            --j;
        }
        arr[j] = temp[i];
    }
    printf ("%d", swaps);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11880483_21347164_39_64
11880483_43246038_51_63
Title: Multi-threaded program with 3 threads that prints sequence of numbers 
----------------------------------------

int main () {
    pthread_t ThreadId [THREAD_LIMIT];
    struct thread_arg ThreadArg [THREAD_LIMIT];
    for (int i = 0; i < THREAD_LIMIT; i++)
        pthread_cond_init (&cond[i], NULL);
    for (int i = 0; i < THREAD_LIMIT; i++) {
        ThreadArg[i].index = i;
        ThreadArg[i].waitCond = &cond[i];
        if (i == THREAD_LIMIT - 1)
            ThreadArg[i].signalCond = &cond[0];
        else
            ThreadArg[i].signalCond = &cond[i + 1];
        printf ("starting Thread %d \n", i + 1);
        pthread_create (& ThreadId [i], NULL, & threadFun, (void *) & ThreadArg [i]);
        usleep (500);
    }
    for (int i = 0; i < THREAD_LIMIT; i++)
        pthread_join (ThreadId[i], NULL);
    return 0;
}
----------------------------------------

int main () {
    thread t1 (function1);
    thread t2 (function2);
    thread t3 (function3);
    t1.join ();
    t2.join ();
    t3.join ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11880483_21347164_39_64
11880483_50611883_48_62
Title: Multi-threaded program with 3 threads that prints sequence of numbers 
----------------------------------------

int main () {
    pthread_t ThreadId [THREAD_LIMIT];
    struct thread_arg ThreadArg [THREAD_LIMIT];
    for (int i = 0; i < THREAD_LIMIT; i++)
        pthread_cond_init (&cond[i], NULL);
    for (int i = 0; i < THREAD_LIMIT; i++) {
        ThreadArg[i].index = i;
        ThreadArg[i].waitCond = &cond[i];
        if (i == THREAD_LIMIT - 1)
            ThreadArg[i].signalCond = &cond[0];
        else
            ThreadArg[i].signalCond = &cond[i + 1];
        printf ("starting Thread %d \n", i + 1);
        pthread_create (& ThreadId [i], NULL, & threadFun, (void *) & ThreadArg [i]);
        usleep (500);
    }
    for (int i = 0; i < THREAD_LIMIT; i++)
        pthread_join (ThreadId[i], NULL);
    return 0;
}
----------------------------------------

int main () {
    thread t3 (function3);
    thread t1 (function1);
    thread t2 (function2);
    cv1.notify_one ();
    t1.join ();
    t2.join ();
    t3.join ();
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11880483_43246038_51_63
11880483_50611883_48_62
Title: Multi-threaded program with 3 threads that prints sequence of numbers 
----------------------------------------

int main () {
    thread t1 (function1);
    thread t2 (function2);
    thread t3 (function3);
    t1.join ();
    t2.join ();
    t3.join ();
    return 0;
}
----------------------------------------

int main () {
    thread t3 (function3);
    thread t1 (function1);
    thread t2 (function2);
    cv1.notify_one ();
    t1.join ();
    t2.join ();
    t3.join ();
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11883803_11884062_1_11
11883803_11885407_2_11
Title: different behaviour of program 
----------------------------------------

int main (int argc, char const *argv []) {
    do {
        char name [20];
        gets (name);
        printf ("%s\n", name);
    }
    while (1);
    return 0;
}
----------------------------------------

int main () {
    char name [20];
    do {
        gets (name);
        puts (name);
    }
    while (1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11961037_11968806_102_138
11961037_11976016_164_193
Title: C parser recursion 
----------------------------------------

int process_expression (char operator, int *operands, int num_operands) {
    int result = 0;
    switch (operator) {
    case '+' :
        for (int i = 0; i < num_operands; i++) {
            result += operands[i];
        }
        break;
    case '-' :
        result = operands[0];
        for (int i = 1; i < num_operands; i++) {
            result -= operands[i];
        }
        break;
    case '*' :
        result = operands[0];
        for (int i = 1; i < num_operands; i++) {
            result *= operands[i];
        }
        break;
    case '/' :
        result = operands[0];
        for (int i = 1; i < num_operands; i++) {
            result /= operands[i];
        }
        break;
    default :
        printf ("ERROR invalid operator: %c\n", operator);
    }
    return result;
}
----------------------------------------

int process_expression (void) {
    int result = 0;
    token current_token = get_token ();
    if (current_token.type != OPERATOR) {
        fprintf (stderr, "ERROR: %s expecting operator\n", __func__);
        exit (1);
    }
    char operator = current_token.operator;
    current_token = get_token ();
    int operands [200];
    int operands_index = 0;
    while (current_token.type != CLOSE_PAREN && current_token.type != END_OF_EXPR) {
        if (current_token.type == NUMBER) {
            operands[operands_index] = current_token.number;
            operands_index += 1;
        }
        else if (current_token.type == OPEN_PAREN) {
            operands[operands_index] = process_expression ();
            operands_index += 1;
        }
        current_token = get_token ();
    }
    result = evaluate (operator, operands, operands_index);
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11961037_11968806_183_197
11961037_11976016_195_215
Title: C parser recursion 
----------------------------------------

void process_lisp_string (const char *string) {
    token tokens [100];
    int num_tokens = 0;
    int result = get_tokens (string, tokens, &num_tokens);
    if (result == GOOD_LINE) {
        printf ("the answer is: %d\n", process_tokens (tokens, num_tokens));
    }
    else {
        printf ("the string contained errors\n");
    }
}
----------------------------------------

void process_lisp_string (const char *line) {
    int result = tokenize (line, tokens, &num_tokens);
    if (result == GOOD_LINE) {
        token first = get_token ();
        if (first.type == OPEN_PAREN)
            printf ("the answer for %s is: %d\n", line, process_expression ());
        else {
            fprintf (stderr, "ERROR: no open parentheses at front of expression\n");
            fprintf (stderr, "token type:%d\n", first.type);
        }
    }
    else {
        printf ("the line contained errors\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11970714_11973511_20_81
11970714_18558094_4_42
Title: Converting binary to number string to decimal number in C 
----------------------------------------

int main () {
    char string [100];
    int s;
    char a;
    char j;
    int sum = 0;
    int string_length = 0;
    int number, original_number;
    int remainder;
    char binary_string [200];
    int i = 0;
    printf ("B = B to D\n");
    printf ("D = D to B\n");
    printf ("choose which one to convert to:");
    scanf ("%c%c", & a, & j);
    a = toupper (a);
    if (a == 'B') {
        printf ("enter binary number to convert to decimal: ");
        scanf ("%s", string);
        string_length = strlen (string);
        for (s = strlen (string) - 1; s >= 0; s--) {
            if (string[s] == '1') {
                sum = sum + pow (2, string_length -(s + 1));
            }
        }
        printf ("%s in binary is %d\n", string, sum);
    }
    else if (a == 'D') {
        printf ("enter positive decimal number to convert to binary: ");
        scanf ("%s", string);
        number = atoi (string);
        original_number = number;
        if (number < 0) {
            printf ("ERROR: only positive numbers please\n");
            return 1;
        }
        do {
            remainder = number % 2;
            if (remainder == 0)
                binary_string[i] = '0';
            else
                binary_string[i] = '1';
            number = number / 2;
            i += 1;
        }
        while (number > 0);
        binary_string[i] = '\0';
        reverse_string (binary_string);
        printf ("decimal %d is %s in binary\n", original_number, binary_string);
    }
    return 0;
}
----------------------------------------

int main () {
    double fraDecimal = 0.0, dFractional = 0.0, fraFactor = 0.5;
    long dIntegral = 0, bIntegral = 0, bFractional [MAX];
    long intFactor = 1, remainder, i = 0, k = 0, flag = 0;
    char fraBinary [MAX];
    printf ("Enter any fractional binary number: ");
    scanf ("%s", & fraBinary);
    while (fraBinary[i]) {
        if (fraBinary[i] == '.')
            flag = 1;
        else if (flag == 0)
            bIntegral = bIntegral * 10 + (fraBinary[i] - 48);
        else
            bFractional[k++] = fraBinary[i] - 48;
        i++;
    }
    while (bIntegral != 0) {
        remainder = bIntegral % 10;
        dIntegral = dIntegral + remainder * intFactor;
        intFactor = intFactor * 2;
        bIntegral = bIntegral / 10;
    }
    for (i = 0; i < k; i++) {
        dFractional = dFractional + bFractional[i] * fraFactor;
        fraFactor = fraFactor / 2;
    }
    fraDecimal = dIntegral + dFractional;
    printf ("Equivalent decimal value: %Lf", fraDecimal);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11980723_11981121_1_23
11980723_11987032_19_28
Title: Array manipulation in C 
----------------------------------------

int main () {
    int c, i, j;
    char word [10];
    printf ("Enter a word:");
    scanf ("%s", word);
    c = strlen (word);
    printf ("Your word has %d letters ", c);
    for (i = 0; i < c; i++) {
        for (j = 0; j <= 25; j++) {
            if (word[i] == alphabetsEnglish[0][j] || word[i] == alphabetsEnglish[1][j]) {
                printf ("Your alphabet %c translates to %d: ", word [i], j);
            }
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *word = "abc";
    int i, size = strlen (word), *result;
    result = conv (word);
    for (i = 0; i < size; ++i) {
        printf ("%d ", result [i]);
    }
    free (result);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11982038_11982249_40_65
11982038_11982436_4_19
Title: how to pass 2 dimensional array if both dimensions are unknown at compile time 
----------------------------------------

int main () {
    print (& test [0] [0], 2, 4);
    print2 (test2, 2, 4);
    float **dynamic_array = (float **) malloc (2 * sizeof (float *));
    dynamic_array[0] = (float *) malloc (4 * sizeof (float));
    dynamic_array[1] = (float *) malloc (4 * sizeof (float));
    for (int row = 0; row < 2; ++row) {
        for (int col = 0; col < 4; ++col) {
            dynamic_array[row][col] = (float) (row * 4 + col);
        }
    }
    print2 (dynamic_array, 2, 4);
    return 0;
}
----------------------------------------

int main (void) {
    int layers = 3;
    int elem = 5;
    int * pArray = new int [layers * elem];
    for (int i = 0; i < sizeof (pArray) / sizeof (pArray[0]); ++i) {
        for (int j = 0; j < sizeof (pArray[0]) / sizeof (int); ++j) {
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11999884_11999913_3_15
11999884_12001102_3_14
Title: Do while loop with choice as char in C 
----------------------------------------

int main () {
    char choice;
    do {
        printf ("Press y to continue the loop : ");
        choice = getchar ();
        getchar ();
    }
    while (choice == 'y');
    return 0;
}
----------------------------------------

int main (void) {
    char choice;
    do {
        printf ("Press y to continue the loop : ");
        scanf (" %c", & choice);
    }
    while (choice == 'y');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1201200_12280731_1_71
1201200_14976268_1_32
Title: fast algorithm for drawing filled circles? 
----------------------------------------

void DrawFilledCircle (int circleDiameter, int circlePosX, int circlePosY) {
    const int FULL = (1 << 2);
    const int HALF = (FULL >> 1);
    int size = (circleDiameter << 2);
    int ray = (size >> 1);
    int dY2;
    int ray2 = ray * ray;
    int posmin, posmax;
    int Y, X;
    int x = ((circleDiameter & 1) == 1) ? ray : ray - HALF;
    int y = HALF;
    circlePosX -= (circleDiameter >> 1);
    circlePosY -= (circleDiameter >> 1);
    for (;; y += FULL) {
        dY2 = (ray - y) * (ray - y);
        for (;; x -= FULL) {
            if (dY2 + (ray - x) * (ray - x) <= ray2)
                continue;
            if (x < y) {
                Y = (y >> 2);
                posmin = Y;
                posmax = circleDiameter - Y;
                while (Y < posmax) {
                    for (X = posmin; X < posmax; X++)
                        setPixel (circlePosX +X, circlePosY +Y);
                    Y++;
                }
                return;
            }
            X = (x >> 2) + 1;
            Y = y >> 2;
            posmax = circleDiameter - X;
            int mirrorY = circleDiameter - Y - 1;
            while (X < posmax) {
                setPixel (circlePosX + X, circlePosY + Y);
                setPixel (circlePosX + X, circlePosY + mirrorY);
                setPixel (circlePosX + Y, circlePosY + X);
                setPixel (circlePosX + mirrorY, circlePosY + X);
                X++;
            }
            break;
        }
    }
}
----------------------------------------

void DrawFilledCircle (int x0, int y0, int radius) {
    int x = radius;
    int y = 0;
    int xChange = 1 - (radius << 1);
    int yChange = 0;
    int radiusError = 0;
    while (x >= y) {
        for (int i = x0 - x; i <= x0 + x; i++) {
            SetPixel (i, y0 + y);
            SetPixel (i, y0 - y);
        }
        for (int i = x0 - y; i <= x0 + y; i++) {
            SetPixel (i, y0 + x);
            SetPixel (i, y0 - x);
        }
        y++;
        radiusError += yChange;
        yChange += 2;
        if (((radiusError << 1) + xChange) > 0) {
            x--;
            radiusError += xChange;
            xChange += 2;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12017168_12017550_11_29
12017168_12018225_10_24
Title: Passing command line arguments through a C setuid wrapper to another script 
----------------------------------------

int main (int argc, char **argv) {
    struct passwd *pwd;
    char user [] = SETUIDUSER;
    char buf [CMDMAXLGTH];
    char *p = buf;
    int i = 1;
    pwd = getpwnam (user);
    setuid (pwd -> pw_uid);
    memset (buf, 0, sizeof (buf));
    while (argv[i]) {
        p += sprintf (p, " %s", argv[i++]);
    }
    system (buf);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    struct passwd *pwd;
    char user [] = SETUIDUSER;
    pwd = getpwnam (user);
    setuid (pwd -> pw_uid);
    if (argc < 2)
        return 1;
    execvp (argv [1], & argv [1]);
    return 42;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12091059_12091300_1_11
12091059_12093635_1_22
Title: How to parse integer command line arguments in C? 
----------------------------------------

int main (int argc, char *argv []) {
    long a, b;
    if (argc > 2) {
        a = strtol (argv[1], NULL, 0);
        b = strtol (argv[2], NULL, 0);
        printf ("%ld %ld", a, b);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int no1 = 0, no2 = 0, ret = 0;
    if ((argc != 0) && (argc != 2)) {
        return 0;
    }
    if (2 == argc) {
        ret = sscanf (argv[1], "%d", &no1);
        if (ret != 1)
            return 0;
        ret = sscanf (argv[2], "%d", &no2);
        if (ret != 1)
            return 0;
        if ((no1 < 0) || (no1 > 100))
            return 0;
        if ((no2 < 0) || (no2 > 100))
            return 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12128934_38769238_3_14
12128934_42927381_2_16
Title: how to count string array elements in C? 
----------------------------------------

int main () {
    char *myarray [] = {"Mere", "Pere", "Gutui"};
    int i = 0;
    int lungime = strlen (*myarray);
    while (i < (lungime - 1)) {
        printf ("Fruit no. %d is %s\n", i, * (myarray + i));
        i++;
    }
    return 0;
}
----------------------------------------

int main () {
    char *fruits [] = {"Apple", "Grapefruit", "Banana"};
    int i = 0;
    int count = sizeof (fruits) / sizeof (fruits[0]);
    char **bitter = &fruits[1];
    printf ("Bitter fruit is: %s\n", * bitter);
    printf ("All fruits are:\n");
    for (i = 0; i < count; i++) {
        printf ("%s\n", fruits [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12147542_12147857_4_12
12147542_12163518_71_81
Title: A basic/ manual way to check that a value entered by the user is numeric 
----------------------------------------

int main () {
    int a;
    char str [LEN];
    fgets (str, LEN, stdin);
    while (!sscanf (str, "%d", &a))
        fgets (str, 10, stdin);
    printf ("Num is : %d\n", a);
    return 0;
}
----------------------------------------

int main () {
    const char *error_message = "Wrong input. Re-enter a valid value.\n";
    int x, y, z, max;
    x = getValue (error_message, 1, 1000);
    y = getValue (error_message, 1, 1000);
    z = getValue (error_message, 1, 1000);
    max = max (max (x, y), z);
    printf ("max:%d\n", max);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1217721_29715411_3_35
1217721_29845361_5_26
Title: How do I replace multiple spaces with a single space? 
----------------------------------------

int main () {
    int c, lastspace;
    lastspace = 0;
    while ((c = getchar ()) != EOF) {
        if (c != ' ') {
            putchar (c);
            lastspace = 0;
        }
        else {
            if (lastspace != 1)
                putchar (c);
            lastspace = 1;
        }
    }
    return 0;
}
----------------------------------------

int main () {
    int t;
    bool flag = False;
    while ((t = getchar ()) != EOF)
        if (t == ' ' && !flag) {
            putchar (' ');
            flag = True;
        }
        else if (t == ' ' && flag)
            continue;
        else {
            putchar (t);
            flag = False;
        }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1217721_29715411_3_35
1217721_36807047_4_21
Title: How do I replace multiple spaces with a single space? 
----------------------------------------

int main () {
    int c, lastspace;
    lastspace = 0;
    while ((c = getchar ()) != EOF) {
        if (c != ' ') {
            putchar (c);
            lastspace = 0;
        }
        else {
            if (lastspace != 1)
                putchar (c);
            lastspace = 1;
        }
    }
    return 0;
}
----------------------------------------

int main () {
    char word [100];
    gets (word);
    int i = 0, l, j;
    l = strlen (word);
    for (i = 0; i < l; i++) {
        if (word[i] == ' ' && word[i + 1] == ' ') {
            for (j = i + 1; j < l; j++)
                word[j] = word[j + 1];
        }
    }
    puts (word);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1217721_29845361_5_26
1217721_36807047_4_21
Title: How do I replace multiple spaces with a single space? 
----------------------------------------

int main () {
    int t;
    bool flag = False;
    while ((t = getchar ()) != EOF)
        if (t == ' ' && !flag) {
            putchar (' ');
            flag = True;
        }
        else if (t == ' ' && flag)
            continue;
        else {
            putchar (t);
            flag = False;
        }
    return 0;
}
----------------------------------------

int main () {
    char word [100];
    gets (word);
    int i = 0, l, j;
    l = strlen (word);
    for (i = 0; i < l; i++) {
        if (word[i] == ' ' && word[i + 1] == ' ') {
            for (j = i + 1; j < l; j++)
                word[j] = word[j + 1];
        }
    }
    puts (word);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12183899_12183931_5_16
12183899_12192531_6_16
Title: How to print value of global variable and local variable having same name? 
----------------------------------------

int main (void) {
    int a = 15;
    printf ("Inside a's main local a = : %d\n", a);
    {
        extern int a;
        printf ("In a global a = %d\n", a);
    }
    return 0;
}
----------------------------------------

int main () {
    int a = 10;
    if (1) {
        extern int a;
        printf ("global: %d\n", a);
    }
    printf ("local: %d\n", a);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1219199_52256935_5_28
1219199_6385166_2_21
Title: size of a datatype without using sizeof 
----------------------------------------

int main () {
    char *a = 0;
    int *b = 0;
    long *c = 0;
    a++;
    b++;
    c++;
    printf ("%d", a);
    printf ("%d", b);
    printf ("%d", c);
    return 0;
}
----------------------------------------

int main () {
    unsigned int i = 1;
    unsigned int int_bits = 0;
    while (i != 0) {
        i <<= 1;
        ++int_bits;
    }
    unsigned char uc = 1;
    unsigned int char_bits = 0;
    while (uc != 0) {
        uc <<= 1;
        ++char_bits;
    }
std :
    : cout << "Type int has " << int_bits << "bits.\n";
std :
    : cout << "This would be  " << int_bits / 8 << " IT bytes and " << int_bits / char_bits << " C++ bytes on your platform.\n";
std :
    : cout << "Anyways, not all bits might be usable by you. Hah.\n";
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1219438_1219450_1_11
1219438_1219475_1_10
Title: C : How do you simulate an 'exception'? 
----------------------------------------

int pop (double *outval) {
    if (outval == 0)
        return -1;
    if (sp > 0)
        *outval = val[--sp];
    else {
        printf ("error: stack empty\n");
        return -1;
    }
    return 0;
}
----------------------------------------

double pop (int *error) {
    if (sp > 0) {
        return val[--sp];
        *error = 0;
    }
    else {* error = 1;
    printf ("error: stack empty\n");
    return 0.0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1219438_1219450_1_11
1219438_1219888_11_19
Title: C : How do you simulate an 'exception'? 
----------------------------------------

int pop (double *outval) {
    if (outval == 0)
        return -1;
    if (sp > 0)
        *outval = val[--sp];
    else {
        printf ("error: stack empty\n");
        return -1;
    }
    return 0;
}
----------------------------------------

popRC pop (struct stack *pS) {
    popRC rc;
    rc.size = pS->size;
    if (rc.size) {
        --pS->size;
        rc.value = pS->pData[pS->size];
    }
    return rc;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1219438_1219475_1_10
1219438_1219888_11_19
Title: C : How do you simulate an 'exception'? 
----------------------------------------

double pop (int *error) {
    if (sp > 0) {
        return val[--sp];
        *error = 0;
    }
    else {* error = 1;
    printf ("error: stack empty\n");
    return 0.0;
}
----------------------------------------

popRC pop (struct stack *pS) {
    popRC rc;
    rc.size = pS->size;
    if (rc.size) {
        --pS->size;
        rc.value = pS->pData[pS->size];
    }
    return rc;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1223947_6016639_1_14
1223947_6019464_4_20
Title: "Time zone conversion C API on Linux anyone?" 
----------------------------------------

int main () {
    time_t t_gmt, t_local = time (NULL);
    struct tm tm_gmt;
    gmtime_r (& t_local, & tm_gmt);
    t_gmt = mktime (&tm_gmt);
    printf ("Time now is:    %s", ctime (& t_local));
    printf ("Time in GMT is: %s", ctime (& t_gmt));
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    time_t t, lt, gt;
    struct tm tm;
    t = time (NULL);
    lt = mktime (localtime (&t));
    gt = mktime (gmtime (&t));
    printf ("(t = time(NULL)) == %x,\n" "mktime(localtime(&t)) == %x,\n" "mktime(gmtime(&t)) == %x\n" "difftime(...) == %f\n" "timezone == %d\n", t, lt, gt, difftime (gt, lt), timezone);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12247884_12249169_21_72
12247884_12259814_33_111
Title: Why is my variable corrupt after returning from a function? 
----------------------------------------

void set_credentials (char *username, char *password) {
    char c;
    char lines [2] [100];
    int i = 0;
    char *tmp = *lines;
    char *user = "user";
    char *pass = "password";
    const char *filename = "/netnfork/config/netnfork_credentials.properties";
    FILE *fp = fopen (filename, "r");
    if (fp == NULL)
        exit (EIO);
    else
        printf ("successfully opened %s\n", filename);
    while ((c = fgetc (fp)) != EOF && i < 2) {
        if (c != '\n') {
            *tmp = c;
            tmp++;
        }
        else {
            *tmp = '\0';
            i++;
            tmp = lines[i];
        }
    }
    fclose (fp);
    i = 0;
    while (i < 2) {
        if (strncmp (user, lines[i], 4) == 0) {
            strcpy (username, lines [i] + 5);
        }
        else if (strncmp (pass, lines[i], 8) == 0) {
            strcpy (password, lines [i] + 9);
        }
        else {
            printf ("ERROR: invalid line in file:\n");
            printf ("%s\n", lines [i]);
            exit (1);
        }
        i++;
    }
}
----------------------------------------

void set_credentials (char **username, char **password) {
    char c;
    int i = 0, j = 0;
    char *lines [FILE_LINES];
    char *tmp = NULL;
    char *user = "user ";
    char *pass = "password ";
    char user_found = 0, password_found = 0;
    for (j = 0; j < FILE_LINES; j++) {
        lines[j] = malloc (MAX_LINE_LENGTH +1);
        lines[j][0] = '\0';
    }
    tmp = lines[0];
    const char *filename = "/netnfork/config/netnfork_credentials.properties";
    FILE *fp = fopen (filename, "r");
    if (fp == NULL) {
        printf ("ERROR %d trying to open %s\n", errno, filename);
        exit (EIO);
    }
    while ((c = fgetc (fp)) != EOF && i < FILE_LINES) {
        if (c != '\n') {
            *tmp = c;
            tmp++;
        }
        else {
            *tmp = '\0';
            i++;
            tmp = lines[i];
        }
    }
    if (i < 2) {
        printf ("ERROR: file %s is incomplete needs %d lines (password and user)\n", filename, FILE_LINES);
        exit (1);
    }
    fclose (fp);
    i = 0;
    while (i < FILE_LINES) {
        if (strncmp (user, lines[i], USERLINE_PREFIX) == 0) {
            user_found = 1;
            *username = lines[i];
        }
        else if (strncmp (pass, lines[i], PASSLINE_PREFIX) == 0) {
            password_found = 1;
            *password = lines[i];
        }
        else {
            printf ("ERROR: invalid line in file:\n");
            printf ("%s\n", lines [i]);
            exit (1);
        }
        i++;
    }
    if (!(password_found && user_found)) {
        printf ("ERROR: file %s is invalid, missing %s line\n", filename, (user_found) ? "password" : "user");
        exit (1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12247884_12258824_25_81
12247884_12259814_33_111
Title: Why is my variable corrupt after returning from a function? 
----------------------------------------

void set_credentials (char **username, char **password) {
    char c;
    static char lines [MAX_FILE_LINES] [100];
    int i = 0;
    char *tmp = *lines;
    char *user = "user";
    char *pass = "password";
    const char *filename = "/netnfork/config/netnfork_credentials.properties";
    FILE *fp = fopen (filename, "r");
    if (fp == NULL) {
        printf ("ERROR: unable to open %s\n", filename);
        exit (EIO);
    }
    else
        printf ("successfully opened %s\n", filename);
    while ((c = fgetc (fp)) != EOF && i < MAX_FILE_LINES) {
        if (c != '\n') {
            *tmp = c;
            tmp++;
        }
        else {
            *tmp = '\0';
            i++;
            tmp = lines[i];
        }
    }
    fclose (fp);
    i = 0;
    while (i < 2) {
        if (strncmp (user, lines[i], 4) == 0) {
            *username = lines[i] + 5;
        }
        else if (strncmp (pass, lines[i], 8) == 0) {
            *password = lines[i] + 9;
        }
        else {
            printf ("ERROR: invalid line in file:\n");
            printf ("%s\n", lines [i]);
            exit (1);
        }
        i++;
    }
}
----------------------------------------

void set_credentials (char **username, char **password) {
    char c;
    int i = 0, j = 0;
    char *lines [FILE_LINES];
    char *tmp = NULL;
    char *user = "user ";
    char *pass = "password ";
    char user_found = 0, password_found = 0;
    for (j = 0; j < FILE_LINES; j++) {
        lines[j] = malloc (MAX_LINE_LENGTH +1);
        lines[j][0] = '\0';
    }
    tmp = lines[0];
    const char *filename = "/netnfork/config/netnfork_credentials.properties";
    FILE *fp = fopen (filename, "r");
    if (fp == NULL) {
        printf ("ERROR %d trying to open %s\n", errno, filename);
        exit (EIO);
    }
    while ((c = fgetc (fp)) != EOF && i < FILE_LINES) {
        if (c != '\n') {
            *tmp = c;
            tmp++;
        }
        else {
            *tmp = '\0';
            i++;
            tmp = lines[i];
        }
    }
    if (i < 2) {
        printf ("ERROR: file %s is incomplete needs %d lines (password and user)\n", filename, FILE_LINES);
        exit (1);
    }
    fclose (fp);
    i = 0;
    while (i < FILE_LINES) {
        if (strncmp (user, lines[i], USERLINE_PREFIX) == 0) {
            user_found = 1;
            *username = lines[i];
        }
        else if (strncmp (pass, lines[i], PASSLINE_PREFIX) == 0) {
            password_found = 1;
            *password = lines[i];
        }
        else {
            printf ("ERROR: invalid line in file:\n");
            printf ("%s\n", lines [i]);
            exit (1);
        }
        i++;
    }
    if (!(password_found && user_found)) {
        printf ("ERROR: file %s is invalid, missing %s line\n", filename, (user_found) ? "password" : "user");
        exit (1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_122974_1_41
122616_1845096_5_32
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

int main (int argc, char *argv []) {
    char *sample_strings [] = {"nothing to trim", "    trim the front", "trim the back     ", " trim one char front and back ", " trim one char front", "trim one char back ", "                   ", " ", "a", "", NULL};
    char test_buffer [64];
    int index;
    for (index = 0; sample_strings[index] != NULL; ++index) {
        strcpy (test_buffer, sample_strings [index]);
        printf ("[%s] -> [%s]\n", sample_strings [index], trim (test_buffer));
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *ptr = (char *) malloc (sizeof (char) * 30);
    strcpy (ptr, "            Hel  lo    wo           rl   d G    eo rocks!!!    by shahil    sucks b i          g       tim           e");
    int i = 0, j = 0;
    while (ptr[j] != '\0') {
        if (ptr[j] == ' ') {
            j++;
            ptr[i] = ptr[j];
        }
        else {
            i++;
            j++;
            ptr[i] = ptr[j];
        }
    }
    printf ("\noutput-%s\n", ptr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_35305045_1_23
122616_35899634_1_20
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char * const str) {
    char *begin = str;
    char *end = str;
    while (isspace (*begin)) {
        ++begin;
    }
    char *s = begin;
    while (*s != '\0') {
        if (!isspace (*s++)) {
            end = s;
        }
    }
    *end = '\0';
    const int dist = end - begin;
    if (begin > str && dist > 0) {
        memmove (str, begin, dist + 1);
    }
}
----------------------------------------

void trim (char *string) {
    int lenght = strlen (string);
    int i = 0;
    while (string[0] == ' ') {
        for (i = 0; i < lenght; i++) {
            string[i] = string[i + 1];
        }
        lenght--;
    }
    for (i = lenght - 1; i > 0; i--) {
        if (string[i] == ' ') {
            string[i] = '\0';
        }
        else {
            break;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_35305045_1_23
122616_3975465_1_18
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char * const str) {
    char *begin = str;
    char *end = str;
    while (isspace (*begin)) {
        ++begin;
    }
    char *s = begin;
    while (*s != '\0') {
        if (!isspace (*s++)) {
            end = s;
        }
    }
    *end = '\0';
    const int dist = end - begin;
    if (begin > str && dist > 0) {
        memmove (str, begin, dist + 1);
    }
}
----------------------------------------

void trim (char *str) {
    int i;
    int begin = 0;
    int end = strlen (str) - 1;
    while (isspace ((unsigned char) str[begin]))
        begin++;
    while ((end >= begin) && isspace ((unsigned char) str[end]))
        end--;
    for (i = begin; i <= end; i++)
        str[i - begin] = str[i];
    str[i - begin] = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_35305045_1_23
122616_4505533_3_10
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char * const str) {
    char *begin = str;
    char *end = str;
    while (isspace (*begin)) {
        ++begin;
    }
    char *s = begin;
    while (*s != '\0') {
        if (!isspace (*s++)) {
            end = s;
        }
    }
    *end = '\0';
    const int dist = end - begin;
    if (begin > str && dist > 0) {
        memmove (str, begin, dist + 1);
    }
}
----------------------------------------

void trim (char * const a) {
    char *p = a, *q = a;
    while (isspace (*q))
        ++q;
    while (*q)
        *p++ = *q++;
    *p = '\0';
    while (p > a && isspace (*--p))
        *p = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_35305045_1_23
122616_45582189_5_30
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char * const str) {
    char *begin = str;
    char *end = str;
    while (isspace (*begin)) {
        ++begin;
    }
    char *s = begin;
    while (*s != '\0') {
        if (!isspace (*s++)) {
            end = s;
        }
    }
    *end = '\0';
    const int dist = end - begin;
    if (begin > str && dist > 0) {
        memmove (str, begin, dist + 1);
    }
}
----------------------------------------

size_t trim (char *out, size_t n, const char *str) {
    if (n == 0)
        return 0;
    while (isspace (*str))
        str++;
    if (*str == '\0') {
        out[0] = '\0';
        return 0;
    }
    size_t i = 0;
    for (i = 0; i < n - 1 && *str != '\0'; i++) {
        out[i] = *str++;
    }
    while (isspace (out[--i]))
        ;
    out[++i] = '\0';
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_35899634_1_20
122616_3975465_1_18
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char *string) {
    int lenght = strlen (string);
    int i = 0;
    while (string[0] == ' ') {
        for (i = 0; i < lenght; i++) {
            string[i] = string[i + 1];
        }
        lenght--;
    }
    for (i = lenght - 1; i > 0; i--) {
        if (string[i] == ' ') {
            string[i] = '\0';
        }
        else {
            break;
        }
    }
}
----------------------------------------

void trim (char *str) {
    int i;
    int begin = 0;
    int end = strlen (str) - 1;
    while (isspace ((unsigned char) str[begin]))
        begin++;
    while ((end >= begin) && isspace ((unsigned char) str[end]))
        end--;
    for (i = begin; i <= end; i++)
        str[i - begin] = str[i];
    str[i - begin] = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_35899634_1_20
122616_4505533_3_10
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char *string) {
    int lenght = strlen (string);
    int i = 0;
    while (string[0] == ' ') {
        for (i = 0; i < lenght; i++) {
            string[i] = string[i + 1];
        }
        lenght--;
    }
    for (i = lenght - 1; i > 0; i--) {
        if (string[i] == ' ') {
            string[i] = '\0';
        }
        else {
            break;
        }
    }
}
----------------------------------------

void trim (char * const a) {
    char *p = a, *q = a;
    while (isspace (*q))
        ++q;
    while (*q)
        *p++ = *q++;
    *p = '\0';
    while (p > a && isspace (*--p))
        *p = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_35899634_1_20
122616_45582189_5_30
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char *string) {
    int lenght = strlen (string);
    int i = 0;
    while (string[0] == ' ') {
        for (i = 0; i < lenght; i++) {
            string[i] = string[i + 1];
        }
        lenght--;
    }
    for (i = lenght - 1; i > 0; i--) {
        if (string[i] == ' ') {
            string[i] = '\0';
        }
        else {
            break;
        }
    }
}
----------------------------------------

size_t trim (char *out, size_t n, const char *str) {
    if (n == 0)
        return 0;
    while (isspace (*str))
        str++;
    if (*str == '\0') {
        out[0] = '\0';
        return 0;
    }
    size_t i = 0;
    for (i = 0; i < n - 1 && *str != '\0'; i++) {
        out[i] = *str++;
    }
    while (isspace (out[--i]))
        ;
    out[++i] = '\0';
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_3975465_1_18
122616_4505533_3_10
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char *str) {
    int i;
    int begin = 0;
    int end = strlen (str) - 1;
    while (isspace ((unsigned char) str[begin]))
        begin++;
    while ((end >= begin) && isspace ((unsigned char) str[end]))
        end--;
    for (i = begin; i <= end; i++)
        str[i - begin] = str[i];
    str[i - begin] = '\0';
}
----------------------------------------

void trim (char * const a) {
    char *p = a, *q = a;
    while (isspace (*q))
        ++q;
    while (*q)
        *p++ = *q++;
    *p = '\0';
    while (p > a && isspace (*--p))
        *p = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_3975465_1_18
122616_45582189_5_30
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char *str) {
    int i;
    int begin = 0;
    int end = strlen (str) - 1;
    while (isspace ((unsigned char) str[begin]))
        begin++;
    while ((end >= begin) && isspace ((unsigned char) str[end]))
        end--;
    for (i = begin; i <= end; i++)
        str[i - begin] = str[i];
    str[i - begin] = '\0';
}
----------------------------------------

size_t trim (char *out, size_t n, const char *str) {
    if (n == 0)
        return 0;
    while (isspace (*str))
        str++;
    if (*str == '\0') {
        out[0] = '\0';
        return 0;
    }
    size_t i = 0;
    for (i = 0; i < n - 1 && *str != '\0'; i++) {
        out[i] = *str++;
    }
    while (isspace (out[--i]))
        ;
    out[++i] = '\0';
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
122616_4505533_3_10
122616_45582189_5_30
Title: How do I trim leading/trailing whitespace in a standard way? 
----------------------------------------

void trim (char * const a) {
    char *p = a, *q = a;
    while (isspace (*q))
        ++q;
    while (*q)
        *p++ = *q++;
    *p = '\0';
    while (p > a && isspace (*--p))
        *p = '\0';
}
----------------------------------------

size_t trim (char *out, size_t n, const char *str) {
    if (n == 0)
        return 0;
    while (isspace (*str))
        str++;
    if (*str == '\0') {
        out[0] = '\0';
        return 0;
    }
    size_t i = 0;
    for (i = 0; i < n - 1 && *str != '\0'; i++) {
        out[i] = *str++;
    }
    while (isspace (out[--i]))
        ;
    out[++i] = '\0';
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12284768_18798832_3_137
12284768_28390270_13_45
Title: Write code to convert given number into words (eg 1234 as input should output one thousand two hundred and thirty four) 
----------------------------------------

void main () {
    int len = 0, revnum, i, dup = 0, j = 0, k = 0;
    long int gvalue;
    char ones [] [10] = {"one", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen", ""};
    char twos [] [10] = {"Ten", "Twenty", "Thirty", "Fourty", "fifty", "Sixty", "Seventy", "eighty", "Ninety", ""};
    clrscr ();
    printf ("\n Enter value");
    scanf ("%ld", & gvalue);
    if (gvalue == 10)
        printf ("Ten");
    else if (gvalue == 100)
        printf ("Hundred");
    else if (gvalue == 1000)
        printf ("Thousand");
    dup = gvalue;
    for (i = 0; dup > 0; i++) {
        revnum = revnum * 10 + dup % 10;
        len++;
        dup = dup / 10;
    }
    while (j < len) {
        if (gvalue < 10) {
            printf ("%s ", ones [gvalue - 1]);
        }
        else if (gvalue > 10 && gvalue <= 19) {
            printf ("%s ", ones [gvalue - 2]);
            break;
        }
        else if (gvalue > 19 && gvalue < 100) {
            k = gvalue / 10;
            gvalue = gvalue % 10;
            printf ("%s ", twos [k - 1]);
        }
        else if (gvalue > 100 && gvalue < 1000) {
            k = gvalue / 100;
            gvalue = gvalue % 100;
            printf ("%s Hundred ", ones [k - 1]);
        }
        else if (gvalue >= 1000 && gvlaue < 9999) {
            k = gvalue / 1000;
            gvalue = gvalue % 1000;
            printf ("%s Thousand ", ones [k - 1]);
        }
        else if (gvalue >= 11000 && gvalue <= 19000) {
            k = gvalue / 1000;
            gvalue = gvalue % 1000;
            printf ("%s Thousand ", twos [k - 2]);
        }
        else if (gvalue >= 12000 && gvalue < 100000) {
            k = gvalue / 10000;
            gvalue = gvalue % 10000;
            printf ("%s ", ones [gvalue - 1]);
        }
        else {printf ("");
    }
    j++;
    getch ();
}
----------------------------------------

int main () {
    cout << "Enter the number:";
    cin >> input;
    nFake = input;
    buffer = 0;
    while (nFake) {
        part[buffer] = nFake % 1000;
        nFake /= 1000;
        buffer++;
    }
    if (buffer == 0) {
        cout << "Zero.";
    }
    else if (buffer == 1) {
        convert (part [0]);
    }
    else if (buffer == 2) {
        convert (part [1]);
        cout << " thousand,";
        convert (part [0]);
    }
    else {
        convert (part [2]);
        cout << " million,";
        if (part[1]) {
            convert (part [1]);
            cout << " thousand,";
        }
        else {
            cout << "";
        }
        convert (part [0]);
    }
    system ("pause");
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12305512_12305956_1_31
12305512_12306260_4_46
Title: "Simple file copying different behavior on different file types" 
----------------------------------------

int main () {
    FILE *readf, *writef;
    unsigned char *buffer;
    unsigned long len;
    int i = 0;
    readf = fopen ("1.jpg", "rb");
    writef = fopen ("2.jpg", "wb");
    fseek (readf, 0, SEEK_END);
    len = ftell (readf);
    fseek (readf, 0, SEEK_SET);
    buffer = (char *) malloc (len);
    fread (buffer, fileLen, sizeof (unsigned char), readf);
    fwrite (buffer, fileLen, sizeof (unsigned char), writef);
    fclose (readf);
    fclose (writef);
    free (buffer);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    if (argc != 3) {
        printf ("usage: fileexer1 <read_pathname> <write_pathname>");
        exit (1);
    }
    FILE *file_read;
    FILE *file_write;
    char buffer [64 * 1024];
    size_t nbytes;
    file_read = fopen (argv[1], "rb");
    if (!file_read) {
        perror ("File cannot be opened for reading");
        exit (1);
    }
    file_write = fopen (argv[2], "wb");
    if (!file_write) {
        perror ("File cannot be opened for writing");
        exit (1);
    }
    while ((nbytes = fread (buffer, sizeof (buffer), sizeof (char), file_read)) != EOF) {
        if (fwrite (buffer, nbytes, sizeof (char), file_write) != nbytes) {
            perror ("Failed to write to file");
            exit (1);
        }
    }
    fclose (file_read);
    fclose (file_write);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12403895_12403976_1_13
12403895_12404195_14_27
Title: Some questions about global variables in multi-threaded programming 
----------------------------------------

int main () {
    int pid;
    pid = fork ();
    if (pid == 0) {
    }
    else if (pid > 0) {
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i;
    pthread_t threads [5];
    for (i = 0; i < 5; i++) {
        pthread_create (& threads [i], NULL, threadFunc, NULL);
    }
    for (i = 0; i < 5; i++) {
        pthread_join (threads [i], NULL);
    }
    pthrad_mutex_destroy (& mutex);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12412583_12412834_2_22
12412583_12412879_1_29
Title: How to generalize my code 
----------------------------------------

int main () {
    unsigned int arr [] = {0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00};
    int i, j;
    for (i = 0; i < 16; ++i) {
        unsigned char letter = arr[i];
        for (j = 0; j < 7; j++) {
            const char *str = "..";
            if (letter & 0x80)
                str = "AA";
            fputs (str, stdout);
            letter <<= 1;
        }
        putchar ('\n');
    }
}
----------------------------------------

int main () {
    unsigned int arr [] = {0x00, 0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0xc6, 0xc6, 0xc6, 0xc6, 0x00, 0x00, 0x00, 0x00};
    int i, k, j;
    int bin [8];
    for (i = 0; i < 16; ++i) {
        for (j = 0; j < 8; j++) {
            bin[j] = arr[j] >> (7 - i2);
        }
        for (k = 0; k < 8; k += 2) {
            if (bin[k] == 0 && bin[k + 1] == 0) {
                printf ("..");
                continue;
            }
            printf ("AA");
        }
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12417210_12417415_1_20
12417210_17713862_1_18
Title: How to convert unsigned char * to QString 
----------------------------------------

QString getStringFromUnsignedChar (unsigned char *str) {
    QString s;
    QString result = "";
    int rev = strlen (str);
    for (int i = 0; i < rev; i++) {
        s = QString ("%1").arg (str[i], 0, 16);
        if (s == "0") {
            s = "00";
        }
        result.append (s);
    }
    return result;
}
----------------------------------------

QString getStringFromUnsignedChar (unsigned char *str) {
    QString result = "";
    int lengthOfString = strlen (reinterpret_cast < const char * > (str));
    QString s;
    for (int i = 0; i < lengthOfString; i++) {
        s = QString ("%1").arg (str[i], 0, 16);
        if (s.length () == 1)
            result.append ("0");
        result.append (s);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12417210_12417415_1_20
12417210_24255190_1_18
Title: How to convert unsigned char * to QString 
----------------------------------------

QString getStringFromUnsignedChar (unsigned char *str) {
    QString s;
    QString result = "";
    int rev = strlen (str);
    for (int i = 0; i < rev; i++) {
        s = QString ("%1").arg (str[i], 0, 16);
        if (s == "0") {
            s = "00";
        }
        result.append (s);
    }
    return result;
}
----------------------------------------

QString getStringFromUnsignedChar (unsigned char *str, const int len) {
    QString result = "";
    int lengthOfString = len);
    QString s;
    for (int i = 0; i < lengthOfString; i++) {
        s = QString ("%1").arg (str[i], 0, 16);
        if (s.length () == 1)
            result.append ("0");
        result.append (s);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12439410_12439429_1_13
12439410_12439503_7_20
Title: floating point division in C 
----------------------------------------

int main (void) {
    float h, x, n;
    printf ("enter h > ");
    scanf ("%f", & h);
    getchar ();
    printf ("enter x > ");
    getchar ();
    scanf ("%f", & x);
    n = x / h;
    return 0;
}
----------------------------------------

int main () {
    double x, h, n;
    printf ("enter h> ");
    flush ();
    scanf ("%lf", & h);
    printf ("enter x> ");
    flush ();
    scanf ("%lf", & x);
    n = x / h;
    printf ("n: %lf\n", n);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12440238_18249979_3_19
12440238_36580261_5_17
Title: Program to read a 4-digit integer and output the sum of the digits 
----------------------------------------

main () {
    int n, rem;
    int sum = 0;
    printf ("enter a no.");
    scanf ("%d", & n);
    while (n != 0) {
        rem = n % 10;
        sum += rem;
        n = n / 10;
    }
    printf ("sum is=%d\n", sum);
}
----------------------------------------

main () {
    int num, a, b, c, d, result;
    printf ("enter four digit number for sum ");
    scanf ("%d", & num);
    a = num % 10;
    b = num % 100 / 10;
    c = num % 1000 / 100;
    d = num % 10000 / 1000;
    result = a + b + c + d;
    printf ("so\na=%d\nb=%d\nc=%d\nd=%d", a, b, c, d);
    printf ("\nresult is%d ", result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12440238_31916729_3_28
12440238_35434104_4_33
Title: Program to read a 4-digit integer and output the sum of the digits 
----------------------------------------

int main () {
    int num, sum = 0;
    printf ("Enter any number to find sum of its digit: ");
    scanf ("%d", & num);
    while (num != 0) {
        sum += num % 10;
        num = num / 10;
    }
    printf ("\nSum of digits = %d", sum);
    return 0;
}
----------------------------------------

int main () {
    int digit, dig1, dig2, dig3, dig4, digi, sum;
    printf ("Enter 4-Digit Number:\n");
    scanf ("%d", & digit);
    dig1 = (digit / 1000);
    printf ("Digit at 1000th place is: %d \n", dig1);
    dig2 = (digit - (dig1 * 1000)) / 100;
    printf ("Digit at 100th place is: %d \n", dig2);
    digi = ((digit / 100) * 100);
    dig3 = (digit - digi) / 10;
    printf ("Digit at 10th place is: %d \n", dig3);
    dig4 = ((digit - ((digit / 10) * 10)));
    printf ("Digit at unit place is: %d \n", dig4);
    sum = dig1 + dig2 + dig3 + dig4;
    printf ("Sum of digits in the number is: %d \n\n", sum);
    printf ("Isn't it Awesome ! A big hand of applaud for my technique !!! \n\n\n");
    system ("Pause");
    return 0;
}
----------------------------------------
