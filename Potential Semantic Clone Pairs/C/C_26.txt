$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30003379_30003548_4_25
30003379_30004189_4_17
Title: Extract integers from a string in C 
----------------------------------------

int main (int argc, char *argv []) {
    char temp [100];
    char op [4];
    char *buf = "add 56 89 29";
    int offset = 0;
    int used = 0;
    int rcount = 0;
    int lastno = -999;
    int currno;
    bzero (& temp, sizeof (temp));
    sscanf (buf, "%3s%n", op, & used);
    offset += used;
    if (!strcmp (op, "add")) {
        while ((sscanf (buf +offset, "%99s%n", temp, &used)) == 1) {
            currno = atoi (temp);
            offset += used;
            printf ("Current no: %d\tOffset: %d\n", currno, offset);
            lastno = currno;
        }
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *buf = "add 56 89 29";
    char *token;
    int count = 0;
    token = strtok (buf, " ");
    while (token != NULL) {
        count++;
        if (count == 1)
            continue;
        printf ("%s\n", token)
        token = strtok (NULL, " ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30003379_30003889_1_34
30003379_30004189_4_17
Title: Extract integers from a string in C 
----------------------------------------

int main (int argc, const char *argv []) {
    char *buf = "add 56 89 29";
    int sum = 0;
    if (!strncmp (buf, "add", 3)) {
        buf += 3;
        while (*buf != '\0') {
            if (isdigit (*buf) == 0) {
                ++buf;
                continue;
            }
            int digit;
            int num = 0;
            while (isdigit (*buf)) {
                digit = (int) *buf - 48;
                num = (num * 10) + digit;
                ++buf;
            }
            sum += num;
            printf ("Current no: %d\t Sum: %d\n", num, sum);
        }
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *buf = "add 56 89 29";
    char *token;
    int count = 0;
    token = strtok (buf, " ");
    while (token != NULL) {
        count++;
        if (count == 1)
            continue;
        printf ("%s\n", token)
        token = strtok (NULL, " ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30010171_38105054_89_100
30010171_45347493_89_100
Title: Implementing a fixed size queue of maximum size 5 using an array 
----------------------------------------

void display (struct queue q) {
    int i, index;
    if (q.count == 0)
        printf (" {}");
    else {
        for (index = q.front, i = 1; i <= q.count; i++, index++)
            printf (" %d", q.contents[index % 5]);
    }
}
----------------------------------------

void display (struct queue q) {
    int i, index;
    if (q.count == 0)
        printf (" {}");
    else {
        for (index = q.front, i = 1; i <= q.count; i++, index++)
            printf (" %d", q.contents[index % 5]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30018615_30019507_7_43
30018615_30019570_21_65
Title: getopt does not handle errors correctly 
----------------------------------------

int main (int argc, char *argv []) {
    int options [6] = {0};
    int args;
    while ((args = getopt (argc, argv, "ehs:")) != -1) {
        switch (args) {
        case 'e' :
            if (options[0] == 1)
                printf ("option 'e' can only be included once \n");
            else
                options[0] = 1;
            break;
        case 'h' :
            if (options[1] == 1)
                printf ("option 'h' can only be included once\n");
            else
                options[1] = 1;
            break;
        case 's' :
            if (options[2] == 2)
                printf ("option 's' can only be included once\n");
            else
                options[2] = 2;
            break;
        case '?' :
        default :
            printf ("unknown option encountered\n");
            break;
        }
    }
}
----------------------------------------

int main (int argc, char **argv) {
    Opt options = {{0}, 0, 0};
    int args;
    while ((args = getopt (argc, argv, "ehs:")) != -1) {
        switch (args) {
        case 'e' :
            if (options.opts[0] == 1)
                error_exit (USAGE_ERROR, "option multiple times");
            else
                options.opts[0] = 1;
            break;
        case 'h' :
            if (options.opts[1] == 1)
                error_exit (USAGE_ERROR, "option multiple times");
            else
                options.opts[1] = 1;
            break;
        case 's' :
            if (options.opts[2] == 2)
                error_exit (USAGE_ERROR, "option multiple times");
            else
                options.opts[2] = 2;
            char *saveptr;
            if ((options.word = strtok_r (optarg, ":", &saveptr)) == NULL)
                error_exit (USAGE_ERROR, "WORD MISSING");
            if ((options.tag = strtok_r (NULL, ":", &saveptr)) == NULL)
                error_exit (USAGE_ERROR, "TAG MISSING");
            char *temp = NULL;
            if ((temp = strtok_r (NULL, ":", &saveptr)))
                error_exit (USAGE_ERROR, "WORD and TAG already set!");
            break;
        case '?' :
        default :
            error_exit (USAGE_ERROR, "Unexpected option");
            break;
        }
    }
    printf ("e = %d, h = %d, s = %d\n", options.opts [0], options.opts [1], options.opts [2]);
    printf ("word = <<%s>>\n", options.word ? options.word : "NULL");
    printf ("tag  = <<%s>>\n", options.tag ? options.tag : "NULL");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30029113_30029147_1_12
30029113_30029217_1_11
Title: Please explain this output of the code 
----------------------------------------

int GetPositiveInt (void) {
    int n;
    do {
        printf ("Enter a positive number : ");
        scanf ("%d", & n);
    }
    while (n <= 0);
    return n;
}
----------------------------------------

int GetPositiveInt (void) {
    int n;
    do {
        printf ("Enter a positive number : ");
        scanf ("%d", & n);
    }
    while (n <= 0);
    return n;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30035254_30035567_2_24
30035254_30035906_5_22
Title: Using character for sentinel but receiving pointer error 
----------------------------------------

int main () {
    char ch = '0';
    int chcount;
    printf ("Enter your text, terminate with a #:");
    chcount = 0;
    int i = 0;
    while (ch != SENTINEL) {
        scanf ("%c", & ch);
        if ((ch >= 'A') && (ch <= 'Z')) {
            chcount = chcount + 1;
            printf ("You have entered %d characters", chcount);
            i++;
        }
    }
    return (0);
}
----------------------------------------

int main () {
    char ch;
    int chcount;
    printf ("Enter your text, terminate with a #:");
    chcount = 0;
    while ((ch = getchar ()) != SENTINEL) {
        if ((ch >= 'A') && (ch <= 'Z')) {
            chcount = chcount + 1;
            printf ("You have entered %d characters\n", chcount);
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30035254_30035567_2_24
30035254_30037010_5_39
Title: Using character for sentinel but receiving pointer error 
----------------------------------------

int main () {
    char ch = '0';
    int chcount;
    printf ("Enter your text, terminate with a #:");
    chcount = 0;
    int i = 0;
    while (ch != SENTINEL) {
        scanf ("%c", & ch);
        if ((ch >= 'A') && (ch <= 'Z')) {
            chcount = chcount + 1;
            printf ("You have entered %d characters", chcount);
            i++;
        }
    }
    return (0);
}
----------------------------------------

int main (void) {
    int sentinelFound = 0;
    char *line = NULL;
    size_t lineLen = 0;
    printf ("Enter your text, terminate with a #:");
    int chcount;
    getline (& line, & lineLen, stdin);
    size_t i;
    for (i = 0; i < lineLen; i++) {
        if (SENTINEL == line[i]) {
            sentinelFound = 1;
            break;
        }
        if ((line[i] >= 'A') && (line[i] <= 'Z')) {
            chcount = chcount + 1;
        }
    }
    free (line);
    if (!sentinelFound)
        printf ("You did not enter the sentinel character!");
    else
        printf ("You have entered %d capital characters\n", chcount);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30035254_30035906_5_22
30035254_30037010_5_39
Title: Using character for sentinel but receiving pointer error 
----------------------------------------

int main () {
    char ch;
    int chcount;
    printf ("Enter your text, terminate with a #:");
    chcount = 0;
    while ((ch = getchar ()) != SENTINEL) {
        if ((ch >= 'A') && (ch <= 'Z')) {
            chcount = chcount + 1;
            printf ("You have entered %d characters\n", chcount);
        }
    }
    return (0);
}
----------------------------------------

int main (void) {
    int sentinelFound = 0;
    char *line = NULL;
    size_t lineLen = 0;
    printf ("Enter your text, terminate with a #:");
    int chcount;
    getline (& line, & lineLen, stdin);
    size_t i;
    for (i = 0; i < lineLen; i++) {
        if (SENTINEL == line[i]) {
            sentinelFound = 1;
            break;
        }
        if ((line[i] >= 'A') && (line[i] <= 'Z')) {
            chcount = chcount + 1;
        }
    }
    free (line);
    if (!sentinelFound)
        printf ("You did not enter the sentinel character!");
    else
        printf ("You have entered %d capital characters\n", chcount);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30038093_30038545_14_26
30038093_30042371_29_41
Title: Reversing array logic in C not working properly 
----------------------------------------

int main () {
    char * string = read from file int len = strlen (string);
    rev (string, 0, len);
    for (int i = 0; i < len;) {
        int l = 0;
        int j = i;
        while (j < len && string[j] != ' ')
            ++j;
        rev (string, i, j - i);
        i = j + 1;
    }
}
----------------------------------------

int main (void) {
    FILE *fp = stdin;
    char toReverse [1000] = " ";
    char outputArray [1000];
    while (1 == fscanf (fp, "%998[^\n]%*c", &toReverse[1])) {
        proc_rev (toReverse, outputArray);
        puts (outputArray);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30039660_30041026_5_24
30039660_30080884_17_57
Title: Recursive function to convert string to integer in C 
----------------------------------------

int finalValue (const char *string1) {
    int i = 0;
    if (string1[i] != '\0') {
        if (string1[i] < '0' || string1[i] > '9') {
            if (dp == NULL && string1[i] == '.') {
                dp = string1;
                finalValue (& string1 [i + 1]);
            }
            else {
                printf ("Sorry, we can't convert this to an integer\n\n");
            }
            else {
            }
            else {
                num *= 10;
                num += string1[i] - '0';
                finalValue (& string1 [i + 1]);
            }
        }
        else if (dp) {dp_offset = string1 - dp;
    }
    return num;
}
----------------------------------------

double finalValue (char *string1) {
    int i = 0;
    if (string1[i] != '\0') {
        double newGuy = string1[i] - 48;
        if (flag == TRUE) {
            newGuy = newGuy * pow (10, (j) *-1);
            dec += newGuy;
            j++;
            finalValue (& string1 [i + 1]);
        }
        else {
            num *= 10;
            num += string1[i] - '0';
            if (string1[i + 1] == 46) {
                flag = TRUE;
                finalValue (& string1 [i + 2]);
            }
            finalValue (& string1 [i + 1]);
        }
    }
    else {
        final = num + dec;
        return final;
    }
    return final;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30064121_30064343_3_17
30064121_30064404_7_40
Title: Read numbers from text file to 2D array 
----------------------------------------

int main (int argc, char *argv []) {
    int i, j;
    int lines [18] [3];
    i = 0;
    while (i != sizeof (lines) / sizeof (lines[0]) && 3 == scanf ("%i %i %i", lines[i] + 0, lines[i] + 1, lines[i] + 2)) {
        i++;
    }
    for (j = 0; j != i; j++) {
        printf ("%i %i %i\n", lines [j] [0], lines [j] [1], lines [j] [2]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i = 0;
    int numlines = 0;
    char buf [MAXB] = {0};
    char lines [MAXL] [MAXD];
    FILE *fp = fopen ("inputs/control.txt", "r");
    if (fp == 0) {
        fprintf (stderr, "failed to open inputs/control.txt\n");
        return 1;
    }
    while (i < MAXL && fgets (buf, MAXB -1, fp)) {
        if (sscanf (buf, "%hhd %hhd %hhd", &lines[i][0], &lines[i][1], &lines[i][2]) == 3)
            i++;
    }
    fclose (fp);
    numlines = i;
    int j = 0;
    for (i = 0; i < numlines; i++)
        for (j = 0; j < MAXD; j++)
            printf (" line[%2d][%2d] : %hhd\n", i, j, lines[i][j]);
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3007422_3007686_1_44
3007422_3007886_1_17
Title: How to optimize this simple function which translates input bits into words? 
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    uint32 i, j, z = 0;
    for (i = 0; i < BufInLen; i++) {
        uint8 byte = pc_BufIn[i];
        for (j = 0; j < 2; ++j) {
            switch (byte & 0x0F) {
            case 0 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                break;
            case 1 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x81;
                break;
            case 2 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x7F;
                break;
            case 15 :
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                break;
            }
            byte >>= 1;
        }
    }
}
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    while (BufInLen--) {
        int16 tmp = *pc_BufIn++;
        *pw_BufOut++ = 0x007f + ((tmp >> 6) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 5) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 4) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 3) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 2) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 1) & 0x02);
        *pw_BufOut++ = 0x007f + (tmp & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp << 1) & 0x02);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3007422_3007686_1_44
3007422_3007890_2_18
Title: How to optimize this simple function which translates input bits into words? 
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    uint32 i, j, z = 0;
    for (i = 0; i < BufInLen; i++) {
        uint8 byte = pc_BufIn[i];
        for (j = 0; j < 2; ++j) {
            switch (byte & 0x0F) {
            case 0 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                break;
            case 1 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x81;
                break;
            case 2 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x7F;
                break;
            case 15 :
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                break;
            }
            byte >>= 1;
        }
    }
}
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    while (BufInLen--) {
        unsigned int tmp = *pc_BufIn++;
        *pw_BufOut++ = (tmp & 0x80) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x40) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x20) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x10) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x08) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x04) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x02) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x01) ? 0x0081 : 0x007f;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3007422_3007686_1_44
3007422_3008452_1_25
Title: How to optimize this simple function which translates input bits into words? 
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    uint32 i, j, z = 0;
    for (i = 0; i < BufInLen; i++) {
        uint8 byte = pc_BufIn[i];
        for (j = 0; j < 2; ++j) {
            switch (byte & 0x0F) {
            case 0 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                break;
            case 1 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x81;
                break;
            case 2 :
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x7F;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x7F;
                break;
            case 15 :
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                pw_BufOut[z++] = 0x81;
                break;
            }
            byte >>= 1;
        }
    }
}
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    int8 *end = pc_BufIn + BufInLen;
    while (end < pc_BufIn) {
        uint_fast8_t cur = *(pc_BufIn++);
        uint_fast8_t down = 8;
        do {
            *(pw_BufOut++) = 0x07f + ((mask & cur) << 1);
            cur >>= 1;
        }
        while (--down);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3007422_3007886_1_17
3007422_3007890_2_18
Title: How to optimize this simple function which translates input bits into words? 
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    while (BufInLen--) {
        int16 tmp = *pc_BufIn++;
        *pw_BufOut++ = 0x007f + ((tmp >> 6) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 5) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 4) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 3) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 2) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 1) & 0x02);
        *pw_BufOut++ = 0x007f + (tmp & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp << 1) & 0x02);
    }
}
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    while (BufInLen--) {
        unsigned int tmp = *pc_BufIn++;
        *pw_BufOut++ = (tmp & 0x80) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x40) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x20) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x10) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x08) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x04) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x02) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x01) ? 0x0081 : 0x007f;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3007422_3007886_1_17
3007422_3008452_1_25
Title: How to optimize this simple function which translates input bits into words? 
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    while (BufInLen--) {
        int16 tmp = *pc_BufIn++;
        *pw_BufOut++ = 0x007f + ((tmp >> 6) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 5) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 4) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 3) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 2) & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp >> 1) & 0x02);
        *pw_BufOut++ = 0x007f + (tmp & 0x02);
        *pw_BufOut++ = 0x007f + ((tmp << 1) & 0x02);
    }
}
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    int8 *end = pc_BufIn + BufInLen;
    while (end < pc_BufIn) {
        uint_fast8_t cur = *(pc_BufIn++);
        uint_fast8_t down = 8;
        do {
            *(pw_BufOut++) = 0x07f + ((mask & cur) << 1);
            cur >>= 1;
        }
        while (--down);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3007422_3007890_2_18
3007422_3008452_1_25
Title: How to optimize this simple function which translates input bits into words? 
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    while (BufInLen--) {
        unsigned int tmp = *pc_BufIn++;
        *pw_BufOut++ = (tmp & 0x80) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x40) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x20) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x10) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x08) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x04) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x02) ? 0x0081 : 0x007f;
        *pw_BufOut++ = (tmp & 0x01) ? 0x0081 : 0x007f;
    }
}
----------------------------------------

void inline BitsToWords (int8 *pc_BufIn, int16 *pw_BufOut, int32 BufInLen) {
    int8 *end = pc_BufIn + BufInLen;
    while (end < pc_BufIn) {
        uint_fast8_t cur = *(pc_BufIn++);
        uint_fast8_t down = 8;
        do {
            *(pw_BufOut++) = 0x07f + ((mask & cur) << 1);
            cur >>= 1;
        }
        while (--down);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30077782_30077952_1_11
30077782_30080516_11_25
Title: C - return pointer to an array 
----------------------------------------

int *greater (int n [], int length, int value) {
    for (int i = 0; i < length; i++)
        if (n[i] > value) {
            v[k] = n[i];
            k++;
        }
    int *p = v;
    return p;
}
----------------------------------------

int *greater (int n [], int length, int value) {
    qsort (n, sizeof * n, length, cmp);
    while (0 < length) {
        --length;
        if (n[length] > value) {
            break;
        }
    }
    return n + length + 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30077782_30077952_1_11
30077782_30081926_4_46
Title: C - return pointer to an array 
----------------------------------------

int *greater (int n [], int length, int value) {
    for (int i = 0; i < length; i++)
        if (n[i] > value) {
            v[k] = n[i];
            k++;
        }
    int *p = v;
    return p;
}
----------------------------------------

int *greater (const int const n [], const size_t n_elem, const int threshold, size_t *n_greater) {
    size_t i = 0;
    size_t n_found = 0;
    size_t n_allocated = 0;
    int *ret = NULL;
    for (i = 0; i < n_elem; i += 1) {
        if (n[i] > threshold) {
            n_found += 1;
            if (n_found > n_allocated) {
                size_t new_size = (n_allocated < (n_elem / 2)) ? 2 * n_found : n_elem;
                int *tmp = realloc (ret, new_size * sizeof (*tmp));
                if (!tmp) {
                    fputs ("Failed to allocate memory", stderr);
                    exit (EXIT_FAILURE);
                }
                n_allocated = new_size;
                ret = tmp;
            }
            ret[n_found - 1] = n[i];
        }
    }
    if (n_allocated > n_found) {
        int *tmp = realloc (ret, n_found * sizeof (*tmp));
        if (!tmp) {
            fputs ("Failed to shrink result array", stderr);
            exit (EXIT_FAILURE);
        }
        ret = tmp;
    }
    *n_greater = n_found;
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30077782_30080516_11_25
30077782_30081926_4_46
Title: C - return pointer to an array 
----------------------------------------

int *greater (int n [], int length, int value) {
    qsort (n, sizeof * n, length, cmp);
    while (0 < length) {
        --length;
        if (n[length] > value) {
            break;
        }
    }
    return n + length + 1;
}
----------------------------------------

int *greater (const int const n [], const size_t n_elem, const int threshold, size_t *n_greater) {
    size_t i = 0;
    size_t n_found = 0;
    size_t n_allocated = 0;
    int *ret = NULL;
    for (i = 0; i < n_elem; i += 1) {
        if (n[i] > threshold) {
            n_found += 1;
            if (n_found > n_allocated) {
                size_t new_size = (n_allocated < (n_elem / 2)) ? 2 * n_found : n_elem;
                int *tmp = realloc (ret, new_size * sizeof (*tmp));
                if (!tmp) {
                    fputs ("Failed to allocate memory", stderr);
                    exit (EXIT_FAILURE);
                }
                n_allocated = new_size;
                ret = tmp;
            }
            ret[n_found - 1] = n[i];
        }
    }
    if (n_allocated > n_found) {
        int *tmp = realloc (ret, n_found * sizeof (*tmp));
        if (!tmp) {
            fputs ("Failed to shrink result array", stderr);
            exit (EXIT_FAILURE);
        }
        ret = tmp;
    }
    *n_greater = n_found;
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30086644_30087074_1_16
30086644_30087578_5_20
Title: Getting the element of a 2D array in c? 
----------------------------------------

void multiply (int **res, int **mat1, int **mat2, int size) {
    int i, j, k;
    for (i = 0; i < size; i++)
        for (j = 0; j < size; j++) {
            res[i][j] = 0;
            for (k = 0; k < size; k++)
                res[i][j] += mat1[i][k] * mat2[k][j];
            printf ("sumElement: %d\n", res [i] [j]);
        }
}
----------------------------------------

struct _2dimensarrayofSIZE multiply (int (*pmat1) [SIZE] [SIZE], int (*pmat2) [SIZE] [SIZE]) {
    struct _2dimensarrayofSIZE res;
    int i, j, k;
    for (i = 0; i < size; i++) {
        for (j = 0; j < size; j++) {
            int sumElement = 0;
            for (k = 0; k < size; k++) {
                sumElement += (*pmat1)[i][k] * (*pmat2)[k][j];
            }
            res.d[i][j] = sumElement;
            printf ("sumElement: %d\n", sumElement);
        }
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3009042_3009145_1_17
3009042_5976619_1_25
Title: How to view printf output in a Win32 application on Visual Studio 2010? 
----------------------------------------

void SetStdOutToNewConsole () {
    int hConHandle;
    long lStdHandle;
    FILE *fp;
    AllocConsole ();
    lStdHandle = (long) GetStdHandle (STD_OUTPUT_HANDLE);
    hConHandle = _open_osfhandle (lStdHandle, _O_TEXT);
    fp = _fdopen (hConHandle, "w");
    *stdout = *fp;
    setvbuf (stdout, NULL, _IONBF, 0);
}
----------------------------------------

void SetStdOutToNewConsole () {
    AllocConsole ();
    HANDLE consoleHandle = GetStdHandle (STD_OUTPUT_HANDLE);
    int fileDescriptor = _open_osfhandle ((intptr_t) consoleHandle, _O_TEXT);
    FILE *fp = _fdopen (fileDescriptor, "w");
    *stdout = *fp;
    setvbuf (stdout, NULL, _IONBF, 0);
    SetConsoleTitle (L "Debug Output");
    CONSOLE_SCREEN_BUFFER_INFO csbi;
    if (GetConsoleScreenBufferInfo (consoleHandle, &csbi)) {
        COORD bufferSize;
        bufferSize.X = csbi.dwSize.X;
        bufferSize.Y = 9999;
        SetConsoleScreenBufferSize (consoleHandle, bufferSize);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30125877_30125943_1_18
30125877_30126547_7_21
Title: where is the error in the code of string reverse.c programming? 
----------------------------------------

int main (void) {
    size_t size = strlen (A);
    char *pA;
    char *pB;
    pA = A;
    pB = (B + size);
    puts (A);
    *pB-- = '\0';
    while (*pA != '\0') {
        *pB-- = *pA++;
    }
    puts (B);
    return 0;
}
----------------------------------------

int main (void) {
    size_t size = strlen (A);
    char *pA = A;
    char *pB = B + size;
    puts (A);
    while ((* pA != '\0') * -- pB = * pA ++;
    puts (B);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30125877_30126002_5_21
30125877_30126547_7_21
Title: where is the error in the code of string reverse.c programming? 
----------------------------------------

int main () {
    int size = strlen (A);
    char *pA;
    char *pB;
    pA = A;
    pB = (B + size);
    puts (A);
    while (*pA != '\0') {
        *(--pB) = *pA++;
    }
    puts (B);
    return 0;
}
----------------------------------------

int main (void) {
    size_t size = strlen (A);
    char *pA = A;
    char *pB = B + size;
    puts (A);
    while ((* pA != '\0') * -- pB = * pA ++;
    puts (B);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30139191_30139224_3_29
30139191_30140500_5_34
Title: Isolate the odd numbers and even numbers 
----------------------------------------

int main () {
    const int n = 10;
    int array [n] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int odd [n / 2];
    int even [n / 2];
    int l = 0;
    int k = 0;
    for (int i = 0; i < n; i++) {
        if ((array[i] % 2) == 0) {
            even[l] = array[i];
            l++;
        }
        else {
            odd[k] = array[i];
            k++;
        }
    }
std :
    : cout << "Even Number: " << "\n";
    for (int i = 0; i < n / 2; i++) {
    std :
        : cout << even [i] << " ";
    }
std :
    : cout << "\nOdd Number: " << "\n";
    for (int i = 0; i < n / 2; i++) {
    std :
        : cout << odd [i] << " ";
    }
}
----------------------------------------

int main (void) {
    int num [BILMAX], i;
    printf ("insert 10 number and separated by space\n");
    for (i = 0; i < 10; i++) {
        scanf ("%d", & num [i]);
    }
    printf ("\n\nEven Number: \n");
    for (i = 0; i < 10; i++) {
        if (num[i] % 2 == 0)
            printf ("%d ", num[i]);
    }
    printf ("\n\nOdd Number: \n");
    for (i = 0; i < 10; i++) {
        if (num[i] % 2 != 0)
            printf ("%d ", num[i]);
    }
    getch ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30140934_30141100_16_28
30140934_30142257_1_15
Title: LTRIM function in C 
----------------------------------------

void ltrim (char *string) {
    int i = 0;
    while (string[0] == ' ') {
        i = 0;
        while (string[i]) {
            string[i] = string[i + 1];
            i++;
        }
    }
    printf ("inside function string is <%s>---length is %d\n", string, strlen (string));
}
----------------------------------------

void ltrim (char *src) {
    char *dst;
    for (dst = src; *src == ' '; src++) {
    }
    if (dst == src)
        return;
    while ((*dst++ = *src++)) {
    }
    return;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30170109_30170314_1_12
30170109_30170601_1_19
Title: Listing values from Linked list 
----------------------------------------

void insertEnd (ROW *row, int value) {
    if (*row == NULL) {
        printf ("Inserting %d\n", value);
        *row = (ROW) (malloc (sizeof (Element)));
        if (*row == NULL) {
            return;
        }
        else {
            (*row)->data = value;
            (**row).next = NULL;
        }
    }
}
----------------------------------------

void insertEnd (ROW *row, int value) {
    if (*row != NULL) {
        ROW *lastElement = (ROW) (malloc (sizeof (Element)));
        if (*lastElement == NULL) {
            return;
        }
        else {
            (*lastElement)->data = value;
            (**lastElement).next = NULL;
            (**row).next = lastElement;
        }
    }
    else {
        *row = (ROW) (malloc (sizeof (Element)));
        if (*row == NULL) {
            return;
        }
        else {(* row) -> data = value;
        (**row).next = NULL;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3018313_14733008_15_58
3018313_22120275_15_76
Title: Algorithm to convert RGB to HSV and HSV to RGB in range 0-255 for both 
----------------------------------------

RgbColor HsvToRgb (HsvColor hsv) {
    RgbColor rgb;
    unsigned char region, remainder, p, q, t;
    if (hsv.s == 0) {
        rgb.r = hsv.v;
        rgb.g = hsv.v;
        rgb.b = hsv.v;
        return rgb;
    }
    region = hsv.h / 43;
    remainder = (hsv.h - (region * 43)) * 6;
    p = (hsv.v * (255 - hsv.s)) >> 8;
    q = (hsv.v * (255 - ((hsv.s * remainder) >> 8))) >> 8;
    t = (hsv.v * (255 - ((hsv.s * (255 - remainder)) >> 8))) >> 8;
    switch (region) {
    case 0 :
        rgb.r = hsv.v;
        rgb.g = t;
        rgb.b = p;
        break;
    case 1 :
        rgb.r = q;
        rgb.g = hsv.v;
        rgb.b = p;
        break;
    case 2 :
        rgb.r = p;
        rgb.g = hsv.v;
        rgb.b = t;
        break;
    case 3 :
        rgb.r = p;
        rgb.g = q;
        rgb.b = hsv.v;
        break;
    case 4 :
        rgb.r = t;
        rgb.g = p;
        rgb.b = hsv.v;
        break;
    default :
        rgb.r = hsv.v;
        rgb.g = p;
        rgb.b = q;
        break;
    }
    return rgb;
}
----------------------------------------

RgbColor HsvToRgb (HsvColor hsv) {
    RgbColor rgb;
    unsigned char region, p, q, t;
    unsigned int h, s, v, remainder;
    if (hsv.s == 0) {
        rgb.r = hsv.v;
        rgb.g = hsv.v;
        rgb.b = hsv.v;
        return rgb;
    }
    h = hsv.h;
    s = hsv.s;
    v = hsv.v;
    region = h / 43;
    remainder = (h - (region * 43)) * 6;
    p = (v * (255 - s)) >> 8;
    q = (v * (255 - ((s * remainder) >> 8))) >> 8;
    t = (v * (255 - ((s * (255 - remainder)) >> 8))) >> 8;
    switch (region) {
    case 0 :
        rgb.r = v;
        rgb.g = t;
        rgb.b = p;
        break;
    case 1 :
        rgb.r = q;
        rgb.g = v;
        rgb.b = p;
        break;
    case 2 :
        rgb.r = p;
        rgb.g = v;
        rgb.b = t;
        break;
    case 3 :
        rgb.r = p;
        rgb.g = q;
        rgb.b = v;
        break;
    case 4 :
        rgb.r = t;
        rgb.g = p;
        rgb.b = v;
        break;
    default :
        rgb.r = v;
        rgb.g = p;
        rgb.b = q;
        break;
    }
    return rgb;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3018313_19400360_1_39
3018313_24319877_1_16
Title: Algorithm to convert RGB to HSV and HSV to RGB in range 0-255 for both 
----------------------------------------

float3 HSV2RGB (float3 _HSV) {
    _HSV.x = fmod (100.0 + _HSV.x, 1.0);
    float HueSlice = 6.0 * _HSV.x;
    float HueSliceInteger = floor (HueSlice);
    float HueSliceInterpolant = HueSlice - HueSliceInteger;
    float3 TempRGB = float3 (_HSV.z * (1.0 - _HSV.y), _HSV.z * (1.0 - _HSV.y * HueSliceInterpolant), _HSV.z * (1.0 - _HSV.y * (1.0 - HueSliceInterpolant)));
    float IsOddSlice = fmod (HueSliceInteger, 2.0);
    float ThreeSliceSelector = 0.5 * (HueSliceInteger - IsOddSlice);
    float3 ScrollingRGBForEvenSlices = float3 (_HSV.z, TempRGB.zx);
    float3 ScrollingRGBForOddSlices = float3 (TempRGB.y, _HSV.z, TempRGB.x);
    float3 ScrollingRGB = lerp (ScrollingRGBForEvenSlices, ScrollingRGBForOddSlices, IsOddSlice);
    float IsNotFirstSlice = saturate (ThreeSliceSelector);
    float IsNotSecondSlice = saturate (ThreeSliceSelector -1.0);
    return lerp (ScrollingRGB.xyz, lerp (ScrollingRGB.zxy, ScrollingRGB.yzx, IsNotSecondSlice), IsNotFirstSlice);
}
----------------------------------------

vec3 HSV2RGB (vec3 hsv) {
    hsv.x = mod (100.0 + hsv.x, 1.0);
    float HueSlice = 6.0 * hsv.x;
    float HueSliceInteger = floor (HueSlice);
    float HueSliceInterpolant = HueSlice - HueSliceInteger;
    vec3 TempRGB = vec3 (hsv.z * (1.0 - hsv.y), hsv.z * (1.0 - hsv.y * HueSliceInterpolant), hsv.z * (1.0 - hsv.y * (1.0 - HueSliceInterpolant)));
    float IsOddSlice = mod (HueSliceInteger, 2.0);
    float ThreeSliceSelector = 0.5 * (HueSliceInteger - IsOddSlice);
    vec3 ScrollingRGBForEvenSlices = vec3 (hsv.z, TempRGB.zx);
    vec3 ScrollingRGBForOddSlices = vec3 (TempRGB.y, hsv.z, TempRGB.x);
    vec3 ScrollingRGB = mix (ScrollingRGBForEvenSlices, ScrollingRGBForOddSlices, IsOddSlice);
    float IsNotFirstSlice = clamp (ThreeSliceSelector, 0.0, 1.0);
    float IsNotSecondSlice = clamp (ThreeSliceSelector -1.0, 0.0, 1.);
    return mix (ScrollingRGB.xyz, mix (ScrollingRGB.zxy, ScrollingRGB.yzx, IsNotSecondSlice), IsNotFirstSlice);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3018313_36209005_15_45
3018313_6930407_61_117
Title: Algorithm to convert RGB to HSV and HSV to RGB in range 0-255 for both 
----------------------------------------

rgb hsv2rgb (hsv HSV) {
    rgb RGB;
    double H = HSV.h, S = HSV.s, V = HSV.v, P, Q, T, fract;
    (H == 360.) ? (H = 0.) : (H /= 60.);
    fract = H - floor (H);
    P = V * (1.- S);
    Q = V * (1.- S * fract);
    T = V * (1.- S * (1.- fract));
    if (0.<= H && H < 1.)
        RGB = (rgb) {
        .r = V,
        .g = T,
        .b = P};
    else if (1.<= H && H < 2.)
        RGB = (rgb) {
        .r = Q,
        .g = V,
        .b = P};
    else if (2.<= H && H < 3.)
        RGB = (rgb) {
        .r = P,
        .g = V,
        .b = T};
    else if (3.<= H && H < 4.)
        RGB = (rgb) {
        .r = P,
        .g = Q,
        .b = V};
    else if (4.<= H && H < 5.)
        RGB = (rgb) {
        .r = T,
        .g = P,
        .b = V};
    else if (5.<= H && H < 6.)
        RGB = (rgb) {
        .r = V,
        .g = P,
        .b = Q};
    else
        RGB = (rgb) {
        .r = 0.,
        .g = 0.,
        .b = 0.};
    return RGB;
}
----------------------------------------

rgb hsv2rgb (hsv in) {
    double hh, p, q, t, ff;
    long i;
    rgb out;
    if (in.s <= 0.0) {
        out.r = in.v;
        out.g = in.v;
        out.b = in.v;
        return out;
    }
    hh = in.h;
    if (hh >= 360.0)
        hh = 0.0;
    hh /= 60.0;
    i = (long) hh;
    ff = hh - i;
    p = in.v * (1.0 - in.s);
    q = in.v * (1.0 - (in.s * ff));
    t = in.v * (1.0 - (in.s * (1.0 - ff)));
    switch (i) {
    case 0 :
        out.r = in.v;
        out.g = t;
        out.b = p;
        break;
    case 1 :
        out.r = q;
        out.g = in.v;
        out.b = p;
        break;
    case 2 :
        out.r = p;
        out.g = in.v;
        out.b = t;
        break;
    case 3 :
        out.r = p;
        out.g = q;
        out.b = in.v;
        break;
    case 4 :
        out.r = t;
        out.g = p;
        out.b = in.v;
        break;
    case 5 :
    default :
        out.r = in.v;
        out.g = p;
        out.b = q;
        break;
    }
    return out;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3020031_3020228_6_85
3020031_40570267_5_26
Title: K&R Exercise 1-21 - Mental incomprehension 
----------------------------------------

int main () {
    int col = 0, base_col = 0, entab = 0;
    int c = getchar ();
    while (c != EOF) {
        if (!entab) {
            if (c == ' ' || c == '\t') {
                entab = 1;
                base_col = col;
            }
            else
                putchar (c);
        }
        else {
            if (c == '\n') {
                entab = 0;
                putchar ('\n');
            }
            else if (c != ' ' && c != '\t') {
                entab = 0;
                while ((base_col + (N - base_col % N)) <= col) {
                    base_col += (N - base_col % N);
                    putchar ('\t');
                }
                while ((base_col + 1) <= col) {
                    base_col++;
                    putchar (' ');
                }
                putchar (c);
            }
        }
        if (c == '\t')
            col += (N - col % N);
        else if (c == '\n')
            col = 0;
        else
            col++;
        c = getchar ();
    }
    return 0;
}
----------------------------------------

int main (int arg, char *argv []) {
    int counter = 0, space_counter = 0, c;
    while ((c = getchar ()) != EOF) {
        ++counter;
        if (c == ' ' && ++space_counter && (counter % TS) == 0) {
            space_counter = 0;
            c = '\t';
        }
        else if (c == '\t') {
            counter = space_counter = 0;
        }
        else if (c != ' ') {
            while (space_counter--)
                putchar (' ');
            space_counter = 0;
            if (c == '\n')
                counter = 0;
        }
        else {
            continue;
        }
        putchar (c);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30233355_30233792_5_34
30233355_30234022_6_31
Title: Read Line By Line Until Integer is Found C 
----------------------------------------

int main (void) {
    FILE *fpin = fopen ("ipfile", "r");
    if (!fpin) {
        printf ("Error in ipfile opening\n");
        exit (- 1);
    }
    FILE *fpout = fopen ("opfile", "w");
    if (!fpout) {
        printf ("Error in opfile opening\n");
        exit (- 1);
    }
    char buff [1024] = {0};
    char str [1024] = {0};
    int num1 = 0, num2 = 0;
    while (fgets (buff, 1024, fpin) != NULL) {
        memset (str, 0, sizeof (str));
        if (sscanf (buff, "%[^0-9]%d %d", str, &num1, &num2) == 3)
            fprintf (fpout, "%s %d\n", str, (num1 + num2));
        else if (sscanf (buff, "%d %d", &num1, &num2) == 2)
            fprintf (fpout, "%d\n", (num1 + num2));
    }
    return 0;
}
----------------------------------------

int main (void) {
    char line [1000];
    while (fgets (line, sizeof line, stdin)) {
        char *ptr;
        size_t x = strcspn (line, "0123456789");
        if (line[x]) {
            errno = 0;
            int n1 = strtol (line +x, &ptr, 10);
            if (*ptr && !errno) {
                errno = 0;
                int n2 = strtol (ptr, &ptr, 10);
                if (*ptr && !errno) {
                    int n3 = n1 + n2;
                    printf ("%.*s%d\n", (int) x, line, n3);
                }
                else {
                    printf ("%s", line);
                }
            }
            else {
                printf ("%s", line);
            }
        }
        else {
            printf ("%s", line);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30234363_30234466_3_16
30234363_30234708_33_54
Title: how can i store an int array into string 
----------------------------------------

int main (void) {
    int a [5] = {5, 21, 456, 1, 3};
    char s [9] = {0};
    int n = 0;
    for (int i = 0; i < 5; i++) {
        n += sprintf (&s[n], "%d", a[i]);
    }
    printf ("\n char* s = %s\n\n", s);
    return 0;
}
----------------------------------------

int main (void) {
    int a [5] = {5, 21, 456, 1, 3};
    int string_max_size = 256;
    char *string_from_array = NULL;
    string_from_array = (char *) malloc (string_max_size);
    if (NULL == string_from_array) {
        printf ("Memory allocation failed. Exiting...");
        return 1;
    }
    memset (string_from_array, 0, string_max_size);
    get_me_a_string (a, 5, string_from_array, string_max_size);
    printf (string_from_array);
    free (string_from_array);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30234363_30234466_3_16
30234363_30234891_3_20
Title: how can i store an int array into string 
----------------------------------------

int main (void) {
    int a [5] = {5, 21, 456, 1, 3};
    char s [9] = {0};
    int n = 0;
    for (int i = 0; i < 5; i++) {
        n += sprintf (&s[n], "%d", a[i]);
    }
    printf ("\n char* s = %s\n\n", s);
    return 0;
}
----------------------------------------

int main (void) {
    int a [] = {5, 21, 456, 1, 3};
    const size_t N = sizeof (a) / sizeof (*a);
    char s [10];
    int n;
    for (size_t i = 0, j = 0; i < N && (n = snprintf (s +j, sizeof (s) - j, "%d", a[i])) > 0; i++) {
        j += n;
    }
    puts (s);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30234363_30234708_33_54
30234363_30234891_3_20
Title: how can i store an int array into string 
----------------------------------------

int main (void) {
    int a [5] = {5, 21, 456, 1, 3};
    int string_max_size = 256;
    char *string_from_array = NULL;
    string_from_array = (char *) malloc (string_max_size);
    if (NULL == string_from_array) {
        printf ("Memory allocation failed. Exiting...");
        return 1;
    }
    memset (string_from_array, 0, string_max_size);
    get_me_a_string (a, 5, string_from_array, string_max_size);
    printf (string_from_array);
    free (string_from_array);
    return 0;
}
----------------------------------------

int main (void) {
    int a [] = {5, 21, 456, 1, 3};
    const size_t N = sizeof (a) / sizeof (*a);
    char s [10];
    int n;
    for (size_t i = 0, j = 0; i < N && (n = snprintf (s +j, sizeof (s) - j, "%d", a[i])) > 0; i++) {
        j += n;
    }
    puts (s);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30242126_30244078_78_88
30242126_30244335_9_40
Title: print a list: 1 2 3 4 5 6 7 8 9 = 1 8 3 6 5 4 7 2 9 
----------------------------------------

int main () {
    Node *head = NULL, *rev;
    int i;
    for (i = 1; i < 10; i++)
        prepend (&head, i);
    print_list (head);
    rev = reverse_sll_evenpos (head);
    print_list (rev);
}
----------------------------------------

int main () {
    int i, length = 0;
    int max = 7;
    struct List *list = malloc (sizeof (struct List));
    struct List *head = list;
    for (i = 0; i < max; i++) {
        list->value = i;
        struct List *temp = malloc (sizeof (struct List));
        if (i < max - 1)
            list->next = temp;
        else
            list->next = NULL;
        list = temp;
    }
    list = head;
    while (list != NULL) {
        list = list->next;
        length++;
    }
    list = head;
    printListValue (list, length, 0);
    list = head;
    while (list != NULL) {
        printf ("%d\t", list -> value);
        list = list->next;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30253110_30254171_1_12
30253110_30254428_19_50
Title: Combinations of elements in an array 
----------------------------------------

void com (int *a, int *t, int len, int i) {
    if (i == len) {
        for (int k = 0; k < len; k++)
            printf ("%d ", t[k]);
        printf ("\n");
        return;
    }
    while (*a) {
        t[i] = *a;
        com (++ a, t, len, i + 1);
    }
}
----------------------------------------

void com (int *a, int *t, int len, int i) {
    int j, k;
    int comb = 1;
    if (len == 0) {
        comb = check (t);
        if (comb) {
            for (k = 0; k < 3; k++) {
                printf ("%d  ", t [k]);
            }
            printf ("\n");
        }
        return;
    }
    for (j = i; j <= 4 - len; j++) {
        t[3 - len] = a[j];
        com (a, t, len - 1, i + 1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30278017_30278433_14_25
30278017_30278782_16_33
Title: Graph representation with dynamic linked lists 
----------------------------------------

LIST_NODE *create_node (int dest) {
    LIST_NODE *nod;
    if (dest < 0)
        exit (0);
    nod = (LIST_NODE *) malloc (sizeof (LIST_NODE));
    if (nod == NULL) {
        printf ("Problems at memory allocation!");
        exit (0);
    }
    nod->dest = dest;
    nod->next = NULL;
    return (LIST_NODE *) nod;
}
----------------------------------------

struct AdjListNode *create_node (int dest) {
    struct AdjListNode *nod;
    nod = malloc (sizeof (struct AdjListNode));
    if (nod == NULL) {
        perror (" malloc failed");
        printf ("Problems at memory allocation!");
        exit (- 1);
    }
    nod->dest = dest;
    nod->next = NULL;
    return nod;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30278017_30278433_43_88
30278017_30278782_37_94
Title: Graph representation with dynamic linked lists 
----------------------------------------

int main () {
    int n;
    int i;
    int dest;
    dest = -1;
    char *c = (char *) (malloc (sizeof (char)));
    ADJACENCY_LIST *t;
    LIST_NODE *last_added;
    printf ("The number of nodes of the graph: ");
    scanf ("%d", & n);
    t = (ADJACENCY_LIST *) calloc (n, sizeof (ADJACENCY_LIST));
    for (i = 0; i < n; i++) {
        printf ("Specify the links of the node %d with the others:\n", i);
        int contor;
        contor = 0;
        do {
            LIST_NODE *nod;
            printf ("The link with node: ");
            scanf ("%d", & dest);
            if (dest >= 0) {
                nod = create_node (dest);
                if (contor == 0) {
                    t[i].head = (LIST_NODE *) nod;
                    last_added = nod;
                }
                else {
                    last_added->next = nod;
                    last_added = nod;
                }
            }
            printf ("Do you want to link any other node to %d?(D to add, anything else STOP\n)", i);
            fflush (stdin);
            *c = getchar ();
            contor++;
        }
        while (*c == 'D');
    }
    display_graph (t, n);
    return 0;
}
----------------------------------------

int main (void) {
    int n;
    int i;
    int dest = -1;
    printf ("The number of nodes of the graph: ");
    if (1 != scanf ("%d", &n)) {
        perror ("scanf for number of nodes failed");
        exit (- 1);
    }
    head = malloc (n * sizeof (struct AdjList *));
    if (NULL == head) {
        perror ("malloc failed for list of pointers to nodes");
        exit (- 1);
    }
    memset (head, 0x00, n * sizeof (struct AdjList *));
    for (i = 0; i < n; i++) {
        printf ("Enter Dest value for %d of %d:", i, n);
        if (1 != scanf ("%d", &dest)) {
            perror ("scanf for dest value failed");
            exit (- 1);
        }
        if (dest >= 0) {
            head[i] = create_node (dest);
        }
        else {
            printf ("Dest value must be >= 0\n");
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30291977_30292268_1_24
30291977_30305016_46_58
Title: Find Largest Prime Factor - Complexity of Code 
----------------------------------------

int main () {
    unsigned long long n, lar, fact, sqroot;
    cin >> n;
    lar = 0;
    while (n && n % 2 == 0) {
        lar = 2;
        n /= 2;
    }
    fact = 3;
    sqroot = sqrt (n);
    while (fact <= sqroot) {
        if (n % fact == 0) {
            lar = fact;
            do {
                n /= fact;
            }
            while (n % fact == 0);
            sqroot = sqrt (n);
        }
        fact += 2;
    }
    if (lar < n)
        lar = n;
    cout << lar << endl;
    return 0;
}
----------------------------------------

int main (void) {
    uint64 x, k;
    do {
        printf ("Input long int: ");
        if (scanf ("%llu", &x) < 1)
            break;
        printf ("Largest Prime Factor: %llu\n", lpf5 (x));
    }
    while (x != 0);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30293105_30293136_1_22
30293105_30293193_1_13
Title: Error in reversing string 
----------------------------------------

char *reverse (char *str) {
    char *end;
    char tmp;
    int i;
    end = str;
    if ((str == NULL) || (*str == '\0'))
        return str;
    while (*end != 0)
        ++end;
    --end;
    i = 0;
    while (str + i < end) {
        tmp = str[i];
        str[i++] = *end;
        *end-- = tmp;
    }
    return str;
}
----------------------------------------

char *reverse (char *str) {
    if (str && *str) {
        char *p = str;
        char *end = p + strlen (p) - 1;
        while (p < end) {
            char tmp = *p;
            *p++ = *end;
            *end-- = tmp;
        }
    }
    return str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30293105_30293136_1_22
30293105_30313962_14_25
Title: Error in reversing string 
----------------------------------------

char *reverse (char *str) {
    char *end;
    char tmp;
    int i;
    end = str;
    if ((str == NULL) || (*str == '\0'))
        return str;
    while (*end != 0)
        ++end;
    --end;
    i = 0;
    while (str + i < end) {
        tmp = str[i];
        str[i++] = *end;
        *end-- = tmp;
    }
    return str;
}
----------------------------------------

char *reverse (const char *s) {
    char *s_new = strdup (s);
    char *s_begptr = &s[0];
    char *s_endptr = &s[strlen (s) - 1];
    char *ptr = NULL;
    for (ptr = s_endptr; ptr >= s_begptr; ptr--, s_new++) {
        *s_new = *ptr;
    }
    *s_new = '\0';
    s_new -= strlen (s);
    return s_new;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30293105_30293193_1_13
30293105_30313962_14_25
Title: Error in reversing string 
----------------------------------------

char *reverse (char *str) {
    if (str && *str) {
        char *p = str;
        char *end = p + strlen (p) - 1;
        while (p < end) {
            char tmp = *p;
            *p++ = *end;
            *end-- = tmp;
        }
    }
    return str;
}
----------------------------------------

char *reverse (const char *s) {
    char *s_new = strdup (s);
    char *s_begptr = &s[0];
    char *s_endptr = &s[strlen (s) - 1];
    char *ptr = NULL;
    for (ptr = s_endptr; ptr >= s_begptr; ptr--, s_new++) {
        *s_new = *ptr;
    }
    *s_new = '\0';
    s_new -= strlen (s);
    return s_new;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294032_30294437_10_49
30294032_30294610_45_56
Title: How to confirm no whitespace or trailing data with scanf/sscanf? 
----------------------------------------

int main (void) {
    char str [10] = "QQQQQQQQQ";
    char chr = 'Z';
    int i1 = 77;
    int i2 = 88;
    int n1;
    int n2;
    int n3;
    char *line = 0;
    size_t linelen = 0;
    int length;
    while ((length = getline (&line, &linelen, stdin)) != -1) {
        printf ("Line: <<%.*s>>\n", length - 1, line);
        int rc = sscanf (line, "%9[a-z],%c,%n%d,%n%d%n", str, &chr, &n1, &i1, &n2, &i2, &n3);
        const char *tag = "success";
        if (rc <= 0)
            tag = "total failure";
        else if (rc < 4)
            tag = "partial failure";
        else if (rc > 4)
            tag = "WTF?";
        printf ("rc = %d: %s\n", rc, tag);
        printf ("n1 = %d [%c], n2 = %d [%c], n3 = %d [%c]\n", n1, line [n1], n2, line [n2], n3, line [n3]);
        if (!isdecint (line[n1]))
            printf ("Invalid char for n1\n");
        if (!isdecint (line[n2]))
            printf ("Invalid char for n2\n");
        if (line[n3] != '\n')
            printf ("Invalid char for n3\n");
        printf ("<<%s>>,<<%c>>,%d,%d\n", str, chr, i1, i2);
    }
    return 0;
}
----------------------------------------

int main () {
    char str1 [50];
    char str2 [50];
    char str3 [50];
    char str4 [50];
    testSccanf ("abc,  f  , 123    , 234  ", str1, str2, str3, str4);
    testSccanf ("abc,f,123,234", str1, str2, str3, str4);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30303545_30303698_12_23
30303545_30304792_3_14
Title: function address cast to char array 
----------------------------------------

int main (int argc, char **argv) {
    int i = 0;
    char fp_c [FPSZ];
    for (i = 0; i < FPSZ; ++i)
        fp_c[i] = (char) (((uintptr_t) &a) >> CHAR_BIT * i);
    for (i = 0; i < FPSZ; ++i)
        printf ("%hhx ", fp_c[FPSZ - i - 1]);
    puts ("");
    printf ("%p\n", a);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int i;
    _vfp fp = a;
    char *cp = &fp;
    for (i = 0; i < sizeof (fp); ++i) {
        printf ("%hhx ", cp [i]);
    }
    printf ("\n%p\n", (void *) a);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30304561_30306607_5_28
30304561_51197694_7_35
Title: Print each word in a separate line from an input string 
----------------------------------------

int main (void) {
    int c = 0;
    size_t n = 0;
    printf ("\n Enter a sentence.\n\n input: ");
    while (n < MAXC && (c = getchar ()) != EOF && c != '\n') {
        if (c == ' ')
            printf ("\n");
        else
            printf ("%c", c);
        n++;
    }
    printf ("\n");
    if (n == MAXC)
        while ((c = getchar ()) != '\n' && c != EOF)
            ;
    return 0;
}
----------------------------------------

int main () {
    int c, nl, nc, ns, nt;
    nl = nc = ns = nt = 0;
    int d, r, prevd, prevr;
    printf ("Enter which char to replace :: ");
    while ((d = getchar ()) != '\n' && (prevd = d))
        ;
    d = prevd;
    printf ("Enter word below \n");
    while ((c = getchar ()) != EOF) {
        ++nc;
        if (c == ' ')
            ++ns;
        if (c == '\n')
            ++nl;
        if (c == '\t')
            ++nt;
        if (c == d)
            putchar ('\n');
        else
            putchar (c);
    }
    printf ("total char=%2d, newline=%2d, space=%2d tabs=%2d\n", nc, nl, ns, nt);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30305890_30307797_1_17
30305890_30309001_1_15
Title: Building tree in Nim game 
----------------------------------------

struct Node *buildGameTree () {
    struct Node *cube = calloc (1, sizeof (struct Node));
    cube->numCubes = M;
    cube->left = NULL;
    cube->right = NULL;
    if (cube->numCubes >= 1) {
        cube->numCubes = cube->numCubes - 1;
        cube->left = buildGameTree ();
    }
    if (cube->numCubes >= M) {
        cube->numCubes = cube->numCubes - M;
        cube->right = buildGameTree ();
    }
    return (cube);
}
----------------------------------------

struct Node *buildGameTree (int ncubes) {
    struct Node *cube = calloc (1, sizeof (struct Node));
    cube->cubesRemaining = ncubes;
    if (cube->cubesRemaining >= 1) {
        cube->left = buildGameTree (ncubes -1);
        switchPlayer ();
    }
    if (cube->cubesRemaining >= M) {
        cube->right = buildGameTree (ncubes -M);
        switchPlayer ();
    }
    return (cube);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30375277_30375354_1_16
30375277_30375537_1_12
Title: C - Assignment makes integer from pointer without a cast 
----------------------------------------

int ft_replace (char const *s1) {
    int result;
    int i;
    result = -1;
    i = 0;
    for (; *s1 != '\0'; ++s1) {
        i++;
        if (*s1 == '-')
            result = i;
    }
    return (result);
}
----------------------------------------

int ft_replace (const char *s) {
    int pos = -1;
    const char *p = s;
    for (; *p != '\0'; ++p) {
        if (*p == '-')
            pos = p - s;
    }
    return pos;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30375277_30375354_1_16
30375277_30375591_1_13
Title: C - Assignment makes integer from pointer without a cast 
----------------------------------------

int ft_replace (char const *s1) {
    int result;
    int i;
    result = -1;
    i = 0;
    for (; *s1 != '\0'; ++s1) {
        i++;
        if (*s1 == '-')
            result = i;
    }
    return (result);
}
----------------------------------------

int ft_replace (char const *s1) {
    int result, i;
    result = 0;
    for (i = 0; s1[i] != '\0'; ++i) {
        if (s1[i] == '-')
            result = i + 1;
    }
    return (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30375277_30375537_1_12
30375277_30375591_1_13
Title: C - Assignment makes integer from pointer without a cast 
----------------------------------------

int ft_replace (const char *s) {
    int pos = -1;
    const char *p = s;
    for (; *p != '\0'; ++p) {
        if (*p == '-')
            pos = p - s;
    }
    return pos;
}
----------------------------------------

int ft_replace (char const *s1) {
    int result, i;
    result = 0;
    for (i = 0; s1[i] != '\0'; ++i) {
        if (s1[i] == '-')
            result = i + 1;
    }
    return (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3039513_17674145_46_69
3039513_3043668_42_54
Title: Type-safe generic data structures in plain-old C? 
----------------------------------------

int main (int argc, char **argv) {
    LIST_ELEMENT (mytype)
    el1;
    LIST_ELEMENT (mytype)
    el2;
    LIST_ELEMENT (mytype)
    *pEl;
    el1.value.a = 1;
    el1.value.b = 2;
    el2.value.a = 3;
    el2.value.b = 4;
    LINK_LIST_ELEMENT (mytype, & el1, & el2);
    TERMINATE_LIST_AT_ELEMENT (mytype, & el2);
    printf ("Testing.\n");
    SET_POINTER_TO_LIST_ELEMENT (mytype, pEl, & el1);
    if (pEl->value.a != 1)
        printf ("pEl->value.a != 1: %d.\n", pEl->value.a);
    ADVANCE_POINTER_TO_LIST_ELEMENT (mytype, pEl);
    if (pEl->value.a != 3)
        printf ("pEl->value.a != 3: %d.\n", pEl->value.a);
    ADVANCE_POINTER_TO_LIST_ELEMENT (mytype, pEl);
    if (pEl != NULL)
        printf ("pEl != NULL.\n");
    printf ("Done.\n");
    return 0;
}
----------------------------------------

int main (void) {
    struct ll_node *head = NULL;
    head = ll_unshift_value (head, int, 1);
    head = ll_unshift_value (head, int, 2);
    head = ll_unshift_value (head, int, 3);
    printf ("%i\n", ll_get_value (head, 0, int));
    printf ("%i\n", ll_get_value (head, 1, int));
    printf ("%i\n", ll_get_value (head, 2, int));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30402907_30403047_1_19
30402907_30403210_10_29
Title: Add ordered element recursively 
----------------------------------------

void inserord (Lint *li, int x, Lint *k) {
    if (*li == NULL) {
        return;
    }
    else if (((*li)->value) > x) {
        Lint New;
        New = (Lint) calloc (1, sizeof (Nodo));
        New->value = x;
        New->next = (*li);
        (*k)->next = New;
        return;
    }
    *k = *li;
    inserord (& ((* li) -> next), x, & (* k));
}
----------------------------------------

void inserord (struct Nodo **current, int x, struct Nodo **prev) {
    if ((*current == NULL) || !((*current)->value < x)) {
        struct Nodo *nodo = malloc (sizeof (struct Nodo));
        nodo->value = x;
        nodo->next = *current;
        if (*prev == *current)
            *current = nodo;
        else
            (*prev)->next = nodo;
        return;
    }
    prev = current;
    current = &(*current)->next;
    inserord (current, x, prev);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30404757_30404866_1_28
30404757_30405783_1_12
Title: Finding all capital letter combinations of random text 
----------------------------------------

void enumerate (String input) {
    int count = 0;
    for (int i = 0; i < input.length (); i++)
        if (!Character.isDigit (input.charAt (i))) {
            count++;
        }
    count = (int) Math.pow (2, count);
    int i = 0, digit = 0;
    while (count-- > 0) {
        String output = "";
        for (int j = input.length () - 1; j >= 0; j--) {
            char c = input.charAt (j);
            if (Character.isDigit (c))
                output = (char) c + output;
            else {
                output = (char) (((i & 1) == 1) ? c - 32 : c) + output;
                i = i >> 1;
            }
        }
        System.out.println (output);
        i = ++digit;
    }
}
----------------------------------------

void enumerate (char *str, int n) {
    printf ("%s\n", str);
    while (++n < strlen (str))
        if (str[n] > 96 && str[n] < 123) {
            char *tmp = calloc (strlen (str) +1, sizeof (char));
            strcpy (tmp, str);
            tmp[n] -= 32;
            enumerate (tmp, n);
        }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30414090_30414497_6_25
30414090_30414901_19_29
Title: Synchronizing pthreads using mutex in C 
----------------------------------------

void *term (int x) {
    float w;
    pthread_mutex_lock (& number_mutex);
    int mynumber = number++;
    pthread_mutex_unlock (& number_mutex);
    w = pow (x, mynumber) / factorial (mynumber);
    printf ("%d term of series with x: %d  is: %f\n", mynumber, x, w);
    pthread_mutex_lock (& result_mutex);
    result += w;
    pthread_mutex_unlock (& result_mutex);
    return (void *) 0;
}
----------------------------------------

void *term (void *value) {
    int x = *(int*) value;
    float w;
    pthread_mutex_lock (& lock);
    w = pow (x, number) / factorial (number);
    printf ("%d term of series with x: %d  is: %f\n", number, x, w);
    result[number] = w;
    number++;
    pthread_mutex_unlock (& lock);
    return NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30438159_30438394_5_44
30438159_30438850_1_25
Title: Return VLA and usage 
----------------------------------------

int create_matrix_2 (size_t rows, size_t cols, int (**a) [rows] [cols]) {
    int result = 0;
    if (NULL == a) {
        result = -1;
        errno = EINVAL;
    }
    else {
        (*a) = malloc (sizeof **a);
        if (NULL == (*a)) {
            result = -1;
        }
        else {
            for (size_t row = 0; row < rows; row++) {
                for (size_t col = 0; col < cols; col++) {
                    (**a)[row][col] = row * cols + col;
                }
            }
            for (size_t row = 0; row < rows; row++) {
                for (size_t col = 0; col < cols; col++) {
                    printf ("%d, ", (* * a) [row] [col]);
                }
                printf ("\n");
            }
        }
    }
    return result;
}
----------------------------------------

void create_matrix_2 (int rows, int cols, double (**array) [rows] [cols]) {
    double (*A) [cols] = malloc (sizeof (double [rows] [cols]));
    for (int row = 0; row < rows; row++) {
        for (int col = 0; col < cols; col++) {
            A[row][col] = row * cols + col;
        }
    }
    for (int row = 0; row < rows; row++) {
        for (int col = 0; col < cols; col++) {
            printf ("%lf, ", A [row] [col]);
        }
        printf ("\n");
    }
    *array = (void *) A;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30443199_30443534_11_29
30443199_30443547_55_76
Title: "Finding Min Max and Median for Survey program" 
----------------------------------------

int main (void) {
    int response [SIZE + 1];
    int count;
    for (count = 0; count <= SIZE; count++) {
        printf ("Please enter your rating for the Samsung Galaxy S5 %d\n", count);
        scanf ("%d", & response [count]);
    }
    for (count = 0; count <= SIZE; count++)
        printf ("%d\n", response[count]);
    mean (response);
    max (response);
    min (response);
    return 0;
}
----------------------------------------

int main (void) {
    int response [SIZE];
    int count;
    for (count = 0; count < SIZE; count++) {
        printf ("Please enter your rating for the Samsung Galaxy S5 %d\n", count + 1);
        scanf ("%d", & response [count]);
    }
    for (count = 0; count < SIZE; count++) {
        printf ("%d\n", response [count]);
    }
    get_mean (response);
    get_max (response);
    get_min (response);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30444226_30444434_1_13
30444226_30444518_12_35
Title: Brick-Breaker in C - incrementing rows of bricks issue 
----------------------------------------

void initBricks (GWindow window) {
    int row, col, x, y;
    for (y = 10, row = 0; row < ROWS; row++, y += 40)
        for (x = 2, col = 0; col < COLS; col++, x += 40) {
            GRect brick = newGRect (x, y, BRICK_W, BRICK_H);
            setFilled (brick, true);
            setColor (brick, "RED");
            add (window, brick);
        }
}
----------------------------------------

void initBricks (GWindow window) {
    int x_coord = 2;
    for (int i = 0; i < ROWS; i++) {
        int y_coord = 10;
        for (int j = 0; j < COLS; j++) {
            GRect brick = newGRect (x_coord, y_coord, BRICK_W, BRICK_H);
            setFilled (brick, true);
            setColor (brick, "RED");
            add (window, brick);
            x_coord += 40;
        }
        y_coord += 40;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30450567_30452452_9_59
30450567_30452460_10_77
Title: C - Print Specific Line From Text File 
----------------------------------------

int main () {
    FILE *infile;
    char inputWord1 [WORD_LEN_MAX], inputWord2 [WORD_LEN_MAX];
    char filename [WORD_LEN_MAX];
    char wordInText [WORD_LEN_MAX], line [LINE_LEN_MAX];
    char firsAppear [LINE_LEN_MAX];
    int word1Count, word2Count, lineCount, i;
    printf ("Enter the first word: ");
    gets (inputWord1);
    printf ("Enter the second word: ");
    gets (inputWord2);
    printf ("Enter the file name: ");
    gets (filename);
    infile = fopen (filename, "r");
    if (infile == NULL) {
        printf ("Error cannot open %s", filename);
        exit (1);
    }
    word1Count = 0;
    word2Count = 0;
    lineCount = 1;
    while (fgets (line, sizeof (line), infile) != NULL) {
        char *p = line;
        lineCount++;
        while (*p != '\0' && *p != '\n') {
            i = 0;
            while (*p != ' ' && *p != '\0' && *p != '\n') {
                wordInText[i++] = tolower (*p++);
            }
            if (*p == ' ') {
                p++;
            }
            wordInText[i] = '\0';
            if (!strcmp (wordInText, inputWord1)) {
                word1Count++;
                if (word1Count == 1) {
                    strncpy (firsAppear, line, sizeof (firsAppear));
                }
            }
            if (!strcmp (wordInText, inputWord2)) {
                word2Count++;
            }
        }
    }
    printf ("Word 1 appears %d times\n", word1Count);
    printf ("Word 2 appears %d times\n", word2Count);
    printf ("%s", firsAppear);
}
----------------------------------------

int main (void) {
    char inputWord1 [MAXW] = {0};
    char inputWord2 [MAXW] = {0};
    char filename [MAXW] = {0};
    char line [MAXL] = {0};
    char *token = NULL;
    char *delim = " ,.;\n";
    size_t word1Count = 0;
    size_t word2Count = 0;
    size_t lineCount = 0;
    size_t len = 0;
    FILE *infile = NULL;
    printf ("\nEnter the first word: ");
    fgets (inputWord1, MAXW, stdin);
    len = strlen (inputWord1);
    while (len > 0 && (inputWord1[len - 1] == '\n' || inputWord1[len - 1] == '\r'))
        inputWord1[--len] = 0;
    printf ("\nEnter the second word: ");
    fgets (inputWord2, MAXW, stdin);
    len = strlen (inputWord2);
    while (len > 0 && (inputWord2[len - 1] == '\n' || inputWord2[len - 1] == '\r'))
        inputWord2[--len] = 0;
    printf ("\nEnter the file name: ");
    fgets (filename, MAXW, stdin);
    len = strlen (filename);
    while (len > 0 && (filename[len - 1] == '\n' || filename[len - 1] == '\r'))
        filename[--len] = 0;
    infile = fopen (filename, "r");
    if (infile == NULL) {
        printf ("error: file open failed. '%s'\n", filename);
        exit (1);
    }
    printf ("\nThe lines processed are:\n\n");
    while (fgets (line, MAXL, infile) != NULL) {
        len = strlen (line);
        while (len > 0 && (line[len - 1] == '\n' || line[len - 1] == '\r'))
            line[--len] = 0;
        printf ("  %2zu  %s\n", lineCount, line);
        for (token = strtok (line, delim); token != NULL; token = strtok (NULL, delim)) {
            if (strcmp (token, inputWord1) == 0)
                word1Count++;
            if (strcmp (token, inputWord2) == 0)
                word2Count++;
        }
        lineCount++;
    }
    printf ("\nWord 1 appears %zu times\n", word1Count);
    printf ("Word 2 appears %zu times\n", word2Count);
    printf ("Number of lines: %zu\n\n", lineCount);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30466043_30466280_2_20
30466043_30466337_1_22
Title: How to save do...while status/progress in C? 
----------------------------------------

int main () {
    int x, max = 0, max2 = 0;
    printf ("Insert numbers:\n");
    do {
        scanf ("%d", & x);
        if (x > max) {
            max2 = max;
            max = x;
        }
        else if (x > max2) {
            max2 = x;
        }
    }
    while (x != 0);
    printf ("The second biggest number is %d.\n", max2);
    return 0;
}
----------------------------------------

int main () {
    int x, status = 0, bigger = 0, secondbigger = 0, Array [50];
    while (true) {
        scanf ("%d", & x)
        if (x == 0)
            break;
        Array[status] = x;
        status++;
    }
    for (i = 0; i < status - 1; i++) {
        if (Array[i] > bigger)
            bigger = Array[i];
    }
    for (i = 0; i < status - 1; i++) {
        if (Array[i] > secondbigger && Array[i] != bigger)
            secondbigger = Array[i];
    }
    printf ("The second biggest number is %d.\n", secondbigger);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30527860_30528148_1_29
30527860_30528187_1_22
Title: Transformation of C code to only use goto 
----------------------------------------

void BubbleSort (int a [], int array_size) {
    int i, j, temp;
    i = 0;
BEGINFOR :
    if (i >= (array_size - 1))
        goto ENDFOR;
    j = 0;
BEGININNERFOR :
    if (j >= array_size - 1 - i)
        goto ENDINNERFOR;
    if (a[j] > a[j + 1]) {
        temp = a[j + 1];
        a[j + 1] = a[j];
        a[j] = temp;
    }
    ++j;
    goto BEGININNERFOR;
ENDINNERFOR :
    ++i;
    goto BEGINFOR;
ENDFOR :
}
----------------------------------------

void BubbleSort (int a [], int array_size) {
    int i, j, temp;
    i = 0;
first_loop :
    j = 0;
second_loop :
    if (a[j] > a[j + 1]) {
        temp = a[j + 1];
        a[j + 1] = a[j];
        a[j] = temp;
    }
    j++;
    if (j < array_size - 1 - 1) {
        goto second_loop;
    }
    i++;
    if (i < array_size - 1) {
        goto first_loop;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30527860_30528187_1_22
30527860_30528261_1_26
Title: Transformation of C code to only use goto 
----------------------------------------

void BubbleSort (int a [], int array_size) {
    int i, j, temp;
    i = 0;
first_loop :
    j = 0;
second_loop :
    if (a[j] > a[j + 1]) {
        temp = a[j + 1];
        a[j + 1] = a[j];
        a[j] = temp;
    }
    j++;
    if (j < array_size - 1 - 1) {
        goto second_loop;
    }
    i++;
    if (i < array_size - 1) {
        goto first_loop;
    }
}
----------------------------------------

void BubbleSort (int a [], int array_size) {
    int i, j, temp;
    i = 0;
BEGINFOR :
    if (i >= (array_size - 1))
        goto ENDFOR;
    j = 0;
BEGININNERFOR :
    if (j >= array_size - 1 - i)
        goto ENDINNERFOR;
    if (a [j] <= a [j + 1]) goto ENDOFCOMPARISON temp = a [j + 1];
    a[j + 1] = a[j];
    a[j] = temp;
EDNOFCOMPARISON :
    ++j;
    goto BEGININNERFOR;
ENDINNERFOR :
    ++i;
    goto BEGINFOR;
ENDFOR :
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30529469_30532912_12_33
30529469_30533838_12_34
Title: Print all the unique elements of an array 
----------------------------------------

struct node *insert (struct node *n, int value) {
    if (n == NULL) {
        n = (struct node *) malloc (sizeof (struct node));
        n->data = value;
        n->left = NULL;
        n->right = NULL;
        printf ("inserted %d\n", value);
        return n;
    }
    else {
        if (value == n->data) {
            printf ("Duplicated Value %d\n", value);
            return n;
        }
        if ((n->data) > value) {
            n->left = insert (n->left, value);
        }
        else {
            n->right = insert (n->right, value);
        }
        return n;
    }
}
----------------------------------------

struct node *insert (struct node *n, int value) {
    if (n == NULL) {
        n = (struct node *) malloc (sizeof (struct node));
        n->data = value;
        n->left = NULL;
        n->right = NULL;
        printf ("%d ", value);
        return n;
    }
    else if (value == n->data)
        return n;
    else if ((n->data) > value)
        n->left = insert (n->left, value);
    else
        insert (n->right, value);
    return n;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30529469_30532912_12_33
30529469_30534326_12_34
Title: Print all the unique elements of an array 
----------------------------------------

struct node *insert (struct node *n, int value) {
    if (n == NULL) {
        n = (struct node *) malloc (sizeof (struct node));
        n->data = value;
        n->left = NULL;
        n->right = NULL;
        printf ("inserted %d\n", value);
        return n;
    }
    else {
        if (value == n->data) {
            printf ("Duplicated Value %d\n", value);
            return n;
        }
        if ((n->data) > value) {
            n->left = insert (n->left, value);
        }
        else {
            n->right = insert (n->right, value);
        }
        return n;
    }
}
----------------------------------------

struct node *insert (struct node *n, int value) {
    if (n == NULL) {
        n = (struct node *) malloc (sizeof (struct node));
        n->data = value;
        n->left = NULL;
        n->right = NULL;
        printf ("%d ", value);
        return n;
    }
    else if (value == n->data)
        return n;
    else if ((n->data) > value)
        n->left = insert (n->left, value);
    else
        insert (n->right, value);
    return n;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30540156_30685749_43_65
30540156_30761135_133_154
Title: trapping signals in a multithreaded environment 
----------------------------------------

int main (void) {
    pthread_t thread1, thread2, thread3;
    int segvindex1 = rand () % 5;
    int segvindex2 = rand () % 5;
    int segvindex3 = rand () % 5;
    struct sigaction sact;
    memset (& sact, 0, sizeof sact);
    sact.sa_sigaction = handler;
    sact.sa_flags = SA_SIGINFO;
    if (sigaction (SIGSEGV, &sact, NULL) < 0) {
        perror ("sigaction");
        return 1;
    }
    pthread_create (& thread1, NULL, & threadfunc, (void *) & segvindex1);
    pthread_create (& thread2, NULL, & threadfunc, (void *) & segvindex2);
    pthread_create (& thread3, NULL, & threadfunc, (void *) & segvindex3);
    pthread_join (thread1, NULL);
    pthread_join (thread2, NULL);
    pthread_join (thread3, NULL);
    return 0;
}
----------------------------------------

int main () {
    int k;
    struct sigdeath_notify_info death;
    daft_thread_accounting_info_init (& g_thread_accounting);
    register_signal_handlers ();
    for (k = 0; k < 200; ++k) {
        start_daft_thread (someone_please_fix_me, (void *) k);
    }
    while (read (g_thread_accounting.monitor_pipe[0], &death, sizeof (death)) == sizeof (death)) {
        struct daft_thread_t *info = find_thread_by_tid (death.tid);
        if (info == NULL) {
            fprintf (stderr, "*** thread_id %u not found\n", death.tid);
            continue;
        }
        fprintf (stderr, "Thread %u (%d) died of %d, restarting.\n", death.tid, (int) info -> start_routine_arg, death.signum);
        restart_daft_thread (info);
    }
    fprintf (stderr, "Shouldn't get here.\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30540607_30540925_3_52
30540607_30540964_7_33
Title: Win32/C: Convert line endings to DOS/Windows format 
----------------------------------------

enum LEStatus_e ConvertLineEndings (BYTE *inData, INT inLen, BYTE *outData, INT outLen, INT *bytesWritten) {
    INT sourceIndex = 0, destIndex;
    if (outLen < inLen)
        return LE_CHANGES_FAILED;
    while (sourceIndex < inLen) {
        if (inData[sourceIndex] == '\r') {
            if (sourceIndex < inLen - 1 && inData[sourceIndex + 1] == '\n') {
                memcpy (outData, inData, inLen);
                *bytesWritten = inLen;
                return LE_NO_CHANGES_NEEDED;
            }
            break;
        }
        if (inData[sourceIndex] == '\n')
            break;
        sourceIndex++;
    }
    memcpy (outData, inData, sourceIndex);
    if (sourceIndex == inLen)
        return LE_NO_CHANGES_NEEDED;
    destIndex = sourceIndex;
    while (sourceIndex < inLen) {
        switch (inData[sourceIndex]) {
        case '\n' :
        case '\r' :
            sourceIndex++;
            if (destIndex + 2 >= outLen)
                return LE_CHANGES_FAILED;
            outData[destIndex++] = '\r';
            outData[destIndex++] = '\n';
            break;
        default :
            outData[destIndex++] = inData[sourceIndex++];
        }
    }
    *bytesWritten = destIndex;
    return LE_CHANGES_SUCCEEDED;
}
----------------------------------------

enum lestatus ConvertLineEndings (char *indata, int inlen, char *outdata, int outlen) {
    int outpos = 0, inpos;
    enum lestatus it_changed = le_no_changes_needed;
    for (inpos = 0; inpos < inlen; inpos++) {
        if (outpos + 1 > outlen)
            return le_changes_failed;
        if (indata[inpos] != '\r' && indata[inpos] != '\n') {
            outdata[outpos++] = indata[inpos];
        }
        else if (outpos + 2 > outlen) {
            return le_changes_failed;
        }
        else if ((indata[inpos + 1] == '\r' || indata[inpos + 1] == '\n') && indata[inpos] != indata[inpos + 1]) {
            outdata[outpos++] = '\r';
            outdata[outpos++] = '\n';
            inpos++;
        }
        else {
            outdata[outpos++] = '\r';
            outdata[outpos++] = '\n';
            it_changed = le_changes_succeeded;
        }
    }
    return it_changed;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30548837_30551615_3_99
30548837_44456604_17_87
Title: Encode printing of alphabets in C 
----------------------------------------

int main () {
    char c;
    int n, y;
    scanf ("%c", & c);
    n = c;
    if (n >= 65 && n < 70) {
        int val;
        val = (((n - 65) + 1) * 2) + 64;
        printf ("%c\n", val);
    }
    else if (n >= 70 && n < 75) {
        int val = (n - 65 + 1);
        if ((val) % 3 != 0) {
            printf ("%c\n", (((val) % 3) * 5) + 64);
        }
        else
            printf ("#\n");
    }
    else if (n >= 75 && n < 80) {
        int val = (n - 65 + 1);
        if ((val) % 4 != 0) {
            printf ("%c\n", (((val) % 4) * 8) + 64);
        }
        else
            printf ("#\n");
    }
    else if (n >= 80 && n < 85) {
        int val = n - 65 + 1;
        if (val > 16) {
            val = val - 26;
            printf ("%c", val + 10 + 64);
        }
        else
            printf ("%c\n", (val + 10) + 64);
    }
    if (n >= 85 && n < 91) {
        int d, b = 0, m;
        int val = n - 65 + 1;
        d = large (val);
        y = (d * 12);
        while (b < y) {
            b = b + 26;
        }
        b = b - 26;
        m = y - b;
        printf ("%c\n", m + 64);
    }
    return 0;
}
----------------------------------------

int main () {
    char c;
    scanf ("%c", & c);
    if ((int) c >= 65 && (int) c <= 69) {
        c = (((int) c - 64) * 2) + 64;
    }
    else if ((int) c >= 70 && (int) c <= 74) {
        c = (((int) c - 64) % 3) * 5;
        if (c == 0)
            c = '#';
        else
            c = (int) c + 64;
    }
    else if ((int) c >= 75 && (int) c <= 79) {
        c = (((int) c - 64) % 4) * 8;
        if (c == 0)
            c = '#';
        else
            c = (int) c + 64;
    }
    else if ((int) c >= 80 && (int) c <= 84) {
        c = c + 10;
        if (c > 90)
            c = c - 26;
    }
    else if ((int) c >= 85 && (int) c <= 90) {
        int z;
        c = c - 64;
        z = maxFac (c);
        c = z;
        c = (z * 12) % 26 + 64;
        if (c == '@')
            c = c + 26;
    }
    printf ("%c", c);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30552870_30553050_4_18
30552870_30553100_5_49
Title: "c/c++ hackerrank my code is working but im getting 038/10 points(dunno why) code works" 
----------------------------------------

int main () {
    const char *itself [] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "even", "odd"};
    int a, b;
    scanf ("%d %d", & a, & b);
    for (int n = a; n <= b; ++n) {
        if (1 <= n && n <= 9)
            puts (itself[n]);
        else if (9 < n)
            puts (itself[10 + (n & 1)]);
    }
    return 0;
}
----------------------------------------

int main () {
    int a, b, n;
    cin >> a;
    cin >> b;
    for (n = a; n <= b; n++) {
        if (n == 1) {
            printf ("one\n");
        }
        else if (n == 2) {
            printf ("two\n");
        }
        else if (n == 3) {
            printf ("three\n");
        }
        else if (n == 4) {
            printf ("four\n");
        }
        else if (n == 5) {
            printf ("five\n");
        }
        else if (n == 6) {
            printf ("six\n");
        }
        else if (n == 7) {
            printf ("seven\n");
        }
        else if (n == 8) {
            printf ("eight\n");
        }
        else if (n == 9) {
            printf ("nine\n");
        }
        if (n > 9) {
            if (n % 2 == 0) {
                printf ("even\n");
            }
            else {
                printf ("odd\n");
            }
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30554060_30554379_31_46
30554060_30554476_27_47
Title: search and sorting in c program? 
----------------------------------------

void bobsort (int num, int *array) {
    int c, d, swap;
    for (c = 0; c < num - 1; c++) {
        for (d = 0; d < num - c - 1; d++) {
            if (array[d] > array[d + 1]) {
                swap = array[d];
                array[d] = array[d + 1];
                array[d + 1] = swap;
            }
        }
    }
    printf ("Sorted list in ascending order:\n");
    for (c = 0; c < num; c++)
        printf ("%d\n", array[c]);
}
----------------------------------------

void bobsort (int *array, int n) {
    int c, d, swap;
    c = d = swap = 0;
    for (c = 0; c < n; c++) {
        for (d = 0; d < n - 1; d++) {
            if (array[d] > array[d + 1]) {
                swap = array[d + 1];
                array[d + 1] = array[d];
                array[d] = swap;
            }
        }
    }
    printf ("\nSorted list in ascending order:\n\n");
    for (c = 0; c < n; c++)
        printf ("%d\n", array[c]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30554060_30554379_49_73
30554060_30554476_50_75
Title: search and sorting in c program? 
----------------------------------------

void searchi (int num, int *array) {
    int c, first, last, middle, search;
    printf ("Enter value to find\n");
    scanf ("%d", & search);
    first = 0;
    last = num - 1;
    middle = (first + last) / 2;
    while (first <= last) {
        if (array[middle] < search)
            first = middle + 1;
        else if (array[middle] == search) {
            printf ("%d found at location %d\n", search, middle + 1);
            break;
        }
        else
            last = middle - 1;
        middle = (first + last) / 2;
    }
    if (first > last)
        printf ("Not found! %d is not present in the list\n", search);
}
----------------------------------------

void searchi (int *array, int n) {
    int first, last, middle, search;
    first = last = middle = search = 0;
    printf (" enter value to find: ");
    scanf ("%d", & search);
    first = 0;
    last = n - 1;
    middle = (first + last) / 2;
    while (first <= last) {
        if (array[middle] < search)
            first = middle + 1;
        else if (array[middle] == search) {
            printf ("%d found at location %d.\n", search, middle + 1);
            break;
        }
        else
            last = middle - 1;
        middle = (first + last) / 2;
    }
    if (first > last)
        printf ("Not found! %d is not present in the list.\n", search);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30554060_30554379_8_28
30554060_30554476_6_24
Title: search and sorting in c program? 
----------------------------------------

int main () {
    int num, i;
    printf ("Enter Count Number\n");
    scanf ("%d", & num);
    int array [num];
    for (i = 1; i <= num; i++) {
        printf ("Enter Number %d\n", i);
        scanf ("%d", & array [i - 1]);
    }
    bobsort (num, array);
    searchi (num, array);
    return 0;
}
----------------------------------------

int main (void) {
    int num = 0, i = 0;
    int array [num];
    printf ("\n no. of array elements: ");
    scanf ("%d", & num);
    for (i = 0; i < num; i++) {
        printf (" enter array[%d] ", i);
        scanf ("%d", & array [i]);
    }
    bobsort (array, num);
    searchi (array, num);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30554292_30554571_19_39
30554292_30554937_87_106
Title: C uninitialized mutex works and initialized mutex fails? 
----------------------------------------

static char *getBuffer (struct allVars *allVars) {
    int lock_ok = pthread_mutex_lock (&allVars->outEvents.critical);
    if (lock_ok != 0)
        printf ("%s(): lock error %d (%s)\n", __func__, lock_ok, strerror (lock_ok));
    int out = allVars->outEvents.eventCount;
    int unlock_ok = pthread_mutex_unlock (&allVars->outEvents.critical);
    if (unlock_ok != 0)
        printf ("%s(): unlock error %d (%s)\n", __func__, unlock_ok, strerror (unlock_ok));
    await (& allVars -> inEvents, out + 1);
    char *str = malloc (128);
    strcpy (str, allVars -> buffer [out % allVars -> bufferSize]);
    advance (& allVars -> outEvents);
    return str;
}
----------------------------------------

char *getBuffer (struct allVars *allVars) {
    pthread_mutex_lock (& allVars -> outEvents.critical);
    int out = allVars->outEvents.eventCount;
    pthread_mutex_unlock (& allVars -> outEvents.critical);
    await (& allVars -> inEvents, out + 1);
    char *str = malloc (128);
    strcpy (str, allVars -> buffer [out % allVars -> bufferSize]);
    advance (& allVars -> outEvents);
    return str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30562016_30562156_2_33
30562016_30562208_2_19
Title: Removing Duplicate values and adding 0 on their place 
----------------------------------------

int main () {
    int a [100];
    int i, j, size, left;
    scanf ("%d", & size);
    for (i = 0; i < size; i++) {
        scanf ("%d", & a [i]);
    }
    left = size;
    for (i = 0; i < size && left > 1; i++) {
        if (a[i] == 0)
            continue;
        for (j = i + 1, left = 0; j < size; j++) {
            if (a[i] == a[j]) {
                a[j] = 0;
            }
            if (a[j] != 0)
                left++;
        }
    }
    for (i = 0; i < size; i++)
        printf ("%d\n", a[i]);
    return 0;
}
----------------------------------------

int main () {
    int a [100];
    int i, j, size;
    scanf ("%d", & size);
    for (i = 0; i < size; i++) {
        scanf ("%d", & a [i]);
        for (j = 0; j < i; j++) {
            if (a[j] == a[i]) {
                a[i] = 0;
                break;
            }
        }
    }
    for (i = 0; i < size; i++)
        printf ("%d\n", a[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30562016_30562156_2_33
30562016_30562261_3_24
Title: Removing Duplicate values and adding 0 on their place 
----------------------------------------

int main () {
    int a [100];
    int i, j, size, left;
    scanf ("%d", & size);
    for (i = 0; i < size; i++) {
        scanf ("%d", & a [i]);
    }
    left = size;
    for (i = 0; i < size && left > 1; i++) {
        if (a[i] == 0)
            continue;
        for (j = i + 1, left = 0; j < size; j++) {
            if (a[i] == a[j]) {
                a[j] = 0;
            }
            if (a[j] != 0)
                left++;
        }
    }
    for (i = 0; i < size; i++)
        printf ("%d\n", a[i]);
    return 0;
}
----------------------------------------

int main () {
    int a [100];
    int i, j, size;
    scanf ("%d", & size);
    for (i = 0; i < size; i++) {
        scanf ("%d", & a [i]);
    }
    for (i = 1; i < size; i++) {
        for (j = i - 1; j >= 0; j--) {
            if (a[i] == a[j]) {
                a[i] = 0;
                break;
            }
        }
    }
    for (i = 0; i < size; i++)
        printf ("%d ", a[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3056307_3056510_5_56
3056307_3056992_11_51
Title: How do I use mqueue in a c program on a Linux based system? 
----------------------------------------

int main (int argc, char *argv []) {
    mqd_t mq;
    struct mq_attr ma;
    int status = 0;
    int a = 5;
    int b = 0;
    printf ("a = %d, b = %d\n", a, b);
    ma.mq_flags = 0;
    ma.mq_maxmsg = 16;
    ma.mq_msgsize = sizeof (int);
    ma.mq_curmsgs = 0;
    mq = mq_open ("/test_queue", O_RDWR | O_CREAT, 0700, &ma);
    if (mq == -1) {
        printf ("Failed to create queue.\n");
        status = 1;
    }
    if (status == 0) {
        status = mq_send (mq, (char *) (&a), sizeof (int), 1);
    }
    if (status == 0) {
        status = mq_receive (mq, (char *) (&b), sizeof (int), NULL);
    }
    if ((status == 0) && (mq_close (mq) == -1)) {
        printf ("Error closing message queue.\n");
        status = 1;
    }
    if ((status == 0) && (mq_unlink ("test_queue") == -1)) {
        printf ("Error deleting message queue.\n");
        status = 1;
    }
    printf ("a = %d, b = %d\n", a, b);
    return status;
}
----------------------------------------

int main (int argc, char **argv) {
    mqd_t mq;
    struct mq_attr attr;
    char buffer [MAX_SIZE + 1];
    int must_stop = 0;
    attr.mq_flags = 0;
    attr.mq_maxmsg = 10;
    attr.mq_msgsize = MAX_SIZE;
    attr.mq_curmsgs = 0;
    mq = mq_open (QUEUE_NAME, O_CREAT | O_RDONLY, 0644, &attr);
    CHECK ((mqd_t) - 1 != mq);
    do {
        ssize_t bytes_read;
        bytes_read = mq_receive (mq, buffer, MAX_SIZE, NULL);
        CHECK (bytes_read >= 0);
        buffer[bytes_read] = '\0';
        if (!strncmp (buffer, MSG_STOP, strlen (MSG_STOP))) {
            must_stop = 1;
        }
        else {
            printf ("Received: %s\n", buffer);
        }
    }
    while (!must_stop);
    CHECK ((mqd_t) - 1 != mq_close (mq));
    CHECK ((mqd_t) - 1 != mq_unlink (QUEUE_NAME));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30564052_30570856_6_20
30564052_30589277_2_20
Title: Confused with making an input into an empty array. 
----------------------------------------

int main (void) {
    char array [2] [MAXSTRINGSIZE];
    int i;
    void *result;
    for (i = 0; i < 2; i++) {
        printf ("Input String %d: ", i);
        result = fgets (&array[i][0], MAXSTRINGSIZE, stdin);
        if (result == NULL)
            exit (1);
    }
    printf ("String 1: %s\nString 2: %s\n", & array [0] [0], & array [1] [0]);
    exit (0);
}
----------------------------------------

int main (void) {
    int flx = 0, fly = 0;
    char a, b [10] [100];
    while (1) {
        a = getchar ();
        if (a == EOF)
            exit (0);
        else if (a == '\n') {
            flx++;
            fly = 0;
        }
        else {
            b[flx][fly++] = a;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30568730_30569477_5_35
30568730_30570181_11_43
Title: How to use strstr() function to compare content in character arrays in C? 
----------------------------------------

int main () {
    char line [150] [80] = {0};
    char line2 [150] [80] = {0};
    int i = 0, b = 0;
    FILE *file1 = fopen ("file1.csv", "r");
    FILE *file2 = fopen ("file2.csv", "r");
    FILE *file3 = fopen ("file3.csv", "w");
    while (fscanf (file2, "%79[^\n]\n", line2[b]) != EOF) {
        while (fscanf (file1, "%79[^\n]\n", line[i]) != EOF) {
            if (strstr (line[i], line2[b])) {
                printf ("\nFound: %s", line2 [b]);
                fprintf (file3, "%s\n", line [i]);
                i++;
                break;
            }
            i++;
        }
        b++;
    }
    fclose (file1);
    fclose (file2);
    fclose (file3);
    return 0;
}
----------------------------------------

int main () {
    char line [150] = "";
    char line2 [150] [80] = {0};
    int b = 0;
    int filterCount = 0;
    FILE *file1 = fopen ("file1.csv", "r");
    CHECK_FILE_OPEN (file1, "file1.csv");
    FILE *file2 = fopen ("file2.csv", "r");
    CHECK_FILE_OPEN (file2, "file2.csv");
    FILE *file3 = fopen ("file3.csv", "w");
    CHECK_FILE_OPEN (file3, "file3.csv");
    while (fscanf (file2, "%79[^\n]\n", line2[b]) != EOF) {
        b++;
    }
    filterCount = b;
    while (fscanf (file1, "%79[^\n]\n", line) != EOF) {
        for (b = 0; b < filterCount; b++) {
            if (strstr (line, line2[b])) {
                fprintf (file3, "%s\n", line);
                break;
            }
        }
    }
    fclose (file1);
    fclose (file2);
    fclose (file3);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30568730_30569477_5_35
30568730_30597787_21_57
Title: How to use strstr() function to compare content in character arrays in C? 
----------------------------------------

int main () {
    char line [150] [80] = {0};
    char line2 [150] [80] = {0};
    int i = 0, b = 0;
    FILE *file1 = fopen ("file1.csv", "r");
    FILE *file2 = fopen ("file2.csv", "r");
    FILE *file3 = fopen ("file3.csv", "w");
    while (fscanf (file2, "%79[^\n]\n", line2[b]) != EOF) {
        while (fscanf (file1, "%79[^\n]\n", line[i]) != EOF) {
            if (strstr (line[i], line2[b])) {
                printf ("\nFound: %s", line2 [b]);
                fprintf (file3, "%s\n", line [i]);
                i++;
                break;
            }
            i++;
        }
        b++;
    }
    fclose (file1);
    fclose (file2);
    fclose (file3);
    return 0;
}
----------------------------------------

int main () {
    char line [150] [80];
    char line2 [150] [80];
    int i, j;
    FILE *file1 = fopen ("file1.csv", "r");
    FILE *file2 = fopen ("file2.csv", "r");
    FILE *file3 = fopen ("file3.csv", "w");
    char fileOne [100] = "file1.csv";
    int nolFileone = 0;
    nolFileone = numberOfLines (fileOne);
    char fileTwo [100] = "file2.csv";
    int nolFiletwo = 0;
    nolFiletwo = numberOfLines (fileTwo);
    for (i = 0; i < nolFileone; i++) {
        fscanf (file1, "%79[^\n]\n", line [i]);
        for (j = 0; j < nolFiletwo - 1; j++) {
            fscanf (file2, "%79[^\n]\n", line2 [j]);
            if (strstr (line[i], line2[j]))
                fprintf (file3, "%s\n", line[i]);
        }
    }
    fclose (file1);
    fclose (file2);
    fclose (file3);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30568730_30570181_11_43
30568730_30597787_21_57
Title: How to use strstr() function to compare content in character arrays in C? 
----------------------------------------

int main () {
    char line [150] = "";
    char line2 [150] [80] = {0};
    int b = 0;
    int filterCount = 0;
    FILE *file1 = fopen ("file1.csv", "r");
    CHECK_FILE_OPEN (file1, "file1.csv");
    FILE *file2 = fopen ("file2.csv", "r");
    CHECK_FILE_OPEN (file2, "file2.csv");
    FILE *file3 = fopen ("file3.csv", "w");
    CHECK_FILE_OPEN (file3, "file3.csv");
    while (fscanf (file2, "%79[^\n]\n", line2[b]) != EOF) {
        b++;
    }
    filterCount = b;
    while (fscanf (file1, "%79[^\n]\n", line) != EOF) {
        for (b = 0; b < filterCount; b++) {
            if (strstr (line, line2[b])) {
                fprintf (file3, "%s\n", line);
                break;
            }
        }
    }
    fclose (file1);
    fclose (file2);
    fclose (file3);
    return 0;
}
----------------------------------------

int main () {
    char line [150] [80];
    char line2 [150] [80];
    int i, j;
    FILE *file1 = fopen ("file1.csv", "r");
    FILE *file2 = fopen ("file2.csv", "r");
    FILE *file3 = fopen ("file3.csv", "w");
    char fileOne [100] = "file1.csv";
    int nolFileone = 0;
    nolFileone = numberOfLines (fileOne);
    char fileTwo [100] = "file2.csv";
    int nolFiletwo = 0;
    nolFiletwo = numberOfLines (fileTwo);
    for (i = 0; i < nolFileone; i++) {
        fscanf (file1, "%79[^\n]\n", line [i]);
        for (j = 0; j < nolFiletwo - 1; j++) {
            fscanf (file2, "%79[^\n]\n", line2 [j]);
            if (strstr (line[i], line2[j]))
                fprintf (file3, "%s\n", line[i]);
        }
    }
    fclose (file1);
    fclose (file2);
    fclose (file3);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30575619_30576167_14_44
30575619_30625519_9_35
Title: Algorithm to reflect octant of a square matrix all seven ways 
----------------------------------------

int main () {
    int n = 6;
    for (int i = 0; i < n / 2; ++i) {
        for (int j = i; j < n / 2; ++j) {
            v[i][n - j - 1] = v[i][j];
            v[j][n - i - 1] = v[i][j];
            v[j][i] = v[i][j];
            v[n - i - 1][j] = v[i][j];
            v[n - i - 1][n - j - 1] = v[i][j];
            v[n - j - 1][n - i - 1] = v[i][j];
            v[n - j - 1][i] = v[i][j];
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            cout << v[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
----------------------------------------

int main () {
    int d [10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n = 8;
    int *v [8] [8];
    int k = 0;
    for (int i = 0; i < n / 2; ++i) {
        for (int j = i; j < n / 2; ++j) {
            v[i][j] = &d[k];
            v[j][i] = &d[k];
            v[i][n - j - 1] = &d[k];
            v[j][n - i - 1] = &d[k];
            v[n - i - 1][j] = &d[k];
            v[n - j - 1][i] = &d[k];
            v[n - i - 1][n - j - 1] = &d[k];
            v[n - j - 1][n - i - 1] = &d[k];
            k++;
        }
    }
    showArray (v);
    cout << endl;
    d[2] = 44;
    showArray (v);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30576016_30576472_26_36
30576016_30576516_28_45
Title: Why am I getting an Segmentation fault in this implementation of binary search? 
----------------------------------------

int binarySearch (int key, int array [], int min, int max) {
    int midpoint = findMidpoint (min, max);
    if (array[midpoint] < key) {
        return binarySearch (key, array, midpoint +1, max);
    }
    else if (array[midpoint] > key) {
        return binarySearch (key, array, min, midpoint -1);
    }
    else {
        return array[midpoint];
    }
    return -1;
}
----------------------------------------

int binarySearch (int key, int array [], int min, int max) {
    if (min > max)
        return -1;
    else {
        int midpoint = findMidpoint (min, max);
        if (array[midpoint] < key)
            return binarySearch (key, array, midpoint +1, max);
        else if (array[midpoint] > key)
            return binarySearch (key, array, min, midpoint -1);
        else
            return midpoint;
    }
    return -1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30577716_30577770_4_33
30577716_30579081_4_27
Title: Find distinct numbers from an array in C 
----------------------------------------

int main () {
    int v [100], w [100], n, m = 0, i, j, distinct = 1;
    printf ("n= ");
    scanf ("%d", & n);
    for (i = 0; i < n; i++) {
        printf ("v[%d]= ", i);
        scanf ("%d", & v [i]);
    }
    distinct = 1;
    for (i = 0; i < n; i++) {
        for (j = 0; (j < m) && (distinct == 1); j++)
            if (v[i] == w[j])
                distinct = 0;
        if (distinct == 1) {
            w[m] = v[i];
            m++;
        }
    }
    printf ("the distinct elements are: ");
    for (i = 0; i < m; i++)
        printf ("%d\n", w[i]);
    return 0;
}
----------------------------------------

int main () {
    int v [100], w [100], n, i;
    bool check [1000001];
    printf ("n= ");
    scanf ("%d", & n);
    int j = 0;
    for (i = 0; i < n; i++) {
        printf ("v[%d]= ", i);
        scanf ("%d", & v [i]);
        if (!check[v[i]]) {
            check[v[i]] = true;
            w[j] = v[i];
            j++;
        }
    }
    printf ("the distinct elements are: \n");
    for (i = 0; i < j; i++)
        printf ("%d\n", w[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30590568_30590761_12_23
30590568_30590792_3_14
Title: "C passing 2D array to function printing results" 
----------------------------------------

void printArray (int *ptr) {
    int i, j;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++) {
            printf ("%d\t", * ptr ++);
        }
        printf ("\n");
    }
}
----------------------------------------

static void printArray (int *ptr, int nb_columns, int nb_lines) {
    int i, j;
    for (i = 0; i < nb_lines; i++) {
        for (j = 0; j < nb_columns; j++) {
            printf ("%d\t", * (ptr ++));
        }
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30644573_30645741_7_58
30644573_30646319_5_47
Title: Print the 5th letter of each word read from a text file 
----------------------------------------

int main () {
    char fname [30];
    char myCurLine [MAX_LINE + 1];
    char myCurWord [MAX_LINE + 1];
    int index, loop;
    FILE *fp;
    printf ("enter file name with path\n");
    gets (fname);
    fp = fopen (fname, "r");
    if (fp == 0)
        printf ("file doesnot exist\n");
    else {
        printf ("File read successfully\n");
        do {
            if (fgets (myCurLine, MAX_LINE, fp) != NULL) {
                index = 0;
                for (loop = 0; loop < MAX_LINE; loop++) {
                    myCurWord[index] = myCurLine[loop];
                    index++;
                    if ((myCurLine[loop] == ' ') || (myCurLine[loop] == '\n')) {
                        myCurWord[index] = '\0';
                        index = 0;
                        if (strlen (myCurWord) > 4) {
                            putchar (myCurWord [4]);
                        }
                        index = 0;
                        if (myCurLine[loop] == '\n')
                            break;
                    }
                }
            }
            if (feof (fp)) {
                break;
            }
        }
        while (1);
        fclose (fp);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char fname [30];
    char ch;
    int i = 0;
    FILE *fp;
    printf ("enter file name with path\n");
    fgets (fname, sizeof (fname), stdin);
    strtok (fname, "\n");
    fp = fopen (fname, "r");
    if (!fp) {
        printf ("file does not exist\n");
        return -1;
    }
    while (!feof (fp))
        for (i = 0; (ch = getc (fp)) != ' ' && ch != '\n'; i++)
            if (i == 4 && isalpha (ch)) {
                putc (ch, stdout);
                i = 0;
                break;
            }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30671040_30671576_1_20
30671040_30686642_45_90
Title: Tokenizer not working 
----------------------------------------

asmInstruction *tokenizeLine (char *charLine) {
    int words = countTokens (charLine);
    char *tokens;
    asmInstruction *instr = (asmInstruction *) malloc (sizeof (asmInstruction));
    instr->args = (char **) malloc ((words + 1) * sizeof (char *));
    int count = 0;
    tokens = strtok (charLine, " ,");
    while (tokens) {
        instr->args[count] = malloc (strlen (tokens) +1);
        strcpy (instr -> args [count ++], tokens);
        tokens = strtok (NULL, " ,");
    }
    instr->args[count] = NULL;
    return instr;
}
----------------------------------------

struct asmInstruction *tokenizeLine (char *charLine) {
    int words = countTokens (charLine);
    char *tokens = NULL;
    struct asmInstruction *instr = NULL;
    if (NULL == (instr = malloc (sizeof (struct asmInstruction)))) {
        perror ("malloc for struct asmInstruction failed");
        exit (EXIT_FAILURE);
    }
    instr->args = NULL;
    if (NULL == (instr->args = malloc (words * sizeof (char *)))) {
        perror ("malloc for array of char pointers failed:");
        exit (EXIT_FAILURE);
    }
    memset (instr -> args, '\0', words * sizeof (char *));
    int count = 0;
    tokens = strtok (charLine, " ,");
    while (tokens) {
        if (NULL == (instr->args[count] = malloc (strlen (tokens) +1))) {
            perror ("malloc for arg failed");
            exit (EXIT_FAILURE);
        }
        strcpy (instr -> args [count], tokens);
        ++count;
        tokens = strtok (NULL, " ,");
    }
    return instr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3068198_3069192_4_22
3068198_3073626_8_20
Title: How to read a multiple line input from command line in c or C++? 
----------------------------------------

int main (void) {
    char *line = NULL;
    size_t sz = 0;
    while (!feof (stdin)) {
        ssize_t ln = getline (&line, &sz, stdin);
        if (ln > 0) {
            int x, y;
            if (sscanf (line, "%d %d", &x, &y) == 2)
                printf ("x = %i, y = %i\n", x, y);
            else
                puts ("invalid input");
        }
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main (int argc, char *argv []) {
    string line;
    while (true) {
        getline (cin, line);
        if (line.empty ()) {
            break;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30685109_30687023_13_26
30685109_30687023_2_10
Title: Does C have any tools for doing string addition? 
----------------------------------------

char *concatf (const char *fmt, ... ) {
    va_list args;
    va_start (args, fmt);
    char *buf = NULL;
    int n = vsnprintf (NULL, 0, fmt, args);
    va_end (args);
    if (n >= 0) {
        va_start (args, fmt);
        buf = malloc (n +1);
        if (buf)
            vsnprintf (buf, n +1, fmt, args);
        va_end (args);
    }
    return buf;
}
----------------------------------------

char *concatf (const char *fmt, ... ) {
    va_list args;
    char *buf = NULL;
    va_start (args, fmt);
    int n = vasprintf (&buf, fmt, args);
    va_end (args);
    if (n < 0) {
        free (buf);
        buf = NULL;
    }
    return buf;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30685109_30687023_2_10
30685109_30687023_36_49
Title: Does C have any tools for doing string addition? 
----------------------------------------

char *concatf (const char *fmt, ... ) {
    va_list args;
    char *buf = NULL;
    va_start (args, fmt);
    int n = vasprintf (&buf, fmt, args);
    va_end (args);
    if (n < 0) {
        free (buf);
        buf = NULL;
    }
    return buf;
}
----------------------------------------

char *concatf (const char *fmt, ... ) {
    char *buf = NULL;
    va_list args;
    va_start (args, fmt);
    int n = _vscprintf (fmt, args);
    va_end (args);
    if (n >= 0) {
        va_start (args, fmt);
        buf = malloc (n +1);
        if (buf)
            _vsnprintf (buf, n +1, fmt, args);
        va_end (args);
    }
    return buf;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30691513_30691558_6_21
30691513_30691565_3_20
Title: Printing data from a single dimension of a multidimensional array in C 
----------------------------------------

int main (void) {
    int array [M] [N];
    int i, j;
    i = 0;
    for (; i < N; i++) {
        printf ("Reading %d number in the first dimension.\n", i + 1);
        if (scanf ("%d", &array[0][i]) != 1)
            break;
    }
    printf ("\n");
    for (j = 0; j < i; j++) {
        printf ("%d\n", array [0] [j]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int array [5] [10];
    int i;
    for (i = 0; i < 10; i++) {
        printf ("Reading %d number in the first dimension.\n", i + 1);
        scanf ("%d", & array [0] [i]);
    }
    printf ("\n");
    int item;
    for (item = 0; item < 10; item++)
        printf ("%d\n", array[0][item]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30695064_30695105_1_11
30695064_30695208_23_36
Title: Checking if string is only letters and spaces 
----------------------------------------

int checkString (char str1 []) {
    int i, x = 0, p;
    p = strlen (str1);
    for (i = 0; i < p; i++)
        if ((str1[i] >= 'a' && str1[i] <= 'z') || (str1[i] >= 'A' && str1[i] <= 'Z') || (str1[i] == ' ') || (str1[i] >= '0' && str1[i] <= '9')) {
            continue;
        }
        else
            return 0;
    return 1;
}
----------------------------------------

int checkString (char str1 []) {
    int i, x = 0, p;
    p = strlen (str1);
    for (i = 0; i < p; i++) {
        if ((str1[i] >= 'a' && str1[i] <= 'z') || (str1[i] >= 'A' && str1[i] <= 'Z') || (str1[i] == ' ')) {
            continue;
        }
        else {
            return 0;
        }
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30695064_30695105_1_11
30695064_30702515_30_43
Title: Checking if string is only letters and spaces 
----------------------------------------

int checkString (char str1 []) {
    int i, x = 0, p;
    p = strlen (str1);
    for (i = 0; i < p; i++)
        if ((str1[i] >= 'a' && str1[i] <= 'z') || (str1[i] >= 'A' && str1[i] <= 'Z') || (str1[i] == ' ') || (str1[i] >= '0' && str1[i] <= '9')) {
            continue;
        }
        else
            return 0;
    return 1;
}
----------------------------------------

int checkString (char str1 []) {
    char *p = str1;
    while (*p) {
        if (!isalpha (*p) && !isspace (*p)) {
            return 0;
        }
        p++;
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30695064_30695208_10_21
30695064_30702515_10_27
Title: Checking if string is only letters and spaces 
----------------------------------------

void main () {
    char str1 [N];
    int i = 0;
    while (1) {
        str1[i++] = getchar ();
        if (str1[i - 1] == '\n')
            break;
    }
    printf ("%d", checkString (str1));
    getch ();
}
----------------------------------------

void main () {
    int i = 0;
    int c;
    char str1 [N];
    memset (str1, 0, sizeof (str1));
    do {
        c = getchar ();
        str1[i++] = c;
    }
    while ((c != '\n') && (i < (N - 1)));
    str1[i - 1] = 0;
    printf ("Result: %s\n", checkString (str1) ? "letters and/or spaces only" : "other characters other than spaces and/or letters present");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30695064_30695208_23_36
30695064_30702515_30_43
Title: Checking if string is only letters and spaces 
----------------------------------------

int checkString (char str1 []) {
    int i, x = 0, p;
    p = strlen (str1);
    for (i = 0; i < p; i++) {
        if ((str1[i] >= 'a' && str1[i] <= 'z') || (str1[i] >= 'A' && str1[i] <= 'Z') || (str1[i] == ' ')) {
            continue;
        }
        else {
            return 0;
        }
    }
    return 1;
}
----------------------------------------

int checkString (char str1 []) {
    char *p = str1;
    while (*p) {
        if (!isalpha (*p) && !isspace (*p)) {
            return 0;
        }
        p++;
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30695191_30695264_3_16
30695191_30695344_3_14
Title: Just first alphabet is showing in the output.[char type] 
----------------------------------------

int main () {
    char name [100];
    char grades;
    int i;
    printf ("Name of the Student: ");
    scanf ("%s", & name);
    printf ("Name your Just entered is : %s", name);
    return 0;
}
----------------------------------------

int main () {
    char name [101];
    printf ("Name of the student:");
    if (scanf ("%100s", &name) == 1) {
        printf ("Name you just entered: %s\n", name);
        return 0;
    }
    else {
        printf ("Unable to read name of student\n";
        return -1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30707160_30707324_1_11
30707160_30707957_37_47
Title: Program crash while trying to print a bidimensional array 
----------------------------------------

void printarray (int array [COL] [ROW], int col, int row) {
    int i, j;
    for (i = 0; i < col; i++) {
        for (j = 0; j < row; j++) {
            printf ("%d", array [i] [j]);
        }
        printf ("\n");
    }
}
----------------------------------------

void printarray (int array [COL] [ROW], int col, int row) {
    int i, j;
    for (i = 0; i <= col; i++) {
        for (j = 0; j <= row; j++) {
            printf ("%d", array [i] [j]);
        }
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30738807_30738892_1_11
30738807_30738980_1_13
Title: block of code that won't work. fopen function and %d 
----------------------------------------

int main (void) {
    char filename [100];
    for (j = 0; j < 10; j++) {
        sprintf (filename, "C:\\playlist%d.txt", j + 1);
        string = fopen (filename, "w+t");
        fclose (string);
    }
    return 0;
}
----------------------------------------

int main () {
std :
    : string filename = "C:\\playlist";
std :
    : fstream file;
    for (int i = 0; i < 10; i++) {
        file.open (filename +to_string (i) + ".txt");
        file.close ();
    }
    cin.get ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30745397_30746329_3_17
30745397_30746628_7_44
Title: Exiting a while loop in C 
----------------------------------------

int main (void) {
    float celsius, fahrenheit;
    while (1) {
        printf ("Please input a temperature in Celsius (type 'stop' to stop): ");
        if (scanf ("%f", &celsius) != 1)
            break;
        fahrenheit = (1.8 * celsius) + 32;
        printf ("Temperature in Fahrenheit: %f\n", fahrenheit);
    }
    return (0);
}
----------------------------------------

int main (int argc, char **argv) {
    char buffer [BUFFER_SIZE];
    char *exitword = "stop";
    float celsius, fahrenheit;
    while (0x01) {
        memset (buffer, 0x00, BUFFER_SIZE);
        printf ("Please input a temperature in Celsius (type '%s' to stop): ", exitword);
        if (fgets (buffer, BUFFER_SIZE -0x01, stdin) == NULL) {
            fprintf (stderr, "Unable to read user input!\n");
            fprintf (stderr, "Please try again\n");
            continue;
        }
        if (strncmp (buffer, exitword, strlen (exitword)) == 0x00) {
            printf ("Good bye!\n");
            break;
        }
        if ((celsius = strtof (buffer, NULL)) == 0) {
            fprintf (stderr, "Unable to convert user input to floating point number\n");
            fprintf (stderr, "Please try again\n");
            continue;
        }
        fahrenheit = (1.8 * celsius) + 32;
        printf ("Temperature in Fahrenheit: %f\n", fahrenheit);
    }
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30745397_30746329_3_17
30745397_32885177_9_44
Title: Exiting a while loop in C 
----------------------------------------

int main (void) {
    float celsius, fahrenheit;
    while (1) {
        printf ("Please input a temperature in Celsius (type 'stop' to stop): ");
        if (scanf ("%f", &celsius) != 1)
            break;
        fahrenheit = (1.8 * celsius) + 32;
        printf ("Temperature in Fahrenheit: %f\n", fahrenheit);
    }
    return (0);
}
----------------------------------------

int main (int argc, char *argv []) {
    int celsius = 0;
    float fahrenheit;
    char stop [] = "stop";
    char checkForStop [10];
    int i;
    int array [10];
    while (true) {
        printf ("Please input a temperature in Celsius (type 'stop' to stop): ");
        gets (checkForStop);
        if (strcmp (stop, checkForStop) == 0) {
            break;
        }
        else {
            for (i = 0; i < 2; i++) {
                array[i] = checkForStop[i] - '0';
            }
            celsius = array[0] * 10 + array[1];
        }
        fahrenheit = (1.8 * celsius) + 32;
        ` enter code here ` printf ("Temperature in Fahrenheit: %f ", fahrenheit);
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30745397_30746628_7_44
30745397_32885177_9_44
Title: Exiting a while loop in C 
----------------------------------------

int main (int argc, char **argv) {
    char buffer [BUFFER_SIZE];
    char *exitword = "stop";
    float celsius, fahrenheit;
    while (0x01) {
        memset (buffer, 0x00, BUFFER_SIZE);
        printf ("Please input a temperature in Celsius (type '%s' to stop): ", exitword);
        if (fgets (buffer, BUFFER_SIZE -0x01, stdin) == NULL) {
            fprintf (stderr, "Unable to read user input!\n");
            fprintf (stderr, "Please try again\n");
            continue;
        }
        if (strncmp (buffer, exitword, strlen (exitword)) == 0x00) {
            printf ("Good bye!\n");
            break;
        }
        if ((celsius = strtof (buffer, NULL)) == 0) {
            fprintf (stderr, "Unable to convert user input to floating point number\n");
            fprintf (stderr, "Please try again\n");
            continue;
        }
        fahrenheit = (1.8 * celsius) + 32;
        printf ("Temperature in Fahrenheit: %f\n", fahrenheit);
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main (int argc, char *argv []) {
    int celsius = 0;
    float fahrenheit;
    char stop [] = "stop";
    char checkForStop [10];
    int i;
    int array [10];
    while (true) {
        printf ("Please input a temperature in Celsius (type 'stop' to stop): ");
        gets (checkForStop);
        if (strcmp (stop, checkForStop) == 0) {
            break;
        }
        else {
            for (i = 0; i < 2; i++) {
                array[i] = checkForStop[i] - '0';
            }
            celsius = array[0] * 10 + array[1];
        }
        fahrenheit = (1.8 * celsius) + 32;
        ` enter code here ` printf ("Temperature in Fahrenheit: %f ", fahrenheit);
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30764665_32673932_1_11
30764665_32687315_1_10
Title: Perfect Number Check 
----------------------------------------

boolean perfectNum (int currentNum) {
    int i, sum = 0;
    for (i = 1; i < currentNum; i++)
        if (perfectNum % i == 0)
            sum += i;
    if (sum == currentNum)
        return ture;
    return false;
}
----------------------------------------

boolean perfectNum (int currentNum) {
    int i, sum = 0;
    for (i = 1; i < currentNum; i++)
        if (perfectNum % i == 0)
            sum += i;
    if (sum == currentNum)
        return ture;
    return false;
}
----------------------------------------
