$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38629924_38643103_2_36
38629924_38643533_1_20
Title: Error while calculating sum of two matrices in c 
----------------------------------------

int main () {
    int m, n;
    printf ("enter the number of rows and columns for matrix ");
    scanf ("%i%i", & m, & n);
    int mat1 [m] [n];
    int mat2 [m] [n];
    int result [m] [n];
    int i, j;
    printf ("enter elements of matrix one :");
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            scanf ("%d", & mat1 [i] [j]);
        }
    }
    printf ("enter the elements of matrix two:");
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            scanf ("%d", & mat2 [i] [j]);
        }
    }
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            result[i][j] = mat1[i][j] + mat2[i][j];
        }
    }
    printf ("the sum of the matrices are");
    for (i = 0; i < m; i++) {
        for (j = 0; j < n; j++) {
            printf ("%d", result [i] [j]);
        }
    }
    return 0;
}
----------------------------------------

int main () {
    int a, b, c, d, e, f, m, n;
    printf ("enter the rows and columns of matrix ");
    scanf ("%i%i", & m, & n);
    int res [m] [n];
    int mat1 [m] [n];
    int mat2 [m] [n];
    mat_entry (m, n, mat1);
    mat_entry (m, n, mat2);
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            res[i][j] = (mat1[i][j] + mat2[i][j]);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38635601_38637208_13_25
38635601_38638734_54_65
Title: Efficient way to match two arrays 
----------------------------------------

int main (void) {
    const char *pins [] = {"d1", "d2", "d3", "d4", "d5", "o1", "o2", "o3", "o4"};
    const int pinsNumbers [] = {1, 2, 19, 4, 14, 6, 12, 15, 17};
    const char *key = "d3";
    const char **p = bsearch (&key, pins, sizeof (pins) / sizeof (*pins), sizeof (const char *), cmp);
    if (p)
        printf ("%d\n", pinsNumbers[p - pins]);
    return 0;
}
----------------------------------------

int main (void) {
    int num;
    unsigned char const inp [] = "d3";
    printf ("\f%s is ", inp);
    if (pin_to_num (&num, inp) == DECODE_OK) {
        printf ("%d\r\n", num);
    }
    else {
        printf ("err\r\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38647175_38647545_17_41
38647175_38649291_63_78
Title: Have I utilized pointers properly in the updateDate function? 
----------------------------------------

int main (void) {
    struct date *thisDay, *nextDay;
    thisDay = malloc (sizeof (struct date));
    printf ("Enter today's date (mm dd yyyy) : ");
    scanf ("%i%i%i", & thisDay -> month, & thisDay -> day, & thisDay -> year);
    nextDay = dateUpdate (thisDay);
    printf ("Tomorrow's date is %i/%i/%.2i.\n", nextDay -> month, nextDay -> day, nextDay -> year % 100);
    free (nextDay);
    free (thisDay);
    return 0;
}
----------------------------------------

int main (void) {
    void dateUpdate (struct date * ptr);
    struct date calendar;
    printf ("Enter a day's date (mm dd yyyy): ");
    scanf ("%i%i%i", & calendar.month, & calendar.day, & calendar.year);
    dateUpdate (& calendar);
    printf ("The next day's date is %i/%i/%.2i.\n", calendar.month, calendar.day, calendar.year % 100);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38647175_38647545_65_78
38647175_38649291_35_49
Title: Have I utilized pointers properly in the updateDate function? 
----------------------------------------

int numberOfDays (struct date *d) {
    int days;
    const int daysPerMonth [12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (isLeapYear (d) && d->month == 2) {
        days = 29;
    }
    else {
        days = daysPerMonth[d->month - 1];
    }
    return days;
}
----------------------------------------

int numberOfDays (struct date d) {
    bool isLeapYear (struct date d);
    int days;
    const int daysPerMonth [12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
    if (isLeapYear (d) && d.month == 2)
        days = 29;
    else
        days = daysPerMonth[d.month - 1];
    return days;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38650241_38650263_4_19
38650241_38650287_4_19
Title: C weird string output 
----------------------------------------

int main (void) {
    char first [20];
    char last [20];
    char full [40];
    printf ("Your first name? ");
    if (!fgets (first, sizeof (first), stdin))
        return 1;
    printf ("your last name? ");
    if (!fgets (last, sizeof (last), stdin))
        return 1;
    first[strlen (first) - 1] = '\0';
    snprintf (full, sizeof full, "%s %s", first, last);
    printf ("Your full name is: %s", full);
    return 0;
}
----------------------------------------

int main () {
    char first [20];
    char last [20];
    char full [40];
    printf ("Your first name?: ");
    fgets (first, sizeof (first), stdin);
    printf ("your last name?: ");
    fgets (last, sizeof (last), stdin);
    first[strlen (first) - 1] = '\0';
    strcpy (full, first);
    strcat (full, " ");
    strcat (full, last);
    printf ("Your full name is: %s", full);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38650991_38651505_1_21
38650991_38655294_1_17
Title: binary search tree indexing 
----------------------------------------

generic tree_get_at_index (tree_node *t, int index) {
    assert (index >= 0 && index <= tree_size (t));
    printf ("tree size: %d \n", tree_size (t));
    if (index == tree_size (t)) {
        return t->element;
    }
    else if (index <= tree_size (t->left)) {
        return tree_get_at_index (t->left, index);
    }
    else {
        return tree_get_at_index (t->right, index);
    }
}
----------------------------------------

generic tree_get_at_index (tree_node *t, int index) {
    assert (t);
    assert (index > 0);
    int leftCount = tree_size (t->left);
    if (index < leftCount) {
        return tree_get_at_index (t->left, index);
    }
    if (index == leftCount) {
        return t->element;
    }
    return tree_get_at_index (t->right, index -leftCount - 1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38659066_38659395_1_32
38659066_38659652_1_33
Title: Deleting a node at a given position in Linked List 
----------------------------------------

void delete (struct node **head_ref, int position) {
    int i = 1;
    if (*head_ref == NULL)
        return;
    struct node *temp = *head_ref;
    if (position == 0) {
        *head_ref = temp->next;
        free (temp);
        return;
    }
    struct node *tails = *head_ref;
    while (temp->next != NULL) {
        temp = temp->next;
        if (i == position) {
            tails->next = temp->next;
            free (temp);
            return;
        }
        tails = tails->next;
        i++;
    }
}
----------------------------------------

int delete (struct node **head, size_t position) {
    struct node *prev = NULL;
    size_t i = 0;
    while (i != position && *head != NULL) {
        prev = *head;
        head = &(*head)->next;
        ++i;
    }
    int success = *head != NULL;
    if (success) {
        struct node *tmp = *head;
        if (prev == NULL) {
            *head = (*head)->next;
        }
        else {
            prev->next = (*head)->next;
        }
        free (tmp);
    }
    return success;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38659270_38659392_1_15
38659270_38662872_1_25
Title: Optimized way for Finding prime numbers upto given value n 
----------------------------------------

int primeCheck (long long int k) {
    if (k <= 1 || k % 2 == 0) {
        return 0;
    }
    int sr = (int) sqrt (k);
    for (int j = 3; j <= sr; j += 2) {
        if (k % j == 0) {
            return 0;
        }
    }
    return 1;
}
----------------------------------------

int primeCheck (long long int n) {
    if (n <= 1) {
        return 0;
    }
    if (n <= 3) {
        return 1;
    }
    if (n % 2 == 0 || n % 3 == 0) {
        return 0;
    }
    int sr = (int) sqrt (n);
    for (int i = 5; i <= sr; i += 6) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return 0;
        }
    }
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38675046_38675314_4_17
38675046_38675688_67_86
Title: Split string by one of few delimiters? 
----------------------------------------

int main (void) {
    const char *string = "A > B";
    char lho [100];
    char op [3];
    char rho [100];
    if (sscanf (string, "%99[^=><]%2[=><]%99[^=><]", lho, op, rho) == 3) {
        fprintf (stdout, "left hand operand: %s\n", lho);
        fprintf (stdout, "operator: %s\n", op);
        fprintf (stdout, "right hand operand: %s\n", rho);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *source_str = "A <> B";
    char *left, *delim, *right;
    if (!split_string (source_str, &left, &delim, &right)) {
        printf ("invalid input\n");
    }
    else {
        printf ("left: \"%s\"\n", left);
        printf ("delim: \"%s\"\n", delim);
        printf ("right: \"%s\"\n", right);
        free (left);
        free (delim);
        free (right);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38682123_38682234_8_44
38682123_38682656_1_18
Title: Create variable numbers of string variables according to users's input(C language) 
----------------------------------------

int main (void) {
    int t;
    if (scanf ("%d", &t) != 1) {
        fputs ("read t error\n", stderr);
        return 1;
    }
    getchar ();
    char (*ptr) [STRING_MAX + 2] = malloc (t * sizeof (char [STRING_MAX + 2]));
    if (ptr == NULL) {
        perror ("malloc");
        return 1;
    }
    int i;
    for (i = 0; i < t; i++) {
        if (fgets (ptr[i], sizeof (ptr[i]), stdin) == NULL) {
            fprintf (stderr, "read ptr[%d] error\n", i);
            return 1;
        }
        char *lf;
        if ((lf = strchr (ptr[i], '\n')) != NULL)
            *lf = '\0';
    }
    for (i = 0; i < t; i++) {
        puts (ptr [i]);
    }
    free (ptr);
    return 0;
}
----------------------------------------

int main () {
    int t;
    scanf ("%d", & t);
    char **ptr = (char **) malloc (t * sizeof (char));
    int i, j;
    for (i = 0; i < t; i++) {
        scanf ("%s", ptr [i]);
    }
    for (i = 0; i < t; i++) {
        puts (ptr [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38682123_38682234_8_44
38682123_38728897_7_38
Title: Create variable numbers of string variables according to users's input(C language) 
----------------------------------------

int main (void) {
    int t;
    if (scanf ("%d", &t) != 1) {
        fputs ("read t error\n", stderr);
        return 1;
    }
    getchar ();
    char (*ptr) [STRING_MAX + 2] = malloc (t * sizeof (char [STRING_MAX + 2]));
    if (ptr == NULL) {
        perror ("malloc");
        return 1;
    }
    int i;
    for (i = 0; i < t; i++) {
        if (fgets (ptr[i], sizeof (ptr[i]), stdin) == NULL) {
            fprintf (stderr, "read ptr[%d] error\n", i);
            return 1;
        }
        char *lf;
        if ((lf = strchr (ptr[i], '\n')) != NULL)
            *lf = '\0';
    }
    for (i = 0; i < t; i++) {
        puts (ptr [i]);
    }
    free (ptr);
    return 0;
}
----------------------------------------

int main (void) {
    int tot, i;
    char **strheads;
    if (scanf ("%d\n", &tot) < 1)
        return (1);
    strheads = malloc (tot * sizeof (char *));
    assert (strheads != NULL);
    for (i = 0; i < tot; i++) {
        strheads[i] = malloc (sizeof (char *) * MAX_LINE_LENGTH);
        assert (strheads [i] != NULL);
        (void) fgets (strheads[i], MAX_LINE_LENGTH, stdin);
    }
    (void) printf ("back at ya:\n");
    for (i = 0; i < tot; i++) {
        fputs (strheads [i], stdout);
        free (strheads [i]);
    }
    free (strheads);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38682123_38682656_1_18
38682123_38728897_7_38
Title: Create variable numbers of string variables according to users's input(C language) 
----------------------------------------

int main () {
    int t;
    scanf ("%d", & t);
    char **ptr = (char **) malloc (t * sizeof (char));
    int i, j;
    for (i = 0; i < t; i++) {
        scanf ("%s", ptr [i]);
    }
    for (i = 0; i < t; i++) {
        puts (ptr [i]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int tot, i;
    char **strheads;
    if (scanf ("%d\n", &tot) < 1)
        return (1);
    strheads = malloc (tot * sizeof (char *));
    assert (strheads != NULL);
    for (i = 0; i < tot; i++) {
        strheads[i] = malloc (sizeof (char *) * MAX_LINE_LENGTH);
        assert (strheads [i] != NULL);
        (void) fgets (strheads[i], MAX_LINE_LENGTH, stdin);
    }
    (void) printf ("back at ya:\n");
    for (i = 0; i < tot; i++) {
        fputs (strheads [i], stdout);
        free (strheads [i]);
    }
    free (strheads);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38686181_38735818_3_32
38686181_38737476_4_45
Title: Segmentation fault in C while trying to declare an array of strings. 
----------------------------------------

int main () {
    FILE *fp;
    int count;
    int i;
    fp = fopen ("fruits.txt", "w");
    if (fp == NULL) {
        printf ("Can't open file!!");
        exit (0);
    }
    fputs ("4 Apple Banana mango berry", fp);
    fclose (fp);
    * / fp = fopen ("fruits.txt", "r");
    if (fp == NULL) {
        printf ("Can't open file!!");
        exit (0);
    }
    fscanf (fp, "%d", & count);
    printf ("%d\n", count);
    fclose (fp);
    char *fruits [count];
    return 0;
}
----------------------------------------

int main (void) {
    int count, i;
    FILE *fp;
    if (!(fp = fopen ("fruits.txt", "w+"))) {
        fprintf (stderr, "error: file open failed 'fruits.txt'.\n");
        exit (EXIT_FAILURE);
    }
    fputs ("4 Apple Banana mango berry", fp);
    fclose (fp);
    if (!(fp = fopen ("fruits.txt", "r"))) {
        fprintf (stderr, "error: file open failed 'fruits.txt'.\n");
        exit (EXIT_FAILURE);
    }
    if (fscanf (fp, " %d", &count) != 1) {
        fprintf (stderr, "error: in read of value from 'fruits.txt'.\n");
        exit (EXIT_FAILURE);
    }
    printf ("\n Quantity read from 'fruits.txt' is '%d'.\n\n", count);
    char *fruits [count];
    for (i = 0; i < count; i++)
        if (fscanf (fp, " %ms", &fruits[i]) != 1) {
            fprintf (stderr, "error: read/allocation for fruits[%d] failed.\n", i);
            exit (EXIT_FAILURE);
        }
    fclose (fp);
    for (i = 0; i < count; i++)
        printf (" fruit[%d] : %s\n", i, fruits[i]);
    for (i = 0; i < count; i++)
        free (fruits[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38694073_38694900_4_32
38694073_38695314_5_17
Title: "Remove vowels from a character string Stack smashing error" 
----------------------------------------

int main () {
    char str [] = "my name is khan. and i am not a terrorist";
    char arr [80] = {0};
    char wolf [] = {'a', 'e', 'i', 'o', 'u', '\0'};
    int i, j, k, len, flag = 0;
    len = strlen (str);
    for (i = 0, j = 0; i < len; i++) {
        for (k = 0; k <= 4; k++) {
            if (wolf[k] == str[i]) {
                flag = 1;
                break;
            }
        }
        if (0 == flag) {
            arr[j] = str[i];
            j++;
        }
        flag = 0;
    }
    arr[j] = '\0';
    printf ("str:%s\n", str);
    printf ("arr:%s\n", arr);
    return 0;
}
----------------------------------------

int main () {
    char str [] = "my name is khan. and i am not a terrorist\n";
    char arr [80];
    char *wolf = "aeiouy";
    int i, j;
    for (i = j = 0; arr[j] = str[i]; i++) {
        if (!strchr (wolf, str[i]))
            j++;
    }
    printf ("%s\n", arr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38694073_38694900_4_32
38694073_38702283_4_25
Title: "Remove vowels from a character string Stack smashing error" 
----------------------------------------

int main () {
    char str [] = "my name is khan. and i am not a terrorist";
    char arr [80] = {0};
    char wolf [] = {'a', 'e', 'i', 'o', 'u', '\0'};
    int i, j, k, len, flag = 0;
    len = strlen (str);
    for (i = 0, j = 0; i < len; i++) {
        for (k = 0; k <= 4; k++) {
            if (wolf[k] == str[i]) {
                flag = 1;
                break;
            }
        }
        if (0 == flag) {
            arr[j] = str[i];
            j++;
        }
        flag = 0;
    }
    arr[j] = '\0';
    printf ("str:%s\n", str);
    printf ("arr:%s\n", arr);
    return 0;
}
----------------------------------------

int main () {
    char str [] = "my name is khan. and i am not a terrorist\n";
    char arr [80];
    char wolf [] = {'a', 'e', 'i', 'o', 'u', '\0'};
    int i, j, k, len;
    len = strlen (str);
    for (i = 0, j = 0; i < len; i++) {
        for (k = 0; k < 5; k++) {
            if (str[i] == wolf[k])
                break;
        }
        if (k == 5) {
            arr[j] = str[i];
            j++;
        }
    }
    arr[j] = '\0';
    printf ("result: %s\n", arr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38694073_38695314_5_17
38694073_38702283_4_25
Title: "Remove vowels from a character string Stack smashing error" 
----------------------------------------

int main () {
    char str [] = "my name is khan. and i am not a terrorist\n";
    char arr [80];
    char *wolf = "aeiouy";
    int i, j;
    for (i = j = 0; arr[j] = str[i]; i++) {
        if (!strchr (wolf, str[i]))
            j++;
    }
    printf ("%s\n", arr);
    return 0;
}
----------------------------------------

int main () {
    char str [] = "my name is khan. and i am not a terrorist\n";
    char arr [80];
    char wolf [] = {'a', 'e', 'i', 'o', 'u', '\0'};
    int i, j, k, len;
    len = strlen (str);
    for (i = 0, j = 0; i < len; i++) {
        for (k = 0; k < 5; k++) {
            if (str[i] == wolf[k])
                break;
        }
        if (k == 5) {
            arr[j] = str[i];
            j++;
        }
    }
    arr[j] = '\0';
    printf ("result: %s\n", arr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38696792_38697450_1_18
38696792_38697698_3_28
Title: Count the number of occurrences of each letter in a string 
----------------------------------------

void countChar (char *str) {
    int i, j, cnt = 1;
    int l;
    for (l = 0; str[l]; ++l)
        str[l] = tolower (str[l]);
    for (i = 0; i < l; i++) {
        if (!str[i])
            continue;
        for (j = i + 1; j < l; j++) {
            if (str[i] == str[j]) {
                cnt++;
                str[j] = 0;
            }
        }
        printf ("\n %c occurs : %d times", str [i], cnt);
        cnt = 1;
    }
}
----------------------------------------

void countChar (char *str) {
    char parsed [strlen (str)];
    int flag = 0;
    int i, j, cnt = 1, k = 0;
    int l = strlen (str);
    for (i = 0; i < l; i++) {
        for (j = 0; j <= k; j++) {
            if (str[i] == parsed[j]) {
                cnt = 1;
                flag = 1;
            }
        }
        if (flag == 1) {
            flag = 0;
            continue;
        }
        for (j = i + 1; j < l; j++) {
            if (str[i] == str[j])
                cnt++;
        }
        parsed[k++] = str[i];
        printf ("\n %c occurs : %d times", str [i], cnt);
        cnt = 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38696792_38697450_1_18
38696792_38697745_10_28
Title: Count the number of occurrences of each letter in a string 
----------------------------------------

void countChar (char *str) {
    int i, j, cnt = 1;
    int l;
    for (l = 0; str[l]; ++l)
        str[l] = tolower (str[l]);
    for (i = 0; i < l; i++) {
        if (!str[i])
            continue;
        for (j = i + 1; j < l; j++) {
            if (str[i] == str[j]) {
                cnt++;
                str[j] = 0;
            }
        }
        printf ("\n %c occurs : %d times", str [i], cnt);
        cnt = 1;
    }
}
----------------------------------------

void countChar (const char *str) {
    size_t i;
    int count = 1;
    char *sorted = strdup (str);
    size_t len = strlen (sorted);
    qsort (sorted, len, sizeof (char), cmp);
    for (i = 0; i < len; i++, count++) {
        if (sorted[i] != sorted[i + 1]) {
            printf ("%c occurs : %d times\n", sorted [i], count);
            count = 0;
        }
    }
    free (sorted);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38696792_38697698_3_28
38696792_38697745_10_28
Title: Count the number of occurrences of each letter in a string 
----------------------------------------

void countChar (char *str) {
    char parsed [strlen (str)];
    int flag = 0;
    int i, j, cnt = 1, k = 0;
    int l = strlen (str);
    for (i = 0; i < l; i++) {
        for (j = 0; j <= k; j++) {
            if (str[i] == parsed[j]) {
                cnt = 1;
                flag = 1;
            }
        }
        if (flag == 1) {
            flag = 0;
            continue;
        }
        for (j = i + 1; j < l; j++) {
            if (str[i] == str[j])
                cnt++;
        }
        parsed[k++] = str[i];
        printf ("\n %c occurs : %d times", str [i], cnt);
        cnt = 1;
    }
}
----------------------------------------

void countChar (const char *str) {
    size_t i;
    int count = 1;
    char *sorted = strdup (str);
    size_t len = strlen (sorted);
    qsort (sorted, len, sizeof (char), cmp);
    for (i = 0; i < len; i++, count++) {
        if (sorted[i] != sorted[i + 1]) {
            printf ("%c occurs : %d times\n", sorted [i], count);
            count = 0;
        }
    }
    free (sorted);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38697197_38697350_3_27
38697197_38699462_7_91
Title: Printing values of array in C 
----------------------------------------

int main (int argc, char *argv []) {
    char const * const fileName = argv[1];
    FILE *file = fopen (fileName, "r");
    char line [256];
    char i, cnt = 0;
    char str1 [MAX_LINE_CNT] [10], str3 [MAX_LINE_CNT] [10], *tmp;
    int arr2 [MAX_LINE_CNT], arr4 [MAX_LINE_CNT];
    while (fgets (line, sizeof (line), file)) {
        tmp = strstr (line, " -> ");
        arr2[cnt] = 0;
        arr4[cnt] = 0;
        sscanf (line, "%[^+ ]%x%*s", str1 [cnt], & arr2 [cnt]);
        sscanf (tmp, " -> %[^+ ]%x%*s", str3 [cnt], & arr4 [cnt]);
        if (++cnt >= MAX_LINE_CNT)
            break;
    }
    fclose (file);
    for (i = 0; i < cnt; i++) {
        printf ("Array1[%d] %s \n", i + 1, str1 [i]);
        printf ("Array2[%d] %x \n", i + 1, arr2 [i]);
        printf ("Array3[%d] %s \n", i + 1, str3 [i]);
        printf ("Array4[%d] %x \n", i + 1, arr4 [i]);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char line [256];
    char str1 [SIZE] [40], str3 [SIZE] [40];
    char sub1 [40], sub3 [40];
    int str2 [SIZE], str4 [SIZE];
    int each = 0;
    int result = 0;
    int loop = 0;
    FILE *file = NULL;
    if (argc != 2) {
        printf ("syntax is program filename\n");
        return 1;
    }
    if ((file = fopen (argv[1], "r")) == NULL) {
        printf ("could not open file %s\n", argv [1]);
        return 2;
    }
    while (fgets (line, sizeof (line), file)) {
        printf ("The Full Line is: %s", line);
        if ((result = sscanf (line, "%39[^-] -> %39[^\n]", sub1, sub3)) == 2) {
            printf ("First is: %s \n", sub1);
            printf ("Thirs is : %s\n", sub3);
            if ((strchr (sub1, '+')) != NULL) {
                if ((result = sscanf (sub1, "%39[^+]+ 0x%x", str1[each], &str2[each])) != 2) {
                    printf ("problem parsing sub1 + %s\n", sub1);
                    continue;
                }
            }
            else {
                str2[each] = 0;
                if ((result = sscanf (sub1, "%39s", str1[each])) != 1) {
                    printf ("problem parsing sub1 %s\n", sub1);
                    continue;
                }
            }
            if ((strchr (sub3, '+')) != NULL) {
                if ((result = sscanf (sub3, "%39[^+]+ 0x%x", str3[each], &str4[each])) != 2) {
                    printf ("problem parsing sub3 + %s\n", sub3);
                    continue;
                }
            }
            else {
                str4[each] = 0;
                if ((result = sscanf (sub3, "%39s", str3[each])) != 1) {
                    printf ("problem parsing sub3 %s\n", sub3);
                    continue;
                }
            }
            each++;
            if (each >= SIZE) {
                break;
            }
        }
        else {
            printf ("trouble parsing %s\n", line);
        }
    }
    fclose (file);
    for (loop = 0; loop < each; loop++) {
        printf ("Array[%d]=%s\n", loop + 1, str1 [loop]);
        printf ("Array[%d]=0x%x\n", loop + 1, str2 [loop]);
        printf ("Array[%d]=%s\n", loop + 1, str3 [loop]);
        printf ("Array[%d]=0x%x\n\n", loop + 1, str4 [loop]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38703496_38704217_5_22
38703496_38704849_5_35
Title: popen: intercepting user's input 
----------------------------------------

int main (void) {
    FILE *in;
    char buff [512];
    char cmd [512];
    while (fgets (buff, sizeof (buff), stdin) != NULL) {
        strcpy (cmd, "echo '");
        strcat (cmd, buff);
        strcat (cmd, "' | bc");
        if (!(in = popen (cmd, "r"))) {
            exit (1);
        }
        fgets (buff, sizeof (buff), in);
        printf ("output:%s", buff);
    }
    pclose (in);
    return 0;
}
----------------------------------------

int main (void) {
    int write_pipe [2], read_pipe [2];
    pipe (read_pipe);
    pipe (write_pipe);
    int child = fork ();
    if (child == 0) {
        close (PARENT_WRITE);
        close (PARENT_READ);
        dup2 (CHILD_READ, 0);
        close (CHILD_READ);
        dup2 (CHILD_WRITE, 1);
        close (CHILD_WRITE);
        execl ("/usr/bin/bc", "/usr/bin/bc");
    }
    else {
        close (CHILD_READ);
        close (CHILD_WRITE);
        write (PARENT_WRITE, "2+3\n", 4);
        char buff [512];
        int output_len = read (PARENT_READ, buff, sizeof (buff));
        write (1, buff, output_len);
        close (PARENT_READ);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
387104_387254_63_79
387104_46253995_20_78
Title: C Symmetric Stream Cipher 
----------------------------------------

int main (void) {
    char *key = "123";
    char *message = "Hello, World!";
    char encrypted [20];
    char decrypted [20];
    ResetCipher (key);
    Encrypt (message, encrypted);
    ResetCipher (key);
    Decrypt (decrypted, encrypted);
    printf ("output: %s\n", decrypted);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char array_string [MAX_SIZE];
    char ascii_key [MAX_SIZE];
    int data [MAX_SIZE];
    int key [MAX_SIZE];
    int encypted_data [MAX_SIZE];
    int seed;
    int key_int;
    int key_size = 0;
    int index;
    int data_size = 0;
    fprintf (stdout, "Enter data to encrypt: \n");
    fscanf (stdin, "%s", array_string);
    convertStringToBinary (array_string, data, & data_size);
    printf ("Data in binary: \n");
    displayIntArray (data, data_size);
    fprintf (stdout, "Enter key to encrypt data with: \n");
    fscanf (stdin, "%s", ascii_key);
    key_size = getSize (ascii_key);
    seed = hashCode (ascii_key, key_size);
    srand (seed);
    key_int = rand ();
    convertIntToBinaryArray (key_int, key, & index);
    printf ("Key in binary: \n");
    displayIntArray (key, index);
    encryptStreamCipher (key, data, encypted_data, data_size);
    printf ("encrypted Data: \n");
    displayIntArray (encypted_data, data_size);
    decryptStreamCipher (key, encypted_data, data_size);
    printf ("Decrypted binary data: \n");
    displayIntArray (encypted_data, data_size);
    memset (array_string, 0, sizeof (array_string));
    convertBinaryToString (encypted_data, array_string, & data_size);
    printf ("Decrypted Data in String: \n");
    displayCharArray (array_string, data_size);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38711239_38711498_6_54
38711239_38711514_1_13
Title: Showing output in a certain way 
----------------------------------------

int main (int argc, char const *argv []) {
    char char_equivalents [NEW_TERMINAL_LINE] = {0};
    int c;
    int i = 0;
    int final_position;
    FILE *file;
    file = fopen ("file.txt", "r");
    if (file) {
        while ((c = getc (file)) != EOF) {
            if (i > NEW_TERMINAL_LINE - 1) {
                print_current_characters (char_equivalents);
                int j;
                for (j = 0; j < sizeof (char_equivalents) / sizeof (char_equivalents[0]); j++) {
                    char_equivalents[j] = 0;
                    i = 0;
                }
                printf ("\n\n");
            }
            char_equivalents[i] = c;
            if (char_equivalents[i] == '\n') {
                printf ("\\n\t");
            }
            else if (char_equivalents[i] == '\t') {
                printf ("\\t\t");
            }
            else if (char_equivalents[i] == ' ') {
                printf ("[space]\t");
            }
            else {
                printf ("%c\t", c);
            }
            final_position = i;
            i++;
        }
        print_current_characters (char_equivalents);
        fclose (file);
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    FILE *fp;
    int c;
    char line [100];
    fp = fopen (argv[1], "r");
    while (fgets (line, 100, fp) != NULL) {
        line[strlen (line) - 1] = '\0';
        print_words (line);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38734387_38734851_1_24
38734387_38734979_6_37
Title: How to convert a 2D char array to a 2D int in c 
----------------------------------------

int main () {
    int i, j;
    char nextchar;
    int **matsudoku = malloc (9 * sizeof (int *));
    for (i = 0; i < 9; ++i)
        matsudoku[i] = malloc (9 * sizeof (int));
    FILE *fpointer = fopen ("C:/Users/Owner/Documents/Como Sci in C/sudokuchar.txt", "r");
    if (fpointer == NULL) {
        printf ("Cannot open file \n");
        exit (0);
    }
    for (i = 0; i < 9; i++) {
        for (j = 0; j < 9; j++) {
            fscanf (fpointer, " %c", & nextchar);
            matsodoku[i][j] = (int) (nextchar - 'A') + 1;
            printf ("%d", matsudoku [i] [j]);
        }
    }
    fclose (fpointer);
}
----------------------------------------

int main (void) {
    int i, j;
    int matsudoku [SDKSZ] [SDKSZ] = {{0}};
    FILE *fpointer = fopen ("C:/Users/Owner/Documents/Como Sci in C/sudokuchar.txt", "r");
    if (fpointer == NULL) {
        printf ("Cannot open file \n");
        exit (0);
    }
    for (i = 0; i < SDKSZ; i++)
        for (j = 0; j < SDKSZ; j++) {
            int tmp;
            if (fscanf (fpointer, " %d", &tmp) != 1) {
                fprintf (stderr, "error: on read matsudoku[%d][%d]\n", i, j);
                exit (1);
            }
            matsudoku[i][j] = tmp - '0';
        }
    fclose (fpointer);
    for (i = 0; i < SDKSZ; i++) {
        for (j = 0; j < SDKSZ; j++)
            printf (" %3d", matsudoku[i][j]);
        putchar ('\n');
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38782375_38783334_35_76
38782375_38911930_11_58
Title: Unwanted symbol result when evaluating postfix expression 
----------------------------------------

int main () {
    char item, postfix [100];
    int i = 0;
    printf ("Enter Postfix Expression: ");
    gets (postfix);
    while ((item = postfix[i++]) != '\0') {
        if (is_operator (item)) {
            char n1 = pop ();
            char n2 = pop ();
            char n3 = 0;
            switch (item) {
            case '+' :
                n3 = n1 + n2;
                break;
            case '-' :
                n3 = n2 - n1;
                break;
            case '*' :
                n3 = n1 * n2;
                break;
            case '/' :
                n3 = n2 / n1;
                break;
            }
            push (n3);
        }
        else if (isdigit (item)) {
            push (item - '0');
        }
    }
    answer ();
    return 0;
}
----------------------------------------

void main () {
    char *postfix;
    int item;
    int i = 0;
    printf ("Enter Postfix Expression");
    gets (postfix);
    char c;
    while (*postfix != '\0') {
        c = *postfix;
        if (is_operator (c) == 2) {
            push ((c - '0'));
        }
        if (is_operator (c) == 1) {
            char op;
            int n1, n2, n3;
            op = *postfix;
            n1 = pop ();
            n2 = pop ();
            switch (op) {
            case '+' :
                n3 = n1 + n2;
                break;
            case '-' :
                n3 = n1 - n2;
                break;
            case '*' :
                n3 = n1 * n2;
                break;
            case '/' :
                n3 = n1 / n2;
                break;
            }
            push (n3);
        }
        postfix++;
    }
    answer ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38788503_38788545_3_25
38788503_38788567_2_23
Title: Calculations Not working properly 
----------------------------------------

int main () {
    const int n = 10;
    float sum = 0.0f;
    float average;
    int i;
    printf ("Please input the scores of the students: \n");
    for (i = 0; i < n; ++i) {
        float score;
        scanf (" %f", & score);
        sum += score;
    }
    average = sum / n;
    printf ("The average score is: %.2f", average);
    return 0;
}
----------------------------------------

int main () {
    float score1, score2, score3, score4, score5, score6, score7, score8, score9, score10;
    printf ("Please input the scores of the students: \n");
    scanf (" %f", & score1);
    scanf (" %f", & score2);
    scanf (" %f", & score3);
    scanf (" %f", & score4);
    scanf (" %f", & score5);
    scanf (" %f", & score6);
    scanf (" %f", & score7);
    scanf (" %f", & score8);
    scanf (" %f", & score9);
    scanf (" %f", & score10);
    float average = (score1 + score2 + score3 + score4 + score5 + score6 + score7 + score8 + score9 + score10) / 10;
    printf ("The average score is: %.2f", average);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38792542_38793239_10_47
38792542_38794313_9_48
Title: Readline.H history usage in C 
----------------------------------------

int main () {
    char *s;
    char *p = getenv ("USER");
    char *host = getenv ("HOSTNAME");
    int count = 1;
    char *ps;
    printf ("USER: %s\n", p);
    printf ("HOST: %s\n", host);
    size_t size_int = (sizeof (int) == 4) ? 10 : 20;
    ps = malloc (strlen (p) +size_int + 4 + 1);
    sprintf (ps, "%d %s:", count, p);
    while ((s = readline (ps)) != NULL) {
        add_history (s);
        free (s);
        count++;
        sprintf (ps, "%d %s:", count, p);
    }
    printf ("\nlastline:\n");
    HIST_ENTRY *entry = history_get (where_history ());
    printf ("%s\n", entry -> line);
    free (ps);
    exit (EXIT_SUCCESS);
}
----------------------------------------

int main (void) {
    char ps [MAXC] = "", *p = getenv ("USER"), *host = getenv ("HOSTNAME"), *s = NULL;
    int count = 1;
    sprintf (ps, "%d %s@%s> ", count, p, host);
    using_history ();
    while ((s = readline (ps))) {
        if (strcmp (s, "quit") == 0) {
            free (s);
            break;
        }
        add_history (s);
        free (s);
        count++;
        sprintf (ps, "%d %s@%s> ", count, p, host);
    }
    HISTORY_STATE *myhist = history_get_history_state ();
    HIST_ENTRY **mylist = history_list ();
    printf ("\nsession history for %s@%s\n\n", p, host);
    for (int i = 0; i < myhist->length; i++) {
        printf (" %8s  %s\n", mylist [i] -> line, mylist [i] -> timestamp);
        free_history_entry (mylist [i]);
    }
    putchar ('\n');
    free (myhist);
    free (mylist);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38799692_38799850_4_18
38799692_38800047_10_50
Title: Coding an alphabet in C that shows previous and post letters 
----------------------------------------

int main () {
    int resp;
    printf ("Please input an uppercase letter: ");
    resp = getchar ();
    int i = resp;
    if ((resp - 1) < 'A')
        i = resp + 26;
    printf ("The lowercase version of the letter is: %c\n", tolower (resp));
    printf ("The letter %c comes before the letter %c in the alphabet \n", i - 1, resp);
    i = resp;
    if ((resp + 1) > 'Z')
        i = resp - 26;
    printf ("The letter %c comes after the letter %c in the alphabet \n", (i + 1), resp);
    printf ("%c is letter nr %d in the alphabet \n", resp, resp - 'A' + 1);
}
----------------------------------------

int main () {
    char letter;
    puts ("Alphabet Facts!");
    puts ("^^^^^^^^^^^^^^^");
    do {
        printf ("\nPlease input an uppercase letter: ");
        letter = getc (stdin);
        getc (stdin);
    }
    while (!isupper (letter));
    printf ("\nSome interesting facts:\n\n");
    printf ("  1) The lowercase version of the letter is '%c'.\n\n", tolower (letter));
    if (letter == 'A') {
        printf ("  2) No letter comes before '%c' in the alphabet.\n", letter);
    }
    else {
        printf ("  2) The letter '%c' comes before '%c' in the alphabet.\n\n", letter - 1, letter);
    }
    if (letter == 'Z') {
        printf ("  3) No letter comes after '%c' in the alphabet.\n\n", letter);
    }
    else {
        printf ("  3) The letter '%c' comes after '%c' in the alphabet.\n\n", letter + 1, letter);
    }
    printf ("  4) %c is letter number %d in the alphabet!\n\n", letter, letter - ('A' - 1));
    exit (EXIT_SUCCESS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38800099_38800273_6_52
38800099_38801262_3_25
Title: read string char and int from file in c programming 
----------------------------------------

int main () {
    int num, grade, ret;
    char id, name [35];
    int lineno = 1;
    FILE *fp = NULL;
    errno = 0;
    fp = fopen ("student.dat", "r");
    if (fp != NULL) {
        for (;;) {
            ret = fscanf (fp, "Stu: %d %s (%c) - %d\n", &num, name, &id, &grade);
            if (ret != 4 && ret != EOF) {
                fprintf (stderr, "fscanf() returned %d instead of 4 for line %d\n", ret, lineno);
                if (errno != 0) {
                    fprintf (stderr, "With error %s\n", strerror (errno));
                }
                exit (EXIT_FAILURE);
            }
            if (ret == EOF) {
                if (errno != 0) {
                    fprintf (stderr, "The error %s occured while reading line %d\n", strerror (errno), lineno);
                    exit (EXIT_FAILURE);
                }
                break;
            }
            printf ("Student Num: %d, ", num);
            printf ("Student Name: %s, ", name);
            printf ("Student id: %c, ", id);
            printf ("Student grade: %d\n", grade);
            lineno++;
        }
        fclose (fp);
    }
    else {
        printf ("Failed to open file: %s\n", strerror (errno));
        exit (EXIT_FAILURE);
    }
    exit (EXIT_SUCCESS);
}
----------------------------------------

int main (int argc, char **argv) {
    int num = 0, grade = 0, max = 0;
    char id = 0, name [35];
    const char *fmt = " Stu:%d %s (%c) - %d";
    FILE *fp = NULL;
    if (!(fp = argc > 1 ? fopen (argv[1], "r") : stdin)) {
        fprintf (stderr, "error: file open failed '%s'.\n", argv [1]);
        return 1;
    }
    while (fscanf (fp, fmt, &num, name, &id, &grade) == 4) {
        if (grade > max)
            max = grade;
        printf ("Student Num: %d  Name: %-12s  id: %c  grade: %d\n", num, name, id, grade);
    }
    printf ("\n highest grade : %d\n\n", max);
    if (fp != stdin)
        fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38801887_38804247_3_19
38801887_38804727_10_24
Title: how to implement a circular counter? 
----------------------------------------

int main (void) {
    int max = 3, num, i;
    num = 0;
    for (i = 0; i < 10; i++) {
        printf ("%d\n", num);
        num = (num + 1) % (max + 1);
    }
    puts ("--");
    num = max;
    for (i = 0; i < 10; i++) {
        printf ("%d\n", num);
        num = (max - -num) % (max + 1);
    }
    return 0;
}
----------------------------------------

int main () {
    SmallInt up = {0};
    SmallInt down = {0};
    for (int z = 0; z < 10; z++) {
        printf ("%d %d\n", up.x, down.x);
        up.x++;
        down.x--;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38814506_38814595_1_18
38814506_38814958_10_46
Title: From integer to char array of digits and printing 
----------------------------------------

int baseChange (int base, int newBase, int num) {
    int baseTen = toBaseTen (base, num);
    char finalBase [24];
    int i;
    for (i = 0; baseTen != 0; i++) {
        int remain = baseTen % newBase;
        finalBase[i] = (char) (remain + 48);
        baseTen /= newBase;
    }
    for (i--; i >= 0; i--) {
        printf ("i is: %d... %c", i, finalBase [i]);
    }
    return SUCCESS_EXIT;
}
----------------------------------------

int baseChange (int base, int newBase, int num) {
    const char *digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/";
    int baseTen = num;
    char finalBase [64];
    int i, remain;
    if (base < 2 || base > 64) {
        return BC_ERROR_OB;
    }
    if (newBase < 2 || newBase > 64) {
        return BC_ERROR_NB;
    }
    if (num == 0) {
        i = 0;
        finalBase[0] = '0';
    }
    else {
        for (i = 0; baseTen != 0; i++) {
            remain = baseTen % newBase;
            finalBase[i] = digits[remain & 0xff];
            baseTen /= newBase;
        }
        i--;
    }
    for (; i >= 0; i--) {
        printf ("i is: %d... %c\n", i, finalBase [i]);
    }
    return BC_OK;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38818455_38819298_14_57
38818455_38819928_17_74
Title: coulomb's law force calculation using c code 
----------------------------------------

int main () {
    FILE *psf = fopen ("atom.psf", "r");
    FILE *pdb = fopen ("beads.pdb", "r");
    FILE *fout = fopen ("out.txt", "w");
    char buffer [1024];
    fgets (buffer, 1024, psf);
    int i = 0;
    for (; (i < ROW) && (psf != NULL); i++) {
        fscanf (psf, "%*8d%*4s%*4d%*6s%*5s%*6s%11f%*14f%*12d", & q [i]);
        fscanf (pdb, "%*4s%*7d%*5s%*4s%*6d%12f%8f%8f%*6f%*6f%*9s", & x [i], & y [i], & z [i]);
    }
    for (i = 0; i < ROW; i++) {
        Fx = Fy = Fz = F = 0.0;
        for (j = 0; j < ROW; j++) {
            if (i == j)
                continue;
            dx = x[i] - x[j];
            dy = y[i] - y[j];
            dz = z[i] - z[j];
            R = sqrt (dx *dx + dy * dy + dz * dz);
            Fx += Constant * q[i] * q[j] * dx / (R * R * R);
            Fy += Constant * q[i] * q[j] * dy / (R * R * R);
            Fz += Constant * q[i] * q[j] * dz / (R * R * R);
        }
        F = sqrt (Fx *Fx + Fy * Fy + Fz * Fz);
        fprintf (fout, "%d %g %g %g, %g\n", i + 1, Fx, Fy, Fz, F);
    }
}
----------------------------------------

int main (int argc, char **argv) {
    beads atoms [NATM] = {{
            .x = 0.0
        }
    };
    size_t i;
    char buf [MAXL] = "";
    FILE *fp = xfopen (argc > 1 ? argv[1] : "dat/atom.psf", "r");
    fgets (buf, MAXL, fp);
    for (i = 0; i < NATM && fgets (buf, MAXL, fp); i++) {
        if (sscanf (buf, "%*s %*s %*s %*s %*s %*s %f", &atoms[i].chrg) != 1) {
            fprintf (stderr, "error: read of charge failed, atom[%zu].\n", i);
            return 1;
        }
    }
    fclose (fp);
    if (i != NATM) {
        fprintf (stderr, "error: only '%zu' charge values read.\n", i);
        return 1;
    }
    fp = xfopen (argc > 2 ? argv[2] : "dat/beads.pdb", "r");
    for (i = 0; i < NATM && fgets (buf, MAXL, fp); i++) {
        if (sscanf (buf, "%*s %*s %*s %*s %*s %f %f %f", &atoms[i].x, &atoms[i].y, &atoms[i].z) != 3) {
            fprintf (stderr, "error: read of position failed, atom[%zu].\n", i);
            return 1;
        }
    }
    fclose (fp);
    if (i != NATM) {
        fprintf (stderr, "error: only '%zu' position values read.\n", i);
        return 1;
    }
    for (i = 0; i < NATM; i++) {
        for (size_t j = 0; j < NATM; j++) {
            if (i == j)
                continue;
            float dx = atoms[j].x - atoms[i].x, dy = atoms[j].y - atoms[i].y, dz = atoms[j].z - atoms[i].z, d = sqrt (dx *dx + dy * dy + dz * dz);
            atoms[i].fx += (KEair * atoms[i].chrg * atoms[j].chrg * dx) / (d * d * d);
            atoms[i].fy += (KEair * atoms[i].chrg * atoms[j].chrg * dy) / (d * d * d);
            atoms[i].fz += (KEair * atoms[i].chrg * atoms[j].chrg * dz) / (d * d * d);
            atoms[i].f += (KEair * atoms[i].chrg * atoms[j].chrg) / (d * d);
        }
    }
    for (i = 0; i < NATM; i++)
        printf (" atom[%2zu]  %5.2f  %5.2f  %5.2f   %+.2f   %15.2f  %15.2f  %5.2f  %15.2f\n", i, atoms[i].x, atoms[i].y, atoms[i].z, atoms[i].chrg, atoms[i].fx, atoms[i].fy, atoms[i].fz, atoms[i].f);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38822148_38822263_1_20
38822148_38822311_22_34
Title: C - Pass Array of Strings as Function Parameter 
----------------------------------------

int main (int argc, const char *argv []) {
    char my_array [10] [100];
    int tot_char_arrs, i;
    char *char_arr_ptr [10];
    tot_char_arrs = sizeof (my_array) / sizeof (my_array[0]);
    for (i = 0; i < tot_char_arrs; i++)
        char_arr_ptr[i] = my_array[i];
    string_copy (char_arr_ptr);
    printf ("%s%s\n", my_array [0], my_array [1]);
}
----------------------------------------

int main (void) {
    const char *strings [] = {"hello", "World"};
    char *my_array [sizeof (strings) / sizeof (strings[0])] = {0};
    if (string_copy (my_array, strings, sizeof (strings) / sizeof (strings[0]))) {
        printf ("%s %s\n", my_array [0], my_array [1]);
    }
    for (size_t i = 0; i < sizeof (strings) / sizeof (strings[0]); i++)
        free (my_array[i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38855858_38856530_25_34
38855858_38857417_31_46
Title: signal handler in child thread 
----------------------------------------

int main (int argc, char **argv) {
    proxy = (proxy_node *) malloc (sizeof (proxy_node));
    proxy->p_self = pthread_self ();
    pthread_create (& proxy -> sub_thread, NULL, t_consensus, NULL);
    sleep (2);
    pthread_kill (proxy -> sub_thread, SIGINT);
    sleep (2);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    sem_init (& sema1, 0, 0);
    sem_init (& sema2, 0, 0);
    proxy = (proxy_node *) malloc (sizeof (proxy_node));
    proxy->p_self = pthread_self ();
    pthread_create (& proxy -> sub_thread, NULL, t_consensus, NULL);
    sem_wait (& sema1);
    pthread_kill (proxy -> sub_thread, SIGINT);
    sem_post (& sema2);
    pthread_join (proxy -> sub_thread, NULL);
    free (proxy);
    sem_destroy (& sema1);
    sem_destroy (& sema2);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38859310_38859393_19_32
38859310_38860206_9_46
Title: Passing structures to functions in C 
----------------------------------------

int main (void) {
    Book books [10];
    for (int i = 0; i < 10; i++) {
        strncpy (books [i].name, "aaa", 4);
        books[i].pagec = 4;
        books[i].price = 10;
    }
    BookSorter (books, 10);
}
----------------------------------------

int main () {
    int n, i;
    book_t **books;
    puts ("How many books?");
    scanf ("%d", & n);
    books = malloc (n * sizeof (book_t *));
    for (i = 0; i < n; i++) {
        books[i] = malloc (sizeof (book_t));
    }
    for (i = 0; i < n; i++) {
        printf ("Name of book (3 letter abbrev.):");
        scanf ("%3s", books [i] -> name);
        printf ("Number of pages:");
        scanf ("%d", & books [i] -> pagec);
        printf ("Price of book (incl. taxes):");
        scanf ("%d", & books [i] -> price);
    }
    sort_books (books, n);
    print_books (books, n);
    for (i = 0; i < n; i++) {
        free (books [i]);
    }
    free (books);
    exit (EXIT_SUCCESS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38881877_38886259_30_43
38881877_39040492_10_26
Title: Bit hack: Expanding bits 
----------------------------------------

int main (void) {
    f_time (expand_bits);
    f_time (expandBits);
    f_time (remask);
    f_time (javey);
    f_time (thndrwrks_expand);
    f_time (thndrwrks_expand);
    f_time (javey);
    f_time (remask);
    f_time (expandBits);
    f_time (expand_bits);
    return 0;
}
----------------------------------------

int main (void) {
    unsigned int in = 12;
    unsigned int out = 0;
    bool success;
    char buff [SIZE_MAX];
    success = expand_uint (&in, &out);
    if (false == success) {
        (void) puts ("Error: expand_uint failed");
        return EXIT_FAILURE;
    }
    (void) snprintf (buff, (size_t) SIZE_MAX, "%u expanded is %u\n", in, out);
    (void) fputs (buff, stdout);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38899126_38899899_1_10
38899126_38899909_4_83
Title: Split string using more than one char as delimeter 
----------------------------------------

int main (int argc, char *argv []) {
    char str [] = "file1.h: file2.c,file3.cpp";
    char name [100];
    char depends [100];
    sscanf (str, "%s%s", name, depends);
    printf ("str: '%s'\n", str);
    printf ("Name: %s\n", name);
    printf ("Deps: %s\n", depends);
    return 0;
}
----------------------------------------

int main (void) {
    const char * const string = "file1.h: file2.c,file3.cpp ";
    const char *head;
    const char *tail;
    const char *next;
    head = string;
    if ((tail = strchr (head, ':')) == NULL)
        return -1;
    next = tail + 1;
    while (isspace ((unsigned char) *head) != 0)
        ++head;
    while (isspace ((unsigned char) *(tail - 1)) != 0)
        --tail;
    fputc ('*', stdout);
    fwrite (head, 1, tail - head, stdout);
    fputc ('*', stdout);
    fputc ('\n', stdout);
    head = next;
    while (head != NULL) {
        tail = strchr (head, ',');
        if (tail == NULL) {
            tail = strchr (head, '\0');
        }
        next = tail + 1;
        while (isspace ((unsigned char) *head) != 0)
            ++head;
        while (isspace ((unsigned char) *(tail - 1)) != 0)
            --tail;
        fputc ('*', stdout);
        fwrite (head, 1, tail - head, stdout);
        fputc ('*', stdout);
        fputc ('\n', stdout);
        if (*(next - 1) == '\0') {
            head = NULL;
        }
        else {
            head = next;
        }
    }
    fputc ('\n', stderr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38920547_38920848_6_33
38920547_38929675_17_36
Title: Why is XORing a string in c giving me garbage values? 
----------------------------------------

int main (void) {
    char ip [N];
    char op [N];
    char rv [N];
    char c = '0';
    size_t i, len;
    printf ("Enter the original text: ");
    fgets (ip, sizeof (ip), stdin);
    ip[strcspn (ip, "\n")] = '\0';
    len = strlen (ip);
    i = 0;
    for (; i < len; i++)
        op[i] = ip[i];
    op[i] = '\0';
    i = 0;
    for (; i < len; i++)
        rv[i] = op[i];
    rv[i] = '\0';
    puts (ip);
    puts (rv);
    return 0;
}
----------------------------------------

int main () {
    char key = '0', input [BUFFER_SIZE], output [BUFFER_SIZE], reverse [BUFFER_SIZE];
    printf ("Enter the original text: ");
    (void) fgets (input, BUFFER_SIZE, stdin);
    *strrchr (input, '\n') = '\0';
    encode_decode (key, input, output);
    printf ("The Cypher Text is: %s\n", output);
    encode_decode (key, output, reverse);
    printf ("The Original text again is: %s\n", reverse);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38926819_38926990_1_17
38926819_38995568_1_25
Title: how to detect duplicates in arrays & print non duplicates? 
----------------------------------------

void main () {
    int x [4] = {1, 3, 2, 1};
    size_t i, j;
    for (i = 0; i < sizeof (x) / sizeof (int); i++) {
        for (j = 0; j < i; j++) {
            if (x[i] == x[j])
                break;
        }
        if (j == i)
            printf ("Unique: %i\n", x[i]);
    }
}
----------------------------------------

void main () {
    int num [20] = {0}, i = 0, n = 0, index_num = 0, init_incr = 0, unique = 0, n_uniq = 1, temp, check = 0;
    while (i <= 19) {
        printf ("%02d-  ", i + 1);
        scanf ("%d", & num [i]);
        i = i + 1;
    }
    for (index_num = 0; index_num < 19; index_num++) {
        for (n = init_incr + index_num; n < 19; n++) {
            if (num[index_num] != num[index_num + 1] && num[index_num] != num[index_num - 1]) {
                check++;
                temp = num[index_num];
                unique = temp;
                for (; n_uniq <= check; n_uniq++)
                    printf ("\tunique %02d  = %d\n", n_uniq, unique);
                break;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38933373_38933457_1_19
38933373_38933854_10_25
Title: error in building link list in c 
----------------------------------------

void insert (struct node **start) {
    struct node *temp;
    temp = (struct node *) malloc (sizeof (struct node));
    temp->data = 75;
    temp->next = NULL;
    if (*start == NULL) {
        *start = temp;
    }
    else {
        struct node *curr = *start;
        while (curr->next != NULL) {
            curr = curr->next;
        }
        curr->next = temp;
    }
}
----------------------------------------

int insert (struct node **start, int data) {
    struct node *new_node = malloc (sizeof (struct node));
    int success = new_node != NULL;
    if (success) {
        new_node->data = data;
        new_node->next = NULL;
        while (*start)
            start = &(*start)->next;
        *start = new_node;
    }
    return success;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38938883_38938926_7_24
38938883_38939796_5_32
Title: String tokenization strange character output 
----------------------------------------

int main (void) {
    char *s [] = {"12, 34, 56, 78", "82.16, 41.296", "2, -3, 5, -7, 11, -13, 17, -19", "9.00009, 90.0009, 900.009, 9000.09, 90000.9"};
    int sNo = 0;
    while (sNo < 4) {
        char *token = strtok (s[sNo++], ", ");
        while (token != NULL) {
            printf ("%s\n", token);
            token = strtok (NULL, ", ");
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char s1 [] = "12, 34, 56, 78", s2 [] = "82.16, 41.296", s3 [] = "2, -3, 5, -7, 11, -13, 17, -19", s4 [] = "9.00009, 90.0009, 900.009, 9000.09, 90000.9", *s [] = {s1, s2, s3, s4};
    size_t i, idx = 0, n = sizeof s / sizeof *s;
    double avg [n];
    for (i = 0; i < n; i++) {
        double sum = 0.0;
        size_t nval = 0;
        char *token = strtok (s[i], ", ");
        while (token != NULL) {
            sum += strtod (token, NULL);
            nval++;
            printf ("  %8s, sum : %9.2lf\n", token, sum);
            token = strtok (NULL, ", ");
        }
        printf ("----------------------------\n");
        printf ("        average : %9.2lf\n\n", (avg [idx ++] = sum / nval));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38938883_38938926_7_24
38938883_38939870_7_30
Title: String tokenization strange character output 
----------------------------------------

int main (void) {
    char *s [] = {"12, 34, 56, 78", "82.16, 41.296", "2, -3, 5, -7, 11, -13, 17, -19", "9.00009, 90.0009, 900.009, 9000.09, 90000.9"};
    int sNo = 0;
    while (sNo < 4) {
        char *token = strtok (s[sNo++], ", ");
        while (token != NULL) {
            printf ("%s\n", token);
            token = strtok (NULL, ", ");
        }
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char strings [] [BUFFER_SIZE] = {"12, 34, 56, 78", "82.16, 41.296", "2, -3, 5, -7, 11, -13, 17, -19", "9.00009, 90.0009, 900.009, 9000.09, 90000.9"};
    size_t limit = sizeof (strings) / BUFFER_SIZE;
    for (size_t i = 0; i < limit; i++) {
        char *token, *string = strings[i];
        while ((token = strsep (&string, ",")) != NULL) {
            while (isspace (*token)) {
                token++;
            }
            printf ("%s\n", token);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38938883_38939796_5_32
38938883_38939870_7_30
Title: String tokenization strange character output 
----------------------------------------

int main (void) {
    char s1 [] = "12, 34, 56, 78", s2 [] = "82.16, 41.296", s3 [] = "2, -3, 5, -7, 11, -13, 17, -19", s4 [] = "9.00009, 90.0009, 900.009, 9000.09, 90000.9", *s [] = {s1, s2, s3, s4};
    size_t i, idx = 0, n = sizeof s / sizeof *s;
    double avg [n];
    for (i = 0; i < n; i++) {
        double sum = 0.0;
        size_t nval = 0;
        char *token = strtok (s[i], ", ");
        while (token != NULL) {
            sum += strtod (token, NULL);
            nval++;
            printf ("  %8s, sum : %9.2lf\n", token, sum);
            token = strtok (NULL, ", ");
        }
        printf ("----------------------------\n");
        printf ("        average : %9.2lf\n\n", (avg [idx ++] = sum / nval));
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char strings [] [BUFFER_SIZE] = {"12, 34, 56, 78", "82.16, 41.296", "2, -3, 5, -7, 11, -13, 17, -19", "9.00009, 90.0009, 900.009, 9000.09, 90000.9"};
    size_t limit = sizeof (strings) / BUFFER_SIZE;
    for (size_t i = 0; i < limit; i++) {
        char *token, *string = strings[i];
        while ((token = strsep (&string, ",")) != NULL) {
            while (isspace (*token)) {
                token++;
            }
            printf ("%s\n", token);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38941080_38941367_1_20
38941080_38943615_3_28
Title: what is wrong with this code? (to check whether a given number is a prime number) 
----------------------------------------

int main () {
    int a, n, x = 0;
    printf ("enter a number: ");
    scanf ("%d", & a);
    for (n = 2; n <= a / 2; ++n) {
        if (a % n == 0) {
            x = 1;
            break;
        }
    }
    if (x == 0)
        printf ("", n);
    else
        printf ("a is not a prime no");
    return 0;
}
----------------------------------------

int main () {
    clrscr ();
    int n, x = 2, count = 0;
    printf ("Enter a number : ");
    scanf ("%d", & n);
    while (x < n) {
        if (n % x == 0) {
            count++;
            break;
        }
        else
            x++;
    }
    if (count == 0) {
        printf ("%d is a prime number", n);
        return 0;
    }
    printf ("%d is not a prime number", n);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38946291_38946482_9_19
38946291_38946648_1_13
Title: C - Representation of a matrix as a linked list 
----------------------------------------

struct Node *addRow (struct Node *bottomLeft) {
    if (bottomLeft == NULL) {
        return NULL;
    }
    else {
        struct Node *newNode = malloc (sizeof (struct Node));
        newNode->value = 0;
        newNode->up = bottomLeft;
        newNode->right = addRow (bottomLeft->right);
        return newNode;
    }
}
----------------------------------------

struct Node *addRow (struct Node *mat) {
    struct Node *res = NULL, **pp = &res;
    for (; mat; mat = mat->right) {
        *pp = malloc (sizeof **pp);
        (*pp)->value = 0;
        (*pp)->up = mat;
        pp = &(*pp)->right;
    }
    *pp = NULL;
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38948527_38948916_4_49
38948527_38949274_21_74
Title: Convert 8Byte char hex string to 4Byte value; Preferably in uint32_t to get proper binary value 
----------------------------------------

int main () {
    uint8_t in [] = {'A', 'C', 'D', 'B', '5', '8', '2', '3', '\0'};
    uint32_t out = 0;
    char c;
    int i, k;
    for (i = 0; in[i] != (uint8_t) '\0'; i++) {
        c = (char) in[i];
        switch (c) {
        case 'A' :
            k = 10;
            break;
        case 'B' :
            k = 11;
            break;
        case 'C' :
            k = 12;
            break;
        case 'D' :
            k = 13;
            break;
        case 'E' :
            k = 14;
            break;
        case 'F' :
            k = 15;
            break;
        default :
            k = (int) (c - '\0');
            break;
        }
        out <<= 4;
        k &= 0xf;
        out |= k;
    }
    printf ("%X\n", out);
    exit (EXIT_SUCCESS);
}
----------------------------------------

int main (void) {
    unsigned int ra;
    unsigned int rb;
    unsigned int rc;
    unsigned int rd;
    start[0] = 0xAC;
    start[1] = 0xDB;
    start[2] = 0x58;
    start[3] = 0x23;
    for (ra = 0; ra < 4; ra++)
        printf ("[%02X]", start[ra]);
    printf ("\n");
    rb = 0;
    for (ra = 0; ra < 4; ra++) {
        send[rb++] = to_hex ((start[ra] >> 4) & 0xF);
        send[rb++] = to_hex ((start[ra] >> 0) & 0xF);
    }
    for (ra = 0; ra < 8; ra++)
        printf ("[%02X]", send[ra]);
    printf ("\n");
    send[9] = 0;
    printf ("%s\n", send);
    send_somewhere ();
    for (ra = 0; ra < 8; ra++)
        printf ("[%02X]", recv[ra]);
    printf ("\n");
    rb = 0;
    for (ra = 0; ra < 8; ra += 2) {
        rc = 0;
        rc = from_hex (recv[ra + 0]);
        rc <<= 4;
        rc |= from_hex (recv[ra + 1]);
        end[rb++] = rc;
    }
    for (ra = 0; ra < 4; ra++)
        printf ("[%02X]", end[ra]);
    printf ("\n");
    rb = 0;
    for (ra = 0; ra < 4; ra++) {
        send[rb++] = 0x40 + ((start[ra] >> 4) & 0xF);
        send[rb++] = 0x40 + ((start[ra] >> 0) & 0xF);
    }
    for (ra = 0; ra < 8; ra++)
        printf ("[%02X]", send[ra]);
    printf ("\n");
    send[9] = 0;
    printf ("%s\n", send);
    send_somewhere ();
    for (ra = 0; ra < 8; ra++)
        printf ("[%02X]", recv[ra]);
    printf ("\n");
    rb = 0;
    for (ra = 0; ra < 8; ra += 2) {
        rc = recv[ra + 0] & 0xF;
        rc <<= 4;
        rc |= recv[ra + 1] & 0xF;
        end[rb++] = rc;
    }
    for (ra = 0; ra < 4; ra++)
        printf ("[%02X]", end[ra]);
    printf ("\n");
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38950579_38950984_4_18
38950579_38953024_4_20
Title: Fibonacci Sum of Large Numbers(Only Last Digit to be Printed) 
----------------------------------------

int calc_fib (long long int n) {
    int fibzero = 0;
    int fibone = 1;
    int fibnext;
    long long int res = 1;
    for (long long int i = 2; i <= n; i++) {
        fibnext = (fibone + fibzero) % 10;
        fibzero = fibone;
        fibone = fibnext;
        res = res + fibnext;
    }
    return (res % 10);
}
----------------------------------------

long long calc_fib (long long n) {
    n = (n + 2) % 60;
    int fib [n + 1];
    fib[0] = 0;
    fib[1] = 1;
    int res = 1;
    for (int i = 2; i <= n; i++) {
        fib[i] = (fib[i - 1] % 10 + fib[i - 2] % 10) % 10;
    }
    if (fib[n] == 0) {
        return 9;
    }
    return (fib[n] % 10 - 1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38956890_38957968_3_53
38956890_38960558_1_23
Title: C program to delete all unnecessary blanks from a string 
----------------------------------------

char *DeleteSpaces (char *str) {
    char *src = str;
    char *dest = str;
    int inBlank = 0;
    while (*src) {
        if (isalpha (*src)) {
            *dest = *src;
            dest++;
            src++;
            inBlank = 0;
        }
        else if (ispunct (*src)) {
            if (inBlank) {
                dest--;
            }
            *dest = *src;
            dest++;
            src++;
            inBlank = 0;
        }
        else if (isspace (*src)) {
            if (inBlank) {
                src++;
            }
            else {
                inBlank = 1;
                *dest = *src;
                dest++;
                src++;
            }
        }
    }
    *dest = '\0';
    return str;
}
----------------------------------------

char *DeleteSpaces (char *str) {
    char *start = str;
    char *dest = str;
    while (*str == ' ')
        str++;
    char previous = 0;
    char ch;
    while ((ch = *str++) != '\0') {
        if (ch != ' ') {
            if (previous == ' ') {
                *dest++ = previous;
            }
            *dest++ = ch;
        }
        previous = ch;
    }
    *dest = '\0';
    return start;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3896067_3896312_4_29
3896067_3896377_1_20
Title: Why am I getting a segmentation fault? 
----------------------------------------

static int sumNumbers (const char *filename) {
    int sum, num, c;
    FILE *f;
    if ((f = fopen (filename, "r")) == NULL) {
    }
    sum = 0;
    num = 0;
    while ((c = fgetc (f)) != EOF) {
        if (isdigit (c)) {
            num = 10 * num + (c - '0');
        }
        else if (num != 0) {
            sum += num;
            num = 0;
        }
    }
    if (fclose (f) != 0) {
    }
    return sum;
}
----------------------------------------

static int sumNumbers (char *filename) {
    int sum = 0;
    FILE *file = fopen (filename, "r");
    char buf [BUFSIZ], *str;
    while (fgets (buf, BUFSIZ, file)) {
        str = buf;
        while (*str) {
            if (isdigit (*str)) {
                sum += strtol (str, &str, 10);
            }
            str++;
        }
    }
    fclose (file);
    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38961480_38961582_1_13
38961480_38961668_1_10
Title: Function return value in C 
----------------------------------------

int checkIfPrime (int n) {
    int flag = 1;
    for (int i = 2; i <= (n / 2); i++) {
        if (n % i == 0) {
            flag = 0;
            break;
        }
    }
    for (int i = 2; i <= (n / 2); i++) {
    }
}
----------------------------------------

void checkIfPrime (int n, int *flag) {
    *flag = 1;
    for (int i = 2; i <= (n / 2); i++) {
        if (n % i == 0) {
            *flag = 0;
            break;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38987079_38987177_4_30
38987079_41579790_8_16
Title: Return first letter of each word capitalized 
----------------------------------------

int main (void) {
    char s [1024];
    char last_character = ' ';
    while (fgets (s, sizeof (s), stdin) != NULL) {
        int i;
        for (i = 0; s[i] != '\0'; i++) {
            if (isalpha ((unsigned char) s[i]) && (i == 0 ? last_character : s[i - 1]) == ' ') {
                printf ("%c", toupper ((unsigned char) s [i]));
            }
        }
        if (i > 0) {
            last_character = s[i - 1];
            if (last_character == '\n')
                break;
        }
    }
    putchar ('\n');
    return 0;
}
----------------------------------------

int main (void) {
    string str = GetString ();
    str[0] = toupper (str[0]);
    for (int i = 1; i < strlen (str); i++) {
        if (str[i - 1] == ' ')
            str[i] = toupper (str[i]);
    }
    puts (str);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38999185_38999355_1_19
38999185_39020482_6_22
Title: C program crashes after printing few lines 
----------------------------------------

void main () {
    char *str [] = {"Dog", "Cat", "Hen", "Goat"};
    char *sentence = NULL;
    int i;
    srand (time (NULL));
    for (i = 0; i < 20; i++) {
        sentence = malloc (13);
        sentence[0] = '\0';
        strcat (sentence, str [rand () % 4]);
        strcat (sentence, str [rand () % 4]);
        strcat (sentence, str [rand () % 4]);
        printf ("%s\n", sentence);
        free (sentence);
    }
}
----------------------------------------

int main () {
    char *str [] = {"Dog", "Cat", "Hen", "Goat"};
    char sentence [64];
    int i;
    srand (time (NULL));
    for (i = 0; i < 20; i++) {
        strcpy (sentence, str [rand () % 4]);
        strcat (sentence, str [rand () % 4]);
        strcat (sentence, str [rand () % 4]);
        printf ("%s\n", sentence);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39001200_39001685_4_30
39001200_39001833_1_36
Title: How do I replace more than one blank in c programming with one blank? 
----------------------------------------

int main (void) {
    int c;
    int blanks = 0;
    printf ("Enter your name please\n");
    while ((c = getchar ()) != EOF) {
        if (c == ' ') {
            ++blanks;
            if (blanks == 1)
                putchar (c);
        }
        if (isalpha (c)) {
            putchar (c);
            blanks = 0;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    int c;
    int blankfound = 0;
    printf ("Enter your name please\n");
    while ((c = getchar ()) != EOF) {
        if (c == ' ') {
            blankfound = 1;
            continue;
        }
        if (c >= 'a' && c <= 'z') {
            if (blankfound == 1) {
                putchar (' ');
                blankfound = 0;
            }
            putchar (c);
            continue;
        }
        if (c >= 'A' && c <= 'Z') {
            if (blankfound == 1) {
                putchar (' ');
                blankfound = 0;
            }
            putchar (c);
            continue;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39030056_39030406_9_72
39030056_39030575_4_57
Title: fscanf() and realloc() - reading file to matrix 
----------------------------------------

int main () {
    int i, COL = 5;
    double *row, **table, **cp;
    int allocated = 0, needed = 0;
    row = malloc (COL * sizeof (double));
    table = NULL;
    FILE *f;
    f = fopen ("realloc2.dat", "r");
    for (;;) {
        if (needed >= allocated) {
            cp = realloc (table, (needed + REALLOC_GROW) * sizeof (double *));
            table = cp;
            for (i = 0; i < REALLOC_GROW; i++) {
                table[needed + i] = malloc (COL * sizeof (double));
            }
            allocated += REALLOC_GROW;
        }
        fscanf (f, "%lf, %lf, %lf, %lf, %lf\n", & row [0], & row [1], & row [2], & row [3], & row [4]);
        memcpy (table [needed], row, COL * sizeof (double));
        needed++;
        if (feof (f)) {
            break;
        }
    }
    for (i = 0; i < needed; i++) {
        printf ("%f, %f, %f, %f, %f\n", table [i] [0], table [i] [1], table [i] [2], table [i] [3], table [i] [4]);
    }
    free (row);
    for (i = 0; i < allocated; i++) {
        free (table [i]);
    }
    free (table);
    fclose (f);
    exit (EXIT_SUCCESS);
}
----------------------------------------

int main (void) {
    double **x;
    int ROW = 5;
    int COL = 5;
    int c, r = 0, rows;
    FILE *fp = fopen ("realloc2.dat", "r");
    if (fp == NULL) {
        perror ("file can't open");
        exit (EXIT_FAILURE);
    }
    x = malloc (ROW * sizeof (double *));
    for (;; ++r) {
        if (r == ROW) {
            ROW += 5;
            if ((x = realloc (x, ROW * sizeof (*x))) == NULL) {
                perror ("failed realloc");
                exit (EXIT_FAILURE);
            }
        }
        if ((x[r] = malloc (COL * sizeof (double))) == NULL) {
            perror ("failed malloc");
            exit (EXIT_FAILURE);
        }
        for (c = 0; c < COL; ++c) {
            if (1 != fscanf (fp, "%lf", &x[r][c]))
                goto readend;
        }
    }
readend :
    rows = r;
    if (c != 0) {
        puts ("data are insufficient.");
    }
    else {
        for (r = 0; r < rows; ++r) {
            for (c = 0; c < COL; ++c) {
                if (c)
                    putchar (' ');
                printf ("%5.2f", x [r] [c]);
            }
            puts ("");
        }
    }
    fclose (fp);
    for (r = 0; r <= rows; ++r) {
        free (x [r]);
    }
    free (x);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3903059_24592243_4_29
3903059_3903118_8_22
Title: Cannot print array of strings without getting garbage characters 
----------------------------------------

int main () {
    char test [5] [20 + 1] = {{0}};
    int i;
    int c;
    char *ptr = NULL;
    for (i = 0; i < 5; i++) {
        printf ("enter> ");
        fgets (test [i], 20 + 1, stdin);
        if ((ptr = strrchr (test[i], '\n'))) {
            *ptr = 0x00;
        }
        else {
            while ((c = getchar ()) != '\n' && c != EOF)
                ;
        }
    }
    for (i = 0; i < 5; i++)
        printf ("%d | %s\n", i, test[i]);
    return 0;
}
----------------------------------------

int main () {
    char test [5] [20];
    char input [20];
    int i;
    for (i = 0; i < 5; i++) {
        printf ("enter> ");
        fflush (stdout);
        fgets (input, 20, stdin);
        chopnl (input);
        memcpy (test [i], input, strlen (input) + 1);
    }
    for (i = 0; i < 5; i++)
        printf ("%d | %s\n", i, test[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39032201_39032448_4_34
39032201_39032473_4_45
Title: "C Program: A array containts items ID's B array contains sold items find C array which contains unsold items" 
----------------------------------------

int main () {
    int a [] = {101, 102, 103, 104, 107, 110};
    int n = sizeof (a) / sizeof (int);
    int b [] = {102, 103, 101};
    int m = sizeof (b) / sizeof (int);
    int c [20];
    static int k = 0;
    int flag;
    for (int i = 0; i < n; i++) {
        int f = 0;
        for (int j = 0; j < m; j++) {
            if (a[i] == b[j]) {
                f = 1;
            }
        }
        if (f == 0) {
            c[k] = a[i];
            printf ("c[%d]=%d\n", k, c [k]);
            k++;
        }
    }
    return 0;
}
----------------------------------------

int main () {
    int a [] = {101, 102, 103, 104, 107, 110};
    int n = sizeof (a) / sizeof (int);
    int b [] = {102, 103, 101};
    int m = sizeof (b) / sizeof (int);
    int c [20];
    static int k = 0;
    int flag;
    int largestNumInA = 0;
    for (int i = 0; i < n; i++) {
        if (largestNumInA < a[i])
            largestNumInA = a[i];
    }
    int solutionSet [largestNumInA];
    for (int j = 0; j < n; j++) {
        solutionSet[a[j]] = 1;
    }
    for (int k = 0; k < m; k++) {
        solutionSet[b[k]] = -1;
    }
    for (int x = 0; x < largestNumInA; x++) {
        if (solutionSet[x] == 1) {
            c[k] = x;
            printf ("c[%d]=%d\n", k, x);
            k++;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39071321_39071839_5_35
39071321_39072171_5_31
Title: Stop a for loop when user is finished entering input in c 
----------------------------------------

int main (void) {
    printf ("\n Welcome! \n\n Please enter each data point. Enter 'done' when finished.\n\n");
    double data [NUM_OF_DATA];
    int i;
    char str [5] = {0};
    for (i = 0; i < NUM_OF_DATA; i++) {
        printf ("Data[%i]: ", i);
        if (1 == scanf ("%lf", &data[i]))
            continue;
        scanf ("%4s", str);
        if (strcmp (str, "done") == 0) {
            break;
        }
        while (getchar () != '\n')
            ;
        i--;
    }
    printf ("%d numbers were entered.\n", i);
    return 0;
}
----------------------------------------

int main (void) {
    double data [MAXD] = {0};
    int i, count = 0;
    printf ("\n Welcome! \n\n Please enter each data point. " "Enter 'done' when finished.\n\n");
    for (;;) {
        double tmp;
        printf (" data[%4d]: ", count);
        if (count < MAXD && scanf (" %lf", &tmp) == 1)
            data[count++] = tmp;
        else
            break;
    }
    printf ("\n %d values entered:\n\n", count);
    for (i = 0; i < count; i++)
        printf ("  data[%4d] : %.2lf\n", i, data[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39097295_39097372_4_26
39097295_39097704_7_47
Title: C array pointer segmentation fault 
----------------------------------------

int main () {
    char actualstring [100];
    char (*string) [100] = &actualstring, i = 0, j = 0;
    char actualodd [100];
    char (*odd) [100] = &actualodd;
    fgets (* string, 100, stdin);
    (*string)[strlen (*string) - 1] = '\0';
    while ((*string)[i] != '\0') {
        if (i % 2 == 0) {
            (*odd)[j++] = (*string)[i];
        }
        i++;
    }
    (*odd)[j] = '\0';
    printf ("Characters at odd position: %s\n", * odd);
    return 0;
}
----------------------------------------

int main () {
    char *string;
    char i, j;
    char *odd;
    string = malloc (sizeof (char) * SIZEOF_BUFFER);
    if (string == NULL) {
        exit (- 1);
    }
    odd = malloc (sizeof (char) * SIZEOF_BUFFER);
    if (od == NULL) {
        free (string);
        exit (- 1);
    }
    i = j = 0;
    fgets (string, SIZEOF_BUFFER, stdin);
    while (string[i] != '\0') {
        if (i % 2 == 0) {
            odd[j++] = string[i];
        }
        i++;
    }
    odd[j] = '\0';
    printf ("Characters at odd position: %s\n", odd);
    free (odd);
    free (string);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39124910_39125570_5_14
39124910_39125714_5_25
Title: Free 2d array of char with realloc 
----------------------------------------

int main (void) {
    char *p = malloc (10 * sizeof (char));
    printf ("%p\n", (void *) p);
    strcpy (p, "aaaa");
    printf ("%p\n", (void *) p);
    printf ("%s\n", p);
    free (p);
    return 1;
}
----------------------------------------

int main () {
    char **TwodArray = NULL;
    int k = 0;
    int j = 0;
    do {
        k++;
        for (int i = 0; i < 10; i++) {
            j++;
            TwodArray = (char **) realloc (TwodArray, (j + 1) * 10 * sizeof (char *));
            TwodArray[j - 1] = strndup ("abcdefgh", 8);
        }
    }
    while (k < 3);
    for (int l = 0; l < j; l++) {
        if (TwodArray[l] != NULL)
            free (TwodArray[l]);
    }
    free (TwodArray);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39142074_39142160_1_15
39142074_39142186_1_14
Title: dynamically allocated string populated with characters results in empty string C 
----------------------------------------

int main () {
    char *c = (char *) malloc (4 * sizeof (char));
    char *temp = c;
    *c = 'a';
    c++;
    *c = 'b';
    c++;
    *c = 'c';
    c++;
    *c = '\0';
    printf ("%s", c);
    printf ("%s,temp");
    free (temp);
    return 0;
}
----------------------------------------

int main () {
    char *p = (char *) malloc (4 * sizeof (char));
    char *c = p;
    *c = 'a';
    c++;
    *c = 'b';
    c++;
    *c = 'c';
    c++;
    *c = '\0';
    printf ("%s", p);
    free (p);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39167115_39168042_4_38
39167115_39176386_6_65
Title: how to split words in a string in c? 
----------------------------------------

int main () {
    char st [100] = "here we go again";
    int start [30] = {0};
    int end [30] = {0};
    int count = 0;
    int len = strlen (st);
    int i, j;
    start[0] = 0;
    for (i = 0; i < len; ++i) {
        if (st[i] == ' ') {
            end[count] = i;
            ++count;
            start[count] = i + 1;
        }
    }
    end[count] = len;
    for (i = count; i >= 0; --i) {
        for (j = start[i]; j < end[i]; ++j) {
            printf ("%c", st [j]);
        }
        printf (" ");
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    int i, j, n, word;
    char st [100], arr [100], mat [MAX_LEN / 2] [MAX_LEN + 1];
    printf ("Please, enter your sentence (up to %d chars and A-Z or space)\n>", MAX_LEN);
    fflush (stdout);
    scanf ("%99[^\n]%*c", st);
    for (j = i = 0; st[i]; ++i) {
        if (i > MAX_LEN) {
            fputs ("ERROR: Incorrect data, try again.\n", stderr);
            return 1;
        }
        if ('A' <= st[i] && st[i] <= 'Z') {
            arr[j++] = st[i];
        }
        else if (st[i] == ' ') {
            arr[j++] = ' ';
            while (st[++i] == ' ')
                ;
            --i;
        }
        else {
            fputs ("ERROR: Incorrect data, try again.\n", stderr);
            return 1;
        }
    }
    arr[j] = '\0';
    for (word = j = i = 0; arr[i];) {
        while (arr[i] == ' ')
            ++i;
        while (arr[i] != ' ' && arr[i] != '\0')
            mat[word][j++] = arr[i++];
        mat[word++][j] = '\0';
        j = 0;
    }
    puts ("reverse word");
    for (i = 0; i < word; ++i) {
        if (i)
            putchar (' ');
        printf ("%s", mat [word - 1 - i]);
    }
    puts ("\nrotate word");
    printf ("Please, enter number of rotate\n>");
    fflush (stdout);
    scanf ("%d", & n);
    for (i = 0; i < word; ++i) {
        if (i)
            putchar (' ');
        printf ("%s", mat [(i + n) % word]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39184825_39184939_20_36
39184825_39185533_1_38
Title: "Adding string to array pointer being realloc'd was not allocated" 
----------------------------------------

char **add_string (char **array, const char *string) {
    char **cache = array;
    unsigned int size = 0;
    while (*array) {
        size++;
        array++;
    }
    char **newarr = (char **) realloc (cache, sizeof (char *) * (size + 2));
    newarr[size] = malloc (strlen (string) +1);
    strcpy (newarr [size], string);
    newarr[size + 1] = NULL;
    return newarr;
}
----------------------------------------

char **add_string (char **array, const char *string) {
    char **newarr;
    size_t size = 0;
    assert (NULL != string);
    if (NULL != array) {
        while (NULL != array[size]) {
            ++size;
        }
    }
    newarr = realloc (array, (size + 2) * sizeof *newarr);
    if (NULL == newarr) {
        perror ("realloc() failed");
        return NULL;
    }
    newarr[size] = malloc (strlen (string) +1);
    if (NULL == newarr[size]) {
        perror ("malloc() failed");
    }
    else {
        strcpy (newarr [size], string);
    }
    newarr[size + 1] = NULL;
    return newarr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39186168_39186310_5_22
39186168_39189841_10_50
Title: strtok() then strcmp() returning false when true 
----------------------------------------

int main () {
    char *input = (char *) malloc (32 * sizeof (char));
    char *command = (char *) malloc (8 * sizeof (char));
    while (strcmp (command, "q") != 0) {
        memset (input, 0, sizeof (input));
        printf ("Enter command: ");
        fgets (input, 64, stdin);
        command = strtok (input, " \n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int result = EXIT_SUCCESS;
    char *input = malloc (INPUT_BUFFER_SIZE * sizeof *input);
    if (NULL == input) {
        perror ("malloc () failed");
        result = EXIT_FAILURE;
    }
    else {
        char *command;
        do {
            printf ("Enter command:\n");
            if (NULL == fgets (input, INPUT_BUFFER_SIZE, stdin)) {
                if (!feof (stdin)) {
                    result = EXIT_FAILURE;
                    fprintf (stderr, "fgets() failed.\n");
                }
                break;
            }
            command = strtok (input, " \n");
        }
        while ((command == NULL) || strcmp (command, QUIT_STRING) != 0);
        if (NULL != command) {
            printf ("User quit.\n");
        }
        free (input);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39188634_39188719_2_19
39188634_39191180_8_22
Title: Having problems with creating menu in C using do..while and if..else statement 
----------------------------------------

int main () {
    int choice;
    printf ("Menu:\n\n");
    printf ("1) Choice 1.\n");
    printf ("2) Choice 2.\n");
    printf ("2) Choice 3.\n");
    printf ("Choose any of the above, or enter 4 to quit.\n\n");
    while (1) {
        char c = scanf ("%d", &choice);
        if (c == EOF || choice == 4)
            break;
        if (choice == 1 || choice == 2 || choice == 3) {
            printf ("Choice %d.\n", choice);
        }
        else {
            printf ("Invalid character.\n");
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    int ch;
    for (;;) {
        switch (ch = menu ()) {
        case '1' :
            choice1 ();
            continue;
        case '2' :
            choice2 ();
            continue;
        case '3' :
            choice3 ();
            continue;
        case '4' :
        case EOF :
            break;
        default :
            printf ("Invalid character %c\n", ch);
            continue;
        }
        break;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39188634_39188967_10_22
39188634_39191180_24_36
Title: Having problems with creating menu in C using do..while and if..else statement 
----------------------------------------

char menu (void) {
    char choice;
    printf ("\nMenu:\n\n");
    printf ("1) Choice 1.\n");
    printf ("2) Choice 2.\n");
    printf ("3) Choice 3.\n");
    printf ("Choose any of the above, or enter 4 to quit.\n\n");
    if (scanf ("%c", &choice) != 1)
        exit (1);
    return choice;
}
----------------------------------------

int menu (void) {
    char choice;
    printf ("\nMenu:\n\n");
    printf ("1) Choice 1.\n");
    printf ("2) Choice 2.\n");
    printf ("3) Choice 3.\n");
    printf ("Choose any of the above, or enter 4 to quit.\n\n");
    if (scanf (" %c", &choice) == 1)
        return choice;
    else
        return EOF;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39189661_39189860_2_13
39189661_39190844_4_16
Title: Character Count in C 
----------------------------------------

int main () {
    int nc = 0;
    for (;;) {
        do
            ++nc;
        while (getchar () != '\n');
        printf ("Character count is:%d\n", nc - 1);
        nc = 0;
    }
}
----------------------------------------

int main () {
    int nc = 0;
    int ch;
    while ((ch = getchar ()) != EOF) {
        if (isprint (ch) && ch != ' ')
            ++nc;
        printf ("Character count after reading '%c' is %d.\n", ch, nc);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3919009_3919126_6_18
3919009_3919185_7_21
Title: How to read from stdin with fgets()? 
----------------------------------------

int main () {
    char *text = calloc (1, 1), buffer [BUFFERSIZE];
    printf ("Enter a message: \n");
    while (fgets (buffer, BUFFERSIZE, stdin)) {
        text = realloc (text, strlen (text) +1 + strlen (buffer));
        if (! text)...strcat (text, buffer);
        printf ("%s\n", buffer);
    }
    printf ("\ntext:\n%s", text);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char buffer [BUFFERSIZE];
    char * big_buffer = new char [BIG_BUFFERSIZE];
    big_buffer[0] = '\0';
    printf ("Enter a message: \n");
    while (fgets (buffer, BUFFERSIZE, stdin) != NULL) {
        if ((strlen (big_buffer) + strlen (buffer)) < BIG_BUFFERSIZE) {
            strcat (big_buffer, buffer);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3919009_3919126_6_18
3919009_39261885_19_123
Title: How to read from stdin with fgets()? 
----------------------------------------

int main () {
    char *text = calloc (1, 1), buffer [BUFFERSIZE];
    printf ("Enter a message: \n");
    while (fgets (buffer, BUFFERSIZE, stdin)) {
        text = realloc (text, strlen (text) +1 + strlen (buffer));
        if (! text)...strcat (text, buffer);
        printf ("%s\n", buffer);
    }
    printf ("\ntext:\n%s", text);
    return 0;
}
----------------------------------------

int main (void) {
    char acBuffer [BUFFERSIZE] = {0};
    LpNode_t lpNode = (LpNode_t) malloc (sizeof (Node_t));
    assert (lpNode != NULL);
    LpNode_t lpHeadNode = lpNode;
    char *lpBuffer = (char *) calloc (1, sizeof (char));
    assert (lpBuffer != NULL);
    char cChar;
    printf ("Enter a message: \n");
    while (true) {
        assert (fgets (acBuffer, BUFFERSIZE, stdin) != NULL);
        lpNode->lpBuffer = (char *) malloc ((strlen (acBuffer) + 1) * sizeof (char));
        assert (lpNode -> lpBuffer != NULL);
        strcpy (lpNode -> lpBuffer, acBuffer);
        if (acBuffer[strlen (acBuffer) - 1] == '\n')
            lpNode->lpBuffer[strlen (acBuffer) - 1] = '\0';
        if (strlen (acBuffer) == (BUFFERSIZE - 1) && (acBuffer[strlen (acBuffer) - 1] != '\n')) {
            cChar = fgetc (stdin);
            if (cChar != '\n')
                ungetc (cChar, stdin);
        }
        if (acBuffer[0] == '\n') {
            lpNode->LpProxNode = NULL;
            break;
        }
        lpNode->LpProxNode = (LpNode_t) malloc (sizeof (Node_t));
        lpNode = lpNode->LpProxNode;
        assert (lpNode != NULL);
    }
    printf ("\nPseudo String :\n");
    lpNode = lpHeadNode;
    while (lpNode != NULL) {
        printf ("%s", lpNode -> lpBuffer);
        lpNode = lpNode->LpProxNode;
    }
    printf ("\n\nMemory blocks:\n");
    lpNode = lpHeadNode;
    while (lpNode != NULL) {
        printf ("Block \"%7s\" size = %lu\n", lpNode -> lpBuffer, (long unsigned) (strlen (lpNode -> lpBuffer) + 1));
        lpNode = lpNode->LpProxNode;
    }
    printf ("\nConcatenated string:\n");
    lpNode = lpHeadNode;
    while (lpNode != NULL) {
        lpBuffer = (char *) realloc (lpBuffer, (strlen (lpBuffer) + strlen (lpNode->lpBuffer)) + 1);
        strcat (lpBuffer, lpNode -> lpBuffer);
        lpNode = lpNode->LpProxNode;
    }
    printf ("%s", lpBuffer);
    printf ("\n\n");
    lpNode = lpHeadNode;
    while (lpNode != NULL) {
        lpHeadNode = lpNode->LpProxNode;
        free (lpNode -> lpBuffer);
        free (lpNode);
        lpNode = lpHeadNode;
    }
    lpBuffer = (char *) realloc (lpBuffer, 0);
    lpBuffer = NULL;
    if ((lpNode == NULL) && (lpBuffer == NULL)) {
        printf ("Deallocate memory = %s", (char *) lpNode);
    }
    printf ("\n\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3919009_3919185_7_21
3919009_39261885_19_123
Title: How to read from stdin with fgets()? 
----------------------------------------

int main (int argc, char *argv []) {
    char buffer [BUFFERSIZE];
    char * big_buffer = new char [BIG_BUFFERSIZE];
    big_buffer[0] = '\0';
    printf ("Enter a message: \n");
    while (fgets (buffer, BUFFERSIZE, stdin) != NULL) {
        if ((strlen (big_buffer) + strlen (buffer)) < BIG_BUFFERSIZE) {
            strcat (big_buffer, buffer);
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char acBuffer [BUFFERSIZE] = {0};
    LpNode_t lpNode = (LpNode_t) malloc (sizeof (Node_t));
    assert (lpNode != NULL);
    LpNode_t lpHeadNode = lpNode;
    char *lpBuffer = (char *) calloc (1, sizeof (char));
    assert (lpBuffer != NULL);
    char cChar;
    printf ("Enter a message: \n");
    while (true) {
        assert (fgets (acBuffer, BUFFERSIZE, stdin) != NULL);
        lpNode->lpBuffer = (char *) malloc ((strlen (acBuffer) + 1) * sizeof (char));
        assert (lpNode -> lpBuffer != NULL);
        strcpy (lpNode -> lpBuffer, acBuffer);
        if (acBuffer[strlen (acBuffer) - 1] == '\n')
            lpNode->lpBuffer[strlen (acBuffer) - 1] = '\0';
        if (strlen (acBuffer) == (BUFFERSIZE - 1) && (acBuffer[strlen (acBuffer) - 1] != '\n')) {
            cChar = fgetc (stdin);
            if (cChar != '\n')
                ungetc (cChar, stdin);
        }
        if (acBuffer[0] == '\n') {
            lpNode->LpProxNode = NULL;
            break;
        }
        lpNode->LpProxNode = (LpNode_t) malloc (sizeof (Node_t));
        lpNode = lpNode->LpProxNode;
        assert (lpNode != NULL);
    }
    printf ("\nPseudo String :\n");
    lpNode = lpHeadNode;
    while (lpNode != NULL) {
        printf ("%s", lpNode -> lpBuffer);
        lpNode = lpNode->LpProxNode;
    }
    printf ("\n\nMemory blocks:\n");
    lpNode = lpHeadNode;
    while (lpNode != NULL) {
        printf ("Block \"%7s\" size = %lu\n", lpNode -> lpBuffer, (long unsigned) (strlen (lpNode -> lpBuffer) + 1));
        lpNode = lpNode->LpProxNode;
    }
    printf ("\nConcatenated string:\n");
    lpNode = lpHeadNode;
    while (lpNode != NULL) {
        lpBuffer = (char *) realloc (lpBuffer, (strlen (lpBuffer) + strlen (lpNode->lpBuffer)) + 1);
        strcat (lpBuffer, lpNode -> lpBuffer);
        lpNode = lpNode->LpProxNode;
    }
    printf ("%s", lpBuffer);
    printf ("\n\n");
    lpNode = lpHeadNode;
    while (lpNode != NULL) {
        lpHeadNode = lpNode->LpProxNode;
        free (lpNode -> lpBuffer);
        free (lpNode);
        lpNode = lpHeadNode;
    }
    lpBuffer = (char *) realloc (lpBuffer, 0);
    lpBuffer = NULL;
    if ((lpNode == NULL) && (lpBuffer == NULL)) {
        printf ("Deallocate memory = %s", (char *) lpNode);
    }
    printf ("\n\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39211047_39211320_2_22
39211047_39211517_1_24
Title: Convert code from C++ to C: `a+b > b+a` where a and b are `string` 
----------------------------------------

int compare (const char *a, const char *b) {
    int a_len = strlen (a), b_len = strlen (b);
    int min_len = (a_len < b_len) ? a_len : b_len;
    int result = strncmp (a, b, min_len);
    if (result != 0)
        return result;
    if (a_len == b_len)
        return 0;
    if (a_len < b_len)
        result = strncmp (b, b +a_len, b_len -a_len);
    else
        result = strncmp (a +b_len, a, a_len -b_len);
    if (result != 0)
        return result;
    if (a_len < b_len)
        result = strncmp (b +(b_len - a_len), a, a_len);
    else
        result = strncmp (b, a +(a_len - b_len), b_len);
    return result;
}
----------------------------------------

int compare (char *a, char *b) {
    char *p1, *p2;
    int i, len = strlen (a) + strlen (b);
    p1 = a;
    p2 = b;
    for (i = 0; i < len; i++) {
        if (*p1 > *p2) {
            return 1;
        }
        else if (*p1 < *p2) {
            return -1;
        }
        p1++;
        p2++;
        if (!*p1) {
            p1 = b;
        }
        if (!*p2) {
            p2 = a;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39218049_39218532_3_14
39218049_39218661_3_21
Title: Space isn't replaced 
----------------------------------------

int main (void) {
    int c;
    int oldc = 'a';
    while ((c = getchar ()) != EOF) {
        if (oldc != ' ' || c != ' ')
            putchar (c);
        oldc = c;
    }
}
----------------------------------------

int main (void) {
    int c;
    c = getchar ();
    while (c != EOF) {
        putchar (c);
        if (c == ' ') {
            do {
                c = getchar ();
            }
            while (c == ' ');
        }
        else
            c = getchar ();
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39245576_39245697_1_20
39245576_39245731_1_12
Title: Find frequency of digits in an int array in C 
----------------------------------------

void freq (int size, int numArray []) {
    int one = 0, two = 0, thr = 0;
    int i;
    for (i = 0; i < size; i++) {
        if (numArray[i] == 1) {
            one += 1;
        }
        else if (numArray[i] == 2) {
            two += 1;
        }
        else if (numArray[i] == 3) {
            thr += 1;
        }
    }
    printf ("1 occurs %d times.\n", one);
    printf ("2 occurs %d times.\n", two);
    printf ("3 occurs %d times.\n", thr);
}
----------------------------------------

void freq (int size, const int *numbers) {
    unsigned int counts [10] = {0};
    for (int i = 0; i < size; ++i) {
        const int here = numbers[i];
        if (here >= 1 && here <= 9)
            counts[here]++;
    }
    for (int i = 1; i < 10; ++i)
        printf ("%d occurs %u times\n", i, counts[i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39267129_39267840_7_20
39267129_39271223_5_31
Title: How to read space-separated 0-9 digits in C? 
----------------------------------------

int main (void) {
    for (int c1 = 0, c2 = 0; c1 != EOF && c2 != EOF;) {
        c1 = getchar ();
        if (c1 == EOF || c1 == '\n')
            continue;
        if (!isdigit (c1))
            e ();
        c2 = getchar ();
        if (c2 != EOF && c2 != '\n' && c2 != ' ')
            e ();
        printf ("Got input: '%c'.\n", c1);
    }
}
----------------------------------------

int main (void) {
    int inputArr [999];
    int c = 0;
    int length = 0;
    int gotdigit = 0;
    while ((c = getchar ()) != '\n' && c != EOF) {
        if (isdigit (c) && !gotdigit) {
            inputArr[length] = c - '0';
            length++;
            if (length >= 999) {
                break;
            }
            gotdigit = 1;
        }
        else {
            if (c == ' ') {
                gotdigit = 0;
            }
            else {
                printf ("Wrong Input Format!\n");
            }
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39271482_39271540_1_10
39271482_39271548_1_10
Title: Getting issues for redefinition of functions 
----------------------------------------

void getMatrix (double B [N] [N]) {
    int i;
    for (i = 0; i <= N; i++) {
        for (i = 0; i < N; i++) {
            scanf ("%lf", & B [N] [N]);
        }
    }
    return;
}
----------------------------------------

void getMatrix (double B [N] [N]) {
    int i;
    for (i = 0; i <= N; i++) {
        for (i = 0; i < N; i++) {
            scanf ("%lf", & B [N] [N]);
        }
    }
    return;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39271815_39272827_17_43
39271815_39279097_14_127
Title: Reading tab separated file using getchar() 
----------------------------------------

int main (void) {
    struct record records [ROWS];
    for (size_t i = 0; i < ROWS; i++) {
        if (scanf (" %" MAX_CH "[^\t] %" MAX_CH "[^\t] %" MAX_CH "[^\t] %" MAX_CH "[^\n]", records[i].country, records[i].sport, records[i].gender, records[i].medal) == 4) {
            printf ("%s %s %s %s\n", records [i].country, records [i].sport, records [i].gender, records [i].medal);
        }
        else {
            break;
        }
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char records [ROWS] [COLS] [MAX_CH] = {{{'\0'}}};
    char item [MAX_CH] = {'\0'};
    int row = 0;
    int col = 0;
    int usedcol = 0;
    int sortby [COLS] = {0};
    int ch = 0;
    int each = 0;
    int loop = 0;
    int result = 0;
    if (argc < 2 || argc > COLS + 1) {
        fprintf (stderr, "syntax is\n%s column0 [column1]...[column%d] < inputfile\n", argv [0], COLS - 1);
        exit (EXIT_FAILURE);
    }
    for (each = 1; each <= COLS + 1; each++) {
        sortby[each - 1] = -1;
        if (each < argc) {
            if ((result = sscanf (argv[each], "%d", &sortby[each - 1])) != 1 || sortby[each - 1] < 0 || sortby[each - 1] >= COLS) {
                fprintf (stderr, "syntax is\n%s column0 [column1]...[column%d] < inputfile\n", argv [0], COLS - 1);
                fprintf (stderr, "column%d must be 0 to %d\n", each - 1, COLS - 1);
                exit (EXIT_FAILURE);
            }
        }
    }
    for (each = 0; each < argc - 1; each++) {
        for (loop = 0; loop < argc - 1; loop++) {
            if (loop != each && sortby[each] == sortby[loop]) {
                fprintf (stderr, "found duplicate columns in args\n");
                exit (EXIT_FAILURE);
            }
        }
    }
    if (isatty (fileno (stdin))) {
        printf ("expected that a file would be redirected to this program\n");
        printf ("syntax is\n%s column0 [column1]...[column%d] < inputfile\n", argv [0], COLS - 1);
        exit (EXIT_FAILURE);
    }
    row = 0;
    col = 0;
    each = 0;
    while ((ch = getchar ()) != EOF) {
        if (ch == '\r') {
            continue;
        }
        if (ch == '\t') {
            strcpy (records [row] [col], item);
            each = 0;
            col++;
            if (col >= COLS) {
                col = 0;
                row++;
                if (row >= ROWS) {
                    fprintf (stderr, "too many rows\n");
                    break;
                }
            }
            continue;
        }
        if (ch == '\n') {
            strcpy (records [row] [col], item);
            col++;
            if (col > usedcol) {
                usedcol = col;
            }
            col = 0;
            each = 0;
            row++;
            if (row >= ROWS) {
                fprintf (stderr, "too many rows\n");
                break;
            }
            continue;
        }
        item[each] = ch;
        each++;
        item[each] = '\0';
        if (each >= MAX_CH - 1) {
            fprintf (stderr, "too many characters in item\n");
            each = 0;
            col++;
            if (col >= COLS) {
                col = 0;
                row++;
                if (row >= ROWS) {
                    fprintf (stderr, "too many rows\n");
                    break;
                }
            }
            continue;
        }
    }
    print_array (records, row, usedcol, sortby, 0);
    sort_array (records, row, usedcol, sortby);
    print_array (records, row, usedcol, sortby, 1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3929282_14466245_2_27
3929282_3929345_4_25
Title: Palindrome in C without pointers and recursion 
----------------------------------------

void main () {
    char a [50], b [50];
    int i = 0, j, ele, test = 0, x;
    while ((a[i] = getchar ()) != '\n') {
        if (a[i] != ' ' && a[i] != ',')
            i++;
    }
    a[i] = '\0';
    ele = strlen (a);
    for (i = 0; i < ele; i++)
        if (a[i] >= 'A' && a[i] <= 'Z')
            a[i] = a[i] + ('a' - 'A');
    x = ele - 1;
    for (j = 0; j < ele; j++) {
        b[j] = a[x];
        x--;
    }
    for (i = 0; i < ele; i++)
        if (a[i] == b[i])
            test++;
    if (test == ele)
        printf ("You entered a palindrome!");
    else
        printf ("That's not a palindrome!");
}
----------------------------------------

int main () {
    int i, j, length;
    char space = ' ';
    char phrase [80];
    printf ("Give me the phrase: ");
    gets (phrase);
    length = strlen (phrase);
    for (i = 0, j = length - 1; i < j; i++, j--) {
        while (phrase[i] == space)
            i++;
        while (phrase[j] == space)
            j--;
        if (phrase[i] != phrase[j]) {
            printf ("It's not a palindrome\n");
            return 0;
        }
    }
    printf ("It's a palindrome\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3929282_14466245_2_27
3929282_3929505_4_33
Title: Palindrome in C without pointers and recursion 
----------------------------------------

void main () {
    char a [50], b [50];
    int i = 0, j, ele, test = 0, x;
    while ((a[i] = getchar ()) != '\n') {
        if (a[i] != ' ' && a[i] != ',')
            i++;
    }
    a[i] = '\0';
    ele = strlen (a);
    for (i = 0; i < ele; i++)
        if (a[i] >= 'A' && a[i] <= 'Z')
            a[i] = a[i] + ('a' - 'A');
    x = ele - 1;
    for (j = 0; j < ele; j++) {
        b[j] = a[x];
        x--;
    }
    for (i = 0; i < ele; i++)
        if (a[i] == b[i])
            test++;
    if (test == ele)
        printf ("You entered a palindrome!");
    else
        printf ("That's not a palindrome!");
}
----------------------------------------

int main () {
    int i, j, length, halfLength;
    char space = ' ';
    char phrase1 [80], phrase2 [80];
    printf ("Give me the phrase: ");
    gets (phrase1);
    length = strlen (phrase1);
    for (i = 0, j = 0; i <= length; ++i) {
        if (phrase1[i] != space) {
            phrase2[j++] = phrase1[i];
        }
    }
    length = strlen (phrase2);
    halfLength = length / 2;
    for (i = 0, j = length - 1; i < halfLength; ++i, --j) {
        if (phrase2[i] != phrase2[j]) {
            printf ("It's not a palindrome\n");
            return 0;
        }
    }
    printf ("It's a palindrome\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3929282_3929345_4_25
3929282_3929505_4_33
Title: Palindrome in C without pointers and recursion 
----------------------------------------

int main () {
    int i, j, length;
    char space = ' ';
    char phrase [80];
    printf ("Give me the phrase: ");
    gets (phrase);
    length = strlen (phrase);
    for (i = 0, j = length - 1; i < j; i++, j--) {
        while (phrase[i] == space)
            i++;
        while (phrase[j] == space)
            j--;
        if (phrase[i] != phrase[j]) {
            printf ("It's not a palindrome\n");
            return 0;
        }
    }
    printf ("It's a palindrome\n");
    return 0;
}
----------------------------------------

int main () {
    int i, j, length, halfLength;
    char space = ' ';
    char phrase1 [80], phrase2 [80];
    printf ("Give me the phrase: ");
    gets (phrase1);
    length = strlen (phrase1);
    for (i = 0, j = 0; i <= length; ++i) {
        if (phrase1[i] != space) {
            phrase2[j++] = phrase1[i];
        }
    }
    length = strlen (phrase2);
    halfLength = length / 2;
    for (i = 0, j = length - 1; i < halfLength; ++i, --j) {
        if (phrase2[i] != phrase2[j]) {
            printf ("It's not a palindrome\n");
            return 0;
        }
    }
    printf ("It's a palindrome\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39300434_39300918_6_38
39300434_39300921_1_23
Title: Xor encryptor new line issue 
----------------------------------------

static void xorInput (char *in_name, char *out_name) {
    FILE *fp1 = fopen (in_name, "rb");
    if (fp1 == NULL) {
        fprintf (stderr, "failed to opn file %s for reading\n", in_name);
        exit (1);
    }
    FILE *fp2 = fopen (out_name, "wb");
    if (fp2 == NULL) {
        fprintf (stderr, "failed to open file %s for writing\n", out_name);
        exit (1);
    }
    char buffer [1024];
    size_t nbytes;
    while ((nbytes = fread (buffer, 1, sizeof (buffer), fp1)) > 0) {
        for (size_t i = 0; i < nbytes; ++i)
            buffer[i] ^= Xor_key;
        if (fwrite (buffer, 1, nbytes, fp2) != nbytes) {
            fprintf (stderr, "failed to write %zu bytes to %s\n", nbytes, out_name);
            exit (1);
        }
    }
    fclose (fp1);
    fclose (fp2);
}
----------------------------------------

void xorInput (const char *in, const char *o) {
    FILE *fp = fopen (in, "rb");
    if (fp == NULL) {
        printf ("file '%s' isn't here...\n", in);
        exit (1);
    }
    FILE *fp2 = fopen (o, "wb");
    if (fp2 == NULL) {
        fclose (in);
        printf ("file '%s' isn't here...\n", o);
        exit (1);
    }
    int ch;
    while ((ch = fgetc (fp)) != EOF) {
        ch ^= Xor_key;
        fputc (ch, fp2);
    }
    fclose (fp);
    fclose (fp2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39300744_39300859_1_18
39300744_39301001_3_37
Title: How to pass a struct by value to a pthread? 
----------------------------------------

int main (int argc, char *argv []) {
    int N = atoi (argv[1]);
    pthread_t *thread = malloc (N * sizeof (pthread_t));
    for (int i = 0; i < N; i++) {
        struct thread_arg arg;
        arg.value1 = i;
        arg.value2 = 'f';
        arg.value3 = i / 10.0;
        struct thread_arg *p = malloc (sizeof *p);
        *p = arg;
        pthread_create (& thread [i], NULL, foo, p);
    }
    free (thread);
    pthread_exit (NULL);
}
----------------------------------------

int main (int argc, char *argv []) {
    int N;
    if (argc < 2) {
        exit (1);
    }
    N = atoi (argv[1]);
    if (N < 0 || N > THREAD_LIMIT) {
        exit (1);
    }
    struct thread_arg args [N];
    pthread_t threads [N];
    for (int i = 0; i < N; i++) {
        args[i].value1 = i;
        args[i].value2 = 'f';
        args[i].value3 = i / 10;
        if (pthread_create (&threads[i], NULL, foo, &args[i])) {
        }
    }
    for (int i = 0; i < N; i++) {
        pthread_join (threads [i], NULL);
    }
    pthread_exit (NULL);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39300744_39300859_1_18
39300744_39301595_21_44
Title: How to pass a struct by value to a pthread? 
----------------------------------------

int main (int argc, char *argv []) {
    int N = atoi (argv[1]);
    pthread_t *thread = malloc (N * sizeof (pthread_t));
    for (int i = 0; i < N; i++) {
        struct thread_arg arg;
        arg.value1 = i;
        arg.value2 = 'f';
        arg.value3 = i / 10.0;
        struct thread_arg *p = malloc (sizeof *p);
        *p = arg;
        pthread_create (& thread [i], NULL, foo, p);
    }
    free (thread);
    pthread_exit (NULL);
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc < 2)
        fprintf (stderr, "Error: Provide N\n\n"), exit (1);
    int N = atoi (argv[1]);
    if (N < 0 || N > UINT16_MAX)
        fprintf (stderr, "Error: N should be 0-%u\n\n", UINT16_MAX), exit (1);
    pthread_t *thread = malloc (N * sizeof (pthread_t));
    union thread_arg thread_arg;
    for (int i = 0; i < N; i++) {
        thread_arg.data.value1 = (uint16_t) i;
        thread_arg.data.value2 = 'f';
        thread_arg.data.value3 = (uint16_t) i;
        if (pthread_create (thread +i, NULL, foo, thread_arg.to_arg))
            fprintf (stderr, "Couldn't initiate thread no. %i\n", N), exit (1);
    }
    for (int i = 0; i < N; i++)
        pthread_join (thread[i], NULL);
    free (thread);
    pthread_exit (NULL);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39300744_39301001_3_37
39300744_39301595_21_44
Title: How to pass a struct by value to a pthread? 
----------------------------------------

int main (int argc, char *argv []) {
    int N;
    if (argc < 2) {
        exit (1);
    }
    N = atoi (argv[1]);
    if (N < 0 || N > THREAD_LIMIT) {
        exit (1);
    }
    struct thread_arg args [N];
    pthread_t threads [N];
    for (int i = 0; i < N; i++) {
        args[i].value1 = i;
        args[i].value2 = 'f';
        args[i].value3 = i / 10;
        if (pthread_create (&threads[i], NULL, foo, &args[i])) {
        }
    }
    for (int i = 0; i < N; i++) {
        pthread_join (threads [i], NULL);
    }
    pthread_exit (NULL);
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc < 2)
        fprintf (stderr, "Error: Provide N\n\n"), exit (1);
    int N = atoi (argv[1]);
    if (N < 0 || N > UINT16_MAX)
        fprintf (stderr, "Error: N should be 0-%u\n\n", UINT16_MAX), exit (1);
    pthread_t *thread = malloc (N * sizeof (pthread_t));
    union thread_arg thread_arg;
    for (int i = 0; i < N; i++) {
        thread_arg.data.value1 = (uint16_t) i;
        thread_arg.data.value2 = 'f';
        thread_arg.data.value3 = (uint16_t) i;
        if (pthread_create (thread +i, NULL, foo, thread_arg.to_arg))
            fprintf (stderr, "Couldn't initiate thread no. %i\n", N), exit (1);
    }
    for (int i = 0; i < N; i++)
        pthread_join (thread[i], NULL);
    free (thread);
    pthread_exit (NULL);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
393248_393319_3_14
393248_840356_13_50
Title: Counting the number of occurrences of words in a textfile 
----------------------------------------

int main (int argc, char **argv) {
    char buffer [2048];
    if (argc != 2) {
        fprintf (stderr, "Usage: %s file\n", argv [0]);
        exit (EXIT_FAILURE);
    }
    snprintf (buffer, sizeof (buffer), "tr -cs '[a-z][A-Z]' '[\\n*]' < %s |" " sort | uniq -c | sort -n", argv [1]);
    return (system (buffer));
}
----------------------------------------

int main () {
    stdt boy;
    int a = 0;
    ofstream TextFile;
    cout << "Begin File Creation \n";
    TextFile.open ("F:\\C++ Book Chapter Program\\Ch  7\\File.txt");
    if (!TextFile) {
        cerr << "Erro 100 Openoing File.DAT";
        exit (100);
    }
    while (a < 3) {
        TextFile.write ((char *) &boy, sizeof (boy));
        cout << "\nEnter Name : ";
        cin >> boy.name;
        cout << "\nEnter ID : ";
        cin >> boy.id;
        a++;
    }
    TextFile.close ();
    cout << "\nEnd File Creation";
    ifstream TextFile1;
    TextFile1.open ("F:\\C++ Book Chapter Program\\Ch  7\\File.txt");
    while (TextFile1.read ((char *) &boy, sizeof (boy))) {
        cout << "\nEnter Name : " << boy.name;
        cout << "\nEnter ID : " << boy.id;
    }
    getch ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39355268_39355580_24_40
39355268_39355674_20_34
Title: C list->data doesnt show on terminal 
----------------------------------------

int main () {
    FILE *fr = fopen ("dat1.txt", "r");
    node list = (node) malloc (sizeof (struct list_node));
    list->next = NULL;
    int i;
    while ((i = fgetc (fr)) != EOF) {
        insert_right (list, i);
    }
    while (list != NULL) {
        printf ("%c", list -> data);
        list = list->next;
    }
}
----------------------------------------

int main () {
    FILE *fr = fopen ("dat1.txt", "r");
    node list = (node) malloc (sizeof (struct list_node));
    int i;
    node next = list;
    while ((i = fgetc (fr)) != EOF) {
        next = insert_right (next, i);
    }
    node print = list;
    while (print != NULL) {
        printf ("%c", print -> data);
        print = print->next;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39355268_39355580_24_40
39355268_39356100_9_34
Title: C list->data doesnt show on terminal 
----------------------------------------

int main () {
    FILE *fr = fopen ("dat1.txt", "r");
    node list = (node) malloc (sizeof (struct list_node));
    list->next = NULL;
    int i;
    while ((i = fgetc (fr)) != EOF) {
        insert_right (list, i);
    }
    while (list != NULL) {
        printf ("%c", list -> data);
        list = list->next;
    }
}
----------------------------------------

int main () {
    FILE *fr = fopen ("dat1.txt", "r");
    struct list_node *list = malloc (sizeof (*list)), *pos = list;
    int i;
    while ((i = fgetc (fr)) != EOF) {
        pos->data = i;
        pos->next = malloc (sizeof (*list->next));
        pos = pos->next;
    }
    pos->next = NULL;
    while (list->next) {
        printf ("%c ", list -> data);
        free (list);
        list = list->next;
    }
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39355268_39355674_20_34
39355268_39356100_9_34
Title: C list->data doesnt show on terminal 
----------------------------------------

int main () {
    FILE *fr = fopen ("dat1.txt", "r");
    node list = (node) malloc (sizeof (struct list_node));
    int i;
    node next = list;
    while ((i = fgetc (fr)) != EOF) {
        next = insert_right (next, i);
    }
    node print = list;
    while (print != NULL) {
        printf ("%c", print -> data);
        print = print->next;
    }
}
----------------------------------------

int main () {
    FILE *fr = fopen ("dat1.txt", "r");
    struct list_node *list = malloc (sizeof (*list)), *pos = list;
    int i;
    while ((i = fgetc (fr)) != EOF) {
        pos->data = i;
        pos->next = malloc (sizeof (*list->next));
        pos = pos->next;
    }
    pos->next = NULL;
    while (list->next) {
        printf ("%c ", list -> data);
        free (list);
        list = list->next;
    }
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39360552_39361307_9_33
39360552_39361526_1_33
Title: Wrote my code to look for a mode but gives me the largest number 
----------------------------------------

mode findmode (int *arr, int size) {
    mode x;
    x.self = arr[0];
    x.size = 1;
    int i;
    int count = 1;
    for (i = 1; i < size; i++) {
        if (arr[i - 1] == arr[i]) {
            count++;
        }
        else {
            count = 1;
        }
        if (count >= x.size) {
            x.self = arr[i];
            x.size = count;
        }
    }
    return x;
}
----------------------------------------

mode findmode (int *arr, int size) {
    mode x;
    int i = 0;
    int count = 1;
    x.size = 0;
    for (i = 0; i < size; i++) {
        if (i > 0) {
            if (arr[i] == arr[i - 1]) {
                ++count;
            }
            if (arr[i] != arr[i - 1]) {
                if (count > x.size) {
                    x.size = count;
                    x.self = arr[i - 1];
                }
                count = 0;
                ++count;
            }
        }
    }
    return x;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39373063_39373185_7_19
39373063_39373194_7_22
Title: Accidently creating gigantic file with write 
----------------------------------------

int main () {
    char swap_array [2];
    int test = creat ("TEST", 0751);
    close (test);
    test = open ("TEST", O_RDWR);
    write (test, "123456789101112131415", 21);
    lseek (test, - 2, SEEK_END);
    read (test, swap_array, 2);
    write (test, swap_array, 2);
    lseek (test, - 6, SEEK_CUR);
    write (test, "xx", 2);
    return 0;
}
----------------------------------------

int main (void) {
    char swap_array [2];
    int test = creat ("TEST", MODE_0751);
    close (test);
    test = open ("TEST", O_RDWR);
    write (test, "123456789101112131415", 21);
    lseek (test, - 2L, SEEK_END);
    read (test, swap_array, 2);
    write (test, swap_array, 2);
    lseek (test, - 6L, SEEK_CUR);
    write (test, "xx", 2);
    close (test);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39380364_39380615_6_18
39380364_39380940_6_47
Title: Input to array of strings won't show? 
----------------------------------------

int main () {
    int i;
    char *nums [SIZE] [4];
    for (i = 0; i < SIZE; i++) {
        scanf ("%3s", nums [i]);
        printf ("%.*s", 3, nums [i]);
    }
    return 0;
}
----------------------------------------

int main () {
    int res;
    int i = 0, m;
    double in, in1, in2;
    for (m = 0; m < MAXNUM; m++) {
        res = scanf ("%lf", &in);
        if (res != 1) {
            break;
        }
        else {
            switch (i) {
            case 0 :
                in1 = in;
                i++;
                break;
            case 1 :
                in2 = in;
                i++;
                break;
            case 2 :
                fprintf (stdout, "%f %f %f\n", in1, in2, in);
                i = 0;
                break;
            }
        }
    }
    if (i != 0) {
        if (i == 1) {
            fprintf (stdout, "%f\n", in1);
        }
        else {
            fprintf (stdout, "%f %f\n", in1, in2);
        }
    }
    exit (EXIT_SUCCESS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39382760_67_109
39382328_39382763_43_92
Title: Grouping array of Strings C 
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    struct country *countries = NULL;
    int nelements = sizeof (results) / sizeof (results[0]);
    int i;
    for (i = 0; i < nelements; i += 2) {
        struct country *pCountry = findCountry (countries, results[i]);
        if (!pCountry) {
            countries = addCountry (countries, results[i]);
            pCountry = countries;
        }
        struct city *pCity = findCity (pCountry->cities, results[i + 1]);
        if (!pCity) {
            pCountry->cities = addCity (pCountry->cities, results[i + 1]);
            pCity = pCountry->cities;
        }
        pCity->counter++;
    }
    struct country *pCountry = countries;
    while (pCountry != NULL) {
        printf ("%s\n", pCountry -> coutryName);
        struct city *pCity = pCountry->cities;
        while (pCity != NULL) {
            printf ("    %s %d\n", pCity -> cityName, pCity -> counter);
            pCity = pCity->next;
        }
        printf ("\n");
        pCountry = pCountry->next;
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements, i, j;
    nelements = sizeof (results) / sizeof (results[0]);
    const int records_size = nelements / 2;
    Record record [records_size];
    for (i = 0; i < records_size; i++) {
        for (j = 0; j < COUNTRY_LENGTH; j++)
            record[i].country[j] = 0;
        for (j = 0; j < MAX_SPORTS; j++)
            record[i].sports[j] = 0;
    }
    int country_index, records_count = 0;
    for (i = 0; i < nelements; ++i) {
        if (i % 2 == 0) {
            country_index = exists (results[i], record, records_size);
            if (country_index == -1) {
                country_index = records_count++;
                strcpy (record [country_index].country, results [i]);
            }
        }
        else {
            record[country_index].sports[find_sport_index (results[i])]++;
        }
    }
    for (i = 0; i < records_size; ++i) {
        if (strlen (record[i].country)) {
            printf ("%s\n", record [i].country);
            for (j = 0; j < MAX_SPORTS; j++) {
                if (record[i].sports[j] != 0) {
                    printf ("    %s %d\n", find_sport_string (j), record [i].sports [j]);
                }
            }
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39382760_67_109
39382328_39383149_5_55
Title: Grouping array of Strings C 
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    struct country *countries = NULL;
    int nelements = sizeof (results) / sizeof (results[0]);
    int i;
    for (i = 0; i < nelements; i += 2) {
        struct country *pCountry = findCountry (countries, results[i]);
        if (!pCountry) {
            countries = addCountry (countries, results[i]);
            pCountry = countries;
        }
        struct city *pCity = findCity (pCountry->cities, results[i + 1]);
        if (!pCity) {
            pCountry->cities = addCity (pCountry->cities, results[i + 1]);
            pCity = pCountry->cities;
        }
        pCity->counter++;
    }
    struct country *pCountry = countries;
    while (pCountry != NULL) {
        printf ("%s\n", pCountry -> coutryName);
        struct city *pCity = pCountry->cities;
        while (pCity != NULL) {
            printf ("    %s %d\n", pCity -> cityName, pCity -> counter);
            pCity = pCity->next;
        }
        printf ("\n");
        pCountry = pCountry->next;
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements, i, sport_count = 0, country_change = 0;
    char country [50];
    char sport [50];
    strcpy (country, results [0]);
    printf ("%s\n", country);
    strcpy (sport, results [1]);
    nelements = sizeof (results) / sizeof (results[0]);
    for (i = 1; i < nelements; i++) {
        if (((i % 2) == 0) && (strcmp (country, results[i]))) {
            printf ("\t%s %d\n", sport, sport_count);
            country_change = 1;
            strcpy (country, results [i]);
            printf ("%s\n", country);
        }
        else if ((i % 2) == 1) {
            if (country_change) {
                strcpy (sport, results [i]);
                country_change = 0;
                sport_count = 0;
            }
            if (!strcmp (sport, results[i])) {
                sport_count++;
            }
            else {
                printf ("\t%s %d\n", sport, sport_count);
                strcpy (sport, results [i]);
                sport_count = 1;
            }
        }
    }
    printf ("\t%s %d\n", sport, sport_count);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39382760_67_109
39382328_39383895_5_74
Title: Grouping array of Strings C 
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    struct country *countries = NULL;
    int nelements = sizeof (results) / sizeof (results[0]);
    int i;
    for (i = 0; i < nelements; i += 2) {
        struct country *pCountry = findCountry (countries, results[i]);
        if (!pCountry) {
            countries = addCountry (countries, results[i]);
            pCountry = countries;
        }
        struct city *pCity = findCity (pCountry->cities, results[i + 1]);
        if (!pCity) {
            pCountry->cities = addCity (pCountry->cities, results[i + 1]);
            pCity = pCountry->cities;
        }
        pCity->counter++;
    }
    struct country *pCountry = countries;
    while (pCountry != NULL) {
        printf ("%s\n", pCountry -> coutryName);
        struct city *pCity = pCountry->cities;
        while (pCity != NULL) {
            printf ("    %s %d\n", pCity -> cityName, pCity -> counter);
            pCity = pCity->next;
        }
        printf ("\n");
        pCountry = pCountry->next;
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements = sizeof (results) / sizeof (results[0]);
    int i;
    int **map = calloc (nelements / 2, sizeof (int *));
    for (i = 0; i < nelements / 2; i++)
        map[i] = calloc (nelements / 2, sizeof (int));
    char **rowNames = calloc (nelements / 2, sizeof (char *));
    int usedRows = 0;
    char **colNames = calloc (nelements / 2, sizeof (char *));
    int usedCols = 0;
    int c;
    for (c = 0; c < nelements; c += 2) {
        int row = -1;
        for (i = 0; i < usedRows; i++) {
            if (strcmp (results[c], rowNames[i]) == 0) {
                row = i;
                break;
            }
        }
        if (row < 0) {
            row = usedRows;
            rowNames[usedRows] = results[c];
            usedRows++;
        }
        int col = -1;
        for (i = 0; i < usedCols; i++) {
            if (strcmp (results[c + 1], colNames[i]) == 0) {
                col = i;
                break;
            }
        }
        if (col < 0) {
            col = usedCols;
            colNames[usedCols] = results[c + 1];
            usedCols++;
        }
        map[row][col]++;
    }
    for (c = 0; c < usedRows; c++) {
        printf ("%s\n", rowNames [c]);
        for (i = 0; i < usedCols; i++)
            if (map[c][i])
                printf ("   %s %d\n", colNames[i], map[c][i]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39382760_67_109
39382328_39385459_15_56
Title: Grouping array of Strings C 
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    struct country *countries = NULL;
    int nelements = sizeof (results) / sizeof (results[0]);
    int i;
    for (i = 0; i < nelements; i += 2) {
        struct country *pCountry = findCountry (countries, results[i]);
        if (!pCountry) {
            countries = addCountry (countries, results[i]);
            pCountry = countries;
        }
        struct city *pCity = findCity (pCountry->cities, results[i + 1]);
        if (!pCity) {
            pCountry->cities = addCity (pCountry->cities, results[i + 1]);
            pCity = pCountry->cities;
        }
        pCity->counter++;
    }
    struct country *pCountry = countries;
    while (pCountry != NULL) {
        printf ("%s\n", pCountry -> coutryName);
        struct city *pCity = pCountry->cities;
        while (pCity != NULL) {
            printf ("    %s %d\n", pCity -> cityName, pCity -> counter);
            pCity = pCity->next;
        }
        printf ("\n");
        pCountry = pCountry->next;
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    host hosts [MAXC] = {{
            .country = NULL
        }
    };
    int hidx = 0, i, j, country_count, current = 0, nelements;
    country_count = sizeof countries / sizeof *countries;
    nelements = sizeof results / sizeof *results;
    for (i = 0; i < nelements; i++) {
        for (j = 0; j < country_count; j++) {
            if (strcmp (results[i], countries[j]) == 0) {
                int k;
                for (k = 0; k < hidx && strcmp (hosts[k].country, countries[j]); k++) {
                }
                if (!hosts[k].country) {
                    hosts[hidx++].country = results[i];
                    current = hidx - 1;
                }
                goto nextc;
            }
        }
        if (hosts[current].eventcnt < MAXE) {
            int k;
            for (k = 0; k < hosts[current].eventcnt; k++)
                if (strcmp (results[i], hosts[current].event[k]) == 0)
                    goto nextc;
            hosts[current].event[hosts[current].eventcnt++] = results[i];
        }
    nextc :
        ;
    }
    for (i = 0; i < hidx; i++) {
        printf (" %s\n", hosts [i].country);
        for (j = 0; j < hosts[i].eventcnt; j++)
            printf ("     %s\n", hosts[i].event[j]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39382763_43_92
39382328_39383149_5_55
Title: Grouping array of Strings C 
----------------------------------------

int main (int argc, char *argv []) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements, i, j;
    nelements = sizeof (results) / sizeof (results[0]);
    const int records_size = nelements / 2;
    Record record [records_size];
    for (i = 0; i < records_size; i++) {
        for (j = 0; j < COUNTRY_LENGTH; j++)
            record[i].country[j] = 0;
        for (j = 0; j < MAX_SPORTS; j++)
            record[i].sports[j] = 0;
    }
    int country_index, records_count = 0;
    for (i = 0; i < nelements; ++i) {
        if (i % 2 == 0) {
            country_index = exists (results[i], record, records_size);
            if (country_index == -1) {
                country_index = records_count++;
                strcpy (record [country_index].country, results [i]);
            }
        }
        else {
            record[country_index].sports[find_sport_index (results[i])]++;
        }
    }
    for (i = 0; i < records_size; ++i) {
        if (strlen (record[i].country)) {
            printf ("%s\n", record [i].country);
            for (j = 0; j < MAX_SPORTS; j++) {
                if (record[i].sports[j] != 0) {
                    printf ("    %s %d\n", find_sport_string (j), record [i].sports [j]);
                }
            }
        }
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements, i, sport_count = 0, country_change = 0;
    char country [50];
    char sport [50];
    strcpy (country, results [0]);
    printf ("%s\n", country);
    strcpy (sport, results [1]);
    nelements = sizeof (results) / sizeof (results[0]);
    for (i = 1; i < nelements; i++) {
        if (((i % 2) == 0) && (strcmp (country, results[i]))) {
            printf ("\t%s %d\n", sport, sport_count);
            country_change = 1;
            strcpy (country, results [i]);
            printf ("%s\n", country);
        }
        else if ((i % 2) == 1) {
            if (country_change) {
                strcpy (sport, results [i]);
                country_change = 0;
                sport_count = 0;
            }
            if (!strcmp (sport, results[i])) {
                sport_count++;
            }
            else {
                printf ("\t%s %d\n", sport, sport_count);
                strcpy (sport, results [i]);
                sport_count = 1;
            }
        }
    }
    printf ("\t%s %d\n", sport, sport_count);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39382763_43_92
39382328_39383895_5_74
Title: Grouping array of Strings C 
----------------------------------------

int main (int argc, char *argv []) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements, i, j;
    nelements = sizeof (results) / sizeof (results[0]);
    const int records_size = nelements / 2;
    Record record [records_size];
    for (i = 0; i < records_size; i++) {
        for (j = 0; j < COUNTRY_LENGTH; j++)
            record[i].country[j] = 0;
        for (j = 0; j < MAX_SPORTS; j++)
            record[i].sports[j] = 0;
    }
    int country_index, records_count = 0;
    for (i = 0; i < nelements; ++i) {
        if (i % 2 == 0) {
            country_index = exists (results[i], record, records_size);
            if (country_index == -1) {
                country_index = records_count++;
                strcpy (record [country_index].country, results [i]);
            }
        }
        else {
            record[country_index].sports[find_sport_index (results[i])]++;
        }
    }
    for (i = 0; i < records_size; ++i) {
        if (strlen (record[i].country)) {
            printf ("%s\n", record [i].country);
            for (j = 0; j < MAX_SPORTS; j++) {
                if (record[i].sports[j] != 0) {
                    printf ("    %s %d\n", find_sport_string (j), record [i].sports [j]);
                }
            }
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements = sizeof (results) / sizeof (results[0]);
    int i;
    int **map = calloc (nelements / 2, sizeof (int *));
    for (i = 0; i < nelements / 2; i++)
        map[i] = calloc (nelements / 2, sizeof (int));
    char **rowNames = calloc (nelements / 2, sizeof (char *));
    int usedRows = 0;
    char **colNames = calloc (nelements / 2, sizeof (char *));
    int usedCols = 0;
    int c;
    for (c = 0; c < nelements; c += 2) {
        int row = -1;
        for (i = 0; i < usedRows; i++) {
            if (strcmp (results[c], rowNames[i]) == 0) {
                row = i;
                break;
            }
        }
        if (row < 0) {
            row = usedRows;
            rowNames[usedRows] = results[c];
            usedRows++;
        }
        int col = -1;
        for (i = 0; i < usedCols; i++) {
            if (strcmp (results[c + 1], colNames[i]) == 0) {
                col = i;
                break;
            }
        }
        if (col < 0) {
            col = usedCols;
            colNames[usedCols] = results[c + 1];
            usedCols++;
        }
        map[row][col]++;
    }
    for (c = 0; c < usedRows; c++) {
        printf ("%s\n", rowNames [c]);
        for (i = 0; i < usedCols; i++)
            if (map[c][i])
                printf ("   %s %d\n", colNames[i], map[c][i]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39382763_43_92
39382328_39385459_15_56
Title: Grouping array of Strings C 
----------------------------------------

int main (int argc, char *argv []) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements, i, j;
    nelements = sizeof (results) / sizeof (results[0]);
    const int records_size = nelements / 2;
    Record record [records_size];
    for (i = 0; i < records_size; i++) {
        for (j = 0; j < COUNTRY_LENGTH; j++)
            record[i].country[j] = 0;
        for (j = 0; j < MAX_SPORTS; j++)
            record[i].sports[j] = 0;
    }
    int country_index, records_count = 0;
    for (i = 0; i < nelements; ++i) {
        if (i % 2 == 0) {
            country_index = exists (results[i], record, records_size);
            if (country_index == -1) {
                country_index = records_count++;
                strcpy (record [country_index].country, results [i]);
            }
        }
        else {
            record[country_index].sports[find_sport_index (results[i])]++;
        }
    }
    for (i = 0; i < records_size; ++i) {
        if (strlen (record[i].country)) {
            printf ("%s\n", record [i].country);
            for (j = 0; j < MAX_SPORTS; j++) {
                if (record[i].sports[j] != 0) {
                    printf ("    %s %d\n", find_sport_string (j), record [i].sports [j]);
                }
            }
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    host hosts [MAXC] = {{
            .country = NULL
        }
    };
    int hidx = 0, i, j, country_count, current = 0, nelements;
    country_count = sizeof countries / sizeof *countries;
    nelements = sizeof results / sizeof *results;
    for (i = 0; i < nelements; i++) {
        for (j = 0; j < country_count; j++) {
            if (strcmp (results[i], countries[j]) == 0) {
                int k;
                for (k = 0; k < hidx && strcmp (hosts[k].country, countries[j]); k++) {
                }
                if (!hosts[k].country) {
                    hosts[hidx++].country = results[i];
                    current = hidx - 1;
                }
                goto nextc;
            }
        }
        if (hosts[current].eventcnt < MAXE) {
            int k;
            for (k = 0; k < hosts[current].eventcnt; k++)
                if (strcmp (results[i], hosts[current].event[k]) == 0)
                    goto nextc;
            hosts[current].event[hosts[current].eventcnt++] = results[i];
        }
    nextc :
        ;
    }
    for (i = 0; i < hidx; i++) {
        printf (" %s\n", hosts [i].country);
        for (j = 0; j < hosts[i].eventcnt; j++)
            printf ("     %s\n", hosts[i].event[j]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39383149_5_55
39382328_39383895_5_74
Title: Grouping array of Strings C 
----------------------------------------

int main (int argc, char *argv []) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements, i, sport_count = 0, country_change = 0;
    char country [50];
    char sport [50];
    strcpy (country, results [0]);
    printf ("%s\n", country);
    strcpy (sport, results [1]);
    nelements = sizeof (results) / sizeof (results[0]);
    for (i = 1; i < nelements; i++) {
        if (((i % 2) == 0) && (strcmp (country, results[i]))) {
            printf ("\t%s %d\n", sport, sport_count);
            country_change = 1;
            strcpy (country, results [i]);
            printf ("%s\n", country);
        }
        else if ((i % 2) == 1) {
            if (country_change) {
                strcpy (sport, results [i]);
                country_change = 0;
                sport_count = 0;
            }
            if (!strcmp (sport, results[i])) {
                sport_count++;
            }
            else {
                printf ("\t%s %d\n", sport, sport_count);
                strcpy (sport, results [i]);
                sport_count = 1;
            }
        }
    }
    printf ("\t%s %d\n", sport, sport_count);
    return 0;
}
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements = sizeof (results) / sizeof (results[0]);
    int i;
    int **map = calloc (nelements / 2, sizeof (int *));
    for (i = 0; i < nelements / 2; i++)
        map[i] = calloc (nelements / 2, sizeof (int));
    char **rowNames = calloc (nelements / 2, sizeof (char *));
    int usedRows = 0;
    char **colNames = calloc (nelements / 2, sizeof (char *));
    int usedCols = 0;
    int c;
    for (c = 0; c < nelements; c += 2) {
        int row = -1;
        for (i = 0; i < usedRows; i++) {
            if (strcmp (results[c], rowNames[i]) == 0) {
                row = i;
                break;
            }
        }
        if (row < 0) {
            row = usedRows;
            rowNames[usedRows] = results[c];
            usedRows++;
        }
        int col = -1;
        for (i = 0; i < usedCols; i++) {
            if (strcmp (results[c + 1], colNames[i]) == 0) {
                col = i;
                break;
            }
        }
        if (col < 0) {
            col = usedCols;
            colNames[usedCols] = results[c + 1];
            usedCols++;
        }
        map[row][col]++;
    }
    for (c = 0; c < usedRows; c++) {
        printf ("%s\n", rowNames [c]);
        for (i = 0; i < usedCols; i++)
            if (map[c][i])
                printf ("   %s %d\n", colNames[i], map[c][i]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39383149_5_55
39382328_39385459_15_56
Title: Grouping array of Strings C 
----------------------------------------

int main (int argc, char *argv []) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements, i, sport_count = 0, country_change = 0;
    char country [50];
    char sport [50];
    strcpy (country, results [0]);
    printf ("%s\n", country);
    strcpy (sport, results [1]);
    nelements = sizeof (results) / sizeof (results[0]);
    for (i = 1; i < nelements; i++) {
        if (((i % 2) == 0) && (strcmp (country, results[i]))) {
            printf ("\t%s %d\n", sport, sport_count);
            country_change = 1;
            strcpy (country, results [i]);
            printf ("%s\n", country);
        }
        else if ((i % 2) == 1) {
            if (country_change) {
                strcpy (sport, results [i]);
                country_change = 0;
                sport_count = 0;
            }
            if (!strcmp (sport, results[i])) {
                sport_count++;
            }
            else {
                printf ("\t%s %d\n", sport, sport_count);
                strcpy (sport, results [i]);
                sport_count = 1;
            }
        }
    }
    printf ("\t%s %d\n", sport, sport_count);
    return 0;
}
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    host hosts [MAXC] = {{
            .country = NULL
        }
    };
    int hidx = 0, i, j, country_count, current = 0, nelements;
    country_count = sizeof countries / sizeof *countries;
    nelements = sizeof results / sizeof *results;
    for (i = 0; i < nelements; i++) {
        for (j = 0; j < country_count; j++) {
            if (strcmp (results[i], countries[j]) == 0) {
                int k;
                for (k = 0; k < hidx && strcmp (hosts[k].country, countries[j]); k++) {
                }
                if (!hosts[k].country) {
                    hosts[hidx++].country = results[i];
                    current = hidx - 1;
                }
                goto nextc;
            }
        }
        if (hosts[current].eventcnt < MAXE) {
            int k;
            for (k = 0; k < hosts[current].eventcnt; k++)
                if (strcmp (results[i], hosts[current].event[k]) == 0)
                    goto nextc;
            hosts[current].event[hosts[current].eventcnt++] = results[i];
        }
    nextc :
        ;
    }
    for (i = 0; i < hidx; i++) {
        printf (" %s\n", hosts [i].country);
        for (j = 0; j < hosts[i].eventcnt; j++)
            printf ("     %s\n", hosts[i].event[j]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
39382328_39383895_5_74
39382328_39385459_15_56
Title: Grouping array of Strings C 
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    int nelements = sizeof (results) / sizeof (results[0]);
    int i;
    int **map = calloc (nelements / 2, sizeof (int *));
    for (i = 0; i < nelements / 2; i++)
        map[i] = calloc (nelements / 2, sizeof (int));
    char **rowNames = calloc (nelements / 2, sizeof (char *));
    int usedRows = 0;
    char **colNames = calloc (nelements / 2, sizeof (char *));
    int usedCols = 0;
    int c;
    for (c = 0; c < nelements; c += 2) {
        int row = -1;
        for (i = 0; i < usedRows; i++) {
            if (strcmp (results[c], rowNames[i]) == 0) {
                row = i;
                break;
            }
        }
        if (row < 0) {
            row = usedRows;
            rowNames[usedRows] = results[c];
            usedRows++;
        }
        int col = -1;
        for (i = 0; i < usedCols; i++) {
            if (strcmp (results[c + 1], colNames[i]) == 0) {
                col = i;
                break;
            }
        }
        if (col < 0) {
            col = usedCols;
            colNames[usedCols] = results[c + 1];
            usedCols++;
        }
        map[row][col]++;
    }
    for (c = 0; c < usedRows; c++) {
        printf ("%s\n", rowNames [c]);
        for (i = 0; i < usedCols; i++)
            if (map[c][i])
                printf ("   %s %d\n", colNames[i], map[c][i]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *results [] = {"Canada", "Cycling", "Canada", "Swimming", "India", "Swimming", "New Mexico", "Cycling", "New Mexico", "Cycling", "New Mexico", "Swimming"};
    host hosts [MAXC] = {{
            .country = NULL
        }
    };
    int hidx = 0, i, j, country_count, current = 0, nelements;
    country_count = sizeof countries / sizeof *countries;
    nelements = sizeof results / sizeof *results;
    for (i = 0; i < nelements; i++) {
        for (j = 0; j < country_count; j++) {
            if (strcmp (results[i], countries[j]) == 0) {
                int k;
                for (k = 0; k < hidx && strcmp (hosts[k].country, countries[j]); k++) {
                }
                if (!hosts[k].country) {
                    hosts[hidx++].country = results[i];
                    current = hidx - 1;
                }
                goto nextc;
            }
        }
        if (hosts[current].eventcnt < MAXE) {
            int k;
            for (k = 0; k < hosts[current].eventcnt; k++)
                if (strcmp (results[i], hosts[current].event[k]) == 0)
                    goto nextc;
            hosts[current].event[hosts[current].eventcnt++] = results[i];
        }
    nextc :
        ;
    }
    for (i = 0; i < hidx; i++) {
        printf (" %s\n", hosts [i].country);
        for (j = 0; j < hosts[i].eventcnt; j++)
            printf ("     %s\n", hosts[i].event[j]);
    }
    return 0;
}
----------------------------------------
