$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47961996_47962889_19_31
47961996_47963133_22_34
Title: "Tkinter loop ""Tkinter não esta respondendo""" 
----------------------------------------

def agendar() :
INDENT
    comeco = start.get()
    final = limit.get()
    current = strftime('%H:%M:%S')
    if comeco == current :
    INDENT
        conexao.write(b'1')
        janela.after(1000, agendar)
    DEDENT
    elif final == current :
    INDENT
        conexao.write(b'2')
    DEDENT
DEDENT
----------------------------------------

def agendar() :
INDENT
    global start, limit
    comeco = start.get()
    final = limit.get()
    while 1 > 0 :
    INDENT
        if comeco == strftime('%H:%M:%S') :
        INDENT
            valor = bytes(('1'), 'utf-8')
            conexao.write(valor)
        DEDENT
        elif final == strftime('%H:%M:%S') :
        INDENT
            valor = bytes(('2'), 'utf-8')
            conexao.write(valor)
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47961996_47962889_6_18
47961996_47963133_9_21
Title: "Tkinter loop ""Tkinter não esta respondendo""" 
----------------------------------------

def ligar() :
INDENT
    global cont
    cont = not cont
    if cont :
    INDENT
        conexao.write(b'1')
        ligar ['text'] = 'Desligar led'
    DEDENT
    else :
    INDENT
        conexao.write(b'2')
        ligar ['text'] = 'Ligar led'

    DEDENT
DEDENT
----------------------------------------

def ligar() :
INDENT
    global cont
    cont = cont + 1
    if cont == 1 :
    INDENT
        valor = bytes(('1'), 'utf-8')
        conexao.write(valor)
        ligar ['text'] = 'Desligar led'
    DEDENT
    elif cont == 2 :
    INDENT
        valor = bytes(('2'), 'utf-8')
        conexao.write(valor)
        ligar ['text'] = 'Ligar led'
        cont = 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47965782_47965820_2_13
47965782_47965835_1_9
Title: While loop vs a for loop in finding sum of multiples of 3 and 5 under 1000 
----------------------------------------

def multiple() :
INDENT
    lst = []
    x = 1
    while (3 * x < 1000) or (5 * x < 1000) :
    INDENT
        if 3 * x < 1000 :
        INDENT
            lst.append(3 * x)
        DEDENT
        if 5 * x < 1000 :
        INDENT
            lst.append(5 * x)
        DEDENT
        x += 1
    DEDENT
    lst2 = list(set(lst))
    print (sum(lst2))
DEDENT
----------------------------------------

def multiple() :
INDENT
    sum = 0
    cnt = 1
    while cnt < = 1000 :
    INDENT
        if cnt % 3 == 0 or cnt % 5 == 0 :
        INDENT
            sum += cnt
        DEDENT
        cnt += 1
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47965782_47965823_1_15
47965782_47965835_1_9
Title: While loop vs a for loop in finding sum of multiples of 3 and 5 under 1000 
----------------------------------------

def multiple() :
INDENT
    lst = []
    x = 1
    while True :
    INDENT
        if 3 * x < 1000 :
        INDENT
            lst.append(3 * x)
        DEDENT
        if 5 * x < 1000 :
        INDENT
            lst.append(5 * x)
        DEDENT
        if (3 * x > 1000) and (5 * x > 1000) :
        INDENT
            break
        DEDENT
        x += 1
    DEDENT
    lst2 = list(set(lst))
    print (sum(lst2))
DEDENT
----------------------------------------

def multiple() :
INDENT
    sum = 0
    cnt = 1
    while cnt < = 1000 :
    INDENT
        if cnt % 3 == 0 or cnt % 5 == 0 :
        INDENT
            sum += cnt
        DEDENT
        cnt += 1
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48017181_48017213_100_108
48017181_48017213_111_119
Title: Tile blocks rendering invisible in pygame platformer 
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((15, 15))
    self.image.fill(YELLOW)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y

DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((5, 5))
    self.image.fill(RED)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y
    self.speedx = 7
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48017181_48017213_100_108
48017181_48017213_28_38
Title: Tile blocks rendering invisible in pygame platformer 
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((15, 15))
    self.image.fill(YELLOW)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((30, 30))
    self.image.fill(RED)
    self.rect = self.image.get_rect()
    self.rect.center = (WIDTH / 2, HEIGHT / 2)
    self.pos = vec(WIDTH / 3, HEIGHT / 2)
    self.vel = vec(0, 0)
    self.acc = vec(0, 0)
    self.speed = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48017181_48017213_100_108
48017181_48017213_89_97
Title: Tile blocks rendering invisible in pygame platformer 
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((15, 15))
    self.image.fill(YELLOW)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y

DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((30, 30))
    self.image.fill(GREEN)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48017181_48017213_111_119
48017181_48017213_28_38
Title: Tile blocks rendering invisible in pygame platformer 
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((5, 5))
    self.image.fill(RED)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y
    self.speedx = 7
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((30, 30))
    self.image.fill(RED)
    self.rect = self.image.get_rect()
    self.rect.center = (WIDTH / 2, HEIGHT / 2)
    self.pos = vec(WIDTH / 3, HEIGHT / 2)
    self.vel = vec(0, 0)
    self.acc = vec(0, 0)
    self.speed = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48017181_48017213_111_119
48017181_48017213_89_97
Title: Tile blocks rendering invisible in pygame platformer 
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((5, 5))
    self.image.fill(RED)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y
    self.speedx = 7
DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((30, 30))
    self.image.fill(GREEN)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48017181_48017213_120_126
48017181_48017213_39_77
Title: Tile blocks rendering invisible in pygame platformer 
----------------------------------------

def update(self) :
INDENT
    self.rect.x += self.speedx
    if self.rect.right > WIDTH :
    INDENT
        self.kill()

    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    self.speed = 0
    self.acc = vec(0, PLAYER_GRAV)
    keys = pg.key.get_pressed()
    if keys [pg.K_LEFT] :
    INDENT
        self.speed = - 5
    DEDENT
    if keys [pg.K_RIGHT] :
    INDENT
        self.speed = 5
    DEDENT
    self.pos.x += self.speed

    self.vel += self.acc
    self.pos += self.vel + 0.5 * self.acc
    self.rect.midbottom = self.pos

    if self.rect.left < 150 :
    INDENT
        self.pos.x -= self.speed
        for block in blocks :
        INDENT
            block.rect.x -= self.speed
        DEDENT
        for powerup in powerups :
        INDENT
            powerup.rect.x -= self.speed
        DEDENT
    DEDENT
    if self.rect.right > WIDTH - 150 :
    INDENT
        self.pos.x -= self.speed
        for block in blocks :
        INDENT
            block.rect.x -= self.speed
            if block.rect.right < 0 :
            INDENT
                block.kill()
            DEDENT
        DEDENT
        for powerup in powerups :
        INDENT
            powerup.rect.x -= self.speed
        DEDENT
    DEDENT
    if self.rect.top < = HEIGHT / 4 :
    INDENT
        self.pos.y += abs(self.vel.y)
        for block in blocks :
        INDENT
            block.rect.y += abs(self.vel.y)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48017181_48017213_28_38
48017181_48017213_89_97
Title: Tile blocks rendering invisible in pygame platformer 
----------------------------------------

def __init__(self) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((30, 30))
    self.image.fill(RED)
    self.rect = self.image.get_rect()
    self.rect.center = (WIDTH / 2, HEIGHT / 2)
    self.pos = vec(WIDTH / 3, HEIGHT / 2)
    self.vel = vec(0, 0)
    self.acc = vec(0, 0)
    self.speed = 0
DEDENT
----------------------------------------

def __init__(self, x, y) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = pg.Surface((30, 30))
    self.image.fill(GREEN)
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48018017_48118256_14_20
48018017_48118256_31_40
Title: Python Twisted best way to signal events to a proxy 
----------------------------------------

def dataReceived(self, data) :
INDENT
    print ('==> received {0} from server'.format(data))
    print ('<== transmitting data to all actors')
    for actor in self.factory.actors :
    INDENT
        actor.transport.write(data)

    DEDENT
DEDENT
----------------------------------------

def dataReceived(self, data) :
INDENT
    print ('==> received {0} from actor'.format(data))
    proxy_connection = self.factory.proxy_factory.proxy_proto
    if proxy_connection is not None :
    INDENT
        print ('<== transmitting data to server through the proxy')
        proxy_connection.transport.write(data)
    DEDENT
    else :
    INDENT
        print ('[ ] proxy connection to server has not been established')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48025283_48025629_16_23
48025283_48025629_25_32
Title: Pixel perfect collision detection for sprites with a transparent background 
----------------------------------------

def __init__(self, pos) :
INDENT
    super(Enemy, self).__init__()
    self.image = pg.Surface((120, 120), pg.SRCALPHA)
    pg.draw.circle(self.image, (240, 100, 0), (60, 60), 60)
    self.rect = self.image.get_rect(center = pos)
    self.mask = pg.mask.from_surface(self.image)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.screen = pg.display.set_mode((640, 480))
    self.player = Player((20, 20))
    self.enemies = pg.sprite.Group(Enemy((320, 240)))
    self.all_sprites = pg.sprite.Group(self.player, self.enemies)
    self.done = False
    self.clock = pg.time.Clock()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48025283_48025629_16_23
48025283_48025629_6_13
Title: Pixel perfect collision detection for sprites with a transparent background 
----------------------------------------

def __init__(self, pos) :
INDENT
    super(Enemy, self).__init__()
    self.image = pg.Surface((120, 120), pg.SRCALPHA)
    pg.draw.circle(self.image, (240, 100, 0), (60, 60), 60)
    self.rect = self.image.get_rect(center = pos)
    self.mask = pg.mask.from_surface(self.image)

DEDENT
----------------------------------------

def __init__(self, pos) :
INDENT
    super(Player, self).__init__()
    self.image = pg.Surface((120, 120), pg.SRCALPHA)
    pg.draw.polygon(self.image, (0, 100, 240), [(60, 0), (120, 120), (0, 120)])
    self.rect = self.image.get_rect(center = pos)
    self.mask = pg.mask.from_surface(self.image)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48025283_48025629_25_32
48025283_48025629_6_13
Title: Pixel perfect collision detection for sprites with a transparent background 
----------------------------------------

def __init__(self) :
INDENT
    self.screen = pg.display.set_mode((640, 480))
    self.player = Player((20, 20))
    self.enemies = pg.sprite.Group(Enemy((320, 240)))
    self.all_sprites = pg.sprite.Group(self.player, self.enemies)
    self.done = False
    self.clock = pg.time.Clock()
DEDENT
----------------------------------------

def __init__(self, pos) :
INDENT
    super(Player, self).__init__()
    self.image = pg.Surface((120, 120), pg.SRCALPHA)
    pg.draw.polygon(self.image, (0, 100, 240), [(60, 0), (120, 120), (0, 120)])
    self.rect = self.image.get_rect(center = pos)
    self.mask = pg.mask.from_surface(self.image)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48032100_48032300_1_12
48032100_48032607_1_9
Title: Convert the following into a recursive function 
----------------------------------------

def factorial(n, b) :
INDENT
    if n == 1 :
    INDENT
        return [1]
    DEDENT
    elif len(b) == n :
    INDENT
        return b
    DEDENT
    else :
    INDENT
        if len(b) == 0 :
        INDENT
            b.append(1)
            factorial(n, b)
        DEDENT
        else :
        INDENT
            b.append((len(b) + 1) * b [len(b) - 1])
            factorial(n, b)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def factorial(n) :
INDENT
    if n == 1 :
    INDENT
        return [1]
    DEDENT
    a = factorial(n - 1)
    a.append(n * a [- 1])
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48039660_48084660_24_40
48039660_48084660_4_19
Title: wxpython assign variable in an event handler 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None)
    self.track_selected = '0'
    self.tc = wx.TextCtrl(self, wx.ID_ANY, "", style = wx.TE_MULTILINE)
    self.bt = wx.Button(self, wx.ID_ANY, "master (push to send)")
    self.bt.Bind(wx.EVT_BUTTON, self.change_track)
    self.Title = 'Master'
    self.tc.SetValue('enter value to be read by the tracker')
    sz_1 = wx.BoxSizer(wx.HORIZONTAL)
    sz_2 = wx.BoxSizer(wx.VERTICAL)
    sz_2.Add(self.tc, 1, wx.EXPAND, 0)
    sz_2.Add(self.bt, 0, wx.EXPAND, 0)
    sz_1.Add(sz_2, 1, wx.EXPAND, 0)
    self.SetSizer(sz_1)
    self.Layout()
    self.SetSize((250, 100))
DEDENT
----------------------------------------

def __init__(self, link) :
INDENT
    wx.Frame.__init__(self, None)
    self.link = link
    self.tc = wx.TextCtrl(self, style = wx.TE_MULTILINE)
    self.bt = wx.Button(self, label = "tracker (push to read master)")
    self.bt.Bind(wx.EVT_BUTTON, self.on_read_master)
    self.Title = 'Tracker'
    sz_1 = wx.BoxSizer(wx.HORIZONTAL)
    sz_2 = wx.BoxSizer(wx.VERTICAL)
    sz_2.Add(self.tc, 1, wx.EXPAND, 0)
    sz_2.Add(self.bt, 0, wx.EXPAND, 0)
    sz_1.Add(sz_2, 1, wx.EXPAND, 0)
    self.SetSizer(sz_1)
    self.Layout()
    self.SetSize((250, 100))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48041125_48041145_3_16
48041125_48041150_3_12
Title: "Line too long how do I break a line within brackets" 
----------------------------------------

def __init__(self,
start_number,
stop_number,
input_number,
rotation_units,
direction) :
INDENT
    self.start_number = start_number
    self.stop_number = stop_number
    self.input_number = input_number
    self.rotation_units = rotation_units
    self.direction = direction
    self.output_number = 0
    self.verify = None
    self.circumference_units_sum = 0
DEDENT
----------------------------------------

def __init__(self, start_number, stop_number, input_number, rotation_units,
direction) :
INDENT
    self.start_number = start_number
    self.stop_number = stop_number
    self.input_number = input_number
    self.rotation_units = rotation_units
    self.direction = direction
    self.output_number = 0
    self.verify = None
    self.circumference_units_sum = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48041639_48041759_1_10
48041639_48041800_1_10
Title: How can I count the swaps in a Merge Sort Algorithm in Python 
----------------------------------------

def mergesortInv(list, mergeInv) :
INDENT
    if len(list) < 2 :
    INDENT
        return list, 0
    DEDENT
    else :
    INDENT
        middle = len(list) / / 2
        left, lc = mergesortInv(list [: middle], mergeInv)
        right, rc = mergesortInv(list [middle :], mergeInv)
    DEDENT
    merge, mc = mergeInv(left, right)
    return merge, lc + rc + mc
DEDENT
----------------------------------------

def mergesortInv(list) :
INDENT
    if len(list) < 2 :
    INDENT
        return list
    DEDENT
    else :
    INDENT
        middle = len(list) / / 2
        left = mergesortInv(list [: middle])
        right = mergesortInv(list [middle :])
    DEDENT
    return mergeInv(left, right)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48055036_48066456_28_38
48055036_48066456_5_20
Title: Forcing QRubberBand to a specific aspect ratio 
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.button = QtWidgets.QPushButton('Show Rubber Band')
    self.button.clicked.connect(self.handleButton)
    self.label = QtWidgets.QLabel()
    self.label.setScaledContents(True)
    self.label.setPixmap(QtGui.QPixmap('image.jpg'))
    layout = QtWidgets.QVBoxLayout(self)
    layout.addWidget(self.label)
    layout.addWidget(self.button)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(ResizableRubberBand, self).__init__(parent)
    self.setWindowFlags(QtCore.Qt.SubWindow)
    layout = QtWidgets.QHBoxLayout(self)
    layout.setContentsMargins(0, 0, 0, 0)
    layout.addWidget(
        QtWidgets.QSizeGrip(self), 0,
        QtCore.Qt.AlignLeft | QtCore.Qt.AlignTop)
    layout.addWidget(
        QtWidgets.QSizeGrip(self), 0,
        QtCore.Qt.AlignRight | QtCore.Qt.AlignBottom)
    self._band = QtWidgets.QRubberBand(
        QtWidgets.QRubberBand.Rectangle, self)
    self._band.show()
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48055581_48058137_13_32
48055581_48061170_21_38
Title: How to reorder nodes (change depth) in a scatterplot for an animation 
----------------------------------------

def animate(N) :
INDENT
    x = [random.random() for val in range(N)]
    y = [random.random() for val in range(N)]
    points = [[x [i], y [i]] for i in range(N)]
    fig = plt.figure()
    ax = fig.add_subplot(111)
    plotted_points = ax.scatter(x, y, color = 'gray', zorder = 1)
    red_plotted_points = ax.scatter([], [], color = 'red', zorder = 2)
    fargs = (red_plotted_points, points, N)
    ani = FuncAnimation(fig, update, frames = range(100), fargs = fargs,
        interval = 200, repeat = True)
    ani._start()
    fig.show()
    return fig, ani

DEDENT
----------------------------------------

def animate(N) :
INDENT
    x = [random.random() for val in range(N)]
    y = [random.random() for val in range(N)]
    fig = plt.figure()
    ax = fig.add_subplot(111)

    colors = ['red' if idx < 1000 else 'gray' for idx in range(N)]
    colors.reverse()
    plotted_points = ax.scatter(x, y, color = colors)
    fargs = (plotted_points,)
    ani = FuncAnimation(fig, update, frames = range(100), fargs = fargs)
    plt.show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48056160_48056184_1_8
48056160_48056409_1_13
Title: Python List remove multiple items 
----------------------------------------

def rem(a, li) :
INDENT
    try :
    INDENT
        while a in li :
        INDENT
            li.remove(a)
        DEDENT
        print ('Updated list: ', li)
    DEDENT
    except ValueError :
    INDENT
        print (a, ' is not located in the list ', li)
    DEDENT
DEDENT
----------------------------------------

def rem(a, li) :
INDENT
    list_length = len(li)
    i = 0
    while (li [i] ! = a) and (i < list_length) :
    INDENT
        i += 1
    DEDENT
    i += 1
    while i < list_length :
    INDENT
        if li [i] == a :
        INDENT
            del li [i]
            print ('Updated list: ', li)
            list_length -= 1
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48056160_48056184_1_8
48056160_48063482_3_11
Title: Python List remove multiple items 
----------------------------------------

def rem(a, li) :
INDENT
    try :
    INDENT
        while a in li :
        INDENT
            li.remove(a)
        DEDENT
        print ('Updated list: ', li)
    DEDENT
    except ValueError :
    INDENT
        print (a, ' is not located in the list ', li)
    DEDENT
DEDENT
----------------------------------------

def rem(a, li) :
INDENT
    for j, i in enumerate(li) :
    INDENT
        if a == i :
        INDENT
            del li [j]

        DEDENT
    DEDENT
    return li

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48056160_48056409_1_13
48056160_48063482_3_11
Title: Python List remove multiple items 
----------------------------------------

def rem(a, li) :
INDENT
    list_length = len(li)
    i = 0
    while (li [i] ! = a) and (i < list_length) :
    INDENT
        i += 1
    DEDENT
    i += 1
    while i < list_length :
    INDENT
        if li [i] == a :
        INDENT
            del li [i]
            print ('Updated list: ', li)
            list_length -= 1
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def rem(a, li) :
INDENT
    for j, i in enumerate(li) :
    INDENT
        if a == i :
        INDENT
            del li [j]

        DEDENT
    DEDENT
    return li

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48069825_48070168_23_31
48069825_48070168_4_21
Title: how to output my functions numeric values as a list in python 
----------------------------------------

def seq_sum(n) :
INDENT
    flip = 0
    seq = list()
    while flip < n :
    INDENT
        coin = random.randint(0, 1)
        seq.append(coin)
        flip += 1
    DEDENT
    return seq
DEDENT
----------------------------------------

def seq_sum(n) :
INDENT
    flip = 0
    heads = 0
    seq = list()
    while flip < = n :
    INDENT
        coin = random.randint(0, 2)
        seq.append(coin)
        flip += 1
        if coin == 1 :
        INDENT
            heads += 1
        DEDENT
    DEDENT
    print (heads, seq)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48076905_48077520_1_10
48076905_48077962_5_14
Title: i get python function NameError 
----------------------------------------

def disemvowel(word) :
INDENT
    vowels = ["a", "e", "i", "o", "u"]
    out = word
    for vowel in vowels :
    INDENT
        if vowel in word.lower() :
        INDENT
            out = out.replace(vowel, "")
        DEDENT
    DEDENT
    print (out)
DEDENT
----------------------------------------

def disemvowel(word) :
INDENT
    for vowel in 'aeiou' :
    INDENT
        if vowel.lower() in new_word :
        INDENT
            new_word.remove(vowel)
        DEDENT
    DEDENT
    strword = ''.join(new_word)
    print (strword)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48080899_48084702_3_13
48080899_48084749_1_11
Title: How to grab a certain word from a .txt file given what it begins and ends with 
----------------------------------------

def login() :
INDENT
    with open('usernames.txt') as fin :
    INDENT
        users_list = fin.readlines()
    DEDENT
    for user in users_list :
    INDENT
        user = user.strip()
        if user [: - 3] == query.get() :
        INDENT
            nam_lbl ['text'] = user [: - 3]
            val_lbl ['text'] = user [- 3 : - 1]
            zero_lbl ['text'] = user [- 1]
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def login(userlogin) :
INDENT
    with open(
        'usernames.txt') as input_data :
    INDENT
        for user in input_data :
        INDENT
            if user.strip() == '0' :
            INDENT
                break
            DEDENT
            if user.strip().startswith(userlogin, 0, len(userlogin)) :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    print (user)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48080899_48084702_3_13
48080899_48084892_1_9
Title: How to grab a certain word from a .txt file given what it begins and ends with 
----------------------------------------

def login() :
INDENT
    with open('usernames.txt') as fin :
    INDENT
        users_list = fin.readlines()
    DEDENT
    for user in users_list :
    INDENT
        user = user.strip()
        if user [: - 3] == query.get() :
        INDENT
            nam_lbl ['text'] = user [: - 3]
            val_lbl ['text'] = user [- 3 : - 1]
            zero_lbl ['text'] = user [- 1]
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def login(userlogin) :
INDENT
    with open('usernames.txt') as usernames :
    INDENT
        for line in usernames :
        INDENT
            username = line.strip()
            if username.startswith(userlogin + '0') and len(username) == len(userlogin) + 3 :
            INDENT
                print (username)
                return
            DEDENT
        DEDENT
    DEDENT
    print ('no match')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48080899_48084749_1_11
48080899_48084892_1_9
Title: How to grab a certain word from a .txt file given what it begins and ends with 
----------------------------------------

def login(userlogin) :
INDENT
    with open(
        'usernames.txt') as input_data :
    INDENT
        for user in input_data :
        INDENT
            if user.strip() == '0' :
            INDENT
                break
            DEDENT
            if user.strip().startswith(userlogin, 0, len(userlogin)) :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    print (user)
DEDENT
----------------------------------------

def login(userlogin) :
INDENT
    with open('usernames.txt') as usernames :
    INDENT
        for line in usernames :
        INDENT
            username = line.strip()
            if username.startswith(userlogin + '0') and len(username) == len(userlogin) + 3 :
            INDENT
                print (username)
                return
            DEDENT
        DEDENT
    DEDENT
    print ('no match')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48100407_48110969_13_24
48100407_48110969_30_37
Title: tkinter molecular simulation issue 
----------------------------------------

def move(self) :
INDENT
    canvas.move(self.shape, self.speed_x, self.speed_y)
    pos = canvas.coords(self.shape)

    if pos [3] > = 100 or pos [1] < = 0 :
    INDENT
        self.speed_y = - self.speed_y
    DEDENT
    if pos [2] > 100 or pos [0] < = 0 :
    INDENT
        self.speed_x = - self.speed_x
    DEDENT
DEDENT
----------------------------------------

def move() :
INDENT
    for ball in all_balls :
    INDENT
        ball.move()
    DEDENT
    root.after(100, move)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48102791_48103310_13_21
48102791_48105969_20_39
Title: player walking on predetermined path pygame 
----------------------------------------

def update(self) :
INDENT
    if self.index == 4 :
    INDENT

        self.list.reverse()
        self.index = 0
    DEDENT
    self.rect.x = self.list [self.index]
    self.index += 1
DEDENT
----------------------------------------

def update(self) :
INDENT
    heading = self.target - self.pos
    distance = heading.length()
    heading.normalize_ip()
    if distance < = 2 :
    INDENT

        self.waypoint_index = (self.waypoint_index + 1) % len(self.waypoints)
        self.target = self.waypoints [self.waypoint_index]
    DEDENT
    if distance < = self.target_radius :
    INDENT

        self.vel = heading * (distance / self.target_radius * self.max_speed)
    DEDENT
    else :
    INDENT
        self.vel = heading * self.max_speed
    DEDENT
    self.pos += self.vel
    self.rect.center = self.pos

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48102791_48103310_2_12
48102791_48105969_7_19
Title: player walking on predetermined path pygame 
----------------------------------------

def __init__(self) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.image.load("enemy.png")
    self.image = pygame.transform.scale(self.image, (int(50), int(50)))
    self.rect = self.image.get_rect()
    self.rect.x = width / 3
    self.rect.y = height / 3
    self.list = [1, 2, 3, 4, 5]
    self.index = 0
DEDENT
----------------------------------------

def __init__(self, pos, waypoints) :
INDENT
    super().__init__()
    self.image = pg.Surface((30, 50))
    self.image.fill(pg.Color('dodgerblue1'))
    self.rect = self.image.get_rect(center = pos)
    self.vel = Vector2(0, 0)
    self.max_speed = 3
    self.pos = Vector2(pos)
    self.waypoints = waypoints
    self.waypoint_index = 0
    self.target = self.waypoints [self.waypoint_index]
    self.target_radius = 50
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48121711_48122488_17_25
48121711_48122565_5_10
Title: Drag and drop within PyQt5 TreeView? 
----------------------------------------

def dragEnterEvent(self, event) :
INDENT
    m = event.mimeData()
    if m.hasUrls() :
    INDENT
        for url in m.urls() :
        INDENT
            if url.isLocalFile() :
            INDENT
                event.accept()
                return
            DEDENT
        DEDENT
    DEDENT
    event.ignore()
DEDENT
----------------------------------------

def dragEnterEvent(self, event) :
INDENT
    if event.mimeData().hasUrls :
    INDENT
        event.accept()
    DEDENT
    else :
    INDENT
        event.ignore()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48121711_48122488_26_54
48121711_48122565_18_28
Title: Drag and drop within PyQt5 TreeView? 
----------------------------------------

def dropEvent(self, event) :
INDENT
    if event.source() :
    INDENT
        QTreeView.dropEvent(self, event)
    DEDENT
    else :
    INDENT
        ix = self.indexAt(event.pos())
        if not self.model().isDir(ix) :
        INDENT
            ix = ix.parent()
        DEDENT
        pathDir = self.model().filePath(ix)
        m = event.mimeData()
        if m.hasUrls() :
        INDENT
            urlLocals = [url for url in m.urls() if url.isLocalFile()]
            accepted = False
            for urlLocal in urlLocals :
            INDENT
                path = urlLocal.toLocalFile()
                info = QFileInfo(path)
                n_path = QDir(pathDir).filePath(info.fileName())
                o_path = info.absoluteFilePath()
                if n_path == o_path :
                INDENT
                    continue
                DEDENT
                if info.isDir() :
                INDENT
                    QDir().rename(o_path, n_path)
                DEDENT
                else :
                INDENT
                    qfile = QFile(o_path)
                    if QFile(n_path).exists() :
                    INDENT
                        n_path += "(copy)"
                    DEDENT
                    qfile.rename(n_path)
                DEDENT
                accepted = True
            DEDENT
            if accepted :
            INDENT
                event.acceptProposedAction()
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def dropEvent(self, event) :
INDENT
    if event.mimeData().hasUrls :
    INDENT
        event.setDropAction(QtCore.Qt.CopyAction)
        event.accept()
        drop_list = []
        for url in event.mimeData().urls() :
        INDENT
            drop_list.append(str(url.toLocalFile()))
        DEDENT
    DEDENT
    else :
    INDENT
        event.ignore()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48140576_48140926_16_65
48140576_48140926_76_83
Title: matplotlib toolbar in a pyqt5 application 
----------------------------------------

def __init__(self) :
INDENT
    QMainWindow.__init__(self)
    self.title = 'test'
    self.left = 10
    self.top = 10
    self.width = 1920
    self.height = 1080
    self.setWindowTitle(self.title)
    self.setGeometry(self.left, self.top, self.width, self.height)
    self.statusBar().showMessage('Ready')
    mainMenu = self.menuBar()
    mainMenu.setNativeMenuBar(False)
    fileMenu = mainMenu.addMenu('File')
    helpMenu = mainMenu.addMenu('Help')
    exitButton = QAction(QIcon('exit24.png'), 'Exit', self)
    exitButton.setShortcut('Ctrl+Q')
    exitButton.setStatusTip('Exit application')
    exitButton.triggered.connect(self.close)
    fileMenu.addAction(exitButton)

    widget = QWidget(self)
    self.setCentralWidget(widget)
    vlay = QVBoxLayout(widget)
    hlay = QHBoxLayout()
    vlay.addLayout(hlay)
    self.nameLabel = QLabel('Name:', self)
    self.line = QLineEdit(self)
    self.nameLabel2 = QLabel('Result', self)
    hlay.addWidget(self.nameLabel)
    hlay.addWidget(self.line)
    hlay.addWidget(self.nameLabel2)
    hlay.addItem(QSpacerItem(1000, 10, QSizePolicy.Expanding))
    pybutton = QPushButton('Click me', self)
    pybutton.clicked.connect(self.clickMethod)
    hlay2 = QHBoxLayout()
    hlay2.addWidget(pybutton)
    hlay2.addItem(QSpacerItem(1000, 10, QSizePolicy.Expanding))
    vlay.addLayout(hlay2)
    m = WidgetPlot(self)
    vlay.addWidget(m)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QWidget.__init__(self, * args, ** kwargs)
    self.setLayout(QVBoxLayout())
    self.canvas = PlotCanvas(self, width = 10, height = 8)
    self.toolbar = NavigationToolbar(self.canvas, self)
    self.layout().addWidget(self.toolbar)
    self.layout().addWidget(self.canvas)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48140576_48140926_16_65
48140576_48140926_85_92
Title: matplotlib toolbar in a pyqt5 application 
----------------------------------------

def __init__(self) :
INDENT
    QMainWindow.__init__(self)
    self.title = 'test'
    self.left = 10
    self.top = 10
    self.width = 1920
    self.height = 1080
    self.setWindowTitle(self.title)
    self.setGeometry(self.left, self.top, self.width, self.height)
    self.statusBar().showMessage('Ready')
    mainMenu = self.menuBar()
    mainMenu.setNativeMenuBar(False)
    fileMenu = mainMenu.addMenu('File')
    helpMenu = mainMenu.addMenu('Help')
    exitButton = QAction(QIcon('exit24.png'), 'Exit', self)
    exitButton.setShortcut('Ctrl+Q')
    exitButton.setStatusTip('Exit application')
    exitButton.triggered.connect(self.close)
    fileMenu.addAction(exitButton)

    widget = QWidget(self)
    self.setCentralWidget(widget)
    vlay = QVBoxLayout(widget)
    hlay = QHBoxLayout()
    vlay.addLayout(hlay)
    self.nameLabel = QLabel('Name:', self)
    self.line = QLineEdit(self)
    self.nameLabel2 = QLabel('Result', self)
    hlay.addWidget(self.nameLabel)
    hlay.addWidget(self.line)
    hlay.addWidget(self.nameLabel2)
    hlay.addItem(QSpacerItem(1000, 10, QSizePolicy.Expanding))
    pybutton = QPushButton('Click me', self)
    pybutton.clicked.connect(self.clickMethod)
    hlay2 = QHBoxLayout()
    hlay2.addWidget(pybutton)
    hlay2.addItem(QSpacerItem(1000, 10, QSizePolicy.Expanding))
    vlay.addLayout(hlay2)
    m = WidgetPlot(self)
    vlay.addWidget(m)
DEDENT
----------------------------------------

def __init__(self, parent = None, width = 10, height = 8, dpi = 100) :
INDENT
    fig = Figure(figsize = (width, height), dpi = dpi)
    FigureCanvas.__init__(self, fig)
    self.setParent(parent)
    FigureCanvas.setSizePolicy(self, QSizePolicy.Expanding, QSizePolicy.Expanding)
    FigureCanvas.updateGeometry(self)
    self.plot()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48140576_48140926_76_83
48140576_48140926_85_92
Title: matplotlib toolbar in a pyqt5 application 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QWidget.__init__(self, * args, ** kwargs)
    self.setLayout(QVBoxLayout())
    self.canvas = PlotCanvas(self, width = 10, height = 8)
    self.toolbar = NavigationToolbar(self.canvas, self)
    self.layout().addWidget(self.toolbar)
    self.layout().addWidget(self.canvas)
DEDENT
----------------------------------------

def __init__(self, parent = None, width = 10, height = 8, dpi = 100) :
INDENT
    fig = Figure(figsize = (width, height), dpi = dpi)
    FigureCanvas.__init__(self, fig)
    self.setParent(parent)
    FigureCanvas.setSizePolicy(self, QSizePolicy.Expanding, QSizePolicy.Expanding)
    FigureCanvas.updateGeometry(self)
    self.plot()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48152899_48157737_18_31
48152899_48158238_8_21
Title: Write 'Function output ' into a nice Pandas dataframe 
----------------------------------------

def get_details(url) :
INDENT
    print ('details:', url)
    r = requests.get(url)
    soup = BeautifulSoup(r.text, "lxml")

    return pd.read_html(str(soup)) [0]

DEDENT
----------------------------------------

def get_details(url) :
INDENT
    global df
    global headings
    print ('details:', url)
    r = requests.get(url)
    soup = BeautifulSoup(r.text, "lxml")
    dts = soup.findAll('dt')
    dds = soup.findAll('dd')
    data = {}
    for dt, dd in zip(dts, dds) :
    INDENT
        if (dt.text in headings) and (dt.text not in data) :
        INDENT
            data [dt.text] = dd.text
        DEDENT
    DEDENT
    df = df.append(data, ignore_index = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48155269_48156036_60_86
48155269_48156129_68_77
Title: Tensorflow queues hang 
----------------------------------------

def __init__(self, filenames) :
INDENT
    self.filename_queue = tf.train.string_input_producer(filenames)
    self.reader = tf.FixedLengthRecordReader(record_bytes = Cifar10Record.record_bytes)
    self.key, value = self.reader.read(self.filename_queue)
    record = tf.decode_raw(value, tf.uint8)
    label = tf.cast(
        tf.strided_slice(record, [0], [Cifar10Record.label_bytes]), tf.int32)
    label.set_shape([1])
    self.label = tf.one_hot(label, 10, on_value = 1.0, off_value = 0.0)

    depth_major = tf.reshape(
        tf.strided_slice(record, [Cifar10Record.label_bytes],
            [Cifar10Record.record_bytes]),
        [Cifar10Record.depth, Cifar10Record.height, Cifar10Record.width])
    self.uint8image = tf.transpose(depth_major, [1, 2, 0])
    self.float32image = tf.cast(self.uint8image, tf.float32)
    self.image = self.undistorted_input_branch()
DEDENT
----------------------------------------

def __init__(self, filenames) :
INDENT
    self.filename_queue = tf.train.string_input_producer(filenames)
    self.dataset = tf.data.FixedLengthRecordDataset(filenames, Cifar10Record.record_bytes, buffer_size = 1 * MB)
    self.dataset = self.dataset.map(Cifar10Record._parse_function)
    self.dataset = self.dataset.shuffle(buffer_size = 1 * MB)
    self.dataset = self.dataset.batch(100)
    self.iterator = self.dataset.make_initializable_iterator()
    self.next_input = self.iterator.get_next()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48158903_48159309_2_30
48158903_48159439_5_14
Title: How to retrieve dict with the row column and value of table in Tkinter 
----------------------------------------

def __init__(self, master) :
INDENT
    frame = Tkinter.Frame(master)
    self.data_readout = Tkinter.Button(frame,
        text = "Collect Data", bd = 10, height = 2, width = 10,
        command = lambda : self.dataReadout(self.table_values))
    self.data_readout.grid(row = 0, column = 0, padx = 5, pady = 5)
    self.table_values = Tkinter.LabelFrame(frame,
        text = "Values", borderwidth = 10,
        relief = Tkinter.GROOVE, padx = 10, pady = 10)
    self.table_values.grid(row = 1, column = 0, padx = 20, pady = 20)

    with open('table.pkl', 'rb') as infile :
    INDENT
        table = pickle.load(infile)

    DEDENT
    height = 4
    width = 10
    for i in range(height) :
    INDENT
        for j in range(width) :
        INDENT
            b = Tkinter.Entry(self.table_values, text = "", width = 5)
            b.grid(row = i, column = j)
            b.insert(0, str(table [i] [j]))
        DEDENT
    DEDENT
    frame.grid(row = 0, column = 0, padx = 20, pady = 20)
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.b = list()
    for i in range(4) :
    INDENT
        self.b.append(list())
        for j in range(10) :
        INDENT
            self.b [i].append(Tkinter.Entry(master, text = "", width = 5))
            self.b [i] [j].grid(row = i, column = j)
            self.b [i] [j].insert(0, str(round(random.random() * 100)))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48162287_48162458_2_18
48162287_48164665_1_28
Title: How can i completely get rid of a row in my csv file? 
----------------------------------------

def delete_information_method() :
INDENT
    global delete_entry
    with open('employees.csv', 'r', newline = '') as emp_read :
    INDENT

        csv_dictreader = csv.DictReader(emp_read)
        fieldnames = csv_dictreader.fieldnames
        with open('employees_out.csv', 'w', newline = '') as emp_write :
        INDENT

            csv_writer1 = csv.DictWriter(emp_write, fieldnames = fieldnames)
            csv_writer1.writeheader()
            for line in csv_dictreader :
            INDENT
                if line ['employee id'] ! = str(delete_entry.get()) :
                INDENT
                    csv_writer1.writerow(line)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def delete_information_method() :
INDENT
    new_records = []
    with open('employees.csv', 'r') as emp_read :
    INDENT
        csv_dictreader = csv.DictReader(emp_read)
        for record in csv_dictreader :
        INDENT
            if record ['employee id'] ! = str(delete_entry) :
            INDENT
                new_records.append(record)

            DEDENT
        DEDENT
    DEDENT
    with open('output.csv', 'w') as emp_writer :
    INDENT
        csv_writer = csv.DictWriter(
            emp_writer,
            fieldnames = csv_dictreader.fieldnames)
        csv_writer.writeheader()
        for record in new_records :
        INDENT
            csv_writer.writerow(record)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48176103_48176298_6_27
48176103_48176374_1_15
Title: Python 3.5: Guessing the cube root game is returning None as an output 
----------------------------------------

def guess() :
INDENT
    import random
    rand = random.randint(0, 100)
    cubed = rand * rand * rand

    string = "What is the cube root of"
    cubed = str(cubed)
    qmark = "?"
    question = string + " " + cubed + qmark
    user = int(input(question))
    if (user == rand) :
    INDENT
        print ("\nCorrect!")
    DEDENT
    elif (user ! = rand) :
    INDENT
        print ("\tIncorrect!, the cube root of", cubed, "is", rand)
    DEDENT
    user = input("\n\tWould you like to try again?").lower()
    if user == "y" :
    INDENT
        guess()
    DEDENT
    else :
    INDENT
        print ("Goodbye")
    DEDENT
DEDENT
----------------------------------------

def guess() :
INDENT
    import random
    rand = random.randint(0, 100)
    cubed = rand * rand * rand

    question = "What is the cube root of {cubed} ?".format(cubed = cubed)
    user = int(input(question))
    if user == rand :
    INDENT
        print ("\nCorrect!")
    DEDENT
    else :
    INDENT
        print ("\tIncorrect!, the cube root of", cubed, "is", rand)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48176291_48188957_1_8
48176291_48216071_1_10
Title: Maximum Sum Sub Array 
----------------------------------------

def max_subarray(A) :
INDENT
    max_ending_here = max_so_far = A [0]
    for x in A [1 :] :
    INDENT
        max_ending_here = max(x, max_ending_here + x)
        max_so_far = max(max_so_far, max_ending_here)
    DEDENT
    return max_so_far
DEDENT
----------------------------------------

def max_subarray(A) :
INDENT
    solve = A [0]
    sum = 0
    for i in range(0, len(A)) :
    INDENT
        sum = sum + A [i]
        if sum > solve :
        INDENT
            solve = sum
        DEDENT
        if sum < 0 :
        INDENT
            sum = 0
        DEDENT
        return solve
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48181586_48184779_38_53
48181586_48184779_59_72
Title: Save data from multiple classes 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "What are the sizes?")
    label1.pack()
    L1 = tk.Label(self, text = "Length :")
    L1.pack()
    self.E1 = tk.Entry(self)
    self.E1.pack()
    button = tk.Button(self, text = "Next", command = lambda : controller.show_frame(PageOne))
    button.pack()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "You have insert")
    label1.pack()

    self.label2 = tk.Label(self, text = "")
    self.label2.pack()
    button = tk.Button(self, text = "Back", command = lambda : controller.show_frame(StartPage))
    button.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48181586_48184779_38_53
48181586_48184779_5_26
Title: Save data from multiple classes 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "What are the sizes?")
    label1.pack()
    L1 = tk.Label(self, text = "Length :")
    L1.pack()
    self.E1 = tk.Entry(self)
    self.E1.pack()
    button = tk.Button(self, text = "Next", command = lambda : controller.show_frame(PageOne))
    button.pack()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.geometry("700x400")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48181586_48184779_59_72
48181586_48184779_5_26
Title: Save data from multiple classes 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "You have insert")
    label1.pack()

    self.label2 = tk.Label(self, text = "")
    self.label2.pack()
    button = tk.Button(self, text = "Back", command = lambda : controller.show_frame(StartPage))
    button.pack()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.geometry("700x400")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, PageOne) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
481862_481991_71_77
481862_485417_61_66
Title: Extracting info from large structured text files 
----------------------------------------

def main() :
INDENT
    arquivo = open('rm1972.txt')
    for desp in process(arquivo) :
    INDENT
        print desp
        print ('-' * 20)
    DEDENT
    return 0
DEDENT
----------------------------------------

def main() :
INDENT
    arquivo = file('rm1972.txt')
    for desp in process(arquivo) :
    INDENT
        print desp
        print '-' * 20
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48187744_48191591_11_25
48187744_48191591_32_40
Title: How to get nested Kivy widgets to interact between each other? 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(AddNumpad, self).__init__(** kwargs)
    self.cols = 3
    self.padding = 50
    for i in range(1, 10) :
    INDENT
        btn = Button(text = str(i))
        btn.bind(on_press = self.callback)
        self.add_widget(btn)
    DEDENT
    self.add_widget(Label(text = ''))
    btn = Button(text = '0')
    btn.bind(on_press = self.callback)
    self.add_widget(btn)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(LoginScreen, self).__init__(** kwargs)
    self.password = TextInput(password = True, multiline = False)
    self.cols = 2
    self.numpad = AddNumpad()
    self.numpad.bind(passwIn = self.numpad_pressed)
    self.add_widget(self.numpad)
    self.add_widget(self.password)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48201057_48201205_7_11
48201057_48201460_3_14
Title: python3 recursive function of n * (b(a)) 
----------------------------------------

def shasum(key, n) :
INDENT
    if n == 0 :
    INDENT
        return key
    DEDENT
    key = str(key).encode('utf-8')
    return hash_b(hash_a(shasum(key, n - 1)))
DEDENT
----------------------------------------

def shasum(key, n) :
INDENT
    print ("n: " + str(n))
    key = str(key).encode('utf-8')
    hash_a = hashlib.sha224(key).hexdigest().encode('utf-8')
    print ("hash_a: " + str(hash_a))
    hash_b = hashlib.sha256(hash_a).hexdigest()
    print ("hash_b: " + str(hash_b))
    if n == 0 :
    INDENT
        return hash_b
    DEDENT
    else :
    INDENT
        return shasum(hash_b, n - 1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48215097_48215440_1_10
48215097_48215488_1_11
Title: Printing all dictionary results from For Loop in Python 
----------------------------------------

def name() :
INDENT
    entries = []
    for count in range(5) :
    INDENT
        d = {}
        qs = dict(Fname = 'first name', Lname = 'last name')
        for k, v in qs.items() :
        INDENT
            d [k] = input('Please enter your {}: '.format(v))
        DEDENT
        entries.append(d)
    DEDENT
    return entries
DEDENT
----------------------------------------

def name() :
INDENT
    count = 0
    while (count < 5) :
    INDENT
        d = {}
        qs = dict(Fname = 'first name', Lname = 'last name')
        for k, v in qs.items() :
        INDENT
            a = input('Please enter your {}: '.format(v))
            d [v] = a
        DEDENT
        count += 1
        print (d ['first name'], d ['last name'])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48215940_48216086_24_49
48215940_48216810_12_30
Title: loop simple calculator: will not loop back to original input 
----------------------------------------

def main() :
INDENT
    validInput = False
    num1, num2, operation = None, None, None
    while not validInput :
    INDENT
        try :
        INDENT
            if num1 is None : num1 = int(input("What is number 1?"))
            if num2 is None : num2 = int(input("What is number 2?"))
            if operation is None : operation = int(input("What do you want to do? 1. add, 2. subtract, 3. multiply, or 4. divide. Enter number:"))
            validInput = True
        DEDENT
        except :
        INDENT
            print ("invalid input. Try again")
        DEDENT
    DEDENT
    if (operation == 1) :
    INDENT
        print ("Adding...")
        print (add(num1, num2))
    DEDENT
    elif (operation == 2) :
    INDENT
        print ("Subtracting...")
        print (sub(num1, num2))
    DEDENT
    elif (operation == 3) :
    INDENT
        print ("Multiplying...")
        print (mul(num1, num2))
    DEDENT
    elif (operation == 4) :
    INDENT
        print ("Dividing...")
        print (div(num1, num2))
    DEDENT
    else :
    INDENT
        print ("I don't understand")
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    num1 = tryUntilSuccess("What is number 1?")
    num2 = tryUntilSuccess("What is number 2?")
    operation = tryUntilSuccess("What do you want to do? 1. add, 2. subtract, 3. multiply, or 4. divide. Enter number:", [1, 2, 3, 4])
    if (operation == 1) :
    INDENT
        print ("Adding...")
        print (add(num1, num2))
    DEDENT
    elif (operation == 2) :
    INDENT
        print ("Subtracting...")
        print (sub(num1, num2))
    DEDENT
    elif (operation == 3) :
    INDENT
        print ("Multiplying...")
        print (mul(num1, num2))
    DEDENT
    elif (operation == 4) :
    INDENT
        print ("Dividing...")
        print (div(num1, num2))
    DEDENT
    else :
    INDENT
        print ("I should not be printed.")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48235938_48236207_3_11
48235938_48238822_1_14
Title: "Python permutations of a list storing value without mutating" 
----------------------------------------

def permutations(array) :
INDENT
    if array in newArray :
    INDENT
        return
    DEDENT
    for i in range(len(array)) :
    INDENT
        array_copy = list(array)
        array_copy [0], array_copy [i] = array_copy [i], array_copy [0]
        newArray.append(array_copy)
        permutations(array_copy)
    DEDENT
    return newArray
DEDENT
----------------------------------------

def permutations(array) :
INDENT
    if len(array) == 0 :
    INDENT
        return [[]]
    DEDENT
    if len(array) == 1 :
    INDENT
        return [array]
    DEDENT
    else :
    INDENT
        arr = []
        for i in range(len(array)) :
        INDENT
            array [0], array [i] = array [i], array [0]
            start = array [0]
            end = permutations(array [1 :])
            for x in end :
            INDENT
                arr.append([start] + x)
            DEDENT
        DEDENT
    DEDENT
    return arr
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48253823_48254212_11_22
48253823_48254358_9_33
Title: Pyglet Into Class 
----------------------------------------

def __init__(self) :
INDENT
    platform = pyglet.window.get_platform()
    display = platform.get_default_display()
    screen = display.get_default_screen()
    self.widthScreen = screen.width
    self.heightScreen = screen.height
    self.xDisplay = int(self.widthScreen / 2 - self.widthDisplay / 2)
    self.yDisplay = int(self.heightScreen / 2 - self.heightDiplay / 2)
    self.Display = pyglet.window.Window(width = self.widthDisplay, height = self.heightDiplay, caption = self.title, resizable = False)
    self.Display.set_location(self.xDisplay, self.yDisplay)
    pyglet.app.run()
DEDENT
----------------------------------------

def __init__(self, width = 1024, height = 576, caption = "Pokémon Life and Death: Esploratori del proprio Destino", fps = True, * args, ** kwargs) :
INDENT
    super(main, self).__init__(width, height, * args, ** kwargs)
    platform = pyglet.window.get_platform()
    display = platform.get_default_display()
    screen = display.get_default_screen()
    self.xDisplay = int(screen.width / 2 - self.width / 2)
    self.yDisplay = int(screen.height / 2 - self.height / 2)
    self.set_location(self.xDisplay, self.yDisplay)
    self.sprites = OrderedDict()
    if fps :
    INDENT
        self.sprites ['fps_label'] = pyglet.text.Label('0 fps', x = 10, y = 10)
        self.last_update = time()
        self.fps_count = 0
    DEDENT
    self.keys = OrderedDict()
    self.mouse_x = 0
    self.mouse_y = 0
    self.alive = 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48262966_48269737_22_37
48262966_48269737_8_13
Title: Terminate a long-running Python command within a PyQt application 
----------------------------------------

def long_task(self) :
INDENT
    dialog = QDialog(self)
    vbox = QVBoxLayout(dialog)
    label = QLabel("Running...")
    button = QDialogButtonBox(QDialogButtonBox.Cancel)
    button.rejected.connect(dialog.close)
    vbox.addWidget(label)
    vbox.addWidget(button)
    def callback(msg) :
    INDENT
        print (msg)
        dialog.accept()
    DEDENT
    pool.apply_async(long_task, callback = callback)
    if dialog.exec_() == QDialog.Rejected :
    INDENT
        pool.terminate()
        print ('terminated')
    DEDENT
DEDENT
----------------------------------------

def long_task() :
INDENT
    for x in range(10) :
    INDENT
        print ('long task:', x)
        time.sleep(1)
    DEDENT
    return 'finished'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48265583_48283153_9_24
48265583_48458088_11_33
Title: Shutdown for socketserver based Python 3 server hangs 
----------------------------------------

def handle(self) :
INDENT
    self.request.setblocking(False)
    while True :
    INDENT
        try :
        INDENT
            msg = self.request.recv(1024)
            if msg == b'shutdown' :
            INDENT
                shutdown_evt.set()
                break
            DEDENT
            elif msg :
            INDENT
                self.request.send(b'you said: ' + msg)
            DEDENT
            if shutdown_evt.wait(0.1) :
            INDENT
                break
            DEDENT
        DEDENT
        except Exception as e :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def handle(self, socket, address) :
INDENT
    print ('New connection from %s:%s' % address [: 2])
    socket.sendall(b'Welcome to the echo server! Type quit to exit.\r\n')

    rfileobj = socket.makefile(mode = 'rb')
    while True :
    INDENT
        line = rfileobj.readline()
        if not line :
        INDENT
            print ("client disconnected")
            break
        DEDENT
        if line.strip().lower() == b'quit' :
        INDENT
            print ("client quit")
            break
        DEDENT
        if line.strip().lower() == b'shutdown' :
        INDENT
            print ("client initiated server shutdown")
            self.stop()
            break
        DEDENT
        socket.sendall(line)
        print ("echoed %r" % line.decode().strip())
    DEDENT
    rfileobj.close()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48267969_48269401_26_39
48267969_48269401_5_17
Title: Movement code of pygame sprites not working correctly 
----------------------------------------

def __init__(self, alive, x, y) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface([32, 32])
    self.image.set_colorkey(black)
    self.image.fill((255, 0, 0))
    self.rect = self.image.get_rect()
    self.rect.x = x
    self.rect.y = y
    self.alive = True
    self.directional = 1
DEDENT
----------------------------------------

def __init__(self, life) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface([32, 32])
    self.image.set_colorkey(black)
    self.image.fill((0, 255, 0))
    self.life = 3
    self.rect = self.image.get_rect()
    self.rect.x = 300
    self.rect.y = 700
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48269163_48269901_125_152
48269163_48269901_14_34
Title: how to show the cursor coordinates in wxPython when using wx.SplitterWindow 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title)

    self.statusBar = wx.StatusBar(self, - 1)
    self.SetStatusBar(self.statusBar)

    self.splitter = ProportionalSplitter(self, - 1, 0.85)
    self.ppanel = Plot_Panel(self.splitter, self)
    self.ppanel.SetBackgroundColour('#ffffff')

    self.bpanel = Button_Panel(self.splitter)

    self.splitter.SplitVertically(self.ppanel, self.bpanel)
    self.Show(True)
    self.Maximize(True)

    self.ppanel.toggleMarker.Bind(wx.EVT_CHECKBOX, self.onToggleMarker)
    self.bpanel.toggleStart.Bind(wx.EVT_BUTTON, self.onToggleStart)

    self.data = data()

DEDENT
----------------------------------------

def __init__(self, parent, base) :
INDENT
    wx.Panel.__init__(self, parent)
    self.base = base
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    checkSizer = wx.BoxSizer(wx.HORIZONTAL)

    self.fig = Figure()
    self.canvas = FigCanvas(self, - 1, self.fig)
    self.axes = self.fig.add_subplot(111)

    self.toggleMarker = wx.CheckBox(self, label = "Show Marker")

    mainSizer.Add(self.canvas, 1, wx.EXPAND)
    checkSizer.Add(self.toggleMarker, 0, wx.ALL, 5)
    mainSizer.Add(checkSizer)
    self.SetSizer(mainSizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48269163_48269901_125_152
48269163_48269901_70_81
Title: how to show the cursor coordinates in wxPython when using wx.SplitterWindow 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title)

    self.statusBar = wx.StatusBar(self, - 1)
    self.SetStatusBar(self.statusBar)

    self.splitter = ProportionalSplitter(self, - 1, 0.85)
    self.ppanel = Plot_Panel(self.splitter, self)
    self.ppanel.SetBackgroundColour('#ffffff')

    self.bpanel = Button_Panel(self.splitter)

    self.splitter.SplitVertically(self.ppanel, self.bpanel)
    self.Show(True)
    self.Maximize(True)

    self.ppanel.toggleMarker.Bind(wx.EVT_CHECKBOX, self.onToggleMarker)
    self.bpanel.toggleStart.Bind(wx.EVT_BUTTON, self.onToggleStart)

    self.data = data()

DEDENT
----------------------------------------

def __init__(self, parent, id = - 1, proportion = 0.66, size = wx.DefaultSize, ** kwargs) :
INDENT
    wx.SplitterWindow.__init__(self, parent, id, wx.Point(0, 0), size, ** kwargs)
    self.SetMinimumPaneSize(50)
    self.proportion = proportion
    if not 0 < self.proportion < 1 :
    INDENT
        raise ValueError, "proportion value for ProportionalSplitter must be between 0 and 1."
    DEDENT
    self.ResetSash()
    self.Bind(wx.EVT_SIZE, self.OnReSize)
    self.Bind(wx.EVT_SPLITTER_SASH_POS_CHANGED, self.OnSashChanged, id = id)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.firstpaint = True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48269163_48269901_14_34
48269163_48269901_70_81
Title: how to show the cursor coordinates in wxPython when using wx.SplitterWindow 
----------------------------------------

def __init__(self, parent, base) :
INDENT
    wx.Panel.__init__(self, parent)
    self.base = base
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    checkSizer = wx.BoxSizer(wx.HORIZONTAL)

    self.fig = Figure()
    self.canvas = FigCanvas(self, - 1, self.fig)
    self.axes = self.fig.add_subplot(111)

    self.toggleMarker = wx.CheckBox(self, label = "Show Marker")

    mainSizer.Add(self.canvas, 1, wx.EXPAND)
    checkSizer.Add(self.toggleMarker, 0, wx.ALL, 5)
    mainSizer.Add(checkSizer)
    self.SetSizer(mainSizer)
DEDENT
----------------------------------------

def __init__(self, parent, id = - 1, proportion = 0.66, size = wx.DefaultSize, ** kwargs) :
INDENT
    wx.SplitterWindow.__init__(self, parent, id, wx.Point(0, 0), size, ** kwargs)
    self.SetMinimumPaneSize(50)
    self.proportion = proportion
    if not 0 < self.proportion < 1 :
    INDENT
        raise ValueError, "proportion value for ProportionalSplitter must be between 0 and 1."
    DEDENT
    self.ResetSash()
    self.Bind(wx.EVT_SIZE, self.OnReSize)
    self.Bind(wx.EVT_SPLITTER_SASH_POS_CHANGED, self.OnSashChanged, id = id)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.firstpaint = True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48292632_48295403_41_50
48292632_48295403_5_27
Title: How to correctly implement wait_window()? 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.test_entry_field = tk.Entry(self.master)
    self.test_entry_field.pack()
    self.cancel_button = tk.Button(self.master, text = "Cancel",
        command = self.exit_program)
    self.cancel_button.pack()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.button_height = 2
    self.button_width = 8
    self.list_of_tasks = []

    self.new_task = tk.Button(self.master, bg = "yellow",
        height = self.button_height,
        width = self.button_width * 2,
        text = "New Task",
        command = self.create_new_task)
    self.new_task.grid(row = 1, column = 0, columnspan = 2,
        sticky = "N" + "W" + "S" + "E")

    self.tasks_in_tab = tk.Frame(master, height = 300, width = 300)
    self.tasks_in_tab.grid(row = 2, rowspan = 5, column = 0, columnspan = 5)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48349128_48349684_1_7
48349128_48349693_3_11
Title: How do I insert a file into a string? (python3) 
----------------------------------------

def readsave(savefile, gameinfo = [0, 0]) :
INDENT
    "Reads a file and adds its statistics to variables"
    with open(savefile) as file_object :
    INDENT
        gameinfo = file_object.readlines()
    DEDENT
    return gameinfo

DEDENT
----------------------------------------

def readsave(savefile) :
INDENT
    "Reads a file and adds its statistics to variables"
    filename = savefile
    with open(filename) as file_object :
    INDENT
        gameinfo = file_object.readlines()
    DEDENT
    print (gameinfo)
    return gameinfo

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48358686_48358757_1_11
48358686_48358851_1_12
Title: """while loop"" not breaking (using Python)" 
----------------------------------------

def chooseReport() :
INDENT
    print "Choose a report."
    t = True
    while t :
    INDENT
        choice = raw_input("Enter A or B: ")
        if choice == 'a' or choice == 'A' :
        INDENT
            reportA()
            t = False
        DEDENT
        elif choice == 'b' or choice == 'B' :
        INDENT
            reportB()
            t = False
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def chooseReport() :
INDENT
    print "Choose a report."
    while True :
    INDENT
        choice = raw_input("Enter A or B: ")
        if "a" in choice or "A" in choice :
        INDENT
            reportA()
            break
        DEDENT
        elif "b" in choice or "B" in choice :
        INDENT
            reportB()
            break
        DEDENT
        else :
        INDENT
            continue
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48358686_48358848_2_13
48358686_48358851_1_12
Title: """while loop"" not breaking (using Python)" 
----------------------------------------

def chooseReport() :
INDENT
    print "Choose a report."
    allow = True
    while allow :
    INDENT
        choice = raw_input("Enter A or B: ")
        if choice.lower().strip() == "a" :
        INDENT
            reportA()
            allow = False
        DEDENT
        elif choice.lower().strip() == "b" :
        INDENT
            reportB()
            allow = False
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def chooseReport() :
INDENT
    print "Choose a report."
    while True :
    INDENT
        choice = raw_input("Enter A or B: ")
        if "a" in choice or "A" in choice :
        INDENT
            reportA()
            break
        DEDENT
        elif "b" in choice or "B" in choice :
        INDENT
            reportB()
            break
        DEDENT
        else :
        INDENT
            continue
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48358686_48358848_2_13
48358686_48358932_8_21
Title: """while loop"" not breaking (using Python)" 
----------------------------------------

def chooseReport() :
INDENT
    print "Choose a report."
    allow = True
    while allow :
    INDENT
        choice = raw_input("Enter A or B: ")
        if choice.lower().strip() == "a" :
        INDENT
            reportA()
            allow = False
        DEDENT
        elif choice.lower().strip() == "b" :
        INDENT
            reportB()
            allow = False
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def chooseReport() :
INDENT
    print "Choose a report."
    while True :
    INDENT
        choice = raw_input("Enter A or B: ")
        if choice == 'a' or choice == 'A' :
        INDENT
            reportA()
            break
        DEDENT
        elif choice == 'b' or choice == 'B' :
        INDENT
            reportB()
            break
        DEDENT
        else :
        INDENT
            continue
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48362828_48362956_3_18
48362828_48371305_6_19
Title: Writing a function that asks a user to input a color and then fills a shape with that color 
----------------------------------------

def drawCircle(radius, fillColor) :
INDENT
    x = 360 / 300
    win = turtle.Screen()
    tom = turtle.Turtle()
    tom.fillcolor(fillColor)
    tom.begin_fill()
    for _ in range(300) :
    INDENT
        tom.forward(radius)
        tom.right(x)
        tom.forward(radius)
    DEDENT
    tom.end_fill()
    win.exitonclick()
DEDENT
----------------------------------------

def drawCircle(radius, fillColor) :
INDENT
    distance = math.pi * radius * 2 / SEGMENTS
    angle = 360 / SEGMENTS
    turtle.fillcolor(fillColor)
    turtle.begin_fill()
    for _ in range(SEGMENTS) :
    INDENT
        turtle.forward(distance)
        turtle.left(angle)
    DEDENT
    turtle.end_fill()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48366740_48367244_26_37
48366740_48367244_6_15
Title: Multiple Video Display using Tkinter in Python for GUI design 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    tk.Toplevel.__init__(self, master)
    if 'title' in kwargs :
    INDENT
        self.title(kwargs ['title'])
    DEDENT
    self.hide_main_button = tk.Button(self, text = "Hide/Show MainWindow")
    self.hide_main_button ['command'] = self.master.toggle_hide
    self.hide_main_button.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self)
    self.title("This is the MainWindow")
    self._is_hidden = False
    self.window1 = OtherWindow(self, title = "window 1")
    self.window2 = OtherWindow(self, title = "window 2")

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48370743_48372806_2_9
48370743_48378734_2_13
Title: How to pass gobject.Gtype arguments to a Gtk.ListStore in a function 
----------------------------------------

def initListStore(lesTypes, laListe) :
INDENT
    leStore = Gtk.ListStore()
    leStore.set_column_types(lesTypes)
    for item in laListe :
    INDENT
        leStore.append(item)
    DEDENT
    return leStore

DEDENT
----------------------------------------

def initListStore(laListe) :
INDENT
    types = []
    ligne = laListe [0]
    for mot in ligne :
    INDENT
        types.append(type(mot))
    DEDENT
    leStore = Gtk.ListStore()
    leStore.set_column_types(types)
    for item in laListe :
    INDENT
        leStore.append(item)
    DEDENT
    return leStore

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48373872_48374323_5_37
48373872_48378525_5_28
Title: Why is the animation speeding up after being resumed? 
----------------------------------------

def __init__(self) :
INDENT
    win = Tk()
    win.title('Pendulum')

    self.w, self.h = 250, 300
    self.canvas = Canvas(win, width = self.w, height = self.h, bg = 'white')
    self.canvas.pack()

    win.bind('s', self.stop)
    win.bind('S', self.stop)
    win.bind('r', self.resume)
    win.bind('R', self.resume)

    self.g = 1
    self.L = 4 * self.h / 5
    self.theta_i = radians(20)

    self.t = 0
    self._queue = False

    self.isStopped = False
    self.speed = 1 / 50
    self.animate()

    win.mainloop()
DEDENT
----------------------------------------

def __init__(self, master = None, ** kwargs) :
INDENT
    Canvas.__init__(self, master, bg = 'white', ** kwargs)

    master.bind('s', self.stop)
    master.bind('S', self.stop)
    master.bind('r', self.resume)
    master.bind('R', self.resume)

    self.g = 1
    self.theta_i = radians(20)

    self.t = 0
    cord, bob = self.calcPendulum()
    self.cord = self.create_line(* cord, tags = 'cord')
    self.bob = self.create_oval(* bob, fill = 'red', tags = 'bob')

    self.timer = ''
    self.speed = 1 / 50
    self.animate()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48377577_48395717_7_33
48377577_48395717_80_112
Title: can't get Variable value of groups of ttk.CheckButtons 
----------------------------------------

def __init__(self, pContainer, pLstVal, pCommand, pInitValue = True) :
INDENT
    self.grpChk = [0] * len(pLstVal)
    self.grpKey = [0] * len(pLstVal)
    self.grpLstVal = [0] * len(pLstVal)
    self.grpVariable = [0] * len(pLstVal)
    self.grpActiveKeys = [0]
    for l, t in enumerate(pLstVal) :
    INDENT

        self.grpKey [l] = t [0]
        self.grpLstVal [l] = t [1]
        self.grpVariable [l] = tk.StringVar()
        self.grpChk [l] = ttk.Checkbutton(pContainer, text = self.grpLstVal [l],
            state = 'active',
            onvalue = self.grpKey [l],
            offvalue = '',
            variable = self.grpVariable [l],
            command = partial(pCommand, self))

        if pInitValue :
        INDENT
            self.grpVariable [l].set(self.grpKey [l])
            self.grpActiveKeys.append(self.grpKey [l])

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    tk.Tk.__init__(self)
    la = [1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3]
    lb = [10, 11, 12, 14, 15, 20, 21, 22, 23, 24, 25, 26, 30, 31, 32, 33]
    lc = ['d10', 'd11', 'd12', 'd14', 'd15', 'd20', 'd21', 'd22', 'd23', 'd24', 'd25', 'd26', 'd30', 'd31', 'd32', 'd33']
    df = pd.DataFrame(
        {'DIVISION' : la,
            'DEPT_CODE' : lb,
            'DEPT_NAME' : lc})
    lW = list(zip(df ['DIVISION'].astype(str), df ['DEPT_CODE'].astype(str)))
    lpt = list(zip(df ['DEPT_CODE'].astype(str), df ['DEPT_NAME'].astype(str)))
    curHead = ""
    r = 0
    c = - 1
    for head, DPT in lW :
    INDENT
        if not curHead == head :
        INDENT
            curHead = head
            c += 1
            r = 0
            dq = df.query('DIVISION==' + head)
            lpt = list(zip(dq ['DEPT_CODE'].astype(str), dq ['DEPT_NAME'].astype(str)))
            t = ttk.Labelframe(self, text = head)
            t.grid(column = c, row = 0, sticky = 'nw')
            checkGrpDept = clsGrpCheckButton(t, lpt, clsGrpCheckButton.chkGrpGetValue, True)
        DEDENT
        checkGrpDept.chkGrpGetChkObj(DPT).grid(column = c, row = r, sticky = 'nw')
        t.rowconfigure(r, weight = 1)
        t.columnconfigure(c, weight = 1)
        r += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48397745_48398398_12_26
48397745_48398489_13_37
Title: "I write myself a little bubble sorting code while self-learning python but couldnt figure out why it doesnt work" 
----------------------------------------

def bubble_sort(to_sort) :
INDENT
    def swap(index_1, index_2) :
    INDENT
        temp = to_sort [index_1]
        to_sort [index_1] = to_sort [index_2]
        to_sort [index_2] = temp
    DEDENT
    we_are_done = False
    while not we_are_done :
    INDENT
        we_are_done = True
        for index in range(len(to_sort) - 1) :
        INDENT
            if to_sort [index] [2] > to_sort [index + 1] [2] :
            INDENT
                we_are_done = False
                swap(index, index + 1)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def bubble_sort(list) :
INDENT
    def swap(item1, item2) :
    INDENT
        pos1 = list.index(item1)
        pos2 = list.index(item2)
        list [pos1] = item2
        list [pos2] = item1
    DEDENT
    count = 0
    for student in list :
    INDENT
        try :
        INDENT
            next = list [(list.index(student)) + 1]
            if student [2] > next [2] :
            INDENT
                swap(student, next)
                count += 1
            DEDENT
        DEDENT
        except IndexError :
        INDENT
            break
        DEDENT
    DEDENT
    if count == 0 :
    INDENT
        return list
    DEDENT
    else :
    INDENT
        return bubble_sort(list)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48398991_48399278_16_21
48398991_48400805_8_17
Title: "Python3 Tkinter GUI crashes and button remain clicked" 
----------------------------------------

def do(self) :
INDENT
    self.do_count = not self.do_count
    if not self.do_count :
    INDENT
        self.count = 0
    DEDENT
    self.update()
DEDENT
----------------------------------------

def do() :
INDENT
    while x > 0 :
    INDENT
        try :
        INDENT
            x = 1
            x += 1
            return x
        DEDENT
        except :
        INDENT
            time.sleep(x)
            x = 0
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48436211_48436441_34_42
48436211_48436441_8_13
Title: How does a node with return self work?(Python) 
----------------------------------------

def __str__(self) :
INDENT
    result = '<'
    p = self.head
    while p is not None :
    INDENT
        result += str(p) + ', '
        p = p.link
    DEDENT
    result += '>'
    return result
DEDENT
----------------------------------------

def __str__(self) :
INDENT
    if self.val == None :
    INDENT
        return ''
    DEDENT
    else :
    INDENT
        return str(self.val)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48436211_48436441_34_42
48436211_48514127_38_48
Title: How does a node with return self work?(Python) 
----------------------------------------

def __str__(self) :
INDENT
    result = '<'
    p = self.head
    while p is not None :
    INDENT
        result += str(p) + ', '
        p = p.link
    DEDENT
    result += '>'
    return result
DEDENT
----------------------------------------

def __str__(self) :
INDENT
    result = ''
    self.current = self.head
    while self.current.value is not None :
    INDENT
        if self.current.link.value is None :
        INDENT
            result += str(self.current.value)
        DEDENT
        else :
        INDENT
            result += str(self.current.value) + ' -> '
        DEDENT
        self.current = self.current.link
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48436211_48436441_8_13
48436211_48514127_38_48
Title: How does a node with return self work?(Python) 
----------------------------------------

def __str__(self) :
INDENT
    if self.val == None :
    INDENT
        return ''
    DEDENT
    else :
    INDENT
        return str(self.val)
    DEDENT
DEDENT
----------------------------------------

def __str__(self) :
INDENT
    result = ''
    self.current = self.head
    while self.current.value is not None :
    INDENT
        if self.current.link.value is None :
        INDENT
            result += str(self.current.value)
        DEDENT
        else :
        INDENT
            result += str(self.current.value) + ' -> '
        DEDENT
        self.current = self.current.link
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48440057_48440408_1_13
48440057_48440501_1_15
Title: Connecting input statement to a function in python 
----------------------------------------

def hammer_time(hour) :
INDENT
    if 7 < = hour < = 9 :
    INDENT
        print ("It's breakfast time!")
    DEDENT
    elif 12 < = hour < = 14 :
    INDENT
        print ("It's lunch time!")
    DEDENT
    elif 19 < = hour < = 21 :
    INDENT
        print ("It's dinner time!")
    DEDENT
    elif 22 > = hour or hour < = 4 :
    INDENT
        print ("It's hammer time!")
    DEDENT
    else :
    INDENT
        print ("Nothing is scheduled at this time.")
    DEDENT
DEDENT
----------------------------------------

def hammer_time(hour) :
INDENT
    if hour > = 7 and hour < = 9 :
    INDENT
        return "It's breakfast time!"
    DEDENT
    elif hour > = 12 and hour < = 2 :
    INDENT
        return "It's lunch time!"
    DEDENT
    elif hour > = 7 and hour < = 9 :
    INDENT
        return "It's dinner time!"
    DEDENT
    elif hour > = 10 and hour < = 4 :
    INDENT
        return "It's hammer time!"
    DEDENT
    else :
    INDENT
        return "Nothing is scheduled at this time."
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48446351_48447538_10_25
48446351_48452190_24_29
Title: Distinguish button_press_event from drag and zoom clicks in matplotlib 
----------------------------------------

def onrelease(event, ax) :
INDENT
    if event.inaxes == ax :
    INDENT
        if event.button == 1 and ((time.time() - ax.time_onclick) < MAX_CLICK_LENGTH) :
        INDENT
            print (event.xdata, event.ydata)
            ax.scatter(event.xdata, event.ydata)
            ax.figure.canvas.draw()
        DEDENT
        elif event.button == 2 :
        INDENT
            print ("scroll click")
        DEDENT
        elif event.button == 3 :
        INDENT
            print ("right click")
        DEDENT
        else :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def onrelease(self, event) :
INDENT
    if self.press and not self.move :
    INDENT
        self.onclick(event)
    DEDENT
    self.press = False; self.move = False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48462669_48462863_1_32
48462669_48462866_1_32
Title: Why is this object regarded as integer when I think it's a list? 
----------------------------------------

def numbers_in_lists(s) :
INDENT
    p = [int(x) for x in s]

    flag = False
    previous_high = 0

    r = []

    for num in p :
    INDENT
        if num < = previous_high and not flag :
        INDENT

            r.append([num])
            flag = True
        DEDENT
        elif num < previous_high and flag :
        INDENT

            r [- 1].append(num)
        DEDENT
        elif num > previous_high :
        INDENT

            r.append(num)
            previous_high = num
            flag = False
        DEDENT
    DEDENT
    return r
DEDENT
----------------------------------------

def numbers_in_lists(s) :
INDENT
    n = len(s)
    p = []
    i = 0
    while i < = n - 1 :
    INDENT
        p.append(int(s [i]))
        i = i + 1
    DEDENT
    r = [p [0]]
    if p [1] < = p [0] :
    INDENT
        r.append([p [1]])
        k = p [1]
    DEDENT
    else :
    INDENT
        r.append(p [1])
        k = - 1
    DEDENT
    if n < = 2 :
    INDENT
        return r
    DEDENT
    j = 2
    while j < = n - 1 :
    INDENT
        if p [j] < = p [j - 1] :
        INDENT
            if p [j - 1] < = p [j - 2] or p [j] < = k :
            INDENT
                r [- 1].append(p [j])
            DEDENT
            else :
            INDENT
                r.append([p [j]])
                k = p [j]
            DEDENT
        DEDENT
        else :
        INDENT
            if p [j] < = p [j - 2] or p [j] < = k :
            INDENT
                r [- 1].append(p [j])
            DEDENT
            else :
            INDENT
                r.append(p [j])
            DEDENT
        DEDENT
        j = j + 1
    DEDENT
    return r
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48479646_48479804_1_19
48479646_48480114_15_39
Title: "How to populate django form  based on two ModelForm" 
----------------------------------------

def Edit_Vendor_Profile(request, pk) :
INDENT
    user = User.objects.get(pk = pk)
    if request.method == "POST" :
    INDENT
        vendor_form = VendorProfileForm(request.POST, request.FILES,
            instance = user.vendor)
        user_form = UserForm(request.POST, instance = user)
        if vendor_form.is_valid() and user_form.is_valid() :
        INDENT
            vendor_form.save()
            user_form.save()
            return HttpResponseRedirect('/profile/')
        DEDENT
    DEDENT
    else :
    INDENT
        vendor_form = VendorProfileForm(instance = user.vendor)
        user_form = UserForm(instance = user)
        return render(request, "accounts/update.html", {'vendor_form' : vendor_form, 'user_form' : user_form})
    DEDENT
DEDENT
----------------------------------------

def Edit_Vendor_Profile(request, pk) :
INDENT
    user = User.objects.get(pk = pk)
    vendor = Vendor.objects.get(id = user.id)
    user_form = UserForm(instance = user)
    vndor_form = Vendor(instance = vendor)
    if request.method == "POST" :
    INDENT
        vendor_form = VendorProfileForm(request.POST, request.FILES,
            instance = vendor)
        user_form = UserForm(request.POST, instance = user)
        if user_form.is_valid() :
        INDENT
            created_user = user.save()(commit = False)
            vendor_form = VendorProfileForm(request.POST, request.FILES,
                instance = created_user)
            if vendor_form.is_valid() :
            INDENT
                created_user.save()
                vendor_form.save()
            DEDENT
            return HttpResponseRedirect('/profile/')
        DEDENT
    DEDENT
    else :
    INDENT
        vendor_form = VendorProfileForm()
        user_form = UserForm()
        return render(request, "accounts/update.html", {'vendor_form' : vendor_form, 'user_form' : user_form})
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48483339_48483392_6_13
48483339_48483540_1_10
Title: how to repeat taking input until expected value 
----------------------------------------

def n_g() :
INDENT
    first_input = input("are you okay?")
    if first_input == "good" :
    INDENT

        conf()
        return "Nice"
    DEDENT
    else :
    INDENT
        return n_g()
    DEDENT
DEDENT
----------------------------------------

def n_g(check) :
INDENT
    if check == False :
    INDENT
        first_input = input("are you okay?")
    DEDENT
    else :
    INDENT
        first_input = "good"
    DEDENT
    if first_input == "good" :
    INDENT
        if input("are you sure") == "yes" :
        INDENT
            return "Nice"
        DEDENT
        return n_g(True)
    DEDENT
    return n_g(False)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48496155_48502953_59_89
48496155_48502953_7_16
Title: "Tkinter: Trying to get a checklist that strikeouts labels and sends them to the bottom of the list but it fails after the first one" 
----------------------------------------

def __init__(self, controller) :
INDENT
    tk.Toplevel.__init__(self, controller)
    self.controller = controller

    self.checkbuttons = []
    self.button_vars = []

    self.checklist_details = ["A", "B", "C"]
    '''For each item in the checklist, create an IntVar, checkbuttons, labels for the checklists
       (checkbutton text can't be struckthrough) and grid them'''

    for i, item in enumerate(self.checklist_details) :
    INDENT

        self.button_vars.append(IntVar())
        self.checkbuttons.append(tk.Checkbutton(self, variable = self.button_vars [i],
                onvalue = 1, offvalue = 0, command = lambda i = i : controller.check_off(i),
                text = item, font = controller.normal_Font))
        self.checkbuttons [i].grid(column = 0, row = i + 1)

    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, * args, ** kwargs)

    self.normal_Font = tkFont.Font(family = "Helvetica", size = 12, overstrike = 0)
    self.strike_Font = tkFont.Font(family = "Helvetica", size = 12, overstrike = 1)
    self.popup = Popup(self)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48503385_48503553_6_13
48503385_48504168_1_8
Title: Depth of Tuple Tree Structure in Python 
----------------------------------------

def depth(b, count = 0) :
INDENT
    if isinstance(b, str) or isinstance(b, int) or all(not isinstance(i, tuple) for i in b) :
    INDENT
        yield count + 1
    DEDENT
    else :
    INDENT
        for i in b :
        INDENT
            for c in depth(i, count + 1) :
            INDENT
                yield c
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def depth(l) :
INDENT
    depths = [depth(item) for item in l if isinstance(item, tuple)]
    if len(depths) > 0 :
    INDENT
        return 1 + max(depths)
    DEDENT
    return 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48505498_48505593_5_9
48505498_48505632_5_9
Title: every time i run an program i get error: there is an error in your program: expected an indented bloak 
----------------------------------------

def polygon(t, n, length) :
INDENT
    angle = 360.0 / n
    for i in range(n) :
    INDENT
        fd(t, length)
        lt(t, angle)
    DEDENT
DEDENT
----------------------------------------

def polygon(t, n, length) :
INDENT
    angle = 360.0 / n
    for i in range(n) :
    INDENT
        fd(t, length)
        lt(t, angle)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48509363_48509453_11_17
48509363_48509592_15_24
Title: Python 3.x: function that deals cards to x amount of players and makes a list 
----------------------------------------

def cards(deck, number_players) :
INDENT
    hands = []
    for i in range(number_players) :
    INDENT
        hands.append([deck.pop(), deck.pop()])
    DEDENT
    return hands

DEDENT
----------------------------------------

def cards(number_players) :
INDENT
    deck = make_deck()
    hands = []
    for i in range(number_players) :
    INDENT

        hands.append([deck.pop(), deck.pop()])
    DEDENT
    return hands
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48509718_48509817_1_15
48509718_48510176_31_38
Title: Simple Python program won't return error message 
----------------------------------------

def bookcost() :
INDENT
    if floatCostOfBook < = 0 :
    INDENT
        print ("Invalid Entry")
    DEDENT
    elif intNumOfBooks == 1 :
    INDENT
        totalcost = CostofFirstBook
        return round(totalcost, 2)
    DEDENT
    elif intNumOfBooks > 1 :
    INDENT
        totalcost = CostofFirstBook + CostofAddBooks
        return round(totalcost, 2)
    DEDENT
    elif intNumOfBooks < 1 :
    INDENT
        print ("Invalid entry")
    DEDENT
    else :
    INDENT
        print ("Internal Error")
    DEDENT
DEDENT
----------------------------------------

def bookcost() :
INDENT
    if num_of_books == 1 :
    INDENT
        total_cost = cost_of_first_book
        return round(total_cost, 2)
    DEDENT
    elif num_of_books > 1 :
    INDENT
        total_cost = cost_of_first_book + add_books_cost
        return round(total_cost, 2)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48516434_48539673_28_36
48516434_48539673_8_22
Title: best tool for rendering short items of text in wxPython and Kivi 
----------------------------------------

def __init__(self, parent, * args, ** kwargs) :
INDENT
    wx.Panel.__init__(self, parent, * args, ** kwargs)
    display_style = wx.VSCROLL | wx.HSCROLL | wx.TE_READONLY | wx.BORDER_SIMPLE
    self.html = wxhtml.HtmlWindow(self, - 1, size = (300, 200),
        style = display_style)
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(self.html)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, * args, ** kwargs)
    self.panel = MainPanel(self)
    sizer = wx.BoxSizer()
    sizer.Add(self.panel)
    self.SetSizerAndFit(sizer)
    self.Show()
    input_string = ("Heading\n"
        "=======\n"
        "\n"
        "1. With 24 widgets pull a **long** one;\n"
        "2. with fewer, push a **wide** one.\n")
    self.display_rst(input_string)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48519768_48528280_2_12
48519768_48538519_2_13
Title: Automatically create one2many fields 
----------------------------------------

def automate_creation(self) :
INDENT
    self.number_of_slices = (self.how_much / self.fixed_amount)
    i = 0
    while i < 10 :
    INDENT
        term = self.line_ids.create({'value' : 'fixed',
                'value_amount' : 100,
                'days' : 30,
                'option' : 'day_after_invoice_date',
                'payment_id' : self._origin.id})
        self.line_ids |= term
        i = i + 1
    DEDENT
DEDENT
----------------------------------------

def automate_creation(self) :
INDENT
    terms = self.line_ids.browse([])
    self.number_of_slices = (self.how_much / self.fixed_amount)
    days = 30
    i = 0
    while i < self.number_of_slices :
    INDENT
        terms += terms.new({'value' : 'fixed',
                'value_amount' : self.fixed_amount,
                'days' : days,
                'option' : 'day_after_invoice_date',
                'payment_id' : self._origin.id})
    DEDENT
    self.line_ids = terms
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48532301_49366850_104_110
48532301_49366850_176_186
Title: Python Postgres psycopg2 ThreadedConnectionPool exhausted 
----------------------------------------

def __init__(self, maxsize = config_opts ['poolsize']) :
INDENT
    if not isinstance(maxsize, integer_types) :
    INDENT
        raise TypeError('Expected integer, got %r' % (maxsize,))
    DEDENT
    self.maxsize = maxsize
    self.pool = Queue()
    self.size = 0
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    try :
    INDENT
        self.pconnect = ThreadedConnectionPool(1, poolsize, dsn = pdsn)
    DEDENT
    except :
    INDENT
        global _pgpool
        _pgpool = None
        raise ConnectorError('Database Connection Failed')
    DEDENT
    maxsize = kwargs.pop('maxsize', None)
    self.kwargs = kwargs
    AbstractDatabaseConnectionPool.__init__(self, maxsize)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48532301_49366850_104_110
48532301_49366850_38_48
Title: Python Postgres psycopg2 ThreadedConnectionPool exhausted 
----------------------------------------

def __init__(self, maxsize = config_opts ['poolsize']) :
INDENT
    if not isinstance(maxsize, integer_types) :
    INDENT
        raise TypeError('Expected integer, got %r' % (maxsize,))
    DEDENT
    self.maxsize = maxsize
    self.pool = Queue()
    self.size = 0
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    global _pgpool
    if not _pgpool :
    INDENT
        while not _pgpool :
        INDENT
            try :
            INDENT
                pgpool()
            DEDENT
            except :
            INDENT
                logger.debug('Attempting Connection To Postgres...')
                gevent.sleep(1)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48532301_49366850_176_186
48532301_49366850_38_48
Title: Python Postgres psycopg2 ThreadedConnectionPool exhausted 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    try :
    INDENT
        self.pconnect = ThreadedConnectionPool(1, poolsize, dsn = pdsn)
    DEDENT
    except :
    INDENT
        global _pgpool
        _pgpool = None
        raise ConnectorError('Database Connection Failed')
    DEDENT
    maxsize = kwargs.pop('maxsize', None)
    self.kwargs = kwargs
    AbstractDatabaseConnectionPool.__init__(self, maxsize)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    global _pgpool
    if not _pgpool :
    INDENT
        while not _pgpool :
        INDENT
            try :
            INDENT
                pgpool()
            DEDENT
            except :
            INDENT
                logger.debug('Attempting Connection To Postgres...')
                gevent.sleep(1)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48533060_48533238_17_24
48533060_48533530_6_12
Title: Views/Templates returning incorrect information in Django 
----------------------------------------

def get_queryset(self) :
INDENT
    queryset = self.queryset
    category = self.get_category()
    if category :
    INDENT
        return queryset.filter(category = category).all()
    DEDENT
    else :
    INDENT
        return queryset
    DEDENT
DEDENT
----------------------------------------

def get_queryset(self) :
INDENT
    category = self.kwargs.get("category")
    if category :
    INDENT
        queryset = Product.objects.filter(category__iexact = category)
    DEDENT
    else :
    INDENT
        queryset = Product.objects.all()
    DEDENT
    return queryset
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48536295_48536495_4_11
48536295_48536592_1_11
Title: Inverse of string format in python 
----------------------------------------

def fun() :
INDENT
    k = 'Alice 10 F'
    c = '{name:} {age:} {gender}'
    l = re.sub('[:}{]', '', c)
    d = {}
    for i, j in zip(k.split(), l.split()) :
    INDENT
        d [j] = i
    DEDENT
    print (d)
DEDENT
----------------------------------------

def fun(** kwargs) :
INDENT
    result = '{'
    for key, value in kwargs.iteritems() :
    INDENT
        result += '{}:{} '.format(key, value)

    DEDENT
    result = result [: - 1]
    result += '}'
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48543779_48544001_1_14
48543779_48544033_1_26
Title: Need to initialize empty list within recursive function only once on the first call. if conditioning on a depth variable doesn't work 
----------------------------------------

def split(arr, splitted = None) :
INDENT
    if splitted == None :
    INDENT
        print ("hey")
        splitted = []
        print ('splitted initialized')
    DEDENT
    a1 = arr [: len(arr) / / 2]
    a2 = arr [len(arr) / / 2 :]
    if len(a1) > 2 :
    INDENT
        print ("splitting " + str(a1))
        split(a1, splitted)

    DEDENT
DEDENT
----------------------------------------

def split(arr, res, i = 0) :
INDENT
    if i == 0 :
    INDENT
        print ("hey")
        print ('splitted initialized')
    DEDENT
    a1 = arr [: len(arr) / / 2]
    a2 = arr [len(arr) / / 2 :]
    if len(a1) > 2 :
    INDENT
        print ("splitting " + str(a1))
        i += 1
        split(a1, res, i)
    DEDENT
    else :
    INDENT
        print ("not splitting " + str(a1))
        res.append(a1)
    DEDENT
    if len(a2) > 2 :
    INDENT
        print ("splitting " + str(a2))
        i += 1
        split(a2, res, i)
    DEDENT
    else :
    INDENT
        print ("not splitting " + str(a2))
        res.append(a2)
    DEDENT
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48543779_48544001_1_14
48543779_48551851_4_10
Title: Need to initialize empty list within recursive function only once on the first call. if conditioning on a depth variable doesn't work 
----------------------------------------

def split(arr, splitted = None) :
INDENT
    if splitted == None :
    INDENT
        print ("hey")
        splitted = []
        print ('splitted initialized')
    DEDENT
    a1 = arr [: len(arr) / / 2]
    a2 = arr [len(arr) / / 2 :]
    if len(a1) > 2 :
    INDENT
        print ("splitting " + str(a1))
        split(a1, splitted)

    DEDENT
DEDENT
----------------------------------------

def split(ls) :
INDENT
    if len(ls) < 3 :
    INDENT
        return [ls]
    DEDENT
    else :
    INDENT
        return cut_at_index(ls, len(ls) / / 2, lambda left, right :
            split(left) + split(right))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48543779_48544033_1_26
48543779_48551851_4_10
Title: Need to initialize empty list within recursive function only once on the first call. if conditioning on a depth variable doesn't work 
----------------------------------------

def split(arr, res, i = 0) :
INDENT
    if i == 0 :
    INDENT
        print ("hey")
        print ('splitted initialized')
    DEDENT
    a1 = arr [: len(arr) / / 2]
    a2 = arr [len(arr) / / 2 :]
    if len(a1) > 2 :
    INDENT
        print ("splitting " + str(a1))
        i += 1
        split(a1, res, i)
    DEDENT
    else :
    INDENT
        print ("not splitting " + str(a1))
        res.append(a1)
    DEDENT
    if len(a2) > 2 :
    INDENT
        print ("splitting " + str(a2))
        i += 1
        split(a2, res, i)
    DEDENT
    else :
    INDENT
        print ("not splitting " + str(a2))
        res.append(a2)
    DEDENT
    return
DEDENT
----------------------------------------

def split(ls) :
INDENT
    if len(ls) < 3 :
    INDENT
        return [ls]
    DEDENT
    else :
    INDENT
        return cut_at_index(ls, len(ls) / / 2, lambda left, right :
            split(left) + split(right))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48545516_48558233_26_39
48545516_48558233_9_18
Title: Creating a 'frame' that hides all but what it contains in pygame 
----------------------------------------

def __init__(self, grp, bounds) :
INDENT
    self._layer = 1000
    pg.sprite.Sprite.__init__(self, grp)
    self.image = pg.Surface((bounds.width, bounds.height))
    self.image.set_colorkey(pg.Color('yellow'))

    self.image.fill(pg.Color('black'))
    self.rect = self.image.get_rect()
    self.start = None
    self.inner_rect = None
DEDENT
----------------------------------------

def __init__(self, grp, bounds, pos) :
INDENT
    self._layer = 0
    pg.sprite.Sprite.__init__(self, grp)
    self.image = IMAGE
    self.rect = self.image.get_rect(center = pos)
    self.vec = pg.math.Vector2()
    self.vec.from_polar((10, random.randrange(0, 360)))
    self.bounds = bounds
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48572558_48576183_42_63
48572558_48597116_21_25
Title: Parsing a file with special format using python to a list of dictionaries 
----------------------------------------

def parse(self) :
INDENT
    current = next(self.tokens, None)
    if current :
    INDENT
        if current.type == 'start' :
        INDENT
            self.starts.append(current.value)
            self.parse()
        DEDENT
        if current.type == 'key' :
        INDENT
            self.k = current.value
            self.k_list.append(self.k)
            self.parse()
        DEDENT
        if current.type not in ['start', 'end', 'key'] :
        INDENT
            if len(self.starts) == 1 :
            INDENT
                self.d [self.k] = current.value [1 : - 1] if current.value.startswith('"') and current.value.endswith('"') else current.value
                self.parse()
            DEDENT
            else :
            INDENT
                self.current_d [self.k_list [- 1]] = current.value [1 : - 1] if current.value.startswith('"') and current.value.endswith('"') else current.value
                self.parse()
            DEDENT
        DEDENT
        if current.type == 'end' :
        INDENT
            end = self.starts.pop()
            self.d [self.k_list [- len(self.starts) - 1]] = self.current_d
            self.current_d = {}
            self.parse()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def parse(text_input) :
INDENT
    output = defaultdict(list)
    for key, val in file_format.parse(text_input) :
    INDENT
        output [key].append(val)
    DEDENT
    return dict(output)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48600328_48602032_27_37
48600328_48602032_7_18
Title: How to pass value from one dialog to another 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Dialog, self).__init__(parent)
    self.setLayout(QVBoxLayout())
    button = QPushButton('Show modal dialog')
    button.clicked.connect(self.showModal)
    self.label = QLabel('Default text value')
    self.layout().addWidget(self.label)
    self.layout().addWidget(button)
    self.resize(200, 50)
    self.show()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(Modal, self).__init__(parent)
    self.setLayout(QVBoxLayout())
    self.lineedit = QLineEdit(self)
    self.layout().addWidget(self.lineedit)
    button = QPushButton(self)
    button.setText('Confirm')
    button.clicked.connect(partial(self.confirm, parent))
    self.layout().addWidget(button)
    self.setModal(True)
    self.exec_()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48621973_48622097_3_15
48621973_48622466_1_11
Title: "Accessing key value in a nested dictionary" 
----------------------------------------

def get_key_value_of_nested_dict(nested_dict, outer_key = None) :
INDENT
    inner_key = None
    inner_value = None
    for key, value in nested_dict.items() :
    INDENT
        if isinstance(value, dict) :
        INDENT
            outer_key = key
            return get_key_value_of_nested_dict(value, key)
        DEDENT
        else :
        INDENT
            inner_key = key
            inner_value = value
        DEDENT
        return outer_key, inner_key, inner_value
    DEDENT
DEDENT
----------------------------------------

def get_key_value_of_nested_dict(nested_dict) :
INDENT
    rv = []
    for outer_key, value in nested_dict.items() :
    INDENT
        try :
        INDENT
            inner_kvs = get_key_value_of_nested_dict(value)
            for i_kvs in inner_kvs :
            INDENT
                rv.append((outer_key,) + i_kvs)
            DEDENT
        DEDENT
        except AttributeError :
        INDENT
            rv.append((outer_key, value))
        DEDENT
    DEDENT
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48624104_48630532_46_53
48624104_48630532_9_23
Title: pyqt update qgraphicsscene with mousewheelevent output 
----------------------------------------

def __init__(self) :
INDENT
    super(Mainwidget, self).__init__()
    image_viewer = DCMViewer()
    self.setCentralWidget(image_viewer)
    self.showFullScreen()
    image_viewer.scrollToItem(0)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(DCMViewer, self).__init__()
    self.currentId = 0
    self.maxId = 0
    self.setScene(QGraphicsScene())
    directory = QStandardPaths.writableLocation(QStandardPaths.PicturesLocation)
    it = QDirIterator(directory, QDir.Files)
    while it.hasNext() :
    INDENT
        pixmap = QPixmap(it.next())
        item = QGraphicsPixmapItem(pixmap)
        item.setData(0, self.maxId)
        self.scene().addItem(item)
        self.maxId += 1
    DEDENT
DEDENT
----------------------------------------
