$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8280648_8298916_33_48
8280648_8298916_9_20
Title: wxPython Splitter windows and Panels 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "Splitter Tutorial")
    splitter = wx.SplitterWindow(self)
    leftP = LeftPanel(splitter)
    rightP = RightPanel(splitter)

    splitter.SplitVertically(leftP, rightP)
    splitter.SetMinimumPaneSize(20)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(splitter, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(25, 12)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8282558_8282680_1_9
8282558_8282768_1_11
Title: Combining two sets and splitting them in pairs 
----------------------------------------

def mating_pairs(males, females) :
INDENT
    res = set()
    males_copy, females_copy = males.copy(), females.copy()
    while males_copy and females_copy :
    INDENT
        res.add((males_copy.pop(), females_copy.pop()))
    DEDENT
    return res
DEDENT
----------------------------------------

def mating_pairs(males, females) :
INDENT
    pairs = set()

    for male in males :
    INDENT
        for female in females :
        INDENT

            pairs.add((male, female))
        DEDENT
    DEDENT
    return pairs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8306654_20955291_1_17
8306654_41081810_1_10
Title: Finding all possible permutations of a given string in python 
----------------------------------------

def permutations(string, step = 0) :
INDENT
    if step == len(string) :
    INDENT
        print "".join(string)
    DEDENT
    for i in range(step, len(string)) :
    INDENT

        string_copy = [character for character in string]

        string_copy [step], string_copy [i] = string_copy [i], string_copy [step]

        permutations(string_copy, step + 1)
    DEDENT
DEDENT
----------------------------------------

def permutations(string) :
INDENT
    if len(string) == 1 :
    INDENT
        return string
    DEDENT
    recursive_perms = []
    for c in string :
    INDENT
        for perm in permutations(string.replace(c, '', 1)) :
        INDENT
            revursive_perms.append(c + perm)
        DEDENT
    DEDENT
    return set(revursive_perms)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8306654_20955291_1_17
8306654_46395041_1_10
Title: Finding all possible permutations of a given string in python 
----------------------------------------

def permutations(string, step = 0) :
INDENT
    if step == len(string) :
    INDENT
        print "".join(string)
    DEDENT
    for i in range(step, len(string)) :
    INDENT

        string_copy = [character for character in string]

        string_copy [step], string_copy [i] = string_copy [i], string_copy [step]

        permutations(string_copy, step + 1)
    DEDENT
DEDENT
----------------------------------------

def permutations(string) :
INDENT
    permutation_list = []
    if len(string) == 1 :
    INDENT
        return [string]
    DEDENT
    else :
    INDENT
        for char in string :
        INDENT
            [permutation_list.append(char + a) for a in permutations(string.replace(char, ""))]
        DEDENT
    DEDENT
    return permutation_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8306654_41081810_1_10
8306654_46395041_1_10
Title: Finding all possible permutations of a given string in python 
----------------------------------------

def permutations(string) :
INDENT
    if len(string) == 1 :
    INDENT
        return string
    DEDENT
    recursive_perms = []
    for c in string :
    INDENT
        for perm in permutations(string.replace(c, '', 1)) :
        INDENT
            revursive_perms.append(c + perm)
        DEDENT
    DEDENT
    return set(revursive_perms)
DEDENT
----------------------------------------

def permutations(string) :
INDENT
    permutation_list = []
    if len(string) == 1 :
    INDENT
        return [string]
    DEDENT
    else :
    INDENT
        for char in string :
        INDENT
            [permutation_list.append(char + a) for a in permutations(string.replace(char, ""))]
        DEDENT
    DEDENT
    return permutation_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8315389_53404188_8_37
8315389_8315566_1_9
Title: How do I print functions as they are called 
----------------------------------------

def tracefunc(frame, event, arg) :
INDENT
    if event == "call" :
    INDENT
        tracefunc.stack_level += 1
        unique_id = frame.f_code.co_filename + str(frame.f_lineno)
        if unique_id in tracefunc.memorized :
        INDENT
            return
        DEDENT
        if any(x in frame.f_code.co_filename for x in WHITE_LIST) and not any(x in frame.f_code.co_name for x in EXCLUSIONS) :
        INDENT
            if 'self' in frame.f_locals :
            INDENT
                class_name = frame.f_locals ['self'].__class__.__name__
                func_name = class_name + '.' + frame.f_code.co_name
            DEDENT
            else :
            INDENT
                func_name = frame.f_code.co_name
            DEDENT
            func_name = '{name:->{indent}s}()'.format(
                indent = tracefunc.stack_level * 2, name = func_name)
            txt = '{: <40} # {}, {}'.format(
                func_name, frame.f_code.co_filename, frame.f_lineno)
            print (txt)
            tracefunc.memorized.add(unique_id)
        DEDENT
    DEDENT
    elif event == "return" :
    INDENT
        tracefunc.stack_level -= 1

    DEDENT
DEDENT
----------------------------------------

def tracefunc(frame, event, arg, indent = [0]) :
INDENT
    if event == "call" :
    INDENT
        indent [0] += 2
        print "-" * indent [0] + "><![CDATA[ call function", frame.f_code.co_name
    DEDENT
    elif event == "return" :
    INDENT
        print "<" + "-" * indent [0], "exit function", frame.f_code.co_name
        indent [0] -= 2
    DEDENT
    return tracefunc
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8334240_8338446_18_33
8334240_8338446_36_56
Title: wxPython: scrollbars interfering with formatting 
----------------------------------------

def __init__(self, parent, title, size = (300, 350)) :
INDENT
    super(Example, self).__init__(parent, title = title)
    self.panelOne = MyPanel(self, size)
    self.frameSizer = wx.BoxSizer(wx.VERTICAL)
    self.frameSizer.Add(self.panelOne, 1, wx.EXPAND)
    self.SetSizer(self.frameSizer)
    self.frameSizer.Layout()
    self.Centre()
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent, size) :
INDENT
    super(MyPanel, self).__init__(parent)
    self.mainSizer = wx.BoxSizer(wx.VERTICAL)
    self.SetScrollbars(1, 1, 400, 200)
    self.entryGrid = wx.FlexGridSizer(cols = 8, rows = 10)
    for i in range(80) :
    INDENT
        x = wx.StaticText(self, label = str(i))
        self.entryGrid.Add(x, 1, wx.ALL, 20)
    DEDENT
    self.mainSizer.Add(self.entryGrid)
    self.SetSizer(self.mainSizer)
    self.SetSizeHints(* size)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8340584_8340812_1_17
8340584_8341201_3_19
Title: How to make a random but partial shuffle in Python? 
----------------------------------------

def partial_shuffle(st, p = 20) :
INDENT
    p = int(round(p / 100.0 * len(st)))
    idx = range(len(s))
    sample = random.sample(idx, p)
    res = str()
    samptrav = 1
    for i in range(len(st)) :
    INDENT
        if i in sample :
        INDENT
            res += st [sample [- samptrav]]
            samptrav += 1
            continue
        DEDENT
        res += st [i]
    DEDENT
    return res
DEDENT
----------------------------------------

def partial_shuffle(a, part = 0.5) :
INDENT
    idx_todo = random.sample(xrange(len(a)), int(len(a) * part))

    idx_target = idx_todo [:]
    random.shuffle(idx_target)

    mapper = dict((i, i) for i in xrange(len(a)))

    mapper.update(zip(idx_todo, idx_target))

    return ''.join(a [mapper [i]] for i in xrange(len(a)))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8360710_8361208_3_9
8360710_8361291_5_34
Title: How can I write a generic Python 2.2 function that returns a list of unset parameters? 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    params = needed_params.copy()
    params.update(kwargs)
    for key, value in params.iteritems() :
    INDENT
        if not value :
        INDENT
            raise TypeError("You need to provide the argument '%s'" % key)
        DEDENT
    DEDENT
    return target(** params)
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    code = func.func_code
    argsreq = code.co_argcount - 1
    argsrec = len(args)
    posargs = code.co_varnames [1 : argsreq + 1]
    errs = []

    for i, arg in enumerate(args) :
    INDENT
        if i == len(posargs) :
        INDENT
            break
        DEDENT
        if not (arg or arg is False) :
        INDENT
            argname = posargs [i]
            if argname in requiredargs :
            INDENT
                errs.append(argname + " (" + requiredargs [argname] + ")")

            DEDENT
        DEDENT
    DEDENT
    for argname, arg in kwargs.iteritems() :
    INDENT
        if argname in requiredargs :
        INDENT
            if not (arg or arg is False) :
            INDENT
                errs.append(argname + " (" + requiredargs [argname] + ")")

            DEDENT
        DEDENT
    DEDENT
    for argname in requiredargs :
    INDENT
        if argname not in kwargs and argname not in posargs :
        INDENT
            errs.append(argname + " (" + requiredargs [argname] + ")")
        DEDENT
    DEDENT
    return func(errs, * args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_20788031_1_12
8385120_35690157_1_11
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    total = 0
    i = 0
    while i < len(nums) :
    INDENT
        if nums [i] == 6 :
        INDENT
            while nums [i] ! = 7 :
            INDENT
                i += 1
            DEDENT
            i += 1
        DEDENT
        if i < len(nums) and nums [i] ! = 6 :
        INDENT
            total += nums [i]
            i += 1
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    result = 0
    flag = True
    for num in nums :
    INDENT
        if num == 6 :
        INDENT
            flag = False
        DEDENT
        if flag :
        INDENT
            result += num
        DEDENT
        if num == 7 :
        INDENT
            flag = True
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_20788031_1_12
8385120_38890279_28_36
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    total = 0
    i = 0
    while i < len(nums) :
    INDENT
        if nums [i] == 6 :
        INDENT
            while nums [i] ! = 7 :
            INDENT
                i += 1
            DEDENT
            i += 1
        DEDENT
        if i < len(nums) and nums [i] ! = 6 :
        INDENT
            total += nums [i]
            i += 1
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    detect67(nums)
    sums = 0
    if nums == [] :
    INDENT
        return 0
    DEDENT
    for i in range(len(nums)) :
    INDENT
        sums += nums [i]
    DEDENT
    return sums
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_20788031_1_12
8385120_51527055_1_16
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    total = 0
    i = 0
    while i < len(nums) :
    INDENT
        if nums [i] == 6 :
        INDENT
            while nums [i] ! = 7 :
            INDENT
                i += 1
            DEDENT
            i += 1
        DEDENT
        if i < len(nums) and nums [i] ! = 6 :
        INDENT
            total += nums [i]
            i += 1
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    s = 0
    flag = 1
    for n in nums :
    INDENT
        while flag :
        INDENT
            if n ! = 6 :
            INDENT
                s += n
                break
            DEDENT
            else :
            INDENT
                flag = 0
            DEDENT
        DEDENT
        while not flag :
        INDENT
            if n ! = 9 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                flag = 1
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_20788031_1_12
8385120_52880420_1_17
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    total = 0
    i = 0
    while i < len(nums) :
    INDENT
        if nums [i] == 6 :
        INDENT
            while nums [i] ! = 7 :
            INDENT
                i += 1
            DEDENT
            i += 1
        DEDENT
        if i < len(nums) and nums [i] ! = 6 :
        INDENT
            total += nums [i]
            i += 1
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------

def sum67(arr) :
INDENT
    sum = 0
    tmp = 0
    for n in arr :
    INDENT
        if n == 6 :
        INDENT
            tmp = 6
            continue
        DEDENT
        if tmp == 6 :
        INDENT
            if n == 7 :
            INDENT
                tmp = 0
                continue
            DEDENT
            elif arr [- 1] == 7 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                continue
            DEDENT
        DEDENT
        sum += n
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_20788031_1_12
8385120_8385246_1_13
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    total = 0
    i = 0
    while i < len(nums) :
    INDENT
        if nums [i] == 6 :
        INDENT
            while nums [i] ! = 7 :
            INDENT
                i += 1
            DEDENT
            i += 1
        DEDENT
        if i < len(nums) and nums [i] ! = 6 :
        INDENT
            total += nums [i]
            i += 1
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    state = 0
    s = 0
    for n in nums :
    INDENT
        if state == 0 :
        INDENT
            if n == 6 :
            INDENT
                state = 1
            DEDENT
            else :
            INDENT
                s += n
            DEDENT
        DEDENT
        else :
        INDENT
            if n == 7 :
            INDENT
                state = 0
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_35690157_1_11
8385120_38890279_28_36
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    result = 0
    flag = True
    for num in nums :
    INDENT
        if num == 6 :
        INDENT
            flag = False
        DEDENT
        if flag :
        INDENT
            result += num
        DEDENT
        if num == 7 :
        INDENT
            flag = True
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    detect67(nums)
    sums = 0
    if nums == [] :
    INDENT
        return 0
    DEDENT
    for i in range(len(nums)) :
    INDENT
        sums += nums [i]
    DEDENT
    return sums
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_35690157_1_11
8385120_49972155_1_12
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    result = 0
    flag = True
    for num in nums :
    INDENT
        if num == 6 :
        INDENT
            flag = False
        DEDENT
        if flag :
        INDENT
            result += num
        DEDENT
        if num == 7 :
        INDENT
            flag = True
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def sum67(anArray) :
INDENT
    arrTotal = 0
    n = 0
    while n < len(anArray) :
    INDENT
        if anArray [n] == 6 :
        INDENT
            while anArray [n] ! = 7 :
            INDENT
                n += 1
            DEDENT
            n += 1
        DEDENT
        elif anArray [n] ! = 6 :
        INDENT
            arrTotal += anArray [n]
            n += 1
        DEDENT
    DEDENT
    return arrTotal
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_35690157_1_11
8385120_51527055_1_16
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    result = 0
    flag = True
    for num in nums :
    INDENT
        if num == 6 :
        INDENT
            flag = False
        DEDENT
        if flag :
        INDENT
            result += num
        DEDENT
        if num == 7 :
        INDENT
            flag = True
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    s = 0
    flag = 1
    for n in nums :
    INDENT
        while flag :
        INDENT
            if n ! = 6 :
            INDENT
                s += n
                break
            DEDENT
            else :
            INDENT
                flag = 0
            DEDENT
        DEDENT
        while not flag :
        INDENT
            if n ! = 9 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                flag = 1
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_35690157_1_11
8385120_52880420_1_17
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    result = 0
    flag = True
    for num in nums :
    INDENT
        if num == 6 :
        INDENT
            flag = False
        DEDENT
        if flag :
        INDENT
            result += num
        DEDENT
        if num == 7 :
        INDENT
            flag = True
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def sum67(arr) :
INDENT
    sum = 0
    tmp = 0
    for n in arr :
    INDENT
        if n == 6 :
        INDENT
            tmp = 6
            continue
        DEDENT
        if tmp == 6 :
        INDENT
            if n == 7 :
            INDENT
                tmp = 0
                continue
            DEDENT
            elif arr [- 1] == 7 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                continue
            DEDENT
        DEDENT
        sum += n
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_35690157_1_11
8385120_8385246_1_13
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    result = 0
    flag = True
    for num in nums :
    INDENT
        if num == 6 :
        INDENT
            flag = False
        DEDENT
        if flag :
        INDENT
            result += num
        DEDENT
        if num == 7 :
        INDENT
            flag = True
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    state = 0
    s = 0
    for n in nums :
    INDENT
        if state == 0 :
        INDENT
            if n == 6 :
            INDENT
                state = 1
            DEDENT
            else :
            INDENT
                s += n
            DEDENT
        DEDENT
        else :
        INDENT
            if n == 7 :
            INDENT
                state = 0
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_38890279_28_36
8385120_49972155_1_12
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    detect67(nums)
    sums = 0
    if nums == [] :
    INDENT
        return 0
    DEDENT
    for i in range(len(nums)) :
    INDENT
        sums += nums [i]
    DEDENT
    return sums
DEDENT
----------------------------------------

def sum67(anArray) :
INDENT
    arrTotal = 0
    n = 0
    while n < len(anArray) :
    INDENT
        if anArray [n] == 6 :
        INDENT
            while anArray [n] ! = 7 :
            INDENT
                n += 1
            DEDENT
            n += 1
        DEDENT
        elif anArray [n] ! = 6 :
        INDENT
            arrTotal += anArray [n]
            n += 1
        DEDENT
    DEDENT
    return arrTotal
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_38890279_28_36
8385120_51527055_1_16
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    detect67(nums)
    sums = 0
    if nums == [] :
    INDENT
        return 0
    DEDENT
    for i in range(len(nums)) :
    INDENT
        sums += nums [i]
    DEDENT
    return sums
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    s = 0
    flag = 1
    for n in nums :
    INDENT
        while flag :
        INDENT
            if n ! = 6 :
            INDENT
                s += n
                break
            DEDENT
            else :
            INDENT
                flag = 0
            DEDENT
        DEDENT
        while not flag :
        INDENT
            if n ! = 9 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                flag = 1
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_38890279_28_36
8385120_52880420_1_17
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    detect67(nums)
    sums = 0
    if nums == [] :
    INDENT
        return 0
    DEDENT
    for i in range(len(nums)) :
    INDENT
        sums += nums [i]
    DEDENT
    return sums
DEDENT
----------------------------------------

def sum67(arr) :
INDENT
    sum = 0
    tmp = 0
    for n in arr :
    INDENT
        if n == 6 :
        INDENT
            tmp = 6
            continue
        DEDENT
        if tmp == 6 :
        INDENT
            if n == 7 :
            INDENT
                tmp = 0
                continue
            DEDENT
            elif arr [- 1] == 7 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                continue
            DEDENT
        DEDENT
        sum += n
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_38890279_28_36
8385120_8385246_1_13
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    detect67(nums)
    sums = 0
    if nums == [] :
    INDENT
        return 0
    DEDENT
    for i in range(len(nums)) :
    INDENT
        sums += nums [i]
    DEDENT
    return sums
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    state = 0
    s = 0
    for n in nums :
    INDENT
        if state == 0 :
        INDENT
            if n == 6 :
            INDENT
                state = 1
            DEDENT
            else :
            INDENT
                s += n
            DEDENT
        DEDENT
        else :
        INDENT
            if n == 7 :
            INDENT
                state = 0
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_49972155_1_12
8385120_51527055_1_16
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(anArray) :
INDENT
    arrTotal = 0
    n = 0
    while n < len(anArray) :
    INDENT
        if anArray [n] == 6 :
        INDENT
            while anArray [n] ! = 7 :
            INDENT
                n += 1
            DEDENT
            n += 1
        DEDENT
        elif anArray [n] ! = 6 :
        INDENT
            arrTotal += anArray [n]
            n += 1
        DEDENT
    DEDENT
    return arrTotal
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    s = 0
    flag = 1
    for n in nums :
    INDENT
        while flag :
        INDENT
            if n ! = 6 :
            INDENT
                s += n
                break
            DEDENT
            else :
            INDENT
                flag = 0
            DEDENT
        DEDENT
        while not flag :
        INDENT
            if n ! = 9 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                flag = 1
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_49972155_1_12
8385120_52880420_1_17
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(anArray) :
INDENT
    arrTotal = 0
    n = 0
    while n < len(anArray) :
    INDENT
        if anArray [n] == 6 :
        INDENT
            while anArray [n] ! = 7 :
            INDENT
                n += 1
            DEDENT
            n += 1
        DEDENT
        elif anArray [n] ! = 6 :
        INDENT
            arrTotal += anArray [n]
            n += 1
        DEDENT
    DEDENT
    return arrTotal
DEDENT
----------------------------------------

def sum67(arr) :
INDENT
    sum = 0
    tmp = 0
    for n in arr :
    INDENT
        if n == 6 :
        INDENT
            tmp = 6
            continue
        DEDENT
        if tmp == 6 :
        INDENT
            if n == 7 :
            INDENT
                tmp = 0
                continue
            DEDENT
            elif arr [- 1] == 7 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                continue
            DEDENT
        DEDENT
        sum += n
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_49972155_1_12
8385120_8385246_1_13
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(anArray) :
INDENT
    arrTotal = 0
    n = 0
    while n < len(anArray) :
    INDENT
        if anArray [n] == 6 :
        INDENT
            while anArray [n] ! = 7 :
            INDENT
                n += 1
            DEDENT
            n += 1
        DEDENT
        elif anArray [n] ! = 6 :
        INDENT
            arrTotal += anArray [n]
            n += 1
        DEDENT
    DEDENT
    return arrTotal
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    state = 0
    s = 0
    for n in nums :
    INDENT
        if state == 0 :
        INDENT
            if n == 6 :
            INDENT
                state = 1
            DEDENT
            else :
            INDENT
                s += n
            DEDENT
        DEDENT
        else :
        INDENT
            if n == 7 :
            INDENT
                state = 0
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_51527055_1_16
8385120_52880420_1_17
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    s = 0
    flag = 1
    for n in nums :
    INDENT
        while flag :
        INDENT
            if n ! = 6 :
            INDENT
                s += n
                break
            DEDENT
            else :
            INDENT
                flag = 0
            DEDENT
        DEDENT
        while not flag :
        INDENT
            if n ! = 9 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                flag = 1
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------

def sum67(arr) :
INDENT
    sum = 0
    tmp = 0
    for n in arr :
    INDENT
        if n == 6 :
        INDENT
            tmp = 6
            continue
        DEDENT
        if tmp == 6 :
        INDENT
            if n == 7 :
            INDENT
                tmp = 0
                continue
            DEDENT
            elif arr [- 1] == 7 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                continue
            DEDENT
        DEDENT
        sum += n
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_51527055_1_16
8385120_8385246_1_13
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(nums) :
INDENT
    s = 0
    flag = 1
    for n in nums :
    INDENT
        while flag :
        INDENT
            if n ! = 6 :
            INDENT
                s += n
                break
            DEDENT
            else :
            INDENT
                flag = 0
            DEDENT
        DEDENT
        while not flag :
        INDENT
            if n ! = 9 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                flag = 1
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    state = 0
    s = 0
    for n in nums :
    INDENT
        if state == 0 :
        INDENT
            if n == 6 :
            INDENT
                state = 1
            DEDENT
            else :
            INDENT
                s += n
            DEDENT
        DEDENT
        else :
        INDENT
            if n == 7 :
            INDENT
                state = 0
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8385120_52880420_1_17
8385120_8385246_1_13
Title: CodingBat sum67: why is this solution wrong? 
----------------------------------------

def sum67(arr) :
INDENT
    sum = 0
    tmp = 0
    for n in arr :
    INDENT
        if n == 6 :
        INDENT
            tmp = 6
            continue
        DEDENT
        if tmp == 6 :
        INDENT
            if n == 7 :
            INDENT
                tmp = 0
                continue
            DEDENT
            elif arr [- 1] == 7 :
            INDENT
                break
            DEDENT
            else :
            INDENT
                continue
            DEDENT
        DEDENT
        sum += n
    DEDENT
    return sum
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    state = 0
    s = 0
    for n in nums :
    INDENT
        if state == 0 :
        INDENT
            if n == 6 :
            INDENT
                state = 1
            DEDENT
            else :
            INDENT
                s += n
            DEDENT
        DEDENT
        else :
        INDENT
            if n == 7 :
            INDENT
                state = 0
            DEDENT
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8436666_8436715_10_14
8436666_9207726_7_11
Title: How to make python on Heroku https only? 
----------------------------------------

def process_request(self, request) :
INDENT
    if not any([settings.DEBUG, request.is_secure()]) :
    INDENT
        url = request.build_absolute_uri(request.get_full_path())
        secure_url = url.replace("http://", "https://")
        return HttpResponseRedirect(secure_url)
    DEDENT
DEDENT
----------------------------------------

def process_request(self, request) :
INDENT
    if not any([settings.DEBUG, request.is_secure(), request.META.get("HTTP_X_FORWARDED_PROTO", "") == 'https']) :
    INDENT
        url = request.build_absolute_uri(request.get_full_path())
        secure_url = url.replace("http://", "https://")
        return HttpResponseRedirect(secure_url)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8439763_9089253_14_21
8439763_9089253_34_69
Title: "Generating a linear timeline-based representation from items that consume time and items which do not but still need space to be drawn on" 
----------------------------------------

def __init__(self, duration, displacement = 0, visible = True, time = None, row_id = None) :
INDENT
    self.duration = duration
    self.displacement = displacement
    self.visible = visible
    self.time = time
    self.row_id = row_id
    self.pos = None
DEDENT
----------------------------------------

def __init__(self, * args) :
INDENT
    list.__init__(self, * args)

    for i, row in enumerate(self) :
    INDENT
        t = 0
        for ev in row :
        INDENT
            ev.time = t
            t += ev.duration
            ev.row_id = i

        DEDENT
    DEDENT
    t2pos_disp = defaultdict(int)
    t2pos_ev = defaultdict(int)

    t_prev = 0
    for t, g in groupby(merge(* self), key = attrgetter("time")) :
    INDENT

        t2pos_ev [t] = t2pos_disp [t] = max(t2pos_ev [t], t2pos_ev [t_prev] + t - t_prev)
        t_prev = t
        for (duration, row_id), g_row in groupby(g, key = attrgetter("duration", "row_id")) :
        INDENT
            pos_ev = t2pos_ev [t] if duration > 0 else t2pos_disp [t]
            for ev in g_row :
            INDENT
                ev.pos = pos_ev
                pos_ev += ev.duration + ev.displacement
            DEDENT
            t2pos_ev [t + ev.duration] = max(t2pos_ev [t + ev.duration], pos_ev)

        DEDENT
    DEDENT
    self.t2pos_ev = t2pos_ev
    self.t2pos_disp = t2pos_disp

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8463271_17321410_1_17
8463271_42935184_1_26
Title: rotate text around its center in pycairo 
----------------------------------------

def text(ctx, string, pos, theta = 0.0, face = 'Georgia', font_size = 18) :
INDENT
    ctx.save()

    ctx.select_font_face(face, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
    ctx.set_font_size(font_size)
    fascent, fdescent, fheight, fxadvance, fyadvance = ctx.font_extents()
    x_off, y_off, tw, th = ctx.text_extents(string) [: 4]
    nx = - tw / 2.0
    ny = fheight / 2
    ctx.translate(pos [0], pos [1])
    ctx.rotate(theta)
    ctx.translate(nx, ny)
    ctx.move_to(0, 0)
    ctx.show_text(string)
    ctx.restore()
DEDENT
----------------------------------------

def text(self, text, x, y, rotation = 0, fontName = "Arial", fontSize = 10, verticalPadding = 0) :
INDENT
    rotation = rotation * math.pi / 180
    self.ctx.select_font_face(fontName, cairo.FONT_SLANT_NORMAL, cairo.FONT_WEIGHT_NORMAL)
    self.ctx.set_font_size(fontSize)
    fascent, fdescent, fheight, fxadvance, fyadvance = self.ctx.font_extents()
    self.ctx.save()
    self.ctx.translate(x, y)
    self.ctx.rotate(rotation)
    lines = text.split("\n")
    for i in xrange(len(lines)) :
    INDENT
        line = lines [i]
        xoff, yoff, textWidth, textHeight = self.ctx.text_extents(line) [: 4]
        offx = - textWidth / 2.0
        offy = (fheight / 2.0) + (fheight + verticalPadding) * i
        self.ctx.move_to(offx, offy)
        self.ctx.show_text(line)
    DEDENT
    self.ctx.restore()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8467978_43140586_21_30
8467978_9587563_15_50
Title: "Python want logging with log rotation and compression" 
----------------------------------------

def doRollover(self) :
INDENT
    super(TimedCompressedRotatingFileHandler, self).doRollover()
    dfn = self.find_last_rotated_file()
    dfn_zipped = '{}.zip'.format(dfn)
    if os.path.exists(dfn_zipped) :
    INDENT
        os.remove(dfn_zipped)
    DEDENT
    with zipfile.ZipFile(dfn_zipped, 'w') as f :
    INDENT
        f.write(dfn, dfn_zipped, zipfile.ZIP_DEFLATED)
    DEDENT
    os.remove(dfn)
DEDENT
----------------------------------------

def doRollover(self) :
INDENT
    self.stream.close()
    t = self.rolloverAt - self.interval
    timeTuple = time.localtime(t)
    dfn = self.baseFilename + "." + time.strftime(self.suffix, timeTuple)
    if os.path.exists(dfn) :
    INDENT
        os.remove(dfn)
    DEDENT
    os.rename(self.baseFilename, dfn)
    if self.backupCount > 0 :
    INDENT

        s = glob.glob(self.baseFilename + ".20*")
        if len(s) > self.backupCount :
        INDENT
            s.sort()
            os.remove(s [0])
        DEDENT
    DEDENT
    if self.encoding :
    INDENT
        self.stream = codecs.open(self.baseFilename, 'w', self.encoding)
    DEDENT
    else :
    INDENT
        self.stream = open(self.baseFilename, 'w')
    DEDENT
    self.rolloverAt = self.rolloverAt + self.interval
    if os.path.exists(dfn + ".zip") :
    INDENT
        os.remove(dfn + ".zip")
    DEDENT
    file = zipfile.ZipFile(dfn + ".zip", "w")
    file.write(dfn, os.path.basename(dfn), zipfile.ZIP_DEFLATED)
    file.close()
    os.remove(dfn)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8483344_8485554_7_20
8483344_8489991_6_24
Title: Incrementing a variable or assigning an iterator-element to it 
----------------------------------------

def fillDates(dates_prices) :
INDENT
    filled = []
    iter_data = iter(copy.deepcopy(dates_prices))
    item = iter_data.next()
    filled.append(item [:])
    dates_idx = 1
    while dates_idx < len(dates_prices) :
    INDENT
        item [0] += dt.timedelta(1)
        if item [0] == dates_prices [dates_idx] [0] :
        INDENT
            item = iter_data.next()
            dates_idx += 1
        DEDENT
        filled.append(item [:])
    DEDENT
    return filled
DEDENT
----------------------------------------

def fillDates(dates_prices, daylta = dt.timedelta(1)) :
INDENT
    all_dates = [el [0] for el in dates_prices]
    ending_date = all_dates [- 1]
    itnext = iter(dates_prices).next
    item = itnext()
    filled = [item]
    dateplus = item [0] + daylta
    while dateplus < = ending_date :
    INDENT
        if dateplus in all_dates :
        INDENT
            item = itnext()
        DEDENT
        else :
        INDENT
            item = [dateplus, item [1]]
        DEDENT
        filled.append(item)
        dateplus = item [0] + dt.timedelta(1)
    DEDENT
    return filled
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8510305_8510493_20_26
8510305_9508340_5_14
Title: Is there a way to inspect incoming args from within __getattr__ or to somehow otherwise redirect a call based upon incoming arguments? 
----------------------------------------

def __getattr__(self, name) :
INDENT
    if not hasattr(self.EU, name) :
    INDENT
        raise AttributeError()
    DEDENT
    else :
    INDENT
        return ProxyCall(self, name)
    DEDENT
DEDENT
----------------------------------------

def __getattr__(self, name) :
INDENT
    try :
    INDENT
        EU = object.__getattribute__(self, 'EU_' + name)
        Other = object.__getattribute__(self, 'Other_' + name)
    DEDENT
    except AttributeError :
    INDENT
        raise AttributeError(
            "%r is missing an EU_%s or Other_%s" % (self, name, name))
    DEDENT
    judge = partial(self._judge, name, EU, Other)
    return judge
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8514017_17911139_75_92
8514017_8522855_7_26
Title: How to decide the language from cookies/headers/session in webapp2? 
----------------------------------------

def __init__(self, request, response) :
INDENT
    self.initialize(request, response)

    if not self.set_locale_from_param() :
    INDENT
        if not self.set_locale_from_cookie() :
        INDENT
            if not self.set_locale_from_header() :
            INDENT

                self.set_locale_default()
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, request, response) :
INDENT
    self.initialize(request, response)

    locale = request.cookies.get('locale')
    if locale in AVAILABLE_LOCALES :
    INDENT
        i18n.get_i18n().set_locale(locale)
    DEDENT
    else :
    INDENT

        header = request.headers.get('Accept-Language', '')
        locales = [locale.split(';') [0] for locale in header.split(',')]
        for locale in locales :
        INDENT
            if locale in AVAILABLE_LOCALES :
            INDENT
                i18n.get_i18n().set_locale(locale)
                break
            DEDENT
        DEDENT
        else :
        INDENT

            i18n.get_i18n().set_locale(AVAILABLE_LOCALES [0])
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8525765_8525905_1_11
8525765_8525962_1_22
Title: load parameters from a file in Python 
----------------------------------------

def load(self, filename = "input.dat") :
INDENT
    d = {"Z0" : "z0", "k" : "k", "g" : "g", "Delta" : "D", "t_end" : "T"}
    FILE = open(filename)
    for line in FILE :
    INDENT
        name, value = line.split(":")
        value = value.strip()
        if " " in value :
        INDENT
            value = map(float, value.split())
        DEDENT
        else :
        INDENT
            value = float(value)
        DEDENT
        setattr(self, d [name], value)
    DEDENT
DEDENT
----------------------------------------

def load(self, filename = "input.dat") :
INDENT
    argmap = dict(Z0 = 2)

    namemap = dict(Z0 = "z0", Delta = "D", t_end = "T")
    with open(filename) as FILE :
    INDENT
        for line in FILE :
        INDENT
            s = line.split()
            var = s [0].rstrip(":")
            try :
            INDENT
                val = [float(x) for x in s [1 :]]
            DEDENT
            except ValueError :
            INDENT
                continue
            DEDENT
            if len(val) == varmap.get(var, 1) :
            INDENT
                if len(val) == 1 :
                INDENT
                    val = val [0]
                DEDENT
                setattr(self, namemap.get(var, var), val)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8525765_8526106_2_14
8525765_8528297_11_24
Title: load parameters from a file in Python 
----------------------------------------

def __init__(self, path = 'infile.dat') :
INDENT
    with open(path, 'r') as fo :
    INDENT
        for line in fo.readlines() :
        INDENT
            if len(line) < 2 : continue

            parts = [s.strip(' :\n') for s in line.split(' ', 1)]
            numbers = [float(s) for s in parts [1].split()]

            if len(numbers) == 1 : numbers = numbers [0]
            self.__dict__ [parts [0]] = numbers

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, input_file_name) :
INDENT
    with open(input_file_name, 'r') as input_file :
    INDENT
        for line in input_file :
        INDENT
            row = line.split()
            label = row [0]
            data = row [1 :]
            attr = label_attr_map [label] [0]
            datatypes = label_attr_map [label] [1 :]
            values = [(datatypes [i](data [i])) for i in range(len(data))]
            self.__dict__ [attr] = values if len(values) > 1 else values [0]
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8530443_8530598_4_14
8530443_8531345_1_10
Title: Python PIL: image crop with black area if not enough photo region 
----------------------------------------

def resize(file_path) :
INDENT
    file, ext = os.path.splitext(file_path)
    im = Image.open(file_path)
    size = (100, 'auto')
    new_path = file + "_.jpg"
    im.thumbnail(size)
    (width, height) = im.size
    if height > = width : box = (0, 0, 100, 100)
    else : box = (0, 0, 100, height)
    region = im.crop(box)
    region.save(new_path, "JPEG")
DEDENT
----------------------------------------

def resize(file_path) :
INDENT
    file, ext = os.path.splitext(file_path)
    im = Image.open(file_path)
    w, h = im.size
    size = (100, 'auto') if h > w else ('auto', 100)
    new_path = file + "_.jpg"
    im.thumbnail(size, Image.ANTIALIAS)
    w, h = im.size
    region = im.crop((w / 2 - 50, h / 2 - 50, w / 2 + 50, h / 2 + 50))
    region.save(new_path, "JPEG")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8541137_8541606_7_13
8541137_8541609_7_22
Title: How to automate the delegation of __special_methods__ in Python? 
----------------------------------------

def __new__(cls, name, bases, dct) :
INDENT
    default_attrs = dir(object)
    for attr in dir(dict) :
    INDENT
        if attr not in default_attrs :
        INDENT
            dct [attr] = _wrapper(attr)
        DEDENT
    DEDENT
    return type.__new__(cls, name, bases, dct)
DEDENT
----------------------------------------

def __new__(cls, name, bases, dict) :
INDENT
    objs = dict.get('proxyobjs', [])
    if objs :
    INDENT
        old_init = dict.get('__init__', lambda self : None)
        def new_init(self, * a, ** k) :
        INDENT
            for (n, v) in objs.iteritems() :
            INDENT
                setattr(self, n, v())
            DEDENT
            old_init(self, * a, ** k)
        DEDENT
        dict ['__init__'] = new_init
        meths = dict.get('proxymethods', {})
        for (proxyname, methnames) in meths.iteritems() :
        INDENT
            for methname in methnames :
            INDENT
                dict [methname] = make_method(proxyname, methname)
            DEDENT
        DEDENT
    DEDENT
    return super(Proxier, cls).__new__(cls, name, bases, dict)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8541137_8541606_7_13
8541137_8541719_10_20
Title: How to automate the delegation of __special_methods__ in Python? 
----------------------------------------

def __new__(cls, name, bases, dct) :
INDENT
    default_attrs = dir(object)
    for attr in dir(dict) :
    INDENT
        if attr not in default_attrs :
        INDENT
            dct [attr] = _wrapper(attr)
        DEDENT
    DEDENT
    return type.__new__(cls, name, bases, dct)
DEDENT
----------------------------------------

def __new__(cls, name, bases, attrs) :
INDENT
    dict_attr_names = set(dir(dict))
    common_names = set(dir(cls))
    for methodname in dict_attr_names - common_names :
    INDENT
        if not methodname.startswith('__') :
        INDENT
            continue
        DEDENT
        attrs [methodname] = redirect(methodname)
    DEDENT
    return type(name, bases, attrs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8541137_8541609_7_22
8541137_8541719_10_20
Title: How to automate the delegation of __special_methods__ in Python? 
----------------------------------------

def __new__(cls, name, bases, dict) :
INDENT
    objs = dict.get('proxyobjs', [])
    if objs :
    INDENT
        old_init = dict.get('__init__', lambda self : None)
        def new_init(self, * a, ** k) :
        INDENT
            for (n, v) in objs.iteritems() :
            INDENT
                setattr(self, n, v())
            DEDENT
            old_init(self, * a, ** k)
        DEDENT
        dict ['__init__'] = new_init
        meths = dict.get('proxymethods', {})
        for (proxyname, methnames) in meths.iteritems() :
        INDENT
            for methname in methnames :
            INDENT
                dict [methname] = make_method(proxyname, methname)
            DEDENT
        DEDENT
    DEDENT
    return super(Proxier, cls).__new__(cls, name, bases, dict)

DEDENT
----------------------------------------

def __new__(cls, name, bases, attrs) :
INDENT
    dict_attr_names = set(dir(dict))
    common_names = set(dir(cls))
    for methodname in dict_attr_names - common_names :
    INDENT
        if not methodname.startswith('__') :
        INDENT
            continue
        DEDENT
        attrs [methodname] = redirect(methodname)
    DEDENT
    return type(name, bases, attrs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8552165_8552360_35_49
8552165_8552503_15_32
Title: Importing a python module without actually executing it 
----------------------------------------

def validate(self) :
INDENT
    tokens = tokenize.generate_tokens(io.StringIO(self.codestr).readline)
    self.toks.append(Token(next(tokens)))
    for tok in tokens :
    INDENT
        self.toks.append(Token(tok))
        if (self.toks [0].tokname == 'NAME'
            and self.toks [0].scol == 0
            and self.toks [0].tokval == 'def'
            and self.toks [1].tokname == 'NAME') :
        INDENT
            self.names.add(self.toks [1].tokval)
        DEDENT
    DEDENT
    delta = set(['init', 'cleanup', 'execute']) - self.names
    if delta :
    INDENT
        raise ValueError('{n} not defined'.format(n = ' and '.join(delta)))
    DEDENT
DEDENT
----------------------------------------

def validate(source, required_functions) :
INDENT
    tree = ast.parse(source)
    functions = set()
    required_functions = set(required_functions)
    for item in tree.body :
    INDENT
        if isinstance(item, ast.FunctionDef) :
        INDENT
            functions.add(item.name)
            continue
        DEDENT
        if all(not checker(item) for checker in whitelist) :
        INDENT
            return False

        DEDENT
    DEDENT
    return len(required_functions - functions) == 0

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8554453_12738990_16_21
8554453_9137866_27_35
Title: python koans: class proxy 
----------------------------------------

def __setattr__(self, name, value) :
INDENT
    if hasattr(self, '_obj') :
    INDENT
        self.logs.append(name)
        object.__setattr__(object.__getattribute__(self, '_obj'), name, value)
    DEDENT
    else :
    INDENT
        object.__setattr__(self, name, value)
    DEDENT
DEDENT
----------------------------------------

def __setattr__(self, attr_name, value) :
INDENT
    if ((attr_name == '_obj') | (attr_name == '_message_counts')) :
    INDENT
        print 'setting the PROXY attribute: "' + attr_name + '"'
        object.__setattr__(self, attr_name, value)
    DEDENT
    else :
    INDENT
        print 'setting the REAL attribute: "' + attr_name + '"'
        self._message_counts [attr_name + "="] += 1
        object.__setattr__(self._obj, attr_name, value)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8568694_8577357_56_70
8568694_8577357_5_39
Title: "On click button data from panel two field should be copied to panel one field?" 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.SetBackgroundColour("gray")
    self.hsizerb = wx.BoxSizer(wx.HORIZONTAL)
    self.st5 = wx.StaticText(self, - 1, "Input 1 (mm)", pos = (10, 12))
    self.pt2_1 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.fgs_pt2 = wx.FlexGridSizer(1, 2, 10, 10)
    self.fgs_pt2.AddMany([(self.st5, 1, wx.EXPAND),
            (self.pt2_1, 1, wx.EXPAND)])
    self.hsizerb.Add(self.fgs_pt2, 1, wx.EXPAND | wx.ALIGN_CENTER | wx.ALL, 10)
    self.SetSizer(self.hsizerb)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.SetBackgroundColour("gray")
    self.tc1 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.tc2 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.tc3 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.st1 = wx.StaticText(self, - 1, "input", pos = (10, 12))
    self.st2 = wx.StaticText(self, - 1, "X:", pos = (10, 12))
    self.st3 = wx.StaticText(self, - 1, "Y:", pos = (10, 12))
    self.st4 = wx.StaticText(self, - 1, "Z:", pos = (10, 12))
    self.fgs = wx.FlexGridSizer(1, 7, 9, 10)
    self.fgs.AddMany([(self.st1, 1, wx.EXPAND),
            (self.st2, 1, wx.EXPAND),
            (self.tc1, 1, wx.EXPAND),
            (self.st3, 1, wx.EXPAND),
            (self.tc2, 1, wx.EXPAND),
            (self.st4, 1, wx.EXPAND),
            (self.tc3, 1, wx.EXPAND)])
    self.hsizer1 = wx.BoxSizer(wx.HORIZONTAL)
    self.hsizer2 = wx.BoxSizer(wx.HORIZONTAL)
    self.vsizerb = wx.BoxSizer(wx.VERTICAL)
    self.hsizer1.Add(self.fgs, 1, wx.EXPAND | wx.ALIGN_CENTER | wx.ALL, 1)
    self.but1 = wx.Button(self, 1, 'Calculate', (10, 10))
    self.but1.Bind(wx.EVT_BUTTON, self.Create_OnClick)
    self.hsizer2.Add(self.but1, 1, wx.ALIGN_CENTER)
    self.vsizerb.Add(self.hsizer1, 1.8, wx.EXPAND | wx.ALL, 10)
    self.vsizerb.Add(self.hsizer2, 0.2, wx.EXPAND | wx.ALL, 10)
    self.SetSizer(self.vsizerb)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8568694_8577357_56_70
8568694_8577357_72_80
Title: "On click button data from panel two field should be copied to panel one field?" 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.SetBackgroundColour("gray")
    self.hsizerb = wx.BoxSizer(wx.HORIZONTAL)
    self.st5 = wx.StaticText(self, - 1, "Input 1 (mm)", pos = (10, 12))
    self.pt2_1 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.fgs_pt2 = wx.FlexGridSizer(1, 2, 10, 10)
    self.fgs_pt2.AddMany([(self.st5, 1, wx.EXPAND),
            (self.pt2_1, 1, wx.EXPAND)])
    self.hsizerb.Add(self.fgs_pt2, 1, wx.EXPAND | wx.ALIGN_CENTER | wx.ALL, 10)
    self.SetSizer(self.hsizerb)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Notebook.__init__(self, parent)
    self.page1 = PageOne(self)
    self.page2 = PageTwo(self)
    self.AddPage(self.page1, "Tab 1")
    self.AddPage(self.page2, "Tab 2")

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8568694_8577357_56_70
8568694_8577357_82_95
Title: "On click button data from panel two field should be copied to panel one field?" 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.SetBackgroundColour("gray")
    self.hsizerb = wx.BoxSizer(wx.HORIZONTAL)
    self.st5 = wx.StaticText(self, - 1, "Input 1 (mm)", pos = (10, 12))
    self.pt2_1 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.fgs_pt2 = wx.FlexGridSizer(1, 2, 10, 10)
    self.fgs_pt2.AddMany([(self.st5, 1, wx.EXPAND),
            (self.pt2_1, 1, wx.EXPAND)])
    self.hsizerb.Add(self.fgs_pt2, 1, wx.EXPAND | wx.ALIGN_CENTER | wx.ALL, 10)
    self.SetSizer(self.hsizerb)
DEDENT
----------------------------------------

def __init__(self, parent, fid, title) :
INDENT
    wx.Frame.__init__(self, parent, fid, title, pos = (200, 50), size = (500, 200), style = wx.DEFAULT_FRAME_STYLE | wx.NO_FULL_REPAINT_ON_RESIZE)
    panel1 = wx.Panel(self, - 1)
    panel1.SetBackgroundColour("blue")
    nb = MyNotebook(panel1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(nb, 1, wx.ALL | wx.ALIGN_CENTER | wx.EXPAND, 1)
    panel1.SetSizer(sizer)
    panel1.SetAutoLayout(True)
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8568694_8577357_5_39
8568694_8577357_72_80
Title: "On click button data from panel two field should be copied to panel one field?" 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.SetBackgroundColour("gray")
    self.tc1 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.tc2 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.tc3 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.st1 = wx.StaticText(self, - 1, "input", pos = (10, 12))
    self.st2 = wx.StaticText(self, - 1, "X:", pos = (10, 12))
    self.st3 = wx.StaticText(self, - 1, "Y:", pos = (10, 12))
    self.st4 = wx.StaticText(self, - 1, "Z:", pos = (10, 12))
    self.fgs = wx.FlexGridSizer(1, 7, 9, 10)
    self.fgs.AddMany([(self.st1, 1, wx.EXPAND),
            (self.st2, 1, wx.EXPAND),
            (self.tc1, 1, wx.EXPAND),
            (self.st3, 1, wx.EXPAND),
            (self.tc2, 1, wx.EXPAND),
            (self.st4, 1, wx.EXPAND),
            (self.tc3, 1, wx.EXPAND)])
    self.hsizer1 = wx.BoxSizer(wx.HORIZONTAL)
    self.hsizer2 = wx.BoxSizer(wx.HORIZONTAL)
    self.vsizerb = wx.BoxSizer(wx.VERTICAL)
    self.hsizer1.Add(self.fgs, 1, wx.EXPAND | wx.ALIGN_CENTER | wx.ALL, 1)
    self.but1 = wx.Button(self, 1, 'Calculate', (10, 10))
    self.but1.Bind(wx.EVT_BUTTON, self.Create_OnClick)
    self.hsizer2.Add(self.but1, 1, wx.ALIGN_CENTER)
    self.vsizerb.Add(self.hsizer1, 1.8, wx.EXPAND | wx.ALL, 10)
    self.vsizerb.Add(self.hsizer2, 0.2, wx.EXPAND | wx.ALL, 10)
    self.SetSizer(self.vsizerb)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Notebook.__init__(self, parent)
    self.page1 = PageOne(self)
    self.page2 = PageTwo(self)
    self.AddPage(self.page1, "Tab 1")
    self.AddPage(self.page2, "Tab 2")

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8568694_8577357_5_39
8568694_8577357_82_95
Title: "On click button data from panel two field should be copied to panel one field?" 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.SetBackgroundColour("gray")
    self.tc1 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.tc2 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.tc3 = wx.TextCtrl(self, - 1, '', (110, 15), (120, - 1))
    self.st1 = wx.StaticText(self, - 1, "input", pos = (10, 12))
    self.st2 = wx.StaticText(self, - 1, "X:", pos = (10, 12))
    self.st3 = wx.StaticText(self, - 1, "Y:", pos = (10, 12))
    self.st4 = wx.StaticText(self, - 1, "Z:", pos = (10, 12))
    self.fgs = wx.FlexGridSizer(1, 7, 9, 10)
    self.fgs.AddMany([(self.st1, 1, wx.EXPAND),
            (self.st2, 1, wx.EXPAND),
            (self.tc1, 1, wx.EXPAND),
            (self.st3, 1, wx.EXPAND),
            (self.tc2, 1, wx.EXPAND),
            (self.st4, 1, wx.EXPAND),
            (self.tc3, 1, wx.EXPAND)])
    self.hsizer1 = wx.BoxSizer(wx.HORIZONTAL)
    self.hsizer2 = wx.BoxSizer(wx.HORIZONTAL)
    self.vsizerb = wx.BoxSizer(wx.VERTICAL)
    self.hsizer1.Add(self.fgs, 1, wx.EXPAND | wx.ALIGN_CENTER | wx.ALL, 1)
    self.but1 = wx.Button(self, 1, 'Calculate', (10, 10))
    self.but1.Bind(wx.EVT_BUTTON, self.Create_OnClick)
    self.hsizer2.Add(self.but1, 1, wx.ALIGN_CENTER)
    self.vsizerb.Add(self.hsizer1, 1.8, wx.EXPAND | wx.ALL, 10)
    self.vsizerb.Add(self.hsizer2, 0.2, wx.EXPAND | wx.ALL, 10)
    self.SetSizer(self.vsizerb)
DEDENT
----------------------------------------

def __init__(self, parent, fid, title) :
INDENT
    wx.Frame.__init__(self, parent, fid, title, pos = (200, 50), size = (500, 200), style = wx.DEFAULT_FRAME_STYLE | wx.NO_FULL_REPAINT_ON_RESIZE)
    panel1 = wx.Panel(self, - 1)
    panel1.SetBackgroundColour("blue")
    nb = MyNotebook(panel1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(nb, 1, wx.ALL | wx.ALIGN_CENTER | wx.EXPAND, 1)
    panel1.SetSizer(sizer)
    panel1.SetAutoLayout(True)
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8568694_8577357_72_80
8568694_8577357_82_95
Title: "On click button data from panel two field should be copied to panel one field?" 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Notebook.__init__(self, parent)
    self.page1 = PageOne(self)
    self.page2 = PageTwo(self)
    self.AddPage(self.page1, "Tab 1")
    self.AddPage(self.page2, "Tab 2")

DEDENT
----------------------------------------

def __init__(self, parent, fid, title) :
INDENT
    wx.Frame.__init__(self, parent, fid, title, pos = (200, 50), size = (500, 200), style = wx.DEFAULT_FRAME_STYLE | wx.NO_FULL_REPAINT_ON_RESIZE)
    panel1 = wx.Panel(self, - 1)
    panel1.SetBackgroundColour("blue")
    nb = MyNotebook(panel1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(nb, 1, wx.ALL | wx.ALIGN_CENTER | wx.EXPAND, 1)
    panel1.SetSizer(sizer)
    panel1.SetAutoLayout(True)
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8571799_8571878_2_21
8571799_8599758_19_62
Title: Copying Directories in Python 
----------------------------------------

def __init__(self, Obj) :
INDENT
    la = Label(win, text = "Source Directory is", font = "verdana 12 italic bold", width = 20, fg = "Red", bg = "WHITE",)
    la.grid(row = 1, column = 1)
    abc = "tk_chooseDirectory"
    bu = Button(text = "Source", font = "Verdana 12 italic", command = abc)
    bu.grid(row = 1, column = 3)

    la1 = Label(win, text = "DestibationDirectory is", font = "verdana 12 italic bold", width = 20, fg = "Red", bg = "WHITE",)
    la1.grid(row = 2, column = 1)
    abc1 = "tk_chooseDirectory"
    bu1 = Button(text = "Destination", font = "Verdana 12 italic", command = abc1)
    bu1.grid(row = 2, column = 3)

    def start() :
    INDENT
        shutil.copy(abc, abc1)
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    def srce() :
    INDENT
        self.src = tkFileDialog.askdirectory(title = "The source folder is ")
        textboxsrc.delete(0, END)
        textboxsrc.insert(0, self.src)
        print self.src
        return self.src
    DEDENT
    textboxsrc = Entry(win, width = "70")
    textboxsrc.insert(0, 'Enter master file name')
    textboxsrc.pack()
    textboxsrc.place(relx = 0.40, rely = 0.06, anchor = CENTER)
    bu = Button(text = "Source", font = "Verdana 12 italic bold", bg = "Purple", fg = "white", command = srce)
    bu.pack(fill = X, expand = YES)
    bu.place(relx = 0.85, rely = 0.06, anchor = CENTER)
    def dest() :
    INDENT
        self.des = tkFileDialog.askdirectory(title = "TheDestination folder is ")
        textboxdes.delete(0, END)
        textboxdes.insert(0, self.des)
        print self.des
        return self.des
    DEDENT
    textboxdes = Entry(win, width = "70")
    textboxdes.insert(0, 'Enter master file name')
    textboxdes.pack()
    textboxdes.place(relx = 0.40, rely = 0.13, anchor = CENTER)
    bu1 = Button(text = "Destination", font = "Verdana 12 italic", bg = "Purple", fg = "white", command = dest)
    bu1.pack(fill = X, expand = YES)
    bu1.place(relx = 0.85, rely = 0.13, anchor = CENTER)
    def start() :
    INDENT
        try :
        INDENT
            shutil.copytree(self.src, self.des)
        DEDENT
        except :
        INDENT
            tkMessageBox.showwarning("Copying file", "Error while copying\n(%s)")
        DEDENT
    DEDENT
    bn = Button(text = "Copy", font = "Verdana 12 italic", bg = "Purple", fg = "white", command = start)
    bn.pack(fill = X, expand = YES)
    bn.place(relx = 0.50, rely = 0.25, anchor = CENTER)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8574070_10425495_48_59
8574070_22722889_7_23
Title: Python : Display a Dict of Dicts using a UI Tree for the keys and any other widget for the values 
----------------------------------------

def JSONTree(Tree, Parent, Dictionery, TagList = []) :
INDENT
    for key in Dictionery :
    INDENT
        if isinstance(Dictionery [key], dict) :
        INDENT
            Tree.insert(Parent, 'end', key, text = key)
            TagList.append(key)
            JSONTree(Tree, key, Dictionery [key], TagList)
            pprint(TagList)
        DEDENT
        elif isinstance(Dictionery [key], list) :
        INDENT
            Tree.insert(Parent, 'end', key, text = key)
        DEDENT
        else :
        INDENT
            Tree.insert(Parent, 'end', key, text = key, value = Dictionery [key])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def JSONTree(Tree, Parent, Dictionary) :
INDENT
    for key in Dictionary :
    INDENT
        uid = uuid.uuid4()
        if isinstance(Dictionary [key], dict) :
        INDENT
            Tree.insert(Parent, 'end', uid, text = key)
            JSONTree(Tree, uid, Dictionary [key])
        DEDENT
        elif isinstance(Dictionary [key], list) :
        INDENT
            Tree.insert(Parent, 'end', uid, text = key + '[]')
            JSONTree(Tree,
                uid,
                dict([(i, x) for i, x in enumerate(Dictionary [key])]))
        DEDENT
        else :
        INDENT
            value = Dictionary [key]
            if isinstance(value, str) or isinstance(value, unicode) :
            INDENT
                value = value.replace(' ', '_')
            DEDENT
            Tree.insert(Parent, 'end', uid, text = key, value = value)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8582766_10256996_6_18
8582766_17501900_5_18
Title: Adding SSL Support to SocketServer 
----------------------------------------

def __init__(self, server_address, RequestHandlerClass, bind_and_activate = True) :
INDENT
    SocketServer.BaseServer.__init__(self, server_address,
        RequestHandlerClass)
    ctx = SSL.Context(SSL.SSLv3_METHOD)
    cert = 'cert.pem'
    key = 'private_key.pem'
    ctx.use_privatekey_file(key)
    ctx.use_certificate_file(cert)
    self.socket = SSL.Connection(ctx, socket.socket(self.address_family,
            self.socket_type))
    if bind_and_activate :
    INDENT
        self.server_bind()
        self.server_activate()
    DEDENT
DEDENT
----------------------------------------

def __init__(self, server_address, RequestHandlerClass, bind_and_activate = True) :
INDENT
    SocketServer.TCPServer.__init__(self, server_address, RequestHandlerClass, False)
    dir = os.path.dirname(__file__)
    key_file = os.path.join(dir, 'server.key')
    cert_file = os.path.join(dir, 'server.crt')
    import ssl
    self.socket = ssl.wrap_socket(self.socket, keyfile = key_file, certfile = cert_file, cert_reqs = ssl.CERT_NONE)
    if bind_and_activate :
    INDENT
        self.server_bind()
        self.server_activate()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8582766_10256996_6_18
8582766_19803457_5_16
Title: Adding SSL Support to SocketServer 
----------------------------------------

def __init__(self, server_address, RequestHandlerClass, bind_and_activate = True) :
INDENT
    SocketServer.BaseServer.__init__(self, server_address,
        RequestHandlerClass)
    ctx = SSL.Context(SSL.SSLv3_METHOD)
    cert = 'cert.pem'
    key = 'private_key.pem'
    ctx.use_privatekey_file(key)
    ctx.use_certificate_file(cert)
    self.socket = SSL.Connection(ctx, socket.socket(self.address_family,
            self.socket_type))
    if bind_and_activate :
    INDENT
        self.server_bind()
        self.server_activate()
    DEDENT
DEDENT
----------------------------------------

def __init__(self,
server_address,
RequestHandlerClass,
certfile,
keyfile,
ssl_version = ssl.PROTOCOL_TLSv1,
bind_and_activate = True) :
INDENT
    TCPServer.__init__(self, server_address, RequestHandlerClass, bind_and_activate)
    self.certfile = certfile
    self.keyfile = keyfile
    self.ssl_version = ssl_version
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8582766_17501900_5_18
8582766_19803457_5_16
Title: Adding SSL Support to SocketServer 
----------------------------------------

def __init__(self, server_address, RequestHandlerClass, bind_and_activate = True) :
INDENT
    SocketServer.TCPServer.__init__(self, server_address, RequestHandlerClass, False)
    dir = os.path.dirname(__file__)
    key_file = os.path.join(dir, 'server.key')
    cert_file = os.path.join(dir, 'server.crt')
    import ssl
    self.socket = ssl.wrap_socket(self.socket, keyfile = key_file, certfile = cert_file, cert_reqs = ssl.CERT_NONE)
    if bind_and_activate :
    INDENT
        self.server_bind()
        self.server_activate()
    DEDENT
DEDENT
----------------------------------------

def __init__(self,
server_address,
RequestHandlerClass,
certfile,
keyfile,
ssl_version = ssl.PROTOCOL_TLSv1,
bind_and_activate = True) :
INDENT
    TCPServer.__init__(self, server_address, RequestHandlerClass, bind_and_activate)
    self.certfile = certfile
    self.keyfile = keyfile
    self.ssl_version = ssl_version
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8589877_8607944_28_41
8589877_8607944_4_21
Title: PyQt4 - Ambiguity in QLayout Spacing 
----------------------------------------

def __init__(self, label, parent = None) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    self.setMaximumWidth(100)
    layout = QtGui.QGridLayout(self)
    self.label = QtGui.QLabel(label, self)
    self.label.setAlignment(QtCore.Qt.AlignCenter)
    layout.addWidget(self.label, 0, 0, 1, 2)
    self.lineEdit = QtGui.QLineEdit(self)
    layout.addWidget(self.lineEdit, 1, 0, 1, 2)
    self.toolButton = QtGui.QToolButton(self)
    layout.addWidget(self.toolButton, 2, 0, 1, 1)
    self.comboBox = QtGui.QComboBox(self)
    layout.addWidget(self.comboBox, 2, 1, 1, 1)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QWidget.__init__(self)
    self.groupBox = QtGui.QGroupBox(self)
    hbox = QtGui.QHBoxLayout(self.groupBox)
    length = 3
    for index in range(length) :
    INDENT
        hbox.addWidget(Widget(u'H\u2082O', self))
        if index < length - 1 :
        INDENT
            hbox.addWidget(Label(u'+', self))
        DEDENT
        else :
        INDENT
            hbox.addWidget(Label(u'\u2192', self))
        DEDENT
    DEDENT
    hbox.addWidget(Widget(u'4 H\u2082O', self))
    hbox.addWidget(Label(u'+', self))
    hbox.addWidget(Widget(u'H\u2084O\u2082', self))
    vbox = QtGui.QVBoxLayout(self)
    vbox.addWidget(self.groupBox)
    vbox.addStretch()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8597013_9324696_78_88
8597013_9324696_7_26
Title: Item Checking not possible with UltimateListCtrl in ULC_VIRTUAL mode 
----------------------------------------

def __init__(self, parent, log) :
INDENT
    wx.Frame.__init__(self, parent, - 1, "UltimateListCtrl in wx.LC_VIRTUAL mode", size = (700, 600))
    panel = wx.Panel(self, - 1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    listCtrl = TestUltimateListCtrl(panel, log)
    sizer.Add(listCtrl, 1, wx.EXPAND)
    panel.SetSizer(sizer)
    sizer.Layout()
    self.CenterOnScreen()
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent, log) :
INDENT
    ULC.UltimateListCtrl.__init__(self, parent, - 1, agwStyle = ULC.ULC_VIRTUAL | ULC.ULC_REPORT | ULC.ULC_SINGLE_SEL | ULC.ULC_VRULES | ULC.ULC_HRULES)
    self.SetItemCount(1000)
    self.table_fields = ['First', 'Second', 'Third']
    field_index = 0
    for field in self.table_fields :
    INDENT
        info = ULC.UltimateListItem()
        info._mask = wx.LIST_MASK_TEXT | wx.LIST_MASK_IMAGE | wx.LIST_MASK_FORMAT | ULC.ULC_MASK_CHECK
        info._image = []
        info._format = wx.LIST_FORMAT_CENTER
        info._kind = 1
        info._text = field
        info._font = wx.Font(13, wx.ROMAN, wx.NORMAL, wx.BOLD)
        self.InsertColumnInfo(field_index, info)
        self.SetColumnWidth(field_index, 175)
        field_index += 1
    DEDENT
    self.checked = []
    self.Bind(ULC.EVT_LIST_ITEM_CHECKING, self.OnCheck)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8618157_8618326_4_9
8618157_8618604_20_25
Title: How can I add a delay to every method in a Python sub-class when I don't want to replicate every method in the parent class 
----------------------------------------

def delayed(func) :
INDENT
    def wrapped(* args, ** kwargs) :
    INDENT
        sleep(seconds)
        func(* args, ** kwargs)
    DEDENT
    return wrapped
DEDENT
----------------------------------------

def delayed(func) :
INDENT
    def wrapped(* args, ** kwargs) :
    INDENT
        time.sleep(2)
        func(* args, ** kwargs)
    DEDENT
    return wrapped
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8651742_12666939_5_37
8651742_8652125_43_53
Title: dynamically adding and removing widgets in PyQt 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Main, self).__init__(parent)

    self.addButton = QtGui.QPushButton('button to add other widgets')
    self.addButton.clicked.connect(self.addWidget)

    self.scrollLayout = QtGui.QFormLayout()

    self.scrollWidget = QtGui.QWidget()
    self.scrollWidget.setLayout(self.scrollLayout)

    self.scrollArea = QtGui.QScrollArea()
    self.scrollArea.setWidgetResizable(True)
    self.scrollArea.setWidget(self.scrollWidget)

    self.mainLayout = QtGui.QVBoxLayout()

    self.mainLayout.addWidget(self.addButton)
    self.mainLayout.addWidget(self.scrollArea)

    self.centralWidget = QtGui.QWidget()
    self.centralWidget.setLayout(self.mainLayout)

    self.setCentralWidget(self.centralWidget)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Test, self).__init__(parent)
    self.pushButton = QtGui.QPushButton('I am in Test widget')
    layout = QtGui.QHBoxLayout()
    layout.addWidget(self.pushButton)
    self.setLayout(layout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8651742_8652125_43_53
8651742_8652125_5_37
Title: dynamically adding and removing widgets in PyQt 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Test, self).__init__(parent)
    self.pushButton = QtGui.QPushButton('I am in Test widget')
    layout = QtGui.QHBoxLayout()
    layout.addWidget(self.pushButton)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Main, self).__init__(parent)

    self.addButton = QtGui.QPushButton('button to add other widgets')
    self.addButton.clicked.connect(self.addWidget)

    self.scrollLayout = QtGui.QFormLayout()

    self.scrollWidget = QtGui.QWidget()
    self.scrollWidget.setLayout(self.scrollLayout)

    self.scrollArea = QtGui.QScrollArea()
    self.scrollArea.setWidgetResizable(True)
    self.scrollArea.setWidget(self.scrollWidget)

    self.mainLayout = QtGui.QVBoxLayout()

    self.mainLayout.addWidget(self.addButton)
    self.mainLayout.addWidget(self.scrollArea)

    self.centralWidget = QtGui.QWidget()
    self.centralWidget.setLayout(self.mainLayout)

    self.setCentralWidget(self.centralWidget)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8673482_8673715_1_21
8673482_8674062_1_13
Title: transitive closure python tuples 
----------------------------------------

def transitive_closure(elements) :
INDENT
    elements = set([(x, y) if x < y else (y, x) for x, y in elements])
    relations = {}
    for x, y in elements :
    INDENT
        if x not in relations :
        INDENT
            relations [x] = []
        DEDENT
        relations [x].append(y)
    DEDENT
    closure = set()
    def build_closure(n) :
    INDENT
        def f(k) :
        INDENT
            for y in relations.get(k, []) :
            INDENT
                closure.add((n, y))
                f(y)
            DEDENT
        DEDENT
        f(n)
    DEDENT
    for k in relations.keys() :
    INDENT
        build_closure(k)
    DEDENT
    return closure
DEDENT
----------------------------------------

def transitive_closure(a) :
INDENT
    closure = set(a)
    while True :
    INDENT
        new_relations = set((x, w) for x, y in closure for q, w in closure if q == y)
        closure_until_now = closure | new_relations
        if closure_until_now == closure :
        INDENT
            break
        DEDENT
        closure = closure_until_now
    DEDENT
    return closure
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8673482_8673715_1_21
8673482_8674173_3_14
Title: transitive closure python tuples 
----------------------------------------

def transitive_closure(elements) :
INDENT
    elements = set([(x, y) if x < y else (y, x) for x, y in elements])
    relations = {}
    for x, y in elements :
    INDENT
        if x not in relations :
        INDENT
            relations [x] = []
        DEDENT
        relations [x].append(y)
    DEDENT
    closure = set()
    def build_closure(n) :
    INDENT
        def f(k) :
        INDENT
            for y in relations.get(k, []) :
            INDENT
                closure.add((n, y))
                f(y)
            DEDENT
        DEDENT
        f(n)
    DEDENT
    for k in relations.keys() :
    INDENT
        build_closure(k)
    DEDENT
    return closure
DEDENT
----------------------------------------

def transitive_closure(elements) :
INDENT
    edges = defaultdict(set)
    for x, y in elements : edges [x].add(y)
    for _ in range(len(elements) - 1) :
    INDENT
        edges = defaultdict(set, (
                (k, v.union(* (edges [i] for i in v))) for (k, v) in edges.items()
                ))
    DEDENT
    return set((k, i) for (k, v) in edges.items() for i in v)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8673482_8673715_1_21
8673482_8674313_1_6
Title: transitive closure python tuples 
----------------------------------------

def transitive_closure(elements) :
INDENT
    elements = set([(x, y) if x < y else (y, x) for x, y in elements])
    relations = {}
    for x, y in elements :
    INDENT
        if x not in relations :
        INDENT
            relations [x] = []
        DEDENT
        relations [x].append(y)
    DEDENT
    closure = set()
    def build_closure(n) :
    INDENT
        def f(k) :
        INDENT
            for y in relations.get(k, []) :
            INDENT
                closure.add((n, y))
                f(y)
            DEDENT
        DEDENT
        f(n)
    DEDENT
    for k in relations.keys() :
    INDENT
        build_closure(k)
    DEDENT
    return closure
DEDENT
----------------------------------------

def transitive_closure(a) :
INDENT
    closure = set()
    for x, _ in a :
    INDENT
        closure |= set((x, y) for y in dfs(x, a))
    DEDENT
    return closure
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8673482_8674062_1_13
8673482_8674173_3_14
Title: transitive closure python tuples 
----------------------------------------

def transitive_closure(a) :
INDENT
    closure = set(a)
    while True :
    INDENT
        new_relations = set((x, w) for x, y in closure for q, w in closure if q == y)
        closure_until_now = closure | new_relations
        if closure_until_now == closure :
        INDENT
            break
        DEDENT
        closure = closure_until_now
    DEDENT
    return closure
DEDENT
----------------------------------------

def transitive_closure(elements) :
INDENT
    edges = defaultdict(set)
    for x, y in elements : edges [x].add(y)
    for _ in range(len(elements) - 1) :
    INDENT
        edges = defaultdict(set, (
                (k, v.union(* (edges [i] for i in v))) for (k, v) in edges.items()
                ))
    DEDENT
    return set((k, i) for (k, v) in edges.items() for i in v)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8673482_8674062_1_13
8673482_8674313_1_6
Title: transitive closure python tuples 
----------------------------------------

def transitive_closure(a) :
INDENT
    closure = set(a)
    while True :
    INDENT
        new_relations = set((x, w) for x, y in closure for q, w in closure if q == y)
        closure_until_now = closure | new_relations
        if closure_until_now == closure :
        INDENT
            break
        DEDENT
        closure = closure_until_now
    DEDENT
    return closure
DEDENT
----------------------------------------

def transitive_closure(a) :
INDENT
    closure = set()
    for x, _ in a :
    INDENT
        closure |= set((x, y) for y in dfs(x, a))
    DEDENT
    return closure
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8673482_8674173_3_14
8673482_8674313_1_6
Title: transitive closure python tuples 
----------------------------------------

def transitive_closure(elements) :
INDENT
    edges = defaultdict(set)
    for x, y in elements : edges [x].add(y)
    for _ in range(len(elements) - 1) :
    INDENT
        edges = defaultdict(set, (
                (k, v.union(* (edges [i] for i in v))) for (k, v) in edges.items()
                ))
    DEDENT
    return set((k, i) for (k, v) in edges.items() for i in v)
DEDENT
----------------------------------------

def transitive_closure(a) :
INDENT
    closure = set()
    for x, _ in a :
    INDENT
        closure |= set((x, y) for y in dfs(x, a))
    DEDENT
    return closure
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8707160_8708153_4_13
8707160_8709523_2_9
Title: wxpython capture keyboard events in a wx.Frame 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (200, 100))
    self.panel = wx.Panel(self, wx.ID_ANY)
    self.panel.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown)
    self.panel.Bind(wx.EVT_KEY_UP, self.OnKeyDown)
    self.panel.Bind(wx.EVT_CHAR, self.OnKeyDown)
    self.panel.SetFocus()
    self.Show(True)
DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (200, 100))
    self.panel = wx.Panel(self, wx.ID_ANY)
    self.Bind(wx.EVT_KEY_DOWN, self.KeyDown)
    self.Bind(wx.EVT_KEY_UP, self.KeyDown)
    self.Bind(wx.EVT_CHAR, self.KeyDown)
    self.panel.SetFocus()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8707457_30937545_13_18
8707457_8718039_12_20
Title: PyQt: Editable Tab Labels 
----------------------------------------

def eventFilter(self, widget, event) :
INDENT
    if ((event.type() == QEvent.MouseButtonPress and not self._editor.geometry().contains(event.globalPos())) or (event.type() == QEvent.KeyPress and event.key() == Qt.Key_Escape)) :
    INDENT
        self._editor.hide()
        return True
    DEDENT
    return QTabBar.eventFilter(self, widget, event)
DEDENT
----------------------------------------

def eventFilter(self, widget, event) :
INDENT
    if ((event.type() == QtCore.QEvent.MouseButtonPress and
            not self._editor.geometry().contains(event.globalPos())) or
        (event.type() == QtCore.QEvent.KeyPress and
            event.key() == QtCore.Qt.Key_Escape)) :
    INDENT
        self._editor.hide()
        return True
    DEDENT
    return QtGui.QTabBar.eventFilter(self, widget, event)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8707457_30937545_32_37
8707457_8718039_34_39
Title: PyQt: Editable Tab Labels 
----------------------------------------

def handleEditingFinished(self) :
INDENT
    index = self.currentIndex()
    if index > = 0 :
    INDENT
        self._editor.hide()
        self.setTabText(index, self._editor.text())
    DEDENT
DEDENT
----------------------------------------

def handleEditingFinished(self) :
INDENT
    index = self.currentIndex()
    if index > = 0 :
    INDENT
        self._editor.hide()
        self.setTabText(index, self._editor.text())
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8707457_30937545_5_12
8707457_8718039_4_11
Title: PyQt: Editable Tab Labels 
----------------------------------------

def __init__(self, parent) :
INDENT
    QTabBar.__init__(self, parent)
    self._editor = QLineEdit(self)
    self._editor.setWindowFlags(Qt.Popup)
    self._editor.setFocusProxy(self)
    self._editor.editingFinished.connect(self.handleEditingFinished)
    self._editor.installEventFilter(self)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    QtGui.QTabBar.__init__(self, parent)
    self._editor = QtGui.QLineEdit(self)
    self._editor.setWindowFlags(QtCore.Qt.Popup)
    self._editor.setFocusProxy(self)
    self._editor.editingFinished.connect(self.handleEditingFinished)
    self._editor.installEventFilter(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8725605_21112077_9_34
8725605_8726223_1_6
Title: "Bottle framework and OOP using method instead of function" 
----------------------------------------

def routeapp(obj) :
INDENT
    for kw in dir(obj) :
    INDENT
        attr = getattr(obj, kw)
        if hasattr(attr, "route") :
        INDENT
            if hasattr(attr, "method") :
            INDENT
                method = getattr(attr, "method")
            DEDENT
            else :
            INDENT
                method = "GET"
            DEDENT
            if hasattr(attr, "callback") :
            INDENT
                callback = getattr(attr, "callback")
            DEDENT
            else :
            INDENT
                callback = None
            DEDENT
            if hasattr(attr, "name") :
            INDENT
                name = getattr(attr, "name")
            DEDENT
            else :
            INDENT
                name = None
            DEDENT
            if hasattr(attr, "apply") :
            INDENT
                aply = getattr(attr, "apply")
            DEDENT
            else :
            INDENT
                aply = None
            DEDENT
            if hasattr(attr, "skip") :
            INDENT
                skip = getattr(attr, "skip")
            DEDENT
            else :
            INDENT
                skip = None
            DEDENT
            bottle.route(attr.route, method, callback, name, aply, skip)(attr)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def routeapp(obj) :
INDENT
    for kw in dir(app) :
    INDENT
        attr = getattr(app, kw)
        if hasattr(attr, 'route') :
        INDENT
            bottle.route(attr.route)(attr)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
874121_874131_5_10
874121_874148_7_13
Title: Python list of objects with random attributes 
----------------------------------------

def __init__(self, width = 100, height = 100) :
INDENT
    for i in range(0, 8, 2) :
    INDENT
        self.points [i] = randrange(width)
        self.points [i + 1] = randrange(height)
    DEDENT
    return
DEDENT
----------------------------------------

def __init__(self, width = 100, height = 100) :
INDENT
    self.points = [0] * 8
    self.fill = 'red'
    self.alpha = random()
    for i in range(0, 8, 2) :
    INDENT
        self.points [i] = randrange(width)
        self.points [i + 1] = randrange(height)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8762204_8762597_12_22
8762204_8762662_2_21
Title: Pythonic way to return an array of the correct dimension 
----------------------------------------

def running_average(data, windowSize) :
INDENT
    dShape = np.shape(data)
    raOut = np.zeros(dShape)
    if len(dShape) == 1 :
    INDENT
        for row, avg in average_iterator(data, windowSize) :
        INDENT
            raOut [row] = avg
        DEDENT
    DEDENT
    else :
    INDENT
        for col in xrange(dShape [1]) :
        INDENT
            for row, avg in average_iterator(data [:, col], windowSize) :
            INDENT
                raOut [row, col] = avg
            DEDENT
        DEDENT
    DEDENT
    return raOut
DEDENT
----------------------------------------

def running_average(data, windowSize) :
INDENT
    dShape = np.shape(data)
    try :
    INDENT
        dShape [1]
    DEDENT
    except :
    INDENT
        data = [data]
        dShape = np.shape(data)
    DEDENT
    raOut = np.zeros(dShape)
    for col in dShape [1] :
    INDENT
        rSum = 0.0
        for row, value in enumerate(data [:] [col]) :
        INDENT
            if row < windowSize :
            INDENT
                rSum += float(value)
            DEDENT
            else :
            INDENT
                rSum = rSum - data [row - windowSize] [col] + value
            DEDENT
            raOut [row] [col] = rSum / windowSize
        DEDENT
    DEDENT
    return np.squeeze(raOut)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8814452_17164331_7_14
8814452_8815111_17_28
Title: PyQt - how to add separate UI widget to QMainWindow 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.form_widget = FormWidget(self)
    _widget = QtGui.QWidget()
    _layout = QtGui.QVBoxLayout(_widget)
    _layout.addWidget(self.form_widget)
    self.setCentralWidget(_widget)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(FormWidget, self).__init__(parent)
    self.layout = QVBoxLayout(self)
    self.button1 = QPushButton("Button 1")
    self.layout.addWidget(self.button1)
    self.button2 = QPushButton("Button 2")
    self.layout.addWidget(self.button2)
    self.setLayout(self.layout)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8824311_33981172_6_20
8824311_8824811_4_17
Title: How to pass arguments to callback functions in PyQt 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMainWindow.__init__(self)
    self.centralwidget = QtGui.QWidget()
    self.vboxlayout = QtGui.QVBoxLayout()
    for idx in range(5) :
    INDENT
        button = QtGui.QPushButton('button ' + str(idx), None)
        button.my_own_data = str(idx)
        button.clicked.connect(self.click_handler)
        self.vboxlayout.addWidget(button)
    DEDENT
    self.centralwidget.setLayout(self.vboxlayout)
    self.setCentralWidget(self.centralwidget)
    self.show()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMainWindow.__init__(self)
    self.mapper = QtCore.QSignalMapper(self)
    self.toolbar = self.addToolBar('Foo')
    self.toolbar.setToolButtonStyle(QtCore.Qt.ToolButtonTextOnly)
    for text in 'One Two Three'.split() :
    INDENT
        action = QtGui.QAction(text, self)
        self.mapper.setMapping(action, text)
        action.triggered.connect(self.mapper.map)
        self.toolbar.addAction(action)
    DEDENT
    self.mapper.mapped ['QString'].connect(self.handleButton)
    self.edit = QtGui.QLineEdit(self)
    self.setCentralWidget(self.edit)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8839253_8842522_18_38
8839253_8842522_6_16
Title: Tkinter GUI to Convert Fixed Width File to Delimited File 
----------------------------------------

def __init__(self, parent, header, samplerow) :
INDENT
    fixedFont = tkFont.nametofont("TkFixedFont")
    tk.Text.__init__(self, parent, wrap = "none", height = 3, font = fixedFont)
    self.configure(cursor = "left_ptr")
    self.tag_configure("header", background = "gray")
    self.tag_configure("even", background = "#ffffff")
    self.tag_configure("header_even", background = "bisque")
    self.tag_configure("header_odd", background = "lightblue")
    self.tag_configure("odd", background = "#eeeeee")
    markers = " " * len(header)
    for i in range(len(header)) :
    INDENT
        tag = "even" if i % 2 == 0 else "odd"
        self.insert("end", " ", (tag,))
    DEDENT
    self.insert("end", "\n")
    self.insert("end", header + "\n", "header")
    self.insert("end", samplerow, "sample")
    self.configure(state = "disabled")
    self.bind("<1>", self.on_click)
    self.bind("<Double-1>", self.on_click)
    self.bind("<Triple-1>", self.on_click)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    header = "SequenSack and PaFull Name****************************]JOB TITLE****************]HOSP NAME******************************]Delivery Address***********************]Alternate 1 Address********************]Calculated Text**********************************]POSTNET Bar"
    sample = "000001T1  P1     Sample A Sample                                                                                         123 Any Street                                                                  Anytown 12345-6789                                12345678900"
    widget = DelimiterWidget(self, header, sample)
    hsb = tk.Scrollbar(orient = "horizontal", command = widget.xview)
    widget.configure(xscrollcommand = hsb.set)
    hsb.pack(side = "bottom", fill = "x")
    widget.pack(side = "top", fill = "x")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8852696_8853416_1_19
8852696_8854607_6_42
Title: Flattening nested loops / decreasing complexity - complementary pairs counting algorithm 
----------------------------------------

def complementary_pairs_number(complementary_diff, values) :
INDENT
    value_key = {}
    for index, item in enumerate(values) :
    INDENT
        value_key.setdefault(item, []).append(index)
    DEDENT
    num_pairs = 0
    seen = set()
    for pos_value in value_key :
    INDENT
        if pos_value in seen : continue
        sym_value = complementary_diff - pos_value
        seen.add(sym_value)
        if sym_value in value_key :
        INDENT

            n = len(value_key [pos_value]) * len(value_key [sym_value])
            if pos_value == sym_value :
            INDENT
                num_pairs += n
            DEDENT
            else :
            INDENT
                num_pairs += 2 * n
            DEDENT
        DEDENT
    DEDENT
    return num_pairs
DEDENT
----------------------------------------

def complementary_pairs_number(complementary_diff, values) :
INDENT
    print "Input:", complementary_diff, values
    resultlist = [complementary_diff - value for value in values]
    print "Result List:", resultlist
    original_table = {}
    for original_index in xrange(len(values)) :
    INDENT
        if values [original_index] in original_table :
        INDENT
            original_table [values [original_index]].append(original_index)
        DEDENT
        else :
        INDENT
            original_table [values [original_index]] = [original_index]
        DEDENT
    DEDENT
    print "Flattened dictionary:", original_table
    pair_count = 0
    for resultlist_index in xrange(len(resultlist)) :
    INDENT
        if resultlist [resultlist_index] in original_table :
        INDENT
            pair_count += len(original_table [resultlist [resultlist_index]])
        DEDENT
    DEDENT
    print "Complementary Pair Count:", pair_count
    pairs = []
    for resultlist_index in xrange(len(resultlist)) :
    INDENT
        if resultlist [resultlist_index] in original_table :
        INDENT
            pairs += [(resultlist_index, original_index) for original_index in
                original_table [resultlist [resultlist_index]]]
        DEDENT
    DEDENT
    print "Complementary Pair Indices:", pairs
    return pair_count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8852696_8853416_1_19
8852696_8870884_1_16
Title: Flattening nested loops / decreasing complexity - complementary pairs counting algorithm 
----------------------------------------

def complementary_pairs_number(complementary_diff, values) :
INDENT
    value_key = {}
    for index, item in enumerate(values) :
    INDENT
        value_key.setdefault(item, []).append(index)
    DEDENT
    num_pairs = 0
    seen = set()
    for pos_value in value_key :
    INDENT
        if pos_value in seen : continue
        sym_value = complementary_diff - pos_value
        seen.add(sym_value)
        if sym_value in value_key :
        INDENT

            n = len(value_key [pos_value]) * len(value_key [sym_value])
            if pos_value == sym_value :
            INDENT
                num_pairs += n
            DEDENT
            else :
            INDENT
                num_pairs += 2 * n
            DEDENT
        DEDENT
    DEDENT
    return num_pairs
DEDENT
----------------------------------------

def complementary_pairs_number(complementary_diff, values) :
INDENT
    value_key = {}
    for index, item in enumerate(values) :
    INDENT
        value_key.setdefault(item, []).append(index)
    DEDENT
    answer_key = {}
    for index, item in enumerate(values) :
    INDENT
        answer_key.setdefault((complementary_diff - item), []).append(index)
    DEDENT
    num_pairs = 0
    print (value_key)
    print (answer_key)
    for pos_value in value_key :
    INDENT
        if pos_value in answer_key :
        INDENT
            num_pairs += len(value_key [pos_value]) * len(answer_key [pos_value])
        DEDENT
    DEDENT
    return num_pairs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8852696_8854607_6_42
8852696_8870884_1_16
Title: Flattening nested loops / decreasing complexity - complementary pairs counting algorithm 
----------------------------------------

def complementary_pairs_number(complementary_diff, values) :
INDENT
    print "Input:", complementary_diff, values
    resultlist = [complementary_diff - value for value in values]
    print "Result List:", resultlist
    original_table = {}
    for original_index in xrange(len(values)) :
    INDENT
        if values [original_index] in original_table :
        INDENT
            original_table [values [original_index]].append(original_index)
        DEDENT
        else :
        INDENT
            original_table [values [original_index]] = [original_index]
        DEDENT
    DEDENT
    print "Flattened dictionary:", original_table
    pair_count = 0
    for resultlist_index in xrange(len(resultlist)) :
    INDENT
        if resultlist [resultlist_index] in original_table :
        INDENT
            pair_count += len(original_table [resultlist [resultlist_index]])
        DEDENT
    DEDENT
    print "Complementary Pair Count:", pair_count
    pairs = []
    for resultlist_index in xrange(len(resultlist)) :
    INDENT
        if resultlist [resultlist_index] in original_table :
        INDENT
            pairs += [(resultlist_index, original_index) for original_index in
                original_table [resultlist [resultlist_index]]]
        DEDENT
    DEDENT
    print "Complementary Pair Indices:", pairs
    return pair_count
DEDENT
----------------------------------------

def complementary_pairs_number(complementary_diff, values) :
INDENT
    value_key = {}
    for index, item in enumerate(values) :
    INDENT
        value_key.setdefault(item, []).append(index)
    DEDENT
    answer_key = {}
    for index, item in enumerate(values) :
    INDENT
        answer_key.setdefault((complementary_diff - item), []).append(index)
    DEDENT
    num_pairs = 0
    print (value_key)
    print (answer_key)
    for pos_value in value_key :
    INDENT
        if pos_value in answer_key :
        INDENT
            num_pairs += len(value_key [pos_value]) * len(answer_key [pos_value])
        DEDENT
    DEDENT
    return num_pairs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8854421_18115718_1_10
8854421_29271756_1_13
Title: How to determine if a path is a subdirectory of another? 
----------------------------------------

def is_subdir(path, directory) :
INDENT
    path = os.path.realpath(path)
    directory = os.path.realpath(directory)
    relative = os.path.relpath(path, directory)
    if relative.startswith(os.pardir) :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        return True
    DEDENT
DEDENT
----------------------------------------

def is_subdir(path, directory) :
INDENT
    import os
    from os.path import normpath, normcase, sep
    path = normpath(normcase(path))
    directory = normpath(normcase(directory))
    if len(path) > len(directory) :
    INDENT
        sep = sep.encode('ascii') if isinstance(directory, bytes) else sep
        if path.startswith(directory.rstrip(sep) + sep) :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8856164_16916969_9_16
8856164_8856235_16_22
Title: Class Decorator decorating method in python 
----------------------------------------

def __call__(self, * args) :
INDENT
    try :
    INDENT
        return self.cache [args]
    DEDENT
    except KeyError :
    INDENT
        value = self.func(* args)
        self.cache [args] = value
        return value
    DEDENT
DEDENT
----------------------------------------

def __call__(self, * args) :
INDENT
    if args in self.cache :
    INDENT
        return self.cache [args]
    DEDENT
    self.cache [args] = self.fget(self.inst, * args)
    return self.cache [args]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8866334_8871802_1_18
8866334_8916845_7_21
Title: Getting standard errors from regressions using rpy2 
----------------------------------------

def test_regress() :
INDENT
    stats = importr('stats')
    x = random.uniform(0, 1, 100).reshape([100, 1])
    y = 1 + x + random.uniform(0, 1, 100).reshape([100, 1])
    x_in_r = create_r_matrix(x, x.shape [1])
    y_in_r = create_r_matrix(y, y.shape [1])
    formula = robjects.Formula('y~x')
    env = formula.environment
    env ['x'] = x_in_r
    env ['y'] = y_in_r
    fit = stats.lm(formula)
    coeffs = array(fit [0])
    resids = array(fit [1])
    fitted_vals = array(fit [4])
    modsum = base.summary(fit)
    rsquared = array(modsum [7])
    se = array(modsum.rx2('coefficients') [2 : 4])
    return (coeffs, resids, fitted_vals, rsquared, se)
DEDENT
----------------------------------------

def test_regress() :
INDENT
    x = base.matrix(stats.runif(100), nrow = 100)
    y = (x.ro + base.matrix(stats.runif(100), nrow = 100)).ro + 1
    formula = robjects.Formula('y~x')
    env = formula.environment
    env ['x'] = x
    env ['y'] = y
    fit = stats.lm(formula)
    coefs = stats.coef(fit)
    resids = stats.residuals(fit)
    fitted_vals = stats.fitted(fit)
    modsum = base.summary(fit)
    rsquared = modsum.rx2('r.squared')
    se = modsum.rx2('coefficients') [2 : 4]
    return (coefs, resids, fitted_vals, rsquared, se)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8874046_8874084_1_10
8874046_8874508_14_25
Title: Python Connect Four. Making the computer move 
----------------------------------------

def make_computer_move(board) :
INDENT
    import random
    col = random.randint(0, (len(board [0]) - 1))
    for row in range(len(board) - 1, - 1, - 1) :
    INDENT
        if board [row] [col] == " " :
        INDENT
            print "The pairing is(" + str(row), str(col) + ")"
            board [row] [col] = 'O'
            break
        DEDENT
    DEDENT
    else :
    INDENT
        make_computer_move(board)
    DEDENT
DEDENT
----------------------------------------

def make_computer_move(board, avail_cols) :
INDENT
    col = random.choice(avail_cols)
    for row in range(len(board) - 1, - 1, - 1) :
    INDENT
        if board [row] [col] == " " :
        INDENT
            print "The pairing is (%i,%i)" % (row, col)
            board [row] [col] = 'O'
            break
        DEDENT
    DEDENT
    if row == 0 :
    INDENT
        return col

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877095_8901416_25_40
8877095_8901416_45_62
Title: Head start with wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.list_ctrl = wx.ListCtrl(self, size = (- 1, 100),
        style = wx.LC_REPORT
        | wx.BORDER_SUNKEN)
    self.list_ctrl.InsertColumn(0, 'Subject')
    self.list_ctrl.InsertColumn(1, 'Due')
    self.list_ctrl.InsertColumn(2, 'Location', width = 125)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.list_ctrl, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    notebook = wx.Notebook(self)
    page1 = TabPanel(notebook)
    page2 = TabPanel(notebook)
    page3 = TabPanel(notebook)
    notebook.AddPage(page1, "Page_1")
    notebook.AddPage(page2, "Page_2")
    notebook.AddPage(page3, "Page_3")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(notebook, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877095_8901416_25_40
8877095_8901416_67_103
Title: Head start with wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.list_ctrl = wx.ListCtrl(self, size = (- 1, 100),
        style = wx.LC_REPORT
        | wx.BORDER_SUNKEN)
    self.list_ctrl.InsertColumn(0, 'Subject')
    self.list_ctrl.InsertColumn(1, 'Due')
    self.list_ctrl.InsertColumn(2, 'Location', width = 125)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.list_ctrl, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    btnSizer = wx.BoxSizer(wx.HORIZONTAL)

    for i in range(4) :
    INDENT
        btn = wx.Button(self, label = "button_%s" % i)
        btnSizer.Add(btn, 0, wx.ALL, 5)
    DEDENT
    mainSizer.Add(btnSizer)

    splitter = wx.SplitterWindow(self)
    leftPanel = LeftPanel(splitter)
    rightPanel = RightPanel(splitter)
    splitter.SplitVertically(leftPanel, rightPanel)
    mainSizer.Add(splitter, 1, wx.EXPAND)

    btnSizer2 = wx.BoxSizer(wx.HORIZONTAL)
    btn5 = wx.Button(self, label = "button_5")
    btn6 = wx.Button(self, label = "button_6")
    btn7 = wx.Button(self, label = "button_7")
    btn8 = wx.Button(self, label = "button_8")
    btnSizer2.Add(btn5)
    btnSizer2.Add(btn6)
    btnSizer2.Add((1, 1), 1, wx.EXPAND)
    btnSizer2.Add(btn7)
    btnSizer2.Add(btn8)
    mainSizer.Add(btnSizer2)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877095_8901416_25_40
8877095_8901416_8_20
Title: Head start with wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.list_ctrl = wx.ListCtrl(self, size = (- 1, 100),
        style = wx.LC_REPORT
        | wx.BORDER_SUNKEN)
    self.list_ctrl.InsertColumn(0, 'Subject')
    self.list_ctrl.InsertColumn(1, 'Due')
    self.list_ctrl.InsertColumn(2, 'Location', width = 125)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.list_ctrl, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    btnOne = wx.Button(self, label = "button_10")
    btnTwo = wx.Button(self, label = "button_11")
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(btnOne, 0, wx.ALIGN_BOTTOM)
    sizer.Add(btnTwo, 0, wx.ALIGN_BOTTOM)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877095_8901416_45_62
8877095_8901416_67_103
Title: Head start with wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    notebook = wx.Notebook(self)
    page1 = TabPanel(notebook)
    page2 = TabPanel(notebook)
    page3 = TabPanel(notebook)
    notebook.AddPage(page1, "Page_1")
    notebook.AddPage(page2, "Page_2")
    notebook.AddPage(page3, "Page_3")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(notebook, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    btnSizer = wx.BoxSizer(wx.HORIZONTAL)

    for i in range(4) :
    INDENT
        btn = wx.Button(self, label = "button_%s" % i)
        btnSizer.Add(btn, 0, wx.ALL, 5)
    DEDENT
    mainSizer.Add(btnSizer)

    splitter = wx.SplitterWindow(self)
    leftPanel = LeftPanel(splitter)
    rightPanel = RightPanel(splitter)
    splitter.SplitVertically(leftPanel, rightPanel)
    mainSizer.Add(splitter, 1, wx.EXPAND)

    btnSizer2 = wx.BoxSizer(wx.HORIZONTAL)
    btn5 = wx.Button(self, label = "button_5")
    btn6 = wx.Button(self, label = "button_6")
    btn7 = wx.Button(self, label = "button_7")
    btn8 = wx.Button(self, label = "button_8")
    btnSizer2.Add(btn5)
    btnSizer2.Add(btn6)
    btnSizer2.Add((1, 1), 1, wx.EXPAND)
    btnSizer2.Add(btn7)
    btnSizer2.Add(btn8)
    mainSizer.Add(btnSizer2)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877095_8901416_45_62
8877095_8901416_8_20
Title: Head start with wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    notebook = wx.Notebook(self)
    page1 = TabPanel(notebook)
    page2 = TabPanel(notebook)
    page3 = TabPanel(notebook)
    notebook.AddPage(page1, "Page_1")
    notebook.AddPage(page2, "Page_2")
    notebook.AddPage(page3, "Page_3")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(notebook, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    btnOne = wx.Button(self, label = "button_10")
    btnTwo = wx.Button(self, label = "button_11")
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(btnOne, 0, wx.ALIGN_BOTTOM)
    sizer.Add(btnTwo, 0, wx.ALIGN_BOTTOM)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877095_8901416_67_103
8877095_8901416_8_20
Title: Head start with wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    btnSizer = wx.BoxSizer(wx.HORIZONTAL)

    for i in range(4) :
    INDENT
        btn = wx.Button(self, label = "button_%s" % i)
        btnSizer.Add(btn, 0, wx.ALL, 5)
    DEDENT
    mainSizer.Add(btnSizer)

    splitter = wx.SplitterWindow(self)
    leftPanel = LeftPanel(splitter)
    rightPanel = RightPanel(splitter)
    splitter.SplitVertically(leftPanel, rightPanel)
    mainSizer.Add(splitter, 1, wx.EXPAND)

    btnSizer2 = wx.BoxSizer(wx.HORIZONTAL)
    btn5 = wx.Button(self, label = "button_5")
    btn6 = wx.Button(self, label = "button_6")
    btn7 = wx.Button(self, label = "button_7")
    btn8 = wx.Button(self, label = "button_8")
    btnSizer2.Add(btn5)
    btnSizer2.Add(btn6)
    btnSizer2.Add((1, 1), 1, wx.EXPAND)
    btnSizer2.Add(btn7)
    btnSizer2.Add(btn8)
    mainSizer.Add(btnSizer2)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    btnOne = wx.Button(self, label = "button_10")
    btnTwo = wx.Button(self, label = "button_11")
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(btnOne, 0, wx.ALIGN_BOTTOM)
    sizer.Add(btnTwo, 0, wx.ALIGN_BOTTOM)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8886953_8898755_13_48
8886953_8898755_54_63
Title: wXPython: Unable to get widget to enlarge/expand in size 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    super(QueueDialog, self).__init__(parent = parent,
        title = title, size = (400, 500))

    panel = wx.Panel(self)
    vbox = wx.BoxSizer(wx.VERTICAL)
    sb = wx.StaticBox(panel, label = 'Queue')
    sbs = wx.StaticBoxSizer(sb, orient = wx.VERTICAL)
    hbox3 = wx.BoxSizer(wx.VERTICAL)
    listB = CheckListCtrl(panel)
    listB.InsertColumn(0, "Test", width = 100)
    listB.InsertColumn(1, "Status", wx.LIST_FORMAT_RIGHT)
    hbox3.Add(listB, 1, wx.EXPAND)
    dalist = ["heh", "ha", "hello"]
    for name in dalist [0 : 3] :
    INDENT
        index = listB.InsertStringItem(sys.maxint, name [0 : - 1])
    DEDENT
    sbs.Add(hbox3, proportion = 1, flag = wx.EXPAND | wx.ALL)
    panel.SetSizer(sbs)
    hbox2 = wx.BoxSizer(wx.HORIZONTAL)
    okButton = wx.Button(self, label = 'OK')
    closeButton = wx.Button(self, label = 'Cancel')
    hbox2.Add(okButton)
    hbox2.Add(closeButton, flag = wx.LEFT, border = 5)
    vbox = wx.BoxSizer(wx.VERTICAL)
    vbox.Add(panel, proportion = 1, flag = wx.EXPAND | wx.ALL, border = 10)
    vbox.Add(hbox2, flag = wx.ALIGN_CENTER | wx.BOTTOM, border = 10)
    self.SetSizer(vbox)
DEDENT
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (600, 400))
    e = QueueDialog(None, title = 'Queue')
    e.ShowModal()
    e.Destroy()
    self.Centre()
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
89178_89230_1_11
89178_89250_1_11
Title: "In Python what is the fastest algorithm for removing duplicates from a list so that all elements are unique *while preserving order*?" 
----------------------------------------

def unique(x) :
INDENT
    output = []
    y = {}
    for item in x :
    INDENT
        y [item] = ""
    DEDENT
    for item in x :
    INDENT
        if item in y :
        INDENT
            output.append(item)
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------

def unique(items) :
INDENT
    found = set([])
    keep = []
    for item in items :
    INDENT
        if item not in found :
        INDENT
            found.add(item)
            keep.append(item)
        DEDENT
    DEDENT
    return keep
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
89178_89230_1_11
89178_89917_1_15
Title: "In Python what is the fastest algorithm for removing duplicates from a list so that all elements are unique *while preserving order*?" 
----------------------------------------

def unique(x) :
INDENT
    output = []
    y = {}
    for item in x :
    INDENT
        y [item] = ""
    DEDENT
    for item in x :
    INDENT
        if item in y :
        INDENT
            output.append(item)
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------

def unique(list) :
INDENT
    s = {}
    output = []
    for x in list :
    INDENT
        count = 1
        if (s.has_key(x)) :
        INDENT
            count = s [x] + 1
        DEDENT
        s [x] = count
    DEDENT
    for x in list :
    INDENT
        count = s [x]
        if (count > 0) :
        INDENT
            s [x] = 0
            output.append(x)
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
89178_89250_1_11
89178_89917_1_15
Title: "In Python what is the fastest algorithm for removing duplicates from a list so that all elements are unique *while preserving order*?" 
----------------------------------------

def unique(items) :
INDENT
    found = set([])
    keep = []
    for item in items :
    INDENT
        if item not in found :
        INDENT
            found.add(item)
            keep.append(item)
        DEDENT
    DEDENT
    return keep
DEDENT
----------------------------------------

def unique(list) :
INDENT
    s = {}
    output = []
    for x in list :
    INDENT
        count = 1
        if (s.has_key(x)) :
        INDENT
            count = s [x] + 1
        DEDENT
        s [x] = count
    DEDENT
    for x in list :
    INDENT
        count = s [x]
        if (count > 0) :
        INDENT
            s [x] = 0
            output.append(x)
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8919718_11503492_1_20
8919718_33260133_17_29
Title: financial python library that has xirr and xnpv function? 
----------------------------------------

def xirr(transactions) :
INDENT
    years = [(ta [0] - transactions [0] [0]).days / 365.0 for ta in transactions]
    residual = 1
    step = 0.05
    guess = 0.05
    epsilon = 0.0001
    limit = 10000
    while abs(residual) > epsilon and limit > 0 :
    INDENT
        limit -= 1
        residual = 0.0
        for i, ta in enumerate(transactions) :
        INDENT
            residual += ta [1] / pow(guess, years [i])
        DEDENT
        if abs(residual) > epsilon :
        INDENT
            if residual > 0 :
            INDENT
                guess += step
            DEDENT
            else :
            INDENT
                guess -= step
                step /= 2.0
            DEDENT
        DEDENT
    DEDENT
    return guess - 1
DEDENT
----------------------------------------

def xirr(values, dates) :
INDENT
    try :
    INDENT
        return scipy.optimize.newton(lambda r : xnpv(r, values, dates), 0.0)
    DEDENT
    except RuntimeError :
    INDENT
        return scipy.optimize.brentq(lambda r : xnpv(r, values, dates), - 1.0, 1e10)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
892199_16385946_36_50
892199_6743593_27_50
Title: Detect & Record Audio in Python 
----------------------------------------

def trim(data_all) :
INDENT
    _from = 0
    _to = len(data_all) - 1
    for i, b in enumerate(data_all) :
    INDENT
        if abs(b) > THRESHOLD :
        INDENT
            _from = max(0, i - TRIM_APPEND)
            break
        DEDENT
    DEDENT
    for i, b in enumerate(reversed(data_all)) :
    INDENT
        if abs(b) > THRESHOLD :
        INDENT
            _to = min(len(data_all) - 1, len(data_all) - 1 - i + TRIM_APPEND)
            break
        DEDENT
    DEDENT
    return copy.deepcopy(data_all [_from : (_to + 1)])
DEDENT
----------------------------------------

def trim(snd_data) :
INDENT
    "Trim the blank spots at the start and end"
    def _trim(snd_data) :
    INDENT
        snd_started = False
        r = array('h')
        for i in snd_data :
        INDENT
            if not snd_started and abs(i) > THRESHOLD :
            INDENT
                snd_started = True
                r.append(i)
            DEDENT
            elif snd_started :
            INDENT
                r.append(i)
            DEDENT
        DEDENT
        return r

    DEDENT
    snd_data = _trim(snd_data)

    snd_data.reverse()
    snd_data = _trim(snd_data)
    snd_data.reverse()
    return snd_data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
892199_16385946_51_89
892199_6743593_58_104
Title: Detect & Record Audio in Python 
----------------------------------------

def record() :
INDENT
    p = pyaudio.PyAudio()
    stream = p.open(format = FORMAT, channels = CHANNELS, rate = RATE, input = True, output = True, frames_per_buffer = CHUNK_SIZE)
    silent_chunks = 0
    audio_started = False
    data_all = array('h')
    while True :
    INDENT

        data_chunk = array('h', stream.read(CHUNK_SIZE))
        if byteorder == 'big' :
        INDENT
            data_chunk.byteswap()
        DEDENT
        data_all.extend(data_chunk)
        silent = is_silent(data_chunk)
        if audio_started :
        INDENT
            if silent :
            INDENT
                silent_chunks += 1
                if silent_chunks > SILENT_CHUNKS :
                INDENT
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                silent_chunks = 0
            DEDENT
        DEDENT
        elif not silent :
        INDENT
            audio_started = True
        DEDENT
    DEDENT
    sample_width = p.get_sample_size(FORMAT)
    stream.stop_stream()
    stream.close()
    p.terminate()
    data_all = trim(data_all)
    data_all = normalize(data_all)
    return sample_width, data_all
DEDENT
----------------------------------------

def record() :
INDENT
    p = pyaudio.PyAudio()
    stream = p.open(format = FORMAT, channels = 1, rate = RATE,
        input = True, output = True,
        frames_per_buffer = CHUNK_SIZE)
    num_silent = 0
    snd_started = False
    r = array('h')
    while 1 :
    INDENT

        snd_data = array('h', stream.read(CHUNK_SIZE))
        if byteorder == 'big' :
        INDENT
            snd_data.byteswap()
        DEDENT
        r.extend(snd_data)
        silent = is_silent(snd_data)
        if silent and snd_started :
        INDENT
            num_silent += 1
        DEDENT
        elif not silent and not snd_started :
        INDENT
            snd_started = True
        DEDENT
        if snd_started and num_silent > 30 :
        INDENT
            break
        DEDENT
    DEDENT
    sample_width = p.get_sample_size(FORMAT)
    stream.stop_stream()
    stream.close()
    p.terminate()
    r = normalize(r)
    r = trim(r)
    r = add_silence(r, 0.5)
    return sample_width, r
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8934772_8934832_1_20
8934772_8934902_1_18
Title: "Assigning to variable from parent function: ""Local variable referenced before assignment""" 
----------------------------------------

def funcA() :
INDENT
    print "funcA"
    c = 0
    def funcB(c) :
    INDENT
        c += 3
        print "funcB", c
        return c
    DEDENT
    def funcC(c) :
    INDENT
        c = 5
        print "funcC", c
        return c
    DEDENT
    print "c", c
    c = funcB(c)
    c = funcC(c)
    c = funcB(c)
    c = funcC(c)
    print "end"
DEDENT
----------------------------------------

def funcA() :
INDENT
    print "funcA"
    c = [0]
    def funcB() :
    INDENT
        c [0] += 3
        print "funcB", c [0]
    DEDENT
    def funcC() :
    INDENT
        c [0] = 5
        print "funcC", c [0]
    DEDENT
    print "c", c [0]
    funcB()
    funcC()
    funcB()
    funcC()
    print "end"
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
895371_21298077_4_16
895371_895405_1_12
Title: Bubble Sort Homework 
----------------------------------------

def bubble(badList) :
INDENT
    length = len(badList) - 1
    element = 0
    while element < length :
    INDENT
        if badList [element] > badList [element + 1] :
        INDENT
            hold = badList [element + 1]
            badList [element + 1] = badList [element]
            badList [element] = hold
            element = 0
            print badList
        DEDENT
        else :
        INDENT
            element = element + 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def bubble(values) :
INDENT
    length = len(values) - 1
    sorted = False
    while not sorted :
    INDENT
        sorted = True
        for element in range(0, length) :
        INDENT
            if values [element] > values [element + 1] :
            INDENT
                hold = values [element + 1]
                values [element + 1] = values [element]
                values [element] = hold
                sorted = False
            DEDENT
        DEDENT
    DEDENT
    return values
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
895371_21298077_4_16
895371_895477_3_19
Title: Bubble Sort Homework 
----------------------------------------

def bubble(badList) :
INDENT
    length = len(badList) - 1
    element = 0
    while element < length :
    INDENT
        if badList [element] > badList [element + 1] :
        INDENT
            hold = badList [element + 1]
            badList [element + 1] = badList [element]
            badList [element] = hold
            element = 0
            print badList
        DEDENT
        else :
        INDENT
            element = element + 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def bubble(badList) :
INDENT
    length = len(badList) - 2
    unsorted = True
    while unsorted :
    INDENT
        for element in range(0, length) :
        INDENT
            unsorted = False
            if badList [element] > badList [element + 1] :
            INDENT
                hold = badList [element + 1]
                badList [element + 1] = badList [element]
                badList [element] = hold
                print badList
                unsorted = True
            DEDENT
        DEDENT
    DEDENT
    return badList
DEDENT
----------------------------------------
