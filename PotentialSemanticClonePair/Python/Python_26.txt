$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
323829_3541638_111_128
323829_3541638_153_158
Title: How to find out if there is data to be read from stdin on Windows in Python? 
----------------------------------------

def readline(self) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            data = self.s_in.recv(4096)
        DEDENT
        except :
        INDENT
            return ''
        DEDENT
        if not data :
        INDENT
            return ''
        DEDENT
        pos = data.find('\n')
        if pos == - 1 :
        INDENT
            self.read_str += data
        DEDENT
        else :
        INDENT
            left = data [0 : pos + 1]
            right = data [pos + 1 :]
            ret = self.read_str + left
            self.read_str = right
            return ret
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def readline(self) :
INDENT
    try :
    INDENT
        return sys.stdin.readline()
    DEDENT
    except :
    INDENT
        return ''
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32498603_32499231_1_15
32498603_32499348_1_13
Title: Fail to compare whitespace from Tkinter text widget to one in python code 
----------------------------------------

def verify(self) :
INDENT
    self.main_text.tag_remove("red", "1.0", END)
    last = "1.0"
    while True :
    INDENT

        start = self.main_text.search("\d+", last, regexp = True, stopindex = END)
        if start :
        INDENT

            last = self.main_text.search("\D|$", start, regexp = True)
            num = self.main_text.get(start, last)
            if num not in numbers :
            INDENT
                self.main_text.tag_add("red", start, last)
            DEDENT
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def verify(self) :
INDENT
    self.content = self.main_text.get("1.0", 'end-1c')
    self.main_text.delete('1.0', END)
    self.content.encode('utf-8')
    numbers_list = re.findall('\d+', self.content)
    for number in numbers_list :
    INDENT
        self.main_text.insert(END, self.content.split(number) [0])
        if number in numbers :
        INDENT
            self.main_text.insert(END, number)
        DEDENT
        else :
        INDENT
            self.main_text.insert(END, number, "red")
        DEDENT
        content = ''.join(self.content.split(number) [1 :])
    DEDENT
    return 'break'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32502556_32530964_1_16
32502556_32531351_1_11
Title: Posgres Record does not exits while fetching 
----------------------------------------

def get_application_view(application_id) :
INDENT
    try :
    INDENT
        cursor = connection.cursor()
        sql_query = "SELECT views FROM get_application_views WHERE application_id = '" + str(application_id) + "';"
        cursor.execute(sql_query)
    DEDENT
    except Exception as e :
    INDENT
        print e
        status = 0
        return status
    DEDENT
    else :
    INDENT
        ver = cursor.fetchone()
        if ver :
        INDENT
            status = ver [0]
        DEDENT
        else :
        INDENT
            status = 0
        DEDENT
        return status
    DEDENT
DEDENT
----------------------------------------

def get_application_view(application_id) :
INDENT
    cursor = connection.cursor()
    sql_query = "SELECT * FROM get_application_views('{id}')".format(id = application_id)
    try :
    INDENT
        cursor.execute(sql_query)
    DEDENT
    except Exception as e :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        ver = cursor.fetchone()
        status = ver [0]
        return status
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32510000_32510095_1_12
32510000_32510379_17_26
Title: "Python class: Why can't I use the method len() inside __eq__(self other)?" 
----------------------------------------

def __eq__(self, other) :
INDENT
    if len(self.vals) ! = len(other.vals) :
    INDENT
        return False
    DEDENT
    if type(self.vals) ! = type(other.vals) :
    INDENT
        return False
    DEDENT
    if type(other.vals) not in [list, set, tuple] :
    INDENT
        return False
    DEDENT
    other_list = list(other.vals)
    for i, item in enumerate(self.vals) :
    INDENT
        if item ! = other_list [i] :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def __eq__(self, other) :
INDENT
    if len(self) ! = len(other) :
    INDENT
        print "len(self)"
        return False
    DEDENT
    for i, item in enumerate(self.vals) :
    INDENT
        if item ! = other [i] :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32529645_32530233_1_16
32529645_32530311_1_11
Title: python recursive yield to reduce memory footprint 
----------------------------------------

def split(array) :
INDENT
    n = len(array)
    if n == 1 :
    INDENT
        return
    DEDENT
    else :
    INDENT
        i = n / / 2
        subarray1 = array [: i]
        subarray2 = array [i :]
        yield subarray1
        yield subarray2
        for a in split(subarray1) :
        INDENT
            yield a
        DEDENT
        for a in split(subarray2) :
        INDENT
            yield a
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def split(xs) :
INDENT
    n = len(xs)
    if n == 1 :
    INDENT
        yield xs
    DEDENT
    else :
    INDENT
        i = n / 2
        for xs_ in split(xs [: i]) :
        INDENT
            yield xs_
        DEDENT
        for _xs in split(xs [i :]) :
        INDENT
            yield _xs
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32536224_32536433_1_13
32536224_32536791_1_13
Title: Python check if next element exist in list 
----------------------------------------

def SimpleSymbols(str) :
INDENT
    letters = []
    results = []
    for i in range(len(str)) :
    INDENT
        if str [i] ! = '=' and str [i] ! = '+' :
        INDENT
            letters.append(str [i])
            if i < len(str) - 1 and str [i - 1] == '+' and str [i + 1] == '+' :
            INDENT
                results.append(str [i])
            DEDENT
        DEDENT
    DEDENT
    return len(letters) == len(results)
DEDENT
----------------------------------------

def SimpleSymbols(symbols) :
INDENT
    control = ('+', '=')
    if symbols [0] not in control or symbols [- 1] not in control :
    INDENT
        return False
    DEDENT
    for last_index, symbol in enumerate(symbols [1 : - 1]) :
    INDENT
        next_index = last_index + 2
        if letter not in control :
        INDENT
            if symbols [last_index] ! = '+' or symbols [next_index] ! = '+' :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32544920_32548184_15_25
32544920_32548184_27_40
Title: Change a specified line in QMenu 
----------------------------------------

def __init__(self) :
INDENT
    super(Example, self).__init__()
    mpos = QtGui.QCursor
    x = mpos.pos().x()
    y = mpos.pos().y()
    self.qmenu = popQMenu()
    self.qmenu.show()
    self.qmenu.setGeometry(x - 11, y - 11, 101, 101)
    self.qmenu.exec_()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(popQMenu, self).__init__()
    self.sel_line_pos = 2
    self.widgets = []
    for i in range(22) :
    INDENT
        wAction = QtGui.QWidgetAction(self)
        ql = MyLabel(wAction, i, self.sel_line_pos)
        ql.setStyleSheet(NormalStyle)
        ql.setText("<u>Hello</u> <i>Qt!</i>")
        self.widgets.append(ql)
        wAction.setDefaultWidget(ql)
        self.addAction(wAction)
    DEDENT
    self.widgets [self.sel_line_pos].setStyleSheet(SelectedStyle)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32551201_32551333_1_21
32551201_32552434_1_27
Title: "Searching logs outputting lines before and after match" 
----------------------------------------

def findLogData(log_Files, searchForData, folderPath, resultsFile) :
INDENT
    with open(resultsFile, "w") as resultFile :
    INDENT
        lineCounter = 0
        for file in log_Files :
        INDENT
            with open(folderPath + "\\" + file, 'r', encoding = 'UTF-8') as datalookUp :
            INDENT
                logLines = []
                flag = False
                remLines = 0
                for line in log :
                INDENT
                    if remLines > 0 :
                    INDENT
                        resultsFile.write(line)
                        remLines -= 1
                    DEDENT
                    logLines.append(line)
                    if len(logLines) > nbrOfLinesOver + 1 :
                    INDENT
                        logLines.pop(0)
                    DEDENT
                    for stringToFind in searchForData :
                    INDENT
                        if stringToFind in line :
                        INDENT
                            resultsFile.writelines(logLines)
                            remLines = nbrOfLinesUnder
                        DEDENT
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def findLogData(log_Files, searchForData, folderPath, resultsFile, span = (3, 2)) :
INDENT
    nbrOfLinesOver, nbrOfLinesUnder = span
    with open(resultsFile, 'w') as resultFile :
    INDENT
        for filename in log_Files :
        INDENT
            with open(filename, 'r', encoding = 'UTF-8') as f :
            INDENT
                log = f.readlines()
            DEDENT
            for lineCounter, line in enumerate(log) :
            INDENT
                for stringToFind in searchForData :
                INDENT
                    if stringToFind in line :
                    INDENT
                        slinceStart = min(0, lineCounter - nbrOfLinesUnder)
                        slinceEnd = max(len(log), lineCounter + nbrOfLinesOver + 1)
                        resultFile.writelines(log [slinceStart : slinceEnd])

                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32632157_32634131_2_9
32632157_32653275_14_23
Title: Printing words with the same first and last character and words with the same second character and one before the last character 
----------------------------------------

def main() :
INDENT
    for line in sys.stdin :
    INDENT
        line = line.split()
        for word in line :
        INDENT
            uword = word.lower()
            if len(uword) > 1 :
            INDENT
                if uword [0 : 1] == uword [- 1] or (uword [1 : 2] == uword [- 2] and len(uword) > 3) :
                INDENT
                    print (word)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    for line in sys.stdin :
    INDENT
        line = line.rstrip()
        text = ""
        for word in line :
        INDENT
            if word in ' ' :
            INDENT
                text = text + '\n'
            DEDENT
            else :
            INDENT
                text = text + word
            DEDENT
        DEDENT
        print (text)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32632157_32653275_14_23
32632157_32653275_2_9
Title: Printing words with the same first and last character and words with the same second character and one before the last character 
----------------------------------------

def main() :
INDENT
    for line in sys.stdin :
    INDENT
        line = line.rstrip()
        text = ""
        for word in line :
        INDENT
            if word in ' ' :
            INDENT
                text = text + '\n'
            DEDENT
            else :
            INDENT
                text = text + word
            DEDENT
        DEDENT
        print (text)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    for line in sys.stdin :
    INDENT
        line = line.split()
        for word in line :
        INDENT
            letterword = lw = word.lower()
            if len(lw) > 1 :
            INDENT
                if lw [0 : 1] == lw [- 1] and (lw [1 : 2] == lw [- 2]) :
                INDENT
                    print (word)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32652645_32654430_27_44
32652645_32654430_66_73
Title: Storing logic inside database 
----------------------------------------

def filter_queryset(self, queryset) :
INDENT
    if not self.parent_set :
    INDENT
        for rule in self.rules :
        INDENT
            if self.nature == 'and' :
            INDENT
                queryset = rule.filter_queryset(queryset)
            DEDENT
            elif self.nature == 'or' :
            INDENT
                queryset = queryset | rule.filter_queryset(queryset)
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        for rule_set in self.children :
        INDENT
            if self.nature == 'and' :
            INDENT
                queryset = rule_set.filter_queryset(queryset)
            DEDENT
            elif self.nature == 'or' :
            INDENT
                queryset = queryset | rule_set.filter_queryset(queryset)
            DEDENT
        DEDENT
    DEDENT
    return queryset
DEDENT
----------------------------------------

def filter_queryset(self, queryset) :
INDENT
    filters = {}
    if self.start :
    INDENT
        filters ['{0}__gte'.format(self.attribute)] = self.start
    DEDENT
    if self.end :
    INDENT
        filters ['{0}__lte'.format(self.attribute)] = self.end
    DEDENT
    return queryset.filter(** filters)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32652645_32654430_45_56
32652645_32654430_74_83
Title: Storing logic inside database 
----------------------------------------

def match_instance(self, instance) :
INDENT
    if not self.parent_set :
    INDENT
        if self.nature == 'and' :
        INDENT
            return all([rule_set.match_instance(instance) for rule_set in self.children])
        DEDENT
        if self.nature == 'any' :
        INDENT
            return any([rule_set.match_instance(instance) for rule_set in self.children])
        DEDENT
    DEDENT
    else :
    INDENT
        if self.nature == 'and' :
        INDENT
            return all([rule_set.match_instance(instance) for rule_set in self.children])
        DEDENT
        if self.nature == 'any' :
        INDENT
            return any([rule_set.match_instance(instance) for rule_set in self.children])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def match_instance(self, instance) :
INDENT
    start_ok = True
    end_ok = True
    if self.start :
    INDENT
        start_ok = getattr(instance, self.attribute) > = self.start
    DEDENT
    if self.end :
    INDENT
        end_ok = getattr(instance, self.attribute) < = self.end
    DEDENT
    return start_ok and end_ok
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32663088_32663125_3_11
32663088_32663250_1_11
Title: Python - formatting a file.write string with spaces 
----------------------------------------

def main() :
INDENT
    myfile = open('numbers.txt', 'w')
    total = 0
    for count in range(3, 8) :
    INDENT
        file_size = random.choice(range(5, 19, 2))
        myfile.write(format(str(file_size) + ' '))
        total += file_size
    DEDENT
    myfile.write(format(total))
    myfile.close()
DEDENT
----------------------------------------

def main() :
INDENT
    total = 0
    with open('numbers.txt', 'r') as myfile :
    INDENT
        for line in myfile :
        INDENT
            for i in line.split() :
            INDENT
                amount = float(i)
                total += amount
            DEDENT
        DEDENT
        print (line.strip(), 'End of file')
        print('Numbers in file add up to ', format(total, ',.1f'), end = '')
        print ()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32672769_32672786_1_8
32672769_32672879_1_11
Title: Failing to change bool var state in loop 
----------------------------------------

def primer(x) :
INDENT
    if x == 2 :
    INDENT
        return True
    DEDENT
    if x % 2 == 0 or x < 3 :
    INDENT
        return False
    DEDENT
    return not any(x % i == 0 for i in range(3, int(x **.5) + 1, 2))

DEDENT
----------------------------------------

def primer(x) :
INDENT
    prime = True
    y = math.sqrt(x)
    if type(y) == float :
    INDENT
        y = math.ceil(y)
    DEDENT
    for i in range(3, y + 1) :
    INDENT
        if (x % i) == 0 :
        INDENT
            prime = False
        DEDENT
    DEDENT
    print (prime)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32673965_32674562_4_13
32673965_32674593_4_12
Title: pygame blitting - center 
----------------------------------------

def __init__(self, text,(x, y, w, h), color = (0, 0, 0)) :
INDENT
    self.x, self.y, self.w, self.h = x, y, w, h
    pygame.font.init()
    font = pygame.font.SysFont("sans", 20)
    width, height = font.size(text)
    xoffset = (self.w - width) / / 2
    yoffset = (self.h - height) / / 2
    self.coords = self.x + xoffset, self.y + yoffset
    self.txt = font.render(text, True, color)
DEDENT
----------------------------------------

def __init__(self, text,(x, y), color = (0, 0, 0)) :
INDENT
    self.x = x
    self.y = y
    pygame.font.init()
    font = pygame.font.SysFont("sans", 20)
    self.txt = font.render(text, True, color)
    self.size = font.size(text)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32702954_32703450_7_35
32702954_35881094_5_10
Title: Removing numbers and spaces in multiple file names with Python 
----------------------------------------

def rename_files(path, ext, remove_existing = True) :
INDENT
    for fname in os.listdir(path) :
    INDENT
        if not fname.endswith(ext) :
        INDENT
            continue
        DEDENT
        oldpath = os.path.join(path, fname)
        newname = fname.lstrip(string.digits).strip()
        newpath = os.path.join(path, newname)
        if os.path.exists(newpath) :
        INDENT
            if remove_existing :
            INDENT

                os.remove(newpath)
            DEDENT
            else :
            INDENT
                raise FileExists(newpath)
            DEDENT
        DEDENT
        os.rename(oldpath, newpath)

    DEDENT
DEDENT
----------------------------------------

def rename_files() :
INDENT
    path = os.getcwd()
    file_names = os.listdir(path)
    for name in file_names :
    INDENT
        os.rename(name, re.sub("[0-9](?!\d*$)", "", name))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32705659_32705840_39_47
32705659_32705840_50_59
Title: Tkinter throwing a KeyError when trying to change frames 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Start Page", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)

    button1 = tk.Button(self, text = "Visit Page 1", command = lambda : controller.show_frame(PageOne))
    button1.pack()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Page One", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)

    button1 = tk.Button(self, text = "Start Page", command = lambda : controller.show_frame(StartPage))
    button1.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32705659_32705840_39_47
32705659_32705840_8_29
Title: Tkinter throwing a KeyError when trying to change frames 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Start Page", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)

    button1 = tk.Button(self, text = "Visit Page 1", command = lambda : controller.show_frame(PageOne))
    button1.pack()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    frame = StartPage(container, self)
    frame_ = PageOne(container, self)
    self.frames [StartPage] = frame
    self.frames [PageOne] = frame_
    frame.grid(row = 0, column = 0, sticky = "nsew")
    frame_.grid(row = 0, column = 0, sticky = "nsew")
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32705659_32705840_50_59
32705659_32705840_8_29
Title: Tkinter throwing a KeyError when trying to change frames 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Page One", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)

    button1 = tk.Button(self, text = "Start Page", command = lambda : controller.show_frame(StartPage))
    button1.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    frame = StartPage(container, self)
    frame_ = PageOne(container, self)
    self.frames [StartPage] = frame
    self.frames [PageOne] = frame_
    frame.grid(row = 0, column = 0, sticky = "nsew")
    frame_.grid(row = 0, column = 0, sticky = "nsew")
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
327223_327924_21_30
327223_327924_7_13
Title: Memory Efficient Alternatives to Python Dictionaries 
----------------------------------------

def count(self, wordTuple) :
INDENT
    head, tail = wordTuple [0], wordTuple [1 :]
    loc = bisect.bisect_left(self.words, head)
    if self.words [loc] [0] ! = head :
    INDENT
        if len(tail) == 1 :
        INDENT
            newList = WordList()
        DEDENT
        else :
        INDENT
            newList = WordTree()
        DEDENT
        self.words.insert(loc, (head, newList))
    DEDENT
    self.words [loc] [1].count(tail)
DEDENT
----------------------------------------

def count(self, wordTuple) :
INDENT
    assert len(wordTuple) == 1
    word = wordTuple [0]
    loc = bisect.bisect_left(self.words, word)
    if self.words [loc] [0] ! = word :
    INDENT
        self.words.insert(loc, (word, 0))
    DEDENT
    self.words [loc] = (word, self.words [loc] [1] + 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32728526_32728552_4_23
32728526_52407148_1_9
Title: LCM using recursive? 
----------------------------------------

def lcm(x, y) :
INDENT
    if x > y :
    INDENT
        greater = x
    DEDENT
    else :
    INDENT
        greater = y
    DEDENT
    while True :
    INDENT
        if ((greater % x == 0) and (greater % y == 0)) :
        INDENT
            lcm = greater
            break
        DEDENT
        greater += 1
    DEDENT
    return lcm

DEDENT
----------------------------------------

def lcm(greater, a, b) :
INDENT
    if (greater % a == 0 and greater % b == 0) :
    INDENT
        lcm1 = greater
        return lcm1
    DEDENT
    else :
    INDENT

        lcm1 = lcm(greater + 1, a, b)
        return lcm1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32729397_32729438_2_11
32729397_32729459_2_8
Title: Need tips on writing function in python and return variables 
----------------------------------------

def guessTheNumber(number) :
INDENT
    if number < = 10 :
    INDENT
        return 'Your number is to small'
    DEDENT
    elif number > = 10 :
    INDENT
        return 'Your number is to big'
    DEDENT
    elif number == 10 :
    INDENT
        return 'Your right!'
    DEDENT
DEDENT
----------------------------------------

def guessTheNumber(number) :
INDENT
    if number < = 10 :
    INDENT
        return str('Your number is to small')
    DEDENT
    if number > = 10 :
    INDENT
        return str('Your number is to big')
    DEDENT
    if number == 10 :
    INDENT
        return str('Your right!')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32729397_32729438_2_11
32729397_32729467_1_8
Title: Need tips on writing function in python and return variables 
----------------------------------------

def guessTheNumber(number) :
INDENT
    if number < = 10 :
    INDENT
        return 'Your number is to small'
    DEDENT
    elif number > = 10 :
    INDENT
        return 'Your number is to big'
    DEDENT
    elif number == 10 :
    INDENT
        return 'Your right!'
    DEDENT
DEDENT
----------------------------------------

def guessTheNumber(number) :
INDENT
    if number < 10 :
    INDENT
        return str('Your number is to small')
    DEDENT
    if number == 10 :
    INDENT
        return str('Your right!')
    DEDENT
    if number > 10 :
    INDENT
        return str('Your number is to big')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32729397_32729459_2_8
32729397_32729467_1_8
Title: Need tips on writing function in python and return variables 
----------------------------------------

def guessTheNumber(number) :
INDENT
    if number < = 10 :
    INDENT
        return str('Your number is to small')
    DEDENT
    if number > = 10 :
    INDENT
        return str('Your number is to big')
    DEDENT
    if number == 10 :
    INDENT
        return str('Your right!')
    DEDENT
DEDENT
----------------------------------------

def guessTheNumber(number) :
INDENT
    if number < 10 :
    INDENT
        return str('Your number is to small')
    DEDENT
    if number == 10 :
    INDENT
        return str('Your right!')
    DEDENT
    if number > 10 :
    INDENT
        return str('Your number is to big')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32751602_32751686_46_63
32751602_32751812_36_61
Title: Getting rid of globals and creating functions 
----------------------------------------

def main() :
INDENT
    plyr_x, plyr_y = (9, 5)
    plyr_char = 'o'
    board = create_board(plyr_x, plyr_y, plyr_char)
    print_board(board)
    while True :
    INDENT
        '''Main loop'''
        choice = raw_input('What do you want to do? ')
        print_board(board)
        if choice == 'move' :
        INDENT
            plyr_x, plyr_y, board = move(plyr_x, plyr_y, board)
        DEDENT
        elif choice == 'attack' :
        INDENT
            print 'There is no one to attack right now.'
        DEDENT
        elif choice == 'die' :
        INDENT
            plyr_char = '%'
            print_board(board)
            quit()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    player = Player(9, 5, 'o')
    board = create_board(player)
    print_board(board)
    while True :
    INDENT
        '''Main loop'''
        choice = raw_input('What do you want to do? ')
        print_board(board)
        if choice == 'move' :
        INDENT
            '''Moves the player. Empties the cell previously occupid,
                adds/subtracts 1 from the player location,
                and then reprints the board'''
            direction = raw_input('Which way do you want to move? ')
            if direction in ('up', 'down', 'left', 'right') :
            INDENT
                board [player.x] [player.y] = ' '
                player.move(direction)
                board [player.x] [player.y] = player.char
                print_board(board)
            DEDENT
        DEDENT
        elif choice == 'attack' :
        INDENT
            print 'There is no one to attack right now.'
        DEDENT
        elif choice == 'die' :
        INDENT
            player.char = '%'
            print_board(board)
            quit()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32751602_32751686_5_31
32751602_32751812_9_20
Title: Getting rid of globals and creating functions 
----------------------------------------

def move(plyr_x, plyr_y, board) :
INDENT
    direction = raw_input('Which way do you want to move? ')
    if direction == 'up' :
    INDENT
        board [plyr_x] [plyr_y] = ' '
        plyr_x += - 1
        board [plyr_x] [plyr_y] = 'o'
        print_board(board)
    DEDENT
    elif direction == 'down' :
    INDENT
        board [plyr_x] [plyr_y] = ' '
        plyr_x += 1
        board [plyr_x] [plyr_y] = 'o'
        print_board(board)
    DEDENT
    elif direction == 'right' :
    INDENT
        board [plyr_x] [plyr_y] = ' '
        plyr_y += 1
        board [plyr_x] [plyr_y] = 'o'
        print_board(board)
    DEDENT
    elif direction == 'left' :
    INDENT
        board [plyr_x] [plyr_y] = ' '
        plyr_y += - 1
        board [plyr_x] [plyr_y] = 'o'
        print_board(board)
    DEDENT
    return (plyr_x, plyr_y, board)
DEDENT
----------------------------------------

def move(self, direction) :
INDENT
    if direction.lower() == 'left' :
    INDENT
        self.y -= 1
    DEDENT
    elif direction.lower() == 'right' :
    INDENT
        self.y += 1
    DEDENT
    elif direction.lower() == 'up' :
    INDENT
        self.x -= 1
    DEDENT
    elif direction.lower() == 'down' :
    INDENT
        self.x += 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3276040_3276119_7_19
3276040_4518082_11_19
Title: How can I use the python HTMLParser library to extract data from a specific div tag? 
----------------------------------------

def handle_starttag(self, tag, attributes) :
INDENT
    if tag ! = 'div' :
    INDENT
        return
    DEDENT
    if self.recording :
    INDENT
        self.recording += 1
        return
    DEDENT
    for name, value in attributes :
    INDENT
        if name == 'id' and value == 'remository' :
        INDENT
            break
        DEDENT
    DEDENT
    else :
    INDENT
        return
    DEDENT
    self.recording = 1
DEDENT
----------------------------------------

def handle_starttag(self, tag, attrs) :
INDENT
    if tag == 'required_tag' :
    INDENT
        for name, value in attrs :
        INDENT
            if name == 'somename' and value == 'somevale' :
            INDENT
                print name, value
                print "Encountered the beginning of a %s tag" % tag
                self.recording = 1

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3278481_3278575_1_23
3278481_3278823_1_13
Title: list of all paths from source to sink in directed acyclic graph 
----------------------------------------

def allpaths(source_node, sink_node, memo_dict = None) :
INDENT
    if memo_dict is None :
    INDENT

        memo_dict = dict()
    DEDENT
    if source_node == sink_node :
    INDENT
        return frozenset([(source_node,)])
    DEDENT
    else :
    INDENT
        pair = (source_node, sink_node)
        if pair in memo_dict :
        INDENT
            return memo_dict [pair]
        DEDENT
        else :
        INDENT
            result = set()
            for new_source in source_node.children :
            INDENT
                paths = allpaths(new_source, sink_node, memo_dict)
                for path in paths :
                INDENT
                    path = (source_node,) + path
                    result.add(path)
                DEDENT
            DEDENT
            result = frozenset(result)
            memo_dict [(source_node, sink_node)] = result
            return result
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def allpaths(G, source_nodes, set_of_sink_nodes, path_prefix = ()) :
INDENT
    set_of_result_paths = set()
    for n in source_nodes :
    INDENT
        next_from_n = []
        for an in G [n] :
        INDENT
            if an in set_of_sink_nodes :
            INDENT
                set_of_result_paths.add(path_prefix + (n, an))
            DEDENT
            else :
            INDENT
                next_from_n.append(an)
            DEDENT
        DEDENT
        if next_from_n :
        INDENT
            set_of_result_paths.update(
                allpaths(G, next_from_n, set_of_sink_nodes, path_prefix + (n,)))
        DEDENT
    DEDENT
    return set_of_result_paths
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32792304_32792332_2_18
32792304_32792474_1_9
Title: To insert multiple dictionaries as values into a single key 
----------------------------------------

def dictizeString(string, dictionary) :
INDENT
    while string.startswith('/') :
    INDENT
        string = string [1 :]
    DEDENT
    parts = string.split('/', 1)
    if len(parts) > 1 :
    INDENT
        branch = dictionary.setdefault(parts [0], [dict()])
        dictionary [parts [0]].append(dict())
        dictizeString(parts [1], branch [1])
    DEDENT
    else :
    INDENT
        if dictionary.has_key(parts [0]) :
        INDENT
            dictionary [parts [0]] = dict()
        DEDENT
        else :
        INDENT
            dictionary [parts [0]] = [dict()]
            dictionary [parts [0]].append(dict())

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def dictizeString(path, dictionary) :
INDENT
    keys = path.lstrip('/').split('/')
    current_key = None
    for key in keys :
    INDENT
        if current_key is None :
        INDENT
            current_key = dictionary.setdefault(key, {})
        DEDENT
        else :
        INDENT
            current_key = current_key.setdefault(key, {})
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3279615_3611698_26_49
3279615_4594659_13_22
Title: Python implementation of Jenkins Hash? 
----------------------------------------

def mix(a, b, c) :
INDENT
    a &= 0xffffffff; b &= 0xffffffff; c &= 0xffffffff
    a -= b; a -= c; a ^= (c >> 13); a &= 0xffffffff
    b -= c; b -= a; b ^= (a < < 8); b &= 0xffffffff
    c -= a; c -= b; c ^= (b >> 13); c &= 0xffffffff
    a -= b; a -= c; a ^= (c >> 12); a &= 0xffffffff
    b -= c; b -= a; b ^= (a < < 16); b &= 0xffffffff
    c -= a; c -= b; c ^= (b >> 5); c &= 0xffffffff
    a -= b; a -= c; a ^= (c >> 3); a &= 0xffffffff
    b -= c; b -= a; b ^= (a < < 10); b &= 0xffffffff
    c -= a; c -= b; c ^= (b >> 15); c &= 0xffffffff
    return a, b, c
DEDENT
----------------------------------------

def mix(a, b, c) :
INDENT
    a &= 0xffffffff; b &= 0xffffffff; c &= 0xffffffff
    a -= c; a &= 0xffffffff; a ^= rot(c, 4); a &= 0xffffffff; c += b; c &= 0xffffffff
    b -= a; b &= 0xffffffff; b ^= rot(a, 6); b &= 0xffffffff; a += c; a &= 0xffffffff
    c -= b; c &= 0xffffffff; c ^= rot(b, 8); c &= 0xffffffff; b += a; b &= 0xffffffff
    a -= c; a &= 0xffffffff; a ^= rot(c, 16); a &= 0xffffffff; c += b; c &= 0xffffffff
    b -= a; b &= 0xffffffff; b ^= rot(a, 19); b &= 0xffffffff; a += c; a &= 0xffffffff
    c -= b; c &= 0xffffffff; c ^= rot(b, 4); c &= 0xffffffff; b += a; b &= 0xffffffff
    return a, b, c
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32811790_36257176_21_27
32811790_47725499_1_10
Title: "How to get the same result in book ""Web Scraping with Python: Collecting Data from the Modern Web"" Chapter 7 Data Normalization section" 
----------------------------------------

def ngrams(input, n) :
INDENT
    input = cleanInput(input)
    output = []
    for i in range(len(input) - n + 1) :
    INDENT
        output.append(input [i : i + n])
    DEDENT
    return output
DEDENT
----------------------------------------

def ngrams(input, n) :
INDENT
    input = cleanInput(input)
    output = dict()
    for i in range(len(input) - n + 1) :
    INDENT
        new_ng = " ".join(input [i : i + n])
        if new_ng in output :
        INDENT
            output [new_ng] += 1
        DEDENT
        else :
        INDENT
            output [new_ng] = 1
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32811790_45127800_23_30
32811790_47725499_1_10
Title: "How to get the same result in book ""Web Scraping with Python: Collecting Data from the Modern Web"" Chapter 7 Data Normalization section" 
----------------------------------------

def ngrams(input, n) :
INDENT
    input = clean_input(input)
    output = []
    for i in xrange(len(input) - n + 1) :
    INDENT
        output.append(input [i : i + n])
    DEDENT
    return output

DEDENT
----------------------------------------

def ngrams(input, n) :
INDENT
    input = cleanInput(input)
    output = dict()
    for i in range(len(input) - n + 1) :
    INDENT
        new_ng = " ".join(input [i : i + n])
        if new_ng in output :
        INDENT
            output [new_ng] += 1
        DEDENT
        else :
        INDENT
            output [new_ng] = 1
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32820713_32820983_6_16
32820713_32823020_6_19
Title: Python - Why is this data being written to file incorrectly? 
----------------------------------------

def grab_listings() :
INDENT
    for i in range(0, 5) :
    INDENT
        url = "http://www.gym-directory.com/listing-category/gyms-fitness-centres/page/{}/"
        r = requests.get(url.format(i + 1))
        soup = BeautifulSoup(r.text, 'html.parser')
        l_area = soup.find("div", {"class" : "wlt_search_results"})
        for elem in l_area.findAll("a", {"class" : "frame"}) :
        INDENT
            yield elem ["href"]
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def grab_listings(page_idx) :
INDENT
    ret = []
    url = ("http://www.gym-directory.com/listing-category/gyms-fitness-centres/"
        "page/{}/").format(page_idx)
    r = requests.get(url)
    soup = BeautifulSoup(r.text, 'html.parser')
    l_area = soup.find("div", {"class" : "wlt_search_results"})
    for elem in l_area.findAll("a", {"class" : "frame"}) :
    INDENT

        ret.append(elem ["href"])
    DEDENT
    return ret

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32825565_32826739_2_20
32825565_32836745_8_25
Title: How to use an email template through code in Odoo 8? 
----------------------------------------

def notify(self, composition_mode = False) :
INDENT
    form_view_id = self.env.ref('mail.email_compose_message_wizard_form', False)
    ctx = self.env.context.copy()
    if composition_mode :
    INDENT
        ctx.update({
                'default_composition_mode' : composition_mode,
                })
    DEDENT
    result = {
        'name' : _('Send Mail'),
        'view_type' : 'form',
        'view_mode' : 'form',
        'views' : [(form_view_id, 'form')],
        'res_model' : 'mail.compose.message',
        'view_id' : form_view_id and form_view_id.id,
        'context' : ctx,
        'type' : 'ir.actions.act_window',
        'target' : 'new',
        }
    return result
DEDENT
----------------------------------------

def notify(self) :
INDENT
    self.ensure_one()
    form_view_id = self.env.ref('mail.email_compose_message_wizard_form')
    ctx = dict(default_model = 'event.participants',
        default_res_id = self.id,
        default_composition_mode = 'mass_mail',
        )
    return {
        'name' : 'Send Mail',
        'type' : 'ir.actions.act_window',
        'view_type' : 'form',
        'view_mode' : 'form',
        'res_model' : 'mail.compose.message',
        'views' : [(form_view_id.id, 'form'),],
        'view_id' : form_view_id.id,
        'context' : ctx,
        'target' : 'new',
        }
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32852088_32852632_10_32
32852088_32852632_50_59
Title: Can't access variable from other class - tkinter 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.iconbitmap(self, default = "")
    tk.Tk.wm_title(self, "program")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.name = StringVar()
    self.frames = {}
    for F in (StartPage, contactQues, nameVerify) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
        self.show_frame(StartPage)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "Select Your Name", font = LARGE_FONT)
    label1.pack(pady = 10, padx = 10)
    button2 = ttk.Button(self, text = "Bojangles", command = self.bojangles)
    button2.pack(pady = 5)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32852088_32852632_10_32
32852088_32852632_70_78
Title: Can't access variable from other class - tkinter 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.iconbitmap(self, default = "")
    tk.Tk.wm_title(self, "program")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.name = StringVar()
    self.frames = {}
    for F in (StartPage, contactQues, nameVerify) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
        self.show_frame(StartPage)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label5 = tk.Label(self, text = "Your Name:", font = LARGE_FONT)
    label5.pack(pady = 10, padx = 10)
    labelcontact = tk.Label(self, textvariable = self.controller.name, font = NORM_FONT)
    labelcontact.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32852088_32852632_50_59
32852088_32852632_70_78
Title: Can't access variable from other class - tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label1 = tk.Label(self, text = "Select Your Name", font = LARGE_FONT)
    label1.pack(pady = 10, padx = 10)
    button2 = ttk.Button(self, text = "Bojangles", command = self.bojangles)
    button2.pack(pady = 5)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label5 = tk.Label(self, text = "Your Name:", font = LARGE_FONT)
    label5.pack(pady = 10, padx = 10)
    labelcontact = tk.Label(self, textvariable = self.controller.name, font = NORM_FONT)
    labelcontact.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32883885_32884207_3_15
32883885_32884262_1_15
Title: Exact change in python via recursion 
----------------------------------------

def exact_change(target_amount, L) :
INDENT
    L = sorted(L, reverse = True)
    for v in L :
    INDENT
        if v == target_amount :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            if v < target_amount :
            INDENT
                L.remove(v)
                return exact_change(target_amount - v, L)
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        return False

    DEDENT
DEDENT
----------------------------------------

def exact_change(target_amount, coins) :
INDENT
    list_len = len(coins)
    if list_len == 0 :
    INDENT
        return False
    DEDENT
    if target_amount in coins :
    INDENT
        return True
    DEDENT
    for i in range(0, list_len) :
    INDENT
        reduced = coins [0 : i] + coins [i + 1 :]
        if exact_change(target_amount - coins [i], reduced) :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32894184_32894305_3_11
32894184_32894370_5_13
Title: "Python: Read line from file split it and change object" 
----------------------------------------

def __init__(self, FNAME, SNAME, M1, M2, M3, M4) :
INDENT
    super(Record, self).__init__()
    self.FNAME = FNAME
    self.SNAME = SNAME
    self.M1 = M1
    self.M2 = M2
    self.M3 = M3
    self.M4 = M4
DEDENT
----------------------------------------

def __init__(self, fname = 'default', sname = 'default', m1 = 0, m2 = 0, m3 = 0, m4 = 0) :
INDENT
    self.fname = fname
    self.sname = sname
    self.m1 = int(m1)
    self.m2 = int(m2)
    self.m3 = int(m3)
    self.m4 = int(m4)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32894184_32894305_3_11
32894184_32894738_2_13
Title: "Python: Read line from file split it and change object" 
----------------------------------------

def __init__(self, FNAME, SNAME, M1, M2, M3, M4) :
INDENT
    super(Record, self).__init__()
    self.FNAME = FNAME
    self.SNAME = SNAME
    self.M1 = M1
    self.M2 = M2
    self.M3 = M3
    self.M4 = M4
DEDENT
----------------------------------------

def __init__(self,
first_name = 'default',
second_name = 'default',
m1 = 0, m2 = 0, m3 = 0, m4 = 0) :
INDENT
    self._first_name = first_name
    self._second_name = second_name
    self._m1 = m1
    self._m2 = m2
    self._m3 = m3
    self._m4 = m4
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32894184_32894370_5_13
32894184_32894738_2_13
Title: "Python: Read line from file split it and change object" 
----------------------------------------

def __init__(self, fname = 'default', sname = 'default', m1 = 0, m2 = 0, m3 = 0, m4 = 0) :
INDENT
    self.fname = fname
    self.sname = sname
    self.m1 = int(m1)
    self.m2 = int(m2)
    self.m3 = int(m3)
    self.m4 = int(m4)
DEDENT
----------------------------------------

def __init__(self,
first_name = 'default',
second_name = 'default',
m1 = 0, m2 = 0, m3 = 0, m4 = 0) :
INDENT
    self._first_name = first_name
    self._second_name = second_name
    self._m1 = m1
    self._m2 = m2
    self._m3 = m3
    self._m4 = m4
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32927896_32928261_1_13
32927896_32928331_1_13
Title: "Print out the character word and line amounts using Python" 
----------------------------------------

def stats(filename) :
INDENT
    ' prints the number of lines, words, and characters in file filename'
    lines = chars = 0
    words = []
    with open(filename) as infile :
    INDENT
        for line in infile :
        INDENT
            lines += 1
            words.extend(line.split())
            chars += len(line)
        DEDENT
    DEDENT
    print ("line count:", lines)
    print ("word count:", len(words))
    print ("character counter:", chars)
    return len(words) > len(set(words))
DEDENT
----------------------------------------

def stats(filename) :
INDENT
    chars, words, dupes = 0, 0, False
    seen = set()
    with open(filename) as f :
    INDENT
        for i, line in enumerate(f, 1) :
        INDENT
            chars += len(line)
            spl = line.split()
            words += len(spl)
            if dupes or not seen.isdisjoint(spl) :
            INDENT
                dupes = True
            DEDENT
            elif not dupes :
            INDENT
                seen.update(spl)
            DEDENT
        DEDENT
    DEDENT
    return i, chars, words, dupes
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32932894_32932954_5_12
32932894_32932982_2_10
Title: How can I wrap an empty function to be implemented by a child class in a try-except block? 
----------------------------------------

def get_image_source_url(self, image_page_soup) :
INDENT
    try :
    INDENT
        url = self._image_source_url_implementation(image_page_soup)
    DEDENT
    except NotImplementedError :
    INDENT

        url = 'something else'
    DEDENT
    return processed_result
DEDENT
----------------------------------------

def get_image_source_url(self, image_page_soup) :
INDENT
    try :
    INDENT
        self._get_image_source_url(image_page_soup)
    DEDENT
    except NotImplementedError :
    INDENT
        raise
    DEDENT
    except Exception :
    INDENT
        print ('Some exception occurred, fall back to something else')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32937126_32937561_4_15
32937126_32938576_4_18
Title: "BeautifulSoup replaceWith() method adding escaped html want it unescaped" 
----------------------------------------

def html_urlize(self, text) :
INDENT
    soup = BeautifulSoup(text, "html.parser")
    finalFragments = []
    textNodes = soup.findAll(text = True)
    for textNode in textNodes :
    INDENT
        if getattr(textNode.parent, 'name') == 'a' :
        INDENT
            finalFragments.append(str(textNode.parent))
        DEDENT
        else :
        INDENT
            finalFragments.append(urlize(textNode))
        DEDENT
    DEDENT
    return str("".join(finalFragments))
DEDENT
----------------------------------------

def html_urlize(self, text) :
INDENT
    soup = BeautifulSoup(text, "html.parser")
    print (soup)
    textNodes = soup.findAll(text = True)
    for textNode in textNodes :
    INDENT
        if textNode.parent and getattr(textNode.parent, 'name') == 'a' :
        INDENT
            continue
        DEDENT
        urlizedText = urlize(textNode)
        textNode.replaceWith(BeautifulSoup(urlizedText, "html.parser"))
    DEDENT
    print (soup)
    return str(soup)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32940197_32940336_1_29
32940197_32940352_1_16
Title: Beginner Python Program Evaluating a Password 
----------------------------------------

def validatePassword(pswd) :
INDENT
    if len(pswd) < 8 :
    INDENT
        return False
    DEDENT
    number_in_password = False
    for char in pswd :
    INDENT
        if char in '012356789' :
        INDENT
            number_in_password = True
        DEDENT
    DEDENT
    if not number_in_password :
    INDENT
        return False
    DEDENT
    symbol_in_password = False
    for char in pswd :
    INDENT
        if char in '!@#$%^&*()_+=' :
        INDENT
            symbol_in_password = True
        DEDENT
    DEDENT
    if not symbol_in_password :
    INDENT
        return False
    DEDENT
    uppercase_in_password = False
    for char in pswd :
    INDENT
        if char.isupper() :
        INDENT
            uppercase_in_password = True
        DEDENT
    DEDENT
    if not uppercase_in_password :
    INDENT
        return False

    DEDENT
    return True
DEDENT
----------------------------------------

def validatePassword(pswd) :
INDENT
    if len(pswd) < 8 :
    INDENT
        return False

        return False

        return False

        return False
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32940197_32940336_1_29
32940197_32940585_1_14
Title: Beginner Python Program Evaluating a Password 
----------------------------------------

def validatePassword(pswd) :
INDENT
    if len(pswd) < 8 :
    INDENT
        return False
    DEDENT
    number_in_password = False
    for char in pswd :
    INDENT
        if char in '012356789' :
        INDENT
            number_in_password = True
        DEDENT
    DEDENT
    if not number_in_password :
    INDENT
        return False
    DEDENT
    symbol_in_password = False
    for char in pswd :
    INDENT
        if char in '!@#$%^&*()_+=' :
        INDENT
            symbol_in_password = True
        DEDENT
    DEDENT
    if not symbol_in_password :
    INDENT
        return False
    DEDENT
    uppercase_in_password = False
    for char in pswd :
    INDENT
        if char.isupper() :
        INDENT
            uppercase_in_password = True
        DEDENT
    DEDENT
    if not uppercase_in_password :
    INDENT
        return False

    DEDENT
    return True
DEDENT
----------------------------------------

def validatePassword(pswd) :
INDENT
    l = []
    if len(pswd) > 8 :
    INDENT
        for char in pswd :
        INDENT
            l.append(char)
        DEDENT
    DEDENT
    if any(l for x in l if x.isdigit()) and any(l for x in l if x.isupper()) and any(l for x in l if x in '!@#$%^&*()_+=') :
    INDENT
        print ('Success')
    DEDENT
    else :
    INDENT
        print ('Try again')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32940197_32940352_1_16
32940197_32940585_1_14
Title: Beginner Python Program Evaluating a Password 
----------------------------------------

def validatePassword(pswd) :
INDENT
    if len(pswd) < 8 :
    INDENT
        return False

        return False

        return False

        return False
    DEDENT
    return True
DEDENT
----------------------------------------

def validatePassword(pswd) :
INDENT
    l = []
    if len(pswd) > 8 :
    INDENT
        for char in pswd :
        INDENT
            l.append(char)
        DEDENT
    DEDENT
    if any(l for x in l if x.isdigit()) and any(l for x in l if x.isupper()) and any(l for x in l if x in '!@#$%^&*()_+=') :
    INDENT
        print ('Success')
    DEDENT
    else :
    INDENT
        print ('Try again')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32960868_32961088_1_11
32960868_32961438_2_13
Title: Using a pattern for making a list 
----------------------------------------

def get_pattern(length) :
INDENT
    template = [1, 2, 4, 8]
    output = []
    i = 0
    while True :
    INDENT
        num = template [i % 4] * 10 ** (i / / 4)
        if num > length :
        INDENT
            break
        DEDENT
        output += [num]
        i += 1
    DEDENT
    return output
DEDENT
----------------------------------------

def get_pattern(length) :
INDENT
    repeated_multiplier = (y for x in count(0) for y in repeat(x, 4))
    repeat_1248 = cycle([1, 2, 4, 8])
    number_generator = izip(repeat_1248, repeated_multiplier)
    values = []
    while True :
    INDENT
        x = next(number_generator)
        x = x [0] * 10 ** x [1]
        if x > length :
        INDENT
            break
        DEDENT
        values.append(x)
    DEDENT
    return values
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32961441_32962287_1_11
32961441_33971156_1_10
Title: Variable value passing eeror in openERP 
----------------------------------------

def create(self, cr, uid, values, context = None) :
INDENT
    vals = {}
    for item in self.browse(cr, uid, ids, context = context) :
    INDENT
        acc_no = str(item.name)
    DEDENT
    bank = self.pool.get('hr.bank.register').browse(cr, uid, values ['bank_id']).name
    branch = self.pool.get('hr.branch.registration').browse(cr, uid, values ['branch_id']).name

    name = str(bank) + '/' + str(branch) + '/' + acc_no
    values.update({'name' : name})
    return super(hr_bank_account, self).create(cr, uid, values, context = context)
DEDENT
----------------------------------------

def create(self, cr, uid, values, context = None) :
INDENT
    if values.get('account_no', '') and values.get('bank_id', '') and values.get('branch_id', '') :
    INDENT
        acc_no = values.get('account_no', '')
        bank = self.pool.get('hr.bank.register').browse(cr, uid, values.get('bank_id', '')).name
        branch = self.pool.get('hr.branch.registration').browse(cr, uid, values.get('branch_id', '')).name
        name = str(bank) + '/' + str(branch) + '/' + acc_no
        values.update({'name' : name})
    DEDENT
    return super(hr_bank_account, self).create(cr, uid, values, context = context)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32981350_32981648_30_37
32981350_32981701_27_34
Title: Several functions without global variable 
----------------------------------------

def insert(self) :
INDENT
    ins = raw_input("Word to insert: ").lower()
    if ins not in self.words :
    INDENT
        desc = raw_input("Enter description of word: ")
        self.words [ins] = desc
    DEDENT
    else :
    INDENT
        print "Error: Word already exist"
    DEDENT
DEDENT
----------------------------------------

def insert(word, desc) :
INDENT
    ins = raw_input("Word to insert: ")
    if ins not in word :
    INDENT
        word.append(ins)
    DEDENT
    else :
    INDENT
        print "Error: Word already exist"
    DEDENT
    desc.append(raw_input("Description of word: "))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32981350_32981648_38_44
32981350_32981701_35_44
Title: Several functions without global variable 
----------------------------------------

def look(self) :
INDENT
    up = raw_input("Word to lookup: ").lower()
    if up in self.words :
    INDENT
        print "description of `%s` is `%s`" % (up, self.words [up])
    DEDENT
    else :
    INDENT
        print "Error: Word %s not found" % up
    DEDENT
DEDENT
----------------------------------------

def look(word, desc) :
INDENT
    up = raw_input("Word to lookup: ")
    if up not in word :
    INDENT
        print "Error: Word not found"
    DEDENT
    i = 0
    while up ! = word [i] :
    INDENT
        i += 1
    DEDENT
    if up == word [i] :
    INDENT
        print "Description of word: ", desc [i]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33004993_33005096_1_15
33004993_33005162_1_19
Title: How do i fix my while loop 
----------------------------------------

def main() :
INDENT
    PASSWORD = "apple"
    ALLOWED = 3
    password = input("Enter the password: ")
    while password ! = PASSWORD :
    INDENT
        ALLOWED = ALLOWED - 1
        print ("Wrong. You have", ALLOWED, "guesses left")
        if ALLOWED == 0 :
        INDENT
            print ("You have been locked out")
            break
        DEDENT
        password = input("Enter again ")
    DEDENT
    print ("You have successfully logged into the system")
DEDENT
----------------------------------------

def main() :
INDENT
    USERNAME = "admin"
    PASSWORD = "root"
    ATTEMPTS = 3
    while ATTEMPTS > = 1 :
    INDENT
        print ("You have", ATTEMPTS, "attempts left")
        if ATTEMPTS == 0 :
        INDENT
            break
        DEDENT
        user = input("Please enter your username:")
        password = input("Now enter your password:")
        if user == USERNAME and password == PASSWORD :
        INDENT
            print ("\nYou have successfully logged into the system")
            return
        DEDENT
        else :
        INDENT
            print ("\nThis user name or password does not exist\n")
            ATTEMPTS -= 1
        DEDENT
    DEDENT
    print ("you have been locked out.")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3302844_3302950_10_17
3302844_3302950_2_9
Title: Writing a CherryPy Decorator for Authorization 
----------------------------------------

def authentication_required(* allowed_groups) :
INDENT
    def _authentication_required(f) :
    INDENT
        @ functools.wraps(f)
        def __authentication_required(* args, ** kwargs) :
        INDENT
            return f(* args, ** kwargs)
        DEDENT
        return __authentication_required
    DEDENT
    return _authentication_required
DEDENT
----------------------------------------

def authentication_required(f) :
INDENT
    @ functools.wraps(f)
    def _authentication_required(* args, ** kwargs) :
    INDENT
        return f(* args, ** kwargs)
    DEDENT
    return _authentication_required

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33029034_33029163_13_18
33029034_33029176_14_24
Title: Why aren't my input getting appended into the array? (Python) 
----------------------------------------

def populate_array() :
INDENT
    array = []
    while len(array) < 26 :
    INDENT
        guess = get_guess()
        array.append(guess)
    DEDENT
    return array
DEDENT
----------------------------------------

def populate_array(array) :
INDENT
    while len(array) < 26 :
    INDENT

        guess = guess_function()
        array.append(guess)

    DEDENT
    return array

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33070941_33071113_1_9
33070941_33071142_1_10
Title: Developing a function to show time without imports 
----------------------------------------

def show_time(hour, min) :
INDENT
    hour = int(hour)
    min = int(min)
    if hour > 12 :
    INDENT
        hour -= 12
        return str(hour) + ":" + str(min) + 'pm'
    DEDENT
    else :
    INDENT
        return str(hour) + ":" + str(min) + 'am'
    DEDENT
DEDENT
----------------------------------------

def show_time(hour, minutes) :
INDENT
    if hour > = 12 :
    INDENT
        suffix = "pm"
        if hour ! = 12 :
        INDENT
            hour -= 12
        DEDENT
    DEDENT
    else :
    INDENT
        suffix = "am"
        if hour == 0 :
        INDENT
            hour = 12
        DEDENT
    DEDENT
    return "{0}:{1:02}{2}".format(hour, minutes, suffix)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33070941_33071113_1_9
33070941_33071166_1_11
Title: Developing a function to show time without imports 
----------------------------------------

def show_time(hour, min) :
INDENT
    hour = int(hour)
    min = int(min)
    if hour > 12 :
    INDENT
        hour -= 12
        return str(hour) + ":" + str(min) + 'pm'
    DEDENT
    else :
    INDENT
        return str(hour) + ":" + str(min) + 'am'
    DEDENT
DEDENT
----------------------------------------

def show_time(hour, min) :
INDENT
    if hour > 24 or min > 59 or hour < 0 or min < 0 :
    INDENT
        raise ValueError("Invalid input")
    DEDENT
    is_pm = (hour / 12.0) > 1
    hour = hour % 12
    half_day = "pm" if is_pm else "am"
    print "%02d:%02d%s" % (hour, min, half_day)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33070941_33071142_1_10
33070941_33071166_1_11
Title: Developing a function to show time without imports 
----------------------------------------

def show_time(hour, minutes) :
INDENT
    if hour > = 12 :
    INDENT
        suffix = "pm"
        if hour ! = 12 :
        INDENT
            hour -= 12
        DEDENT
    DEDENT
    else :
    INDENT
        suffix = "am"
        if hour == 0 :
        INDENT
            hour = 12
        DEDENT
    DEDENT
    return "{0}:{1:02}{2}".format(hour, minutes, suffix)
DEDENT
----------------------------------------

def show_time(hour, min) :
INDENT
    if hour > 24 or min > 59 or hour < 0 or min < 0 :
    INDENT
        raise ValueError("Invalid input")
    DEDENT
    is_pm = (hour / 12.0) > 1
    hour = hour % 12
    half_day = "pm" if is_pm else "am"
    print "%02d:%02d%s" % (hour, min, half_day)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33089832_33090101_1_10
33089832_33090291_1_12
Title: loop indentation in python 
----------------------------------------

def avg(lst) :
INDENT
    classSum = 0
    for row in lst :
    INDENT
        sum = 0
        for item in row :
        INDENT
            sum = sum + item
        DEDENT
        print sum / len(row),
        classSum = classSum + sum
    DEDENT
    print
    print classSum / len(lst)
DEDENT
----------------------------------------

def avg(lst) :
INDENT
    try :
    INDENT
        lst [0]
        class_gr = 0
        for row in lst :
        INDENT
            aver_gr = (row [0] + row [1] + row [2]) / 3
            class_gr += aver_gr
            print(aver_gr, end = ' ')
        DEDENT
        print ('\n' + str(class_gr / len(lst)))
    DEDENT
    except IndexError :
    INDENT
        print ('List is empty!')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33089832_33090175_3_13
33089832_33090291_1_12
Title: loop indentation in python 
----------------------------------------

def avg(list) :
INDENT
    total_grade = 0
    for student in list :
    INDENT
        student_sum = 0
        for grade in student :
        INDENT
            student_sum += grade
        DEDENT
        print student_sum / 3
        total_grade += student_sum / 3
    DEDENT
    print " "
    print total_grade / len(list)
DEDENT
----------------------------------------

def avg(lst) :
INDENT
    try :
    INDENT
        lst [0]
        class_gr = 0
        for row in lst :
        INDENT
            aver_gr = (row [0] + row [1] + row [2]) / 3
            class_gr += aver_gr
            print(aver_gr, end = ' ')
        DEDENT
        print ('\n' + str(class_gr / len(lst)))
    DEDENT
    except IndexError :
    INDENT
        print ('List is empty!')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33090225_33090283_1_9
33090225_33090329_10_15
Title: Pounds to Kilograms Conversion not working? 
----------------------------------------

def weight() :
INDENT
    pounds = input("Enter a number in pounds to convert to kilos: ")
    if pounds.isdigit() :
    INDENT
        pounds = int(pounds)
        kilos = pounds * 2.2
        return kilos
    DEDENT
    else :
    INDENT
        print ("Please enter a number next time :D")
    DEDENT
DEDENT
----------------------------------------

def weight() :
INDENT
    conv_type = input("What would you like to convert? ")
    if conv_type == 'pounds' :
    INDENT
        pounds = get_int("Enter a number in pounds to convert to kilos: ")
        kilos = pounds / 2.2
        return kilos, "kg"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3310049_3311157_5_11
3310049_49453199_6_16
Title: Proper use of mutexes in Python 
----------------------------------------

def processData(data) :
INDENT
    mutex.acquire()
    try :
    INDENT
        print ('Do some stuff')
    DEDENT
    finally :
    INDENT
        mutex.release()
    DEDENT
DEDENT
----------------------------------------

def processData(data, thread_safe) :
INDENT
    if thread_safe :
    INDENT
        mutex.acquire()
    DEDENT
    try :
    INDENT
        thread_id = threading.get_ident()
        print ('\nProcessing data:', data, "ThreadId:", thread_id)
    DEDENT
    finally :
    INDENT
        if thread_safe :
        INDENT
            mutex.release()

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33128135_33128276_1_12
33128135_33129410_1_10
Title: Determining the number of integers with a certain amount of factors between two numbers 
----------------------------------------

def n_factors(x, lower, upper) :
INDENT
    int_counter = 0
    div_count = 0
    for i in range(lower, upper + 1) :
    INDENT
        for j in range(1, i + 1) :
        INDENT
            if (i % j) == 0 :
            INDENT
                div_count += 1
            DEDENT
        DEDENT
        if div_count == x :
        INDENT
            print i
            int_counter += 1
        DEDENT
        div_count = 0
    DEDENT
    return int_counter
DEDENT
----------------------------------------

def n_factors(x, lower, upper) :
INDENT
    facs = {}
    for f in range(1, int(upper ** 0.5) + 1) :
    INDENT
        for n in range(lower + f - (lower % f), upper + 1, f) :
        INDENT
            if n not in facs : facs [n] = []
            facs [n].append(f)
        DEDENT
    DEDENT
    for n, numFacs in facs.items() :
    INDENT
        if len(numFacs) ! = x : continue
        print (n)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33132132_33132258_1_12
33132132_33132334_3_21
Title: Python dictionary switch goes through other functions instead of just the one called 
----------------------------------------

def control(a, * args) :
INDENT
    return {
        'ADDITION' : addition,
        'SUBTRACTION' : subtraction,
        'MULTIPLICATION' : multiplication,
        'DIVISION' : division,
        'MOD' : modulo,
        'SECONDPOWER' : secondPower,
        'POWER' : power,
        'SECONDRADIX' : secondRadix,
        'MAGIC' : magic} [a](* args)
DEDENT
----------------------------------------

def control(a, x, y, z, k) :
INDENT
    if a == 'ADDITION' :
    INDENT
        return addition(x, y)
    DEDENT
    elif a == 'SUBTRACTION' :
    INDENT
        return subtraction(x, y)
    DEDENT
    elif a == 'MULTIPLICATION' :
    INDENT
        return multiplication(x, y)
    DEDENT
    elif a == 'DIVISION' :
    INDENT
        return division(x, y),
    DEDENT
    elif a == 'MOD' :
    INDENT
        return modulo(x, y)
    DEDENT
    elif a == 'SECONDPOWER' :
    INDENT
        return secondPower(x)
    DEDENT
    elif a == 'POWER' :
    INDENT
        return power(x, y)
    DEDENT
    elif a == 'SECONDRADIX' :
    INDENT
        return secondRadix(x)
    DEDENT
    elif a == 'MAGIC' :
    INDENT
        return magic(x, y, z, k)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33148740_33149137_3_9
33148740_33150735_1_13
Title: sub-string text with a running number 
----------------------------------------

def count_replace() :
INDENT
    def replace(m) :
    INDENT
        replace.count += 1
        return '[%d]' % replace.count
    DEDENT
    replace.count = 0
    return replace
DEDENT
----------------------------------------

def count_replace(s, to_replace, leng = 0, count = 1, replaced = []) :
INDENT
    if s.find(' ') == - 1 :
    INDENT
        replaced.append(s)
        return ' '.join(replaced)
    DEDENT
    else :
    INDENT
        if s [0 : s.find(' ')].lower() == to_replace.lower() :
        INDENT
            replaced.append('[%d]' % count)
            count += 1
            leng = len(to_replace)
        DEDENT
        else :
        INDENT
            replaced.append(s [0 : s.find(' ')])
            leng = s.find(' ')
        DEDENT
        return count_replace(s [leng + 1 :], to_replace, leng, count, replaced)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33152457_33152630_3_14
33152457_45538825_1_20
Title: Identity matrix 
----------------------------------------

def is_identity_matrix(matrix) :
INDENT
    n = len(matrix)
    if n ! = len(matrix [0]) :
    INDENT
        return False
    DEDENT
    for i, j in product(range(n), range(n)) :
    INDENT
        if i == j :
        INDENT
            if matrix [i] [j] ! = 1 :
            INDENT
                return False
            DEDENT
        DEDENT
        else :
        INDENT
            if matrix [i] [j] ! = 0 :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def is_identity_matrix(matrix) :
INDENT
    n = len(matrix)
    if n == len(matrix [0]) :
    INDENT
        i = 0
        while i < n :
        INDENT
            j = 0
            while j < n :
            INDENT
                if j == i :
                INDENT
                    if matrix [i] [j] ! = 1 :
                    INDENT
                        return False
                    DEDENT
                DEDENT
                else :
                INDENT
                    if matrix [i] [j] ! = 0 or matrix [j] [i] ! = 0 :
                    INDENT
                        return False
                    DEDENT
                DEDENT
                j = j + 1
            DEDENT
            i = i + 1
        DEDENT
        else :
        INDENT
            return True
        DEDENT
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33165212_33176066_29_37
33165212_33176066_7_27
Title: Reading .pcap file from STDIN in Python Scapy 
----------------------------------------

def __init__(self, fd) :
INDENT
    RawPcapReaderFD.__init__(self, fd)
    try :
    INDENT
        self.LLcls = conf.l2types [self.linktype]
    DEDENT
    except KeyError :
    INDENT
        warning("PcapReader: unknown LL type [%i]/[%#x]. Using Raw packets" % (self.linktype, self.linktype))
        self.LLcls = conf.raw_layer

    DEDENT
DEDENT
----------------------------------------

def __init__(self, fd) :
INDENT
    self.filename = "dummy"
    try :
    INDENT
        self.f = fd
        magic = self.f.read(4)
    DEDENT
    except IOError :
    INDENT
        self.f = fd
        magic = self.f.read(4)
    DEDENT
    if magic == "\xa1\xb2\xc3\xd4" :
    INDENT
        self.endian = "><![CDATA["
    DEDENT
    elif magic == "\xd4\xc3\xb2\xa1" :
    INDENT
        self.endian = "<"
    DEDENT
    else :
    INDENT
        raise Scapy_Exception("Not a pcap capture file (bad magic)")
    DEDENT
    hdr = self.f.read(20)
    if len(hdr) < 20 :
    INDENT
        raise Scapy_Exception("Invalid pcap file (too short)")
    DEDENT
    vermaj, vermin, tz, sig, snaplen, linktype = struct.unpack(self.endian + "HHIIII", hdr)
    self.linktype = linktype
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3318625_21894086_8_13
3318625_3318797_11_17
Title: Efficient bidirectional hash table in Python? 
----------------------------------------

def __setitem__(self, key, value) :
INDENT
    if key in self :
    INDENT
        self.inverse [self [key]].remove(key)
    DEDENT
    super(bidict, self).__setitem__(key, value)
    self.inverse.setdefault(value, []).append(key)
DEDENT
----------------------------------------

def __setitem__(self, key, value) :
INDENT
    if key in self :
    INDENT
        del self [key]
    DEDENT
    if value in self :
    INDENT
        del self [value]
    DEDENT
    dict.__setitem__(self, key, value)
    dict.__setitem__(self, value, key)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3318625_21894086_8_13
3318625_34460187_18_24
Title: Efficient bidirectional hash table in Python? 
----------------------------------------

def __setitem__(self, key, value) :
INDENT
    if key in self :
    INDENT
        self.inverse [self [key]].remove(key)
    DEDENT
    super(bidict, self).__setitem__(key, value)
    self.inverse.setdefault(value, []).append(key)
DEDENT
----------------------------------------

def __setitem__(self, key, value) :
INDENT
    if value in self.inverse :
    INDENT
        raise BijectionError(value)
    DEDENT
    self.inverse._set_item(value, key)
    self._set_item(key, value)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3318625_3318797_11_17
3318625_34460187_18_24
Title: Efficient bidirectional hash table in Python? 
----------------------------------------

def __setitem__(self, key, value) :
INDENT
    if key in self :
    INDENT
        del self [key]
    DEDENT
    if value in self :
    INDENT
        del self [value]
    DEDENT
    dict.__setitem__(self, key, value)
    dict.__setitem__(self, value, key)
DEDENT
----------------------------------------

def __setitem__(self, key, value) :
INDENT
    if value in self.inverse :
    INDENT
        raise BijectionError(value)
    DEDENT
    self.inverse._set_item(value, key)
    self._set_item(key, value)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33190518_37488166_14_19
33190518_37488166_4_9
Title: "How can I pass arguments to decorator process there and forward to decorated function?" 
----------------------------------------

def decorator(func) :
INDENT
    @ wraps(func)
    def wrapper(p1, p2 = 101) :
    INDENT
        for v in func(p1, p2) :
        INDENT
            yield v * multiplier
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def decorator(func) :
INDENT
    @ wraps(func)
    def wrapper(p1, p2 = 101) :
    INDENT
        for v in func(p1, p2) :
        INDENT
            yield v + addend
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33198673_33199542_18_22
33198673_33201819_22_28
Title: Memory management for python scripts 
----------------------------------------

def freq89(n) :
INDENT
    total = 0
    for i in range(1, n + 1) :
    INDENT
        if f(i) == 89 : total += 1
    DEDENT
    return total / n
DEDENT
----------------------------------------

def freq89(n) :
INDENT
    total = 0
    for i in range(1, n) :
    INDENT
        if cache [ss(i)] :
        INDENT
            total += 1
        DEDENT
    DEDENT
    return total / n
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33203500_33203551_1_10
33203500_33203619_1_13
Title: How to identify if only a certain amount of numbers in an array are consecutive 
----------------------------------------

def straightCheck(playerHand) :
INDENT
    playerHand.sort()
    tally = 1
    for i in range(len(playerHand) - 1) :
    INDENT
        if playerHand [i] ! = playerHand [i + 1] - 1 :
        INDENT
            tally = 0
        DEDENT
        tally += 1
        if tally > = 5 :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def straightCheck(playerHand) :
INDENT
    playerHand.sort()
    print (playerHand)
    count = 0;
    for i in range(len(playerHand) - 1) :
    INDENT
        if playerHand [i] == playerHand [i + 1] - 1 :
        INDENT
            count += 1
            if count > = 5 :
            INDENT
                return True
            DEDENT
        DEDENT
        else :
        INDENT
            count = 0
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33203992_33204904_15_26
33203992_33204928_17_26
Title: How can I make a recursive search for longest node more efficient? 
----------------------------------------

def find_longest_path(graph, start) :
INDENT
    cache = {}
    maxlen = find_longest_path_rec(graph, start, cache)
    path = [start]
    for i in range(maxlen - 1, 0, - 1) :
    INDENT
        for node in graph [path [- 1]] :
        INDENT
            if cache [node] == i :
            INDENT
                path.append(node)
                break
            DEDENT
        DEDENT
        else :
        INDENT
            assert (0)
        DEDENT
    DEDENT
    return path
DEDENT
----------------------------------------

def find_longest_path(graph) :
INDENT
    max_path = []
    for node in graph :
    INDENT
        candidate_path = find_longest_path_from(graph, node)
        if len(candidate_path) > len(max_path) :
        INDENT
            max_path = candidate_path
        DEDENT
    DEDENT
    return max_path
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3324306_3324868_12_33
3324306_3328629_2_16
Title: Puzzle that defies the brute force approach? 
----------------------------------------

def how_many_used(dight, n) :
INDENT
    if (dight, n) in cache :
    INDENT
        return cache [(dight, n)]
    DEDENT
    result = 0
    if dight == "0" :
    INDENT
        if OPTIMIZE_1 :
        INDENT
            return 0
        DEDENT
        else :
        INDENT
            assert (False)
        DEDENT
    DEDENT
    else :
    INDENT
        if int(n) > = 10 :
        INDENT
            if n [0] == dight :
            INDENT
                result += int(n [1 :]) + 1
            DEDENT
            result += how_many_used(dight, str(int(n [1 :])))
            result += how_many_used(dight, str(int(str(int(n [0]) - 1) + "9" * (len(n) - 1))))
        DEDENT
        else :
        INDENT
            result += 1 if n > = dight else 0
        DEDENT
    DEDENT
    if n.endswith("9" * (len(n) - 4)) :
    INDENT
        cache [(dight, n)] = result
    DEDENT
    return result
DEDENT
----------------------------------------

def how_many_used(n) :
INDENT
    if n in cache :
    INDENT
        return cache [n]
    DEDENT
    result = 0
    if int(n) > = 10 :
    INDENT
        if n [0] == '1' :
        INDENT
            result += int(n [1 :]) + 1
        DEDENT
        result += how_many_used(str(int(n [1 :])))
        result += how_many_used(str(int(str(int(n [0]) - 1) + "9" * (len(n) - 1))))
    DEDENT
    else :
    INDENT
        result += 1 if n > = '1' else 0
    DEDENT
    if n.endswith("9" * (len(n) - 0)) or n.endswith("0" * (len(n) - 1)) :
    INDENT
        cache [n] = result
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3324306_3324868_41_52
3324306_3328629_51_71
Title: Puzzle that defies the brute force approach? 
----------------------------------------

def solve(stickers) :
INDENT
    i = 0
    stickers_left = 0
    while stickers_left > = 0 :
    INDENT
        i += best_jump(i, stickers_left)
        stickers_left = min(map(
                lambda x : how_many_have(x, i, stickers) - how_many_used(str(x), str(i)),
                NUMBERS))
    DEDENT
    return i - 1
DEDENT
----------------------------------------

def solve(stickers) :
INDENT
    i = 1
    while lowest_state(str(i), stickers) > = 0 :
    INDENT
        i *= 2
    DEDENT
    top = i
    bottom = 0
    center = 0
    while top - bottom > 1 :
    INDENT
        center = (top + bottom) / 2
        if lowest_state(str(center), stickers) > = 0 :
        INDENT
            bottom = center
        DEDENT
        else :
        INDENT
            top = center
        DEDENT
    DEDENT
    if lowest_state(str(top), stickers) > = 0 :
    INDENT
        return top
    DEDENT
    else :
    INDENT
        return bottom
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33247149_33247229_1_14
33247149_33247273_1_10
Title: Why is the while loop not working in the if loop? 
----------------------------------------

def n() :
INDENT
    rep = 0
    success = 0
    while rep < 5 or success == 1 :
    INDENT
        name = input('What is the missing animal?')
        if name == 'dog' :
        INDENT
            success = 1
        DEDENT
        else :
        INDENT
            print ('Sorry this is not right')
            rep = rep + 1
        DEDENT
    DEDENT
    if rep == 5 :
    INDENT
        print ('You have guessed incorrectly 5 times.')
    DEDENT
    elif success == 1 :
    INDENT
        print ('Well done')
    DEDENT
DEDENT
----------------------------------------

def n() :
INDENT
    for rep in range(5) :
    INDENT
        name = input('What is the missing animal?')
        if name == 'dog' :
        INDENT
            print ('Well done')
            break
        DEDENT
        else :
        INDENT
            print ('Sorry this is not right')
        DEDENT
    DEDENT
    else :
    INDENT
        print ('You have guessed incorrectly 5 times.')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33247149_33247229_1_14
33247149_33247313_1_12
Title: Why is the while loop not working in the if loop? 
----------------------------------------

def n() :
INDENT
    rep = 0
    success = 0
    while rep < 5 or success == 1 :
    INDENT
        name = input('What is the missing animal?')
        if name == 'dog' :
        INDENT
            success = 1
        DEDENT
        else :
        INDENT
            print ('Sorry this is not right')
            rep = rep + 1
        DEDENT
    DEDENT
    if rep == 5 :
    INDENT
        print ('You have guessed incorrectly 5 times.')
    DEDENT
    elif success == 1 :
    INDENT
        print ('Well done')
    DEDENT
DEDENT
----------------------------------------

def n() :
INDENT
    rep = 0
    while rep < 5 :
    INDENT
        name = input('What is the missing animal? ')
        if name == 'dog' :
        INDENT
            print ('Well done')
            break
        DEDENT
        else :
        INDENT
            print ('Sorry this is not right')
        DEDENT
        rep = rep + 1
    DEDENT
    if rep > = 5 :
    INDENT
        print ('You have guessed incorrectly 5 times.')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33249825_33249916_1_12
33249825_33249959_1_11
Title: Python: How to check if a number is in range and if not have the user enter a new number? 
----------------------------------------

def getInt(low, high) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            num = int(input("Enter a number for your calculation in range of 1- 9: "))
        DEDENT
        except ValueError :
        INDENT
            print ("Error: Please only enter numbers")
            continue
        DEDENT
        if num not in range(1, 10) :
        INDENT
            print ("Error: Please only enter numbers between 1-9")
        DEDENT
        else :
        INDENT
            return num
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def getInt(low, high) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            numStr = raw_input("Enter a number for your calculation in range of {0} - {1}: ".format(low, high))
            if numStr.isdigit() :
            INDENT
                num = int(numStr)
                if num < = high and num > = low :
                INDENT
                    return num
                DEDENT
            DEDENT
        DEDENT
        except :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33280181_33280319_1_20
33280181_33281941_5_17
Title: For loop calculation incorrect 
----------------------------------------

def rpn_eval(s) :
INDENT
    result = []
    for x in s :
    INDENT
        print (result)
        if x == "add" :
        INDENT
            result.append(result.pop() + result.pop())
        DEDENT
        elif x == "subtract" :
        INDENT
            y = result.pop()
            x = result.pop()
            result.append(x - y)
        DEDENT
        elif x == "multiply" :
        INDENT
            result.append(result.pop() * result.pop())
        DEDENT
        elif x == "divide" :
        INDENT
            y = result.pop()
            z = result.pop()
            result.append(z / y)
        DEDENT
        else :
        INDENT
            result.append(x)
        DEDENT
    DEDENT
    return result [- 1]
DEDENT
----------------------------------------

def rpn_eval(expression) :
INDENT
    result = []
    ops = {"add" : float.__radd__,
        "subtract" : float.__rsub__,
        "multiply" : float.__rmul__,
        "divide" : float.__rtruediv__}
    for arg in expression :
    INDENT
        result.append(arg if arg not in ops else ops [arg](result.pop().__float__(), result.pop()))
    DEDENT
    return result [- 1]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33291297_33291667_1_11
33291297_33304329_11_21
Title: How to replace previous plots in a matplotlib figure with new plots or grid of plots? 
----------------------------------------

def dosomething() :
INDENT
    try :
    INDENT
        self.canvas.get_tk_widget().destroy()
    DEDENT
    except :
    INDENT
        pass
    DEDENT
    fig = Figure(figsize = (12, 4))
    axes = fig.add_subplot(111)
    self.canvas = FigureCanvasTkAgg(fig, master = windows)
    self.canvas.get_tk_widget().pack()
    data = np.arange(100)
DEDENT
----------------------------------------

def dosomething(self) :
INDENT
    try :
    INDENT
        self.canvas.get_tk_widget().destroy()
    DEDENT
    except :
    INDENT
        pass
    DEDENT
    self.figure = Figure(figsize = (12, 4))
    self.axes = self.figure.add_subplot(111)
    self.im = self.axes.plot(data)
    self.canvas = FigureCanvasTkAgg(self.figure, master = windows)
    self.canvas.get_tk_widget().pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33292644_33292721_10_22
33292644_33292734_7_17
Title: How to add the Numbers from the User into a List 
----------------------------------------

def userChoice(userNumbers) :
INDENT
    while True :
    INDENT
        print ("Awesome, now that we haave your numbers please choose an operation (Mean, Median, or Mode!)")
        userAnswer = raw_input("Enter your choice here: ")
        if userAnswer == "Mean" :
        INDENT
            mean = sum(userNumbers) / float(len(userNumbers))
            return mean
        DEDENT
        elif userAnswer == "Mode" :
        INDENT
            mode = Counter(userNumbers)
            return mode
        DEDENT
        continue
    DEDENT
DEDENT
----------------------------------------

def userChoice(userNumbers) :
INDENT
    print ("Awesome, now that we haave your numbers please choose an operation (Mean, Median, or Mode!)")
    userAnswer = raw_input("Enter your choice here: ")
    if userAnswer == "Mean" :
    INDENT

        mean = sum(userNumbers) / float(len(userNumbers))
        return mean

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33295297_33295365_1_12
33295297_33295394_1_16
Title: Adding values to a 2D list 
----------------------------------------

def organize(orgList) :
INDENT
    intList = []
    floatList = []
    strList = []
    for i in orgList :
    INDENT
        if isinstance(i, int) :
        INDENT
            intList.append(i)
        DEDENT
        elif isinstance(i, float) :
        INDENT
            floatList.append(i)
        DEDENT
        else :
        INDENT
            strList.append(i)
        DEDENT
    DEDENT
    return intList, strList, floatList
DEDENT
----------------------------------------

def organize(orgList) :
INDENT
    result = []
    intList = []
    floatList = []
    strList = []
    for i in orgList :
    INDENT
        if type(i) == str :
        INDENT
            strList.append(i)
        DEDENT
        elif type(i) == float :
        INDENT
            floatList.append(i)
        DEDENT
        elif type(i) == int :
        INDENT
            intList.append(i)
        DEDENT
    DEDENT
    result.append(strList)
    result.append(intList)
    result.append(floatList)
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33295297_33295394_1_16
33295297_33295531_1_13
Title: Adding values to a 2D list 
----------------------------------------

def organize(orgList) :
INDENT
    result = []
    intList = []
    floatList = []
    strList = []
    for i in orgList :
    INDENT
        if type(i) == str :
        INDENT
            strList.append(i)
        DEDENT
        elif type(i) == float :
        INDENT
            floatList.append(i)
        DEDENT
        elif type(i) == int :
        INDENT
            intList.append(i)
        DEDENT
    DEDENT
    result.append(strList)
    result.append(intList)
    result.append(floatList)
    return result
DEDENT
----------------------------------------

def organize(orgList) :
INDENT
    intList = []
    floatList = []
    strList = []
    for i in orgList :
    INDENT
        ti = type(i)
        if ti is int :
        INDENT
            intList.append(i)
        DEDENT
        elif ti is float :
        INDENT
            floatList.append(i)
        DEDENT
        elif ti is str :
        INDENT
            strList.append(i)
        DEDENT
    DEDENT
    return intList, strList, floatList
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33300579_33300727_1_26
33300579_33300753_1_11
Title: python add results from different lists to single list 
----------------------------------------

def zipper(l1, l2, l3) :
INDENT
    results = []
    g, h, t = True, True, True
    i = 0
    while (g or h or t) :
    INDENT
        if (len(l1) > i) :
        INDENT
            results.append(l1 [i])
        DEDENT
        else :
        INDENT
            g = False
        DEDENT
        if (len(l2) > i) :
        INDENT
            results.append(l2 [i])
        DEDENT
        else :
        INDENT
            h = False
        DEDENT
        if (len(l3) > i) :
        INDENT
            results.append(l3 [i])
        DEDENT
        else :
        INDENT
            t = False
        DEDENT
        i += 1
    DEDENT
    return results
    l1 = [1, 2, 3, 4, 5, 6, 7]
    l2 = ["a", "b", "c"]
    l3 = [[1, 2], [1, 2, 3], "test", 300]
    print (zipper(l1, l2, l3))
DEDENT
----------------------------------------

def zipper(l1, l2, l3) :
INDENT
    results = []
    while l1 or l2 or l3 :
    INDENT
        if l1 :
        INDENT
            results.append(l1.pop(0))
        DEDENT
        if l2 :
        INDENT
            results.append(l2.pop(0))
        DEDENT
        if l3 :
        INDENT
            results.append(l3.pop(0))
        DEDENT
        return results
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33300579_33300727_1_26
33300579_33301194_10_19
Title: python add results from different lists to single list 
----------------------------------------

def zipper(l1, l2, l3) :
INDENT
    results = []
    g, h, t = True, True, True
    i = 0
    while (g or h or t) :
    INDENT
        if (len(l1) > i) :
        INDENT
            results.append(l1 [i])
        DEDENT
        else :
        INDENT
            g = False
        DEDENT
        if (len(l2) > i) :
        INDENT
            results.append(l2 [i])
        DEDENT
        else :
        INDENT
            h = False
        DEDENT
        if (len(l3) > i) :
        INDENT
            results.append(l3 [i])
        DEDENT
        else :
        INDENT
            t = False
        DEDENT
        i += 1
    DEDENT
    return results
    l1 = [1, 2, 3, 4, 5, 6, 7]
    l2 = ["a", "b", "c"]
    l3 = [[1, 2], [1, 2, 3], "test", 300]
    print (zipper(l1, l2, l3))
DEDENT
----------------------------------------

def zipper(* iterables) :
INDENT
    gens = [forever(it) for it in iterables]
    result = []
    while True :
    INDENT
        a = [u for u in [next(g) for g in gens] if u is not Done]
        if a == [] :
        INDENT
            break
        DEDENT
        result.extend(a)
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33300579_33300753_1_11
33300579_33301194_10_19
Title: python add results from different lists to single list 
----------------------------------------

def zipper(l1, l2, l3) :
INDENT
    results = []
    while l1 or l2 or l3 :
    INDENT
        if l1 :
        INDENT
            results.append(l1.pop(0))
        DEDENT
        if l2 :
        INDENT
            results.append(l2.pop(0))
        DEDENT
        if l3 :
        INDENT
            results.append(l3.pop(0))
        DEDENT
        return results
    DEDENT
DEDENT
----------------------------------------

def zipper(* iterables) :
INDENT
    gens = [forever(it) for it in iterables]
    result = []
    while True :
    INDENT
        a = [u for u in [next(g) for g in gens] if u is not Done]
        if a == [] :
        INDENT
            break
        DEDENT
        result.extend(a)
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33304037_33305170_11_30
33304037_33306455_15_31
Title: 'NoneType' object has no attribute 'children' 
----------------------------------------

def init_window(self) :
INDENT
    self.ins = StringVar
    self.dele = StringVar
    self.upd = StringVar
    self.b1 = Button(self.master, text = 'insert(name,info,date)')
    self.b1.grid(row = 0, column = 0)
    self.b2 = Button(self.master, text = 'delete')
    self.b2.grid(row = 1, column = 0)
    self.b3 = Button(self.master, text = 'update')
    self.b3.grid(row = 2, column = 0)
    self.e1 = Entry(self.master, textvariable = self.ins)
    self.e1.grid(row = 0, column = 1)
    self.e2 = Entry(self.master, textvariable = self.dele)
    self.e2.grid(row = 1, column = 1)
    self.e3 = Entry(self.master, textvariable = self.upd)
    self.e3.grid(row = 2, column = 1)
    a = self.e1.get()
    b = self.e2.get()
    c = self.e3.get()
DEDENT
----------------------------------------

def init_window(self) :
INDENT
    self.root.title("GUI")
    self.b1 = Label(self.root, text = 'insert(name,info,date)')
    self.b1.grid(row = 0, column = 0)

    Button(self.root, text = "print entry",
        command = self.get_values).grid(row = 3, column = 0)
    self.e1 = Entry(self.root)
    self.e1.grid(row = 0, column = 1)
    self.e2 = Entry(self.root, text = "info")
    self.e2.grid(row = 1, column = 1)
    self.e3 = Entry(self.root, text = "date")
    self.e3.grid(row = 2, column = 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33330263_33332146_15_20
33330263_33332146_22_28
Title: how to tell Python that we always want to interpret an object of type Foo as an object of type Bar when there are conflicts? 
----------------------------------------

def register(self, types, function) :
INDENT
    if types in self.typemap :
    INDENT
        raise TypeError("duplicate registration")
    DEDENT
    print ('registering: {!r} for args: {}'.format(function.__name__, types))
    self.typemap [types] = function
DEDENT
----------------------------------------

def register(function) :
INDENT
    name = function.__name__
    mm = _registry.get(name)
    if mm is None :
    INDENT
        mm = _registry [name] = MultiMethod(name)
    DEDENT
    mm.register(types, function)
    return mm
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33330263_33332146_15_20
33330263_33332146_32_39
Title: how to tell Python that we always want to interpret an object of type Foo as an object of type Bar when there are conflicts? 
----------------------------------------

def register(self, types, function) :
INDENT
    if types in self.typemap :
    INDENT
        raise TypeError("duplicate registration")
    DEDENT
    print ('registering: {!r} for args: {}'.format(function.__name__, types))
    self.typemap [types] = function
DEDENT
----------------------------------------

def register(function) :
INDENT
    name = function.__name__
    mm = _registry.get(name)
    if mm is None :
    INDENT
        mm = _registry [name] = MultiMethod(name)
    DEDENT
    mm.register(types [: : - 1], lambda a, b : function(b, a))
    mm.register(types, function)
    return mm
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33330263_33332146_22_28
33330263_33332146_32_39
Title: how to tell Python that we always want to interpret an object of type Foo as an object of type Bar when there are conflicts? 
----------------------------------------

def register(function) :
INDENT
    name = function.__name__
    mm = _registry.get(name)
    if mm is None :
    INDENT
        mm = _registry [name] = MultiMethod(name)
    DEDENT
    mm.register(types, function)
    return mm
DEDENT
----------------------------------------

def register(function) :
INDENT
    name = function.__name__
    mm = _registry.get(name)
    if mm is None :
    INDENT
        mm = _registry [name] = MultiMethod(name)
    DEDENT
    mm.register(types [: : - 1], lambda a, b : function(b, a))
    mm.register(types, function)
    return mm
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33335875_40346549_1_38
33335875_51334902_41_60
Title: Python-How to find length of the longest run of monotonically increasing numbers? 
----------------------------------------

def longest_run(L) :
INDENT
    firstone = mIncreasing(L)
    secondone = mDecreasing(L)
    result = 0
    if len(firstone) > len(secondone) :
    INDENT
        for i in firstone :
        INDENT
            result += i
        DEDENT
    DEDENT
    elif len(firstone) == len(secondone) :
    INDENT
        for i in L :
        INDENT
            if sum(firstone) == sum(secondone) :
            INDENT
                for r in firstone :
                INDENT
                    result += r
                DEDENT
                break
            DEDENT
            if i in firstone and not i in secondone :
            INDENT
                for j in firstone :
                INDENT
                    result += j
                DEDENT
                break
            DEDENT
            elif i in secondone and not i in firstone :
            INDENT
                for k in secondone :
                INDENT
                    result += k
                DEDENT
                break
            DEDENT
        DEDENT
    DEDENT
    elif len(firstone) < len(secondone) :
    INDENT
        for i in secondone :
        INDENT
            result += i
        DEDENT
    DEDENT
    return result

DEDENT
----------------------------------------

def longest_run(L) :
INDENT
    startIndexI, endIndexI = getMonotonicallyI(L)
    startIndexD, endIndexD = getMonotonicallyD(L)
    if newIndexIsLongerLength(startIndexI, endIndexI, startIndexD, endIndexD) :
    INDENT
        return sum(L [startIndexD : endIndexD + 1])
    DEDENT
    return sum(L [startIndexI : endIndexI + 1])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33387729_33387829_20_29
33387729_33390866_22_30
Title: Where would I add a for loop? Stock Transaction 
----------------------------------------

def calc(num_stocks, name, numsh, pp, sp, comm) :
INDENT
    for d in range(num_stocks) :
    INDENT
        Amtpaid = numsh * pp
        bycomm = Amtpaid * comm
        stocksold = numsh * sp
        scomm = stocksold * comm
        profit = (Amtpaid + comm) - (scomm - comm)
        prnt(Amtpaid, bycomm, stocksold, scomm, profit)
    DEDENT
DEDENT
----------------------------------------

def calc(name, numsh, pp, sp, comm) :
INDENT
    amtpaid = numsh * pp
    bycomm = amtpaid * comm
    stocksold = numsh * sp
    scomm = stocksold * comm
    profit = (amtpaid + comm) - (scomm - comm)
    return amtpaid, bycomm, stocksold, scomm, profit
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33387729_33387829_30_39
33387729_33390866_31_39
Title: Where would I add a for loop? Stock Transaction 
----------------------------------------

def prnt(Amtpaid, bycomm, stocksold, scomm, profit) :
INDENT
    print ("Amount paid for stock:$", format(Amtpaid, ',.2f'))
    print ("Commision paid on the purchase:$", format(bycomm, ',.2f'))
    print ("Amount the stock sold for:$:", format(stocksold, ',.2f'))
    print ("Commission paid on the sale:$", format(scomm, ',.2f'))
    print ("Profit:$", format(profit, ',.2f'))
    print ("\n")
DEDENT
----------------------------------------

def prnt(amtpaid, bycomm, stocksold, scomm, profit) :
INDENT
    print ("Amount paid for stock: ${:,.2f}".format(amtpaid))
    print ("Commision paid on the purchase: ${:,.2f}".format(bycomm))
    print ("Amount the stock sold for: ${:,.2f}".format(stocksold))
    print ("Commission paid on the sale: ${:,.2f}".format(scomm))
    print ("Profit: ${:,.2f}".format(profit))
    print ("\n")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33387729_33387829_5_19
33387729_33390866_9_21
Title: Where would I add a for loop? Stock Transaction 
----------------------------------------

def load() :
INDENT
    num_stocks = int(input("How many stocks do you want processed?"))
    for i in range(num_stocks) :
    INDENT
        print ("Stock number", i + 1)
        print (".....................")
        name = input("Enter stock name:\n")
        numsh = float(input("Number of Shares:\n"))
        pp = float(input("Enter Purchase Price:\n"))
        sp = float(input("Enter Selling Price:\n"))
        comm = float(input("Enter Commission:\n"))
        print("Stock Results", end = '')
        print ("..................")
        calc(num_stocks, name, numsh, pp, sp, comm)
    DEDENT
DEDENT
----------------------------------------

def load(stock_number) :
INDENT
    print ("Stock number", stock_number)
    print (".....................")
    name = input("Enter stock name:\n")
    numsh = float(input("Number of Shares:\n"))
    pp = float(input("Enter Purchase Price:\n"))
    sp = float(input("Enter Selling Price:\n"))
    comm = float(input("Enter Commission:\n"))
    print("Stock Results", end = '')
    print ("..................")
    return name, numsh, pp, sp, comm
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33435559_33436975_1_13
33435559_33437170_1_12
Title: "Quicksort first element as pivot  quick code check" 
----------------------------------------

def quickSort(aList, l, r) :
INDENT
    if l < r :
    INDENT
        swap = l
        for run in range(l + 1, r + 1) :
        INDENT
            if aList [l] > aList [run] :
            INDENT
                swap += 1
                aList [swap], aList [run] = aList [run], aList [swap]

            DEDENT
        DEDENT
        aList [l], aList [swap] = aList [swap], aList [l]
        quickSort(aList, l, swap - 1)
        quickSort(aList, swap + 1, r)
    DEDENT
DEDENT
----------------------------------------

def quickSort(aList, l, r) :
INDENT
    if l < r :
    INDENT
        swap = l + 1
        pivot = aList [l]
        for run in range(l + 1, r) :
        INDENT
            if pivot > aList [run] :
            INDENT
                aList [swap], aList [run] = aList [run], aList [swap]
                swap += 1
            DEDENT
        DEDENT
        aList [l], aList [swap - 1] = aList [swap - 1], aList [l]
        quickSort(aList, l, swap - 1)
        quickSort(aList, swap, r)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33436193_33439199_28_46
33436193_33439199_70_88
Title: append item to variable list from widget in python 
----------------------------------------

def initUI(self) :
INDENT
    self.setGeometry(300, 300, 250, 150)
    self.setWindowTitle('Input List')

    self.listLabel = QtGui.QLabel('Label')
    self.nameInput = QtGui.QLineEdit()

    self.nameInput.returnPressed.connect(self.returnPressed)

    self.mainLayout = QtGui.QVBoxLayout(self)
    self.mainLayout.addWidget(self.listLabel)
    self.mainLayout.addWidget(self.nameInput)
    self.show()
DEDENT
----------------------------------------

def initUI(self) :
INDENT
    self.setGeometry(300, 300, 250, 50)
    self.setWindowTitle('Names')

    self.formWidget = FormWidget('Names')
    self.btn = QtGui.QPushButton('Print')

    self.btn.clicked.connect(self.printNames)

    self.mainLayout = QtGui.QHBoxLayout(self)
    self.mainLayout.addWidget(self.formWidget)
    self.mainLayout.addWidget(self.btn)
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33469897_33470137_13_20
33469897_38406708_1_23
Title: "dfs to implement a graph python" 
----------------------------------------

def dfs(graph, start, end, path, result) :
INDENT
    path += [start]
    if start == end :
    INDENT
        result.append(path)
    DEDENT
    else :
    INDENT
        for node in graph [start] :
        INDENT
            if node not in path :
            INDENT
                dfs(graph, node, end, path [:], result)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def dfs(graph, start) :
INDENT
    vertex = start
    visited, stack = [vertex], [vertex]
    while stack :
    INDENT
        for i, each in enumerate(graph [vertex]) :
        INDENT
            if each not in visited :
            INDENT
                visited.append(each)
                stack += [each]
                vertex = each
                break
            DEDENT
            else :
            INDENT
                if i == len(graph [vertex]) - 1 :
                INDENT
                    vertex = stack.pop()
                    break
                DEDENT
                else :
                INDENT
                    continue
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return visited
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33508034_33508835_1_11
33508034_35417009_1_10
Title: Making a collatz program automate the boring stuff 
----------------------------------------

def collatz(number) :
INDENT
    if number % 2 == 0 :
    INDENT
        print (number / / 2)
        return number / / 2
    DEDENT
    elif number % 2 == 1 :
    INDENT
        result = 3 * number + 1
        print (result)
        return result
    DEDENT
DEDENT
----------------------------------------

def collatz(number) :
INDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number = number / / 2
            print (number)
        DEDENT
        elif number % 2 == 1 :
        INDENT
            number = number * 3 + 1
            print (number)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
33508034_33508835_1_11
33508034_37338843_1_9
Title: Making a collatz program automate the boring stuff 
----------------------------------------

def collatz(number) :
INDENT
    if number % 2 == 0 :
    INDENT
        print (number / / 2)
        return number / / 2
    DEDENT
    elif number % 2 == 1 :
    INDENT
        result = 3 * number + 1
        print (result)
        return result
    DEDENT
DEDENT
----------------------------------------

def collatz(number) :
INDENT
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            print (number / / 2)
            number = number / / 2
        DEDENT
        elif number % 2 == 1 :
        INDENT
            print (number * 3 + 1)
            number = number * 3 + 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
