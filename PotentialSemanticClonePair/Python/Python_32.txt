$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36205245_36234502_36_52
36205245_36234502_6_34
Title: Progress bar in Sublime Text with Python 
----------------------------------------

def run(self) :
INDENT
    self.window.create_output_panel("progess_bar")
    self.window.run_command("show_panel", {"panel" : "output.progess_bar"})
    def test_progress_bar() :
    INDENT
        import random
        test_progress_bar.value += 2 * random.random()
        if test_progress_bar.value > = 100 :
        INDENT
            self.finish_progress()
            return
        DEDENT
        self.show_progress(test_progress_bar.value)
        sublime.set_timeout(test_progress_bar, 100)
    DEDENT
    test_progress_bar.value = 0
    sublime.set_timeout_async(test_progress_bar, 1)
DEDENT
----------------------------------------

def run(self, edit, value) :
INDENT
    view = self.view
    width, _ = view.viewport_extent()
    em_width = view.em_width()

    columns = int(width / em_width) - 2

    bar_length = columns - 2
    filled_length = int(bar_length * value / 100)
    remaining_length = bar_length - filled_length
    text = "[{0}{1}]\n".format("=" * filled_length, "." * remaining_length)
    if value > = 100 :
    INDENT
        percentage_text = "finished!"
    DEDENT
    else :
    INDENT
        percentage_text = "{:3.2f} %".format(value)
    DEDENT
    text += " " * (columns - len(percentage_text)) + percentage_text

    view.replace(edit, sublime.Region(0, view.size()), text)
    view.sel().clear()
    view.sel().add(sublime.Region(0, 0))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36208713_36208997_6_25
36208713_36209846_7_13
Title: python download all files in a web page 
----------------------------------------

def main() :
INDENT
    os.chdir('Downloads')
    base_url = 'http://standards.iso.org'
    page_url = basejoin(base_url,
        'ittf/PubliclyAvailableStandards/'
        'ISO_IEC_14496-26_2010_Bitstreams/'
        'DVD1/mpeg4audio-conformance/compressedMp4/')
    page_string = urlopen(page_url).read()
    page_html = html.fromstring(page_string)
    for link in page_html.getiterator('a') :
    INDENT
        file_url = basejoin(base_url, link.get('href'))
        if file_url.endswith('.mp4') :
        INDENT
            print 'Downloading: {}'.format(file_url)
            runme('wget {}'.format(file_url))

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    url = "http://standards.iso.org/ittf/PubliclyAvailableStandards/ISO_IEC_14496-26_2010_Bitstreams/DVD1/mpeg4audio-conformance/compressedMp4/"
    page = html.fromstring(urllib.urlopen(url).read())
    reqs = (grequests.get((urljoin("http://standards.iso.org/", link))) for link in page.xpath("//a/@href"))
    for resp in grequests.imap(reqs) :
    INDENT
        print (resp.content)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36263131_36263253_4_9
36263131_36263365_4_9
Title: How to call multi-level nested function in Python? 
----------------------------------------

def func2() :
INDENT
    x2 = 2
    def func3() :
    INDENT
        x3 = 3
        print (x1, x2, x3)
    DEDENT
    return func3
DEDENT
----------------------------------------

def func2() :
INDENT
    x2 = 2
    def func3() :
    INDENT
        x3 = 3
        print (x1, x2, x3)
    DEDENT
    func3()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36295020_49341086_2_10
36295020_50787875_2_16
Title: Python/PyQT: How can I truncate a text in QLineEdit 
----------------------------------------

def __init__(self, text = "") :
INDENT
    super(ElidingQLineEdit, self).__init__()
    self.mText = text
    self.fm = QtGui.QFontMetrics(self.font())
    self.textEdited.connect(self.saveText)
    self.editingFinished.connect(self.elideText)

DEDENT
----------------------------------------

def __init__(self, elide = Qt.ElideMiddle, parent = None) :
INDENT
    QWidget.__init__(self, parent)
    self.setMinimumWidth(80)
    self.font_metrics = QFontMetrics(self.font())
    self.saved_text = ""
    self._elide = elide
    self._show_original_text = False
    self.init_ui()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36297253_36297402_1_12
36297253_36297431_1_15
Title: "Looping through a text file while adding it to a dictionary with word length as the key" 
----------------------------------------

def make_length_wordcount(x) :
INDENT
    filename = x + '.txt'
    infile = open(filename)
    wordlist = infile.read().split()
    counter1 = {}
    for word in wordlist :
    INDENT
        if len(word) in counter1 :
        INDENT
            counter1 [len(word)] += 1
        DEDENT
        else :
        INDENT
            counter1 [len(word)] = 1
        DEDENT
    DEDENT
    infile.close()
    print (counter1)
DEDENT
----------------------------------------

def make_length_wordcount() :
INDENT
    test = " Hello World\n This is some cool python"
    wordlist = test.split()
    words = {}
    for word in wordlist :
    INDENT
        if str(len(word)) in words.keys() :
        INDENT
            words [str(len(word))] = words [str(len(word))] + 1
        DEDENT
        else :
        INDENT
            words [str(len(word))] = 1
        DEDENT
    DEDENT
    result = ""
    for key in sorted(words.iterkeys()) :
    INDENT
        result = result + "%s: %s, " % (key, words [key])
    DEDENT
    result = result [: len(result) - 2]
    print result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36300850_36304025_19_42
36300850_36304025_52_85
Title: "Py 3: tkinter frames coding inside or outside of frame classes" 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    tk.Tk.wm_title(self, "Mathematic Equation program")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, AdditionPage, SubtractionPage, MultiplicationPage, DivisionPage) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label1 = tk.Label(self, text = "Mathmatics Problems Quiz", font = LARGE_FONT)
    label2 = tk.Label(self, text = "Mathematic Equation program", font = MEDIUM_FONT)
    label3 = tk.Label(self, text = "Select Your Operation and Difficulty Level", font = SMALL_FONT)
    label1.pack(pady = 10, padx = 10)
    label2.pack(pady = 10, padx = 10)
    label3.pack(pady = 10, padx = 10)
    button1 = tk.Button(self, text = "Addition Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(AdditionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button2 = tk.Button(self, text = "Subtraction Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(SubtractionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button3 = tk.Button(self, text = "Multiplication Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(MultiplicationPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button4 = tk.Button(self, text = "Division Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(DivisionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    label4 = tk.Label(self, text = "Select Difficulty", font = LARGE_FONT).pack()

    difficulty = tk.StringVar(value = dif_enum [0])
    def show_and_set_difficulty() :
    INDENT
        global current_difficulty
        current_difficulty = difficulty.get()
        print (1 + dif_enum.index(difficulty.get()), difficulty.get())
    DEDENT
    for dif in dif_enum :
    INDENT
        tk.Radiobutton(self, text = dif, value = dif, variable = difficulty, command = show_and_set_difficulty).pack()
    DEDENT
    quit_button = tk.Button(self, text = 'Quit', command = quit, font = MEDIUM_FONT).pack(fill = X, side = BOTTOM)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36300850_36304025_19_42
36300850_36304025_87_116
Title: "Py 3: tkinter frames coding inside or outside of frame classes" 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    tk.Tk.wm_title(self, "Mathematic Equation program")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, AdditionPage, SubtractionPage, MultiplicationPage, DivisionPage) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------

def __init__(self, parent, controller, equal_type) :
INDENT
    tk.Frame.__init__(self, parent)
    tk.Label(self, text = "Mathmatics Problems Quiz", font = LARGE_FONT).pack(pady = 10, padx = 10)
    tk.Label(self, text = "Mathematic Equation program", font = MEDIUM_FONT).pack(pady = 10, padx = 10)
    tk.Label(self, text = "You have Selected {} as The Unit".format(equal_type), font = SMALL_FONT).pack(pady = 10, padx = 10)
    tk.Button(self, text = "Reselect Unit", font = MEDIUM_FONT, command = lambda : controller.show_frame(StartPage)).pack(fill = X)
    Label(self, text = "").pack()
    Label(self, text = "").pack()

    self.submit_counter = 0
    self.correct_counter = 0
    self.equation_strvar = tk.StringVar(value = '')
    Label(self, textvariable = self.equation_strvar, font = MEDIUM_FONT).pack()
    Label(self, text = "").pack()
    self.answer_strvar = StringVar()
    Entry(self, textvariable = self.answer_strvar, font = MEDIUM_FONT,).pack(fill = X)
    Label(self, text = "").pack()
    Label(self, text = "").pack()
    tk.Button(self, text = "Submit Answer", font = MEDIUM_FONT, command = self.submit).pack(fill = X)
    tk.Button(self, text = 'Quit', command = quit, font = MEDIUM_FONT,).pack(fill = X, side = BOTTOM)
    self.update_equation()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36300850_36304025_19_42
36300850_36446270_6_27
Title: "Py 3: tkinter frames coding inside or outside of frame classes" 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    tk.Tk.wm_title(self, "Mathematic Equation program")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (StartPage, AdditionPage, SubtractionPage, MultiplicationPage, DivisionPage) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    Frame.__init__(self, master)

    self.msg2show = StringVar()
    self.text_input = StringVar()

    Label(self, text = 'If you click the button, the text in the entry widget will show above.').pack()

    Label(self, textvariable = self.msg2show).pack()

    Entry(self, textvariable = self.text_input).pack()

    Button(self, text = 'Set message', command = self.set_msg).pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36300850_36304025_52_85
36300850_36304025_87_116
Title: "Py 3: tkinter frames coding inside or outside of frame classes" 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label1 = tk.Label(self, text = "Mathmatics Problems Quiz", font = LARGE_FONT)
    label2 = tk.Label(self, text = "Mathematic Equation program", font = MEDIUM_FONT)
    label3 = tk.Label(self, text = "Select Your Operation and Difficulty Level", font = SMALL_FONT)
    label1.pack(pady = 10, padx = 10)
    label2.pack(pady = 10, padx = 10)
    label3.pack(pady = 10, padx = 10)
    button1 = tk.Button(self, text = "Addition Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(AdditionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button2 = tk.Button(self, text = "Subtraction Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(SubtractionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button3 = tk.Button(self, text = "Multiplication Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(MultiplicationPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button4 = tk.Button(self, text = "Division Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(DivisionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    label4 = tk.Label(self, text = "Select Difficulty", font = LARGE_FONT).pack()

    difficulty = tk.StringVar(value = dif_enum [0])
    def show_and_set_difficulty() :
    INDENT
        global current_difficulty
        current_difficulty = difficulty.get()
        print (1 + dif_enum.index(difficulty.get()), difficulty.get())
    DEDENT
    for dif in dif_enum :
    INDENT
        tk.Radiobutton(self, text = dif, value = dif, variable = difficulty, command = show_and_set_difficulty).pack()
    DEDENT
    quit_button = tk.Button(self, text = 'Quit', command = quit, font = MEDIUM_FONT).pack(fill = X, side = BOTTOM)

DEDENT
----------------------------------------

def __init__(self, parent, controller, equal_type) :
INDENT
    tk.Frame.__init__(self, parent)
    tk.Label(self, text = "Mathmatics Problems Quiz", font = LARGE_FONT).pack(pady = 10, padx = 10)
    tk.Label(self, text = "Mathematic Equation program", font = MEDIUM_FONT).pack(pady = 10, padx = 10)
    tk.Label(self, text = "You have Selected {} as The Unit".format(equal_type), font = SMALL_FONT).pack(pady = 10, padx = 10)
    tk.Button(self, text = "Reselect Unit", font = MEDIUM_FONT, command = lambda : controller.show_frame(StartPage)).pack(fill = X)
    Label(self, text = "").pack()
    Label(self, text = "").pack()

    self.submit_counter = 0
    self.correct_counter = 0
    self.equation_strvar = tk.StringVar(value = '')
    Label(self, textvariable = self.equation_strvar, font = MEDIUM_FONT).pack()
    Label(self, text = "").pack()
    self.answer_strvar = StringVar()
    Entry(self, textvariable = self.answer_strvar, font = MEDIUM_FONT,).pack(fill = X)
    Label(self, text = "").pack()
    Label(self, text = "").pack()
    tk.Button(self, text = "Submit Answer", font = MEDIUM_FONT, command = self.submit).pack(fill = X)
    tk.Button(self, text = 'Quit', command = quit, font = MEDIUM_FONT,).pack(fill = X, side = BOTTOM)
    self.update_equation()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36300850_36304025_52_85
36300850_36446270_6_27
Title: "Py 3: tkinter frames coding inside or outside of frame classes" 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label1 = tk.Label(self, text = "Mathmatics Problems Quiz", font = LARGE_FONT)
    label2 = tk.Label(self, text = "Mathematic Equation program", font = MEDIUM_FONT)
    label3 = tk.Label(self, text = "Select Your Operation and Difficulty Level", font = SMALL_FONT)
    label1.pack(pady = 10, padx = 10)
    label2.pack(pady = 10, padx = 10)
    label3.pack(pady = 10, padx = 10)
    button1 = tk.Button(self, text = "Addition Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(AdditionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button2 = tk.Button(self, text = "Subtraction Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(SubtractionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button3 = tk.Button(self, text = "Multiplication Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(MultiplicationPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    button4 = tk.Button(self, text = "Division Equations", font = MEDIUM_FONT, command = lambda : controller.show_frame(DivisionPage)).pack(fill = X)
    label = Label(self, text = "").pack()
    label4 = tk.Label(self, text = "Select Difficulty", font = LARGE_FONT).pack()

    difficulty = tk.StringVar(value = dif_enum [0])
    def show_and_set_difficulty() :
    INDENT
        global current_difficulty
        current_difficulty = difficulty.get()
        print (1 + dif_enum.index(difficulty.get()), difficulty.get())
    DEDENT
    for dif in dif_enum :
    INDENT
        tk.Radiobutton(self, text = dif, value = dif, variable = difficulty, command = show_and_set_difficulty).pack()
    DEDENT
    quit_button = tk.Button(self, text = 'Quit', command = quit, font = MEDIUM_FONT).pack(fill = X, side = BOTTOM)

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    Frame.__init__(self, master)

    self.msg2show = StringVar()
    self.text_input = StringVar()

    Label(self, text = 'If you click the button, the text in the entry widget will show above.').pack()

    Label(self, textvariable = self.msg2show).pack()

    Entry(self, textvariable = self.text_input).pack()

    Button(self, text = 'Set message', command = self.set_msg).pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36300850_36304025_87_116
36300850_36446270_6_27
Title: "Py 3: tkinter frames coding inside or outside of frame classes" 
----------------------------------------

def __init__(self, parent, controller, equal_type) :
INDENT
    tk.Frame.__init__(self, parent)
    tk.Label(self, text = "Mathmatics Problems Quiz", font = LARGE_FONT).pack(pady = 10, padx = 10)
    tk.Label(self, text = "Mathematic Equation program", font = MEDIUM_FONT).pack(pady = 10, padx = 10)
    tk.Label(self, text = "You have Selected {} as The Unit".format(equal_type), font = SMALL_FONT).pack(pady = 10, padx = 10)
    tk.Button(self, text = "Reselect Unit", font = MEDIUM_FONT, command = lambda : controller.show_frame(StartPage)).pack(fill = X)
    Label(self, text = "").pack()
    Label(self, text = "").pack()

    self.submit_counter = 0
    self.correct_counter = 0
    self.equation_strvar = tk.StringVar(value = '')
    Label(self, textvariable = self.equation_strvar, font = MEDIUM_FONT).pack()
    Label(self, text = "").pack()
    self.answer_strvar = StringVar()
    Entry(self, textvariable = self.answer_strvar, font = MEDIUM_FONT,).pack(fill = X)
    Label(self, text = "").pack()
    Label(self, text = "").pack()
    tk.Button(self, text = "Submit Answer", font = MEDIUM_FONT, command = self.submit).pack(fill = X)
    tk.Button(self, text = 'Quit', command = quit, font = MEDIUM_FONT,).pack(fill = X, side = BOTTOM)
    self.update_equation()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    Frame.__init__(self, master)

    self.msg2show = StringVar()
    self.text_input = StringVar()

    Label(self, text = 'If you click the button, the text in the entry widget will show above.').pack()

    Label(self, textvariable = self.msg2show).pack()

    Entry(self, textvariable = self.text_input).pack()

    Button(self, text = 'Set message', command = self.set_msg).pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36333683_36334191_1_13
36333683_36334997_1_12
Title: Carry numbers in list 
----------------------------------------

def increment(nums) :
INDENT
    if not nums :
    INDENT
        return []
    DEDENT
    if nums [- 1] < 61 :
    INDENT

        nums [- 1] += 1
        return nums
    DEDENT
    else :
    INDENT
        return increment(nums [: - 1]) + [0]
    DEDENT
DEDENT
----------------------------------------

def increment(nums) :
INDENT
    nums [- 1] += 1
    for i in range(len(nums)) :
    INDENT
        if nums [- i - 1] == 62 :
        INDENT
            nums [- i - 1] = 0
            nums [- i - 2] += 1
        DEDENT
    DEDENT
    if nums [0] == 62 :
    INDENT
        nums [:] = [0] * len(nums)
    DEDENT
    return nums
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36377688_36378205_43_72
36377688_36378205_5_29
Title: changing frames based on radio button answer 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    lbl1 = tk.Label(self, text = "for page 2", font = ("Helvetica", 12, "bold"))
    lbl1.grid(row = 1, sticky = "W")
    lbl2 = tk.Label(self, text = "for page 3", font = ("Helvetica", 12, "bold"))
    lbl2.grid(row = 1, column = 1, sticky = "W")
    btn1 = tk.Button(self, text = "next page", font = ('MS', 24, 'bold'))
    btn1.grid(row = 3, column = 0, columnspan = 1)

    self.var1 = tk.BooleanVar()

    rButton1 = tk.Radiobutton(self, variable = self.var1, value = True,
        command = self.switch_pages)
    rButton1.grid(row = 2, sticky = "W")
    rButton2 = tk.Radiobutton(self, variable = self.var1, value = False,
        command = self.switch_pages)
    rButton2.grid(row = 2, column = 1, sticky = "W")
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)

    self.frames = {}

    for F in (Page1, Page2, Page3) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "w")
    DEDENT
    self.show_frame(Page1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36379952_36379981_1_13
36379952_36379993_1_14
Title: Python: Unexpected print values from within a simple function 
----------------------------------------

def chair() :
INDENT
    correct = 1
    a = [1, 2, 3]
    random.shuffle(a)
    if a [0] == 3 :
    INDENT
        correct = chair()
    DEDENT
    return correct

DEDENT
----------------------------------------

def chair() :
INDENT
    correct = 1
    a = [1, 2, 3]
    random.shuffle(a)
    if a [0] == 3 :
    INDENT
        correct = 0
        chair()
    DEDENT
    else :
    INDENT
        print correct
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36399627_36402501_20_29
36399627_36402501_32_47
Title: wxPython - change panel by button 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    tekst = 'Panel 2'
    font = wx.Font(18, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    wx.StaticText(self, - 1, tekst, (300, 10)).SetFont(font)
    self.btn = wx.Button(self, - 1, "Change panel", (345, 100))

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, 'Program')
    sizer = wx.BoxSizer()
    self.SetSizer(sizer)
    self.panel_one = Glowne(self)
    sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.panel_one.btn.Bind(wx.EVT_BUTTON, self.show_panel_two)
    self.panel_two = Glowne1(self)
    sizer.Add(self.panel_two, 1, wx.EXPAND)
    self.panel_two.btn.Bind(wx.EVT_BUTTON, self.show_panel_one)
    self.panel_two.Hide()
    self.SetSize((800, 600))
    self.Centre()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36399627_36402501_20_29
36399627_36402501_6_17
Title: wxPython - change panel by button 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    tekst = 'Panel 2'
    font = wx.Font(18, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    wx.StaticText(self, - 1, tekst, (300, 10)).SetFont(font)
    self.btn = wx.Button(self, - 1, "Change panel", (345, 100))

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    self.SetSize((800, 600))
    tekst = 'HELLO'
    font = wx.Font(18, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    wx.StaticText(self, - 1, tekst, (300, 10)).SetFont(font)
    self.btn = wx.Button(self, - 1, "Change panel", (345, 100))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36399627_36402501_32_47
36399627_36402501_6_17
Title: wxPython - change panel by button 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, 'Program')
    sizer = wx.BoxSizer()
    self.SetSizer(sizer)
    self.panel_one = Glowne(self)
    sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.panel_one.btn.Bind(wx.EVT_BUTTON, self.show_panel_two)
    self.panel_two = Glowne1(self)
    sizer.Add(self.panel_two, 1, wx.EXPAND)
    self.panel_two.btn.Bind(wx.EVT_BUTTON, self.show_panel_one)
    self.panel_two.Hide()
    self.SetSize((800, 600))
    self.Centre()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    self.SetSize((800, 600))
    tekst = 'HELLO'
    font = wx.Font(18, wx.DEFAULT, wx.NORMAL, wx.NORMAL)
    wx.StaticText(self, - 1, tekst, (300, 10)).SetFont(font)
    self.btn = wx.Button(self, - 1, "Change panel", (345, 100))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36405438_36411865_5_14
36405438_36413411_5_14
Title: how to check if RLock in python 3 is acquired by any thread 
----------------------------------------

def main() :
INDENT
    lock = Test().lock
    print('The RLock was', end = '')
    if lock.acquire(False) :
    INDENT
        lock.release()
    DEDENT
    else :
    INDENT
        print(' not', end = '')
    DEDENT
    print (' acquired by the main thread.')
DEDENT
----------------------------------------

def main() :
INDENT
    lock = CustomRLock()
    if random.randrange(2) :
    INDENT
        lock.acquire()
    DEDENT
    print('Lock was', end = '')
    if not lock.acquired :
    INDENT
        print(' not', end = '')
    DEDENT
    print (' acquired.')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36435261_36435690_1_10
36435261_36489556_37_63
Title: Mondrian Art Program Python 
----------------------------------------

def mondrian(t, random_w, random_h) :
INDENT
    piet.begin_fill()
    for number_r in range(1) :
    INDENT
        for box in range(2) :
        INDENT
            piet.fillcolor(random.choice(('red', 'blue', 'yellow')))
            t.left(90)
            t.forward(random_w)
            t.left(90)
            t.forward(random_h)
        DEDENT
    DEDENT
    piet.end_fill()
DEDENT
----------------------------------------

def mondrian(piet, bounds) :
INDENT
    if bounds.width < bounds.height :
    INDENT
        dimension = 'height'
        random_dimension = random.randint(getattr(bounds, dimension) / / 5, 2 * getattr(bounds, dimension) / / 3)
        bounds_yin = Bounds(bounds.x, y = bounds.y + random_dimension, width = bounds.width, height = bounds.height - random_dimension)
        bounds_yang = Bounds(bounds.x, bounds.y, bounds.width, random_dimension)
    DEDENT
    else :
    INDENT
        dimension = 'width'
        random_dimension = random.randint(getattr(bounds, dimension) / / 5, 2 * getattr(bounds, dimension) / / 3)
        bounds_yin = Bounds(bounds.x, bounds.y, random_dimension, bounds.height)
        bounds_yang = Bounds(x = bounds.x + random_dimension, y = bounds.y, width = bounds.width - random_dimension, height = bounds.height)
    DEDENT
    if getattr(bounds_yin, dimension) > getattr(bounds_yang, dimension) :
    INDENT
        bounds_paint, bounds_divide = bounds_yang, bounds_yin
    DEDENT
    else :
    INDENT
        bounds_paint, bounds_divide = bounds_yin, bounds_yang
    DEDENT
    fill_rectangle(piet, bounds_paint)
    if getattr(bounds_divide, dimension) < MINIMUM_DIVISIBLE_PORTION * getattr(PICTURE_BOUNDS, dimension) :
    INDENT
        fill_rectangle(piet, bounds_divide)
    DEDENT
    else :
    INDENT
        mondrian(piet, bounds_divide)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36435261_36435797_15_24
36435261_36489556_37_63
Title: Mondrian Art Program Python 
----------------------------------------

def mondrian(t, random_w, random_h) :
INDENT
    piet.fillcolor(random.choice(('red', 'blue', 'yellow')))
    piet.begin_fill()
    for box in range(2) :
    INDENT
        t.left(90)
        t.forward(random_w)
        t.left(90)
        t.forward(random_h)
    DEDENT
    piet.end_fill()
DEDENT
----------------------------------------

def mondrian(piet, bounds) :
INDENT
    if bounds.width < bounds.height :
    INDENT
        dimension = 'height'
        random_dimension = random.randint(getattr(bounds, dimension) / / 5, 2 * getattr(bounds, dimension) / / 3)
        bounds_yin = Bounds(bounds.x, y = bounds.y + random_dimension, width = bounds.width, height = bounds.height - random_dimension)
        bounds_yang = Bounds(bounds.x, bounds.y, bounds.width, random_dimension)
    DEDENT
    else :
    INDENT
        dimension = 'width'
        random_dimension = random.randint(getattr(bounds, dimension) / / 5, 2 * getattr(bounds, dimension) / / 3)
        bounds_yin = Bounds(bounds.x, bounds.y, random_dimension, bounds.height)
        bounds_yang = Bounds(x = bounds.x + random_dimension, y = bounds.y, width = bounds.width - random_dimension, height = bounds.height)
    DEDENT
    if getattr(bounds_yin, dimension) > getattr(bounds_yang, dimension) :
    INDENT
        bounds_paint, bounds_divide = bounds_yang, bounds_yin
    DEDENT
    else :
    INDENT
        bounds_paint, bounds_divide = bounds_yin, bounds_yang
    DEDENT
    fill_rectangle(piet, bounds_paint)
    if getattr(bounds_divide, dimension) < MINIMUM_DIVISIBLE_PORTION * getattr(PICTURE_BOUNDS, dimension) :
    INDENT
        fill_rectangle(piet, bounds_divide)
    DEDENT
    else :
    INDENT
        mondrian(piet, bounds_divide)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36440618_36440986_17_43
36440618_36441163_9_22
Title: How to append a list selectively? 
----------------------------------------

def on_message(client, userdata, msg) :
INDENT
    payloadjson = json.loads(msg.payload.decode('utf-8'))
    line = payloadjson ["value"].split(',')
    epc = line [1]
    datetime = payloadjson ['datetime']

    datetime = dt.datetime.strptime(datetime, '%Y-%m-%d %H:%M:%S')
    payload = {'datetime' : datetime, 'epc' : epc [11 : 35]}

    if payload ['epc'] not in seen_ids :
    INDENT
        should_add = True
        if len(testlist) > 0 :
        INDENT
            last_payload = testlist [- 1]
            diff = payload ['datetime'] - last_payload ['datetime']
            if diff < five_minutes :
            INDENT
                should_add = False
            DEDENT
        DEDENT
        if should_add :
        INDENT
            seen_ids.add(payload ['epc'])
            testlist.append(payload)
            print ('Content of testlist now:')
            for each in testlist :
            INDENT
                print (each)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def on_message(client, userdata, msg) :
INDENT
    payloadjson = json.loads(msg.payload.decode('utf-8'))
    line = payloadjson ["value"].split(',')
    epc = line [1]

    when = dt.datetime.strptime(payloadjson ['datetime'], '%Y-%m-%d %H:%M:%S')
    if epc not in testlist or when - testlist [epc] > TIMELIMIT :
    INDENT
        testlist [epc] = when
        for epc, when in teslist.items() :
        INDENT
            print (epc, when)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36460141_36460423_1_12
36460141_36464575_1_7
Title: Python - Ask for input multiple times til a certain input disables it 
----------------------------------------

def list_maker() :
INDENT
    result = []
    def main() :
    INDENT
        element = input("Input an element: ")
        if element == "Stop" :
        INDENT
            print (result)
        DEDENT
        else :
        INDENT
            result.append(element)
            main()
        DEDENT
    DEDENT
    main()
DEDENT
----------------------------------------

def list_maker(result) :
INDENT
    element = input("Input an element: ")
    while element ! = "Stop" :
    INDENT
        result.append(int(element))
        element = input("Input an element: ")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36465969_36466235_4_12
36465969_36466912_12_25
Title: Switching between frames in python with functions 
----------------------------------------

def __init__(self, parent1) :
INDENT
    self.parent = parent1
    self.go = Frame(self.parent, width = 500, height = 450)
    self.go.grid(row = 0, column = 0)
    self.go.grid_propagate(0)
    menuButton = Button(self.go, text = "Continue", command = self.menuScreen)
    menuButton.grid(row = 1, column = 0)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    self.parent = parent
    self.parent.title("Traveller Details")
    self.parent.geometry("500x450+0+0")
    self.go_frame = tk.Frame(self.parent, width = 500, height = 450, bg = 'light blue')
    self.goto_menu_frame_button = tk.Button(self.go_frame, text = "Continue", command = self.menu_screen)
    self.menu_frame = tk.Frame(self.parent, width = 500, height = 450, bg = 'light steel blue')
    self.goto_go_frame_button = tk.Button(self.menu_frame, text = "Return", command = self.go_screen)
    self.current_frame = None
    self.go_screen()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36479510_36480317_24_32
36479510_36480317_60_69
Title: Layout images in form of a number 
----------------------------------------

def get_image() :
INDENT
    fn = cbook.get_sample_data("ada.png")
    face_img = Image.open(fn).convert('RGBA')
    face_img = face_img.resize((30, 40), Image.ANTIALIAS)
    img = Image.new('RGBA', size = (36, 46), color = (255, 255, 255))
    img.paste(face_img, (3, 3))
    return img
DEDENT
----------------------------------------

def get_image() :
INDENT
    import matplotlib.cbook as cbook
    fn = cbook.get_sample_data("ada.png")
    face_img = Image.open(fn).convert('RGBA')
    face_img = face_img.resize((30, 40), Image.ANTIALIAS)
    img = Image.new('RGBA', size = (36, 46), color = (255, 255, 255))
    img.paste(face_img, (3, 3))
    return img
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36516279_36516445_1_15
36516279_36517613_1_19
Title: How to return elements with the highest occurrence in list? 
----------------------------------------

def mode(numlist) :
INDENT
    mylist = numlist
    dic = {}
    for num in mylist :
    INDENT
        if num in dic :
        INDENT
            dic [num] += 1
        DEDENT
        else :
        INDENT
            dic [num] = 1
        DEDENT
    DEDENT
    vals = max(dic.values())
    return [k for k, v in dic.items() if v == vals]

DEDENT
----------------------------------------

def mode(num_list) :
INDENT
    max_ocur = [(i, num_list.count(i)) for i in num_list]

    max_ocur = set(max_ocur)

    m = max(max_ocur, key = lambda x : x [1]) [1]

    modes = [i for i, ocur in max_ocur if ocur == m]
    modes.sort()
    return modes
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36517258_36525208_25_32
36517258_36658360_24_32
Title: Tkinter pack_forget() and pack() issue on key-release event 
----------------------------------------

def showLabel(self, event) :
INDENT
    global loop
    self.lbl.pack_forget()
    master.update_idletasks()
    time.sleep(2)
    loop += 1
    Demo(self.parent)
DEDENT
----------------------------------------

def showLabel(self, event) :
INDENT
    global loop
    self.lbl.pack_forget()
    self.parent.update()
    time.sleep(2)
    loop += 1
    Demo(self.parent)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36521374_36521952_4_26
36521374_36522113_6_20
Title: writing list of tuples within a dictionary to csv 
----------------------------------------

def writeCSV(path, filename, d) :
INDENT
    filename = os.path.join(path, filename)
    col_names = list(d.keys())
    header = []
    for name in col_names :
    INDENT
        header.append(name)
        header.append('id')
    DEDENT
    with open(filename, 'wb') as outfile :
    INDENT
        writer = csv.writer(outfile)
        writer.writerow(header)
        index = 0
        end = max([len(x) for x in d.values()])
        while index < end :
        INDENT
            line = []
            for name in col_names :
            INDENT
                try :
                INDENT
                    row_values = d [name] [index]
                DEDENT
                except IndexError :
                INDENT
                    row_values = [''] * len(col_names)
                DEDENT
                line.extend(row_values)
            DEDENT
            writer.writerow(line)
            index += 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def writeCSV(path, filename, d) :
INDENT
    def flatten(l) :
    INDENT
        return [t [i] for t in l for i in range(len(t))]
    DEDENT
    filename = os.path.join(path, filename)
    with open(filename, 'wb') as outfile :
    INDENT
        writer = csv.writer(outfile, delimiter = '~')
        keys = d.keys()
        writer.writerow(flatten(zip(keys, ['id'] * len(keys))))
        values = [d [key] for key in keys]
        writer.writerows(flatten(row) for row in izip_longest(* values, fillvalue = ('', '')))
        print "write file complete"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36523353_36524201_1_12
36523353_36524248_3_21
Title: Can I redefine the iterator variable in the body of a for-loop? 
----------------------------------------

def foobar() :
INDENT
    A = [1, 2, 3, 4, 5]
    B = [6, 7, 8, 9, 10]
    it = swapable_iterator(cycle(A))
    tmp = 0
    for item in it :
    INDENT
        print item, tmp
        if item == 5 and tmp > 10 :
        INDENT
            it.swap(cycle(B))
        DEDENT
        if tmp > 30 :
        INDENT
            return tmp
        DEDENT
        tmp += item
    DEDENT
DEDENT
----------------------------------------

def foobar() :
INDENT
    A = [1, 2, 3, 4, 5]
    B = [6, 7, 8, 9, 10]
    tmp = 0
    iter_A = cycle(A)
    iter_B = cycle(B)
    use_A = True
    while True :
    INDENT
        if use_A :
        INDENT
            item = next(iter_A)
        DEDENT
        else :
        INDENT
            item = next(iter_B)
        DEDENT
        print item, tmp
        if tmp > 10 :
        INDENT
            use_A = False
        DEDENT
        if tmp > 30 :
        INDENT
            return tmp
        DEDENT
        tmp += item
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36528428_36528728_3_26
36528428_36528816_1_15
Title: Why doesn't this writing to file in python work? 
----------------------------------------

def appendA(filename, crop, quantity) :
INDENT
    result = []
    exists = False
    with open(filename, 'r') as file_1 :
    INDENT
        lines = file_1.readlines()
    DEDENT
    for line in lines :
    INDENT
        if not crop in line :
        INDENT
            result.append(line)
        DEDENT
        else :
        INDENT
            exists = True
            result.append(line.strip('\n') + quantity + '\n')

        DEDENT
    DEDENT
    if not exists :
    INDENT
        with open(filename, 'a') as file_2 :
        INDENT
            file_2.write('\n' + crop + ' ' + quantity + ' ')
        DEDENT
    DEDENT
    else :
    INDENT
        tmp_file = filename + '.tmp'
        with open(tmp_file, 'w') as file_3 :
        INDENT
            file_3.write(result)
            remove(filename)
            move(tmp_file, filename)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def appendA() :
INDENT
    with open('alpha.txt', 'r') as file_1 :
    INDENT
        lines = []
        for line in file_1 :
        INDENT
            if crop in line :
            INDENT
                line = str(line.rstrip("\n") + quantity + "\n")
            DEDENT
            lines.append(line)

        DEDENT
        with open('alpha.txt', 'w') as file_3 :
        INDENT
            file_3.writelines(lines)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36528428_36528728_3_26
36528428_36529306_1_32
Title: Why doesn't this writing to file in python work? 
----------------------------------------

def appendA(filename, crop, quantity) :
INDENT
    result = []
    exists = False
    with open(filename, 'r') as file_1 :
    INDENT
        lines = file_1.readlines()
    DEDENT
    for line in lines :
    INDENT
        if not crop in line :
        INDENT
            result.append(line)
        DEDENT
        else :
        INDENT
            exists = True
            result.append(line.strip('\n') + quantity + '\n')

        DEDENT
    DEDENT
    if not exists :
    INDENT
        with open(filename, 'a') as file_2 :
        INDENT
            file_2.write('\n' + crop + ' ' + quantity + ' ')
        DEDENT
    DEDENT
    else :
    INDENT
        tmp_file = filename + '.tmp'
        with open(tmp_file, 'w') as file_3 :
        INDENT
            file_3.write(result)
            remove(filename)
            move(tmp_file, filename)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def appendA() :
INDENT
    with open('alpha.txt', 'r') as file_1 :
    INDENT
        lines = file_1.readlines()
        for line in lines :
        INDENT
            if crop in line :
            INDENT
                index = lines.index(line)
                line = str(line.replace("\n", "") + ' ' + quantity + '\n')
                lines [index] = line
            DEDENT
        DEDENT
        newlines = ''.join(lines)

        with open('alpha.txt', 'w') as file_3 :
        INDENT
            file_3.write(newlines)

        DEDENT
    DEDENT
    def appendB() :
    INDENT
        with open('alpha.txt', 'a') as file_2 :
        INDENT
            file_2.write("\n")
            file_2.write(crop + ' ')
            file_2.write(quantity + ' ')

        DEDENT
    DEDENT
    crop = input("Which crop? ")
    quantity = input("How many? ")
    with open('alpha.txt', 'a') as file_0 :
    INDENT
        if crop in open('alpha.txt').read() :
        INDENT
            appendA()
        DEDENT
        else :
        INDENT
            appendB()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36528428_36528816_16_21
36528428_36529306_18_24
Title: Why doesn't this writing to file in python work? 
----------------------------------------

def appendB() :
INDENT
    with open('alpha.txt', 'a') as file_2 :
    INDENT
        file_2.write('\n')
        file_2.write(crop + ' ')
        file_2.write(quantity + ' ')
    DEDENT
DEDENT
----------------------------------------

def appendB() :
INDENT
    with open('alpha.txt', 'a') as file_2 :
    INDENT
        file_2.write("\n")
        file_2.write(crop + ' ')
        file_2.write(quantity + ' ')

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36528428_36528816_1_15
36528428_36529306_1_32
Title: Why doesn't this writing to file in python work? 
----------------------------------------

def appendA() :
INDENT
    with open('alpha.txt', 'r') as file_1 :
    INDENT
        lines = []
        for line in file_1 :
        INDENT
            if crop in line :
            INDENT
                line = str(line.rstrip("\n") + quantity + "\n")
            DEDENT
            lines.append(line)

        DEDENT
        with open('alpha.txt', 'w') as file_3 :
        INDENT
            file_3.writelines(lines)

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def appendA() :
INDENT
    with open('alpha.txt', 'r') as file_1 :
    INDENT
        lines = file_1.readlines()
        for line in lines :
        INDENT
            if crop in line :
            INDENT
                index = lines.index(line)
                line = str(line.replace("\n", "") + ' ' + quantity + '\n')
                lines [index] = line
            DEDENT
        DEDENT
        newlines = ''.join(lines)

        with open('alpha.txt', 'w') as file_3 :
        INDENT
            file_3.write(newlines)

        DEDENT
    DEDENT
    def appendB() :
    INDENT
        with open('alpha.txt', 'a') as file_2 :
        INDENT
            file_2.write("\n")
            file_2.write(crop + ' ')
            file_2.write(quantity + ' ')

        DEDENT
    DEDENT
    crop = input("Which crop? ")
    quantity = input("How many? ")
    with open('alpha.txt', 'a') as file_0 :
    INDENT
        if crop in open('alpha.txt').read() :
        INDENT
            appendA()
        DEDENT
        else :
        INDENT
            appendB()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36539814_36539944_2_11
36539814_36540006_1_9
Title: Datetime module - ValueError try/except won't work python 3 
----------------------------------------

def get_stock_date(prompt) :
INDENT
    while True :
    INDENT
        d = input(prompt)
        try :
        INDENT
            d = datetime.datetime.strptime(d, "%m/%d/%Y")
        DEDENT
        except (ValueError, TypeError) :
        INDENT
            print ("Try again.")
        DEDENT
        else :
        INDENT
            return d
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_stock_date(prompt) :
INDENT
    try :
    INDENT
        stock_date = datetime.datetime.strptime(prompt, "%m/%d/%Y")
        return (stock_date)
    DEDENT
    except :
    INDENT
        print ("Try Again.")
        prompt = input("Enter the stock purchase date ==> ")
        get_stock_date(prompt)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36539814_36539944_2_11
36539814_36540014_3_9
Title: Datetime module - ValueError try/except won't work python 3 
----------------------------------------

def get_stock_date(prompt) :
INDENT
    while True :
    INDENT
        d = input(prompt)
        try :
        INDENT
            d = datetime.datetime.strptime(d, "%m/%d/%Y")
        DEDENT
        except (ValueError, TypeError) :
        INDENT
            print ("Try again.")
        DEDENT
        else :
        INDENT
            return d
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_stock_date(prompt) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            return datetime.datetime.strptime(input(prompt), "%m/%d/%Y")
        DEDENT
        except (ValueError, TypeError) :
        INDENT
            print ("Try again.")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36539814_36540006_1_9
36539814_36540014_3_9
Title: Datetime module - ValueError try/except won't work python 3 
----------------------------------------

def get_stock_date(prompt) :
INDENT
    try :
    INDENT
        stock_date = datetime.datetime.strptime(prompt, "%m/%d/%Y")
        return (stock_date)
    DEDENT
    except :
    INDENT
        print ("Try Again.")
        prompt = input("Enter the stock purchase date ==> ")
        get_stock_date(prompt)
    DEDENT
DEDENT
----------------------------------------

def get_stock_date(prompt) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            return datetime.datetime.strptime(input(prompt), "%m/%d/%Y")
        DEDENT
        except (ValueError, TypeError) :
        INDENT
            print ("Try again.")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36549460_36556526_33_47
36549460_36556526_7_22
Title: prevent the sub windows to open multiple times 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(MainFrame, self).__init__(* args, ** kwargs)
    self.SetInitialSize((800, 600))
    self.CreateStatusBar()
    menubar = wx.MenuBar()
    self.SetMenuBar(menubar)
    menu_file = wx.Menu()
    menu_file.Append(
        wx.ID_NEW, 'Show msg', 'Add a new message to message frame')
    menubar.Append(menu_file, '&File')
    self.Bind(wx.EVT_MENU, self.on_new, id = wx.ID_NEW)
    self.count = 1
    self.multi_message_frame = None
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(MultiMessageFrame, self).__init__(* args, ** kwargs)
    pane = self.GetContentsPane()
    text_ctrl = wx.TextCtrl(
        pane, style = wx.TE_READONLY | wx.TE_CENTRE | wx.TE_MULTILINE)
    text_ctrl.SetSizerProps(proportion = 1, expand = True)
    text_ctrl.SetBackgroundColour('White')
    self.text_ctrl = text_ctrl
    pane_btns = sized_controls.SizedPanel(pane)
    pane_btns.SetSizerType('horizontal')
    pane_btns.SetSizerProps(align = 'center')
    button_ok = wx.Button(pane_btns, wx.ID_OK)
    button_ok.Bind(wx.EVT_BUTTON, self.on_button_ok)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36631101_36631248_6_14
36631101_36641004_7_17
Title: "Global variable in python initliazing and terminating" 
----------------------------------------

def start_record() :
INDENT
    print ("Starting recording");
    reset_tmp()
    global filename
    filename = "vid/" + str(int(time.time()));
    global camera
    camera = picamera.PiCamera()
    camera.start_recording(filename + ".h264");
DEDENT
----------------------------------------

def start_record(resolution = (1920, 1080)) :
INDENT
    print ("Starting recording")
    camera = picamera.PiCamera()
    camera.resolution = resolution
    reset_tmp()
    filename = os.path.join('vid', '{}.h264'.format(int(time.time())))
    camera.start_recording(filename)
    return camera, filename

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36660129_36660255_1_21
36660129_36660264_1_19
Title: 1-D array into a 2-D array results in wrong array values 
----------------------------------------

def makeTwoArr(array, height, width) :
INDENT
    print (array)
    newArray = [[0 for x in range(width)] for x in range(height)]
    print (newArray)
    row = 0
    col = 0

    for location in range(0, len(array)) :
    INDENT
        print ("row: ", row, " col: ", col);
        print (location)
        newArray [row] [col] = array [location]
        col += 1
        if col == width :
        INDENT
            row += 1
            col = 0
        DEDENT
        print ("In loop...", newArray)
    DEDENT
    print ("Before return...", newArray)
    return newArray
DEDENT
----------------------------------------

def makeTwoArr(array, height, width) :
INDENT
    print (array)
    newArray = []
    for i in range(height) :
    INDENT
        newArray.append([0] * width)
    DEDENT
    location = 0
    print (newArray)
    for row in range(height) :
    INDENT
        for col in range(width) :
        INDENT
            print ("row: ", row, " col: ", col);
            print (location)
            newArray [col] [row] = array [location]
            print (newArray)
            location += 1
            print ("In loop...", newArray)
        DEDENT
    DEDENT
    print ("Before return...", newArray)
    return newArray
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36666313_36675064_58_70
36666313_37444258_17_28
Title: "How can I change the datetime in my Python Atom-class or create a setter for it?" 
----------------------------------------

def main() :
INDENT
    case = SimulationCase()
    print (case.currentDateTime)
    print (case.incrementTime)
    print (case.endDateTime)
    a = datetime.time(2, 0, 0)
    case.incrementTime = a
    print (case.incrementTime)
DEDENT
----------------------------------------

def main() :
INDENT
    case = SimulationCase()
    print (case.currentDateTime)
    a = datetime.time(1, 0, 0)
    print (a)
    case.incrementTime = a

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36681067_36681117_1_9
36681067_36681138_1_8
Title: My code isnt recognising a function? 
----------------------------------------

def main() :
INDENT
    print ("1 = Add")
    print ("2 = Subtract")
    print ("3 = Times")
    print ("4 = Divide")
    print ("5 = Quit program")
    calc = int(input("enter number of choise: "))
DEDENT
----------------------------------------

def main() :
INDENT
    print ("1 = Add")
    print ("2 = Subtract")
    print ("3 = Times")
    print ("4 = Divide")
    print ("5 = Quit program")
    calc = int(input("enter number of choise: "))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36684319_36684675_5_22
36684319_36693030_14_18
Title: Decorator for a class method that caches return value after first access 
----------------------------------------

def __get__(self, obj, typ) :
INDENT
    name = self.name
    while True :
    INDENT
        try :
        INDENT
            return getattr(obj, name)
        DEDENT
        except AttributeError :
        INDENT
            get_the_value = self.get_the_value
            try :
            INDENT

                value = getattr(obj, get_the_value)()
            DEDENT
            except AttributeError :
            INDENT

                value = get_the_value()
            DEDENT
            setattr(obj, name, value)
            continue
        DEDENT
        break
    DEDENT
DEDENT
----------------------------------------

def __get__(self, instance, type = None) :
INDENT
    if instance is None :
    INDENT
        return self
    DEDENT
    res = instance.__dict__ [self.name] = self.func(instance)
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36711673_36711879_1_15
36711673_36712033_4_30
Title: What is wrong with this alternative bitwise operator function? 
----------------------------------------

def bitwise_or(num1, num2) :
INDENT
    new_num1 = list(num1 [2 :])
    new_num2 = list(num2 [2 :])
    if len(num1) > len(num2) :
    INDENT
        new_num2 [: 0] = '0' * (len(num1) - len(num2))
    DEDENT
    elif len(num1) < len(num2) :
    INDENT
        new_num1 [: 0] = '0' * (len(num2) - len(num1))
    DEDENT
    new_num = []
    for c1, c2 in zip(new_num1, new_num2) :
    INDENT
        if c1 == "1" or c2 == "1" :
        INDENT
            new_num.append("1")
        DEDENT
        else :
        INDENT
            new_num.append(c1)
        DEDENT
    DEDENT
    return '0b' + ''.join(new_num)
DEDENT
----------------------------------------

def bitwise_or(num1, num2) :
INDENT
    new_num1 = []
    new_num2 = []
    new_num = []
    for c in num1 [2 :] :
    INDENT
        new_num1.append(c)
    DEDENT
    for c in num2 [2 :] :
    INDENT
        new_num2.append(c)
    DEDENT
    if len(num1) ! = len(num2) :
    INDENT
        if len(num1) > len(num2) :
        INDENT
            diff1 = ["0"] * (len(num1) - len(num2))
            new_num2 = diff1 + new_num2
        DEDENT
        if len(num1) < len(num2) :
        INDENT
            diff1 = ["0"] * (len(num2) - len(num1))
            new_num1 = diff1 + new_num1
        DEDENT
    DEDENT
    for i in range(len(new_num1)) :
    INDENT
        if new_num1 [i] == "1" or new_num2 [i] == "1" :
        INDENT
            new_num.append("1")
        DEDENT
        else :
        INDENT
            new_num.append(new_num1 [i])
        DEDENT
    DEDENT
    final = "".join(new_num)
    return final

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36726767_36726912_4_27
36726767_36726970_4_22
Title: Count the number of times a letter appears in a text file in python 
----------------------------------------

def count_letters(textfile, case_sensitive = False) :
INDENT
    with open(textfile, 'r') as f :
    INDENT
        original_text = f.read()
        if case_sensitive :
        INDENT

            text = original_text
        DEDENT
        else :
        INDENT

            text = original_text.lower()
        DEDENT
        p = dict()
        for i in text :
        INDENT
            if i in p.keys() :
            INDENT
                p [i] += 1
            DEDENT
            elif i.isalpha() :
            INDENT
                p [i] = 1;
            DEDENT
        DEDENT
        keys = p.keys()
        for k in keys :
        INDENT
            print str(k) + " " + str(p [k])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def count_letters(text_file, case_sensitive = False) :
INDENT
    with open(text_file, 'r') as f :
    INDENT
        original_text = f.read()
    DEDENT
    if case_sensitive :
    INDENT
        alphabet = string.ascii_letters
        text = original_text
    DEDENT
    else :
    INDENT
        alphabet = string.ascii_lowercase
        text = original_text.lower()
        alphabet_set = set(alphabet)
        counts = collections.Counter(c for c in text if c in alphabet_set)
    DEDENT
    for letter in alphabet :
    INDENT
        print (letter, counts [letter])
    DEDENT
    print ("total:", sum(counts.values()))
    return counts
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36729451_36780238_115_122
36729451_36780238_6_14
Title: How can I stop a long-running function when it is called multiple times? 
----------------------------------------

def __init__(self, func, args = tuple(), kwargs = {}) :
INDENT
    self.func = func
    self.args = args
    self.kwargs = kwargs
    self.thread = threading.Thread(target = self.run, daemon = True)
    self.thread.start()
    self.output = None
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.oneShots = []
    self.timers = []
    self.oldOneShots = []
    self.latest = None
    self.cleaning = False
    self._startCleaner()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36729451_36780238_115_122
36729451_36780238_84_93
Title: How can I stop a long-running function when it is called multiple times? 
----------------------------------------

def __init__(self, func, args = tuple(), kwargs = {}) :
INDENT
    self.func = func
    self.args = args
    self.kwargs = kwargs
    self.thread = threading.Thread(target = self.run, daemon = True)
    self.thread.start()
    self.output = None
DEDENT
----------------------------------------

def __init__(self, delay, func, args = tuple(), kwargs = {}) :
INDENT
    self.delay = delay
    self.func = func
    self.loop = True
    self.args = args
    self.kwargs = kwargs
    self.thread = threading.Thread(target = self.run, daemon = True)
    self.thread.start()
    self.output = None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36729451_36780238_6_14
36729451_36780238_84_93
Title: How can I stop a long-running function when it is called multiple times? 
----------------------------------------

def __init__(self) :
INDENT
    self.oneShots = []
    self.timers = []
    self.oldOneShots = []
    self.latest = None
    self.cleaning = False
    self._startCleaner()
DEDENT
----------------------------------------

def __init__(self, delay, func, args = tuple(), kwargs = {}) :
INDENT
    self.delay = delay
    self.func = func
    self.loop = True
    self.args = args
    self.kwargs = kwargs
    self.thread = threading.Thread(target = self.run, daemon = True)
    self.thread.start()
    self.output = None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36756936_36757093_15_21
36756936_36757093_1_10
Title: Re-writing function recursively 
----------------------------------------

def hollowSquare(height, symb, count) :
INDENT
    innerSquare = height - 2
    print ('*' * height)
    for i in range(innerSquare) :
    INDENT
        print ('*' + ' ' * innerSquare + '*')
    DEDENT
    print ('*' * height)
DEDENT
----------------------------------------

def hollowSquare(height, symb, count = 0) :
INDENT
    if count < height - 1 :
    INDENT
        if not count :
        INDENT
            print (symb * height)
        DEDENT
        else :
        INDENT
            print (symb + ' ' * (height - 2) + symb)
        DEDENT
        hollowSquare(height, symb, count + 1)
    DEDENT
    else :
    INDENT
        print (symb * height)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36795430_36796775_17_23
36795430_36798238_24_31
Title: Problems with outputing console to GUI in tkinter 
----------------------------------------

def start(self) :
INDENT
    for i in range(1, 1000) :
    INDENT
        self.write(str(i) + '\n')
        print (i)
        time.sleep(2)

    DEDENT
DEDENT
----------------------------------------

def start(self) :
INDENT
    if self.count < 1000 :
    INDENT
        self.write(str(self.count) + '\n')
        print (self.count)
        self.count += 1
        self.after(2000, self.start)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36795430_36796775_6_16
36795430_36798238_6_23
Title: Problems with outputing console to GUI in tkinter 
----------------------------------------

def __init__(self) :
INDENT
    tk.Frame.__init__(self)
    self.doIt = tk.Button(self, text = "Start", command = self.start, background = 'black', fg = 'white')
    self.doIt.pack()
    self.output = tk.Text(self, width = 100, height = 15, background = 'black', fg = 'white')
    self.output.pack()
    self.configure(background = 'black')
    self.pack()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    tk.Frame.__init__(self)
    self.doIt = tk.Button(self, text = "Start", command = self.start, background = 'black', fg = 'white')
    self.doIt.pack()
    self.output = tk.Text(self, width = 100, height = 15, background = 'black', fg = 'white')
    self.output.pack(side = tk.LEFT)
    self.scrollbar = tk.Scrollbar(self, orient = "vertical", command = self.output.yview)
    self.scrollbar.pack(side = tk.RIGHT, fill = "y")
    self.output ['yscrollcommand'] = self.scrollbar.set
    self.count = 1
    self.configure(background = 'black')
    self.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36801303_36814405_5_12
36801303_36815099_3_10
Title: "Python 3.5 how to remove the brackets and quotes from an element when printing or sending the value to a function?" 
----------------------------------------

def getTID() :
INDENT
    with open('TID.csv') as csvTID :
    INDENT
        readCSV = csv.reader(csvTID, delimiter = '\n')
        for row in readCSV :
        INDENT
            stockList.append((row [0]))

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def getTID(file = 'TID.csv', delim = '\n') :
INDENT
    result = []
    with open(file) as csvTID :
    INDENT
        readCSV = csv.reader(csvTID, delimiter = delim)
        for row in readCSV :
        INDENT
            result.append(row [0])
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36801677_36801967_10_16
36801677_36802034_5_15
Title: 4 Digit Guessing Game Python 
----------------------------------------

def evaluate(self) :
INDENT
    correct = 0
    for n in range(4) :
    INDENT
        if self.player_guess [n] == self.real_ans [n] :
        INDENT
            correct += 1
        DEDENT
    DEDENT
    return correct
DEDENT
----------------------------------------

def evaluate(self, correct) :
INDENT
    for n in range(4) :
    INDENT
        if self.player_guess [n] == real_ans_str [n] :
        INDENT
            correct += 1
        DEDENT
        else :
        INDENT
            print (str(correct), " was correct")
            correct = 0
            break
        DEDENT
    DEDENT
    if correct == 4 :
    INDENT
        print ("You guessed it! ")
        guessing = False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36811197_36812982_18_26
36811197_36814366_10_23
Title: Button not working till current loop ends in python 
----------------------------------------

def xval(self) :
INDENT
    if self.x == "False" :
    INDENT
        print "x=false %d=counter value" % self.ctr
        self.ctr += 1
        if self.ctr < 9 :
        INDENT

            root.after(1000, self.xval)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def xval(* args) :
INDENT
    try :
    INDENT
        for i in range(0, 9) :
        INDENT
            global x
            print x.get()
            if x.get() == 'false' :
            INDENT
                print "x=false %d time" % i
                time.sleep(1)
            DEDENT
            else :
            INDENT
                print "waiting"
            DEDENT
            root.update()
        DEDENT
    DEDENT
    except :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36820077_36820112_2_10
36820077_36820176_1_22
Title: How to ask user for a series of number and return the sum of all numbers excluding the max number? 
----------------------------------------

def excludeMax() :
INDENT
    while True :
    INDENT
        result = input('Enter next number or end:')
        if (result == 'end') :
        INDENT
            break
        DEDENT
        else :
        INDENT
            numbers.append(result)
        DEDENT
    DEDENT
    numbers.sort()
    sum_numbers = sum(numbers [: - 1])
DEDENT
----------------------------------------

def excludeMax() :
INDENT
    biggest_sof_far = None
    sum_of_inputs = 0
    while True :
    INDENT
        result = input('Enter next number or end:')
        if result == 'end' :
        INDENT
            break
        DEDENT
        if biggest_sof_far == None :
        INDENT
            biggest_sof_far = result
        DEDENT
        elif result == biggest_sof_far :
        INDENT
            pass
        DEDENT
        elif result > biggest_sof_far :
        INDENT
            sum_of_inputs += biggest_sof_far
            biggest_sof_far = result
        DEDENT
        else :
        INDENT
            sum_of_inputs += result
        DEDENT
    DEDENT
    return sum_of_inputs

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36820077_36820123_1_11
36820077_36820176_1_22
Title: How to ask user for a series of number and return the sum of all numbers excluding the max number? 
----------------------------------------

def excludeMax() :
INDENT
    numbers = []
    while True :
    INDENT
        result = input('Enter next number or end:')
        if (result == 'end') :
        INDENT
            break
        DEDENT
        else :
        INDENT
            numbers.append(result)
        DEDENT
    DEDENT
    numbers.remove(max(numbers))
    return sum(numbers)
DEDENT
----------------------------------------

def excludeMax() :
INDENT
    biggest_sof_far = None
    sum_of_inputs = 0
    while True :
    INDENT
        result = input('Enter next number or end:')
        if result == 'end' :
        INDENT
            break
        DEDENT
        if biggest_sof_far == None :
        INDENT
            biggest_sof_far = result
        DEDENT
        elif result == biggest_sof_far :
        INDENT
            pass
        DEDENT
        elif result > biggest_sof_far :
        INDENT
            sum_of_inputs += biggest_sof_far
            biggest_sof_far = result
        DEDENT
        else :
        INDENT
            sum_of_inputs += result
        DEDENT
    DEDENT
    return sum_of_inputs

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36827263_36920384_37_64
36827263_36920384_8_24
Title: How to set default response on button with add_action_widget in Gtk.Dialog 
----------------------------------------

def __init__(self, text) :
INDENT
    self.dialog = Gtk.Dialog(title = "Dialog")
    self.dialog.set_default_size(400, 300)
    self.dialog.set_border_width(10)

    self.dialog.add_action_widget(self._make_button(etiquette = u'Ok(-5)', stock_icon = Gtk.STOCK_OK), Gtk.ResponseType.OK)
    self.dialog.add_action_widget(self._make_button(etiquette = u'Cancel(-6)', stock_icon = Gtk.STOCK_CANCEL), Gtk.ResponseType.CANCEL)
    self.dialog.add_action_widget(self._make_button(etiquette = u'close(-7)', stock_icon = Gtk.STOCK_ABOUT), Gtk.ResponseType.CLOSE)
    self.dialog.add_action_widget(self._make_button(etiquette = u'YES(-8)', stock_icon = Gtk.STOCK_ADD), Gtk.ResponseType.YES)
    self.dialog.add_action_widget(self._make_button(etiquette = u'NON(-9)', stock_icon = Gtk.STOCK_ADD), Gtk.ResponseType.NO)
    self.dialog.add_action_widget(self._make_button(etiquette = u'APPLY(-10)', stock_icon = Gtk.STOCK_ADD), Gtk.ResponseType.APPLY)

    self.dialog.add_action_widget(self._make_button(etiquette = u'HELP(-11)', stock_icon = Gtk.STOCK_ADD), Gtk.ResponseType.HELP)
    """
        # three next button run ok also Gtk doc may be not update :-)
        self.dialog.add_action_widget(self._make_button(etiquette=u'ACCEPT(-3)', stock_icon=Gtk.STOCK_ADD),Gtk.ResponseType.ACCEPT)#indice -3
        self.dialog.add_action_widget(self._make_button(etiquette=u'REJECT(-2)', stock_icon=Gtk.STOCK_ADD),Gtk.ResponseType.REJECT)#indice -2
        self.dialog.add_action_widget(self._make_button(etiquette=u'FONCTION(42)', stock_icon=Gtk.STOCK_ADD),42)#indice -2
        """
    label = Gtk.Label(text)
    content_area = self.dialog.get_content_area()
    content_area.add(label)
    self.dialog.show_all()
DEDENT
----------------------------------------

def __init__(self, text, stock_icon = None, sizeicon = Gtk.IconSize.MENU) :
INDENT
    self.box = Gtk.HBox(False, 0)
    self.box.set_border_width(2)
    if stock_icon is not None :
    INDENT
        image = Gtk.Image.new_from_stock(stock_id = stock_icon, size = sizeicon)
    DEDENT
    else :
    INDENT
        image = Gtk.Image.new_from_stock(stock_id = Gtk.STOCK_OK, size = sizeicon)
    DEDENT
    etiquette = Gtk.Label(text)
    self.box.pack_start(image, False, False, 3)
    self.box.pack_start(etiquette, False, False, 3)
    """image.show()
        etiquette.show()"""
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36831573_36831631_1_11
36831573_36831639_1_11
Title: "Loop that adds user inputted numbers and breaks when user types ""end""" 
----------------------------------------

def SumFunction() :
INDENT
    sum = 0
    while (True) :
    INDENT
        x = input('Enter: ')
        while x.lower() == 'end' :
        INDENT
            return sum
        DEDENT
        while float(x) > = 0 :
        INDENT
            sum += float(x)
            break
        DEDENT
        else :
        INDENT
            print ("Wrong Number!")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def SumFunction() :
INDENT
    number = 0
    user_input = 1
    while user_input > = 0 :
    INDENT
        user_input = input("Enter next number: ")
        if user_input == 'end' :
        INDENT
            break
        DEDENT
        user_input = float(user_input)
        number += max(user_input, 0)
    DEDENT
    return number
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36851171_36851188_3_15
36851171_36851450_1_16
Title: How can I search for repeating characters in a string? 
----------------------------------------

def password_check(pw) :
INDENT
    if not pw :
    INDENT
        print ('Please enter a password')
    DEDENT
    elif pw.isalpha() :
    INDENT
        print ('Password must contain at least one number.')
    DEDENT
    elif pw.isdigit() :
    INDENT
        print ('Password must contain at least one letter. ')
    DEDENT
    elif any((len(list(vals)) > 1) for (char, vals) in groupby(pw)) :
    INDENT
        print ('Password cannot contain duplicate characters. ')
    DEDENT
    else :
    INDENT
        print ('True')
    DEDENT
DEDENT
----------------------------------------

def password_check(pw) :
INDENT
    if len(pw) < 2 :
    INDENT
        print ('Password must be at least 2 characters long')
        return False
    DEDENT
    elif pw.isalpha() :
    INDENT
        print ('Password must contain at least one number.')
        return False
    DEDENT
    elif pw.isdigit() :
    INDENT
        print ('Password must contain at least one letter. ')
        return False
    DEDENT
    for a in pw :
    INDENT
        if a * 2 in pw :
        INDENT
            print ('Password contains a consecutive character')
            return False
        DEDENT
    DEDENT
    print ('Password was accepted')
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36853770_36864477_1_21
36853770_36877936_3_31
Title: Vectorizing for loop with repeated indices in python 
----------------------------------------

def twopointcorr(x, y, s, dr) :
INDENT
    width = np.max(x) - np.min(x)
    height = np.max(y) - np.min(y)
    n = len(x)
    maxR = np.sqrt((width / 2) ** 2 + (height / 2) ** 2)
    r = np.arange(0, maxR, dr)
    corrfun = r * 0
    rw = r * 0
    for j in range(0, n) :
    INDENT
        hypot = np.sqrt((x [j] - x) ** 2 + (y [j] - y) ** 2)
        ind = [np.abs(r - h).argmin() for h in hypot]
        for k, v in enumerate(ind) :
        INDENT
            if j == k :
            INDENT
                continue
            DEDENT
            corrfun [v] += (s [k] - s [j]) ** 2
            rw [v] += 1
        DEDENT
    DEDENT
    return r, corrfun, rw
DEDENT
----------------------------------------

def twopointcorr(x, y, s, dr, maxR = - 1) :
INDENT
    width = np.max(x) - np.min(x)
    height = np.max(y) - np.min(y)
    n = len(x)
    if maxR < dr :
    INDENT
        maxR = np.sqrt((width / 2) ** 2 + (height / 2) ** 2)
    DEDENT
    r = np.arange(0, maxR + dr, dr)
    corrfun = r * 0
    rw = r * 0

    for j in range(0, n) :
    INDENT

        ind = np.clip(np.round(np.hypot(x [j] - x, y [j] - y) / dr), 0, len(r) - 1).astype(int)
        np.add.at(corrfun, ind, (s - s [j]) ** 2)
        np.add.at(rw, ind, 1)
    DEDENT
    rw [0] -= n
    corrfun = np.sqrt(np.divide(corrfun, np.maximum(rw, 1)))
    r = np.delete(r, - 1)
    rw = np.delete(rw, - 1)
    corrfun = np.delete(corrfun, - 1)
    return r, corrfun, rw
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
368545_368550_1_12
368545_368554_1_10
Title: How can I stop a While loop? 
----------------------------------------

def determine_period(universe_array) :
INDENT
    period = 0
    tmp = universe_array
    while True :
    INDENT
        tmp = apply_rules(tmp)
        period += 1
        if numpy.array_equal(tmp, universe_array) is True :
        INDENT
            return period
        DEDENT
        if period > 12 :
        INDENT
            return 0
        DEDENT
        else :
        INDENT
            return period
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def determine_period(universe_array) :
INDENT
    period = 0
    tmp = universe_array
    while period < 12 :
    INDENT
        tmp = apply_rules(tmp)
        if numpy.array_equal(tmp, universe_array) is True :
        INDENT
            break
        DEDENT
        period += 1
    DEDENT
    return period
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36873540_36874465_15_27
36873540_36874473_10_16
Title: Contextually injecting static class properties in Python 
----------------------------------------

def __init__(self, root_url) :
INDENT
    self.url = root_url
    """
        This is where the magic happens. We're telling type() to
        construct a class, with the class name ContentManagerPage,
        have it inherit from the above explicitly-declared Page
        class, and then overriding its __dict__ such that the class
        cm variable is set to be the ContentManager we're
        constructing it from.
        """
    self.Page = type(str('ContentManagerPage'), (Page,), {'cm' : self})
DEDENT
----------------------------------------

def __init__(self, root_url) :
INDENT
    class PerContentManagerPage(Page) :
    INDENT
        cm = self
    DEDENT
    self.Page = PerContentManagerPage

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36878018_36878146_1_22
36878018_36878838_1_13
Title: List of points and find the closest points trouble 
----------------------------------------

def closest1(num_list) :
INDENT
    if len(num_list) < 2 :
    INDENT
        return (None, None)
    DEDENT
    else :
    INDENT
        num1 = num_list [0]
        num2 = num_list [1]
        diff = abs(num1 - num2)
        if diff == 0 :
        INDENT
            return num1, num2
        DEDENT
        for p1, element in enumerate(num_list) :
        INDENT
            for p2, sec_element in enumerate(num_list) :
            INDENT
                if p1 == p2 :
                INDENT
                    continue
                DEDENT
                if abs(sec_element - element) < abs(diff) :
                INDENT
                    diff = sec_element - element
                    num1 = element
                    num2 = sec_element
                    if diff == 0 :
                    INDENT
                        return num1, num2
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return num1, num2
DEDENT
----------------------------------------

def closest1(num_list) :
INDENT
    if len(num_list) < 2 :
    INDENT
        return (None, None)
    DEDENT
    a, b = num_list [0], num_list [1]
    diff = b - a
    for i in range(len(num_list)) :
    INDENT
        for j in range(i) :
        INDENT
            new_diff = num_list [i] - num_list [j]
            if abs(new_diff) < abs(diff) :
            INDENT
                diff = new_diff
                a, b = num_list [i], num_list [j]
            DEDENT
        DEDENT
    DEDENT
    return a, b
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36880705_36880853_1_14
36880705_36881251_1_10
Title: Trouble understanding python generators and iterable arguments 
----------------------------------------

def alternate(* iterables) :
INDENT
    iterators = [iter(iterable) for iterable in iterables]
    sentinel = object()
    keep_going = True
    while keep_going :
    INDENT
        keep_going = False
        for iterator in iterators :
        INDENT
            maybe_yield = next(iterator, sentinel)
            if maybe_yield ! = sentinel :
            INDENT
                keep_going = True
                yield maybe_yield
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def alternate(* args) :
INDENT
    for i in range(10) :
    INDENT
        for arg in args :
        INDENT
            arg_num = i
            for thing in arg :
            INDENT
                if arg_num == i :
                INDENT
                    yield thing
                    break
                DEDENT
                else :
                INDENT
                    arg_num += 1
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36883772_36933697_115_122
36883772_36933697_73_81
Title: PYQT - Share signals between QThread 
----------------------------------------

def run(self) :
INDENT
    self.exiting = False
    while not self.exiting :
    INDENT
        print ("Signal A: ", self.signalA)
        print ("Signal B: ", self.signalB)
        time.sleep(1)

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    self.exiting = False
    i = 0
    while not self.exiting :
    INDENT
        self.signal_a.emit(i)
        print ("Thread A:", i)
        i = i + 1
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36883772_36933697_115_122
36883772_36933697_94_102
Title: PYQT - Share signals between QThread 
----------------------------------------

def run(self) :
INDENT
    self.exiting = False
    while not self.exiting :
    INDENT
        print ("Signal A: ", self.signalA)
        print ("Signal B: ", self.signalB)
        time.sleep(1)

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    self.exiting = False
    i = 0
    while not self.exiting :
    INDENT
        self.signal_b.emit(i)
        print ("Thread B:", i)
        i = i + 1
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36909320_37046176_1_17
36909320_37079053_8_20
Title: faster geometric average on ASCII 
----------------------------------------

def GA() :
INDENT
    InStr = "0204507890"
    InDict = {
        0 : "ABCDEFGHIJ",
        1 : "KLMNOPQRST",
        2 : "WXYZ#&/()?"}
    OutStr = bytearray()
    DLen = len(InDict)
    for pos in zip(InStr, * InDict.values()) :
    INDENT
        if pos [0] == "0" :
        INDENT
            multiplOrds = 1
            for mul in (ord(char) for char in pos [1 :] if char ! = "!") : multiplOrds *= mul
            OutStr += chr(int(round(multiplOrds ** (1.0 / DLen), 0)))
        DEDENT
    DEDENT
    return str(OutStr)
DEDENT
----------------------------------------

def GA() :
INDENT
    OutStr = ""
    p = 1.0 / len(InDict)
    for pos, rest in zip(InStr, zip(* InDict.values())) :
    INDENT
        if pos == "0" :
        INDENT
            product = 1
            for char in rest :
            INDENT
                if char ! = '!' :
                INDENT
                    product *= ord(char)
                DEDENT
            DEDENT
            OutStr += chr(int(round(product ** p)))
        DEDENT
    DEDENT
    return OutStr
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36909320_37046176_1_17
36909320_37098120_21_35
Title: faster geometric average on ASCII 
----------------------------------------

def GA() :
INDENT
    InStr = "0204507890"
    InDict = {
        0 : "ABCDEFGHIJ",
        1 : "KLMNOPQRST",
        2 : "WXYZ#&/()?"}
    OutStr = bytearray()
    DLen = len(InDict)
    for pos in zip(InStr, * InDict.values()) :
    INDENT
        if pos [0] == "0" :
        INDENT
            multiplOrds = 1
            for mul in (ord(char) for char in pos [1 :] if char ! = "!") : multiplOrds *= mul
            OutStr += chr(int(round(multiplOrds ** (1.0 / DLen), 0)))
        DEDENT
    DEDENT
    return str(OutStr)
DEDENT
----------------------------------------

def GA() :
INDENT
    OutStr = ""
    p = 1.0 / len(InDict)
    for pos, rest in zip(InStr, zip(* InDict.values())) :
    INDENT
        if pos == "0" :
        INDENT
            product = 1
            for char in rest :
            INDENT
                if char ! = '!' :
                INDENT
                    product *= ord(char)
                DEDENT
            DEDENT
            OutStr += chr(int(round(product ** p)))
        DEDENT
    DEDENT
    return OutStr

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36968162_36968648_3_14
36968162_36968668_3_15
Title: Checking if input contains a name - python 
----------------------------------------

def ifName() :
INDENT
    ifNameList = userInput.split()
    non_title_names = []
    for each_name in ifNameList :
    INDENT
        if not each_name.istitle() :
        INDENT
            non_title_names.append(each_name)
        DEDENT
    DEDENT
    if non_title_names :
    INDENT
        print ("Not a dude/dudette?")
    DEDENT
    else :
    INDENT
        print ("is that a dude/dudette?")
    DEDENT
DEDENT
----------------------------------------

def ifName(userInput) :
INDENT
    ifNameList = userInput.split()
    if len(ifNameList) ! = 2 :
    INDENT
        print("Please enter two names", file = sys.stderr)
    DEDENT
    elif ifNameList [0].istitle() and ifNameList [1].istitle() :
    INDENT
        print ("is that a dude/dudette?")
    DEDENT
    else :
    INDENT
        print("Please capilalize your names", file = sys.stderr)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36972714_36972806_1_15
36972714_47090901_1_15
Title: Implementing 3-way quicksort 
----------------------------------------

def partition3(a, l, r) :
INDENT
    x, j, t = a [l], l, r
    i = j
    while i < = t :
    INDENT
        if a [i] < x :
        INDENT
            a [j], a [i] = a [i], a [j]
            j += 1
        DEDENT
        elif a [i] > x :
        INDENT
            a [t], a [i] = a [i], a [t]
            t -= 1
            i -= 1
        DEDENT
        i += 1
    DEDENT
    return j, t
DEDENT
----------------------------------------

def partition3(a, l, r) :
INDENT
    x = a [l]
    m1 = l
    m2 = l
    i = m1
    for i in range(l + 1, r + 1) :
    INDENT
        if a [i] < x :
        INDENT
            a [i], a [m1] = a [m1], a [i]
            a [i], a [m2 + 1] = a [m2 + 1], a [i]
            m1 += 1
            m2 += 1
        DEDENT
        elif a [i] == x :
        INDENT
            a [i], a [m2 + 1] = a [m2 + 1], a [i]
            m2 += 1
        DEDENT
    DEDENT
    return m1, m2
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36972868_36973083_8_15
36972868_36973467_3_14
Title: Python : How to dynamically combine any number of small matrices into one big matrix 
----------------------------------------

def combine_matrix(* args) :
INDENT
    n = len(args)
    rows, cols = args [0].shape
    a = np.zeros((n, rows, cols))
    for i in range(n) :
    INDENT
        a [i] = args [i]
    DEDENT
    return a
DEDENT
----------------------------------------

def combine_matrix(* args) :
INDENT
    n = len(args)
    rows, cols = args [0].shape
    a = np.zeros((n, cols * rows))
    m = 0
    for i in range(n / rows) :
    INDENT
        for j in range(n / cols) :
        INDENT
            a [i * rows : (i + 1) * rows, j * cols : (j + 1) * cols] = args [m]
            m += 1
        DEDENT
    DEDENT
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
36993067_36994221_1_23
36993067_37041655_1_24
Title: How to add a number to a value in all keys in a text file? 
----------------------------------------

def add_sausage() :
INDENT
    L = open("list.txt", "r")
    data = L.read()
    L.close()
    datalines = data.split("\n")
    L = open("list.txt", "w")
    for line in datalines :
    INDENT
        s = line.strip()
        string = s.split(",")
        if len(string) > 1 :
        INDENT

            option = input("Do you want to add a sausage? y/n\n")
            if option == "y" :
            INDENT
                string [5] = str(int(string [5]) + 1)
            DEDENT
            elif option == "n" :
            INDENT
                pass
            DEDENT
            newline = ",".join(string)
            L.write(newline + "\n")
        DEDENT
    DEDENT
    L.close()
DEDENT
----------------------------------------

def add_sausage() :
INDENT
    dataline_location = 0
    with open("list.txt", "r+") as f :
    INDENT
        for i, line in enumerate(f) :
        INDENT

            string = line.rstrip().split(',')
            if len(string) > 1 :
            INDENT
                for j in range(0, len(string), 2) :
                INDENT
                    option = input("For order {0} do you want to add a {1}? y/n\n".format(i + 1, string [j]))
                    if option == "y" :
                    INDENT
                        string [j + 1] = str(int(string [j + 1]) + 1)
                    DEDENT
                    elif option == "n" :
                    INDENT
                        pass
                    DEDENT
                DEDENT
                newline = ",".join(string)
                f.seek(dataline_location)
                f.write(newline + "\n")
                f.flush()
                dataline_location += len(line)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3699532_3699677_26_31
3699532_3699677_48_54
Title: SQLAlchemy memory hog on select statement 
----------------------------------------

def worker(conn) :
INDENT
    cursor = conn.cursor()
    cursor.execute(query)
    for row in cursor :
    INDENT
        logger.info(row)
    DEDENT
DEDENT
----------------------------------------

def worker() :
INDENT
    conn = mysqldb_conn()
    cursor = conn.cursor()
    cursor.execute(query)
    for row in cursor :
    INDENT
        logger.info(row)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37041660_37041722_21_38
37041660_37041735_1_18
Title: How to use string methods on text files? 
----------------------------------------

def main() :
INDENT
    in_file = open("text.txt", "r")
    line = in_file.readline()
    line_list = line.split()
    lowercase(line_list)
    uppercase(line_list)
    numbers(line_list)
    whitespace(line_list)
    in_file.close()
DEDENT
----------------------------------------

def main() :
INDENT
    lower_case = 0
    upper_case = 0
    numbers = 0
    whitespace = 0
    with open("text.txt", "r") as in_file :
    INDENT
        for line in in_file :
        INDENT
            lower_case += sum(1 for x in line if x.islower())
            upper_case += sum(1 for x in line if x.isupper())
            numbers += sum(1 for x in line if x.isdigit())
            whitespace += sum(1 for x in line if x.isspace())
        DEDENT
    DEDENT
    print 'Lower case Letters: %s' % lower_case
    print 'Upper case Letters: %s' % upper_case
    print 'Numbers: %s' % numbers
    print 'Spaces: %s' % spaces
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37090774_37091053_2_25
37090774_37091188_6_33
Title: Aligning in wxpython 
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, "MyCanvas", size = (1200, 400))
    self.fig = plt.Figure(figsize = (15, 5))
    self.ax1 = self.fig.add_subplot(1, 1, 1)
    self.canvas = FigureCanvas(self, - 1, self.fig)
    b1 = wx.CheckBox(self, - 1, "Apples", (10, 20), (160, - 1))
    b2 = wx.CheckBox(self, - 1, "Mango", (10, 40), (160, - 1))
    checkbox_sizer = wx.BoxSizer(wx.VERTICAL)
    checkbox_sizer.AddMany([b1, b2])
    main_sizer = wx.BoxSizer(wx.HORIZONTAL)
    main_sizer.Add(checkbox_sizer)
    main_sizer.Add(self.canvas)
    self.SetSizer(main_sizer)
    self.Layout()
    self.Fit()
DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, "MyCanvas", size = (1200, 400))
    self.fig = plt.Figure(figsize = (15, 5))
    self.ax1 = self.fig.add_subplot(1, 1, 1)
    self.canvas = FigureCanvas(self, - 1, self.fig)
    b1 = wx.CheckBox(self, - 1, "Apples", size = (160, - 1))
    b2 = wx.CheckBox(self, - 1, "Mango", size = (160, - 1))
    mainsizer = wx.BoxSizer(wx.HORIZONTAL)
    cbsizer = wx.BoxSizer(wx.VERTICAL)
    canvassizer = wx.BoxSizer(wx.VERTICAL)

    cbsizer.Add(b1, 0, wx.ALIGN_LEFT | wx.ALL, 5)
    cbsizer.Add(b2, 0, wx.ALIGN_LEFT | wx.ALL, 5)

    canvassizer.Add(self.canvas, 1, wx.EXPAND | wx.ALL, 1)

    mainsizer.Add(cbsizer, 1, wx.EXPAND | wx.ALL, 2)
    mainsizer.Add(canvassizer, 3, wx.EXPAND | wx.ALL, 2)
    self.SetSizer(mainsizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37092633_37106947_24_37
37092633_37106947_76_84
Title: The Pong ball is going through the paddle and hitting the wall and reflecting rather hitting the paddle 
----------------------------------------

def __init__(self, name) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    if name == "george" :
    INDENT
        self.x, self.y = 16, SCR_HEI / 2
    DEDENT
    elif name == "frank" :
    INDENT
        self.x, self.y = SCR_WID - 16, SCR_HEI / 2
    DEDENT
    self.name = name
    self.speed = 3
    self.padWid, self.padHei = 8, 64
    self.score = 0
    self.scoreFont = pygame.font.SysFont("Arial", 32)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.rect = self.image.get_rect()
    self.rect.x, self.rect.y = SCR_WID / 2, SCR_HEI / 2
    self.speed_x = - 3
    self.speed_y = 3
    self.size = 8
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37092633_37106947_51_69
37092633_37106947_85_114
Title: The Pong ball is going through the paddle and hitting the wall and reflecting rather hitting the paddle 
----------------------------------------

def movement(self) :
INDENT
    keys = pygame.key.get_pressed()
    if self.name == "george" :
    INDENT
        if keys [pygame.K_w] :
        INDENT
            self.y -= self.speed
        DEDENT
        elif keys [pygame.K_s] :
        INDENT
            self.y += self.speed
        DEDENT
    DEDENT
    elif self.name == "frank" :
    INDENT
        if keys [pygame.K_UP] :
        INDENT
            self.y -= self.speed
        DEDENT
        elif keys [pygame.K_DOWN] :
        INDENT
            self.y += self.speed
        DEDENT
    DEDENT
    if self.y < = 0 :
    INDENT
        self.y = 0
    DEDENT
    elif self.y > = SCR_HEI - 64 :
    INDENT
        self.y = SCR_HEI - 64
    DEDENT
DEDENT
----------------------------------------

def movement(self) :
INDENT
    self.rect.x += self.speed_x
    self.rect.y += self.speed_y

    if self.rect.y < = 0 :
    INDENT
        self.speed_y *= - 1
    DEDENT
    elif self.rect.y > = SCR_HEI - self.size :
    INDENT
        self.speed_y *= - 1
    DEDENT
    if self.rect.x < = 0 :
    INDENT
        self.__init__()
        enemy.score += 1
    DEDENT
    elif self.rect.x > = SCR_WID - self.size :
    INDENT
        self.__init__()
        self.speed_x = 3
        player.score += 1
    DEDENT
    for n in range(- self.size, player.padHei) :
    INDENT
        if self.rect.y == player.y + n :
        INDENT
            if self.rect.x < = player.x + player.padWid :
            INDENT
                self.speed_x *= - 1
                break
            DEDENT
        DEDENT
        n += 1
    DEDENT
    for n in range(- self.size, enemy.padHei) :
    INDENT
        if self.rect.y == enemy.y + n :
        INDENT
            if self.rect.x > = enemy.x - enemy.padWid :
            INDENT
                self.speed_x *= - 1
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37092683_37092875_6_13
37092683_37093143_4_18
Title: execute multiple commands in Linux using python in the same time 
----------------------------------------

def worker_func() :
INDENT
    while commands :
    INDENT
        com = commands.pop(0)
        print "Start execute commands.."
        os.system(com)
        count += 1
        print "[OK] command " + str(count) + " runing successfully."
    DEDENT
DEDENT
----------------------------------------

def worker_func() :
INDENT
    while not stopped.is_set() :
    INDENT
        try :
        INDENT

            com = q.get_nowait()
        DEDENT
        except Empty :
        INDENT
            continue
        DEDENT
        try :
        INDENT
            os.system(com)
        DEDENT
        except Exception as e :
        INDENT
            print "[-] Error running command %s" % (str(e))
        DEDENT
        finally :
        INDENT
            q.task_done()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37101400_37101506_1_14
37101400_37101639_3_19
Title: create file after positive exception FileNotFoundError 
----------------------------------------

def open_file() :
INDENT
    try :
    INDENT
        current_file = codecs.open(TARGET_DIR, 'r', 'utf-8')
    DEDENT
    except FileNotFoundError :
    INDENT
        procesed_data = parse_site(URL)
        save_parsed(procesed_data)
        compare_parsed()
        current_file = codecs.open(TARGET_DIR, 'r', 'utf-8')
    DEDENT
    data = csv.reader(current_file, delimiter = ';')
    all_lines = list(data)
    current_file.close()
    return all_lines
DEDENT
----------------------------------------

def open_file() :
INDENT
    all_lines = []

    if not os.path.isfile(TARGET_DIR) :
    INDENT
        procesed_data = parse_site(URL)
        save_parsed(procesed_data)
        compare_parsed()

    DEDENT
    current_file = codecs.open(TARGET_DIR, 'r', 'utf-8')
    data = csv.reader(current_file, delimiter = ';')
    for row in data :
    INDENT
        all_lines.append(row)
    DEDENT
    current_file.close()
    return all_lines
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3710751_23736245_5_13
3710751_3711299_4_22
Title: how to create read only text ctrl but support copy paste event 
----------------------------------------

def __init__(self) :
INDENT
    super(MyWin, self).__init__(None, size = (800, 600))
    self.painted = True
    self.backup = ''
    self.text = wx.TextCtrl(self, style = wx.TE_MULTILINE | wx.HSCROLL)
    self.text.Bind(wx.EVT_TEXT_PASTE, self.onpaste)
    self.text.Bind(wx.EVT_TEXT, self.ontextchange)
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent, id = - 1) :
INDENT
    wx.Frame.__init__(self, parent, id, size = (200, 200))
    self.panel = wx.Panel(self, wx.ID_ANY)
    bsizer = wx.BoxSizer()
    read_only_txtCtrl = wx.TextCtrl(self, - 1,
        "This textCtrl is read only",
        style = wx.TE_MULTILINE | wx.TE_READONLY)
    editable_txtCtrl = wx.TextCtrl(self, - 1,
        "This textCtrl is editable",
        style = wx.TE_MULTILINE)
    bsizer.Add(read_only_txtCtrl, 1, wx.EXPAND)
    bsizer.Add(editable_txtCtrl, 1, wx.EXPAND)
    self.SetSizerAndFit(bsizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37126206_37126434_2_12
37126206_37130587_9_23
Title: IndexError in array PYTHON 
----------------------------------------

def binary_translating() :
INDENT
    Population.BinaryX = []
    j = 0
    for i in range(10) :
    INDENT
        Population.BinaryX.insert([])
        while Population.CodedX [i] > 1 & j < 8 :
        INDENT
            dec = int(Population.CodedX [i]) % 2
            Population.BinaryX [i].insert(j, dec)
            Population.CodedX [i] /= 2
            j += 1
        DEDENT
        j = 0
    DEDENT
DEDENT
----------------------------------------

def binary_translating(self) :
INDENT
    for i in range(10) :
    INDENT
        j = 0
        self.BinaryX.append([0 for k in range(10)])
        while (self.CodedX [i] > 0) and (j < 10) :
        INDENT
            dec = int(self.CodedX [i] % 2)
            self.BinaryX [i] [j] = dec
            self.CodedX [i] = int(self.CodedX [i] / 2)
            j += 1
        DEDENT
    DEDENT
    print (self.BinaryX)
    for i in range(10) :
    INDENT
        self.CodedX [i] = int(0)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3712697_3712829_1_11
3712697_3712850_3_10
Title: Django querysets - make sure results are retrieved only once 
----------------------------------------

def getIsland(request) :
INDENT
    if hasattr(request, "_cached_island") :
    INDENT
        return request._cached_island
    DEDENT
    try :
    INDENT
        island = Island.objects.get(user = request.user)
    DEDENT
    except Island.DoesNotExist :
    INDENT
        island = Island(user = request.user)
        island.save()
    DEDENT
    island.update()
    request._cached_island = island
    return island
DEDENT
----------------------------------------

def getIsland(self, request) :
INDENT
    user_id = request.user.pk
    island = store.get(user_id)
    if island is None :
    INDENT
        island, created = Island.objects.get_or_create(user = user_id)
        store [user_id] = island
    DEDENT
    island.update()
    return island
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3712697_3712850_3_10
3712697_3713745_1_11
Title: Django querysets - make sure results are retrieved only once 
----------------------------------------

def getIsland(self, request) :
INDENT
    user_id = request.user.pk
    island = store.get(user_id)
    if island is None :
    INDENT
        island, created = Island.objects.get_or_create(user = user_id)
        store [user_id] = island
    DEDENT
    island.update()
    return island
DEDENT
----------------------------------------

def getIsland(request) :
INDENT
    island = cache.get("island_" + request.user)
    if island == None :
    INDENT
        try :
        INDENT
            island = Island.objects.get(user = request.user)
        DEDENT
        except Island.DoesNotExist :
        INDENT
            island = Island(user = request.user)
            island.save()
        DEDENT
        island.update()
        cache.set("island_" + request.user, island, 60)
    DEDENT
    return island
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37150287_37150734_10_25
37150287_37150734_33_42
Title: How to access Kivy screens manager.<property> using Python 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(HomePage, self).__init__(** kwargs)
    layout = FloatLayout()
    notification = Label(text = 'upcoming: ....', font_size = '16sp', size_hint = (0, 0), pos_hint = {'center_x' :.5, 'top' : 0.9})
    layout.add_widget(notification)
    button_row = BoxLayout(size_hint_y =.1, spacing = 20)
    profile_button = Button(text = 'Profile')
    button_row.add_widget(profile_button)
    profile_button.bind(on_press = self.transit)
    layout.add_widget(button_row)
    self.add_widget(layout)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(ProfilePage, self).__init__(** kwargs)
    layout = FloatLayout()
    labelP = Label(text = "Profile Page")
    layout.add_widget(labelP)
    self.add_widget(layout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37151895_37241805_26_44
37151895_39376833_15_31
Title: TensorFlow - Read all examples from a TFRecords at once? 
----------------------------------------

def get_all_records(FILE) :
INDENT
    with tf.Session() as sess :
    INDENT
        filename_queue = tf.train.string_input_producer([FILE])
        image, label, height, width, depth = read_and_decode(filename_queue)
        image = tf.reshape(image, tf.pack([height, width, 3]))
        image.set_shape([720, 720, 3])
        init_op = tf.initialize_all_variables()
        sess.run(init_op)
        coord = tf.train.Coordinator()
        threads = tf.train.start_queue_runners(coord = coord)
        for i in range(2053) :
        INDENT
            example, l = sess.run([image, label])
            img = Image.fromarray(example, 'RGB')
            img.save("output/" + str(i) + '-train.png')
            print (example, l)
        DEDENT
        coord.request_stop()
        coord.join(threads)
    DEDENT
DEDENT
----------------------------------------

def get_all_records(FILE) :
INDENT
    with tf.Session() as sess :
    INDENT
        filename_queue = tf.train.string_input_producer([FILE], num_epochs = 1)
        image = read_and_decode(filename_queue)
        init_op = tf.initialize_all_variables()
        sess.run(init_op)
        coord = tf.train.Coordinator()
        threads = tf.train.start_queue_runners(coord = coord)
        try :
        INDENT
            while True :
            INDENT
                example = sess.run([image])
            DEDENT
        DEDENT
        except tf.errors.OutOfRangeError, e :
        INDENT
            coord.request_stop(e)
        DEDENT
        finally :
        INDENT
            coord.request_stop()
            coord.join(threads)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37151895_37241805_5_25
37151895_39376833_3_14
Title: TensorFlow - Read all examples from a TFRecords at once? 
----------------------------------------

def read_and_decode(filename_queue) :
INDENT
    reader = tf.TFRecordReader()
    _, serialized_example = reader.read(filename_queue)
    features = tf.parse_single_example(
        serialized_example,
        features = {
            'image_raw' : tf.FixedLenFeature([], tf.string),
            'label' : tf.FixedLenFeature([], tf.int64),
            'height' : tf.FixedLenFeature([], tf.int64),
            'width' : tf.FixedLenFeature([], tf.int64),
            'depth' : tf.FixedLenFeature([], tf.int64)})
    image = tf.decode_raw(features ['image_raw'], tf.uint8)
    label = tf.cast(features ['label'], tf.int32)
    height = tf.cast(features ['height'], tf.int32)
    width = tf.cast(features ['width'], tf.int32)
    depth = tf.cast(features ['depth'], tf.int32)
    return image, label, height, width, depth

DEDENT
----------------------------------------

def read_and_decode(filename_queue) :
INDENT
    reader = tf.TFRecordReader()
    _, serialized_example = reader.read(filename_queue)
    features = tf.parse_single_example(
        serialized_example,
        features = {
            'image_raw' : tf.FixedLenFeature([], tf.string)})
    image = tf.decode_raw(features ['image_raw'], tf.uint8)
    return image

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37167275_37264772_37_60
37167275_38249823_1_33
Title: How to set ttk calendar programmatically 
----------------------------------------

def set_day(self, day) :
INDENT
    w = self._calendar
    if not w.winfo_viewable() :
    INDENT
        w.after(200, self.set_day, day)
        return
    DEDENT
    text = '%02d' % day
    column = None
    for iid in self._items :
    INDENT
        rowvals = w.item(iid, 'values')
        try :
        INDENT
            column = rowvals.index(text)
        DEDENT
        except ValueError as err :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            item = iid
            bbox = w.bbox(iid, column)
            break
        DEDENT
    DEDENT
    if column is not None :
    INDENT
        self._selection = (text, item, column)
        self._show_selection(text, bbox)

    DEDENT
DEDENT
----------------------------------------

def set_day(self, dt_object) :
INDENT
    day = dt_object.day
    w = self._calendar
    if not w.winfo_viewable() :
    INDENT
        w.after(200, self.set_day, dt_object)
        return
    DEDENT
    while dt_object.year < self._date.year :
    INDENT
        self._prev_month()
    DEDENT
    while dt_object.year > self._date.year :
    INDENT
        self._next_month()
    DEDENT
    while dt_object.month < self._date.month :
    INDENT
        self._prev_month()
    DEDENT
    while dt_object.month > self._date.month :
    INDENT
        self._next_month()
    DEDENT
    text = '%02d' % day
    column = None
    for iid in self._items :
    INDENT
        rowvals = w.item(iid, 'values')
        try :
        INDENT
            column = rowvals.index(text)
        DEDENT
        except ValueError as err :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            item = iid
            bbox = w.bbox(iid, column)
            break
        DEDENT
    DEDENT
    if column is not None :
    INDENT
        self._selection = (text, item, column)
        self._show_selection(text, bbox)
    DEDENT
    else :
    INDENT
        print "Column is None"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37215268_37450685_13_23
37215268_37450685_30_43
Title: Python Tweepy streaming with multitasking 
----------------------------------------

def run(self) :
INDENT
    print "addemup starting"
    global var
    while (var < 100000) :
    INDENT
        if var > 90000 :
        INDENT
            var = 0
        DEDENT
        var = var + 10

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    print "checkem starting"
    global var
    start = time.time()
    elapsed = time.time() - start
    while (elapsed < 10) :
    INDENT
        elapsed = time.time() - start
        if elapsed > 5 :
        INDENT
            print "var = ", var
            start = time.time()
            elapsed = time.time() - start

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37218047_37218698_1_31
37218047_37223165_1_20
Title: recursive backtracking - python. not returning value 
----------------------------------------

def IterateStaples(combo, target) :
INDENT
    bestCombo = []
    def helper(combo) :
    INDENT
        for staple in combo.staples :
        INDENT

            staple.increment()
            combo.calcTotals()
            combo.findDiff(target)

            if combo.findConflict(target) :
            INDENT
                staple.decrement()
                combo.calcTotals()
                combo.findDiff(target)

            DEDENT
            elif all(combo.diff [macro] < 2 for macro in combo.diff) :
            INDENT
                bestCombo.append(deepcopy(combo))
                return
            DEDENT
            else :
            INDENT
                helper(combo)
                staple.decrement()
                combo.calcTotals()
                combo.findDiff(target)
            DEDENT
        DEDENT
    DEDENT
    helper(combo)
    return bestCombo
DEDENT
----------------------------------------

def IterateStaples(combo, target) :
INDENT
    if all(combo.diff [macro] < 2 for macro in combo.diff) :
    INDENT
        return combo
    DEDENT
    for staple in combo.staples :
    INDENT
        staple.increment()
        combo.calcTotals()
        combo.findDiff(target)
        if not combo.findConflict(target) :
        INDENT
            result = IterateStaples(combo, target)
            if result is not None :
            INDENT
                return result
            DEDENT
        DEDENT
        staple.decrement()
        combo.calcTotals()
        combo.findDiff(target)
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37227566_37227716_8_14
37227566_37227723_8_13
Title: "if else button not working" 
----------------------------------------

def toggle() :
INDENT
    text = tglBtn.cget("text")
    if text == "LBS" :
    INDENT
        tglBtn.config(text = "KGS")
    DEDENT
    else :
    INDENT
        tglBtn.config(text = "LBS")
    DEDENT
DEDENT
----------------------------------------

def toggle() :
INDENT
    if buttonText.get() == "LBS" :
    INDENT
        buttonText.set("KGS")
    DEDENT
    else :
    INDENT
        buttonText.set("LBS")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37233803_37234844_24_46
37233803_46859625_31_76
Title: How to web scrape followers from Instagram web browser? 
----------------------------------------

def scrape_followers(driver, account) :
INDENT
    driver.get("https://www.instagram.com/{0}/".format(account))

    driver.find_element_by_partial_link_text("follower").click()

    xpath = "//div[@style='position: relative; z-index: 1;']/div/div[2]/div/div[1]"
    WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.XPATH, xpath)))

    xpath = "//div[@style='position: relative; z-index: 1;']//ul/li/div/div/div/div/a"
    followers_elems = driver.find_elements_by_xpath(xpath)
    return [e.text for e in followers_elems]

DEDENT
----------------------------------------

def scrape_followers(driver, account) :
INDENT
    driver.get("https://www.instagram.com/{0}/".format(account))

    driver.find_element_by_partial_link_text("follower").click()

    xpath = "/html/body/div[4]/div/div/div[2]/div/div[2]"
    WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.XPATH, xpath)))
    SCROLL_PAUSE = 0.5
    driver.execute_script("followersbox = document.getElementsByClassName('_gs38e')[0];")
    last_height = driver.execute_script("return followersbox.scrollHeight;")

    while True :
    INDENT
        driver.execute_script("followersbox.scrollTo(0, followersbox.scrollHeight);")

        time.sleep(SCROLL_PAUSE)

        new_height = driver.execute_script("return followersbox.scrollHeight;")
        if new_height == last_height :
        INDENT
            break
        DEDENT
        last_height = new_height

    DEDENT
    xpath = "/html/body/div[4]/div/div/div[2]/div/div[2]/ul/li"
    followers_elems = driver.find_elements_by_xpath(xpath)
    followers_temp = [e.text for e in followers_elems]
    followers = []

    for i in followers_temp :
    INDENT
        username, sep, name = i.partition('\n')
        followers.append(username)
    DEDENT
    print ("______________________________________")
    print ("FOLLOWERS")
    return followers
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
372365_2138709_7_12
372365_26774377_2_7
Title: Set timeout for xmlrpclib.ServerProxy 
----------------------------------------

def __init__(self, host = '', port = None, strict = None,
timeout = socket._GLOBAL_DEFAULT_TIMEOUT) :
INDENT
    if port == 0 :
    INDENT
        port = None
    DEDENT
    self._setup(self._connection_class(host, port, strict, timeout))
DEDENT
----------------------------------------

def __init__(self, host = '', port = None, strict = None,
timeout = socket._GLOBAL_DEFAULT_TIMEOUT) :
INDENT
    if port == 0 :
    INDENT
        port = None
    DEDENT
    self._setup(self._connection_class(host, port, strict, timeout))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37240621_37268445_1_16
37240621_37275096_1_18
Title: Django-Rest-Framework. Updating nested object 
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    instance.nr = validated_data.get('nr', instance.nr)
    instance.title = validated_data.get('title', instance.title)
    instance.save()

    items = validated_data.get('items')
    for item in items :
    INDENT
        inv_item = InvoiceItem.objects.get(invoice = instance, pk = item.pk)
        inv_item.name = item.get('name', inv_item.name)
        inv_item.price = item.get('price', inv_item.price)
        inv_item.invoice = instance
        inv_item.save()
    DEDENT
    instance.save()
    return instance
DEDENT
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    instance.nr = validated_data.get('nr', instance.nr)
    instance.title = validated_data.get('title', instance.title)
    instance.save()
    items = validated_data.get('items')
    for item in items :
    INDENT
        item_id = item.get('id', None)
        if item_id :
        INDENT
            inv_item = InvoiceItem.objects.get(id = item_id, invoice = instance)
            inv_item.name = item.get('name', inv_item.name)
            inv_item.price = item.get('price', inv_item.price)
            inv_item.save()
        DEDENT
        else :
        INDENT
            InvoiceItem.objects.create(account = instance, ** item)
        DEDENT
    DEDENT
    return instance
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37263748_37264397_16_34
37263748_37265787_23_42
Title: Python - Project Euler #35 -- what is wrong with this approach? 
----------------------------------------

def circular_list(limit) :
INDENT
    circular = []
    primes = list(gen_primes(limit))
    for prime in primes :
    INDENT
        string = str(prime)
        digits = deque(string)
        for rotation in range(1, len(string)) :
        INDENT
            digits.rotate(1)
            if int("".join(digits)) not in primes :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            circular.append(prime)
        DEDENT
    DEDENT
    return circular
DEDENT
----------------------------------------

def circular_list(limit) :
INDENT
    circular_count = 0
    primes = set(exclude_primes(gen_primes(limit)))
    for prime in primes.copy() :
    INDENT
        digits = deque(prime)
        rotations = set()
        for rotation in range(len(digits)) :
        INDENT
            digits.rotate(1)
            rotations.add("".join(digits))
        DEDENT
        if rotations.issubset(primes) :
        INDENT
            circular_count += len(rotations)
        DEDENT
        primes.difference_update(rotations)
    DEDENT
    return circular_count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3728577_3728635_11_18
3728577_3728635_27_33
Title: Python scoping and threading question 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        if not self.queueStream.empty() :
        INDENT
            print 'Handling tweet'
            self.handleNextTweet()
        DEDENT
        else :
        INDENT
            print 'No tweets, sleep for 1 second'
            time.sleep(1)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    i = 0
    while True :
    INDENT
        addToQueue(self.queueStream, i)
        i += 1
        time.sleep(random.randint(0, 2))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3730831_3730858_1_10
3730831_3731084_1_10
Title: Passing 'None' as function parameter (where parameter is a function) 
----------------------------------------

def sanity_check(b, true_func, false_func) :
INDENT
    if b :
    INDENT
        logfunc = log.debug
        execfunc = true_func
    DEDENT
    else :
    INDENT
        logfunc = log.warning
        execfunc = false_func
    DEDENT
    logfunc('exec: %s', execfunc.__name__)
    execfunc()
DEDENT
----------------------------------------

def sanity_check(test, name = 'undefined', ontrue = None, onfalse = None) :
INDENT
    if test :
    INDENT
        log.debug(name)
        if ontrue is not None :
        INDENT
            ontrue()
        DEDENT
    DEDENT
    else :
    INDENT
        log.warn(name)
        if onfalse is not None :
        INDENT
            onfalse()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37331346_37331958_56_76
37331346_37331958_79_85
Title: flask_restful not working with flask.ext.login's login_required decorator 
----------------------------------------

def get(self) :
INDENT
    api_key = request.args.get('api_key', '')
    username = request.args.get('username', '')
    if username == '' :
    INDENT
        abort(400, message = 'username was not provided')
    DEDENT
    if api_key == '' :
    INDENT
        abort(400, message = 'api key was not provided')
    DEDENT
    account = db.accounts.find_one({'username' : username, 'api_key' : api_key})
    if account :
    INDENT
        if account ['account_type'] == 'admin' :
        INDENT
            user = User(username, api_key, account ['_id'])
            login_user(user)
            return {'auth' : 'successful', 'status_code' : 200}, 200
        DEDENT
        else :
        INDENT
            abort(401, message = 'you are not an admin')
        DEDENT
    DEDENT
    else :
    INDENT
        abort(401, message = 'could not auth account')

    DEDENT
DEDENT
----------------------------------------

def get(self) :
INDENT
    cron = CronTab(user = True)
    cronjobs = []
    for line in cron.lines :
    INDENT
        cronjobs.append(line)
    DEDENT
    return {'data' : cronjobs}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37341322_37341736_1_17
37341322_37343060_5_18
Title: Python xlsx to csv 
----------------------------------------

def xls_to_csv(xls_filename, csv_filename) :
INDENT
    wb = xlrd.open_workbook(xls_filename)
    sh = wb.sheet_by_index(0)
    with open(csv_filename, "wb") as fh :
    INDENT
        csv_out = unicodecsv.writer(fh, encoding = 'utf-8', delimiter = ';')
        for row_number in range(1, sh.nrows) :
        INDENT
            row = []
            for col in sh.row_values(row_number) :
            INDENT
                try :
                INDENT
                    row.append(col.strip('"'))
                DEDENT
                except AttributeError :
                INDENT
                    row.append(col)
                DEDENT
            DEDENT
            csv_out.writerow(row)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def xls_to_csv(xls_filename, csv_filename) :
INDENT
    wb = xlrd.open_workbook(xls_filename)
    sh = wb.sheet_by_index(0)
    fh = open(csv_filename, "wb")
    csv_out = unicodecsv.writer(fh, encoding = 'utf-8', delimiter = ';')
    for row_number in range(1, sh.nrows) :
    INDENT
        row = []
        row = [s.replace('"', '') for s in sh.row_values(row_number)]
        csv_out.writerow(row)
    DEDENT
    fh.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37375840_37376081_74_87
37375840_37376086_1_12
Title: Python matplotlib animating the path of an object 
----------------------------------------

def animate(i) :
INDENT
    global foox, fooy, foo
    thisx = [0, x [i]]
    thisy = [0, y [i]]
    foox += [x [i]]
    fooy += [y [i]]
    line.set_data(thisx, thisy)

    time_text.set_text(time_template % (i * dt))
    return line, time_text
DEDENT
----------------------------------------

def animate(i) :
INDENT
    thisx = [0, x [i]]
    thisy = [0, y [i]]
    foox.append(x [i])
    fooy.append(y [i])
    line.set_data(thisx, thisy)
    foo.set_data(foox, fooy)
    time_text.set_text(time_template % (i * dt))
    return line, time_text, foo
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3741581_3741757_3_14
3741581_3741785_1_16
Title: Slower search when start character is given is counterintuitive 
----------------------------------------

def main() :
INDENT
    line = r'I do not start with an underscore 123456789012345678901234567890'
    p1 = re.compile(r"_")
    p2 = re.compile(r"abcdefghijklmnopqrstuvwxyz")
    patterns = (p1, p2)
    for p in patterns :
    INDENT
        start = time()
        for i in xrange(1000 * 1000) :
        INDENT
            match = p.match(line)
        DEDENT
        end = time()
        print 'Elapsed: ' + str(end - start)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    line = r'I do not start with an underscore 123456789012345678901234567890'
    p1 = re.compile(r"_.*")
    p2 = re.compile(r"abcdefghijklmnopqrstuvwxyz")
    patterns = (p1, p2)
    start = time()
    for i in xrange(1000 * 1000) :
    INDENT
        match = re.match(p1, line)
    DEDENT
    end = time()
    print 'Elapsed: ' + str(end - start)
    start = time()
    for i in xrange(1000 * 1000) :
    INDENT
        match = re.search(p2, line)
    DEDENT
    end = time()
    print 'Elapsed: ' + str(end - start)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37437101_42007731_12_29
37437101_42007731_37_51
Title: Python: Change Color of frame root.configure(background='red') don't work 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "GUi")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    F1.config()
    self.frames = {}
    for F in (StartPage, PageOne) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.config(bg = "black")
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    ttk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "GUI", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button = ttk.Button(self, text = "Visit Page One",
        command = lambda : controller.show_frame(PageOne))

    button2 = ttk.Button(self, text = "Ok",
        command = lambda : controller.label2)
    button.pack()
    button2.pack()

DEDENT
----------------------------------------
