$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1904351_1925836_9_15
1904351_27315715_16_19
Title: "Python Observer Pattern: Examples Tips?" 
----------------------------------------

def fire(self, ** attrs) :
INDENT
    e = Event()
    e.source = self
    for k, v in attrs.iteritems() :
    INDENT
        setattr(e, k, v)
    DEDENT
    for fn in self.callbacks :
    INDENT
        fn(e)
    DEDENT
DEDENT
----------------------------------------

def fire(self) :
INDENT
    for observer in Observer._observers :
    INDENT
        if self.name in observer._observables :
        INDENT
            observer._observables [self.name](self.data)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1904351_1926336_6_12
1904351_23668721_82_96
Title: "Python Observer Pattern: Examples Tips?" 
----------------------------------------

def __get__(self, obj, cls) :
INDENT
    try :
    INDENT
        return obj.__dict__ [self._key]
    DEDENT
    except KeyError, exc :
    INDENT
        be = obj.__dict__ [self._key] = boundevent()
        return be
    DEDENT
DEDENT
----------------------------------------

def __get__(self, inst, cls) :
INDENT
    if inst is None :
    INDENT
        return self
    DEDENT
    ID = id(inst)
    if ID in self.instances :
    INDENT
        wr, om = self.instances [ID]
        if not wr() :
        INDENT
            msg = "Object id %d should have been cleaned up" % (ID,)
            raise RuntimeError(msg)
        DEDENT
    DEDENT
    else :
    INDENT
        wr = weakref.ref(inst, Cleanup(ID, self.instances))
        om = ObservableMethod(inst, self._func)
        self.instances [ID] = (wr, om)
    DEDENT
    return om
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19058022_19078309_48_56
19058022_19078309_6_20
Title: Why is Surface.unlock failing to unlock the surface for blitting? 
----------------------------------------

def __init__(self, rect) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.rect = rect
    self.image = pygame.Surface((rect.width, rect.height), SRCALPHA)
    self.image.convert_alpha()
    self.image.fill((126, 126, 126))

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    self.width, self.height = 800, 800
    pygame.display.set_caption("Surfarray test")
    self.screen = pygame.display.set_mode((self.width, self.height))
    self.background = pygame.Surface((self.width, self.height))
    self.background.fill((255, 255, 255))
    self.background.convert()
    self.bar = pygame.Surface((200, 100))
    self.bar.fill((255, 0, 0))
    self.bar.convert()
    self.sprite = pygame.sprite.GroupSingle()
    self.sprite.add(CustomSprite(pygame.Rect(5, 5, 100, 100)))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19087515_19099802_21_27
19087515_19099802_4_19
Title: Subclassing Tkinter to create a custom Widget 
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self, parent)
    self.scrolled_text = ScrolledText(self)
    self.scrolled_text.pack(side = "top", fill = "both", expand = True)
    with open(__file__, "r") as f :
    INDENT
        self.scrolled_text.insert("1.0", f.read())
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, parent)
    self.text = tk.Text(self, * args, ** kwargs)
    self.vsb = tk.Scrollbar(self, orient = "vertical", command = self.text.yview)
    self.text.configure(yscrollcommand = self.vsb.set)
    self.vsb.pack(side = "right", fill = "y")
    self.text.pack(side = "left", fill = "both", expand = True)

    self.insert = self.text.insert
    self.delete = self.text.delete
    self.mark_set = self.text.mark_set
    self.get = self.text.get
    self.index = self.text.index
    self.search = self.text.search
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1908878_1909355_3_14
1908878_27767560_3_13
Title: Netcat implementation in Python 
----------------------------------------

def netcat(hostname, port, content) :
INDENT
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((hostname, port))
    s.sendall(content)
    s.shutdown(socket.SHUT_WR)
    while 1 :
    INDENT
        data = s.recv(1024)
        if data == "" :
        INDENT
            break
        DEDENT
        print "Received:", repr(data)
    DEDENT
    print "Connection closed."
    s.close()
DEDENT
----------------------------------------

def netcat(host, port, content) :
INDENT
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, int(port)))
    s.sendall(content.encode())
    s.shutdown(socket.SHUT_WR)
    while True :
    INDENT
        data = s.recv(4096)
        if not data :
        INDENT
            break
        DEDENT
        print (repr(data))
    DEDENT
    s.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19106623_19107446_3_9
19106623_20304752_1_23
Title: PigLatin translator for words starting with multiple consonants[Python] 
----------------------------------------

def pigLatin(word) :
INDENT
    if isvowel(word [0]) :
    INDENT
        return word + "hay"
    DEDENT
    else :
    INDENT
        first_vowel_position = get_first_vowel_position(word)
        return word [first_vowel_position :] + word [: first_vowel_position] + "ay"
    DEDENT
DEDENT
----------------------------------------

def pigLatin(aString) :
INDENT
    index = 0
    stringLength = len(aString)
    consonants = ''

    if isVowel(aString [index]) :
    INDENT
        return aString + 'way'
    DEDENT
    else :
    INDENT

        consonants += aString [index]
        index += 1

        while index < stringLength :
        INDENT
            if isVowel(aString [index]) :
            INDENT
                return aString [index : stringLength] + consonants + 'ay'
            DEDENT
            else :
            INDENT
                consonants += aString [index]
                index += 1
            DEDENT
        DEDENT
        return 'This word does contain any vowels.'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19109068_19117637_5_23
19109068_19117831_3_22
Title: Nesting sizers within a box using wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.mainBox = wx.StaticBox(self, id = - 1, label = "Box Label")
    self.mainSizer = wx.StaticBoxSizer(self.mainBox, wx.VERTICAL)
    labels = ["A: ", "B: ", "C: "]
    for i, label in enumerate(labels) :
    INDENT
        itemLabel = wx.StaticText(self, label = label)
        itemTextCtrl = wx.TextCtrl(self, value = "placeholder")
        itemTextCtrl.SetForegroundColour(wx.LIGHT_GREY)
        rowSizer = wx.BoxSizer(wx.HORIZONTAL)
        rowSizer.Add(itemLabel, 0, wx.ALL, 0)
        rowSizer.Add(itemTextCtrl, 0, wx.ALL, 0)
        self.mainSizer.Add(rowSizer)
    DEDENT
    self.SetSizer(self.mainSizer)
    self.mainSizer.Fit(self)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.mainBox = wx.StaticBox(self, label = "Box Label")
    self.boxSizer = wx.StaticBoxSizer(self.mainBox, wx.VERTICAL)
    labels = ["A: ", "B: ", "C: "]
    for label in labels :
    INDENT
        itemLabel = wx.StaticText(self, label = label)
        itemTextCtrl = wx.TextCtrl(self, value = "placeholder")
        itemTextCtrl.SetForegroundColour(wx.LIGHT_GREY)
        rowSizer = wx.BoxSizer(wx.HORIZONTAL)
        rowSizer.Add(itemLabel, 0, wx.ALL, 2)
        rowSizer.Add(itemTextCtrl, 0, wx.ALL, 2)
        self.boxSizer.Add(rowSizer)
    DEDENT
    pSizer = wx.BoxSizer(wx.VERTICAL)
    pSizer.Add(self.boxSizer, 0, wx.ALL, 7)
    self.SetSizer(pSizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19120775_19121127_1_11
19120775_19122182_20_30
Title: Python -- Ancient Taxation 
----------------------------------------

def tax(income) :
INDENT
    tax = 0;
    if income > 70000 :
    INDENT
        tax += (income - 70000) * 0.3
        income = 70000
    DEDENT
    if income > 30000 :
    INDENT
        tax += (income - 30000) * 0.2
        income = 30000
    DEDENT
    if income > 10000 :
    INDENT
        tax += (income - 10000) * 0.1
    DEDENT
    return tax;
DEDENT
----------------------------------------

def tax(income, brackets) :
INDENT
    '''Calculates income taxes based on provided income and tax brackets.'''
    total_tax = 0
    for (lower, higher, rate) in brackets :
    INDENT
        total_tax += tax_on_bracket(income, lower, higher, rate)
    DEDENT
    return total_tax

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19129212_19129256_1_10
19129212_19129284_1_7
Title: Python function not returning correct output 
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    keys = dictionary.keys()
    for i in keys :
    INDENT
        if i == key :
        INDENT
            dictionary [key] = newValue
        DEDENT
    DEDENT
    return dictionary

DEDENT
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    if key in dictionary :
    INDENT
        dictionary [key] = newValue
        return dictionary
    DEDENT
    else :
    INDENT
        return 'Nothing'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19129212_19129256_1_10
19129212_19129534_1_12
Title: Python function not returning correct output 
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    keys = dictionary.keys()
    for i in keys :
    INDENT
        if i == key :
        INDENT
            dictionary [key] = newValue
        DEDENT
    DEDENT
    return dictionary

DEDENT
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    keys = dictionary.keys()
    print 'keys:', keys
    for i in keys :
    INDENT
        print 'i:', i, 'i == key:', i == key
        if i == key :
        INDENT
            print dictionary [key]
            dictionary [key] = newValue
            return
        DEDENT
        else :
        INDENT
            return "Nothing"
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19129212_19129256_1_10
19129212_19130271_1_10
Title: Python function not returning correct output 
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    keys = dictionary.keys()
    for i in keys :
    INDENT
        if i == key :
        INDENT
            dictionary [key] = newValue
        DEDENT
    DEDENT
    return dictionary

DEDENT
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    keys = dictionary.keys()
    for i in keys :
    INDENT
        if i == key :
        INDENT
            print dictionary [key]
            dictionary [key] = newValue
            return
        DEDENT
    DEDENT
    else :
    INDENT
        return "Nothing"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19129212_19129284_1_7
19129212_19129534_1_12
Title: Python function not returning correct output 
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    if key in dictionary :
    INDENT
        dictionary [key] = newValue
        return dictionary
    DEDENT
    else :
    INDENT
        return 'Nothing'
    DEDENT
DEDENT
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    keys = dictionary.keys()
    print 'keys:', keys
    for i in keys :
    INDENT
        print 'i:', i, 'i == key:', i == key
        if i == key :
        INDENT
            print dictionary [key]
            dictionary [key] = newValue
            return
        DEDENT
        else :
        INDENT
            return "Nothing"
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19129212_19129284_1_7
19129212_19130271_1_10
Title: Python function not returning correct output 
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    if key in dictionary :
    INDENT
        dictionary [key] = newValue
        return dictionary
    DEDENT
    else :
    INDENT
        return 'Nothing'
    DEDENT
DEDENT
----------------------------------------

def fetchAndReplace(dictionary, key, newValue) :
INDENT
    keys = dictionary.keys()
    for i in keys :
    INDENT
        if i == key :
        INDENT
            print dictionary [key]
            dictionary [key] = newValue
            return
        DEDENT
    DEDENT
    else :
    INDENT
        return "Nothing"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1913722_18814649_4_19
1913722_5419368_4_39
Title: wxPython controls not clickable 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, 'not-clickable')
    self.panel = wx.Panel(self)
    button = wx.Button(self.panel, - 1, "Can't click me")
    sttBox = wx.StaticBox(self.panel, - 1, "Created after button")
    sizer = wx.StaticBoxSizer(sttBox, wx.HORIZONTAL)
    sizer.Add(button)
    self.panel.SetSizerAndFit(sizer)
    self.Centre()
    self.Fit()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, * args, ** kwargs)
    self.panel = wx.Panel(self)
    self.label1 = wx.StaticText(self.panel)
    self.fileCtrl = wx.FilePickerCtrl(self.panel)
    self.mailRadio = wx.RadioButton(self.panel)
    self.uploadRadio = wx.RadioButton(self.panel)
    row1 = wx.StaticBoxSizer(wx.StaticBox(self.panel, - 1, 'this is row one'), orient = wx.HORIZONTAL)
    row1.Add(self.label1, 0, wx.TOP | wx.RIGHT, 7)
    row1.Add(self.fileCtrl)
    row2 = wx.BoxSizer(wx.HORIZONTAL)
    actionBox = wx.StaticBoxSizer(wx.StaticBox(self.panel, - 1, 'asdfasdf'), orient = wx.VERTICAL)
    actionRow1 = wx.BoxSizer(wx.HORIZONTAL)
    actionRow1.Add(wx.StaticText(self.panel, - 1, 'blah blah ', (5, 5)))
    actionRow1.Add(self.mailRadio)
    actionRow2 = wx.BoxSizer(wx.HORIZONTAL)
    actionRow2.Add(wx.StaticText(self.panel, - 1, 'lah dee dah', (5, 5)))
    actionRow2.Add(self.uploadRadio, 5)
    actionBox.Add(actionRow1, 0, wx.EXPAND)
    actionBox.Add(actionRow2)
    row2.Add(actionBox)
    wrapper = wx.FlexGridSizer(2, 1, 5, 5)
    wrapper.AddGrowableCol(0)
    wrapper.Add(row1, 0, wx.TOP | wx.LEFT | wx.RIGHT | wx.ALIGN_CENTER, 15)
    wrapper.Add(row2, 0, wx.ALL | wx.ALIGN_CENTER, 15)
    self.panel.SetSizerAndFit(wrapper)
    self.Centre()
    self.Fit()
    self.Show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19144554_19145411_4_12
19144554_19145473_4_11
Title: python: integrating a piecewise function 
----------------------------------------

def f(x) :
INDENT
    if 0 < = x < = 1 :
    INDENT
        return 1
    DEDENT
    if - 1 < = x < = 0 :
    INDENT
        return - 1

    DEDENT
DEDENT
----------------------------------------

def f(x, coef) :
INDENT
    n = coef [- 1]
    p = (2 * n + 1) / 2.* np.polynomial.legendre.Legendre(coef = coef)
    if 0 < = x < = 1 :
    INDENT
        return 1 * p(x)
    DEDENT
    if - 1 < = x < = 0 :
    INDENT
        return - 1 * p(x)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1916953_2258426_2_18
1916953_3034230_2_24
Title: Filter zipcodes by proximity in Django with the Spherical Law of Cosines 
----------------------------------------

def nearby_locations(self, latitude, longitude, radius, max_results = 100, use_miles = True) :
INDENT
    if use_miles :
    INDENT
        distance_unit = 3959
    DEDENT
    else :
    INDENT
        distance_unit = 6371
    DEDENT
    from django.db import connection, transaction
    cursor = connection.cursor()
    sql = """SELECT id, (%f * acos( cos( radians(%f) ) * cos( radians( latitude ) ) *
        cos( radians( longitude ) - radians(%f) ) + sin( radians(%f) ) * sin( radians( latitude ) ) ) )
        AS distance FROM locations_location HAVING distance < %d
        ORDER BY distance LIMIT 0 , %d;""" % (distance_unit, latitude, longitude, latitude, int(radius), max_results)
    cursor.execute(sql)
    ids = [row [0] for row in cursor.fetchall()]
    return self.filter(id__in = ids)
DEDENT
----------------------------------------

def nearby_locations(self, latitude, longitude, radius, max_results = 100, use_miles = True) :
INDENT
    if use_miles :
    INDENT
        distance_unit = 3959
    DEDENT
    else :
    INDENT
        distance_unit = 6371
    DEDENT
    from django.db import connection, transaction
    from mysite import settings
    cursor = connection.cursor()
    if settings.DATABASE_ENGINE == 'sqlite3' :
    INDENT
        connection.connection.create_function('acos', 1, math.acos)
        connection.connection.create_function('cos', 1, math.cos)
        connection.connection.create_function('radians', 1, math.radians)
        connection.connection.create_function('sin', 1, math.sin)
    DEDENT
    sql = """SELECT id, (%f * acos( cos( radians(%f) ) * cos( radians( latitude ) ) *
        cos( radians( longitude ) - radians(%f) ) + sin( radians(%f) ) * sin( radians( latitude ) ) ) )
        AS distance FROM location_location WHERE distance < %d
        ORDER BY distance LIMIT 0 , %d;""" % (distance_unit, latitude, longitude, latitude, int(radius), max_results)
    cursor.execute(sql)
    ids = [row [0] for row in cursor.fetchall()]
    return self.filter(id__in = ids)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1916953_3034230_2_24
1916953_4523820_8_22
Title: Filter zipcodes by proximity in Django with the Spherical Law of Cosines 
----------------------------------------

def nearby_locations(self, latitude, longitude, radius, max_results = 100, use_miles = True) :
INDENT
    if use_miles :
    INDENT
        distance_unit = 3959
    DEDENT
    else :
    INDENT
        distance_unit = 6371
    DEDENT
    from django.db import connection, transaction
    from mysite import settings
    cursor = connection.cursor()
    if settings.DATABASE_ENGINE == 'sqlite3' :
    INDENT
        connection.connection.create_function('acos', 1, math.acos)
        connection.connection.create_function('cos', 1, math.cos)
        connection.connection.create_function('radians', 1, math.radians)
        connection.connection.create_function('sin', 1, math.sin)
    DEDENT
    sql = """SELECT id, (%f * acos( cos( radians(%f) ) * cos( radians( latitude ) ) *
        cos( radians( longitude ) - radians(%f) ) + sin( radians(%f) ) * sin( radians( latitude ) ) ) )
        AS distance FROM location_location WHERE distance < %d
        ORDER BY distance LIMIT 0 , %d;""" % (distance_unit, latitude, longitude, latitude, int(radius), max_results)
    cursor.execute(sql)
    ids = [row [0] for row in cursor.fetchall()]
    return self.filter(id__in = ids)
DEDENT
----------------------------------------

def nearby_locations(self, latitude, longitude, radius, use_miles = False) :
INDENT
    if use_miles :
    INDENT
        distance_unit = 3959
    DEDENT
    else :
    INDENT
        distance_unit = 6371
    DEDENT
    cursor = connection.cursor()
    sql = """SELECT id, latitude, longitude FROM locations_location WHERE (%f * acos( cos( radians(%f) ) * cos( radians( latitude ) ) *
            cos( radians( longitude ) - radians(%f) ) + sin( radians(%f) ) * sin( radians( latitude ) ) ) ) < %d
            """ % (distance_unit, latitude, longitude, latitude, int(radius))
    cursor.execute(sql)
    ids = [row [0] for row in cursor.fetchall()]
    return self.filter(id__in = ids)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1918420_1924950_14_28
1918420_24135933_15_29
Title: split a pdf based on outline 
----------------------------------------

def _setup_page_id_to_num(pages = None, _result = None, _num_pages = None) :
INDENT
    if _result is None :
    INDENT
        _result = {}
    DEDENT
    if pages is None :
    INDENT
        _num_pages = []
        pages = self.trailer ["/Root"].getObject() ["/Pages"].getObject()
    DEDENT
    t = pages ["/Type"]
    if t == "/Pages" :
    INDENT
        for page in pages ["/Kids"] :
        INDENT
            _result [page.idnum] = len(_num_pages)
            _setup_page_id_to_num(page.getObject(), _result, _num_pages)
        DEDENT
    DEDENT
    elif t == "/Page" :
    INDENT
        _num_pages.append(1)
    DEDENT
    return _result
DEDENT
----------------------------------------

def _setup_page_id_to_num(pages = None, _result = None, _num_pages = None) :
INDENT
    if _result is None :
    INDENT
        _result = {}
    DEDENT
    if pages is None :
    INDENT
        _num_pages = []
        pages = self.trailer ["/Root"].getObject() ["/Pages"].getObject()
    DEDENT
    t = pages ["/Type"]
    if t == "/Pages" :
    INDENT
        for page in pages ["/Kids"] :
        INDENT
            _result [page.idnum] = len(_num_pages)
            _setup_page_id_to_num(page.getObject(), _result, _num_pages)
        DEDENT
    DEDENT
    elif t == "/Page" :
    INDENT
        _num_pages.append(1)
    DEDENT
    return _result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1918420_1924950_4_13
1918420_24135933_5_14
Title: split a pdf based on outline 
----------------------------------------

def _setup_outline_page_ids(outline, _result = None) :
INDENT
    if _result is None :
    INDENT
        _result = {}
    DEDENT
    for obj in outline :
    INDENT
        if isinstance(obj, pyPdf.pdf.Destination) :
        INDENT
            _result [(id(obj), obj.title)] = obj.page.idnum
        DEDENT
        elif isinstance(obj, list) :
        INDENT
            _setup_outline_page_ids(obj, _result)
        DEDENT
    DEDENT
    return _result
DEDENT
----------------------------------------

def _setup_outline_page_ids(outline, _result = None) :
INDENT
    if _result is None :
    INDENT
        _result = {}
    DEDENT
    for obj in outline :
    INDENT
        if isinstance(obj, pyPdf.pdf.Destination) :
        INDENT
            _result [(id(obj), obj.title)] = obj.page.idnum
        DEDENT
        elif isinstance(obj, list) :
        INDENT
            _setup_outline_page_ids(obj, _result)
        DEDENT
    DEDENT
    return _result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19193934_20418084_29_56
19193934_26490794_34_57
Title: Python memcache consistent hashing using ketama 
----------------------------------------

def _get_server(self, key) :
INDENT
    if self.hash_algorithm == 'ketama' :
    INDENT
        """ Basic concept of the Implementation of ketama algorithm
            e.g. ring = {100:server1, 110:server2, 120:server3, 140:server4}
            If the hash of the current key is 105, it server will be the next
            bigger integer in the ring which is 110 (server2)
            If a server is added on position 108 the key will be now allocated
            to it and not to server 110. Otherwise if the server on position
            110 is removed the key will now belong to de server 120.
            If there's no bigger integer position in the ring then the hash of
            the key, it will take the first server from the ring.
            """

        servers_generator = self.consistent_hash_manager.get_nodes(key)
        for server in servers_generator :
        INDENT
            if server.connect() :
            INDENT
                return server, key
            DEDENT
        DEDENT
        return None, None
    DEDENT
    else :
    INDENT
        return super(MemcacheClient, self)._get_server(key)
    DEDENT
DEDENT
----------------------------------------

def _get_server(self, key) :
INDENT
    h_key = self._generate_ring_slot(key)
    for slot in self._ketama_server_slots :
    INDENT
        if h_key < = slot :
        INDENT
            server = self._ketama_server_ring [slot]
            if server.connect() :
            INDENT
                return (server, key)

            DEDENT
        DEDENT
    DEDENT
    server = self._ketama_server_ring [self._ketama_server_slots [0]] if self._ketama_server_slots else None
    server and server.connect()
    return server, key
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19193934_20418084_57_89
19193934_26490794_58_73
Title: Python memcache consistent hashing using ketama 
----------------------------------------

def add_server(self, server) :
INDENT
    """
        if not self.consistent_hash_manager:
            raise Exception("The current consistent hash algorithm (\"%s\") is"
                            " not reliable for adding a new server"
                            "" % self.hash_algorithm)
        """

    server = memcache._Host(
        server, self.debug, dead_retry = self.dead_retry,
        socket_timeout = self.socket_timeout,
        flush_on_reconnect = self.flush_on_reconnect)
    self.servers.append(server)
    """This for statement will ensure that a server with a bigger weight
        will have more copies into the buckets increasing it's probability to
        be retrieved.
        """
    for i in range(server.weight) :
    INDENT
        self.buckets.append(server)

    DEDENT
    if self.consistent_hash_manager :
    INDENT
        self.consistent_hash_manager.add_node(server)
    DEDENT
DEDENT
----------------------------------------

def add_server(self, server) :
INDENT
    server_obj = memcache._Host(
        server if isinstance(server, tuple) else (
            server, self.DEFAULT_SERVER_WEIGHT),
        self.debug, dead_retry = self.dead_retry,
        socket_timeout = self.socket_timeout,
        flush_on_reconnect = self.flush_on_reconnect)
    self._place_server_on_ring(server_obj)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19204131_19204143_2_28
19204131_19204145_1_18
Title: Infinite loop in python 
----------------------------------------

def main() :
INDENT
    score = 0
    count = 0

    roll = randrange(1, 7,) + randrange(1, 7,)

    while roll ! = 7 :
    INDENT

        count += 1

        score += roll

        roll = randrange(1, 7,) + randrange(1, 7,)
    DEDENT
    print count
    print score
DEDENT
----------------------------------------

def main() :
INDENT
    dice1 = randrange(1, 7,)
    dice2 = randrange(1, 7,)
    roll = dice1 + dice2
    score = 0
    count = 0
    while roll ! = 7 :
    INDENT
        count = count + 1
        score = score + roll
        if roll == 7 :
        INDENT
            break
        DEDENT
        dice1 = randrange(1, 7,)
        dice2 = randrange(1, 7,)
        roll = dice1 + dice2
    DEDENT
    print count
    print score
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19235747_19236438_1_21
19235747_25510441_1_23
Title: Python Quickselect not printing/returning pivot 
----------------------------------------

def quickSelect(lst, k) :
INDENT
    if len(lst) ! = 0 :
    INDENT
        pivot = lst [(len(lst)) / / 2]
        smallerList = []
        for i in lst :
        INDENT
            if i < pivot :
            INDENT
                smallerList.append(i)
            DEDENT
        DEDENT
        largerList = []
        for i in lst :
        INDENT
            if i > pivot :
            INDENT
                largerList.append(i)
            DEDENT
        DEDENT
        count = len(lst) - len(smallerList) - len(largerList)
        m = len(smallerList)
        if k > = m and k < m + count :
        INDENT
            return pivot
            print (pivot)
        DEDENT
        elif m > k :
        INDENT
            return quickSelect(smallerList, k)
        DEDENT
        else :
        INDENT
            return quickSelect(largerList, k - m - count)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def quickSelect(seq, k) :
INDENT
    len_seq = len(seq)
    if len_seq < 2 : return seq
    ipivot = len_seq / / 2
    pivot = seq [ipivot]
    smallerList = [x for i, x in enumerate(seq) if x < = pivot and i ! = ipivot]
    largerList = [x for i, x in enumerate(seq) if x > pivot and i ! = ipivot]

    m = len(smallerList)
    if k == m :
    INDENT
        return pivot
    DEDENT
    elif k < m :
    INDENT
        return quickSelect(smallerList, k)
    DEDENT
    else :
    INDENT
        return quickSelect(largerList, k - m - 1)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19246643_19247651_1_18
19246643_19794036_3_14
Title: How do I force Django to connect to Oracle using Service Name 
----------------------------------------

def _connect_string(self) :
INDENT
    settings_dict = self.settings_dict
    if not settings_dict ['HOST'].strip() :
    INDENT
        settings_dict ['HOST'] = 'localhost'
    DEDENT
    if settings_dict ['PORT'].strip() :
    INDENT
        if not 'SERVICE_NAME' in settings_dict :
        INDENT
            dsn = Database.makedsn(settings_dict ['HOST'],
                int(settings_dict ['PORT']),
                settings_dict ['NAME'])
        DEDENT
        else :
        INDENT
            dsn = Database.makedsn(host = settings_dict ['HOST'],
                port = int(settings_dict ['PORT']),
                service_name = settings_dict ['SERVICE_NAME'].strip())
        DEDENT
    DEDENT
    else :
    INDENT
        dsn = settings_dict ['NAME']
    DEDENT
    return "%s/%s@%s" % (settings_dict ['USER'],
        settings_dict ['PASSWORD'], dsn)
DEDENT
----------------------------------------

def _connect_string(self) :
INDENT
    settings_dict = self.settings_dict
    if not settings_dict ['HOST'].strip() :
    INDENT
        settings_dict ['HOST'] = 'localhost'
    DEDENT
    if settings_dict ['PORT'].strip() :
    INDENT
        dsn = Database.makedsn(settings_dict ['HOST'],
            int(settings_dict ['PORT']),
            settings_dict ['NAME'])
    DEDENT
    else :
    INDENT
        dsn = settings_dict ['NAME']
    DEDENT
    return "%s/%s@%s" % (settings_dict ['USER'],
        settings_dict ['PASSWORD'], dsn)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1925635_1925664_1_10
1925635_1925664_2_7
Title: Handling an exception in another thread 
----------------------------------------

def safer(func) :
INDENT
    def safer(* args, ** kwargs) :
    INDENT
        try :
        INDENT
            return func(* args, ** kwargs)
        DEDENT
        except Exception, e :
        INDENT
            print "Couldn't call", func
        DEDENT
    DEDENT
    return safer

DEDENT
----------------------------------------

def safer(* args, ** kwargs) :
INDENT
    try :
    INDENT
        return func(* args, ** kwargs)
    DEDENT
    except Exception, e :
    INDENT
        print "Couldn't call", func
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19297350_19297984_25_38
19297350_19297984_40_55
Title: wxpython panel size and titles 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.tittle2 = wx.StaticText(self, label = "Outputs:")
    self.lblname3 = wx.StaticText(self, label = "Output1")
    self.result3 = wx.StaticText(self, label = "", size = (100, - 1))

    self.sizer = wx.GridBagSizer(2, 2)
    self.sizer.Add(self.tittle2, (1, 2))
    self.sizer.Add(self.lblname3, (2, 1))
    self.sizer.Add(self.result3, (2, 2))
    self.SetSizer(self.sizer)
DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (800, 600))

    self.splitter = wx.SplitterWindow(self, style = wx.SP_LIVE_UPDATE)
    self.panel1 = Input_Panel(self.splitter)
    self.panel2 = Output_Panel(self.splitter)
    self.splitter.SplitVertically(self.panel1, self.panel2)
    w, h = self.GetSize()
    self.splitter.SetMinimumPaneSize(w / 2)
    self.windowSizer = wx.BoxSizer(wx.VERTICAL)
    self.windowSizer.Add(self.splitter, 1, wx.ALL | wx.EXPAND)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19297350_19297984_25_38
19297350_19297984_4_23
Title: wxpython panel size and titles 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.tittle2 = wx.StaticText(self, label = "Outputs:")
    self.lblname3 = wx.StaticText(self, label = "Output1")
    self.result3 = wx.StaticText(self, label = "", size = (100, - 1))

    self.sizer = wx.GridBagSizer(2, 2)
    self.sizer.Add(self.tittle2, (1, 2))
    self.sizer.Add(self.lblname3, (2, 1))
    self.sizer.Add(self.result3, (2, 2))
    self.SetSizer(self.sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.tittle1 = wx.StaticText(self, label = "Inputs:")
    self.lblname1 = wx.StaticText(self, label = "Input 1:")
    self.format1 = ['Option 1', 'Option 2']
    self.combo1 = wx.ComboBox(self, size = (200, - 1), value = '', choices = self.format1, style = wx.CB_DROPDOWN)
    self.lblname2 = wx.StaticText(self, label = "Input 2")
    self.format2 = ['Option 1', 'Option 2', 'Option 3']
    self.combo2 = wx.ComboBox(self, size = (200, - 1), value = '', choices = self.format2, style = wx.CB_DROPDOWN)

    self.sizer = wx.GridBagSizer(2, 2)
    self.sizer.Add(self.tittle1, (1, 2))
    self.sizer.Add(self.lblname1, (2, 1))
    self.sizer.Add(self.combo1, (2, 2))
    self.sizer.Add(self.lblname2, (3, 1))
    self.sizer.Add(self.combo2, (3, 2))
    self.SetSizer(self.sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19297350_19297984_40_55
19297350_19297984_4_23
Title: wxpython panel size and titles 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (800, 600))

    self.splitter = wx.SplitterWindow(self, style = wx.SP_LIVE_UPDATE)
    self.panel1 = Input_Panel(self.splitter)
    self.panel2 = Output_Panel(self.splitter)
    self.splitter.SplitVertically(self.panel1, self.panel2)
    w, h = self.GetSize()
    self.splitter.SetMinimumPaneSize(w / 2)
    self.windowSizer = wx.BoxSizer(wx.VERTICAL)
    self.windowSizer.Add(self.splitter, 1, wx.ALL | wx.EXPAND)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.tittle1 = wx.StaticText(self, label = "Inputs:")
    self.lblname1 = wx.StaticText(self, label = "Input 1:")
    self.format1 = ['Option 1', 'Option 2']
    self.combo1 = wx.ComboBox(self, size = (200, - 1), value = '', choices = self.format1, style = wx.CB_DROPDOWN)
    self.lblname2 = wx.StaticText(self, label = "Input 2")
    self.format2 = ['Option 1', 'Option 2', 'Option 3']
    self.combo2 = wx.ComboBox(self, size = (200, - 1), value = '', choices = self.format2, style = wx.CB_DROPDOWN)

    self.sizer = wx.GridBagSizer(2, 2)
    self.sizer.Add(self.tittle1, (1, 2))
    self.sizer.Add(self.lblname1, (2, 1))
    self.sizer.Add(self.combo1, (2, 2))
    self.sizer.Add(self.lblname2, (3, 1))
    self.sizer.Add(self.combo2, (3, 2))
    self.SetSizer(self.sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19328381_19328657_8_31
19328381_19328927_6_10
Title: Objects/classes/lists Python 
----------------------------------------

def main() :
INDENT
    people = []
    filename = 'yob' + input('Enter year: ') + '.txt'
    for line in open(filename) :
    INDENT
        line = line.strip()
        fields = line.split(',')
        p = Person(fields [0], fields [1], int(fields [2]))
        people.append(p)

    DEDENT
    p_m = [p for p in people if p.gender == 'M']
    p_f = [p for p in people if p.gender == 'F']

    p_m = sorted(p_m, key = lambda x : - x.occurrences)
    p_f = sorted(p_f, key = lambda x : - x.occurrences)

    for p in p_m [: 20] :
    INDENT
        print p.name, p.gender, p.occurrences
    DEDENT
    for p in p_f [: 20] :
    INDENT
        print p.name, p.gender, p.occurrences
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    filename = 'yob' + input('Enter year: ') + '.txt'
    with open(filename, newlines = "") as f :
    INDENT
        reader = csv.reader(f)
        lst = [Person(* row) for row in reader]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19329542_19329747_1_15
19329542_19329757_3_21
Title: Is there a more pythonic way of combining duplicate objects in a list? 
----------------------------------------

def normalise_repeatable_options(options) :
INDENT
    parsed = []
    flat = defaultdict(list)
    for o in options :
    INDENT
        if isinstance(o, Option) :
        INDENT
            if o.long not in flat :
            INDENT
                parsed.append(o.long)
            DEDENT
            flat [o.long].append(o)
        DEDENT
        else :
        INDENT
            parsed.append(o)
        DEDENT
    DEDENT
    return [Option.combine(* tuple(flat [o])) if isinstance(o, str) else o for o in parsed]
DEDENT
----------------------------------------

def normalise_repeatable_options(options) :
INDENT
    actual_options = [o for o in options if isinstance(o, Option)]
    non_options = [o for o in options if not isinstance(o, Option)]
    flat = defaultdict(list)
    for o in actual_options :
    INDENT
        flat [o.long].append(o)
    DEDENT
    parsed = (
        non_options +
        [Option.combine(* tuple(dups)) for dup in flat.values() if len(dup) > 1] +
        [value [0] for value in flat.values() if len(value) == 1])
    return parsed
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19330773_19331726_19_31
19330773_19331726_40_82
Title: PyGame: Sprites won't move 
----------------------------------------

def __init__(self) :
INDENT
    self.x = 350
    self.y = 250
    self.dx = 0
    self.dy = 0
    self.width = 50
    self.height = 50
    self.sprite = temp_sprite("red")

    self.dead_sprite = None
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.wall = temp_sprite("blue")
    self.floor = temp_sprite("green")
    self.door = temp_sprite("brown")
    self.null_tile = temp_sprite("magenta")
    self.x = 0
    self.y = 0
    self.tile_height = 50
    self.tile_width = 50
    self.center_x = 400
    self.center_y = 300

    self.town = [
        [0, 0, 0, 0, 0, 0, 0, 1, 2, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 2, 2, 2, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
        [0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 0, 0, 0, 0, 0],
        [0, 1, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 1, 1, 0, 0, 0, 0, 0],
        [0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933619_3_17
1933564_1933630_3_17
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    key_to_collection = {
        "model.paramName" : names,
        "model.paramValue" : params,
        "model.optimizeParam" : optimize,
        "model.paramLowerBound" : upper,
        "model.paramUpperBound" : lower,
        }
    reg = re.compile(r'(.+?) (\d) (.+)')
    for line in lines :
    INDENT
        m = reg.match(line)
        key, digit, value = m.group(1, 2, 3)
        key_to_collection [key].append(value)
    DEDENT
DEDENT
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    sn = 'Names Params Optimize Upper Lower'.split()
    ks = '''paramName paramValue optimizeParam
          paramLowerBound paramUpperBound'''.split()
    vals = dict((k, []) for k in ks)
    are = re.compile(r'model\.(%s) (\d+) (.*)' % '|'.join(ks))
    for line in lines :
    INDENT
        mo = are.search(line)
        if not mo : continue
        p = int(mo.group(2))
        if p < 1 or p > num_of_params : continue
        vals [mo.group(1)].append(mo.group(3).rstrip())
    DEDENT
    for k, s in zip(ks, sn) :
    INDENT
        print '%-8s =' % s,
        print vals [k]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933619_3_17
1933564_1933673_3_31
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    key_to_collection = {
        "model.paramName" : names,
        "model.paramValue" : params,
        "model.optimizeParam" : optimize,
        "model.paramLowerBound" : upper,
        "model.paramUpperBound" : lower,
        }
    reg = re.compile(r'(.+?) (\d) (.+)')
    for line in lines :
    INDENT
        m = reg.match(line)
        key, digit, value = m.group(1, 2, 3)
        key_to_collection [key].append(value)
    DEDENT
DEDENT
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    pattern = re.compile(r"""
        model\.
        (.+)    # keyword
        (\d+)   # index to keyword
        [ ]+    # whitespace
        (.+)    # value
        """, re.VERBOSE)
    key_to_collection = {
        "paramName" : names,
        "paramValue" : params,
        "optimizeParam" : optimize,
        "paramLowerBound" : upper,
        "paramUpperBound" : lower,
        }
    for line in lines :
    INDENT
        match = pattern.match(line)
        if not match :
        INDENT
            print "Invalid line: " + line
        DEDENT
        elif match [1] not in key_to_collection :
        INDENT
            print "Invalid key: " + line
        DEDENT
        elif match [2] > num_of_params :
        INDENT
            print "Invalid param: " + line
        DEDENT
        else :
        INDENT
            key_to_collection [match [1]].append(match [3])
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933619_3_17
1933564_1933684_8_15
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    key_to_collection = {
        "model.paramName" : names,
        "model.paramValue" : params,
        "model.optimizeParam" : optimize,
        "model.paramLowerBound" : upper,
        "model.paramUpperBound" : lower,
        }
    reg = re.compile(r'(.+?) (\d) (.+)')
    for line in lines :
    INDENT
        m = reg.match(line)
        key, digit, value = m.group(1, 2, 3)
        key_to_collection [key].append(value)
    DEDENT
DEDENT
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    stmts = defaultdict(list)
    for m in (stmt_regex.match(s) for s in lines) :
    INDENT
        if m and 1 < = int(m.group(2)) < = num_of_params :
        INDENT
            stmts [m.group(1)].append(m.group(3).rstrip())
        DEDENT
    DEDENT
    for k, v in stmts.iteritems() :
    INDENT
        print "%s = %s" % (k, ' '.join(v))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933619_3_17
1933564_1933701_1_13
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    key_to_collection = {
        "model.paramName" : names,
        "model.paramValue" : params,
        "model.optimizeParam" : optimize,
        "model.paramLowerBound" : upper,
        "model.paramUpperBound" : lower,
        }
    reg = re.compile(r'(.+?) (\d) (.+)')
    for line in lines :
    INDENT
        m = reg.match(line)
        key, digit, value = m.group(1, 2, 3)
        key_to_collection [key].append(value)
    DEDENT
DEDENT
----------------------------------------

def parse_params(input) :
INDENT
    parameter_list = {}
    param = re.compile(r"model\.([^ ]+) [0-9]+ ([^ ]+)")
    each_parameter = param.finditer(input)
    for match in each_parameter :
    INDENT
        key = match [0]
        value = match [1]
        if not key in paramter_list :
        INDENT
            parameter_list [key] = []
        DEDENT
        parameter_list [key].append(value)
    DEDENT
    return parameter_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933630_3_17
1933564_1933673_3_31
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    sn = 'Names Params Optimize Upper Lower'.split()
    ks = '''paramName paramValue optimizeParam
          paramLowerBound paramUpperBound'''.split()
    vals = dict((k, []) for k in ks)
    are = re.compile(r'model\.(%s) (\d+) (.*)' % '|'.join(ks))
    for line in lines :
    INDENT
        mo = are.search(line)
        if not mo : continue
        p = int(mo.group(2))
        if p < 1 or p > num_of_params : continue
        vals [mo.group(1)].append(mo.group(3).rstrip())
    DEDENT
    for k, s in zip(ks, sn) :
    INDENT
        print '%-8s =' % s,
        print vals [k]
    DEDENT
DEDENT
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    pattern = re.compile(r"""
        model\.
        (.+)    # keyword
        (\d+)   # index to keyword
        [ ]+    # whitespace
        (.+)    # value
        """, re.VERBOSE)
    key_to_collection = {
        "paramName" : names,
        "paramValue" : params,
        "optimizeParam" : optimize,
        "paramLowerBound" : upper,
        "paramUpperBound" : lower,
        }
    for line in lines :
    INDENT
        match = pattern.match(line)
        if not match :
        INDENT
            print "Invalid line: " + line
        DEDENT
        elif match [1] not in key_to_collection :
        INDENT
            print "Invalid key: " + line
        DEDENT
        elif match [2] > num_of_params :
        INDENT
            print "Invalid param: " + line
        DEDENT
        else :
        INDENT
            key_to_collection [match [1]].append(match [3])
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933630_3_17
1933564_1933684_8_15
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    sn = 'Names Params Optimize Upper Lower'.split()
    ks = '''paramName paramValue optimizeParam
          paramLowerBound paramUpperBound'''.split()
    vals = dict((k, []) for k in ks)
    are = re.compile(r'model\.(%s) (\d+) (.*)' % '|'.join(ks))
    for line in lines :
    INDENT
        mo = are.search(line)
        if not mo : continue
        p = int(mo.group(2))
        if p < 1 or p > num_of_params : continue
        vals [mo.group(1)].append(mo.group(3).rstrip())
    DEDENT
    for k, s in zip(ks, sn) :
    INDENT
        print '%-8s =' % s,
        print vals [k]
    DEDENT
DEDENT
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    stmts = defaultdict(list)
    for m in (stmt_regex.match(s) for s in lines) :
    INDENT
        if m and 1 < = int(m.group(2)) < = num_of_params :
        INDENT
            stmts [m.group(1)].append(m.group(3).rstrip())
        DEDENT
    DEDENT
    for k, v in stmts.iteritems() :
    INDENT
        print "%s = %s" % (k, ' '.join(v))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933630_3_17
1933564_1933701_1_13
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    sn = 'Names Params Optimize Upper Lower'.split()
    ks = '''paramName paramValue optimizeParam
          paramLowerBound paramUpperBound'''.split()
    vals = dict((k, []) for k in ks)
    are = re.compile(r'model\.(%s) (\d+) (.*)' % '|'.join(ks))
    for line in lines :
    INDENT
        mo = are.search(line)
        if not mo : continue
        p = int(mo.group(2))
        if p < 1 or p > num_of_params : continue
        vals [mo.group(1)].append(mo.group(3).rstrip())
    DEDENT
    for k, s in zip(ks, sn) :
    INDENT
        print '%-8s =' % s,
        print vals [k]
    DEDENT
DEDENT
----------------------------------------

def parse_params(input) :
INDENT
    parameter_list = {}
    param = re.compile(r"model\.([^ ]+) [0-9]+ ([^ ]+)")
    each_parameter = param.finditer(input)
    for match in each_parameter :
    INDENT
        key = match [0]
        value = match [1]
        if not key in paramter_list :
        INDENT
            parameter_list [key] = []
        DEDENT
        parameter_list [key].append(value)
    DEDENT
    return parameter_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933673_3_31
1933564_1933684_8_15
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    pattern = re.compile(r"""
        model\.
        (.+)    # keyword
        (\d+)   # index to keyword
        [ ]+    # whitespace
        (.+)    # value
        """, re.VERBOSE)
    key_to_collection = {
        "paramName" : names,
        "paramValue" : params,
        "optimizeParam" : optimize,
        "paramLowerBound" : upper,
        "paramUpperBound" : lower,
        }
    for line in lines :
    INDENT
        match = pattern.match(line)
        if not match :
        INDENT
            print "Invalid line: " + line
        DEDENT
        elif match [1] not in key_to_collection :
        INDENT
            print "Invalid key: " + line
        DEDENT
        elif match [2] > num_of_params :
        INDENT
            print "Invalid param: " + line
        DEDENT
        else :
        INDENT
            key_to_collection [match [1]].append(match [3])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    stmts = defaultdict(list)
    for m in (stmt_regex.match(s) for s in lines) :
    INDENT
        if m and 1 < = int(m.group(2)) < = num_of_params :
        INDENT
            stmts [m.group(1)].append(m.group(3).rstrip())
        DEDENT
    DEDENT
    for k, v in stmts.iteritems() :
    INDENT
        print "%s = %s" % (k, ' '.join(v))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933673_3_31
1933564_1933701_1_13
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    pattern = re.compile(r"""
        model\.
        (.+)    # keyword
        (\d+)   # index to keyword
        [ ]+    # whitespace
        (.+)    # value
        """, re.VERBOSE)
    key_to_collection = {
        "paramName" : names,
        "paramValue" : params,
        "optimizeParam" : optimize,
        "paramLowerBound" : upper,
        "paramUpperBound" : lower,
        }
    for line in lines :
    INDENT
        match = pattern.match(line)
        if not match :
        INDENT
            print "Invalid line: " + line
        DEDENT
        elif match [1] not in key_to_collection :
        INDENT
            print "Invalid key: " + line
        DEDENT
        elif match [2] > num_of_params :
        INDENT
            print "Invalid param: " + line
        DEDENT
        else :
        INDENT
            key_to_collection [match [1]].append(match [3])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def parse_params(input) :
INDENT
    parameter_list = {}
    param = re.compile(r"model\.([^ ]+) [0-9]+ ([^ ]+)")
    each_parameter = param.finditer(input)
    for match in each_parameter :
    INDENT
        key = match [0]
        value = match [1]
        if not key in paramter_list :
        INDENT
            parameter_list [key] = []
        DEDENT
        parameter_list [key].append(value)
    DEDENT
    return parameter_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1933564_1933684_8_15
1933564_1933701_1_13
Title: How to refactor this python code block to be more efficient 
----------------------------------------

def parse_params(num_of_params, lines) :
INDENT
    stmts = defaultdict(list)
    for m in (stmt_regex.match(s) for s in lines) :
    INDENT
        if m and 1 < = int(m.group(2)) < = num_of_params :
        INDENT
            stmts [m.group(1)].append(m.group(3).rstrip())
        DEDENT
    DEDENT
    for k, v in stmts.iteritems() :
    INDENT
        print "%s = %s" % (k, ' '.join(v))
    DEDENT
DEDENT
----------------------------------------

def parse_params(input) :
INDENT
    parameter_list = {}
    param = re.compile(r"model\.([^ ]+) [0-9]+ ([^ ]+)")
    each_parameter = param.finditer(input)
    for match in each_parameter :
    INDENT
        key = match [0]
        value = match [1]
        if not key in paramter_list :
        INDENT
            parameter_list [key] = []
        DEDENT
        parameter_list [key].append(value)
    DEDENT
    return parameter_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19346524_19348200_50_67
19346524_19348200_76_88
Title: How to Quit program when all the thread have been finished? 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        path = status = None
        try :
        INDENT
            try :
            INDENT
                path = self.work_q.get(timeout = 0.00001)
            DEDENT
            except Queue.Empty :
            INDENT
                continue
            DEDENT
            if path == self.STOP_TOKEN :
            INDENT
                break
            DEDENT
            get_url = urllib.urlopen(aim + '/' + path)
            status = get_url.getcode()
        DEDENT
        except Exception as e :
        INDENT
            status = 'unhandled error ({})'.format(e)
        DEDENT
        self.result_q.put((path, status))
        self.work_q.task_done()

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    with open(self.results_file_path, 'w') as results_file :
    INDENT
        while True :
        INDENT
            try :
            INDENT
                result = self.result_q.get(timeout = 0.00001)
            DEDENT
            except Queue.Empty :
            INDENT
                continue
            DEDENT
            if result == self.STOP_TOKEN :
            INDENT
                break
            DEDENT
            path, status = result
            results_file.write('{}=>{}\n'.format(path, status))

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19350900_19351053_1_17
19350900_19351306_1_12
Title: finding all unique words from a list using loops 
----------------------------------------

def getUniqueWords(allWords) :
INDENT
    uw = []
    for word in allWords :
    INDENT
        (lo, hi) = (0, len(uw) - 1)
        m = - 1
        while hi > = lo and m == - 1 :
        INDENT
            mid = lo + (hi - lo) / 2
            if uw [mid] == word :
            INDENT
                m = mid
            DEDENT
            elif uw [mid] < word :
            INDENT
                lo = mid + 1
            DEDENT
            else :
            INDENT
                hi = mid - 1
            DEDENT
        DEDENT
        if m == - 1 :
        INDENT
            m = lo
            uw = uw [: m] + [word] + uw [m :]
        DEDENT
    DEDENT
    return uw
DEDENT
----------------------------------------

def getUniqueWords(allWords) :
INDENT
    uniqueWords = []
    uniqueWords.append(allWords [0])
    for i in range(len(allWords)) :
    INDENT
        for j in range(len(uniqueWords)) :
        INDENT
            if allWords [i] == uniqueWords [j] :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            uniqueWords.append(allWords [i])
            print uniqueWords [j]
        DEDENT
    DEDENT
    print uniqueWords
    return uniqueWords
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19429470_19429598_1_10
19429470_19429634_1_21
Title: "Python 2.7.5 making loop with unlimited user input accumulate totals applying sentinel?" 
----------------------------------------

def main() :
INDENT
    total = 0
    print 'this is the accumulator test run '
    while True :
    INDENT
        number = input('enter a number: ')
        if number == 0 :
        INDENT
            break
        DEDENT
        total += number
    DEDENT
    print 'the total is', total
DEDENT
----------------------------------------

def main() :
INDENT
    total = 0.0
    print ' this is the accumulator test run '
    while True :
    INDENT

        number = raw_input('enter a number: ')
        if number == 'done' :
        INDENT
            break
        DEDENT
        try :
        INDENT

            total += float(number)
        DEDENT
        except ValueError :
        INDENT
            continue
        DEDENT
    DEDENT
    print ' the total is', total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19433401_19433618_2_15
19433401_19433620_1_21
Title: Displaying more than one of an item in pygame 
----------------------------------------

def addPane(self, textToDisplay) :
INDENT
    x = 0
    y = 0
    for i in range(10) :
    INDENT
        panes.append(pygame.draw.rect(self.screen, (black), (x, y, 200, 100), 2))
        panes [- 1]
        x += 200
        y += 100
        if len(panes) > 10 :
        INDENT
            print ("Limit reached")
            break
        DEDENT
    DEDENT
    pygame.display.update()
DEDENT
----------------------------------------

def addPane(self, text_to_display) :
INDENT
    pane_locs = [(175, 75, 200, 100),
        (0, 0, 200, 100),
        (600, 400, 200, 100),
        (175, 75, 200, 100),
        (175, 75, 200, 100),
        (175, 75, 200, 100),
        (175, 75, 200, 100),
        (175, 75, 200, 100),
        (175, 75, 200, 100),
        (175, 75, 200, 100),
        ]
    for i, pane_loc in enumerate(pane_locs) :
    INDENT
        if self.num_panes > 10 :
        INDENT
            print ("limit reached")
            break
        DEDENT
        if i == 1 :
        INDENT
            self.screen.blit(self.font.render(text_to_display, True, (black)), (250, 115))
        DEDENT
        pygame.draw.rect(self.screen, (black), pane_loc, 2)
        self.num_panes += 1
        pygame.display.update()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19439045_19439134_4_11
19439045_19441817_4_11
Title: There is any event for a Gtk.Button that would execute the code repeatedly while the button is being pressed? 
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self)
    self.button = Gtk.Button("Hi Printer")
    self.button.connect("pressed", self.on_button_clicked)
    self.button.connect("released", self.on_button_released)
    self.add(self.button)
    self.connect("delete-event", Gtk.main_quit)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self)
    self.button = Gtk.Button("Hi Printer")
    self.button.connect("pressed", self.on_button_clicked)
    self.button.connect("released", self.on_button_released)
    self.add(self.button)
    self.connect("delete-event", Gtk.main_quit)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19446529_19447155_6_14
19446529_19447502_6_14
Title: Pass arguments to decorators when calling decorated function 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    id = kwargs.get('id', self.id)
    entity_ids = func(* args)
    result = {}
    for k, v in entity_ids.items() :
    INDENT
        if self.id :
        INDENT
            if '_' + str(self.id) in k :
            INDENT
                result.update({k : v})
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    id = kwargs.get("id", self.id)
    entity_ids = func(* args)
    result = {}
    for k, v in entity_ids.items() :
    INDENT
        if id :
        INDENT
            if '_' + str(id) in k :
            INDENT
                result.update({k : v})
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19487149_19488432_4_13
19487149_19488664_27_32
Title: "Parameter validation Best practices in Python" 
----------------------------------------

def get_abs_directory(path) :
INDENT
    try :
    INDENT
        if os.path.isdir(path) :
        INDENT
            return path
        DEDENT
        else :
        INDENT
            return os.path.split(os.path.abspath(path)) [0]
        DEDENT
    DEDENT
    except TypeError :
    INDENT
        print "You inserted the wrong type!"
    DEDENT
DEDENT
----------------------------------------

def get_abs_directory(self, path) :
INDENT
    if os.path.isdir(path) :
    INDENT
        return path
    DEDENT
    else :
    INDENT
        return os.path.split(os.path.abspath(path)) [0]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19519587_19521738_8_12
19519587_19536687_32_40
Title: "Python Matplotlib plot multi-lines (array) and animation" 
----------------------------------------

def animate(coef) :
INDENT
    data = odata * (1.- float(coef) / 360.)
    for mline, x, d in zip(lines, data.T, xx.T) :
    INDENT
        mline.set_data(x, d)
    DEDENT
    return lines
DEDENT
----------------------------------------

def animate(coef) :
INDENT
    data = odata * (1.- float(coef) / 360.)
    for mline, x, d in zip(lines, xx.T, data.T,) :
    INDENT
        mline.set_data(x, d)
    DEDENT
    return lines
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19528158_19797326_14_28
19528158_19797326_78_101
Title: Simplifying a QPainterPath to an outline 
----------------------------------------

def __init__(self, graphWidget, line) :
INDENT
    super(self.__class__, self).__init__()
    self.line = line
    self.radius = 8
    if graphWidget ! = None :
    INDENT
        self.graph = weakref.ref(graphWidget)
    DEDENT
    self.newPos = QPointF()
    self.setCacheMode(self.DeviceCoordinateCache)
    self.setZValue(- 1)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(self.__class__, self).__init__()
    self.timerId = 0
    scene = QGraphicsScene(self)
    scene.setItemIndexMethod(QGraphicsScene.NoIndex)
    scene.setSceneRect(0, 0, 880, 880)
    self.setScene(scene)
    self.setCacheMode(QGraphicsView.CacheBackground)
    self.setRenderHint(QPainter.Antialiasing)
    self.setTransformationAnchor(QGraphicsView.AnchorUnderMouse)
    self.setResizeAnchor(QGraphicsView.AnchorViewCenter)
    self.centerNode = Node(self, [[50, 50], [200, 100], [500, 100], [700, 700]])
    scene.addItem(self.centerNode)

    self.centerNode.setPos(0, 0)
    self.setGeometry(100, 100, 900, 900)
    self.setWindowTitle(self.tr("Elastic Nodes"))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19530383_34778555_1_28
19530383_35048327_18_44
Title: How to use datasets.fetch_mldata() in sklearn? 
----------------------------------------

def get_data() :
INDENT
    from sklearn.datasets import fetch_mldata
    mnist = fetch_mldata('MNIST original')
    x = mnist.data
    y = mnist.target

    x = x / 255.0 * 2 - 1
    from sklearn.cross_validation import train_test_split
    x_train, x_test, y_train, y_test = train_test_split(x, y,
        test_size = 0.33,
        random_state = 42)
    data = {'train' : {'X' : x_train,
            'y' : y_train},
        'test' : {'X' : x_test,
            'y' : y_test}}
    return data
DEDENT
----------------------------------------

def get_data() :
INDENT
    """
    Get MNIST data; returns a dict with keys 'train' and 'test'.
    Both have the keys 'X' (features) and 'y' (labels)
    """
    from sklearn.datasets.mldata import fetch_mldata
    mnist = fetch_mldata('mnist-original', data_home = '/media/Vancouver/apps/mnist_dataset/')
    x = mnist.data
    y = mnist.target

    x = x / 255.0 * 2 - 1
    from sklearn.cross_validation import train_test_split
    x_train, x_test, y_train, y_test = train_test_split(x, y,
        test_size = 0.33, random_state = 42)
    data = {'train' : {'X' : x_train, 'y' : y_train},
        'test' : {'X' : x_test, 'y' : y_test}}
    return data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1956623_1956648_6_12
1956623_1956679_11_20
Title: "i don't know __iter__ in pythonwho can give me a good code example" 
----------------------------------------

def next(self) :
INDENT
    if self.x > 0 :
    INDENT
        self.x -= 1
        return self.x
    DEDENT
    else :
    INDENT
        raise StopIteration
    DEDENT
DEDENT
----------------------------------------

def next(self) :
INDENT
    if (self.skip > 0) and (self.curval > = self.lastval) :
    INDENT
        raise StopIteration()
    DEDENT
    elif (self.skip < 0) and (self.curval < = self.lastval) :
    INDENT
        raise StopIteration()
    DEDENT
    else :
    INDENT
        oldval = self.curval
        self.curval += self.skip
        return oldval
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19582424_19582699_2_15
19582424_19582716_1_14
Title: Creating columns with lists read from a file in Python 
----------------------------------------

def main() :
INDENT
    inGolf = open('golf.txt', 'r')
    allRecords = inGolf.readlines()
    for record in allRecords :
    INDENT
        player = record.split(',') [0]
        score = record.split(',') [1]
        print player + "\t" + score + "\n"
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    inGolf = open('golf.txt', 'r')
    names = []
    scores = []
    for line in inGolf :
    INDENT
        line_list = line.split(",")
        names.append(line_list [0])
        scores.append(line_list [1])
    DEDENT
    for i in range(len(names)) :
    INDENT
        print "{0:20}{1:10}".format(names [i], scores [i])
    DEDENT
    inGolf.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19607409_19607796_19_30
19607409_19607796_3_18
Title: Using closure to decorate a class's methods 
----------------------------------------

def proxy(bridge) :
INDENT
    def proxyfy(cls) :
    INDENT
        def __getattr__(self, attr) :
        INDENT
            target = getattr(self, bridge)
            if attr.startswith('__') and not attr.endswith('__') :
            INDENT

                attr = '_{}{}'.format(type(target).__name__, attr)
            DEDENT
            return getattr(target, attr)
        DEDENT
        setattr(cls, '__getattr__', __getattr__)
        return cls
    DEDENT
    return proxyfy
DEDENT
----------------------------------------

def proxy(bridge, target) :
INDENT
    def proxyfy(cls) :
    INDENT
        for bname, func in inspect.getmembers(target, predicate = inspect.ismethod) :
        INDENT
            fname = func.__name__
            if fname in cls.__dict__ :
            INDENT
                print 'ignoring %s.%s' % (cls, fname)
                continue
            DEDENT
            print 'adding %s.%s' % (cls, fname)
            def proxy_func(self, bname = bname, * args, ** kwargs) :
            INDENT
                print 'calling %s.%s.%s' % (cls, bridge, bname)
                bridge_member = getattr(self, bridge)
                return getattr(bridge_member, bname)(* args, ** kwargs)
            DEDENT
            setattr(cls, fname, proxy_func)
        DEDENT
        return cls
    DEDENT
    return proxyfy
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19607409_19607796_20_28
19607409_19607796_4_16
Title: Using closure to decorate a class's methods 
----------------------------------------

def proxyfy(cls) :
INDENT
    def __getattr__(self, attr) :
    INDENT
        target = getattr(self, bridge)
        if attr.startswith('__') and not attr.endswith('__') :
        INDENT

            attr = '_{}{}'.format(type(target).__name__, attr)
        DEDENT
        return getattr(target, attr)
    DEDENT
    setattr(cls, '__getattr__', __getattr__)
    return cls
DEDENT
----------------------------------------

def proxyfy(cls) :
INDENT
    for bname, func in inspect.getmembers(target, predicate = inspect.ismethod) :
    INDENT
        fname = func.__name__
        if fname in cls.__dict__ :
        INDENT
            print 'ignoring %s.%s' % (cls, fname)
            continue
        DEDENT
        print 'adding %s.%s' % (cls, fname)
        def proxy_func(self, bname = bname, * args, ** kwargs) :
        INDENT
            print 'calling %s.%s.%s' % (cls, bridge, bname)
            bridge_member = getattr(self, bridge)
            return getattr(bridge_member, bname)(* args, ** kwargs)
        DEDENT
        setattr(cls, fname, proxy_func)
    DEDENT
    return cls
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19615876_19616385_1_20
19615876_20992920_17_44
Title: Showing the right funcName when wrapping logger functionality in a custom class 
----------------------------------------

def findCaller(self) :
INDENT
    f = currentframe()

    if f is not None :
    INDENT
        f = f.f_back
    DEDENT
    rv = "(unknown file)", 0, "(unknown function)"
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)
        if filename == _srcfile :
        INDENT
            f = f.f_back
            continue
        DEDENT
        rv = (co.co_filename, f.f_lineno, co.co_name)
        break
    DEDENT
    return rv
DEDENT
----------------------------------------

def findCaller(self) :
INDENT
    outer = inspect.getouterframes(inspect.currentframe())
    outer.reverse()
    rv = "(unknown file)", 0, "(unknown function)"
    pos = 0
    for i in range(0, len(outer)) :
    INDENT
        if outer [i] [1] == _srcfile :
        INDENT

            pos = i - 1
            break
        DEDENT
    DEDENT
    f = outer [pos] [0]
    co = f.f_code
    rv = (co.co_filename, f.f_lineno, co.co_name)
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19615876_19616385_1_20
19615876_28357385_43_102
Title: Showing the right funcName when wrapping logger functionality in a custom class 
----------------------------------------

def findCaller(self) :
INDENT
    f = currentframe()

    if f is not None :
    INDENT
        f = f.f_back
    DEDENT
    rv = "(unknown file)", 0, "(unknown function)"
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)
        if filename == _srcfile :
        INDENT
            f = f.f_back
            continue
        DEDENT
        rv = (co.co_filename, f.f_lineno, co.co_name)
        break
    DEDENT
    return rv
DEDENT
----------------------------------------

def findCaller(self, stack_info = False) :
INDENT
    sinfo = None
    f = currentframe()

    if f is not None :
    INDENT
        f = f.f_back
    DEDENT
    if sys.version_info.major == 2 :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)"
    DEDENT
    else :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)", sinfo
    DEDENT
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)
        if filename == _srcfile or filename == logging._srcfile :
        INDENT
            f = f.f_back
            continue
        DEDENT
        f = f.f_back
        co = f.f_code
        if sys.version_info.major == 2 :
        rv = "(unknown file)", 0, "(unknown function)"
    DEDENT
    else :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)", sinfo
    DEDENT
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)
        if filename == _srcfile or filename == logging._srcfile :
        INDENT
            f = f.f_back
            continue
        DEDENT
        f = f.f_back
        co = f.f_code
        if sys.version_info.major == 2 :
        INDENT
            rv = co.co_filename, f.f_lineno, co.co_name
        DEDENT
        else :
        INDENT
            if stack_info :
            INDENT
                sio = io.StringIO()
                sio.write('Stack (most recent call last):\n')
                traceback.print_stack(f, file = sio)
                sinfo = sio.getvalue()
                if sinfo [- 1] == '\n' :
                INDENT
                    sinfo = sinfo [: - 1]
                DEDENT
                sio.close()
            DEDENT
            rv = co.co_filename, f.f_lineno, co.co_name, sinfo
        DEDENT
        break
    DEDENT
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19615876_20992920_17_44
19615876_28357385_43_102
Title: Showing the right funcName when wrapping logger functionality in a custom class 
----------------------------------------

def findCaller(self) :
INDENT
    outer = inspect.getouterframes(inspect.currentframe())
    outer.reverse()
    rv = "(unknown file)", 0, "(unknown function)"
    pos = 0
    for i in range(0, len(outer)) :
    INDENT
        if outer [i] [1] == _srcfile :
        INDENT

            pos = i - 1
            break
        DEDENT
    DEDENT
    f = outer [pos] [0]
    co = f.f_code
    rv = (co.co_filename, f.f_lineno, co.co_name)
    return rv
DEDENT
----------------------------------------

def findCaller(self, stack_info = False) :
INDENT
    sinfo = None
    f = currentframe()

    if f is not None :
    INDENT
        f = f.f_back
    DEDENT
    if sys.version_info.major == 2 :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)"
    DEDENT
    else :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)", sinfo
    DEDENT
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)
        if filename == _srcfile or filename == logging._srcfile :
        INDENT
            f = f.f_back
            continue
        DEDENT
        f = f.f_back
        co = f.f_code
        if sys.version_info.major == 2 :
        rv = "(unknown file)", 0, "(unknown function)"
    DEDENT
    else :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)", sinfo
    DEDENT
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)
        if filename == _srcfile or filename == logging._srcfile :
        INDENT
            f = f.f_back
            continue
        DEDENT
        f = f.f_back
        co = f.f_code
        if sys.version_info.major == 2 :
        INDENT
            rv = co.co_filename, f.f_lineno, co.co_name
        DEDENT
        else :
        INDENT
            if stack_info :
            INDENT
                sio = io.StringIO()
                sio.write('Stack (most recent call last):\n')
                traceback.print_stack(f, file = sio)
                sinfo = sio.getvalue()
                if sinfo [- 1] == '\n' :
                INDENT
                    sinfo = sinfo [: - 1]
                DEDENT
                sio.close()
            DEDENT
            rv = co.co_filename, f.f_lineno, co.co_name, sinfo
        DEDENT
        break
    DEDENT
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19615876_20992920_17_44
19615876_38375345_28_54
Title: Showing the right funcName when wrapping logger functionality in a custom class 
----------------------------------------

def findCaller(self) :
INDENT
    outer = inspect.getouterframes(inspect.currentframe())
    outer.reverse()
    rv = "(unknown file)", 0, "(unknown function)"
    pos = 0
    for i in range(0, len(outer)) :
    INDENT
        if outer [i] [1] == _srcfile :
        INDENT

            pos = i - 1
            break
        DEDENT
    DEDENT
    f = outer [pos] [0]
    co = f.f_code
    rv = (co.co_filename, f.f_lineno, co.co_name)
    return rv
DEDENT
----------------------------------------

def findCaller(self) :
INDENT
    f = currentframe()

    if f is not None :
    INDENT
        f = f.f_back
    DEDENT
    rv = "(unknown file)", 0, "(unknown function)"
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)

        if co.co_name ! = 'test_logging' and filename in [_logging_srcfile, _this_srcfile] :
        INDENT
            f = f.f_back
            continue
        DEDENT
        rv = (co.co_filename, f.f_lineno, co.co_name)
        break
    DEDENT
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19615876_28357385_43_102
19615876_38375345_28_54
Title: Showing the right funcName when wrapping logger functionality in a custom class 
----------------------------------------

def findCaller(self, stack_info = False) :
INDENT
    sinfo = None
    f = currentframe()

    if f is not None :
    INDENT
        f = f.f_back
    DEDENT
    if sys.version_info.major == 2 :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)"
    DEDENT
    else :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)", sinfo
    DEDENT
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)
        if filename == _srcfile or filename == logging._srcfile :
        INDENT
            f = f.f_back
            continue
        DEDENT
        f = f.f_back
        co = f.f_code
        if sys.version_info.major == 2 :
        rv = "(unknown file)", 0, "(unknown function)"
    DEDENT
    else :
    INDENT
        rv = "(unknown file)", 0, "(unknown function)", sinfo
    DEDENT
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)
        if filename == _srcfile or filename == logging._srcfile :
        INDENT
            f = f.f_back
            continue
        DEDENT
        f = f.f_back
        co = f.f_code
        if sys.version_info.major == 2 :
        INDENT
            rv = co.co_filename, f.f_lineno, co.co_name
        DEDENT
        else :
        INDENT
            if stack_info :
            INDENT
                sio = io.StringIO()
                sio.write('Stack (most recent call last):\n')
                traceback.print_stack(f, file = sio)
                sinfo = sio.getvalue()
                if sinfo [- 1] == '\n' :
                INDENT
                    sinfo = sinfo [: - 1]
                DEDENT
                sio.close()
            DEDENT
            rv = co.co_filename, f.f_lineno, co.co_name, sinfo
        DEDENT
        break
    DEDENT
    return rv
DEDENT
----------------------------------------

def findCaller(self) :
INDENT
    f = currentframe()

    if f is not None :
    INDENT
        f = f.f_back
    DEDENT
    rv = "(unknown file)", 0, "(unknown function)"
    while hasattr(f, "f_code") :
    INDENT
        co = f.f_code
        filename = os.path.normcase(co.co_filename)

        if co.co_name ! = 'test_logging' and filename in [_logging_srcfile, _this_srcfile] :
        INDENT
            f = f.f_back
            continue
        DEDENT
        rv = (co.co_filename, f.f_lineno, co.co_name)
        break
    DEDENT
    return rv
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19617355_20177277_11_18
19617355_20177277_25_31
Title: Dynamically changing log level in python without restarting the application 
----------------------------------------

def _run(self) :
INDENT
    while True :
    INDENT
        events = inotify.get_events(self.fd)
        for event in events :
        INDENT
            self.queue.put(event)
            gevent.sleep(0)

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def _run(self) :
INDENT
    while True :
    INDENT
        _ = self.queue.get()
        self.callback()
        gevent.sleep(0)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19634554_19634764_16_31
19634554_19635035_6_14
Title: Bubblesort in Python 3.2 
----------------------------------------

def bubblesort() :
INDENT
    sorted = False;
    while sorted ! = True :
    INDENT
        y = 0;
        l = len(test) - 1
        print (l);
        sorted = True;
        while y < l :
        INDENT
            if test [y] < test [y + 1] :
            INDENT
                tmp = test [y]
                test [y] = test [y + 1];
                test [y + 1] = tmp;
                sorted = False;
            DEDENT
            y = y + 1;
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def bubblesort(test) :
INDENT
    is_sorted = False
    while not is_sorted :
    INDENT
        is_sorted = True
        for y in range(len(test) - 1) :
        INDENT
            if test [y] > test [y + 1] :
            INDENT
                test [y], test [y + 1] = test [y + 1], test [y]
                is_sorted = False
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19649030_19649259_18_26
19649030_19649259_28_34
Title: "Why use threading data race will occur but will not use gevent" 
----------------------------------------

def run(self) :
INDENT
    global count
    for i in xrange(cycles_count) :
    INDENT
        if use_debug :
        INDENT
            print '%s:%s' % (self.thread_name, count)
        DEDENT
        if use_gevent :
        INDENT
            print self.thread_name
        DEDENT
        count = count + 1
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    if use_gevent :
    INDENT
        print 'Infinite ...'
    DEDENT
    while True :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19655836_19660341_28_38
19655836_19660341_43_59
Title: How to add panel with event button in wxpython? 
----------------------------------------

def __init__(self, parent, a, b) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    MyGrid = grid.Grid(self)
    MyGrid.CreateGrid(a, b)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(MyGrid, 0, wx.EXPAND)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "test", size = (800, 600))
    self.splitter = wx.SplitterWindow(self)
    self.panelOne = MainPanel(self.splitter)
    self.panelTwo = SecondPanel(self.splitter, 1, 1)
    self.splitter.SplitHorizontally(self.panelOne, self.panelTwo)
    self.splitter.SetMinimumPaneSize(20)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.splitter, 2, wx.EXPAND)
    self.SetSizer(self.sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19655836_19660341_28_38
19655836_19660341_8_18
Title: How to add panel with event button in wxpython? 
----------------------------------------

def __init__(self, parent, a, b) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    MyGrid = grid.Grid(self)
    MyGrid.CreateGrid(a, b)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(MyGrid, 0, wx.EXPAND)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    self.txtOne = wx.StaticText(self, - 1, label = "piradoba", pos = (20, 10))
    self.txtPlace = wx.TextCtrl(self, pos = (20, 30))
    self.txtTwo = wx.StaticText(self, - 1, label = "", pos = (20, 40))
    button = wx.Button(self, label = "search", pos = (20, 70))
    button.Bind(wx.EVT_BUTTON, self.onButton)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19655836_19660341_43_59
19655836_19660341_8_18
Title: How to add panel with event button in wxpython? 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "test", size = (800, 600))
    self.splitter = wx.SplitterWindow(self)
    self.panelOne = MainPanel(self.splitter)
    self.panelTwo = SecondPanel(self.splitter, 1, 1)
    self.splitter.SplitHorizontally(self.panelOne, self.panelTwo)
    self.splitter.SetMinimumPaneSize(20)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.splitter, 2, wx.EXPAND)
    self.SetSizer(self.sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    self.txtOne = wx.StaticText(self, - 1, label = "piradoba", pos = (20, 10))
    self.txtPlace = wx.TextCtrl(self, pos = (20, 30))
    self.txtTwo = wx.StaticText(self, - 1, label = "", pos = (20, 40))
    button = wx.Button(self, label = "search", pos = (20, 70))
    button.Bind(wx.EVT_BUTTON, self.onButton)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1965607_1965615_1_7
1965607_28914097_3_9
Title: How can I pass a variable in a decorator to function's argument in a decorated function? 
----------------------------------------

def decorate(function) :
INDENT
    def wrap_function(* args, ** kwargs) :
    INDENT
        str = 'Hello!'
        args.insert(1, str)
        return function(* args, ** kwargs)
    DEDENT
    return wrap_function
DEDENT
----------------------------------------

def decorate(func) :
INDENT
    def wrap_and_call(* args, ** kwargs) :
    INDENT
        if 'str' in inspect.getargspec(func).args :
        INDENT
            kwargs ['str'] = 'Hello!'
        DEDENT
        return func(* args, ** kwargs)
    DEDENT
    return wrap_and_call
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19675112_19675227_11_17
19675112_19675560_4_14
Title: "Converting dictionaries to list sorted by values with multiple values per item" 
----------------------------------------

def list_to_dictionary(data) :
INDENT
    result = {}
    for index, char in enumerate(data) :
    INDENT
        result.setdefault(char, [])
        result [char].append(index)
    DEDENT
    return dict((key, value [0]) if len(value) == 1 else (key, value) for key, value in result.items())
DEDENT
----------------------------------------

def list_to_dictionary(l) :
INDENT
    d = {}
    for i, c in enumerate(l) :
    INDENT
        if c in d :
        INDENT
            if isinstance(d [c], list) :
            INDENT
                d [c].append(i)
            DEDENT
            else :
            INDENT
                d [c] = [d [c], i]
            DEDENT
        DEDENT
        else :
        INDENT
            d [c] = i
        DEDENT
    DEDENT
    return d
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19693442_19693555_3_50
19693442_19693822_5_14
Title: die roll program giving syntax error in python 
----------------------------------------

def main() :
INDENT
    counter2 = 0
    counter3 = 0
    counter4 = 0
    counter5 = 0
    counter6 = 0
    counter7 = 0
    counter8 = 0
    counter9 = 0
    counter10 = 0
    counter11 = 0
    counter12 = 0
    doubles = 0

    rolls = int(input("How many times would you like to roll the dice?"))
    for count in range(rolls + 1) :
    INDENT

        die1 = random.randint(1, 6)
        die2 = random.randint(1, 6)
        if die1 + die2 == 2 :
        INDENT
            counter2 += 1
        DEDENT
        if die1 + die2 == 3 :
        INDENT
            counter3 += 1
        DEDENT
        if die1 + die2 == 4 :
        INDENT
            counter4 += 1
        DEDENT
        if die1 + die2 == 5 :
        INDENT
            counter5 += 1
        DEDENT
        if die1 + die2 == 6 :
        INDENT
            counter6 += 1
        DEDENT
        if die1 + die2 == 7 :
        INDENT
            counter7 += 1
        DEDENT
        if die1 + die2 == 8 :
        INDENT
            counter8 += 1
        DEDENT
        if die1 + die2 == 9 :
        INDENT
            counter9 += 1
        DEDENT
        if die1 + die2 == 10 :
        INDENT
            counter10 += 1
        DEDENT
        if die1 + die2 == 11 :
        INDENT
            counter11 += 1
        DEDENT
        if die1 + die2 == 12 :
        INDENT
            counter12 += 1
        DEDENT
        if die1 == die2 :
        INDENT
            doubles += 1
        DEDENT
    DEDENT
    print ("2 - ", counter2, "3 - ", counter3, "4 - ", counter4, "5 - ", counter5, "6 - ", counter6, "7 - ", counter7, "8 - ", counter8, "9 - ", counter9, "10 - ", counter10, "11 - ", counter11, "12 - ", counter12, "Doubles - ", doubles)
DEDENT
----------------------------------------

def main() :
INDENT
    counter = defaultdict(int)
    rolls = int(input("How many times would you like to roll the dice?"))
    for count in range(rolls) :
    INDENT
        die1, die2 = random.randint(1, 6), random.randint(1, 6)
        counter [die1 + die2] += 1
        if die1 == die2 :
        INDENT
            counter ['Doubles'] += 1
        DEDENT
    DEDENT
    counter
    print ('\n'.join('%s - %s ' % (key, value) for key, value in counter.iteritems()))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19709086_29723995_20_36
19709086_29725917_18_40
Title: How to scrape website with infinte scrolling? 
----------------------------------------

def parse(self, response) :
INDENT
    products = response.xpath("//li[@data-url]")
    if not products :
    INDENT
        raise CloseSpider("No more products!")
    DEDENT
    for product in products :
    INDENT
        item = Product()
        item ['brand'] = product.xpath(".//span[contains(@class, 'qa-brandName')]/text()").extract() [0].strip()
        item ['title'] = product.xpath(".//span[contains(@class, 'qa-brandTitle')]/text()").extract() [0].strip()
        yield item
    DEDENT
    self.page += 1
    yield Request(url = "http://www.jabong.com/women/clothing/womens-tops/?page=%d" % self.page,
        headers = {"Referer" : "http://www.jabong.com/women/clothing/womens-tops/", "X-Requested-With" : "XMLHttpRequest"},
        callback = self.parse,
        dont_filter = True)
DEDENT
----------------------------------------

def parse(self, response) :
INDENT
    products = response.xpath("//li[@data-url]")
    if products :
    INDENT
        for product in products :
        INDENT
            brand = product.xpath(
                ".//span[contains(@class, 'qa-brandName')]/text()").extract()
            brand = brand [0].strip() if brand else 'N/A'
            title = product.xpath(
                ".//span[contains(@class, 'qa-brandTitle')]/text()").extract()
            title = title [0].strip() if title else 'N/A'
            item = aqaqItem()
            item ['brand'] = brand,
            item ['title'] = title
            yield item

        DEDENT
    DEDENT
    else :
    INDENT
        return
    DEDENT
    self.page_index += 1
    if page_index :
    INDENT
        yield Request(url = "http://www.jabong.com/women/clothing/womens-tops/?page=%s" % (self.page_index + 1),
            callback = self.parse)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19721965_19722852_1_12
19721965_46932670_6_19
Title: sublime plugin: find and select text 
----------------------------------------

def run(self, edit, target) :
INDENT
    if not target or target == "" :
    INDENT
        return
    DEDENT
    content = self.view.substr(sublime.Region(0, self.view.size()))
    begin = content.find(target)
    if begin == - 1 :
    INDENT
        return
    DEDENT
    end = begin + len(target)
    target_region = sublime.Region(begin, end)
    self.view.sel().clear()
    self.view.sel().add(target_region)
DEDENT
----------------------------------------

def run(self, edit) :
INDENT
    TARGET = 'http://nabiraem'

    content = self.view.substr(sublime.Region(0, self.view.size()))
    begin = content.find(TARGET)
    if begin == - 1 :
    INDENT
        return
    DEDENT
    end = begin + len(TARGET)
    self._target_region = sublime.Region(begin, end)
    self._select()
    self.view.show(self._target_region)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19747408_19747717_3_9
19747408_19748014_3_12
Title: How get number of subfolders and folders using Python os walks? 
----------------------------------------

def fcount(path) :
INDENT
    count1 = 0
    for root, dirs, files in os.walk(path) :
    INDENT
        count1 += len(dirs)
    DEDENT
    return count1
DEDENT
----------------------------------------

def fcount(path, map = {}) :
INDENT
    count = 0
    for f in os.listdir(path) :
    INDENT
        child = os.path.join(path, f)
        if os.path.isdir(child) :
        INDENT
            child_count = fcount(child, map)
            count += child_count + 1
        DEDENT
    DEDENT
    map [path] = count
    return count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19760186_19760312_10_21
19760186_19761042_7_39
Title: Simple python hangman game 
----------------------------------------

def Playing() :
INDENT
    global guessWord, board, alreadySaid
    whatplayersaid = input("Guess a letter: ")
    if whatplayersaid in guessWord :
    INDENT
        board = [char if char == whatplayersaid or char in alreadySaid else " * " for char in guessWord]
        board = "".join(board)
        print (board)
    DEDENT
    else :
    INDENT
        print ("Nope")
    DEDENT
    alreadySaid = alreadySaid + whatplayersaid
    Hangman.Playing()
DEDENT
----------------------------------------

def Playing(self) :
INDENT
    listOfWords = ["example", "says", "python", "rocks"]
    again = True
    while again :
    INDENT

        guessWord = random.choice(listOfWords)
        board = "*" * len(guessWord)
        alreadySaid = set()
        mistakes = 7
        print (" ".join(board))
        guessed = False
        while not guessed and mistakes > 0 :
        INDENT

            whatplayersaid = input("Guess a letter: ")
            if whatplayersaid in guessWord :
            INDENT
                alreadySaid.add(whatplayersaid)
                board = "".join([char if char in alreadySaid else "*" for char in guessWord])
                if board == guessWord :
                INDENT
                    guessed = True
                DEDENT
            DEDENT
            else :
            INDENT
                mistakes -= 1
                print ("Nope.", mistakes, "mistakes left.")
            DEDENT
            print (" ".join(board))
        DEDENT
        again = (input("Again [y/n]: ").lower() == 'y')

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19767795_19776270_59_76
19767795_19778351_7_31
Title: Tkinter issue trying to show calendar dates with StringVars 
----------------------------------------

def initUI(self) :
INDENT
    self.master.title("Planner")

    self.frame_with_dates = Frame(self.master)
    self.frame_with_dates.grid(row = 0, column = 0)

    self.start_date_menu()

    self.add_button = Button(self.master, text = "Add more", command = self.add_more, width = 10)
    self.add_button.grid(row = 1, column = 0, pady = (10, 10))

    self.remove_button = Button(self.master, text = "Remove last", command = self.remove_last, width = 10)
    self.remove_button.grid(row = 2, column = 0, pady = (10, 10))
DEDENT
----------------------------------------

def initUI(self) :
INDENT
    self.master.title("Planner")
    self.frameOne = Frame(self.master)
    self.frameOne.grid(row = 0, column = 0)
    self.frameTwo = Frame(self.master)
    self.frameTwo.grid(row = 0, column = 1)
    self.frameThree = Frame(self.master)
    self.frameThree.grid(row = 0, column = 2)
    self.frameFour = Frame(self.master)
    self.frameFour.grid(row = 1, column = 0, sticky = N)
    self.frameFive = Frame(self.master)
    self.frameFive.grid(row = 1, column = 1)
    self.frameSix = Frame(self.master)
    self.frameSix.grid(row = 1, column = 2, sticky = N)
    self.frameSeven = Frame(self.master)
    self.frameSeven.grid(row = 2, column = 0)
    self.frameEight = Frame(self.master)
    self.frameEight.grid(row = 2, column = 1, sticky = S)
    self.frameNine = Frame(self.master)
    self.frameNine.grid(row = 2, column = 2)
    self.start_date_menu()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19767795_19776270_77_113
19767795_19778351_32_52
Title: Tkinter issue trying to show calendar dates with StringVars 
----------------------------------------

def start_date_menu(self) :
INDENT
    self.date_num = int(raw_input("Number of dates? "))

    self.label_day_in_left = Label(self.frame_with_dates, text = "Day in", justify = "center")
    self.label_day_in_left.grid(row = 0, column = 0, padx = (10, 10))
    self.label_day_out_left = Label(self.frame_with_dates, text = "Day out", justify = "center")
    self.label_day_out_left.grid(row = 0, column = 1, padx = (10, 10))

    self.label_empty = Label(self.frame_with_dates, text = "|", justify = "center")
    self.label_empty.grid(row = 0, column = 2, padx = (25, 25))

    self.label_day_in_right = Label(self.frame_with_dates, text = "Day in", justify = "center")
    self.label_day_in_right.grid(row = 0, column = 3, padx = (10, 10))
    self.label_day_out_right = Label(self.frame_with_dates, text = "Day out", justify = "center")
    self.label_day_out_right.grid(row = 0, column = 4, padx = (10, 10))

    self.dates_buttons = []
    self.dates_vars = []

    self.n = 0
    while self.n < self.date_num :
    INDENT

        self.add_date_button(self.n)

        self.n += 1
    DEDENT
DEDENT
----------------------------------------

def start_date_menu(self) :
INDENT
    initial_num_dates = int(raw_input("Number of dates?"))
    self.DATE_MENU_ROW = 0
    self.COL_WIDTH = 10
    for frame in (self.frameFour, self.frameSix) :
    INDENT
        self.textoprioridad = Label(frame, text = "Day in",
            width = self.COL_WIDTH, justify = "center")
        self.textoprioridad.grid(row = self.DATE_MENU_ROW, column = 0)
        self.lotestext = Label(frame, text = "Day out", width = self.COL_WIDTH,
            justify = "center")
        self.lotestext.grid(row = self.DATE_MENU_ROW, column = 1)
    DEDENT
    self.dates = [self.create_date_entry(date_index) for date_index in xrange(initial_num_dates)]
    self.anadirpiezas = Button(self.frameEight, text = "add more",
        command = self.addpieza, width = self.COL_WIDTH)
    self.anadirpiezas.grid(row = 0, column = 3)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19769937_19771098_21_40
19769937_19796236_25_44
Title: using listctrl in notebook wxPython 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (400, 400), pos = wx.Point(100, 100),
        style = wx.SYSTEM_MENU | wx.CAPTION)
    p = wx.Panel(self)
    nb = wx.Notebook(p)

    self.MainFrame = PageOne(nb)
    self.SecondFrame = PageTwo(nb)

    nb.AddPage(self.MainFrame, "One")
    nb.AddPage(self.SecondFrame, "Two")
    sizer = wx.BoxSizer()
    sizer.Add(nb, 1, wx.EXPAND)
    p.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (400, 400),
        pos = (100, 100), style = wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX)
    p = wx.Panel(self)
    nb = wx.Notebook(p)
    self.mainframe = PageOne(nb)
    self.secondframe = PageTwo(nb)
    nb.AddPage(self.mainframe, "One")
    nb.AddPage(self.secondframe, "Two")
    sizer = wx.BoxSizer()
    sizer.Add(nb, 1, wx.EXPAND)
    p.SetSizer(sizer)
    sizer.Layout()
    self.mainframe.bind_find_btn(self.on_button)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19769937_19772107_26_43
19769937_19796236_25_44
Title: using listctrl in notebook wxPython 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (400, 400), pos = wx.Point(100, 100),
        style = wx.SYSTEM_MENU | wx.CAPTION)
    p = wx.Panel(self)
    nb = wx.Notebook(p)
    MainFrame = PageOne(nb)
    SecondFrame = PageTwo(nb)
    nb.AddPage(MainFrame, "One")
    nb.AddPage(SecondFrame, "Two")
    sizer = wx.BoxSizer()
    sizer.Add(nb, 1, wx.EXPAND)
    p.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (400, 400),
        pos = (100, 100), style = wx.SYSTEM_MENU | wx.CAPTION | wx.CLOSE_BOX)
    p = wx.Panel(self)
    nb = wx.Notebook(p)
    self.mainframe = PageOne(nb)
    self.secondframe = PageTwo(nb)
    nb.AddPage(self.mainframe, "One")
    nb.AddPage(self.secondframe, "Two")
    sizer = wx.BoxSizer()
    sizer.Add(nb, 1, wx.EXPAND)
    p.SetSizer(sizer)
    sizer.Layout()
    self.mainframe.bind_find_btn(self.on_button)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19775636_19776496_14_26
19775636_19776496_36_48
Title: Pygame pause key 
----------------------------------------

def __init__(self, screen) :
INDENT
    self.screen = screen
    self.x = 0
    self.y = 0
    self.r = 0
    filename = "maps.png"
    self.image = pygame.image.load(filename).convert_alpha()
DEDENT
----------------------------------------

def __init__(self, screen) :
INDENT
    self.screen = screen
    self.x = 0
    self.y = 0
    self.movex = 0
    self.movey = 0
    filename = "boy.png"
    self.image = pygame.image.load(filename).convert_alpha()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19775636_19776496_14_26
19775636_19776496_82_100
Title: Pygame pause key 
----------------------------------------

def __init__(self, screen) :
INDENT
    self.screen = screen
    self.x = 0
    self.y = 0
    self.r = 0
    filename = "maps.png"
    self.image = pygame.image.load(filename).convert_alpha()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    if Android :
    INDENT
        android.init()
        android.map_key(android.KEYCODE_BACK, pygame.K_ESCAPE)
    DEDENT
    self.size = self.width, self.height = 1276, 650
    self.screen = pygame.display.set_mode(self.size)
    pygame.display.set_caption("Pygame 2D RPG !")
    self.background = Background(self.screen)
    self.player = Player(self.screen)
    font = pygame.font.SysFont("serif", 72)
    self.text_paused = font.render("PAUSED", True, (255, 0, 0))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19775636_19776496_36_48
19775636_19776496_82_100
Title: Pygame pause key 
----------------------------------------

def __init__(self, screen) :
INDENT
    self.screen = screen
    self.x = 0
    self.y = 0
    self.movex = 0
    self.movey = 0
    filename = "boy.png"
    self.image = pygame.image.load(filename).convert_alpha()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.init()
    if Android :
    INDENT
        android.init()
        android.map_key(android.KEYCODE_BACK, pygame.K_ESCAPE)
    DEDENT
    self.size = self.width, self.height = 1276, 650
    self.screen = pygame.display.set_mode(self.size)
    pygame.display.set_caption("Pygame 2D RPG !")
    self.background = Background(self.screen)
    self.player = Player(self.screen)
    font = pygame.font.SysFont("serif", 72)
    self.text_paused = font.render("PAUSED", True, (255, 0, 0))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19779191_19779373_74_86
19779191_19779373_92_101
Title: Python: launch default mail client on the system 
----------------------------------------

def open(self, filename) :
INDENT
    if isinstance(filename, basestring) :
    INDENT
        cmdline = self.args + [filename]
    DEDENT
    else :
    INDENT

        cmdline = self.args + filename
    DEDENT
    try :
    INDENT
        return self._invoke(cmdline)
    DEDENT
    except OSError :
    INDENT
        return False

    DEDENT
DEDENT
----------------------------------------

def open(self, filename) :
INDENT
    try :
    INDENT
        os.startfile(filename)
    DEDENT
    except WindowsError :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        return True
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19781694_19782949_1_21
19781694_19789682_8_21
Title: Compare two CSV files against a master CSV file and merge the results into a new file 
----------------------------------------

def vbfunc(dictreader1, dictreader2) :
INDENT
    dictreader1 = list(dictreader1) [: 5]
    dictreader2 = list(dictreader2) [: 5]
    for dictline1 in dictreader1 :
    INDENT
        for dictline2 in dictreader2 :
        INDENT
            print '\nLines 1, 2', dictline1, dictline2
            print '\nColumns 1, 2', dictline1 ['PART CODE'], dictline2 ['\xef\xbb\xbfPART_CODE']
            if dictline1 ['PART CODE'] == dictline2 ['\xef\xbb\xbfPART_CODE'] :
            INDENT
                dictline2 ['VB'] = dictline1 ['ON-HAND']
            DEDENT
            else :
            INDENT
                dictline2 ['VB'] = "0"

            DEDENT
            print '\n New line 2', dictline2
            vblist.append(dictline2)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def vbfunc(dictreader1, dictreader2) :
INDENT
    dictreader2 = list(dictreader2)
    dictreader1 = list(dictreader1)
    vblist = []
    for dictline1 in dictreader1 :
    INDENT
        for dictline2 in dictreader2 :
        INDENT
            if dictline1 ['PART CODE'] == dictline2 ['\xef\xbb\xbfPART_CODE'] :
            INDENT
                dictline2 ['VB'] = dictline1 ['ON-HAND']
            DEDENT
            else :
            INDENT
                continue
            DEDENT
        DEDENT
    DEDENT
    vblist.append(dictline2)
    for i in vblist :
    INDENT
        print i ['BARCODE'], i ['VB']
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19790570_19790994_12_19
19790570_52514734_16_22
Title: Using a global variable with a thread 
----------------------------------------

def thread2(threadname, q) :
INDENT
    a = 0
    for _ in xrange(10) :
    INDENT
        a += 1
        q.put(a)
        time.sleep(1)
    DEDENT
    q.put(None)
DEDENT
----------------------------------------

def thread2(threadname) :
INDENT
    global a
    for k in range(10) :
    INDENT
        a += 1
        time.sleep(0.2)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19790570_19790994_5_11
19790570_52514734_7_15
Title: Using a global variable with a thread 
----------------------------------------

def thread1(threadname, q) :
INDENT
    while True :
    INDENT
        a = q.get()
        if a is None : return
        print a
    DEDENT
DEDENT
----------------------------------------

def thread1(threadname) :
INDENT
    global a
    for k in range(100) :
    INDENT
        print ("{} {}".format(threadname, a))
        time.sleep(0.1)
        if k == 5 :
        INDENT
            a += 100

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19803920_27758377_12_19
19803920_27758377_2_10
Title: Doubly Linked list in Python 
----------------------------------------

def __init__(self) :
INDENT
    self.head = Node(None, None)
    self.tail = Node(None, None)
    self.head.next_name = self.tail
    self.head.next_weight = self.tail
    self.tail.prev_name = self.head
    self.tail.prev_weight = self.head
DEDENT
----------------------------------------

def __init__(self, name, weight) :
INDENT
    self.name = name
    self.weight = weight
    self.prev_name = None
    self.next_name = None
    self.prev_weight = None
    self.next_weight = None

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19823805_19826678_15_31
19823805_19826678_81_114
Title: Pygame collision interaction 
----------------------------------------

def __init__(self, screen, x, y) :
INDENT
    self.screen = screen
    self.rect = pygame.Rect(0, 0, 0, 0)
    self.image = pygame.image.load('player.png')
    self.rect.size = self.image.get_size()
    self.rect.center = (x, y)
    self.speed_x = 0
    self.speed_y = 15
    self.direction = None
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.FPS = 25
    pygame.init()

    self.fpsClock = pygame.time.Clock()
    self.background = pygame.image.load('background.jpg')
    self.size = self.width, self.height = self.background.get_size()
    self.screen = pygame.display.set_mode(self.size, 0, 32)
    self.ball = Ball(self.screen, 100, 100)
    self.player1 = Player(self.screen, 35, self.height / 2)
    self.player2 = Player(self.screen, self.width - 35, self.height / 2)
    print self.screen.get_rect().center
    font = pygame.font.SysFont("", 72)
    self.text_paused = font.render("PAUSE", True, (255, 0, 0))
    print self.text_paused.get_rect()
    screen_rect = self.screen.get_rect()
    self.text_rect = self.text_paused.get_rect()
    self.text_rect.center = screen_rect.center
    print self.text_rect
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19823805_19826678_35_47
19823805_19826678_68_78
Title: Pygame collision interaction 
----------------------------------------

def move(self) :
INDENT
    if self.direction :
    INDENT
        if self.direction == UP :
        INDENT
            self.rect.y -= self.speed_y
            if self.rect.y < 0 :
            INDENT
                self.rect.y = 0
            DEDENT
        DEDENT
        elif self.direction == DOWN :
        INDENT
            self.rect.y += self.speed_y
            if self.rect.y > self.screen.get_size() [1] - self.rect.height :
            INDENT
                self.rect.y = self.screen.get_size() [1] - self.rect.height

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def move(self) :
INDENT
    self.rect.x += self.speed_x
    self.rect.y += self.speed_y
    if self.rect.left < 0 or self.rect.right > self.screen.get_size() [0] :
    INDENT
        self.speed_x = - self.speed_x
    DEDENT
    if self.rect.top < 0 or self.rect.bottom > self.screen.get_size() [1] :
    INDENT
        self.speed_y = - self.speed_y

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19823805_19826678_50_64
19823805_19826678_81_114
Title: Pygame collision interaction 
----------------------------------------

def __init__(self, screen, x, y) :
INDENT
    self.screen = screen
    self.rect = pygame.Rect(0, 0, 0, 0)
    self.image = pygame.image.load('ball.png')
    self.rect.size = self.image.get_size()
    self.rect.center = (x, y)
    self.speed_x = 15
    self.speed_y = 15
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.FPS = 25
    pygame.init()

    self.fpsClock = pygame.time.Clock()
    self.background = pygame.image.load('background.jpg')
    self.size = self.width, self.height = self.background.get_size()
    self.screen = pygame.display.set_mode(self.size, 0, 32)
    self.ball = Ball(self.screen, 100, 100)
    self.player1 = Player(self.screen, 35, self.height / 2)
    self.player2 = Player(self.screen, self.width - 35, self.height / 2)
    print self.screen.get_rect().center
    font = pygame.font.SysFont("", 72)
    self.text_paused = font.render("PAUSE", True, (255, 0, 0))
    print self.text_paused.get_rect()
    screen_rect = self.screen.get_rect()
    self.text_rect = self.text_paused.get_rect()
    self.text_rect.center = screen_rect.center
    print self.text_rect
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19838152_19838337_1_7
19838152_19838455_2_9
Title: Beginning Python fibonacci generator 
----------------------------------------

def fib(n) :
INDENT
    if n == 0 :
    INDENT
        return 0
    DEDENT
    if n == 1 :
    INDENT
        return 1
    DEDENT
    return fib(n - 1) + fib(n - 2)
DEDENT
----------------------------------------

def fib(stop) :
INDENT
    prev, current = 0, 1
    while current < stop :
    INDENT
        yield current
        prev, current = current, prev + current

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19842752_19842921_1_19
19842752_19843094_1_16
Title: Finding a string multiple times in another String - Python 
----------------------------------------

def multi_find(s, r) :
INDENT
    s_len = len(s)
    r_len = len(r)
    _complete = []
    if s_len < r_len :
    INDENT
        n = - 1
    DEDENT
    else :
    INDENT
        for i in xrange(s_len) :
        INDENT
            if s [i : i + r_len] == r :
            INDENT
                _complete.append(i)
            DEDENT
            else :
            INDENT
                i = i + 1
            DEDENT
        DEDENT
    DEDENT
    print (_complete)
DEDENT
----------------------------------------

def multi_find(s, r) :
INDENT
    s_len = len(s)
    r_len = len(r)
    n = []
    if s_len > = r_len :
    INDENT
        m = s_len - r_len
        i = 0
        while i < m :
        INDENT
            if s [i : i + r_len] == r :
            INDENT
                n.append(i)
            DEDENT
            i = i + 1
        DEDENT
    DEDENT
    print (n)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19883495_19883591_1_12
19883495_19883669_1_13
Title: Using recursion to remove a value from a linked list 
----------------------------------------

def removeRec(node, value) :
INDENT
    if node.value == value :
    INDENT
        node.value = node.next.value
        node.next = node.next.next
        return True
    DEDENT
    if node.next == None :
    INDENT
        return False
    DEDENT
    if node.next.value == value :
    INDENT
        node.next = node.next.next
        return True
    DEDENT
    return removeRec(node.next, value)
DEDENT
----------------------------------------

def removeRec(node, value) :
INDENT
    if isinstance(node, EmptyNode) :
    INDENT
        print ("Cannot remove value from an empty list")
        return None
    DEDENT
    elif node.data == value :
    INDENT
        return node.next
    DEDENT
    else :
    INDENT
        rec_result = removeRec(node.next, value)
        if rec_result is None :
        INDENT
            return rec_result
        DEDENT
        else :
        INDENT
            node.next = rec_result
            return node
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19883495_19883591_1_12
19883495_19883719_4_13
Title: Using recursion to remove a value from a linked list 
----------------------------------------

def removeRec(node, value) :
INDENT
    if node.value == value :
    INDENT
        node.value = node.next.value
        node.next = node.next.next
        return True
    DEDENT
    if node.next == None :
    INDENT
        return False
    DEDENT
    if node.next.value == value :
    INDENT
        node.next = node.next.next
        return True
    DEDENT
    return removeRec(node.next, value)
DEDENT
----------------------------------------

def removeRec(node, value) :
INDENT
    if isinstance(node, EmptyNode) :
    INDENT
        print ("Cannot remove value from an empty list")
    DEDENT
    elif node.data == value :
    INDENT
        remove.ret = True
        return node.next
    DEDENT
    else :
    INDENT
        node.next = removeRec(node.next, value)
        return node
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19883495_19883669_1_13
19883495_19883719_4_13
Title: Using recursion to remove a value from a linked list 
----------------------------------------

def removeRec(node, value) :
INDENT
    if isinstance(node, EmptyNode) :
    INDENT
        print ("Cannot remove value from an empty list")
        return None
    DEDENT
    elif node.data == value :
    INDENT
        return node.next
    DEDENT
    else :
    INDENT
        rec_result = removeRec(node.next, value)
        if rec_result is None :
        INDENT
            return rec_result
        DEDENT
        else :
        INDENT
            node.next = rec_result
            return node
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def removeRec(node, value) :
INDENT
    if isinstance(node, EmptyNode) :
    INDENT
        print ("Cannot remove value from an empty list")
    DEDENT
    elif node.data == value :
    INDENT
        remove.ret = True
        return node.next
    DEDENT
    else :
    INDENT
        node.next = removeRec(node.next, value)
        return node
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19888697_19896049_10_23
19888697_19896049_37_56
Title: how to make instances of event for every single tab on multi tab GUI tkinter( notebook widget) 
----------------------------------------

def __init__(self, root, name) :
INDENT
    Frame.__init__(self, root)
    self.root = root
    self.name = name
    self.entry = Entry(self)
    self.entry.pack(side = TOP)
    self.entry.bind('<FocusOut>', self.alert)
    self.entry.bind('<Key>', self.printing)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.tabs = {'ky' : 1}
    self.root = Tk()
    self.root.minsize(300, 300)
    self.root.geometry("1000x700")
    self.notebook = ttk.Notebook(self.root, width = 1000, height = 650)

    self.addTab('tab1')
    self.button = Button(self.root, text = 'generate', command = self.start_generating).pack(side = BOTTOM)
    self.notebook.pack(side = TOP)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19894508_19894542_1_14
19894508_19894548_1_10
Title: TypeError: 'str' object is not callable i think if statement error 
----------------------------------------

def main() :
INDENT
    series = input('Enter series of lowercase letters:')
    index = 0
    vowels = 0
    consonants = 0
    while index < len(series) :
    INDENT
        if series [index] in "aeiou" :
        INDENT
            vowels += 1
        DEDENT
        else :
        INDENT
            consonants += 1
        DEDENT
        index += 1
    DEDENT
    print ('Vowels:', vowels)
    print ('Constants:', consonants)
DEDENT
----------------------------------------

def main() :
INDENT
    series = input('Enter series of lowercase letters:')
    vowels = 0
    constants = 0
    vowels = ("a", "e", "i", "o", "u")
    for c in series :
    INDENT
        if c in vowels :
        INDENT
            vowels = vowels + 1
        DEDENT
        else :
        INDENT
            constants = constants + 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19902790_19913787_60_74
19902790_19913787_7_41
Title: wxpython : changing background / foreground image dynamically 
----------------------------------------

def __init__(self, size = (800, 480)) :
INDENT
    wx.Frame.__init__(self, None, size = size)
    self.state = None
    self.panel = None
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(self.sizer)
    self.Show()
    self.ChangePanel()

DEDENT
----------------------------------------

def __init__(self, parent, state, button_image, background_image) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    print "(debug) MyPanel.__init__: state:", state
    self.parent = parent
    self.state = state
    self.button_image = button_image
    self.background_image = background_image

    self.SetBackgroundStyle(wx.BG_STYLE_CUSTOM)
    vsizer = wx.BoxSizer(wx.VERTICAL)
    hSizer = wx.BoxSizer(wx.HORIZONTAL)

    self.buttonImage = wx.Image(button_image, wx.BITMAP_TYPE_PNG).ConvertToBitmap()
    self.button = wx.BitmapButton(self, - 1, self.buttonImage, pos = (100, 50))
    self.button.Bind(wx.EVT_LEFT_DCLICK, self.buttonClick)
    self.backgroundImage = wx.Bitmap(self.background_image)
    vsizer.Add(self.button, 0, wx.ALL, 5)
    hSizer.Add((1, 1), 1, wx.EXPAND)
    hSizer.Add(vsizer, 0, wx.TOP, 100)
    hSizer.Add((1, 1), 0, wx.ALL, 75)
    self.SetSizer(hSizer)
    self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnEraseBackground)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1993896_1993928_1_10
1993896_1994855_1_16
Title: How to check for EOF in Python? 
----------------------------------------

def get_text_blocks(filename) :
INDENT
    text_blocks = []
    with open(filename, 'r') as f :
    INDENT
        for line in f :
        INDENT
            if line.startswith('-- -') :
            INDENT
                text_blocks.append(line)
            DEDENT
            else :
            INDENT
                if len(text_blocks) ! = 0 :
                INDENT
                    text_blocks [- 1] += line
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return text_blocks
DEDENT
----------------------------------------

def get_text_blocks(filename) :
INDENT
    text_blocks = []
    text_block = StringIO.StringIO()
    with open(filename, 'r') as f :
    INDENT
        for line in f :
        INDENT
            text_block.write(line)
            print line
            if line.startswith('-- -') :
            INDENT
                text_blocks.append(text_block.getvalue())
                text_block.close()
                text_block = StringIO.StringIO()
            DEDENT
            if len(text_block) > 0 :
            INDENT
                text_blocks.append(text_block.getvalue())
            DEDENT
        DEDENT
    DEDENT
    return text_blocks
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19955101_19955353_1_12
19955101_19955371_1_11
Title: Sharing local variable between nested functions in python 
----------------------------------------

def f1() :
INDENT
    def f2() :
    INDENT
        global g
        print g
        g = 1
        print g
    DEDENT
    global g
    g = 0
    print g
    f2()
    print g
DEDENT
----------------------------------------

def f1() :
INDENT
    def f2() :
    INDENT
        print g [0]
        g [0] = 1
        print g [0]
    DEDENT
    g = [0]
    print g [0]
    f2()
    print g [0]
    f1()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19962699_32561337_1_28
19962699_32561337_2_27
Title: "Flask RESTful cross-domain issue with Angular: PUT OPTIONS methods" 
----------------------------------------

def cross_origin(origin = "*") :
INDENT
    def cross_origin(func) :
    INDENT
        @ functools.wraps(func)
        def _decoration(* args, ** kwargs) :
        INDENT
            ret = func(* args, ** kwargs)
            _cross_origin_header = {"Access-Control-Allow-Origin" : origin,
                "Access-Control-Allow-Headers" :
                "Origin, X-Requested-With, Content-Type, Accept"}
            if isinstance(ret, tuple) :
            INDENT
                if len(ret) == 2 and isinstance(ret [0], dict) and isinstance(ret [1], int) :
                INDENT
                    return ret [0], ret [1], _cross_origin_header
                DEDENT
                elif isinstance(ret, basestring) :
                INDENT
                    response = make_response(ret)
                    response.headers ["Access-Control-Allow-Origin"] = origin
                    response.headers ["Access-Control-Allow-Headers"] = "Origin, X-Requested-With, Content-Type, Accept"
                    return response
                DEDENT
                elif isinstance(ret, Response) :
                INDENT
                    ret.headers ["Access-Control-Allow-Origin"] = origin
                    ret.headers ["Access-Control-Allow-Headers"] = "Origin, X-Requested-With, Content-Type, Accept"
                    return ret
                DEDENT
                else :
                INDENT
                    raise ValueError("Cannot handle cross origin, because the return value is not matched!")
                DEDENT
            DEDENT
            return ret
        DEDENT
        return _decoration
    DEDENT
    return cross_origin
DEDENT
----------------------------------------

def cross_origin(func) :
INDENT
    @ functools.wraps(func)
    def _decoration(* args, ** kwargs) :
    INDENT
        ret = func(* args, ** kwargs)
        _cross_origin_header = {"Access-Control-Allow-Origin" : origin,
            "Access-Control-Allow-Headers" :
            "Origin, X-Requested-With, Content-Type, Accept"}
        if isinstance(ret, tuple) :
        INDENT
            if len(ret) == 2 and isinstance(ret [0], dict) and isinstance(ret [1], int) :
            INDENT
                return ret [0], ret [1], _cross_origin_header
            DEDENT
            elif isinstance(ret, basestring) :
            INDENT
                response = make_response(ret)
                response.headers ["Access-Control-Allow-Origin"] = origin
                response.headers ["Access-Control-Allow-Headers"] = "Origin, X-Requested-With, Content-Type, Accept"
                return response
            DEDENT
            elif isinstance(ret, Response) :
            INDENT
                ret.headers ["Access-Control-Allow-Origin"] = origin
                ret.headers ["Access-Control-Allow-Headers"] = "Origin, X-Requested-With, Content-Type, Accept"
                return ret
            DEDENT
            else :
            INDENT
                raise ValueError("Cannot handle cross origin, because the return value is not matched!")
            DEDENT
        DEDENT
        return ret
    DEDENT
    return _decoration
DEDENT
----------------------------------------
