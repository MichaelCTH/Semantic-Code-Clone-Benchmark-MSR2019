$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45386171_45396948_3_16
45386171_49706289_2_22
Title: Shorten a Python turtle program for a house 
----------------------------------------

def yellowHouse(side_length) :
INDENT
    wn.register_shape("brick", ((0, 0), (- 0.5, - 0.5), (0.5, - 0.5)))
    house = Turtle('brick', visible = False)
    house.shapesize(stretch_wid = side_length, outline = 5)
    house.color("yellow", wn.bgcolor())
    house.penup()
    for angle in range(360, 0, - 90) :
    INDENT
        house.setheading(angle)
        house.stamp()
    DEDENT
    house.forward(side_length)
    house.stamp()
DEDENT
----------------------------------------

def yellowHouse() :
INDENT
    wn = turtle.Screen()
    wn.title("Yellow House")
    wn.bgcolor("Blue")
    house = turtle.Turtle()
    house.pensize(5)
    house.speed(4.6)
    house.color("Yellow")
    side = 200
    diag = (2 * (side ** 2)) ** 0.5
    ang = 90
    for i in range(4) :
    INDENT
        house.fd(side)
        house.lt(ang)
    DEDENT
    house.lt(ang / 2)
    moves = [(diag, ang), (diag / 2, ang), (diag / 2, ang), (diag, ang)]
    for (move, turn) in moves :
    INDENT
        house.fd(move)
        house.lt(turn)
    DEDENT
    wn.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45400664_45400874_3_10
45400664_45400912_1_22
Title: "String index out of range Python" 
----------------------------------------

def increment_string(s) :
INDENT
    number = search('\d+$', s)
    if number ! = None :
    INDENT
        number = number.group()
        first_part = s.split(number) [0]
        return first_part + str(int(number) + 1)
    DEDENT
    else :
    INDENT
        return s + '1'
    DEDENT
DEDENT
----------------------------------------

def increment_string(strng) :
INDENT
    if strng == "" :
    INDENT
        return "1"
    DEDENT
    elif strng [- 1].isdigit() :
    INDENT
        exp_strng = strng [: : - 1]
        new_strng = ""
        new_strng1 = ""
        for i in exp_strng :
        INDENT
            if i.isdigit() :
            INDENT
                new_strng += i
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        new_strng = new_strng [: : - 1]
        new_strng1 = int(new_strng) + 1
        new_strng1 = '{num:{fill}{width}}'.format(num = new_strng1, fill = '0', width = len(new_strng))
        return strng [: - len(new_strng)] + new_strng1
    DEDENT
    else :
    INDENT
        strng += "1"
        return strng
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45418631_45419011_6_12
45418631_45420259_14_34
Title: python multiprocessing shared variable safe 
----------------------------------------

def main() :
INDENT
    pool = Pool(16)
    ma = Manager()
    counter = ma.Value('i', 0)
    lock = ma.Lock()
    for i in range(100) :
    INDENT
        pool.apply_async(a_complex_operation, args = (counter, lock))
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    pool = Pool(16)
    list_ = Manager().list()
    counter = Manager().Value('i', 0)
    lock = Manager().Lock()
    for i in range(100) :
    INDENT
        pool.apply_async(a_complex_operation, args = (list_, counter, lock))
    DEDENT
    pool.close()
    pool.join()
    if len(list_) ! = 1000 :
    INDENT
        print "><![CDATA[>> length of list is not equal 1000, current is:" + str(len(list_))
    DEDENT
    elif len(list_) == 1000 :
    INDENT
        print "><![CDATA[>> length of list is equal 1000"
    DEDENT
    if counter.value ! = 1000 :
    INDENT
        print "value of counter is not equal 1000, current is :" + str(counter.value)
    DEDENT
    elif counter.value == 1000 :
    INDENT
        print "value of counter is equal 1000"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45427554_45427604_5_14
45427554_45428837_7_20
Title: Button calling a function in Maya 
----------------------------------------

def create_window(self) :
INDENT
    window = cmds.window()
    cmds.rowColumnLayout(numberOfColumns = 2, columnWidth = [(1, 50), (1, 70)])
    cmds.text(label = 'Name')
    axis = cmds.textField()
    cmds.showWindow(window)
    self.text_entered = cmds.textField(axis, query = True, text = True)
    cmds.button(label = "asd", command = self.printText)
    return
DEDENT
----------------------------------------

def create_window(self) :
INDENT
    if cmds.window("UI", exists = True) :
    INDENT
        cmds.deleteUI("UI")
    DEDENT
    win = cmds.window("UI")
    cmds.columnLayout()
    textEntered = cmds.textField()
    def print_text_contents(a) :
    INDENT
        print cmds.textField(textEntered, query = True, text = True)
    DEDENT
    cmds.button(label = 'Confirm', command = print_text_contents)
    cmds.showWindow(win)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45432007_45432183_14_19
45432007_45438152_19_26
Title: Calling class method in python thread queue 
----------------------------------------

def run(self) :
INDENT
    for thing in self.things :
    INDENT
        t = Thread(target = thing.print_name, name = thing.name)
        t.daemon = True
        t.start()
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    for thing in self.things :
    INDENT
        t = Thread(target = thing.print_name, name = thing.name, args = (self.thread_queue,))
        t.daemon = True
        t.start()
        self.thread_queue.put(t)
    DEDENT
    self.thread_queue.join()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45433660_45440977_16_28
45433660_45440977_6_14
Title: wx python how to place a button on a frame 
----------------------------------------

def __init__(self, frame) :
INDENT
    wx.Panel.__init__(self, frame)

    button_sizer = self.save_cancel()

    main_sizer = wx.BoxSizer(wx.VERTICAL)
    main_sizer.Add((400, 0))
    main_sizer.Add(button_sizer, proportion = 1, flag = wx.EXPAND)
    self.SetSizer(main_sizer)
    self.Fit()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1,
        'Demonstrate wxPython button')
    self.panel = MainPanel(self)
    self.Fit()
    self.Centre()
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45433660_45440977_16_28
45433660_45442657_11_20
Title: wx python how to place a button on a frame 
----------------------------------------

def __init__(self, frame) :
INDENT
    wx.Panel.__init__(self, frame)

    button_sizer = self.save_cancel()

    main_sizer = wx.BoxSizer(wx.VERTICAL)
    main_sizer.Add((400, 0))
    main_sizer.Add(button_sizer, proportion = 1, flag = wx.EXPAND)
    self.SetSizer(main_sizer)
    self.Fit()
DEDENT
----------------------------------------

def __init__(self, frame) :
INDENT
    wx.Panel.__init__(self, frame)
    button_sizer = self._button_sizer(frame)
    main_sizer = wx.BoxSizer(wx.VERTICAL)
    main_sizer.Add(button_sizer, proportion = 1, flag = wx.EXPAND)
    self.SetSizer(main_sizer)
    self.Fit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45433660_45440977_6_14
45433660_45442657_11_20
Title: wx python how to place a button on a frame 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1,
        'Demonstrate wxPython button')
    self.panel = MainPanel(self)
    self.Fit()
    self.Centre()
    self.Show()

DEDENT
----------------------------------------

def __init__(self, frame) :
INDENT
    wx.Panel.__init__(self, frame)
    button_sizer = self._button_sizer(frame)
    main_sizer = wx.BoxSizer(wx.VERTICAL)
    main_sizer.Add(button_sizer, proportion = 1, flag = wx.EXPAND)
    self.SetSizer(main_sizer)
    self.Fit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45442377_45443536_1_11
45442377_45446509_50_65
Title: unable to fix this 
----------------------------------------

def add_tent(self, new_tent_loc) :
INDENT
    try :
    INDENT
        self.tent_loc [object] += 1
    DEDENT
    except :
    INDENT
        self.tent_loc [object] = 1
    DEDENT
    return new_tent_loc in self.tent_loc
DEDENT
----------------------------------------

def add_tent(self, new_tent_loc) :
INDENT
    assert isinstance(new_tent_loc, Location)
    added = False
    for tent_loc in self.tent_locs :
    INDENT
        if tent_loc.dist_from(new_tent_loc) < = 0.5 :
        INDENT
            break
        DEDENT
    DEDENT
    else :
    INDENT
        self.tent_locs.append(new_tent_loc)
        added = True
    DEDENT
    return added
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45474651_45474698_11_20
45474651_45474700_11_15
Title: Making property of class in python 
----------------------------------------

def first_name(self, value) :
INDENT
    print (value, isinstance(value, str))
    if not isinstance(value, str) :
    INDENT
        raise TypeError("expected a string")
    DEDENT
    self._first_name = value

DEDENT
----------------------------------------

def first_name(self, value) :
INDENT
    print (value, isinstance(value, str))
    if not isinstance(value, str) :
    INDENT
        raise TypeError("expected a string")
    DEDENT
    self._first_name = value
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45504277_45504614_1_18
45504277_45504708_1_16
Title: Python Requests Exceptions 
----------------------------------------

def job(lk) :
INDENT
    session = requests.session()
    headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0'}
    try :
    INDENT

        r = session.get("https://www.example.com/login/")
        post = session.post(
            'https://www.example.com',
            data = {"log" : "name", "pwd" : "name",},
            headers = headers)
        rGet = session.get('https://www.example.com')

    DEDENT
    except requests.exceptions.ConnectionError as C :
    INDENT
        print "Failed 2"
    DEDENT
    except requests.exceptions.TooManyRedirects :
    INDENT
        print "Failed 3"
    DEDENT
DEDENT
----------------------------------------

def job(lk) :
INDENT
    try :
    INDENT
        session = requests.session()
        headers = {'User-Agent' : 'Mozilla/5.0 (Windows NT 6.3; WOW64; rv:54.0) Gecko/20100101 Firefox/54.0'}
        r = session.get("https://www.example.com/login/")
        post = session.post('https://www.example.com', data = {"log" : "name",
                "pwd" : "name",},
            headers = headers)
        rGet = session.get('https://www.example.com')

    DEDENT
    except requests.exceptions.ConnectionError :
    INDENT
        print ("Failed 2")
    DEDENT
    except requests.exceptions.TooManyRedirects :
    INDENT
        print ("Failed 3")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45512980_45513324_20_31
45512980_45513616_12_21
Title: resetting password python program 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        password_1 = getpass.getpass()
        print "One more time"
        password_2 = getpass.getpass()
        if (password_1 ! = password_2) or not (checkupper(password_1)) or not (checklower(password_2)) or not (len(password_1) > = 8) :
        INDENT
            print "Please try again"
            continue
        DEDENT
        else :
        INDENT
            logged()
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        password = getpass()
        if password == getpass() :
        INDENT
            if check_password(password) :
            INDENT
                print ('Successfully logged in.')
                break
            DEDENT
        DEDENT
        else :
        INDENT
            print ('Try again!')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45512980_45513324_20_31
45512980_45529508_52_60
Title: resetting password python program 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        password_1 = getpass.getpass()
        print "One more time"
        password_2 = getpass.getpass()
        if (password_1 ! = password_2) or not (checkupper(password_1)) or not (checklower(password_2)) or not (len(password_1) > = 8) :
        INDENT
            print "Please try again"
            continue
        DEDENT
        else :
        INDENT
            logged()
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    flag = get_password()
    if flag == True :
    INDENT
        logged()
    DEDENT
    else :
    INDENT
        while True :
        INDENT

            get_password()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45512980_45513616_12_21
45512980_45529508_52_60
Title: resetting password python program 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        password = getpass()
        if password == getpass() :
        INDENT
            if check_password(password) :
            INDENT
                print ('Successfully logged in.')
                break
            DEDENT
        DEDENT
        else :
        INDENT
            print ('Try again!')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    flag = get_password()
    if flag == True :
    INDENT
        logged()
    DEDENT
    else :
    INDENT
        while True :
        INDENT

            get_password()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45512980_45513616_4_11
45512980_45529508_18_23
Title: resetting password python program 
----------------------------------------

def check_password(password) :
INDENT
    if len(password) > 9 :
    INDENT
        return False
    DEDENT
    for character in password :
    INDENT
        if character.isupper() :
        INDENT
            return True

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def check_password(password, password2) :
INDENT
    if password == password2 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45516072_45552463_110_134
45516072_45552463_16_43
Title: Rotating hit box rects in pygame 
----------------------------------------

def __init__(self) :
INDENT
    self.done = False
    self.screen = pg.display.set_mode((800, 600))
    self.clock = pg.time.Clock()
    self.bg_color = pg.Color(60, 60, 60)
    self.space = pm.Space()
    self.space.gravity = Vec2d(0.0, 0.0)
    self.space.damping =.4
    self.all_sprites = pg.sprite.Group()
    self.player = Player((100, 300), self.space)
    self.all_sprites.add(self.player)
    vertices = [
        ([80, 120], ((0, 0), (100, 0), (70, 100), (0, 100))),
        ([400, 250], ((20, 40), (100, 0), (80, 80), (10, 100))),
        ([200, 450], ((20, 40), (300, 0), (300, 120), (10, 100))),
        ([760, 10], ((0, 0), (30, 0), (30, 420), (0, 400))),
        ]
    for pos, verts in vertices :
    INDENT
        Wall(pos, verts, self.space, 1, self.all_sprites)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, pos, space, mass = 0.3) :
INDENT
    super().__init__()
    self.image = pg.Surface((52, 72), pg.SRCALPHA)
    pg.draw.polygon(self.image, pg.Color('steelblue2'),
        [(1, 72), (26, 1), (51, 72)])
    self.rect = self.image.get_rect(center = pos)
    self.orig_image = self.image

    vertices = [(0, 36), (26, - 36), (- 26, - 36)]
    moment = pm.moment_for_poly(mass, vertices)
    self.body = pm.Body(mass, moment)
    self.shape = pm.Poly(self.body, vertices, radius = 3)
    self.shape.friction =.8
    self.shape.elasticity =.2
    self.body.position = pos
    self.space = space
    self.space.add(self.body, self.shape)
    self.accel_forw = False
    self.accel_back = False
    self.turn_left = False
    self.turn_right = False
    self.topspeed = 1790
    self.angle = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45516072_45552463_110_134
45516072_45552463_86_107
Title: Rotating hit box rects in pygame 
----------------------------------------

def __init__(self) :
INDENT
    self.done = False
    self.screen = pg.display.set_mode((800, 600))
    self.clock = pg.time.Clock()
    self.bg_color = pg.Color(60, 60, 60)
    self.space = pm.Space()
    self.space.gravity = Vec2d(0.0, 0.0)
    self.space.damping =.4
    self.all_sprites = pg.sprite.Group()
    self.player = Player((100, 300), self.space)
    self.all_sprites.add(self.player)
    vertices = [
        ([80, 120], ((0, 0), (100, 0), (70, 100), (0, 100))),
        ([400, 250], ((20, 40), (100, 0), (80, 80), (10, 100))),
        ([200, 450], ((20, 40), (300, 0), (300, 120), (10, 100))),
        ([760, 10], ((0, 0), (30, 0), (30, 420), (0, 400))),
        ]
    for pos, verts in vertices :
    INDENT
        Wall(pos, verts, self.space, 1, self.all_sprites)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, pos, verts, space, mass, * sprite_groups) :
INDENT
    super().__init__(* sprite_groups)
    width = max(v [0] for v in verts)
    height = max(v [1] for v in verts)
    self.image = pg.Surface((width, height), pg.SRCALPHA)
    pg.draw.polygon(self.image, pg.Color('sienna1'), verts)
    self.rect = self.image.get_rect(topleft = pos)
    moment = pm.moment_for_poly(mass, verts)
    self.body = pm.Body(mass, moment, pm.Body.STATIC)

    verts2 = [(x, - y) for x, y in verts]
    self.shape = pm.Poly(self.body, verts2, radius = 2)
    self.shape.friction = 1.0
    self.shape.elasticity =.52
    self.body.position = flipy(pos)
    self.space = space
    self.space.add(self.shape)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45516072_45552463_16_43
45516072_45552463_86_107
Title: Rotating hit box rects in pygame 
----------------------------------------

def __init__(self, pos, space, mass = 0.3) :
INDENT
    super().__init__()
    self.image = pg.Surface((52, 72), pg.SRCALPHA)
    pg.draw.polygon(self.image, pg.Color('steelblue2'),
        [(1, 72), (26, 1), (51, 72)])
    self.rect = self.image.get_rect(center = pos)
    self.orig_image = self.image

    vertices = [(0, 36), (26, - 36), (- 26, - 36)]
    moment = pm.moment_for_poly(mass, vertices)
    self.body = pm.Body(mass, moment)
    self.shape = pm.Poly(self.body, vertices, radius = 3)
    self.shape.friction =.8
    self.shape.elasticity =.2
    self.body.position = pos
    self.space = space
    self.space.add(self.body, self.shape)
    self.accel_forw = False
    self.accel_back = False
    self.turn_left = False
    self.turn_right = False
    self.topspeed = 1790
    self.angle = 0
DEDENT
----------------------------------------

def __init__(self, pos, verts, space, mass, * sprite_groups) :
INDENT
    super().__init__(* sprite_groups)
    width = max(v [0] for v in verts)
    height = max(v [1] for v in verts)
    self.image = pg.Surface((width, height), pg.SRCALPHA)
    pg.draw.polygon(self.image, pg.Color('sienna1'), verts)
    self.rect = self.image.get_rect(topleft = pos)
    moment = pm.moment_for_poly(mass, verts)
    self.body = pm.Body(mass, moment, pm.Body.STATIC)

    verts2 = [(x, - y) for x, y in verts]
    self.shape = pm.Poly(self.body, verts2, radius = 2)
    self.shape.friction = 1.0
    self.shape.elasticity =.52
    self.body.position = flipy(pos)
    self.space = space
    self.space.add(self.shape)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45528637_45528742_2_27
45528637_46705424_1_14
Title: checking integer overflow in python 
----------------------------------------

def reverse(self, x) :
INDENT
    negative = False
    if (x < 0) :
    INDENT
        x = x * - 1
        negative = True
    DEDENT
    else :
    INDENT
        x = x
    DEDENT
    sum = 0
    dig = 1
    strX = str(x)
    lst = list(strX)
    for i in lst :
    INDENT
        sum += int(i) * dig
        dig *= 10
    DEDENT
    if (abs(sum) > ((1 < < 31) - 1)) :
    INDENT
        return 0
    DEDENT
    elif (negative == True) :
    INDENT
        return sum * - 1
    DEDENT
    else :
    INDENT
        return sum
    DEDENT
DEDENT
----------------------------------------

def reverse(self, x) :
INDENT
    neg = False
    if x < 0 :
    INDENT
        neg = True
        x = x * - 1
    DEDENT
    s = str(x) [: : - 1]
    n = int(s)
    if neg :
    INDENT
        n = n * - 1
    DEDENT
    if (abs(n) > (2 ** 31 - 1)) :
    INDENT
        return 0
    DEDENT
    return n
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45552624_45552732_1_8
45552624_45591438_1_10
Title: List index out of range (using json) 
----------------------------------------

def lootprice(json_object, name) :
INDENT
    try :
    INDENT
        needobj = [obj for obj in json_object if obj ['name'] == name] [0]
    DEDENT
    except IndexError :
    INDENT
        return None
    DEDENT
    if needobj ['have'] < needobj ['max'] :
    INDENT
        return needobj ['price']
    DEDENT
DEDENT
----------------------------------------

def lootprice(json_object, name) :
INDENT
    price = None
    objects = [obj for obj in json_object if obj ['name'] == name]
    if not objects :
    INDENT
        needobj = objects [0]
        if needobj ['have'] < needobj ['max'] :
        INDENT
            price = needobj ['price']
        DEDENT
    DEDENT
    return price
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45553478_45553621_2_22
45553478_45557343_3_18
Title: How do i define a list without adding any values? 
----------------------------------------

def random_list() :
INDENT
    suits = ["D", "S", "C", "h"]
    cardnumbers = ["A", 2, 3, 4, 5, 6, 7, 8, 9, "J", "Q", "K"]
    point1 = point = m = 0
    List1 = []
    List2 = []
    List3 = []
    listnames = [List1, List2, List3]
    while point < 3 :
    INDENT
        y = listnames [m]
        m = m + 1
        while point1 < 7 :
        INDENT
            randomsuite = random.randint(0, 3)
            randomnumber = random.randint(0, 11)
            x = cardnumbers [randomnumber], suits [randomsuite];
            y.append(x)
            point1 = point1 + 1
        DEDENT
        point = point + 1
        point1 = 0
    DEDENT
    return listnames
DEDENT
----------------------------------------

def random_list(deals_per_list = 3, cards_per_deal = 7) :
INDENT
    suits = ["D", "S", "C", "H"]
    cardnumbers = ["A", 2, 3, 4, 5, 6, 7, 8, 9, "J", "Q", "K"]
    list_of_deals = []
    for _ in range(deals_per_list) :
    INDENT
        list_of_deals.append([])
    DEDENT
    for deal in list_of_deals :
    INDENT
        while len(deal) < cards_per_deal :
        INDENT
            card = (choice(suits), choice(cardnumbers))
            if card not in deal :
            INDENT
                deal.append(card)
            DEDENT
        DEDENT
    DEDENT
    return list_of_deals
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45553478_45553632_1_22
45553478_45557343_3_18
Title: How do i define a list without adding any values? 
----------------------------------------

def random_list() :
INDENT
    suits = ["D", "S", "C", "h"]
    cardnumbers = ["A", 2, 3, 4, 5, 6, 7, 8, 9, "J", "Q", "K"]
    point1 = point = m = 0
    List1 = []
    List2 = []
    List3 = []
    listnames = [List1], [List2], [List3]
    while point < 3 :
    INDENT
        y = listnames [m]
        m = m + 1
        while point1 < 7 :
        INDENT
            randomsuite = random.randint(0, 3)
            randomnumber = random.randint(0, 11)
            x = cardnumbers [randomnumber], suits [randomsuite];
            y.append(x)
            point1 = point1 + 1
        DEDENT
        point = point + 1
        point1 = 0
    DEDENT
    for x in range(0, len(listnames)) :
    INDENT
        listnames [x].pop(0)
    DEDENT
    return listnames
DEDENT
----------------------------------------

def random_list(deals_per_list = 3, cards_per_deal = 7) :
INDENT
    suits = ["D", "S", "C", "H"]
    cardnumbers = ["A", 2, 3, 4, 5, 6, 7, 8, 9, "J", "Q", "K"]
    list_of_deals = []
    for _ in range(deals_per_list) :
    INDENT
        list_of_deals.append([])
    DEDENT
    for deal in list_of_deals :
    INDENT
        while len(deal) < cards_per_deal :
        INDENT
            card = (choice(suits), choice(cardnumbers))
            if card not in deal :
            INDENT
                deal.append(card)
            DEDENT
        DEDENT
    DEDENT
    return list_of_deals
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4556217_4557322_7_17
4556217_9359132_7_14
Title: Memoization with prime number generator 
----------------------------------------

def test(self, candidate) :
INDENT
    while len(self.primes) > self.to_use :
    INDENT
        next = self.primes [self.to_use]
        if candidate < = next * next : self.to_use += 1
    DEDENT
    return all(candidate % p ! = 0 for p in self.primes [: self.to_use])

DEDENT
----------------------------------------

def test(self, candidate) :
INDENT
    next = self.primes [self.to_use]
    if candidate > = next * next :
    INDENT
        self.to_use += 1
        print candidate, next
    DEDENT
    return all(candidate % p ! = 0 for p in self.primes [: self.to_use])

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45563626_45564189_1_12
45563626_45568735_5_25
Title: "Given a string find the count of possible codes that string can generate using Python" 
----------------------------------------

def get_combination(string) :
INDENT
    def get_branchs(offset = 0) :
    INDENT
        if len(string) - offset < = 1 :
        INDENT
            return 0
        DEDENT
        if string [offset : 2 + offset] < = '26' :
        INDENT
            if '0' not in string [1 + offset : 3 + offset] :
            INDENT
                return 1 + get_branchs(1 + offset) + get_branchs(2 + offset)
            DEDENT
            else :
            INDENT
                return get_branchs(2 + offset)
            DEDENT
        DEDENT
        else :
        INDENT
            return get_branchs(1 + offset)
        DEDENT
    DEDENT
    return 1 + get_branchs()
DEDENT
----------------------------------------

def get_combination(string) :
INDENT
    def fib_to(n) :
    INDENT
        fibs = [1, 1]
        for i in range(2, n + 1) :
        INDENT
            fibs.append(fibs [- 1] + fibs [- 2])
        DEDENT
        return fibs

    DEDENT
    if re.search(r"(?<![12])0", string) :
    INDENT
        return 0
    DEDENT
    sequences = re.findall(r"[12]*?(?:[3-6]|1[3-9]|(?=.0|$))", string)
    if not sequences :
    INDENT
        return 1
    DEDENT
    sizes = [len(seq) for seq in sequences]
    fib = fib_to(max(sizes))
    return reduce(mul, [fib [size] for size in sizes], 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45573217_45573399_1_15
45573217_45573456_3_11
Title: Error handling but still getting a ValueError 
----------------------------------------

def load_file(file) :
INDENT
    file = open(file, "r")
    all_lines = file.read()
    try :
    INDENT
        return int(all_lines)
    DEDENT
    except ValueError :
    INDENT
        try :
        INDENT
            return float(all_lines)
        DEDENT
        except ValueError :
        INDENT
            return all_lines
        DEDENT
    DEDENT
    file.close()
DEDENT
----------------------------------------

def load_file(file) :
INDENT
    with open(file, "r") as file :
    INDENT
        all_lines = file.read()
    DEDENT
    with suppress(ValueError) :
    INDENT
        return int(all_lines)
    DEDENT
    with suppress(ValueError) :
    INDENT
        return float(all_lines)
    DEDENT
    return all_lines
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45573598_45573723_1_15
45573598_45574011_16_29
Title: How to iterate through a dictionary of tuples? 
----------------------------------------

def getSeason(dt) :
INDENT
    season = None
    for t, ranges in seasons.items() :
    INDENT
        for start, end in ranges :
        INDENT
            if start [0] < = end [0] or (start [0] == end [0] and start [1] < = end [1]) :
            INDENT
                if date(dt.year, start [0], start [1]) < = dt.date() < = date(dt.year, end [0], end [1]) :
                INDENT
                    season = t
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                if (date(dt.year, start [0], start [1]) < = dt.date() < = date(dt.year + 1, end [0], end [1])) or (date(dt.year - 1, start [0], start [1]) < = dt.date() < = date(dt.year, end [0], end [1])) :
                INDENT
                    season = t
                    break
                DEDENT
            DEDENT
        DEDENT
        if season is not None :
        INDENT
            break
        DEDENT
    DEDENT
    return season
DEDENT
----------------------------------------

def getSeason(dt) :
INDENT
    for t, (start, end) in seasons.iteritems() :
    INDENT
        if start [0] < end [0] and datetime(dt.year, start [0], start [1]) < = dt < = datetime(dt.year, end [0], end [1]) :
        INDENT
            return t
        DEDENT
        elif (start [0] > end [0] and
            (datetime(dt.year, start [0], start [1]) < = dt < = datetime(dt.year + 1, end [0], end [1]) or
                datetime(dt.year - 1, start [0], start [1]) < = dt < = datetime(dt.year, end [0], end [1]))) :
        INDENT
            return t
        DEDENT
        else :
        INDENT
            continue
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45573598_45573723_1_15
45573598_45574587_15_28
Title: How to iterate through a dictionary of tuples? 
----------------------------------------

def getSeason(dt) :
INDENT
    season = None
    for t, ranges in seasons.items() :
    INDENT
        for start, end in ranges :
        INDENT
            if start [0] < = end [0] or (start [0] == end [0] and start [1] < = end [1]) :
            INDENT
                if date(dt.year, start [0], start [1]) < = dt.date() < = date(dt.year, end [0], end [1]) :
                INDENT
                    season = t
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                if (date(dt.year, start [0], start [1]) < = dt.date() < = date(dt.year + 1, end [0], end [1])) or (date(dt.year - 1, start [0], start [1]) < = dt.date() < = date(dt.year, end [0], end [1])) :
                INDENT
                    season = t
                    break
                DEDENT
            DEDENT
        DEDENT
        if season is not None :
        INDENT
            break
        DEDENT
    DEDENT
    return season
DEDENT
----------------------------------------

def getSeason(dt) :
INDENT
    for sname, duration in seasons.items() :
    INDENT
        start, end = duration
        start_date = date(dt.year, start [0], start [1])
        end_date = date(dt.year, end [0], end [1])
        if dt < start_date :
        INDENT
            start_date = date(start_date.year - 1, start_date.month, start_date.day)
            end_date = date(end_date.year - 1, end_date.month, end_date.day)
        DEDENT
        if end_date < start_date :
        INDENT
            end_date = date(end_date.year + 1, end_date.month, end_date.day)
        DEDENT
        if start_date < = dt < = end_date :
        INDENT
            return sname
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45573598_45574011_16_29
45573598_45574587_15_28
Title: How to iterate through a dictionary of tuples? 
----------------------------------------

def getSeason(dt) :
INDENT
    for t, (start, end) in seasons.iteritems() :
    INDENT
        if start [0] < end [0] and datetime(dt.year, start [0], start [1]) < = dt < = datetime(dt.year, end [0], end [1]) :
        INDENT
            return t
        DEDENT
        elif (start [0] > end [0] and
            (datetime(dt.year, start [0], start [1]) < = dt < = datetime(dt.year + 1, end [0], end [1]) or
                datetime(dt.year - 1, start [0], start [1]) < = dt < = datetime(dt.year, end [0], end [1]))) :
        INDENT
            return t
        DEDENT
        else :
        INDENT
            continue
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def getSeason(dt) :
INDENT
    for sname, duration in seasons.items() :
    INDENT
        start, end = duration
        start_date = date(dt.year, start [0], start [1])
        end_date = date(dt.year, end [0], end [1])
        if dt < start_date :
        INDENT
            start_date = date(start_date.year - 1, start_date.month, start_date.day)
            end_date = date(end_date.year - 1, end_date.month, end_date.day)
        DEDENT
        if end_date < start_date :
        INDENT
            end_date = date(end_date.year + 1, end_date.month, end_date.day)
        DEDENT
        if start_date < = dt < = end_date :
        INDENT
            return sname
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45600785_45600999_1_11
45600785_45601209_1_20
Title: python programming string handling 
----------------------------------------

def depth(s) :
INDENT
    count = 0
    max = 0
    for character in s :
    INDENT
        if character == "(" :
        INDENT
            count += 1
            if count > max :
            INDENT
                max = count
            DEDENT
        DEDENT
        elif character == ")" :
        INDENT
            count -= 1
        DEDENT
    DEDENT
    return max
DEDENT
----------------------------------------

def depth(str, index = 0, counter = 0, max_depth = 0) :
INDENT
    while index < len(str) :
    INDENT
        if str [index] == '(' :
        INDENT
            counter += 1
            counter, index, max_depth = depth(str, index + 1, counter, max_depth)
            counter = 0
            index += 1
            continue
        DEDENT
        if str [index] == ')' :
        INDENT
            if counter > max_depth :
            INDENT
                max_depth = counter
            DEDENT
            return counter, index, max_depth
        DEDENT
        else :
        INDENT
            index += 1
        DEDENT
    DEDENT
    return max_depth
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45601364_45601445_13_29
45601364_45601486_13_29
Title: Django - TDD: 'HttpRequest' has no attribute 'POST' 
----------------------------------------

def test_details(self) :
INDENT
    request = self.factory.get('/customer/details')

    request.user = self.user

    request.user = AnonymousUser()

    response = my_view(request)
    response = MyView.as_view()(request)
    self.assertEqual(response.status_code, 200)
DEDENT
----------------------------------------

def test_details(self) :
INDENT
    request = self.factory.get('/customer/details')

    request.user = self.user

    request.user = AnonymousUser()

    response = my_view(request)
    response = MyView.as_view()(request)
    self.assertEqual(response.status_code, 200)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45618981_45619026_1_12
45618981_45619640_1_20
Title: Convert String to Dictionary Location in Python 
----------------------------------------

def main(locate_user_id) :
INDENT
    response = {
        "users" : [{
                "id" : 1,
                "name" : "Joe"}, {
                "id" : 2,
                "name" : "Bob"}]}
    print (eval('response' + locate_user_id))
DEDENT
----------------------------------------

def main(locate_user_id) :
INDENT
    response = {
        "users" : [{
                "id" : 1,
                "name" : "Joe"}, {
                "id" : 2,
                "name" : "Bob"}]}
    print (response)
    print (locate_user_id)
    keys = locate_user_id.replace(']', '').split('[')
    keys [0] = '"' + keys [0] + '"'
    eval_str = '[' + ']['.join(keys) + ']'
    print (eval(str(response) + eval_str))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45618981_45619640_1_20
45618981_45622690_1_14
Title: Convert String to Dictionary Location in Python 
----------------------------------------

def main(locate_user_id) :
INDENT
    response = {
        "users" : [{
                "id" : 1,
                "name" : "Joe"}, {
                "id" : 2,
                "name" : "Bob"}]}
    print (response)
    print (locate_user_id)
    keys = locate_user_id.replace(']', '').split('[')
    keys [0] = '"' + keys [0] + '"'
    eval_str = '[' + ']['.join(keys) + ']'
    print (eval(str(response) + eval_str))
DEDENT
----------------------------------------

def main(locate_user_id) :
INDENT
    response = {
        "users" : [{
                "id" : 1,
                "name" : "Joe"}, {
                "id" : 2,
                "name" : "Bob"}]}
    print (("{" + locate_user_id + "}").format(response))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45644772_45644920_1_10
45644772_45644985_16_30
Title: Inserting Node at given position 
----------------------------------------

def InsertNpos(self, new_data, pos) :
INDENT
    if pos == 0 :
    INDENT
        self.head = Node(new_data, self.head)
        return
    DEDENT
    start = self.head
    while pos > 1 :
    INDENT
        start = start.next
        pos -= 1
    DEDENT
    start.next = Node(new_data, start.next)
DEDENT
----------------------------------------

def InsertNpos(self, new_data, pos) :
INDENT
    if pos == 0 :
    INDENT
        self.head = Node(new_data, self.head)
        return self.head
    DEDENT
    i = 0
    curr = self.head
    while curr.next :
    INDENT
        if i == pos - 1 :
        INDENT
            curr.next = Node(new_data, curr.next)
            return self.head
        DEDENT
        curr = curr.next
        i += 1
    DEDENT
    curr.next = Node(new_data)
    return self.head
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45647991_45685800_1_19
45647991_45774598_1_13
Title: python function for valley with ascending descending 
----------------------------------------

def valley(list) :
INDENT
    if (len(list) == 0) :
    INDENT
        return (True)
    DEDENT
    if (len(list) == 1) :
    INDENT
        return (False)
    DEDENT
    if (list [0] < list [1]) :
    INDENT
        return (False)
    DEDENT
    for i in range(0, len(list) - 1) :
    INDENT
        if (list [i] < list [i + 1]) :
        INDENT
            pos = i
            break
        DEDENT
        if (list [i] == list [i + 1]) :
        INDENT
            return (False)
        DEDENT
    DEDENT
    else :
    INDENT
        return (False)
    DEDENT
    for i in range(pos, len(list) - 1) :
    INDENT
        if (list [i] > = list [i + 1]) :
        INDENT
            return (False)
        DEDENT
    DEDENT
    return (True)
DEDENT
----------------------------------------

def valley(l) :
INDENT
    if (len(l) < 3) :
    INDENT
        return (False)
    DEDENT
    for i in range(0, len(l) - 1) :
    INDENT
        if (l [i] < l [i + 1]) :
        INDENT
            for i in range(i, len(l) - 1) :
            INDENT
                if (l [i] > = l [i + 1]) :
                INDENT
                    return (False)
                DEDENT
            DEDENT
            return (True)
        DEDENT
        elif (l [i] == l [i + 1]) :
        INDENT
            return (False)
        DEDENT
        else :
        INDENT
            return (False)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45652435_45652556_1_11
45652435_45652762_16_29
Title: BST insertion function in Python 
----------------------------------------

def insert(self, root, val) :
INDENT
    if root is None :
    INDENT
        return Node(val)
    DEDENT
    else :
    INDENT
        if root.data < = val :
        INDENT
            root.Rightchild = self.insert(root.Rightchild, val)
        DEDENT
        else :
        INDENT
            root.Leftchild = self.insert(root.Leftchild, val)
        DEDENT
        return root
    DEDENT
DEDENT
----------------------------------------

def insert(root, data) :
INDENT
    node = Node(data)
    if root is None :
    INDENT
        root = node
    DEDENT
    elif root.data > = data :
    INDENT
        if root.left is None :
        INDENT
            root.left = node
        DEDENT
        else :
        INDENT
            insert(root.left, data)
        DEDENT
    DEDENT
    else :
    INDENT
        if root.right is None :
        INDENT
            root.right = node
        DEDENT
        else :
        INDENT
            insert(root.right, data)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45652435_45652762_16_29
45652435_45652887_10_20
Title: BST insertion function in Python 
----------------------------------------

def insert(root, data) :
INDENT
    node = Node(data)
    if root is None :
    INDENT
        root = node
    DEDENT
    elif root.data > = data :
    INDENT
        if root.left is None :
        INDENT
            root.left = node
        DEDENT
        else :
        INDENT
            insert(root.left, data)
        DEDENT
    DEDENT
    else :
    INDENT
        if root.right is None :
        INDENT
            root.right = node
        DEDENT
        else :
        INDENT
            insert(root.right, data)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def insert(self, root, val) :
INDENT
    if root is None :
    INDENT
        root = Node(val)
        return root
    DEDENT
    else :
    INDENT
        if root.data < = val :
        INDENT
            root.Rightchild = self.insert(root.Rightchild, val)
        DEDENT
        else :
        INDENT
            root.Leftchild = self.insert(root.Leftchild, val)
        DEDENT
        return root
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45652435_45652762_8_15
45652435_45652887_21_27
Title: BST insertion function in Python 
----------------------------------------

def inorder(root) :
INDENT
    if root :
    INDENT
        inorder(root.left)
        arr.append(root.data)
        print root.data,
        inorder(root.right)
    DEDENT
DEDENT
----------------------------------------

def inorder(self, root) :
INDENT
    if root :
    INDENT
        self.inorder(root.Leftchild)
        print root.data,
        self.inorder(root.Rightchild)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4566313_4566391_1_17
4566313_4567528_9_37
Title: Handling Python program arguments in a json file 
----------------------------------------

def get_parameters(some_file_name) :
INDENT
    source = json.loads(some_file_name)
    return dict(
        mpi_nodes = source.get('mpi-nodes', 1),
        cluster_size = source ['cluster-size'],
        initial_cutoff = source ['initial-cutoff'],
        )
    controlsFileName = sys.argv [1]
    try :
    INDENT
        params = get_parameters(controlsFileName)
    DEDENT
    except IOError :
    INDENT
        print "Could not process the file '{0}'!".format(controlsFileName)
        sys.exit(1)
    DEDENT
    except KeyError, e :
    INDENT
        print "Missing control definition for '{0}'.".format(e.message)
        sys.exit(2)
    DEDENT
DEDENT
----------------------------------------

def get_parameters(parameters_file_name) :
INDENT
    parameterValues = json.load(open(parameters_file_name, "r"))
    Parameters = collections.namedtuple('Parameters',
        """
                    mpi_nodes
                    cluster_size
                    initial_cutoff
                    truncation_length
                    """)
    parameters = Parameters(
        parameterValues.get(Parameters._fields [0].replace('_', '-'), 1),
        parameterValues.get(Parameters._fields [1].replace('_', '-')),
        parameterValues.get(Parameters._fields [2].replace('_', '-')),
        parameterValues.get(Parameters._fields [3].replace('_', '-')))
    globals() ["ControlParameters"] = parameters

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45680643_45681891_33_49
45680643_45681891_6_31
Title: menuBar() in PyQt5 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super().__init__(parent)
    grid_layout = QtWidgets.QGridLayout(self)
    self.text_box = QtWidgets.QTextEdit(self)
    self.save_button = QtWidgets.QPushButton('Save')
    self.clear_button = QtWidgets.QPushButton('Clear')
    self.open_button = QtWidgets.QPushButton('Open')

    grid_layout.addWidget(self.text_box, 0, 0, 1, 3)
    grid_layout.addWidget(self.save_button, 1, 0)
    grid_layout.addWidget(self.clear_button, 1, 1)
    grid_layout.addWidget(self.open_button, 1, 2)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super().__init__(parent)
    self.email_blast_widget = EmailBlast(parent = self)
    self.setCentralWidget(self.email_blast_widget)
    bar = self.menuBar()
    file_menu = bar.addMenu('File')
    open_action = QtWidgets.QAction('Open', self)
    close_action = QtWidgets.QAction('Close', self)
    file_menu.addAction(open_action)
    file_menu.addAction(close_action)
    edit_menu = bar.addMenu('Edit')
    undo_action = QtWidgets.QAction('Undo', self)
    redo_action = QtWidgets.QAction('Redo', self)
    edit_menu.addAction(undo_action)
    edit_menu.addAction(redo_action)

    close_action.triggered.connect(self.close)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45681354_45681427_6_13
45681354_45681467_6_12
Title: Generating All Subsets of a Set Using Recursive Backtracking (Python) 
----------------------------------------

def backtrack(res, temp, nums, start) :
INDENT
    res.append([])
    for i in temp :
    INDENT
        res [- 1].append(i);
    DEDENT
    for i in range(start, len(nums)) :
    INDENT
        temp.append(nums [i])
        backtrack(res, temp, nums, i + 1)
        temp.pop()
    DEDENT
DEDENT
----------------------------------------

def backtrack(res, temp, nums, start) :
INDENT
    res.append(temp [:])
    for i in range(start, len(nums)) :
    INDENT
        temp.append(nums [i])
        backtrack(res, temp, nums, i + 1)
        temp.pop()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45700096_45710526_27_50
45700096_45710526_78_89
Title: How to terminate thread using condition returned by wx.CallAfter()? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Dialog.__init__(self, parent)
    self.parent = parent
    self.abort = False
    self.progress = 0
    bSizer2 = wx.BoxSizer(wx.VERTICAL)
    self.gauge = wx.Gauge(self, wx.ID_ANY, 100, wx.DefaultPosition, wx.DefaultSize, wx.GA_HORIZONTAL)
    self.gauge.SetValue(0)
    self.m_button1 = wx.Button(self, wx.ID_ANY, u"Stop Training", wx.DefaultPosition, wx.DefaultSize, 0)
    bSizer2.Add(self.gauge, 0, 0, 5)
    bSizer2.Add(self.m_button1, 0, 0, 5)
    self.SetSizer(bSizer2)
    self.Layout()
    self.Centre(wx.BOTH)

    self.m_button1.Bind(wx.EVT_BUTTON, self.on_cancel)
    pub.subscribe(self.updateProgress, "update")
    pub.subscribe(self.on_finish, "finish")
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent)
    self.panel = wx.Panel(self, wx.ID_ANY)
    self.btn = btn = wx.Button(self.panel, label = "Start Thread")
    btn.Bind(wx.EVT_BUTTON, self.onButton)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(btn, 0, wx.ALL | wx.CENTER, 5)
    self.panel.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45703591_45752511_1_18
45703591_52284862_1_12
Title: How to send post data to flask using pytest-flask 
----------------------------------------

def test_upload(client) :
INDENT
    mimetype = 'application/json'
    headers = {
        'Content-Type' : mimetype,
        'Accept' : mimetype}
    data = {
        'Data' : [20.0, 30.0, 401.0, 50.0],
        'Date' : ['2017-08-11', '2017-08-12', '2017-08-13', '2017-08-14'],
        'Day' : 4}
    url = '/upload/'
    response = client.post(url, data = json.dumps(data), headers = headers)
    assert response.content_type == mimetype
    assert response.json ['Result'] == 39
DEDENT
----------------------------------------

def test_upload(client) :
INDENT
    data = {
        'Data' : [20.0, 30.0, 401.0, 50.0],
        'Date' : ['2017-08-11', '2017-08-12', '2017-08-13', '2017-08-14'],
        'Day' : 4}
    url = '/upload/'
    response = client.post(url, json = data)
    assert response.content_type == 'application/json'
    assert response.json ['Result'] == 39
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45712495_45713023_3_9
45712495_45713078_1_12
Title: Numpy vectorized function assignment with a boolean statement 
----------------------------------------

def func(x, a = 0.5, b = 0.6) :
INDENT
    x = max(x, a)
    if x > b :
    INDENT
        return x ** 2
    DEDENT
    else :
    INDENT
        return x ** 3
    DEDENT
DEDENT
----------------------------------------

def func(x) :
INDENT
    condlist = [
        x < a,
        (x > = a) & (x < = b),
        x > b]
    choicelist = [
        a ** 3,
        x ** 3,
        x ** 2]
    return np.select(condlist, choicelist)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45724806_45780385_6_25
45724806_45851250_1_16
Title: Matrix isn't being appended to correctly 
----------------------------------------

def customop(qstat) :
INDENT
    dimensions = int(input("What are the dimensions of your (square) matrix? Please input a single number: "))
    iterator = 1
    iterator_2 = 1
    elements = []
    while iterator < = dimensions :
    INDENT
        while iterator_2 < = dimensions :
        INDENT
            elements.append(float(input("Matrix element at " + str(iterator) + "," + str(iterator_2) + ": ")))
            iterator_2 += 1
        DEDENT
        iterator_2 = 1
        iterator += 1
    DEDENT
    matrix = np.matrix(elements).reshape(dimensions, dimensions)
    if np.array_equal(np.dot(matrix, matrix.conj().T), np.identity(2)) == True :
    INDENT
        print (matrix)
        return np.dot(matrix, qstat)
    DEDENT
    else :
    INDENT
        print (matrix)
        print ("matrix not unitary, pretending no gate was applied")
        return qstat
    DEDENT
DEDENT
----------------------------------------

def customop(qstat) :
INDENT
    dimensions = input("What are the dimensions of your (square) matrix? Please input a single number: ")
    matrix = np.zeros([dimensions, dimensions])
    for iterator in range(dimensions) :
    INDENT
        for iterator_2 in range(dimensions) :
        INDENT
            matrix [iterator, iterator_2] = float(input("Matrix element at " + str(iterator) + "," + str(iterator_2) + ": "))
        DEDENT
    DEDENT
    if np.array_equal(np.dot(matrix, matrix.conj().T), np.identity(2)) == True :
    INDENT
        print (matrix)
        return np.dot(matrix, qstat)
    DEDENT
    else :
    INDENT
        print (matrix)
        print ("matrix not unitary, pretending no gate was applied")
        return qstat
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45749092_45788762_18_40
45749092_45788762_46_65
Title: "Set identity to several ZMQ servers binded to same port" 
----------------------------------------

def run(self) :
INDENT
    context = zmq.Context()
    socket = context.socket(zmq.DEALER)
    identity = str(self.id)
    socket.identity = identity.encode('ascii')
    socket.connect('tcp://localhost:5570')
    print ('Client %s started' % (identity))
    poll = zmq.Poller()
    poll.register(socket, zmq.POLLIN)
    reqs = 0
    for i in range(3) :
    INDENT
        reqs = reqs + 1
        print ('Client %s sent req #%d..' % (identity, reqs))
        socket.send_string(u'request #%d' % (reqs))
        for i in range(3) :
        INDENT
            sockets = dict(poll.poll(1000))
            if socket in sockets :
            INDENT
                msg = socket.recv()
                tprint('Client %s received: %s' % (identity, msg))
            DEDENT
        DEDENT
    DEDENT
    socket.close()
    context.term()
DEDENT
----------------------------------------

def run(self) :
INDENT
    context = zmq.Context()
    frontend = context.socket(zmq.ROUTER)
    frontend.bind('tcp://*:5570')
    backend = context.socket(zmq.ROUTER)
    backend.bind('inproc://backend')
    workers = []
    for i in range(1, 4) :
    INDENT
        worker = ServerWorker(context, i)
        worker.start()
        workers.append(worker)
    DEDENT
    zmq.proxy(frontend, backend)
    frontend.close()
    backend.close()
    context.term()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45749092_45788762_18_40
45749092_45788762_73_86
Title: "Set identity to several ZMQ servers binded to same port" 
----------------------------------------

def run(self) :
INDENT
    context = zmq.Context()
    socket = context.socket(zmq.DEALER)
    identity = str(self.id)
    socket.identity = identity.encode('ascii')
    socket.connect('tcp://localhost:5570')
    print ('Client %s started' % (identity))
    poll = zmq.Poller()
    poll.register(socket, zmq.POLLIN)
    reqs = 0
    for i in range(3) :
    INDENT
        reqs = reqs + 1
        print ('Client %s sent req #%d..' % (identity, reqs))
        socket.send_string(u'request #%d' % (reqs))
        for i in range(3) :
        INDENT
            sockets = dict(poll.poll(1000))
            if socket in sockets :
            INDENT
                msg = socket.recv()
                tprint('Client %s received: %s' % (identity, msg))
            DEDENT
        DEDENT
    DEDENT
    socket.close()
    context.term()
DEDENT
----------------------------------------

def run(self) :
INDENT
    worker = self.context.socket(zmq.DEALER)
    identity = str(self.id)
    worker.connect('inproc://backend')
    tprint('Worker %s started' % identity)
    for i in range(3) :
    INDENT
        client_ident, msg = worker.recv_multipart()
        tprint('Worker %s received %s from %s' % (identity, msg, client_ident))
        for i in range(2) :
        INDENT
            time.sleep(1./ (randint(1, 10)))
            worker.send_multipart([client_ident, msg])
        DEDENT
    DEDENT
    worker.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45749092_45788762_46_65
45749092_45788762_73_86
Title: "Set identity to several ZMQ servers binded to same port" 
----------------------------------------

def run(self) :
INDENT
    context = zmq.Context()
    frontend = context.socket(zmq.ROUTER)
    frontend.bind('tcp://*:5570')
    backend = context.socket(zmq.ROUTER)
    backend.bind('inproc://backend')
    workers = []
    for i in range(1, 4) :
    INDENT
        worker = ServerWorker(context, i)
        worker.start()
        workers.append(worker)
    DEDENT
    zmq.proxy(frontend, backend)
    frontend.close()
    backend.close()
    context.term()
DEDENT
----------------------------------------

def run(self) :
INDENT
    worker = self.context.socket(zmq.DEALER)
    identity = str(self.id)
    worker.connect('inproc://backend')
    tprint('Worker %s started' % identity)
    for i in range(3) :
    INDENT
        client_ident, msg = worker.recv_multipart()
        tprint('Worker %s received %s from %s' % (identity, msg, client_ident))
        for i in range(2) :
        INDENT
            time.sleep(1./ (randint(1, 10)))
            worker.send_multipart([client_ident, msg])
        DEDENT
    DEDENT
    worker.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45749205_45750658_7_14
45749205_45751574_6_13
Title: python how to reset the url when i define the url in the loop 
----------------------------------------

def __init__(self) :
INDENT
    HTMLParser.__init__(self)
    self.inLink = False
    self.dataList = []
    self.directory = '/'
    self.indexcol = ';'
    self.Counter = 0
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    HTMLParser.__init__(self)
    self.inLink = False
    self.dataList = []
    self.directory = '/'
    self.indexcol = ';'
    self.Counter = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45761532_45762593_27_58
45761532_45762593_2_12
Title: Multiple overlayed plots in pyqtgraph (trouble binding an axis) 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(LoginWidget, self).__init__(parent)
    layout = QtGui.QVBoxLayout()
    pg.setConfigOption('background', 'w')
    pg.setConfigOption('foreground', 'k')
    self.button = QtGui.QPushButton('Start Plotting')
    layout.addWidget(self.button)
    self.plot = pg.PlotWidget(title = 'Force and Extension vs. Time')
    layout.addWidget(self.plot)
    self.setLayout(layout)
    p1 = self.plot.plotItem
    p2 = pg.ViewBox()
    p1.showAxis('right')
    p1.scene().addItem(p2)
    p1.getAxis('right').linkToView(p2)
    p2.setXLink(p1)
    self.plot.getAxis('bottom').setLabel('Time', units = 's')
    self.plot.getAxis('left').setLabel('Force', units = 'lbf', color = "#0000ff")
    p1.getAxis('right').setLabel('Extension', units = 'in.', color = "#ff0000")
    def updateViews() :
    INDENT
        p2.setGeometry(p1.vb.sceneBoundingRect())
        p2.linkedViewChanged(p1.vb, p2.XAxis)
    DEDENT
    updateViews()
    p1.vb.sigResized.connect(updateViews)
    self.it1 = p1.plot()
    self.it2 = pg.PlotCurveItem()
    p2.addItem(self.it2)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.central_widget = QtGui.QStackedWidget()
    self.setCentralWidget(self.central_widget)
    self.login_widget = LoginWidget(self)
    self.login_widget.button.clicked.connect(self.plotter)
    self.central_widget.addWidget(self.login_widget)
    self.curve = self.login_widget.it1
    self.curve2 = self.login_widget.it2
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45762619_45933321_1_9
45762619_46203139_1_12
Title: Nearest Square Function with Python 
----------------------------------------

def nearest_square(value) :
INDENT
    i = 2
    while i < value :
    INDENT
        square = i * i
        if square == value :
        INDENT
            return square
        DEDENT
        i += 1
        value -= 1
    DEDENT
DEDENT
----------------------------------------

def nearest_square(value) :
INDENT
    i = 1
    result = 1
    while (result < value) :
    INDENT
        if (result == value) :
        INDENT
            return result
        DEDENT
        i += 1
        result = i * i
    DEDENT
    return (i - 1) * (i - 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45762619_45933321_1_9
45762619_46793951_1_11
Title: Nearest Square Function with Python 
----------------------------------------

def nearest_square(value) :
INDENT
    i = 2
    while i < value :
    INDENT
        square = i * i
        if square == value :
        INDENT
            return square
        DEDENT
        i += 1
        value -= 1
    DEDENT
DEDENT
----------------------------------------

def nearest_square(limit) :
INDENT
    while limit > 3 :
    INDENT
        i = 2
        while i < = limit / / 2 :
        INDENT
            square = i * i
            if square == limit :
            INDENT
                return square
            DEDENT
            else :
            INDENT
                i += 1
            DEDENT
        DEDENT
        limit -= 1
    DEDENT
    return 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45762619_46203139_1_12
45762619_46793951_1_11
Title: Nearest Square Function with Python 
----------------------------------------

def nearest_square(value) :
INDENT
    i = 1
    result = 1
    while (result < value) :
    INDENT
        if (result == value) :
        INDENT
            return result
        DEDENT
        i += 1
        result = i * i
    DEDENT
    return (i - 1) * (i - 1)
DEDENT
----------------------------------------

def nearest_square(limit) :
INDENT
    while limit > 3 :
    INDENT
        i = 2
        while i < = limit / / 2 :
        INDENT
            square = i * i
            if square == limit :
            INDENT
                return square
            DEDENT
            else :
            INDENT
                i += 1
            DEDENT
        DEDENT
        limit -= 1
    DEDENT
    return 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45763049_45763722_1_10
45763049_45767687_1_15
Title: Python permutation using backtracking 
----------------------------------------

def permute(a, l, r) :
INDENT
    if l == r :
    INDENT
        print toString(a)
    DEDENT
    else :
    INDENT
        for i in xrange(l, r + 1) :
        INDENT
            a [l], a [i] = a [i], a [l]
            permute(a, l + 1, r)
            a [l], a [i] = a [i], a [l]

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def permute(String, SoFar) :
INDENT
    TempString = list(String)
    TempSoFar = list(SoFar)
    if TempString ! = [] :
    INDENT
        for c in String :
        INDENT
            TStr = list(TempString)
            TSF = list(TempSoFar)
            TStr.remove(c)
            TSF.append(c)
            permute(TStr, TSF)
        DEDENT
    DEDENT
    else :
    INDENT
        print "\nOut: ", TempSoFar, "\n"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45767032_46540633_64_71
45767032_46594863_76_90
Title: Selenium/python: extract text from a dynamically-loading webpage after every scroll 
----------------------------------------

def main() :
INDENT
    stream_id, csrf_token = get_necessary_info()
    messages = get_messages(stream_id, csrf_token)
    for message in messages :
    INDENT
        print (message ['created_at'], message ['body'])
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    url = "https://stocktwits.com/symbol/USDJPY?q=%24USDjpy"
    max_screen_scrolls = 4
    driver = webdriver.Chrome()
    try :
    INDENT
        for post_num, post in enumerate(get_posts(driver, url, max_screen_scrolls), 1) :
        INDENT
            print ("*" * 40)
            print ("Post #{0}".format(post_num))
            print ("\nDate: {0}".format(post.date))
            print ("Text: {0}\n".format(post.text [: 34]))
        DEDENT
    DEDENT
    finally :
    INDENT
        driver.quit()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45768114_45768154_1_10
45768114_45768268_1_10
Title: "infinite loop started  Why?" 
----------------------------------------

def digit_sum(n) :
INDENT
    k = str(n)
    i = 0
    j = 0
    while i < len(k) :
    INDENT
        l = int(k [i])
        j = j + l
        i += 1
    DEDENT
    print j
DEDENT
----------------------------------------

def digit_sum(n) :
INDENT
    k = str(n)
    j = 0
    i = 0
    while i in range(len(k)) :
    INDENT

        j = j + int(k [i]);
        i = i + 1
        print j
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45780911_45781005_1_18
45780911_45781635_10_15
Title: Python strings and if statements 
----------------------------------------

def activity_level_from_steps(steps) :
INDENT
    steps = int(steps)
    if steps < 1 :
    INDENT
        level = 'alive?'
    DEDENT
    elif steps > = 1 and steps < 5000 :
    INDENT
        level = 'sedentary'
    DEDENT
    elif steps > = 5000 and steps < 7500 :
    INDENT
        level = 'very low'
    DEDENT
    elif steps > = 7500 and steps < 10000 :
    INDENT
        level = 'low'
    DEDENT
    elif steps > = 10000 and steps < 12500 :
    INDENT
        level = 'active'
    DEDENT
    else :
    INDENT
        level = 'very active'
    DEDENT
    return level
DEDENT
----------------------------------------

def activity_level_from_steps(steps) :
INDENT
    steps = int(steps)
    for step, level in step_levels :
    INDENT
        if steps < step :
        INDENT
            break
        DEDENT
    DEDENT
    return level
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45786139_45786262_2_22
45786139_45786361_43_52
Title: Class Enemy Has Function combat_roll() but can't seem to access it Python 2.7 
----------------------------------------

def __init__(self, name, weapon, hp, attack, defense, xp) :
INDENT
    self.self = self
    self.name = name
    self.hp = hp
    self.attack = attack
    self.defense = defense
    self.xp = xp

    self.attack_text1 = name, " attacks you with ", weapon, "."
    self.attack_damage = random.randint(0, 2) + attack
    self.total_damage = self.attack_damage - player.defense
    if self.total_damage < 1 :
    INDENT
        self.total_damage = 0

    DEDENT
    self.attack_text2 = name, " deals ", self.total_damage, " to you."
    combat_roll(self)
DEDENT
----------------------------------------

def __init__(self, name, weapon, hp, attack, defense, xp) :
INDENT
    self.self = self
    self.name = name
    self.weapon = weapon
    self.hp = hp
    self.attack = attack
    self.defense = defense
    self.xp = xp

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45788675_45822974_15_22
45788675_45822974_2_13
Title: maya.api.openMaya setWeight not calling right version of function 
----------------------------------------

def weights(self, values) :
INDENT
    influences = self.getInfl_IDs()
    for vert, weights in values.iteritems() :
    INDENT
        tempy = []
        for i, value in enumerate(weights) :
        INDENT
            tempy += [(influences [i], value)]
        DEDENT
        cmds.skinPercent(self.path, self.shapeNode.getVertName(vert), transformValue = tempy)
    DEDENT
DEDENT
----------------------------------------

def weights(self) :
INDENT
    vertWeights = self.skinFn.getWeights(self.polygon.tracker.dag, self.vertexComp)
    weights = list(vertWeights [- 2])
    infCount = vertWeights [- 1]
    weights = [weights [x : x + infCount] for x in range(0, len(weights), infCount)]
    dicty = {}
    for i, weight in enumerate(weights) :
    INDENT
        dicty.update({i : weight})

    DEDENT
    return dicty
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45827336_45836645_3_12
45827336_46400776_7_22
Title: How to make wxPython StaticText selectable 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1)
    self.panel = wx.Panel(self)
    self.st = wx.StaticText(self.panel, wx.ID_ANY, "Hello, World! Copy me with right click", pos = (5, 5))
    self.st.Bind(wx.wx.EVT_RIGHT_DOWN, self.ShowPopup)
    self.tc = wx.TextCtrl(self.panel, wx.ID_ANY, "Paste here", pos = (5, 30), size = (300, 20))
    self.tc2 = wx.TextCtrl(self.panel, wx.ID_ANY, "TextCtrl masquerading as StaticText - Select me", style = wx.TE_READONLY | wx.NO_BORDER, pos = (5, 60), size = (300, 20))
    self.tc2.SetBackgroundColour(self.panel.GetBackgroundColour())
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent, style, html_body_content, bgcolor, size) :
INDENT
    wx.PopupTransientWindow.__init__(self, parent, style)
    panel = wx.Panel(self)
    panel.SetBackgroundColour(bgcolor)
    html_window = self.HtmlWindow(panel, wx.ID_ANY, size = size)
    html_window.SetPage('<body bgcolor="' + bgcolor + '"><![CDATA[' + html_body_content + '</body>')
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(html_window, 0, wx.ALL, 5)
    panel.SetSizer(sizer)
    sizer.Fit(panel)
    sizer.Fit(self)
    self.Layout()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45850493_45850593_15_19
45850493_45850593_5_10
Title: "How to ""chain"" iterators?" 
----------------------------------------

def __iter__(self) :
INDENT
    for filename in mr :
    INDENT
        with open(filename) as f :
        INDENT
            for line in f :
            INDENT
                yield line.strip()
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __iter__(self) :
INDENT
    for line in self.f :
    INDENT
        yield line.strip()
    DEDENT
    self.f.close()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45875889_45885564_40_58
45875889_45885564_67_80
Title: Label Tkinter Variable 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.title_font = tkfont.Font(family = 'Helvetica', size = 18, weight = "bold", slant = "italic")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (theme1Q5, Results) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("theme1Q5")
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "Your Score:", font = controller.title_font)
    label.pack(side = "top", fill = "x")
    button = tk.Button(self, text = "return to Menu",
        command = lambda : controller.show_frame("theme1Q5"))
    button.pack(side = "bottom")

    global score
    self.label2 = tk.Label(self, text = "%s / 5" % (score), font = self.controller.title_font)
    self.label2.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45875889_45885564_40_58
45875889_45885564_8_31
Title: Label Tkinter Variable 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.title_font = tkfont.Font(family = 'Helvetica', size = 18, weight = "bold", slant = "italic")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in (theme1Q5, Results) :
    INDENT
        page_name = F.__name__
        frame = F(parent = container, controller = self)
        self.frames [page_name] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame("theme1Q5")
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "5.Question", font = controller.title_font)
    label.pack(side = "top", fill = "x")
    Question15 = tk.Label(self, text = "Which sentence is not true?")
    Question15.place(x = 0, y = 30)
    self.controll15 = tk.IntVar()
    wrong151 = tk.Radiobutton(self, text = "Neural Networks work bad with small amount of data",
        variable = self.controll15, value = 1)
    wrong152 = tk.Radiobutton(self, text = "Concept of neural network exists since the middle of the mid-twentieth",
        variable = self.controll15, value = 0)
    right15 = tk.Radiobutton(self, text = "There is no learning rate parameter in training neural networks",
        variable = self.controll15, value = 5)
    wrong151.place(x = 0, y = 60)
    wrong152.place(x = 0, y = 80)
    right15.place(x = 0, y = 100)
    button = tk.Button(self, text = "Result", command = lambda : controller.show_frame("Results"))
    button.bind("<Button-1>", self.scorer)
    button.pack(side = "right")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45875889_45885564_67_80
45875889_45885564_8_31
Title: Label Tkinter Variable 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "Your Score:", font = controller.title_font)
    label.pack(side = "top", fill = "x")
    button = tk.Button(self, text = "return to Menu",
        command = lambda : controller.show_frame("theme1Q5"))
    button.pack(side = "bottom")

    global score
    self.label2 = tk.Label(self, text = "%s / 5" % (score), font = self.controller.title_font)
    self.label2.pack()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.controller = controller
    label = tk.Label(self, text = "5.Question", font = controller.title_font)
    label.pack(side = "top", fill = "x")
    Question15 = tk.Label(self, text = "Which sentence is not true?")
    Question15.place(x = 0, y = 30)
    self.controll15 = tk.IntVar()
    wrong151 = tk.Radiobutton(self, text = "Neural Networks work bad with small amount of data",
        variable = self.controll15, value = 1)
    wrong152 = tk.Radiobutton(self, text = "Concept of neural network exists since the middle of the mid-twentieth",
        variable = self.controll15, value = 0)
    right15 = tk.Radiobutton(self, text = "There is no learning rate parameter in training neural networks",
        variable = self.controll15, value = 5)
    wrong151.place(x = 0, y = 60)
    wrong152.place(x = 0, y = 80)
    right15.place(x = 0, y = 100)
    button = tk.Button(self, text = "Result", command = lambda : controller.show_frame("Results"))
    button.bind("<Button-1>", self.scorer)
    button.pack(side = "right")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45891144_45891417_1_14
45891144_50390351_1_21
Title: Finding the number of reduced fractions 
----------------------------------------

def proper_fractions(n) :
INDENT
    def gcd(x, y) :
    INDENT
        while y :
        INDENT
            (x, y) = (y, x % y)
        DEDENT
        return x
    DEDENT
    if n < = 1 :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        count = 0
        for num in range(1, n) :
        INDENT
            denom = gcd(n, num)
            if denom == 1 :
            INDENT
                count += 1
            DEDENT
        DEDENT
        return count
    DEDENT
DEDENT
----------------------------------------

def proper_fractions(n) :
INDENT
    distinct_prime_factors = set()
    totient_function = n
    if n == 1 :
    INDENT
        totient_function = 0
    DEDENT
    else :
    INDENT
        i = 2
        while i * i < = n :
        INDENT
            if n % i == 0 :
            INDENT
                distinct_prime_factors.add(i)
                n = n / i
            DEDENT
            else :
            INDENT
                i += 1
            DEDENT
        DEDENT
        if n > 1 :
        INDENT
            distinct_prime_factors.add(n)
        DEDENT
        if len(distinct_prime_factors) == 0 :
        INDENT
            totient_function = n - 1
        DEDENT
        else :
        INDENT
            for p in distinct_prime_factors :
            INDENT
                totient_function = (totient_function * (p - 1)) / p
            DEDENT
        DEDENT
    DEDENT
    return totient_function
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45895996_45896025_7_11
45895996_45896055_21_30
Title: Python 3 - Why wont my simple program do anything with the input? 
----------------------------------------

def divi(x, y) :
INDENT
    if y == 0 :
    INDENT
        print ("Cant divide by 0")
    DEDENT
    else :
    INDENT
        return x / y
    DEDENT
DEDENT
----------------------------------------

def divi(x, y) :
INDENT
    if x == 0 or y == 0 :
    INDENT
        print ("Cant divide 0")
    DEDENT
    elif x == 0 and y == 0 :
    INDENT
        print ("Cant divide 0")
    DEDENT
    else :
    INDENT
        z = x / y
        return z

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45895996_45896025_7_11
45895996_45896087_16_23
Title: Python 3 - Why wont my simple program do anything with the input? 
----------------------------------------

def divi(x, y) :
INDENT
    if y == 0 :
    INDENT
        print ("Cant divide by 0")
    DEDENT
    else :
    INDENT
        return x / y
    DEDENT
DEDENT
----------------------------------------

def divi(x, y) :
INDENT
    if x == 0 or y == 0 :
    INDENT
        print ("Cant divide 0")
    DEDENT
    elif x == 0 and y == 0 :
    INDENT
        print ("Cant divide 0")
    DEDENT
    else :
    INDENT
        z = x / y
        return z
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
459083_40233575_15_53
459083_538559_5_12
Title: How do you run your own code alongside Tkinter's event loop? 
----------------------------------------

def __init__(self, master) :
INDENT
    fontsize = 12
    textwidth = 9
    tk.Frame.__init__(self, master)
    self.pack()
    tk.Label(self, font = ('Helvetica', fontsize), bg = '#be004e', fg = 'white', width = textwidth,
        text = 'Local Time').grid(row = 0, column = 0)
    self.LocalDate = tk.StringVar()
    self.LocalDate.set('waiting...')
    tk.Label(self, font = ('Helvetica', fontsize), bg = '#be004e', fg = 'white', width = textwidth,
        textvariable = self.LocalDate).grid(row = 0, column = 1)
    tk.Label(self, font = ('Helvetica', fontsize), bg = '#be004e', fg = 'white', width = textwidth,
        text = 'Local Date').grid(row = 1, column = 0)
    self.LocalTime = tk.StringVar()
    self.LocalTime.set('waiting...')
    tk.Label(self, font = ('Helvetica', fontsize), bg = '#be004e', fg = 'white', width = textwidth,
        textvariable = self.LocalTime).grid(row = 1, column = 1)
    tk.Label(self, font = ('Helvetica', fontsize), bg = '#40CCC0', fg = 'white', width = textwidth,
        text = 'GMT Time').grid(row = 2, column = 0)
    self.nowGdate = tk.StringVar()
    self.nowGdate.set('waiting...')
    tk.Label(self, font = ('Helvetica', fontsize), bg = '#40CCC0', fg = 'white', width = textwidth,
        textvariable = self.nowGdate).grid(row = 2, column = 1)
    tk.Label(self, font = ('Helvetica', fontsize), bg = '#40CCC0', fg = 'white', width = textwidth,
        text = 'GMT Date').grid(row = 3, column = 0)
    self.nowGtime = tk.StringVar()
    self.nowGtime.set('waiting...')
    tk.Label(self, font = ('Helvetica', fontsize), bg = '#40CCC0', fg = 'white', width = textwidth,
        textvariable = self.nowGtime).grid(row = 3, column = 1)
    tk.Button(self, text = 'Exit', width = 10, bg = '#FF8080', command = root.destroy).grid(row = 4, columnspan = 2)
    self.gettime()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tkinter.Tk()
    self.s = Tkinter.StringVar()
    self.s.set('Foo')
    l = Tkinter.Label(self.root, textvariable = self.s)
    l.pack()
    threading.Thread.__init__(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45909318_45925207_15_31
45909318_45925207_53_72
Title: Show PyMunk with PyGame - Python 
----------------------------------------

def __init__(self, pos, space) :
INDENT
    super().__init__()
    self.image = pg.Surface((46, 52), pg.SRCALPHA)
    pg.draw.polygon(self.image, (0, 50, 200),
        [(0, 0), (48, 0), (48, 54), (24, 54)])
    self.orig_image = self.image
    self.rect = self.image.get_rect(topleft = pos)
    vs = [(- 23, 26), (23, 26), (23, - 26), (0, - 26)]
    mass = 1
    moment = pm.moment_for_poly(mass, vs)
    self.body = pm.Body(mass, moment)
    self.shape = pm.Poly(self.body, vs)
    self.shape.friction =.9
    self.body.position = pos
    self.space = space
    self.space.add(self.body, self.shape)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.done = False
    self.clock = pg.time.Clock()
    self.screen = pg.display.set_mode((800, 600))
    self.gray = pg.Color('gray68')
    self.red = pg.Color('red')

    self.space = pm.Space()
    self.space.gravity = Vec2d(0.0, - 900.0)
    self.static_lines = [
        pm.Segment(self.space.static_body, (60, 100), (370, 100), 0),
        pm.Segment(self.space.static_body, (370, 100), (600, 300), 0),
        ]
    for lin in self.static_lines :
    INDENT
        lin.friction = 0.8
    DEDENT
    self.space.add(self.static_lines)
    self.sprite_group = pg.sprite.Group(Entity((150, 200), self.space))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45910710_45910968_8_12
45910710_45915757_8_13
Title: Create a Car class in python 
----------------------------------------

def fill_up(self) :
INDENT
    if self.g < 13 :
    INDENT
        return 13 - self.g
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------

def fill_up(self) :
INDENT
    added = 13 - self.x
    self.x += added
    if added > 0 :
    INDENT
        return added
    DEDENT
    return 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45931836_45932071_22_30
45931836_45932329_7_17
Title: insert in binary search tree using recursion in python 
----------------------------------------

def _insert(self, root, value) :
INDENT
    if root is None :
    INDENT
        root = Node(value)
    DEDENT
    elif value < root.value :
    INDENT
        root.left = self._insert(root.left, value)
    DEDENT
    elif value > = root.value :
    INDENT
        root.right = self._insert(root.right, value)
    DEDENT
    return root
DEDENT
----------------------------------------

def _insert(self, node, value) :
INDENT
    if value < node.value :
    INDENT
        if node.left :
        INDENT
            self._insert(node.left, value)
        DEDENT
        else :
        INDENT
            node.left = Node(value)
        DEDENT
    DEDENT
    else :
    INDENT
        if node.right :
        INDENT
            self._insert(node.right, value)
        DEDENT
        else :
        INDENT
            node.right = Node(value)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45933021_45933590_15_27
45933021_45933590_34_44
Title: Why overriding mousePressEvent in PyQt makes clicking signal doesn't trigger? 
----------------------------------------

def initUI(self) :
INDENT
    self.setGeometry(300, 300, 300, 220)
    self.setWindowTitle('Simple')
    table = TrackedTableWidget()
    layout = QGridLayout()
    layout.addWidget(table, 0, 0)
    self.setLayout(layout)
    self.show()

DEDENT
----------------------------------------

def initUI(self) :
INDENT
    self.setRowCount(2)
    self.setColumnCount(2)
    self.setItem(0, 0, QTableWidgetItem('30', 0));
    self.setItem(0, 1, QTableWidgetItem('40', 0));
    self.setItem(1, 0, QTableWidgetItem('50', 0));
    self.setItem(1, 1, QTableWidgetItem('60', 0));
    self.cellClicked.connect(self._handle_cell_clicked)
    self.itemSelectionChanged.connect(self._handle_item_selection)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45934233_45934396_8_25
45934233_45934739_2_8
Title: Python decorators implementation 
----------------------------------------

def decorator(view_func) :
INDENT
    @ wraps(view_func, assigned = available_attrs(view_func))
    def _wrapped_view(request, * args, ** kwargs) :
    INDENT
        if test_func(request.user) :
        INDENT
            return view_func(request, * args, ** kwargs)
        DEDENT
        path = request.build_absolute_uri()
        resolved_login_url = resolve_url(login_url or settings.LOGIN_URL)

        login_scheme, login_netloc = urlparse(resolved_login_url) [: 2]
        current_scheme, current_netloc = urlparse(path) [: 2]
        if ((not login_scheme or login_scheme == current_scheme) and
            (not login_netloc or login_netloc == current_netloc)) :
        INDENT
            path = request.get_full_path()
        DEDENT
        from django.contrib.auth.views import redirect_to_login
        return redirect_to_login(
            path, resolved_login_url, redirect_field_name)
    DEDENT
    return _wrapped_view
DEDENT
----------------------------------------

def decorator(func) :
INDENT
    def _wrapped_func(* args, ** kwargs) :
    INDENT
        if test_func(* args, ** kwargs) :
        INDENT
            return func(* args, ** kwargs)
        DEDENT
        else :
        INDENT
            return None
        DEDENT
    DEDENT
    return _wrapped_func
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45942631_45943084_4_9
45942631_45943097_4_11
Title: python parallel loop: communicate to outside 
----------------------------------------

def f(z) :
INDENT
    while True :
    INDENT
        z.value += 1
        print 'z', z.value
        time.sleep(float(0.1))
    DEDENT
DEDENT
----------------------------------------

def f(v) :
INDENT
    z = 0
    while True :
    INDENT
        z = z + 1
        print 'z', z
        v.value = z
        time.sleep(float(0.1))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45948995_45949917_37_69
45948995_45950694_60_81
Title: Pygame sprites - get the rect collision side 
----------------------------------------

def setup() :
INDENT
    pygame.init()
    global display, player, block, sprites, living, noliving, clock
    display = pygame.display.set_mode((800, 600))
    pygame.display.set_caption("Test")
    clock = pygame.time.Clock()
    player = Player(100, 0)
    block = Block(100, 300)
    block1 = Block(200, 400)
    block2 = Block(400, 400)
    sprites = pygame.sprite.Group()
    living = pygame.sprite.Group()
    noliving = pygame.sprite.Group()
    noliving.add(block)
    noliving.add(block1)
    noliving.add(block2)
    living.add(player)
    for liv in living :
    INDENT
        sprites.add(liv)
    DEDENT
    for noliv in noliving :
    INDENT
        sprites.add(noliv)
    DEDENT
    main()
DEDENT
----------------------------------------

def setup() :
INDENT
    global display, player, living, noliving, gravity, speed, sprites
    pygame.init()
    display = pygame.display.set_mode((800, 600))
    player = Player()
    block = Block(y = 500)
    sprites = pygame.sprite.Group()
    living = pygame.sprite.Group()
    noliving = pygame.sprite.Group()
    sprites.add(player)
    sprites.add(block)
    living.add(player)
    noliving.add(block)
    gravity = 10
    speed = 10

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45948995_45949917_70_188
45948995_45950694_82_123
Title: Pygame sprites - get the rect collision side 
----------------------------------------

def main() :
INDENT
    speed = 5
    gravity = 5
    xCh, yCh = 0, 0
    player.leftUnable = False
    player.rightUnable = False
    while True :
    INDENT
        clock.tick(60)
        display.fill((184, 184, 184))
        yCh = gravity
        for event in pygame.event.get() :
        INDENT
            if (event.type == pygame.QUIT) :
            INDENT
                quit()
            DEDENT
            elif (event.type == pygame.KEYDOWN) :
            INDENT
                if (event.key == pygame.K_ESCAPE) :
                INDENT
                    quit()
                DEDENT
                elif ((event.key == pygame.K_a or event.key == pygame.K_LEFT) and not player.leftUnable) :
                INDENT
                    for noliv in noliving :
                    INDENT
                        if (pygame.sprite.collide_rect(player, noliv)) :
                        INDENT
                            if (noliv.rect.left < player.rect.left < noliv.rect.right and player.rect.bottom > noliv.rect.top + 5) :
                            INDENT
                                player.leftUnable = True
                                break
                            DEDENT
                            else :
                            INDENT
                                xCh = - speed
                                player.leftUnable = False
                            DEDENT
                        DEDENT
                        else :
                        INDENT
                            xCh = - speed
                            player.leftUnable = False
                        DEDENT
                    DEDENT
                DEDENT
                elif ((event.key == pygame.K_d or event.key == pygame.K_RIGHT) and not player.rightUnable) :
                INDENT
                    for noliv in noliving :
                    INDENT
                        if (pygame.sprite.collide_rect(player, noliv)) :
                        INDENT
                            if (noliv.rect.left < player.rect.right < noliv.rect.right and player.rect.bottom > noliv.rect.top + 5) :
                            INDENT
                                player.rightUnable = True
                                break
                            DEDENT
                            else :
                            INDENT
                                xCh = speed
                                player.rightUnable = False
                            DEDENT
                        DEDENT
                        else :
                        INDENT
                            xCh = speed
                            player.rightUnable = False
                        DEDENT
                    DEDENT
                DEDENT
                elif (event.key == pygame.K_SPACE or event.key == pygame.K_w or event.key == pygame.K_UP) :
                INDENT
                    oldPos = player.rect.bottom
                    xCh = 0
                    if (not player.inAir) :
                    INDENT
                        while player.rect.bottom > oldPos - player.jumpHeight :
                        INDENT
                            clock.tick(60)
                            display.fill((184, 184, 184))
                            for ev in pygame.event.get() :
                            INDENT
                                if (ev.type == pygame.KEYDOWN) :
                                INDENT
                                    if (ev.key == pygame.K_d or ev.key == pygame.K_RIGHT) :
                                    INDENT
                                        xCh = speed
                                    DEDENT
                                    elif (ev.key == pygame.K_a or ev.key == pygame.K_LEFT) :
                                    INDENT
                                        xCh = - speed
                                    DEDENT
                                DEDENT
                                elif (ev.type == pygame.KEYUP) :
                                INDENT
                                    xCh = 0
                                DEDENT
                            DEDENT
                            player.rect.x += xCh
                            player.rect.y -= player.jumpSpeed
                            player.inAir = True
                            sprites.draw(display)
                            pygame.display.update()
                        DEDENT
                    DEDENT
                DEDENT
            DEDENT
            elif (event.type == pygame.KEYUP) :
            INDENT
                xCh = 0
            DEDENT
        DEDENT
        for liv in living :
        INDENT
            for noliv in noliving :
            INDENT
                if (pygame.sprite.collide_rect(liv, noliv)) :
                INDENT
                    liv.inAir = False
                    break
                DEDENT
                else :
                INDENT
                    liv.inAir = True

                DEDENT
            DEDENT
        DEDENT
        for noliv in noliving :
        INDENT
            if (pygame.sprite.collide_rect(player, noliv)) :
            INDENT
                if (noliv.rect.left < player.rect.left < noliv.rect.right and player.rect.bottom > noliv.rect.top + 5) :
                INDENT
                    player.leftUnable = True
                    if (collideNum(player, noliving) == 1) :
                    INDENT
                        player.inAir = True
                    DEDENT
                    if (xCh < 0) :
                    INDENT
                        xCh = 0
                    DEDENT
                DEDENT
                elif (noliv.rect.left < player.rect.right < noliv.rect.right and player.rect.bottom > noliv.rect.top + 5) :
                INDENT
                    player.rightUnable = True
                    if (collideNum(player, noliving) == 1) :
                    INDENT
                        player.inAir = True
                    DEDENT
                    if (xCh > 0) :
                    INDENT
                        xCh = 0
                    DEDENT
                DEDENT
                else :
                INDENT
                    player.leftUnable = False
                    player.rightUnable = False
                DEDENT
            DEDENT
            else :
            INDENT
                player.leftUnable = False
                player.rightUnable = False
            DEDENT
        DEDENT
        if (not player.inAir) :
        INDENT
            yCh = 0
        DEDENT
        if (player.rect.top > display.get_size() [1]) :
        INDENT
            setup()
        DEDENT
        player.rect.x += xCh
        player.rect.y += yCh
        sprites.draw(display)
        pygame.display.update()
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    xCh = 0
    yCh = 0
    while True :
    INDENT

        display.fill((159, 159, 159))
        for event in pygame.event.get() :
        INDENT
            if (event.type == pygame.KEYDOWN) :
            INDENT
                if (event.key == pygame.K_ESCAPE) :
                INDENT
                    quit()
                DEDENT
                elif (event.key == pygame.K_a or event.key == pygame.K_LEFT) :
                INDENT
                    xCh = - speed
                DEDENT
                elif (event.key == pygame.K_d or event.key == pygame.K_RIGHT) :
                INDENT
                    xCh = speed
                DEDENT
            DEDENT
            elif (event.type == pygame.KEYUP) :
            INDENT
                xCh = 0
                yCh = 0
            DEDENT
            elif (event.type == pygame.QUIT) :
            INDENT
                quit()
            DEDENT
        DEDENT
        yCh = gravity
        for liv in living :
        INDENT
            if liv == player :
            INDENT
                check_x_ch = xCh
            DEDENT
            else :
            INDENT
                check_x_ch = 0
            DEDENT
            can_move, xCh, yCh, obstacle = liv.can_move(xCh, yCh, noliving)
            liv.rect.x += xCh
            liv.rect.y += yCh

        DEDENT
        sprites.draw(display)
        pygame.display.update()
        pygame.time.delay(30)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45949953_45950040_14_19
45949953_45950565_14_19
Title: How to create a next method for a class when the next method is supposed to return the values of two generators? 
----------------------------------------

def _gen2(self) :
INDENT
    i = 1
    while True :
    INDENT
        yield i
        i += 2
    DEDENT
DEDENT
----------------------------------------

def _gen2(self) :
INDENT
    i = 1
    while True :
    INDENT
        yield i
        i += 2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45949953_45950040_8_13
45949953_45950565_8_13
Title: How to create a next method for a class when the next method is supposed to return the values of two generators? 
----------------------------------------

def _gen1(self) :
INDENT
    i = 0
    while True :
    INDENT
        yield i
        i += 2
    DEDENT
DEDENT
----------------------------------------

def _gen1(self) :
INDENT
    i = 0
    while True :
    INDENT
        yield i
        i += 2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45951789_45952110_2_20
45951789_45957164_1_17
Title: How to append variable lenght values to a list in Python 
----------------------------------------

def get_contacts(filename) :
INDENT
    dicto = {}
    dicto ['no_email'] = []
    with open(filename, 'r') as contacts_file :
    INDENT
        for a_contact in contacts_file :
        INDENT
            match = re.match('^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,4})$', a_contact.split() [0])
            to_update = 'no_email'
            if match == None :
            INDENT
                host_and_ip = a_contact.split()
            DEDENT
            else :
            INDENT
                curr_email = a_contact.split() [0]
                if curr_email not in dicto.keys() :
                INDENT
                    dicto [curr_email] = []
                DEDENT
                host_and_ip = a_contact.split() [1 :]
                to_update = curr_email
            DEDENT
            for i in range(len(host_and_ip) / / 2) :
            INDENT
                dicto [to_update] += [[host_and_ip [2 * i], host_and_ip [2 * i + 1]]]
            DEDENT
        DEDENT
    DEDENT
    return dicto
DEDENT
----------------------------------------

def get_contacts(filename) :
INDENT
    no_email = []
    users = []
    with open(filename) as f_contacts :
    INDENT
        for row in f_contacts :
        INDENT
            entries = row.split()
            if '@' in entries [0] :
            INDENT
                pairs = [entries [i : i + 2] for i in range(1, len(entries), 2)]
                users.append([entries [0], pairs])
            DEDENT
            else :
            INDENT
                for i in range(0, len(entries), 2) :
                INDENT
                    no_email.append(entries [i : i + 2])
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return no_email, users
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45982325_45982769_15_38
45982325_45982955_7_19
Title: Python function works but has the wrong order 
----------------------------------------

def tourlength(tour, locations) :
INDENT
    Distance = 0
    X0 = locations [tour [0]] [0]
    Y0 = locations [tour [0]] [1]

    i = 1
    while i < len(tour) :
    INDENT
        X = locations [tour [i]] [0]
        Y = locations [tour [i]] [1]

        Distance += distance(X0, Y0, X, Y)

        X0 = X
        Y0 = Y

        i += 1
    DEDENT
    return Distance
DEDENT
----------------------------------------

def tourlength(tour, locations) :
INDENT
    DBP = []
    coordinates = {}
    for item in locations :
    INDENT
        coordinates [item [0]] = item [1 :]
    DEDENT
    j = 0
    while j < = (len(tour) - 2) :
    INDENT
        dest_1 = tour [j]
        dest_2 = tour [j + 1]
        distances = distance(coordinates [dest_1] [0], coordinates [dest_1] [1], coordinates [dest_2] [0], coordinates [dest_2] [1])
        DBP.append(distances)
        j += 1
    DEDENT
    return sum(DBP)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4598460_4599195_16_38
4598460_9190911_9_18
Title: "Is there a Django template filter that handles ""...more"" and when you click on it it shows more of the text?" 
----------------------------------------

def readmore(txt, showwords = 15) :
INDENT
    global readmore_showscript
    words = re.split(r' ', escape(txt))
    if len(words) < = showwords :
    INDENT
        return txt

    DEDENT
    words.insert(showwords, '<span class="more" style="display:none;"><![CDATA[')
    words.append('</span>')

    words.insert(showwords, '<span class="readmore"><![CDATA[... <a href="#" onclick="')
    words.insert(showwords + 1, readmore_showscript)
    words.insert(showwords + 2, '"><![CDATA[read more</a>')
    words.insert(showwords + 3, '</span>')

    words.insert(0, '<p>')
    words.append('</p>')
    return mark_safe(' '.join(words))
DEDENT
----------------------------------------

def readmore(text, cnt = 250) :
INDENT
    text, cnt = escape(text), int(cnt)
    if len(text) > cnt :
    INDENT
        first_part = text [: cnt]
        link = u'<a href="javascript:;" class="more"><![CDATA[%s</a>' % _('read more')
        second_part = u'%s<span class="hide"><![CDATA[%s</span>' % (link, text [cnt :])
        return mark_safe('... '.join([first_part, second_part]))
    DEDENT
    return text
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4599688_34830188_2_19
4599688_4605472_5_17
Title: wxPython problems with Wrapping StaticText 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Dialog.__init__(self, parent = parent, title = "Test Dialog", style = wx.CAPTION)
    bigstr = "This is a really long string that is intended to test the wrapping functionality of the StaticText control in this dialog.  If it works correctly, it should appear as multiple lines of text with a minimum of fuss."
    self.__label__ = wx.StaticText(parent = self, label = bigstr)
    self.__actionbutton__ = wx.Button(parent = self, label = "Go")
    self.__label__.Bind(wx.EVT_SIZE, self.__WrapText__)
    self.__actionbutton__.Bind(wx.EVT_BUTTON, self.__OnButton__)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.__label__, flag = wx.ALL | wx.EXPAND, border = 5)
    sizer.Add(self.__actionbutton__, flag = wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.CENTER, border = 0)
    self.SetSizer(sizer)
    self.Layout()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "Tutorial")

    panel = wx.Panel(self, wx.ID_ANY)
    text = "I'm subclasses the statictext because I want it to act exactly like a static text, but correctly wordwrap as needed. I've found several examples of it on the web, but none that worked how I wanted. The wordwrap makes it look much nicer when the user may decide to re-size the window, so I would definitely like to have it be wordwrapped. I know about the wx.lib.wordwrap, but chose to use the built in Wrap function of the statictext control instead. It basically does the same thing from what I understand."
    txt = wx.StaticText(panel, label = text)
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(txt, 1, wx.EXPAND, 5)
    panel.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4599688_34830188_2_19
4599688_4617942_23_37
Title: wxPython problems with Wrapping StaticText 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Dialog.__init__(self, parent = parent, title = "Test Dialog", style = wx.CAPTION)
    bigstr = "This is a really long string that is intended to test the wrapping functionality of the StaticText control in this dialog.  If it works correctly, it should appear as multiple lines of text with a minimum of fuss."
    self.__label__ = wx.StaticText(parent = self, label = bigstr)
    self.__actionbutton__ = wx.Button(parent = self, label = "Go")
    self.__label__.Bind(wx.EVT_SIZE, self.__WrapText__)
    self.__actionbutton__.Bind(wx.EVT_BUTTON, self.__OnButton__)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.__label__, flag = wx.ALL | wx.EXPAND, border = 5)
    sizer.Add(self.__actionbutton__, flag = wx.LEFT | wx.RIGHT | wx.BOTTOM | wx.CENTER, border = 0)
    self.SetSizer(sizer)
    self.Layout()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "Tutorial")

    self.panel = wx.Panel(self, wx.ID_ANY)
    text = "I'm subclasses the statictext because I want it to act exactly like a static text, but correctly wordwrap as needed. I've found several examples of it on the web, but none that worked how I wanted. The wordwrap makes it look much nicer when the user may decide to re-size the window, so I would definitely like to have it be wordwrapped. I know about the wx.lib.wordwrap, but chose to use the built in Wrap function of the statictext control instead. It basically does the same thing from what I understand."
    txt = StaticWrapText(self.panel, label = text)
    wxbutton = wx.Button(self.panel, label = 'Button', size = wx.Size(120, 50))
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(txt, 0, wx.EXPAND, 5)
    sizer.Add(wxbutton, 1, wx.EXPAND, 5)
    self.panel.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4599688_4605472_5_17
4599688_4617942_23_37
Title: wxPython problems with Wrapping StaticText 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "Tutorial")

    panel = wx.Panel(self, wx.ID_ANY)
    text = "I'm subclasses the statictext because I want it to act exactly like a static text, but correctly wordwrap as needed. I've found several examples of it on the web, but none that worked how I wanted. The wordwrap makes it look much nicer when the user may decide to re-size the window, so I would definitely like to have it be wordwrapped. I know about the wx.lib.wordwrap, but chose to use the built in Wrap function of the statictext control instead. It basically does the same thing from what I understand."
    txt = wx.StaticText(panel, label = text)
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(txt, 1, wx.EXPAND, 5)
    panel.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "Tutorial")

    self.panel = wx.Panel(self, wx.ID_ANY)
    text = "I'm subclasses the statictext because I want it to act exactly like a static text, but correctly wordwrap as needed. I've found several examples of it on the web, but none that worked how I wanted. The wordwrap makes it look much nicer when the user may decide to re-size the window, so I would definitely like to have it be wordwrapped. I know about the wx.lib.wordwrap, but chose to use the built in Wrap function of the statictext control instead. It basically does the same thing from what I understand."
    txt = StaticWrapText(self.panel, label = text)
    wxbutton = wx.Button(self.panel, label = 'Button', size = wx.Size(120, 50))
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(txt, 0, wx.EXPAND, 5)
    sizer.Add(wxbutton, 1, wx.EXPAND, 5)
    self.panel.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46011337_46011435_1_15
46011337_46011527_1_18
Title: Invisible jump to the main menu from a function - can anyone spot the error? 
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    while True :
    INDENT
        username = input("Enter username:")
        password = input("Enter password:")
        with open('userinfo.txt', 'r') as f :
        INDENT
            reader = csv.reader(f)
            for row in reader :
            INDENT
                for field in row :
                INDENT
                    if field == username and row [1] == password :
                    INDENT
                        mainmenu()
                        break
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
        print ("Try again - wrong username and password")
    DEDENT
DEDENT
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    with open('userinfo.txt', 'r') as f :
    INDENT
        authenticated = False
        line = f.readline().strip()
        while authenticated == False and line ! = "" :
        INDENT
            values = line.split(",")
            if len(values) > = 2 and values [0] == username and values [1] == password :
            INDENT
                authenticated = True
            DEDENT
            line = f.readline().strip()
        DEDENT
        if authenticated :
        INDENT
            print ("****You're in!*****")
            mainmenu()
        DEDENT
        else :
        INDENT
            print ("Wrong username or password, sorry!")
            welcomemenu()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46011337_46011435_1_15
46011337_46011558_1_20
Title: Invisible jump to the main menu from a function - can anyone spot the error? 
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    while True :
    INDENT
        username = input("Enter username:")
        password = input("Enter password:")
        with open('userinfo.txt', 'r') as f :
        INDENT
            reader = csv.reader(f)
            for row in reader :
            INDENT
                for field in row :
                INDENT
                    if field == username and row [1] == password :
                    INDENT
                        mainmenu()
                        break
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
        print ("Try again - wrong username and password")
    DEDENT
DEDENT
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    with open('userinfo.txt', 'r') as f :
    INDENT
        reader = csv.reader(f)
        username_correct = False
        password_correct = False
        for row in reader :
        INDENT
            for field in row :
            INDENT
                if field == username :
                INDENT
                    currentindex = row.index(field)
                    if row [currentindex + 1] == password :
                    INDENT
                        username_correct = True
                        password_correct = True
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    if password_correct == False or username_correct == False :
    INDENT
        print ("Wrong username or password, sorry!")
        welcomemenu()
    DEDENT
    print ("****You're in!*****")
    mainmenu()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46011337_46011435_1_15
46011337_46027732_28_35
Title: Invisible jump to the main menu from a function - can anyone spot the error? 
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    while True :
    INDENT
        username = input("Enter username:")
        password = input("Enter password:")
        with open('userinfo.txt', 'r') as f :
        INDENT
            reader = csv.reader(f)
            for row in reader :
            INDENT
                for field in row :
                INDENT
                    if field == username and row [1] == password :
                    INDENT
                        mainmenu()
                        break
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
        print ("Try again - wrong username and password")
    DEDENT
DEDENT
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    valid = is_valid_user(username, password)
    if not valid :
    INDENT
        print ("Wrong username or password, sorry!")
    DEDENT
    return valid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46011337_46011527_1_18
46011337_46011558_1_20
Title: Invisible jump to the main menu from a function - can anyone spot the error? 
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    with open('userinfo.txt', 'r') as f :
    INDENT
        authenticated = False
        line = f.readline().strip()
        while authenticated == False and line ! = "" :
        INDENT
            values = line.split(",")
            if len(values) > = 2 and values [0] == username and values [1] == password :
            INDENT
                authenticated = True
            DEDENT
            line = f.readline().strip()
        DEDENT
        if authenticated :
        INDENT
            print ("****You're in!*****")
            mainmenu()
        DEDENT
        else :
        INDENT
            print ("Wrong username or password, sorry!")
            welcomemenu()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    with open('userinfo.txt', 'r') as f :
    INDENT
        reader = csv.reader(f)
        username_correct = False
        password_correct = False
        for row in reader :
        INDENT
            for field in row :
            INDENT
                if field == username :
                INDENT
                    currentindex = row.index(field)
                    if row [currentindex + 1] == password :
                    INDENT
                        username_correct = True
                        password_correct = True
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    if password_correct == False or username_correct == False :
    INDENT
        print ("Wrong username or password, sorry!")
        welcomemenu()
    DEDENT
    print ("****You're in!*****")
    mainmenu()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46011337_46011527_1_18
46011337_46027732_28_35
Title: Invisible jump to the main menu from a function - can anyone spot the error? 
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    with open('userinfo.txt', 'r') as f :
    INDENT
        authenticated = False
        line = f.readline().strip()
        while authenticated == False and line ! = "" :
        INDENT
            values = line.split(",")
            if len(values) > = 2 and values [0] == username and values [1] == password :
            INDENT
                authenticated = True
            DEDENT
            line = f.readline().strip()
        DEDENT
        if authenticated :
        INDENT
            print ("****You're in!*****")
            mainmenu()
        DEDENT
        else :
        INDENT
            print ("Wrong username or password, sorry!")
            welcomemenu()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    valid = is_valid_user(username, password)
    if not valid :
    INDENT
        print ("Wrong username or password, sorry!")
    DEDENT
    return valid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46011337_46011558_1_20
46011337_46027732_28_35
Title: Invisible jump to the main menu from a function - can anyone spot the error? 
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    with open('userinfo.txt', 'r') as f :
    INDENT
        reader = csv.reader(f)
        username_correct = False
        password_correct = False
        for row in reader :
        INDENT
            for field in row :
            INDENT
                if field == username :
                INDENT
                    currentindex = row.index(field)
                    if row [currentindex + 1] == password :
                    INDENT
                        username_correct = True
                        password_correct = True
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    if password_correct == False or username_correct == False :
    INDENT
        print ("Wrong username or password, sorry!")
        welcomemenu()
    DEDENT
    print ("****You're in!*****")
    mainmenu()
DEDENT
----------------------------------------

def login() :
INDENT
    print ("===Login===")
    username = input("Enter username:")
    password = input("Enter password:")
    valid = is_valid_user(username, password)
    if not valid :
    INDENT
        print ("Wrong username or password, sorry!")
    DEDENT
    return valid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46017983_46018053_1_14
46017983_46018774_1_9
Title: Is there another way to find boolean in a list of lists? 
----------------------------------------

def findinlist(thing) :
INDENT
    if type(thing) is bool :
    INDENT
        thing = str(thing)
    DEDENT
    global rowsfound
    rowsfound = []
    for sample in enddata :
    INDENT
        for element in sample :
        INDENT
            try :
            INDENT
                if thing in element :
                INDENT
                    rowsfound.append(sample)
                    break
                DEDENT
            DEDENT
            except TypeError :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    return rowsfound
DEDENT
----------------------------------------

def findinlist(thing) :
INDENT
    global rowsfound
    rowsfound = []
    for sample in enddata :
    INDENT
        if thing in sample :
        INDENT
            rowsfound.append(sample)
            break
        DEDENT
    DEDENT
    return rowsfound
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46020095_46020202_1_10
46020095_46082447_1_21
Title: Deleting a linked-list node at a given position 
----------------------------------------

def Delete(head, position) :
INDENT
    temp = head
    if position == 0 :
    INDENT
        return temp.next
    DEDENT
    while position - 1 > 0 :
    INDENT
        head = head.next
        position -= 1
    DEDENT
    head.next = head.next.next
    return temp
DEDENT
----------------------------------------

def Delete(head, position) :
INDENT
    current = head
    previous = None
    found = False
    count = 0
    while not found :
    INDENT
        if count == position :
        INDENT
            found = True
        DEDENT
        else :
        INDENT
            previous = current
            current = current.next
        DEDENT
        count += 1

    DEDENT
    if previous == None :
    INDENT
        head = current.next
    DEDENT
    else :
    INDENT
        previous.next = current.next
    DEDENT
    return head
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46024724_46024891_3_31
46024724_46025125_2_10
Title: PyQt: How to create a scrollable window 
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    layout = QVBoxLayout()
    lbl_arr = makeArrayOfLabelsHTML()
    for i in range(1, 8) :
    INDENT
        qb = lbl_arr [i]
        layout.addWidget(qb)
    DEDENT
    layout.setAlignment(Qt.AlignTop)
    scroll = QScrollArea()
    scroll.setWidget(self)
    scroll.setWidgetResizable(True)
    scroll.setFixedHeight(400)
    layout.addWidget(scroll)

    self.setLayout(layout)
    self.setGeometry(0, 0, 600, 220)
    self.setWindowTitle('SnP watchlist')
    self.show()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    widget = QWidget()
    layout = QVBoxLayout(widget)
    layout.setAlignment(Qt.AlignTop)
    for index in range(100) :
    INDENT
        layout.addWidget(QLabel('Label %02d' % index))
    DEDENT
    self.setWidget(widget)
    self.setWidgetResizable(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46029985_46030075_1_11
46029985_46030101_1_8
Title: Retrieving the position of a a substring present in a string 
----------------------------------------

def separate(string, n) :
INDENT
    k = [string [i : i + n] for i in range(0, len(string), n)]
    current = string
    start = 0
    end = 0
    for i, element in enumerate(k) :
    INDENT
        start = end + current.index(element) + 1
        end = start + len(element) - 1
        current = string [end :]
        print ("PART{i}\t{el}\t{s} {e}".format(i = i, el = element, s = start, e = end))
    DEDENT
DEDENT
----------------------------------------

def separate(string, n) :
INDENT
    k = [string [i : i + n] for i in range(0, len(string), n)]
    yield k
    for curr_index in range(len(k)) :
    INDENT
        element = k [curr_index]
        curr = curr_index * n + 1
        print ('PART' + str(curr_index + 1) + '\t' + element + '\t' + str(curr) + str(curr + n - 1))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46034504_46045164_10_16
46034504_46054674_10_21
Title: scrapy crawl a website 
----------------------------------------

def parse(self, response) :
INDENT
    for article in response.css('.article') :
    INDENT
        yield {
            'title' : article.css('.article-title h1::text').extract(),
            'time' : article.css('.article-time time::text').extract(),
            'article' : article.css('.article-text p::text').extract(),
            }
    DEDENT
DEDENT
----------------------------------------

def parse(self, response) :
INDENT
    for article in response.css('.main-news') :
    INDENT
        yield {
            'title' : article.css('.article-title h1::text').extract(),
            'time' : article.css('.article-time time::text').extract(),
            'another' : article.css('.article-source::text').extract(),
            'section' : response.xpath('/html/body/div[3]/div/div/div[1]/ol/li[2]/a//text()').extract(),
            'article' : article.css('.article-text p::text').extract()}

    DEDENT
    for next_page in response.css('a::attr(href)') :
    INDENT
        yield response.follow(next_page, self.parse)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46036863_46036944_11_16
46036863_46039829_27_35
Title: Python 3: Tkinter: How to change Entry.get() into an integer 
----------------------------------------

def convert(value) :
INDENT
    if value is None :
    INDENT
        return None
    DEDENT
    else :
    INDENT
        return 1.8 * value + 32
    DEDENT
DEDENT
----------------------------------------

def convert(self, event = None) :
INDENT
    try :
    INDENT
        print (self.x.get())
        conversion = self.x.get()
        conversion = conversion * 1.8 + 32
        self.l.config(text = conversion)
    DEDENT
    except tk.TclError :
    INDENT
        self.l.config(text = "Not an integer")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46050084_46050750_3_11
46050084_46050885_2_14
Title: recursion and multi dimension matrix in python 
----------------------------------------

def pathCounter(x, y) :
INDENT
    if x == 0 or y == 0 :
    INDENT
        return 1
    DEDENT
    if (x, y) in cache :
    INDENT
        return cache [(x, y)]
    DEDENT
    cache [(x, y)] = pathCounter(x, y - 1) + pathCounter(x - 1, y)
    return cache [(x, y)]
DEDENT
----------------------------------------

def pathCounter(width, height) :
INDENT
    grid = np.zeros((height + 1, width + 1))
    def pathCounterInternal(x, y) :
    INDENT
        if x == 0 or y == 0 :
        INDENT
            return 1
        DEDENT
        grid [x, y] = pathCounterInternal(x, y - 1) + pathCounterInternal(x - 1, y)
        return grid [x, y]
    DEDENT
    grid [width, height] = pathCounterInternal(width, height)
    return grid [width, height]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
460586_460924_2_10
460586_460924_5_9
Title: Simulating a 'local static' variable in python 
----------------------------------------

def CalcSomething() :
INDENT
    cache = {}
    def CalcSomething(a) :
    INDENT
        if cache.has_key(a) :
        INDENT
            return cache [a]
        DEDENT
        cache [a] = ReallyCalc(a)
        return cache [a]
    DEDENT
    return CalcSomething
DEDENT
----------------------------------------

def CalcSomething(a) :
INDENT
    if cache.has_key(a) :
    INDENT
        return cache [a]
    DEDENT
    cache [a] = ReallyCalc(a)
    return cache [a]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46061798_46064943_47_58
46061798_46064943_9_23
Title: Pygame class menu 
----------------------------------------

def __init__(self, pos, text, window) :
INDENT
    super().__init__()
    self.text_surf = window.font.render(text, True, window.colors ["black"])
    self.image = pg.Surface((self.text_surf.get_width() + 40,
            self.text_surf.get_height() + 20))
    self.image.fill(window.colors ["white"])
    self.image.blit(self.text_surf, (20, 10))
    self.rect = self.image.get_rect(topleft = pos)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.screen = pg.display.set_mode((800, 600))
    self.rect = self.screen.get_rect()
    self.FPS = 30
    self.clock = pg.time.Clock()
    self.font = pg.font.SysFont("Arial", 25)
    self.menu_open = True
    self.colors = {"red" : (255, 0, 0),
        "green" : (0, 255, 0),
        "blue" : (0, 0, 255),
        "white" : (255, 255, 255),
        "black" : (0, 0, 0),
        "brown" : (153, 76, 0),
        "grey" : (100, 100, 100)}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46065414_46065833_1_8
46065414_46074267_7_13
Title: How Do I Make a Program to Calculate The Value Of Each Word 
----------------------------------------

def findworth() :
INDENT
    for i, char in enumerate(wordlist) :
    INDENT
        if char in worth :
        INDENT
            output = (worth [char])
            wordlist [i] = (output)
        DEDENT
        else :
        INDENT
            output = (None)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def findworth(word) :
INDENT
    total = 0
    for char in word :
    INDENT
        if char in worth :
        INDENT
            total += worth [char]
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------
