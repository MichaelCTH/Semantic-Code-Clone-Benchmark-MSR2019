$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43262179_43262336_3_13
43262179_43262656_3_18
Title: Python appending a list and stopping it 
----------------------------------------

def main() :
INDENT
    grades = []

    print ('Please enter the final grades for 10 students: ')
    for i in range(num_grades) :
    INDENT
        grade = input('Enter a grade: ')
        grades.append(grade)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    grades = [0] * num_grades

    index = 0

    print ('Please enter the final grades for 10 students: ')
    while index < num_grades :
    INDENT
        grade = input('Enter a grade: ')
        grades.append(grade)
        index += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43275092_43292398_33_42
43275092_43292398_9_16
Title: Not able to get running the timeout mechanism shown in https://github.com/tyarkoni/transitions/issues/198. 
----------------------------------------

def __init__(self, model, states, transitions, initial, title) :
INDENT
    super(TimeoutMachine, self).__init__(model = model,
        states = states,
        transitions = transitions,
        initial = initial,
        name = title,
        queued = True,
        auto_transitions = True,
        send_event = True)
DEDENT
----------------------------------------

def __init__(self, func, timeout) :
INDENT
    super(Timeout, self).__init__()
    self.func = func
    self.timeout = timeout
    self.canceled = False
    print 'Starting countdown'
    self.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43286545_43286705_12_19
43286545_43286766_1_11
Title: Python iterator returning unwanted 'None' 
----------------------------------------

def __next__(self) :
INDENT
    while self.i < self.length :
    INDENT
        old = self.i
        self.i += self.n
        if (self.purchase [old]) % (self.d) == 0 :
        INDENT
            return old + 1
        DEDENT
    DEDENT
    raise StopIteration
DEDENT
----------------------------------------

def __next__(self) :
INDENT
    if self.i < self.length :
    INDENT
        old = self.i
        self.i += self.n
        if (self.purchase [old]) % (self.d) == 0 :
        INDENT
            print ("returning")
            return old + 1
        DEDENT
        else :
        INDENT
            return self.__next__()
        DEDENT
    DEDENT
    else :
    INDENT
        raise StopIteration
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43288470_43288708_15_35
43288470_43288765_1_23
Title: Filtering/Grouping a list of dictionaries by a list of keys 
----------------------------------------

def group_dictionary(list_of_dicts, list_of_keys) :
INDENT
    group_vals = {}
    current_max_group = 0
    dicts_to_remove = []
    for i, d in enumerate(list_of_dicts) :
    INDENT
        if not all(k in d for k in list_of_keys) :
        INDENT
            dicts_to_remove.append(i)
        DEDENT
        else :
        INDENT
            value_key = make_value_key(d, list_of_keys)
            if value_key in group_vals :
            INDENT
                d ['group'] = group_vals [value_key]
            DEDENT
            else :
            INDENT
                group_vals [value_key] = current_max_group
                d ['group'] = current_max_group
                current_max_group += 1
            DEDENT
        DEDENT
    DEDENT
    list_of_dicts = [i for j, i in enumerate(list_of_dicts) if j not in dicts_to_remove]
    return list_of_dicts
DEDENT
----------------------------------------

def group_dictionary(dicts, keys) :
INDENT
    groups = []
    result = []
    for d in dicts :
    INDENT
        if any(key not in d for key in keys) :
        INDENT
            continue
        DEDENT
        serialized_data = serialize(d, keys)

        if serialized_data not in groups :
        INDENT
            groups.append(serialized_data)

        DEDENT
        d ['group'] = groups.index(serialized_data)

        result.append(d)
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43289024_43289977_1_17
43289024_43290240_1_14
Title: Show common elements in a list and how many times they appeared in python 
----------------------------------------

def common(a, b) :
INDENT
    sorted_a, sorted_b = sorted(a), sorted(b)
    numa, numb = len(a), len(b)
    rv = []
    i, j = 0, 0
    while i < numa and j < numb :
    INDENT
        if sorted_a [i] == sorted_b [j] :
        INDENT
            rv.append(sorted_a [i])
            i += 1
            j += 1
        DEDENT
        elif sorted_a [i] < sorted_b [j] :
        INDENT
            i += 1
        DEDENT
        else :
        INDENT
            j += 1
        DEDENT
    DEDENT
    return rv
DEDENT
----------------------------------------

def common(lista = None, listb = None) :
INDENT
    result_list = list()
    inter_dict = dict()
    lista_count = dict()
    listb_count = dict()
    for i in lista :
    INDENT
        lista_count [i] = lista_count.get(i, 0) + 1
    DEDENT
    for i in listb :
    INDENT
        listb_count [i] = lista_count.get(i, 0) + 1
    DEDENT
    for key in set(lista_count).intersection(set(listb_count)) :
    INDENT
        inter_dict [key] = min(lista_count [key], listb_count [key])
    DEDENT
    for k, v in inter_dict.items() :
    INDENT
        result_list.extend([k] * v)
    DEDENT
    return result_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43289024_43289977_1_17
43289024_43290383_1_12
Title: Show common elements in a list and how many times they appeared in python 
----------------------------------------

def common(a, b) :
INDENT
    sorted_a, sorted_b = sorted(a), sorted(b)
    numa, numb = len(a), len(b)
    rv = []
    i, j = 0, 0
    while i < numa and j < numb :
    INDENT
        if sorted_a [i] == sorted_b [j] :
        INDENT
            rv.append(sorted_a [i])
            i += 1
            j += 1
        DEDENT
        elif sorted_a [i] < sorted_b [j] :
        INDENT
            i += 1
        DEDENT
        else :
        INDENT
            j += 1
        DEDENT
    DEDENT
    return rv
DEDENT
----------------------------------------

def common(l1, l2) :
INDENT
    totalElements = l1 + l2
    resultList = []
    for num in totalElements :
    INDENT
        if num in l1 and num in l2 :
        INDENT
            resultList.append(num)
            l1.remove(num)
            l2.remove(num)
        DEDENT
    DEDENT
    return resultList
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43289024_43290240_1_14
43289024_43290383_1_12
Title: Show common elements in a list and how many times they appeared in python 
----------------------------------------

def common(lista = None, listb = None) :
INDENT
    result_list = list()
    inter_dict = dict()
    lista_count = dict()
    listb_count = dict()
    for i in lista :
    INDENT
        lista_count [i] = lista_count.get(i, 0) + 1
    DEDENT
    for i in listb :
    INDENT
        listb_count [i] = lista_count.get(i, 0) + 1
    DEDENT
    for key in set(lista_count).intersection(set(listb_count)) :
    INDENT
        inter_dict [key] = min(lista_count [key], listb_count [key])
    DEDENT
    for k, v in inter_dict.items() :
    INDENT
        result_list.extend([k] * v)
    DEDENT
    return result_list
DEDENT
----------------------------------------

def common(l1, l2) :
INDENT
    totalElements = l1 + l2
    resultList = []
    for num in totalElements :
    INDENT
        if num in l1 and num in l2 :
        INDENT
            resultList.append(num)
            l1.remove(num)
            l2.remove(num)
        DEDENT
    DEDENT
    return resultList
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43290138_43500494_1_42
43290138_49160669_1_11
Title: Softmax function of a numpy array by row 
----------------------------------------

def softmax(X, theta = 1.0, axis = None) :
INDENT
    y = np.atleast_2d(X)

    if axis is None :
    INDENT
        axis = next(j [0] for j in enumerate(y.shape) if j [1] > 1)

    DEDENT
    y = y * float(theta)

    y = y - np.expand_dims(np.max(y, axis = axis), axis)

    y = np.exp(y)

    ax_sum = np.expand_dims(np.sum(y, axis = axis), axis)

    p = y / ax_sum

    if len(X.shape) == 1 : p = p.flatten()
    return p
DEDENT
----------------------------------------

def softmax(a, axis = None) :
INDENT
    from scipy.special import logsumexp
    lse = logsumexp(a, axis = axis)
    if axis is not None :
    INDENT
        lse = np.expand_dims(lse, axis)
    DEDENT
    return np.exp(a - lse)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43302060_43302489_30_41
43302060_43302489_5_28
Title: Tkinter OptionMenu widget is not displaying values 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.title("Edit User Details")
    self.option_add("*Font", 'TkDefaultFont')
    self.noteBook = ttk.Notebook(self)
    for user in users :
    INDENT
        self.noteBook.add(UserFrame(self, user), text = user [2])
    DEDENT
    self.noteBook.pack()
    self.resizable(width = False, height = False)
DEDENT
----------------------------------------

def __init__(self, master = None, data = None, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    data = data [2], data [0], data [1]
    labels = ("User's name:", "Username:", "Password:")
    for row, (label, value) in enumerate(zip(labels, data)) :
    INDENT
        lbl = tk.Label(self, text = label)
        lbl.grid(row = row, column = 0, sticky = tk.W)
        ent = tk.Entry(self)
        ent.insert(0, value)
        ent.grid(row = row, column = 1, sticky = tk.E)
    DEDENT
    lbl = tk.Label(self, text = "User Access:")
    lbl.grid(row = 3, column = 0, sticky = tk.W)
    self.options = tk.StringVar(self, "User")
    self.userAccessDrop = ttk.OptionMenu(self,
        self.options,
        "User",
        "User", "Admin",
        )
    self.userAccessDrop.config(width = 10)
    self.userAccessDrop.grid(row = len(labels), column = 1, sticky = tk.E)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43305658_43306290_5_22
43305658_43307304_3_19
Title: Proper way to make a call to an Endpoint from the API using Flask 
----------------------------------------

def new_user() :
INDENT
    user_json = json.loads(request.get_json())
    first_name = user_json.get('first_name')
    last_name = user_json.get('last_name')
    email = user_json.get('email')
    password = user_json.get('password')
    user = get_user(email)
    if not user :
    INDENT
        try :
        INDENT
            user = User(first_name = first_name, last_name = last_name, email = email, password = password)
            db.session.add(user)
            db.session.commit()
            return jsonify(user = user.to_json()), 200
        DEDENT
        except :
        INDENT
            return jsonify(error = 500), 500
        DEDENT
    DEDENT
    else :
    INDENT
        return jsonify(user = user.to_json()), 409
    DEDENT
DEDENT
----------------------------------------

def new_user(email) :
INDENT
    if (email) :
    INDENT
        user = User.query.filter_by(email = email).first()
        if user :
        INDENT
            return jsonify(user = user.to_json()), 200
        DEDENT
        else :
        INDENT
            return jsonify(error = 404), 404
        DEDENT
    DEDENT
    else :
    INDENT
        user_json = json.loads(request.get_json())
        first_name = user_json.get('first_name')
        last_name = user_json.get('last_name')
        email = user_json.get('email')
        password = user_json.get('password')
        user = User(first_name = first_name, last_name = last_name, email = email, password = password)
        db.session.add(user)
        db.session.commit()
        return jsonify(user = user.to_json()), 200
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4331006_4331034_3_10
4331006_4331039_3_15
Title: Persistent objects in recursive python functions 
----------------------------------------

def foo(bar = None, i = 10) :
INDENT
    if bar is None :
    INDENT
        bar = set()
    DEDENT
    if i == 0 :
    INDENT
        return bar
    DEDENT
    bar |= set(random.randint(1, 1000) for i in xrange(10))
    return foo(bar, i - 1)
DEDENT
----------------------------------------

def foo() :
INDENT
    acc = Accumulator()
    acc.value = 0

    def bar(n) :
    INDENT
        if (n > 0) : bar(n - 1)
        acc.value = acc.value + 1
    DEDENT
    bar(5)

    return acc.value
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43310307_43310405_3_8
43310307_43310527_12_17
Title: (Python) Incorrect string value (CP1521 to UTF8) 
----------------------------------------

def load_data(filepath) :
INDENT
    with open(filepath, 'r') as f :
    INDENT
        temp_data = json.load(f)
    DEDENT
    return temp_data

DEDENT
----------------------------------------

def load_data(filepath) :
INDENT
    with open(filepath, 'r', encoding = datafile_encoding) as f :
    INDENT
        temp_data = json.load(f)
    DEDENT
    return temp_data

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43313869_43313957_1_18
43313869_43313958_1_16
Title: How to append more than one word? 
----------------------------------------

def lengthWords(string) :
INDENT
    string = string.lower()
    string = string.replace(".", "")
    string = string.replace(",", "")
    string = string.replace("?", "")
    string = string.replace("!", "")
    string = string.split()
    wordDictionary = {}
    for word in string :
    INDENT
        number = len(word)
        wordDictionary [number] = []
    DEDENT
    for i in range(0, len(string)) :
    INDENT
        wordDictionary [len(string [i])].append(string [i])
    DEDENT
    return wordDictionary

DEDENT
----------------------------------------

def lengthWords(string) :
INDENT
    non = ['.', ',', '?', '!']
    string = string.lower()
    for x in string :
    INDENT
        if x in non :
        INDENT
            string = string.replace(x, '')
        DEDENT
    DEDENT
    string = string.split()
    wordDictionary = {}
    for word in string :
    INDENT
        if len(word) not in wordDictionary :
        INDENT
            wordDictionary [len(word)] = [x for x in string if len(x) ==
                len(word)]

        DEDENT
    DEDENT
    return wordDictionary
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43315154_43316047_1_10
43315154_43318618_6_14
Title: Python decorated exception cant be excepted 
----------------------------------------

def err_dec(Cls) :
INDENT
    class NewErr(Exception) :
    INDENT
        c = 0
        def __init__(self, * args, ** kwargs) :
        INDENT
            NewErr.c = NewErr.c + 1
            self.err = Cls(* args, ** kwargs)
        DEDENT
        def counter(self) :
        INDENT
            return NewErr.c
        DEDENT
    DEDENT
    return NewErr
DEDENT
----------------------------------------

def err_dec(cls) :
INDENT
    class NewErr(Exception) :
    INDENT
        __metaclass__ = ErrMetaClass
        _cls = cls
        c = 0
        def __init__(self) :
        INDENT
            NewErr.c += 1
        DEDENT
    DEDENT
    return NewErr
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43324267_43325090_5_10
43324267_43325161_3_8
Title: Program to restrict object creation in Python 
----------------------------------------

def __new__(cls) :
INDENT
    if cls._count > = 5 :
    INDENT
        raise Exception('Too many instances were created')
    DEDENT
    cls._count += 1
    return super(A, cls).__new__(cls)
DEDENT
----------------------------------------

def __new__(cls) :
INDENT
    if cls.__count > = 5 :
    INDENT
        raise TypeError("Already instantiated")
    DEDENT
    cls.__count += 1
    return super(RestrictClass, cls).__new__(cls)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43334803_43335009_5_16
43334803_43335652_3_15
Title: Copy files using wildcard and creating directory if not exists with python script 
----------------------------------------

def parse_args() :
INDENT
    parser = argparse.ArgumentParser()
    parser.add_argument('--src', nargs = '*')
    parser.add_argument('--dest')

    raw_args = sys.argv [1 :]
    args = parser.parse_args(raw_args)
    return args
DEDENT
----------------------------------------

def parse_args() :
INDENT
    parser = argparse.ArgumentParser()
    parser.add_argument('--search')
    parser.add_argument('--src')
    parser.add_argument('--dest')

    raw_args = sys.argv [1 :]
    args = parser.parse_args(raw_args)
    return args
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43355378_43355488_3_13
43355378_43355501_3_14
Title: custom Python get BDay range 
----------------------------------------

def get_bdate(start, end, holidays) :
INDENT
    result = list()
    while start < end :
    INDENT
        if start.weekday() > = 5 :
        INDENT
            pass
        DEDENT
        elif start in holidays :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            result.append(start)
        DEDENT
        start += dt.timedelta(days = 1)
    DEDENT
    return result
DEDENT
----------------------------------------

def get_bdate(start, end, hoildays) :
INDENT
    my_list = []
    while start < end :
    INDENT
        if start.weekday() > = 5 :
        INDENT
            start += dt.timedelta(days = 1)
            continue
        DEDENT
        if start in holidays :
        INDENT
            start += dt.timedelta(days = 1)
            continue
        DEDENT
        my_list.append(start)
        start += dt.timedelta(days = 1)
    DEDENT
    return my_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43357151_43357178_1_22
43357151_43358133_1_24
Title: Not returning expected result python 
----------------------------------------

def isPhoneNumber(text) :
INDENT
    for i in range(0, 3) :
    INDENT
        if not text [i].isdecimal() :
        INDENT
            return False
        DEDENT
    DEDENT
    if text [3] == '-' :
    INDENT
        for i in range(4, 7) :
        INDENT
            if not text [i].isdecimal() :
            INDENT
                return False
            DEDENT
        DEDENT
        for i in range(8, 12) :
        INDENT
            if not text [i].isdecimal() :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    elif text [3].isdecimal() :
    INDENT
        for i in range(4, 6) :
        INDENT
            if not text [i].isdecimal() :
            INDENT
                return False
            DEDENT
        DEDENT
        for i in range(7, 11) :
        INDENT
            if not text [i].isdecimal() :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def isPhoneNumber(text) :
INDENT
    i = 0
    j = 0
    if len(text) < 10 or len(text) > 12 :
    INDENT
        return False
    DEDENT
    while i < 3 :
    INDENT
        if not text [i].isdecimal() :
        INDENT
            return False
        DEDENT
        i += 1
    DEDENT
    if text [i] == '-' :
    INDENT
        i += 1
    DEDENT
    j = i + 3
    while i < j :
    INDENT
        if not text [i].isdecimal() :
        INDENT
            return False
        DEDENT
        i += 1
    DEDENT
    if text [i] == '-' :
    INDENT
        i += 1
    DEDENT
    j = len(text)
    while i < j :
    INDENT
        if not text [i].isdecimal() :
        INDENT
            return False
        DEDENT
        i += 1
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43373776_43375056_22_41
43373776_43375056_4_16
Title: submit button is not work properly in python 3 . how to solve? 
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Toplevel.__init__(self, parent)
    self.buttonDic = {
        '1' : 0,
        '2' : 0,
        '3' : 0,
        '4' : 0}
    for key in self.buttonDic :
    INDENT
        self.buttonDic [key] = tk.IntVar(self)
        aCheckButton = tk.Checkbutton(self, text = key,
            variable = self.buttonDic [key])
        aCheckButton.grid(sticky = 'w')
    DEDENT
    submitButton = tk.Button(self, text = "Submit",
        command = self.query_checkbuttons)
    submitButton.grid()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    tk.Tk.__init__(self)
    self.title("MANAGEMENT")
    self.button1 = tk.Button(self, text = "ENTRY", width = 25, command = self.GUI)
    self.button1.grid(row = 0, column = 1, columnspan = 2, sticky = "wesn")
    self.button2 = tk.Button(self, text = "SHOW BILL", width = 25)
    self.button2.grid(row = 1, column = 1, columnspan = 2, sticky = "wesn")
    self.button3 = tk.Button(self, text = "MEMBERS", width = 25)
    self.button3.grid(row = 2, column = 1, columnspan = 2, sticky = "wesn")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43374920_43375318_11_22
43374920_48343856_1_14
Title: How to automatically annotate maximum value in pyplot? 
----------------------------------------

def annot_max(x, y, ax = None) :
INDENT
    xmax = x [np.argmax(y)]
    ymax = y.max()
    text = "x={:.3f}, y={:.3f}".format(xmax, ymax)
    if not ax :
    INDENT
        ax = plt.gca()
    DEDENT
    bbox_props = dict(boxstyle = "square,pad=0.3", fc = "w", ec = "k", lw = 0.72)
    arrowprops = dict(arrowstyle = "->", connectionstyle = "angle,angleA=0,angleB=60")
    kw = dict(xycoords = 'data', textcoords = "axes fraction",
        arrowprops = arrowprops, bbox = bbox_props, ha = "right", va = "top")
    ax.annotate(text, xy = (xmax, ymax), xytext = (0.94, 0.96), ** kw)
DEDENT
----------------------------------------

def annot_max(x, y, ax = None) :
INDENT
    maxIxVal = np.argmax(y);
    zeroBasedIx = np.argwhere(y.index == maxIxVal).flatten() [0];
    xmax = x [zeroBasedIx];
    ymax = y.max()
    text = "k={:d}, measure={:.3f}".format(xmax, ymax)
    if not ax :
    INDENT
        ax = plt.gca()
    DEDENT
    bbox_props = dict(boxstyle = "round,pad=0.3", fc = "w", ec = "k", lw = 0.72)
    arrowprops = dict(arrowstyle = "-", connectionstyle = "arc3,rad=0.1")
    kw = dict(xycoords = 'data', textcoords = "axes fraction",
        arrowprops = arrowprops, bbox = bbox_props, ha = "right", va = "top")
    ax.annotate(text, xy = (xmax, ymax), xytext = (0.94, 0.90), ** kw)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43401292_43402057_24_37
43401292_43402057_4_18
Title: Defining a tkinter button command to change a canvas in the frame 
----------------------------------------

def __init__(self, master = None, ** kwargs) :
INDENT
    tk.Canvas.__init__(self, master, ** kwargs)

    self.create_oval(25, 40, 105, 120)

    self.create_oval(40, 55, 60, 75)
    self.create_oval(70, 55, 90, 75)

    self.mouth = []
    self.normal_mouth()
DEDENT
----------------------------------------

def __init__(self, master = None, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.face = Face(self, width = 125, height = 175, bg = "#76F015")
    self.face.pack()
    btn = tk.Button(self, text = "Smile", command = self.face.smile)
    btn.pack()
    btn = tk.Button(self, text = "Normal", command = self.face.normal_mouth)
    btn.pack()
    btn = tk.Button(self, text = "Quick smile", command = self.quick_smile)
    btn.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43420535_43420598_1_19
43420535_43420687_1_10
Title: how to pass optional parameters into a function in python? 
----------------------------------------

def json_response_message(status, message, * args) :
INDENT
    assert len(args) == 0 or len(args) == 2
    data = {
        'status' : status,
        'message' : message,
        }

    if args :
    INDENT
        option_key = args [0]
        option_value = args [1]
        data [option_key] = option_value
    DEDENT
    return data
DEDENT
----------------------------------------

def json_response_message(status, message, options = ()) :
INDENT
    data = {
        'status' : status,
        'message' : message,
        }

    data.update(options)
    return data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43420637_43426650_10_17
43420637_43426650_25_34
Title: Determining a collision of an arching projectile with another sprite in Pygame 
----------------------------------------

def __init__(self, pos, color) :
INDENT
    super().__init__()
    self.image = pg.Surface((50, 30))
    self.image.fill(color)
    self.rect = self.image.get_rect(center = pos)
    self.pos = pg.math.Vector2(pos)
    self.vel = pg.math.Vector2()
DEDENT
----------------------------------------

def __init__(self, pos, color, target) :
INDENT
    super().__init__()
    self.image = pg.Surface((7, 5))
    self.image.fill(color)
    self.rect = self.image.get_rect(center = pos)
    self.pos = pg.math.Vector2(pos)
    direction = target - self.pos
    self.vel = direction.normalize() * 33
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43420637_43426650_10_17
43420637_43426650_45_62
Title: Determining a collision of an arching projectile with another sprite in Pygame 
----------------------------------------

def __init__(self, pos, color) :
INDENT
    super().__init__()
    self.image = pg.Surface((50, 30))
    self.image.fill(color)
    self.rect = self.image.get_rect(center = pos)
    self.pos = pg.math.Vector2(pos)
    self.vel = pg.math.Vector2()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.fps = 30
    self.screen = pg.display.set_mode((800, 600))
    pg.display.set_caption('Ballistic trajectory')
    self.clock = pg.time.Clock()
    self.bg_color = pg.Color(90, 120, 100)
    self.green = pg.Color('aquamarine2')
    self.blue = pg.Color(30, 90, 150)
    self.font = pg.font.Font(None, 30)
    self.player = Player((100, 300), self.green)
    self.player2 = Player((400, 300), self.blue)
    self.all_sprites = pg.sprite.Group(self.player, self.player2)
    self.projectiles = pg.sprite.Group()
    self.collisions = 0
    self.done = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43420637_43426650_25_34
43420637_43426650_45_62
Title: Determining a collision of an arching projectile with another sprite in Pygame 
----------------------------------------

def __init__(self, pos, color, target) :
INDENT
    super().__init__()
    self.image = pg.Surface((7, 5))
    self.image.fill(color)
    self.rect = self.image.get_rect(center = pos)
    self.pos = pg.math.Vector2(pos)
    direction = target - self.pos
    self.vel = direction.normalize() * 33
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.fps = 30
    self.screen = pg.display.set_mode((800, 600))
    pg.display.set_caption('Ballistic trajectory')
    self.clock = pg.time.Clock()
    self.bg_color = pg.Color(90, 120, 100)
    self.green = pg.Color('aquamarine2')
    self.blue = pg.Color(30, 90, 150)
    self.font = pg.font.Font(None, 30)
    self.player = Player((100, 300), self.green)
    self.player2 = Player((400, 300), self.blue)
    self.all_sprites = pg.sprite.Group(self.player, self.player2)
    self.projectiles = pg.sprite.Group()
    self.collisions = 0
    self.done = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43426200_43443187_54_65
43426200_43443187_9_29
Title: Python: calling a parent class method to deconfiey a windows (Tkinter) causes two sets of the widgets in the window 
----------------------------------------

def __init__(self, mainUI) :
INDENT
    self.mainUI = mainUI
    self.g = tk.Toplevel()
    self.g.title('Monopoly')
    self.g.wm_iconbitmap('icons\Monopoly-Icon.ico')
    self.g.geometry((resolution))
    self.menuButton = tk.Button(self.g, text = 'Main Menu', command = self.exitMenu)
    self.menuButton.grid(column = 0, row = 0)
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.master.title("Monopoly")
    self.master.wm_iconbitmap('icons\Monopoly-Icon.ico')
    self.master.geometry((resolution))

    self.label = tk.Label(master, text = 'Welcome to Monopoly! PLACEHOLDER')
    self.playButton = tk.Button(master, text = 'Play Game', command = self.playGame)
    self.settingsButton = tk.Button(master, text = 'settings', command = self.settings)
    self.exitButton = tk.Button(master, text = 'Exit', command = self.exitGame)
    self.label.grid(columnspan = 2)
    self.playButton.grid(column = 0)
    self.settingsButton.grid(column = 0)
    self.exitButton.grid(column = 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43432339_43432389_1_16
43432339_43454213_2_9
Title: Loading image of explosion when collision with character sprite in Pygame 
----------------------------------------

def __init__(self, center, size) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.size = size
    img = pg.image.load('regularExplosion00.png').convert()
    img.set_colorkey(BLACK)
    if size == 'lg' :
    INDENT
        self.image = pg.transform.scale(img, (75, 75))
    DEDENT
    elif size == 'sm' :
    INDENT
        self.image = pg.transform.scale(img, (32, 32))
    DEDENT
    self.rect = self.image.get_rect()
    self.rect.center = center
    self.frame = 0
    self.last_update = pg.time.get_ticks()
    self.frame_rate = 50
DEDENT
----------------------------------------

def __init__(self, center) :
INDENT
    pg.sprite.Sprite.__init__(self)
    self.image = EXPLOSION_IMGS [0]
    self.rect = self.image.get_rect(center = center)
    self.frame = 0
    self.last_update = pg.time.get_ticks()
    self.frame_rate = 50
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43449773_43450244_6_19
43449773_43450812_1_19
Title: I want to extract a certain number of words surrounding a given word in a long string(paragraph) in Python 2.7 
----------------------------------------

def search(target, text, context = 6) :
INDENT
    words = re.findall(r'\w+', text)
    matches = (i for (i, w) in enumerate(words) if w.lower() == target)
    for index in matches :
    INDENT
        if index < context / / 2 :
        INDENT
            yield words [0 : context + 1]
        DEDENT
        elif index > len(words) - context / / 2 - 1 :
        INDENT
            yield words [- (context + 1) :]
        DEDENT
        else :
        INDENT
            yield words [index - context / / 2 : index + context / / 2 + 1]
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def search(text, word, n) :
INDENT
    words = text.split(" ")
    position = words.index(word)
    distance_from_end = len(words) - position
    if position < n / / 2 + n % 2 :
    INDENT
        return words [: position], words [position + 1 : n + 1]
    DEDENT
    elif distance_from_end < n / / 2 + n % 2 :
    INDENT
        return words [position - n + distance_from_end : position], words [position + 1 :]
    DEDENT
    else :
    INDENT
        return words [position - n / / 2 - n % 2 : position], words [position + 1 : position + 1 + n / / 2]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43458972_43459217_1_17
43458972_43459631_1_19
Title: Can certain arguments not be specified in a function? 
----------------------------------------

def check_win(token) :
INDENT
    for i in range(0, 6) :
    INDENT
        for j in range(0, 6) :
        INDENT
            if i - 3 in range(0, 6) and j + 3 in range(0, 6) :
            INDENT
                if board [i] [j] == token and board [i - 1] [j + 1] == token and board [i - 2] [j + 2] == token and board [i - 3] [j + 3] == token :
                INDENT
                    return True
                DEDENT
            DEDENT
            if i - 3 in range(0, 6) and j - 3 in range(0, 6) :
            INDENT
                if board [i] [j] == token and board [i - 1] [j - 1] == token and board [i - 2] [j - 2] == token and board [i - 3] [j - 3] == token :
                INDENT
                    return True
                DEDENT
            DEDENT
            if j + 3 in range(0, 6) :
            INDENT
                if board [i] [j] == token and board [i] [j + 1] == token and board [i] [j + 2] == token and board [i] [j + 3] == token :
                INDENT
                    return True
                DEDENT
            DEDENT
            if i - 3 in range(0, 6) :
            INDENT
                if board [i] [j] == token and board [i - 1] [j] == token and board [i - 2] [j] == token and board [i - 3] [j] == token :
                INDENT
                    return True
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def check_win(token) :
INDENT
    token = [token] * 4
    l1 = lambda i, j : [board [i - p] [j + p] for p in range(4)]
    l2 = lambda i, j : [board [i - p] [j - p] for p in range(4)]
    for i in range(5, - 1, - 1) :
    INDENT
        c = 0
        for k in range(4) :
        INDENT
            if board [i] [k : k + 4] == token :
            INDENT
                return True
            DEDENT
        DEDENT
        if i > 2 :
        INDENT
            for k in range(6) :
            INDENT
                if [sub [k] for sub in board [i - 3 : i + 1]] == token :
                INDENT
                    return True
                DEDENT
            DEDENT
            for k in range(4) :
            INDENT
                if l1(i, k) == token :
                INDENT
                    return True
                DEDENT
                if l2(i, k + 3) == token :
                INDENT
                    return True
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43462933_43464465_1_12
43462933_43464477_1_13
Title: StringVar().get() not returning string 
----------------------------------------

def pageclicks(self) :
INDENT
    print ("pageClicks is getting called at least...")
    pop = Tk()
    pop.wm_title("Page Number")
    pop.label = Label(pop, text = "Enter a Page Number:", width = 35)
    pop.label.pack(side = TOP)
    pop._entry = Entry(pop)
    pop._entry.pack()
    pop._entry.focus_set()
    Button(pop, text = "Submit", command = lambda a = pop : self.submitted(a)).pack(side = LEFT, pady = 5, padx = 40)
    Button(pop, text = "Cancel", command = pop.destroy).pack(side = LEFT, pady = 5, padx = 40)
DEDENT
----------------------------------------

def pageclicks(self) :
INDENT
    print ("pageClicks is getting called at least...")
    pop = tk.Toplevel()
    pop.wm_title("Page Number")
    pop.label = Label(pop, text = "Enter a Page Number:", width = 35)
    pop.label.pack(side = TOP)
    pop.entrytext = IntVar()
    Entry(pop, textvariable = pop.entrytext).pack()
    pop.submitbuttontext = StringVar()
    Button(pop, text = "Submit", command = lambda a = pop : self.submitted(a)).pack(side = LEFT, pady = 5, padx = 40)
    pop.cancelbuttontext = StringVar()
    Button(pop, text = "Cancel", command = pop.destroy).pack(side = LEFT, pady = 5, padx = 40)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43477723_43478173_1_16
43477723_43478267_1_9
Title: Function doesn't return right values 
----------------------------------------

def get_matlab_sensor_data() :
INDENT
    simulink_robot_motor1 = []
    with open('C:\\Users\...\sensor_data.txt', "r") as data_file :
    INDENT
        rows = 0
        for line in data_file :
        INDENT
            rows = rows + 1
            columns = len(line.split(","))
        DEDENT
        simulink_robot_motor = [[0 for x in range(columns)] for y in range(rows)]
        i = 0
        with open('C:\\Users\...\sensor_data.txt', "r") as data_file :
        INDENT
            for line in data_file :
            INDENT
                current_line = line.split(",")
                current_line = list(map(float, current_line))
                simulink_robot_motor [i] = current_line
                i = i + 1
            DEDENT
        DEDENT
    DEDENT
    return (simulink_robot_motor)
DEDENT
----------------------------------------

def get_matlab_sensor_data() :
INDENT
    results = []
    with open(filename, 'r') as data_file :
    INDENT
        for line in data_file :
        INDENT
            current_line = list(map(float, line.split(',')))
            results.append(current_line)
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43493532_43493871_3_15
43493532_43493892_6_23
Title: Defined Function Won't Print When I Try To Use It Again? 
----------------------------------------

def Start() :
INDENT
    print ("Hello Welcome To Dice Rolling")
    roll = input("\nWould You Like To Roll? Y/N: ")
    while roll == "Y" :
    INDENT
        print ("Alright")
        dice_no = random.randint(0, 6)
        print (dice_no)
        roll = input("\nWould You Like To Roll Again? Y/N: ")
    DEDENT
    else :
    INDENT
        print ("Okay,Cya")
    DEDENT
DEDENT
----------------------------------------

def Start() :
INDENT
    print ("Hello Welcome To Dice Rolling")
    roll = input("\nWould You Like To Roll? Y/N: ")
    if roll.upper() == "Y" :
    INDENT
        print ("Alright")
        print random.choice(dice_numb)
    DEDENT
    if roll.upper() == "N" :
    INDENT
        print ("Okay,Cya")
        sys.exit()
    DEDENT
    while 1 :
    INDENT
        again = input("Would You Like To Roll Again? Y/N: ")
        if again.upper() == "Y" :
        INDENT
            print ("Alright,Lets Do It!")
        DEDENT
        if again.upper() == "N" :
        INDENT
            print ("Okay,Cya.")
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43510763_43511301_2_10
43510763_43512043_3_10
Title: Implement Python class based on the parameter passed to constructor 
----------------------------------------

def __init__(self, serverSettings, dbtype = None) :
INDENT
    if (dbtype == None) :
    INDENT
        self.__worker = MyAClass(serverSettings)
    DEDENT
    elif (dbtype == "MyBClass") :
    INDENT
        self.__worker = MyBClass(serverSettings)
    DEDENT
    else :
    INDENT
        print ("Undefined type")
    DEDENT
DEDENT
----------------------------------------

def __init__(self, serverSettings, Classtype = MyAClass) :
INDENT
    authclasses = [MyAClass, MyBClass]
    if Classtype not in authclasses :
    INDENT
        self.__worker = MyAClass(serverSettings)
    DEDENT
    else :
    INDENT
        self.__worker = MyBClass(serverSettings)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43522887_43522960_1_6
43522887_43523049_3_11
Title: Python decorator - Trying to understand a simple example 
----------------------------------------

def log(fun) :
INDENT
    def wrapper(* args) :
    INDENT
        print ('in decorator!')
        return fun(* args)
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def log(fun) :
INDENT
    @ functools.wraps(fun)
    def inner(* args) :
    INDENT
        try :
        INDENT
            return fun(* args)
        DEDENT
        except TypeError :
        INDENT
            print ('error!')
        DEDENT
    DEDENT
    return inner
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43526507_43527543_6_16
43526507_43528054_57_66
Title: PyQt5: Updating Label? 
----------------------------------------

def __init__(self) :
INDENT
    super(MyApp, self).__init__()
    self.labelTime = QLabel()
    self.update_labelTime()
    self.setCentralWidget(self.labelTime)
    self.timer = QTimer()
    self.timer.timeout.connect(self.update_labelTime)
    self.timer.start(1000)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent = parent)
    self.setupUi(self)
    timerTime = QtCore.QTimer(self)
    timerTime.timeout.connect(self.updateDate)
    timerTime.start(1000)
    self.pyowm = PyownThread(self)
    self.pyowm.tempSignal.connect(self.updateTemp)
    self.pyowm.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43531833_43531997_14_21
43531833_43532023_15_23
Title: Decorator in class: cannot use self inside the decorated function 
----------------------------------------

def inner(* args) :
INDENT
    try :
    INDENT
        print (fun.__name__)
        self.logger.mssg += fun.__name__ + " :ok, "
        return fun(* args)
    DEDENT
    except Exception as e :
    INDENT
        self.logger.err += fun.__name__ + ": error: " + str(e.args)
    DEDENT
DEDENT
----------------------------------------

def inner(* args) :
INDENT
    self = args [0]
    try :
    INDENT
        print (fun.__name__)
        self.logger.mssg += fun.__name__ + " :ok, "
        return fun(self, * (args [1 :]))
    DEDENT
    except Exception as e :
    INDENT
        self.logger.err += fun.__name__ + ": error: " + str(e.args)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43531833_43531997_14_21
43531833_43533223_20_26
Title: Decorator in class: cannot use self inside the decorated function 
----------------------------------------

def inner(* args) :
INDENT
    try :
    INDENT
        print (fun.__name__)
        self.logger.mssg += fun.__name__ + " :ok, "
        return fun(* args)
    DEDENT
    except Exception as e :
    INDENT
        self.logger.err += fun.__name__ + ": error: " + str(e.args)
    DEDENT
DEDENT
----------------------------------------

def inner(* args, ** kwargs) :
INDENT
    try :
    INDENT
        print (fun.__name__)
        self.logger.msg += fun.__name__ + " :ok, "
        return fun(* args, ** kwargs)
    DEDENT
    except Exception as exc :
    INDENT
        self.logger.err += fun.__name__ + ": error: " + str(exc.args)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43531833_43532023_15_23
43531833_43533223_20_26
Title: Decorator in class: cannot use self inside the decorated function 
----------------------------------------

def inner(* args) :
INDENT
    self = args [0]
    try :
    INDENT
        print (fun.__name__)
        self.logger.mssg += fun.__name__ + " :ok, "
        return fun(self, * (args [1 :]))
    DEDENT
    except Exception as e :
    INDENT
        self.logger.err += fun.__name__ + ": error: " + str(e.args)
    DEDENT
DEDENT
----------------------------------------

def inner(* args, ** kwargs) :
INDENT
    try :
    INDENT
        print (fun.__name__)
        self.logger.msg += fun.__name__ + " :ok, "
        return fun(* args, ** kwargs)
    DEDENT
    except Exception as exc :
    INDENT
        self.logger.err += fun.__name__ + ": error: " + str(exc.args)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43554642_43555028_55_63
43554642_43555028_66_82
Title: why is the input when printed represented as an object using tkinter in python? 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Select Event")
    label.pack(pady = 10, padx = 10)
    floorButton = ttk.Button(self, text = "Floor", command = lambda : controller.showFrame(floorPage))
    floorButton.pack()

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Floor")
    label.pack(pady = 10, padx = 10)

    ele1Label = tk.Label(self, text = "Element Group 1:")
    ele1Label.pack()
    skill1 = tk.StringVar()
    ele1Entry = tk.Entry(self, textvariable = skill1)
    ele1Entry.pack()
    ele1Button = ttk.Button(self, text = "Add", command = lambda : controller.floorEle1(ele1Entry))
    ele1Button.pack()
    startButton = ttk.Button(self, text = "Back to Start", command = lambda : controller.showFrame(startPage))
    startButton.pack(side = 'bottom')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43554642_43555028_55_63
43554642_43555028_9_35
Title: why is the input when printed represented as an object using tkinter in python? 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Select Event")
    label.pack(pady = 10, padx = 10)
    floorButton = ttk.Button(self, text = "Floor", command = lambda : controller.showFrame(floorPage))
    floorButton.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "Start Value Calculator")
    tk.Tk.minsize(self, width = 350, height = 300)
    container = tk.Frame(self)
    container.pack(side = 'top', fill = 'both', expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for f in (startPage, floorPage) :
    INDENT

        frame = f(container, self)
        self.frames [f] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.showFrame(startPage)

    self.floorEle1Skills = []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43554642_43555028_66_82
43554642_43555028_9_35
Title: why is the input when printed represented as an object using tkinter in python? 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Floor")
    label.pack(pady = 10, padx = 10)

    ele1Label = tk.Label(self, text = "Element Group 1:")
    ele1Label.pack()
    skill1 = tk.StringVar()
    ele1Entry = tk.Entry(self, textvariable = skill1)
    ele1Entry.pack()
    ele1Button = ttk.Button(self, text = "Add", command = lambda : controller.floorEle1(ele1Entry))
    ele1Button.pack()
    startButton = ttk.Button(self, text = "Back to Start", command = lambda : controller.showFrame(startPage))
    startButton.pack(side = 'bottom')
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "Start Value Calculator")
    tk.Tk.minsize(self, width = 350, height = 300)
    container = tk.Frame(self)
    container.pack(side = 'top', fill = 'both', expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for f in (startPage, floorPage) :
    INDENT

        frame = f(container, self)
        self.frames [f] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.showFrame(startPage)

    self.floorEle1Skills = []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43564329_43568112_14_26
43564329_43568112_28_39
Title: PyQt5 - Properly dynamically sizing and laying out components 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(IOPanel, self).__init__(parent = None)
    lay = QVBoxLayout(self)
    for _ in range(self.numbers_of_fields) :
    INDENT
        w = Field()
        lay.addWidget(w)
    DEDENT
    self.setMinimumSize(QSize(40, 0))
    sizePolicy = QSizePolicy(QSizePolicy.Minimum, QSizePolicy.Preferred)
    self.setSizePolicy(sizePolicy)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Panel, self).__init__(parent = None)
    lay = QHBoxLayout(self)
    self.input = IOPanel()
    self.output = IOPanel()
    self.canvas = QWidget()
    lay.addWidget(self.input, 0, Qt.AlignLeft)
    lay.addWidget(self.canvas, 0, Qt.AlignCenter)
    lay.addWidget(self.output, 0, Qt.AlignRight)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43564465_43564578_1_12
43564465_43564738_1_22
Title: Python Int object not callable 
----------------------------------------

def player_action() :
INDENT
    user_input = int(input("Enter 0 to stay, 1 to go Up, or 2 to go Down: "))
    if user_input == 0 :
    INDENT
        print ("Thank You, you chose to stay")
    DEDENT
    elif user_input == 1 :
    INDENT
        print ("Thank You, you chose to go up")
    DEDENT
    elif user_input == 2 :
    INDENT
        print ("Thank You, you chose to go down")
    DEDENT
    else :
    INDENT
        print ("You have entered an incorrect number, please try again")
        player_action()
    DEDENT
DEDENT
----------------------------------------

def player_action() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            user_input = int(input("Enter 0 to stay, 1 to go Up, or 2 to go Down: "))
        DEDENT
        except ValueError :
        INDENT
            print ('not a number')
            continue
        DEDENT
        if user_input == 0 :
        INDENT
            print ("Thank You, you chose to stay")
        DEDENT
        if user_input == 1 :
        INDENT
            print ("Thank You, you chose to go up")
        DEDENT
        if user_input == 2 :
        INDENT
            print ("Thank You, you chose to go down")
        DEDENT
        else :
        INDENT
            print ("You have entered an incorrect number, please try again")
            continue
        DEDENT
        break
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43566543_43566638_4_17
43566543_43566668_4_14
Title: "TypeError: must be str not NoneType" 
----------------------------------------

def main_spider(max_pages) :
INDENT
    for page in range(1, max_pages + 1) :
    INDENT
        url = "https://en.wikipedia.org/wiki/Star_Wars" + str(page)
        source_code = requests.get(url)
        plain_text = source_code.text
        soup = BeautifulSoup(plain_text, "html.parser")
        for link in soup.findAll("a") :
        INDENT
            try :
            INDENT
                href = "https://en.wikipedia.org/wiki/Star_Wars" + link.get("href")
                print (href)
            DEDENT
            except TypeError :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main_spider(max_pages) :
INDENT
    for page in range(1, max_pages + 1) :
    INDENT
        url = "https://en.wikipedia.org/wiki/Star_Wars" + str(page)
        source_code = requests.get(url)
        plain_text = source_code.text
        soup = BeautifulSoup(plain_text, "html.parser")
        for link in soup.findAll("a") :
        INDENT

            href = "https://en.wikipedia.org/wiki/Star_Wars" + link.get("href")
            print (href)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43569167_43570124_4_12
43569167_43570145_2_9
Title: PyQt5 - resize label to fill the whole window 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QWidget.__init__(self)
    self.label = QtGui.QLabel(self)
    self.label.resize(800, 600)
    pixmap1 = QtGui.QPixmap("image.png")
    self.pixmap = pixmap1.scaled(self.width(), self.height())
    self.label.setPixmap(self.pixmap)
    self.label.setMinimumSize(1, 1)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtWidgets.QLabel.__init__(self)
    self.setSizePolicy(QtWidgets.QSizePolicy.Ignored, QtWidgets.QSizePolicy.Ignored)
    self.resize(800, 600)
    self.pixmap = QtGui.QPixmap("image.jpg")
    self.setPixmap(self.pixmap)
    self.installEventFilter(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43577816_43577908_1_8
43577816_43577948_9_17
Title: Printing part of a string by recursion 
----------------------------------------

def reverse(s, length, iteration) :
INDENT
    if iteration == 0 :
    INDENT
        return '*' + reverse(s, length, iteration + 1)
    DEDENT
    elif iteration == length :
    INDENT
        return s [: : - 1]
    DEDENT
    else :
    INDENT
        return '%s\n' % s [length - iteration : length] [: : - 1] + reverse(s, length, iteration + 1)
    DEDENT
DEDENT
----------------------------------------

def reverse(s) :
INDENT
    if (len(s) > 0) :
    INDENT
        print (s [: : - 1])
        output.append(s [: : - 1])
        reverse(s [1 :])
    DEDENT
    else :
    INDENT
        print ('*')
        output.append('*')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43578332_43578561_1_14
43578332_43578733_1_11
Title: How do I get Python to ignore extra spaces? 
----------------------------------------

def wordCount(myString) :
INDENT
    try :
    INDENT
        words = 0
        word = ''
        for l in myString :
        INDENT
            if (l == ' ' and word ! = '') or (l == myString [- 1] and l ! = ' ') :
            INDENT
                words += 1
                word = ''
            DEDENT
            elif l ! = ' ' :
            INDENT
                word += l
            DEDENT
        DEDENT
        return words
    DEDENT
    except Exception as ex :
    INDENT
        return "Not a string"
    DEDENT
DEDENT
----------------------------------------

def wordCount(s) :
INDENT
    try :
    INDENT
        s = s.strip()
        count = 1
        for i, v in enumerate(s) :
        INDENT
            if (len(s [i : i + 2]) - len(s [i : i + 2].lstrip()) == 1) :
            INDENT
                count += 1
            DEDENT
        DEDENT
        return count
    DEDENT
    except :
    INDENT
        return "Not a string"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43578989_43579043_1_34
43578989_43579336_9_31
Title: unexpected unindent in function 
----------------------------------------

def showHand() :
INDENT
    print ('This game will let you open your saved Dream Hand.')
    filename = input('Please enter your dream hand file name: ')
    try :
    INDENT

        infile = open(filename, 'r')

        card1 = int(infile.readline())
        card2 = int(infile.readline())
        card3 = int(infile.readline())
        card4 = int(infile.readline())
        card5 = int(infile.readline())

        infile.close()

        print ('Your Dream Hand is: ')
        faceValue(card1)
        faceValue(card2)
        faceValue(card3)
        faceValue(card4)
        faceValue(card5)
    DEDENT
    except IOError :
    INDENT
        print ('An error has occurred')
    DEDENT
    finally :
    INDENT
        print ('Thank you for playing')
    DEDENT
DEDENT
----------------------------------------

def showHand() :
INDENT
    print ('This game will let you open your saved Dream Hand.')
    filename = input('Please enter your dream hand file name: ')
    try :
    INDENT
        with open(filename) as infile :
        INDENT
            cards = [int(infile.readline()) for _ in range(5)]

        DEDENT
        print ('Your Dream Hand is: ')
        for card in cards :
        INDENT
            print (faceValue(card))
        DEDENT
    DEDENT
    except IOError :
    INDENT
        print ('An error has occurred')
    DEDENT
    finally :
    INDENT
        print ('Thank you for playing')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43601446_43601487_3_10
43601446_43601646_3_13
Title: "Python Basics - comparison indents if ... else" 
----------------------------------------

def main() :
INDENT
    a = sys.argv [1]
    if a > 5 :
    INDENT
        print "bad input"
    DEDENT
    else :
    INDENT
        print "good input"
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    print (sys.argv [1])
    a = int(sys.argv [1])
    if a > 5 :
    INDENT
        print ("bad input")
    DEDENT
    else :
    INDENT
        print ("good input")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43646979_43653090_45_62
43646979_43653090_4_37
Title: Not sure about Tkinter class structure and layout 
----------------------------------------

def __init__(self) :
INDENT
    root = tk.Tk()
    root.withdraw()
    root.title("Main Window")

    tk.Label(root, text = "This is the main window").pack()
    tk.Button(root, text = "Show data", command = self.show_data).pack()

    self.prompt = PromptWindow(root)

    root.mainloop()

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.win = tk.Toplevel(master)
    self.win.title("Prompt Window")

    self.win.protocol("WM_DELETE_WINDOW", self.close)
    frame = tk.Frame(self.win, height = 500, padx = 20, pady = 20)
    frame.pack()

    tk.Label(frame, text = "Source Directory").grid(row = 0)
    tk.Label(frame, text = "Destination Directory").grid(row = 1)
    tk.Label(frame, text = "Region Size").grid(row = 2)
    tk.Label(frame, text = "Save File Name").grid(row = 3)

    self.source = tk.StringVar()
    tk.Entry(frame, textvariable = self.source).grid(row = 0, column = 1)
    self.destination = tk.StringVar()
    tk.Entry(frame, textvariable = self.destination).grid(row = 1, column = 1)
    self.region_sz = tk.StringVar()
    tk.Entry(frame, textvariable = self.region_sz).grid(row = 2, column = 1)
    self.save_file_name = tk.StringVar()
    tk.Entry(frame, textvariable = self.save_file_name).grid(row = 3, column = 1)

    tk.Button(frame, text = "Enter", command = self.close).grid(row = 4, column = 2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43655566_43657282_6_13
43655566_43673100_6_17
Title: how can i use fileinput to edit multiple files? 
----------------------------------------

def openFiles(dir) :
INDENT
    filePaths = []
    for root, dirs, files in os.walk(dir) :
    INDENT
        for textFile in fnmatch.filter(files, "*.txt") :
        INDENT
            filepath = os.path.join(root, textFile)
            filePaths.append(filepath)
        DEDENT
    DEDENT
    return filePaths
DEDENT
----------------------------------------

def openFiles() :
INDENT
    for dirpath, dirs, files in os.walk('/home/test1/') :
    INDENT
        for filename in fnmatch.filter(files, "*.txt") :
        INDENT
            filepaths = os.path.join(dirpath, filename)
            for line in fileinput.FileInput(filepaths, inplace = 1) :
            INDENT
                if line.startswith("xe") :
                INDENT
                    add = "# {}".format(line)
                    line = line.replace(line, add)
                DEDENT
                sys.stdout.write(line)
                fileinput.close()

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43660552_43661393_1_13
43660552_43661450_1_12
Title: 'Remembering' a variable when using a recursive algorithm? 
----------------------------------------

def function(pos, new_list = None) :
INDENT
    if new_list is None :
    INDENT
        new_list = []
    DEDENT
    if condition :
    INDENT
        for x in range(0, len(another_list)) :
        INDENT
            new_pos = another_list [x]
            new_list.append(new_pos)
            function(new_pos, new_list)
        DEDENT
    DEDENT
    return new_list

DEDENT
----------------------------------------

def function(first_pos) :
INDENT
    def foo(pos) :
    INDENT
        if condition :
        INDENT
            for x in range(0, len(another_list)) :
            INDENT
                new_pos = another_list [x]
                new_list.append(new_pos)
                foo(new_pos)
            DEDENT
        DEDENT
    DEDENT
    new_list = []
    foo(first_pos)
    return new_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43660950_43662171_17_22
43660950_43662171_24_29
Title: Remove_Widget is not working 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(LargeGrid, self).__init__(** kwargs)
    for i in range(64) :
    INDENT
        self.add_widget(MyButton(text = str(i)))

    DEDENT
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(SmallGrid, self).__init__(** kwargs)
    for i in range(8) :
    INDENT
        self.add_widget(Button(text = str(i), background_color = (random.uniform(0, 1), random.uniform(0, 1), random.uniform(0, 1), 1.0)))

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43665878_43666339_16_23
43665878_43666389_21_28
Title: adding duplicated in a dictionary 
----------------------------------------

def main() :
INDENT
    entree = sys.argv [1]
    item = sys.argv [2]
    nombre = sys.argv [3]
    choix = str(entree)
    texte = choix.strip("[']")
    maj(texte, item, nombre, 'my_test_output.txt')
DEDENT
----------------------------------------

def main() :
INDENT
    entree = sys.argv [1]
    item = sys.argv [2]
    nombre = sys.argv [3]
    choix = str(entree)
    texte = choix.strip("[']")
    maj(texte, item, nombre, 'my_test_output.txt')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43670873_43671328_1_36
43670873_43671725_1_24
Title: Tokenize concatenated characters based on given dictionary 
----------------------------------------

def tokenize(string, dictionary) :
INDENT
    sorted_dictionary = sorted(dictionary,
        key = lambda word : len(word),
        reverse = True)
    start = 0
    tokens = []
    while start < len(string) :
    INDENT
        substring = string [start :]
        try :
        INDENT
            word = next(word for word in sorted_dictionary
                if substring.startswith(word))
            offset = len(word)
        DEDENT
        except StopIteration :
        INDENT

            words_indexes = [substring.find(word) for word in sorted_dictionary]
            appeared_words_indexes = filter(lambda index : index > 0,
                words_indexes)
            try :
            INDENT
                offset = min(appeared_words_indexes)
            DEDENT
            except ValueError :
            INDENT

                offset = len(substring)
            DEDENT
            word = substring [: offset]
        DEDENT
        token = word, (start, start + offset), offset
        tokens.append(token)
        start += offset
    DEDENT
    return tokens
DEDENT
----------------------------------------

def tokenize(chars, word_list) :
INDENT
    tokens = []
    for word in word_list :
    INDENT
        word_len = len(word)
        index = 0

        skip = False
        for other_word in word_list :
        INDENT
            if word in other_word and len(other_word) > len(word) :
            INDENT
                print ("skipped word:", word)
                skip = True
            DEDENT
        DEDENT
        if skip :
        INDENT
            continue
        DEDENT
        while index < len(chars) :
        INDENT
            index = chars.find(word, index)
            if index == - 1 :
            INDENT
                break
            DEDENT
            tokens.append((word, (index, word_len + index), word_len))
            index += word_len
        DEDENT
    DEDENT
    return tokens
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43673830_43673963_1_12
43673830_43674168_1_7
Title: NameError: name 'recPower' is not defined 
----------------------------------------

def recPower(a, n) :
INDENT
    if isinstance(a, str) :
    INDENT
        a = int(a)
    DEDENT
    if isinstance(n, str) :
    INDENT
        n = int(n)
    DEDENT
    if n == 0 :
    INDENT
        return 1
    DEDENT
    else :
    INDENT
        return a * recPower(a, n - 1)

    DEDENT
DEDENT
----------------------------------------

def recPower(a, n) :
INDENT
    if n == 0 :
    INDENT
        return 1
    DEDENT
    else :
    INDENT
        return a * recPower(a, n - 1)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4368364_4384082_21_45
4368364_4384082_63_83
Title: Implementing classes in python 
----------------------------------------

def __init__(self, txt) :
INDENT
    self.flightName = txt [0] [3 :].strip()
    self.numLines = len(txt) - 1
    height = []
    wind = []
    temp = []
    for ln in txt [1 :] :
    INDENT
        data = ln.split()
        height.append(float(data [4]))
        wind.append(float(data [3]))
        temp.append(float(data [8]))
    DEDENT
    self.avg_height, self.std_dev_height = avg_dev(height)
    self.avg_wind_speed, self.std_dev_speed = avg_dev(wind)
    self.avg_temp, self.std_dev_temp = avg_dev(temp)
DEDENT
----------------------------------------

def __init__(self, fname) :
INDENT
    self.filename = fname
    self.flight = []
    inf = file(fname, 'r')
    txt = []
    for ln in inf.readlines() :
    INDENT
        if ln [: 3] == 'ACM' :
        INDENT
            if len(txt) > 0 :
            INDENT
                self.flight.append(Flight(txt))
            DEDENT
            txt = []
        DEDENT
        txt.append(ln)
    DEDENT
    if len(txt) > 0 :
    INDENT
        self.flight.append(Flight(txt))
    DEDENT
    inf.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43690007_43690306_27_42
43690007_43690306_3_13
Title: why isn't my GUI working? 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.newL = tk.Label(self.master, text = "username", height = 1, width = 25)
    self.newL.pack()
    self.newT = tk.Text(self.master, height = 1, width = 25)
    self.newT.pack()
    self.secL = tk.Label(self.master, text = "Password", height = 1, width = 25)
    self.secL.pack()
    self.secT = tk.Text(self.master, height = 1, width = 25)
    self.secT.pack()
    self.quitButton = tk.Button(self.frame, text = 'Log in', width = 25, command = self.master.destroy)
    self.quitButton.pack()
    self.frame.pack()

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.button1 = tk.Button(self.frame, text = "Customer login", width = 25, command = self.new_window)
    self.button1.pack()
    self.button2 = tk.Button(self.frame, text = "Customer register", width = 25, command = self.new_window2)
    self.button2.pack()
    self.button3 = tk.Button(self.frame, text = "Driver login", width = 25, command = self.new_window3)
    self.button3.pack()
    self.frame.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43690007_43690306_27_42
43690007_43690306_44_66
Title: why isn't my GUI working? 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.newL = tk.Label(self.master, text = "username", height = 1, width = 25)
    self.newL.pack()
    self.newT = tk.Text(self.master, height = 1, width = 25)
    self.newT.pack()
    self.secL = tk.Label(self.master, text = "Password", height = 1, width = 25)
    self.secL.pack()
    self.secT = tk.Text(self.master, height = 1, width = 25)
    self.secT.pack()
    self.quitButton = tk.Button(self.frame, text = 'Log in', width = 25, command = self.master.destroy)
    self.quitButton.pack()
    self.frame.pack()

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.Label = tk.Label(self.master, text = "Enter your desired username", height = 1, width = 25)
    self.Label.pack()
    self.TextU = tk.Text(self.master, height = 1, width = 25)
    self.TextU.pack()
    self.Label2 = tk.Label(self.master, text = "Enter your desired password", height = 1, width = 25)
    self.Label2.pack()
    self.TextP = tk.Text(self.master, height = 1, width = 25)
    self.TextP.pack()
    self.Label3 = tk.Label(self.master, text = "Enter your email address", height = 1, width = 25)
    self.Label3.pack()
    self.TextE = tk.Text(self.master, height = 1, width = 25)
    self.TextE.pack()
    self.Label4 = tk.Label(self.master, text = "Enter your pick up address", height = 1, width = 25)
    self.Label4.pack()
    self.TextPick = tk.Text(self.master, height = 1, width = 25)
    self.TextPick.pack()
    self.frame.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43690007_43690306_3_13
43690007_43690306_44_66
Title: why isn't my GUI working? 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.button1 = tk.Button(self.frame, text = "Customer login", width = 25, command = self.new_window)
    self.button1.pack()
    self.button2 = tk.Button(self.frame, text = "Customer register", width = 25, command = self.new_window2)
    self.button2.pack()
    self.button3 = tk.Button(self.frame, text = "Driver login", width = 25, command = self.new_window3)
    self.button3.pack()
    self.frame.pack()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.Label = tk.Label(self.master, text = "Enter your desired username", height = 1, width = 25)
    self.Label.pack()
    self.TextU = tk.Text(self.master, height = 1, width = 25)
    self.TextU.pack()
    self.Label2 = tk.Label(self.master, text = "Enter your desired password", height = 1, width = 25)
    self.Label2.pack()
    self.TextP = tk.Text(self.master, height = 1, width = 25)
    self.TextP.pack()
    self.Label3 = tk.Label(self.master, text = "Enter your email address", height = 1, width = 25)
    self.Label3.pack()
    self.TextE = tk.Text(self.master, height = 1, width = 25)
    self.TextE.pack()
    self.Label4 = tk.Label(self.master, text = "Enter your pick up address", height = 1, width = 25)
    self.Label4.pack()
    self.TextPick = tk.Text(self.master, height = 1, width = 25)
    self.TextPick.pack()
    self.frame.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43694552_43695148_1_10
43694552_43826595_6_13
Title: Function that checks if a string occurs in another string 
----------------------------------------

def isIn(string_1, string_2) :
INDENT
    if (string_1 in string_2) or (string_2 in string_1) :
    INDENT
        is_in = True
    DEDENT
    else :
    INDENT
        is_in = False
    DEDENT
    return is_in

DEDENT
----------------------------------------

def isIn(x, y) :
INDENT
    if x in y :
    INDENT
        return True
    DEDENT
    elif y in x :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return 'False'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43705848_43705949_1_20
43705848_43706133_1_20
Title: What went wrong in my Python Code? 
----------------------------------------

def string_to_matrix(arg) :
INDENT
    result = []
    lines = arg.count("[") - 1
    for i in range(lines) :
    INDENT
        result.append([])
    DEDENT
    count = 0
    i = 2
    while i < len(arg) :
    INDENT
        if arg [i] == "[" :
        INDENT
            count += 1
            i = i + 1
        DEDENT
        elif arg [i].isdigit() :
        INDENT
            new_number = 0
            while arg [i].isdigit() :
            INDENT
                new_number = 10 * new_number + int(arg [i])
                i = i + 1
            DEDENT
            result [count].append(new_number)
        DEDENT
        else :
        INDENT
            i = i + 1
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def string_to_matrix(arg) :
INDENT
    result = []
    i = 1
    while i < len(arg) - 1 :
    INDENT
        if (arg [i] == '[') :
        INDENT
            i += 1
            temp = ""
            while (arg [i] ! = ']') :
            INDENT
                temp += arg [i]
                i += 1
            DEDENT
            temp = temp.split(',')
            temp2 = []
            for j in temp :
            INDENT
                temp2.append(int(j.strip(' ')))
            DEDENT
            result.append(temp2)
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43705848_43706087_1_22
43705848_43706133_1_20
Title: What went wrong in my Python Code? 
----------------------------------------

def string_to_matrix(arg) :
INDENT
    result = []
    lines = arg.count("[") - 1
    for i in range(lines) :
    INDENT
        result.append([])
    DEDENT
    count = 0
    i = 2
    while i < len(arg) :
    INDENT
        if arg [i] == "[" :
        INDENT
            count += 1
            i += 1
        DEDENT
        elif arg [i].isdigit() :
        INDENT
            new_number = 0
            while arg [i].isdigit() :
            INDENT
                new_number = 10 * new_number + int(arg [i])
                i += 1
            DEDENT
            result [count].append(new_number)
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
    return result

DEDENT
----------------------------------------

def string_to_matrix(arg) :
INDENT
    result = []
    i = 1
    while i < len(arg) - 1 :
    INDENT
        if (arg [i] == '[') :
        INDENT
            i += 1
            temp = ""
            while (arg [i] ! = ']') :
            INDENT
                temp += arg [i]
                i += 1
            DEDENT
            temp = temp.split(',')
            temp2 = []
            for j in temp :
            INDENT
                temp2.append(int(j.strip(' ')))
            DEDENT
            result.append(temp2)
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43712401_43712583_1_17
43712401_43712604_2_17
Title: How to refactor repeated code 
----------------------------------------

def top_similar_traces(self, stack_trace, t, top = 10) :
INDENT
    words_to_test = StackTraceProcessor.preprocess(stack_trace)
    words_to_test_clean = [w for w in np.unique(words_to_test).tolist() if w in model]

    all_distances = np.array(1.0 - np.dot(model.wv.syn0norm, model.wv.syn0norm [
                [model.wv.vocab [word].index for word in words_to_test_clean]].transpose()), dtype = np.double)
    for i, (doc_id, rwmd_distance) in enumerate(distances) :
    INDENT
        if t == "something" :
        INDENT
            doc_words_clean = [w for w in self.corpus [doc_id] if w in model]
        DEDENT
        else :
        INDENT
            doc_words_clean = [w for w in self.corpus [doc_id].words if w in model]
        DEDENT
        wmd = self.wmdistance(model, words_to_test_clean, doc_words_clean, all_distances)
    DEDENT
    return sorted(similarities, key = lambda v : v [1]) [: top]
DEDENT
----------------------------------------

def top_similar_traces(self, stack_trace, top = 10) :
INDENT
    words_to_test = StackTraceProcessor.preprocess(stack_trace)
    words_to_test_clean = [w for w in np.unique(words_to_test).tolist() if w in model]

    all_distances = np.array(1.0 - np.dot(model.wv.syn0norm, model.wv.syn0norm [
                [model.wv.vocab [word].index for word in words_to_test_clean]].transpose()), dtype = np.double)
    for i, (doc_id, rwmd_distance) in enumerate(distances) :
    INDENT

        doc_words_clean = self.top_similar_traces_filter_words(doc_id)
        wmd = self.wmdistance(model, words_to_test_clean, doc_words_clean, all_distances)
    DEDENT
    return sorted(similarities, key = lambda v : v [1]) [: top]

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43712401_43712583_1_17
43712401_43712616_1_15
Title: How to refactor repeated code 
----------------------------------------

def top_similar_traces(self, stack_trace, t, top = 10) :
INDENT
    words_to_test = StackTraceProcessor.preprocess(stack_trace)
    words_to_test_clean = [w for w in np.unique(words_to_test).tolist() if w in model]

    all_distances = np.array(1.0 - np.dot(model.wv.syn0norm, model.wv.syn0norm [
                [model.wv.vocab [word].index for word in words_to_test_clean]].transpose()), dtype = np.double)
    for i, (doc_id, rwmd_distance) in enumerate(distances) :
    INDENT
        if t == "something" :
        INDENT
            doc_words_clean = [w for w in self.corpus [doc_id] if w in model]
        DEDENT
        else :
        INDENT
            doc_words_clean = [w for w in self.corpus [doc_id].words if w in model]
        DEDENT
        wmd = self.wmdistance(model, words_to_test_clean, doc_words_clean, all_distances)
    DEDENT
    return sorted(similarities, key = lambda v : v [1]) [: top]
DEDENT
----------------------------------------

def top_similar_traces(self, stack_trace, top = 10, words = True) :
INDENT
    words_to_test = StackTraceProcessor.preprocess(stack_trace)
    words_to_test_clean = [w for w in np.unique(words_to_test).tolist() if w in model]

    all_distances = np.array(1.0 - np.dot(model.wv.syn0norm, model.wv.syn0norm [[model.wv.vocab [word].index for word in words_to_test_clean]].transpose()), dtype = np.double)
    for i, (doc_id, rwmd_distance) in enumerate(distances) :
    INDENT
        if words == True :
        INDENT
            doc_words_clean = [w for w in self.corpus [doc_id].words if w in model]
        DEDENT
        else :
        INDENT
            doc_words_clean = [w for w in self.corpus [doc_id] if w in model]
        DEDENT
        wmd = self.wmdistance(model, words_to_test_clean, doc_words_clean, all_distances)
        return sorted(similarities, key = lambda v : v [1]) [: top]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43712401_43712604_2_17
43712401_43712616_1_15
Title: How to refactor repeated code 
----------------------------------------

def top_similar_traces(self, stack_trace, top = 10) :
INDENT
    words_to_test = StackTraceProcessor.preprocess(stack_trace)
    words_to_test_clean = [w for w in np.unique(words_to_test).tolist() if w in model]

    all_distances = np.array(1.0 - np.dot(model.wv.syn0norm, model.wv.syn0norm [
                [model.wv.vocab [word].index for word in words_to_test_clean]].transpose()), dtype = np.double)
    for i, (doc_id, rwmd_distance) in enumerate(distances) :
    INDENT

        doc_words_clean = self.top_similar_traces_filter_words(doc_id)
        wmd = self.wmdistance(model, words_to_test_clean, doc_words_clean, all_distances)
    DEDENT
    return sorted(similarities, key = lambda v : v [1]) [: top]

DEDENT
----------------------------------------

def top_similar_traces(self, stack_trace, top = 10, words = True) :
INDENT
    words_to_test = StackTraceProcessor.preprocess(stack_trace)
    words_to_test_clean = [w for w in np.unique(words_to_test).tolist() if w in model]

    all_distances = np.array(1.0 - np.dot(model.wv.syn0norm, model.wv.syn0norm [[model.wv.vocab [word].index for word in words_to_test_clean]].transpose()), dtype = np.double)
    for i, (doc_id, rwmd_distance) in enumerate(distances) :
    INDENT
        if words == True :
        INDENT
            doc_words_clean = [w for w in self.corpus [doc_id].words if w in model]
        DEDENT
        else :
        INDENT
            doc_words_clean = [w for w in self.corpus [doc_id] if w in model]
        DEDENT
        wmd = self.wmdistance(model, words_to_test_clean, doc_words_clean, all_distances)
        return sorted(similarities, key = lambda v : v [1]) [: top]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43735131_43735814_27_43
43735131_43737302_19_37
Title: Initializing class attribute Python 
----------------------------------------

def main() :
INDENT
    pygame.init()
    white = (255, 255, 255)
    red = (255, 0, 0)
    gameDisplay = pygame.display.set_mode((600, 800))
    gameExit = False
    x = 0
    y = 0
    w = 25
    h = 25
    sobj = shape(white, 0, 0, 25, 25)
    sobj.draw_rect(gameDisplay)
DEDENT
----------------------------------------

def main() :
INDENT
    game_display = pygame.display.set_mode((600, 800))
    shape = Shape(WHITE, 0, 0, 25, 25)
    shape2 = Shape(pygame.Color('sienna1'), 100, 100, 25, 25)
    clock = pygame.time.Clock()
    game_exit = False
    while not game_exit :
    INDENT
        for event in pygame.event.get() :
        INDENT
            if event.type == pygame.QUIT :
            INDENT
                game_exit = True
            DEDENT
        DEDENT
        game_display.fill((40, 40, 40))
        shape.draw(game_display)
        shape2.draw(game_display)
        pygame.display.update()
        clock.tick(60)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43742738_43743805_1_36
43742738_43744442_1_18
Title: Gradient descent Matlab to Python 
----------------------------------------

def gradient_descent(obj_fun, w0, epochs, eta) :
INDENT
    w = w0
    func_values = []

    for i in range(epochs) :
    INDENT

        [val, grad] = obj_fun(w)

        w = w - (eta * grad)
        [val, grad] = obj_fun(w)

        val = func_values [i]

    DEDENT
    return (w, func_values)
DEDENT
----------------------------------------

def gradient_descent(obj_fun, w0, epochs, eta) :
INDENT
    w = w0
    func_values = np.zeros(epochs)

    for i in range(epochs) :
    INDENT
        val, grad = obj_fun(w)
        if i ! = 0 :
        INDENT
            func_values [i - 1] = val
        DEDENT
        w = w - (eta * grad)

    DEDENT
    val, grad = obj_fun(w)
    func_values [- 1] = val
    return w, func_values
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43757999_43932923_15_48
43757999_43932923_68_87
Title: "Modify server's variable from client's thread (threading python)" 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            data = self.connection.recv(1024)
            if data :
            INDENT
                print (data)
                try :
                INDENT
                    num = int(data)
                    if Server.guess(num) :
                    INDENT
                        msg = "You won! This is the right number!"
                        self.connection.send(msg.encode())
                        break
                    DEDENT
                    else :
                    INDENT
                        msg = "Try again!"
                        self.connection.send(msg.encode())

                    DEDENT
                DEDENT
                except ValueError as e :
                INDENT
                    msg = "%s" % e
                    self.connection.send(msg.encode())
                DEDENT
            DEDENT
            else :
            INDENT
                msg = "error"
                self.connection.send(msg.encode())
            DEDENT
        DEDENT
        except socket.error :
        INDENT
            self.connection.close()
            break
        DEDENT
    DEDENT
    self.connection.close()

DEDENT
----------------------------------------

def run(self) :
INDENT
    try :
    INDENT
        self.server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        self.server_socket.bind((self.ip, self.port))
        self.server_socket.listen(10)
        print ('Num is %s' % self.randnum)
        while True :
        INDENT
            connection, (ip, port) = self.server_socket.accept()
            c = Handler(connection, self.randnum)
            c.start()
        DEDENT
    DEDENT
    except socket.error as e :
    INDENT
        if self.server_socket :
        INDENT
            self.server_socket.close()
        DEDENT
        sys.exit(1)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43773461_43939680_34_45
43773461_43939680_50_58
Title: How to execute a while loop when wx.panel is shown? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(25, 12)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    self.count = 0
    self.lbl = wx.StaticText(self,
        label = 'Counter: {}'.format(self.count))
    self.thread = None

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43773461_43939680_34_45
43773461_43939680_75_101
Title: How to execute a while loop when wx.panel is shown? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(25, 12)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Panel Switcher Tutorial")
    self.panel_one = PanelOne(self)
    self.panel_two = PanelTwo(self)
    self.panel_two.Hide()
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.sizer.Add(self.panel_two, 1, wx.EXPAND)
    self.SetSizer(self.sizer)
    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    switch_panels_menu_item = fileMenu.Append(wx.ID_ANY,
        "Switch Panels",
        "Some text")
    self.Bind(wx.EVT_MENU, self.onSwitchPanels,
        switch_panels_menu_item)
    self.Bind(wx.EVT_CLOSE, self.on_close)
    menubar.Append(fileMenu, '&File')
    self.SetMenuBar(menubar)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43773461_43939680_50_58
43773461_43939680_75_101
Title: How to execute a while loop when wx.panel is shown? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    self.count = 0
    self.lbl = wx.StaticText(self,
        label = 'Counter: {}'.format(self.count))
    self.thread = None

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Panel Switcher Tutorial")
    self.panel_one = PanelOne(self)
    self.panel_two = PanelTwo(self)
    self.panel_two.Hide()
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.sizer.Add(self.panel_two, 1, wx.EXPAND)
    self.SetSizer(self.sizer)
    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    switch_panels_menu_item = fileMenu.Append(wx.ID_ANY,
        "Switch Panels",
        "Some text")
    self.Bind(wx.EVT_MENU, self.onSwitchPanels,
        switch_panels_menu_item)
    self.Bind(wx.EVT_CLOSE, self.on_close)
    menubar.Append(fileMenu, '&File')
    self.SetMenuBar(menubar)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43782307_43842252_32_39
43782307_43842252_4_22
Title: Tkinter - show dialog with options and change password buttons 
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Main application")
    master.geometry("600x400")
    self.c = tk.Button(self, text = "Options", command = self.options_button)
    self.c.pack()
    self.e = tk.Entry(self.master, show = "*")
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    tk.Frame.__init__(self, master, ** kwargs)
    self.pack()
    master.title("Enter password")
    master.geometry("300x200")
    self.status = tk.Label(self, fg = 'red')
    self.status.pack()
    self.lbl = tk.Label(self, text = 'Enter password')
    self.lbl.pack()
    self.pwd = tk.Entry(self, show = "*")
    self.pwd.pack()
    self.pwd.focus()
    self.pwd.bind('<Return>', self.check)
    self.btn = tk.Button(self, text = "Done", command = self.check)
    self.btn.pack()
    self.btn = tk.Button(self, text = "Cancel", command = self.quit)
    self.btn.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4378384_4378734_1_11
4378384_4379188_1_13
Title: Finding smallest contiguous integers in a Python set 
----------------------------------------

def smallest_contiguous(myset, length) :
INDENT
    if len(myset) < length :
    INDENT
        return []
    DEDENT
    s = sorted(myset)
    for idx in range(0, len(myset) - length + 1) :
    INDENT
        if s [idx + length - 1] - s [idx] == length - 1 :
        INDENT
            return s [idx : idx + length]
        DEDENT
    DEDENT
    return []
DEDENT
----------------------------------------

def smallest_contiguous(s, N) :
INDENT
    try :
    INDENT
        result = []
        while len(result) < N :
        INDENT
            min_value = min(s)
            s.remove(min_value)
            if result == [] or min_value == result [- 1] + 1 :
            INDENT
                result.append(min_value)
            DEDENT
            else :
            INDENT
                result = [min_value]
            DEDENT
        DEDENT
        return result
    DEDENT
    except ValueError :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43796423_43796597_12_23
43796423_43796849_12_21
Title: Python converting mysql query result to json 
----------------------------------------

def index() :
INDENT
    cur = mysql.connection.cursor()
    cur.execute('''SELECT * FROM Users WHERE id=1''')
    rv = cur.fetchall()
    payload = []
    content = {}
    for result in rv :
    INDENT
        content = {'id' : result [0], 'username' : result [1], 'password' : result [2]}
        payload.append(content)
        content = {}
    DEDENT
    return jsonify(payload)
DEDENT
----------------------------------------

def index() :
INDENT
    cur = mysql.connection.cursor()
    cur.execute('''SELECT * FROM Users WHERE id=1''')
    row_headers = [x [0] for x in cur.description]
    rv = cur.fetchall()
    json_data = []
    for result in rv :
    INDENT
        json_data.append(dict(zip(row_headers, result)))
    DEDENT
    return json.dumps(json_data)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43833981_43835929_27_57
43833981_43927974_7_52
Title: How to comment out a YAML section using ruamel.yaml? 
----------------------------------------

def comment_block(d, key_index_list, ind, bsi) :
INDENT
    parent = d
    for ki in key_index_list [: - 1] :
    INDENT
        parent = parent [ki]

    DEDENT
    data = deepcopy(parent)
    keys = list(data.keys())
    found = False
    previous_key = None
    for key in keys :
    INDENT
        if key ! = key_index_list [- 1] :
        INDENT
            if not found :
            INDENT
                previous_key = key
            DEDENT
            del data [key]
        DEDENT
        else :
        INDENT
            found = True
        DEDENT
    DEDENT
    del parent [key_index_list [- 1]]
    if previous_key is None :
    INDENT
        if parent.ca.comment is None :
        INDENT
            parent.ca.comment = [None, []]
        DEDENT
        comment_list = parent.ca.comment [1]
    DEDENT
    else :
    INDENT
        comment_list = parent [previous_key].ca.end = []
        parent [previous_key].ca.comment = [None, None]
    DEDENT
    start_mark = StreamMark(None, None, None, ind * (len(key_index_list) - 1))
    for line in round_trip_dump(data, indent = ind, block_seq_indent = bsi).splitlines(True) :
    INDENT
        comment_list.append(CommentToken('#' + line, start_mark, None))
    DEDENT
DEDENT
----------------------------------------

def comment_block(root, key_hierarchy_list, indent, seq_indent) :
INDENT
    found = False
    comment_key = key_hierarchy_list [- 1]
    parent = root
    for ki in key_hierarchy_list [: - 1] :
    INDENT
        parent = parent [ki]

    DEDENT
    block_2b_commented = deepcopy(parent)
    previous_key = None
    for key in parent.keys() :
    INDENT
        if key == comment_key :
        INDENT
            found = True
        DEDENT
        else :
        INDENT
            if not found :
            INDENT
                previous_key = key
            DEDENT
            del block_2b_commented [key]

        DEDENT
    DEDENT
    preceding_comments = parent.ca.items.get(comment_key, [None, None, None, None]) [1]
    del parent [comment_key]

    if previous_key is None :
    INDENT
        if parent.ca.comment is None :
        INDENT
            parent.ca.comment = [None, []]
        DEDENT
        comment_list = parent.ca.comment [1]
    DEDENT
    else :
    INDENT
        comment_list = parent [previous_key].ca.end = []
        parent [previous_key].ca.comment = [None, None]
    DEDENT
    if preceding_comments is not None :
    INDENT
        comment_list.extend(preceding_comments)

    DEDENT
    start_mark = StreamMark(None, None, None, indent * (len(key_hierarchy_list) - 1))
    skip = True
    for line in round_trip_dump(block_2b_commented, indent = indent, block_seq_indent = seq_indent).splitlines(True) :
    INDENT
        if skip :
        INDENT
            if not line.startswith(comment_key + ':') :
            INDENT
                continue
            DEDENT
            skip = False
        DEDENT
        comment_list.append(CommentToken('#' + line, start_mark, None))
    DEDENT
    return False

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43873361_43873837_1_11
43873361_43875009_4_12
Title: Recursion function - Python 
----------------------------------------

def f(n, _sequence = None) :
INDENT
    if _sequence is None :
    INDENT
        _sequence = [0] * (n + 1)
    DEDENT
    if n == 0 or n == 1 :
    INDENT
        val = n
    DEDENT
    else :
    INDENT
        f(n - 1, _sequence)
        f(n - 2, _sequence)
        val = 0.5 * (_sequence [n - 1] + _sequence [n - 2])
    DEDENT
    _sequence [n] = val
    return _sequence
DEDENT
----------------------------------------

def f(newavg, second, count) :
INDENT
    avg = (second + newavg) / 2
    print avg
    count = count + 1
    if count < 8 :
    INDENT
        newavg = avg
        f(second, avg, count)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43873361_43873837_1_11
43873361_43881292_1_8
Title: Recursion function - Python 
----------------------------------------

def f(n, _sequence = None) :
INDENT
    if _sequence is None :
    INDENT
        _sequence = [0] * (n + 1)
    DEDENT
    if n == 0 or n == 1 :
    INDENT
        val = n
    DEDENT
    else :
    INDENT
        f(n - 1, _sequence)
        f(n - 2, _sequence)
        val = 0.5 * (_sequence [n - 1] + _sequence [n - 2])
    DEDENT
    _sequence [n] = val
    return _sequence
DEDENT
----------------------------------------

def f(n) :
INDENT
    def aux(n, acc, a, b) :
    INDENT
        if n == 0 :
        INDENT
            return acc + [a]
        DEDENT
        else :
        INDENT
            return aux(n - 1, acc + [a], b, 0.5 * (a + b))
        DEDENT
    DEDENT
    return aux(n, [], 0, 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43873361_43875009_4_12
43873361_43881292_1_8
Title: Recursion function - Python 
----------------------------------------

def f(newavg, second, count) :
INDENT
    avg = (second + newavg) / 2
    print avg
    count = count + 1
    if count < 8 :
    INDENT
        newavg = avg
        f(second, avg, count)
    DEDENT
DEDENT
----------------------------------------

def f(n) :
INDENT
    def aux(n, acc, a, b) :
    INDENT
        if n == 0 :
        INDENT
            return acc + [a]
        DEDENT
        else :
        INDENT
            return aux(n - 1, acc + [a], b, 0.5 * (a + b))
        DEDENT
    DEDENT
    return aux(n, [], 0, 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43890097_43897129_40_53
43890097_43897129_6_21
Title: context menu in QFileDialog 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWidget, self).__init__(parent)

    mainLayout = QVBoxLayout()

    self.monWidget = CustomWidget()
    mainLayout.addWidget(self.monWidget)
    self.setLayout(mainLayout)
    self.show()

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(CustomWidget, self).__init__(parent)

    self.myTree = self.findChild(QTreeView, "treeView")

    self.myTree.setContextMenuPolicy(Qt.ActionsContextMenu)

    self.action_perso = QAction("MyOwnMenu", self.myTree)
    self.myTree.addAction(self.action_perso)

    self.connect(self.action_perso, SIGNAL("triggered()"), self.myFunction)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43900219_43902338_29_51
43900219_43933241_15_25
Title: Deadlock in Python's multiprocessing upon early termination 
----------------------------------------

def sub(command, check_success = None, directory = None, nproc = 1, permit_nonzero = False, time = None, * args, ** kwargs) :
INDENT
    if check_success and not callable(check_success) :
    INDENT
        msg = "check_success option requires a callable function/object: {0}".format(check_success)
        raise ValueError(msg)
    DEDENT
    queue = multiprocessing.Queue()
    success = multiprocessing.Value('i', int(False))
    workers = []
    for _ in range(nproc) :
    INDENT
        wp = Worker(queue, success, check_success = check_success, directory = directory, permit_nonzero = permit_nonzero)
        wp.start()
        workers.append(wp)
    DEDENT
    for cmd in command :
    INDENT
        queue.put(cmd)
    DEDENT
    for _ in range(nproc) :
    INDENT
        queue.put(None)
    DEDENT
    for wp in workers :
    INDENT
        wp.join(time)
    DEDENT
DEDENT
----------------------------------------

def sub(command, check_success = None, directory = None, nproc = 1, permit_nonzero = False) :
INDENT
    mgr = multiprocessing.Manager()
    success = mgr.Event()
    pool = multiprocessing.Pool(nproc)
    run_args = [(cmd, success, check_success, directory, permit_nonzero)]
    result = pool.starmap(worker, run_args)
    pool.close()
    pool.join()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43902122_43902240_1_11
43902122_43902257_1_11
Title: Passing variable by reference in python 
----------------------------------------

def longestConsecutive(self, root, count = 0) :
INDENT
    self.c = count
    if root :
    INDENT
        self.c = max(self.c, self.DFS(root))
        self.longestConsecutive(root.left, self.c)
        self.longestConsecutive(root.right, self.c)
    DEDENT
    return self.c
DEDENT
----------------------------------------

def longestConsecutive(self, root, count = 0) :
INDENT
    c = count
    if root :
    INDENT
        c = max(c, self.DFS(root))
        c = self.longestConsecutive(root.left, c)
        c = self.longestConsecutive(root.right, c)
    DEDENT
    return c
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43905360_43905413_5_14
43905360_43905590_6_23
Title: Python Rock Paper Scissors error 
----------------------------------------

def playainput() :
INDENT
    while True :
    INDENT
        playerinput = input("Input rock, paper, or scissors:  ")
        if playerinput in choices :
        INDENT
            print ("You chose", playerinput)
            break
        DEDENT
        print ("oops type again")
    DEDENT
    return playerinput
DEDENT
----------------------------------------

def playainput() :
INDENT
    playerinput = raw_input("Input rock, paper, or scissors:  ")
    if playerinput == ("rock") :
    INDENT
        playachoice = ("you chose rock")
    DEDENT
    elif playerinput == ("paper") :
    INDENT
        playachoice = ("you chose paper")
    DEDENT
    elif playerinput == ("scissors") :
    INDENT
        playachoice = ("You chose scissors")
    DEDENT
    else :
    INDENT
        print ("oops type again")
        playainput()
    DEDENT
    return playerinput

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43912516_43912965_12_39
43912516_43912965_54_63
Title: Python and logging: best practice with .exe 
----------------------------------------

def __init__(self, logger, log_level = logging.INFO) :
INDENT
    self.logger = logger
    self.log_level = log_level
    self.error_types = ["AssertionError", "AttributeError",
        "EOFError", "FloatingPointError",
        "GeneratorExit", "ImportError",
        "IndexError", "KeyError",
        "KeyboardInterrupt", "MemoryError",
        "NameError", "NotImplementedError",
        "OSError", "OverflowError",
        "ReferenceError", "RuntimeError",
        "StopIteration", "SyntaxError",
        "IndentationError", "TabError",
        "SystemError",
        "TypeError", "UnboundLocalError",
        "UnicodeError", "UnicodeEncodeError",
        "UnicodeDecodeError", "UnicodeTranslateError",
        "ValueError", "ZeroDivisionError",
        "EnvironmentError", "IOError",
        "WindowsError", "BlockingIOError",
        "ChildProcessError", "ConnectionError",
        "BrokenPipeError", "ConnectionAbortedError",
        "ConnectionRefusedError", "ConnectionResetError",
        "FileExistsError", "FileNotFoundError",
        "InterruptedError", "IsADirectoryError",
        "NotADirectoryError", "PermissionError",
        "ProcessLookupError", "TimeoutError",]
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.GUI = tk.Toplevel()
    self.GUI.protocol('WM_DELETE_WINDOW', self.GUI.withdraw)
    self.GUI.title("Debug Console")
    self.textbox = ScrolledText(self.GUI)
    self.textbox.configure(state = "disabled")
    self.textbox.pack(fill = "both", expand = True)
    self.GUI.focus()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43959344_43959438_2_19
43959344_51348253_1_12
Title: 7. Reverse Integer cannot get it to work using Python. exceeds time integer bound? 
----------------------------------------

def reverse(self, x) :
INDENT
    ret = 0
    neg_flag = False
    if x < 0 :
    INDENT
        neg_flag = True
        x = x * (- 1)
    DEDENT
    while x ! = 0 :
    INDENT
        ret = ret * 10 + x % 10
        x = x / 10
        if ret < = - 2147483648 or ret > = 2147483647 :
        INDENT
            return 0
        DEDENT
    DEDENT
    if neg_flag :
    INDENT
        ret = ret * - 1
    DEDENT
    return ret
DEDENT
----------------------------------------

def reverse(self, x) :
INDENT
    temp = int(str(abs(x)) [: : - 1])
    if temp > 2147483647 or temp < - 2147483648 :
    INDENT
        return 0
    DEDENT
    if (x > 0) :
    INDENT
        return temp
    DEDENT
    else :
    INDENT
        return - temp
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43966933_43967223_1_15
43966933_43977544_26_36
Title: Kivy Layout Background Not Painted on ScrollView 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(TestScreen, self).__init__(** kwargs)
    self.content_grid_layout = GridLayout(cols = 1, spacing = 20, size_hint_y = None)

    self.content_grid_layout.add_widget(Label(text = "A"))
    self.content_grid_layout.add_widget(Label(text = "B"))
    self.content_grid_layout.add_widget(TestView())
    self.scroll_view = ScrollView(size_hint = (1, 1), size = (self.width, self.height))
    self.scroll_view.add_widget(self.content_grid_layout)
    self.add_widget(self.scroll_view)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(TestView, self).__init__(** kwargs)
    self.orientation = 'vertical'
    self.padding = [20, 20, 20, 20]
    self.spacing = 20
    self.add_widget(Label(text = "I'm on the TestView 1"))
    self.add_widget(Label(text = "I'm on the TestView 2"))
    self.add_widget(Label(text = "I'm on the TestView 3"))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43966933_43967223_1_15
43966933_43977544_39_56
Title: Kivy Layout Background Not Painted on ScrollView 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(TestScreen, self).__init__(** kwargs)
    self.content_grid_layout = GridLayout(cols = 1, spacing = 20, size_hint_y = None)

    self.content_grid_layout.add_widget(Label(text = "A"))
    self.content_grid_layout.add_widget(Label(text = "B"))
    self.content_grid_layout.add_widget(TestView())
    self.scroll_view = ScrollView(size_hint = (1, 1), size = (self.width, self.height))
    self.scroll_view.add_widget(self.content_grid_layout)
    self.add_widget(self.scroll_view)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(TestScreen, self).__init__(** kwargs)
    self.content_grid_layout = GridLayout(cols = 1, spacing = 20, size_hint_y = None)
    self.content_grid_layout.bind(minimum_height = self.content_grid_layout.setter('height'))

    for i in range(20) :
    INDENT
        btn = Button(text = str(i), size_hint_y = None, height = 40)
        self.content_grid_layout.add_widget(btn)
        if i == 5 :
        INDENT
            self.content_grid_layout.add_widget(TestView())
        DEDENT
    DEDENT
    self.scroll_view = ScrollView(size_hint = (1, 1), size = (self.width, self.height))
    self.scroll_view.add_widget(self.content_grid_layout)
    self.add_widget(self.scroll_view)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43966933_43977544_26_36
43966933_43977544_39_56
Title: Kivy Layout Background Not Painted on ScrollView 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(TestView, self).__init__(** kwargs)
    self.orientation = 'vertical'
    self.padding = [20, 20, 20, 20]
    self.spacing = 20
    self.add_widget(Label(text = "I'm on the TestView 1"))
    self.add_widget(Label(text = "I'm on the TestView 2"))
    self.add_widget(Label(text = "I'm on the TestView 3"))
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(TestScreen, self).__init__(** kwargs)
    self.content_grid_layout = GridLayout(cols = 1, spacing = 20, size_hint_y = None)
    self.content_grid_layout.bind(minimum_height = self.content_grid_layout.setter('height'))

    for i in range(20) :
    INDENT
        btn = Button(text = str(i), size_hint_y = None, height = 40)
        self.content_grid_layout.add_widget(btn)
        if i == 5 :
        INDENT
            self.content_grid_layout.add_widget(TestView())
        DEDENT
    DEDENT
    self.scroll_view = ScrollView(size_hint = (1, 1), size = (self.width, self.height))
    self.scroll_view.add_widget(self.content_grid_layout)
    self.add_widget(self.scroll_view)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43969228_43969938_7_23
43969228_43971498_11_24
Title: Get an index of a Matrix filled with entries 
----------------------------------------

def compute(master) :
INDENT
    suma = 0.0

    for x in range(0, 1) :
    INDENT
        suma += float(m [i] [x].get())

    DEDENT
    if not i == 0 :
    INDENT
        suma += float(m [i - 1] [2].get())
    DEDENT
    print suma
    m [i] [2].insert(str(suma))

DEDENT
----------------------------------------

def compute(event) :
INDENT
    i, j = indexes(event)
    suma = 0.0
    for x in range(0, 2) :
    INDENT
        suma += float(m [i] [x].get())
    DEDENT
    m [i] [2].config(state = 'normal')
    m [i] [2].delete(0, END)
    m [i] [2].insert(0, str(suma))
    m [i] [2].config(state = 'readonly')

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43970127_43970261_1_16
43970127_43970270_1_16
Title: Get position-X from distance traveled within boundaries 
----------------------------------------

def find_position(dir = 1, width = 10, traveled = 100) :
INDENT
    curr_X = 150
    if traveled > = width :
    INDENT

        dist = traveled % width * dir
    DEDENT
    else :
    INDENT
        dist = traveled * dir
    DEDENT
    new_X = (dist + curr_X) % width

    new_X = new_X - width * 0.5
    return new_X
DEDENT
----------------------------------------

def find_position(dir = 1, width = 10, traveled = 100) :
INDENT
    if traveled < (width / 2) :
    INDENT
        return traveled * dir
    DEDENT
    dist = traveled % width

    if dist < = (width / 2) :
    INDENT
        return dist * dir

    DEDENT
    return (width - dist) * dir * - 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43970327_43970470_9_16
43970327_43970607_9_17
Title: Looping over *args resets counter 
----------------------------------------

def recurse(l, counter) :
INDENT
    for i in l :
    INDENT
        counter += 1
        if isinstance(i, (list, tuple)) :
        INDENT
            counter = recurse(i, counter)
        DEDENT
        else :
        INDENT
            print ("{}. {}.".format(counter, i))
        DEDENT
    DEDENT
    return counter
DEDENT
----------------------------------------

def recurse(l, inner_counter) :
INDENT
    for i in l :
    INDENT
        if isinstance(i, (list, tuple)) :
        INDENT
            inner_counter = recurse(i, inner_counter)
        DEDENT
        else :
        INDENT
            print ("{}. {}.".format(inner_counter, i))
            inner_counter += 1
        DEDENT
    DEDENT
    return inner_counter
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43990332_43990407_1_29
43990332_43990548_1_22
Title: How to run my for loop with same i if i want? 
----------------------------------------

def MH(x, y, sigma = 0.1, iterasyon = 100) :
INDENT
    import random
    import numpy as np
    a = np.array([1])
    b = np.array([1])
    i, c = 0, 0
    while i < 5 :
    INDENT
        try :
        INDENT
            ayap = float(random.gauss(a [i], sigma))
            byap = float(random.gauss(b [i], sigma))
            rss0 = np.sum((a [i] + b [i] * x - y) ** 2)
            rss1 = np.sum((ayap + byap * x - y) ** 2)
            if random.random() < = min(1, rss1 / rss0) :
            INDENT

                a = np.append(a, ayap)
                b = np.append(b, byap)
            DEDENT
        DEDENT
        except :
        INDENT

            c = c + 1
            if c == 3 :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT

            i = i + 1
        DEDENT
    DEDENT
    return a
DEDENT
----------------------------------------

def MH(x, y, sigma = 0.1, iterasyon = 100) :
INDENT
    import random
    import numpy as np
    a = np.array([1])
    b = np.array([1])
    for i in range(5) :
    INDENT
        while True :
        INDENT
            ayap = float(random.gauss(a [i], sigma))
            byap = float(random.gauss(b [i], sigma))
            rss0 = np.sum((a [i] + b [i] * x - y) ** 2)
            rss1 = np.sum((ayap + byap * x - y) ** 2)
            if random.random() < = min(1, rss1 / rss0) :
            INDENT

                a = np.append(a, ayap)
                b = np.append(b, byap)
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
440063_441679_1_11
440063_562695_1_16
Title: make a parent function return - super return? 
----------------------------------------

def gs(a, b) :
INDENT
    def ry() :
    INDENT
        if a == b :
        INDENT
            yield a
        DEDENT
    DEDENT
    for i in ry() :
    INDENT
        yield i
    DEDENT
    yield 'some other value'
    yield 'yet another value'
DEDENT
----------------------------------------

def gs(a, b) :
INDENT
    class SameEvent(Exception) :
    INDENT
        pass
    DEDENT
    def ry() :
    INDENT
        if a == b :
        INDENT
            raise SameEvent(a)
        DEDENT
    DEDENT
    try :
    INDENT

        ry()

        a = b = 3
        ry()
    DEDENT
    except SameEvent as e :
    INDENT
        return e.args [0]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44008427_44010080_1_11
44008427_44036679_3_12
Title: How change the cycle for getting correct answers? 
----------------------------------------

def reverseParentheses(s) :
INDENT
    assert '(' in s and ')' in s
    while '(' in s :
    INDENT

        reverseParentheses(s)
    DEDENT
    return s
DEDENT
----------------------------------------

def reverseParentheses(s) :
INDENT
    def reverse_interior(m) :
    INDENT
        s = m.group()
        return s [- 2 : 0 : - 1]
    DEDENT
    old = ""
    while old ! = s :
    INDENT
        old = s
        s = re.sub(r'(\([^\(\)]*\))', reverse_interior, s)
    DEDENT
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44014005_44014084_3_13
44014005_44014120_1_12
Title: Remove a char in string and then use dictionary to do key match 
----------------------------------------

def str2float(s) :
INDENT
    pos_decimal_point = (len(s) - s.find('.') - 1) if '.' in s else 0
    s = s.replace('.', '')
    def char2number(s) :
    INDENT
        return {'0' : 0, '1' : 1, '2' : 2, '3' : 3, '4' : 4, '5' : 5, '6' : 6, '7' : 7, '8' : 8, '9' : 9} [s]
    DEDENT
    return reduce(lambda x, y : (10 * x + y),
        (map(char2number, s))) / pow(10, pos_decimal_point)

DEDENT
----------------------------------------

def str2float(s) :
INDENT
    def char2number(s) :
    INDENT
        return {'0' : 0, '1' : 1, '2' : 2, '3' : 3, '4' : 4, '5' : 5, '6' : 6, '7' : 7, '8' : 8, '9' : 9} [s]
    DEDENT
    def find_digt(s) :
    INDENT
        return (len(s) - s.find('.') - 1) if '.' in s else 0
    DEDENT
    stripped_s = s.replace('.', '').replace(',', '')
    return reduce(lambda x, y : (10 * x + y), (map(char2number, stripped_s))) / pow(10, find_digt(s))
    print (str2float('1,456.124'))
    1456.124
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44015424_44015532_1_10
44015424_44015614_4_14
Title: How to insert double letters 
----------------------------------------

def double(str) :
INDENT
    new_str = ""
    letters = ('l', 'm', 'n', 'q', 't')
    for c in str :
    INDENT
        if c.lower() in letters :
        INDENT
            new_str += c + c
        DEDENT
    DEDENT
    return new_str
DEDENT
----------------------------------------

def double(string) :
INDENT
    letters = ('l', 'm', 'n', 'q', 't')
    result = list()
    for s in string :
    INDENT
        if s in letters :
        INDENT
            result.append(s.lower() * 2)
        DEDENT
        else :
        INDENT
            result.append(s.lower())
        DEDENT
    DEDENT
    return "".join(result)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44022929_1_33
44022382_44023076_1_27
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    if len([x for x in lst if x ! = "a"]) < 2 :
    INDENT
        return False

    DEDENT
    first_number = next((e for e in lst if e ! = "a"), None)

    first_index = lst.index(first_number)

    diff = first_number - first_index

    if diff < 0 :
    INDENT
        return False

    DEDENT
    all_numbers = []
    for i, x in enumerate(lst) :
    INDENT
        if x == "a" :
        INDENT
            all_numbers.append(i + diff)
        DEDENT
        else :
        INDENT
            all_numbers.append(x)

        DEDENT
    DEDENT
    if all(all_numbers [i + 1] == all_numbers [i] + 1 for i in range(len(all_numbers) - 1)) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def check_consecutive(lst) :
INDENT
    last = 0
    number_count = len(lst) - lst.count('a')
    if number_count < 2 :
    INDENT
        return False
    DEDENT
    for i in reversed(range(len(lst))) :
    INDENT
        if not last :
        INDENT
            last = lst [i] if lst [i] ! = "a" else 0
            continue
        DEDENT
        else :
        INDENT
            if lst [i] ! = "a" and last - lst [i] ! = 1 :
            INDENT
                return False

            DEDENT
            last -= 1

            if last < 1 :
            INDENT
                return False

            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44022929_1_33
44022382_44023605_1_16
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    if len([x for x in lst if x ! = "a"]) < 2 :
    INDENT
        return False

    DEDENT
    first_number = next((e for e in lst if e ! = "a"), None)

    first_index = lst.index(first_number)

    diff = first_number - first_index

    if diff < 0 :
    INDENT
        return False

    DEDENT
    all_numbers = []
    for i, x in enumerate(lst) :
    INDENT
        if x == "a" :
        INDENT
            all_numbers.append(i + diff)
        DEDENT
        else :
        INDENT
            all_numbers.append(x)

        DEDENT
    DEDENT
    if all(all_numbers [i + 1] == all_numbers [i] + 1 for i in range(len(all_numbers) - 1)) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def check_consecutive(lst) :
INDENT
    cond = [0, 1]
    n_sum = False
    for x in lst :
    INDENT
        if not (cond [1]) and x ! = 'a' :
        INDENT
            n_sum = True;
            if (cond [0] - x) ! = (lst.index(cond [0]) - lst.index(x)) :
            INDENT
                return False
            DEDENT
            elif x < = lst.index(x) :
            INDENT
                return False
            DEDENT
        DEDENT
        if x ! = 'a' and cond [1] :
        INDENT
            cond [0] = x;
            cond [1] = 0;
        DEDENT
    DEDENT
    print cond
    return n_sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44022382_44022929_1_33
44022382_44023682_1_30
Title: Checking for consecutive numbers with a specific condition - Python 
----------------------------------------

def check_consecutive(lst) :
INDENT
    if len([x for x in lst if x ! = "a"]) < 2 :
    INDENT
        return False

    DEDENT
    first_number = next((e for e in lst if e ! = "a"), None)

    first_index = lst.index(first_number)

    diff = first_number - first_index

    if diff < 0 :
    INDENT
        return False

    DEDENT
    all_numbers = []
    for i, x in enumerate(lst) :
    INDENT
        if x == "a" :
        INDENT
            all_numbers.append(i + diff)
        DEDENT
        else :
        INDENT
            all_numbers.append(x)

        DEDENT
    DEDENT
    if all(all_numbers [i + 1] == all_numbers [i] + 1 for i in range(len(all_numbers) - 1)) :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def check_consecutive(seq) :
INDENT
    PLACEHOLDER = 'a'
    if sum(obj ! = PLACEHOLDER for obj in seq) < 2 :
    INDENT
        return False
    DEDENT
    if isinstance(seq [0], int) :
    INDENT

        incrementing = True
        delta = 1
    DEDENT
    else :
    INDENT

        incrementing = False
        delta = - 1
    DEDENT
    iterator = iter(seq) if incrementing else reversed(seq)
    previous_item = next(iterator)
    assert previous_item ! = PLACEHOLDER
    for item in iterator :
    INDENT
        if item == PLACEHOLDER :
        INDENT
            item = previous_item + delta
        DEDENT
        if item < = 0 or item ! = (previous_item + delta) :
        INDENT
            return False
        DEDENT
        previous_item = item
    DEDENT
    return True
DEDENT
----------------------------------------
