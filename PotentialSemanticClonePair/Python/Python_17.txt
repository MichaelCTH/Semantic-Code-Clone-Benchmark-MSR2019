$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24887486_24887564_188_200
24887486_24887564_20_44
Title: Nested Classes Python and Indentation errors 
----------------------------------------

def __init__(
self,
testID,
printBagLabel = None,
printDrugLabel = None) :
INDENT
    self.testID = testID
    if (printBagLabel is None) :
    INDENT
        printBagLabel = "false"
        self.drug = drug
    DEDENT
    if (printDrugLabel is None) :
    INDENT
        printDrugLabel = "false"
        self.printDrugLabel = printDrugLabel
    DEDENT
DEDENT
----------------------------------------

def __init__(
self,
testID,
firstname = None,
surname = None,
gender = None,
birthDate = None) :
INDENT
    self.testID = testID
    if (firstname is None) :
    INDENT
        firstname = "Test"
        self.firstname = firstname
    DEDENT
    if (surname is None) :
    INDENT
        surname = "Patient"
        self.surname = surname
    DEDENT
    if (gender is None) :
    INDENT
        gender = "Male"
        self.gender = gender
    DEDENT
    if (birthDate is None) :
    INDENT
        birthDate = "08081988"
        self.birthDate = birthDatename

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24887486_24887564_188_200
24887486_24887564_45_115
Title: Nested Classes Python and Indentation errors 
----------------------------------------

def __init__(
self,
testID,
printBagLabel = None,
printDrugLabel = None) :
INDENT
    self.testID = testID
    if (printBagLabel is None) :
    INDENT
        printBagLabel = "false"
        self.drug = drug
    DEDENT
    if (printDrugLabel is None) :
    INDENT
        printDrugLabel = "false"
        self.printDrugLabel = printDrugLabel
    DEDENT
DEDENT
----------------------------------------

def __init__(
self,
testID,
firstname = None,
middlename = None,
surname = None,
gender = None,
birthDate = None,
title = None,
ppsno = None,
address1 = None,
address2 = None,
address3 = None,
address4 = None,
town = None,
county = None,
country = None,
email = None,
mobile = None) :
INDENT
    self.testID = testID
    if (firstname is None) :
    INDENT
        firstname = "Sample"
        self.firstname = firstname
    DEDENT
    if (surname is None) :
    INDENT
        surname = "Patient"
        self.surname = surname
    DEDENT
    if (middlename is None) :
    INDENT
        middlename = "Mary"
        self.middlename = middlename
    DEDENT
    if (gender is None) :
    INDENT
        gender = "Female"
        self.gender = gender
    DEDENT
    if (birthDate is None) :
    INDENT
        birthDate = "03091959"
        self.birthDate = birthDatename
    DEDENT
    if (title is None) :
    INDENT
        title = "Mrs"
        self.title = title
    DEDENT
    if (ppsno is None) :
    INDENT
        ppsno = "7445213P"
        self.ppsno = ppsno
    DEDENT
    if (address1 is None) :
    INDENT
        address1 = "100"
        self.address1 = address1
    DEDENT
    if (address2 is None) :
    INDENT
        address2 = "Green Glade"
        self.address1 = address1
    DEDENT
    if (address3 is None) :
    INDENT
        address3 = "Pleasent Way"
        self.address3 = address3
    DEDENT
    if (address4 is None) :
    INDENT
        address4 = "Ballybehy"
        self.address4 = address4
    DEDENT
    if (town is None) :
    INDENT
        town = "Abbeyfeale"
        self.town = town
    DEDENT
    if (county is None) :
    INDENT
        county = "Limerick"
        self.county = county
    DEDENT
    if (country is None) :
    INDENT
        country = "Ireland"
        self.country = country
    DEDENT
    if (email is None) :
    INDENT
        email = "supertest69@freewebmail.ie"
        self.email = email
    DEDENT
    if (mobile is None) :
    INDENT
        mobile = "0870563229"
        self.mobile = mobile
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24887486_24887564_20_44
24887486_24887564_45_115
Title: Nested Classes Python and Indentation errors 
----------------------------------------

def __init__(
self,
testID,
firstname = None,
surname = None,
gender = None,
birthDate = None) :
INDENT
    self.testID = testID
    if (firstname is None) :
    INDENT
        firstname = "Test"
        self.firstname = firstname
    DEDENT
    if (surname is None) :
    INDENT
        surname = "Patient"
        self.surname = surname
    DEDENT
    if (gender is None) :
    INDENT
        gender = "Male"
        self.gender = gender
    DEDENT
    if (birthDate is None) :
    INDENT
        birthDate = "08081988"
        self.birthDate = birthDatename

    DEDENT
DEDENT
----------------------------------------

def __init__(
self,
testID,
firstname = None,
middlename = None,
surname = None,
gender = None,
birthDate = None,
title = None,
ppsno = None,
address1 = None,
address2 = None,
address3 = None,
address4 = None,
town = None,
county = None,
country = None,
email = None,
mobile = None) :
INDENT
    self.testID = testID
    if (firstname is None) :
    INDENT
        firstname = "Sample"
        self.firstname = firstname
    DEDENT
    if (surname is None) :
    INDENT
        surname = "Patient"
        self.surname = surname
    DEDENT
    if (middlename is None) :
    INDENT
        middlename = "Mary"
        self.middlename = middlename
    DEDENT
    if (gender is None) :
    INDENT
        gender = "Female"
        self.gender = gender
    DEDENT
    if (birthDate is None) :
    INDENT
        birthDate = "03091959"
        self.birthDate = birthDatename
    DEDENT
    if (title is None) :
    INDENT
        title = "Mrs"
        self.title = title
    DEDENT
    if (ppsno is None) :
    INDENT
        ppsno = "7445213P"
        self.ppsno = ppsno
    DEDENT
    if (address1 is None) :
    INDENT
        address1 = "100"
        self.address1 = address1
    DEDENT
    if (address2 is None) :
    INDENT
        address2 = "Green Glade"
        self.address1 = address1
    DEDENT
    if (address3 is None) :
    INDENT
        address3 = "Pleasent Way"
        self.address3 = address3
    DEDENT
    if (address4 is None) :
    INDENT
        address4 = "Ballybehy"
        self.address4 = address4
    DEDENT
    if (town is None) :
    INDENT
        town = "Abbeyfeale"
        self.town = town
    DEDENT
    if (county is None) :
    INDENT
        county = "Limerick"
        self.county = county
    DEDENT
    if (country is None) :
    INDENT
        country = "Ireland"
        self.country = country
    DEDENT
    if (email is None) :
    INDENT
        email = "supertest69@freewebmail.ie"
        self.email = email
    DEDENT
    if (mobile is None) :
    INDENT
        mobile = "0870563229"
        self.mobile = mobile
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24890811_24891458_5_42
24890811_24891541_2_11
Title: Python - Default values not working 
----------------------------------------

def __init__(
self,
testID,
firstname = 'Sample',
middlename = 'Mary',
surname = 'Patient',
gender = 'Female',
birthDate = '03091959',
title = 'Mrs',
ppsno = '7445213P',
address1 = '100',
address2 = 'Green Glade',
address3 = 'Pleasant Way',
address4 = 'Ballybehy',
town = 'Abbyfeale',
county = 'Limerick',
country = 'Ireland',
email = 'supertest69@freewebmail.ie',
mobile = '0870563229') :
INDENT
    self.testID = testID
    self.firstname = firstname
    self.middlename = middlename
    self.surname = surname
    self.gender = gender
    self.birthDate = birthDate
    self.title = title
    self.ppsno = ppsno
    self.address1 = address1
    self.address2 = address2
    self.address3 = address3
    self.address4 = address4
    self.town = town
    self.county = county
    self.country = country
    self.email = email
    self.mobile = mobile
DEDENT
----------------------------------------

def __init__(
self,
test_id,
firstname,
middlename) :
INDENT
    self.test_id = test_id
    self.firstname = firstname
    self.middlename = middlename
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24891936_25318387_16_25
24891936_25318387_27_35
Title: Elements between panels are not aligned within a sizer 
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MyPanel2, self).__init__(parent = parent)
    sizer = wx.BoxSizer(orient = wx.HORIZONTAL)
    t = wx.StaticText(self, label = "Hello world")
    t.Hide()
    t.GetSize()
    sizer.Add(t.GetSize())
    sizer.Add(wx.Button(self, label = "non-aligned button"))
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MainFrame, self).__init__(None)
    sizer = wx.GridSizer(3, 1)
    panel1 = MyPanel(parent = self)
    panel2 = MyPanel2(parent = self)
    sizer.Add(panel1)
    sizer.Add(panel2)
    self.SetSizer(sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24891936_25318387_16_25
24891936_25318387_4_14
Title: Elements between panels are not aligned within a sizer 
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MyPanel2, self).__init__(parent = parent)
    sizer = wx.BoxSizer(orient = wx.HORIZONTAL)
    t = wx.StaticText(self, label = "Hello world")
    t.Hide()
    t.GetSize()
    sizer.Add(t.GetSize())
    sizer.Add(wx.Button(self, label = "non-aligned button"))
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MyPanel, self).__init__(parent = parent)
    mygridsizer = wx.GridBagSizer()
    sizer = wx.BoxSizer(orient = wx.HORIZONTAL)
    sizer.Add(wx.StaticText(self, label = "Hello world"))
    sizer.Add(wx.Button(self, label = "hello"))
    mygridsizer.Add(sizer, pos = (0, 0))
    mygridsizer.Add(wx.ComboBox(self), pos = (0, 1))
    self.SetSizer(mygridsizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24891936_25318387_27_35
24891936_25318387_4_14
Title: Elements between panels are not aligned within a sizer 
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MainFrame, self).__init__(None)
    sizer = wx.GridSizer(3, 1)
    panel1 = MyPanel(parent = self)
    panel2 = MyPanel2(parent = self)
    sizer.Add(panel1)
    sizer.Add(panel2)
    self.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(MyPanel, self).__init__(parent = parent)
    mygridsizer = wx.GridBagSizer()
    sizer = wx.BoxSizer(orient = wx.HORIZONTAL)
    sizer.Add(wx.StaticText(self, label = "Hello world"))
    sizer.Add(wx.Button(self, label = "hello"))
    mygridsizer.Add(sizer, pos = (0, 0))
    mygridsizer.Add(wx.ComboBox(self), pos = (0, 1))
    self.SetSizer(mygridsizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24896178_24917063_32_37
24896178_24917063_39_45
Title: sklearn: Have an estimator that filters samples 
----------------------------------------

def fit_transform(self, X, y = None, ** fit_params) :
INDENT
    if y is None :
    INDENT
        return self.fit(X, ** fit_params).transform(X)
    DEDENT
    else :
    INDENT
        return self.fit(X, y, ** fit_params).transform(X, y)
    DEDENT
DEDENT
----------------------------------------

def fit_transform(self, X, y = None, ** fit_params) :
INDENT
    Xt, yt, fit_params = self._pre_transform(X, y, ** fit_params)
    if hasattr(self.steps [- 1] [- 1], 'fit_transform') :
    INDENT
        return self.steps [- 1] [- 1].fit_transform(Xt, yt, ** fit_params)
    DEDENT
    else :
    INDENT
        return self.steps [- 1] [- 1].fit(Xt, yt, ** fit_params).transform(Xt)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24923377_24923549_3_10
24923377_52451316_5_11
Title: What is the Python equivalent of Javascript's `Date.prototype.toISOString`? 
----------------------------------------

def iso_format(dt) :
INDENT
    try :
    INDENT
        utc = dt + dt.utcoffset()
    DEDENT
    except TypeError as e :
    INDENT
        utc = dt
    DEDENT
    isostring = datetime.strftime(utc, '%Y-%m-%dT%H:%M:%S.{0}Z')
    return isostring.format(int(round(utc.microsecond / 1000.0)))
DEDENT
----------------------------------------

def iso_format(dt) :
INDENT
    try :
    INDENT
        utc_dt = dt.astimezone(dateutil.tz.tzutc())
    DEDENT
    except ValueError :
    INDENT
        utc_dt = dt
    DEDENT
    ms = "{:.3f}".format(utc_dt.microsecond / 1000000.0) [2 : 5]
    return datetime.datetime.strftime(utc_dt, '%Y-%m-%dT%H:%M:%S.{0}Z'.format(ms))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24928908_43716769_140_148
24928908_43716769_176_185
Title: python3 Type str doesn't support the buffer API 
----------------------------------------

def __init__(self, server, sock) :
INDENT
    super().__init__(sock)
    self.server = server
    self.set_terminator(b"\r\n")
    self.data = []
    self.name = None
    self.enter(LoginRoom(server))
DEDENT
----------------------------------------

def __init__(self, port, name) :
INDENT
    super().__init__()
    self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
    self.set_reuse_addr()
    self.bind(('', port))
    self.listen(5)
    self.name = name
    self.users = {}
    self.main_room = ChatRoom(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24943077_24943387_4_30
24943077_24943481_7_32
Title: How to get currently selected item from QListWidget and not what it remembers 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.resize(720, 480)
    central_widget = QtGui.QWidget(self)
    self.setCentralWidget(central_widget)
    layout = QtGui.QHBoxLayout(central_widget)
    self.text_edit = QtGui.QTextEdit(central_widget)
    layout.addWidget(self.text_edit)
    self.drop_list = QtGui.QListWidget(central_widget)
    self.drop_list.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
    self.drop_list.addItems(['one', 'two', 'three', 'four'])
    layout.addWidget(self.drop_list)
    self.show()
    self.button1 = QtGui.QPushButton("Hide-Unhide Items")
    self.button1.clicked.connect(self.hideUnhideItems)
    layout.addWidget(self.button1)
    self.button2 = QtGui.QPushButton("Print Selected")
    self.button2.clicked.connect(self.getSelected)
    layout.addWidget(self.button2)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super().__init__()
    self.resize(720, 480)
    central_widget = QtGui.QWidget(self)
    self.setCentralWidget(central_widget)
    layout = QtGui.QHBoxLayout(central_widget)
    self.text_edit = QtGui.QTextEdit(central_widget)
    layout.addWidget(self.text_edit)
    self.drop_list = QtGui.QListWidget(central_widget)
    self.drop_list.setSelectionMode(QtGui.QAbstractItemView.MultiSelection)
    self.drop_list.addItems(['one', 'two', 'three', 'four'])
    self.drop_list.itemSelectionChanged.connect(self.show_List)
    layout.addWidget(self.drop_list)
    statusbar = QtGui.QStatusBar(self)
    self.setStatusBar(statusbar)
    action_ShowList = QtGui.QAction(self)
    action_ShowList.triggered.connect(self.show_List)
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
24945648_24945706_1_11
24945648_24945712_1_18
Title: python - issues converting string to number (float or integer) 
----------------------------------------

def num(s) :
INDENT
    if not s : return ""
    try :
    INDENT
        return int(s)
    DEDENT
    except ValueError :
    INDENT
        f = float(s)
        if f % 1.0 < 0.0005 :
        INDENT
            return int(f)
        DEDENT
        else :
        INDENT
            return f
        DEDENT
    DEDENT
    else : return 0
DEDENT
----------------------------------------

def num(s) :
INDENT
    if not s :
    INDENT
        return ""
    DEDENT
    try :
    INDENT

        list_s = s.split(".")

        if (len(list_s) == 1) or (int(list_s [1]) == 0) :
        INDENT
            return int(s)
        DEDENT
        else :
        INDENT
            return float(s)
        DEDENT
    DEDENT
    except :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25007996_25008025_1_8
25007996_25009008_1_9
Title: NameError when trying to pass variable across functions 
----------------------------------------

def void() :
INDENT
    print ("You find your self hanging in the void.")
    response = input("What do you want to do?")
    if response == "dance" :
    INDENT
        dance(response)
    DEDENT
    else :
    INDENT
        bug(response)
    DEDENT
DEDENT
----------------------------------------

def void() :
INDENT
    global response
    response = raw_input('What do u want:\n')
    if response == 'dance' :
    INDENT
        Dance()
    DEDENT
    else :
    INDENT
        Bug()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25058578_25061370_16_22
25058578_25061370_48_61
Title: How to create channel with socket in Python 
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        new_client = self.chan_sock.accept()
        if not new_client :
        INDENT
            break
        DEDENT
        self.clients.append(new_client)
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    data = ""
    while True :
    INDENT
        new_data = self.peer_chan_sock.recv(1024)
        if not new_data :
        INDENT
            break
        DEDENT
        data += new_data
        msgs = data.split("\n\n")
        if msgs [- 1] :
        INDENT
            data = msgs.pop()
        DEDENT
        for msg in msgs :
        INDENT
            self.deal_with_message(msg)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25080096_25080195_1_15
25080096_25089578_7_50
Title: Python OS.WALK Remove Directories 
----------------------------------------

def findit(root, exclude_files = [], exclude_dirs = []) :
INDENT
    exclude_files = (fnmatch.translate(i) for i in exclude_files)
    exclude_files = '(' + ')|('.join(exclude_files) + ')'
    exclude_files = re.compile(exclude_files)
    exclude_dirs = (os.path.normpath(i) for i in exclude_dirs)
    exclude_dirs = (os.path.normcase(i) for i in exclude_dirs)
    exclude_dirs = set(exclude_dirs)
    for current, dirs, files in os.walk(root) :
    INDENT
        if os.path.normpath(os.path.normcase(current)) in exclude_dirs :
        INDENT

            dirs [:] = []
            continue
        DEDENT
        for f in files :
        INDENT
            if not exclude_files.match(os.path.normcase(f)) :
            INDENT
                yield os.path.join(current, f)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def findit(root, exclude_files = [], exclude_dirs = [], exclude_dirs_wc = []) :
INDENT
    join = os.path.join
    normpath = os.path.normpath; normcase = os.path.normcase
    def make_exclude_regex_from(lst) :
    INDENT
        if len(lst) :
        INDENT
            lst = (fnmatch.translate(i) for i in lst)
            lst = "({})".format(")|(".join(lst))
            lst = re.compile(lst)
        DEDENT
        return lst
    DEDENT
    exclude_files = make_exclude_regex_from(exclude_files)
    exclude_dirs_wc = make_exclude_regex_from(exclude_dirs_wc)
    if len(exclude_dirs) :
    INDENT
        exclude_dirs = (normpath(i) for i in exclude_dirs)
        exclude_dirs = (normcase(i) for i in exclude_dirs)
        exclude_dirs = set(exclude_dirs)
    DEDENT
    for current, dirs, files in os.walk(root) :
    INDENT
        current_dir = normpath(normcase(current))
        if exclude_dirs and current_dir in exclude_dirs :
        INDENT

            exclude_dirs.discard(current_dir)
            dirs [:] = []
            continue
        DEDENT
        if exclude_dirs_wc :
        INDENT
            for dd in dirs [:] :
            INDENT
                if exclude_dirs_wc.match(normcase(dd)) :
                INDENT
                    dirs.remove(dd)
                DEDENT
            DEDENT
        DEDENT
        if exclude_files :
        INDENT
            for ff in files [:] :
            INDENT
                if exclude_files.match(normcase(ff)) :
                INDENT
                    files.remove(ff)
                DEDENT
            DEDENT
        DEDENT
        for f in files :
        INDENT
            yield join(current, f)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25105578_25267125_28_40
25105578_25267125_77_86
Title: python help - conditional math operation on arrays 
----------------------------------------

def fA(rr, th, a, b, c) :
INDENT
    arrx = a * np.sin(th)
    arry = b * rr * np.cos(th)
    arrz = c * rr
    slct = rr > 1
    rr = rr [slct]
    th = th [slct]
    arrx [slct] = a / rr * np.sin(th)
    arry [slct] = b / rr * np.cos(th)
    arrz [slct] = c / rr
    return arrx, arry, arrz
DEDENT
----------------------------------------

def fA(rr, th, a, b, c) :
INDENT
    if (rr < = 1) :
    INDENT
        fx = a * sin(th)
        fy = b * rr * cos(th)
        fz = c * rr
    DEDENT
    else :
    INDENT
        fx = (a / rr) * sin(th)
        fy = (b / rr) * cos(th)
        fz = (c / rr)
    DEDENT
    return (fx, fy, fz)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25105578_25267125_41_53
25105578_25267125_87_96
Title: python help - conditional math operation on arrays 
----------------------------------------

def fB(rr, th, a, b, c) :
INDENT
    arrx = b * np.sin(2.* th)
    arry = a * rr * np.cos(2.* th)
    arrz = c * rr
    slct = rr > 1
    rr = rr [slct]
    th = th [slct]
    arrx [slct] = b / rr * np.sin(2.* th)
    arry [slct] = a / rr * np.cos(2.* th)
    arrz [slct] = c
    return arrx, arry, arrz
DEDENT
----------------------------------------

def fB(rr, th, a, b, c) :
INDENT
    if (rr < = 1) :
    INDENT
        fx = b * sin(2.* th)
        fy = a * rr * cos(2.* th)
        fz = c * rr
    DEDENT
    else :
    INDENT
        fx = (b / rr) * sin(2.* th)
        fy = (a / rr) * cos(2.* th)
        fz = c
    DEDENT
    return (fx, fy, fz)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25105578_25267125_54_68
25105578_25267125_97_107
Title: python help - conditional math operation on arrays 
----------------------------------------

def fC(rr, th, a, b, c) :
INDENT
    arrx = np.exp(rr - 1) * np.cos(th)
    arry = np.exp(rr - 1) * np.sin(th)
    arrz = np.empty_like(rr)
    arrz.fill(c)
    slct = rr > 1
    rr = rr [slct]
    th = th [slct]
    arrx [slct] = np.exp(1.- rr) * np.cos(th)
    arry [slct] = np.exp(1.- rr) * np.sin(th)
    arrz [slct] = c / rr
    return arrx, arry, arrz
DEDENT
----------------------------------------

def fC(rr, th, a, b, c) :
INDENT
    if (rr < = 1) :
    INDENT
        fx = exp(rr - 1.) * cos(th)
        fy = exp(rr - 1.) * sin(th)
        fz = c
    DEDENT
    else :
    INDENT
        fx = exp(1.- rr) * cos(th)
        fy = exp(1.- rr) * sin(th)
        fz = c / rr
    DEDENT
    return (fx, fy, fz)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25110373_25110414_6_10
25110373_25110920_11_21
Title: How to get the name of a variable 
----------------------------------------

def hits_further(self, other) :
INDENT
    if self.distance > other.distance :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def hits_further(self, other) :
INDENT
    call_str = traceback.extract_stack() [0] [3]
    m = re.search('([\w]+)\.hits_further\((.*)\)', call_str)
    self_name = m.group(1)
    other_name = m.group(2)
    if self.distance > other.distance :
    INDENT
        return self_name + " hits further"
    DEDENT
    else :
    INDENT
        return other_name + " hits further"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25110373_25110430_7_12
25110373_25110920_11_21
Title: How to get the name of a variable 
----------------------------------------

def hits_further(self, other) :
INDENT
    if self.distance > other.distance :
    INDENT
        print self.name, "club hits further"
    DEDENT
    else :
    INDENT
        print other.name, "That club hits further"
    DEDENT
DEDENT
----------------------------------------

def hits_further(self, other) :
INDENT
    call_str = traceback.extract_stack() [0] [3]
    m = re.search('([\w]+)\.hits_further\((.*)\)', call_str)
    self_name = m.group(1)
    other_name = m.group(2)
    if self.distance > other.distance :
    INDENT
        return self_name + " hits further"
    DEDENT
    else :
    INDENT
        return other_name + " hits further"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25110373_25110433_7_12
25110373_25110920_11_21
Title: How to get the name of a variable 
----------------------------------------

def hits_further(self, other) :
INDENT
    if self.distance > other.distance :
    INDENT
        return "%s hits further" % self.name
    DEDENT
    else :
    INDENT
        return "%s hits further" % other.name
    DEDENT
DEDENT
----------------------------------------

def hits_further(self, other) :
INDENT
    call_str = traceback.extract_stack() [0] [3]
    m = re.search('([\w]+)\.hits_further\((.*)\)', call_str)
    self_name = m.group(1)
    other_name = m.group(2)
    if self.distance > other.distance :
    INDENT
        return self_name + " hits further"
    DEDENT
    else :
    INDENT
        return other_name + " hits further"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25178606_25178663_1_27
25178606_25179040_1_20
Title: Merge sorted arrays into single sorted array: Python 
----------------------------------------

def merging(list1, list2) :
INDENT
    m = len(list1)
    n = len(list2)
    val = m + n
    j, k = 0, 0
    new = []
    for i in range(val) :
    INDENT
        if j < m and k < n :
        INDENT
            if list1 [j] < list2 [k] :
            INDENT
                new.append(list1 [j])
                j += 1
            DEDENT
            else :
            INDENT
                new.append(list2 [k])
                k += 1
            DEDENT
        DEDENT
        elif j == m :
        INDENT
            if k < n :
            INDENT
                new.append(list2 [k])
                k += 1
            DEDENT
        DEDENT
        else :
        INDENT
            if j < m :
            INDENT
                new.append(list1 [j])
                j += 1
            DEDENT
        DEDENT
    DEDENT
    print "sorted array is:"
    print new
DEDENT
----------------------------------------

def merging(list1, list2) :
INDENT
    m = len(list1)
    n = len(list2)
    res = []
    a, b = 0, 0
    while a < m and b < n :
    INDENT
        if list1 [a] < list2 [b] :
        INDENT
            res.append(list1 [a])
            a += 1
        DEDENT
        else :
        INDENT
            res.append(list2 [b])
            b += 1
        DEDENT
    DEDENT
    if a == m :
    INDENT
        for i in list2 [b :] :
        INDENT
            res.append(i)
        DEDENT
    DEDENT
    else :
    INDENT
        for i in list1 [a :] :
        INDENT
            res.append(i)
        DEDENT
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25178606_25179035_1_28
25178606_25179040_1_20
Title: Merge sorted arrays into single sorted array: Python 
----------------------------------------

def merging(list1, list2) :
INDENT
    m = len(list1)
    n = len(list2)
    val = m + n
    j, k = 0, 0
    new = []
    for i in range(val) :
    INDENT
        if j < m and k < n :
        INDENT
            if list1 [j] < list2 [k] :
            INDENT
                new.append(list1 [j])
                j += 1
            DEDENT
            else :
            INDENT
                new.append(list2 [k])
                k += 1
            DEDENT
        DEDENT
        elif j == m :
        INDENT
            while i < m + n :
            INDENT
                new.append(list2 [k])
                k += 1
                i += 1
            DEDENT
            break
        DEDENT
        else :
        INDENT
            while i < m + n :
            INDENT
                new.append(list1 [j])
                j += 1
                i += 1
            DEDENT
            break
        DEDENT
    DEDENT
    return new
DEDENT
----------------------------------------

def merging(list1, list2) :
INDENT
    m = len(list1)
    n = len(list2)
    res = []
    a, b = 0, 0
    while a < m and b < n :
    INDENT
        if list1 [a] < list2 [b] :
        INDENT
            res.append(list1 [a])
            a += 1
        DEDENT
        else :
        INDENT
            res.append(list2 [b])
            b += 1
        DEDENT
    DEDENT
    if a == m :
    INDENT
        for i in list2 [b :] :
        INDENT
            res.append(i)
        DEDENT
    DEDENT
    else :
    INDENT
        for i in list1 [a :] :
        INDENT
            res.append(i)
        DEDENT
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25187444_25188862_35_56
25187444_25188862_5_24
Title: PyQt QListWidget custom items 
----------------------------------------

def __init__(self) :
INDENT
    super(exampleQMainWindow, self).__init__()
    self.myQListWidget = QtGui.QListWidget(self)
    for index, name, icon in [
        ('No.1', 'Meyoko', 'icon.png'),
        ('No.2', 'Nyaruko', 'icon.png'),
        ('No.3', 'Louise', 'icon.png')] :
    INDENT

        myQCustomQWidget = QCustomQWidget()
        myQCustomQWidget.setTextUp(index)
        myQCustomQWidget.setTextDown(name)
        myQCustomQWidget.setIcon(icon)
        myQListWidgetItem = QtGui.QListWidgetItem(self.myQListWidget)
        myQListWidgetItem.setSizeHint(myQCustomQWidget.sizeHint())
        self.myQListWidget.addItem(myQListWidgetItem)
        self.myQListWidget.setItemWidget(myQListWidgetItem, myQCustomQWidget)
    DEDENT
    self.setCentralWidget(self.myQListWidget)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(QCustomQWidget, self).__init__(parent)
    self.textQVBoxLayout = QtGui.QVBoxLayout()
    self.textUpQLabel = QtGui.QLabel()
    self.textDownQLabel = QtGui.QLabel()
    self.textQVBoxLayout.addWidget(self.textUpQLabel)
    self.textQVBoxLayout.addWidget(self.textDownQLabel)
    self.allQHBoxLayout = QtGui.QHBoxLayout()
    self.iconQLabel = QtGui.QLabel()
    self.allQHBoxLayout.addWidget(self.iconQLabel, 0)
    self.allQHBoxLayout.addLayout(self.textQVBoxLayout, 1)
    self.setLayout(self.allQHBoxLayout)
    self.textUpQLabel.setStyleSheet('''
            color: rgb(0, 0, 255);
        ''')
    self.textDownQLabel.setStyleSheet('''
            color: rgb(255, 0, 0);
        ''')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25189554_25189629_3_10
25189554_31357170_2_20
Title: Countdown Clock: 01:05 
----------------------------------------

def countdown(t) :
INDENT
    while t :
    INDENT
        mins, secs = divmod(t, 60)
        timeformat = '{:02d}:{:02d}'.format(mins, secs)
        print(timeformat, end = '\r')
        time.sleep(1)
        t -= 1
    DEDENT
    print ('Goodbye!\n\n\n\n\n')
DEDENT
----------------------------------------

def countdown(p, q) :
INDENT
    i = p
    j = q
    k = 0
    while True :
    INDENT
        if (j == - 1) :
        INDENT
            j = 59
            i -= 1
        DEDENT
        if (j > 9) :
        INDENT
            print(str(k) + str(i) + ":" + str(j), end = "\r")
        DEDENT
        else :
        INDENT
            print(str(k) + str(i) + ":" + str(k) + str(j), end = "\r")
        DEDENT
        time.sleep(1)
        j -= 1
        if (i == 0 and j == - 1) :
        INDENT
            break
        DEDENT
    DEDENT
    if (i == 0 and j == - 1) :
    INDENT
        print("Goodbye!", end = "\r")
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25189660_25189951_11_16
25189660_25191586_5_10
Title: How to call a baseclass function whenever a certain method is called in derived class in python? 
----------------------------------------

def __new__(cls, clsname, bases, dct) :
INDENT
    for k, v in dct.items() :
    INDENT
        if isinstance(v, Field) :
        INDENT
            v.field_name = '_' + k
        DEDENT
    DEDENT
    return type.__new__(cls, clsname, bases, dct)
DEDENT
----------------------------------------

def __new__(cls, clsname, bases, dct) :
INDENT
    for item in dct :
    INDENT
        if item.startswith("set_") and isinstance(dct [item], FunctionType) :
        INDENT
            dct [item] = cls.changer(dct [item])
        DEDENT
    DEDENT
    return super(Setter, cls).__new__(cls, clsname, bases, dct)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25190239_25318318_30_42
25190239_25318318_60_70
Title: Problems sizing a ScrolledPanel when adding/removing child widgets 
----------------------------------------

def __init__(self, parent) :
INDENT
    ScrolledPanel.__init__(self, parent, - 1)
    self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
    self.choices = []
    c = Choice(self, False)
    self.panel_sizer.Add(c, 0, wx.EXPAND)
    self.choices.append(c)
    self.SetSizer(self.panel_sizer)
    self.SetAutoLayout(1)
    self.SetupScrolling(False, True)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1)
    self.sizer = wx.BoxSizer(wx.HORIZONTAL)
    panel = wx.Panel(self, - 1)
    self.test_panel = ChoicePanel(panel)
    self.sizer.Add(wx.StaticText(panel, - 1, "Some text here:"), 1, wx.EXPAND | wx.CENTER | wx.ALL, 4)
    self.sizer.AddSpacer((4, - 1))
    self.sizer.Add(self.test_panel, 1, wx.EXPAND | wx.CENTER | wx.ALL, 4)
    panel.SetSizer(self.sizer)
    panel.Layout()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25190239_25318318_30_42
25190239_25318318_6_28
Title: Problems sizing a ScrolledPanel when adding/removing child widgets 
----------------------------------------

def __init__(self, parent) :
INDENT
    ScrolledPanel.__init__(self, parent, - 1)
    self.panel_sizer = wx.BoxSizer(wx.VERTICAL)
    self.choices = []
    c = Choice(self, False)
    self.panel_sizer.Add(c, 0, wx.EXPAND)
    self.choices.append(c)
    self.SetSizer(self.panel_sizer)
    self.SetAutoLayout(1)
    self.SetupScrolling(False, True)
DEDENT
----------------------------------------

def __init__(self, parent, allow_delete = True) :
INDENT
    wx.Panel.__init__(self, parent)
    self.colChoice = ComboBox(self, choices = ['a', 'b', 'c'], style = wx.CB_READONLY)
    self.colChoice.Select(0)
    if allow_delete :
    INDENT
        self.minus_button = wx.Button(self, label = '-', size = (30, - 1))
        self.minus_button.Bind(wx.EVT_BUTTON, lambda event : self.Parent.on_remove_choice(event, self))
    DEDENT
    self.plus_button = wx.Button(self, label = '+', size = (30, - 1))
    self.plus_button.Bind(wx.EVT_BUTTON, lambda event : self.Parent.on_add_choice(event, self))
    colSizer = wx.BoxSizer(wx.HORIZONTAL)
    colSizer.Add(self.colChoice, 1, wx.EXPAND | wx.ALL, 1)
    colSizer.AddSpacer((5, - 1))
    colSizer.Add(self.plus_button, 0, wx.EXPAND | wx.ALL, 1)
    if allow_delete :
    INDENT
        colSizer.AddSpacer((5, - 1))
        colSizer.Add(self.minus_button, 0, wx.EXPAND)
    DEDENT
    else :
    INDENT
        colSizer.AddSpacer((5, - 1))
        colSizer.Add(wx.StaticText(self), 0, wx.EXPAND)
    DEDENT
    self.SetSizerAndFit(colSizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25190239_25318318_60_70
25190239_25318318_6_28
Title: Problems sizing a ScrolledPanel when adding/removing child widgets 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1)
    self.sizer = wx.BoxSizer(wx.HORIZONTAL)
    panel = wx.Panel(self, - 1)
    self.test_panel = ChoicePanel(panel)
    self.sizer.Add(wx.StaticText(panel, - 1, "Some text here:"), 1, wx.EXPAND | wx.CENTER | wx.ALL, 4)
    self.sizer.AddSpacer((4, - 1))
    self.sizer.Add(self.test_panel, 1, wx.EXPAND | wx.CENTER | wx.ALL, 4)
    panel.SetSizer(self.sizer)
    panel.Layout()
DEDENT
----------------------------------------

def __init__(self, parent, allow_delete = True) :
INDENT
    wx.Panel.__init__(self, parent)
    self.colChoice = ComboBox(self, choices = ['a', 'b', 'c'], style = wx.CB_READONLY)
    self.colChoice.Select(0)
    if allow_delete :
    INDENT
        self.minus_button = wx.Button(self, label = '-', size = (30, - 1))
        self.minus_button.Bind(wx.EVT_BUTTON, lambda event : self.Parent.on_remove_choice(event, self))
    DEDENT
    self.plus_button = wx.Button(self, label = '+', size = (30, - 1))
    self.plus_button.Bind(wx.EVT_BUTTON, lambda event : self.Parent.on_add_choice(event, self))
    colSizer = wx.BoxSizer(wx.HORIZONTAL)
    colSizer.Add(self.colChoice, 1, wx.EXPAND | wx.ALL, 1)
    colSizer.AddSpacer((5, - 1))
    colSizer.Add(self.plus_button, 0, wx.EXPAND | wx.ALL, 1)
    if allow_delete :
    INDENT
        colSizer.AddSpacer((5, - 1))
        colSizer.Add(self.minus_button, 0, wx.EXPAND)
    DEDENT
    else :
    INDENT
        colSizer.AddSpacer((5, - 1))
        colSizer.Add(wx.StaticText(self), 0, wx.EXPAND)
    DEDENT
    self.SetSizerAndFit(colSizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25209078_25209218_5_10
25209078_25209398_6_11
Title: How can I store user and pass in the same dict instead of a new empty dict? 
----------------------------------------

def create() :
INDENT
    myDict = {}
    for i in range(5) :
    INDENT
        user = raw_input("Username: ")
        pas = raw_input("Password: ")
        store(user, pas, myDict)
    DEDENT
DEDENT
----------------------------------------

def create() :
INDENT
    for i in range(5) :
    INDENT
        user = raw_input("Username: ")
        pas = raw_input("Password: ")
        store(passwords, user, pas)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25217426_25217661_10_31
25217426_25218414_8_37
Title: Can I expand Google Image seach screen by scrolling down programatically? 
----------------------------------------

def get_images(query, start) :
INDENT
    screen_width = 1920
    screen_height = 1080
    params = {
        "q" : query,
        "sa" : "X",
        "biw" : screen_width,
        "bih" : screen_height,
        "tbm" : "isch",
        "ijn" : start / 100,
        "start" : start,
        }
    request = s.get(URL, params = params)
    bs = BeautifulSoup(request.text)
    for img in bs.findAll("div", {"class" : "rg_di"}) :
    INDENT
        images.append(img.find("img").attrs ['data-src'])

    DEDENT
DEDENT
----------------------------------------

def get_images(query, num_turn) :
INDENT
    image_urls = []
    s = requests.session()
    s.headers.update({"User-Agent" : "Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/36.0.1985.125 Safari/537.36"})
    URL = "https://www.google.dk/search"
    for x in range(0, num_turn) :
    INDENT
        start = x * 100
        screen_width = 1920
        screen_height = 1080
        params = {
            "q" : query,
            "sa" : "X",
            "biw" : screen_width,
            "bih" : screen_height,
            "tbm" : "isch",
            "ijn" : start / 100,
            "start" : start,
            }
        request = s.get(URL, params = params)
        for img in re.findall(r'imgurl=(.*?(?:&|\.(?:jpg|gif|png|jpeg)))', request.text, re.I) :
        INDENT
            image_urls.append(img)
        DEDENT
    DEDENT
    return image_urls

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25223760_25224103_12_25
25223760_25224103_53_64
Title: Unable to fix broken ball movement in pygame pong 
----------------------------------------

def update(self) :
INDENT
    if self.right > games.screen.width :
    INDENT
        self.dx = - self.dx
    DEDENT
    if self.left < 0 :
    INDENT
        self.game_over()
    DEDENT
    if self.bottom > games.screen.height or self.top < 0 :
    INDENT
        self.dy = - self.dy

    DEDENT
    if games.keyboard.is_pressed(games.K_q) :
    INDENT
        self.game_over()
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    self.y = games.mouse.y
    if self.left > 0 :
    INDENT
        self.left = 10
    DEDENT
    if self.right > games.screen.height :
    INDENT
        self.right = games.screen.height
    DEDENT
    self.check_catch()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25226871_25226944_1_11
25226871_25227005_3_10
Title: Splitting textfile into section with special delimiter line - python 
----------------------------------------

def per_section(it, is_delimiter = lambda x : x.isspace()) :
INDENT
    ret = []
    for line in it :
    INDENT
        if is_delimiter(line) :
        INDENT
            if ret :
            INDENT
                yield ret
                ret = []
            DEDENT
        DEDENT
        else :
        INDENT
            ret.append(line.rstrip())
        DEDENT
    DEDENT
    if ret :
    INDENT
        yield ret
    DEDENT
DEDENT
----------------------------------------

def per_section(s, delimiters = ()) :
INDENT
    def key(s) :
    INDENT
        return not s or s.isspace() or any(s.startswith(x) for x in delimiters)
    DEDENT
    for k, g in groupby(s.splitlines(), key = key) :
    INDENT
        if not k :
        INDENT
            yield list(g)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25229790_25229886_5_10
25229790_25229977_17_33
Title: Tuple for multiprocessing.Array in python 
----------------------------------------

def main(cpu_number) :
INDENT
    values = [("a", "b"), ("c", "d"), ("e", "f")]
    results = pool.imap_unordered(partial(thread_func, 1000), values [: cpu_number])
    for result in results :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def main(cpu_number) :
INDENT
    thread_list = []
    value_list = [
        SomeTuple(cast(create_string_buffer(b"a"), POINTER(c_ubyte)), cast(create_string_buffer(b"b"), POINTER(c_ubyte))),
        SomeTuple(cast(create_string_buffer(b"c"), POINTER(c_ubyte)), cast(create_string_buffer(b"d"), POINTER(c_ubyte))),
        SomeTuple(cast(create_string_buffer(b"e"), POINTER(c_ubyte)), cast(create_string_buffer(b"f"), POINTER(c_ubyte)))]
    arr = Array(SomeTuple, value_list)
    with Pool(processes = cpu_number) as pool :
    INDENT
        for _ in range(cpu_number) :
        INDENT
            r = pool.apply_async(thread_func, args = (1000, arr))
            thread_list.append(r)
        DEDENT
    DEDENT
    for thread in thread_list :
    INDENT
        thread.wait()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25239958_25562948_8_16
25239958_42859371_8_14
Title: Impute categorical missing values in scikit-learn 
----------------------------------------

def __init__(self) :
INDENT
    """Impute missing values.

        Columns of dtype object are imputed with the most frequent value 
        in column.

        Columns of other types are imputed with mean of column.

        """
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    """Impute missing values.

        If the Series is of dtype Object, then impute with the most frequent object.
        If the Series is not of dtype Object, then impute with the mean.  

        """
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25239958_45228286_5_12
25239958_47167330_6_21
Title: Impute categorical missing values in scikit-learn 
----------------------------------------

def fit(self, X, y = None) :
INDENT
    if self.strategy == 'most_frequent' :
    INDENT
        self.fills = pd.DataFrame(X).mode(axis = 0).squeeze()
        self.statistics_ = self.fills.values
        return self
    DEDENT
    else :
    INDENT
        return Imputer.fit(self, X, y = y)
    DEDENT
DEDENT
----------------------------------------

def fit(self, X, y = None) :
INDENT
    if self.strategy in ['mean', 'median'] :
    INDENT
        if not all(X.dtypes == np.number) :
        INDENT
            raise ValueError('dtypes mismatch np.number dtype is \
                                 required for ' + self.strategy)
        DEDENT
    DEDENT
    if self.strategy == 'mean' :
    INDENT
        self.fill = X.mean()
    DEDENT
    elif self.strategy == 'median' :
    INDENT
        self.fill = X.median()
    DEDENT
    elif self.strategy == 'mode' :
    INDENT
        self.fill = X.mode().iloc [0]
    DEDENT
    elif self.strategy == 'fill' :
    INDENT
        if type(self.fill) is list and type(X) is pd.DataFrame :
        INDENT
            self.fill = dict([(cname, v) for cname, v in zip(X.columns, self.fill)])
        DEDENT
    DEDENT
    return self
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25240554_25240859_1_11
25240554_25242332_7_16
Title: Detecting vicinal words 
----------------------------------------

def is_vicinal(word) :
INDENT
    letters = [ord(l) for l in word]
    for letter in letters :
    INDENT
        if letter - 1 not in letters and letter + 1 not in letters :
        INDENT
            if letter == 97 and 122 in letters :
            INDENT
                continue
            DEDENT
            elif letter == 122 and 97 in letters :
            INDENT
                continue
            DEDENT
            else :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def is_vicinal(arr, abc) :
INDENT
    vicinal = True
    index = 0
    while vicinal and index < len(arr) :
    INDENT
        c = arr [index]
        vicinal = vicinal and (abc [(c - 1) % LEN] or abc [(c + 1) % LEN])
        index += 1
    DEDENT
    return vicinal

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25250499_25253757_2_24
25250499_25274337_1_23
Title: Can we limit the number of tests running in parallel with testtools.ConcurrentStreamTestSuite 
----------------------------------------

def split_suite_into_chunks(n, suite) :
INDENT
    if n < 0 :
    INDENT
        n = 1
    DEDENT
    if n > 8 :
    INDENT
        n = 8
    DEDENT
    n = math.ceil(suite.countTestCases() / n)
    s = []
    i = 0
    s_tmp = unittest.TestSuite()
    for case in suite :
    INDENT
        if i < n :
        INDENT
            s_tmp.addTest(case)
            i += 1
        DEDENT
        if i == n :
        INDENT
            s.append([s_tmp, None])
            i = 0
            s_tmp = unittest.TestSuite()
        DEDENT
    DEDENT
    if (i > 0) :
    INDENT
        s.append([s_tmp, None])
    DEDENT
    return s
DEDENT
----------------------------------------

def split_suite_into_chunks(num_threads, suite) :
INDENT
    if num_threads < 0 : num_threads = 1
    if num_threads > 8 : num_threads = 8
    num_tests = suite.countTestCases()
    s = []
    s_tmp = unittest.TestSuite()
    n = round(num_tests / num_threads)
    for case in suite :
    INDENT
        if n < = 0 and s_tmp.countTestCases() > 0 :
        INDENT
            s.append([s_tmp, None])
            num_threads -= 1
            num_tests -= s_tmp.countTestCases()
            s_tmp = unittest.TestSuite()
            n = round(num_tests / num_threads)
        DEDENT
        s_tmp.addTest(case)
        n -= 1
    DEDENT
    if s_tmp.countTestCases() > 0 :
    INDENT
        if s_tmp.countTestCases() > 0 : s.append([s_tmp, None])
        num_tests -= s_tmp.countTestCases()
    DEDENT
    if num_tests ! = 0 : print ("Error: num_tests should be 0 but is %s!" % num_tests)
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25253225_25253810_2_15
25253225_25256208_43_70
Title: How to share single StyleSheet among multiple item-widgets? 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Tree, self).__init__()
    comboStyle = "QComboBox {background-color: #7A7A7A; border: 1px solid black;}"
    self.setStyleSheet(comboStyle)
    for each in ['Item_1', 'Item_2', 'Item_3', 'Item_4', 'Item_5'] :
    INDENT
        item = QtGui.QTreeWidgetItem([each])
        self.addTopLevelItem(item)
        combo1 = QtGui.QComboBox()
        combo2 = QtGui.QComboBox()
        self.setItemWidget(item, 1, combo1)
        self.setItemWidget(item, 2, combo2)
    DEDENT
    self.setColumnCount(5)
    self.resize(360, 240)
    self.show()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Tree, self).__init__()
    self.setAutoFillBackground(True)
    self.setBackgroundRole(QtGui.QPalette.Base)
    p = self.palette()
    p.setColor(self.backgroundRole(), QtGui.QColor("#0F0F0F"))
    self.setPalette(p)
    self.setColumnCount(5)
    for each in ['Item_1', 'Item_2', 'Item_3', 'Item_4', 'Item_5'] :
    INDENT
        item = QtGui.QTreeWidgetItem([each])
        self.addTopLevelItem(item)
        combo = ComboBox(self, item)
        lineEdit = LineEdit(self, item)
        combo.connect(self, QtCore.SIGNAL('selectionChanged!'), combo.restyle)
        lineEdit.connect(self, QtCore.SIGNAL('selectionChanged!'), lineEdit.restyle)
        self.setItemWidget(item, 1, combo)
        self.setItemWidget(item, 2, lineEdit)
        self.connect(combo, QtCore.SIGNAL('click!'), self.select)
        self.connect(lineEdit, QtCore.SIGNAL('click!'), self.select)
    DEDENT
    self.itemSelectionChanged.connect(self.emitOnChange)
    self.resize(480, 120)
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25253225_25256208_14_22
25253225_25256208_33_41
Title: How to share single StyleSheet among multiple item-widgets? 
----------------------------------------

def restyle(self) :
INDENT
    if self.item.isSelected() : bgColor = '#7A7A7A'
    elif self.tree.indexFromItem(self.item).row() % 2 : bgColor = '#1F1F1F'
    else : bgColor = '#262626'
    stylesheet = "QLineEdit {{background-color: {0}; border: 1px solid black;}}".format(bgColor)
    self.setStyleSheet(stylesheet)
    for i in range(5) : self.item.setBackgroundColor(i, QtGui.QColor(bgColor))
DEDENT
----------------------------------------

def restyle(self) :
INDENT
    if self.item.isSelected() : bgColor = '#7A7A7A'
    elif self.tree.indexFromItem(self.item).row() % 2 : bgColor = '#1F1F1F'
    else : bgColor = '#262626'
    stylesheet = "QComboBox {{background-color: {0}; border: 1px solid black;}}".format(bgColor)
    self.setStyleSheet(stylesheet)
    for i in range(5) : self.item.setBackgroundColor(i, QtGui.QColor(bgColor))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25269459_25269931_1_23
25269459_25270212_1_18
Title: Make HTML Table from List 
----------------------------------------

def reformat_html_id_table(line) :
INDENT
    del (line [4])
    htmlTable = '<table>\n'
    for i in range(0, len(line)) :
    INDENT
        posInRow = i % 8

        if (posInRow == 0) :
        INDENT
            htmlTable += '<tr>'
        DEDENT
        htmlTable += '\t<td>{0}</td>\n'.format(line [i])

        if (posInRow == 3) :
        INDENT
            htmlTable += '\t<td> </td>\n'

        DEDENT
        if (posInRow == 7) :
        INDENT
            htmlTable += '</tr>'
        DEDENT
    DEDENT
    htmlTable += '</table>'
    print htmlTable
DEDENT
----------------------------------------

def reformat_html_id_table(line) :
INDENT
    htmlTable = '<table>\n'
    mod = 9
    for i in range(0, len(line)) :
    INDENT
        if (i > mod and i % mod == 5) :
        INDENT
            htmlTable = htmlTable + '\t\t<td> </td>\n'
        DEDENT
        if (i - 9) % mod == 0 :
        INDENT
            if i == 0 :
            INDENT
                htmlTable = htmlTable + '\t<tr>\n'
            DEDENT
            else :
            INDENT
                htmlTable = htmlTable + '\t</tr>\n\t<tr>\n'
            DEDENT
            htmlTable = htmlTable + '\t\t<td>{0}</td>\n'.format(line [i])
        DEDENT
        else :
        INDENT
            htmlTable = htmlTable + '\t\t<td>{0}</td>\n'.format(line [i])
        DEDENT
        if i == 9 :
        INDENT
            mod = 8
        DEDENT
    DEDENT
    htmlTable = htmlTable + '\t</tr>\n</table>'
    print htmlTable
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25283882_25286268_3_13
25283882_25287521_5_20
Title: Determining the filesystem type from a path in Python 
----------------------------------------

def get_fs_type(mypath) :
INDENT
    root_type = ""
    for part in psutil.disk_partitions() :
    INDENT
        if part.mountpoint == '/' :
        INDENT
            root_type = part.fstype
            continue
        DEDENT
        if mypath.startswith(part.mountpoint) :
        INDENT
            return part.fstype
        DEDENT
    DEDENT
    return root_type
DEDENT
----------------------------------------

def get_fs_type(path) :
INDENT
    partition = {}
    for part in psutil.disk_partitions() :
    INDENT
        partition [part.mountpoint] = (part.fstype, part.device)
    DEDENT
    if path in partition :
    INDENT
        return partition [path]
    DEDENT
    splitpath = path.split(os.sep)
    for i in xrange(len(splitpath), 0, - 1) :
    INDENT
        path = os.sep.join(splitpath [: i]) + os.sep
        if path in partition :
        INDENT
            return partition [path]
        DEDENT
        path = os.sep.join(splitpath [: i])
        if path in partition :
        INDENT
            return partition [path]
        DEDENT
    DEDENT
    return ("unkown", "none")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25283882_25286268_3_13
25283882_35291824_3_10
Title: Determining the filesystem type from a path in Python 
----------------------------------------

def get_fs_type(mypath) :
INDENT
    root_type = ""
    for part in psutil.disk_partitions() :
    INDENT
        if part.mountpoint == '/' :
        INDENT
            root_type = part.fstype
            continue
        DEDENT
        if mypath.startswith(part.mountpoint) :
        INDENT
            return part.fstype
        DEDENT
    DEDENT
    return root_type
DEDENT
----------------------------------------

def get_fs_type(path) :
INDENT
    bestMatch = ""
    fsType = ""
    for part in psutil.disk_partitions() :
    INDENT
        if mypath.startswith(part.mountpoint) and len(bestMatch) < len(part.mountpoint) :
        INDENT
            fsType = part.fstype
            bestMatch = part.mountpoint
        DEDENT
    DEDENT
    return fsType
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25283882_25287521_5_20
25283882_35291824_3_10
Title: Determining the filesystem type from a path in Python 
----------------------------------------

def get_fs_type(path) :
INDENT
    partition = {}
    for part in psutil.disk_partitions() :
    INDENT
        partition [part.mountpoint] = (part.fstype, part.device)
    DEDENT
    if path in partition :
    INDENT
        return partition [path]
    DEDENT
    splitpath = path.split(os.sep)
    for i in xrange(len(splitpath), 0, - 1) :
    INDENT
        path = os.sep.join(splitpath [: i]) + os.sep
        if path in partition :
        INDENT
            return partition [path]
        DEDENT
        path = os.sep.join(splitpath [: i])
        if path in partition :
        INDENT
            return partition [path]
        DEDENT
    DEDENT
    return ("unkown", "none")
DEDENT
----------------------------------------

def get_fs_type(path) :
INDENT
    bestMatch = ""
    fsType = ""
    for part in psutil.disk_partitions() :
    INDENT
        if mypath.startswith(part.mountpoint) and len(bestMatch) < len(part.mountpoint) :
        INDENT
            fsType = part.fstype
            bestMatch = part.mountpoint
        DEDENT
    DEDENT
    return fsType
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25289170_25303375_118_154
25289170_25303375_80_95
Title: How to make QTreeWidget dragging semi-transparent and keep itemWidgets 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(QCustomQDialog, self).__init__(parent)
    self.myQCustomTreeWidget = QCustomTreeWidget(self)
    self.addQPushButton = QtGui.QPushButton('Add', self)
    self.connect(self.addQPushButton, QtCore.SIGNAL('released()'), self.myQCustomTreeWidget.addMenu)
    self.cssQPlainTextEdit = QtGui.QPlainTextEdit(self)
    self.connect(self.cssQPlainTextEdit, QtCore.SIGNAL('textChanged()'), self.updateCss)
    self.rootDecorationCBQCheckBox = QtGui.QCheckBox('Root is decorated')
    self.connect(self.rootDecorationCBQCheckBox, QtCore.SIGNAL('stateChanged(int)'), self.updateRootDecorated)
    self.updateRootDecorated(self.rootDecorationCBQCheckBox.checkState())
    self.indentationQSlider = QtGui.QSlider(self)
    self.indentationQSlider.setOrientation(QtCore.Qt.Horizontal)
    self.indentationQSlider.setRange(0, 100)
    self.indentationQSlider.setValue(20)
    self.connect(self.indentationQSlider, QtCore.SIGNAL('valueChanged(int)'), self.alterIndentation)
    self.alterIndentation(self.indentationQSlider.value())
    self.layoutQVBoxLayout = QtGui.QVBoxLayout()
    self.layoutQVBoxLayout.addWidget(self.myQCustomTreeWidget)
    self.layoutQVBoxLayout.addWidget(self.addQPushButton)
    self.layoutQVBoxLayout.addWidget(self.cssQPlainTextEdit)
    self.downMenuQHBoxLayout = QtGui.QHBoxLayout()
    self.downMenuQHBoxLayout.addWidget(self.rootDecorationCBQCheckBox)
    self.downMenuQHBoxLayout.addWidget(self.indentationQSlider)
    self.layoutQVBoxLayout.addLayout(self.downMenuQHBoxLayout)
    self.layoutQVBoxLayout.setStretchFactor(self.myQCustomTreeWidget, 1)
    self.setLayout(self.layoutQVBoxLayout)
    self.resize(480, 640)
    _ = self.myQCustomTreeWidget.addMenu()
    _ = self.myQCustomTreeWidget.addMenu()
    currentQTreeWidgetItem = self.myQCustomTreeWidget.addMenu()
    self.myQCustomTreeWidget.addMenu(parentQTreeWidgetItem = currentQTreeWidgetItem)
    self.myQCustomTreeWidget.addMenu(parentQTreeWidgetItem = currentQTreeWidgetItem)
    currentQTreeWidgetItem = self.myQCustomTreeWidget.addMenu()
    currentQTreeWidgetItem = self.myQCustomTreeWidget.addMenu(parentQTreeWidgetItem = currentQTreeWidgetItem)
    currentQTreeWidgetItem = self.myQCustomTreeWidget.addMenu(parentQTreeWidgetItem = currentQTreeWidgetItem)
    _ = self.myQCustomTreeWidget.addMenu()
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(QCustomTreeWidget, self).__init__(parent)
    self.setDragEnabled(True)
    self.setDragDropMode(QtGui.QAbstractItemView.InternalMove)
    self.setColumnCount(3)
    self.setHeaderLabels(('script', 'chunksize', 'mem'))
    for i in range(self.columnCount()) :
    INDENT
        self.headerItem().setTextAlignment(i, QtCore.Qt.AlignHCenter)
    DEDENT
    self.header().setStretchLastSection(False)
    self.header().setResizeMode(0, QtGui.QHeaderView.Stretch)
    self.setIndentation(60)
    self.setColumnWidth(0, 200)
    myQCustomDelegate = QCustomDelegate()
    self.setItemDelegate(myQCustomDelegate)
    self.connect(myQCustomDelegate, QtCore.SIGNAL('requestNewPath'), self.getNewPath)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25295863_25302027_29_37
25295863_25307429_59_72
Title: How to Quit Current Program and recreate the original Gui? Also creating a secret code to close program 
----------------------------------------

def initialize(self) :
INDENT
    self.grid()
    def gatherinfo() :
    INDENT
        example2()
    DEDENT
    MSubmit = TK.Button(self, text = 'Submit', font = font2, command = gatherinfo)
    MSubmit.grid(column = 3, row = 3, sticky = 'we', padx = (10, 10))
DEDENT
----------------------------------------

def initialize(self) :
INDENT
    self.grid()
    def gatherinfo() :
    INDENT
        example2(self)
    DEDENT
    def terminate(event = None) :
    INDENT
        self.do_restart = False
        self.destroy()
    DEDENT
    self.bind("<Escape>", terminate)
    MSubmit = TK.Button(self, text = 'Submit', font = font2, command = gatherinfo)
    MSubmit.grid(column = 3, row = 3, sticky = 'we', padx = (10, 10))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25295863_25307429_13_22
25295863_25307429_30_51
Title: How to Quit Current Program and recreate the original Gui? Also creating a secret code to close program 
----------------------------------------

def initalize(self) :
INDENT
    self.grid()
    def restart() :
    INDENT
        self.parent.do_restart = True
        self.parent.destroy()
    DEDENT
    Yes = TK.Button(self, text = 'Yes', font = font2, command = restart)
    Yes.grid(column = 0, row = 0, sticky = 'we', padx = (10, 10))
DEDENT
----------------------------------------

def initalize(self) :
INDENT
    self.grid()

    MstepOne = TK.LabelFrame(self, font = font2)
    MstepOne.grid(row = 0, columnspan = 7, sticky = 'w', padx = 5, pady = 5, ipadx = 5, ipady = 5)
    def gatherinfo2() :
    INDENT
        example3(self.parent)

    DEDENT
    MLabel1 = TK.Label(MstepOne, text = "First Name", font = font)
    MLabel1.grid(column = 2, row = 0, sticky = 'w', padx = (10, 10))
    MLabel2 = TK.Label(MstepOne, text = "Last Name", font = font)
    MLabel2.grid(column = 4, row = 0, sticky = 'w', padx = (10, 10))

    MSubmit = TK.Button(self, text = 'Submit', font = font2, command = gatherinfo2)
    MSubmit.grid(column = 3, row = 3, sticky = 'we', padx = (10, 10))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25299837_25299968_1_11
25299837_25299993_1_12
Title: "given and integer return the next integer that is a prime number and a palindrome . Python" 
----------------------------------------

def golf(number) :
INDENT
    x = number
    while True :
    INDENT
        x += 1
        if str(x) ! = str(x) [: : - 1] :
        INDENT
            continue
        DEDENT
        for i in xrange(2, x) :
        INDENT
            if x % i == 0 :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            return x
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def golf(number) :
INDENT
    x = number + 1
    while True :
    INDENT
        is_golf = True
        for i in range(2, x) :
        INDENT
            if x % i == 0 or str(x) ! = str(x) [: : - 1] :
            INDENT
                is_golf = False
                break
            DEDENT
        DEDENT
        if is_golf :
        INDENT
            return x
        DEDENT
        x += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_25437110_9_20
25316765_27235766_46_75
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    if '@' in username :
    INDENT
        kwargs = {'email' : username}
    DEDENT
    else :
    INDENT
        kwargs = {'username' : username}
    DEDENT
    try :
    INDENT
        user = get_user_model().objects.get(** kwargs)
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    UserModel = get_user_model()
    try :
    INDENT
        if ((am == 'email') or (am == 'both')) :
        INDENT
            if ((cs == 'email') or cs == 'both') :
            INDENT
                kwargs = {'email' : username}
            DEDENT
            else :
            INDENT
                kwargs = {'email__iexact' : username}
            DEDENT
            user = UserModel.objects.get(** kwargs)
        DEDENT
        else :
        INDENT
            raise
        DEDENT
    DEDENT
    except :
    INDENT
        if ((am == 'username') or (am == 'both')) :
        INDENT
            if ((cs == 'username') or cs == 'both') :
            INDENT
                kwargs = {'username' : username}
            DEDENT
            else :
            kwargs = {'username__iexact' : username}
            user = UserModel.objects.get(** kwargs)
        DEDENT
    DEDENT
    finally :
    INDENT
        try :
        INDENT
            if user.check_password(password) :
            INDENT
                return user
            DEDENT
        DEDENT
        except :
        INDENT

            UserModel().set_password(password)
            return None
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_25437110_9_20
25316765_30647871_7_18
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    if '@' in username :
    INDENT
        kwargs = {'email' : username}
    DEDENT
    else :
    INDENT
        kwargs = {'username' : username}
    DEDENT
    try :
    INDENT
        user = get_user_model().objects.get(** kwargs)
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    try :
    INDENT
        user = UserModel.objects.get(Q(username__iexact = username) | Q(email__iexact = username))
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except UserModel.DoesNotExist :
    INDENT

        UserModel().set_password(password)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_25437110_9_20
25316765_35836674_8_23
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    if '@' in username :
    INDENT
        kwargs = {'email' : username}
    DEDENT
    else :
    INDENT
        kwargs = {'username' : username}
    DEDENT
    try :
    INDENT
        user = get_user_model().objects.get(** kwargs)
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    if username is None :
    INDENT
        username = kwargs.get(UserModel.USERNAME_FIELD)

    DEDENT
    users = UserModel._default_manager.filter(
        Q(** {UserModel.USERNAME_FIELD : username}) | Q(email__iexact = username))
    for user in users :
    INDENT
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    if not users :
    INDENT

        UserModel().set_password(password)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_25437110_9_20
25316765_51994770_5_13
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    if '@' in username :
    INDENT
        kwargs = {'email' : username}
    DEDENT
    else :
    INDENT
        kwargs = {'username' : username}
    DEDENT
    try :
    INDENT
        user = get_user_model().objects.get(** kwargs)
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    try :
    INDENT
        user = User.objects.get(email = username)
        if user.check_password(raw_password = password) :
        INDENT
            return user
        DEDENT
        return None
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_27235766_46_75
25316765_30647871_7_18
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    UserModel = get_user_model()
    try :
    INDENT
        if ((am == 'email') or (am == 'both')) :
        INDENT
            if ((cs == 'email') or cs == 'both') :
            INDENT
                kwargs = {'email' : username}
            DEDENT
            else :
            INDENT
                kwargs = {'email__iexact' : username}
            DEDENT
            user = UserModel.objects.get(** kwargs)
        DEDENT
        else :
        INDENT
            raise
        DEDENT
    DEDENT
    except :
    INDENT
        if ((am == 'username') or (am == 'both')) :
        INDENT
            if ((cs == 'username') or cs == 'both') :
            INDENT
                kwargs = {'username' : username}
            DEDENT
            else :
            kwargs = {'username__iexact' : username}
            user = UserModel.objects.get(** kwargs)
        DEDENT
    DEDENT
    finally :
    INDENT
        try :
        INDENT
            if user.check_password(password) :
            INDENT
                return user
            DEDENT
        DEDENT
        except :
        INDENT

            UserModel().set_password(password)
            return None
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    try :
    INDENT
        user = UserModel.objects.get(Q(username__iexact = username) | Q(email__iexact = username))
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except UserModel.DoesNotExist :
    INDENT

        UserModel().set_password(password)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_27235766_46_75
25316765_35836674_8_23
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    UserModel = get_user_model()
    try :
    INDENT
        if ((am == 'email') or (am == 'both')) :
        INDENT
            if ((cs == 'email') or cs == 'both') :
            INDENT
                kwargs = {'email' : username}
            DEDENT
            else :
            INDENT
                kwargs = {'email__iexact' : username}
            DEDENT
            user = UserModel.objects.get(** kwargs)
        DEDENT
        else :
        INDENT
            raise
        DEDENT
    DEDENT
    except :
    INDENT
        if ((am == 'username') or (am == 'both')) :
        INDENT
            if ((cs == 'username') or cs == 'both') :
            INDENT
                kwargs = {'username' : username}
            DEDENT
            else :
            kwargs = {'username__iexact' : username}
            user = UserModel.objects.get(** kwargs)
        DEDENT
    DEDENT
    finally :
    INDENT
        try :
        INDENT
            if user.check_password(password) :
            INDENT
                return user
            DEDENT
        DEDENT
        except :
        INDENT

            UserModel().set_password(password)
            return None
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    if username is None :
    INDENT
        username = kwargs.get(UserModel.USERNAME_FIELD)

    DEDENT
    users = UserModel._default_manager.filter(
        Q(** {UserModel.USERNAME_FIELD : username}) | Q(email__iexact = username))
    for user in users :
    INDENT
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    if not users :
    INDENT

        UserModel().set_password(password)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_27235766_46_75
25316765_51994770_5_13
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    UserModel = get_user_model()
    try :
    INDENT
        if ((am == 'email') or (am == 'both')) :
        INDENT
            if ((cs == 'email') or cs == 'both') :
            INDENT
                kwargs = {'email' : username}
            DEDENT
            else :
            INDENT
                kwargs = {'email__iexact' : username}
            DEDENT
            user = UserModel.objects.get(** kwargs)
        DEDENT
        else :
        INDENT
            raise
        DEDENT
    DEDENT
    except :
    INDENT
        if ((am == 'username') or (am == 'both')) :
        INDENT
            if ((cs == 'username') or cs == 'both') :
            INDENT
                kwargs = {'username' : username}
            DEDENT
            else :
            kwargs = {'username__iexact' : username}
            user = UserModel.objects.get(** kwargs)
        DEDENT
    DEDENT
    finally :
    INDENT
        try :
        INDENT
            if user.check_password(password) :
            INDENT
                return user
            DEDENT
        DEDENT
        except :
        INDENT

            UserModel().set_password(password)
            return None
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    try :
    INDENT
        user = User.objects.get(email = username)
        if user.check_password(raw_password = password) :
        INDENT
            return user
        DEDENT
        return None
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_30647871_7_18
25316765_35836674_8_23
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    try :
    INDENT
        user = UserModel.objects.get(Q(username__iexact = username) | Q(email__iexact = username))
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except UserModel.DoesNotExist :
    INDENT

        UserModel().set_password(password)
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    if username is None :
    INDENT
        username = kwargs.get(UserModel.USERNAME_FIELD)

    DEDENT
    users = UserModel._default_manager.filter(
        Q(** {UserModel.USERNAME_FIELD : username}) | Q(email__iexact = username))
    for user in users :
    INDENT
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    if not users :
    INDENT

        UserModel().set_password(password)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_30647871_7_18
25316765_51994770_5_13
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    try :
    INDENT
        user = UserModel.objects.get(Q(username__iexact = username) | Q(email__iexact = username))
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except UserModel.DoesNotExist :
    INDENT

        UserModel().set_password(password)
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    try :
    INDENT
        user = User.objects.get(email = username)
        if user.check_password(raw_password = password) :
        INDENT
            return user
        DEDENT
        return None
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25316765_35836674_8_23
25316765_51994770_5_13
Title: Log in user using either email address or username in Django 
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    if username is None :
    INDENT
        username = kwargs.get(UserModel.USERNAME_FIELD)

    DEDENT
    users = UserModel._default_manager.filter(
        Q(** {UserModel.USERNAME_FIELD : username}) | Q(email__iexact = username))
    for user in users :
    INDENT
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    if not users :
    INDENT

        UserModel().set_password(password)
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    try :
    INDENT
        user = User.objects.get(email = username)
        if user.check_password(raw_password = password) :
        INDENT
            return user
        DEDENT
        return None
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25320775_25320793_2_8
25320775_25320815_1_10
Title: New If Statement after If Else Block In a Function Return Unexpected Results 
----------------------------------------

def type(d) :
INDENT
    if d in (datetime(2014, 1, 1), datetime(2014, 5, 26), datetime(2014, 7, 4), datetime(2014, 9, 1), datetime(2014, 11, 27), datetime(2014, 12, 25)) :
    INDENT
        return 3
    DEDENT
    if d.weekday() in [0, 1, 2, 3, 4] :
    INDENT
        return 1
    DEDENT
    else :
    INDENT
        return 2
    DEDENT
DEDENT
----------------------------------------

def type(d) :
INDENT
    if d in (datetime(2014, 1, 1), datetime(2014, 5, 26), datetime(2014, 7, 4), datetime(2014, 9, 1), datetime(2014, 11, 27), datetime(2014, 12, 25)) :
    INDENT
        daytype = 3
    DEDENT
    elif d.weekday() in [5, 6] :
    INDENT
        daytype = 2
    DEDENT
    else :
    INDENT
        daytype = 1
    DEDENT
    return daytype
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25327599_25330539_23_31
25327599_25330539_7_15
Title: PyQt5 QDialog in subsequent threads 
----------------------------------------

def setupUi(self, mainWindow) :
INDENT
    mainWindow.setObjectName("mainWindow")
    self.pushButton = QtWidgets.QPushButton(mainWindow)
    self.pushButton.setGeometry(QtCore.QRect(30, 20, 100, 60))
    self.pushButton.setObjectName("pushButton")
    self.retranslateUi(mainWindow)
    QtCore.QMetaObject.connectSlotsByName(mainWindow)
DEDENT
----------------------------------------

def setupUi(self, Dialog) :
INDENT
    Dialog.setObjectName("Dialog")
    self.pushButton = QtWidgets.QPushButton(Dialog)
    self.pushButton.setGeometry(QtCore.QRect(100, 100, 100, 50))
    self.pushButton.setObjectName("pushButton")
    self.retranslateUi(Dialog)
    QtCore.QMetaObject.connectSlotsByName(Dialog)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25327599_25330539_57_66
25327599_52193157_66_74
Title: PyQt5 QDialog in subsequent threads 
----------------------------------------

def __init__(self) :
INDENT
    super(Main, self).__init__()
    self.ui = Ui_MainWindow()
    self.ui.setupUi(self)
    self.dialog = TestDialog()
    self.dialog_done = False
    self.ui.pushButton.clicked.connect(self.start_thread)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    app = PyQt5.QtWidgets.QApplication(sys.argv)
    FULLPROGRAM.fxRun = PROCESS_BOX()
    FULLPROGRAM.mainUI = MAIN_UI()
    FULLPROGRAM.mainUI.startSignal.connect(FULLPROGRAM.fxRun.show_dialogbox)
    FULLPROGRAM.mainUI.endSignal.connect(FULLPROGRAM.fxRun.processComplete)
    FULLPROGRAM.mainUI.show()
    app.exec_()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25351754_25352525_38_49
25351754_25352525_5_19
Title: PyQt QTableWidget retrieve edited field 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(QCustomWidget, self).__init__(parent)
    self.myQCustomTableWidget = QCustomTableWidget(self)
    self.myQLabel = QtGui.QLabel('Track edited data', self)
    myQVBoxLayout = QtGui.QVBoxLayout()
    myQVBoxLayout.addWidget(self.myQLabel)
    myQVBoxLayout.addWidget(self.myQCustomTableWidget)
    self.setLayout(myQVBoxLayout)
    self.connect(self.myQCustomTableWidget, QtCore.SIGNAL('currentKeyboardDataChanged'), self.setTrackData)
    self.myQCustomTableWidget.setItem(0, 0, QtGui.QTableWidgetItem('Test'))
    self.myQCustomTableWidget.setItem(1, 1, QtGui.QTableWidgetItem('Work'))
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(QCustomTableWidget, self).__init__(parent)
    self.focusKeyboardOn = False
    listsVerticalHeaderItem = ['Device 1', 'Device 2', 'Device 3', 'Device 4', 'Device 5']
    self.setRowCount(len(listsVerticalHeaderItem))
    for index in range(self.rowCount()) :
    INDENT
        self.setVerticalHeaderItem(index, QtGui.QTableWidgetItem(listsVerticalHeaderItem [index]))
    DEDENT
    listsVerticalHeaderItem = ['Device 1', 'Device 2', 'Device 3', 'Device 4']
    self.setColumnCount(5)
    listsHorizontalHeaderItem = ['Option 1', 'Option 2']
    self.setColumnCount(len(listsHorizontalHeaderItem))
    for index in range(self.columnCount()) :
    INDENT
        self.setHorizontalHeaderItem(index, QtGui.QTableWidgetItem(listsHorizontalHeaderItem [index]))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25368295_25375061_5_20
25368295_25377844_5_16
Title: QWidget::mouseMoveEvent not firing when cursor over child widget 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(QCustomWidget, self).__init__(parent)
    self.myQTabWidget = QtGui.QTabWidget(self)
    self.my1QWidget = QtGui.QWidget()
    self.my2QWidget = QtGui.QWidget()
    self.myQTabWidget.addTab(self.my1QWidget, 'Tab 1')
    self.myQTabWidget.addTab(self.my2QWidget, 'Tab 2')
    myQLayout = QtGui.QVBoxLayout()
    myQLayout.addWidget(self.myQTabWidget)
    self.setLayout(myQLayout)
    self.setMouseMoveEventDelegate(self)
    self.setMouseMoveEventDelegate(self.myQTabWidget)
    self.setMouseMoveEventDelegate(self.myQTabWidget.tabBar())
    self.setMouseMoveEventDelegate(self.my1QWidget)
    self.setMouseMoveEventDelegate(self.my2QWidget)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QWidget.__init__(self)
    tabs = QtGui.QTabWidget()
    tab1 = QtGui.QWidget()
    tab2 = QtGui.QWidget()
    tabs.addTab(tab1, "Tab 1")
    tabs.addTab(tab2, "Tab 2")
    layout = QtGui.QVBoxLayout()
    layout.addWidget(tabs)
    self.setLayout(layout)
    self.setMouseTracking(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25374833_25375208_1_12
25374833_25391583_38_49
Title: multi-threaded script hangs at the end 
----------------------------------------

def worker(unext, udone) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            m = unext.get_nowait()
            users_all [m].runNextDelay()
            if users_all [m].hasDelay() :
            INDENT
                unext.put(m)
            DEDENT
            else :
            INDENT
                udone.put(m)
            DEDENT
        DEDENT
        except queue.Queue.Empty :
        INDENT
            if udone.qsize() > = len(users_all) :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def worker(unext, udone) :
INDENT
    logging.info('start')
    for user in iter(unext.get, None) :
    INDENT
        while True :
        INDENT
            user.runNextDelay()
            if not user.hasDelay() :
            INDENT
                break
            DEDENT
            logging.debug('%s: reloop', user)
        DEDENT
        udone.put(user)
    DEDENT
    logging.info('done')

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25392763_25393430_18_45
25392763_25393430_70_102
Title: "is it possible to have two sortable ListCtrls in one window?" 
----------------------------------------

def __init__(self, parent, DataMap, ctrl_type = 1) :
INDENT
    wx.Panel.__init__(self, parent, wx.ID_ANY, style = wx.WANTS_CHARS)
    self.parent = parent
    self.list_ctrl = MyListCtrl(self,
        style = wx.LC_REPORT | wx.BORDER_SUNKEN | wx.LC_SORT_ASCENDING)
    gr = 2
    self.list_ctrl.InsertColumn(0, 'path', width = 30 * gr)
    self.list_ctrl.InsertColumn(1, 'name', width = 30 * gr)
    if ctrl_type == 1 :
    INDENT
        self.list_ctrl.InsertColumn(2, 'size(real)', wx.LIST_FORMAT_RIGHT, width = 15 * gr)
        self.list_ctrl.InsertColumn(3, 'size(dest)', wx.LIST_FORMAT_RIGHT, width = 15 * gr)
    DEDENT
    elif ctrl_type == 2 :
    INDENT
        self.list_ctrl.InsertColumn(2, 'size(dest)', wx.LIST_FORMAT_RIGHT, width = 15 * gr)
    DEDENT
    listmix.ColumnSorterMixin.__init__(self, 4)
    self.list_ctrl.DataMap = DataMap
    self.fillListCtrl(ctrl_type)
    self.list_ctrl.Bind(wx.EVT_LIST_COL_CLICK, self.OnColClick)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.list_ctrl, 1, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, wx.ID_ANY, style = wx.WANTS_CHARS)
    self.parent = parent
    DataMap_1 = {
        0 : ("pth1", "nam1", 62, 70),
        1 : ("pth2", "nam2", 22, 30),
        2 : ("pth3", "nam3", 57, 60),
        4 : ("pth4", "nam4", 9, 10)}
    DataMap_2 = {
        0 : ("pth5", "nam5", 45, 50),
        1 : ("pth6", "nam6", 81, 90),
        2 : ("pth7", "nam7", 33, 40),
        4 : ("pth8", "nam8", 13, 20)}
    self.testen = wx.Button(self, - 1, "&test", (- 1, - 1), wx.DefaultSize)
    list_panel = FillPanel(self, DataMap_1)
    list_panel_2 = FillPanel(self, DataMap_2, ctrl_type = 2)

    vsizer = wx.BoxSizer(wx.VERTICAL)
    hsizer = wx.BoxSizer(wx.HORIZONTAL)
    vsizer.Add(self.testen, 0, wx.ALL, 5)
    hsizer.Add(list_panel, 1, wx.ALL | wx.EXPAND, 5)
    hsizer.Add(list_panel_2, 1, wx.ALL | wx.EXPAND, 5)
    vsizer.Add(hsizer, 1, wx.EXPAND)
    self.SetSizer(vsizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25407416_25407565_1_15
25407416_25408438_2_7
Title: How can list[n] point to list[0]? Getting items not in sequence 
----------------------------------------

def __getitem__(self, i) :
INDENT
    if isinstance(i, int) :
    INDENT
        if len(self) == 0 :
        INDENT
            raise IndexError
        DEDENT
        i = i % len(self)
        return super(modList, self).__getitem__(i)
    DEDENT
    elif isinstance(i, slice) :
    INDENT
        if len(self) == 0 :
        INDENT
            return []
        DEDENT
        start = i.start % len(self)
        stop = i.stop % len(self)
        step = i.step
        return super(modList, self).__getItem__(slice(start, stop, step))
    DEDENT
    else :
    INDENT
        raise TypeError("invalid index")
    DEDENT
DEDENT
----------------------------------------

def __getitem__(self, index) :
INDENT
    try :
    INDENT
        return list.__getitem__(self, index % len(self))
    DEDENT
    except ZeroDivisionError :
    INDENT
        raise IndexError('list assignment index out of range')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25412405_25415544_3_19
25412405_25415595_7_17
Title: Google URL Builder in Python 
----------------------------------------

def buildurl(url) :
INDENT
    url = sub('utm_source=.*?(&|$)utm_medium=.*?(&|$)|utm_term=.*?(&|$)|utm_content=.*?(&|$)|utm_campaign=.*?(&|$)', '', url)

    o = urlparse(url)

    query = o.query
    query += 'utm_source=' + self.data ['source']
    query += '&utm_medium=' + self.data ['medium']
    query += '&utm_campaign=' + self.data ['campaign']

    return urlunparse(o.scheme, o.netloc, o.path, o.params, query, o.fragment)
DEDENT
----------------------------------------

def buildurl(url) :
INDENT
    scheme, netloc, path, params, query, fragment = urlparse(url)

    query = sub('\?utm_source=.*?(&|$)utm_medium=.*?(&|$)|utm_term=.*?(&|$)|utm_content=.*?(&|$)|utm_campaign=.*?(&|$)', '', query)

    query += '?utm_source=' + self.data ['source']
    query += '&utm_medium=' + self.data ['medium']
    query += '&utm_campaign=' + self.data ['campaign']
    return urlunparse((scheme, netloc, path, params, query, fragment))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25428870_25428961_2_8
25428870_25429526_4_11
Title: Using a decorator to check for optional arguments 
----------------------------------------

def decorator(func) :
INDENT
    def wrapper(* args, ** kwargs) :
    INDENT
        for arg in reqargs :
        INDENT
            if not arg in kwargs :
            INDENT
                raise TypeError("Missing %s" % arg)
            DEDENT
        DEDENT
        return func(* args, ** kwargs)
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def decorator(func) :
INDENT
    @ wraps(func)
    def decorated(* args, ** kwargs) :
    INDENT
        missing = [req for req in reqs if req not in kwargs]
        if missing :
        INDENT
            raise TypeError('missing ' + ', '.join(missing))
        DEDENT
        return func(* args, ** kwargs)
    DEDENT
    return decorated
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25448932_25449606_22_31
25448932_25449606_5_10
Title: Creating a class signal with pyqt4 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyDialog, self).__init__(parent)
    hbox = QtGui.QVBoxLayout()
    self.lines = [QtGui.QLineEdit() for _ in range(5)]
    for line in self.lines :
    INDENT
        hbox.addWidget(line)
    DEDENT
    self.label = CustomLabel(self.lines)
    hbox.addWidget(self.label)
    self.setLayout(hbox)
DEDENT
----------------------------------------

def __init__(self, line_edit_lst) :
INDENT
    super(CustomLabel, self).__init__("0")
    self.line_edit_lst = line_edit_lst
    for line_edit in self.line_edit_lst :
    INDENT
        line_edit.textChanged.connect(self.update)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25454065_25454433_16_25
25454065_25454433_6_13
Title: is this bad programming practice in tkinter? 
----------------------------------------

def __init__(self, master = None, cnf = {}, ** kw) :
INDENT
    super().__init__(master, cnf, ** kw)
    self.w = tkinter.Label(self, text = 'Hello, world!')
    self.w.grid()
    self.v = tkinter.Button(self, text = 'Press Me', command = self.click)
    self.v.grid()
    self.u = tkinter.Button(self, text = 'Me Too!',
        command = lambda : external_mutator(self.w))
    self.u.grid()
DEDENT
----------------------------------------

def __init__(self, screenName = None, baseName = None, className = 'Tk',
useTk = 1, sync = 0, use = None) :
INDENT
    super().__init__(screenName, baseName, className,
        useTk, sync, use)
    frame = Application(self)
    frame.grid()
    self.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25469009_25469371_55_72
25469009_25469371_6_21
Title: Weird crash when using PIL to save screen and display by PYQT 
----------------------------------------

def __init__(self, pics, parent = None) :
INDENT
    QtGui.QDialog.__init__(self, parent)
    layout = QtGui.QVBoxLayout()
    for p in pics :
    INDENT
        l = QtGui.QLabel()
        imageq = ImageQt(p)
        qimage = QtGui.QImage(imageq)
        i = QtGui.QPixmap(qimage)
        l.setPixmap(i)
        layout.addWidget(l)

    DEDENT
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QMainWindow.__init__(self, parent)
    button = QtGui.QPushButton('Start', parent = self)
    button.clicked.connect(self.add)
    layout = QtGui.QVBoxLayout()
    layout.addWidget(button)
    self.setLayout(layout)
    self.pics = []
    self.timer = QtCore.QTimer()
    QtCore.QObject.connect(self.timer, QtCore.SIGNAL("timeout()"), self.OnTimer)
    self.timer.start(3000)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25469009_25469371_6_21
25469009_25471435_2_21
Title: Weird crash when using PIL to save screen and display by PYQT 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QMainWindow.__init__(self, parent)
    button = QtGui.QPushButton('Start', parent = self)
    button.clicked.connect(self.add)
    layout = QtGui.QVBoxLayout()
    layout.addWidget(button)
    self.setLayout(layout)
    self.pics = []
    self.timer = QtCore.QTimer()
    QtCore.QObject.connect(self.timer, QtCore.SIGNAL("timeout()"), self.OnTimer)
    self.timer.start(3000)
DEDENT
----------------------------------------

def __init__(self, pics, parent = None) :
INDENT
    QtGui.QDialog.__init__(self, parent)
    layout = QtGui.QVBoxLayout()
    self.imageqs = []
    self.qimages = []
    for p in pics :
    INDENT
        l = QtGui.QLabel()
        imageq = ImageQt(Image.fromstring('RGB', (920, 60), p))
        qimage = QtGui.QImage(imageq)
        i = QtGui.QPixmap(qimage)
        self.imageqs.append(imageq)
        self.qimages.append(qimage)
        l.setPixmap(i)
        layout.addWidget(l)

    DEDENT
    self.setLayout(layout)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2549939_36516025_10_16
2549939_36516025_4_8
Title: Get signal names from numbers in Python 
----------------------------------------

def _signal_name(signum) :
INDENT
    for n, v in sorted(signal.__dict__.items()) :
    INDENT
        if v ! = signum :
        INDENT
            continue
        DEDENT
        if n.startswith("SIG") and not n.startswith("SIG_") :
        INDENT
            return n
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def _signal_name(signum) :
INDENT
    try :
    INDENT
        return signal.Signals(signum).name
    DEDENT
    except ValueError :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25508202_25509244_4_10
25508202_25511719_5_11
Title: Discarding a tee element 
----------------------------------------

def gen(mydeque) :
INDENT
    while True :
    INDENT
        if not mydeque :
        INDENT
            newval = next(it)
            for d in deques :
            INDENT
                d.append(newval)
            DEDENT
        DEDENT
        yield mydeque.popleft()
    DEDENT
DEDENT
----------------------------------------

def gen(mydeque) :
INDENT
    while True :
    INDENT
        if not mydeque :
        INDENT
            newval = next(it)
            for d in self.deques :
            INDENT
                d.append(newval)
            DEDENT
        DEDENT
        yield mydeque.popleft()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25509840_25510292_8_18
25509840_25514648_12_21
Title: How to get a function's attributes when passing it as a parameter 
----------------------------------------

def evaluate(fcall, testname) :
INDENT
    "print message if func call throws exception"
    try :
    INDENT
        fcall()
    DEDENT
    except Exception :
    INDENT
        funct = fcall.func
        print ("Error in " + testname + " "
            + funct.__name__
            + " " + funct.__doc__)
    DEDENT
DEDENT
----------------------------------------

def evaluate(funct, args, testname) :
INDENT
    try :
    INDENT
        if hasattr(funct, '__call__') :
        INDENT
            funct(* args)
        DEDENT
    DEDENT
    except Exception :
    INDENT
        print "Error in " + testname + " " + funct.__name__ + " " + funct.__doc__
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25510856_25511090_3_11
25510856_25511186_1_15
Title: Python efficiency query 
----------------------------------------

def check(s) :
INDENT
    if not re_credit.match(s) :
    INDENT
        return False
    DEDENT
    checksum = 0
    for c in s.replace(' ', '') :
    INDENT
        checksum += int(c)
    DEDENT
    if (checksum % 10) ! = 0 :
    INDENT
        return False
    DEDENT
    return True
DEDENT
----------------------------------------

def check(s) :
INDENT
    if len(s) ! = 19 :
    INDENT
        return False
    DEDENT
    expected_spaces = (4, 9, 14)
    for idx, ch in enumerate(s) :
    INDENT
        if (ch == ' ') ! = (idx in expected_spaces) :
        INDENT
            return False
        DEDENT
    DEDENT
    try :
    INDENT
        checksum = sum(int(d) for d in s if d ! = ' ')
        return checksum % 10 == 0

    DEDENT
    except ValueError :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25510856_25511090_3_11
25510856_25511767_1_23
Title: Python efficiency query 
----------------------------------------

def check(s) :
INDENT
    if not re_credit.match(s) :
    INDENT
        return False
    DEDENT
    checksum = 0
    for c in s.replace(' ', '') :
    INDENT
        checksum += int(c)
    DEDENT
    if (checksum % 10) ! = 0 :
    INDENT
        return False
    DEDENT
    return True
DEDENT
----------------------------------------

def check(s) :
INDENT
    fmt = "#### #### #### ####"
    if len(s) ! = len(fmt) :
    INDENT
        return False
    DEDENT
    checksum = 0
    for f, i in zip(fmt, s) :
    INDENT
        if f == "#" :
        INDENT
            try :
            INDENT
                checksum += int(i)
            DEDENT
            except ValueError :
            INDENT
                return False
            DEDENT
        DEDENT
        elif i ! = " " :
        INDENT
            return False
        DEDENT
    DEDENT
    return not checksum % 10
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25510856_25511186_1_15
25510856_25511767_1_23
Title: Python efficiency query 
----------------------------------------

def check(s) :
INDENT
    if len(s) ! = 19 :
    INDENT
        return False
    DEDENT
    expected_spaces = (4, 9, 14)
    for idx, ch in enumerate(s) :
    INDENT
        if (ch == ' ') ! = (idx in expected_spaces) :
        INDENT
            return False
        DEDENT
    DEDENT
    try :
    INDENT
        checksum = sum(int(d) for d in s if d ! = ' ')
        return checksum % 10 == 0

    DEDENT
    except ValueError :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def check(s) :
INDENT
    fmt = "#### #### #### ####"
    if len(s) ! = len(fmt) :
    INDENT
        return False
    DEDENT
    checksum = 0
    for f, i in zip(fmt, s) :
    INDENT
        if f == "#" :
        INDENT
            try :
            INDENT
                checksum += int(i)
            DEDENT
            except ValueError :
            INDENT
                return False
            DEDENT
        DEDENT
        elif i ! = " " :
        INDENT
            return False
        DEDENT
    DEDENT
    return not checksum % 10
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25554286_25554458_4_13
25554286_25554506_3_10
Title: Python to extract unique CSV rows 
----------------------------------------

def unique() :
INDENT
    rows = list(csv.reader(open('try.csv', 'r'), delimiter = ','))
    result = collections.OrderedDict()
    for r in rows :
    INDENT
        key = (r [1], r [6])
        if key not in result :
        INDENT
            result [key] = r
        DEDENT
    DEDENT
    return result.values()
DEDENT
----------------------------------------

def unique() :
INDENT
    uniq = defaultdict(list)
    for row in csv.reader(open('try.csv', 'r'), delimiter = ',') :
    INDENT
        uniq [(row [0], row [6])].append(row)
    DEDENT
    for idx, row in uniq.iteritems() :
    INDENT
        yield row [0]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25554666_25554821_1_14
25554666_25575994_3_22
Title: How to parse a list of class objects from json text in python? 
----------------------------------------

def as_party(d) :
INDENT
    if isinstance(d, dict) :
    INDENT
        p = Party()
        p.__dict__.update(d)
    DEDENT
    elif isinstance(d, list) :
    INDENT
        out = []
        for i in d :
        INDENT
            n = Party()
            n.__dict__.update(i)
            out.append(n)
        DEDENT
        p = out
    DEDENT
    else :
    INDENT
        raise Exception('got non-dict value %s' % d)
    DEDENT
    return p
DEDENT
----------------------------------------

def as_party(d) :
INDENT
    if isinstance(d, dict) :
    INDENT
        p = Party()
        for k, v in d.iteritems() :
        INDENT
            if keyword.iskeyword(k) :
            INDENT
                raise Exception('Cannot accept %s as a property name. That is resrved python keyword' % k)
            DEDENT
            setattr(p, k, v)
        DEDENT
    DEDENT
    elif isinstance(d, list) :
    INDENT
        out = []
        for i in d :
        INDENT
            n = Party()
            for k, v in i.iteritems() :
            INDENT
                if keyword.iskeyword(k) :
                INDENT
                    raise Exception('Cannot accept %s as a property name. That is resrved python keyword' % k)
                    setattr(n, k, v)
                DEDENT
            DEDENT
            out.append(n)
        DEDENT
        p = out
    DEDENT
    else :
    INDENT
        raise Exception('got non-dict value %s' % d)
    DEDENT
    return p
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25571882_45507587_4_11
25571882_51288143_1_12
Title: pandas columns correlation with statistical significance 
----------------------------------------

def calculate_pvalues(df) :
INDENT
    df = df.dropna()._get_numeric_data()
    dfcols = pd.DataFrame(columns = df.columns)
    pvalues = dfcols.transpose().join(dfcols, how = 'outer')
    for r in df.columns :
    INDENT
        for c in df.columns :
        INDENT
            pvalues [r] [c] = round(pearsonr(df [r], df [c]) [1], 4)
        DEDENT
    DEDENT
    return pvalues
DEDENT
----------------------------------------

def calculate_pvalues(df) :
INDENT
    df = df._get_numeric_data()
    dfcols = pd.DataFrame(columns = df.columns)
    pvalues = dfcols.transpose().join(dfcols, how = 'outer')
    for r in df.columns :
    INDENT
        for c in df.columns :
        INDENT
            if c == r :
            INDENT
                df_corr = df [[r]].dropna()
            DEDENT
            else :
            INDENT
                df_corr = df [[r, c]].dropna()
            DEDENT
            pvalues [r] [c] = pearsonr(df_corr [r], df_corr [c]) [1]
        DEDENT
    DEDENT
    return pvalues
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25576469_25576517_1_9
25576469_25576568_1_15
Title: inconsistent string to int error and response 
----------------------------------------

def addition() :
INDENT
    total = 0
    while True :
    INDENT
        total += int(input())
        if input() == "exit" :
        INDENT
            break
        DEDENT
    DEDENT
    print (total)
DEDENT
----------------------------------------

def addition() :
INDENT
    total = 0
    while True :
    INDENT
        value = input()
        if value == "exit" :
        INDENT
            break
        DEDENT
        else :
        INDENT
            try :
            INDENT
                total += int(value)
            DEDENT
            except :
            INDENT
                print ('Please enter in a valid integer')
            DEDENT
        DEDENT
    DEDENT
    print (total)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25576469_25576568_1_15
25576469_25576581_1_10
Title: inconsistent string to int error and response 
----------------------------------------

def addition() :
INDENT
    total = 0
    while True :
    INDENT
        value = input()
        if value == "exit" :
        INDENT
            break
        DEDENT
        else :
        INDENT
            try :
            INDENT
                total += int(value)
            DEDENT
            except :
            INDENT
                print ('Please enter in a valid integer')
            DEDENT
        DEDENT
    DEDENT
    print (total)
DEDENT
----------------------------------------

def addition() :
INDENT
    total = 0
    while True :
    INDENT
        user_input = input()
        if user_input.strip().isalpha() and user_input.strip() == 'exit' :
        INDENT
            break
        DEDENT
        total += int(user_input)
    DEDENT
    print (total)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25608107_25608441_15_20
25608107_41599695_26_33
Title: python mock - patching a method without obstructing implementation 
----------------------------------------

def test_something(self) :
INDENT
    spud = Potato()
    with patch.object(Potato, 'foo', wraps = spud.foo) as mock :
    INDENT
        forty_two = spud.spam(n = 40)
        mock.assert_called_once_with(n = 40)
    DEDENT
    self.assertEqual(forty_two, 42)
DEDENT
----------------------------------------

def test_something(self) :
INDENT
    foo = spy_decorator(Potato.foo)
    with unittest.mock.patch.object(Potato, 'foo', foo) :
    INDENT
        forty_two = spam(n = 40)
    DEDENT
    foo.mock.assert_called_once_with(n = 40)
    self.assertEqual(forty_two, 42)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25609156_25609215_12_21
25609156_25609325_2_14
Title: "Issue with an ""is_prime"" python function on Sublime Text" 
----------------------------------------

def is_prime(n) :
INDENT
    if n < = 3 :
    INDENT
        return n > 1
    DEDENT
    if not n % 2 or not n % 3 :
    INDENT
        return False
    DEDENT
    for i in range(5, int(n ** 0.5) + 1, 6) :
    INDENT
        if not n % i or not n % (i + 2) :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def is_prime(N) :
INDENT
    if (N == 2) :
    INDENT
        print (str(N) + " is a prime")
        return True
    DEDENT
    if ((N % 2 == 0) or (N == 1)) :
    INDENT
        print (str(N) + " is not prime")
        return False
    DEDENT
    for i in range(3, int(math.sqrt(N)) + 1, 2) :
    INDENT
        if (N % i == 0) :
        INDENT
            print (str(N) + " is not prime")
            return False
        DEDENT
    DEDENT
    print (str(N) + " is prime")
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25616217_25616464_9_21
25616217_25616479_28_36
Title: Count even and odd numbers and the totals (python) 
----------------------------------------

def main() :
INDENT
    high = int(input('Enter the high integer for the range: '))
    low = int(input('Enter the low integer for the range: '))
    num = int(input('Enter the integer for the multiples: '))
    multiplies = get_multiplies(high, low, num)
    print ' '.join(str(m) for m in multiplies)
    even_count = len(filter(isEven, multiplies))
    print (even_count, 'even numbers total to')
    print (len(multiplies) - even_count, 'odd numbers total to')
DEDENT
----------------------------------------

def main() :
INDENT
    high = int(input('Enter the high integer for the range: '))
    low = int(input('Enter the low integer for the range: '))
    num = int(input('Enter the integer for the multiples: '))

    reslst = show_multiples()
    print reslst
    check_even_odd(reslst)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25616217_25616479_1_37
25616217_25617241_1_26
Title: Count even and odd numbers and the totals (python) 
----------------------------------------

def show_multiples() :
INDENT
    lst = []
    for x in range(low, high + 1) :
    INDENT
        if (x % num) == 0 :
        INDENT

            lst.append(x)
        DEDENT
    DEDENT
    return lst
    def check_even_odd(lst) :
    INDENT
        count = 0
        total = 0
        eventotal = 0
        oddtotal = 0
        for x in lst :
        INDENT
            if (x % 2) == 0 :
            INDENT
                count = count + 1
                eventotal = eventotal + x
            DEDENT
            else :
            INDENT
                total = total + 1
                oddtotal = oddtotal + x

            DEDENT
        DEDENT
        print (count, 'even numbers total to', eventotal)
        print (total, 'odd numbers total to', oddtotal)
    DEDENT
    def main() :
    INDENT
        high = int(input('Enter the high integer for the range: '))
        low = int(input('Enter the low integer for the range: '))
        num = int(input('Enter the integer for the multiples: '))

        reslst = show_multiples()
        print reslst
        check_even_odd(reslst)
    DEDENT
    main()
DEDENT
----------------------------------------

def show_multiples(low, high, num) :
INDENT
    first = high / / num * num

    multiples = list(range(first, low - 1, - num))

    odd, even = [], []
    for value in multiples :
    INDENT
        if value % 2 == 0 :
        INDENT
            even.append(value)
        DEDENT
        else :
        INDENT
            odd.append(value)
        DEDENT
    DEDENT
    print (" ".join(map(str, multiples)))
    print ("{} even numbers total {}".format(len(even), sum(even)))
    print ("{} odd numbers total {}".format(len(odd), sum(odd)))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25658717_25659121_1_17
25658717_25659141_1_16
Title: Python - deleteing words from a list 
----------------------------------------

def remove(word) :
INDENT
    removeword = input("Please enter the word you would like to remove")
    try :
    INDENT
        index = english_list.index(removeword)
        spanishword = spanish_list [index]
        english_list.remove(removeword)
        spanish_list.remove(spanishword)
        del (english_to_spanish [removeword])
        del (spanish_to_english [spanishword])
        print ("The word '%s' and '%s' has been removed from the English and Spanish list, enter 'show' to see." % (removeword, spanishword))
    DEDENT
    except ValueError :
    INDENT
        index = spanish_list.index(removeword)
        englishword = english_list [index]
        spanish_list.remove(removeword)
        english_list.remove(englishword)
        del (english_to_spanish [englishword])
        del (spanish_to_english [removeword])
    DEDENT
DEDENT
----------------------------------------

def remove(word) :
INDENT
    removeword = input("Please enter the word you would like to remove")
    spanishword = ""
    index = english_list.index(removeword)
    if (index) :
    INDENT
        spanishword = spanish_list [index]
    DEDENT
    else :
    INDENT
        index = spanish_list.index(removeword)
        spanishword = removeword
        removeword = english_list [index]
    DEDENT
    english_list.remove(removeword)
    spanish_list.remove(spanishword)
    del (english_to_spanish [removeword])
    del (spanish_to_english [spanishword])
    print ("The word '%s' and '%s' has been removed from the English and Spanish list, enter 'show' to see." % (removeword, spanishword))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25666894_25670050_12_25
25666894_25788075_2_13
Title: Get a 3D or 4D array as input and reshape it to 2D array in a function from external script 
----------------------------------------

def frontend(data) :
INDENT
    dimensions = len(data [0])

    if dimensions == 4 :
    INDENT
        return [[x * y * z, t] for x, y, z, t in data]
    DEDENT
    elif dimensions == 3 :
    INDENT
        return [[x * y, t] for x, y, t in data]
    DEDENT
    else :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def frontend(data) :
INDENT
    if data.ndim == 4 :
    INDENT
        data = data.reshape([data.shape [0] * data.shape [1] * data.shape [2], data.shape [3]])
        return data
    DEDENT
    elif data.ndim == 3 :
    INDENT
        data = data.reshape([data.shape [0] * data.shape [1], data.shape [2]])
        return data
    DEDENT
    elif data.ndim == 2 :
    INDENT
        return data
    DEDENT
    else :
    INDENT
        text = 'unrecognized shape'
        print str(text)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25686900_25857532_14_22
25686900_27904843_13_22
Title: pip install misses some generated files when writing installed-files.txt 
----------------------------------------

def run(self) :
INDENT
    if not self.dry_run :
    INDENT
        target_dir = os.path.join(self.build_lib, "install-entry-missing")
        self.mkpath(target_dir)
        touch(os.path.join(target_dir, "my_file.txt"))
    DEDENT
    build_py.run(self)

DEDENT
----------------------------------------

def run(self) :
INDENT
    self.my_outputs = []
    if not self.dry_run :
    INDENT
        target_dir = os.path.join(self.build_lib, "install-entry-missing")
        self.mkpath(target_dir)
        output = os.path.join(target_dir, "my_file.txt")
        touch(output)
        self.my_outputs.append(output)
    DEDENT
    build_py.run(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25691484_25692629_59_72
25691484_25692629_5_48
Title: How to show and hide QtGui.QGridLayout in PySide 
----------------------------------------

def __init__(self, parent = None, total = 20) :
INDENT
    super(NewTimeSliderTest, self).__init__(parent)
    self.newTimeSlider = TimeSlider()
    self.resize(841, 474)
    self.newTimeSlider.hide()
    self.button = QtGui.QPushButton('Show/Hide')
    self.button.clicked.connect(self.handleButton)
    main_layout = QtGui.QGridLayout()
    main_layout.addWidget(self.button, 0, 0)
    main_layout.addLayout(self.newTimeSlider, 0, 1)
    self.setLayout(main_layout)
    self.setWindowTitle('Test')
    self._active = False
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QVBoxLayout.__init__(self)
    _manLayout = QtGui.QVBoxLayout()
    self._frame = QtGui.QFrame();
    _manLayout.addWidget(self._frame)
    _grid = QtGui.QGridLayout(self._frame)

    _grid.addWidget(QtGui.QLabel(''), 0, 0)
    _labelLayout = QtGui.QHBoxLayout()
    _grid.addLayout(_labelLayout, 0, 1)
    self.lower = QtGui.QLabel('LOW')

    _labelLayout.addWidget(self.lower)
    self.higher = QtGui.QLabel('HIGH')
    self.higher.setAlignment(QtCore.Qt.AlignRight | QtCore.Qt.AlignVCenter)
    _labelLayout.addWidget(self.higher)

    _grid.addWidget(QtGui.QLabel(''), 1, 0)
    self.sliderBarLayout = QtGui.QHBoxLayout()
    self.sliderBarLayout.setSpacing(0)
    _grid.addLayout(self.sliderBarLayout, 1, 1)

    self.slider = QtGui.QSlider(QtCore.Qt.Horizontal)
    self.slider.setTickPosition(QtGui.QSlider.TicksBelow)
    self.slider.setTracking(True)
    self.slider.setMinimumWidth(40)
    self.slider.setPageStep(1)
    self.sliderBarLayout.addWidget(self.slider)
    self._frame.setLayout(_grid)
    self.addLayout(_manLayout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25706885_25706932_7_13
25706885_25706933_1_11
Title: Generator function for prime numbers 
----------------------------------------

def getPrimes(n) :
INDENT
    yield 2
    i = 1
    while i < = n - 2 :
    INDENT
        i += 2
        if isprime(i) :
        INDENT
            yield i
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def getPrimes(n) :
INDENT
    i = 2
    while i < n :
    INDENT
        prime = True
        for a in xrange(2, i) :
        INDENT
            if i % a == 0 :
            INDENT
                prime = False
                break
            DEDENT
        DEDENT
        if prime :
        INDENT
            yield i
        DEDENT
        i += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25706885_25706932_7_13
25706885_25706980_1_10
Title: Generator function for prime numbers 
----------------------------------------

def getPrimes(n) :
INDENT
    yield 2
    i = 1
    while i < = n - 2 :
    INDENT
        i += 2
        if isprime(i) :
        INDENT
            yield i
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def getPrimes(n) :
INDENT
    yield 2
    i = 3
    while i < n :
    INDENT
        for a in getPrimes(int(math.sqrt(i)) + 1) :
        INDENT
            if i % a == 0 :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            yield i
        DEDENT
        i += 2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25746759_25746815_17_26
25746759_25746815_8_15
Title: Initializing instance variable: Idiomatic way 
----------------------------------------

def __init__(self, street, length, ltype, use, a, b, ab, ba) :
INDENT
    self.street = street
    self.length = length
    self.ltype = ltype
    self.use = use
    self.a = a
    self.b = b
    self.ab = ab
    self.ba = ba
DEDENT
----------------------------------------

def __init__(self, lanes, left, right, speed, fspd, capacity) :
INDENT
    self.lanes = lanes
    self.left = left
    self.right = right
    self.speed = speed
    self.fspd = fspd
    self.capacity = capacity
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25763814_25765009_6_15
25763814_25813935_6_22
Title: "5*5 grid in every 3*3 square of the grid must be 4 ""lights""" 
----------------------------------------

def check(g) :
INDENT
    for r in range(3) :
    INDENT
        for c in range(3) :
        INDENT
            s = (nbits [7 & (g [r + 0] >> (2 - c))]
                + nbits [7 & (g [r + 1] >> (2 - c))]
                + nbits [7 & (g [r + 2] >> (2 - c))])
            if s ! = 4 :
            INDENT
                return False
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def check(grid) :
INDENT
    count = 0
    for row in range(3) :
    INDENT
        for column in range(3) :
        INDENT
            s = 0
            for right in range(3) :
            INDENT
                for down in range(3) :
                INDENT
                    if grid [row + right] [column + down] == 1 :
                    INDENT
                        s += 1
                        if s == 4 :
                        INDENT
                            count += 1
                        DEDENT
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    if count ! = 9 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        return True

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25769837_25770358_1_15
25769837_28859454_2_19
Title: Need help on Python 
----------------------------------------

def isPangram(s) :
INDENT
    alphabetList = 'abcdefghijklmnopqrstuvwxyz'
    alphabetCount = 0
    if len(s) < 26 :
    INDENT
        print "False 1"
    DEDENT
    else :
    INDENT
        s = re.sub('[^a-zA-Z]', '', s).lower()
        for i in range(len(alphabetList)) :
        INDENT
            if alphabetList [i] in s :
            INDENT
                alphabetCount = alphabetCount + 1
            DEDENT
        DEDENT
        if alphabetCount == 26 :
        INDENT
            print "True"
        DEDENT
        else :
        INDENT
            print "False"
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def isPangram(s) :
INDENT
    alphabetList = 'abcdefghijklmnopqrstuvwxyz'
    alphabetCount = 0
    if len(s) < 26 :
    INDENT
        print ('lenth is short')
        return False
    DEDENT
    else :
    INDENT
        s = re.sub('[^a-zA-Z]', '', s).lower()
        print (s)
        for i in range(len(alphabetList)) :
        INDENT
            if alphabetList [i] in s :
            INDENT
                print (alphabetList [i])
                print ("The string is pangram2")
                alphabetCount = alphabetCount + 1
                print (alphabetCount)
                if alphabetCount > = 26 :
                INDENT
                    print ("The string is pangram")
                    return True
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25772750_35678092_3_19
25772750_51901790_3_20
Title: Sierpinski triangle recursion using turtle graphics 
----------------------------------------

def sier(side, level) :
INDENT
    if level == 1 :
    INDENT
        for i in range(3) :
        INDENT
            turtle.fd(side)
            turtle.left(120)
        DEDENT
    DEDENT
    else :
    INDENT
        sier(side / 2, level - 1)
        turtle.fd(side / 2)
        sier(side / 2, level - 1)
        turtle.bk(side / 2)
        turtle.left(60)
        turtle.fd(side / 2)
        turtle.right(60)
        sier(side / 2, level - 1)
        turtle.left(60)
        turtle.bk(side / 2)
        turtle.right(60)
    DEDENT
DEDENT
----------------------------------------

def sier(tur, order, size) :
INDENT
    if order == 0 :
    INDENT
        for _ in range(3) :
        INDENT
            tur.forward(size)
            tur.left(120)
        DEDENT
    DEDENT
    else :
    INDENT
        step = size / 2
        for t1, m1, t2, m2 in [(0, step, 0, 0),
            (120, step, - 120, 0),
            (- 60, step, 60, - (step))] :
        INDENT
            sier(tur, order - 1, step)
            tur.left(t1)
            tur.forward(m1)
            tur.left(t2)
            tur.forward(m2)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25787412_25789984_1_13
25787412_25791388_2_9
Title: create a function in python to convert form keys into three diferrent json objects 
----------------------------------------

def convert_form_to_json_object(self, form, keys_to_ignore = None) :
INDENT
    json_obj = {}
    i = 0
    for key in form :
    INDENT
        k = key + "_" + str(i)
        if keys_to_ignore is not None :
        INDENT
            if key not in keys_to_ignore :
            INDENT
                json_obj [k] = form [key]
            DEDENT
        DEDENT
        else :
        INDENT
            json_obj [k] = form [key]
        DEDENT
    DEDENT
    i += 1
    return json_obj
DEDENT
----------------------------------------

def convert_form_to_json_object(form, keys_to_ignore = ()) :
INDENT
    json_obj = {}
    for key in form :
    INDENT
        if key not in keys_to_ignore :
        INDENT
            json_obj [key] = json.dumps(form [key])
        DEDENT
    DEDENT
    return json_obj

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25797471_25797774_13_21
25797471_25798769_3_11
Title: Context manager to validate data 
----------------------------------------

def validator(validate_func) :
INDENT
    func = partial(patched, validate_func, input)
    patch = unittest.mock.patch('builtins.input', func)
    patch.start()
    try :
    INDENT
        yield
    DEDENT
    finally :
    INDENT
        patch.stop()
    DEDENT
DEDENT
----------------------------------------

def validator(test) :
INDENT
    def wrap(func) :
    INDENT
        def wrapped(* args, ** kwargs) :
        INDENT
            result = func(* args, ** kwargs)
            if test(result) :
            INDENT
                return result
            DEDENT
            return None
        DEDENT
        return wrapped
    DEDENT
    return wrap
DEDENT
----------------------------------------
