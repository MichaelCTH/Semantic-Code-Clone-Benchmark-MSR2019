$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27875256_27875446_6_24
27875256_27888801_22_41
Title: Trace radiobutton value defined in child class and pass it to parent class in Python 
----------------------------------------

def __init__(self, root) :
INDENT
    tk.Frame.__init__(self, root)
    root.title("Parent Window")
    root.geometry("400x200")
    tk.Label(self, text = "First").grid(row = 0)
    tk.Label(self, text = "Second").grid(row = 1)
    e1 = tk.Entry(self)
    e2 = tk.Entry(self)
    e1.grid(row = 0, column = 1)
    e2.grid(row = 1, column = 1)
    button = tk.Button(self, text = "Create", width = 10, command = self.create_new_window)
    button.grid(row = 2, column = 0, sticky = tk.E + tk.W)
    self.grid()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.master.title("Child Window")
    self.frame.grid()
    self._var = IntVar()
    self._var.set(0)
    self._var.trace("w", self.trace_fun)
    self._radioButton = tk.Radiobutton(self.frame, text = "Option 1", variable = self._var, value = 1)
    self._radioButton.grid(row = 0, column = 0, sticky = W, padx = 10, pady = 10)
    self._radioButton2 = tk.Radiobutton(self.frame, text = "Option 2", variable = self._var, value = 2)
    self._radioButton2.grid(row = 1, column = 0, sticky = W, padx = 10, pady = 10)
    self._button = tk.Button(self.frame, text = 'Ok', command = self.master.destroy)
    self._button.grid(row = 2, column = 0, pady = 10)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27875256_27875446_6_24
27875256_27888801_6_15
Title: Trace radiobutton value defined in child class and pass it to parent class in Python 
----------------------------------------

def __init__(self, root) :
INDENT
    tk.Frame.__init__(self, root)
    root.title("Parent Window")
    root.geometry("400x200")
    tk.Label(self, text = "First").grid(row = 0)
    tk.Label(self, text = "Second").grid(row = 1)
    e1 = tk.Entry(self)
    e2 = tk.Entry(self)
    e1.grid(row = 0, column = 1)
    e2.grid(row = 1, column = 1)
    button = tk.Button(self, text = "Create", width = 10, command = self.create_new_window)
    button.grid(row = 2, column = 0, sticky = tk.E + tk.W)
    self.grid()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.master.title("Parent Window")
    self.master.geometry("400x100")
    self.frame.grid()
    self._button = tk.Button(self.frame, text = "Create", width = 10, command = self.new_window)
    self._button.grid(row = 0, column = 0, sticky = tk.E + tk.W)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27875256_27888801_22_41
27875256_27888801_6_15
Title: Trace radiobutton value defined in child class and pass it to parent class in Python 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.master.title("Child Window")
    self.frame.grid()
    self._var = IntVar()
    self._var.set(0)
    self._var.trace("w", self.trace_fun)
    self._radioButton = tk.Radiobutton(self.frame, text = "Option 1", variable = self._var, value = 1)
    self._radioButton.grid(row = 0, column = 0, sticky = W, padx = 10, pady = 10)
    self._radioButton2 = tk.Radiobutton(self.frame, text = "Option 2", variable = self._var, value = 2)
    self._radioButton2.grid(row = 1, column = 0, sticky = W, padx = 10, pady = 10)
    self._button = tk.Button(self.frame, text = 'Ok', command = self.master.destroy)
    self._button.grid(row = 2, column = 0, pady = 10)
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(self.master)
    self.master.title("Parent Window")
    self.master.geometry("400x100")
    self.frame.grid()
    self._button = tk.Button(self.frame, text = "Create", width = 10, command = self.new_window)
    self._button.grid(row = 0, column = 0, sticky = tk.E + tk.W)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27894777_27894969_16_27
27894777_27894969_39_47
Title: Bullets not showing up when trying to fire in pygame 
----------------------------------------

def __init__(self, x, y, xc, yc, w, h, angle, img, lives, direc) :
INDENT
    self.x = x
    self.y = y
    self.xc = xc
    self.yc = yc
    self.w = w
    self.h = h
    self.img = img
    self.lives = lives
    self.angle = angle
    self.direc = direc
DEDENT
----------------------------------------

def __init__(self, x, y, xc, yc, w, h, img) :
INDENT
    self.x = x
    self.y = y
    self.xc = xc
    self.yc = yc
    self.w = w
    self.h = h
    self.img = img
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27904784_27905611_3_19
27904784_27905645_3_20
Title: move along/replace certain rows csv python 
----------------------------------------

def update_scores(name, new_score) :
INDENT
    new_file = []
    with open('scores.csv', 'rb') as f :
    INDENT
        reader = csv.reader(f)
        for line in reader :
        INDENT
            if line [0] == name :
            INDENT
                highest = max(int(new_score), int(line [1]), int(line [2]))
                avg = round((int(new_score) + int(line [1]) + int(line [2])) / 3.00, 2)
                new_file.append([line [0], new_score, line [1], line [2], highest, avg])
            DEDENT
            else :
            INDENT
                new_file.append(line)
            DEDENT
        DEDENT
    DEDENT
    with open('scores.csv', 'wb') as f :
    INDENT
        writer = csv.writer(f)
        for line in new_file :
        INDENT
            writer.writerow(line)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def update_scores(new_scores) :
INDENT
    rows = []
    with open('quiz.csv', 'r') as f :
    INDENT
        reader = csv.reader(f)
        next(reader)
        for row in reader :
        INDENT
            if row [0] in new_scores :
            INDENT
                updated_scores = [new_scores [row [0]], int(row [1]), int(row [2])]
                highest = max(updated_scores)
                avg = sum(updated_scores) / float(len(updated_scores))
                rows.append([row [0]] + updated_scores + [highest, '%.1f' % avg])
            DEDENT
            else :
            INDENT
                rows.append(row)
            DEDENT
        DEDENT
    DEDENT
    with open('quiz.csv', 'w') as f :
    INDENT
        writer = csv.writer(f)
        writer.writerow(['name', 'score1', 'score2', 'score3', 'highest', 'avg'])
        writer.writerows(rows)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27912308_27912525_18_24
27912308_27912702_3_18
Title: How can you slice with string keys instead of integers on a python OrderedDict? 
----------------------------------------

def __getitem__(self, key) :
INDENT
    if isinstance(key, slice) :
    INDENT
        items = self.items()
        index_slice = _key_slice_to_index_slice(items, key)
        return SlicableDict(items [index_slice])
    DEDENT
    return super(SlicableDict, self).__getitem__(key)
DEDENT
----------------------------------------

def __getitem__(self, key) :
INDENT
    if isinstance(key, slice) :
    INDENT
        tmp = OrderedDict()
        i_self = iter(self)
        for k in i_self :
        INDENT
            if key.start < = k < = key.stop :
            INDENT
                tmp [k] = self [k]
                if key.step is not None and key.step > 1 :
                INDENT
                    for _ in range(key.step - 1) :
                    INDENT
                        try :
                        INDENT
                            next(i_self)
                        DEDENT
                        except StopIteration :
                        INDENT
                            break
                        DEDENT
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
        return tmp
    DEDENT
    else :
    INDENT
        return super(SliceOrdered, self).__getitem__(key)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27912308_27912525_18_24
27912308_27912838_4_34
Title: How can you slice with string keys instead of integers on a python OrderedDict? 
----------------------------------------

def __getitem__(self, key) :
INDENT
    if isinstance(key, slice) :
    INDENT
        items = self.items()
        index_slice = _key_slice_to_index_slice(items, key)
        return SlicableDict(items [index_slice])
    DEDENT
    return super(SlicableDict, self).__getitem__(key)
DEDENT
----------------------------------------

def __getitem__(self, key) :
INDENT
    if isinstance(key, slice) :
    INDENT

        root = getattr(self, "_OrderedDict__root")
        start, end = root [1] [2], root [0] [2]
        start = key.start or start
        end = key.stop or end
        step = key.step or 1
        curr, result, begun, counter = root [1], [], False, 0

        curr, result, begun = root [1], [], False
        while curr is not root :
        INDENT
            if curr [2] == end :
            INDENT
                break
            DEDENT
            if curr [2] == start :
            INDENT
                begun = True
            DEDENT
            if begun :
            INDENT
                if counter % step == 0 :
                INDENT
                    result.append((curr [2], self [curr [2]]))
                DEDENT
                counter += 1

            DEDENT
            curr = curr [1]
        DEDENT
        return result
    DEDENT
    return super(SlicableDict, self).__getitem__(key)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27912308_27912702_3_18
27912308_27912838_4_34
Title: How can you slice with string keys instead of integers on a python OrderedDict? 
----------------------------------------

def __getitem__(self, key) :
INDENT
    if isinstance(key, slice) :
    INDENT
        tmp = OrderedDict()
        i_self = iter(self)
        for k in i_self :
        INDENT
            if key.start < = k < = key.stop :
            INDENT
                tmp [k] = self [k]
                if key.step is not None and key.step > 1 :
                INDENT
                    for _ in range(key.step - 1) :
                    INDENT
                        try :
                        INDENT
                            next(i_self)
                        DEDENT
                        except StopIteration :
                        INDENT
                            break
                        DEDENT
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
        return tmp
    DEDENT
    else :
    INDENT
        return super(SliceOrdered, self).__getitem__(key)
    DEDENT
DEDENT
----------------------------------------

def __getitem__(self, key) :
INDENT
    if isinstance(key, slice) :
    INDENT

        root = getattr(self, "_OrderedDict__root")
        start, end = root [1] [2], root [0] [2]
        start = key.start or start
        end = key.stop or end
        step = key.step or 1
        curr, result, begun, counter = root [1], [], False, 0

        curr, result, begun = root [1], [], False
        while curr is not root :
        INDENT
            if curr [2] == end :
            INDENT
                break
            DEDENT
            if curr [2] == start :
            INDENT
                begun = True
            DEDENT
            if begun :
            INDENT
                if counter % step == 0 :
                INDENT
                    result.append((curr [2], self [curr [2]]))
                DEDENT
                counter += 1

            DEDENT
            curr = curr [1]
        DEDENT
        return result
    DEDENT
    return super(SlicableDict, self).__getitem__(key)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27928275_27928411_22_33
27928275_27975633_16_52
Title: Find p-value (significance) in scikit-learn LinearRegression 
----------------------------------------

def fit(self, X, y, n_jobs = 1) :
INDENT
    self = super(LinearRegression, self).fit(X, y, n_jobs)
    sse = np.sum((self.predict(X) - y) ** 2, axis = 0) / float(X.shape [0] - X.shape [1])
    se = np.array([
            np.sqrt(np.diagonal(sse [i] * np.linalg.inv(np.dot(X.T, X)))) for i in range(sse.shape [0])
            ])
    self.t = self.coef_ / se
    self.p = 2 * (1 - stats.t.cdf(np.abs(self.t), y.shape [0] - X.shape [1]))
    return self
DEDENT
----------------------------------------

def fit(self, x, y) :
INDENT
    self = super(LinearRegression, self).fit(x, y)
    n, k = x.shape
    yHat = np.matrix(self.predict(x)).T

    x = np.hstack((np.ones((n, 1)), np.matrix(x)))
    y = np.matrix(y).T

    df = float(n - k - 1)

    sse = np.sum(np.square(yHat - y), axis = 0)
    self.sampleVariance = sse / df

    self.sampleVarianceX = x.T * x

    self.covarianceMatrix = sc.linalg.sqrtm(self.sampleVariance [0, 0] * self.sampleVarianceX.I)

    self.se = self.covarianceMatrix.diagonal() [1 :]

    self.betasTStat = np.zeros(len(self.se))
    for i in xrange(len(self.se)) :
    INDENT
        self.betasTStat [i] = self.coef_ [0, i] / self.se [i]

    DEDENT
    self.betasPValue = 1 - t.cdf(abs(self.betasTStat), df)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27929001_27929035_1_13
27929001_27929429_1_10
Title: Python function not hitting the entire for loop 
----------------------------------------

def two_pair(ranks) :
INDENT
    if len(set(ranks)) ! = 3 :
    INDENT
        return None
    DEDENT
    pairs = []
    preceding = None
    for card in ranks :
    INDENT
        if card == preceding :
        INDENT
            pairs.append(card)
        DEDENT
        preceding = card
    DEDENT
    return tuple(pairs)
DEDENT
----------------------------------------

def two_pair(ranks) :
INDENT
    newlist = []
    for i in set(ranks) :
    INDENT
        if ranks.count(i) == 2 :
        INDENT
            newlist.append(i)
        DEDENT
    DEDENT
    newlist.sort(reverse = True)
    newlist = tuple(newlist)
    return None if newlist == () else newlist
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27957426_27957794_25_33
27957426_27957794_4_12
Title: Python Tkinter Input Box 
----------------------------------------

def __init__(self, parent, ** kwargs) :
INDENT
    super().__init__(parent, ** kwargs)
    self.pack()
    self.myLabel1 = tk.Label(parent, text = 'Click OK to enter the group name')
    self.myLabel1.pack()
    self.mySubmitButton1 = tk.Button(parent, text = 'OK', command = self.get_group_name)
    self.mySubmitButton1.pack()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    top = self.top = tk.Toplevel(parent)
    self.myLabel = tk.Label(top, text = 'Enter a Grouping Name')
    self.myLabel.pack()
    self.myEntryBox = tk.Entry(top)
    self.myEntryBox.focus_set()
    self.myEntryBox.pack()
    self.mySubmitButton = tk.Button(top, text = 'OK', command = self.DestWin)
    self.mySubmitButton.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
27962323_27962490_3_29
27962323_27963087_1_11
Title: Assertion python 
----------------------------------------

def count_inversion(sequence) :
INDENT
    global result
    global counter
    """
       Count inversions in a sequence of numbers
    """
    sequence = list(sequence)
    if len(sequence) == 1 :
    INDENT
        result.append(sequence [0])
        if result == sorted(result) :
        INDENT
            result = []
            return_counter = counter
            counter = 0
            return return_counter
        DEDENT
        else :
        INDENT
            sequence = result
            result = []
            return count_inversion(sequence)
        DEDENT
    DEDENT
    if sequence [0] > sequence [1] :
    INDENT
        result.append(sequence.pop(1))
        counter += 1
        return count_inversion(sequence)
    DEDENT
    else :
    INDENT
        result.append(sequence [0])
        return count_inversion(sequence [1 :])
    DEDENT
DEDENT
----------------------------------------

def count_inversion(sequence, current = (), counter = 0) :
INDENT
    if len(sequence) < 2 :
    INDENT
        current += sequence
        if list(current) == sorted(current) :
        INDENT
            return counter
        DEDENT
        return count_inversion(current, (), counter)
    DEDENT
    index = sequence [0] > sequence [1]
    return count_inversion(sequence [: index] + sequence [index + 1 :],
        current + sequence [index : index + 1],
        counter + index)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28007727_28007763_5_14
28007727_28007790_5_12
Title: """Unexpected EOF while parsing"" after a ""try"" statement" 
----------------------------------------

def prompt_sta() :
INDENT
    prompt_0 = raw_input("Input a Command: ")
    try :
    INDENT
        if prompt_0 == 'Okay' :
        INDENT
            next_screen()
        DEDENT
        else :
        INDENT
            print ('Type Okay.')
            prompt_sta()
        DEDENT
    DEDENT
    except Exception as ex :
    INDENT
        print (ex)
    DEDENT
DEDENT
----------------------------------------

def prompt_sta() :
INDENT
    prompt_0 = raw_input("Input a Command: ")
    if prompt_0 == 'Okay' :
    INDENT
        next_screen()
    DEDENT
    else :
    INDENT
        print ('Type Okay.')
        prompt_sta()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28044902_28044977_11_19
28044902_28044977_21_29
Title: Setters and Getters python 
----------------------------------------

def type(self) :
INDENT
    return {
        "Patrol boat" : 0,
        "Destroyer" : 1,
        "Submarine" : 2,
        "Battleship" : 3,
        "Aircraft carrier" : 4,
        }.get(self._type, 0)
DEDENT
----------------------------------------

def type(self, type) :
INDENT
    self._type = {
        0 : "Patrol boat",
        1 : "Destroyer",
        2 : "Submarine",
        3 : "Battleship",
        4 : "Aircraft carrier",
        }.get(type, "Patrol boat")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28061720_28061797_23_31
28061720_45431645_24_41
Title: Attempt at Infinite Monkey theorem using Python 
----------------------------------------

def main() :
INDENT
    run = 0
    curScore = 0
    while not (curScore == 100) :
    INDENT
        curScore = score()
        if (curScore ! = 0) :
        INDENT
            print (run, " = ", curScore)
        DEDENT
        run = run + 1;
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    pwd = 'methinks it is like a weasel'
    score = best_score = count = 0
    best_guess = ""
    while (best_score < len(pwd)) :
    INDENT
        iter = generate(len(pwd) - best_score)
        score = score_me(iter, pwd [best_score :])
        if score > 0 :
        INDENT
            best_score += score
            best_guess += iter [: score]
        DEDENT
        count = count + 1
        print (best_guess)
    DEDENT
    print ("Total runs: ", count)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28061720_28061797_23_31
28061720_49572474_25_43
Title: Attempt at Infinite Monkey theorem using Python 
----------------------------------------

def main() :
INDENT
    run = 0
    curScore = 0
    while not (curScore == 100) :
    INDENT
        curScore = score()
        if (curScore ! = 0) :
        INDENT
            print (run, " = ", curScore)
        DEDENT
        run = run + 1;
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    goal = "methinks it is like a weasel"
    goalList = [goal [i] for i in range(len(goal))]
    clist = [' ' for i in range(len(goal))]
    randList = randomGen(goalList)
    clist = common_elements(clist, goalList, randList)
    score = scoreRand(goalList, clist)
    totalIteration = 0
    while (score < 1) :
    INDENT
        newrandList = randomGen(goalList)
        newclist = common_elements(clist, goalList, randList)
        newscore = scoreRand(goalList, clist)
        score = newscore
        randList = newrandList
        clist = newclist
        totalIteration = totalIteration + 1
        print (score, " : ", ''.join(clist))
    DEDENT
    print ("Total iterations: ", totalIteration)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28061720_45431645_24_41
28061720_49572474_25_43
Title: Attempt at Infinite Monkey theorem using Python 
----------------------------------------

def main() :
INDENT
    pwd = 'methinks it is like a weasel'
    score = best_score = count = 0
    best_guess = ""
    while (best_score < len(pwd)) :
    INDENT
        iter = generate(len(pwd) - best_score)
        score = score_me(iter, pwd [best_score :])
        if score > 0 :
        INDENT
            best_score += score
            best_guess += iter [: score]
        DEDENT
        count = count + 1
        print (best_guess)
    DEDENT
    print ("Total runs: ", count)
DEDENT
----------------------------------------

def main() :
INDENT
    goal = "methinks it is like a weasel"
    goalList = [goal [i] for i in range(len(goal))]
    clist = [' ' for i in range(len(goal))]
    randList = randomGen(goalList)
    clist = common_elements(clist, goalList, randList)
    score = scoreRand(goalList, clist)
    totalIteration = 0
    while (score < 1) :
    INDENT
        newrandList = randomGen(goalList)
        newclist = common_elements(clist, goalList, randList)
        newscore = scoreRand(goalList, clist)
        score = newscore
        randList = newrandList
        clist = newclist
        totalIteration = totalIteration + 1
        print (score, " : ", ''.join(clist))
    DEDENT
    print ("Total iterations: ", totalIteration)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28077905_28078228_1_12
28077905_28078318_1_25
Title: How would I edit the following Python function so that I can easily append an array with additional tokens? 
----------------------------------------

def calculate_total(symbols) :
INDENT
    def find(name) :
    INDENT
        syms = [s for s in symbols if s.name == name]
        if len(syms) == 0 : return None
        return syms [0]
    DEDENT
    mainTotalSymbol = find('## Main Total')
    firstSymbol = find('## First Component')
    secondSymbol = find('## Second Component')
    thirdSymbol = find('## Third Component')
    return mainTotalSymbol.metrics ['% InclusiveTotal'] - firstSymbol.metrics ['% InclusiveTotal'] - secondSymbol.metrics ['% InclusiveTotal'] - thirdSymbol.metrics ['% InclusiveTotal']
DEDENT
----------------------------------------

def calculate_total(
symbols,
terms = {

    "## Main Total" : + 1,
    "## First Component" : - 1,
    "## Second Component" : - 1,
    "## Third Component" : - 1
    },
get_key = lambda s : s.name,
get_value = lambda s : s.metrics ['% InclusiveTotal']
) :
INDENT
    seen = set()
    total = 0
    for symbol in symbols :
    INDENT
        key = get_key(symbol)
        if key in terms and key not in seen :
        INDENT
            sign = terms [key]
            total += sign * get_value(symbol)
            seen.add(key)
            if len(seen) == len(terms) :
            INDENT
                return total
            DEDENT
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28077905_28078228_1_12
28077905_28078361_1_12
Title: How would I edit the following Python function so that I can easily append an array with additional tokens? 
----------------------------------------

def calculate_total(symbols) :
INDENT
    def find(name) :
    INDENT
        syms = [s for s in symbols if s.name == name]
        if len(syms) == 0 : return None
        return syms [0]
    DEDENT
    mainTotalSymbol = find('## Main Total')
    firstSymbol = find('## First Component')
    secondSymbol = find('## Second Component')
    thirdSymbol = find('## Third Component')
    return mainTotalSymbol.metrics ['% InclusiveTotal'] - firstSymbol.metrics ['% InclusiveTotal'] - secondSymbol.metrics ['% InclusiveTotal'] - thirdSymbol.metrics ['% InclusiveTotal']
DEDENT
----------------------------------------

def calculate_total(symbols, names) :
INDENT
    all_symbols = []
    for name in names :
    INDENT
        tot_symbol = next((s for s in symbols if s.name == name), None)
        if tot_symbol == None :
        INDENT
            return None
        DEDENT
        all_symbols.append(tot_symbol.metrics ['% InclusiveTotal'])
    DEDENT
    return all_symbols [0] - sum(all_symbols [1 :])

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28077905_28078318_1_25
28077905_28078361_1_12
Title: How would I edit the following Python function so that I can easily append an array with additional tokens? 
----------------------------------------

def calculate_total(
symbols,
terms = {

    "## Main Total" : + 1,
    "## First Component" : - 1,
    "## Second Component" : - 1,
    "## Third Component" : - 1
    },
get_key = lambda s : s.name,
get_value = lambda s : s.metrics ['% InclusiveTotal']
) :
INDENT
    seen = set()
    total = 0
    for symbol in symbols :
    INDENT
        key = get_key(symbol)
        if key in terms and key not in seen :
        INDENT
            sign = terms [key]
            total += sign * get_value(symbol)
            seen.add(key)
            if len(seen) == len(terms) :
            INDENT
                return total
            DEDENT
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def calculate_total(symbols, names) :
INDENT
    all_symbols = []
    for name in names :
    INDENT
        tot_symbol = next((s for s in symbols if s.name == name), None)
        if tot_symbol == None :
        INDENT
            return None
        DEDENT
        all_symbols.append(tot_symbol.metrics ['% InclusiveTotal'])
    DEDENT
    return all_symbols [0] - sum(all_symbols [1 :])

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28078092_28246994_1_17
28078092_33076951_1_10
Title: Django Rest Framework writable nested serializers 
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    ingredients_data = validated_data.pop('ingredients')
    instance.name = validated_data.get('name', instance.name)
    instance.description = validated_data.get('description', instance.description)
    instance.directions = validated_data.get('directions', instance.directions)
    instance.photo = validated_data.get('photo', instance.photo)
    ingredients_list = []
    for ingredient in ingredients_data :
    INDENT
        ingredient, created = Ingredient.objects.get_or_create(name = ingredient ["name"])
        ingredients_list.append(ingredient)
    DEDENT
    instance.ingredients = ingredients_list
    instance.save()
    return instance
DEDENT
----------------------------------------

def update(self, instance, validated_data) :
INDENT
    ingredients_data = validated_data.pop('ingredients')
    instance.name = validated_data ['name']
    instance.description = validated_data ['description']
    instance.directions = validated_data ['directions']
    for ingredient in ingredients_data :
    INDENT
        ingredient, created = Ingredient.objects.get_or_create(name = ingredient ['name'])
        recipe.ingredients.add(ingredient)
    DEDENT
    return instance
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2809122_3023530_21_29
2809122_47349875_32_38
Title: How to show raw_id value of a ManyToMany relation in the Django admin? 
----------------------------------------

def formfield_for_dbfield(self, db_field, ** kwargs) :
INDENT
    if db_field.name in ('foo', 'bar') :
    INDENT
        try :
        INDENT
            del kwargs ['request']
        DEDENT
        except KeyError :
        INDENT
            pass
        DEDENT
        kwargs ['widget'] = VerboseManyToManyRawIdWidget(db_field.rel)
        return db_field.formfield(** kwargs)
    DEDENT
    return super(MyAdmin, self).formfield_for_dbfield(db_field, ** kwargs)
DEDENT
----------------------------------------

def formfield_for_dbfield(self, db_field, ** kwargs) :
INDENT
    if db_field.name in self.raw_id_fields :
    INDENT
        kwargs.pop('request', None)
        if db_field.rel.__class__.__name__ == 'ManyToManyRel' :
        INDENT
            kwargs ['widget'] = VerboseManyToManyRawIdWidget(db_field.rel, site)
        DEDENT
        return db_field.formfield(** kwargs)
    DEDENT
    return super().formfield_for_dbfield(db_field, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28115607_28115924_3_16
28115607_28116480_1_17
Title: how do I display the elements in the slice all on one line separated by a single space and sorted in highest to lowest order 
----------------------------------------

def main() :
INDENT
    nums = []
    for i in range(7) :
    INDENT
        nums.append(random.randrange(20, 80))
    DEDENT
    print nums
    print ("The highest number is"), max(nums)
    print ("The lowest number is"), min(nums)
    print ("The middle 5 sorted from high to low:")
    print (sorted(nums) [1 : - 1])
DEDENT
----------------------------------------

def main() :
INDENT
    import random
    nums = []
    for i in range(7) :
    INDENT
        nums.append(random.randrange(20, 80))
        result = nums
    DEDENT
    print (result)
    print ("The highest number is ", max(result))
    print ("The lowest number is ", min(result))
    print ("The middle 5 sorted high to low:")
    process(result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28131446_28131507_4_8
28131446_28132100_4_9
Title: Get nested arrays out of a dictionary 
----------------------------------------

def nodeRecursiveMap(d, node_path) :
INDENT
    for key, val in d.items() :
    INDENT
        if type(val) is not dict : node_map ['.'.join(node_path + [key])] = val
        if type(val) is dict :
        INDENT
            nodeRecursiveMap(val, node_path + [key])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def nodeRecursiveMap(d, node_path) :
INDENT
    for key, val in d.items() :
    INDENT
        if type(val) in types :
        INDENT
            node_map ['.'.join(node_path + [key])] = val
        DEDENT
        if type(val) is dict :
        INDENT
            nodeRecursiveMap(val, node_path + [key])
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28157202_28159305_43_62
28157202_28308459_25_43
Title: Render non-uniform grid and mark maximum value's location in contour plot 
----------------------------------------

def main() :
INDENT
    data = np.array([[0.56555019, 0.57933922, 0.58266252, 0.58067285, 0.57660236,
                0.57185625, 0.56711252, 0.55557035, 0.55027705, 0.54480605],
            [0.55486559, 0.57349717, 0.57940478, 0.57843897, 0.57463271,
                0.56963449, 0.5643922, 0.55095598, 0.54452534, 0.53762606],
            [0.53529358, 0.56254991, 0.57328105, 0.57409218, 0.57066168,
                0.5654082, 0.55956853, 0.5432474, 0.53501127, 0.52601203],
            [0.50110483, 0.54004071, 0.55800178, 0.56173719, 0.55894846,
                0.55328279, 0.54642887, 0.52598388, 0.51533094, 0.50354147]])
    x = np.array([10 + i * (150.- 10.) / 9 for i in range(10)])
    y = np.array([50 + i * (100.- 50.) / 4 for i in range(4)])

    xlist = np.array([10., 20., 30., 40., 50., 60., 70., 100., 120., 150.])
    ylist = np.array([50, 70, 90, 100])
    plot_s(data, x, y, xlist, ylist)
DEDENT
----------------------------------------

def main() :
INDENT
    data = np.array([[0.56555019, 0.57933922, 0.58266252, 0.58067285,
                0.57660236, 0.57185625, 0.56711252, 0.55557035,
                0.55027705, 0.54480605],
            [0.55486559, 0.57349717, 0.57940478, 0.57843897,
                0.57463271, 0.56963449, 0.5643922, 0.55095598,
                0.54452534, 0.53762606],
            [0.53529358, 0.56254991, 0.57328105, 0.57409218,
                0.57066168, 0.5654082, 0.55956853, 0.5432474,
                0.53501127, 0.52601203],
            [0.50110483, 0.54004071, 0.55800178, 0.56173719,
                0.55894846, 0.55328279, 0.54642887, 0.52598388,
                0.51533094, 0.50354147]])
    xlist = [10., 20., 30., 40., 50., 60., 70., 100., 120., 150.]
    ylist = [50, 70, 90, 100]
    plot_s(data, xlist, ylist)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28157202_28159305_5_42
28157202_28308459_4_24
Title: Render non-uniform grid and mark maximum value's location in contour plot 
----------------------------------------

def plot_s(data, x, y, xlist, ylist) :
INDENT
    ax = plt.gca()

    X, Y = np.meshgrid(x, y)
    CS = ax.contour(X, Y, data, colors = 'k')

    ax.set_yticks(y)
    ax.set_yticklabels(ylist)

    ax.set_xticks(x)
    ax.set_xticklabels(xlist)

    max_value = np.max(data)
    local_max_index = np.where(data == max_value)

    max_x = X [local_max_index [0], local_max_index [1]]
    max_y = Y [local_max_index [0], local_max_index [1]]

    plt.plot(max_x, max_y, color = "red", marker = "o", zorder = 10,
        markersize = 15, clip_on = False)

    plt.title('Contour plot')
    plt.show()

DEDENT
----------------------------------------

def plot_s(data, xlist, ylist) :
INDENT
    fig, ax = plt.subplots()
    x = np.arange(len(xlist))
    y = np.arange(len(ylist))
    X, Y = np.meshgrid(x, y)
    CS = ax.contour(X, Y, data, colors = 'k')
    ax.clabel(CS, inline = 1, fontsize = 10)
    ax.set_xlabel('x list')
    ax.set_ylabel('y list')
    ax.set_xticks(x)
    ax.set_yticks(y)
    ax.set_xticklabels(xlist)
    ax.set_yticklabels(ylist)
    jmax, imax = np.unravel_index(np.argmax(data), data.shape)
    ax.plot(imax, jmax, 'ro')
    ax.set_title('Contour plot')
    plt.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28159510_28161117_4_23
28159510_28200894_64_110
Title: Writing from file to another file in Python from certain set of characters to another one 
----------------------------------------

def save_lines(infile, outfile) :
INDENT
    save = False
    for line in infile :
    INDENT
        if save :
        INDENT
            pos = line.find('}}')
            if pos > - 1 :
            INDENT
                outfile.write(line [: pos] + '\n')
                save = False
            DEDENT
            else :
            INDENT
                outfile.write(line)
            DEDENT
        DEDENT
        else :
        INDENT
            pos = line.find('{{')
            if pos > - 1 :
            INDENT
                outfile.write('-----\n')
                save = True
                outfile.write(line [pos + 2 :])
            DEDENT
            else :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def save_lines(infile, outfile) :
INDENT
    state = ST_start
    while True :
    INDENT
        if state == ST_start :
        INDENT
            reader_writer = ReaderWriter(infile, outfile)
            inchar = reader_writer.get_char()
            state = ST_outside_brackets
        DEDENT
        elif state == ST_outside_brackets :
        INDENT
            if inchar == Left_bracket :
            INDENT
                inchar = reader_writer.get_char()
                state = ST_seen_left_bracket if inchar is not None else ST_end
            DEDENT
            else :
            INDENT
                inchar = reader_writer.get_char()
                state = ST_outside_brackets if inchar is not None else ST_end
            DEDENT
        DEDENT
        elif state == ST_seen_left_bracket :
        INDENT
            if inchar == Left_bracket :
            INDENT
                reader_writer.write('found (pos {:d}): "'.format(
                        reader_writer.char_count))
                inchar = reader_writer.get_char()
                state = ST_inside_brackets if inchar is not None else ST_end
            DEDENT
            else :
            INDENT
                inchar = reader_writer.get_char()
                state = ST_outside_brackets if inchar is not None else ST_end
            DEDENT
        DEDENT
        elif state == ST_inside_brackets :
        INDENT
            if inchar == Right_bracket :
            INDENT
                inchar = reader_writer.get_char()
                state = ST_seen_right_bracket if inchar is not None else ST_end
            DEDENT
            else :
            INDENT
                reader_writer.write(inchar)
                inchar = reader_writer.get_char()
                state = ST_inside_brackets if inchar is not None else ST_end
            DEDENT
        DEDENT
        elif state == ST_seen_right_bracket :
        INDENT
            if inchar == Right_bracket :
            INDENT
                reader_writer.write('"\n')
                inchar = reader_writer.get_char()
                state = ST_outside_brackets if inchar is not None else ST_end
            DEDENT
            else :
            INDENT
                reader_writer.write_prev_char()
                reader_writer.write(inchar)
                inchar = reader_writer.get_char()
                state = ST_inside_brackets if inchar is not None else ST_end
            DEDENT
        DEDENT
        elif state == ST_end :
        INDENT
            return
        DEDENT
        else :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28183410_28183468_5_16
28183410_28183563_5_11
Title: can't insert data into sqlite3 using python 
----------------------------------------

def cur_execute(data) :
INDENT
    con = sqlite3.connect('sqlite3.db')
    try :
    INDENT
        with con :
        INDENT
            cur = con.cursor()
            cur.execute(data)
            con.commit()
        DEDENT
    DEDENT
    except Exception as why :
    INDENT
        print (why)
    DEDENT
    finally :
    INDENT
        if con : con.close()
    DEDENT
DEDENT
----------------------------------------

def cur_execute(data, args = ()) :
INDENT
    con = sqlite3.connect('sqlite3.db')
    with con :
    INDENT
        cur = con.cursor()
        cur.execute(data, args)
        con.commit()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28183410_28183468_5_16
28183410_28183579_7_13
Title: can't insert data into sqlite3 using python 
----------------------------------------

def cur_execute(data) :
INDENT
    con = sqlite3.connect('sqlite3.db')
    try :
    INDENT
        with con :
        INDENT
            cur = con.cursor()
            cur.execute(data)
            con.commit()
        DEDENT
    DEDENT
    except Exception as why :
    INDENT
        print (why)
    DEDENT
    finally :
    INDENT
        if con : con.close()
    DEDENT
DEDENT
----------------------------------------

def cur_execute(data, * args) :
INDENT
    con = sqlite3.connect('sqlite3.db')
    with con :
    INDENT
        cur = con.cursor()
        cur.execute(data, args)
        con.commit()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28183410_28183560_5_19
28183410_28183563_5_11
Title: can't insert data into sqlite3 using python 
----------------------------------------

def cur_execute(data, * args) :
INDENT
    con = sqlite3.connect('sqlite3.db')
    try :
    INDENT
        with con :
        INDENT
            cur = con.cursor()
            if args is not None :
            INDENT
                cur.execute(data, args)
            DEDENT
            else :
            INDENT
                cur.execute(data)
            DEDENT
            con.commit()
        DEDENT
    DEDENT
    except Exception as why :
    INDENT
        print (why)
    DEDENT
    finally :
    INDENT
        if con : con.close()
    DEDENT
DEDENT
----------------------------------------

def cur_execute(data, args = ()) :
INDENT
    con = sqlite3.connect('sqlite3.db')
    with con :
    INDENT
        cur = con.cursor()
        cur.execute(data, args)
        con.commit()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28183410_28183560_5_19
28183410_28183579_7_13
Title: can't insert data into sqlite3 using python 
----------------------------------------

def cur_execute(data, * args) :
INDENT
    con = sqlite3.connect('sqlite3.db')
    try :
    INDENT
        with con :
        INDENT
            cur = con.cursor()
            if args is not None :
            INDENT
                cur.execute(data, args)
            DEDENT
            else :
            INDENT
                cur.execute(data)
            DEDENT
            con.commit()
        DEDENT
    DEDENT
    except Exception as why :
    INDENT
        print (why)
    DEDENT
    finally :
    INDENT
        if con : con.close()
    DEDENT
DEDENT
----------------------------------------

def cur_execute(data, * args) :
INDENT
    con = sqlite3.connect('sqlite3.db')
    with con :
    INDENT
        cur = con.cursor()
        cur.execute(data, args)
        con.commit()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28193025_44852715_7_11
28193025_47642971_11_25
Title: Pylint can't find SQLAlchemy query member 
----------------------------------------

def transform(cls) :
INDENT
    if cls.name == 'scoped_session' :
    INDENT
        for prop in ['add', 'delete', 'query', 'commit', 'rollback'] :
        INDENT
            cls.locals [prop] = [scoped_nodes.Function(prop, None)]
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def transform(cls) :
INDENT
    if cls.name == 'scoped_session' :
    INDENT
        builder = AstroidBuilder(MANAGER)
        module_node = builder.module_build(sys.modules [Session.__module__])
        session_cls_node = [
            c for c in module_node.get_children()
            if getattr(c, "type", None) == "class" and c.name == Session.__name__
            ] [0]
        for prop in Session.public_methods :
        INDENT
            cls.locals [prop] = [
                c for c in session_cls_node.get_children()
                if getattr(c, "type", None) == "method" and c.name == prop
                ]
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28207113_28207308_1_12
28207113_28207413_9_24
Title: Can't figure out a Python exercise with dictionaries 
----------------------------------------

def calculateBill(food) :
INDENT
    total = 0
    for k in food :
    INDENT
        if k in inventory :
        INDENT
            if inventory [k] > 0 :
            INDENT
                total += prices [k]
                inventory [k] = inventory [k] - 1
            DEDENT
            else :
            INDENT
                print 'There are no %s in stock' % k
            DEDENT
        DEDENT
        else :
        INDENT
            print 'dont stock %s' % k
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------

def calculateBill(food) :
INDENT
    def buy_item(food_item, qty = 1, inv_dict = None, prices_dict = None) :
    INDENT
        get_price = lambda item, price_dct : price_dct.get(item, 9999999)
        if inv_dict is None :
        INDENT
            inv_dict = inventory
        DEDENT
        if prices_dict is None :
        INDENT
            prices_dict = prices
        DEDENT
        if inv_dict.get(food_item, 0) > = qty :
        INDENT
            inv_dict [food_item] -= qty
            return sum(get_price(food_item, prices_dict) for _ in range(qty))
        DEDENT
        else :
        INDENT
            raise QtyError("Cannot purchase item '{0}' of quantity {1}, inventory only contains {2} of '{0}'".format(food_item, qty, inv_dict.get(food_item, 0)))
        DEDENT
    DEDENT
    total = sum(buy_item(food_item, 1, inventory, prices) for food_item in food)
    return total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28217541_28218270_2_12
28217541_41411444_3_22
Title: Drawing 4 squares inside each other 
----------------------------------------

def drawSquares(myTurtle, sideLength, x, y, nSquares, distanceApart) :
INDENT
    if nSquares > 0 :
    INDENT
        myTurtle.pu()
        myTurtle.setx(x)
        myTurtle.sety(y)
        myTurtle.pd()
        for i in range(4) :
        INDENT
            myTurtle.forward(sideLength)
            myTurtle.right(90)
        DEDENT
        drawSquares(myTurtle, sideLength - distanceApart * 2, x + 10, y - 10, nSquares - 1, distanceApart)
    DEDENT
DEDENT
----------------------------------------

def drawSquares(myTurtle, sideLength, nSquares, distanceApart) :
INDENT
    myTurtle.penup()
    x, y = myTurtle.position()
    myTurtle.goto(x - sideLength / 2, y - sideLength / 2)
    myTurtle.pendown()
    myTurtle.setheading(- 45)
    for _ in range(nSquares) :
    INDENT
        radius = sideLength * 2 ** 0.5 / 2
        myTurtle.circle(radius, steps = 4)
        sideLength -= 10
        myTurtle.penup()
        x, y = myTurtle.position()
        myTurtle.goto(x + distanceApart / 2, y + distanceApart / 2)
        myTurtle.pendown()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28222527_28232615_5_17
28222527_28242995_4_13
Title: How to resize the main window again after setFixedSize()? 
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.setFixedSize(400, 300)
    widget = QtGui.QWidget()
    layout = QtGui.QVBoxLayout(widget)
    button = QtGui.QPushButton('Toggle visibility')
    button.clicked.connect(self.hideAndShowWidget)
    layout.addWidget(button)
    self.widgetObject = QtGui.QLabel('Test')
    layout.addWidget(self.widgetObject)
    self.setCentralWidget(widget)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.widgetObject = QtGui.QTextEdit(self)
    self.button = QtGui.QPushButton('Hide Widget', self)
    self.button.clicked.connect(self.hideAndShowWidget)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.button)
    layout.addWidget(self.widgetObject)
    self.setFixedSize(300, 200)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28225808_28265854_14_24
28225808_28316279_17_24
Title: Unable to get post data in a multipleChoiceField with django 
----------------------------------------

def post_if_authenticated(self, request, user) :
INDENT
    PostFormSet = modelformset_factory(
        models.Post,
        form = PostForm)
    formset = PostFormSet(request.POST)
    if formset.is_valid() :
    INDENT
        post = formset.save(commit = False) [0]
        post.user = user
        post.save()
        return HttpResponseRedirect(reverse('trendby:actions'))
    DEDENT
    return render(request, self.template_name)
DEDENT
----------------------------------------

def post_if_authenticated(self, request, user) :
INDENT
    form = PostForm(request.POST, request.FILES)
    if form.is_valid() :
    INDENT
        post = form.save(commit = False)
        post.user = user
        post.save()
        return HttpResponseRedirect(reverse('myapp:actions'))
    DEDENT
    return render(request, self.template_name, {"form" : form})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28228218_28228348_1_27
28228218_28228410_1_19
Title: "Using nested while loops to create a sum or powers list python" 
----------------------------------------

def sum_of_powers(base_list, expo_list) :
INDENT
    end = []
    sum = 0
    j = 0
    i = 0
    k = 0
    while j < len(expo_list) :
    INDENT
        sum = 0
        i = 0
        k = 0
        sub_accum = []
        while i < len(base_list) :
        INDENT
            sub_accum.append(base_list [i] ** expo_list [j])
            i += 1
        DEDENT
        while k < len(sub_accum) :
        INDENT
            sum = sum + sub_accum [k]
            k += 1
        DEDENT
        end.append(sum)
        j += 1
    DEDENT
    return end
DEDENT
----------------------------------------

def sum_of_powers(base_list, expo_list) :
INDENT
    end = []
    endsum = []
    j = 0
    while j < len(expo_list) :
    INDENT
        sub_accum = []
        i = 0
        while i < len(base_list) :
        INDENT
            sub_accum.append(base_list [i] ** expo_list [j])
            i += 1
        DEDENT
        end.append(sub_accum)
        j += 1
    DEDENT
    for i in range(len(end)) :
    INDENT
        endsum.append(sum(end [i]))
    DEDENT
    return endsum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28259967_28259986_1_7
28259967_28260126_4_14
Title: how do I apply a function n times? 
----------------------------------------

def repeat(f, n) :
INDENT
    def new_fn(x) :
    INDENT
        for _ in range(n) :
        INDENT
            x = f(x)
        DEDENT
        return x
    DEDENT
    return new_fn
DEDENT
----------------------------------------

def repeat(n = 1) :
INDENT
    def decorator(func) :
    INDENT
        @ wraps(func)
        def wrapper(args) :
        INDENT
            args = func(args)
            for i in xrange(n - 1) :
            INDENT
                args = func(args)
            DEDENT
            return args
        DEDENT
        return wrapper
    DEDENT
    return decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28282717_28282890_4_13
28282717_28283049_4_12
Title: Display 2D sudoku board in python 
----------------------------------------

def display(values) :
INDENT
    for r in rows :
    INDENT
        if r == "D" or r == "H" :
        INDENT
            print '------+-------+------'
        DEDENT
        else :
        INDENT
            for c in cols :
            INDENT
                if c % 3 == 0 and c ! = 9 :
                INDENT
                    print values [r + c] + "|"
                DEDENT
                else :
                INDENT
                    print values [r + c]
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def display(values) :
INDENT
    for i, r in enumerate(rows) :
    INDENT
        if i in [3, 6] :
        INDENT
            print '------+-------+------'
        DEDENT
        for j, c in enumerate(cols) :
        INDENT
            if j in [3, 6] :
            INDENT
                print '|',
            DEDENT
            print values [r + c],
        DEDENT
        print
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28282717_28282890_4_13
28282717_28283071_6_24
Title: Display 2D sudoku board in python 
----------------------------------------

def display(values) :
INDENT
    for r in rows :
    INDENT
        if r == "D" or r == "H" :
        INDENT
            print '------+-------+------'
        DEDENT
        else :
        INDENT
            for c in cols :
            INDENT
                if c % 3 == 0 and c ! = 9 :
                INDENT
                    print values [r + c] + "|"
                DEDENT
                else :
                INDENT
                    print values [r + c]
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def display(values) :
INDENT
    for r in rows :
    INDENT
        for c in cols :
        INDENT
            if r == "x" :
            INDENT
                if c == "x" :
                INDENT
                    print "+",
                DEDENT
                else :
                INDENT
                    print "-"
                DEDENT
            DEDENT
            elif c == "x" :
            INDENT
                print "|",
            DEDENT
            else :
            INDENT
                print values.get(r + c, "?"),
            DEDENT
        DEDENT
        print ""
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28282717_28283049_4_12
28282717_28283071_6_24
Title: Display 2D sudoku board in python 
----------------------------------------

def display(values) :
INDENT
    for i, r in enumerate(rows) :
    INDENT
        if i in [3, 6] :
        INDENT
            print '------+-------+------'
        DEDENT
        for j, c in enumerate(cols) :
        INDENT
            if j in [3, 6] :
            INDENT
                print '|',
            DEDENT
            print values [r + c],
        DEDENT
        print
    DEDENT
DEDENT
----------------------------------------

def display(values) :
INDENT
    for r in rows :
    INDENT
        for c in cols :
        INDENT
            if r == "x" :
            INDENT
                if c == "x" :
                INDENT
                    print "+",
                DEDENT
                else :
                INDENT
                    print "-"
                DEDENT
            DEDENT
            elif c == "x" :
            INDENT
                print "|",
            DEDENT
            else :
            INDENT
                print values.get(r + c, "?"),
            DEDENT
        DEDENT
        print ""
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28337436_28337618_1_14
28337436_28338216_18_24
Title: reading file into dictionary python 
----------------------------------------

def bird_weights(filename) :
INDENT
    result = collections.defaultdict(list)
    with open(filename, 'r') as f :
    INDENT
        for line in f.readlines() :
        INDENT
            bird_name, values = line.strip().split(':')

            bird_name = bird_name.strip().capitalize()
            values = map(lambda v : float(v.strip()), values.strip().split(' '))
            result [bird_name].extend(values)
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def bird_weights(f) :
INDENT
    birdlist = []
    for line in f :
    INDENT
        name, weights = line.split(':')
        birdy = Bird(name.capitalize(), get_float_list(weights))
        birdlist.append(birdy)
    DEDENT
    print_birds(birdlist)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28384657_28384926_27_33
28384657_28384926_51_57
Title: Matplotlib mutli-barchart plots 
----------------------------------------

def autolabel(rects) :
INDENT
    for rect in rects :
    INDENT
        height = rect.get_height()
        ax.text(rect.get_x() + rect.get_width() / 2., 1.05 * height, '%d' % int(height),
            ha = 'center', va = 'bottom')
    DEDENT
DEDENT
----------------------------------------

def autolabel(rects) :
INDENT
    for rect in rects :
    INDENT
        height = rect.get_height()
        ax2.text(rect.get_x() + rect.get_width() / 2., 1.05 * height, '%d' % int(height),
            ha = 'center', va = 'bottom')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2839363_2839437_13_18
2839363_2839437_5_10
Title: Decorator that can take both init args and call args? 
----------------------------------------

def decorator(fn) :
INDENT
    def new_fn() :
    INDENT
        if self.debug :
        INDENT
            print x
        DEDENT
        fn()
    DEDENT
    return new_fn
DEDENT
----------------------------------------

def decorator(fn) :
INDENT
    def new_fn() :
    INDENT
        if self.debug :
        INDENT
            print a
        DEDENT
        fn()
    DEDENT
    return new_fn
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2841971_2842030_9_19
2841971_2842057_14_28
Title: Compound dictionary keys 
----------------------------------------

def getitem(context, dotted_key) :
INDENT
    keys = dotted_key.split(".")
    value = context
    for key in keys :
    INDENT
        try :
        INDENT
            value = value [key]
        DEDENT
        except TypeError :
        INDENT
            value = value [int(key)]
        DEDENT
    DEDENT
    return value

DEDENT
----------------------------------------

def getitem(key, context) :
INDENT
    if isinstance(context, dict) and context.has_key(key) :
    INDENT
        return context [key]
    DEDENT
    for key in key.split('.') :
    INDENT
        try :
        INDENT
            context = context [int(key)]
            continue
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
        if isinstance(context, dict) and context.has_key(key) :
        INDENT
            context = context [key]
            continue
        DEDENT
        raise KeyError, key
    DEDENT
    return context
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2841971_2842030_9_19
2841971_2842124_1_23
Title: Compound dictionary keys 
----------------------------------------

def getitem(context, dotted_key) :
INDENT
    keys = dotted_key.split(".")
    value = context
    for key in keys :
    INDENT
        try :
        INDENT
            value = value [key]
        DEDENT
        except TypeError :
        INDENT
            value = value [int(key)]
        DEDENT
    DEDENT
    return value

DEDENT
----------------------------------------

def getitem(key, context, first = True) :
INDENT
    if not isinstance(key, basestring) and not isinstance(key, list) and first :
    INDENT
        raise TypeError("Compound key must be a string.")
    DEDENT
    if isinstance(key, basestring) :
    INDENT
        if key in context :
        INDENT
            return context [key]
        DEDENT
        else :
        INDENT
            keys = key.split('.')
        DEDENT
    DEDENT
    else :
    INDENT
        keys = key
    DEDENT
    k = keys.pop(0)
    if key :
    INDENT
        try :
        INDENT
            return getitem(keys, context [k], False)
        DEDENT
        except KeyError, e :
        INDENT
            raise KeyError(key)
        DEDENT
    DEDENT
    if hasattr(context, '__getitem__') and not hasattr(context, 'keys') :
    INDENT

        k = int(k)
    DEDENT
    return context [k]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2841971_2842030_9_19
2841971_2842155_1_13
Title: Compound dictionary keys 
----------------------------------------

def getitem(context, dotted_key) :
INDENT
    keys = dotted_key.split(".")
    value = context
    for key in keys :
    INDENT
        try :
        INDENT
            value = value [key]
        DEDENT
        except TypeError :
        INDENT
            value = value [int(key)]
        DEDENT
    DEDENT
    return value

DEDENT
----------------------------------------

def getitem(key, context) :
INDENT
    stk = [(key.split('.'), context)]
    while stk :
    INDENT
        kl, ctx = stk.pop()
        if not kl : return ctx
        if kl [0].isdigit() :
        INDENT
            ik = int(kl [0])
            try : stk.append((kl [1 :], ctx [ik]))
            except LookupError : pass
        DEDENT
        for i in range(1, len(kl) + 1) :
        INDENT
            k = '.'.join(kl [: i])
            if k in ctx : stk.append((kl [i :], ctx [k]))
        DEDENT
    DEDENT
    raise KeyError(key)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2841971_2842057_14_28
2841971_2842124_1_23
Title: Compound dictionary keys 
----------------------------------------

def getitem(key, context) :
INDENT
    if isinstance(context, dict) and context.has_key(key) :
    INDENT
        return context [key]
    DEDENT
    for key in key.split('.') :
    INDENT
        try :
        INDENT
            context = context [int(key)]
            continue
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
        if isinstance(context, dict) and context.has_key(key) :
        INDENT
            context = context [key]
            continue
        DEDENT
        raise KeyError, key
    DEDENT
    return context
DEDENT
----------------------------------------

def getitem(key, context, first = True) :
INDENT
    if not isinstance(key, basestring) and not isinstance(key, list) and first :
    INDENT
        raise TypeError("Compound key must be a string.")
    DEDENT
    if isinstance(key, basestring) :
    INDENT
        if key in context :
        INDENT
            return context [key]
        DEDENT
        else :
        INDENT
            keys = key.split('.')
        DEDENT
    DEDENT
    else :
    INDENT
        keys = key
    DEDENT
    k = keys.pop(0)
    if key :
    INDENT
        try :
        INDENT
            return getitem(keys, context [k], False)
        DEDENT
        except KeyError, e :
        INDENT
            raise KeyError(key)
        DEDENT
    DEDENT
    if hasattr(context, '__getitem__') and not hasattr(context, 'keys') :
    INDENT

        k = int(k)
    DEDENT
    return context [k]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2841971_2842057_14_28
2841971_2842155_1_13
Title: Compound dictionary keys 
----------------------------------------

def getitem(key, context) :
INDENT
    if isinstance(context, dict) and context.has_key(key) :
    INDENT
        return context [key]
    DEDENT
    for key in key.split('.') :
    INDENT
        try :
        INDENT
            context = context [int(key)]
            continue
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
        if isinstance(context, dict) and context.has_key(key) :
        INDENT
            context = context [key]
            continue
        DEDENT
        raise KeyError, key
    DEDENT
    return context
DEDENT
----------------------------------------

def getitem(key, context) :
INDENT
    stk = [(key.split('.'), context)]
    while stk :
    INDENT
        kl, ctx = stk.pop()
        if not kl : return ctx
        if kl [0].isdigit() :
        INDENT
            ik = int(kl [0])
            try : stk.append((kl [1 :], ctx [ik]))
            except LookupError : pass
        DEDENT
        for i in range(1, len(kl) + 1) :
        INDENT
            k = '.'.join(kl [: i])
            if k in ctx : stk.append((kl [i :], ctx [k]))
        DEDENT
    DEDENT
    raise KeyError(key)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2841971_2842124_1_23
2841971_2842155_1_13
Title: Compound dictionary keys 
----------------------------------------

def getitem(key, context, first = True) :
INDENT
    if not isinstance(key, basestring) and not isinstance(key, list) and first :
    INDENT
        raise TypeError("Compound key must be a string.")
    DEDENT
    if isinstance(key, basestring) :
    INDENT
        if key in context :
        INDENT
            return context [key]
        DEDENT
        else :
        INDENT
            keys = key.split('.')
        DEDENT
    DEDENT
    else :
    INDENT
        keys = key
    DEDENT
    k = keys.pop(0)
    if key :
    INDENT
        try :
        INDENT
            return getitem(keys, context [k], False)
        DEDENT
        except KeyError, e :
        INDENT
            raise KeyError(key)
        DEDENT
    DEDENT
    if hasattr(context, '__getitem__') and not hasattr(context, 'keys') :
    INDENT

        k = int(k)
    DEDENT
    return context [k]
DEDENT
----------------------------------------

def getitem(key, context) :
INDENT
    stk = [(key.split('.'), context)]
    while stk :
    INDENT
        kl, ctx = stk.pop()
        if not kl : return ctx
        if kl [0].isdigit() :
        INDENT
            ik = int(kl [0])
            try : stk.append((kl [1 :], ctx [ik]))
            except LookupError : pass
        DEDENT
        for i in range(1, len(kl) + 1) :
        INDENT
            k = '.'.join(kl [: i])
            if k in ctx : stk.append((kl [i :], ctx [k]))
        DEDENT
    DEDENT
    raise KeyError(key)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28423295_28425594_34_51
28423295_28442211_23_33
Title: Trouble Mapping Recursive Relationship - SQLAlchemy 
----------------------------------------

def datamap() :
INDENT
    properties = {'neighbors' :
        relationship(Neighbor, backref = "r_person",
            foreign_keys = neighbor.c.name,),
        'neighbors_of' :
        relationship(Neighbor, backref = "r_neigbor",
            foreign_keys = neighbor.c.neighbor,)}
    mapper(Person, person, properties = properties)
    mapper(Neighbor, neighbor)

DEDENT
----------------------------------------

def datamap() :
INDENT
    properties = {
        'neighbors' : relationship(
            Person, backref = "neighbor_of", secondary = neighbor,
            primaryjoin = person.c.name == neighbor.c.name,
            secondaryjoin = person.c.name == neighbor.c.neighbor,
            ),
        }
    mapper(Person, person, properties = properties)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28423295_28425594_53_62
28423295_28442211_35_47
Title: Trouble Mapping Recursive Relationship - SQLAlchemy 
----------------------------------------

def test_map(self) :
INDENT
    session = self.get_session()

    datamap()
    model = self.build_model()
    session.add(model)
    session.flush()
DEDENT
----------------------------------------

def test_map(self) :
INDENT
    session = self.get_session()

    datamap()
    model = self.build_model()
    session.add(model)
    session.flush()
    model.neighbors.append(Person('Anna'))
    session.commit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28423295_28425594_70_76
28423295_28442211_55_61
Title: Trouble Mapping Recursive Relationship - SQLAlchemy 
----------------------------------------

def get_session(self) :
INDENT
    from sqlalchemy.orm import sessionmaker
    from sqlalchemy import create_engine
    engine = create_engine('sqlite:///:memory:', echo = True)
    metadata.create_all(engine, tables = [person, neighbor])
    Session = sessionmaker(bind = engine)
    return Session()
DEDENT
----------------------------------------

def get_session(self) :
INDENT
    from sqlalchemy.orm import sessionmaker
    from sqlalchemy import create_engine
    engine = create_engine('sqlite:///:memory:', echo = True)
    metadata.create_all(engine, tables = [person, neighbor])
    Session = sessionmaker(bind = engine)
    return Session()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28431201_28433053_7_14
28431201_28435597_6_10
Title: Python: Equivalent of Inheritance with Closures 
----------------------------------------

def thing_1(alpha, beta) :
INDENT
    gamma = alpha + beta
    def func_1(x) :
    INDENT
        return x + gamma
    DEDENT
    def func_2(x) :
    INDENT
        return x * gamma
    DEDENT
    return Funcs(func_1, func_2)
DEDENT
----------------------------------------

def thing_1(alpha, beta) :
INDENT
    gamma = alpha + beta
    def func_2(x) :
    INDENT
        return x * gamma
    DEDENT
    return Funcs(gammafied_func_1(gamma), func_2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28436386_28436780_7_12
28436386_28438591_4_11
Title: Defining function with function object passed in as argument 
----------------------------------------

def do_n(f, n) :
INDENT
    if n < = 0 :
    INDENT
        return
    DEDENT
    f('test')
    do_n(f, n - 1)
DEDENT
----------------------------------------

def do_n(f, n) :
INDENT
    if n < = 0 :
    INDENT
        return
    DEDENT
    print (type(f))
    f()
    print ('been here')
    do_n(f, n - 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28466019_28466127_1_10
28466019_28466277_3_11
Title: "Division with str float int and tuples" 
----------------------------------------

def half(x) :
INDENT
    if type(x) == float :
    INDENT
        return x / 2
    DEDENT
    if type(x) == int :
    INDENT
        return x / / 2
    DEDENT
    if type(x) in (tuple, str) :
    INDENT
        return x [: len(x) / / 2]
    DEDENT
DEDENT
----------------------------------------

def half(x) :
INDENT
    if isinstance(x, numbers.Integral) :
    INDENT
        return x / / 2
    DEDENT
    elif isinstance(x, numbers.Real) :
    INDENT
        return x / 2.
    DEDENT
    elif isinstance(x, (tuple, str)) :
    INDENT
        return x [: len(x) / / 2]
    DEDENT
    else :
    INDENT
        raise TypeError("x should be an int, float, tuple, or str (or derived from one of those)")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28468359_28468414_1_11
28468359_28468455_4_10
Title: Can't figure out what's wrong with my method 
----------------------------------------

def retrieve_data() :
INDENT
    insert_data()
    nb = input('Choose a label: ')
    for j in data :
    INDENT
        a = j [0]
        b = j [1]
        if a == nb :
        INDENT
            print (b)
            break
        DEDENT
    DEDENT
    else :
    INDENT
        print ('Label not in list!')
    DEDENT
DEDENT
----------------------------------------

def retrieve_data() :
INDENT
    nb = raw_input("Choose a label: ")
    if nb in dic.keys() :
    INDENT
        print dic [nb]
    DEDENT
    else :
    INDENT
        print "Label not in list!"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28477608_28477981_2_11
28477608_28478122_1_11
Title: Find number of sub-directories in each folder separately 
----------------------------------------

def count_folders(path) :
INDENT
    count = 0
    for dir in os.listdir(path) :
    INDENT
        nDir = os.path.join(path, dir)
        if os.path.isdir(nDir) :
        INDENT
            count += 1

        DEDENT
    DEDENT
    print count
DEDENT
----------------------------------------

def count_folders(path) :
INDENT
    count = {}
    for dir in os.listdir(path) :
    INDENT
        nDir = os.path.join(path, dir)
        if os.path.isdir(nDir) :
        INDENT
            c = 0
            for d in os.listdir(nDir) :
            INDENT
                if os.path.isdir(os.path.join(nDir, d)) :
                INDENT
                    c += 1
                DEDENT
            DEDENT
            count [nDir] = c
        DEDENT
    DEDENT
    print count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_37754360_109_126
28509629_48847045_244_287
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def delete(self) :
INDENT
    topleft = list(self.GetSelectionBlockTopLeft())
    bottomright = list(self.GetSelectionBlockBottomRight())
    if topleft == [] :
    INDENT
        rows = 1
        cols = 1
    DEDENT
    else :
    INDENT
        rows = bottomright [0] [0] - topleft [0] [0] + 1
        cols = bottomright [0] [1] - topleft [0] [1] + 1
    DEDENT
    for r in range(rows) :
    INDENT
        for c in range(cols) :
        INDENT
            if topleft == [] :
            INDENT
                self.SetCellValue(self.GetGridCursorRow() + r, self.GetGridCursorCol() + c, '')
            DEDENT
            else :
            INDENT
                self.SetCellValue(topleft [0] [0] + r, topleft [0] [1] + c, '')
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def delete(self) :
INDENT
    if self.GetSelectionBlockTopLeft() == [] :
    INDENT
        rowstart = self.GetGridCursorRow()
        colstart = self.GetGridCursorCol()
        rowend = rowstart
        colend = colstart
    DEDENT
    else :
    INDENT
        rowstart = self.GetSelectionBlockTopLeft() [0] [0]
        colstart = self.GetSelectionBlockTopLeft() [0] [1]
        rowend = self.GetSelectionBlockBottomRight() [0] [0]
        colend = self.GetSelectionBlockBottomRight() [0] [1]
    DEDENT
    rows = rowend - rowstart + 1
    cols = colend - colstart + 1

    text4undo = ''
    for r in range(rows) :
    INDENT
        for c in range(cols) :
        INDENT
            text4undo += str(self.GetCellValue(rowstart + r, colstart + c)) + '\t'
            self.SetCellValue(rowstart + r, colstart + c, '')
        DEDENT
        text4undo = text4undo [: - 1] + '\n'

    DEDENT
    self.data4undo = [rowstart, colstart, text4undo]

    clipboard = wx.TextDataObject()
    clipboard.SetText(text4undo)
    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_37754360_109_126
28509629_50311733_321_332
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def delete(self) :
INDENT
    topleft = list(self.GetSelectionBlockTopLeft())
    bottomright = list(self.GetSelectionBlockBottomRight())
    if topleft == [] :
    INDENT
        rows = 1
        cols = 1
    DEDENT
    else :
    INDENT
        rows = bottomright [0] [0] - topleft [0] [0] + 1
        cols = bottomright [0] [1] - topleft [0] [1] + 1
    DEDENT
    for r in range(rows) :
    INDENT
        for c in range(cols) :
        INDENT
            if topleft == [] :
            INDENT
                self.SetCellValue(self.GetGridCursorRow() + r, self.GetGridCursorCol() + c, '')
            DEDENT
            else :
            INDENT
                self.SetCellValue(topleft [0] [0] + r, topleft [0] [1] + c, '')
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def delete(self, event) :
INDENT
    cells = []
    for row, col in self.get_selected_cells() :
    INDENT
        attributes = {
            "value" : self.GetCellValue(row, col),
            "alignment" : self.GetCellAlignment(row, col)}
        cells.append((row, col, attributes))
        self.SetCellValue(row, col, "")
    DEDENT
    self.add_history({"type" : "delete", "cells" : cells})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_37754360_29_72
28509629_48847045_91_133
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def copy(self) :
INDENT
    topleft = self.GetSelectionBlockTopLeft()
    if list(topleft) == [] :
    INDENT
        topleft = []
    DEDENT
    else :
    INDENT
        topleft = list(topleft [0])
    DEDENT
    bottomright = self.GetSelectionBlockBottomRight()
    if list(bottomright) == [] :
    INDENT
        bottomright = []
    DEDENT
    else :
    INDENT
        bottomright = list(bottomright [0])
    DEDENT
    if list(self.GetSelectionBlockTopLeft()) == [] :
    INDENT
        rows = 1
        cols = 1
        iscell = True
    DEDENT
    else :
    INDENT
        rows = bottomright [0] - topleft [0] + 1
        cols = bottomright [1] - topleft [1] + 1
        iscell = False
    DEDENT
    data = ''

    for r in range(rows) :
    INDENT
        for c in range(cols) :
        INDENT
            if iscell :
            INDENT
                data += str(self.GetCellValue(self.GetGridCursorRow() + r, self.GetGridCursorCol() + c))
            DEDENT
            else :
            INDENT
                data += str(self.GetCellValue(topleft [0] + r, topleft [1] + c))
            DEDENT
            if c < cols - 1 :
            INDENT
                data += '    '
            DEDENT
        DEDENT
        data += '\n'
    DEDENT
    clipboard = wx.TextDataObject()
    clipboard.SetText(data)
    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")
    DEDENT
DEDENT
----------------------------------------

def copy(self) :
INDENT
    if self.GetSelectionBlockTopLeft() == [] :
    INDENT
        rowstart = self.GetGridCursorRow()
        colstart = self.GetGridCursorCol()
        rowend = rowstart
        colend = colstart
    DEDENT
    else :
    INDENT
        rowstart = self.GetSelectionBlockTopLeft() [0] [0]
        colstart = self.GetSelectionBlockTopLeft() [0] [1]
        rowend = self.GetSelectionBlockBottomRight() [0] [0]
        colend = self.GetSelectionBlockBottomRight() [0] [1]
    DEDENT
    self.crows = rowend - rowstart + 1
    self.ccols = colend - colstart + 1

    data = ''

    for r in range(self.crows) :
    INDENT
        for c in range(self.ccols) :
        INDENT
            data += str(self.GetCellValue(rowstart + r, colstart + c))
            if c < self.ccols - 1 :
            INDENT
                data += '\t'
            DEDENT
        DEDENT
        data += '\n'

    DEDENT
    clipboard = wx.TextDataObject()

    clipboard.SetText(data)

    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_37754360_29_72
28509629_50311733_235_265
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def copy(self) :
INDENT
    topleft = self.GetSelectionBlockTopLeft()
    if list(topleft) == [] :
    INDENT
        topleft = []
    DEDENT
    else :
    INDENT
        topleft = list(topleft [0])
    DEDENT
    bottomright = self.GetSelectionBlockBottomRight()
    if list(bottomright) == [] :
    INDENT
        bottomright = []
    DEDENT
    else :
    INDENT
        bottomright = list(bottomright [0])
    DEDENT
    if list(self.GetSelectionBlockTopLeft()) == [] :
    INDENT
        rows = 1
        cols = 1
        iscell = True
    DEDENT
    else :
    INDENT
        rows = bottomright [0] - topleft [0] + 1
        cols = bottomright [1] - topleft [1] + 1
        iscell = False
    DEDENT
    data = ''

    for r in range(rows) :
    INDENT
        for c in range(cols) :
        INDENT
            if iscell :
            INDENT
                data += str(self.GetCellValue(self.GetGridCursorRow() + r, self.GetGridCursorCol() + c))
            DEDENT
            else :
            INDENT
                data += str(self.GetCellValue(topleft [0] + r, topleft [1] + c))
            DEDENT
            if c < cols - 1 :
            INDENT
                data += '    '
            DEDENT
        DEDENT
        data += '\n'
    DEDENT
    clipboard = wx.TextDataObject()
    clipboard.SetText(data)
    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")
    DEDENT
DEDENT
----------------------------------------

def copy(self, event) :
INDENT
    selection = self.get_selection()
    if not selection :
    INDENT
        return []
    DEDENT
    start_row, start_col, end_row, end_col = selection
    data = u''
    rows = range(start_row, end_row + 1)
    for row in rows :
    INDENT
        columns = range(start_col, end_col + 1)
        for idx, column in enumerate(columns, 1) :
        INDENT
            if idx == len(columns) :
            INDENT

                data += self.GetCellValue(row, column) + "\n"
            DEDENT
            else :
            INDENT
                data += self.GetCellValue(row, column) + "\t"
            DEDENT
        DEDENT
    DEDENT
    text_data_object = wx.TextDataObject()
    text_data_object.SetText(data)
    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(text_data_object)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Warning")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_37754360_73_108
28509629_48847045_204_243
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def paste(self, stage) :
INDENT
    topleft = list(self.GetSelectionBlockTopLeft())
    if stage == 'clip' :
    INDENT
        clipboard = wx.TextDataObject()
        if wx.TheClipboard.Open() :
        INDENT
            wx.TheClipboard.GetData(clipboard)
            wx.TheClipboard.Close()
        DEDENT
        else :
        INDENT
            wx.MessageBox("Can't open the clipboard", "Error")
        DEDENT
        data = clipboard.GetText()
        if topleft == [] :
        INDENT
            rowstart = self.GetGridCursorRow()
            colstart = self.GetGridCursorCol()
        DEDENT
        else :
        INDENT
            rowstart = topleft [0] [0]
            colstart = topleft [0] [1]
        DEDENT
    DEDENT
    elif stage == 'undo' :
    INDENT
        data = self.data4undo [2]
        rowstart = self.data4undo [0]
        colstart = self.data4undo [1]
    DEDENT
    else :
    INDENT
        wx.MessageBox("Paste method " + stage + " does not exist", "Error")
    DEDENT
    text4undo = ''
    for y, r in enumerate(data.splitlines()) :
    INDENT
        for x, c in enumerate(r.split('    ')) :
        INDENT
            if y + rowstart < self.NumberRows and x + colstart < self.NumberCols :
            INDENT
                text4undo += str(self.GetCellValue(rowstart + y, colstart + x)) + '    '
                self.SetCellValue(rowstart + y, colstart + x, c)
            DEDENT
        DEDENT
        text4undo = text4undo [: - 1] + '\n'
    DEDENT
    if stage == 'clip' :
    INDENT
        self.data4undo = [rowstart, colstart, text4undo]
    DEDENT
    else :
    INDENT
        self.data4undo = [0, 0, '']
    DEDENT
DEDENT
----------------------------------------

def paste(self, mode) :
INDENT
    if mode == 'paste' :
    INDENT

        self.build_paste_selection()
        if self.GetSelectionBlockTopLeft() == [] :
        INDENT
            rowstart = self.GetGridCursorRow()
            colstart = self.GetGridCursorCol()
        DEDENT
        else :
        INDENT
            rowstart = self.GetSelectionBlockTopLeft() [0] [0]
            colstart = self.GetSelectionBlockTopLeft() [0] [1]
        DEDENT
    DEDENT
    elif mode == 'undo' :
    INDENT
        self.out_data = self.data4undo [2]
        rowstart = self.data4undo [0]
        colstart = self.data4undo [1]
    DEDENT
    else :
    INDENT
        wx.MessageBox("Paste method " + mode + " does not exist", "Error")

    DEDENT
    text4undo = ''
    for y, r in enumerate(self.out_data.splitlines()) :
    INDENT
        for x, c in enumerate(r.split('\t')) :
        INDENT
            if y + rowstart < self.NumberRows and x + colstart < self.NumberCols :
            INDENT
                text4undo += str(self.GetCellValue(rowstart + y,
                        colstart + x)) + '\t'
                self.SetCellValue(rowstart + y, colstart + x, c)
            DEDENT
        DEDENT
        text4undo = text4undo [: - 1] + '\n'

    DEDENT
    if mode == 'paste' :
    INDENT
        self.data4undo = [rowstart, colstart, text4undo]
    DEDENT
    else :
    INDENT
        self.data4undo = [0, 0, '']
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_37754360_73_108
28509629_50311733_266_320
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def paste(self, stage) :
INDENT
    topleft = list(self.GetSelectionBlockTopLeft())
    if stage == 'clip' :
    INDENT
        clipboard = wx.TextDataObject()
        if wx.TheClipboard.Open() :
        INDENT
            wx.TheClipboard.GetData(clipboard)
            wx.TheClipboard.Close()
        DEDENT
        else :
        INDENT
            wx.MessageBox("Can't open the clipboard", "Error")
        DEDENT
        data = clipboard.GetText()
        if topleft == [] :
        INDENT
            rowstart = self.GetGridCursorRow()
            colstart = self.GetGridCursorCol()
        DEDENT
        else :
        INDENT
            rowstart = topleft [0] [0]
            colstart = topleft [0] [1]
        DEDENT
    DEDENT
    elif stage == 'undo' :
    INDENT
        data = self.data4undo [2]
        rowstart = self.data4undo [0]
        colstart = self.data4undo [1]
    DEDENT
    else :
    INDENT
        wx.MessageBox("Paste method " + stage + " does not exist", "Error")
    DEDENT
    text4undo = ''
    for y, r in enumerate(data.splitlines()) :
    INDENT
        for x, c in enumerate(r.split('    ')) :
        INDENT
            if y + rowstart < self.NumberRows and x + colstart < self.NumberCols :
            INDENT
                text4undo += str(self.GetCellValue(rowstart + y, colstart + x)) + '    '
                self.SetCellValue(rowstart + y, colstart + x, c)
            DEDENT
        DEDENT
        text4undo = text4undo [: - 1] + '\n'
    DEDENT
    if stage == 'clip' :
    INDENT
        self.data4undo = [rowstart, colstart, text4undo]
    DEDENT
    else :
    INDENT
        self.data4undo = [0, 0, '']
    DEDENT
DEDENT
----------------------------------------

def paste(self, event) :
INDENT
    if not wx.TheClipboard.Open() :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Warning")
        return False
    DEDENT
    clipboard = wx.TextDataObject()
    wx.TheClipboard.GetData(clipboard)
    wx.TheClipboard.Close()
    data = clipboard.GetText()
    if data [- 1] == "\n" :
    INDENT
        data = data [: - 1]
    DEDENT
    try :
    INDENT
        cells = self.get_selected_cells()
        cell = next(cells)
    DEDENT
    except StopIteration :
    INDENT
        return False
    DEDENT
    start_row = end_row = cell [0]
    start_col = end_col = cell [1]
    max_row = self.GetNumberRows()
    max_col = self.GetNumberCols()
    history = []
    out_of_range = False
    for row, line in enumerate(data.split("\n")) :
    INDENT
        target_row = start_row + row
        if not (0 < = target_row < max_row) :
        INDENT
            out_of_range = True
            break
        DEDENT
        if target_row > end_row :
        INDENT
            end_row = target_row
        DEDENT
        for col, value in enumerate(line.split("\t")) :
        INDENT
            target_col = start_col + col
            if not (0 < = target_col < max_col) :
            INDENT
                out_of_range = True
                break
            DEDENT
            if target_col > end_col :
            INDENT
                end_col = target_col

            DEDENT
            history.append([target_row, target_col, {"value" : self.GetCellValue(target_row, target_col)}])
            self.SetCellValue(target_row, target_col, value)
        DEDENT
    DEDENT
    self.SelectBlock(start_row, start_col, end_row, end_col)
    if out_of_range :
    INDENT
        wx.MessageBox("Pasted data is out of Grid range", "Warning")
    DEDENT
    self.add_history({"type" : "change", "cells" : history})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_48847045_204_243
28509629_50311733_266_320
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def paste(self, mode) :
INDENT
    if mode == 'paste' :
    INDENT

        self.build_paste_selection()
        if self.GetSelectionBlockTopLeft() == [] :
        INDENT
            rowstart = self.GetGridCursorRow()
            colstart = self.GetGridCursorCol()
        DEDENT
        else :
        INDENT
            rowstart = self.GetSelectionBlockTopLeft() [0] [0]
            colstart = self.GetSelectionBlockTopLeft() [0] [1]
        DEDENT
    DEDENT
    elif mode == 'undo' :
    INDENT
        self.out_data = self.data4undo [2]
        rowstart = self.data4undo [0]
        colstart = self.data4undo [1]
    DEDENT
    else :
    INDENT
        wx.MessageBox("Paste method " + mode + " does not exist", "Error")

    DEDENT
    text4undo = ''
    for y, r in enumerate(self.out_data.splitlines()) :
    INDENT
        for x, c in enumerate(r.split('\t')) :
        INDENT
            if y + rowstart < self.NumberRows and x + colstart < self.NumberCols :
            INDENT
                text4undo += str(self.GetCellValue(rowstart + y,
                        colstart + x)) + '\t'
                self.SetCellValue(rowstart + y, colstart + x, c)
            DEDENT
        DEDENT
        text4undo = text4undo [: - 1] + '\n'

    DEDENT
    if mode == 'paste' :
    INDENT
        self.data4undo = [rowstart, colstart, text4undo]
    DEDENT
    else :
    INDENT
        self.data4undo = [0, 0, '']
    DEDENT
DEDENT
----------------------------------------

def paste(self, event) :
INDENT
    if not wx.TheClipboard.Open() :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Warning")
        return False
    DEDENT
    clipboard = wx.TextDataObject()
    wx.TheClipboard.GetData(clipboard)
    wx.TheClipboard.Close()
    data = clipboard.GetText()
    if data [- 1] == "\n" :
    INDENT
        data = data [: - 1]
    DEDENT
    try :
    INDENT
        cells = self.get_selected_cells()
        cell = next(cells)
    DEDENT
    except StopIteration :
    INDENT
        return False
    DEDENT
    start_row = end_row = cell [0]
    start_col = end_col = cell [1]
    max_row = self.GetNumberRows()
    max_col = self.GetNumberCols()
    history = []
    out_of_range = False
    for row, line in enumerate(data.split("\n")) :
    INDENT
        target_row = start_row + row
        if not (0 < = target_row < max_row) :
        INDENT
            out_of_range = True
            break
        DEDENT
        if target_row > end_row :
        INDENT
            end_row = target_row
        DEDENT
        for col, value in enumerate(line.split("\t")) :
        INDENT
            target_col = start_col + col
            if not (0 < = target_col < max_col) :
            INDENT
                out_of_range = True
                break
            DEDENT
            if target_col > end_col :
            INDENT
                end_col = target_col

            DEDENT
            history.append([target_row, target_col, {"value" : self.GetCellValue(target_row, target_col)}])
            self.SetCellValue(target_row, target_col, value)
        DEDENT
    DEDENT
    self.SelectBlock(start_row, start_col, end_row, end_col)
    if out_of_range :
    INDENT
        wx.MessageBox("Pasted data is out of Grid range", "Warning")
    DEDENT
    self.add_history({"type" : "change", "cells" : history})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_48847045_244_287
28509629_50311733_321_332
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def delete(self) :
INDENT
    if self.GetSelectionBlockTopLeft() == [] :
    INDENT
        rowstart = self.GetGridCursorRow()
        colstart = self.GetGridCursorCol()
        rowend = rowstart
        colend = colstart
    DEDENT
    else :
    INDENT
        rowstart = self.GetSelectionBlockTopLeft() [0] [0]
        colstart = self.GetSelectionBlockTopLeft() [0] [1]
        rowend = self.GetSelectionBlockBottomRight() [0] [0]
        colend = self.GetSelectionBlockBottomRight() [0] [1]
    DEDENT
    rows = rowend - rowstart + 1
    cols = colend - colstart + 1

    text4undo = ''
    for r in range(rows) :
    INDENT
        for c in range(cols) :
        INDENT
            text4undo += str(self.GetCellValue(rowstart + r, colstart + c)) + '\t'
            self.SetCellValue(rowstart + r, colstart + c, '')
        DEDENT
        text4undo = text4undo [: - 1] + '\n'

    DEDENT
    self.data4undo = [rowstart, colstart, text4undo]

    clipboard = wx.TextDataObject()
    clipboard.SetText(text4undo)
    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")

    DEDENT
DEDENT
----------------------------------------

def delete(self, event) :
INDENT
    cells = []
    for row, col in self.get_selected_cells() :
    INDENT
        attributes = {
            "value" : self.GetCellValue(row, col),
            "alignment" : self.GetCellAlignment(row, col)}
        cells.append((row, col, attributes))
        self.SetCellValue(row, col, "")
    DEDENT
    self.add_history({"type" : "delete", "cells" : cells})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_48847045_33_63
28509629_48847045_6_15
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def __init__(self, parent, id, style) :
INDENT
    wx.grid.Grid.__init__(self, parent, id, wx.DefaultPosition,
        wx.DefaultSize, style)

    wx.EVT_KEY_DOWN(self, self.OnKey)

    self.data4undo = [0, 0, '']

    self.crows = 1
    self.ccols = 1

    data = ''

    clipboard = wx.TextDataObject()

    clipboard.SetText(data)

    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent, ID, title, pos = wx.DefaultPosition,
size = wx.Size(800, 400), style = wx.DEFAULT_FRAME_STYLE) :
INDENT
    wx.Frame.__init__(self, parent, ID, title, pos, size, style)
    agrid = CpGrid(self, - 1, wx.WANTS_CHARS)
    agrid.CreateGrid(7, 7)
    for count in range(3) :
    INDENT
        for count2 in range(3) :
        INDENT
            agrid.SetCellValue(count, count2, str(count + count2))

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_48847045_33_63
28509629_50311733_340_347
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def __init__(self, parent, id, style) :
INDENT
    wx.grid.Grid.__init__(self, parent, id, wx.DefaultPosition,
        wx.DefaultSize, style)

    wx.EVT_KEY_DOWN(self, self.OnKey)

    self.data4undo = [0, 0, '']

    self.crows = 1
    self.ccols = 1

    data = ''

    clipboard = wx.TextDataObject()

    clipboard.SetText(data)

    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent, ID, title, pos = wx.DefaultPosition, size = wx.Size(800, 400), style = wx.DEFAULT_FRAME_STYLE) :
INDENT
    wx.Frame.__init__(self, parent, ID, title, pos, size, style)
    agrid = MyGrid(self)
    agrid.CreateGrid(7, 7)
    for count in range(3) :
    INDENT
        for count2 in range(3) :
        INDENT
            agrid.SetCellValue(count, count2, str(count + count2))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_48847045_33_63
28509629_50311733_6_15
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def __init__(self, parent, id, style) :
INDENT
    wx.grid.Grid.__init__(self, parent, id, wx.DefaultPosition,
        wx.DefaultSize, style)

    wx.EVT_KEY_DOWN(self, self.OnKey)

    self.data4undo = [0, 0, '']

    self.crows = 1
    self.ccols = 1

    data = ''

    clipboard = wx.TextDataObject()

    clipboard.SetText(data)

    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.grid.Grid.__init__(self, parent, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0)
    self.Bind(wx.EVT_KEY_DOWN, self.on_key)
    self.Bind(wx.grid.EVT_GRID_CELL_CHANGING, self.on_change)
    self.Bind(wx.grid.EVT_GRID_LABEL_RIGHT_CLICK, self.on_label_right_click)
    self.Bind(wx.grid.EVT_GRID_CELL_RIGHT_CLICK, self.on_cell_right_click)
    self.selected_rows = []
    self.selected_cols = []
    self.history = []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_48847045_6_15
28509629_50311733_6_15
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def __init__(self, parent, ID, title, pos = wx.DefaultPosition,
size = wx.Size(800, 400), style = wx.DEFAULT_FRAME_STYLE) :
INDENT
    wx.Frame.__init__(self, parent, ID, title, pos, size, style)
    agrid = CpGrid(self, - 1, wx.WANTS_CHARS)
    agrid.CreateGrid(7, 7)
    for count in range(3) :
    INDENT
        for count2 in range(3) :
        INDENT
            agrid.SetCellValue(count, count2, str(count + count2))

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.grid.Grid.__init__(self, parent, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0)
    self.Bind(wx.EVT_KEY_DOWN, self.on_key)
    self.Bind(wx.grid.EVT_GRID_CELL_CHANGING, self.on_change)
    self.Bind(wx.grid.EVT_GRID_LABEL_RIGHT_CLICK, self.on_label_right_click)
    self.Bind(wx.grid.EVT_GRID_CELL_RIGHT_CLICK, self.on_cell_right_click)
    self.selected_rows = []
    self.selected_cols = []
    self.history = []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_48847045_91_133
28509629_50311733_235_265
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def copy(self) :
INDENT
    if self.GetSelectionBlockTopLeft() == [] :
    INDENT
        rowstart = self.GetGridCursorRow()
        colstart = self.GetGridCursorCol()
        rowend = rowstart
        colend = colstart
    DEDENT
    else :
    INDENT
        rowstart = self.GetSelectionBlockTopLeft() [0] [0]
        colstart = self.GetSelectionBlockTopLeft() [0] [1]
        rowend = self.GetSelectionBlockBottomRight() [0] [0]
        colend = self.GetSelectionBlockBottomRight() [0] [1]
    DEDENT
    self.crows = rowend - rowstart + 1
    self.ccols = colend - colstart + 1

    data = ''

    for r in range(self.crows) :
    INDENT
        for c in range(self.ccols) :
        INDENT
            data += str(self.GetCellValue(rowstart + r, colstart + c))
            if c < self.ccols - 1 :
            INDENT
                data += '\t'
            DEDENT
        DEDENT
        data += '\n'

    DEDENT
    clipboard = wx.TextDataObject()

    clipboard.SetText(data)

    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(clipboard)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Error")
    DEDENT
DEDENT
----------------------------------------

def copy(self, event) :
INDENT
    selection = self.get_selection()
    if not selection :
    INDENT
        return []
    DEDENT
    start_row, start_col, end_row, end_col = selection
    data = u''
    rows = range(start_row, end_row + 1)
    for row in rows :
    INDENT
        columns = range(start_col, end_col + 1)
        for idx, column in enumerate(columns, 1) :
        INDENT
            if idx == len(columns) :
            INDENT

                data += self.GetCellValue(row, column) + "\n"
            DEDENT
            else :
            INDENT
                data += self.GetCellValue(row, column) + "\t"
            DEDENT
        DEDENT
    DEDENT
    text_data_object = wx.TextDataObject()
    text_data_object.SetText(data)
    if wx.TheClipboard.Open() :
    INDENT
        wx.TheClipboard.SetData(text_data_object)
        wx.TheClipboard.Close()
    DEDENT
    else :
    INDENT
        wx.MessageBox("Can't open the clipboard", "Warning")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28509629_50311733_340_347
28509629_50311733_6_15
Title: Work with ctrl-c and ctrl-v to copy and paste into a wx.Grid in wxPython 
----------------------------------------

def __init__(self, parent, ID, title, pos = wx.DefaultPosition, size = wx.Size(800, 400), style = wx.DEFAULT_FRAME_STYLE) :
INDENT
    wx.Frame.__init__(self, parent, ID, title, pos, size, style)
    agrid = MyGrid(self)
    agrid.CreateGrid(7, 7)
    for count in range(3) :
    INDENT
        for count2 in range(3) :
        INDENT
            agrid.SetCellValue(count, count2, str(count + count2))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.grid.Grid.__init__(self, parent, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, 0)
    self.Bind(wx.EVT_KEY_DOWN, self.on_key)
    self.Bind(wx.grid.EVT_GRID_CELL_CHANGING, self.on_change)
    self.Bind(wx.grid.EVT_GRID_LABEL_RIGHT_CLICK, self.on_label_right_click)
    self.Bind(wx.grid.EVT_GRID_CELL_RIGHT_CLICK, self.on_cell_right_click)
    self.selected_rows = []
    self.selected_cols = []
    self.history = []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28531646_28531859_1_8
28531646_28531905_3_15
Title: how to find max element from dictionary that has list of lists in python 
----------------------------------------

def create_champion_index(d, n) :
INDENT
    new_d = {}
    for k, v in d.items() :
    INDENT

        new_d [k] = sorted(v, key = sum, reverse = True) [: n]
    DEDENT
    return new_d
DEDENT
----------------------------------------

def create_champion_index(in_dict, threshold = 2) :
INDENT
    from heapq import nlargest
    from itertools import count
    retdict = {}
    for key in in_dict :
    INDENT
        this_list = in_dict [key]
        this_list_sublists_sorted = [sorted(x, reverse = True) for x in this_list]
        max_ndcs = nlargest(threshold, zip(this_list_sublists_sorted, count()))
        ndcs = [x [1] for x in max_ndcs]
        retlist = [this_list [i] for i in ndcs]
        retdict [key] = retlist
    DEDENT
    return retdict
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28546253_29148850_1_21
28546253_48513771_8_36
Title: How to create request body for Python Elasticsearch mSearch 
----------------------------------------

def msearch() :
INDENT
    es = get_es_instance()
    search_arr = []
    search_arr.append({'index' : 'my_test_index', 'type' : 'doc_type_1'})
    search_arr.append({"query" : {"term" : {"text" : "bag"}}, 'from' : 0, 'size' : 2})

    search_arr.append({'index' : 'my_test_index', 'type' : 'doc_type_2'})
    search_arr.append({"query" : {"match_all" : {}}, 'from' : 0, 'size' : 2})
    request = ''
    for each in search_arr :
    INDENT
        request += '%s \n' % json.dumps(each)

    DEDENT
    resp = es.msearch(body = request)
DEDENT
----------------------------------------

def msearch(es_conn, queries, index, doc_type, retries = 0) :
INDENT
    search_header = json.dumps({'index' : index, 'type' : doc_type})
    request = ''
    for q in queries :
    INDENT

        request += '{}\n{}\n'.format(search_header, json.dumps(q))
    DEDENT
    try :
    INDENT
        resp = es_conn.msearch(body = request, index = index)
        found = [r ['hits'] ['hits'] for r in resp ['responses']]
    DEDENT
    except (es_exceptions.ConnectionTimeout, es_exceptions.ConnectionError,
        es_exceptions.TransportError) :
    INDENT
        logging.warning("msearch connection failed, retrying...")
        if retries > RETRY_ATTEMPTS :
        INDENT
            raise
        DEDENT
        time.sleep(RECONNECT_SLEEP_SECS)
        found = msearch(queries = queries, index = index, retries = retries + 1)
    DEDENT
    except Exception as e :
    INDENT
        logging.critical("msearch error {} on query {}".format(e, queries))
        raise
    DEDENT
    return found
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28560813_28561073_1_22
28560813_28561171_1_15
Title: list of list concept in python 
----------------------------------------

def numbers_in_lists(string) :
INDENT
    current_min = - 1
    rv = []
    current_list = []
    def push_sublist() :
    INDENT
        if current_list :
        INDENT
            largest = current_list.pop(0)
            rv.append(largest)
            if current_list :
            INDENT
                rv.append(current_list)
            DEDENT
        DEDENT
    DEDENT
    for digit in map(int, string) :
    INDENT
        if digit > current_min :
        INDENT
            push_sublist()
            current_list = []
            current_min = digit
        DEDENT
        current_list.append(digit)
    DEDENT
    push_sublist()
    return rv
DEDENT
----------------------------------------

def numbers_in_lists(string) :
INDENT
    output = []
    sublist = []
    for num in map(int, string) :
    INDENT
        if not output or num > output [- 1] :
        INDENT
            if sublist :
            INDENT
                output.append(sublist)
                sublist = []
            DEDENT
            output.append(num)
        DEDENT
        else :
        INDENT
            sublist.append(num)
        DEDENT
    DEDENT
    if sublist :
    INDENT
        output.append(sublist)
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28560813_28561073_1_22
28560813_28561790_1_24
Title: list of list concept in python 
----------------------------------------

def numbers_in_lists(string) :
INDENT
    current_min = - 1
    rv = []
    current_list = []
    def push_sublist() :
    INDENT
        if current_list :
        INDENT
            largest = current_list.pop(0)
            rv.append(largest)
            if current_list :
            INDENT
                rv.append(current_list)
            DEDENT
        DEDENT
    DEDENT
    for digit in map(int, string) :
    INDENT
        if digit > current_min :
        INDENT
            push_sublist()
            current_list = []
            current_min = digit
        DEDENT
        current_list.append(digit)
    DEDENT
    push_sublist()
    return rv
DEDENT
----------------------------------------

def numbers_in_lists(string) :
INDENT
    output = []
    sublist = []
    for number in [int(c) for c in string] :
    INDENT
        if output and number < = output [- 1] :
        INDENT
            """
            - If a number x in the string is less than or equal
              to the preceding number y, the number x should be
              inserted into a sublist.
            - Continue adding the following numbers to the sublist
              until reaching a number z that is greater than the number y.
            """
            sublist.append(number)
        DEDENT
        else :
        INDENT
            """
            - Then add this number z to the normal list and continue.
            """
            if sublist :
            INDENT
                output.append(sublist)
                sublist = []
            DEDENT
            output.append(number)
        DEDENT
    DEDENT
    if sublist :
    INDENT
        output.append(sublist)
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28560813_28561171_1_15
28560813_28561790_1_24
Title: list of list concept in python 
----------------------------------------

def numbers_in_lists(string) :
INDENT
    output = []
    sublist = []
    for num in map(int, string) :
    INDENT
        if not output or num > output [- 1] :
        INDENT
            if sublist :
            INDENT
                output.append(sublist)
                sublist = []
            DEDENT
            output.append(num)
        DEDENT
        else :
        INDENT
            sublist.append(num)
        DEDENT
    DEDENT
    if sublist :
    INDENT
        output.append(sublist)
    DEDENT
    return output
DEDENT
----------------------------------------

def numbers_in_lists(string) :
INDENT
    output = []
    sublist = []
    for number in [int(c) for c in string] :
    INDENT
        if output and number < = output [- 1] :
        INDENT
            """
            - If a number x in the string is less than or equal
              to the preceding number y, the number x should be
              inserted into a sublist.
            - Continue adding the following numbers to the sublist
              until reaching a number z that is greater than the number y.
            """
            sublist.append(number)
        DEDENT
        else :
        INDENT
            """
            - Then add this number z to the normal list and continue.
            """
            if sublist :
            INDENT
                output.append(sublist)
                sublist = []
            DEDENT
            output.append(number)
        DEDENT
    DEDENT
    if sublist :
    INDENT
        output.append(sublist)
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28567530_28568178_19_33
28567530_28568178_53_61
Title: Python stopwatch example - starting all class instances at the same time? 
----------------------------------------

def __init__(self, master = None, cnf = {}, ** kw) :
INDENT
    padding = dict(padx = kw.pop('padx', 5), pady = kw.pop('pady', 5))
    super().__init__(master, cnf, ** kw)
    self.grid_columnconfigure(1, weight = 1)
    self.grid_rowconfigure(1, weight = 1)
    self.__total = 0
    self.__label = tkinter.Label(self, text = 'Total Time:')
    self.__time = tkinter.StringVar(self, '0.000000')
    self.__display = tkinter.Label(self, textvariable = self.__time)
    self.__button = tkinter.Button(self, text = 'Start', command = self.click)
    self.__label.grid(row = 0, column = 0, sticky = tkinter.E, ** padding)
    self.__display.grid(row = 0, column = 1, sticky = tkinter.EW, ** padding)
    self.__button.grid(row = 1, column = 0, columnspan = 2,
        sticky = tkinter.NSEW, ** padding)
DEDENT
----------------------------------------

def __init__(self, count) :
INDENT
    super().__init__()
    self.title('Stopwatches')
    padding = dict(padx = 5, pady = 5)
    tkinter.Button(self, text = 'Toggle All', command = self.click).grid(
        sticky = tkinter.NSEW, ** padding)
    for _ in range(count) :
    INDENT
        StopWatch(self, ** padding).grid(sticky = tkinter.NSEW, ** padding)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28567530_28568178_34_42
28567530_28568178_62_66
Title: Python stopwatch example - starting all class instances at the same time? 
----------------------------------------

def click(self) :
INDENT
    if self.__button ['text'] == 'Start' :
    INDENT
        self.__button ['text'] = 'Stop'
        self.__start = time.clock()
        self.__counter = self.after_idle(self.__update)
    DEDENT
    else :
    INDENT
        self.__button ['text'] = 'Start'
        self.after_cancel(self.__counter)
    DEDENT
DEDENT
----------------------------------------

def click(self) :
INDENT
    for child in self.children.values() :
    INDENT
        if isinstance(child, StopWatch) :
        INDENT
            child.click()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28593638_28593903_3_7
28593638_28593980_5_40
Title: How can I iterate tuples in this code python? 
----------------------------------------

def readfile() :
INDENT
    with open('file.log', 'r') as f :
    INDENT
        for line in f :
        INDENT
            yield ast.literal_eval(line)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def readfile() :
INDENT
    """ Reads a file consisting of a list of tuples (x, y) line-by-line. Prints x and y of the current line and the next line as reading ensues. """
    file_in = open("./tuples.txt", "r")
    result = []
    while True :
    INDENT

        line = file_in.readline()
        go_back = file_in.tell()
        next_line = file_in.readline()
        x, y = str(line).replace("(", "").replace(")", "").replace(" ", "").rstrip().lstrip().split(",")

        try :
        INDENT

            x_next, y_next = str(next_line).replace("(", "").replace(")", "").replace(" ", "").rstrip().lstrip().split(",")
            result.append([float(x), float(y)])
            print "current line: " + str(x) + " " + str(y) + " ..next line: " + str(x_next) + " " + str(y_next)
        DEDENT
        except ValueError :
        INDENT
            print "current line: " + str(x) + " " + str(y) + " ..next line: " + "NaN NaN"
            break
        DEDENT
        line = file_in.seek(go_back)
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28599068_39105034_10_55
28599068_46370324_32_128
Title: Changing the edge color of zoom-rect in matplotlib 
----------------------------------------

def paintEvent(self, e) :
INDENT
    paintcolor = QCore.Qt.black if not hasattr(self, "rectanglecolor") else self.rectanglecolor
    if not hasattr(self, 'renderer') :
    INDENT
        return
    DEDENT
    if self.blitbox is None :
    INDENT
        if QCore.QSysInfo.ByteOrder == QCore.QSysInfo.LittleEndian :
        INDENT
            stringBuffer = self.renderer._renderer.tostring_bgra()
        DEDENT
        else :
        INDENT
            stringBuffer = self.renderer._renderer.tostring_argb()
        DEDENT
        refcnt = sys.getrefcount(stringBuffer)
        qImage = QGui.QImage(stringBuffer, self.renderer.width,
            self.renderer.height,
            QGui.QImage.Format_ARGB32)
        rect = qImage.rect()
        p = QGui.QPainter(self)
        p.eraseRect(rect)
        p.drawPixmap(QCore.QPoint(0, 0), QGui.QPixmap.fromImage(qImage))
        if self._drawRect is not None :
        INDENT
            p.setPen(QGui.QPen(paintcolor, 1, QCore.Qt.DotLine))
            x, y, w, h = self._drawRect
            p.drawRect(x, y, w, h)
        DEDENT
        p.end()
        del qImage
        if refcnt ! = sys.getrefcount(stringBuffer) :
        INDENT
            _decref(stringBuffer)
        DEDENT
    DEDENT
    else :
    INDENT
        bbox = self.blitbox
        l, b, r, t = bbox.extents
        w = int(r) - int(l)
        h = int(t) - int(b)
        t = int(b) + h
        reg = self.copy_from_bbox(bbox)
        stringBuffer = reg.to_string_argb()
        qImage = QGui.QImage(stringBuffer, w, h,
            QGui.QImage.Format_ARGB32)
        if QT_API == 'PySide' and six.PY3 :
        INDENT
            ctypes.c_long.from_address(id(stringBuffer)).value = 1
        DEDENT
        pixmap = QGui.QPixmap.fromImage(qImage)
        p = QGui.QPainter(self)
        p.drawPixmap(QCore.QPoint(l, self.renderer.height - t), pixmap)
        if self._drawRect is not None :
        INDENT
            p.setPen(QGui.QPen(paintcolor, 1, QCore.Qt.DotLine))
            x, y, w, h = self._drawRect
            p.drawRect(x, y, w, h)
        DEDENT
        p.end()
        self.blitbox = None
    DEDENT
DEDENT
----------------------------------------

def paintEvent(self, e) :
INDENT
    if not hasattr(self, 'renderer') :
    INDENT
        return
    DEDENT
    if DEBUG :
    INDENT
        print ('FigureCanvasQtAgg.paintEvent: ', self,
            self.get_width_height())
    DEDENT
    if len(self.blitbox) == 0 :
    INDENT
        if QtCore.QSysInfo.ByteOrder == QtCore.QSysInfo.LittleEndian :
        INDENT
            stringBuffer = self.renderer._renderer.tostring_bgra()
        DEDENT
        else :
        INDENT
            stringBuffer = self.renderer._renderer.tostring_argb()
        DEDENT
        refcnt = sys.getrefcount(stringBuffer)

        qImage = QtGui.QImage(stringBuffer, self.renderer.width,
            self.renderer.height,
            QtGui.QImage.Format_ARGB32)
        if hasattr(qImage, 'setDevicePixelRatio') :
        INDENT

            qImage.setDevicePixelRatio(self._dpi_ratio)
        DEDENT
        rect = qImage.rect()
        p = QtGui.QPainter(self)
        p.eraseRect(rect)
        p.drawPixmap(QtCore.QPoint(0, 0), QtGui.QPixmap.fromImage(qImage))

        if self._drawRect is not None :
        INDENT
            pen = QtGui.QPen(QtCore.Qt.white, 1 / self._dpi_ratio,
                QtCore.Qt.DotLine)
            p.setPen(pen)
            x, y, w, h = self._drawRect
            p.drawRect(x, y, w, h)
        DEDENT
        p.end()

        del qImage
        if refcnt ! = sys.getrefcount(stringBuffer) :
        INDENT
            _decref(stringBuffer)
        DEDENT
    DEDENT
    else :
    INDENT
        p = QtGui.QPainter(self)
        while len(self.blitbox) :
        INDENT
            bbox = self.blitbox.pop()
            l, b, r, t = bbox.extents
            w = int(r) - int(l)
            h = int(t) - int(b)
            t = int(b) + h
            reg = self.copy_from_bbox(bbox)
            stringBuffer = reg.to_string_argb()
            qImage = QtGui.QImage(stringBuffer, w, h,
                QtGui.QImage.Format_ARGB32)
            if hasattr(qImage, 'setDevicePixelRatio') :
            INDENT

                qImage.setDevicePixelRatio(self._dpi_ratio)

            DEDENT
            if QT_API == 'PySide' and six.PY3 :
            INDENT
                ctypes.c_long.from_address(id(stringBuffer)).value = 1
            DEDENT
            origin = QtCore.QPoint(l, self.renderer.height - t)
            pixmap = QtGui.QPixmap.fromImage(qImage)
            p.drawPixmap(origin / self._dpi_ratio, pixmap)

        DEDENT
        if self._drawRect is not None :
        INDENT
            pen = QtGui.QPen(QtCore.Qt.black, 1 / self._dpi_ratio,
                QtCore.Qt.DotLine)
            p.setPen(pen)
            x, y, w, h = self._drawRect
            p.drawRect(x, y, w, h)
        DEDENT
        p.end()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28602338_28602709_1_10
28602338_28603435_9_34
Title: Split array to approximately equal chunks 
----------------------------------------

def foo(lst) :
INDENT
    total_sum = sum(lst)
    i = 1
    while sum(lst [: i]) < total_sum / 2 :
    INDENT
        if sum(lst [: i + 1]) > = total_sum / 2 :
        INDENT
            break
        DEDENT
        i += 1
    DEDENT
    return [lst [: i], lst [i :]]
DEDENT
----------------------------------------

def foo(Input) :
INDENT
    size = len(Input)
    checkLeftCross = 0
    previousLeft = 0
    previousRight = 0
    currentLeft = 0
    currentRight = 0
    targetIndex = 0
    for i in range(size) :
    INDENT
        currentLeft = sum(Input [0 : i])
        currentRight = sum(Input [i : size])
        if currentLeft > = currentRight :
        INDENT
            targetIndex = i
            break
        DEDENT
        else :
        INDENT
            previousLeft = currentLeft
            previousRight = currentRight
        DEDENT
    DEDENT
    diffPrev = previousRight - previousLeft
    diffCurr = currentLeft - currentRight
    if diffPrev > diffCurr :
    INDENT
        return Input [0 : targetIndex], Input [targetIndex : size]
    DEDENT
    else :
    INDENT
        return Input [0 : targetIndex - 1], Input [targetIndex - 1 : size]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28607666_28608444_12_25
28607666_28608583_12_19
Title: Maybe monad in Python with method chaining 
----------------------------------------

def do(self, func) :
INDENT
    if self.val is not None :
    INDENT
        try :
        INDENT
            val = func(self.val)
        DEDENT
        except Exception as e :
        INDENT
            return Maybe(None, e)
        DEDENT
        if not isinstance(val, Maybe) :
        INDENT
            return Maybe(val)
        DEDENT
        else :
        INDENT
            return val
        DEDENT
    DEDENT
    else :
    INDENT
        return Maybe(None, self.err)

    DEDENT
DEDENT
----------------------------------------

def do(self, func) :
INDENT
    if self.val is None :
    INDENT
        return self
    DEDENT
    try :
    INDENT
        return Maybe(func(self.val))
    DEDENT
    except Exception as e :
    INDENT
        return Maybe(None, e)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28613102_30749014_6_14
28613102_41785255_17_25
Title: last_login field is not updated when authenticating using Tokenauthentication in Django Rest Framework 
----------------------------------------

def post(self, request) :
INDENT
    result = super(TokenAuthenticationView, self).post(request)
    try :
    INDENT
        request_user, data = requests.get_parameters(request)
        user = requests.get_user_by_username(data ['username'])
        update_last_login(None, user)
    DEDENT
    except Exception as exc :
    INDENT
        return None
    DEDENT
    return result
DEDENT
----------------------------------------

def post(self, request, * args, ** kwargs) :
INDENT
    serializer = self.serializer_class(data = request.data)
    serializer.is_valid(raise_exception = True)
    user = serializer.validated_data ['user']
    token, created = Token.objects.get_or_create(user = user)
    user_logged_in.send(sender = user.__class__, request = request, user = user)
    return Response({'token' : token.key, 'user' : UserSerializer(user).data})

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28613102_30749014_6_14
28613102_52727528_7_13
Title: last_login field is not updated when authenticating using Tokenauthentication in Django Rest Framework 
----------------------------------------

def post(self, request) :
INDENT
    result = super(TokenAuthenticationView, self).post(request)
    try :
    INDENT
        request_user, data = requests.get_parameters(request)
        user = requests.get_user_by_username(data ['username'])
        update_last_login(None, user)
    DEDENT
    except Exception as exc :
    INDENT
        return None
    DEDENT
    return result
DEDENT
----------------------------------------

def post(self, request, * args, ** kwargs) :
INDENT
    response = super().post(request, * args, ** kwargs)
    if response.status_code == status.HTTP_200_OK :
    INDENT
        token = AccessToken.objects.get(token = response.data ['access_token'])
        user = token.user
        user_logged_in.send(sender = type(user), request = request, user = user)
    DEDENT
    return response
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28613102_41785255_17_25
28613102_52727528_7_13
Title: last_login field is not updated when authenticating using Tokenauthentication in Django Rest Framework 
----------------------------------------

def post(self, request, * args, ** kwargs) :
INDENT
    serializer = self.serializer_class(data = request.data)
    serializer.is_valid(raise_exception = True)
    user = serializer.validated_data ['user']
    token, created = Token.objects.get_or_create(user = user)
    user_logged_in.send(sender = user.__class__, request = request, user = user)
    return Response({'token' : token.key, 'user' : UserSerializer(user).data})

DEDENT
----------------------------------------

def post(self, request, * args, ** kwargs) :
INDENT
    response = super().post(request, * args, ** kwargs)
    if response.status_code == status.HTTP_200_OK :
    INDENT
        token = AccessToken.objects.get(token = response.data ['access_token'])
        user = token.user
        user_logged_in.send(sender = type(user), request = request, user = user)
    DEDENT
    return response
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28615507_28745655_17_27
28615507_28745655_44_57
Title: Convert OpenCV IplImage* data to numpy array 
----------------------------------------

def __repr__(self) :
INDENT
    res = []
    for field in self._fields_ :
    INDENT
        res.append('%s=%s' % (field [0], repr(getattr(self, field [0]))))
    DEDENT
    return self.__class__.__name__ + '(' + ','.join(res) + ')'
DEDENT
----------------------------------------

def __repr__(self) :
INDENT
    res = []
    for field in self._fields_ :
    INDENT
        if field [0] in ['imageData', 'imageDataOrigin'] :
        INDENT
            continue
        DEDENT
        res.append('%s=%s' % (field [0], repr(getattr(self, field [0]))))
    DEDENT
    return self.__class__.__name__ + '(' + ','.join(res) + ')'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28631981_28632011_5_15
28631981_28632054_5_12
Title: How to add characters to filename using glob in Python? 
----------------------------------------

def run() :
INDENT
    input = path_res + "/" + "input.shp"

    os.chdir(path_dir)
    for fname in glob.glob("*.shp") :
    INDENT
        output = path_res + "/" + fname
        run_function, input, output
    DEDENT
DEDENT
----------------------------------------

def run() :
INDENT
    os.chdir(path_dir)
    for fname in glob.glob("*.shp") :
    INDENT
        name, ex = fname.rsplit(".", 1)
        shutil.copy(fname, os.path.join(path_res, "{}{}{}".format(name, "(A)", ex)))

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28657935_28658373_23_55
28657935_28911977_43_90
Title: New Google ReCAPTCHA with django-recaptcha 
----------------------------------------

def submit(recaptcha_secret, recaptcha_response, remoteip = '') :
INDENT
    if not (recaptcha_secret and recaptcha_response and len(recaptcha_secret) and len(recaptcha_response)) :
    INDENT
        return RecaptchaResponse(is_valid = False, error_code = 'incorrect-captcha-sol')
    DEDENT
    def encode_if_necessary(s) :
    INDENT
        if isinstance(s, unicode) :
        INDENT
            return s.encode('utf-8')
        DEDENT
        return s
    DEDENT
    params = urllib.urlencode({
            'secret' : encode_if_necessary(recaptcha_secret),
            'response' : encode_if_necessary(recaptcha_response),
            'remoteip' : encode_if_necessary(remoteip)})
    request = urllib2.Request(
        url = API_SERVER,
        data = params,
        headers = {
            "Content-type" : "application/x-www-form-urlencoded",
            "User-agent" : "reCAPTCHA Python"})
    httpresp = urllib2.urlopen(request)
    return_values = json.loads(httpresp.read())
    print return_values
    if return_values.get('success', False) :
    INDENT
        return RecaptchaResponse(is_valid = True)
    DEDENT
    else :
    INDENT
        return RecaptchaResponse(is_valid = False, error_code = return_values.get('error-codes', ''))
    DEDENT
DEDENT
----------------------------------------

def submit(response,
secret_key,
remote_ip,
verify_server = VERIFY_SERVER) :
INDENT
    if not (response and len(response)) :
    INDENT
        return RecaptchaResponse(is_valid = False, error_code = 'incorrect-captcha-sol')
    DEDENT
    def encode_if_necessary(s) :
    INDENT
        if isinstance(s, str) :
        INDENT
            return s.encode('utf-8')
        DEDENT
        return s
    DEDENT
    params = urlencode({
            'secret' : encode_if_necessary(secret_key),
            'remoteip' : encode_if_necessary(remote_ip),
            'response' : encode_if_necessary(response),
            })
    params = params.encode('utf-8')
    request = Request(
        url = "https://%s/recaptcha/api/siteverify" % verify_server,
        data = params,
        headers = {
            "Content-type" : "application/x-www-form-urlencoded",
            "User-agent" : "reCAPTCHA Python"})
    httpresp = urlopen(request)
    return_values = json.loads(httpresp.read().decode('utf-8'))
    httpresp.close()
    return_code = return_values ['success']
    if return_code :
    INDENT
        return RecaptchaResponse(is_valid = True)
    DEDENT
    else :
    INDENT
        return RecaptchaResponse(is_valid = False, error_code = return_values ['error-codes'])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28664720_28721419_14_20
28664720_28854553_11_18
Title: How to create global lock/semaphore with multiprocessing.pool in Python? 
----------------------------------------

def main() :
INDENT
    lock = Lock()
    poolsize = 4
    with Pool(poolsize, initializer = init_child, initargs = (lock,)) as pool :
    INDENT
        results = pool.imap_unordered(do_job, range(poolsize))
        print (list(results))
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    pool = multiprocessing.Pool(6)
    for job_id in range(6) :
    INDENT
        print ("Starting job")
        pool.apply_async(do_job, [job_id])
    DEDENT
    pool.close()
    pool.join()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28676187_28676904_3_10
28676187_28677450_3_13
Title: numpy blit (copy part of an array to another one with a different size) 
----------------------------------------

def blit(dest, src, loc) :
INDENT
    pos = [i if i > = 0 else None for i in loc]
    neg = [- i if i < 0 else None for i in loc]
    target = dest [[slice(i, None) for i in pos]]
    src = src [[slice(i, j) for i, j in zip(neg, target.shape)]]
    target [[slice(None, i) for i in src.shape]] = src
    return dest
DEDENT
----------------------------------------

def blit(dest, src, loc) :
INDENT
    th, tw = dest.shape
    sh, sw = src.shape
    sr = 0 if - loc [0] < 0 else - loc [0]
    fr = sh if loc [0] + sh < = th else sh - (loc [0] + sh - th)
    sc = 0 if - loc [1] < 0 else - loc [1]
    fc = sw if loc [1] + sw < = tw else sw - (loc [1] + sw - th)
    loc [0] = max(0, loc [0])
    loc [1] = max(0, loc [1])
    dest [loc [0] : loc [0] + sh - sr, loc [1] : loc [1] + sw - sc] = src [sr : fr, sc : fc]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28689895_28690045_11_16
28689895_28690109_1_14
Title: Missing positional arguments? (python help) 
----------------------------------------

def findLocation(year_to_location, year) :
INDENT
    if year in year_to_location :
    INDENT
        return year_to_location [year]
    DEDENT
    else :
    INDENT
        print ("That was incorrect")
    DEDENT
DEDENT
----------------------------------------

def findLocation(yearList, locList, year) :
INDENT
    i = 0
    location = ""
    while i < len(locList) :
    INDENT
        if yearList [i] == year :
        INDENT
            return locList [i]
        DEDENT
        elif int(yearList [i]) > int(year) :
        INDENT
            print "That was incorrect"
            return
        DEDENT
        i += 1
    DEDENT
    print "Year was incorrect"
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28762116_40086042_18_40
28762116_40104583_14_25
Title: Cannot construct tkinter.PhotoImage from PIL Image 
----------------------------------------

def __init__(self) :
INDENT
    self.root = tkinter.Tk()
    self.frame = tkinter.Frame(self.root, width = 500, height = 400)
    self.frame.pack()
    self.canvas = tkinter.Canvas(self.frame, width = 500, height = 400)
    self.canvas.place(x = - 2, y = - 2)
    self.root.after(0, self.start)
    self.root.mainloop()
    def start(self) :
    INDENT
        global data
        global theimage
        self.theimage.frombytes(self.data.astype('b').tobytes())
        self.theimage.save('work.pgm')
        self.photo = tkinter.PhotoImage(file = 'work.pgm')
        self.canvas.create_image(0, 0, image = self.photo, anchor = tkinter.NW)
        self.root.update()
        self.times += 1
        if self.times % 33 == 0 :
        INDENT
            print ("%.02f FPS" % (self.times / (time.clock() - self.timestart)))
        DEDENT
        self.root.after(10, self.start)
        self.data = numpy.roll(self.data, - 1, 1)
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = tkinter.Tk()
    self.frame = tkinter.Frame(self.root, width = 500, height = 400)
    self.frame.pack()
    self.canvas = tkinter.Canvas(self.frame, width = 500, height = 400)
    self.canvas.place(x = - 2, y = - 2)
    xdata = b'P5 500 400 255 ' + self.data.tobytes()
    self.photo = tkinter.PhotoImage(width = 500, height = 400, data = xdata, format = 'PPM')
    self.imid = self.canvas.create_image(0, 0, image = self.photo, anchor = tkinter.NW)
    self.root.after(1, self.start)
    self.root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28762116_40086042_27_40
28762116_40104583_26_41
Title: Cannot construct tkinter.PhotoImage from PIL Image 
----------------------------------------

def start(self) :
INDENT
    global data
    global theimage
    self.theimage.frombytes(self.data.astype('b').tobytes())
    self.theimage.save('work.pgm')
    self.photo = tkinter.PhotoImage(file = 'work.pgm')
    self.canvas.create_image(0, 0, image = self.photo, anchor = tkinter.NW)
    self.root.update()
    self.times += 1
    if self.times % 33 == 0 :
    INDENT
        print ("%.02f FPS" % (self.times / (time.clock() - self.timestart)))
    DEDENT
    self.root.after(10, self.start)
    self.data = numpy.roll(self.data, - 1, 1)
DEDENT
----------------------------------------

def start(self) :
INDENT
    global data
    xdata = b'P5 500 400 255 ' + numpy.clip(self.data, 0, 255).tobytes()
    self.photo = tkinter.PhotoImage(width = 500, height = 400, data = xdata, format = 'PPM')
    if True :
    INDENT
        self.canvas.itemconfig(self.imid, image = self.photo)
    DEDENT
    else :
    INDENT
        self.canvas.delete(self.imid)
        self.imid = self.canvas.create_image(0, 0, image = self.photo, anchor = tkinter.NW)
    DEDENT
    self.times += 1
    if self.times % 33 == 0 :
    INDENT
        print ("%.02f FPS" % (self.times / (time.clock() - self.timestart)))
    DEDENT
    self.root.update()
    self.root.after(0, self.start)
    self.data = numpy.roll(self.data, - 1, 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28767826_28768938_16_20
28767826_28768938_38_44
Title: Python decorator call function multiple times 
----------------------------------------

def decorator(func) :
INDENT
    def wrapped_function(* args, ** kwargs) :
    INDENT
        for d in argdicts :
        INDENT
            func(** d)
        DEDENT
    DEDENT
    return wrapped_function
DEDENT
----------------------------------------

def decorator(func) :
INDENT
    dlist = [[(k, v) for v in kwargs [k]] for k in kwargs.keys()]
    argdicts = [dict(item) for item in zip(* dlist)]
    def wrapped_function(* args, ** kwargs) :
    INDENT
        for d in argdicts :
        INDENT
            func(** d)
        DEDENT
    DEDENT
    return wrapped_function
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28767826_28768938_16_20
28767826_28769144_3_13
Title: Python decorator call function multiple times 
----------------------------------------

def decorator(func) :
INDENT
    def wrapped_function(* args, ** kwargs) :
    INDENT
        for d in argdicts :
        INDENT
            func(** d)
        DEDENT
    DEDENT
    return wrapped_function
DEDENT
----------------------------------------

def decorator(func) :
INDENT
    funcname = func.__name__
    if funcname not in cache :
    INDENT

        cache [funcname] = func
    DEDENT
    @ functools.wraps(func)
    def wrapped_function(** kwargs) :
    INDENT
        if cache [funcname] ! = func :
        INDENT
            cache [funcname](** case)
        DEDENT
        func(** case)
    DEDENT
    return wrapped_function
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28767826_28768938_38_44
28767826_28769144_3_13
Title: Python decorator call function multiple times 
----------------------------------------

def decorator(func) :
INDENT
    dlist = [[(k, v) for v in kwargs [k]] for k in kwargs.keys()]
    argdicts = [dict(item) for item in zip(* dlist)]
    def wrapped_function(* args, ** kwargs) :
    INDENT
        for d in argdicts :
        INDENT
            func(** d)
        DEDENT
    DEDENT
    return wrapped_function
DEDENT
----------------------------------------

def decorator(func) :
INDENT
    funcname = func.__name__
    if funcname not in cache :
    INDENT

        cache [funcname] = func
    DEDENT
    @ functools.wraps(func)
    def wrapped_function(** kwargs) :
    INDENT
        if cache [funcname] ! = func :
        INDENT
            cache [funcname](** case)
        DEDENT
        func(** case)
    DEDENT
    return wrapped_function
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28777024_28777082_1_11
28777024_28777136_4_17
Title: Python: get the range between two dotted numbers 
----------------------------------------

def get_dotted_range(start, end) :
INDENT
    sparts = start.split('.')
    eparts = end.split('.')
    prefix = '.'.join(sparts [0 : - 1])
    slast = int(sparts [- 1])
    elast = int(eparts [- 1])
    return [prefix + '.' + str(i) for i in range(slast, elast + 1)]
DEDENT
----------------------------------------

def get_dotted_range(start, end) :
INDENT
    start = start.split(".")
    end = end.split(".")
    x = int(start.pop())
    y = int(end.pop())

    if start ! = end :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        head = ".".join(start) + "."
        return [head + str(i) for i in range(x, y + 1)]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
28777219_47712620_1_11
28777219_47713392_17_22
Title: Basic program to convert integer to Roman numerals? 
----------------------------------------

def int_to_roman(a) :
INDENT
    all_roman_digits = []
    digit_lookup_table = [
        "", "0", "00", "000", "01",
        "1", "10", "100", "1000", "02"]
    for i, c in enumerate(reversed(str(a))) :
    INDENT
        roman_digit = ""
        for d in digit_lookup_table [int(c)] :
        INDENT
            roman_digit += ("IVXLCDM" [int(d) + i * 2])
        DEDENT
        all_roman_digits.append(roman_digit)
    DEDENT
    return "".join(reversed(all_roman_digits))
DEDENT
----------------------------------------

def int_to_roman(number) :
INDENT
    result = ""
    for (arabic, roman) in ROMAN :
    INDENT
        (factor, number) = divmod(number, arabic)
        result += roman * factor
    DEDENT
    return result
DEDENT
----------------------------------------
