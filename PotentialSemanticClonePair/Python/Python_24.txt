$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30837417_30837458_1_13
30837417_43790244_1_10
Title: "Codecademy Python ""is_prime"" exercise in ""Practice Makes Perfect""-Is it really iterating?" 
----------------------------------------

def is_prime(x) :
INDENT
    if x < 2 :
    INDENT
        return False
    DEDENT
    if x == 2 :
    INDENT
        return True
    DEDENT
    if x == 3 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        for n in range(2, x - 1) :
        INDENT
            print "Current value is %d." % n
            if x % n == 0 :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
DEDENT
----------------------------------------

def is_prime(x) :
INDENT
    if x < 2 :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        for n in range(2, x - 1) :
        INDENT
            if x % n == 0 :
            INDENT
                return False

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30840135_30840669_3_11
30840135_30840879_3_19
Title: Cancel last line iteration on a file 
----------------------------------------

def parse1(file, stop) :
INDENT
    for line in file :
    INDENT
        if line.strip() == stop :
        INDENT
            return itertools.chain([line], file)
        DEDENT
        else :
        INDENT
            print ('parse1: ' + line)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def parse1(file_name, stop) :
INDENT
    def parse2(file_obj) :
    INDENT
        print '**********'
        for line in file_obj :
        INDENT
            print (line)
        DEDENT
    DEDENT
    with open(file_name) as file_obj :
    INDENT
        temp, file_obj = tee(file_obj)
        for line in temp :
        INDENT
            if line.strip() == stop :
            INDENT
                break
            DEDENT
            else :
            INDENT
                next(file_obj)
                print (line)
            DEDENT
        DEDENT
        parse2(file_obj)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30877231_30887783_33_50
30877231_30887783_52_61
Title: WX.EVT_LISTBOX_DCLICK click for get diffrent information from database 
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    wx.Frame.__init__(self, * args, ** kwds)
    pnl = wx.Panel(self, - 1)
    self.explain = wx.StaticText(pnl, - 1, 'Click in list to show explanation')
    self.klmt = wx.TextCtrl(pnl, - 1, '')
    self.srch = wx.Button(pnl, - 1, u'Search…')
    self.vids = wx.ListBox(pnl, - 1, style = wx.LB_MULTIPLE)
    szmain = wx.BoxSizer(wx.VERTICAL)
    szmain.Add(wx.StaticText(pnl, - 1, 'Search for video category:'), 0, wx.EXPAND | wx.ALL, 4)
    szmain.Add(self.klmt, 0, wx.EXPAND | wx.ALL, 4)
    szmain.Add(self.srch, 0, wx.EXPAND | wx.ALL, 4)
    szmain.Add(self.vids, 1, wx.EXPAND | wx.ALL, 4)
    szmain.Add(wx.StaticText(pnl, - 1, 'Explanation for video'), 0, wx.EXPAND | wx.ALL, 4)
    szmain.Add(self.explain, 0, wx.EXPAND | wx.ALL, 4)
    pnl.SetSizer(szmain)
    szmain.Fit(self)
DEDENT
----------------------------------------

def __init__(self, app) :
INDENT
    self.model = play_model()
    self.search_results = []
    self.frm = playframe(None, - 1, 'test_playframe')
    self.frm.Show()
    self.frm.srch.Bind(wx.EVT_BUTTON, self.on_srch)
    self.frm.vids.Bind(wx.EVT_LISTBOX, self.onvid_dblclick)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30877231_30887783_33_50
30877231_30887783_6_22
Title: WX.EVT_LISTBOX_DCLICK click for get diffrent information from database 
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    wx.Frame.__init__(self, * args, ** kwds)
    pnl = wx.Panel(self, - 1)
    self.explain = wx.StaticText(pnl, - 1, 'Click in list to show explanation')
    self.klmt = wx.TextCtrl(pnl, - 1, '')
    self.srch = wx.Button(pnl, - 1, u'Search…')
    self.vids = wx.ListBox(pnl, - 1, style = wx.LB_MULTIPLE)
    szmain = wx.BoxSizer(wx.VERTICAL)
    szmain.Add(wx.StaticText(pnl, - 1, 'Search for video category:'), 0, wx.EXPAND | wx.ALL, 4)
    szmain.Add(self.klmt, 0, wx.EXPAND | wx.ALL, 4)
    szmain.Add(self.srch, 0, wx.EXPAND | wx.ALL, 4)
    szmain.Add(self.vids, 1, wx.EXPAND | wx.ALL, 4)
    szmain.Add(wx.StaticText(pnl, - 1, 'Explanation for video'), 0, wx.EXPAND | wx.ALL, 4)
    szmain.Add(self.explain, 0, wx.EXPAND | wx.ALL, 4)
    pnl.SetSizer(szmain)
    szmain.Fit(self)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.conn = sqlite3.connect(':memory:')
    c = self.conn.cursor()
    c.execute('CREATE TABLE video (word text, name_link text, explain text, link text)')
    newrecs = (('python', 'Video1', 'test1', r'C:\video1.MP4'),
        ('python', 'Video2', 'test2', r'C:\video2.MP4'),
        ('notpython', 'Video3', 'test3', r'C:\video3.MP4'),
        ('python', 'Video4', 'test4', r'C:\video4.MP4'),
        ('python', 'Video5', 'test5', r'C:\video5.MP4'),
        )
    for tup in newrecs :
    INDENT
        c.execute('INSERT INTO video VALUES (?, ?, ?, ?)', tup)
    DEDENT
    self.map_explain = {}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30877231_30887783_52_61
30877231_30887783_6_22
Title: WX.EVT_LISTBOX_DCLICK click for get diffrent information from database 
----------------------------------------

def __init__(self, app) :
INDENT
    self.model = play_model()
    self.search_results = []
    self.frm = playframe(None, - 1, 'test_playframe')
    self.frm.Show()
    self.frm.srch.Bind(wx.EVT_BUTTON, self.on_srch)
    self.frm.vids.Bind(wx.EVT_LISTBOX, self.onvid_dblclick)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.conn = sqlite3.connect(':memory:')
    c = self.conn.cursor()
    c.execute('CREATE TABLE video (word text, name_link text, explain text, link text)')
    newrecs = (('python', 'Video1', 'test1', r'C:\video1.MP4'),
        ('python', 'Video2', 'test2', r'C:\video2.MP4'),
        ('notpython', 'Video3', 'test3', r'C:\video3.MP4'),
        ('python', 'Video4', 'test4', r'C:\video4.MP4'),
        ('python', 'Video5', 'test5', r'C:\video5.MP4'),
        )
    for tup in newrecs :
    INDENT
        c.execute('INSERT INTO video VALUES (?, ?, ?, ?)', tup)
    DEDENT
    self.map_explain = {}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30954381_37309070_518_535
30954381_37309070_610_624
Title: Python HTMLTestRunner not generating report 
----------------------------------------

def __init__(self, verbosity = 1) :
INDENT
    TestResult.__init__(self)
    self.stdout0 = None
    self.stderr0 = None
    self.success_count = 0
    self.failure_count = 0
    self.error_count = 0
    self.verbosity = verbosity

    self.result = []
DEDENT
----------------------------------------

def __init__(self, stream = sys.stdout, verbosity = 1, title = None, description = None) :
INDENT
    self.stream = stream
    self.verbosity = verbosity
    if title is None :
    INDENT
        self.title = self.DEFAULT_TITLE
    DEDENT
    else :
    INDENT
        self.title = title
    DEDENT
    if description is None :
    INDENT
        self.description = self.DEFAULT_DESCRIPTION
    DEDENT
    else :
    INDENT
        self.description = description
    DEDENT
    self.startTime = datetime.datetime.now()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30959844_31152220_28_37
30959844_31152220_62_73
Title: wx.ProgressDialog causing seg fault and/or GTK_IS_WINDOW failure when being destroyed 
----------------------------------------

def __init__(self, parent, title, range = 100) :
INDENT
    wx.Frame.__init__(self, parent = parent, title = title)
    self.range = range
    self.createProgressbar()
    self.SetMinSize((400, 10))
    self.Centre()
    self.Show()
    self.t0 = time.time()
    self.elapsed_time_timer.Start(1000)
DEDENT
----------------------------------------

def __init__(self, title) :
INDENT
    wx.Frame.__init__(self, None, title = title, pos = (150, 150), size = (350, 200))
    panel = wx.Panel(self)
    box = wx.BoxSizer(wx.VERTICAL)
    m_btn = wx.Button(panel, wx.ID_ANY, "Run Stuff")
    self.Bind(wx.EVT_BUTTON, self.OnRunButton, m_btn)
    box.Add(m_btn, 0, wx.ALL, 10)
    panel.SetSizer(box)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30966409_30966627_1_10
30966409_30966665_1_10
Title: Remove values from an array in-place without using extra memory 
----------------------------------------

def remove_element(value, array) :
INDENT
    reading_idx = writing_idx = 0
    while reading_idx < len(array) :
    INDENT
        if array [reading_idx] ! = value :
        INDENT
            array [writing_idx] = array [reading_idx]
            writing_idx += 1
        DEDENT
        reading_idx += 1
    DEDENT
    while writing_idx < len(array) :
    INDENT
        array [writing_idx] = None
        writing_idx += 1
    DEDENT
DEDENT
----------------------------------------

def remove_element(value, array) :
INDENT
    shift = 0
    for index in xrange(len(array)) :
    INDENT
        try :
        INDENT
            array [index] = array [index + shift]
            while array [index] == value :
            INDENT
                shift += 1
                array [index] = array [index + shift]
            DEDENT
        DEDENT
        except IndexError :
        INDENT
            array [index] = None
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30981325_31009091_32_39
30981325_31016715_35_43
Title: Tkinter: select multiple items in MultiListBox 
----------------------------------------

def __init__(self, root) :
INDENT
    self.root = root
    self.tree = None
    self._setup_widgets()
    self._build_tree()
    ttk.Button(self.root, text = 'Exit',
        command = self.root.quit).grid(row = 20)
DEDENT
----------------------------------------

def __init__(self, root) :
INDENT
    self.root = root
    self.tree = None
    self._setup_widgets()
    self._build_tree()
    ttk.Button(self.root, text = 'Exit',
        command = self.root.quit).grid(row = 20)
    self.selected_offsets = []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30993051_30993122_1_10
30993051_30993201_3_12
Title: loop that will generate math problems until told to stop 
----------------------------------------

def Math() :
INDENT
    ready = raw_input('Are you ready?')
    if ready ! = 'yes' :
    INDENT
        return
    DEDENT
    while True :
    INDENT
        num1 = int(random.randint(0, 10))
        num2 = int(random.randint(0, 10))
        result = raw_input('%d + %d = ')
        if result == 'stop' :
        INDENT
            return
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def Math() :
INDENT
    if raw_input('Are you ready? ') ! = 'yes' :
    INDENT
        return
    DEDENT
    while True :
    INDENT
        num1 = random.randint(0, 10)
        num2 = random.randint(0, 10)
        result = raw_input('%d + %d = ' % (num1, num2))
        if result == 'stop' :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31003685_31003864_1_8
31003685_31004674_1_16
Title: Shortest subset for given sum and fastest solution in Python 
----------------------------------------

def solution(N) :
INDENT
    possibles = []
    tea(1, [1], N, possibles)
    if not possibles :
    INDENT
        return - 1
    DEDENT
    else :
    INDENT
        return min(map(len, possibles))
    DEDENT
DEDENT
----------------------------------------

def solution(n) :
INDENT
    q = [(1,)]
    visited = set()
    for seq in q :
    INDENT
        s = sum(seq)
        if s == n :
        INDENT
            return seq
        DEDENT
        elif s > n :
        INDENT
            continue
        DEDENT
        key = (seq [- 1], s)
        if key in visited :
        INDENT
            continue
        DEDENT
        visited.add(key)
        q.append(seq + (seq [- 1] * 2,))
        q.append(seq + (seq [- 1] + 1,))
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31016075_31016155_9_13
31016075_31016320_12_18
Title: Simple Python Assistance 
----------------------------------------

def makelist(random_int) :
INDENT
    number_list = []
    for count in range(random_int) :
    INDENT
        number_list.append(random.randint(1, 100))
    DEDENT
    return number_list
DEDENT
----------------------------------------

def makelist(random_int) :
INDENT
    number_list = []
    for count in range(random_int) :
    INDENT
        number_list.append(random.randint(1, 100))
    DEDENT
    return number_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31033786_31035480_17_23
31033786_31035480_43_53
Title: Editing an object in a Listbox and the list where it comes from 
----------------------------------------

def edit() :
INDENT
    for i in range(len(labels)) :
    INDENT
        z [index] [labels [i]] = entries [i].get()
    DEDENT
    print z
    top.destroy()
DEDENT
----------------------------------------

def edit() :
INDENT
    global l, z, root
    sel = l.curselection()
    if len(sel) > 0 :
    INDENT
        indexToEdit = z.index(eval(l.get(sel [0])))
        l.delete(sel)
        root.wait_window(createPerson(indexToEdit))
        print z [indexToEdit]
        l.insert(sel, z [indexToEdit])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31038208_31038288_1_13
31038208_31038360_12_25
Title: Error with simple Python code 
----------------------------------------

def calc_grade() :
INDENT
    score = None
    while score is None :
    INDENT
        try :
        INDENT
            score = float(raw_input("Enter a score: "))
            if score > 1.0 :
            INDENT
                print "Error: Score cannot be greater than 1."
                score = None
            DEDENT
        DEDENT
        except :
        INDENT
            print "Error: Score must be a numeric value from 0 to 1."
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calc_grade() :
INDENT
    score = get_input()
    print "\nthe score is: %s" % (score)
    if score > = 0.9 :
    INDENT
        print "A"
    DEDENT
    elif score > = 0.8 :
    INDENT
        print "B"
    DEDENT
    elif score > = 0.7 :
    INDENT
        print "C"
    DEDENT
    elif score > = 0.6 :
    INDENT
        print "D"
    DEDENT
    else :
    INDENT
        print "F"
    DEDENT
    return 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31038208_31038288_1_13
31038208_31038893_1_26
Title: Error with simple Python code 
----------------------------------------

def calc_grade() :
INDENT
    score = None
    while score is None :
    INDENT
        try :
        INDENT
            score = float(raw_input("Enter a score: "))
            if score > 1.0 :
            INDENT
                print "Error: Score cannot be greater than 1."
                score = None
            DEDENT
        DEDENT
        except :
        INDENT
            print "Error: Score must be a numeric value from 0 to 1."
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calc_grade() :
INDENT
    try :
    INDENT
        score = float(raw_input("Enter a score: "))
        if score > 1.0 :
        INDENT
            raise TypeError
        DEDENT
    DEDENT
    except ValueError :
    INDENT
        print "Error: Score must be a numeric value from 0 to 1."
    DEDENT
    except TypeError :
    INDENT
        print "Error: Score cannot be greater than 1."
    DEDENT
    except :
    INDENT
        print "Error: Unexpected error, try again."
    DEDENT
    else :
    INDENT
        if score > = 0.9 :
        INDENT
            score = "A"
        DEDENT
        elif score > = 0.8 :
        INDENT
            score = "B"
        DEDENT
        elif score > = 0.7 :
        INDENT
            score = "C"
        DEDENT
        elif score > = 0.6 :
        INDENT
            score = "D"
        DEDENT
        else :
        INDENT
            score = "F"
        DEDENT
        print "the score is: {}".format(score)
        return
    DEDENT
    calc_grade()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31038208_31038360_12_25
31038208_31038893_1_26
Title: Error with simple Python code 
----------------------------------------

def calc_grade() :
INDENT
    score = get_input()
    print "\nthe score is: %s" % (score)
    if score > = 0.9 :
    INDENT
        print "A"
    DEDENT
    elif score > = 0.8 :
    INDENT
        print "B"
    DEDENT
    elif score > = 0.7 :
    INDENT
        print "C"
    DEDENT
    elif score > = 0.6 :
    INDENT
        print "D"
    DEDENT
    else :
    INDENT
        print "F"
    DEDENT
    return 0
DEDENT
----------------------------------------

def calc_grade() :
INDENT
    try :
    INDENT
        score = float(raw_input("Enter a score: "))
        if score > 1.0 :
        INDENT
            raise TypeError
        DEDENT
    DEDENT
    except ValueError :
    INDENT
        print "Error: Score must be a numeric value from 0 to 1."
    DEDENT
    except TypeError :
    INDENT
        print "Error: Score cannot be greater than 1."
    DEDENT
    except :
    INDENT
        print "Error: Unexpected error, try again."
    DEDENT
    else :
    INDENT
        if score > = 0.9 :
        INDENT
            score = "A"
        DEDENT
        elif score > = 0.8 :
        INDENT
            score = "B"
        DEDENT
        elif score > = 0.7 :
        INDENT
            score = "C"
        DEDENT
        elif score > = 0.6 :
        INDENT
            score = "D"
        DEDENT
        else :
        INDENT
            score = "F"
        DEDENT
        print "the score is: {}".format(score)
        return
    DEDENT
    calc_grade()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31039457_31041775_1_13
31039457_31053793_1_11
Title: "Python Social Auth Extending Disconnect Pipeline" 
----------------------------------------

def disconnect(strategy, entries, user_storage, * args, ** kwargs) :
INDENT
    for entry in entries :
    INDENT
        user_storage.disconnect(entry)
    DEDENT
    backend = kwargs.get('name')
    profile = Profiles.objects.get(user = entries [0].user)
    if backend == 'facebook' :
    INDENT
        profile.fb_id = ''
    DEDENT
    elif backend == 'twitter' :
    INDENT
        profile.tw_id = ''
    DEDENT
    elif backend == 'instagram' :
    INDENT
        new_profile.in_id = ''
    DEDENT
    profile.save()
DEDENT
----------------------------------------

def disconnect(strategy, entries, * args, ** kwargs) :
INDENT
    backend = kwargs.get('name')
    profile = Profiles.objects.get(user = entries [0].user)
    if backend == 'facebook' :
    INDENT
        profile.fb_id = False
    DEDENT
    elif backend == 'twitter' :
    INDENT
        profile.tw_id = False
    DEDENT
    elif backend == 'instagram' :
    INDENT
        new_profile.in_id = False
    DEDENT
    profile.save()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31041680_31041717_13_40
31041680_31044295_12_33
Title: How do I make this program start over from user's decision? 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        side1, side2, side3 = input("Give me the lengths of a triangle's 3 sides?: ").split()
        side1 = int(side1)
        side2 = int(side2)
        side3 = int(side3)
        valid = True
        valid = isValid(side1, side2, side3)

        if valid is not True :
        INDENT
            print ("This is not a valid triangle.")
            print ("\n")
            print ("Would you like to go again? ")
            answer = input()
            answer = answer.lower()
            if answer == "yes" :
            INDENT
                continue
            DEDENT
            elif answer == "no" :
            INDENT
                break
            DEDENT
            else :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            x = area(side1, side2, side3)
            print ("The area of the triangle is ", x)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    flag = True
    while flag :
    INDENT
        side1, side2, side3 = input("Give me the lengths of a triangle's 3 sides?: ")
        valid = isValid(side1, side2, side3)
        if valid is not True :
        INDENT
            print ("This is not a valid triangle.")
            print ()
            print ("Would you like to go again? ")
            answer = raw_input()
            if answer.lower() == "yes" :
            INDENT
                flag = True
            DEDENT
            elif answer.lower() == "no" :
            INDENT
                flag = False
            DEDENT
        DEDENT
        else :
        INDENT
            x = area(side1, side2, side3)
            print ("The area of the triangle is ", x)
            return x
        DEDENT
    DEDENT
    r = main()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31041680_31041922_1_22
31041680_31044295_12_33
Title: How do I make this program start over from user's decision? 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        side1, side2, side3 = input("Give me the lengths of a triangle's 3 sides?: ").split()
        side1 = eval(side1)
        side2 = eval(side2)
        side3 = eval(side3)
        valid = isValid(side1, side2, side3)
        if not valid :
        INDENT
            print ("This is not a valid triangle.")
            print ()
            while True :
            INDENT
                print ("Would you like to go again? (yes/no)")
                answer = input()
                if answer in ("no", "No") :
                INDENT
                    return
                DEDENT
                elif answer in ("yes", "Yes") :
                INDENT
                    break
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT
            x = area(side1, side2, side3)
            print ("The area of the triangle is ", x)
            return
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    flag = True
    while flag :
    INDENT
        side1, side2, side3 = input("Give me the lengths of a triangle's 3 sides?: ")
        valid = isValid(side1, side2, side3)
        if valid is not True :
        INDENT
            print ("This is not a valid triangle.")
            print ()
            print ("Would you like to go again? ")
            answer = raw_input()
            if answer.lower() == "yes" :
            INDENT
                flag = True
            DEDENT
            elif answer.lower() == "no" :
            INDENT
                flag = False
            DEDENT
        DEDENT
        else :
        INDENT
            x = area(side1, side2, side3)
            print ("The area of the triangle is ", x)
            return x
        DEDENT
    DEDENT
    r = main()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31044605_31049787_19_51
31044605_31049787_7_17
Title: pyqt:how to emit a signal when NextButton of a QwizardPage was clicked 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(AccountPage, self).__init__(parent)
    self.setTitle("Account Information")
    self.NameLabel = QLabel("&Name:")
    self.NameLineEdit = QLineEdit()
    self.NameLabel.setBuddy(self.NameLineEdit)
    self.EmailLabel = QLabel("&Email Address:")
    self.EmailLineEdit = QLineEdit()
    self.EmailLabel.setBuddy(self.EmailLineEdit)
    self.PwdLabel = QLabel("&Password:")
    self.PwdLineEdit = QLineEdit()
    self.PwdLabel.setBuddy(self.PwdLineEdit)
    self.registerField('Name*', self.NameLineEdit)
    self.registerField('EmailAddress*', self.EmailLineEdit)
    self.registerField('Password*', self.PwdLineEdit)

    layout = QGridLayout()
    layout.addWidget(self.NameLabel, 0, 0)
    layout.addWidget(self.NameLineEdit, 0, 1)
    layout.addWidget(self.EmailLabel, 1, 0)
    layout.addWidget(self.EmailLineEdit, 1, 1)
    layout.addWidget(self.PwdLabel, 2, 0)
    layout.addWidget(self.PwdLineEdit, 2, 1)
    self.setLayout(layout)
    self.i = 0
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.accoutPage = AccountPage()
    self.secondPage = Page2()
    self.thirdPage = Page3()
    self.addPage(self.accoutPage)
    self.addPage(self.secondPage)
    self.addPage(self.thirdPage)
    self.button(QWizard.NextButton).clicked.connect(self.accoutPage.setMB)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31049554_31049616_1_16
31049554_31049632_1_7
Title: "Return error in this ""computepay"" function" 
----------------------------------------

def computepay() :
INDENT
    try :
    INDENT
        int1 = raw_input("Enter Hours")
        h = float(int1)
        int2 = raw_input("Enter Rate")
        r = float(int2)
    DEDENT
    except :
    INDENT
        print "Error, please enter a numeric input"
        quit()
    DEDENT
    if h > = 40 :
    INDENT
        pay1 = 40 * r + (h - 40) * r * 1.5
        return pay1
    DEDENT
    else :
    INDENT
        pay2 = h * r
        return pay2
    DEDENT
DEDENT
----------------------------------------

def computepay(h, r) :
INDENT
    if h > = 40 :
    INDENT
        return 40 * r + (h - 40) * r * 1.5
    DEDENT
    else :
    INDENT
        return h * r

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31057532_31061772_4_16
31057532_47489066_11_19
Title: How to check profanity using python3 
----------------------------------------

def check_profanity(to_check) :
INDENT
    try :
    INDENT
        connection = urllib.urlopen('http://www.wdyl.com/profanity?q='
            + smart_str(to_check))
        output = connection.read()
        connection.close()
        if 'true' in output :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    except :
    INDENT
        print "An error occurred!"
        return
    DEDENT
DEDENT
----------------------------------------

def check_profanity(text_to_check) :
INDENT
    encoded_text = urllib.parse.quote(text_to_check, 'utf-8')
    address = "http://www.wdylike.appspot.com/?q=" + encoded_text
    print (address)
    connection = urllib.request.urlopen(address)
    output = connection.read()
    print (output)
    connection.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31063926_31064055_7_17
31063926_31064217_13_26
Title: "Needs to remove word from string and display both the removed word + remaining string possible tuple?" 
----------------------------------------

def NoBacon(sandwich) :
INDENT
    replacements_made = []
    for line in sandwich :
    INDENT
        for word in to_replace :
        INDENT
            words_replaced = []
            if word in line :
            INDENT
                words_replaced.append(word)
                line = line.replace(word, "")
            DEDENT
        DEDENT
        replacements_made.append((words_replaced, line))
    DEDENT
    return replacements_made
DEDENT
----------------------------------------

def NoBacon(sandwich) :
INDENT
    result = []
    length = len(user_input)
    lines = sandwich.strip().split('\n')
    for line in lines :
    INDENT
        cleaned_line = line.replace(user_input, '')
        if len(line) - len(cleaned_line) > = length :
        INDENT
            result.append([user_input, cleaned_line])

        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31083862_31085493_1_13
31083862_31092845_1_15
Title: Car Class Object Oriented Programming Python 
----------------------------------------

def drive(self, miles) :
INDENT
    if miles < 0 :
    INDENT
        return ("The car is not driven")
    DEDENT
    one_gallon = miles / self.fuelEfficiency
    if one_gallon < self.fuelLevel :
    INDENT
        print ("The car drove {} miles".format(miles))
    DEDENT
    elif self.fuelLevel == 0 :
    INDENT
        print ("The car drove 0 miles")
    DEDENT
    elif one_gallon > self.fuelLevel :
    INDENT
        print ("car cannot drive")
    DEDENT
    self.fuelLevel -= one_gallon
    self.odometer += miles
DEDENT
----------------------------------------

def drive(self, miles) :
INDENT
    if miles < 0 :
    INDENT
        return
    DEDENT
    trip_gallons = miles / self.fuelEfficiency
    if trip_gallons < = self.fuelLevel :
    INDENT
        self.odometer += miles
        print ("The car drove {} miles".format(miles))
        self.fuelLevel -= trip_gallons
    DEDENT
    else :
    INDENT
        miles_possible = self.fuelLevel * self.fuelEfficiency
        self.odometer += miles_possible
        print ("The car drove {} miles".format(miles_possible))
        self.fuelLevel = 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31117340_31117452_1_6
31117340_31118544_1_8
Title: Simple algorithm in python fails 
----------------------------------------

def multiply(first, second) :
INDENT
    if first == 0 :
    INDENT
        return second
    DEDENT
    else :
    INDENT
        return multiply(first - 1, second + second)
    DEDENT
DEDENT
----------------------------------------

def multiply(first, second) :
INDENT
    if first > 0 :
    INDENT
        return second + multiply(first - 1, second)
    DEDENT
    elif first < 0 :
    INDENT
        return - second + multiply(first + 1, second)
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31124031_31124138_13_24
31124031_31124138_4_11
Title: Adding labels iteratively to Tkinter form 
----------------------------------------

def __init__(self, parent) :
INDENT
    fields = ['Text Box 1', 'Text Box 2']
    GUIFrame = Frame(parent, width = 300, height = 200)
    GUIFrame.pack(expand = False, anchor = CENTER)
    field_index = 10
    for field in fields :
    INDENT
        self.field = LabeledEntry(GUIFrame, text = field)
        self.field.place(x = 65, y = field_index)
        field_index += 25
    DEDENT
    self.Button2 = Button(parent, text = 'exit', command = parent.quit)
    self.Button2.place(x = 160, y = 60)
DEDENT
----------------------------------------

def __init__(self, parent, * args, ** kargs) :
INDENT
    text = kargs.pop("text")
    Frame.__init__(self, parent)
    self.label = Label(self, text = text)
    self.label.grid(column = 0, row = 0)
    self.entry = Entry(self, * args, ** kargs)
    self.entry.grid(column = 1, row = 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31138061_31140195_19_30
31138061_31140195_34_58
Title: WxPython switch between multiple panels 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(25, 12)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Panel Switcher Tutorial")
    self.panel_one = PanelOne(self)
    self.panel_two = PanelTwo(self)
    self.panel_two.Hide()
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.sizer.Add(self.panel_two, 1, wx.EXPAND)
    self.SetSizer(self.sizer)

    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    switch_panels_menu_item = fileMenu.Append(wx.ID_ANY,
        "Switch Panels",
        "Some text")
    self.Bind(wx.EVT_MENU, self.onSwitchPanels,
        switch_panels_menu_item)
    menubar.Append(fileMenu, '&File')
    self.SetMenuBar(menubar)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31139948_31159360_1_12
31139948_50534284_6_19
Title: flask admin custom QueryAjaxModelLoader 
----------------------------------------

def get_list(self, term, offset = 0, limit = DEFAULT_PAGE_SIZE) :
INDENT
    filters = list(
        field.ilike(u'%%%s%%' % term) for field in self._cached_fields
        )
    filters.append(Organisation.org_id == "Google")
    return (
        db.session.query(Product)
        .join(organisation_products_table)
        .join(Organisation)
        .filter(* filters)
        .all())
DEDENT
----------------------------------------

def get_list(self, term, offset = 0, limit = DEFAULT_PAGE_SIZE) :
INDENT
    filters = list(
        field.ilike(u'%%%s%%' % term) for field in self._cached_fields
        )
    for f in self.additional_filters :
    INDENT
        filters.append(f)

    DEDENT
    return (
        db.session.query(self.model)
        .filter(* filters)
        .all())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114982_24_44
3114924_3114984_25_38
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_sys_argv()
    run_flag = [True]
    queue = Queue(argv [1])
    send = Stack()
    recv = Stack()
    producer = Thread(target = produce, args = (run_flag, queue, send))
    consumer = Thread(target = consume, args = (run_flag, queue, recv, producer))
    producer.start()
    consumer.start()
    sleep(argv [2])
    run_flag [0] = False
    consumer.join()
    calculate_results(send, recv)

DEDENT
----------------------------------------

def main() :
INDENT
    parse_argv()
    run_flag, buffer_queue, producer_stack, consumer_stack, print_queue = [True], Queue(argv [1]), Stack(), Stack(), Queue()
    producer_thread = Thread(target = producer, args = (run_flag, argv [3], buffer_queue, producer_stack, print_queue))
    consumer_thread = Thread(target = consumer, args = (run_flag, producer_thread, buffer_queue, consumer_stack, argv [4], print_queue))
    printer_thread = Thread(target = printer, args = (run_flag, consumer_thread, print_queue))
    producer_thread.start()
    consumer_thread.start()
    printer_thread.start()
    sleep(argv [2])
    run_flag [0] = False
    printer_thread.join()
    check_results(producer_stack, consumer_stack)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114982_24_44
3114924_3114992_5_12
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_sys_argv()
    run_flag = [True]
    queue = Queue(argv [1])
    send = Stack()
    recv = Stack()
    producer = Thread(target = produce, args = (run_flag, queue, send))
    consumer = Thread(target = consume, args = (run_flag, queue, recv, producer))
    producer.start()
    consumer.start()
    sleep(argv [2])
    run_flag [0] = False
    consumer.join()
    calculate_results(send, recv)

DEDENT
----------------------------------------

def main(setup, error) :
INDENT
    sys.stderr = file(error, 'a')
    for settings in parse(setup) :
    INDENT
        thread.start_new_thread(server, settings)
    DEDENT
    lock = thread.allocate_lock()
    lock.acquire()
    lock.acquire()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114982_24_44
3114924_3114999_14_78
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_sys_argv()
    run_flag = [True]
    queue = Queue(argv [1])
    send = Stack()
    recv = Stack()
    producer = Thread(target = produce, args = (run_flag, queue, send))
    consumer = Thread(target = consume, args = (run_flag, queue, recv, producer))
    producer.start()
    consumer.start()
    sleep(argv [2])
    run_flag [0] = False
    consumer.join()
    calculate_results(send, recv)

DEDENT
----------------------------------------

def main(argc, argv) :
INDENT
    global runFlag
    try :
    INDENT
        N = abs(int(argv [1]))
    DEDENT
    except :
    INDENT
        sys.exit(1)
    DEDENT
    try :
    INDENT
        runTime = abs(int(argv [2]))
    DEDENT
    except :
    INDENT
        sys.exit(1)

    DEDENT
    now = time.localtime()

    sys.stdout.write('mthread: Suite starting at system time %d:%d:%d\n' % (now.tm_hour, now.tm_min, now.tm_sec))
    stopTimeSecond = (now.tm_sec + runTime) % 60

    stopTimeMinute = now.tm_min + (now.tm_sec + runTime) / 60

    for i in range(N) :
    INDENT

        thread.start_new_thread(threadWork, ())
        time.sleep(0.1)

    DEDENT
    while runFlag :
    INDENT

        now = time.localtime()

        if now.tm_min > = stopTimeMinute and now.tm_sec > = stopTimeSecond :
        INDENT

            runFlag = False
        DEDENT
        time.sleep(1)

    DEDENT
    time.sleep(5)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114982_24_44
3114924_3115044_104_114
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_sys_argv()
    run_flag = [True]
    queue = Queue(argv [1])
    send = Stack()
    recv = Stack()
    producer = Thread(target = produce, args = (run_flag, queue, send))
    consumer = Thread(target = consume, args = (run_flag, queue, recv, producer))
    producer.start()
    consumer.start()
    sleep(argv [2])
    run_flag [0] = False
    consumer.join()
    calculate_results(send, recv)

DEDENT
----------------------------------------

def main() :
INDENT
    root = tkinter.Tk()
    root.resizable(False, False)
    root.title('Time in Tessaressunago')
    secs = tkinter.StringVar()
    text = tkinter.Label(textvariable = secs, font = ('helvetica', 16, 'bold'))
    text.grid(padx = 5, pady = 5)
    thread = Quantum_Timer(update, secs)
    thread.start()
    root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114982_24_44
3114924_3115069_31_58
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_sys_argv()
    run_flag = [True]
    queue = Queue(argv [1])
    send = Stack()
    recv = Stack()
    producer = Thread(target = produce, args = (run_flag, queue, send))
    consumer = Thread(target = consume, args = (run_flag, queue, recv, producer))
    producer.start()
    consumer.start()
    sleep(argv [2])
    run_flag [0] = False
    consumer.join()
    calculate_results(send, recv)

DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 2.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114982_24_44
3114924_3115210_233_260
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_sys_argv()
    run_flag = [True]
    queue = Queue(argv [1])
    send = Stack()
    recv = Stack()
    producer = Thread(target = produce, args = (run_flag, queue, send))
    consumer = Thread(target = consume, args = (run_flag, queue, recv, producer))
    producer.start()
    consumer.start()
    sleep(argv [2])
    run_flag [0] = False
    consumer.join()
    calculate_results(send, recv)

DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 1.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114984_25_38
3114924_3114992_5_12
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_argv()
    run_flag, buffer_queue, producer_stack, consumer_stack, print_queue = [True], Queue(argv [1]), Stack(), Stack(), Queue()
    producer_thread = Thread(target = producer, args = (run_flag, argv [3], buffer_queue, producer_stack, print_queue))
    consumer_thread = Thread(target = consumer, args = (run_flag, producer_thread, buffer_queue, consumer_stack, argv [4], print_queue))
    printer_thread = Thread(target = printer, args = (run_flag, consumer_thread, print_queue))
    producer_thread.start()
    consumer_thread.start()
    printer_thread.start()
    sleep(argv [2])
    run_flag [0] = False
    printer_thread.join()
    check_results(producer_stack, consumer_stack)
DEDENT
----------------------------------------

def main(setup, error) :
INDENT
    sys.stderr = file(error, 'a')
    for settings in parse(setup) :
    INDENT
        thread.start_new_thread(server, settings)
    DEDENT
    lock = thread.allocate_lock()
    lock.acquire()
    lock.acquire()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114984_25_38
3114924_3114999_14_78
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_argv()
    run_flag, buffer_queue, producer_stack, consumer_stack, print_queue = [True], Queue(argv [1]), Stack(), Stack(), Queue()
    producer_thread = Thread(target = producer, args = (run_flag, argv [3], buffer_queue, producer_stack, print_queue))
    consumer_thread = Thread(target = consumer, args = (run_flag, producer_thread, buffer_queue, consumer_stack, argv [4], print_queue))
    printer_thread = Thread(target = printer, args = (run_flag, consumer_thread, print_queue))
    producer_thread.start()
    consumer_thread.start()
    printer_thread.start()
    sleep(argv [2])
    run_flag [0] = False
    printer_thread.join()
    check_results(producer_stack, consumer_stack)
DEDENT
----------------------------------------

def main(argc, argv) :
INDENT
    global runFlag
    try :
    INDENT
        N = abs(int(argv [1]))
    DEDENT
    except :
    INDENT
        sys.exit(1)
    DEDENT
    try :
    INDENT
        runTime = abs(int(argv [2]))
    DEDENT
    except :
    INDENT
        sys.exit(1)

    DEDENT
    now = time.localtime()

    sys.stdout.write('mthread: Suite starting at system time %d:%d:%d\n' % (now.tm_hour, now.tm_min, now.tm_sec))
    stopTimeSecond = (now.tm_sec + runTime) % 60

    stopTimeMinute = now.tm_min + (now.tm_sec + runTime) / 60

    for i in range(N) :
    INDENT

        thread.start_new_thread(threadWork, ())
        time.sleep(0.1)

    DEDENT
    while runFlag :
    INDENT

        now = time.localtime()

        if now.tm_min > = stopTimeMinute and now.tm_sec > = stopTimeSecond :
        INDENT

            runFlag = False
        DEDENT
        time.sleep(1)

    DEDENT
    time.sleep(5)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114984_25_38
3114924_3115044_104_114
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_argv()
    run_flag, buffer_queue, producer_stack, consumer_stack, print_queue = [True], Queue(argv [1]), Stack(), Stack(), Queue()
    producer_thread = Thread(target = producer, args = (run_flag, argv [3], buffer_queue, producer_stack, print_queue))
    consumer_thread = Thread(target = consumer, args = (run_flag, producer_thread, buffer_queue, consumer_stack, argv [4], print_queue))
    printer_thread = Thread(target = printer, args = (run_flag, consumer_thread, print_queue))
    producer_thread.start()
    consumer_thread.start()
    printer_thread.start()
    sleep(argv [2])
    run_flag [0] = False
    printer_thread.join()
    check_results(producer_stack, consumer_stack)
DEDENT
----------------------------------------

def main() :
INDENT
    root = tkinter.Tk()
    root.resizable(False, False)
    root.title('Time in Tessaressunago')
    secs = tkinter.StringVar()
    text = tkinter.Label(textvariable = secs, font = ('helvetica', 16, 'bold'))
    text.grid(padx = 5, pady = 5)
    thread = Quantum_Timer(update, secs)
    thread.start()
    root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114984_25_38
3114924_3115069_31_58
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_argv()
    run_flag, buffer_queue, producer_stack, consumer_stack, print_queue = [True], Queue(argv [1]), Stack(), Stack(), Queue()
    producer_thread = Thread(target = producer, args = (run_flag, argv [3], buffer_queue, producer_stack, print_queue))
    consumer_thread = Thread(target = consumer, args = (run_flag, producer_thread, buffer_queue, consumer_stack, argv [4], print_queue))
    printer_thread = Thread(target = printer, args = (run_flag, consumer_thread, print_queue))
    producer_thread.start()
    consumer_thread.start()
    printer_thread.start()
    sleep(argv [2])
    run_flag [0] = False
    printer_thread.join()
    check_results(producer_stack, consumer_stack)
DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 2.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114984_25_38
3114924_3115210_233_260
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    parse_argv()
    run_flag, buffer_queue, producer_stack, consumer_stack, print_queue = [True], Queue(argv [1]), Stack(), Stack(), Queue()
    producer_thread = Thread(target = producer, args = (run_flag, argv [3], buffer_queue, producer_stack, print_queue))
    consumer_thread = Thread(target = consumer, args = (run_flag, producer_thread, buffer_queue, consumer_stack, argv [4], print_queue))
    printer_thread = Thread(target = printer, args = (run_flag, consumer_thread, print_queue))
    producer_thread.start()
    consumer_thread.start()
    printer_thread.start()
    sleep(argv [2])
    run_flag [0] = False
    printer_thread.join()
    check_results(producer_stack, consumer_stack)
DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 1.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114992_5_12
3114924_3114999_14_78
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main(setup, error) :
INDENT
    sys.stderr = file(error, 'a')
    for settings in parse(setup) :
    INDENT
        thread.start_new_thread(server, settings)
    DEDENT
    lock = thread.allocate_lock()
    lock.acquire()
    lock.acquire()
DEDENT
----------------------------------------

def main(argc, argv) :
INDENT
    global runFlag
    try :
    INDENT
        N = abs(int(argv [1]))
    DEDENT
    except :
    INDENT
        sys.exit(1)
    DEDENT
    try :
    INDENT
        runTime = abs(int(argv [2]))
    DEDENT
    except :
    INDENT
        sys.exit(1)

    DEDENT
    now = time.localtime()

    sys.stdout.write('mthread: Suite starting at system time %d:%d:%d\n' % (now.tm_hour, now.tm_min, now.tm_sec))
    stopTimeSecond = (now.tm_sec + runTime) % 60

    stopTimeMinute = now.tm_min + (now.tm_sec + runTime) / 60

    for i in range(N) :
    INDENT

        thread.start_new_thread(threadWork, ())
        time.sleep(0.1)

    DEDENT
    while runFlag :
    INDENT

        now = time.localtime()

        if now.tm_min > = stopTimeMinute and now.tm_sec > = stopTimeSecond :
        INDENT

            runFlag = False
        DEDENT
        time.sleep(1)

    DEDENT
    time.sleep(5)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114992_5_12
3114924_3115044_104_114
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main(setup, error) :
INDENT
    sys.stderr = file(error, 'a')
    for settings in parse(setup) :
    INDENT
        thread.start_new_thread(server, settings)
    DEDENT
    lock = thread.allocate_lock()
    lock.acquire()
    lock.acquire()
DEDENT
----------------------------------------

def main() :
INDENT
    root = tkinter.Tk()
    root.resizable(False, False)
    root.title('Time in Tessaressunago')
    secs = tkinter.StringVar()
    text = tkinter.Label(textvariable = secs, font = ('helvetica', 16, 'bold'))
    text.grid(padx = 5, pady = 5)
    thread = Quantum_Timer(update, secs)
    thread.start()
    root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114992_5_12
3114924_3115069_31_58
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main(setup, error) :
INDENT
    sys.stderr = file(error, 'a')
    for settings in parse(setup) :
    INDENT
        thread.start_new_thread(server, settings)
    DEDENT
    lock = thread.allocate_lock()
    lock.acquire()
    lock.acquire()
DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 2.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114992_5_12
3114924_3115210_233_260
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main(setup, error) :
INDENT
    sys.stderr = file(error, 'a')
    for settings in parse(setup) :
    INDENT
        thread.start_new_thread(server, settings)
    DEDENT
    lock = thread.allocate_lock()
    lock.acquire()
    lock.acquire()
DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 1.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114999_14_78
3114924_3115044_104_114
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main(argc, argv) :
INDENT
    global runFlag
    try :
    INDENT
        N = abs(int(argv [1]))
    DEDENT
    except :
    INDENT
        sys.exit(1)
    DEDENT
    try :
    INDENT
        runTime = abs(int(argv [2]))
    DEDENT
    except :
    INDENT
        sys.exit(1)

    DEDENT
    now = time.localtime()

    sys.stdout.write('mthread: Suite starting at system time %d:%d:%d\n' % (now.tm_hour, now.tm_min, now.tm_sec))
    stopTimeSecond = (now.tm_sec + runTime) % 60

    stopTimeMinute = now.tm_min + (now.tm_sec + runTime) / 60

    for i in range(N) :
    INDENT

        thread.start_new_thread(threadWork, ())
        time.sleep(0.1)

    DEDENT
    while runFlag :
    INDENT

        now = time.localtime()

        if now.tm_min > = stopTimeMinute and now.tm_sec > = stopTimeSecond :
        INDENT

            runFlag = False
        DEDENT
        time.sleep(1)

    DEDENT
    time.sleep(5)

DEDENT
----------------------------------------

def main() :
INDENT
    root = tkinter.Tk()
    root.resizable(False, False)
    root.title('Time in Tessaressunago')
    secs = tkinter.StringVar()
    text = tkinter.Label(textvariable = secs, font = ('helvetica', 16, 'bold'))
    text.grid(padx = 5, pady = 5)
    thread = Quantum_Timer(update, secs)
    thread.start()
    root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114999_14_78
3114924_3115069_31_58
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main(argc, argv) :
INDENT
    global runFlag
    try :
    INDENT
        N = abs(int(argv [1]))
    DEDENT
    except :
    INDENT
        sys.exit(1)
    DEDENT
    try :
    INDENT
        runTime = abs(int(argv [2]))
    DEDENT
    except :
    INDENT
        sys.exit(1)

    DEDENT
    now = time.localtime()

    sys.stdout.write('mthread: Suite starting at system time %d:%d:%d\n' % (now.tm_hour, now.tm_min, now.tm_sec))
    stopTimeSecond = (now.tm_sec + runTime) % 60

    stopTimeMinute = now.tm_min + (now.tm_sec + runTime) / 60

    for i in range(N) :
    INDENT

        thread.start_new_thread(threadWork, ())
        time.sleep(0.1)

    DEDENT
    while runFlag :
    INDENT

        now = time.localtime()

        if now.tm_min > = stopTimeMinute and now.tm_sec > = stopTimeSecond :
        INDENT

            runFlag = False
        DEDENT
        time.sleep(1)

    DEDENT
    time.sleep(5)

DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 2.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3114999_14_78
3114924_3115210_233_260
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main(argc, argv) :
INDENT
    global runFlag
    try :
    INDENT
        N = abs(int(argv [1]))
    DEDENT
    except :
    INDENT
        sys.exit(1)
    DEDENT
    try :
    INDENT
        runTime = abs(int(argv [2]))
    DEDENT
    except :
    INDENT
        sys.exit(1)

    DEDENT
    now = time.localtime()

    sys.stdout.write('mthread: Suite starting at system time %d:%d:%d\n' % (now.tm_hour, now.tm_min, now.tm_sec))
    stopTimeSecond = (now.tm_sec + runTime) % 60

    stopTimeMinute = now.tm_min + (now.tm_sec + runTime) / 60

    for i in range(N) :
    INDENT

        thread.start_new_thread(threadWork, ())
        time.sleep(0.1)

    DEDENT
    while runFlag :
    INDENT

        now = time.localtime()

        if now.tm_min > = stopTimeMinute and now.tm_sec > = stopTimeSecond :
        INDENT

            runFlag = False
        DEDENT
        time.sleep(1)

    DEDENT
    time.sleep(5)

DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 1.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3115044_104_114
3114924_3115069_31_58
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    root = tkinter.Tk()
    root.resizable(False, False)
    root.title('Time in Tessaressunago')
    secs = tkinter.StringVar()
    text = tkinter.Label(textvariable = secs, font = ('helvetica', 16, 'bold'))
    text.grid(padx = 5, pady = 5)
    thread = Quantum_Timer(update, secs)
    thread.start()
    root.mainloop()
DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 2.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3115044_104_114
3114924_3115210_233_260
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def main() :
INDENT
    root = tkinter.Tk()
    root.resizable(False, False)
    root.title('Time in Tessaressunago')
    secs = tkinter.StringVar()
    text = tkinter.Label(textvariable = secs, font = ('helvetica', 16, 'bold'))
    text.grid(padx = 5, pady = 5)
    thread = Quantum_Timer(update, secs)
    thread.start()
    root.mainloop()
DEDENT
----------------------------------------

def main() :
INDENT
    global hold, fill, draw, look
    hold = []
    fill = '#000000'
    connect()
    root = Tk()
    root.title('Paint 1.0')
    root.resizable(False, False)
    upper = LabelFrame(root, text = 'Your Canvas')
    lower = LabelFrame(root, text = 'Their Canvas')
    draw = Canvas(upper, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    look = Canvas(lower, bg = '#ffffff', width = 400, height = 300, highlightthickness = 0)
    cursor = Button(upper, text = 'Cursor Color', command = change_cursor)
    canvas = Button(upper, text = 'Canvas Color', command = change_canvas)
    draw.bind('<Motion>', motion)
    draw.bind('<ButtonPress-1>', press)
    draw.bind('<ButtonRelease-1>', release)
    draw.bind('<Button-3>', delete)
    upper.grid(padx = 5, pady = 5)
    lower.grid(padx = 5, pady = 5)
    draw.grid(row = 0, column = 0, padx = 5, pady = 5, columnspan = 2)
    look.grid(padx = 5, pady = 5)
    cursor.grid(row = 1, column = 0, padx = 5, pady = 5, sticky = EW)
    canvas.grid(row = 1, column = 1, padx = 5, pady = 5, sticky = EW)
    root.mainloop()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3115044_69_76
3114924_3115210_49_59
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def __init__(self, function, * args, ** kwargs) :
INDENT
    "Initialize the Quantum_Timer object."
    self.__function = function
    self.__args = args
    self.__kwargs = kwargs
    self.__thread = False
    self.__lock = _thread.allocate_lock()
DEDENT
----------------------------------------

def __init__(self, ZSP) :
INDENT
    'Initialize the Query/Reply Protocol object.'
    self.__ZSP = ZSP
    self.__error = None
    self.__Q_anchor = []
    self.__Q_packet = []
    self.__R_anchor = {}
    self.__Q_lock = thread.allocate_lock()
    self.__R_lock = thread.allocate_lock()
    thread.start_new_thread(self.__thread, ())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3115069_103_108
3114924_3115210_309_314
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def motion(event) :
INDENT
    if hold :
    INDENT
        hold.extend([event.x, event.y])
        event.widget.create_line(hold [- 4 :], fill = fill, tag = 'TEMP')
        call('create_line', hold [- 4 :], fill = fill, tag = 'TEMP')
    DEDENT
DEDENT
----------------------------------------

def motion(event) :
INDENT
    if hold :
    INDENT
        hold.extend([event.x, event.y])
        event.widget.create_line(hold [- 4 :], fill = fill, tag = 'TEMP')
        call('create_line', hold [- 4 :], fill = fill, tag = 'TEMP')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3115069_89_94
3114924_3115210_294_299
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def change_cursor() :
INDENT
    global fill
    color = tkColorChooser.askcolor(color = fill) [1]
    if color is not None :
    INDENT
        fill = color
    DEDENT
DEDENT
----------------------------------------

def change_cursor() :
INDENT
    global fill
    color = tkColorChooser.askcolor(color = fill) [1]
    if color is not None :
    INDENT
        fill = color
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3115069_95_102
3114924_3115210_300_308
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def change_canvas() :
INDENT
    color = tkColorChooser.askcolor(color = draw ['bg']) [1]
    if color is not None :
    INDENT
        draw.config(bg = color)
        call('config', bg = color)

    DEDENT
DEDENT
----------------------------------------

def change_canvas() :
INDENT
    color = tkColorChooser.askcolor(color = draw ['bg']) [1]
    if color is not None :
    INDENT
        draw ['bg'] = color
        draw.config(bg = color)
        call('config', bg = color)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3114924_3115210_208_216
3114924_3115210_286_293
Title: "I have a serial Python application that takes hours to process how can I decrease the time it takes to run?" 
----------------------------------------

def call(self, obj, timeout = None) :
INDENT
    'Send one query and receive one reply.'
    self.__lock.acquire()
    ID = ''.join(chr(self.__ID >> shift & 0xFF) for shift in range(24, - 8, - 8))
    self.__ID = (self.__ID + 1) % (2 ** 32)
    self.__lock.release()
    self.__QRP.send_Q(ID, obj)
    return self.__QRP.recv_R(ID, timeout)
DEDENT
----------------------------------------

def call(func, * args, ** kwargs) :
INDENT
    try :
    INDENT
        QRI.call((func, args, kwargs), 0.05)
    DEDENT
    except :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31162560_31163085_4_11
31162560_31167166_4_10
Title: Flask route rule as function args 
----------------------------------------

def test(command = None, arg1 = None, arg2 = None) :
INDENT
    a = [arg1, arg2]
    args = [arg for arg in a if arg is not None]
    if command == "say" :
    INDENT
        return ' '.join(args)
    DEDENT
    else :
    INDENT
        return "Unknown Command"
    DEDENT
DEDENT
----------------------------------------

def test(command = "", args = "") :
INDENT
    if args :
    INDENT
        args = tuple(args.split("/"))
    DEDENT
    else :
    INDENT
        args = tuple()
    DEDENT
    return "{0}: {1}".format(command, args)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31168051_31170170_131_138
31168051_31170170_24_49
Title: Creating Probability/Frequency Axis Grid (Irregularly Spaced) with Matplotlib 
----------------------------------------

def __init__(self, lower_bound, upper_bound, L, k, x0) :
INDENT
    mtransforms.Transform.__init__(self)
    self.lower_bound = lower_bound
    self.L = L
    self.k = k
    self.x0 = x0
    self.upper_bound = upper_bound
DEDENT
----------------------------------------

def __init__(self, axis, ** kwargs) :
INDENT
    mscale.ScaleBase.__init__(self)
    lower_bound = kwargs.pop("lower_bound",.01)
    if lower_bound < = 0 :
    INDENT
        raise ValueError("lower_bound must be greater than 0")
    DEDENT
    self.lower_bound = lower_bound
    upper_bound_dist = kwargs.pop("upper_bound_dist", lower_bound)
    self.points = kwargs ['points']
    x = np.linspace(0, 1, len(self.points))
    p0 = [max(self.points), 1,.5]
    popt, pcov = curve_fit(logistic, x, self.points, p0 = p0)
    [self.L, self.k, self.x0] = popt
    self.upper_bound = self.L - upper_bound_dist
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31168051_31170170_131_138
31168051_31170170_97_103
Title: Creating Probability/Frequency Axis Grid (Irregularly Spaced) with Matplotlib 
----------------------------------------

def __init__(self, lower_bound, upper_bound, L, k, x0) :
INDENT
    mtransforms.Transform.__init__(self)
    self.lower_bound = lower_bound
    self.L = L
    self.k = k
    self.x0 = x0
    self.upper_bound = upper_bound
DEDENT
----------------------------------------

def __init__(self, lower_bound, upper_bound, L, k, x0) :
INDENT
    mtransforms.Transform.__init__(self)
    self.lower_bound = lower_bound
    self.L = L
    self.k = k
    self.x0 = x0
    self.upper_bound = upper_bound
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31168051_31170170_131_138
31168051_31273927_31_61
Title: Creating Probability/Frequency Axis Grid (Irregularly Spaced) with Matplotlib 
----------------------------------------

def __init__(self, lower_bound, upper_bound, L, k, x0) :
INDENT
    mtransforms.Transform.__init__(self)
    self.lower_bound = lower_bound
    self.L = L
    self.k = k
    self.x0 = x0
    self.upper_bound = upper_bound
DEDENT
----------------------------------------

def __init__(self, axis, ** kwargs) :
INDENT
    mscale.ScaleBase.__init__(self)
    upper = kwargs.pop("upper", 98)
    if upper < = 0 or upper > = 100 :
    INDENT
        raise ValueError("upper must be between 0 and 100.")
    DEDENT
    lower = kwargs.pop("lower", 0.2)
    if lower < = 0 or lower > = 100 :
    INDENT
        raise ValueError("lower must be between 0 and 100.")
    DEDENT
    if lower > = upper :
    INDENT
        raise ValueError("lower must be strictly less than upper!.")
    DEDENT
    self.lower = lower
    self.upper = upper

    mu = kwargs.pop("mu", 15)
    sigma = kwargs.pop("sigma", 40)
    self.mu = mu
    self.sigma = sigma
    axis.axes.set_xlim(lower, upper)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31168051_31170170_24_49
31168051_31170170_97_103
Title: Creating Probability/Frequency Axis Grid (Irregularly Spaced) with Matplotlib 
----------------------------------------

def __init__(self, axis, ** kwargs) :
INDENT
    mscale.ScaleBase.__init__(self)
    lower_bound = kwargs.pop("lower_bound",.01)
    if lower_bound < = 0 :
    INDENT
        raise ValueError("lower_bound must be greater than 0")
    DEDENT
    self.lower_bound = lower_bound
    upper_bound_dist = kwargs.pop("upper_bound_dist", lower_bound)
    self.points = kwargs ['points']
    x = np.linspace(0, 1, len(self.points))
    p0 = [max(self.points), 1,.5]
    popt, pcov = curve_fit(logistic, x, self.points, p0 = p0)
    [self.L, self.k, self.x0] = popt
    self.upper_bound = self.L - upper_bound_dist
DEDENT
----------------------------------------

def __init__(self, lower_bound, upper_bound, L, k, x0) :
INDENT
    mtransforms.Transform.__init__(self)
    self.lower_bound = lower_bound
    self.L = L
    self.k = k
    self.x0 = x0
    self.upper_bound = upper_bound
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31168051_31170170_24_49
31168051_31273927_31_61
Title: Creating Probability/Frequency Axis Grid (Irregularly Spaced) with Matplotlib 
----------------------------------------

def __init__(self, axis, ** kwargs) :
INDENT
    mscale.ScaleBase.__init__(self)
    lower_bound = kwargs.pop("lower_bound",.01)
    if lower_bound < = 0 :
    INDENT
        raise ValueError("lower_bound must be greater than 0")
    DEDENT
    self.lower_bound = lower_bound
    upper_bound_dist = kwargs.pop("upper_bound_dist", lower_bound)
    self.points = kwargs ['points']
    x = np.linspace(0, 1, len(self.points))
    p0 = [max(self.points), 1,.5]
    popt, pcov = curve_fit(logistic, x, self.points, p0 = p0)
    [self.L, self.k, self.x0] = popt
    self.upper_bound = self.L - upper_bound_dist
DEDENT
----------------------------------------

def __init__(self, axis, ** kwargs) :
INDENT
    mscale.ScaleBase.__init__(self)
    upper = kwargs.pop("upper", 98)
    if upper < = 0 or upper > = 100 :
    INDENT
        raise ValueError("upper must be between 0 and 100.")
    DEDENT
    lower = kwargs.pop("lower", 0.2)
    if lower < = 0 or lower > = 100 :
    INDENT
        raise ValueError("lower must be between 0 and 100.")
    DEDENT
    if lower > = upper :
    INDENT
        raise ValueError("lower must be strictly less than upper!.")
    DEDENT
    self.lower = lower
    self.upper = upper

    mu = kwargs.pop("mu", 15)
    sigma = kwargs.pop("sigma", 40)
    self.mu = mu
    self.sigma = sigma
    axis.axes.set_xlim(lower, upper)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31168051_31170170_97_103
31168051_31273927_31_61
Title: Creating Probability/Frequency Axis Grid (Irregularly Spaced) with Matplotlib 
----------------------------------------

def __init__(self, lower_bound, upper_bound, L, k, x0) :
INDENT
    mtransforms.Transform.__init__(self)
    self.lower_bound = lower_bound
    self.L = L
    self.k = k
    self.x0 = x0
    self.upper_bound = upper_bound
DEDENT
----------------------------------------

def __init__(self, axis, ** kwargs) :
INDENT
    mscale.ScaleBase.__init__(self)
    upper = kwargs.pop("upper", 98)
    if upper < = 0 or upper > = 100 :
    INDENT
        raise ValueError("upper must be between 0 and 100.")
    DEDENT
    lower = kwargs.pop("lower", 0.2)
    if lower < = 0 or lower > = 100 :
    INDENT
        raise ValueError("lower must be between 0 and 100.")
    DEDENT
    if lower > = upper :
    INDENT
        raise ValueError("lower must be strictly less than upper!.")
    DEDENT
    self.lower = lower
    self.upper = upper

    mu = kwargs.pop("mu", 15)
    sigma = kwargs.pop("sigma", 40)
    self.mu = mu
    self.sigma = sigma
    axis.axes.set_xlim(lower, upper)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31170616_31171812_46_55
31170616_31171812_4_25
Title: How to access a method in one inherited tkinter class from another inherited tkinter class 
----------------------------------------

def __init__(self, parent) :
INDENT
    self.parent = parent
    tk.Frame.__init__(self, self.parent)
    self.testing = Testing(self.parent, self)
    self.results = Results(self.parent, self)
    self.testing.pack(fill = tk.X)
    self.results.pack(fill = tk.X)
DEDENT
----------------------------------------

def __init__(self, parent, main) :
INDENT
    self.buttonWidth = 10
    self.parent = parent
    self.main = main
    tk.LabelFrame.__init__(self, self.parent,
        text = "Test Operations",
        padx = 10,
        pady = 10)
    self.taskButton = tk.Button(
        self,
        text = "Do A Task",
        width = self.buttonWidth,
        command = self.doATask,
        )
    self.taskButton.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31192394_31192562_6_14
31192394_31192644_7_17
Title: Attempting to create Primacy test in Python but stuck... please troubleshoot 
----------------------------------------

def isnotaprimenumber(n) :
INDENT
    if int(n) < 2 : print (notprime)
    else :
    INDENT
        for number in islice(count(2), int(sqrt((int(n)) - 1))) :
        INDENT
            if (n % number == 0) :
            INDENT
                print (notprime)
                return
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def isnotaprimenumber(n) :
INDENT
    if n < 2 :
    INDENT
        print (notprime)
    DEDENT
    else :
    INDENT
        for number in range(2, int(sqrt(n) + 1)) :
        INDENT
            print (number)
            if (n % number == 0) :
            INDENT
                print (notprime)
                return
            DEDENT
        DEDENT
        print ('prime')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31194045_31194303_7_14
31194045_31194320_6_13
Title: Threading on a list of arguments 
----------------------------------------

def countdown(n) :
INDENT
    while n > 0 :
    INDENT
        print ('T-minus', n)
        n -= 1
        time.sleep(0.5)

    DEDENT
DEDENT
----------------------------------------

def countdown(n) :
INDENT
    while n > 0 :
    INDENT
        print ('T-minus', n)
        n -= 1
        time.sleep(0.5)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31194045_31194303_7_14
31194045_31194365_8_13
Title: Threading on a list of arguments 
----------------------------------------

def countdown(n) :
INDENT
    while n > 0 :
    INDENT
        print ('T-minus', n)
        n -= 1
        time.sleep(0.5)

    DEDENT
DEDENT
----------------------------------------

def countdown(n) :
INDENT
    while n > 0 :
    INDENT
        print ('T-minus', n)
        n -= 1
        time.sleep(0.5)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31194045_31194320_6_13
31194045_31194365_8_13
Title: Threading on a list of arguments 
----------------------------------------

def countdown(n) :
INDENT
    while n > 0 :
    INDENT
        print ('T-minus', n)
        n -= 1
        time.sleep(0.5)

    DEDENT
DEDENT
----------------------------------------

def countdown(n) :
INDENT
    while n > 0 :
    INDENT
        print ('T-minus', n)
        n -= 1
        time.sleep(0.5)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31206443_31207520_3_21
31206443_48523180_19_30
Title: numpy second derivative of a ndimensional array 
----------------------------------------

def hessian(x) :
INDENT
    x_grad = np.gradient(x)
    hessian = np.empty((x.ndim, x.ndim) + x.shape, dtype = x.dtype)
    for k, grad_k in enumerate(x_grad) :
    INDENT

        tmp_grad = np.gradient(grad_k)
        for l, grad_kl in enumerate(tmp_grad) :
        INDENT
            hessian [k, l, :, :] = grad_kl
        DEDENT
    DEDENT
    return hessian
DEDENT
----------------------------------------

def hessian(x, the_func) :
INDENT
    N = x.shape [0]
    hessian = np.zeros((N, N))
    gd_0 = gradient_f(x, the_func)
    eps = np.linalg.norm(gd_0) * np.finfo(np.float32).eps
    for i in range(N) :
    INDENT
        xx0 = 1.* x [i]
        x [i] = xx0 + eps
        gd_1 = gradient_f(x, the_func)
        hessian [:, i] = ((gd_1 - gd_0) / eps).reshape(x.shape [0])
        x [i] = xx0
    DEDENT
    return hessian
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31210854_31211203_1_21
31210854_31211285_1_33
Title: Number of subarrays within a sum range 
----------------------------------------

def numRange(A, B, C) :
INDENT
    n = len(A)
    sets = []
    for i in range(n) :
    INDENT
        sum = 0
        j = i
        while sum < B and j < n :
        INDENT
            sum += A [j]
            j += 1
        DEDENT
        while sum > = B and sum < = C and j < = n :
        INDENT
            if sum < = C :
            INDENT
                sets.append(A [i : j])
            DEDENT
            if j < n :
            INDENT
                sum += A [j]
            DEDENT
            j += 1
        DEDENT
    DEDENT
    return sets
DEDENT
----------------------------------------

def numRange(A, B, C) :
INDENT
    current = []
    current_sum = 0
    count = 0
    for number in A :
    INDENT
        current.append(number)
        current_sum += number
        while current_sum > C :
        INDENT
            current_sum -= current [0]
            current = current [1 :]
        DEDENT
        if B < = current_sum < = C :
        INDENT
            count += 1
            print current_sum, current
        DEDENT
    DEDENT
    if not current :
    INDENT
        return count
    DEDENT
    current_sum -= current [0]
    current = current [1 :]
    while (B < = current_sum < = C) :
    INDENT
        count += 1
        print current_sum, current
        current_sum -= current [0]
        current = current [1 :]
    DEDENT
    return count

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31210854_31211203_1_21
31210854_33387133_2_21
Title: Number of subarrays within a sum range 
----------------------------------------

def numRange(A, B, C) :
INDENT
    n = len(A)
    sets = []
    for i in range(n) :
    INDENT
        sum = 0
        j = i
        while sum < B and j < n :
        INDENT
            sum += A [j]
            j += 1
        DEDENT
        while sum > = B and sum < = C and j < = n :
        INDENT
            if sum < = C :
            INDENT
                sets.append(A [i : j])
            DEDENT
            if j < n :
            INDENT
                sum += A [j]
            DEDENT
            j += 1
        DEDENT
    DEDENT
    return sets
DEDENT
----------------------------------------

def numRange(self, A, B, C) :
INDENT
    count = 0
    end = len(A) - 1
    tot = 0
    temp_sum = 0
    temp_array = []
    tot_sum = sum(A [0 : len(A)])
    for i in range(len(A)) :
    INDENT
        current_sum = 0
        for j in range(i, len(A)) :
        INDENT
            current_sum += A [j]
            if (current_sum > C) :
            INDENT
                break
            DEDENT
            elif (B < = current_sum < = C) :
            INDENT

                tot += 1
            DEDENT
        DEDENT
        tot_sum -= A [i]
        if (tot_sum < B) :
        INDENT
            break
        DEDENT
    DEDENT
    return tot
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31210854_31211285_1_33
31210854_33387133_2_21
Title: Number of subarrays within a sum range 
----------------------------------------

def numRange(A, B, C) :
INDENT
    current = []
    current_sum = 0
    count = 0
    for number in A :
    INDENT
        current.append(number)
        current_sum += number
        while current_sum > C :
        INDENT
            current_sum -= current [0]
            current = current [1 :]
        DEDENT
        if B < = current_sum < = C :
        INDENT
            count += 1
            print current_sum, current
        DEDENT
    DEDENT
    if not current :
    INDENT
        return count
    DEDENT
    current_sum -= current [0]
    current = current [1 :]
    while (B < = current_sum < = C) :
    INDENT
        count += 1
        print current_sum, current
        current_sum -= current [0]
        current = current [1 :]
    DEDENT
    return count

DEDENT
----------------------------------------

def numRange(self, A, B, C) :
INDENT
    count = 0
    end = len(A) - 1
    tot = 0
    temp_sum = 0
    temp_array = []
    tot_sum = sum(A [0 : len(A)])
    for i in range(len(A)) :
    INDENT
        current_sum = 0
        for j in range(i, len(A)) :
        INDENT
            current_sum += A [j]
            if (current_sum > C) :
            INDENT
                break
            DEDENT
            elif (B < = current_sum < = C) :
            INDENT

                tot += 1
            DEDENT
        DEDENT
        tot_sum -= A [i]
        if (tot_sum < B) :
        INDENT
            break
        DEDENT
    DEDENT
    return tot
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31235708_31237181_21_27
31235708_31237391_21_27
Title: Project Euler 17 using Python 2.7 
----------------------------------------

def correct(num, strings) :
INDENT
    if int(str(num) [- 2 :]) in nums.keys() :
    INDENT
        del strings [- 2 :]
        strings.append(nums [int(str(num) [- 2 :])])
    DEDENT
    return strings

DEDENT
----------------------------------------

def correct(num, strings) :
INDENT
    if int(str(num) [- 2 :]) in nums.keys() :
    INDENT
        del strings [- 2 :]
        strings.append(nums [int(str(num) [- 2 :])])
    DEDENT
    return strings

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
312925_39063319_3_11
312925_49051524_5_13
Title: Django authentication and Ajax - URLs that require login 
----------------------------------------

def ajax_login_required(function) :
INDENT
    def wrap(request, * args, ** kwargs) :
    INDENT
        if request.user.is_authenticated() :
        INDENT
            return function(request, * args, ** kwargs)
        DEDENT
        json = simplejson.dumps({'not_authenticated' : True})
        return HttpResponse(json, mimetype = 'application/json')
    DEDENT
    wrap.__doc__ = function.__doc__
    wrap.__name__ = function.__name__
    return wrap
DEDENT
----------------------------------------

def ajax_login_required(view_func) :
INDENT
    @ functools.wraps(view_func)
    def wrapper(request, * args, ** kwargs) :
    INDENT
        if request.user.is_authenticated :
        INDENT
            return view_func(request, * args, ** kwargs)
        DEDENT
        return django.http.JsonResponse('Unauthorized', status = 401, safe = False)
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31316766_31630720_53_59
31316766_31639054_31_37
Title: Clean way of structuring ctypes class 
----------------------------------------

def _getarray(self, seq, data_type) :
INDENT
    if type(type(seq)) == self._array_type and seq._type_ is data_type :
    INDENT
        print ("Optimized!")
        return seq
    DEDENT
    return (data_type * len(seq))(* seq)
DEDENT
----------------------------------------

def _getarray(self, seq, data_type) :
INDENT
    if type(type(seq)) == self._array_type and seq._type_ is data_type :
    INDENT
        print ("Optimized!")
        return seq
    DEDENT
    return (data_type * len(seq))(* seq)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31319158_31319243_1_11
31319158_31319326_3_7
Title: iterating over dictionaries and returning the corresponding string 
----------------------------------------

def morse(s) :
INDENT
    morsecode = {'a' : ".-", 'b' : "-...", 'c' : "-.-.", 'd' : "-..", 'e' : ".", 'f' : "..-.", 'g' : "--.", 'h' : "....", 'i' : "..", 'j' : ".---", 'k' : "-.-", 'l' : ".-..", 'm' : "--", 'n' : "-.", 'o' : "---", 'p' : ".--.", 'q' : "--.-", 'r' : ".-.", 's' : "...", 't' : "-", 'u' : "..-", 'v' : "...-", 'w' : ".--", 'x' : "-..-", 'y' : "-.--", 'z' : "--.."}
    f = ""
    for i in s :
    INDENT
        if not i == ' ' :
        INDENT
            f += morsecode [i]
        DEDENT
        else :
        INDENT
            f += ' '
        DEDENT
    DEDENT
    return f
DEDENT
----------------------------------------

def morse(s) :
INDENT
    outputs = ''
    for item in s :
    INDENT
        outputs += morsecode.get(item, item)
    DEDENT
    return outputs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31319158_31319243_1_11
31319158_31319563_4_9
Title: iterating over dictionaries and returning the corresponding string 
----------------------------------------

def morse(s) :
INDENT
    morsecode = {'a' : ".-", 'b' : "-...", 'c' : "-.-.", 'd' : "-..", 'e' : ".", 'f' : "..-.", 'g' : "--.", 'h' : "....", 'i' : "..", 'j' : ".---", 'k' : "-.-", 'l' : ".-..", 'm' : "--", 'n' : "-.", 'o' : "---", 'p' : ".--.", 'q' : "--.-", 'r' : ".-.", 's' : "...", 't' : "-", 'u' : "..-", 'v' : "...-", 'w' : ".--", 'x' : "-..-", 'y' : "-.--", 'z' : "--.."}
    f = ""
    for i in s :
    INDENT
        if not i == ' ' :
        INDENT
            f += morsecode [i]
        DEDENT
        else :
        INDENT
            f += ' '
        DEDENT
    DEDENT
    return f
DEDENT
----------------------------------------

def morse(mystring) :
INDENT
    output = ""
    for item in mystring :
    INDENT
        if item in morsecode.keys() :
        INDENT
            output += morsecode [item]
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31319158_31319326_3_7
31319158_31319563_4_9
Title: iterating over dictionaries and returning the corresponding string 
----------------------------------------

def morse(s) :
INDENT
    outputs = ''
    for item in s :
    INDENT
        outputs += morsecode.get(item, item)
    DEDENT
    return outputs
DEDENT
----------------------------------------

def morse(mystring) :
INDENT
    output = ""
    for item in mystring :
    INDENT
        if item in morsecode.keys() :
        INDENT
            output += morsecode [item]
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31346593_31347307_5_24
31346593_31393091_6_28
Title: How to list all directories that do not contain a file type? 
----------------------------------------

def get_filepaths(directory, ext_list) :
INDENT
    folder_paths = []
    job_folders = set([])

    for dir, subdirs, files in os.walk(directory) :
    INDENT
        _, lastlevel = os.path.split(dir)
        if re.search('^[0-9]', lastlevel) :
        INDENT
            job_folders.add(lastlevel [: 8])
        DEDENT
        for item in files :
        INDENT
            root, ext = os.path.splitext(item)
            if ext in ext_list :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT

            folder_paths.append(os.path.relpath(dir, directory))
        DEDENT
    DEDENT
    return folder_paths, job_folders
DEDENT
----------------------------------------

def get_filepaths(directory, ext_list) :
INDENT
    not_okay = set([])
    okay = set([])
    job_folders = set([])

    for dir, subdirs, files in os.walk(directory) :
    INDENT
        for item in files :
        INDENT
            root, ext = os.path.splitext(item)
            if len(dir.split(os.sep)) > = 8 :
            INDENT
                job_folder = dir.split(os.sep) [7]
                if ext in ext_list :
                INDENT
                    okay.add(job_folder)
                DEDENT
                else :
                INDENT
                    not_okay.add(job_folder)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    bad_list = list(not_okay - okay)
    bad_list.sort()
    return bad_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31369259_40012083_1_25
31369259_41608614_1_14
Title: How to remove last odd number in a list 
----------------------------------------

def remove_last_odd(numbers) :
INDENT
    found_it = False
    first_list = []
    second_list = []
    third_list = []
    for num in numbers [: : - 1] :
    INDENT
        first_list.append(num)
    DEDENT
    for num in first_list :
    INDENT
        if found_it == False :
        INDENT
            if num % 2 == 0 :
            INDENT
                second_list.append(num)
            DEDENT
            else :
            INDENT
                found_it = True
            DEDENT
        DEDENT
        else :
        INDENT
            second_list.append(num)
        DEDENT
    DEDENT
    for num in second_list [: : - 1] :
    INDENT
        third_list.append(num)
    DEDENT
    return third_list
DEDENT
----------------------------------------

def remove_last_odd(numbers) :
INDENT
    has_odd = False
    last_odd = 0
    for num in range(len(numbers)) :
    INDENT
        if numbers [num] % 2 == 1 :
        INDENT
            has_odd = True
            last_odd = num
        DEDENT
        if has_odd :
        INDENT
            numbers.pop(last_odd)
        DEDENT
    DEDENT
    return numbers
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31369262_31369382_1_12
31369262_31378158_1_15
Title: Python list of frequent occurrences in a list of strings 
----------------------------------------

def trending(slst) :
INDENT
    count = {}
    items = []
    for item in set(slst) :
    INDENT
        count [item] = slst.count(item)
    DEDENT
    for k, v in count.items() :
    INDENT
        if v == max(count.values()) :
        INDENT
            items.append(k)
        DEDENT
    DEDENT
    return items
DEDENT
----------------------------------------

def trending(words) :
INDENT
    lcounts = [(words.count(word), word) for word in words]
    lcounts.sort(reverse = True)
    ltrending = []
    for count, word in lcounts :
    INDENT
        if count == lcounts [0] [0] :
        INDENT
            if word not in ltrending :
            INDENT
                ltrending.append(word)
            DEDENT
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
    return ltrending

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31372252_31372469_1_7
31372252_31372646_1_11
Title: Python exec() problems 
----------------------------------------

def test(variable, customCode = "") :
INDENT
    d = {"variable" : variable}
    if customCode ! = "" :
    INDENT
        exec (customCode, d)
    DEDENT
    if d ["foo"] == 1 :
    INDENT
        print ("Success")
    DEDENT
DEDENT
----------------------------------------

def test(variable, customCode = "") :
INDENT
    if variable > 1 :
    INDENT
        print ("><![CDATA[1")
    DEDENT
    if customCode ! = "" :
    INDENT
        exec (customCode)
    DEDENT
    if foo == 1 :
    INDENT
        print ("Success")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31376763_31540945_65_72
31376763_31540945_74_81
Title: How to cope with the performance of generating signed URLs for accessing private content via CloudFront? 
----------------------------------------

def _sign_string(
self,
message,
private_key_file = None,
private_key_string = None) :
INDENT
    return sign_with_cryptography(message)

DEDENT
----------------------------------------

def _sign_string(
self,
message,
private_key_file = None,
private_key_string = None) :
INDENT
    return sign_with_rsa(message)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31386570_31393858_30_43
31386570_31393858_48_56
Title: wxPython: Ensure only one instance of a panel is open 
----------------------------------------

def __init__(self) :
INDENT
    print id(self)
    if self.init :
    INDENT
        return
    DEDENT
    self.init = 1
    wx.Frame.__init__(self, None, title = "Single Instance Frame")
    panel = MyPanel(self)
    self.Show()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = "Main Frame")
    panel = MyPanel(self)
    btn = wx.Button(panel, label = "Open Frame")
    btn.Bind(wx.EVT_BUTTON, self.open_frame)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31402115_31405623_17_26
31402115_31405623_34_47
Title: Ping pong clone collision detection 
----------------------------------------

def __init__(self, start_pos, up_key, down_key) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.surface.Surface((20, 100))
    self.image.fill(pygame.color.Color('White'))
    self.image.set_colorkey(pygame.color.Color('Black'))
    self.rect = self.image.get_rect(topleft = start_pos)
    self.mask = pygame.mask.from_surface(self.image)
    self.up_key, self.down_key = up_key, down_key
DEDENT
----------------------------------------

def __init__(self, start_pos) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.surface.Surface((20, 20))
    self.rect = self.image.get_rect(center = start_pos)
    pygame.draw.circle(self.image, pygame.color.Color('White'), self.image.get_rect().center, 10)
    self.image.set_colorkey(pygame.color.Color('Black'))
    self.mask = pygame.mask.from_surface(self.image)
    self.move_v = (1, 0.7)

    self.pos = self.rect.center
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31410043_31417070_36_42
31410043_51856190_31_40
Title: Hiding lines after showing a pyplot figure 
----------------------------------------

def _setup_connections(self) :
INDENT
    for artist in self.legend.texts + self.legend.legendHandles :
    INDENT
        artist.set_picker(10)
    DEDENT
    self.fig.canvas.mpl_connect('pick_event', self.on_pick)
    self.fig.canvas.mpl_connect('button_press_event', self.on_click)
DEDENT
----------------------------------------

def _setup_connections(self) :
INDENT
    for legend in self.legends :
    INDENT
        for artist in legend.texts + legend.legendHandles :
        INDENT
            artist.set_picker(10)
        DEDENT
    DEDENT
    for figs in self.figures :
    INDENT
        figs.canvas.mpl_connect('pick_event', self.on_pick)
        figs.canvas.mpl_connect('button_press_event', self.on_click)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31410043_31417070_63_69
31410043_51856190_64_73
Title: Hiding lines after showing a pyplot figure 
----------------------------------------

def on_pick(self, event) :
INDENT
    handle = event.artist
    if handle in self.lookup_artist :
    INDENT
        artist = self.lookup_artist [handle]
        artist.set_visible(not artist.get_visible())
        self.update()
    DEDENT
DEDENT
----------------------------------------

def on_pick(self, event) :
INDENT
    handle = event.artist
    for lookup_artist in self.lookup_artists :
    INDENT
        if handle in lookup_artist :
        INDENT
            artist = lookup_artist [handle]
            artist.set_visible(not artist.get_visible())
            self.update()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31410043_31417070_82_90
31410043_51856190_87_96
Title: Hiding lines after showing a pyplot figure 
----------------------------------------

def update(self) :
INDENT
    for artist in self.lookup_artist.values() :
    INDENT
        handle = self.lookup_handle [artist]
        if artist.get_visible() :
        INDENT
            handle.set_visible(True)
        DEDENT
        else :
        INDENT
            handle.set_visible(False)
        DEDENT
    DEDENT
    self.fig.canvas.draw()
DEDENT
----------------------------------------

def update(self) :
INDENT
    for idx, lookup_artist in enumerate(self.lookup_artists) :
    INDENT
        for artist in lookup_artist.values() :
        INDENT
            handle = self.lookup_handles [idx] [artist]
            if artist.get_visible() :
            INDENT
                handle.set_visible(True)
            DEDENT
            else :
            INDENT
                handle.set_visible(False)
            DEDENT
        DEDENT
        self.figures [idx].canvas.draw()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31410462_31412683_4_13
31410462_52358204_4_15
Title: How to stop a running function without exiting the Tkinter window entirely? 
----------------------------------------

def __init__(self, master) :
INDENT
    self.startButton = Button(master, text = 'Start', command = self.start)
    self.startButton.grid(row = 0, column = 0)
    self.stopButton = Button(master, text = 'Stop', command = self.stop)
    self.stopButton.grid(row = 0, column = 1)
    self.textBox = Text(master, bd = 2)
    self.textBox.grid(row = 1, columnspan = 2)
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.cancel_id = None
    self.startButton = Button(master, text = 'Start', command = self.start)
    self.startButton.grid(row = 0, column = 0)
    self.stopButton = Button(master, text = 'Stop', command = self.stop)
    self.stopButton.grid(row = 0, column = 1)
    self.textBox = Text(master, bd = 2)
    self.textBox.grid(row = 1, columnspan = 2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31415825_31418927_11_26
31415825_31418927_40_51
Title: PyQt and Matplotlib: creating a copy of a plot 
----------------------------------------

def __init__(self, parent = None, width = 5, height = 4, dpi = 100) :
INDENT
    fig = Figure(figsize = (width, height), dpi = dpi)
    self.fig = fig
    self.axes = fig.add_subplot(111)
    self.axes.hold(False)
    self.compute_initial_figure()
    FigureCanvas.__init__(self, fig)
    self.setParent(parent)
    FigureCanvas.setSizePolicy(self,
        QtGui.QSizePolicy.Expanding,
        QtGui.QSizePolicy.Expanding)
    FigureCanvas.updateGeometry(self)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QWidget.__init__(self)
    self.setAttribute(QtCore.Qt.WA_DeleteOnClose)
    self.main_widget = QtGui.QWidget(self)
    l = QtGui.QVBoxLayout(self)
    sc = MyStaticMplCanvas(self, width = 5, height = 4, dpi = 100)
    self.sc = sc
    l.addWidget(sc)
    but = QtGui.QPushButton("make_new", self)
    but.clicked.connect(self.again)
    l.addWidget(but)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31450765_31454198_23_38
31450765_31454198_66_77
Title: Strange timing issues in PyGame when animating bouncing balls 
----------------------------------------

def __init__(self) :
INDENT
    Sprite.__init__(self)

    self.image = Surface((30, 30))
    self.rect = self.image.get_rect()
    self.image.fill(Color('Black'))

    self.image.set_colorkey(Color('Purple'))
    self.mask = pygame.mask.from_surface(self.image)
    self.deaths = 0
DEDENT
----------------------------------------

def __init__(self, start_x, speed) :
INDENT
    Sprite.__init__(self)

    self.image = Surface((30, 30))
    self.rect = self.image.get_rect(x = start_x, y = 100)
    self.image.fill(Color('Purple'))
    self.image.set_colorkey(Color('Purple'))
    pygame.draw.ellipse(self.image, Color('Blue'), (0, 0, 30, 30), 0)
    self.mask = pygame.mask.from_surface(self.image)
    self.y_vel = speed
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31450765_31454198_39_64
31450765_31454198_78_90
Title: Strange timing issues in PyGame when animating bouncing balls 
----------------------------------------

def update(self) :
INDENT
    self.image.fill(random.choice(colour_list))

    pressed = pygame.key.get_pressed()
    for key, movement in keys.iteritems() :
    INDENT
        if pressed [key] :
        INDENT

            self.rect.move_ip(movement)

        DEDENT
    DEDENT
    self.rect.clamp_ip(pygame.display.get_surface().get_rect())

    if pygame.sprite.spritecollide(self, objects, False, pygame.sprite.collide_mask) :
    INDENT
        self.deaths += 1
        self.rect.topleft = (0, 0)
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    target = self.rect.move(0, self.y_vel)

    if not pygame.display.get_surface().get_rect().contains(target) :
    INDENT

        self.y_vel *= - 1

    DEDENT
    self.rect.move_ip(0, self.y_vel)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31451843_31452183_1_21
31451843_31452899_1_14
Title: Why is my output list short of several items? 
----------------------------------------

def list_changer(var1, crypt_num) :
INDENT
    alphabet_list = list("abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz")
    caps_list = list("ABCDEFGHIJKLMNOPQRSTUVWXYZABCDEFGHIJKLMNOPQRSTUVWXYZ")
    output_list = []
    for item in var1 :
    INDENT
        tmp2 = item
        if tmp2 in alphabet_list :
        INDENT
            tmp3 = alphabet_list.index(tmp2)
            tpm3 = int(tmp3)
            object_int = tmp3 + crypt_num
            tmp4 = alphabet_list [object_int]
            output_list.append(tmp4)
        DEDENT
        elif tmp2 in caps_list :
        INDENT
            tmp3 = caps_list.index(tpm2)
            tmp3 = int(imp3)
            object_int = tmp3 + crypt_num
            tmp4 = caps_list [object_int]
            output_list.append(tmp4)
        DEDENT
        else :
        INDENT
            output_list.append(tmp2)
        DEDENT
    DEDENT
    return output_list
DEDENT
----------------------------------------

def list_changer(input_string, encrypt_level) :
INDENT
    output_list = []
    for character in input_string :
    INDENT
        char = ord(character)
        if not ((96 < char < 123) or (64 < char < 91)) :
        INDENT

            output_list.append(character)
            continue
        DEDENT
        offset = 97 if char > 96 else 65
        char = (char - offset + encrypt_level) % 26
        character = chr(char + offset)
        output_list.append(character)
    DEDENT
    return ''.join(output_list)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31475965_31476710_16_23
31475965_31557937_15_20
Title: Fastest way to populate QTableView from Pandas data frame 
----------------------------------------

def data(self, index, role = Qt.DisplayRole) :
INDENT
    if index.isValid() :
    INDENT
        if role == Qt.DisplayRole :
        INDENT
            return QtCore.QVariant(str(
                    self._data.values [index.row()] [index.column()]))
        DEDENT
    DEDENT
    return QtCore.QVariant()

DEDENT
----------------------------------------

def data(self, index, role = QtCore.Qt.DisplayRole) :
INDENT
    if index.isValid() :
    INDENT
        if role == QtCore.Qt.DisplayRole :
        INDENT
            return str(self._data.values [index.row()] [index.column()])
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31475965_31476710_16_23
31475965_42955764_15_20
Title: Fastest way to populate QTableView from Pandas data frame 
----------------------------------------

def data(self, index, role = Qt.DisplayRole) :
INDENT
    if index.isValid() :
    INDENT
        if role == Qt.DisplayRole :
        INDENT
            return QtCore.QVariant(str(
                    self._data.values [index.row()] [index.column()]))
        DEDENT
    DEDENT
    return QtCore.QVariant()

DEDENT
----------------------------------------

def data(self, index, role = QtCore.Qt.DisplayRole) :
INDENT
    if index.isValid() :
    INDENT
        if role == QtCore.Qt.DisplayRole :
        INDENT
            return str(self._data.iloc [index.row(), index.column()])
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31492480_31492506_1_13
31492480_31492524_2_10
Title: Why does this Python function return an UnboundLocalError? 
----------------------------------------

def scatter_x_y(self, filtered_data, x_parameter, y_parameter) :
INDENT
    for i in range(len(filtered_data)) :
    INDENT
        x_index, y_index = None, None
        if filtered_data [i].name == x_parameter :
        INDENT
            x = filtered_data [i]
            x_index = list(x.keys())
        DEDENT
        elif filtered_data [i].name == y_parameter :
        INDENT
            y = filtered_data [i]
            y_index = list(y.keys())
        DEDENT
        if x_index :
        INDENT
            print "x_index={}".format(x_index)
        DEDENT
        if y_index :
        INDENT
            print "y_index={}".format(y_index)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def scatter_x_y(self, filtered_data, x_parameter, y_parameter) :
INDENT
    for i in range(len(filtered_data)) :
    INDENT
        if filtered_data [i].name == x_parameter :
        INDENT
            x = filtered_data [i]
            x_index = list(x.keys())
        DEDENT
        elif filtered_data [i].name == y_parameter :
        INDENT
            y = filtered_data [i]
            y_index = list(y.keys())
        DEDENT
    DEDENT
    print x_index
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31508846_31509015_1_25
31508846_31509031_1_14
Title: How do I get all of one key from a list of dicts in Python? 
----------------------------------------

def do_GET(self) :
INDENT
    self.send_response(200)
    self.send_header('Content-type', 'application/json')
    self.end_headers()
    path = self.path [1 :]
    components = string.split(path, '/')
    if components and components [0] ! = 'data' :
    INDENT
        node = map(lambda x : x.get(components [0]), content)
    DEDENT
    else :
    INDENT
        node = content
        for component in components :
        INDENT
            if len(component) == 0 or component == "favicon.ico" :
            INDENT
                continue
            DEDENT
            if type(node) == dict :
            INDENT
                node = node [component]
            DEDENT
            elif type(node) == list :
            INDENT
                node = node [int(component)]
            DEDENT
        DEDENT
    DEDENT
    self.wfile.write(json.dumps(node))
    return
DEDENT
----------------------------------------

def do_GET(self) :
INDENT
    self.send_response(200)
    self.send_header('Content-type', 'application/json')
    self.end_headers()
    path = self.path [1 :]
    components = string.split(path, '/')
    node = parse_node(content, components)
    self.wfile.write(json.dumps(node))
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31508846_31509015_1_25
31508846_31509111_11_37
Title: How do I get all of one key from a list of dicts in Python? 
----------------------------------------

def do_GET(self) :
INDENT
    self.send_response(200)
    self.send_header('Content-type', 'application/json')
    self.end_headers()
    path = self.path [1 :]
    components = string.split(path, '/')
    if components and components [0] ! = 'data' :
    INDENT
        node = map(lambda x : x.get(components [0]), content)
    DEDENT
    else :
    INDENT
        node = content
        for component in components :
        INDENT
            if len(component) == 0 or component == "favicon.ico" :
            INDENT
                continue
            DEDENT
            if type(node) == dict :
            INDENT
                node = node [component]
            DEDENT
            elif type(node) == list :
            INDENT
                node = node [int(component)]
            DEDENT
        DEDENT
    DEDENT
    self.wfile.write(json.dumps(node))
    return
DEDENT
----------------------------------------

def do_GET(path) :
INDENT
    path = path [1 :]
    components = path.split('/')
    if components [0] == 'favicon.ico' :
    INDENT
        return "favicon response"
    DEDENT
    elif len(components) == 0 or not path :
    INDENT
        return "error response"
    DEDENT
    elif len(components) == 3 and components [0] == "data" :
    INDENT

        key, item_id, attr = components
        item_id = int(item_id)
        return json.dumps(JSON [key] [item_id] [attr])
    DEDENT
    elif len(components) == 1 :
    INDENT

        attr = components [0]
        out = []
        for k in JSON :
        INDENT
            for d in JSON [k] :
            INDENT
                if attr in d :
                INDENT
                    out.append(d [attr])
                DEDENT
            DEDENT
        DEDENT
        return json.dumps(out)
    DEDENT
    else :
    INDENT
        return "unknown response"
    DEDENT
    return json.dumps(node)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31508846_31509031_1_14
31508846_31509111_11_37
Title: How do I get all of one key from a list of dicts in Python? 
----------------------------------------

def do_GET(self) :
INDENT
    self.send_response(200)
    self.send_header('Content-type', 'application/json')
    self.end_headers()
    path = self.path [1 :]
    components = string.split(path, '/')
    node = parse_node(content, components)
    self.wfile.write(json.dumps(node))
    return
DEDENT
----------------------------------------

def do_GET(path) :
INDENT
    path = path [1 :]
    components = path.split('/')
    if components [0] == 'favicon.ico' :
    INDENT
        return "favicon response"
    DEDENT
    elif len(components) == 0 or not path :
    INDENT
        return "error response"
    DEDENT
    elif len(components) == 3 and components [0] == "data" :
    INDENT

        key, item_id, attr = components
        item_id = int(item_id)
        return json.dumps(JSON [key] [item_id] [attr])
    DEDENT
    elif len(components) == 1 :
    INDENT

        attr = components [0]
        out = []
        for k in JSON :
        INDENT
            for d in JSON [k] :
            INDENT
                if attr in d :
                INDENT
                    out.append(d [attr])
                DEDENT
            DEDENT
        DEDENT
        return json.dumps(out)
    DEDENT
    else :
    INDENT
        return "unknown response"
    DEDENT
    return json.dumps(node)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31543542_35966104_4_16
31543542_48347487_1_11
Title: Hierarchical Dirichlet Process Gensim topic number independent of corpus size 
----------------------------------------

def topic_prob_extractor(hdp = None, topn = None) :
INDENT
    topic_list = hdp.show_topics(topics = - 1, topn = topn)
    topics = [int(x.split(':') [0].split(' ') [1]) for x in topic_list]
    split_list = [x.split(' ') for x in topic_list]
    weights = []
    for lst in split_list :
    INDENT
        sub_list = []
        for entry in lst :
        INDENT
            if '*' in entry :
            INDENT
                sub_list.append(float(entry.split('*') [0]))
            DEDENT
        DEDENT
        weights.append(np.asarray(sub_list))
    DEDENT
    sums = [np.sum(x) for x in weights]
    return pd.DataFrame({'topic_id' : topics, 'weight' : sums})
DEDENT
----------------------------------------

def topic_prob_extractor(gensim_hdp, t = - 1, w = 25, isSorted = True) :
INDENT
    shown_topics = gensim_hdp.show_topics(num_topics = t, num_words = w, formatted = False)
    topics_nos = [x [0] for x in shown_topics]
    weights = [sum([item [1] for item in shown_topics [topicN] [1]]) for topicN in topics_nos]
    if (isSorted) :
    INDENT
        return pd.DataFrame({'topic_id' : topics_nos, 'weight' : weights}).sort_values(by = "weight", ascending = False);
    DEDENT
    else :
    INDENT
        return pd.DataFrame({'topic_id' : topics_nos, 'weight' : weights});
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31551395_31552515_1_17
31551395_31682011_1_37
Title: Tab Formatted Nested String to Nested List ~ Python 
----------------------------------------

def parse(data) :
INDENT
    stack = [[]]
    levels = [0]
    current = stack [0]
    for line in data.splitlines() :
    INDENT
        indent = len(line) - len(line.lstrip())
        if indent > levels [- 1] :
        INDENT
            levels.append(indent)
            stack.append([])
            current.append(stack [- 1])
            current = stack [- 1]
        DEDENT
        elif indent < levels [- 1] :
        INDENT
            stack.pop()
            current = stack [- 1]
            levels.pop()
        DEDENT
        current.append(line.strip().rstrip(':'))
    DEDENT
    return stack [0]
DEDENT
----------------------------------------

def parse(data) :
INDENT
    currentTab = 0
    currentList = []
    result = [currentList]
    i = 0
    tabCount = 0
    for line in data.splitlines() :
    INDENT

        tabCount = len(line) - len(line.lstrip())
        line = line.strip().rstrip(' :')
        if tabCount == currentTab :
        INDENT
            currentList.append(line)
        DEDENT
        elif tabCount > currentTab :
        INDENT
            newList = [line]
            currentList.append(newList)
            currentList = newList
        DEDENT
        elif tabCount == 0 :
        INDENT
            currentList = [line]
            result.append(currentList)
        DEDENT
        elif tabCount == 1 :
        INDENT
            currentList = [line]
            result [- 1].append(currentList)
        DEDENT
        currentTab = tabCount
        tabCount = tabCount + 1
        i = i + 1
    DEDENT
    print (result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31556882_31557596_33_43
31556882_31557596_51_70
Title: OOP tkinter: How to set focus (and add text) to entry? 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    ttk.Frame.__init__(self, parent)
    self.controller = controller
    label = ttk.Label(self, text = "StartPage", font = LARGE_FONT)
    label.pack(padx = 10, pady = 10)
    but_1 = ttk.Button(self, text = "Page 1",
        command = self.page_one_command)
    but_1.pack(padx = 10, pady = 10)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    ttk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "Page One", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    frame_answ = ttk.Frame(self)
    frame_answ.pack(side = tk.TOP, fill = tk.X)
    self.useranswer = tk.StringVar()
    self.entry_answ = ttk.Entry(self, textvariable = self.useranswer, font = ANSWER_FONT, justify = tk.CENTER)
    self.entry_answ.pack(fill = tk.X)
    frame_button = ttk.Frame(self)
    frame_button.pack(padx = 10, pady = 10)
    but_next = ttk.Button(frame_button, text = "back", state = tk.NORMAL,
        command = lambda : controller.show_frame(StartPage))
    but_next.pack(side = tk.LEFT)
DEDENT
----------------------------------------
