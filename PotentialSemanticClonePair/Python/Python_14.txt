$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21804592_21807844_7_25
21804592_21809246_28_47
Title: wxpython print to tabbed panel 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 700))
    self.tabbed = wx.Notebook(self, - 1, style = (wx.NB_TOP))
    self.panel1 = wx.Panel(self.tabbed, - 1)
    self.panel2 = wx.Panel(self.tabbed, - 1)
    self.panel3 = wx.Panel(self.tabbed, - 1)
    self.tabbed.AddPage(self.panel1, "Submit Job")
    self.tabbed.AddPage(self.panel2, "Queue")
    self.tabbed.AddPage(self.panel3, "Running Jobs")
    self.CreateStatusBar()
    menuBar = wx.MenuBar()
    menu = wx.Menu()
    self.SetMenuBar(menuBar)
    self.Centre()
    self.submit(self)
    self.queue(self)
    self.running(self)
DEDENT
----------------------------------------

def __init__(self, parent, queue_control) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.queue_control = queue_control
    self.selected_folder = None
    self.drop_target = MyFileDropTarget(self)
    self.tc_files = wx.TextCtrl(self, wx.ID_ANY, pos = (42, 120), size = (500, 25))
    self.tc_files.SetDropTarget(self.drop_target)
    self.buttonGo = wx.Button(self, - 1, "Submit", pos = (90, 530))
    self.buttonGo.Bind(wx.EVT_BUTTON, self.OnSubmit)
    self.buttonClose = wx.Button(self, - 1, "Quit", pos = (195, 530))
    self.buttonClose.Bind(wx.EVT_BUTTON, self.OnClose)
    outputtxt3 = '''Drag & Drop Folder of Packages to Verify'''
    wx.StaticText(self, - 1, outputtxt3, (33, 64), style = wx.ALIGN_CENTRE)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21804592_21807844_7_25
21804592_21809246_4_26
Title: wxpython print to tabbed panel 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 700))
    self.tabbed = wx.Notebook(self, - 1, style = (wx.NB_TOP))
    self.panel1 = wx.Panel(self.tabbed, - 1)
    self.panel2 = wx.Panel(self.tabbed, - 1)
    self.panel3 = wx.Panel(self.tabbed, - 1)
    self.tabbed.AddPage(self.panel1, "Submit Job")
    self.tabbed.AddPage(self.panel2, "Queue")
    self.tabbed.AddPage(self.panel3, "Running Jobs")
    self.CreateStatusBar()
    menuBar = wx.MenuBar()
    menu = wx.Menu()
    self.SetMenuBar(menuBar)
    self.Centre()
    self.submit(self)
    self.queue(self)
    self.running(self)
DEDENT
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 700))
    self.tabbed = wx.Notebook(self, - 1, style = (wx.NB_TOP))
    self.running = RunningPane(self.tabbed)
    self.queue = QueuePane(self.tabbed, self.running)
    self.submissions = SubmissionPane(self.tabbed, self.queue)
    self.tabbed.AddPage(self.submissions, "Submit Job")
    self.tabbed.AddPage(self.queue, "Queue")
    self.tabbed.AddPage(self.running, "Running Jobs")
    self.CreateStatusBar()
    menuBar = wx.MenuBar()
    menu = wx.Menu()
    self.SetMenuBar(menuBar)
    self.Centre()
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21804592_21807844_7_25
21804592_21809246_78_93
Title: wxpython print to tabbed panel 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 700))
    self.tabbed = wx.Notebook(self, - 1, style = (wx.NB_TOP))
    self.panel1 = wx.Panel(self.tabbed, - 1)
    self.panel2 = wx.Panel(self.tabbed, - 1)
    self.panel3 = wx.Panel(self.tabbed, - 1)
    self.tabbed.AddPage(self.panel1, "Submit Job")
    self.tabbed.AddPage(self.panel2, "Queue")
    self.tabbed.AddPage(self.panel3, "Running Jobs")
    self.CreateStatusBar()
    menuBar = wx.MenuBar()
    menu = wx.Menu()
    self.SetMenuBar(menuBar)
    self.Centre()
    self.submit(self)
    self.queue(self)
    self.running(self)
DEDENT
----------------------------------------

def __init__(self, parent, run_control) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.run_control = run_control
    self.queue = []
    self.buttonClose2 = wx.Button(self, - 1, "Quit", pos = (195, 170))
    self.buttonClose2.Bind(wx.EVT_BUTTON, self.OnClose)
    self.log_text = wx.TextCtrl(self, - 1, pos = (35, 210), size = (720, 400),
        style = wx.TE_MULTILINE | wx.TE_READONLY | wx.HSCROLL)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21804592_21809246_108_120
21804592_21809246_28_47
Title: wxpython print to tabbed panel 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.buttonClose3 = wx.Button(self, - 1, "Quit", pos = (195, 170))
    self.buttonClose3.Bind(wx.EVT_BUTTON, self.OnClose)
    self.running_log = wx.TextCtrl(self, - 1, pos = (35, 210), size = (720, 400),
        style = wx.TE_MULTILINE | wx.TE_READONLY | wx.HSCROLL)
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent, queue_control) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.queue_control = queue_control
    self.selected_folder = None
    self.drop_target = MyFileDropTarget(self)
    self.tc_files = wx.TextCtrl(self, wx.ID_ANY, pos = (42, 120), size = (500, 25))
    self.tc_files.SetDropTarget(self.drop_target)
    self.buttonGo = wx.Button(self, - 1, "Submit", pos = (90, 530))
    self.buttonGo.Bind(wx.EVT_BUTTON, self.OnSubmit)
    self.buttonClose = wx.Button(self, - 1, "Quit", pos = (195, 530))
    self.buttonClose.Bind(wx.EVT_BUTTON, self.OnClose)
    outputtxt3 = '''Drag & Drop Folder of Packages to Verify'''
    wx.StaticText(self, - 1, outputtxt3, (33, 64), style = wx.ALIGN_CENTRE)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21804592_21809246_108_120
21804592_21809246_4_26
Title: wxpython print to tabbed panel 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.buttonClose3 = wx.Button(self, - 1, "Quit", pos = (195, 170))
    self.buttonClose3.Bind(wx.EVT_BUTTON, self.OnClose)
    self.running_log = wx.TextCtrl(self, - 1, pos = (35, 210), size = (720, 400),
        style = wx.TE_MULTILINE | wx.TE_READONLY | wx.HSCROLL)
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 700))
    self.tabbed = wx.Notebook(self, - 1, style = (wx.NB_TOP))
    self.running = RunningPane(self.tabbed)
    self.queue = QueuePane(self.tabbed, self.running)
    self.submissions = SubmissionPane(self.tabbed, self.queue)
    self.tabbed.AddPage(self.submissions, "Submit Job")
    self.tabbed.AddPage(self.queue, "Queue")
    self.tabbed.AddPage(self.running, "Running Jobs")
    self.CreateStatusBar()
    menuBar = wx.MenuBar()
    menu = wx.Menu()
    self.SetMenuBar(menuBar)
    self.Centre()
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21804592_21809246_28_47
21804592_21809246_4_26
Title: wxpython print to tabbed panel 
----------------------------------------

def __init__(self, parent, queue_control) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.queue_control = queue_control
    self.selected_folder = None
    self.drop_target = MyFileDropTarget(self)
    self.tc_files = wx.TextCtrl(self, wx.ID_ANY, pos = (42, 120), size = (500, 25))
    self.tc_files.SetDropTarget(self.drop_target)
    self.buttonGo = wx.Button(self, - 1, "Submit", pos = (90, 530))
    self.buttonGo.Bind(wx.EVT_BUTTON, self.OnSubmit)
    self.buttonClose = wx.Button(self, - 1, "Quit", pos = (195, 530))
    self.buttonClose.Bind(wx.EVT_BUTTON, self.OnClose)
    outputtxt3 = '''Drag & Drop Folder of Packages to Verify'''
    wx.StaticText(self, - 1, outputtxt3, (33, 64), style = wx.ALIGN_CENTRE)
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 700))
    self.tabbed = wx.Notebook(self, - 1, style = (wx.NB_TOP))
    self.running = RunningPane(self.tabbed)
    self.queue = QueuePane(self.tabbed, self.running)
    self.submissions = SubmissionPane(self.tabbed, self.queue)
    self.tabbed.AddPage(self.submissions, "Submit Job")
    self.tabbed.AddPage(self.queue, "Queue")
    self.tabbed.AddPage(self.running, "Running Jobs")
    self.CreateStatusBar()
    menuBar = wx.MenuBar()
    menu = wx.Menu()
    self.SetMenuBar(menuBar)
    self.Centre()
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21804592_21809246_28_47
21804592_21809246_78_93
Title: wxpython print to tabbed panel 
----------------------------------------

def __init__(self, parent, queue_control) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.queue_control = queue_control
    self.selected_folder = None
    self.drop_target = MyFileDropTarget(self)
    self.tc_files = wx.TextCtrl(self, wx.ID_ANY, pos = (42, 120), size = (500, 25))
    self.tc_files.SetDropTarget(self.drop_target)
    self.buttonGo = wx.Button(self, - 1, "Submit", pos = (90, 530))
    self.buttonGo.Bind(wx.EVT_BUTTON, self.OnSubmit)
    self.buttonClose = wx.Button(self, - 1, "Quit", pos = (195, 530))
    self.buttonClose.Bind(wx.EVT_BUTTON, self.OnClose)
    outputtxt3 = '''Drag & Drop Folder of Packages to Verify'''
    wx.StaticText(self, - 1, outputtxt3, (33, 64), style = wx.ALIGN_CENTRE)
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent, run_control) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.run_control = run_control
    self.queue = []
    self.buttonClose2 = wx.Button(self, - 1, "Quit", pos = (195, 170))
    self.buttonClose2.Bind(wx.EVT_BUTTON, self.OnClose)
    self.log_text = wx.TextCtrl(self, - 1, pos = (35, 210), size = (720, 400),
        style = wx.TE_MULTILINE | wx.TE_READONLY | wx.HSCROLL)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21804592_21809246_4_26
21804592_21809246_78_93
Title: wxpython print to tabbed panel 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (800, 700))
    self.tabbed = wx.Notebook(self, - 1, style = (wx.NB_TOP))
    self.running = RunningPane(self.tabbed)
    self.queue = QueuePane(self.tabbed, self.running)
    self.submissions = SubmissionPane(self.tabbed, self.queue)
    self.tabbed.AddPage(self.submissions, "Submit Job")
    self.tabbed.AddPage(self.queue, "Queue")
    self.tabbed.AddPage(self.running, "Running Jobs")
    self.CreateStatusBar()
    menuBar = wx.MenuBar()
    menu = wx.Menu()
    self.SetMenuBar(menuBar)
    self.Centre()
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent, run_control) :
INDENT
    wx.Panel.__init__(self, parent, - 1)
    self.parent = parent
    self.run_control = run_control
    self.queue = []
    self.buttonClose2 = wx.Button(self, - 1, "Quit", pos = (195, 170))
    self.buttonClose2.Bind(wx.EVT_BUTTON, self.OnClose)
    self.log_text = wx.TextCtrl(self, - 1, pos = (35, 210), size = (720, 400),
        style = wx.TE_MULTILINE | wx.TE_READONLY | wx.HSCROLL)
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21808107_21808175_1_29
21808107_21808451_14_27
Title: should return outside finally and is the exception handled perfectly? 
----------------------------------------

def sendMessage(self, subject, msgContent, files, mailto) :
INDENT
    msg = self.prepareMail(subject, msgContent, files, mailto)

    server = smtplib.SMTP(self.smtpserver, port = self.EMAIL_PORT)
    server.ehlo()
    server.starttls()
    server.ehlo()
    server.login(self.usrname, self.password)
    server.set_debuglevel(self.debug)
    try :
    INDENT
        server.sendmail(self.mailFrom, mailto, msg.as_string())
    DEDENT
    except Exception as er :
    INDENT
        print er
        return False
    DEDENT
    finally :
    INDENT
        server.quit()
    DEDENT
    return True
DEDENT
----------------------------------------

def sendMessage(self, subject, msgContent, files, mailto) :
INDENT
    server = Connect()
    if not server :
    INDENT
        return False
    DEDENT
    failed = True
    try :
    INDENT
        server.login(self.username, self.password)
        if not server.sendmail(self.mailFrom, mailto, msg.as_string()) :
        INDENT
            failed = False
        DEDENT
    DEDENT
    except Exception, error :
    INDENT
        print error
    DEDENT
    Disconnect(server)
    return failed
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21812668_21812772_1_20
21812668_35305593_1_23
Title: using get total function in python 
----------------------------------------

def get_total(filename) :
INDENT
    total_sum = 0
    print ("\nGetting total numbers contained in file")
    try :
    INDENT

        num = int(input("Input number:\t"))
        outfile.write(str(num) + "\n")
        total_sum += num
        again = input("Enter y to continue:\t")
    DEDENT
    except IOError :
    INDENT
        print ("An error occured trying to read")
        print ("the file", filename)
    DEDENT
    except :
    INDENT
        print ("An undefined error occurred")
    DEDENT
    print ("The total {}".format(total_sum))
DEDENT
----------------------------------------

def get_total(filename) :
INDENT
    total_sum = 0
    print ("Calculating total of the numbers contained in file")
    f = open(filename)
    try :
    INDENT
        for line in f :
        INDENT

            numbers_str = line.split()
            numbers_int = [int(x) for x in numbers_str]
            total_sum = sum(numbers_int)
        DEDENT
    DEDENT
    except IOError :
    INDENT
        print ("An error occured trying to read")
        print ("the file", filename)
    DEDENT
    except :
    INDENT
        print ("An undefined error occurred")
    DEDENT
    print ("The total {}".format(total_sum))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21827874_21861599_5_26
21827874_48980413_5_26
Title: Timeout a python function in windows 
----------------------------------------

def deco(func) :
INDENT
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        res = [Exception('function [%s] timeout [%s seconds] exceeded!' % (func.__name__, timeout))]
        def newFunc() :
        INDENT
            try :
            INDENT
                res [0] = func(* args, ** kwargs)
            DEDENT
            except Exception, e :
            INDENT
                res [0] = e
            DEDENT
        DEDENT
        t = Thread(target = newFunc)
        t.daemon = True
        try :
        INDENT
            t.start()
            t.join(timeout)
        DEDENT
        except Exception, je :
        INDENT
            print 'error starting thread'
            raise je
        DEDENT
        ret = res [0]
        if isinstance(ret, BaseException) :
        INDENT
            raise ret
        DEDENT
        return ret
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def deco(func) :
INDENT
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        res = [Exception('function [%s] timeout [%s seconds] exceeded!' % (func.__name__, seconds_before_timeout))]
        def newFunc() :
        INDENT
            try :
            INDENT
                res [0] = func(* args, ** kwargs)
            DEDENT
            except Exception as e :
            INDENT
                res [0] = e
            DEDENT
        DEDENT
        t = Thread(target = newFunc)
        t.daemon = True
        try :
        INDENT
            t.start()
            t.join(seconds_before_timeout)
        DEDENT
        except Exception as e :
        INDENT
            print ('error starting thread')
            raise e
        DEDENT
        ret = res [0]
        if isinstance(ret, BaseException) :
        INDENT
            raise ret
        DEDENT
        return ret
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21827874_21861599_7_25
21827874_48980413_7_25
Title: Timeout a python function in windows 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    res = [Exception('function [%s] timeout [%s seconds] exceeded!' % (func.__name__, timeout))]
    def newFunc() :
    INDENT
        try :
        INDENT
            res [0] = func(* args, ** kwargs)
        DEDENT
        except Exception, e :
        INDENT
            res [0] = e
        DEDENT
    DEDENT
    t = Thread(target = newFunc)
    t.daemon = True
    try :
    INDENT
        t.start()
        t.join(timeout)
    DEDENT
    except Exception, je :
    INDENT
        print 'error starting thread'
        raise je
    DEDENT
    ret = res [0]
    if isinstance(ret, BaseException) :
    INDENT
        raise ret
    DEDENT
    return ret
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    res = [Exception('function [%s] timeout [%s seconds] exceeded!' % (func.__name__, seconds_before_timeout))]
    def newFunc() :
    INDENT
        try :
        INDENT
            res [0] = func(* args, ** kwargs)
        DEDENT
        except Exception as e :
        INDENT
            res [0] = e
        DEDENT
    DEDENT
    t = Thread(target = newFunc)
    t.daemon = True
    try :
    INDENT
        t.start()
        t.join(seconds_before_timeout)
    DEDENT
    except Exception as e :
    INDENT
        print ('error starting thread')
        raise e
    DEDENT
    ret = res [0]
    if isinstance(ret, BaseException) :
    INDENT
        raise ret
    DEDENT
    return ret
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21827874_21861599_9_13
21827874_48980413_9_13
Title: Timeout a python function in windows 
----------------------------------------

def newFunc() :
INDENT
    try :
    INDENT
        res [0] = func(* args, ** kwargs)
    DEDENT
    except Exception, e :
    INDENT
        res [0] = e
    DEDENT
DEDENT
----------------------------------------

def newFunc() :
INDENT
    try :
    INDENT
        res [0] = func(* args, ** kwargs)
    DEDENT
    except Exception as e :
    INDENT
        res [0] = e
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21839676_21866779_10_31
21839676_33944924_11_24
Title: How to write a DownloadHandler for scrapy that makes requests through socksipy? 
----------------------------------------

def _get_agent(self, request, timeout) :
INDENT
    bindaddress = request.meta.get('bindaddress') or self._bindAddress
    proxy = request.meta.get('proxy')
    if proxy :
    INDENT
        _, _, proxyHost, proxyPort, proxyParams = _parse(proxy)
        scheme = _parse(request.url) [0]
        omitConnectTunnel = proxyParams.find('noconnect') > = 0
        if scheme == 'https' and not omitConnectTunnel :
        INDENT
            proxyConf = (proxyHost, proxyPort,
                request.headers.get('Proxy-Authorization', None))
            return self._TunnelingAgent(reactor, proxyConf,
                contextFactory = self._contextFactory, connectTimeout = timeout,
                bindAddress = bindaddress, pool = self._pool)
        DEDENT
        else :
        INDENT
            _, _, host, port, proxyParams = _parse(request.url)
            proxyEndpoint = TCP4ClientEndpoint(reactor, proxyHost, proxyPort,
                timeout = timeout, bindAddress = bindaddress)
            agent = SOCKS5Agent(reactor, proxyEndpoint = proxyEndpoint)
            return agent
        DEDENT
    DEDENT
    return self._Agent(reactor, contextFactory = self._contextFactory,
        connectTimeout = timeout, bindAddress = bindaddress, pool = self._pool)
DEDENT
----------------------------------------

def _get_agent(self, request, timeout) :
INDENT
    proxy = request.meta.get('proxy')
    if proxy :
    INDENT
        proxy_scheme, _, proxy_host, proxy_port, _ = _parse(proxy)
        if proxy_scheme == 'socks5' :
        INDENT
            endpoint = TCP4ClientEndpoint(reactor, proxy_host, proxy_port)
            return self._Agent(reactor, proxyEndpoint = endpoint)
        DEDENT
    DEDENT
    return super(TorScrapyAgent, self)._get_agent(request, timeout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21841123_21841153_3_16
21841123_21841228_1_10
Title: Shuffle list in certain order recursively 
----------------------------------------

def shuffle(list1, list2) :
INDENT
    if len(list1) == len(list2) : return list(chain(* zip(list1, list2)))
    else :
    INDENT
        a = []
        while any([list1, list2]) :
        INDENT
            for lst in (list1, list2) :
            INDENT
                try : a.append(lst.pop(0))
                except IndexError : pass
            DEDENT
        DEDENT
        return a

    DEDENT
DEDENT
----------------------------------------

def shuffle(list1, list2) :
INDENT
    a = []
    if len(list1) == 0 :
    INDENT
        return list2
    DEDENT
    if len(list2) == 0 :
    INDENT
        return list1
    DEDENT
    else :
    INDENT
        a.append(list1.pop(0))
        a.append(list2.pop(0))
    DEDENT
    return a + shuffle(list1, list2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21841123_21841153_3_16
21841123_21842097_1_18
Title: Shuffle list in certain order recursively 
----------------------------------------

def shuffle(list1, list2) :
INDENT
    if len(list1) == len(list2) : return list(chain(* zip(list1, list2)))
    else :
    INDENT
        a = []
        while any([list1, list2]) :
        INDENT
            for lst in (list1, list2) :
            INDENT
                try : a.append(lst.pop(0))
                except IndexError : pass
            DEDENT
        DEDENT
        return a

    DEDENT
DEDENT
----------------------------------------

def shuffle(a, b) :
INDENT
    A = iter(a)
    B = iter(b)
    while True :
    INDENT
        try :
        INDENT
            yield A.next()
        DEDENT
        except StopIteration :
        INDENT
            for j in B :
            INDENT
                yield j
            DEDENT
            break
        DEDENT
        try :
        INDENT
            yield B.next()
        DEDENT
        except StopIteration :
        INDENT
            for j in A :
            INDENT
                yield j
            DEDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21841123_21841228_1_10
21841123_21842097_1_18
Title: Shuffle list in certain order recursively 
----------------------------------------

def shuffle(list1, list2) :
INDENT
    a = []
    if len(list1) == 0 :
    INDENT
        return list2
    DEDENT
    if len(list2) == 0 :
    INDENT
        return list1
    DEDENT
    else :
    INDENT
        a.append(list1.pop(0))
        a.append(list2.pop(0))
    DEDENT
    return a + shuffle(list1, list2)
DEDENT
----------------------------------------

def shuffle(a, b) :
INDENT
    A = iter(a)
    B = iter(b)
    while True :
    INDENT
        try :
        INDENT
            yield A.next()
        DEDENT
        except StopIteration :
        INDENT
            for j in B :
            INDENT
                yield j
            DEDENT
            break
        DEDENT
        try :
        INDENT
            yield B.next()
        DEDENT
        except StopIteration :
        INDENT
            for j in A :
            INDENT
                yield j
            DEDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21842885_21842990_1_14
21842885_44813051_1_19
Title: Python: Find a substring in a string and returning the index of the substring 
----------------------------------------

def find_str(s, char) :
INDENT
    index = 0
    if char in s :
    INDENT
        c = char [0]
        for ch in s :
        INDENT
            if ch == c :
            INDENT
                if s [index : index + len(char)] == char :
                INDENT
                    return index
                DEDENT
            DEDENT
            index += 1
        DEDENT
    DEDENT
    return - 1
DEDENT
----------------------------------------

def find_str(full, sub) :
INDENT
    index = 0
    sub_index = 0
    position = - 1
    for ch_i, ch_f in enumerate(full) :
    INDENT
        if ch_f.lower() ! = sub [sub_index].lower() :
        INDENT
            position = - 1
            sub_index = 0
        DEDENT
        if ch_f.lower() == sub [sub_index].lower() :
        INDENT
            if sub_index == 0 :
            INDENT
                position = ch_i
            DEDENT
            if (len(sub) - 1) < = sub_index :
            INDENT
                break
            DEDENT
            else :
            INDENT
                sub_index += 1
            DEDENT
        DEDENT
    DEDENT
    return position
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21844024_31539746_1_12
21844024_32034085_1_31
Title: Weighted percentile using numpy 
----------------------------------------

def weighted_percentile(data, percents, weights = None) :
INDENT
    if weights is None :
    INDENT
        return np.percentile(data, percents)
    DEDENT
    ind = np.argsort(data)
    d = data [ind]
    w = weights [ind]
    p = 1.* w.cumsum() / w.sum() * 100
    y = np.interp(percents, p, d)
    return y
DEDENT
----------------------------------------

def weighted_percentile(a, percentile = np.array([75, 25]), weights = None) :
INDENT
    percentile = np.array(percentile) / 100.0
    if weights is None :
    INDENT
        weights = np.ones(len(a))
    DEDENT
    a_indsort = np.argsort(a)
    a_sort = a [a_indsort]
    weights_sort = weights [a_indsort]
    ecdf = np.cumsum(weights_sort)
    percentile_index_positions = percentile * (weights.sum() - 1) + 1
    locations = np.searchsorted(ecdf, percentile_index_positions)
    out_percentiles = np.zeros(len(percentile_index_positions))
    for i, empiricalLocation in enumerate(locations) :
    INDENT
        if ecdf [empiricalLocation - 1] == np.floor(percentile_index_positions [i]) :
        INDENT

            uppWeight = percentile_index_positions [i] - ecdf [empiricalLocation - 1]
            lowWeight = 1 - uppWeight
            out_percentiles [i] = a_sort [empiricalLocation - 1] * lowWeight + a_sort [empiricalLocation] * uppWeight
        DEDENT
        else :
        INDENT

            out_percentiles [i] = a_sort [empiricalLocation]
        DEDENT
    DEDENT
    return out_percentiles
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21844024_31539746_1_12
21844024_32216049_1_50
Title: Weighted percentile using numpy 
----------------------------------------

def weighted_percentile(data, percents, weights = None) :
INDENT
    if weights is None :
    INDENT
        return np.percentile(data, percents)
    DEDENT
    ind = np.argsort(data)
    d = data [ind]
    w = weights [ind]
    p = 1.* w.cumsum() / w.sum() * 100
    y = np.interp(percents, p, d)
    return y
DEDENT
----------------------------------------

def weighted_percentile(a, q = np.array([75, 25]), w = None) :
INDENT
    q = np.array(q) / 100.0
    if w is None :
    INDENT
        w = np.ones(a.size)
    DEDENT
    idx = np.argsort(a)
    a_sort = a [idx]
    w_sort = w [idx]

    ecdf = np.cumsum(w_sort)

    p = q * (w.sum() - 1)

    idx_low = np.searchsorted(ecdf, p, side = 'right')
    idx_high = np.searchsorted(ecdf, p + 1, side = 'right')
    idx_high [idx_high > ecdf.size - 1] = ecdf.size - 1

    weights_high = p - np.floor(p)
    weights_low = 1.0 - weights_high

    x1 = np.take(a_sort, idx_low) * weights_low
    x2 = np.take(a_sort, idx_high) * weights_high

    return np.add(x1, x2)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21844024_32034085_1_31
21844024_32216049_1_50
Title: Weighted percentile using numpy 
----------------------------------------

def weighted_percentile(a, percentile = np.array([75, 25]), weights = None) :
INDENT
    percentile = np.array(percentile) / 100.0
    if weights is None :
    INDENT
        weights = np.ones(len(a))
    DEDENT
    a_indsort = np.argsort(a)
    a_sort = a [a_indsort]
    weights_sort = weights [a_indsort]
    ecdf = np.cumsum(weights_sort)
    percentile_index_positions = percentile * (weights.sum() - 1) + 1
    locations = np.searchsorted(ecdf, percentile_index_positions)
    out_percentiles = np.zeros(len(percentile_index_positions))
    for i, empiricalLocation in enumerate(locations) :
    INDENT
        if ecdf [empiricalLocation - 1] == np.floor(percentile_index_positions [i]) :
        INDENT

            uppWeight = percentile_index_positions [i] - ecdf [empiricalLocation - 1]
            lowWeight = 1 - uppWeight
            out_percentiles [i] = a_sort [empiricalLocation - 1] * lowWeight + a_sort [empiricalLocation] * uppWeight
        DEDENT
        else :
        INDENT

            out_percentiles [i] = a_sort [empiricalLocation]
        DEDENT
    DEDENT
    return out_percentiles
DEDENT
----------------------------------------

def weighted_percentile(a, q = np.array([75, 25]), w = None) :
INDENT
    q = np.array(q) / 100.0
    if w is None :
    INDENT
        w = np.ones(a.size)
    DEDENT
    idx = np.argsort(a)
    a_sort = a [idx]
    w_sort = w [idx]

    ecdf = np.cumsum(w_sort)

    p = q * (w.sum() - 1)

    idx_low = np.searchsorted(ecdf, p, side = 'right')
    idx_high = np.searchsorted(ecdf, p + 1, side = 'right')
    idx_high [idx_high > ecdf.size - 1] = ecdf.size - 1

    weights_high = p - np.floor(p)
    weights_low = 1.0 - weights_high

    x1 = np.take(a_sort, idx_low) * weights_low
    x2 = np.take(a_sort, idx_high) * weights_high

    return np.add(x1, x2)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21868319_21868391_1_11
21868319_21868507_3_16
Title: Functions Assist 
----------------------------------------

def replace_str(string, substring, replace) :
INDENT
    my_str = ""
    index = 0
    while index < len(string) :
    INDENT
        if string [index : index + len(substring)] == substring :
        INDENT
            my_str += replace
        DEDENT
        else :
        INDENT
            my_str += string [index]
        DEDENT
    DEDENT
    return my_str
DEDENT
----------------------------------------

def replace_str(string, substring, replace) :
INDENT
    new_string = ''
    substr_idx = 0
    for character in string :
    INDENT
        if character == substring [substr_idx] :
        INDENT
            substr_idx += 1
        DEDENT
        else :
        INDENT
            new_string += character
        DEDENT
        if substr_idx == len(substring) :
        INDENT
            new_string += replace
            substr_idx = 0
        DEDENT
    DEDENT
    return new_string
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21883544_21886670_1_15
21883544_24953012_5_18
Title: Python Program No Output 
----------------------------------------

def Bsearch(lsta, low, high, search) :
INDENT
    retval = 0
    if low > high :
    INDENT
        retval = 0
    DEDENT
    else :
    INDENT
        mid = int((low + high) / 2)
        if search == lsta [mid] :
        INDENT

            retval = 1
        DEDENT
        elif search < lsta [mid] :
        INDENT
            retval = Bsearch(lsta, low, mid - 1, search)
        DEDENT
        else :
        INDENT
            retval = Bsearch(lsta, mid + 1, high, search)
        DEDENT
    DEDENT
    return retval
DEDENT
----------------------------------------

def Bsearch(lsta, low, high, search) :
INDENT
    if low > high :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        mid = int((low + high) / 2)
        if search < lsta [mid] :
        INDENT
            Bsearch(lsta, low, mid - 1, search)
        DEDENT
        if search > lsta [mid] :
        INDENT
            Bsearch(lsta, mid + 1, high, search)
        DEDENT
        if search == lsta [mid] :
        INDENT
            return 1
        DEDENT
    DEDENT
    return 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21883544_21886670_1_15
21883544_33853553_5_18
Title: Python Program No Output 
----------------------------------------

def Bsearch(lsta, low, high, search) :
INDENT
    retval = 0
    if low > high :
    INDENT
        retval = 0
    DEDENT
    else :
    INDENT
        mid = int((low + high) / 2)
        if search == lsta [mid] :
        INDENT

            retval = 1
        DEDENT
        elif search < lsta [mid] :
        INDENT
            retval = Bsearch(lsta, low, mid - 1, search)
        DEDENT
        else :
        INDENT
            retval = Bsearch(lsta, mid + 1, high, search)
        DEDENT
    DEDENT
    return retval
DEDENT
----------------------------------------

def Bsearch(lsta, low, high, search) :
INDENT
    if low > high :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        mid = int((low + high) / 2)
        if search < lsta [mid] :
        INDENT
            Bsearch(lsta, low, mid - 1, search)
        DEDENT
        if search > lsta [mid] :
        INDENT
            Bsearch(lsta, mid + 1, high, search)
        DEDENT
        if search == lsta [mid] :
        INDENT
            return 1
        DEDENT
    DEDENT
    return 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21891411_21892912_57_83
21891411_21892912_8_48
Title: Global variable between frames in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent, style = wx.DEFAULT_FRAME_STYLE & ~ (wx.RESIZE_BORDER | wx.MAXIMIZE_BOX | wx.CLOSE_BOX | wx.MINIMIZE_BOX), title = "System Login")
    self.panel = wx.Panel(self)
    self.userlabel = wx.StaticText(self.panel, label = "Username:")
    self.passlabel = wx.StaticText(self.panel, label = "Password:")
    self.userbox = wx.TextCtrl(self.panel, size = (140, - 1))
    self.passbox = wx.TextCtrl(self.panel, size = (140, - 1), style = wx.TE_PASSWORD)
    self.login = wx.Button(self.panel, label = "Login")
    self.exit = wx.Button(self.panel, label = "Exit")
    self.Centre()
    self.windowSizer = wx.BoxSizer()
    self.windowSizer.Add(self.panel, 1, wx.ALL | wx.EXPAND)
    self.sizer = wx.GridBagSizer(5, 5)
    self.sizer.Add(self.userlabel, (0, 0))
    self.sizer.Add(self.userbox, (0, 1))
    self.sizer.Add(self.passlabel, (1, 0))
    self.sizer.Add(self.passbox, (1, 1))
    self.sizer.Add(self.login, (2, 0))
    self.sizer.Add(self.exit, (2, 1))
    self.border = wx.BoxSizer()
    self.border.Add(self.sizer, 1, wx.ALL | wx.EXPAND, 5)
    self.panel.SetSizerAndFit(self.border)
    self.SetSizerAndFit(self.windowSizer)
    self.login.Bind(wx.EVT_BUTTON, self.OnLogin)
    self.exit.Bind(wx.EVT_BUTTON, self.onClose)
    self.Bind(wx.EVT_CLOSE, self.onClose)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, title = 'Application Title', style = wx.SYSTEM_MENU)
    pub.subscribe(self.myListener, "update_frame")
    panel = wx.Panel(self)
    menubar = wx.MenuBar()
    panel.SetBackgroundColour((200, 200, 200))
    vbox = wx.BoxSizer(wx.HORIZONTAL)
    midPan = wx.Panel(panel)
    midPan.SetBackgroundColour((100, 0, 0))
    pan2 = wx.Panel(panel)
    pan2.SetBackgroundColour((0, 100, 0))
    vbox.Add(pan2, 1, wx.EXPAND | wx.ALL)
    vbox.Add(midPan, 5, wx.EXPAND | wx.ALL)
    hbox = wx.BoxSizer(wx.VERTICAL)
    hbox1 = wx.BoxSizer(wx.VERTICAL)
    h1 = wx.Panel(midPan)
    h1.SetBackgroundColour((200, 0, 100))
    h2 = wx.Panel(midPan)
    h2.SetBackgroundColour((0, 100, 200))
    self.text1 = wx.StaticText(h1, label = "Welcome ")
    text2 = wx.StaticText(h1, label = "Label2")
    hbox.Add(h1, 3, wx.EXPAND | wx.ALL, 20)
    hbox.Add(h2, 1, wx.EXPAND | wx.ALL, 20)
    hbox1.Add(self.text1, 1, wx.ALIGN_LEFT)
    hbox1.Add(text2, 1, wx.ALIGN_RIGHT)
    panel.SetSizer(vbox)
    midPan.SetSizer(hbox)
    h1.SetSizer(hbox1)
    self.statusbar = self.CreateStatusBar()
    self.SetMenuBar(menubar)
    self.Centre()
    self.Maximize()
    self.Show(True)
    frame = LoginFrame(self)
    frame.Show(True)
    frame.MakeModal(True)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21911009_21911204_1_9
21911009_21911365_1_7
Title: Python counting string 
----------------------------------------

def letterCount(text, collection) :
INDENT
    count = 0
    for i in range(0, len(text) - len(collection)) :
    INDENT
        if collection == text [i : i + len(collection)] :
        INDENT
            count += 1
        DEDENT
    DEDENT
    return count
DEDENT
----------------------------------------

def letterCount(text, collection) :
INDENT
    lettercount = 0
    for letter in collection :
    INDENT
        lettercount += text.count(letter)
    DEDENT
    return lettercount

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2192529_2193508_10_25
2192529_31566082_17_29
Title: Python: Creating a streaming gzip'd file-like? 
----------------------------------------

def read(self, size = - 1) :
INDENT
    if (size < 0) or len(self.buffer) < size :
    INDENT
        for s in self.input :
        INDENT
            self.zipper.write(s)
            if size > 0 and len(self.buffer) > = size :
            INDENT
                self.zipper.flush()
                break
            DEDENT
        DEDENT
        else :
        INDENT
            self.zipper.close()
        DEDENT
        if size < 0 :
        INDENT
            ret = self.buffer
            self.buffer = ''
        DEDENT
    DEDENT
    else :
    INDENT
        ret, self.buffer = self.buffer [: size], self.buffer [size :]
    DEDENT
    return ret
DEDENT
----------------------------------------

def read(self, size = - 1) :
INDENT
    if size < 0 : size = self.__size
    ret_list = []
    while size > 0 and len(self.__buf) :
    INDENT
        s = self.__buf.popleft()
        size -= len(s)
        ret_list.append(s)
    DEDENT
    if size < 0 :
    INDENT
        ret_list [- 1], remainder = ret_list [- 1] [: size], ret_list [- 1] [size :]
        self.__buf.appendleft(remainder)
    DEDENT
    ret = ''.join(ret_list)
    self.__size -= len(ret)
    return ret
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2192529_2193508_10_25
2192529_31566082_41_48
Title: Python: Creating a streaming gzip'd file-like? 
----------------------------------------

def read(self, size = - 1) :
INDENT
    if (size < 0) or len(self.buffer) < size :
    INDENT
        for s in self.input :
        INDENT
            self.zipper.write(s)
            if size > 0 and len(self.buffer) > = size :
            INDENT
                self.zipper.flush()
                break
            DEDENT
        DEDENT
        else :
        INDENT
            self.zipper.close()
        DEDENT
        if size < 0 :
        INDENT
            ret = self.buffer
            self.buffer = ''
        DEDENT
    DEDENT
    else :
    INDENT
        ret, self.buffer = self.buffer [: size], self.buffer [size :]
    DEDENT
    return ret
DEDENT
----------------------------------------

def read(self, size = - 1) :
INDENT
    while size < 0 or len(self.__buf) < size :
    INDENT
        s = self.__input.read(CHUNK)
        if not s :
        INDENT
            self.__gzip.close()
            break
        DEDENT
        self.__gzip.write(s)
    DEDENT
    return self.__buf.read(size)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2192529_31566082_17_29
2192529_31566082_41_48
Title: Python: Creating a streaming gzip'd file-like? 
----------------------------------------

def read(self, size = - 1) :
INDENT
    if size < 0 : size = self.__size
    ret_list = []
    while size > 0 and len(self.__buf) :
    INDENT
        s = self.__buf.popleft()
        size -= len(s)
        ret_list.append(s)
    DEDENT
    if size < 0 :
    INDENT
        ret_list [- 1], remainder = ret_list [- 1] [: size], ret_list [- 1] [size :]
        self.__buf.appendleft(remainder)
    DEDENT
    ret = ''.join(ret_list)
    self.__size -= len(ret)
    return ret
DEDENT
----------------------------------------

def read(self, size = - 1) :
INDENT
    while size < 0 or len(self.__buf) < size :
    INDENT
        s = self.__input.read(CHUNK)
        if not s :
        INDENT
            self.__gzip.close()
            break
        DEDENT
        self.__gzip.write(s)
    DEDENT
    return self.__buf.read(size)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21928368_43473532_24_73
21928368_43983934_15_30
Title: Login to Facebook using python requests 
----------------------------------------

def login(session, username, password) :
INDENT
    '''
    Login to Facebook
    '''

    response = session.get('https://facebook.com')

    dom = pq(response.text)

    lsd = dom('[name="lsd"]').val()

    response = session.post('https://www.facebook.com/login.php?login_attempt=1', data = {
            'lsd' : lsd,
            'email' : username,
            'pass' : password,
            'default_persistent' : '0',
            'timezone' : '-60',
            'lgndim' : '',
            'lgnrnd' : '',
            'lgnjs' : '',
            'locale' : 'en_GB',
            'qsstamp' : ''})
    '''
    Get the users ID and fb_dtsg token. The fb_dtsg token is required when making requests as a logged in user. It
    never changes, so we only need to grab this token once.

    If the login was successful a cookie 'c_user' is set by Facebook. If the login failed, the 'c_user' cookie
    will not be present. This will raise an exception.
    '''
    try :
    INDENT
        uid = session.cookies ['c_user']
        dtsg = re.search(r'(type="hidden" name="fb_dtsg" value="([0-9a-zA-Z-_:]+)")', response.text).group(1)
        dtsg = dtsg [dtsg.find("value") + 6 :]
        dtsg = dtsg [1 : - 1]
    DEDENT
    except KeyError :
    INDENT
        raise Exception('Login Failed!')
    DEDENT
    return uid, dtsg

DEDENT
----------------------------------------

def login(session, email, password) :
INDENT
    response = session.post('https://m.facebook.com/login.php', data = {
            'email' : email,
            'pass' : password}, allow_redirects = False)
    assert response.status_code == 302
    assert 'c_user' in response.cookies
    return response.cookies
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21943973_21944051_3_10
21943973_21944118_4_14
Title: If an exception is raised ask again for input 
----------------------------------------

def add_input(first_input, second_input) :
INDENT
    if first_input + second_input > = 10 :
    INDENT
        print ('legal')
        return None
    DEDENT
    else :
    INDENT
        return illegal
    DEDENT
DEDENT
----------------------------------------

def add_input(repeat = False) :
INDENT
    if repeat :
    INDENT
        print "Wrong input, try again"
    DEDENT
    first_input = input("First number: ")
    second_input = input("Second number: ")
    try :
    INDENT
        if first_input + second_input > = 10 :
        INDENT
            raise IllegalException
        DEDENT
    DEDENT
    except IllegalException :
    INDENT
        add_input(True)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21949796_21950924_46_61
21949796_21950924_9_19
Title: wxPython: How to remove slider and in return populate custom gauge with function CpuData 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title)
    self.cpu = CPU(self, - 1)
    self.timer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.do_CpuData)
    hbox = wx.BoxSizer(wx.HORIZONTAL)
    hbox.Add(self.cpu, 1, wx.EXPAND | wx.ALIGN_CENTER_VERTICAL, 5)
    self.SetSizer(hbox)
    hbox.Fit(self)
    self.Centre()
    self.Show(True)
    self.timer.Start(1000)
DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Panel.__init__(self, parent, id, size = (80, 110))
    self.value = 100
    self.parent = parent
    self.SetBackgroundColour('#ffffff')
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(EVT_CPU_EVENT, self.do_value)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21975403_21975572_1_21
21975403_35569685_1_10
Title: Python: How do I assign 2 values I return from a function with 1 input as values outside the function? 
----------------------------------------

def get_value() :
INDENT
    while True :
    INDENT
        z = input("Insert value: ")

        is_int = isinstance(z, int)
        is_pos = is_int and z > 0
        if is_int and is_pos :
        INDENT
            print z ** 2
        DEDENT
        elif is_int :
        INDENT
            print "Please provide an integer"
            continue
        DEDENT
        else :
        INDENT
            print "Integer must be positive"
            continue
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_value() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            z = int(raw_input("insert value: "))
            if z > 0 :
            INDENT
                return z
            DEDENT
            else :
            INDENT
                print "Please enter a positive integer"
            DEDENT
        DEDENT
        except ValueError :
        INDENT
            print "Please enter an integer"
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2198903_2203002_61_104
2198903_3405979_49_63
Title: wx.TextCtrl and wx.Validator 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Dialog.__init__(self, parent, - 1, "Validated Dialog")
    self.SetAutoLayout(True)
    VSPACE = 10
    fgs = wx.FlexGridSizer(0, 2)
    fgs.Add((1, 1));
    fgs.Add(wx.StaticText(self, - 1,
            "These controls must have text entered into them.  Each\n"
            "one has a validator that is checked when the Okay\n"
            "button is clicked."))
    fgs.Add((1, VSPACE)); fgs.Add((1, VSPACE))
    label = wx.StaticText(self, - 1, "First: ")
    fgs.Add(label, 0, wx.ALIGN_RIGHT | wx.CENTER)
    fgs.Add(wx.TextCtrl(self, - 1, "", validator = TextObjectValidator()))
    fgs.Add((1, VSPACE)); fgs.Add((1, VSPACE))
    label = wx.StaticText(self, - 1, "Second: ")
    fgs.Add(label, 0, wx.ALIGN_RIGHT | wx.CENTER)
    fgs.Add(wx.TextCtrl(self, - 1, "", validator = TextObjectValidator()))

    buttons = wx.StdDialogButtonSizer()
    b = wx.Button(self, wx.ID_OK, "OK")
    b.SetDefault()
    buttons.AddButton(b)
    buttons.AddButton(wx.Button(self, wx.ID_CANCEL, "Cancel"))
    buttons.Realize()
    border = wx.BoxSizer(wx.VERTICAL)
    border.Add(fgs, 1, wx.GROW | wx.ALL, 25)
    border.Add(buttons)
    self.SetSizer(border)
    border.Fit(self)
    self.Layout()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Text Validation Tutorial")
    panel = wx.Panel(self)
    textOne = wx.TextCtrl(panel, validator = CharValidator('no-alpha'))
    textTwo = wx.TextCtrl(panel, validator = CharValidator('no-digit'))
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(textOne, 0, wx.ALL, 5)
    sizer.Add(textTwo, 0, wx.ALL, 5)
    panel.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21994672_21997982_3_8
21994672_21998916_4_21
Title: PyQT4 QMenuBar Visibilty toggled by MouseOver 
----------------------------------------

def __init__(self, parent = None, centralWidget = None) :
INDENT
    super(Hidden_Menubar, self).__init__(parent)
    if centralWidget :
    INDENT
        centralWidget.setMouseTracking(True)
        centralWidget.mouseMoveEvent = self.onMove
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMainWindow.__init__(self)
    widget = QtGui.QWidget(self)
    edit = QtGui.QTextEdit(widget)
    button = QtGui.QPushButton('Button', widget)
    layout = QtGui.QVBoxLayout(widget)
    layout.addWidget(edit)
    layout.addWidget(button)
    self.setCentralWidget(widget)
    menu = self.menuBar().addMenu('&File')
    menu.addAction('&Quit', self.close)
    menu = self.menuBar().addMenu('&Edit')
    menu.addAction('&Clear', edit.clear)
    QtGui.qApp.installEventFilter(self)
    QtCore.QTimer.singleShot(0, self.menuBar().hide)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22028573_22029419_14_22
22028573_22029419_45_52
Title: Python Neural Networking: Run 10 iterations but I get the same output 
----------------------------------------

def __init__(self, name = None) :
INDENT
    self.name = name
    self.activation_threshold = 1.0
    self.net_input = 0.0
    self.outgoing_connections = []
    self.incoming_connections = []
    self.connections = []
    self.activation = None
DEDENT
----------------------------------------

def __init__(self, sender, reciever, weight) :
INDENT
    self.weight = weight
    self.sender = sender
    self.reciever = reciever
    sender.outgoing_connections.append(self)
    reciever.incoming_connections.append(self)
    print 'Created', str(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22029165_22029234_3_11
22029165_22030335_4_34
Title: how to generate a list based on index value 
----------------------------------------

def askTheUser() :
INDENT
    number = input("Do you want to roll again? Pick a number or numbers thru 0 and 4:")
    myList = []
    aList = [1, 0]
    for i in range(5) :
    INDENT
        myList.append(random.choice(aList))
    DEDENT
    myList [int(number)] = 1
    return myList
DEDENT
----------------------------------------

def askTheUser() :
INDENT
    MAX = 5

    msg = "Do you want to roll again? " + "Pick a number or numbers thru 0 and {}: ".format(MAX)

    number = raw_input(msg)

    myList = [random.randint(0, 1) for i in range(MAX)]
    try :
    INDENT

        i = int(number, 10)

        if i < 0 :
        INDENT
            raise IndexError
        DEDENT
        myList [i] = 1

    DEDENT
    except (IndexError, ValueError) :
    INDENT
        print ("That was wrong value:", number)
        pass
    DEDENT
    finally :
    INDENT
        return myList
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22058470_22058500_12_22
22058470_22058536_7_18
Title: Returning integers through if-statments 
----------------------------------------

def max3(x, y, z) :
INDENT
    largest = z
    if (x > y and x > z) :
    INDENT
        largest = x
    DEDENT
    elif (y > z) :
    INDENT
        largest = y
    DEDENT
    return largest

DEDENT
----------------------------------------

def max3(x, y, z = None) :
INDENT
    if (z == None) :
    INDENT
        if (x > y) :
        INDENT
            return x
        DEDENT
        else :
        INDENT
            return y
        DEDENT
    DEDENT
    else :
    INDENT
        maxNum = max3(x, y)
        if (maxNum > z) :
        INDENT
            return maxNum
        DEDENT
        else :
        INDENT
            return z
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22058470_22058500_12_22
22058470_22058609_7_17
Title: Returning integers through if-statments 
----------------------------------------

def max3(x, y, z) :
INDENT
    largest = z
    if (x > y and x > z) :
    INDENT
        largest = x
    DEDENT
    elif (y > z) :
    INDENT
        largest = y
    DEDENT
    return largest

DEDENT
----------------------------------------

def max3(x, y, z) :
INDENT
    number1 = x
    number2 = y
    number3 = z
    if y < = x > = z :
    INDENT
        return (x)
    DEDENT
    if x < = y > = z :
    INDENT
        return (y)
    DEDENT
    if x < = z > = y :
    INDENT
        return (z)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22058470_22058536_7_18
22058470_22058609_7_17
Title: Returning integers through if-statments 
----------------------------------------

def max3(x, y, z = None) :
INDENT
    if (z == None) :
    INDENT
        if (x > y) :
        INDENT
            return x
        DEDENT
        else :
        INDENT
            return y
        DEDENT
    DEDENT
    else :
    INDENT
        maxNum = max3(x, y)
        if (maxNum > z) :
        INDENT
            return maxNum
        DEDENT
        else :
        INDENT
            return z
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def max3(x, y, z) :
INDENT
    number1 = x
    number2 = y
    number3 = z
    if y < = x > = z :
    INDENT
        return (x)
    DEDENT
    if x < = y > = z :
    INDENT
        return (y)
    DEDENT
    if x < = z > = y :
    INDENT
        return (z)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22083416_22083524_8_21
22083416_22083665_6_17
Title: Python Cannot return the final value 
----------------------------------------

def radiationExposure(start, stop, step) :
INDENT
    time = (stop - start)
    newStart = start + step
    if (time ! = 0) :
    INDENT
        radiationExposure(newStart, stop, step)
        global totalExposure
        radiation = f(start) * step
        totalExposure += radiation
        return totalExposure
    DEDENT
    else :
    INDENT
        return totalExposure
    DEDENT
DEDENT
----------------------------------------

def radiationExposure(start, stop, step) :
INDENT
    totalExposure = 0
    time = stop - start
    newStart = start + step
    if time > 0 :
    INDENT
        totalExposure = radiationExposure(newStart, stop, step)
        totalExposure += f(start) * step
    DEDENT
    return totalExposure
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22090001_22093848_1_10
22090001_38541057_1_14
Title: Get folder size using FtpLib 
----------------------------------------

def get_total_size(self, directory) :
INDENT
    size = 0
    for filename in self.ftp.nlst(directory) :
    INDENT
        try :
        INDENT
            self.ftp.cwd(filename)
            size += self.get_total_size(filename)
        DEDENT
        except :
        INDENT
            self.ftp.voidcmd('TYPE I')
            size += self.ftp.size(filename)
        DEDENT
    DEDENT
    return size
DEDENT
----------------------------------------

def get_total_size(ftp_dir) :
INDENT
    size = 0
    parent_dir = ftp.pwd()
    for filename in ftp.nlst(ftp_dir) :
    INDENT

        path = os.path.join(parent_dir, filename)
        try :
        INDENT
            ftp.cwd(path)
            size += get_total_size(path)
            ftp.cwd(parent_dir)
        DEDENT
        except :
        INDENT
            ftp.voidcmd('TYPE I')
            size += ftp.size(path)
        DEDENT
    DEDENT
    return size
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22103227_22103413_1_13
22103227_22103546_4_10
Title: Python File Functions 
----------------------------------------

def userExists(username) :
INDENT
    f = open('score.txt', 'rU')
    uExists = False
    for line in f :
    INDENT
        row = line.split('\r\n')
        info = row [0].strip('\r\n').split(':')
        if user == info [0] :
        INDENT
            uExists = True
            break
        DEDENT
        else :
        INDENT
            uExists = False
        DEDENT
        f.close()
        return uExists
    DEDENT
DEDENT
----------------------------------------

def userExists(username) :
INDENT
    with open('score.txt', 'rU') as f :
    INDENT
        for line in f :
        INDENT
            username = line.rstrip().split(':') [0]
            if user == username :
            INDENT
                return True
            DEDENT
        DEDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22108488_43677631_15_21
22108488_49348412_15_20
Title: "Are list-comprehensions and functional functions faster than ""for loops""?" 
----------------------------------------

def square_sum2(numbers) :
INDENT
    a = 0
    for i in numbers :
    INDENT
        i = i ** 2
        a += i
    DEDENT
    return a
DEDENT
----------------------------------------

def square_sum2(numbers) :
INDENT
    a = 0
    for i in numbers :
    INDENT
        a += i ** 2
    DEDENT
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22108488_43677631_5_10
22108488_49348412_5_10
Title: "Are list-comprehensions and functional functions faster than ""for loops""?" 
----------------------------------------

def time_it(func, numbers, * args) :
INDENT
    start_t = datetime.datetime.now()
    for i in range(numbers) :
    INDENT
        func(args [0])
    DEDENT
    print (datetime.datetime.now() - start_t)
DEDENT
----------------------------------------

def time_it(func, numbers, * args) :
INDENT
    start_t = datetime.datetime.now()
    for i in range(numbers) :
    INDENT
        func(args [0])
    DEDENT
    print (datetime.datetime.now() - start_t)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22114321_22118910_3_10
22114321_22128148_18_28
Title: How to use gzip encoding with wsgi application? 
----------------------------------------

def application(environ, start_response) :
INDENT
    headers = [('Content-Type', 'text/html; charset=utf-8'), ('Content-Encoding', 'gzip')]
    start_response('200 OK', headers)
    buf = io.BytesIO()
    with GzipFile(fileobj = buf, mode = 'wb') as f :
    INDENT
        f.write(b'test')
        f.write(b'test2')
    DEDENT
    return buf
DEDENT
----------------------------------------

def application(environ, start_response) :
INDENT
    headers = [('Content-Type', 'text/html; charset=utf-8'), ('Content-Encoding', 'gzip')]
    start_response('200 OK', headers)
    reader = gzipreader()
    writer = gzip.GzipFile(mode = 'wb', fileobj = reader)
    for s in [b'test', b'test2'] :
    INDENT
        writer.write(s)
        yield reader.read()
    DEDENT
    writer.close()
    yield reader.read()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22124241_22124252_3_8
22124241_22135808_5_17
Title: Implementing a loop for a system of ordinary differential equations 
----------------------------------------

def deriv(y, t) :
INDENT
    a = 2.0
    b = 0.5
    c = 0.1
    for i in range(0, 10) :
    INDENT
        return array([y [i] * a * (1 - y [i] / 10) - b * y [i] * y [i], b * y [i] * y [i] - c * y [i]])
    DEDENT
DEDENT
----------------------------------------

def deriv(y, t) :
INDENT
    a = 2.0
    b = 0.5
    c = 0.1
    doty = zeros_like(y)
    for i in range(0, 5) :
    INDENT
        j = 2 * i
        k = 2 * i + 1
        doty [j] = y [j] * a * (1 - y [j] / 10) - b * y [j] * y [k]
        doty [k] = b * y [j] * y [k] - c * y [k]
    DEDENT
    return doty
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22131236_22131414_1_12
22131236_22138016_15_42
Title: Recursive Python function to produce a list of anagrams 
----------------------------------------

def permutations(A, B = '') :
INDENT
    assert len(A) > = 0
    assert len(A) == len(set(A))
    if len(A) == 0 :
    INDENT
        return [B]
    DEDENT
    else :
    INDENT
        res = []
        for i in range(len(A)) :
        INDENT
            res.extend(permutations(A [0 : i] + A [i + 1 :], B + A [i]))
        DEDENT
        return res
    DEDENT
DEDENT
----------------------------------------

def permutations(lst, length = None, key = None, reverse = False) :
INDENT
    if length is None :
    INDENT
        length = len(lst)
    DEDENT
    elif length < 1 or length > len(lst) :
    INDENT
        return []

    DEDENT
    items = dict_items_list(Counter(lst))
    items.sort(key = key, reverse = reverse)
    if is_string(lst) :
    INDENT
        return (''.join(s) for s in _permutations(items, length))
    DEDENT
    else :
    INDENT
        return _permutations(items, length)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22161840_22161937_2_10
22161840_22161976_1_16
Title: palindromic numbers in python 
----------------------------------------

def palindrome() :
INDENT
    numbers, result = range(1000, 100, - 1), - 1
    for num1, num2 in product(numbers, repeat = 2) :
    INDENT
        prod = num1 * num2
        sprod = str(prod)
        if sprod == sprod [: : - 1] and prod > result :
        INDENT
            result = prod
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def palindrome(floor = 0, upto = 999) :
INDENT
    start = upto
    largest = None
    for i in range(start, floor, - 1) :
    INDENT
        if i * upto < largest :
        INDENT
            break
        DEDENT
        for j in range(start, i - 1, - 1) :
        INDENT
            product = i * j
            if str(product) == str(product) [: : - 1] :
            INDENT
                if product > largest :
                INDENT
                    largest = product
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return largest
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22189227_22189352_1_10
22189227_22252402_6_16
Title: Recursive Function Help (Python) 
----------------------------------------

def radiationExposure(start, stop, step) :
INDENT
    time = stop - start
    new_start = start + step
    radiation = f(start) * step
    if time < = 0 :
    INDENT
        return radiation
    DEDENT
    else :
    INDENT
        return radiation + radiationExposure(newStart, stop, step)
    DEDENT
DEDENT
----------------------------------------

def radiationExposure(start, stop, step) :
INDENT
    totalExposure = 0
    while stop - start > 0 :
    INDENT
        if stop - start < step :
        INDENT
            step = stop - start;
        DEDENT
        totalExposure += f(start) * step
        start += step
    DEDENT
    return totalExposure
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22192858_22249324_129_137
22192858_22249324_38_65
Title: How to keep the controller alive 
----------------------------------------

def __init__(self, name) :
INDENT
    self._log = logging.getLogger("MVC Logger")
    self._log.info("Customer %s logging started" % name)
    self.name = name
    self._cash = 0
    self._account = None
    self._employer = None
DEDENT
----------------------------------------

def __init__(self, view_separate_frames) :
INDENT
    self._log = logging.getLogger("MVC Logger")
    self._log.info("MVC Main Controller: starting...")
    pub.subscribe(self.OnAppEvent, "APP_EVENT")
    if view_separate_frames :
    INDENT
        self._view = bank_view_separate_frames.MainWindow("Demo MVC - Bank Simulator")
    DEDENT
    else :
    INDENT
        self._view = bank_view.MainWindow("Demo MVC - Bank Simulator")

    DEDENT
    self._customers = []
    self._workplaces = []

    self._customers.append(CustomerModel("Fred Nerks"))
    self._bank = BankModel()
    self._bank.CreateAccountFor(self._customers [0])
    self._view.AddBank(self._bank)
    self._view.AddCustomer(self._customers [0])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22214086_22214299_3_23
22214086_22216280_1_13
Title: Python: A program to find the LENGTH of the longest run in a given list? 
----------------------------------------

def longestrun(myList) :
INDENT
    result = None
    prev = None
    size = 0
    max_size = 0

    for i in myList :
    INDENT
        if i == prev :
        INDENT
            print (i)
            size += 1
            if size > max_size :
            INDENT
                print ('*******  ' + str(max_size))
                max_size = size
            DEDENT
        DEDENT
        else :
        INDENT
            size = 0
        DEDENT
        prev = i
    DEDENT
    print (max_size + 1)
    return max_size + 1

DEDENT
----------------------------------------

def longestrun(myList) :
INDENT
    sett = set()
    size = 1
    for ind, elm in enumerate(myList) :
    INDENT
        if ind > 0 :
        INDENT
            if elm == myList [ind - 1] :
            INDENT
                size += 1
            DEDENT
            else :
            INDENT
                sett.update([size])
                size = 1
            DEDENT
        DEDENT
    DEDENT
    sett.update([size])
    return max(sett)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22217314_22218441_2_10
22217314_47555355_2_17
Title: Removing quotes from keys of dicts when rendering to template 
----------------------------------------

def __repr__(self) :
INDENT
    s = "{"
    for key in self :
    INDENT
        s += "{0}:{1}, ".format(key, self [key])
    DEDENT
    if len(s) > 1 :
    INDENT
        s = s [0 : - 2]
    DEDENT
    s += "}"
    return s
DEDENT
----------------------------------------

def __repr__(self) :
INDENT
    s = "{"
    for key in self :
    INDENT
        s += "{0}:".format(key)
        if isinstance(self [key], basestring) :
        INDENT

            s += "\"{0}\", ".format(self [key])
        DEDENT
        elif isinstance(self [key], dict) :
        INDENT

            s += "{0}, ".format(DictWithoutQuotedKeys(self [key]))
        DEDENT
        else :
        INDENT
            s += "{0}, ".format(self [key])
        DEDENT
    DEDENT
    if len(s) > 1 :
    INDENT
        s = s [0 : - 2]
    DEDENT
    s += "}"
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22226708_22226844_5_11
22226708_22265393_5_11
Title: "Can a ""with"" statement be used conditionally?" 
----------------------------------------

def store(items) :
INDENT
    with open(filename, 'w') as output :
    INDENT
        results = []
        for item in items :
        INDENT
            write_result(item, result, output)
            result.append(item)
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------

def store(items) :
INDENT
    with open(filename, mode) as output :
    INDENT
        results = []
        for item in items :
        INDENT
            write_result(item, output)
            results.append(item)
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22237247_22237333_3_14
22237247_22237478_5_16
Title: How to print single lines from file 
----------------------------------------

def main() :
INDENT
    log1 = sys.argv [1]
    log2 = sys.argv [2]
    with open(log1, 'r') as f :
    INDENT
        print (f.readline().strip('\n'))
        for l in f :
        INDENT
            print (l.strip('\n'))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    log1 = (sys.argv [1])
    log2 = (sys.argv [2])

    with open(log1, 'rU') as f :
    INDENT
        print (next(f))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22263023_22263163_7_18
22263023_22263301_9_19
Title: why does a call to locals() add a reference? 
----------------------------------------

def demo(x) :
INDENT
    print getrefcount(x)
    x = trivial(x)
    print getrefcount(x)
    print "Before Locals ", gc.get_referrers(x)
    locals()
    print "After Locals ", gc.get_referrers(x)
    print getrefcount(x)
    gc.collect()
    print getrefcount(x)
    print "After garbage collect", gc.get_referrers(x)
DEDENT
----------------------------------------

def demo(x) :
INDENT
    print getrefcount(x)
    x = trivial(x)
    print getrefcount(x)
    print id(locals())
    print getrefcount(x)
    print gc.collect(), "collected"
    print id(locals())
    print getrefcount(x)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22263752_22263955_13_28
22263752_24145396_20_27
Title: Python - Showing a web browser/iframe right into the app 
----------------------------------------

def create_webview(self) :
INDENT
    webview = WebView(activity)
    activity.addContentView(webview, LayoutParams(- 1, - 1))
    webview.getSettings().setJavaScriptEnabled(True)

    html = "<html><body style='margin:0;padding:0;'>\
            <script type='text/javascript'\
            src='http://ad.leadboltads.net/show_app_ad.js?section_id=ID_HERE'>\
            </script></body></html>"
    activity.setContentView(webview)
    webview.loadData(html, "text/html", "utf-8")
    layout = LinearLayout(activity)
    layout.addView(activity.mView)
    activity.setContentView(layout)
DEDENT
----------------------------------------

def create_webview(self, * args) :
INDENT
    webview = WebView(activity)
    webview.getSettings().setJavaScriptEnabled(True)
    wvc = WebViewClient();
    webview.setWebViewClient(wvc);
    activity.setContentView(webview)
    webview.loadUrl('http://www.google.com')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22284578_24149251_1_13
22284578_50483259_34_41
Title: "Linked List in Python- Append Index Insert and Pop functions. Not sure with code/errors" 
----------------------------------------

def add(self, item) :
INDENT
    temp = Node(item)
    temp.next = self.head
    self.head = temp
    current = self.head
    self.index_correct(current)
    current = self.head
    previous = None
    while current.position ! = self.size() - 1 :
    INDENT
        previous = current
        current = current.next
        current.back = previous
    DEDENT
    self.tail = current
DEDENT
----------------------------------------

def add(self, item) :
INDENT
    temp = Node(item)
    temp.setNext(self.head)
    self.head = temp
    if self.tail is None :
    INDENT
        self.tail = temp
    DEDENT
    self.length += 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22284578_35671448_1_23
22284578_50483259_114_136
Title: "Linked List in Python- Append Index Insert and Pop functions. Not sure with code/errors" 
----------------------------------------

def insert(self, item, position) :
INDENT
    if position == 0 :
    INDENT
        self.add(item)
    DEDENT
    elif position > self.size() :
    INDENT
        print ("Position index is out of range")
    DEDENT
    elif position == self.size() :
    INDENT
        self.append(item)
    DEDENT
    else :
    INDENT
        temp = Node.Node(item, position)
        current = self.head
        previous = None
        current_position = 0
        while current_position ! = position :
        INDENT
            previous = current
            current = current.next
            current_position += 1
        DEDENT
        previous.next = temp
        temp.next = current
    DEDENT
DEDENT
----------------------------------------

def insert(self, index, item) :
INDENT
    temp = Node(item)
    current = self.head
    previous = None
    count = 0
    found = False
    if index > self.length - 1 :
    INDENT
        raise IndexError('List Index Out Of Range')
    DEDENT
    while current is not None and not found :
    INDENT
        if count == index :
        INDENT
            found = True
        DEDENT
        else :
        INDENT
            previous = current
            current = current.getNext()
            count += 1
        DEDENT
    DEDENT
    if previous is None :
    INDENT
        temp.setNext(self.head)
        self.head = temp
    DEDENT
    else :
    INDENT
        temp.setNext(current)
        previous.setNext(temp)
    DEDENT
    self.length += 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22289523_22291486_5_11
22289523_22418646_21_72
Title: minimize alpha in exponential smoothing 
----------------------------------------

def y(alpha, x) :
INDENT
    y = np.empty(len(x), float)
    y [0] = x [0]
    for i in xrange(1, len(x)) :
    INDENT
        y [i] = x [i - 1] * alpha + y [i - 1] * (1 - alpha)
    DEDENT
    return y
DEDENT
----------------------------------------

def y(x, coeffList, debug = True) :
INDENT
    c = 4
    xlen = len(x)

    fc = float(c)
    xbar2 = sum([x [i] for i in range(c, 2 * c)]) / fc
    xbar1 = sum([x [i] for i in range(c)]) / fc
    b0 = (xbar2 - xbar1) / fc
    if debug : print ("b0 = ", b0)
    tbar = sum(i for i in range(1, c + 1)) / fc
    print (tbar)
    a0 = xbar1 - b0 * tbar
    if debug : print ("a0 = ", a0)
    I = [x [i] / (a0 + (i + 1) * b0) for i in range(0, xlen)]
    if debug : print ("Initial indices = ", I)
    S = [0] * (xlen + c)
    for i in range(c) :
    S [i] = (I [i] + I [i + c]) / 2.0

    tS = c / sum([S [i] for i in range(c)])
    for i in range(c) :
    INDENT
        S [i] *= tS
        if debug : print ("S[", i, "]=", S [i])
    DEDENT
    if debug : print ("Use Holt Winters formulae")
    At = a0
    Bt = b0
    y = np.empty(len(x), float)
    for i in range(xlen) :
    INDENT
        Atm1 = At
        Btm1 = Bt
        At = coeffList [0] * x [i] / S [i] + (1.0 - coeffList [0]) * (Atm1 + Btm1)
        Bt = coeffList [1] * (At - Atm1) + (1 - coeffList [1]) * Btm1
        S [i + c] = coeffList [2] * x [i] / At + (1.0 - coeffList [2]) * S [i]
        y [i] = (a0 + b0 * (i + 1)) * S [i]
    DEDENT
    return y

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22299612_22338062_40_47
22299612_22338062_4_25
Title: "How to display color icons in menu PyQt?" 
----------------------------------------

def __init__(self, parent) :
INDENT
    QtGui.QMenu.__init__(self, parent)
    self.colorAction = ColorAction(self)
    self.colorAction.colorSelected.connect(self.handleColorSelected)
    self.addAction(self.colorAction)
    self.addSeparator()
    self.addAction('Custom Color...')
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    QtGui.QWidgetAction.__init__(self, parent)
    widget = QtGui.QWidget(parent)
    layout = QtGui.QGridLayout(widget)
    layout.setSpacing(0)
    layout.setContentsMargins(2, 2, 2, 2)
    palette = self.palette()
    count = len(palette)
    rows = count / / round(count **.5)
    for row in range(rows) :
    INDENT
        for column in range(count / / rows) :
        INDENT
            color = palette.pop()
            button = QtGui.QToolButton(widget)
            button.setAutoRaise(True)
            button.clicked [()].connect(
                lambda color = color : self.handleButton(color))
            pixmap = QtGui.QPixmap(16, 16)
            pixmap.fill(color)
            button.setIcon(QtGui.QIcon(pixmap))
            layout.addWidget(button, row, column)
        DEDENT
    DEDENT
    self.setDefaultWidget(widget)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22330003_22331759_18_48
22330003_22338783_15_38
Title: Strange output for threaded subprocesses 
----------------------------------------

def ping(ip) :
INDENT
    global lock
    pingCommand = pingArgs + ip
    lock.acquire()
    ping = subprocess.Popen(pingCommand,
        stdout = subprocess.PIPE,
        stderr = subprocess.PIPE,
        shell = True)

    out = ping.communicate()
    out = ''.join((out))
    lost = re.findall(r"Lost = (\d+)", out)
    minimum = re.findall(r"Minimum = (\d+)", out)
    maximum = re.findall(r"Maximum = (\d+)", out)
    avg = re.findall(r"Average = (\d+)", out)
    no = re.findall(r"Sent = (\d+)", out)

    lost = [int(x) for x in lost]
    minimum = [int(x) for x in minimum]
    maximum = [int(x) for x in maximum]
    avg = [int(x) for x in avg]
    no = [int(x) for x in no]
    lock.release()
    return "%s \t \t %s \t \t%s \t \t %s \t \t%s" % (no, lost, maximum, minimum, avg)
DEDENT
----------------------------------------

def ping(ip) :
INDENT
    cmd = ["ping", "-n", "1", "-l", "1", "-w", "100", ip]
    ping = Popen(cmd, stdout = PIPE, stderr = PIPE)

    output, err = ping.communicate()
    out = ''.join([output, err])
    lost = re.findall(r"Lost = (\d+)", out)
    minimum = re.findall(r"Minimum = (\d+)", out)
    maximum = re.findall(r"Maximum = (\d+)", out)
    avg = re.findall(r"Average = (\d+)", out)
    no = re.findall(r"Sent = (\d+)", out)

    lost = [int(x) for x in lost]
    minimum = [int(x) for x in minimum]
    maximum = [int(x) for x in maximum]
    avg = [int(x) for x in avg]
    no = [int(x) for x in no]
    return "%s \t \t %s \t \t%s \t \t %s \t \t%s" % (
        no, lost, maximum, minimum, avg)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22330003_22331759_49_70
22330003_22338783_39_58
Title: Strange output for threaded subprocesses 
----------------------------------------

def main() :
INDENT
    ips = get_ips()

    print ("Packets \t loss(%) \t Max(ms) \t Min(ms) \t Average(ms)")
    pool = Pool(processes = 12)

    results = pool.map(ping, ips)

    pool.close()
    pool.join()
    for result in results :
    INDENT
        print (result)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    ips = get_ips(r'C:\Python26\ARPips.prn')

    print "Packets \t loss(%) \t Max(ms) \t Min(ms) \t Average(ms)"
    pool = Pool(processes = 12)

    results = pool.map(ping, ips)

    pool.close()
    pool.join()

    print "\n".join(results)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22330003_22331759_8_17
22330003_22338783_6_14
Title: Strange output for threaded subprocesses 
----------------------------------------

def get_ips() :
INDENT
    ips = []
    with open('C:\\Python26\\ARPips.prn', 'r') as f :
    INDENT
        for line in f :
        INDENT
            line = line [: - 1]
            if line ! = "end" :
            INDENT
                ips.append(line)
            DEDENT
        DEDENT
        return ips
    DEDENT
DEDENT
----------------------------------------

def get_ips(filename) :
INDENT
    ips = []
    with open(filename) as f :
    INDENT
        for line in f :
        INDENT
            line = line.strip()
            if line and line ! = "end" :
            INDENT
                ips.append(line)
            DEDENT
        DEDENT
    DEDENT
    return ips
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22330551_22330612_1_12
22330551_22330886_17_24
Title: List of compiled regexes in Python 
----------------------------------------

def extract_from_db() :
INDENT
    text = ''
    for row in cursor :
    INDENT

        text = REPLACE_1.sub(r'REPLACE_1', str(row [0]))
        text = REPLACE_2.sub(r'REPLACE_2', text)
        text = REPLACE_99.sub(r'REPLACE_99', text)
        text = REPLACE_100.sub(r'REPLACE_100', text)
        print text
    DEDENT
DEDENT
----------------------------------------

def extract_from_db() :
INDENT
    for row in cursor :
    INDENT
        text = str(row [0])
        for pattern, replacement in REPLACEMENTS :
        INDENT
            text = pattern.sub(replacement, text)
        DEDENT
        print text
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22347360_22349329_10_18
22347360_22349329_37_63
Title: Good approach for updating the GUI continuously in wxPython using threads? 
----------------------------------------

def __init__(self, parent, mystyle, interval, topic, message) :
INDENT
    wx.Panel.__init__(self, parent, style = mystyle)
    pub.subscribe(self.updatePanel, topic)
    self.updateMsg = message
    self.textCtrl = None
    self.interval = interval
    self.topic = topic
    pub.subscribe(self.updatePanel, self.topic)
DEDENT
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    screenWidth = 500
    screenHeight = 400
    screenSize = (screenWidth, screenHeight)
    wx.Frame.__init__(self, None, id, title, size = screenSize)
    self.locationFont = locationFont = wx.Font(12, wx.MODERN, wx.NORMAL, wx.BOLD)
    mainSizer = wx.BoxSizer(wx.VERTICAL)

    myPanelA = selfUpdatePanel(self, wx.SIMPLE_BORDER, 3, 'Update-panelA', 'Problem solved')
    myPanelA.SetBackgroundColour('#C0FAE0')
    self.myTextA = wx.StaticText(myPanelA, - 1, "I have a problem :( ")
    myPanelA.setTextCtrl(self.myTextA)

    myPanelB = selfUpdatePanel(self, wx.SIMPLE_BORDER, 5, 'Update-panelB', 'Mine too')
    myPanelB.SetBackgroundColour('#C0FAFF')
    self.myTextB = wx.StaticText(myPanelB, - 1, "Me too :( ")
    myPanelB.setTextCtrl(self.myTextB)
    mainSizer.Add(myPanelA, 1, wx.EXPAND, 5)
    mainSizer.Add(myPanelB, 1, wx.EXPAND, 5)
    self.SetSizer(mainSizer)
    myPanelB.startThread()
    myPanelA.startThread()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22383218_22383985_1_10
22383218_22384035_1_9
Title: How to replace all the file extensions in a folder? (Python) 
----------------------------------------

def parse(map, path = "Maps") :
INDENT
    new_path = os.path.join(os.getcwd(), path)
    os.chdir(new_path)
    for f in os.listdir(new_path) :
    INDENT
        try :
        INDENT
            print f
            os.rename(f, f.replace("txt", "sk"))
        DEDENT
        except WindowsError :
        INDENT
            print "Map file in use by another program."
            sys.exit()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def parse(path = "Maps/") :
INDENT
    for f in os.listdir(path) :
    INDENT
        try :
        os.rename(path + f, path + f.replace("txt", "sk"))
        except OSError as e :
        INDENT
            print (e)
            sys.exit()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22389320_22390309_2_10
22389320_22392544_1_7
Title: "Python Files adding values to/from a list" 
----------------------------------------

def readFile() :
INDENT
    ui = input("Please enter your file name:")
    r = open(ui, 'r')
    files = r.readlines()
    for line in files :
    INDENT
        value = float(line)
        L.append(value)
    DEDENT
    r.close()
DEDENT
----------------------------------------

def readFile(ui) :
INDENT
    L = []
    with open(ui, 'r') as f :
    INDENT
        for line in f.readlines() :
        INDENT
            L.append(float(line))
        DEDENT
    DEDENT
    return sorted(L)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22390122_22390314_1_13
22390122_22390323_1_11
Title: Python recursive function returning none after completion 
----------------------------------------

def countdown(n) :
INDENT
    '''prints values from n to 1, one per line
    pre: n is an integer > 0
    post: prints values from n to 1, one per line'''

    if n > 0 :
    INDENT
        print (n)
        return countdown(n - 1)
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------

def countdown(n) :
INDENT
    '''prints values from n to 1, one per line
    pre: n is an integer > 0
    post: prints values from n to 1, one per line'''

    if n > 0 :
    INDENT
        print (n)
        countdown(n - 1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22390122_22390314_1_13
22390122_22390336_1_15
Title: Python recursive function returning none after completion 
----------------------------------------

def countdown(n) :
INDENT
    '''prints values from n to 1, one per line
    pre: n is an integer > 0
    post: prints values from n to 1, one per line'''

    if n > 0 :
    INDENT
        print (n)
        return countdown(n - 1)
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------

def countdown(n) :
INDENT
    '''prints values from n to 1, one per line
    pre: n is an integer > 0
    post: prints values from n to 1, one per line'''

    if n > 0 :
    INDENT
        print (n)
        countdown(n - 1)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22390416_34057950_19_26
22390416_45424319_3_11
Title: Setting initial Django form field value in the __init__ method 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    if 'submission_type' in kwargs :
    INDENT
        submission_type = kwargs.pop('submission_type')
        if submission_type == 'question' :
        INDENT
            self.declared_fields ['needs_response'].initial = 1
        DEDENT
        else :
        INDENT
            self.declared_fields ['needs_response'].initial = 2
        DEDENT
    DEDENT
    super(FeedbackQuestionResponseForm, self).__init__(* args, ** kwargs)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super().__init__(* args, ** kwargs)
    self.fields ['state'] = forms.ChoiceField(
        required = False,
        choices = Foo.ADDRESS_STATE_CHOICES,
        disabled = 'disabled',
        initial = 'xyz',
        )
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22402124_22402246_1_19
22402124_22403006_1_17
Title: Simple List Error Python 
----------------------------------------

def dice() :
INDENT
    diceSumTable = []
    diceSumTable.append((1, 1))
    diceSumTable.append(((1, 2), (2, 1)))
    diceSumTable.append(((1, 3), (2, 2), (3, 1)))
    diceSumTable.append(((1, 4), (2, 3), (3, 2), (4, 1)))
    diceSumTable.append(((1, 5), (2, 4), (3, 3), (4, 2), (5, 1)))
    diceSumTable.append(((1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1)))
    diceSumTable.append(((2, 6), (3, 5), (4, 4), (5, 3), (6, 2)))
    diceSumTable.append(((3, 6), (4, 5), (5, 4), (6, 3)))
    diceSumTable.append(((4, 6), (5, 5), (6, 4)))
    diceSumTable.append(((5, 6), (6, 5)))
    diceSumTable.append(((6, 6)))

    for i in diceSumTable :
    INDENT
        print i
    DEDENT
DEDENT
----------------------------------------

def dice() :
INDENT
    diceSumTable = [[(1, 1)],
        [(1, 2), (2, 1)],
        [(1, 3), (2, 2), (3, 1)],
        [(1, 4), (2, 3), (3, 2), (4, 1)],
        [(1, 5), (2, 4), (3, 3), (4, 2), (5, 1)],
        [(1, 6), (2, 5), (3, 4), (4, 3), (5, 2), (6, 1)],
        [(2, 6), (3, 5), (4, 4), (5, 3), (6, 2)],
        [(3, 6), (4, 5), (5, 4), (6, 3)],
        [(4, 6), (5, 5), (6, 4)],
        [(5, 6), (6, 5)],
        [(6, 6)]]

    for (i, value) in enumerate(diceSumTable) :
    INDENT
        print str(i + 2) + " is associated to " + str(value)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22403203_22410158_21_26
22403203_22410158_36_44
Title: Pygame - blitting for a preview picture 
----------------------------------------

def draw(self, screen) :
INDENT
    pos = pygame.mouse.get_pos()
    if self.last :
    INDENT
        pygame.draw.line(screen, color, self.last, pos)
        self.last = pos
    DEDENT
DEDENT
----------------------------------------

def draw(self, screen) :
INDENT
    if not self.tmp :
    INDENT
        self.tmp = screen.copy()
    DEDENT
    pos = pygame.mouse.get_pos()
    screen.blit(self.tmp, (0, 0))
    if self.start :
    INDENT
        self.do_draw(screen, pos)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22428987_22429110_1_15
22428987_22429116_1_16
Title: changing variables inside procedures 
----------------------------------------

def Start() :
INDENT
    password = input("Enter A Password With 7 Or More Characters: ")
    passwordLength = len(password)
    if passwordLength < 7 :
    INDENT
        print ("Your entered a password with less than 7 characters. Enter a longer password.")
        return Start()
    DEDENT
    else :
    INDENT
        reEnter = input("Re-enter your password: ")
        if not reEnter == password :
        INDENT
            print ("Your passwords did not match, please try again.")
            return Start()
        DEDENT
        else :
        INDENT
            print ("Your password has been saved.")
            return password, passwordLength
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def Start() :
INDENT
    global password
    global passwordLength
    password = raw_input("Enter A Password With 7 Or More Characters: ")
    passwordLength = len(password)
    if passwordLength < 7 :
    INDENT
        print "Your entered a password with less than 7 characters. Enter a longer password."
        Start()
    DEDENT
    else :
    INDENT
        reEnter = raw_input("Re-enter your password: ")
        if reEnter < > password :
        INDENT
            print "Your passwords did not match, please try again."
            Start()
        DEDENT
        if reEnter == password :
        INDENT
            print "Your password has been saved."
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22441030_22441161_1_11
22441030_22446491_8_13
Title: Counting the depth of a tree using recursion 
----------------------------------------

def set_depth(self, number_of_depth) :
INDENT
    child = BTNode(number_of_depth)
    if self.left is None and self.right is None :
    INDENT
        return self.number_of_depth
    DEDENT
    else :
    INDENT
        if self.left is not None or self.right is not None :
        INDENT
            self.number_of_depth += 1
            self.set_depth(number_of_depth)
        DEDENT
        child.left = child
    DEDENT
DEDENT
----------------------------------------

def set_depth(self, depth) :
INDENT
    if self.left is not None :
    INDENT
        self.left.set_depth(depth + 1)
    DEDENT
    if self.right is not None :
    INDENT
        self.right.set_depth(depth + 1)
    DEDENT
    self.depth = depth
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22456531_22456621_56_65
22456531_22456621_9_32
Title: python pubsub subscribe to more than one topic 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    pub.subscribe(self.myListener, "panelListener")
    pub.subscribe(self.myListener, "anotherListener")
    btn = wx.Button(self, label = "Open Frame")
    btn.Bind(wx.EVT_BUTTON, self.onOpenFrame)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "Secondary Frame")
    panel = wx.Panel(self)
    msg = "Enter a Message to send to the main frame"
    instructions = wx.StaticText(panel, label = msg)
    self.msgTxt = wx.TextCtrl(panel, value = "")
    sendBtn = wx.Button(panel, label = "Send Msg")
    sendBtn.Bind(wx.EVT_BUTTON, self.onSendMsg)
    closeBtn = wx.Button(panel, label = "Send and Close")
    closeBtn.Bind(wx.EVT_BUTTON, self.onSendAndClose)
    sizer = wx.BoxSizer(wx.VERTICAL)
    flags = wx.ALL | wx.CENTER
    sizer.Add(instructions, 0, flags, 5)
    sizer.Add(self.msgTxt, 0, flags, 5)
    sizer.Add(sendBtn, 0, flags, 5)
    sizer.Add(closeBtn, 0, flags, 5)
    panel.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22460483_22460594_1_9
22460483_22460839_1_11
Title: Converting recursive to iterative in python 
----------------------------------------

def collatz(number) :
INDENT
    number = int(number)
    while number ! = 1 :
    INDENT
        if number % 2 == 0 :
        INDENT
            number = number / 2
        DEDENT
        elif number % 2 ! = 0 :
        INDENT
            number = (number * 3) + 1
        DEDENT
    DEDENT
    print ("finished")
DEDENT
----------------------------------------

def collatz(number) :
INDENT
    if number == 1 :
    INDENT
        print ('Finished!')
        return
    DEDENT
    if number % 2 == 0 :
    INDENT
        number = number / 2
        collatz(number)
    DEDENT
    elif number % 2 ! = 0 :
    INDENT
        number = (number * 3) + 1
        collatz(number)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22467111_22500155_35_45
22467111_22528745_35_45
Title: scrapy +couchebase: middleware or pipline? how to store and retrieve data 
----------------------------------------

def spider_opened(self, spider) :
INDENT
    self._server = settings ['COUCHBASE_SERVER']
    self._bucket = settings ['COUCHBASE_BUCKET']
    self._password = settings ['COUCHBASE_PASSWORD']
    try :
    INDENT
        self.cb = Couchbase.connect(self._bucket)
    DEDENT
    except CouchbaseError :
    INDENT
        log.msg('Connection problem to bucket %s' % self._bucket,
            log.ERROR)
    DEDENT
    log.msg("CouchbaseStore.spider_opened called",
        level = log.DEBUG)
DEDENT
----------------------------------------

def spider_opened(self, spider) :
INDENT
    try :
    INDENT
        self.couchbase = Couchbase.connect(bucket = self._bucket,
            host = self._server,
            post = self._port,
            password = self._password)
    DEDENT
    except CouchbaseError :
    INDENT
        log.msg('Connection problem to bucket %s' % self._bucket,
            log.ERROR)
    DEDENT
    log.msg("CouchbaseStore.spider_opened called", level = log.DEBUG)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22471329_22471478_1_17
22471329_22471483_1_16
Title: Doing tasks in a random order 
----------------------------------------

def randstat(level) :
INDENT
    from random import randint
    from random import shuffle
    points = randint(10, max(20, 5 * level))

    sValues = []

    for i in range(5) :
    INDENT
        sValues.append(randint(0, points))
        points -= sValues [- 1]

    DEDENT
    shuffle(sValues)
    agility, stamina, strength, vitality, intelligence = sValues
DEDENT
----------------------------------------

def randstat(level) :
INDENT
    points = randint(10, max(20, 5 * level))

    stats = [0, 0, 0, 0, 0]
    for i in range(points) :
    INDENT
        stat = randint(0, len(stats) - 1);
        stats [stat] = stats [stat] + 1

    DEDENT
    agility = stats [0]
    stamina = stats [1]
    strength = stats [2]
    vitality = stats [3]
    intelligence = stats [4]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22507197_22524616_1_29
22507197_40794749_1_12
Title: merging two sorted linked lists into one linked list in python 
----------------------------------------

def merge_lists(head1, head2) :
INDENT
    if head1 is None :
    INDENT
        return head2
    DEDENT
    if head2 is None :
    INDENT
        return head1

    DEDENT
    s = t = node()
    while not (head1 is None or head2 is None) :
    INDENT
        if head1.value < head2.value :
        INDENT

            c = head1
            head1 = head1.next
        DEDENT
        else :
        INDENT

            c = head2
            head2 = head2.next

        DEDENT
        t.next = c
        t = t.next
    DEDENT
    t.next = head1 or head2

    return s.next
DEDENT
----------------------------------------

def merge_lists(h1, h2) :
INDENT
    if h1 is None :
    INDENT
        return h2
    DEDENT
    if h2 is None :
    INDENT
        return h1
    DEDENT
    if (h1.value < h2.value) :
    INDENT
        h1.next = merge_lists(h1.next, h2)
        return h1
    DEDENT
    else :
    INDENT
        h2.next = merge_lists(h2.next, h1)
        return h2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22511298_22511740_1_21
22511298_23508471_1_16
Title: Using dictionary for matrix factorization and factor vector growing bigger and bigger 
----------------------------------------

def matrix_factorization(R, P, Q, K, steps = 5000, alpha = 0.0002, beta = 0.02) :
INDENT
    for step in xrange(steps) :
    INDENT
        for i in R.keys() :
        INDENT
            for j in R [i].keys() :
            INDENT
                eij = R [i] [j] - sum([P [i] [k] * Q [j] [k] for k in xrange(K)])
                for k in xrange(K) :
                INDENT
                    P_temp = P [i] [k]
                    Q_temp = Q [j] [k]
                    P [i] [k] = P_temp + alpha * (2 * eij * Q_temp - beta * P_temp)
                    Q [j] [k] = Q_temp + alpha * (2 * eij * P_temp - beta * Q_temp)
                DEDENT
            DEDENT
        DEDENT
        e = 0
        for i in R.keys() :
        INDENT
            for j in R [i].keys() :
            INDENT
                e += pow(R [i] [j] - sum([P [i] [k] * Q [j] [k] for k in xrange(K)]), 2)
                for k in xrange(K) :
                INDENT
                    e += (beta / 2) * (pow(P [i] [k], 2) + pow(Q [j] [k], 2))
                DEDENT
            DEDENT
        DEDENT
        if e < 0.001 :
        INDENT
            break
        DEDENT
    DEDENT
    return P, Q
DEDENT
----------------------------------------

def matrix_factorization(R, P, Q, K, steps = 10000, alpha = 0.002, beta = 0.02) :
INDENT
    Q = Q.T
    Indi = numpy.copy(R)
    Indi [Indi < > 0] = 1
    for step in xrange(steps) :
    INDENT
        Pred = P.dot(Q)
        _Pred = numpy.multiply(Indi, Pred)
        E = R - _Pred
        P_tmp = numpy.copy(P)
        Q_tmp = numpy.copy(Q)
        P = P_tmp + alpha * (E.dot(Q_tmp.T) - beta * P_tmp)
        Q = Q_tmp + alpha * (P_tmp.T.dot(E) - beta * Q_tmp)
        rmse = numpy.sqrt(E.ravel().dot(E.flat) / len(Indi [Indi.nonzero()]))
        print 'step:%s' % step
        print "RMSE:", rmse
    DEDENT
    return P, Q.T
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22519047_22519270_1_19
22519047_22519457_4_31
Title: How can I update a text box 'live' in tkinter? 
----------------------------------------

def main() :
INDENT
    frame = Tk()
    frame.geometry("480x360")
    Label(frame, text = "Enter coins.[Press Buttons]").grid(row = 1, column = 1)
    display = Label(frame, text = "")
    display.grid(row = 2, column = 1)
    def add(amount) :
    INDENT
        global credit
        credit += amount
        display.configure(text = "%.2f" % credit)
    DEDENT
    Button(frame, text = "10p", command = lambda : add(.1)).grid(row = 3, column = 1)
    Button(frame, text = "20p", command = lambda : add(.2)).grid(row = 4, column = 1)
    Button(frame, text = "50p", command = lambda : add(.5)).grid(row = 5, column = 1)
    Button(frame, text = "P1", command = lambda : add(1.)).grid(row = 6, column = 1)
    frame.mainloop()
DEDENT
----------------------------------------

def main() :
INDENT
    frame = Tk()
    frame.geometry("480x360")
    credit = tk.DoubleVar(frame, value = 0)

    ttk.Label(frame, textvariable = credit).pack()
    def add_credit(amt) :
    INDENT
        global credit
        credit.set(credit.get() + amt)

    DEDENT
    ttk.Button(frame, text = "10p", command = lambda : add_credit(0.1)).pack()

    ttk.Button(frame, text = "20p", command = lambda : add_credit(0.2)).pack()

    ttk.Button(frame, text = "50p", command = lambda : add_credit(0.5)).pack()

    ttk.Button(frame, text = "P1", command = lambda : add_credit(1.0)).pack()

    frame.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22530507_22530725_1_10
22530507_22532348_1_12
Title: split list of tuples in lists of list of tuples 
----------------------------------------

def get_groups(lst) :
INDENT
    t = []
    for i in lst :
    INDENT
        t.append(i)
        if i [1] == 'b' :
        INDENT
            yield t
            t = []
        DEDENT
    DEDENT
    if t :
    INDENT
        yield t
    DEDENT
DEDENT
----------------------------------------

def get_groups(lst) :
INDENT
    i = iter(lst)
    def row(x) :
    INDENT
        while True :
        INDENT
            yield x
            if x [1] == 'b' :
            INDENT
                return
            DEDENT
            x = next(i)
        DEDENT
    DEDENT
    for x in i :
    INDENT
        yield row(x)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22549602_22549807_1_23
22549602_22549929_10_34
Title: Python 3 program to solve the quadratic formula raises SyntaxError 
----------------------------------------

def main() :
INDENT
    print ("This program finds the real solutions to a quadratic equation.")
    a, b, c = 0.0, 0.0, 0.0
    a, b, c = float(input("n\Please enter the coefficients (a, b, c): "))
    discRoot = math.sqrt(b * b - 4 * a * c)
    if discRoot > 0 :
    INDENT
        root1 = (- b + discRoot) / (2 * a)
        root2 = (- b - discRoot) / (2 * a)
        print ("\nThe solutions are: ", root1, root2)
    DEDENT
    elif discRoot < 0 :
    INDENT
        print ("\nThe solutions for this equation are not real.")
        root1 = (- b + (discRoot * - 1)) / (2 * a)
        root2 = (- b - (discRoot * - 1)) / (2 * a)
        print "\nThe solutions are: ", root1, "+i ", root2, "-i"
    DEDENT
    elif discRoot == 0 :
    INDENT
        root1 = (- b + discRoot) / (2 * a)
        root2 = (- b - discRoot) / (2 * a)
        print ("\nThe solutions are: ", root1, root2)
    DEDENT
    else :
    INDENT
        continue
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    print ("This program solves a quadratic equation.")
    a = get_float("Value of coefficient A? ")
    b = get_float("Value of coefficient B? ")
    c = get_float("Value of coefficient C? ")
    print("\n{}x**2 + {}x + {} = 0 has ".format(a, b, c), end = "")
    discriminant = b * b - 4 * a * c
    if discriminant > 0 :
    INDENT
        rt = sqrt(discriminant)
        root1 = (- b + rt) / (2 * a)
        root2 = (- b - rt) / (2 * a)
        print ("two real solutions: {0:0.4f} and {1:0.4f}".format(root1, root2))
    DEDENT
    elif discriminant == 0 :
    INDENT
        root = - b / (2 * a)
        print ("one real solution: {0:0.4f}".format(root))
    DEDENT
    else :
    INDENT
        real = - b / (2 * a)

        imag = abs(sqrt(- discriminant) / (2 * a))
        print ("two complex solutions: {0:0.4f} + {1:0.4f}i and {0:0.4f} - {1:0.4f}i".format(real, imag))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22550302_22550693_17_23
22550302_22553017_1_17
Title: Find neighbors in a matrix? 
----------------------------------------

def neighbors(matrix, radius, rowNumber, colNumber) :
INDENT
    for row in range(radius) :
    INDENT
        for col in range(radius) :
        INDENT
            if in_bounds(matrix, rowNumber + row, colNumber + col) :
            INDENT
                print str(matrix [rowNumber + row] [colNumber + col]) + " ",
            DEDENT
        DEDENT
        print ""
    DEDENT
DEDENT
----------------------------------------

def neighbors(mat, row, col, radius = 1) :
INDENT
    rows, cols = len(mat), len(mat [0])
    out = []
    for i in xrange(row - radius - 1, row + radius) :
    INDENT
        row = []
        for j in xrange(col - radius - 1, col + radius) :
        INDENT
            if 0 < = i < rows and 0 < = j < cols :
            INDENT
                row.append(mat [i] [j])
            DEDENT
            else :
            INDENT
                row.append(0)
            DEDENT
        DEDENT
        out.append(row)
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2256722_2257520_11_21
2256722_39129160_12_25
Title: wxPython - Drawing an unfilled rectangle with the DC 
----------------------------------------

def OnPaint(self, evt) :
INDENT
    self.dc = wx.PaintDC(self)
    self.dc.BeginDrawing()
    self.dc.SetPen(wx.Pen("grey", style = wx.TRANSPARENT))
    self.dc.SetBrush(wx.Brush("grey", wx.SOLID))
    self.dc.DrawRectangle(250, 250, 50, 50)
    self.dc.EndDrawing()
    del self.dc

DEDENT
----------------------------------------

def OnPaint(self, event) :
INDENT
    dc = wx.PaintDC(self)

    dc.SetPen(wx.Pen("blue"))
    dc.SetBrush(wx.Brush("blue", wx.TRANSPARENT))
    dc.DrawRectangle(10, 10, 200, 200)

    dc.SetPen(wx.Pen("red"))
    dc.SetBrush(wx.Brush("red"))
    dc.DrawRectangle(220, 10, 200, 200)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22568863_22569155_2_37
22568863_22569391_4_16
Title: Dictionary formation in python 
----------------------------------------

def build_word_index() :
INDENT
    input_file = (input('file name: '))
    input_file_open = open(input_file, 'r')
    word_map = collections.defaultdict(list)
    line_no = 0
    w = []
    for line in input_file_open :
    INDENT

        word_lst = line.strip().split()
        word_lst = [w.lower().strip(string.punctuation) for w in word_lst]
        w.append(word_lst)
        for word in word_lst :
        INDENT
            word_map [word] += [line_no]
        DEDENT
        line_no += 1
    DEDENT
    print (word_map)
    index_lst = sorted(list(word_map.items()))
    print (index_lst)
    for word, line_set in index_lst :
    INDENT
        line_lst = sorted(list(line_set))
        line_str = str(line_lst [0])
        for line_no in line_lst [1 :] :
        INDENT
            line_str += ", {}".format(line_no)
        DEDENT
        print ("{:14s}:".format(word), line_str)
    DEDENT
    input_file_open.close()
DEDENT
----------------------------------------

def build_word_index(filename) :
INDENT
    word_index = defaultdict(list)
    with open(filename, 'rb') as word_file :
    INDENT
        for i, line in enumerate(word_file) :
        INDENT
            line = line.strip().lower()
            for word in line.split() :
            INDENT
                word_index [word].append(i)
            DEDENT
        DEDENT
    DEDENT
    for word in sorted(word_index) :
    INDENT
        print word + ': ' + ', '.join(map(str, word_index [word]))
    DEDENT
    return dict(word_index)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22586286_30480884_1_8
22586286_50029039_1_6
Title: "Python: Is there an equivalent of mid right and left from BASIC?" 
----------------------------------------

def left(s, amount = 1, substring = "") :
INDENT
    if (substring == "") :
    INDENT
        return s [: amount]
    DEDENT
    else :
    INDENT
        if (len(substring) > amount) :
        INDENT
            substring = substring [: amount]
        DEDENT
        return substring + s [: - amount]
    DEDENT
DEDENT
----------------------------------------

def left(aString, howMany) :
INDENT
    if howMany < 1 :
    INDENT
        return ''
    DEDENT
    else :
    INDENT
        return aString [: howMany]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22586286_30480884_9_15
22586286_50029039_7_12
Title: "Python: Is there an equivalent of mid right and left from BASIC?" 
----------------------------------------

def right(s, amount = 1, substring = "") :
INDENT
    if (substring == "") :
    INDENT
        return s [- amount :]
    DEDENT
    else :
    INDENT
        if (len(substring) > amount) :
        INDENT
            substring = substring [: amount]
        DEDENT
        return s [: - amount] + substring
    DEDENT
DEDENT
----------------------------------------

def right(aString, howMany) :
INDENT
    if howMany < 1 :
    INDENT
        return ''
    DEDENT
    else :
    INDENT
        return aString [- howMany :]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22589624_22589994_1_21
22589624_22590167_2_10
Title: linked list beginning and end in python 
----------------------------------------

def mutate_linked_list(head) :
INDENT
    if head.next is None :
    INDENT
        return head

    DEDENT
    penultimate = head
    while penultimate.next.next is not None :
    INDENT
        penultimate = penultimate.next
    DEDENT
    last = penultimate.next

    penultimate.next = None

    last.next = head.next.next

    head.next = last
    return head
DEDENT
----------------------------------------

def mutate_linked_list(head) :
INDENT
    mydeque = deque(head)
    try :
    INDENT
        while True :
        INDENT
            yield mydeque.popleft()
            yield mydeque.pop()
        DEDENT
    DEDENT
    except IndexError :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22599692_22599722_4_12
22599692_22599777_1_15
Title: For loop not iterating? 
----------------------------------------

def pig_latin(data) :
INDENT
    words = data.split()
    piglatin = []
    vowels = ["a", "i", "e", "u", "o"] + [str(x) for x in range(10)]
    for word in words :
    INDENT
        piglatin.append(pigetize(word, wovels))
    DEDENT
    return "".join(piglatin)
DEDENT
----------------------------------------

def pig_latin(data) :
INDENT
    words = data.split()
    piglatin = []
    vowels = ["a", "i", "e", "u", "o", "1", "2", "3", "4", "5", "6", "7", "8", "9", "0"]
    for word in words :
    INDENT
        if word [0] in vowels :
        INDENT
            word = word + "way"
        DEDENT
        else :
        INDENT
            word = word.replace(word [0], "") + word [0] + "ay"
            word = word.lower()
        DEDENT
        piglatin.append(word)
    DEDENT
    piglatin = " ".join(piglatin)
    return piglatin
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22623616_22623674_1_10
22623616_22623717_1_10
Title: using for loop in python to convert two strings into one string 
----------------------------------------

def mangle(s1, s2) :
INDENT
    a = ""
    for i in range(min(len(s1), len(s2))) :
    INDENT
        a += s1 [i] + s2 [i]
    DEDENT
    if len(s1) > len(s2) :
    INDENT
        return a + s1 [min(len(s1), len(s2)) :]
    DEDENT
    elif len(s1) < len(s2) :
    INDENT
        return a + s2 [min(len(s1), len(s2)) :]
    DEDENT
    return a
DEDENT
----------------------------------------

def mangle(s1, s2) :
INDENT
    a = ""
    small = min(len(s1), len(s2))
    for i in range(0, small) :
    INDENT
        a = a + s1 [i] + s2 [i]
    DEDENT
    if small is len(s1) :
    INDENT
        a = a + ''.join(s2 [i + 1 :])
    DEDENT
    else :
    INDENT
        a = a + ''.join(s1 [i + 1 :])
    DEDENT
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22624057_22624460_1_17
22624057_22624521_1_29
Title: find the index of element the number of occurence in string 
----------------------------------------

def build_char_records(s) :
INDENT
    records = []
    for idx, char in enumerate(s) :
    INDENT
        char = char.lower()
        current_record = None
        for record in records :
        INDENT
            if record [0] == char :
            INDENT
                current_record = record
                break
            DEDENT
        DEDENT
        if current_record is None :
        INDENT
            current_record = [char, 0, []]
            records.append(current_record)
        DEDENT
        current_record [1] += 1
        current_record [2].append(idx)
    DEDENT
    for value in records :
    INDENT
        print value
    DEDENT
DEDENT
----------------------------------------

def build_char_records(phrase) :
INDENT
    phrase = phrase.lower()
    resultList = []
    for character in phrase :
    INDENT
        if character not in resultList :
        INDENT
            resultList.append(character)
        DEDENT
    DEDENT
    resultList.sort()
    for i in range(len(resultList)) :
    INDENT
        character = resultList [i]
        tphrase = phrase
        num = phrase.count(character)
        acc = 0
        locs = []
        while acc < num :
        INDENT

            index = tphrase.find(character)
            tphrase = tphrase [index + 1 :]
            if len(locs) ! = 0 :
            INDENT
                index = locs [acc - 1] + index + 1
            DEDENT
            locs.append(index)
            acc += 1
        DEDENT
        resultList [i] = [character, num, locs]
    DEDENT
    return resultList
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22670214_22672238_12_38
22670214_22676293_13_29
Title: Python: How to use ListWidget Items to store and retrieve objects: Easy 
----------------------------------------

def __init__(self) :
INDENT
    super(QtGui.QMainWindow, self).__init__()
    myQWidget = QtGui.QWidget()
    myBoxLayout = QtGui.QVBoxLayout()
    myQWidget.setLayout(myBoxLayout)
    self.setCentralWidget(myQWidget)
    self.listWidget = QtGui.QListWidget()
    self.listWidget.currentItemChanged.connect(self.item_clicked)
    for i in range(12) :
    INDENT
        name = 'Item ' + str(i)
        my_item = QtGui.QListWidgetItem()
        my_item.setText('Item ' + str(i))
        self.listWidget.addItem(my_item)
        myObject = MyClass()
        my_item.setData(QtCore.Qt.UserRole, myObject)
    DEDENT
    myBoxLayout.addWidget(self.listWidget)
    Button_01 = QtGui.QPushButton("Get Items")
    Button_01.clicked.connect(self.getListItemsFromQListWidget)
    myBoxLayout.addWidget(Button_01)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(QtGui.QMainWindow, self).__init__()
    myQWidget = QtGui.QWidget()
    myBoxLayout = QtGui.QVBoxLayout()
    myQWidget.setLayout(myBoxLayout)
    self.setCentralWidget(myQWidget)
    self.ComboBox = QtGui.QComboBox()
    for i in range(12) :
    INDENT
        name = 'Item ' + str(i)
        myObject = MyClass()
        self.ComboBox.addItem(name, myObject)
    DEDENT
    self.ComboBox.currentIndexChanged.connect(self.combobox_selected)
    myBoxLayout.addWidget(self.ComboBox)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22697901_22698342_18_26
22697901_22698342_28_36
Title: How do I switch layouts in a window using PyQt?? (Without closing/opening windows) 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(LoginWidget, self).__init__(parent)
    layout = QtGui.QHBoxLayout()
    self.button = QtGui.QPushButton('Login')
    layout.addWidget(self.button)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(LoggedWidget, self).__init__(parent)
    layout = QtGui.QHBoxLayout()
    self.label = QtGui.QLabel('logged in!')
    layout.addWidget(self.label)
    self.setLayout(layout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22697901_22698342_18_26
22697901_22698342_4_10
Title: How do I switch layouts in a window using PyQt?? (Without closing/opening windows) 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(LoginWidget, self).__init__(parent)
    layout = QtGui.QHBoxLayout()
    self.button = QtGui.QPushButton('Login')
    layout.addWidget(self.button)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.central_widget = QtGui.QStackedWidget()
    self.setCentralWidget(self.central_widget)
    login_widget = LoginWidget(self)
    login_widget.button.clicked.connect(self.login)
    self.central_widget.addWidget(login_widget)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22697901_22698342_28_36
22697901_22698342_4_10
Title: How do I switch layouts in a window using PyQt?? (Without closing/opening windows) 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(LoggedWidget, self).__init__(parent)
    layout = QtGui.QHBoxLayout()
    self.label = QtGui.QLabel('logged in!')
    layout.addWidget(self.label)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.central_widget = QtGui.QStackedWidget()
    self.setCentralWidget(self.central_widget)
    login_widget = LoginWidget(self)
    login_widget.button.clicked.connect(self.login)
    self.central_widget.addWidget(login_widget)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22711505_22711903_5_23
22711505_22712492_9_20
Title: Smallest positive number that is evenly divisible by all of the numbers from 1 to 20? 
----------------------------------------

def prime_factors(n) :
INDENT
    if n == 1 :
    INDENT
        return []
    DEDENT
    for prime in primes_below_20 :
    INDENT
        if n % prime == 0 :
        INDENT
            return [prime] + prime_factors(n / prime)
        DEDENT
    DEDENT
    primes_needed = Counter()
    for n in range(2, 21) :
    INDENT
        primes = Counter(prime_factors(n))
        primes_needed = primes_needed | primes
    DEDENT
    total = 1
    for prime, amount in primes_needed.items() :
    INDENT
        total *= prime ** amount
    DEDENT
    print total
DEDENT
----------------------------------------

def prime_factors(n) :
INDENT
    if n < = 0 or n < 20 :
    INDENT
        raise ValueError
    DEDENT
    factors = []
    while n > 1 :
    INDENT
        for x in primes_20 [1 :] :
        INDENT
            if not n % x :
            INDENT
                n = n / x
                factors.append(x)
                break
            DEDENT
        DEDENT
    DEDENT
    return factors
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22739701_22739919_34_41
22739701_22749879_1_16
Title: "Django save ModelForm" 
----------------------------------------

def step3(request) :
INDENT
    if request.method == 'POST' :
    INDENT
        form = SelectCourseYear(request.POST or None, user = request.user)
        if form.is_valid() :
        INDENT
            form.save()
            return render_to_response("registration/complete.html",
                RequestContext(request))
        DEDENT
    DEDENT
    return render(request, 'registration/step3.html',)
DEDENT
----------------------------------------

def step3(request) :
INDENT
    user = request.user
    if request.method == 'POST' :
    INDENT
        form = SelectCourseYear(request.POST)
        if form.is_valid() :
        INDENT
            student = form.save(commit = False)

            student.user = request.user
            student.save()
            return render_to_response("registration/complete.html", RequestContext(request))
        DEDENT
    DEDENT
    else :
    INDENT
        form = SelectCourseYear()
    DEDENT
    return render(request, 'registration/step3.html',)
DEDENT
----------------------------------------
