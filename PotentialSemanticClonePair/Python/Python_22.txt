$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29499593_29500295_36_46
29499593_29500295_80_89
Title: Key Error: Python Finite State Machine? 
----------------------------------------

def execute(fsm) :
INDENT
    print ('WANDERING')
    if fsm.individual.sleep < = 0 :
    INDENT
        fsm.changeState('SLEEP')
    DEDENT
    elif fsm.individual.food > = 25 :
    INDENT
        fsm.changeState('WANDER')
        fsm.individual.sleep -= 5
        fsm.individual.food -= 5
    DEDENT
    else :
    INDENT
        fsm.changeState('EAT')
    DEDENT
DEDENT
----------------------------------------

def execute(fsm) :
INDENT
    print ('SLEEPING')
    if fsm.individual.sleep < 50 :
    INDENT
        fsm.changeState('SLEEP')
        fsm.individual.sleep += 5
    DEDENT
    elif fsm.individual.food < 25 :
    INDENT
        fsm.changeState('EAT')
    DEDENT
    else :
    INDENT
        fsm.changeState('WANDER')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29529247_29529674_10_17
29529247_29532600_8_12
Title: How to write a program that returns a count of strings longer than 10 characters in a list of strings 
----------------------------------------

def main() :
INDENT
    List = input("Please enter a list of strings: ")
    y = []
    for i in List :
    INDENT
        y.append(count(i))
    DEDENT
    print (y)
DEDENT
----------------------------------------

def main() :
INDENT
    Listy = input("Please enter a list of strings: ").split(",")
    for index in Listy :
    INDENT
        y = count(index)
        print (y)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29536980_29544560_11_39
29536980_29544560_44_150
Title: Wxpython - remove tabs in application 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    run_params = {}
    self.run_params = run_params

    self.run_params ["systemType"] = systemType
    if systemType == "Windows" :
    INDENT
        self.run_params ["fontSize"] = 8
        self.run_params ["fontSize2"] = 7
    DEDENT
    else :
    INDENT
        self.run_params ["fontSize"] = 10
        self.run_params ["fontSize2"] = 9
    DEDENT
    wx.Frame.__init__(self, parent, id, title, size = (900, 710), style = wx.DEFAULT_FRAME_STYLE & ~ (wx.RESIZE_BORDER |
            wx.RESIZE_BOX |
            wx.MAXIMIZE_BOX))

    self.submissions = SubmissionPane(self, run_params)
    self.CreateStatusBar()
    menuBar = wx.MenuBar()
    self.Centre()
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent, run_params) :
INDENT
    wx.Panel.__init__(self, parent)
    self.parent = parent
    self.selected_folders = None
    self.params = run_params

    self.frame = self
    main_sizer = wx.BoxSizer(wx.VERTICAL)
    self.top_row_sizer = wx.BoxSizer(wx.HORIZONTAL);
    radio_static_box = wx.StaticBox(self, label = 'Some Text')
    radio_static_box_sizer = wx.StaticBoxSizer(radio_static_box, wx.HORIZONTAL)
    job_static_box = wx.StaticBox(self, label = 'Some Text')
    job_static_box_sizer = wx.StaticBoxSizer(job_static_box, wx.HORIZONTAL)
    '''
        radio_labels = ['Some Text', 'Some Text2']
        self.radio_box = wx.RadioBox(
                self, -1, "", 
                choices=radio_labels,
        )
        '''
    self.radio1 = wx.RadioButton(self, label = 'Some Text', style = wx.RB_GROUP)
    self.radio2 = wx.RadioButton(self, label = 'Some Text')
    self.radio1.SetValue(True)
    radio_static_box_sizer.Add(self.radio1, flag = wx.BOTTOM, border = 0)
    radio_static_box_sizer.Add(self.radio2, flag = wx.LEFT, border = 10)
    self.top_row_sizer.Add(radio_static_box_sizer, flag = wx.LEFT, border = 10)
    self.check_box = wx.CheckBox(self, label = "Some Text")
    self.check_box.SetValue(False)
    if self.params ["systemType"] == "Windows" :
    INDENT
        self.txtTitle = wx.TextCtrl(self, style = wx.SUNKEN_BORDER, value = "Some Text...", size = (200, - 1), pos = (306, 14))
    DEDENT
    else :
    INDENT
        self.txtTitle = wx.TextCtrl(self, style = wx.SUNKEN_BORDER, value = "Some Text...", size = (200, - 1), pos = (350, 19))
    DEDENT
    job_static_box_sizer.Add(self.check_box, flag = wx.LEFT, border = 0)
    self.top_row_sizer.Add(job_static_box_sizer, flag = wx.LEFT, border = 10);
    self.txtTitle.Show(False)
    main_sizer.Add(self.top_row_sizer);
    main_sizer.Add((- 1, 10))
    job_static_box2 = wx.StaticBox(self, label = 'Some Text')
    third_row_sizer = wx.StaticBoxSizer(job_static_box2, wx.HORIZONTAL);
    self.tc_files = wx.TextCtrl(self, size = (375, 25))
    self.buttonGo = wx.Button(self, label = 'Go')
    self.buttonGo.Bind(wx.EVT_BUTTON, self.OnSubmit)
    third_row_sizer.Add(self.tc_files, flag = wx.RIGHT, border = 8)
    if self.params ["systemType"] == "Windows" :
    INDENT
        third_row_sizer.Add(self.buttonGo, flag = wx.LEFT | wx.TOP, border = 0)
    DEDENT
    else :
    INDENT
        third_row_sizer.Add(self.buttonGo, flag = wx.LEFT | wx.TOP, border = 2)
    DEDENT
    main_sizer.Add(third_row_sizer, flag = wx.LEFT, border = 10)
    self.log_text22 = wx.ListCtrl(self, size = (875, 275),
        style = wx.LC_REPORT | wx.BORDER_SUNKEN | wx.LC_SINGLE_SEL | wx.LC_VRULES | wx.LC_HRULES)
    font = wx.Font(self.params ["fontSize2"], wx.FONTFAMILY_DEFAULT, wx.FONTSTYLE_NORMAL, wx.FONTWEIGHT_NORMAL)
    self.log_text22.SetFont(font)
    self.log_text22.InsertColumn(1, '1', width = 40, format = wx.LIST_FORMAT_CENTRE)
    self.log_text22.InsertColumn(2, '2', width = 50, format = wx.LIST_FORMAT_CENTRE)
    self.log_text22.InsertColumn(3, '3', width = 156)
    self.log_text22.InsertColumn(4, '4', width = 332)
    self.log_text22.InsertColumn(5, '5', width = 100, format = wx.LIST_FORMAT_CENTRE)
    self.log_text22.InsertColumn(6, '6', width = 82, format = wx.LIST_FORMAT_CENTRE)
    self.log_text22.InsertColumn(7, '7', width = 60, format = wx.LIST_FORMAT_CENTRE)
    self.log_text22.InsertColumn(8, '8', width = 50, format = wx.LIST_FORMAT_CENTRE)
    main_sizer.Add((- 1, 10))
    list_sizer = wx.BoxSizer(wx.VERTICAL)
    list_sizer.Add(self.log_text22, flag = wx.LEFT, border = 10)
    main_sizer.Add(list_sizer)
    self.running_log1 = wx.stc.StyledTextCtrl(self, - 1, size = (875, 175))
    self.running_log1.StyleSetFont(wx.stc.STC_STYLE_DEFAULT, font)
    self.running_log1.SetMarginWidth(1, 0)
    self.running_log1.StyleSetBackground(wx.stc.STC_STYLE_DEFAULT, (0, 0, 0))
    self.running_log1.StyleSetForeground(wx.stc.STC_STYLE_DEFAULT, (0, 255, 0))
    self.running_log1.StyleClearAll()
    main_sizer.Add((- 1, 5))
    list_sizer = wx.BoxSizer(wx.VERTICAL)
    list_sizer.Add(self.running_log1, flag = wx.LEFT, border = 10)
    main_sizer.Add(list_sizer)
    list_sizer.Add((- 1, 10))
    self.buttonClose = wx.Button(self, - 1, "Quit")
    list_sizer.Add(self.buttonClose, flag = wx.ALIGN_CENTER | wx.TOP | wx.LEFT, border = 10)
    self.SetBackgroundColour("Light Grey")
    self.SetSizer(main_sizer)
    self.Layout()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29545704_29548349_6_21
29545704_45395962_7_20
Title: Fast Haversine Approximation (Python/Pandas) 
----------------------------------------

def haversine(lon1, lat1, lon2, lat2) :
INDENT
    lon1, lat1, lon2, lat2 = map(np.radians, [lon1, lat1, lon2, lat2])
    dlon = lon2 - lon1
    dlat = lat2 - lat1
    a = (np.sin(dlat / 2) ** 2
        + np.cos(lat1) * np.cos(lat2) * np.sin(dlon / 2) ** 2)
    c = 2 * np.arcsin(np.sqrt(a))
    km = 6367 * c
    return km
DEDENT
----------------------------------------

def haversine(lat1, lon1, lat2, lon2) :
INDENT
    R = 3959.87433
    dLat = radians(lat2 - lat1)
    dLon = radians(lon2 - lon1)
    lat1 = radians(lat1)
    lat2 = radians(lat2)
    a = sin(dLat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dLon / 2) ** 2
    c = 2 * asin(sqrt(a))
    return R * c
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29562183_29563726_32_55
29562183_29563726_78_94
Title: wxHtmlListbox as a control in wxListbook 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Listbook.__init__(self, parent, wx.ID_ANY,
        style = wx.BK_DEFAULT)
    il = wx.ImageList(32, 32)
    for x in range(3) :
    INDENT
        obj = getattr(images, 'LB%02d' % (x + 1))
        bmp = obj.GetBitmap()
        il.Add(bmp)
    DEDENT
    self.AssignImageList(il)
    pages = [(MyPanel(self), "Panel One"),
        (MyPanel(self), "Panel Two"),
        (MyPanel(self), "Panel Three")]
    imID = 0
    for page, label in pages :
    INDENT
        self.AddPage(page, label, imageId = imID)
        imID += 1
    DEDENT
    self.Bind(wx.EVT_LISTBOOK_PAGE_CHANGED, self.OnPageChanged)
    self.Bind(wx.EVT_LISTBOOK_PAGE_CHANGING, self.OnPageChanging)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Listbook Tutorial",
        size = (700, 400))
    panel = wx.Panel(self)
    notebook = ListbookDemo(panel)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(notebook, 1, wx.ALL | wx.EXPAND, 5)
    panel.SetSizer(sizer)
    self.Layout()
    self.Show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29570532_29570614_1_9
29570532_29570884_3_11
Title: How to reverse integer values from a while loop? 
----------------------------------------

def decimal_to_base4(num) :
INDENT
    base4_ = []
    while num > 0 :
    INDENT
        quotient = num / / 4
        base4 = num % 4
        num = quotient
        base4_.append(str(base4))
    DEDENT
    base4_ = "".join(base4_)
    print base4_ [: : - 1]
DEDENT
----------------------------------------

def decimal_to_base4(num) :
INDENT
    if num == 0 :
    INDENT
        return
    DEDENT
    quotient = num / / 4
    base4 = num % 4
    num = quotient
    decimal_to_base4(num)
    sys.stdout.write(str(base4))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29587827_29587985_4_22
29587827_29588146_4_21
Title: Fill area between two functions 
----------------------------------------

def domain() :
INDENT
    x = np.arange(0, 2, 0.001)
    f = lambda x : x ** 0.5
    g = lambda x : x ** 2
    plt.plot(x, f(x), label = '$y = \sqrt{2x - x^2}$')
    plt.plot(x, g(x), label = '$x = \sqrt{2y - y^2}$')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.legend(loc = 'best')
    plt.fill_between(x, f(x), g(x), where = f(x) > g(x))
    axes = plt.gca()
    axes.set_xlim([0, 2])
    axes.set_ylim([0, 2])
    plt.show()
DEDENT
----------------------------------------

def domain() :
INDENT
    x = np.arange(0, 10, 0.001)
    f1 = lambda x : (2 * x - x ** 2) ** 0.5
    f2 = lambda x : 1 - (1 - x * x) ** 0.5
    plt.plot(x, f1(x), label = '$y = \sqrt{2x - x^2}$')
    plt.plot(f1(x), x, label = '$x = \sqrt{2y - y^2}$')
    plt.fill_between(x, f1(x), f2(x), where = f1(x) > = f2(x), interpolate = True, color = 'yellow')
    plt.xlabel('X')
    plt.ylabel('Y')
    plt.legend(loc = 'best')

    axes = plt.gca()
    axes.set_xlim([0, 5])
    axes.set_ylim([0, 5])
    plt.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29594480_29598228_1_12
29594480_29614226_1_17
Title: Scrapy: missing xpath item causes wrong data to be written to my pipeline 
----------------------------------------

def parse(self, response) :
INDENT
    selector_object = response.xpath('//div[starts-with(@id,"result_")]')
    for select in selector_object :
    INDENT
        title = select.xpath('./h3/a/span/text()').extract()
        title = title [0].strip() if title else 'N/A'
        price = select.xpath('/ul/li[1]/div/a/span/text()').extract()
        price = price [0].strip() if price else 'N/A'
        item = AmazonItem(
            title = title,
            price = price)
        yield item
    DEDENT
DEDENT
----------------------------------------

def parse(self, response) :
INDENT
    selector_object = response.xpath('//div[starts-with(@id,"result_")]')
    for select in selector_object :
    INDENT
        new_price = select.xpath('./ul/li[1]/a/span[1]/text()').extract()
        title = select.xpath('./h3/a/span/text()').extract()
        title = title [0].strip() if title else 'N/A'
        price = select.xpath('./ul/li[1]/div/a/span/text()').extract()
        if price :
        INDENT
            price = price [0].strip()
        DEDENT
        elif new_price :
        INDENT
            price = new_price [0].strip()
        DEDENT
        item = AmazonItem(
            title = title,
            price = price)
        yield item
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29597268_29614165_64_86
29597268_29614165_92_103
Title: Pygame: One square making other squares bounce 
----------------------------------------

def update(self, screen, foods) :
INDENT
    self.move()

    if self.rect.top < 0 or self.rect.bottom > height :
    INDENT
        self.vy *= - 1
        self.rect.top = max(self.rect.top, 0)
        self.rect.bottom = min(self.rect.bottom, height)
    DEDENT
    if self.rect.left < 0 or self.rect.right > WINDOWIDTH :
    INDENT
        self.vx *= - 1
        self.rect.left = max(self.rect.left, 0)
        self.rect.right = min(self.rect.right, WINDOWIDTH)

    DEDENT
    self.draw(screen)

    for food in foods :
    INDENT
        if self.rect.colliderect(food.rect) :
        INDENT
            food.setVel(self)
            self.registerIncrease(0.1, 0.1)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def update(self, screen, foods) :
INDENT
    if self.vx ! = 0 or self.vy ! = 0 :
    INDENT

        self.move()

        if self.rect.bottom < 0 or self.rect.top > height or self.rect.right < 0 or self.rect.left > WINDOWIDTH :
        INDENT
            foods.remove(self)

        DEDENT
    DEDENT
    self.draw(screen)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29609450_29612845_158_171
29609450_29658647_153_170
Title: Maya Python - Using data from UI 
----------------------------------------

def createUI() :
INDENT
    cmds.window("Bullet_Spray_Generator")
    cmds.columnLayout(adjustableColumn = True)
    GunSelectCtrl = cmds.optionMenu(label = 'Gun', changeCommand = printNewMenuItem)
    for i in storedDataDic ["weapon"] :
    INDENT
        cmds.menuItem(label = i)
    DEDENT
    cmds.button(label = "Continue", command = ui_refreshSelWeapon)
    cmds.button(label = "Cancel", command = cancelShoot)
    cmds.showWindow("Bullet_Spray_Generator")
DEDENT
----------------------------------------

def createUI() :
INDENT
    global GunSelectCtrl
    cmds.window("Bullet_Spray_Generator")
    cmds.columnLayout(adjustableColumn = True)
    GunSelectCtrl = cmds.optionMenu(label = 'Gun', changeCommand = printNewMenuItem)
    cmds.menuItem(label = 'Pistol')
    cmds.menuItem(label = 'Shotgun')
    cmds.menuItem(label = 'SMG')
    cmds.menuItem(label = 'Sniper Rifle')
    cmds.menuItem(label = 'RPG')
    cmds.button(label = "Continue", command = partial(createGunUI, GunSelectCtrl))
    cmds.button(label = "Cancel", command = cancelShoot)
    cmds.showWindow("Bullet_Spray_Generator")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29661360_29661525_1_13
29661360_29661595_1_10
Title: I can't properly define a function in Python. Can anyone tell me where I am going wrong? 
----------------------------------------

def calc_average(filename) :
INDENT
    infile = open(filename, "r")
    readlines = infile.readlines()
    average = 0
    index = 0
    for line in readlines :
    INDENT
        parts = line.split()
        name = parts [0]
        average = average + float(parts [1])
        index = index + 1
    DEDENT
    return average / index
DEDENT
----------------------------------------

def calc_average() :
INDENT
    infile = open("filename.txt", "r")
    readlines = infile.readlines()
    for line in readlines :
    INDENT
        parts = line.split()
        name = parts [0]
        clsavg = parts [1]
        average = 0
    DEDENT
    return variable
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29661360_29661543_1_10
29661360_29661595_1_10
Title: I can't properly define a function in Python. Can anyone tell me where I am going wrong? 
----------------------------------------

def calc_average() :
INDENT
    infile = open("filename.txt", "r")
    readlines = infile.readlines()
    clsavg = 0
    counter = 0
    for line in readlines :
    INDENT
        parts = line.split()
        clsavg = clsavg + float(parts [1])
        counter = counter + 1
    DEDENT
    print clsavg / counter
DEDENT
----------------------------------------

def calc_average() :
INDENT
    infile = open("filename.txt", "r")
    readlines = infile.readlines()
    for line in readlines :
    INDENT
        parts = line.split()
        name = parts [0]
        clsavg = parts [1]
        average = 0
    DEDENT
    return variable
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29691106_29691214_1_11
29691106_29943054_1_12
Title: how to do a echo function to a file's last word in python 
----------------------------------------

def echo(filename, x) :
INDENT
    files = open(filename, "r")
    text = files.read()
    filelist = text.split()
    last_word = filelist [len(filelist) - 1]
    n = 1
    count = text
    while n < x :
    INDENT
        count = count + last_word
        n = n + 1
    DEDENT
    return count
DEDENT
----------------------------------------

def echo(filename, x) :
INDENT
    files = open(filename, "r")
    text = files.read()
    filelist = text.split()
    last_word = text.rsplit(None, 1) [- 1]
    files.close()
    n = 0
    string = text
    while n < x :
    INDENT
        string = string + "\n" + last_word
        n = n + 1
    DEDENT
    return string + "\n"
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29709359_29709500_5_13
29709359_29709503_5_12
Title: Multiprocesses python with shared memory 
----------------------------------------

def on_open(self) :
INDENT
    print "Creating thread..."
    try :
    INDENT
        p = Process(target = WebSocketApp.read_commands, args = (self,))
        p.start()
    DEDENT
    except :
    INDENT
        print "Error: Unable to start thread"
    DEDENT
DEDENT
----------------------------------------

def on_open(self) :
INDENT
    print "Creating process..."
    try :
    INDENT
        multiprocessing.Process(target = self.read_commands,).start()
    DEDENT
    except :
    INDENT
        print "Error: Unable to start process"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29726131_29726207_3_13
29726131_29726387_3_16
Title: """Not in function"" error in recursive function" 
----------------------------------------

def recursive_node_count(node) :
INDENT
    childs = tree [node]
    if childs == None :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        nodes_so_far = len(childs)
        for i in xrange(len(childs)) :
        INDENT
            nodes_in_this_branch = recursive_node_count(childs [i])
            nodes_so_far += nodes_in_this_branch
        DEDENT
        return nodes_so_far
    DEDENT
DEDENT
----------------------------------------

def recursive_node_count(node) :
INDENT
    childs = tree [node]
    if not childs :
    INDENT
        return 1
    DEDENT
    else :
    INDENT

        nodes_so_far = 1
        for child in childs :
        INDENT
            nodes_for_child = recursive_node_count(child)
            nodes_so_far += nodes_for_child
        DEDENT
        return nodes_so_far
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29755023_29765032_13_33
29755023_29765032_39_58
Title: Matplotlib/wxpython: co-ordinate values not showing up in status bar 
----------------------------------------

def __init__(self, parent, frame) :
INDENT
    wx.Panel.__init__(self, parent, - 1, size = (50, 50))

    self.frame = frame
    self.figure = Figure()
    self.canvas = FigureCanvas(self, - 1, self.figure)

    self.chart_toolbar = NavigationToolbar2Wx(self.canvas)
    self.chart_toolbar.Realize()
    graphs_sizer = wx.BoxSizer(wx.VERTICAL)
    graphs_sizer.Add(self.canvas, 20, flag = wx.EXPAND, border = 5)
    graphs_sizer.Add(self.chart_toolbar, 1, flag = wx.ALIGN_CENTER, border = 5)
    self.SetSizer(graphs_sizer)
DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (1000, 800))

    self.splitterWindow = wx.SplitterWindow(self)
    self.panel1 = p1(self.splitterWindow, self)
    self.panel2 = wx.Panel(self.splitterWindow)
    self.splitterWindow.SplitVertically(self.panel1, self.panel2, 700)

    self.statusbar = self.CreateStatusBar()

    self.panel1.plot()
    mouseMoveID = self.panel1.canvas.mpl_connect('motion_notify_event',
        self.onMotion)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29761648_29761766_1_16
29761648_29761816_1_16
Title: How can I make the following function into a tail-recursive function? 
----------------------------------------

def find_val_or_next_smallest(bst, x, best = None) :
INDENT
    if bst is None :
    INDENT
        return best
    DEDENT
    elif bst.val == x :
    INDENT
        return x
    DEDENT
    elif bst.val > x :
    INDENT
        return find_val_or_next_smallest(bst.left, x, best)
    DEDENT
    else :
    INDENT
        return find_val_or_next_smallest(bst.right, x, bst.val)
    DEDENT
DEDENT
----------------------------------------

def find_val_or_next_smallest(bst, x, val = None) :
INDENT
    if bst is None :
    INDENT
        return val
    DEDENT
    elif bst.val == x :
    INDENT
        val = x
    DEDENT
    elif bst.val < x and (val is None or bst.val > val) :
    INDENT
        val = bst.val
    DEDENT
    if bst.val > x :
    INDENT
        return find_val_or_next_smallest(bst.left, x, val)
    DEDENT
    else :
    INDENT
        return find_val_or_next_smallest(bst.right, x, val)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29761800_29761971_10_19
29761800_29762574_3_10
Title: Joining elements in a list without the join command 
----------------------------------------

def lists(list1) :
INDENT
    answer = 0
    h = 0
    while list1 ! = [] :
    INDENT
        answer = answer * 10 ** h + list1 [0]
        list1.pop(0)
        if list1 ! = [] :
        INDENT
            h = numdig(list1 [0])
        DEDENT
    DEDENT
    print (answer)
DEDENT
----------------------------------------

def lists(list1) :
INDENT
    b = 0
    foo = 0
    for item in reversed(list1) :
    INDENT
        b += item * (10 ** foo)
        foo += int(math.floor(math.log10(item))) + 1
    DEDENT
    return b
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29804793_29805839_16_26
29804793_29812689_14_24
Title: Python OpenCV output on Tkinter label deletion 
----------------------------------------

def show_frame() :
INDENT
    _, frame = cap.read()
    frame = cv2.flip(frame, 1)
    cv2image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGBA)
    img = Image.fromarray(cv2image)
    imgtk = ImageTk.PhotoImage(image = img)
    lmain.imgtk = imgtk
    lmain.configure(image = imgtk)
    if isrunning == 1 :
    INDENT
        lmain.after(10, show_frame)
    DEDENT
DEDENT
----------------------------------------

def show_frame() :
INDENT
    _, frame = cap.read()
    frame = cv2.flip(frame, 1)
    cv2image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGBA)
    img = Image.fromarray(cv2image)
    imgtk = ImageTk.PhotoImage(image = img)
    lmain.imgtk = imgtk
    lmain.configure(image = imgtk)
    if isrunning == 1 :
    INDENT
        lmain.after(10, show_frame)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29805003_29805535_1_10
29805003_29805562_1_13
Title: Trouble with Basic Python exercise involving lists and indexes 
----------------------------------------

def checkio(array) :
INDENT
    sum = 0
    last_element = 0
    for index, element in enumerate(array) :
    INDENT
        if index % 2 == 0 :
        INDENT
            sum += element
        DEDENT
        last_element = element
    DEDENT
    return last_element * sum
DEDENT
----------------------------------------

def checkio(array) :
INDENT
    listSum = 0
    if array :
    INDENT
        for i in range(0, len(array), 2) :
        INDENT
            listSum += array [i]
        DEDENT
        finalValue = listSum * array [- 1]
        return finalValue
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29805003_29805535_1_10
29805003_29805580_1_13
Title: Trouble with Basic Python exercise involving lists and indexes 
----------------------------------------

def checkio(array) :
INDENT
    sum = 0
    last_element = 0
    for index, element in enumerate(array) :
    INDENT
        if index % 2 == 0 :
        INDENT
            sum += element
        DEDENT
        last_element = element
    DEDENT
    return last_element * sum
DEDENT
----------------------------------------

def checkio(array) :
INDENT
    result = 0
    if array :
    INDENT
        for i, x in enumerate(array) :
        INDENT
            if i % 2 == 0 :
            INDENT

                result += x
            DEDENT
        DEDENT
        result *= array [- 1]
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29805003_29805562_1_13
29805003_29805580_1_13
Title: Trouble with Basic Python exercise involving lists and indexes 
----------------------------------------

def checkio(array) :
INDENT
    listSum = 0
    if array :
    INDENT
        for i in range(0, len(array), 2) :
        INDENT
            listSum += array [i]
        DEDENT
        finalValue = listSum * array [- 1]
        return finalValue
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------

def checkio(array) :
INDENT
    result = 0
    if array :
    INDENT
        for i, x in enumerate(array) :
        INDENT
            if i % 2 == 0 :
            INDENT

                result += x
            DEDENT
        DEDENT
        result *= array [- 1]
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29807630_29807934_18_26
29807630_29807934_4_13
Title: PyQT Button click doesn't work 
----------------------------------------

def __init__(self) :
INDENT
    super(MyWindow, self).__init__()
    self.btn = Button(self)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.btn)
    self.setLayout(layout)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(Button, self).__init__(parent)
    self.setAcceptDrops(True)
    self.setGeometry(QtCore.QRect(90, 90, 61, 51))
    self.setText("Change Me!")
    self.clicked.connect(self.printSomething)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29811980_30289290_58_64
29811980_30289290_73_82
Title: Pygame how do I create duplicates of a sprite class then put them in a group? 
----------------------------------------

def __init__(self) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.img = pygame.image.load('C:\\Users\\Ben\\Documents\\background.png').convert()
    self.img2 = pygame.image.load('C:\\Users\\Ben\\Documents\\trees1.png').convert()
    self.treesx = 0
    self.treesy = 70
    self.treesrect = pygame.draw.rect(setDisplay, pygame.Color(0, 0, 255), pygame.Rect(self.treesx, self.treesy, 376, 100))
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.img = pygame.image.load('C:\\Users\\Ben\\Documents\\ground.png').convert()
    self.imgx = 0
    self.imgy = 400
    self.setDisplay = pygame.display.get_surface()
    self.x = self.imgx
    self.y = self.imgy
    self.rect = pygame.draw.rect(setDisplay, pygame.Color(0, 0, 255), pygame.Rect(self.x, self.y, 800, 200))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29823179_29824277_2_13
29823179_29824320_10_23
Title: Execute Button Method 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    self.callback = kwargs.pop('command', None)
    self.repeatinterval = kwargs.pop('repeatinterval', 100)
    self.repeatdelay = kwargs.pop('repeatdelay', 300)
    ttk.Button.__init__(self, * args, ** kwargs)
    if self.callback :
    INDENT
        self.bind('<ButtonPress-1>', self.click)
        self.bind('<ButtonRelease-1>', self.release)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self._master = master
    master.title("Grid Master")
    master.frame_1 = ttk.Frame(master)
    master.frame_1.pack()
    master.configure(background = "#FFFFFF")
    self.button = ttk.Button(master, text = 'Press')
    self.button.bind("<Button-1>", self.button_pressed)
    self.button.bind("<ButtonRelease-1>", self.button_released)
    self.button.pack()
    self.hello_world_frequency = 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29825686_29827685_30_37
29825686_29827685_5_14
Title: Align buttons with rows of treeview 
----------------------------------------

def __init__(self, parent, items) :
INDENT
    ttk.Treeview.__init__(self, parent, columns = ("A"), padding = 1)
    self.heading("A", text = "Some A")
    self.parent = parent
    self.items = items
    for item in self.items :
    INDENT
        self.insert(parent = "", index = "end", text = item, values = "hello")
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent, items) :
INDENT
    ttk.Frame.__init__(self, parent)
    self.parent = parent
    self.items = items
    self.tree = MyTree(self, items)
    self.tree.grid(column = 0, row = 0, sticky = tk.N)
    self.buttons = ttk.Frame(self, width = 100)
    self.buttons.grid(column = 1, row = 0, sticky = tk.N)
    print (self.tree.config())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29834257_29834987_30_43
29834257_29834987_45_78
Title: Python: Blocking issues with a queue and threads 
----------------------------------------

def GET(self) :
INDENT
    if JobManagement.incoming_queue.full() :
    INDENT
        print "Queue is full"
        return web.InternalError("Queue is full, please try submitting later.")
    DEDENT
    else :
    INDENT
        job_id = getNextInt()
        req_folder = "req" + str(job_id)
        print JobManagement.incoming_queue
        JobManagement.incoming_queue.put(job_id)
        JobManagement.incoming_jobs.append(job_id)
        print "Received request, assigning Drop Folder {0}".format(req_folder)
        web.header('Drop-Folder', req_folder)
        return req_folder
    DEDENT
DEDENT
----------------------------------------

def GET(self) :
INDENT
    if str(web.input().jobid) == 'all' :
    INDENT

        web.header('Content-Type', 'application/json')
        return {'In Queue' : JobManagement.incoming_jobs,
            'Currently Processing' : JobManagement.current_job,
            'Finished' : JobManagement.finished_jobs}
    DEDENT
    try :
    INDENT
        jobid = int(web.input().jobid)
    DEDENT
    except ValueError :
    INDENT
        jobid = - 1
    DEDENT
    print jobid
    if jobid in JobManagement.finished_jobs :
    INDENT
        file_string = "results{0}.json".format(jobid)
        try :
        INDENT
            json_file = open(file_string)
            JobManagement.finished_jobs.remove(jobid)
            os.remove(file_string)
            web.header('Process-Status', 'Complete')
            web.header('Content-Type', 'application/json')
            return json.load(json_file)
        DEDENT
        except IOError :
        INDENT
            web.header('Process-Status', 'Complete, but failed to retrieve file, saving')
            return ""
        DEDENT
    DEDENT
    elif jobid is JobManagement.current_job :
    INDENT
        web.header('Process-Status', 'Processing')
    DEDENT
    elif jobid in JobManagement.incoming_jobs :
    INDENT
        web.header('Process-Status', 'In Queue')
    DEDENT
    else :
    INDENT
        web.header('Process-Status', 'Unknown')
    DEDENT
    return ""
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29855871_29862676_25_30
29855871_29862676_39_47
Title: How to switch between two windows in python using PyQt 
----------------------------------------

def run(self) :
INDENT
    while self.parent().isRunning() :
    INDENT
        self.timeElapsed.emit(time.time() - self.timeStart)
        time.sleep(0.1)

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    self.timerThread.start(time.time())
    iterations = 10000000000
    while iterations :
    INDENT
        print "Running {0}".format(self.__class__.__name__)
        iterations -= 1
        time.sleep(10)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29861537_29861695_1_10
29861537_29861763_1_11
Title: Python -- generator interspersing value between iterator -- am I doing this correctly? 
----------------------------------------

def iter_intersperse(iterOver, injectItem, startWithIter = True) :
INDENT
    if startWithIter :
    INDENT
        try :
        INDENT
            yield next(iterOver)
        DEDENT
        except Stopiteration :
        INDENT
            return
        DEDENT
    DEDENT
    for item in iterOver :
    INDENT
        yield injectItem
        yield item
    DEDENT
DEDENT
----------------------------------------

def iter_intersperse(iterOver, injectItem, startWithIter = True) :
INDENT
    inject = not startWithIter
    for item in iterOver :
    INDENT
        if inject :
        INDENT
            yield injectItem
        DEDENT
        yield item
        inject = True
    DEDENT
    if startWithIter :
    INDENT
        yield injectItem
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29871184_29871254_2_12
29871184_29871276_3_16
Title: __init__ Constructor in Python 
----------------------------------------

def __init__(self, center = None, x = None, y = None, height = 0, width = 0) :
INDENT
    if center is None :
    INDENT
        if x is None or y is None :
        INDENT
            raise TypeError('You must either specify a center or both x and y')
        DEDENT
    DEDENT
    else :
    INDENT
        if x is not None or y is not None :
        INDENT
            raise TypeError('You must either specify a center or both x and y')
        DEDENT
        x, y = center
    DEDENT
DEDENT
----------------------------------------

def __init__(self, height, width, coord_tuple = None, coord_x = None, coord_y = None) :
INDENT
    if coord_tuple :
    INDENT
        self.x = coord_tuple [0]
        self.y = coord_tuple [1]
    DEDENT
    else :
    INDENT
        self.x = coord_x
        self.y = coord_y
    DEDENT
    self.height = height
    self.width = width
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29871184_29871254_2_12
29871184_29871294_2_12
Title: __init__ Constructor in Python 
----------------------------------------

def __init__(self, center = None, x = None, y = None, height = 0, width = 0) :
INDENT
    if center is None :
    INDENT
        if x is None or y is None :
        INDENT
            raise TypeError('You must either specify a center or both x and y')
        DEDENT
    DEDENT
    else :
    INDENT
        if x is not None or y is not None :
        INDENT
            raise TypeError('You must either specify a center or both x and y')
        DEDENT
        x, y = center
    DEDENT
DEDENT
----------------------------------------

def __init__(self, center, * args) :
INDENT
    if isinstance(center, tuple) and args and len(args) > 1 :
    INDENT
        self.x, self.y = center
        self.w, self.h = args [: 2]
    DEDENT
    elif args and len(args) > 2 :
    INDENT
        self.x = center
        self.y = args [0]
        self.w, self.h = args [1 : 3]
    DEDENT
    else :
    INDENT
        raise Exception('Some exception')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29871184_29871276_3_16
29871184_29871294_2_12
Title: __init__ Constructor in Python 
----------------------------------------

def __init__(self, height, width, coord_tuple = None, coord_x = None, coord_y = None) :
INDENT
    if coord_tuple :
    INDENT
        self.x = coord_tuple [0]
        self.y = coord_tuple [1]
    DEDENT
    else :
    INDENT
        self.x = coord_x
        self.y = coord_y
    DEDENT
    self.height = height
    self.width = width
    return
DEDENT
----------------------------------------

def __init__(self, center, * args) :
INDENT
    if isinstance(center, tuple) and args and len(args) > 1 :
    INDENT
        self.x, self.y = center
        self.w, self.h = args [: 2]
    DEDENT
    elif args and len(args) > 2 :
    INDENT
        self.x = center
        self.y = args [0]
        self.w, self.h = args [1 : 3]
    DEDENT
    else :
    INDENT
        raise Exception('Some exception')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29871237_29871335_3_18
29871237_29871418_3_14
Title: "Python: How to track ""correct"" answer in randomized multiple choice" 
----------------------------------------

def answers() :
INDENT
    answerList = [answer1, answer2, answer3, correct]
    random.shuffle(answerList)
    numberList = ["1: ", "2: ", "3: ", "4: "]
    global track
    track = []
    for x, y in zip(numberList, answerList) :
    INDENT
        print x, y
        track.append(y)

    DEDENT
DEDENT
----------------------------------------

def answers(question, possAnswers) :
INDENT
    print (question)
    answerList = ['answer1', 'answer2', 'answer3', 'correct']
    random.shuffle(answerList)
    for i, j in enumerate(answerList) :
    INDENT
        print ("%s: %s" % (i, possAnswers [j]))
    DEDENT
    inp = int(raw_input("><![CDATA[>> "))
    if answerList [inp] == 'correct' :
    INDENT
        print ('Correct!')
    DEDENT
    else :
    INDENT
        print ('Incorrect!')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29873052_29882118_12_43
29873052_29908567_6_20
Title: Tkinter: widgets not highlighting on <Tab> event 
----------------------------------------

def __init__(self, master) :
INDENT
    frame = Frame(master)
    frame.grid()
    entry1 = Entry(frame)
    entry1.pack()
    entry1.focus_set()
    entry2 = Entry(frame)
    entry2.pack()
    button1 = Button(frame, text = "Test")
    button1.pack()
    button1.bind('<Return>', self.yup)
    var1 = IntVar()
    c = Checkbutton(frame, text = "Expand", variable = var1)
    c.pack()
    var2 = StringVar()
    radio = Radiobutton(frame, text = "Test", variable = var2, value = 1)
    radio.pack()
    var3 = StringVar()
    optionmenu1 = OptionMenu(frame, var3, "one", "two", "three")
    optionmenu1.pack()
    Button(frame, text = "Quit", bg = "orange", command = master.quit).pack()

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    tk.Frame.__init__(self, master)
    self.master = master
    entry1 = tk.Entry(self)
    entry1.pack()
    entry2 = tk.Entry(self)
    entry2.pack()
    button1 = tk.Button(self, text = "Test", command = self.yup)
    button1.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29879908_29880117_4_17
29879908_29880133_1_11
Title: Drawing random circles within a Python turtle circle 
----------------------------------------

def draw_circle(radius, angle) :
INDENT
    circumference = 2 * 3.1415 * radius
    side_length = circumference / (360 / angle)
    penup()
    forward(radius)
    right(90)
    pendown()
    for i in range(360 / angle) :
    INDENT
        forward(side_length)
        right(angle)
    DEDENT
    penup()
    left(90)
    backward(radius)
DEDENT
----------------------------------------

def draw_circle() :
INDENT
    radius_bound = R - r
    center_x = uniform(circle_x - radius_bound, circle_x + radius_bound)
    x_offset = center_x - circle_x
    y_limit = sqrt(radius_bound ** 2 - x_offset ** 2)
    center_y = uniform(circle_y - y_limit, circle_y + y_limit)
    my_turtle.penup()
    my_turtle.goto(center_x, center_y - r)
    my_turtle.seth(0)
    my_turtle.pendown()
    my_turtle.circle(r)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29883453_29883582_3_14
29883453_29883605_3_15
Title: Wrap code in a function 
----------------------------------------

def display_birthday_wishes() :
INDENT
    p = current_year = date.today().year
    name = raw_input("Enter your name: ")
    y = raw_input("Enter the month you were born in: ")
    z = raw_input("Enter your year of birth ")
    current_age = (int(p) - int(z))
    print current_age
    print "Hi,", name, "you are", current_age, "years old this year! Here's a bouquet of flowers for you!"
DEDENT
----------------------------------------

def display_birthday_wishes() :
INDENT
    name = raw_input("enter your name")
    current_year = current_year = date.today().year
    year_born = raw_input("enter your year of birth")
    current_age = (int(current_year) - int(year_born))
    month_born = raw_input("enter your month of birth")

    return "Hi, " + name + ". You are " + str(current_age) + " years old this year! Here's a bouquet of flowers for you!"
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29885261_29885430_1_30
29885261_29885851_1_9
Title: Is there a better way to write the following method in python? 
----------------------------------------

def find_missing(prog) :
INDENT
    items = [int(x) for x in prog.split()]

    first_to_second = items [1] - items [0]

    last_to_second_last = items [- 1] - items [- 2]

    if abs(first_to_second) < abs(last_to_second_last) :
    INDENT
        change = first_to_second
    DEDENT
    else :
    INDENT
        change = last_to_second_last

    DEDENT
    for i in range(1, len(items)) :
    INDENT
        comp = items [i] - items [i - 1]
        if comp ! = change :
        INDENT
            return items [i - 1] + change

        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def find_missing(series) :
INDENT
    A = map(int, series.split(' '))
    a, b, n, sumA = A [0], A [- 1], len(A), sum(A)
    if (a + b) * n / 2 == sumA :
    INDENT
        return None
    DEDENT
    return (a + b) * (n + 1) / 2 - sumA
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_52_59
29888233_31559494_68_73
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_52_59
29888233_33720100_56_66
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    for this_layer_neuron_index in range(len(self.neurons)) :
    INDENT
        neuron = self.neurons [this_layer_neuron_index]
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron_index in range(len(self.previous_layer.neurons)) :
            INDENT
                previous_layer_neuron = self.previous_layer.neurons [previous_layer_neuron_index]
                weight = self.previous_layer.weights [this_layer_neuron_index, previous_layer_neuron_index]
                self.__line_between_two_neurons(neuron, previous_layer_neuron, weight)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_52_59
29888233_33720100_75_81
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_52_59
29888233_37366154_56_70
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self, layerType = 0) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw(self.neuron_radius)
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)
            DEDENT
        DEDENT
    DEDENT
    x_text = self.number_of_neurons_in_widest_layer * self.horizontal_distance_between_neurons
    if layerType == 0 :
    INDENT
        pyplot.text(x_text, self.y, 'Input Layer', fontsize = 12)
    DEDENT
    elif layerType == - 1 :
    INDENT
        pyplot.text(x_text, self.y, 'Output Layer', fontsize = 12)
    DEDENT
    else :
    INDENT
        pyplot.text(x_text, self.y, 'Hidden Layer ' + str(layerType), fontsize = 12)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_52_59
29888233_37366154_81_92
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    pyplot.figure()
    for i in range(len(self.layers)) :
    INDENT
        layer = self.layers [i]
        if i == len(self.layers) - 1 :
        INDENT
            i = - 1
        DEDENT
        layer.draw(i)
    DEDENT
    pyplot.axis('scaled')
    pyplot.axis('off')
    pyplot.title('Neural Network architecture', fontsize = 15)
    pyplot.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_52_59
29888233_37366154_97_102
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    widest_layer = max(self.neural_network)
    network = NeuralNetwork(widest_layer)
    for l in self.neural_network :
    INDENT
        network.add_layer(l)
    DEDENT
    network.draw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_68_73
29888233_33720100_56_66
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()
DEDENT
----------------------------------------

def draw(self) :
INDENT
    for this_layer_neuron_index in range(len(self.neurons)) :
    INDENT
        neuron = self.neurons [this_layer_neuron_index]
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron_index in range(len(self.previous_layer.neurons)) :
            INDENT
                previous_layer_neuron = self.previous_layer.neurons [previous_layer_neuron_index]
                weight = self.previous_layer.weights [this_layer_neuron_index, previous_layer_neuron_index]
                self.__line_between_two_neurons(neuron, previous_layer_neuron, weight)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_68_73
29888233_33720100_75_81
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()
DEDENT
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_68_73
29888233_37366154_56_70
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()
DEDENT
----------------------------------------

def draw(self, layerType = 0) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw(self.neuron_radius)
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)
            DEDENT
        DEDENT
    DEDENT
    x_text = self.number_of_neurons_in_widest_layer * self.horizontal_distance_between_neurons
    if layerType == 0 :
    INDENT
        pyplot.text(x_text, self.y, 'Input Layer', fontsize = 12)
    DEDENT
    elif layerType == - 1 :
    INDENT
        pyplot.text(x_text, self.y, 'Output Layer', fontsize = 12)
    DEDENT
    else :
    INDENT
        pyplot.text(x_text, self.y, 'Hidden Layer ' + str(layerType), fontsize = 12)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_68_73
29888233_37366154_81_92
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()
DEDENT
----------------------------------------

def draw(self) :
INDENT
    pyplot.figure()
    for i in range(len(self.layers)) :
    INDENT
        layer = self.layers [i]
        if i == len(self.layers) - 1 :
        INDENT
            i = - 1
        DEDENT
        layer.draw(i)
    DEDENT
    pyplot.axis('scaled')
    pyplot.axis('off')
    pyplot.title('Neural Network architecture', fontsize = 15)
    pyplot.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_31559494_68_73
29888233_37366154_97_102
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()
DEDENT
----------------------------------------

def draw(self) :
INDENT
    widest_layer = max(self.neural_network)
    network = NeuralNetwork(widest_layer)
    for l in self.neural_network :
    INDENT
        network.add_layer(l)
    DEDENT
    network.draw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_33720100_56_66
29888233_33720100_75_81
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for this_layer_neuron_index in range(len(self.neurons)) :
    INDENT
        neuron = self.neurons [this_layer_neuron_index]
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron_index in range(len(self.previous_layer.neurons)) :
            INDENT
                previous_layer_neuron = self.previous_layer.neurons [previous_layer_neuron_index]
                weight = self.previous_layer.weights [this_layer_neuron_index, previous_layer_neuron_index]
                self.__line_between_two_neurons(neuron, previous_layer_neuron, weight)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_33720100_56_66
29888233_37366154_56_70
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for this_layer_neuron_index in range(len(self.neurons)) :
    INDENT
        neuron = self.neurons [this_layer_neuron_index]
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron_index in range(len(self.previous_layer.neurons)) :
            INDENT
                previous_layer_neuron = self.previous_layer.neurons [previous_layer_neuron_index]
                weight = self.previous_layer.weights [this_layer_neuron_index, previous_layer_neuron_index]
                self.__line_between_two_neurons(neuron, previous_layer_neuron, weight)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self, layerType = 0) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw(self.neuron_radius)
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)
            DEDENT
        DEDENT
    DEDENT
    x_text = self.number_of_neurons_in_widest_layer * self.horizontal_distance_between_neurons
    if layerType == 0 :
    INDENT
        pyplot.text(x_text, self.y, 'Input Layer', fontsize = 12)
    DEDENT
    elif layerType == - 1 :
    INDENT
        pyplot.text(x_text, self.y, 'Output Layer', fontsize = 12)
    DEDENT
    else :
    INDENT
        pyplot.text(x_text, self.y, 'Hidden Layer ' + str(layerType), fontsize = 12)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_33720100_56_66
29888233_37366154_81_92
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for this_layer_neuron_index in range(len(self.neurons)) :
    INDENT
        neuron = self.neurons [this_layer_neuron_index]
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron_index in range(len(self.previous_layer.neurons)) :
            INDENT
                previous_layer_neuron = self.previous_layer.neurons [previous_layer_neuron_index]
                weight = self.previous_layer.weights [this_layer_neuron_index, previous_layer_neuron_index]
                self.__line_between_two_neurons(neuron, previous_layer_neuron, weight)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    pyplot.figure()
    for i in range(len(self.layers)) :
    INDENT
        layer = self.layers [i]
        if i == len(self.layers) - 1 :
        INDENT
            i = - 1
        DEDENT
        layer.draw(i)
    DEDENT
    pyplot.axis('scaled')
    pyplot.axis('off')
    pyplot.title('Neural Network architecture', fontsize = 15)
    pyplot.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_33720100_56_66
29888233_37366154_97_102
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for this_layer_neuron_index in range(len(self.neurons)) :
    INDENT
        neuron = self.neurons [this_layer_neuron_index]
        neuron.draw()
        if self.previous_layer :
        INDENT
            for previous_layer_neuron_index in range(len(self.previous_layer.neurons)) :
            INDENT
                previous_layer_neuron = self.previous_layer.neurons [previous_layer_neuron_index]
                weight = self.previous_layer.weights [this_layer_neuron_index, previous_layer_neuron_index]
                self.__line_between_two_neurons(neuron, previous_layer_neuron, weight)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    widest_layer = max(self.neural_network)
    network = NeuralNetwork(widest_layer)
    for l in self.neural_network :
    INDENT
        network.add_layer(l)
    DEDENT
    network.draw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_33720100_75_81
29888233_37366154_56_70
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()

DEDENT
----------------------------------------

def draw(self, layerType = 0) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw(self.neuron_radius)
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)
            DEDENT
        DEDENT
    DEDENT
    x_text = self.number_of_neurons_in_widest_layer * self.horizontal_distance_between_neurons
    if layerType == 0 :
    INDENT
        pyplot.text(x_text, self.y, 'Input Layer', fontsize = 12)
    DEDENT
    elif layerType == - 1 :
    INDENT
        pyplot.text(x_text, self.y, 'Output Layer', fontsize = 12)
    DEDENT
    else :
    INDENT
        pyplot.text(x_text, self.y, 'Hidden Layer ' + str(layerType), fontsize = 12)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_33720100_75_81
29888233_37366154_81_92
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()

DEDENT
----------------------------------------

def draw(self) :
INDENT
    pyplot.figure()
    for i in range(len(self.layers)) :
    INDENT
        layer = self.layers [i]
        if i == len(self.layers) - 1 :
        INDENT
            i = - 1
        DEDENT
        layer.draw(i)
    DEDENT
    pyplot.axis('scaled')
    pyplot.axis('off')
    pyplot.title('Neural Network architecture', fontsize = 15)
    pyplot.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_33720100_75_81
29888233_37366154_97_102
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    for layer in self.layers :
    INDENT
        layer.draw()
    DEDENT
    pyplot.axis('scaled')
    pyplot.show()

DEDENT
----------------------------------------

def draw(self) :
INDENT
    widest_layer = max(self.neural_network)
    network = NeuralNetwork(widest_layer)
    for l in self.neural_network :
    INDENT
        network.add_layer(l)
    DEDENT
    network.draw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_37366154_56_70
29888233_37366154_81_92
Title: How to visualize a neural network 
----------------------------------------

def draw(self, layerType = 0) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw(self.neuron_radius)
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)
            DEDENT
        DEDENT
    DEDENT
    x_text = self.number_of_neurons_in_widest_layer * self.horizontal_distance_between_neurons
    if layerType == 0 :
    INDENT
        pyplot.text(x_text, self.y, 'Input Layer', fontsize = 12)
    DEDENT
    elif layerType == - 1 :
    INDENT
        pyplot.text(x_text, self.y, 'Output Layer', fontsize = 12)
    DEDENT
    else :
    INDENT
        pyplot.text(x_text, self.y, 'Hidden Layer ' + str(layerType), fontsize = 12)
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    pyplot.figure()
    for i in range(len(self.layers)) :
    INDENT
        layer = self.layers [i]
        if i == len(self.layers) - 1 :
        INDENT
            i = - 1
        DEDENT
        layer.draw(i)
    DEDENT
    pyplot.axis('scaled')
    pyplot.axis('off')
    pyplot.title('Neural Network architecture', fontsize = 15)
    pyplot.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_37366154_56_70
29888233_37366154_97_102
Title: How to visualize a neural network 
----------------------------------------

def draw(self, layerType = 0) :
INDENT
    for neuron in self.neurons :
    INDENT
        neuron.draw(self.neuron_radius)
        if self.previous_layer :
        INDENT
            for previous_layer_neuron in self.previous_layer.neurons :
            INDENT
                self.__line_between_two_neurons(neuron, previous_layer_neuron)
            DEDENT
        DEDENT
    DEDENT
    x_text = self.number_of_neurons_in_widest_layer * self.horizontal_distance_between_neurons
    if layerType == 0 :
    INDENT
        pyplot.text(x_text, self.y, 'Input Layer', fontsize = 12)
    DEDENT
    elif layerType == - 1 :
    INDENT
        pyplot.text(x_text, self.y, 'Output Layer', fontsize = 12)
    DEDENT
    else :
    INDENT
        pyplot.text(x_text, self.y, 'Hidden Layer ' + str(layerType), fontsize = 12)
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    widest_layer = max(self.neural_network)
    network = NeuralNetwork(widest_layer)
    for l in self.neural_network :
    INDENT
        network.add_layer(l)
    DEDENT
    network.draw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29888233_37366154_81_92
29888233_37366154_97_102
Title: How to visualize a neural network 
----------------------------------------

def draw(self) :
INDENT
    pyplot.figure()
    for i in range(len(self.layers)) :
    INDENT
        layer = self.layers [i]
        if i == len(self.layers) - 1 :
        INDENT
            i = - 1
        DEDENT
        layer.draw(i)
    DEDENT
    pyplot.axis('scaled')
    pyplot.axis('off')
    pyplot.title('Neural Network architecture', fontsize = 15)
    pyplot.show()
DEDENT
----------------------------------------

def draw(self) :
INDENT
    widest_layer = max(self.neural_network)
    network = NeuralNetwork(widest_layer)
    for l in self.neural_network :
    INDENT
        network.add_layer(l)
    DEDENT
    network.draw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29899504_29900368_1_22
29899504_29904095_1_42
Title: Delete a string in a dictionary after it's shown 
----------------------------------------

def German() :
INDENT
    import random
    a_q = {'Berlin' : 'What is east capital city for German?',
        'Bonn' : 'What is west capital city for German?',
        'Michael Schumacher' : 'What is a famous formula one driver?',
        'Albert Einstein' : 'He was one of the smartest one.'}
    samp = random.sample(a_q.items(), 3)
    qs = [v for _, v in samp]
    ans = [k for k, _ in samp]
    A, B, C = ans
    d = {"A" : A, "B" : B, "C" : C}
    for a, q in zip(ans, qs) :
    INDENT
        print 'Question: {}'.format(q)
        print '\nA. {} \nB. {} \nC. {}'.format(A, B, C)
        answer = raw_input('What is the right answer? ')
        if d [answer] == a :
        INDENT
            print ("That is correct")
        DEDENT
        else :
        INDENT
            print ("Sorry that is incorrect")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def German() :
INDENT
    import random
    a_q = {'Berlin' : 'What is east capital city for German?',
        'Bonn' : 'What is west capital city for German?',
        'Michael Schumacher' : 'What is a famous formula one driver?',
        'Albert Einstein' : 'He was one of the smartest one.',
        'The Berlin Wall' : 'What was the wall called that separated the country?',
        'Boris Becker' : 'He was a good tennis player he won two wimbildom titles?',
        '2006' : 'What year was the FIFA World Cup held in Germany?',
        '3' : 'How many world cups does Germany have?',
        'Yodeling' : 'What is one of the tradition in German?',
        '9 months' : 'How long does Zugspitze winter last for?'}
    q = [x for x in random.sample(a_q, len(a_q))]
    i = 0
    while i < len(q) :
    INDENT

        correctanswer = a_q [q [i]]
        print 'Question: ', correctanswer
        c = random.sample(a_q, 3)
        while c.count(q [i]) ! = 1 :
        INDENT
            c = random.sample(a_q, 3)
        DEDENT
        key1, key2, key3 = c
        print '\nA. %s \nB. %s \nC. %s' % (key1, key2, key3)
        A, B, C = a_q [key1], a_q [key2], a_q [key3]
        answer = raw_input('What is the right answer? ')
        while answer not in 'ABCD' :
        INDENT
            print "That is not a valid selection.\n"
            answer = raw_input('What is the right answer? ')
        DEDENT
        if answer == 'A' and A == correctanswer :
        INDENT
            print "That's correct!"
        DEDENT
        elif answer == 'B' and B == correctanswer :
        INDENT
            print "That's correct!"
        DEDENT
        elif answer == 'C' and C == correctanswer :
        INDENT
            print "That's correct!"
        DEDENT
        else :
        INDENT
            print "I'm sorry, that is incorrect"
        DEDENT
        i += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29919254_29933566_142_150
29919254_29933566_90_130
Title: Simulating sub packages using Python import hook 
----------------------------------------

def load_module(self, fullname) :
INDENT
    import imp
    name_parts = self.ns_splitter.cut(fullname)
    for (ns, fp, filename, options) in ModuleImportUtility.find_modules(self.namespace, name_parts,
        self.root_path) :
    INDENT
        if ns not in sys.modules :
        INDENT
            sys.modules [ns] = imp.load_module(ns, fp, filename, options)
        DEDENT
    DEDENT
    return sys.modules [fullname]
DEDENT
----------------------------------------

def load_module(self, fullname) :
INDENT
    import sys
    import imp
    class FakePackage(object) :
    INDENT
        def __init__(self, path) :
        INDENT
            self.__path__ = path

        DEDENT
    DEDENT
    if fullname in sys.modules :
    INDENT
        return sys.modules [fullname]

    DEDENT
    m = None
    try :
    INDENT
        m = FakePackage(None)
        parts = fullname.split('.')
        for i, p in enumerate(parts, 1) :
        INDENT
            ns = '.'.join(parts [: i])
            if ns in sys.modules :
            INDENT
                m = sys.modules [ns]
            DEDENT
            else :
            INDENT
                if not hasattr(m, '__path__') :
                INDENT
                    raise ImportError()
                DEDENT
                fp, filename, options = imp.find_module(p, m.__path__)
                m = imp.load_module(p, fp, filename, options)
                sys.modules [ns] = m
            DEDENT
        DEDENT
    DEDENT
    except ImportError :
    INDENT
        m = imp.new_module(fullname)
        m.__name__ = fullname
        m.__path__ = [fullname]
        m.__loader__ = self
        m.__file__ = '<dummy package "%s"><![CDATA[' % fullname
        m.__package__ = ModuleImportUtility.parent_name(fullname)
    DEDENT
    sys.modules [fullname] = m
    return m

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29923827_29927200_115_131
29923827_29927200_149_165
Title: Extract cow number from image 
----------------------------------------

def __init__(self) :
INDENT
    gtk.Table.__init__(self)
    self.attach(gtk.Label("X"), 1, 2, 0, 1, yoptions = gtk.FILL)
    self.attach(gtk.Label("Y"), 2, 3, 0, 1, yoptions = gtk.FILL)
    self.attach(gtk.Label("Top left:"), 0, 1, 1, 2, yoptions = gtk.FILL)
    self.attach(gtk.Label("Bottom right:"), 0, 1, 2, 3, yoptions = gtk.FILL)
    self.entries = {}
    for coord in (("x0", 1, 2, 1, 2), ("y0", 2, 3, 1, 2),
        ("x1", 1, 2, 2, 3), ("y1", 2, 3, 2, 3)) :
    INDENT
        self.entries [coord [0]] = gtk.Entry()
        self.entries [coord [0]].set_width_chars(6)
        self.attach(self.entries [coord [0]],
            coord [1], coord [2], coord [3], coord [4],
            yoptions = gtk.FILL)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, status, task = None) :
INDENT
    gtk.ScrolledWindow.__init__(self)
    self.task = task
    self.status = status
    self.drawing = False
    self.prev_rect = None
    self.viewport = gtk.Viewport()
    self.viewport.connect("button-press-event", self.on_button_pressed)
    self.viewport.connect("button-release-event", self.on_button_released)
    self.viewport.set_events(gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_RELEASE_MASK)
    self.img = gtk.Image()
    self.viewport.add(self.img)
    self.add(self.viewport)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29923827_29927200_115_131
29923827_29927200_192_215
Title: Extract cow number from image 
----------------------------------------

def __init__(self) :
INDENT
    gtk.Table.__init__(self)
    self.attach(gtk.Label("X"), 1, 2, 0, 1, yoptions = gtk.FILL)
    self.attach(gtk.Label("Y"), 2, 3, 0, 1, yoptions = gtk.FILL)
    self.attach(gtk.Label("Top left:"), 0, 1, 1, 2, yoptions = gtk.FILL)
    self.attach(gtk.Label("Bottom right:"), 0, 1, 2, 3, yoptions = gtk.FILL)
    self.entries = {}
    for coord in (("x0", 1, 2, 1, 2), ("y0", 2, 3, 1, 2),
        ("x1", 1, 2, 2, 3), ("y1", 2, 3, 2, 3)) :
    INDENT
        self.entries [coord [0]] = gtk.Entry()
        self.entries [coord [0]].set_width_chars(6)
        self.attach(self.entries [coord [0]],
            coord [1], coord [2], coord [3], coord [4],
            yoptions = gtk.FILL)
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    gtk.Window.__init__(self)
    self.connect("delete-event", self.on_delete_event)
    self.set_size_request(600, 300)
    grid = gtk.Table()

    files = FileSelector(self.update_image)
    grid.attach(files, 0, 1, 0, 1,
        yoptions = gtk.FILL | gtk.EXPAND, xoptions = gtk.FILL)

    self.status = Status()
    grid.attach(self.status, 0, 1, 1, 2,
        yoptions = gtk.FILL, xoptions = gtk.FILL)

    self.viewer = ImageViewer(self.status, RecognizeDigits)
    grid.attach(self.viewer, 1, 2, 0, 2)
    self.add(grid)
    self.show_all()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29923827_29927200_115_131
29923827_29927200_76_96
Title: Extract cow number from image 
----------------------------------------

def __init__(self) :
INDENT
    gtk.Table.__init__(self)
    self.attach(gtk.Label("X"), 1, 2, 0, 1, yoptions = gtk.FILL)
    self.attach(gtk.Label("Y"), 2, 3, 0, 1, yoptions = gtk.FILL)
    self.attach(gtk.Label("Top left:"), 0, 1, 1, 2, yoptions = gtk.FILL)
    self.attach(gtk.Label("Bottom right:"), 0, 1, 2, 3, yoptions = gtk.FILL)
    self.entries = {}
    for coord in (("x0", 1, 2, 1, 2), ("y0", 2, 3, 1, 2),
        ("x1", 1, 2, 2, 3), ("y1", 2, 3, 2, 3)) :
    INDENT
        self.entries [coord [0]] = gtk.Entry()
        self.entries [coord [0]].set_width_chars(6)
        self.attach(self.entries [coord [0]],
            coord [1], coord [2], coord [3], coord [4],
            yoptions = gtk.FILL)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, image_viewer) :
INDENT
    gtk.VBox.__init__(self)
    self.image_viewer = image_viewer
    fc = gtk.FileChooserButton('Select a folder')
    fc.set_action(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
    fc.connect("selection-changed", self.on_file_set)
    self.pack_start(fc, expand = False, fill = True)
    self.tstore = gtk.ListStore(str)
    self.tview = gtk.TreeView(self.tstore)
    self.tsel = self.tview.get_selection()
    self.tsel.connect("changed", self.on_selection_changed)
    renderer = gtk.CellRendererText()
    col = gtk.TreeViewColumn(None, renderer, text = 0)
    self.tview.append_column(col)
    scrw = gtk.ScrolledWindow()
    scrw.add(self.tview)
    self.pack_start(scrw, expand = True, fill = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29923827_29927200_149_165
29923827_29927200_192_215
Title: Extract cow number from image 
----------------------------------------

def __init__(self, status, task = None) :
INDENT
    gtk.ScrolledWindow.__init__(self)
    self.task = task
    self.status = status
    self.drawing = False
    self.prev_rect = None
    self.viewport = gtk.Viewport()
    self.viewport.connect("button-press-event", self.on_button_pressed)
    self.viewport.connect("button-release-event", self.on_button_released)
    self.viewport.set_events(gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_RELEASE_MASK)
    self.img = gtk.Image()
    self.viewport.add(self.img)
    self.add(self.viewport)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    gtk.Window.__init__(self)
    self.connect("delete-event", self.on_delete_event)
    self.set_size_request(600, 300)
    grid = gtk.Table()

    files = FileSelector(self.update_image)
    grid.attach(files, 0, 1, 0, 1,
        yoptions = gtk.FILL | gtk.EXPAND, xoptions = gtk.FILL)

    self.status = Status()
    grid.attach(self.status, 0, 1, 1, 2,
        yoptions = gtk.FILL, xoptions = gtk.FILL)

    self.viewer = ImageViewer(self.status, RecognizeDigits)
    grid.attach(self.viewer, 1, 2, 0, 2)
    self.add(grid)
    self.show_all()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29923827_29927200_149_165
29923827_29927200_76_96
Title: Extract cow number from image 
----------------------------------------

def __init__(self, status, task = None) :
INDENT
    gtk.ScrolledWindow.__init__(self)
    self.task = task
    self.status = status
    self.drawing = False
    self.prev_rect = None
    self.viewport = gtk.Viewport()
    self.viewport.connect("button-press-event", self.on_button_pressed)
    self.viewport.connect("button-release-event", self.on_button_released)
    self.viewport.set_events(gtk.gdk.BUTTON_PRESS_MASK | gtk.gdk.BUTTON_RELEASE_MASK)
    self.img = gtk.Image()
    self.viewport.add(self.img)
    self.add(self.viewport)
DEDENT
----------------------------------------

def __init__(self, image_viewer) :
INDENT
    gtk.VBox.__init__(self)
    self.image_viewer = image_viewer
    fc = gtk.FileChooserButton('Select a folder')
    fc.set_action(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
    fc.connect("selection-changed", self.on_file_set)
    self.pack_start(fc, expand = False, fill = True)
    self.tstore = gtk.ListStore(str)
    self.tview = gtk.TreeView(self.tstore)
    self.tsel = self.tview.get_selection()
    self.tsel.connect("changed", self.on_selection_changed)
    renderer = gtk.CellRendererText()
    col = gtk.TreeViewColumn(None, renderer, text = 0)
    self.tview.append_column(col)
    scrw = gtk.ScrolledWindow()
    scrw.add(self.tview)
    self.pack_start(scrw, expand = True, fill = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29923827_29927200_192_215
29923827_29927200_76_96
Title: Extract cow number from image 
----------------------------------------

def __init__(self) :
INDENT
    gtk.Window.__init__(self)
    self.connect("delete-event", self.on_delete_event)
    self.set_size_request(600, 300)
    grid = gtk.Table()

    files = FileSelector(self.update_image)
    grid.attach(files, 0, 1, 0, 1,
        yoptions = gtk.FILL | gtk.EXPAND, xoptions = gtk.FILL)

    self.status = Status()
    grid.attach(self.status, 0, 1, 1, 2,
        yoptions = gtk.FILL, xoptions = gtk.FILL)

    self.viewer = ImageViewer(self.status, RecognizeDigits)
    grid.attach(self.viewer, 1, 2, 0, 2)
    self.add(grid)
    self.show_all()
DEDENT
----------------------------------------

def __init__(self, image_viewer) :
INDENT
    gtk.VBox.__init__(self)
    self.image_viewer = image_viewer
    fc = gtk.FileChooserButton('Select a folder')
    fc.set_action(gtk.FILE_CHOOSER_ACTION_SELECT_FOLDER)
    fc.connect("selection-changed", self.on_file_set)
    self.pack_start(fc, expand = False, fill = True)
    self.tstore = gtk.ListStore(str)
    self.tview = gtk.TreeView(self.tstore)
    self.tsel = self.tview.get_selection()
    self.tsel.connect("changed", self.on_selection_changed)
    renderer = gtk.CellRendererText()
    col = gtk.TreeViewColumn(None, renderer, text = 0)
    self.tview.append_column(col)
    scrw = gtk.ScrolledWindow()
    scrw.add(self.tview)
    self.pack_start(scrw, expand = True, fill = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29925662_29928736_3_10
29925662_29930529_1_11
Title: Numba's jit fails to compile function that has another function as input 
----------------------------------------

def solve_my_ODE(res, x0, T, dt) :
INDENT
    res [0] = x0
    noiter = int(T / dt)
    for i in range(noiter - 1) :
    INDENT
        res [i + 1] = res [i] + dt * f(res [i], i * dt)
        if res [i + 1] > = 2 :
        INDENT
            res [i + 1] -= 2
        DEDENT
    DEDENT
    return res
DEDENT
----------------------------------------

def solve_my_ODE(res, fdot, x0, T, dt) :
INDENT
    noiter = int(T / dt)
    dt = T / noiter
    res = zeros(noiter + 1)
    res [0] = x0
    for i in range(noiter) :
    INDENT
        res [i + 1] = res [i] + dt * fdot(res [i], i * dt)
        if res [i + 1] > = 2 :
        INDENT
            h = (2 - res [i]) / (res [i + 1] - res [i])
            res [i + 1] = 0 + (1 - h) * dt * fdot(0, (i + h) * dt)
        DEDENT
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29926003_29933617_64_69
29926003_29933617_78_83
Title: "Record where files are opened to debug ""ResourceWarning: unclosed file""" 
----------------------------------------

def __init__(self, * args, ** kw) :
INDENT
    _FileIO.__init__(self, * args, ** kw)
    tb = tracemalloc.get_object_traceback(self)
    if tb is None :
    INDENT
        raise RuntimeError("tracemalloc is disabled")
    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kw) :
INDENT
    _socket.__init__(self, * args, ** kw)
    tb = tracemalloc.get_object_traceback(self)
    if tb is None :
    INDENT
        raise RuntimeError("tracemalloc is disabled")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29943938_29945200_3_15
29943938_29968913_19_36
Title: wxpython: small square panel in corner 
----------------------------------------

def __init__(self, parent, id, title) :
INDENT
    wx.Frame.__init__(self, parent, id, title, size = (250, 250))
    panel1 = wx.Panel(self, - 1)
    panel1.SetTransparent(100)
    panel2 = wx.Panel(panel1, - 1, pos = (200, 180), size = (40, 40))
    panel2.SetBackgroundColour('gray')
    s = wx.BoxSizer(wx.HORIZONTAL)
    s.Add(panel1, 1, wx.ALIGN_RIGHT | wx.ALIGN_BOTTOM)
    panel1.SetSizer(s)
    sizer = wx.BoxSizer(wx.HORIZONTAL)
    sizer.Add(panel2, 1, wx.EXPAND)
    panel2.SetSizer(sizer)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    top_sizer = wx.BoxSizer(wx.VERTICAL)
    h_sizer = wx.BoxSizer(wx.HORIZONTAL)
    top_sizer.AddStretchSpacer(prop = 1)
    mini_panel = SmallPanel(self)
    h_sizer.AddStretchSpacer(prop = 1)
    h_sizer.Add(mini_panel, 0, wx.ALL, 5)
    top_sizer.Add(h_sizer, 0, wx.EXPAND)
    self.SetSizer(top_sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29944052_29944191_11_19
29944052_29944191_24_29
Title: Use database to store session instead of Cookie with Flask 
----------------------------------------

def __init__(self, initial = None, sid = None, new = False) :
INDENT
    def on_update(self) :
    INDENT
        self.modified = True
    DEDENT
    CallbackDict.__init__(self, initial, on_update)
    self.sid = sid
    self.new = new
    self.modified = False

DEDENT
----------------------------------------

def __init__(self, redis = None, prefix = 'session:') :
INDENT
    if redis is None :
    INDENT
        redis = Redis()
    DEDENT
    self.redis = redis
    self.prefix = prefix
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29951718_30215143_58_64
29951718_30215143_72_79
Title: Autobahn sending user specific and broadcast messages from external application 
----------------------------------------

def broadcast(self, msg) :
INDENT
    print ("broadcasting message '{}' ..".format(msg))
    for c in self.clients :
    INDENT
        c.sendMessage(msg.encode('utf8'))
        print ("message sent to {}".format(c.peer))
    DEDENT
DEDENT
----------------------------------------

def broadcast(self, msg) :
INDENT
    print ("broadcasting prepared message '{}' ..".format(msg))
    preparedMsg = self.prepareMessage(msg)
    for c in self.clients :
    INDENT
        c.sendPreparedMessage(preparedMsg)
        print ("prepared message sent to {}".format(c.peer))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29956883_29956937_1_11
29956883_29960991_3_13
Title: Appending data to .txt file 
----------------------------------------

def main() :
INDENT
    import random
    data = open("Random.txt", "a")
    data.write('New run\n')
    for i in range(int(input('How many random numbers?: '))) :
    INDENT
        line = str(random.randint(1, 1000))
        data.write(line + '\n')
        print (line)
    DEDENT
    data.close()
    print ('data has been written')
DEDENT
----------------------------------------

def main() :
INDENT
    with open("Random.txt", "a") as data :
    INDENT
        print('New run', file = data)
        numbers_count = int(input('How many random numbers?: '))
        for i in range(numbers_count) :
        INDENT
            line = str(random.randint(1, 1000))
            print(line, file = data)
            print (line)
        DEDENT
    DEDENT
    print ('data has been written')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29974472_29975457_14_25
29974472_29983898_16_30
Title: Difficulty animating a matplotlib graph with moviepy 
----------------------------------------

def animate(t) :
INDENT
    i = int(t)
    if i in cache :
    INDENT
        return cache [i]
    DEDENT
    xn = x + np.sin(2 * np.pi * time [i] / 10.0)
    yn = y + np.cos(2 * np.pi * time [i] / 8.0)
    p [0].set_data(xn, yn)
    cache.clear()
    cache [i] = mplfig_to_npimage(fig)
    return cache [i]
DEDENT
----------------------------------------

def animate(t) :
INDENT
    global last_i, last_frame
    i = int(t)
    if i == last_i :
    INDENT
        return last_frame
    DEDENT
    xn = x + np.sin(2 * np.pi * time [i] / 10.0)
    yn = y + np.cos(2 * np.pi * time [i] / 8.0)
    p [0].set_data(xn, yn)
    last_i = i
    last_frame = mplfig_to_npimage(fig)
    return last_frame
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29975708_29975819_1_10
29975708_29975923_1_13
Title: Python While Loop how to rerun 
----------------------------------------

def make_payment(payment_amount) :
INDENT
    if payment_amount < 20 :
    INDENT
        print ("Retry: Payment should not be less than $20")
    DEDENT
    elif payment_amount > 1000 :
    INDENT
        print ("Retry:Payment exceeds $1000")
    DEDENT
    elif payment_amount > = 20 :
    INDENT
        print ("Sucess")
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def make_payment(P) :
INDENT
    if P == - 1 :
    INDENT
        exit()
    DEDENT
    elif P < 20 :
    INDENT
        print ("Retry: Payment should not be less than $20\n")
    DEDENT
    elif P > 1000 :
    INDENT
        print ("Retry: Payment exceeds $1000\n")
    DEDENT
    elif P > = 20 :
    INDENT
        print ("Success!\n")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29978341_29978371_1_13
29978341_29978425_1_11
Title: Alternating and iterating through multiples iterators of different lengths without stopping 
----------------------------------------

def f(* args) :
INDENT
    n = len(args)
    iters = map(iter, args)
    exhausted = [False] * n
    while n > 0 :
    INDENT
        for i, it in enumerate(iters) :
        INDENT
            if not exhausted [i] :
            INDENT
                try :
                INDENT
                    yield next(it)
                DEDENT
                except StopIteration :
                INDENT
                    exhausted [i] = True
                    n -= 1
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def f(* args) :
INDENT
    args = [iter(arg) for arg in args]
    while True :
    INDENT
        yielded = False
        for arg in args :
        INDENT
            x = next(arg, None)
            if x is not None :
            INDENT
                yielded = True
                yield x
            DEDENT
        DEDENT
        if not yielded :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29979811_29980095_1_14
29979811_29980102_3_19
Title: Python iterator not working as anticipated 
----------------------------------------

def high(lst) :
INDENT
    returnlist = []
    one = None
    two = None
    for three in lst :
    INDENT
        if not one is None :
        INDENT
            if three < = two and one < = two :
            INDENT
                returnlist.append(two)
            DEDENT
        DEDENT
        one = two
        two = three
    DEDENT
    return returnlist
DEDENT
----------------------------------------

def high(it) :
INDENT
    it1, it2, it3 = tee(iter(it), 3)
    next(it2, None)
    next(it3, None); next(it3, None)
    returnlist = []
    try :
    INDENT
        while True :
        INDENT
            one = next(it1)
            two = next(it2)
            three = next(it3)
            if three < = two and one < = two :
            INDENT
                returnlist.append(two)
            DEDENT
        DEDENT
    DEDENT
    except StopIteration :
    INDENT
        pass
    DEDENT
    return returnlist
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
29996295_29996456_1_13
29996295_29997535_1_8
Title: Converting an integer number into a binary number using recursion 
----------------------------------------

def dec2bin(n, li = None) :
INDENT
    if li is None :
    INDENT
        li = list()
    DEDENT
    if n == 0 :
    INDENT
        return li [: : - 1]
    DEDENT
    else :
    INDENT
        if n % 2 == 0 :
        INDENT
            li.append(0)
        DEDENT
        else :
        INDENT
            li.append(1)
        DEDENT
        return dec2bin(n / 2, li)

    DEDENT
DEDENT
----------------------------------------

def dec2bin(n) :
INDENT
    if n == 0 :
    INDENT
        return []
    DEDENT
    else :
    INDENT
        r = dec2bin(n / / 2)
        r.append(n % 2)
        return r
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30001529_30001764_3_20
30001529_30002042_3_20
Title: Code doesn't print the last sequence in a file 
----------------------------------------

def call() :
INDENT
    with open('trial_perl.txt') as fp :
    INDENT
        docHeader = sys.stdout
        count = 0
        id = None
        for line in fp :
        INDENT
            if line.startswith("<s") :
            INDENT
                if id ! = None :
                INDENT
                    tag = '<s%s>' % id
                    docHeader.write('<s%d> %d\n' % (id, count))
                DEDENT
                count = 0
                id = int(line [2 : line.find('>')])
            DEDENT
            else :
            INDENT
                count += 1
            DEDENT
        DEDENT
        if id ! = None :
        INDENT
            tag = '<s%s>' % id
            docHeader.write('<s%d> %d\n' % (id, count))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def call() :
INDENT
    with open('stack.txt') as fp :
    INDENT
        header = [- 1]
        lines = [0]
        for line in fp :
        INDENT
            if line.startswith("<s") :
            INDENT
                header.append(header [- 1] + 1)
                lines.append(0)
            DEDENT
            else :
            INDENT
                header.append(header [- 1])
                lines.append(lines [- 1] + 1)
            DEDENT
        DEDENT
    DEDENT
    with open('result', 'w') as f :
    INDENT
        for key, group in groupby(zip(header [1 :], lines [1 :]), lambda x : x [0]) :
        INDENT
            f.write(str(("<s%d> %d\n" % max(group))))
        DEDENT
    DEDENT
    f.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30009896_30010139_1_14
30009896_30010386_1_15
Title: Working with empty lists 
----------------------------------------

def main() :
INDENT
    nums = []
    for i in range(20, 80, 7) :
    INDENT
        nums.append(i)
        mx = max(nums)
        mn = min(nums)
    DEDENT
    print "The highest number is %s " % mx
    print "The lowest number is %s " % mn
    while len(nums) ! = 5 :
    INDENT
        nums.remove(max(nums))
        nums.remove(min(nums))
    DEDENT
    nums.sort()
    nums.reverse()
    print "The middle 5 sorted high to low is %s:" % nums
DEDENT
----------------------------------------

def main() :
INDENT
    nums = []
    i = 20
    while i < 80 :
    INDENT
        nums.append(i)
        print(* nums, sep = ' ')
        i += 9
    DEDENT
    print ('The highest number is', max(nums))
    print ('The lowest number is', min(nums))
    print ('The middle 5 sorted high to low:')
    nums.reverse()
    print(* nums [1 : 6])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30012192_30012341_9_19
30012192_30012416_1_12
Title: Execute a function for a user defined number of times python 
----------------------------------------

def get_user_input(t) :
INDENT
    data = {}
    for _ in xrange(t) :
    INDENT
        name = raw_input("What is the name? ")
        bas_lat = validate("What is the latitude? ", float)
        bas_long = validate("What is the longitude? ", float)
        print "{} has a latitude and longitude of ({},{})".format(name, bas_lat, bas_long)
        data [name] = (bas_lat, bas_long)
    DEDENT
    return data

DEDENT
----------------------------------------

def get_user_input() :
INDENT
    name = raw_input("What is the name? ")
    bas_lat = float(input("What is the latitude? "))
    bas_long = float(input("What is the longitude? "))
    print "{} has a latitude of {} degrees and a longitude of {}.\n".format(
        name, bas_lat, bas_long)
    return name, bas_lat, bas_long

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30016493_30016685_21_36
30016493_30017212_10_25
Title: Averaging function isn't averaging instead it's resetting 
----------------------------------------

def determineGrade(testScore) :
INDENT
    if testScore > = 90 and testScore < = 100 :
    INDENT
        print ("Your test score grade is an A.")
    DEDENT
    elif testScore > = 80 and testScore < = 89 :
    INDENT
        print ("Your test score grade is a B.")
    DEDENT
    elif testScore > = 70 and testScore < = 79 :
    INDENT
        print ("Your test score grade is a C.")
    DEDENT
    elif testScore > = 60 and testScore < = 69 :
    INDENT
        print ("Your test score grade is a D.")
    DEDENT
    elif testScore < = 60 :
    INDENT
        print ("Your test score grade is a F.")
    DEDENT
    else :
    INDENT
        print ("That is invalid.")
    DEDENT
DEDENT
----------------------------------------

def determineGrade(score) :
INDENT
    if score > = 90 :
    INDENT
        return "A"
    DEDENT
    elif 80 < = score < = 89 :
    INDENT
        return "B"
    DEDENT
    elif 70 < = score < = 79 :
    INDENT
        return "C"
    DEDENT
    elif 60 < = score < = 69 :
    INDENT
        return "D"
    DEDENT
    elif score < 60 :
    INDENT
        return "F"
    DEDENT
    else :
    INDENT
        return "invalid"

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30020777_30020891_2_20
30020777_30021097_1_23
Title: How to compare 2 list where string matches element in alternate list 
----------------------------------------

def EntryToFieldMatch(Entry, Fields) :
INDENT
    valid = []

    st = OrderedDict.fromkeys(Fields)
    for word in Entry :
    INDENT

        spl = word.split(None, 1)
        if spl [0] in st :
        INDENT

            valid.append(word)
            del st [spl [0]]
        DEDENT
    DEDENT
    print valid
    print "-" * 50
    print st.keys()
DEDENT
----------------------------------------

def EntryToFieldMatch(Entries, Fields) :
INDENT
    valid = [entry for entry in Entries
        if any([field in entry for field in Fields])]
    invalidEntries = [entry for entry in Entries
        if not any([field in entry for field in Fields])]
    missedFields = [field for field in Fields
        if not any([field in entry for entry in Entries])]
    print 'valid entries:', valid
    print '-' * 80
    print 'invalid entries:', invalidEntries
    print '-' * 80
    print 'missed fields:', missedFields
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30023763_30045893_21_37
30023763_30045893_67_71
Title: How to make an interactive 2D grid in a window in python? 
----------------------------------------

def draw(self) :
INDENT
    if self.master ! = None :
    INDENT
        fill = Cell.FILLED_COLOR_BG
        outline = Cell.FILLED_COLOR_BORDER
        if not self.fill :
        INDENT
            fill = Cell.EMPTY_COLOR_BG
            outline = Cell.EMPTY_COLOR_BORDER
        DEDENT
        xmin = self.abs * self.size
        xmax = xmin + self.size
        ymin = self.ord * self.size
        ymax = ymin + self.size
        self.master.create_rectangle(xmin, ymin, xmax, ymax, fill = fill, outline = outline)
    DEDENT
DEDENT
----------------------------------------

def draw(self) :
INDENT
    for row in self.grid :
    INDENT
        for cell in row :
        INDENT
            cell.draw()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30023898_30024312_25_35
30023898_30024939_30_43
Title: How do I completely restart my python script from within? 
----------------------------------------

def playagain() :
INDENT
    while True :
    INDENT
        again = input("Again? Yes/No: ")
        if again == "Yes" or again == "yes" :
        INDENT
            return True
        DEDENT
        elif again == "No" or again == "no" :
        INDENT
            return False
        DEDENT
        else :
        INDENT
            print ("Nope..")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def playagain() :
INDENT
    again = input("Again? Yes/No: ")
    if again.lower() == "yes" :
    INDENT
        return True
    DEDENT
    elif again.lower() == "no" :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        return playagain()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30037326_30037835_13_21
30037326_30037842_16_26
Title: How to textually find an imported name in a module 
----------------------------------------

def visit_ImportFrom(self, node) :
INDENT
    module = node.module
    level = node.level
    names = []
    for i in node.names :
    INDENT
        names.append((i.name, i.asname))
    DEDENT
    self.imports.append(('from', level, module, names))
DEDENT
----------------------------------------

def visit_ImportFrom(self, node) :
INDENT
    print ("In ImportFrom")
    for imp in node.names :
    INDENT
        if imp.asname is not None :
        INDENT
            print ("module = {}\nname = {}\nalias = {}\nlevel = {}\n".
                format(node.module, imp.name, imp.asname, node.level))
        DEDENT
        else :
        INDENT
            print ("module = {}\nname = {}\nlevel = {}\n".
                format(node.module, imp.name, node.level))
        DEDENT
    DEDENT
    print ()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30037326_30037835_7_12
30037326_30037842_7_15
Title: How to textually find an imported name in a module 
----------------------------------------

def visit_Import(self, node) :
INDENT
    names = []
    for i in node.names :
    INDENT
        names.append((i.name, i.asname))
    DEDENT
    self.imports.append(['import', names])
DEDENT
----------------------------------------

def visit_Import(self, node) :
INDENT
    print ("In Import")
    for imp in node.names :
    INDENT
        if imp.asname is not None :
        INDENT
            print ("module name = {}, alias = {}".format(imp.name, imp.asname))
        DEDENT
        else :
        INDENT
            print ("module name = {}".format(imp.name))
        DEDENT
    DEDENT
    print ()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30050194_40686477_49_57
30050194_40686477_93_112
Title: Snake game in Python using Turtle graphics 
----------------------------------------

def __init__(self) :
INDENT
    self.headposition = [SIZE, 0]
    self.body = [Square(- SIZE, 0), Square(0, 0), Square(SIZE, 0)]
    self.nextX = 1
    self.nextY = 0
    self.crashed = False
    self.nextposition = [self.headposition [0] + SIZE * self.nextX, self.headposition [1] + SIZE * self.nextY]

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.screen = Screen()
    self.artist = Turtle(visible = False)
    self.artist.up()
    self.artist.speed("slowest")
    self.snake = Snake()
    self.food = Food(100, 0)
    self.counter = 0
    self.commandpending = False
    self.screen.tracer(0)
    self.screen.listen()
    self.screen.onkey(self.snakedown, "Down")
    self.screen.onkey(self.snakeup, "Up")
    self.screen.onkey(self.snakeleft, "Left")
    self.screen.onkey(self.snakeright, "Right")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30050194_40686477_49_57
30050194_43232273_21_61
Title: Snake game in Python using Turtle graphics 
----------------------------------------

def __init__(self) :
INDENT
    self.headposition = [SIZE, 0]
    self.body = [Square(- SIZE, 0), Square(0, 0), Square(SIZE, 0)]
    self.nextX = 1
    self.nextY = 0
    self.crashed = False
    self.nextposition = [self.headposition [0] + SIZE * self.nextX, self.headposition [1] + SIZE * self.nextY]

DEDENT
----------------------------------------

def __init__(self, Levely) :
INDENT
    self.l = Levely
    self.level = self.l.urovne [self.l.vyber]
    self.mrizka = len(self.level [0])
    self.velikost = self.l.data [self.l.vyber] [0]
    self.vtelo = 100
    self.r = self.l.data [self.l.vyber] [1]
    self.x = 0
    self.y = 0
    self.u = 0
    self.k = self.velikost
    self.c = (self.velikost / self.mrizka)
    self.poprve = 0
    self.neco = [[0, 0], 0, 0, 0]
    self.ukonceni = None
    self.aakce1 = None
    self.aakce2 = None
    self.aakce3 = None
    self.aakce4 = None
    self.s = [0, 0, 0, 0]
    self.j = []
    self.konec = 0
    self.score = 0
    self.pocet_zelenych = 0
    self.okno = Tk()
    self.platno = Canvas(self.okno, width = self.velikost, height = self.velikost, bg = "white")
    self.platno.pack()
    self.tl = Button(self.okno, text = "Restart", command = self.start)
    self.tl.pack(fill = BOTH)
    self.start()
    self.okno.bind("<Key-d>", self.akce1)
    self.okno.bind("<Key-w>", self.akce2)
    self.okno.bind("<Key-s>", self.akce3)
    self.okno.bind("<Key-a>", self.akce4)
    self.okno.bind("<Key-r>", self.start1)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30050194_40686477_49_57
30050194_43232273_7_19
Title: Snake game in Python using Turtle graphics 
----------------------------------------

def __init__(self) :
INDENT
    self.headposition = [SIZE, 0]
    self.body = [Square(- SIZE, 0), Square(0, 0), Square(SIZE, 0)]
    self.nextX = 1
    self.nextY = 0
    self.crashed = False
    self.nextposition = [self.headposition [0] + SIZE * self.nextX, self.headposition [1] + SIZE * self.nextY]

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.urovne = [
        [[0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0]],
        ]
    self.data = [[400, 13], [400, 10], [400, 13], [400, 13], [400, 13], [400, 13]]
    print "Choose from", len(self.urovne), "levels"
    self.vyber = input("Level: ")
    self.vyber -= 1
    h = Had(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30050194_40686477_93_112
30050194_43232273_21_61
Title: Snake game in Python using Turtle graphics 
----------------------------------------

def __init__(self) :
INDENT
    self.screen = Screen()
    self.artist = Turtle(visible = False)
    self.artist.up()
    self.artist.speed("slowest")
    self.snake = Snake()
    self.food = Food(100, 0)
    self.counter = 0
    self.commandpending = False
    self.screen.tracer(0)
    self.screen.listen()
    self.screen.onkey(self.snakedown, "Down")
    self.screen.onkey(self.snakeup, "Up")
    self.screen.onkey(self.snakeleft, "Left")
    self.screen.onkey(self.snakeright, "Right")
DEDENT
----------------------------------------

def __init__(self, Levely) :
INDENT
    self.l = Levely
    self.level = self.l.urovne [self.l.vyber]
    self.mrizka = len(self.level [0])
    self.velikost = self.l.data [self.l.vyber] [0]
    self.vtelo = 100
    self.r = self.l.data [self.l.vyber] [1]
    self.x = 0
    self.y = 0
    self.u = 0
    self.k = self.velikost
    self.c = (self.velikost / self.mrizka)
    self.poprve = 0
    self.neco = [[0, 0], 0, 0, 0]
    self.ukonceni = None
    self.aakce1 = None
    self.aakce2 = None
    self.aakce3 = None
    self.aakce4 = None
    self.s = [0, 0, 0, 0]
    self.j = []
    self.konec = 0
    self.score = 0
    self.pocet_zelenych = 0
    self.okno = Tk()
    self.platno = Canvas(self.okno, width = self.velikost, height = self.velikost, bg = "white")
    self.platno.pack()
    self.tl = Button(self.okno, text = "Restart", command = self.start)
    self.tl.pack(fill = BOTH)
    self.start()
    self.okno.bind("<Key-d>", self.akce1)
    self.okno.bind("<Key-w>", self.akce2)
    self.okno.bind("<Key-s>", self.akce3)
    self.okno.bind("<Key-a>", self.akce4)
    self.okno.bind("<Key-r>", self.start1)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30050194_40686477_93_112
30050194_43232273_7_19
Title: Snake game in Python using Turtle graphics 
----------------------------------------

def __init__(self) :
INDENT
    self.screen = Screen()
    self.artist = Turtle(visible = False)
    self.artist.up()
    self.artist.speed("slowest")
    self.snake = Snake()
    self.food = Food(100, 0)
    self.counter = 0
    self.commandpending = False
    self.screen.tracer(0)
    self.screen.listen()
    self.screen.onkey(self.snakedown, "Down")
    self.screen.onkey(self.snakeup, "Up")
    self.screen.onkey(self.snakeleft, "Left")
    self.screen.onkey(self.snakeright, "Right")
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.urovne = [
        [[0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0]],
        ]
    self.data = [[400, 13], [400, 10], [400, 13], [400, 13], [400, 13], [400, 13]]
    print "Choose from", len(self.urovne), "levels"
    self.vyber = input("Level: ")
    self.vyber -= 1
    h = Had(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30050194_43232273_21_61
30050194_43232273_7_19
Title: Snake game in Python using Turtle graphics 
----------------------------------------

def __init__(self, Levely) :
INDENT
    self.l = Levely
    self.level = self.l.urovne [self.l.vyber]
    self.mrizka = len(self.level [0])
    self.velikost = self.l.data [self.l.vyber] [0]
    self.vtelo = 100
    self.r = self.l.data [self.l.vyber] [1]
    self.x = 0
    self.y = 0
    self.u = 0
    self.k = self.velikost
    self.c = (self.velikost / self.mrizka)
    self.poprve = 0
    self.neco = [[0, 0], 0, 0, 0]
    self.ukonceni = None
    self.aakce1 = None
    self.aakce2 = None
    self.aakce3 = None
    self.aakce4 = None
    self.s = [0, 0, 0, 0]
    self.j = []
    self.konec = 0
    self.score = 0
    self.pocet_zelenych = 0
    self.okno = Tk()
    self.platno = Canvas(self.okno, width = self.velikost, height = self.velikost, bg = "white")
    self.platno.pack()
    self.tl = Button(self.okno, text = "Restart", command = self.start)
    self.tl.pack(fill = BOTH)
    self.start()
    self.okno.bind("<Key-d>", self.akce1)
    self.okno.bind("<Key-w>", self.akce2)
    self.okno.bind("<Key-s>", self.akce3)
    self.okno.bind("<Key-a>", self.akce4)
    self.okno.bind("<Key-r>", self.start1)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.urovne = [
        [[0, 0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 0, 1, 1, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 0, 0, 0, 1, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 1, 1, 0, 0, 1, 0, 0, 0], [1, 1, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 1, 1, 0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 0, 1, 1, 1, 1, 0, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]],
        [[0, 0, 0, 0, 0, 0, 0, 0, 0, 1], [0, 1, 1, 0, 0, 0, 0, 0, 0, 1], [0, 0, 1, 0, 0, 0, 0, 0, 1, 1], [0, 0, 1, 0, 0, 0, 1, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 0, 0, 0, 1, 1, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 0]],
        ]
    self.data = [[400, 13], [400, 10], [400, 13], [400, 13], [400, 13], [400, 13]]
    print "Choose from", len(self.urovne), "levels"
    self.vyber = input("Level: ")
    self.vyber -= 1
    h = Had(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30055830_30056970_4_15
30055830_30066766_1_11
Title: "Pythonic way to merge two overlapping lists preserving order" 
----------------------------------------

def merge(master, addition) :
INDENT
    first = addition [0]
    n = max(len(master) - len(addition), 1)
    while 1 :
    INDENT
        try :
        INDENT
            n = master.index(first, n)
        DEDENT
        except ValueError :
        INDENT
            return master + addition
        DEDENT
        if master [- n :] == addition [: n] :
        INDENT
            return master + addition [n :]
        DEDENT
        n += 1
    DEDENT
DEDENT
----------------------------------------

def merge(a, b) :
INDENT
    results = []
    while True :
    INDENT
        try :
        INDENT
            idx = b.index(a [- 1]) + 1
        DEDENT
        except ValueError :
        INDENT
            results.append(a + b)
            break
        DEDENT
        if a [- idx :] == b [: idx] :
        INDENT
            results.append(a + b [: idx])
        DEDENT
    DEDENT
    return min(results, key = len)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30059795_32395867_2_36
30059795_47295034_2_10
Title: Include list_route methods in Django REST framework's API root 
----------------------------------------

def get_api_root_view(self) :
INDENT
    api_root_dict = OrderedDict()
    list_name = self.routes [0].name
    for prefix, viewset, basename in self.registry :
    INDENT
        api_root_dict [prefix] = list_name.format(basename = basename)
    DEDENT
    class APIRoot(views.APIView) :
    INDENT
        _ignore_model_permissions = True
        def get(self, request, * args, ** kwargs) :
        INDENT
            ret = OrderedDict()
            namespace = request.resolver_match.namespace
            for key, url_name in api_root_dict.items() :
            INDENT
                if namespace :
                INDENT
                    url_name = namespace + ':' + url_name
                DEDENT
                try :
                INDENT
                    ret [key] = reverse(
                        url_name,
                        args = args,
                        kwargs = kwargs,
                        request = request,
                        format = kwargs.get('format', None))
                DEDENT
                except NoReverseMatch :
                INDENT
                    continue
                DEDENT
            DEDENT
            ret ['book-featured-list'] = '%s%s' % (ret ['books'], 'featured/')
            return Response(ret)
        DEDENT
    DEDENT
    return APIRoot.as_view()
DEDENT
----------------------------------------

def get_api_root_view(self, api_urls = None) :
INDENT
    api_root_dict = OrderedDict()
    list_name = self.routes [0].name
    for prefix, viewset, basename in self.registry :
    INDENT
        api_root_dict [prefix] = list_name.format(basename = basename)
    DEDENT
    api_root_dict ['books/featured'] = 'book-featured'
    return self.APIRootView.as_view(api_root_dict = api_root_dict)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30061421_30061610_16_29
30061421_30062033_14_22
Title: Change reference to function in run-time in Python 
----------------------------------------

def patch(self, func) :
INDENT
    def newfunc() :
    INDENT
        global now
        tmp = now
        now = self.now
        func()
        now = tmp
    DEDENT
    self.func = newfunc

DEDENT
----------------------------------------

def patch(self, func) :
INDENT
    def wrapper(* args, ** kw) :
    INDENT
        globalcopy = globals().copy()
        globalcopy ['now'] = self.now
        newfunc = types.FunctionType(func.__code__, globalcopy, func.__name__)
        return newfunc(* args, ** kw)
    DEDENT
    globals() [func.__name__] = wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3010381_3010522_1_19
3010381_3010623_1_16
Title: Can you dynamically combine multiple conditional functions into one in Python? 
----------------------------------------

def combining_function(max_a, min_a) :
INDENT
    constants = {}
    checks = []
    if max_a is not None :
    INDENT
        constants ['max_a'] = max_a
        checks.append('x.a < max_a')
    DEDENT
    if min_a is not None :
    INDENT
        constants ['min_a'] = min_a
        checks.append('x.a > min_a')
    DEDENT
    if not checks :
    INDENT
        return lambda x : True
    DEDENT
    else :
    INDENT
        func = 'def check (x): return (%s)' % ') and ('.join(checks)
        exec func in constants, constants
        return constants ['check']
    DEDENT
DEDENT
----------------------------------------

def combining_function(min_a, max_a, min_b, max_b) :
INDENT
    conditions = []
    for name, value in locals().items() :
    INDENT
        if value is None :
        INDENT
            continue
        DEDENT
        kind, sep, attr = name.partition("_")
        op = {"min" : "><![CDATA[", "max" : "<"}.get(kind, None)
        if op is None :
        INDENT
            continue
        DEDENT
        conditions.append("x.%(attr)s %(op)s %(value)r" % dict(
                attr = attr, op = op, value = value))
    DEDENT
    if conditions :
    INDENT
        return eval("lambda x: " + " and ".join(conditions), {})
    DEDENT
    else :
    INDENT
        return lambda x : True
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30140193_30140324_1_21
30140193_30141276_1_16
Title: Python- Reading and Appending a File 
----------------------------------------

def Char_Name(self, name) :
INDENT
    string1 = str(name).lower()
    unacceptable_names = open("C://Users//Documents//Unacceptable_Names.txt", "r")
    unacceptable_names2 = open("C://Users//Documents//Unacceptable_Names.txt", "a")
    names_list = []
    for line in unacceptable_names.readlines() :
    INDENT
        for i in line.split(",") :
        INDENT
            names_list.append(i.strip())
        DEDENT
    DEDENT
    if name.isalpha() == False :
    INDENT
        print ("You entered a name containing non-alphabetic characters, pease reenter a new name:")
        main()
    DEDENT
    elif len(name) > = 10 :
    INDENT
        print ("You entered a name containing 10 or more characters, pease reenter a new name:")
        main()
    DEDENT
    elif string1 in names_list :
    INDENT
        print ("You entered a name containing bad words or a name already in use! Try again.")
        main()
    DEDENT
    else :
    INDENT
        unacceptable_names2.write(name + ',')
        unacceptable_names2.close()
        self.character_name = name
    DEDENT
DEDENT
----------------------------------------

def Char_Name(self) :
INDENT
    with open("C://Users//Documents//Unacceptable_Names.txt", "a+") as f :
    INDENT
        unacceptable_names = set(line.rstrip() for line in f)
    DEDENT
    while True :
    INDENT
        name = input("Please enter your username")
        _name = name.lower()
        if _name in unacceptable_names :
        INDENT
            print ("You entered a name containing bad words or a name already in use! Try again.")
        DEDENT
        elif _name.isalpha() :
        INDENT
            print ("You entered a name containing non-alphabetic characters, please re-enter a new name:")
        DEDENT
        elif len(name) > = 10 :
        INDENT
            print ("You entered a name containing 10 or more characters, please re-enter a new name:")
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
    f.write("{}\n".format(name))
    self.character_name = name
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30140193_30140329_1_21
30140193_30141276_1_16
Title: Python- Reading and Appending a File 
----------------------------------------

def Char_Name(self, name) :
INDENT
    string1 = str(name).lower()
    unacceptable_names = open("C://Users//Documents//Unacceptable_Names.txt", "r")
    unacceptable_names2 = open("C://Users//Documents//Unacceptable_Names.txt", "a")
    names_list = []
    for line in unacceptable_names.readlines() :
    INDENT
        for i in line.split(",") :
        INDENT
            names_list.append(i)
        DEDENT
    DEDENT
    if name.isalpha() == False :
    INDENT
        print ("You entered a name containing non-alphabetic characters, pease reenter a new name:")
        main()
    DEDENT
    elif len(name) > = 10 :
    INDENT
        print ("You entered a name containing 10 or more characters, pease reenter a new name:")
        main()
    DEDENT
    elif string1 in names_list :
    INDENT
        print ("You entered a name containing bad words or a name already in use! Try again.")
        main()
    DEDENT
    else :
    INDENT
        unacceptable_names2.write(',' + str(name))
        unacceptable_names2.close()
        self.character_name = name
    DEDENT
DEDENT
----------------------------------------

def Char_Name(self) :
INDENT
    with open("C://Users//Documents//Unacceptable_Names.txt", "a+") as f :
    INDENT
        unacceptable_names = set(line.rstrip() for line in f)
    DEDENT
    while True :
    INDENT
        name = input("Please enter your username")
        _name = name.lower()
        if _name in unacceptable_names :
        INDENT
            print ("You entered a name containing bad words or a name already in use! Try again.")
        DEDENT
        elif _name.isalpha() :
        INDENT
            print ("You entered a name containing non-alphabetic characters, please re-enter a new name:")
        DEDENT
        elif len(name) > = 10 :
        INDENT
            print ("You entered a name containing 10 or more characters, please re-enter a new name:")
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
    f.write("{}\n".format(name))
    self.character_name = name
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30143913_30144171_11_20
30143913_30144171_26_42
Title: QWidget cannot display on QMainWindow instance PyQt5 
----------------------------------------

def initUI(self) :
INDENT
    btn = [QPushButton('B', self) for i in range(6)]
    for Btn in btn :
    INDENT
        Btn.resize(30, 30)
    DEDENT
    self.resize(60, 90)
    k = 0
    for i in range(6) :
    INDENT
        btn [i].move((i % 2) * 30, k * 30)
        k += 1 if i % 2 == 1 else 0
    DEDENT
DEDENT
----------------------------------------

def initUI(self) :
INDENT
    self.resize(300, 200)
    self.statusBar().showMessage('Ready!')
    exitAction = QAction(QIcon('idea.png'), 'Exit', self)
    exitAction.setStatusTip('Exit application')
    exitAction.setShortcut('Ctrl+Q')
    exitAction.triggered.connect(qApp.quit)
    menuBar = self.menuBar()
    fileMenu = menuBar.addMenu('File')
    fileMenu.addAction(exitAction)
    t = ToolBox()
    self.setCentralWidget(t)

DEDENT
----------------------------------------
