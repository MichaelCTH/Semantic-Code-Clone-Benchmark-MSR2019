$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41803590_41807293_23_32
41803590_41807293_5_13
Title: The object cannot move 
----------------------------------------

def __init__(self, x1, y1, x2, y2, vx, vy, color, example) :
INDENT
    self.x1 = x1
    self.y1 = y1
    self.x2 = x2
    self.y2 = y2
    self.vx = vx
    self.vy = vy
    self.color = color
    self.example = example
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self)

    self.canvas = tk.Canvas(width = 600, height = 250)
    self.canvas.pack()
    self.road()
    self.crossing()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41838930_41839639_12_37
41838930_41856576_112_124
Title: Listbox update global list contents 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "My Data")
    label.grid(row = 0, column = 0, pady = (10, 15), padx = (90, 0))
    main_dataview = tk.Listbox(self)
    main_dataview.config(width = 44, borderwidth = 7)
    main_dataview.grid(row = 1, column = 0, columnspan = 2)
    for file in file_list :
    INDENT
        main_dataview.insert(tk.END, file)

    DEDENT
    self.main_dataview = main_dataview
    self.next_file_number = len(file_list) + 1

    scroll_y = tk.Scrollbar(self, orient = "vertical", command = main_dataview.yview)
    scroll_y.grid(row = 1, column = 2, sticky = "nsew")
    main_dataview.configure(yscrollcommand = scroll_y.set)

    add_button = tk.Button(self, text = 'Add file', command = self.add_file)
    add_button.grid(row = 3, column = 0)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label1 = ttk.Label(self, text = "Welcome to CODAQ", font = LARGE_FONT)
    label2 = ttk.Label(self, text = "Begin by importing your Data", font = MEDIUM_FONT)
    label1.pack(pady = 0, padx = 5)
    label2.pack(pady = 15, padx = 10)
    button = ttk.Button(self, text = "Enter CODAQ",
        command = lambda : controller.show_frame(MainPage))
    button.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41838930_41839639_12_37
41838930_41856576_127_144
Title: Listbox update global list contents 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "My Data")
    label.grid(row = 0, column = 0, pady = (10, 15), padx = (90, 0))
    main_dataview = tk.Listbox(self)
    main_dataview.config(width = 44, borderwidth = 7)
    main_dataview.grid(row = 1, column = 0, columnspan = 2)
    for file in file_list :
    INDENT
        main_dataview.insert(tk.END, file)

    DEDENT
    self.main_dataview = main_dataview
    self.next_file_number = len(file_list) + 1

    scroll_y = tk.Scrollbar(self, orient = "vertical", command = main_dataview.yview)
    scroll_y.grid(row = 1, column = 2, sticky = "nsew")
    main_dataview.configure(yscrollcommand = scroll_y.set)

    add_button = tk.Button(self, text = 'Add file', command = self.add_file)
    add_button.grid(row = 3, column = 0)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "My Data", font = LARGE_FONT)
    label.grid(row = 0, column = 0, pady = (10, 15), padx = (90, 0))
    self.main_dataview = tk.Listbox(self, font = NORM_FONT)
    self.main_dataview.config(width = 44, borderwidth = 7)
    self.main_dataview.grid(row = 1, column = 0, columnspan = 2)

    scroll_y = Scrollbar(self, orient = "vertical", command = self.main_dataview.yview)
    scroll_y.grid(row = 1, column = 2, sticky = "nsew")
    self.main_dataview.configure(yscrollcommand = scroll_y.set)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41838930_41839639_12_37
41838930_41856576_22_74
Title: Listbox update global list contents 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "My Data")
    label.grid(row = 0, column = 0, pady = (10, 15), padx = (90, 0))
    main_dataview = tk.Listbox(self)
    main_dataview.config(width = 44, borderwidth = 7)
    main_dataview.grid(row = 1, column = 0, columnspan = 2)
    for file in file_list :
    INDENT
        main_dataview.insert(tk.END, file)

    DEDENT
    self.main_dataview = main_dataview
    self.next_file_number = len(file_list) + 1

    scroll_y = tk.Scrollbar(self, orient = "vertical", command = main_dataview.yview)
    scroll_y.grid(row = 1, column = 2, sticky = "nsew")
    main_dataview.configure(yscrollcommand = scroll_y.set)

    add_button = tk.Button(self, text = 'Add file', command = self.add_file)
    add_button.grid(row = 3, column = 0)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "CODAQ")

    self.minsize(width = 1000, height = 500)
    self.file_list = []

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)

    menubar = tk.Menu(container)

    filemenu = tk.Menu(menubar, tearoff = 0)
    filemenu.add_command(label = "Import a CSV File", command = self.openfile)
    menubar.add_cascade(label = "File", menu = filemenu)

    Plot = tk.Menu(menubar, tearoff = 0)

    menubar.add_cascade(label = "Plot", menu = Plot)

    ViewData = tk.Menu(menubar, tearoff = 0)

    menubar.add_cascade(label = "View Data", menu = ViewData)
    tk.Tk.config(self, menu = menubar)
    self.frames = {}
    for F in (WelcomeScreen, MainPage) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(WelcomeScreen)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41838930_41856576_112_124
41838930_41856576_127_144
Title: Listbox update global list contents 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label1 = ttk.Label(self, text = "Welcome to CODAQ", font = LARGE_FONT)
    label2 = ttk.Label(self, text = "Begin by importing your Data", font = MEDIUM_FONT)
    label1.pack(pady = 0, padx = 5)
    label2.pack(pady = 15, padx = 10)
    button = ttk.Button(self, text = "Enter CODAQ",
        command = lambda : controller.show_frame(MainPage))
    button.pack()

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "My Data", font = LARGE_FONT)
    label.grid(row = 0, column = 0, pady = (10, 15), padx = (90, 0))
    self.main_dataview = tk.Listbox(self, font = NORM_FONT)
    self.main_dataview.config(width = 44, borderwidth = 7)
    self.main_dataview.grid(row = 1, column = 0, columnspan = 2)

    scroll_y = Scrollbar(self, orient = "vertical", command = self.main_dataview.yview)
    scroll_y.grid(row = 1, column = 2, sticky = "nsew")
    self.main_dataview.configure(yscrollcommand = scroll_y.set)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41838930_41856576_112_124
41838930_41856576_22_74
Title: Listbox update global list contents 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label1 = ttk.Label(self, text = "Welcome to CODAQ", font = LARGE_FONT)
    label2 = ttk.Label(self, text = "Begin by importing your Data", font = MEDIUM_FONT)
    label1.pack(pady = 0, padx = 5)
    label2.pack(pady = 15, padx = 10)
    button = ttk.Button(self, text = "Enter CODAQ",
        command = lambda : controller.show_frame(MainPage))
    button.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "CODAQ")

    self.minsize(width = 1000, height = 500)
    self.file_list = []

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)

    menubar = tk.Menu(container)

    filemenu = tk.Menu(menubar, tearoff = 0)
    filemenu.add_command(label = "Import a CSV File", command = self.openfile)
    menubar.add_cascade(label = "File", menu = filemenu)

    Plot = tk.Menu(menubar, tearoff = 0)

    menubar.add_cascade(label = "Plot", menu = Plot)

    ViewData = tk.Menu(menubar, tearoff = 0)

    menubar.add_cascade(label = "View Data", menu = ViewData)
    tk.Tk.config(self, menu = menubar)
    self.frames = {}
    for F in (WelcomeScreen, MainPage) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(WelcomeScreen)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41838930_41856576_127_144
41838930_41856576_22_74
Title: Listbox update global list contents 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "My Data", font = LARGE_FONT)
    label.grid(row = 0, column = 0, pady = (10, 15), padx = (90, 0))
    self.main_dataview = tk.Listbox(self, font = NORM_FONT)
    self.main_dataview.config(width = 44, borderwidth = 7)
    self.main_dataview.grid(row = 1, column = 0, columnspan = 2)

    scroll_y = Scrollbar(self, orient = "vertical", command = self.main_dataview.yview)
    scroll_y.grid(row = 1, column = 2, sticky = "nsew")
    self.main_dataview.configure(yscrollcommand = scroll_y.set)

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "CODAQ")

    self.minsize(width = 1000, height = 500)
    self.file_list = []

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)

    menubar = tk.Menu(container)

    filemenu = tk.Menu(menubar, tearoff = 0)
    filemenu.add_command(label = "Import a CSV File", command = self.openfile)
    menubar.add_cascade(label = "File", menu = filemenu)

    Plot = tk.Menu(menubar, tearoff = 0)

    menubar.add_cascade(label = "Plot", menu = Plot)

    ViewData = tk.Menu(menubar, tearoff = 0)

    menubar.add_cascade(label = "View Data", menu = ViewData)
    tk.Tk.config(self, menu = menubar)
    self.frames = {}
    for F in (WelcomeScreen, MainPage) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(WelcomeScreen)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41858080_41859117_16_24
41858080_41859117_5_13
Title: wxPyDeprecationWarning in Python 3.5 
----------------------------------------

def __init__(self, parent, label = "",
id = wx.ID_ANY,
pos = wx.DefaultPosition,
size = wx.DefaultSize, style = wx.NO_BORDER, validator = wx.DefaultValidator,
name = "LoggerUI") :
INDENT
    wx.Control.__init__(self, parent, id, pos, size, style, validator, name)

DEDENT
----------------------------------------

def __init__(self, parent, id, title, pos, size) :
INDENT
    wx.Frame.__init__(self, parent, id, title, pos, size)
    self.panel = wx.Panel(self)
    vbox = wx.BoxSizer(wx.HORIZONTAL)
    component = SvgComponent(self.panel)
    vbox.Add(component, 1, wx.EXPAND | wx.ALL, 10)
    self.panel.SetSizer(vbox)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41864281_41864581_7_29
41864281_41867685_5_22
Title: How to switch widgets visibility by request 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Dialog, self).__init__(parent)
    self.setLayout(QtGui.QVBoxLayout())
    self.widgets = {}
    for i in range(3) :
    INDENT
        row = QtGui.QHBoxLayout()
        combo = QtGui.QComboBox()
        combo.addItems(['Show LineEdit', 'Show DateEdit'])
        combo.activated [str].connect(self.activated)
        row.addWidget(combo)
        lineEdit = QtGui.QLineEdit()
        dateEdit = QtGui.QDateEdit()
        self.widgets [combo] = [lineEdit, dateEdit]
        self.changeWidget(combo.currentText(), lineEdit, dateEdit)
        row.addWidget(lineEdit)
        row.addWidget(dateEdit)
        self.layout().insertLayout(i, row)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Dialog, self).__init__(parent)
    self.setLayout(QtGui.QVBoxLayout())
    for i in range(3) :
    INDENT
        row = QtGui.QHBoxLayout()
        combo = QtGui.QComboBox()
        combo.addItems(['Show LineEdit', 'Show DateEdit'])
        combo.activated [str].connect(self.activated)
        row.addWidget(combo)
        combo.lineEdit = QtGui.QLineEdit()
        combo.dateEdit = QtGui.QDateEdit()
        row.addWidget(combo.lineEdit)
        row.addWidget(combo.dateEdit)
        self.layout().insertLayout(i, row)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41870749_42301118_1_11
41870749_42614062_1_13
Title: Determining if a string is an Isogram 
----------------------------------------

def is_isogram(word) :
INDENT
    if type(word) ! = str :
    INDENT
        raise TypeError("Argument should be a string")
    DEDENT
    if len(word) < 1 :
    INDENT
        return (word, False)
    DEDENT
    word = word.lower()
    for char in word :
    INDENT
        if word.count(char) > 1 or char not in "abcdefghijklmnopqrstuvwxyz" :
        INDENT
            return (word, False)
        DEDENT
    DEDENT
    return (word, True)
DEDENT
----------------------------------------

def is_isogram(argument) :
INDENT
    word_seen = set()
    if type(argument) ! = str :
    INDENT
        raise TypeError('Argument should be a string')
    DEDENT
    if argument == " " :
    INDENT
        return (argument, False)
    DEDENT
    argument.lower()
    argument = ''.join(argument.split())
    for letter in argument :
    INDENT
        if letter in word_seen :
        INDENT
            return (argument, False)
        DEDENT
        word_seen.add(letter)
    DEDENT
    return (argument, True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41883329_41889677_131_184
41883329_41889677_186_205
Title: Redistributing excess values in numpy 2D array 
----------------------------------------

def iteration(state, state_f) :
INDENT
    em = state > threshold
    nnz = em.sum()
    if nnz == 0 :
    INDENT
        return nnz
    DEDENT
    elif nnz < em.size * switch_to_sparse_at :
    INDENT
        ei = np.where(em.flat) [0]
        excess = state_f [ei] - threshold
        state_f [- 1] = 0
        exc_nei_sum = rec_nc [ei] * state_f [nei_ind [ei, :]].sum(axis = - 1)
        exc_nei_ind = np.unique(nei_ind [ei, :])
        if exc_nei_ind [0] == - 1 :
        INDENT
            exc_nei_ind = exc_nei_ind [1 :]
        DEDENT
        nm = exc_nei_sum ! = 0
        state_swap = state_f [exc_nei_ind]
        state_f [exc_nei_ind] = 1
        iadd_conv_ring((ei [nm], excess [nm] / exc_nei_sum [nm], sh),
            state_f)
        state_f [exc_nei_ind] *= state_swap
        iadd_conv_ring((ei [~ nm], excess [~ nm], sh), state_f)
        state_f [ei] -= excess
    DEDENT
    elif use_conv_matrix :
    INDENT
        excess = np.where(em, state - threshold, 0)
        state_f [- 1] = 0
        nei_sum = (rec_nc * state_f [nei_ind].sum(axis = - 1)).reshape(sh)
        nm = nei_sum ! = 0
        pm = em & nm
        exc_p = np.where(pm, excess, 0)
        exc_p [pm] /= nei_sum [pm]
        wei_nei_sum = iadd_conv_ring(exc_p, np.zeros_like(state_f))
        state += state * wei_nei_sum [: - 1].reshape(sh)
        fm = em & ~ nm
        exc_f = np.where(fm, excess, 0)
        iadd_conv_ring(exc_f, state_f)
        state -= excess
    DEDENT
    else :
    INDENT
        excess = np.where(em, state - threshold, 0)
        nei_sum = conv_with_ring(state)
        nm = nei_sum ! = 0
        pm = em & nm
        exc_p = np.where(pm, excess, 0)
        exc_p [pm] /= nei_sum [pm]
        spread_p = state * conv_with_ring(exc_p)

        fm = em & ~ nm
        exc_f = np.where(fm, excess * rec_8, 0)
        spread_f = conv_with_ring(exc_f)
        state += spread_p + spread_f - excess
    DEDENT
    return nnz
DEDENT
----------------------------------------

def iteration(state, state_f) :
INDENT
    em = state > threshold
    nnz = em.sum()
    if nnz == 0 :
    INDENT
        return nnz
    DEDENT
    elif nnz < em.size * switch_to_sparse_at :
    INDENT
        ei = np.where(em.flat) [0]
        excess = state_f [ei] - threshold
        iadd_conv_ring((ei, excess, sh), state_f)
        state_f [ei] -= excess
    DEDENT
    elif use_conv_matrix :
    INDENT
        excess = np.where(em, state - threshold, 0)
        iadd_conv_ring(excess, state_f)
        state -= excess
    DEDENT
    else :
    INDENT
        excess = np.where(em, state - threshold, 0)
        spread = conv_with_ring(excess * rec_8)
        state += spread - excess
    DEDENT
    return nnz
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4189630_4241079_35_42
4189630_4241079_58_70
Title: Abuse yield to avoid condition in loop 
----------------------------------------

def search_revisions(self, keys, pattern) :
INDENT
    for key in keys :
    INDENT
        rev = self.revisions [key]
        result = rev.search(pattern)
        if result :
        INDENT
            yield result
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def search_revisions(self, keys, pattern, just_one) :
INDENT
    results = []
    for key in keys :
    INDENT
        rev = self.revisions [key]
        result = rev.search(pattern)
        if result :
        INDENT
            results.extend(result)
            if just_one :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41905739_41905877_45_78
41905739_41907684_62_82
Title: How to get circular graph coordinates of a clicked position 
----------------------------------------

def main() :
INDENT
    global k
    s = turtle.Screen()

    s.colormode(255)
    tracer(False)
    reset()
    start()
    k = int(numinput("", " How many colors?"))
    colorlist = []
    for i in range(k) :
    INDENT
        colorlist.append(list(colorsys.hsv_to_rgb(i / k, 1, 255)))
    DEDENT
    print (colorlist)
    for i in range(len(colorlist)) :
    INDENT
        for j in range(len(colorlist [i])) :
        INDENT
            colorlist [i] [j] = int(colorlist [i] [j])
        DEDENT
        arch(200, 360 / k, 100, (colorlist [i]))
    DEDENT
    onkey(startover, "a")
    onscreenclick(get_number)

    done()
DEDENT
----------------------------------------

def main() :
INDENT
    screen = Screen()
    segments = int(screen.numinput('Color Wheel', 'How many colors?'))
    colorlist = [hsv_to_rgb(i / segments, 1.0, 1.0) for i in range(segments)]
    screen.tracer(False)
    arch(RADIUS, WIDTH, colorlist)
    screen.tracer(True)
    magic_marker = Turtle(visible = False)
    magic_marker.penup()
    magic_marker.sety(- FONT_SIZE / 2)
    magic_marker.write('', align = 'center', font = FONT)
    screen.onscreenclick(lambda x, y, t = magic_marker, s = segments : get_number(x, y, t, s))
    screen.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41905739_41905877_6_22
41905739_41907684_13_40
Title: How to get circular graph coordinates of a clicked position 
----------------------------------------

def arch(radius, degree, width, colour) :
INDENT
    color(colour)
    pd()
    begin_fill()
    circle(radius, degree)
    lt(90)
    fd(width)
    lt(90)
    circle(- radius + width, degree)
    lt(90)
    fd(width)
    lt(90)
    end_fill()
    pu()
    circle(radius, degree)
    pd()
DEDENT
----------------------------------------

def arch(radius, width, colorlist) :
INDENT
    ''' Creates a color wheel around position (0,0) '''
    degree = 360 / len(colorlist)
    inner_radius = radius - width
    turtle = Turtle(visible = False)
    turtle.penup()
    turtle.setx(radius)
    turtle.setheading(90)
    for color in colorlist :
    INDENT
        turtle.color(color)
        turtle.begin_fill()
        turtle.circle(radius, degree)
        position = turtle.position()
        heading = turtle.heading()
        turtle.left(90)
        turtle.forward(width)
        turtle.left(90)
        turtle.circle(- inner_radius, degree)
        turtle.end_fill()
        turtle.setposition(position)
        turtle.setheading(heading)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41912419_41912549_15_24
41912419_42205458_1_15
Title: Issue with BeautifulSoup and requests parses 
----------------------------------------

def main() :
INDENT
    base_url = 'https://m.vk.com/bageto?act=members&offset='
    total_pages = get_total_pages(get_html(base_url + "0"))
    print (total_pages)
    for i in range(50, total_pages, 50) :
    INDENT
        print (i)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    try :
    INDENT
        urll = []
        base_url = 'https://m.vk.com/bageto?act=members&offset='
        total_pages = int(get_total_pages(get_html(url)))
        for i in range(0, total_pages, 50) :
        INDENT
            url_gen = str(base_url + str(i))
            urll.append(url_gen)
        DEDENT
        pool = ThreadPool(8)
        results = pool.map(get_page_data, urll)
    DEDENT
    except KeyboardInterrupt :
    INDENT
        print ('you are stopped script yourself')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41927787_41927980_2_12
41927787_41927998_3_14
Title: Recursion not terminating in Python 
----------------------------------------

def fib(n) :
INDENT
    ni = 1
    ni_minus_1 = 0
    while ni + ni_minus_1 < n :
    INDENT
        temp = ni_minus_1
        ni_minus_1 = ni
        ni = ni + temp
    DEDENT
    if ni + ni_minus_1 == n :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------

def fib(n) :
INDENT
    if n == 0 or n == 1 : return 1
    else :
    INDENT
        temp1 = 1
        temp = 2
        temp3 = 0
        for z in range(n - 2) :
        INDENT
            temp3 = temp
            temp += temp1
            temp1 = temp3
        DEDENT
        return temp
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41932287_41932417_3_20
41932287_41932494_1_27
Title: How can I create a loop for these if statements? 
----------------------------------------

def my_function(my_list_of_words) :
INDENT
    _digits = re.compile('\d')
    to_return = []
    for i, p in enumerate(my_list_of_words) :
    INDENT
        new_list = []
        if 'start' in p and i + 1 < len(my_list_of_words) :
        INDENT
            if bool(_digits.search(my_list_of_words [i + 1])) :
            INDENT
                new_list.append(p)
                for j in xrange(1, len(my_list_of_words) - i) :
                INDENT
                    if bool(_digits.search(my_list_of_words [i + j])) :
                    INDENT
                        new_list.append(my_list_of_words [i + j])
                    DEDENT
                    else :
                    INDENT
                        break
                    DEDENT
                DEDENT
                to_return.append(" ".join(new_list))
            DEDENT
        DEDENT
    DEDENT
    return to_return
DEDENT
----------------------------------------

def my_function(my_list_of_words, _digits = re.compile('\d').search) :
INDENT
    word_iter = iter(my_list_of_words)
    digit_words = None
    results = []
    try :
    INDENT
        curr = next(word_iter)
        while True :
        INDENT
            while 'start' not in curr :
            INDENT
                curr = next(word_iter)

            DEDENT
            digit_words = [curr]
            while True :
            INDENT
                curr = next(word_iter)
                if not _digits(curr) :
                INDENT
                    break
                DEDENT
                digit_words.append(curr)
            DEDENT
            results.append(' '.join(digit_words))
            digit_words = []
        DEDENT
    DEDENT
    except StopIteration :
    INDENT
        if digit_words :
        INDENT
            results.append(' '.join(digit_words))
        DEDENT
    DEDENT
    return results
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41938405_41939504_13_34
41938405_41939504_37_52
Title: python multiprocessing.Process.terminate - How to kill child processes 
----------------------------------------

def run(self) :
INDENT
    self.subprocess = subprocess.Popen(['python', '-c', 'import time; time.sleep(1000)'])
    while True :
    INDENT
        a = self.subprocess.poll()
        if a is None :
        INDENT
            time.sleep(1)
            try :
            INDENT
                if self.queue.get(0) == "exit" :
                INDENT
                    print "kill"
                    self.subprocess.kill()
                    self.subprocess.wait()
                    break
                DEDENT
                else :
                INDENT
                    pass
                DEDENT
            DEDENT
            except Empty :
            INDENT
                pass
            DEDENT
            print "run"
        DEDENT
        else :
        INDENT
            print "exiting"
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    jobs = []
    queues = []
    for _ in range(2) :
    INDENT
        q = mp.Queue()
        job = WorkerProcess(q)
        queues.append(q)
        jobs.append(job)
        job.start()

    DEDENT
    time.sleep(5)
    for q in queues :
    INDENT
        q.put("exit")
    DEDENT
    time.sleep(30)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41958910_41959196_12_19
41958910_41975814_9_17
Title: update array calling different methods in class 
----------------------------------------

def evaluation(self, array) :
INDENT
    if self.the_method == 'A' :
    INDENT

        array = [self.replace(x) if ((x > themin) & (x < themax)) else x for x in array]
    DEDENT
    return array
DEDENT
----------------------------------------

def evaluation(self, the_name) :
INDENT
    the_name = self.the_name
    the_method = self.the_method
    if the_method == 'A' :
    INDENT
        mask = np.logical_and(the_name > = themin, the_name < = themax)
        the_name [mask] = self.replace(the_name)
        return the_name
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41959308_41967164_27_34
41959308_41967164_5_19
Title: PyQt: align text left and right in a QListView 
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.view = ListView(self)
    for text in 'Aquamarine Red Green Purple Blue Yellow '.split() :
    INDENT
        self.view.addItem(text, str(16 ** len(text)))
    DEDENT
    layout = QtWidgets.QVBoxLayout(self)
    layout.addWidget(self.view)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(ListView, self).__init__(* args, ** kwargs)
    self.setModel(QtGui.QStandardItemModel(self))
    self.model().setColumnCount(2)
    self.setRootIsDecorated(False)
    self.setAllColumnsShowFocus(True)
    self.setSelectionBehavior(
        QtWidgets.QAbstractItemView.SelectRows)
    self.setHeaderHidden(True)
    self.header().setStretchLastSection(False)
    self.header().setSectionResizeMode(
        0, QtWidgets.QHeaderView.Stretch)
    self.header().setSectionResizeMode(
        1, QtWidgets.QHeaderView.ResizeToContents)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
41968892_41969052_3_17
41968892_41969127_1_9
Title: Counting consecutive numbers in a list 
----------------------------------------

def count_consec(listrand) :
INDENT
    count = 1
    consec_list = []
    for i in range(len(listrand [: - 1])) :
    INDENT
        if listrand [i] + 1 == listrand [i + 1] :
        INDENT
            count += 1
        DEDENT
        else :
        INDENT
            consec_list.append(count)
            count = 1

        DEDENT
    DEDENT
    consec_list.append(count)
    return consec_list
DEDENT
----------------------------------------

def count_consec(lst) :
INDENT
    consec = [1]
    for x, y in zip(lst, lst [1 :]) :
    INDENT
        if x == y - 1 :
        INDENT
            consec [- 1] += 1
        DEDENT
        else :
        INDENT
            consec.append(1)
        DEDENT
    DEDENT
    return consec
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42003109_42003226_1_8
42003109_42003292_1_16
Title: Each value in the node of a chain is calculated from the previous value plus the sum of the digits of the previous value 
----------------------------------------

def generate_chain(start, n) :
INDENT
    node = Node(start)
    for k in range(n) :
    INDENT
        yield node.get_data()
        node.set_next(node.get_data() + sum(int(i) for i in str(node)))
        node.set_data(node.get_next())
        value = node.get_data()
    DEDENT
DEDENT
----------------------------------------

def generate_chain(start, n) :
INDENT
    head = node = Node(start)
    for _ in range(n) :
    INDENT
        sum_of_digits = 0
        v = node.get_data()
        while v > 0 :
        INDENT
            sum_of_digits += v % 10
            v //= 10
        DEDENT
        node.set_next(Node(node.get_data() + sum_of_digits))
        node = node.get_next()
    DEDENT
    node = head
    while node :
    INDENT
        print (node.get_data())
        node = node.get_next()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42007434_42011414_11_32
42007434_42011414_40_65
Title: Slider widget for PyQtGraph 
----------------------------------------

def __init__(self, minimum, maximum, parent = None) :
INDENT
    super(Slider, self).__init__(parent = parent)
    self.verticalLayout = QVBoxLayout(self)
    self.label = QLabel(self)
    self.verticalLayout.addWidget(self.label)
    self.horizontalLayout = QHBoxLayout()
    spacerItem = QSpacerItem(0, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem)
    self.slider = QSlider(self)
    self.slider.setOrientation(Qt.Vertical)
    self.horizontalLayout.addWidget(self.slider)
    spacerItem1 = QSpacerItem(0, 20, QSizePolicy.Expanding, QSizePolicy.Minimum)
    self.horizontalLayout.addItem(spacerItem1)
    self.verticalLayout.addLayout(self.horizontalLayout)
    self.resize(self.sizeHint())
    self.minimum = minimum
    self.maximum = maximum
    self.slider.valueChanged.connect(self.setLabelValue)
    self.x = None
    self.setLabelValue(self.slider.value())
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Widget, self).__init__(parent = parent)
    self.horizontalLayout = QHBoxLayout(self)
    self.w1 = Slider(- 10, 10)
    self.horizontalLayout.addWidget(self.w1)
    self.w2 = Slider(- 1, 1)
    self.horizontalLayout.addWidget(self.w2)
    self.w3 = Slider(- 10, 10)
    self.horizontalLayout.addWidget(self.w3)
    self.w4 = Slider(- 10, 10)
    self.horizontalLayout.addWidget(self.w4)
    self.win = pg.GraphicsWindow(title = "Basic plotting examples")
    self.horizontalLayout.addWidget(self.win)
    self.p6 = self.win.addPlot(title = "My Plot")
    self.curve = self.p6.plot(pen = 'r')
    self.update()
    self.w1.slider.valueChanged.connect(self.update)
    self.w2.slider.valueChanged.connect(self.update)
    self.w3.slider.valueChanged.connect(self.update)
    self.w4.slider.valueChanged.connect(self.update)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42014711_42028549_17_25
42014711_42028549_7_11
Title: How to prevent instance variables of a parent are overwritten by child class in python? 
----------------------------------------

def drinkMe(self, tea) :
INDENT
    result = ''
    if tea == self.problem :
    INDENT
        return self.result
    DEDENT
    else :
    INDENT
        super().__init__()
        result = super().drinkMe(tea)
        self.__init__()
        return (result)
    DEDENT
DEDENT
----------------------------------------

def drinkMe(self, tea) :
INDENT
    if tea == self.problem :
    INDENT
        return self.result
    DEDENT
    else :
    INDENT
        return "fine"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42034299_42056066_15_24
42034299_42056066_44_55
Title: "Kivy rectangle redraw self.pos and self.size are (00)" 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(custButtom, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(191 / 255, 191 / 255, 191 / 255, 1)
        self.rect = Rectangle(pos = self.pos, size = self.size)

    DEDENT
    self.bind(pos = self.update_rect, size = self.update_rect)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(myGrid, self).__init__(** kwargs)
    for i in range(0, 27, 1) :
    INDENT
        IN_Labels [i] = custButtom()
        self.add_widget(IN_Labels [i])
        IN_Labels [i].xtext(str(i))

    DEDENT
    IN_Labels [14].xbackground_color(1, 0, 0, 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42041727_42041762_1_13
42041727_42041977_6_12
Title: Checking URLs with Python 
----------------------------------------

def urlcheck() :
INDENT
    for line in f :
    INDENT
        try :
        INDENT
            urllib2.urlopen(line)
            print line, "SITE IS FUNCTIONAL"
        DEDENT
        except urllib2.HTTPError, e :
        INDENT
            print line, "SITE IS NOT FUNCTIONAL"
            print (e.code)
        DEDENT
        except urllib2.URLError, e :
        INDENT
            print line, "SITE IS NOT FUNCTIONAL"
            print (e.args)
        DEDENT
        except Exception, e :
        INDENT
            print line, "Invalid URL"
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def urlcheck() :
INDENT
    for url in urls :
    INDENT
        try :
        INDENT
            urllib2.urlopen(url)
        DEDENT
        except (ValueError, urllib2.URLError) as e :
        INDENT
            print ('invalid url: {}'.format(url))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42041727_42041781_7_15
42041727_42041977_6_12
Title: Checking URLs with Python 
----------------------------------------

def urlcheck() :
INDENT
    for line in f :
    INDENT
        try :
        INDENT
            urllib2.urlopen(line)
            print "SITE IS FUNCTIONAL"
        DEDENT
        except urllib2.HTTPError, e :
        INDENT
            print (e.code)
        DEDENT
        except urllib2.URLError, e :
        INDENT
            print (e.args)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def urlcheck() :
INDENT
    for url in urls :
    INDENT
        try :
        INDENT
            urllib2.urlopen(url)
        DEDENT
        except (ValueError, urllib2.URLError) as e :
        INDENT
            print ('invalid url: {}'.format(url))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42046275_42046347_1_14
42046275_42046351_1_15
Title: Algorithm to delete a node from the middle 
----------------------------------------

def delmid(ll, n) :
INDENT
    current = ll.head
    if current == n :
    INDENT
        print ('Can\'t delete first node')
        return
    DEDENT
    while current.nextnode :
    INDENT
        if current.nextnode == n :
        INDENT
            if current.nextnode.nextnode :
            INDENT
                current.nextnode = current.nextnode.nextnode
                return
            DEDENT
            else :
            INDENT
                print ('Can\'t delete last node')
                return
            DEDENT
        DEDENT
        current = current.nextnode
    DEDENT
DEDENT
----------------------------------------

def delmid(ll, n) :
INDENT
    if ll.head == n :
    INDENT
        print ('Can\'t delete first node')
        return
    DEDENT
    if n.nextnode is None :
    INDENT
        print ('Can\'t delete last node')
        return
    DEDENT
    tmp = n.data
    n.data = n.nextnode.data
    n.nextnode.data = tmp

    n.nextnode = n.nextnode.nextnode
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42047926_42048178_102_111
42047926_42048178_153_163
Title: Not Sure Where To Update The Display - PyGame 
----------------------------------------

def draw(self) :
INDENT
    render = font.render(self.text, True, self.color)
    screen.fill((255, 255, 255))
    screen.blit(render, (self.x, self.y))
    pygame.display.update()
    time.sleep(2)

DEDENT
----------------------------------------

def draw() :
INDENT
    screen.fill((255, 255, 255))
    snake.draw()
    food.draw()

    pygame.display.update()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42056379_42056803_15_60
42056379_42057110_14_28
Title: Magic square python 
----------------------------------------

def is_magic(items) :
INDENT
    if len(set(items)) ! = 9 :
    INDENT
        return 'Invalid'

    DEDENT
    for x in range(0, 9, 3) :
    INDENT
        l = items [x : x + 3]
        if sum(l) ! = 15 :
        INDENT
            return 'Invalid'

        DEDENT
    DEDENT
    for x in range(3) :
    INDENT
        l = [items [x], items [x + 3], items [x + 6]]
        if sum(l) ! = 15 :
        INDENT
            return 'Invalid'

        DEDENT
    DEDENT
    l = [items [0], items [4], items [8]]
    if sum(l) ! = 15 :
    INDENT
        return 'Invalid'
    DEDENT
    l = [items [2], items [4], items [6]]
    if sum(l) ! = 15 :
    INDENT
        return 'Invalid'

    DEDENT
    return 'Valid'
DEDENT
----------------------------------------

def is_magic(cube) :
INDENT
    """Check if cube is magic.
    There are two conditions that must be satisfied:
    1 - There must not be any repetitions of the numbers
    2 - All vertical/horizontal/diagonal sums must be 15
    """
    if not dupe(cube) and check_sum(cube) :
    INDENT
        print ('Valid')
    DEDENT
    else :
    INDENT
        print ('Invalid')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42056379_42056803_9_14
42056379_42056908_1_7
Title: Magic square python 
----------------------------------------

def main() :
INDENT
    for line in data.split("\n") :
    INDENT

        items = list(map(int, line.split()))
        print (is_magic(items))
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    for line in open("Magic Square Input.txt") :
    INDENT
        items = line.split(" ")
        items = [int(x) for x in items]
        result = [items [0 : 3], items [3 : 6], items [6 : 9]]
        print isMagic(result)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42056379_42056803_9_14
42056379_42057110_1_13
Title: Magic square python 
----------------------------------------

def main() :
INDENT
    for line in data.split("\n") :
    INDENT

        items = list(map(int, line.split()))
        print (is_magic(items))
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    """Open the file, parse the input and check if it is a magic cube"""
    with open("Magic Square Input.txt") as f :
    INDENT
        for line in f.readlines() :
        INDENT

            numbers = line.split(" ")
            cube = [int(x) for x in numbers]
            is_magic(cube)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42056379_42056803_9_14
42056379_42057337_1_12
Title: Magic square python 
----------------------------------------

def main() :
INDENT
    for line in data.split("\n") :
    INDENT

        items = list(map(int, line.split()))
        print (is_magic(items))
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    for line in open('Magic Square Input.txt') :
    INDENT
        square = [int(n) for n in line.split()]
        if len(set(square)) ! = len(square) :
        INDENT
            print ('Invalid: Duplicates')
        DEDENT
        else :
        INDENT
            for idx in indexes :
            INDENT
                if sum(square [i] for i in idx) ! = 15 :
                INDENT
                    print ('Invalid: Sum')
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                print ('Valid')
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42056379_42056908_1_7
42056379_42057110_1_13
Title: Magic square python 
----------------------------------------

def main() :
INDENT
    for line in open("Magic Square Input.txt") :
    INDENT
        items = line.split(" ")
        items = [int(x) for x in items]
        result = [items [0 : 3], items [3 : 6], items [6 : 9]]
        print isMagic(result)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    """Open the file, parse the input and check if it is a magic cube"""
    with open("Magic Square Input.txt") as f :
    INDENT
        for line in f.readlines() :
        INDENT

            numbers = line.split(" ")
            cube = [int(x) for x in numbers]
            is_magic(cube)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42056379_42056908_1_7
42056379_42057337_1_12
Title: Magic square python 
----------------------------------------

def main() :
INDENT
    for line in open("Magic Square Input.txt") :
    INDENT
        items = line.split(" ")
        items = [int(x) for x in items]
        result = [items [0 : 3], items [3 : 6], items [6 : 9]]
        print isMagic(result)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    for line in open('Magic Square Input.txt') :
    INDENT
        square = [int(n) for n in line.split()]
        if len(set(square)) ! = len(square) :
        INDENT
            print ('Invalid: Duplicates')
        DEDENT
        else :
        INDENT
            for idx in indexes :
            INDENT
                if sum(square [i] for i in idx) ! = 15 :
                INDENT
                    print ('Invalid: Sum')
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                print ('Valid')
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42056379_42057110_1_13
42056379_42057337_1_12
Title: Magic square python 
----------------------------------------

def main() :
INDENT
    """Open the file, parse the input and check if it is a magic cube"""
    with open("Magic Square Input.txt") as f :
    INDENT
        for line in f.readlines() :
        INDENT

            numbers = line.split(" ")
            cube = [int(x) for x in numbers]
            is_magic(cube)

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    for line in open('Magic Square Input.txt') :
    INDENT
        square = [int(n) for n in line.split()]
        if len(set(square)) ! = len(square) :
        INDENT
            print ('Invalid: Duplicates')
        DEDENT
        else :
        INDENT
            for idx in indexes :
            INDENT
                if sum(square [i] for i in idx) ! = 15 :
                INDENT
                    print ('Invalid: Sum')
                    break
                DEDENT
            DEDENT
            else :
            INDENT
                print ('Valid')
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42083068_42083177_3_24
42083068_42083578_1_16
Title: "Given a list with a number of elements how can I get the number of perfect triples?" 
----------------------------------------

def solution(l) :
INDENT
    l.sort(reverse = True)

    mapping = {}

    for idx, item in enumerate(l) :
    INDENT

        divisors = set()
        for other_item in l [idx + 1 :] :
        INDENT
            if item % other_item == 0 :
            INDENT
                divisors.add(other_item)
            DEDENT
        DEDENT
        mapping [item] = divisors

    DEDENT
    count = 0
    for z, ys in sorted(mapping.items(), key = itemgetter(0), reverse = True) :
    INDENT
        for y in ys :
        INDENT
            count += len(mapping [y])
        DEDENT
    DEDENT
    return count
DEDENT
----------------------------------------

def solution(l) :
INDENT
    divs = [0] * len(l)
    for i in range(len(l)) :
    INDENT
        for j in range(i + 1, len(l)) :
        INDENT
            if l [j] % l [i] == 0 :
            INDENT
                divs [j] += 1
            DEDENT
        DEDENT
    DEDENT
    result = 0
    for i in range(len(l) - 1, 1, - 1) :
    INDENT
        for j in range(i - 1, 0, - 1) :
        INDENT
            if l [i] % l [j] == 0 :
            INDENT
                result += divs [j]
            DEDENT
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42093038_42093505_15_23
42093038_42093505_38_48
Title: Pygame trigonometry: Following the hypotenuse? 
----------------------------------------

def __init__(self, position) :
INDENT
    super(Hunter, self).__init__()
    self.image = pygame.Surface((32, 32))
    self.image.fill(pygame.Color('red'))
    self.rect = self.image.get_rect(topleft = position)
    self.position = pygame.math.Vector2(position)
    self.speed = 2
DEDENT
----------------------------------------

def __init__(self, position) :
INDENT
    super(Player, self).__init__()
    self.image = pygame.Surface((32, 32))
    self.image.fill(pygame.Color('blue'))
    self.rect = self.image.get_rect(topleft = position)
    self.position = pygame.math.Vector2(position)
    self.velocity = pygame.math.Vector2(0, 0)
    self.speed = 3
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42101214_42107453_50_59
42101214_42107453_73_81
Title: QListWidget handling multiple signals from clicking and itemSelectionChanged 
----------------------------------------

def something_happened(self) :
INDENT
    newly_selected_items = set([item.text() for item in self.selectedItems()])
    if newly_selected_items ! = self.selected_items :
    INDENT

        self.selected_items = newly_selected_items
        self.selection_changed.emit(self.selected_items)

    DEDENT
DEDENT
----------------------------------------

def something_happened(self, initial_click = False) :
INDENT
    newly_selected_items = set([item.text() for item in self.selectedItems()])
    if newly_selected_items ! = self.selected_items :
    INDENT

        self.selected_items = newly_selected_items
        self.selection_changed.emit(self.selected_items)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42109398_42110044_7_15
42109398_51569324_1_8
Title: Click type conversion 
----------------------------------------

def check_date(s) :
INDENT
    try :
    INDENT
        return dt.strptime(s, "%Y-%m-%d")
    DEDENT
    except ValueError :
    INDENT
        msg = "Not a valid date: '{0}'.".format(s)
        raise Exception(msg)
    DEDENT
    except TypeError :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def check_date(ctx, param, value) :
INDENT
    try :
    INDENT
        _ = dt.strptime(value, "%Y-%m-%d")
        return value
    DEDENT
    except ValueError :
    INDENT
        msg = "Not a valid date: '{0}'.".format(value)
        raise Exception(msg)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42116657_42119591_37_50
42116657_42119591_9_19
Title: Converting pyside code to pyqt5 code 
----------------------------------------

def __init__(self) :
INDENT
    QWidget.__init__(self, None)
    self.anim_area = Animation_area()
    layout = QVBoxLayout()
    layout.addWidget(self.anim_area)
    self.PlayandPauseButton = QPushButton("Pause")
    self.PlayandPauseButton.clicked.connect(self.clicked)
    layout.addWidget(self.PlayandPauseButton)
    self.setLayout(layout)
    self.setMinimumSize(330, 400)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QWidget.__init__(self, None)
    self.frame_no = 0
    self.images = [QImage("images/frame-" + str(i + 1) + ".png") for i in range(20)]
    timer = QTimer(self)
    timer.timeout.connect(self.update_value)
    timer.start(50)
    self.pause = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42164256_42426342_104_117
42164256_42426712_90_99
Title: Combine PyQt4 CheckBox Functions into single function 
----------------------------------------

def chk_box_value(self) :
INDENT
    letter = ['/E', '/C', '/H', '/Y', '/I']
    value = [self.E_chk.checkState(),
        self.C_chk.checkState(),
        self.H_chk.checkState(),
        self.Y_chk.checkState(),
        self.I_chk.checkState()]
    dictionary = dict(zip(letter, value))
    for k, v in dictionary.items() :
    INDENT
        if v == 2 and k not in self.myList :
        INDENT
            self.myList.append(k)
        DEDENT
        elif v == 0 and k in self.myList :
        INDENT
            self.myList.remove(k)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def chk_box_value(self, state) :
INDENT
    k = '/' + self.sender().text()
    if state == QtCore.Qt.Checked :
    INDENT
        self.myList.append(k)
    DEDENT
    elif state == QtCore.Qt.Unchecked :
    INDENT
        self.myList.remove(k)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42167641_42182100_27_42
42167641_42182100_9_23
Title: Tkinter how to change TTK button to bold? 
----------------------------------------

def __init__(self, name, master = None) :
INDENT
    tk.Frame.__init__(self, master)
    self.master.title(name)
    self.grid()
    self.label = ttk.Label(master, text = 'Launch missiles?')
    self.label.grid(column = 0, row = 0, columnspan = 2)

    self.save_button = ttk.Button(master, text = 'Proceed', command = self.launch)
    self.save_button.grid(column = 0, row = 1)

    self.abort_button = BoldButton(master, text = 'Abort', command = self.quit)
    self.abort_button.grid(column = 1, row = 1)
DEDENT
----------------------------------------

def __init__(self, master = None, ** kwargs) :
INDENT
    STYLE_NAME = 'Bold.TButton'
    if not ttk.Style().configure(STYLE_NAME) :
    INDENT

        button = tk.Button(None)
        font = (tkFont.Font(font = button ['font'])).actual()
        font ['weight'] = 'bold'
        font = tkFont.Font(** font)
        style = ttk.Style()
        style.configure(STYLE_NAME, font = font)
    DEDENT
    super().__init__(master, style = STYLE_NAME, ** kwargs)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42171031_42171079_5_21
42171031_42171175_4_27
Title: I need help finding a smart solution to shorten the time this code runs 
----------------------------------------

def next_bigger(n) :
INDENT
    next_bigger = float('inf')

    perms = map(lambda x : int(''.join(x)), permutations(str(n)))
    for p in perms :
    INDENT
        if (p > n) and (p < = next_bigger) :
        INDENT

            next_bigger = p
        DEDENT
    DEDENT
    return next_bigger
DEDENT
----------------------------------------

def next_bigger(number) :
INDENT
    check = 2
    found = False
    digits = list(str(number))
    if sorted(digits, reverse = True) == digits :
    INDENT
        raise ValueError("No larger number")
    DEDENT
    while not found :
    INDENT
        options = permutations(digits [- 1 * check :], check)
        candidates = list()
        for option in options :
        INDENT
            new = digits.copy() [: - 1 * check]
            new.extend(option)
            candidate = int(''.join(new))
            if candidate > number :
            INDENT
                candidates.append(candidate)
            DEDENT
        DEDENT
        if candidates :
        INDENT
            result = sorted(candidates) [0]
            found = True
            return result
        DEDENT
        check += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42197359_42197561_1_10
42197359_42197613_9_19
Title: How to Compare sublists 
----------------------------------------

def least(lst) :
INDENT
    min_value_in_lst = min(min(sublist) for sublist in lst)
    that_sublist = None
    for sublist in lst :
    INDENT
        if min_value_in_lst in sublist :
        INDENT
            that_sublist = sublist
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def least(list2d) :
INDENT
    minseq = list2d [0]
    x = minimum(minseq)
    for seq in list2d [1 :] :
    INDENT
        i = minimum(seq)
        if i < x :
        INDENT
            x = i
            minseq = seq
        DEDENT
    DEDENT
    print ('In {} the least number is {} found in sublist {}'.format(list2d, x, minseq))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42205011_47252389_3_17
42205011_53018596_1_12
Title: using binary search to return index of target 
----------------------------------------

def binary_search(arr, item, low = 0, high = None) :
INDENT
    if high == None :
    INDENT
        high = len(arr)
    DEDENT
    mid = low + (high - low) / / 2
    if high - low + 1 < = 0 or mid == high :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        guess = arr [mid]
        if guess == item :
        INDENT
            return mid
        DEDENT
        if item < guess :
        INDENT
            return binary_search(arr, item, low, mid)
        DEDENT
        else :
        INDENT
            return binary_search(arr, item, (mid + 1), high)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def binary_search(array, value) :
INDENT
    index = int(len(array) / 2) - 1
    end = int(len(array)) - 1
    while array [index] ! = value :
    INDENT
        if index == end :
        INDENT
            return None
        DEDENT
        elif array [index] > value :
        INDENT
            end = index
            index = int(index / 2)
        DEDENT
        elif array [index] < value :
        INDENT
            index = int((index + 1 + end) / 2)
        DEDENT
    DEDENT
    return index
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42211224_42211454_3_11
42211224_42211658_3_25
Title: Find the most frequent words in a file 
----------------------------------------

def train() :
INDENT
    RemStopWords(file1, file2)
    counter = Counter()
    for line in withoutStops :
    INDENT
        line = line.strip().split("\t")
        words = line [0].split()
        counter.update(words)
    DEDENT
    top10 = [word [0] for word in counter.most_common(10)]
    print (top10)
DEDENT
----------------------------------------

def train() :
INDENT
    textWithoutStops = RemStopWords(file1, file2)

    wordCount = {}
    for word in textWithoutStops.split(' ') :
    INDENT
        if not word in wordCount :
        INDENT
            wordCount [word] = 1
        DEDENT
        else :
        INDENT
            wordCount [word] += 1

        DEDENT
    DEDENT
    sortedWordCount = sorted(wordCount.items(), key = operator.itemgetter(1))
    sortedWordCount = sortedWordCount [: : - 1]

    if len(sortedWordCount) > 10 :
    INDENT
        sortedWordCount = sortedWordCount [: 10]

    DEDENT
    return sortedWordCount
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4223349_34325140_1_23
4223349_39684371_1_43
Title: Python implementation for next_permutation in STL 
----------------------------------------

def next_permutation(a) :
INDENT
    for i in reversed(range(len(a) - 1)) :
    INDENT
        if a [i] < a [i + 1] :
        INDENT
            break
        DEDENT
    DEDENT
    else :
    INDENT
        return False

    DEDENT
    j = next(j for j in reversed(range(i + 1, len(a))) if a [i] < a [j])

    a [i], a [j] = a [j], a [i]

    a [i + 1 :] = reversed(a [i + 1 :])
    return True
DEDENT
----------------------------------------

def next_permutation(case) :
INDENT
    for index in range(1, len(case)) :
    INDENT
        Px_index = len(case) - 1 - index
        Px = case [- index - 1]
        Px_1 = case [- index]

        if Px < Px_1 :
        INDENT
            suffix = case [- index :]
            pivot = Px
            minimum_greater_than_pivot_suffix_index = - 1
            suffix_index = 0

            for Py in suffix :
            INDENT
                if pivot < Py :
                INDENT
                    if minimum_greater_than_pivot_suffix_index == - 1 or suffix [minimum_greater_than_pivot_suffix_index] > = Py :
                    INDENT
                        minimum_greater_than_pivot_suffix_index = suffix_index
                    DEDENT
                DEDENT
                suffix_index += 1
            DEDENT
            minimum_greater_than_pivot_index = minimum_greater_than_pivot_suffix_index + Px_index + 1

            temp = case [minimum_greater_than_pivot_index]
            case [minimum_greater_than_pivot_index] = case [Px_index]
            case [Px_index] = temp

            new_suffix = case [Px_index + 1 :]
            new_suffix.sort()

            new_prefix = case [: Px_index + 1]
            next_permutation = new_prefix + new_suffix
            return next_permutation
        DEDENT
        elif index == (len(case) - 1) :
        INDENT
            return False

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42255889_42256869_7_23
42255889_42256909_1_13
Title: EOF error trying to use user input as arguments 
----------------------------------------

def ricky_adds(x, y) :
INDENT
    num1 = x
    num2 = y
    lessthanzeroerror = "Wow you're dumb, I said a number, not some imaginary shit. Try again :"
    greaterthantenerror = "No. I said A number, not multiple numbers dummy. Try again :"
    if num1 > = 10 :
    INDENT
        num1 = int(input(greaterthantenerror + ":"))
    DEDENT
    elif num1 < 0 :
    INDENT
        num1 = int(input(lessthanzeroerror + ":"))
    DEDENT
    if num2 > = 10 :
    INDENT
        num2 = int(input(greaterthantenerror + ":"))
    DEDENT
    elif num2 < 0 :
    INDENT
        num2 = int(input(lessthanzeroerror + ":"))
    DEDENT
    result = num1 + num2
    return result
DEDENT
----------------------------------------

def ricky_adds(x, y) :
INDENT
    num1 = x
    num2 = y
    if num1 > = 10 :
    INDENT
        num1 = input("No. I said A number, not multiple numbers dummy. Try again :")
    DEDENT
    if num1 < 0 :
    INDENT
        num1 = input("Wow you're dumb, I said a number, not some imaginary shit. Try again :")
    DEDENT
    if num2 > = 10 :
    INDENT
        num2 = input("No. I said A number, not multiple numbers dummy. Try again :")
    DEDENT
    if num2 < 0 :
    INDENT
        num2 = input("Wow you're dumb, I said a number, not some imaginary shit. Try again :")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42281234_42281726_6_12
42281234_42282197_2_19
Title: Which is the cleaner way to get a Python @property as a list with particular conditions? 
----------------------------------------

def __getitem__(self, index) :
INDENT
    item = getitem(self.lst, index)
    if isinstance(index, slice) :
    INDENT
        expected_length = (index.stop - index.start) / / (index.step or 1)
        if len(item) ! = expected_length :
        INDENT
            item.extend([default_value] * (expected_length - len(item)))
        DEDENT
    DEDENT
    return item
DEDENT
----------------------------------------

def __getitem__(self, index) :
INDENT
    result = super(MyList, self).__getitem__(index)
    if isinstance(index, slice) :
    INDENT
        if index.step :
        INDENT
            sublist_len = (index.stop - index.start) / / index.step
        DEDENT
        else :
        INDENT
            sublist_len = (index.stop - index.start)

        DEDENT
        if sublist_len > len(self) or index.start > len(self) :
        INDENT
            result.extend([None for _ in range(sublist_len - len(result))])
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42288079_42288181_9_16
42288079_42288196_1_12
Title: Homework on bubble sorting efficiently 
----------------------------------------

def bubble(values) :
INDENT
    swapped = False
    for i in range(len(values) - 1) :
    INDENT
        if values [i] > values [i + 1] :
        INDENT
            swap(values, i, i + 1)
            swapped = True
        DEDENT
    DEDENT
    return swapped
DEDENT
----------------------------------------

def bubble(values) :
INDENT
    has_changed = False
    while True :
    INDENT
        swapped = False
        for i in range(len(values) - 1) :
        INDENT
            if values [i] > values [i + 1] :
            INDENT
                swap(values, i, i + 1)
                has_changed = True
                swapped = True
            DEDENT
        DEDENT
        if not swapped :
        INDENT
            break
        DEDENT
    DEDENT
    return has_changed
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42290274_42290585_1_16
42290274_42290844_1_13
Title: For loop does not seem to iterate through every list index (nested if statement) 
----------------------------------------

def doggify(word) :
INDENT
    wordlist = list(word)
    start = word [0]
    if start in 'aeiou' :
    INDENT
        dogword = word + 'yay'
        return dogword
    DEDENT
    else :
    INDENT
        empty = []
        new = list(wordlist)
        for letter in wordlist :
        INDENT
            if letter not in 'aeiou' :
            INDENT
                empty.append(letter)
                new.remove(letter)
            DEDENT
            else :
            INDENT
                dogword = ''.join(new) + ''.join(empty) + 'ay'
                return dogword
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def doggify(word) :
INDENT
    if word [0] in 'aeiou' :
    INDENT
        return word + 'yay'
    DEDENT
    else :
    INDENT
        consonants = []
        tail = []
        out = consonants
        for letter in word :
        INDENT
            if letter in 'aeiou' and out is not tail :
            INDENT
                out = tail
            DEDENT
            out.append(letter)
        DEDENT
        return ''.join(tail) + ''.join(consonants) + 'ay'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42293649_42294323_1_21
42293649_42294834_1_22
Title: Three way partitioning of an array 
----------------------------------------

def partition3(alist, lower, heigher, size) :
INDENT
    start = 0
    while alist [start] < lower :
    INDENT
        start = start + 1
    DEDENT
    end = size - 1
    while alist [end] > heigher :
    INDENT
        end = end - 1
    DEDENT
    i = start
    while i < = end :
    INDENT
        if (i > start) and (alist [i] < lower) :
        INDENT
            alist [i], alist [start] = alist [start], alist [i]
            while alist [start] < lower :
            INDENT
                start = start + 1
            DEDENT
        DEDENT
        elif alist [i] > heigher :
        INDENT
            alist [i], alist [end] = alist [end], alist [i]
            while alist [end] > heigher :
            INDENT
                end = end - 1
            DEDENT
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
    return alist
DEDENT
----------------------------------------

def partition3(alist, lower, heigher, size) :
INDENT
    start = 0
    end = size - 1
    i = 0
    while i < size - 1 :
    INDENT
        if alist [i] < lower :
        INDENT
            alist [i], alist [start] = alist [start], alist [i]
            start = start + 1
            i = i + 1
        DEDENT
        elif alist [i] > heigher :
        INDENT
            if end < i + 1 :
            INDENT
                break
            DEDENT
            alist [i], alist [end] = alist [end], alist [i]
            end = end - 1
        DEDENT
        else :
        INDENT
            i = i + 1
        DEDENT
    DEDENT
    return alist
    def sort(alist, low, high) :
    INDENT
        return partition3(alist, low, high, len(alist))
    DEDENT
    print sort([1, 14, 5, 20, 4, 2, 54, 20, 87, 98, 3, 1, 32], 10, 20)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42305464_42329781_14_32
42305464_42329781_46_58
Title: How to display an jpg image and change it on the same panel every x sec using wxPython? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent, id = wx.ID_ANY, title = wx.EmptyString, pos = wx.DefaultPosition,
        size = wx.Size(500, 300), style = wx.DEFAULT_FRAME_STYLE)
    self.panel = wx.Panel(self.frame)
    self.PhotoMaxSize = 240
    self.imageCtrl = wx.StaticBitmap(self.panel, wx.ID_ANY, wx.EmptyBitmap())
    self.mainSizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.mainSizer.Add(wx.StaticLine(self.panel, wx.ID_ANY), 0, wx.ALL | wx.EXPAND, 5)
    self.mainSizer.Add(self.imageCtrl, 0, wx.ALL, 5)
    self.panel.SetSizer(self.mainSizer)
    self.mainSizer.Fit(self.frame)
    self.panel.Layout()
    self.panel.Center()
    self.frame.Show()
DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, 'MiniViewer2017', size = (500, 500))
    panel = wx.Panel(self)
    button_scan = wx.Button(panel, label = 'start scanning!')
    button_exit = wx.Button(panel, label = 'exit', pos = (400, 300))
    self.Bind(wx.EVT_BUTTON, self.Scan, button_scan)
    self.Bind(wx.EVT_BUTTON, self.closebutton, button_exit)
    self.Bind(wx.EVT_CLOSE, self.closewindow)

    self.photo_ctrl = PhotoCtrl(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4231077_4231134_10_30
4231077_4231134_32_39
Title: Get IP address in Google App Engine + Python 
----------------------------------------

def get(self) :
INDENT
    ip = self.request.remote_addr

    log = Log()

    log.ip_address = ip

    log.put()

    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write('Logged your visit from ip address %s' % ip)
DEDENT
----------------------------------------

def get(self) :
INDENT
    logs = Log.all()
    self.response.headers ['Content-Type'] = 'text/plain'
    self.response.out.write('Ip addresses: ')
    for log in logs :
    INDENT
        self.response.out.write(log.ip_address + ',')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42313720_42314295_1_18
42313720_42316903_1_26
Title: "Trying to use formset getting __init__() got an unexpected keyword argument 'instance'" 
----------------------------------------

def edit_row(request, row_pk) :
INDENT
    try :
    INDENT
        row = Row.objects.get(pk = row_pk)
    DEDENT
    except Row.DoesNotExist :
    INDENT
        return HttpResponse('   ')
    DEDENT
    cells = Cell.objects.filter(row = row)
    if request.method == 'POST' :
    INDENT
        formset = CellFormSet(request.POST, instance = cells)
        if formset.is_valid() :
        INDENT
            formset.save()
            return HttpResponseRedirect(reverse('table:index'))
        DEDENT
        else :
        INDENT
            return render(request, 'table/edit-row.html', {'formset' : formset})
        DEDENT
    DEDENT
    else :
    INDENT
        formset = CellFormSet(instance = cells)
        return render(request, 'table/edit-row.html', {'formset' : formset})
    DEDENT
DEDENT
----------------------------------------

def edit_row(request, row_pk) :
INDENT
    try :
    INDENT
        row = Row.objects.get(pk = row_pk)
    DEDENT
    except Row.DoesNotExist :
    INDENT
        return HttpResponse('   ')
    DEDENT
    cells = Cell.objects.filter(row = row)
    contents = []
    if request.method == 'POST' :
    INDENT
        formset = RowFormSet(request.POST)
        if formset.is_valid() :
        INDENT
            for form in formset :
            INDENT
                cd = form.cleaned_data
                content = cd.get('cell')
                contents.append(content)
            DEDENT
            for i, cell in enumerate(cells) :
            INDENT
                cell.content = contents [i]
                cell.save()
            DEDENT
        DEDENT
        return HttpResponseRedirect(reverse('table:index'))
    DEDENT
    else :
    INDENT
        formset = RowFormSet()
    DEDENT
    return render(request, 'table/edit-row.html', {'formset' : formset})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42316495_42323088_103_179
42316495_42323088_203_234
Title: wxPython - Display text from two dialogs printed on a third dialog 
----------------------------------------

def __init__(self, parent, price1) :
INDENT
    self.price1 = price1
    wx.Dialog.__init__(self, parent, id = wx.ID_ANY, title = wx.EmptyString, pos = wx.DefaultPosition,
        size = wx.Size(500, 141), style = wx.DEFAULT_DIALOG_STYLE)
    self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)
    bSizer6 = wx.BoxSizer(wx.VERTICAL)
    self.m_panel2 = wx.Panel(self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL)
    bSizer8 = wx.BoxSizer(wx.HORIZONTAL)
    bSizer42 = wx.BoxSizer(wx.VERTICAL)
    self.m_staticText61 = wx.StaticText(self.m_panel2, wx.ID_ANY, u"item3", wx.DefaultPosition, wx.DefaultSize, 0)
    self.m_staticText61.Wrap(- 1)
    bSizer42.Add(self.m_staticText61, 0, wx.ALL, 5)
    self.m_staticText62 = wx.StaticText(self.m_panel2, wx.ID_ANY, u"item4", wx.DefaultPosition, wx.DefaultSize, 0)
    self.m_staticText62.Wrap(- 1)
    bSizer42.Add(self.m_staticText62, 0, wx.ALL, 5)
    bSizer8.Add(bSizer42, 0, wx.EXPAND, 5)
    bSizer43 = wx.BoxSizer(wx.VERTICAL)
    bSizer43.AddSpacer((80, 0), 1, wx.EXPAND, 5)
    bSizer8.Add(bSizer43, 0, wx.EXPAND, 5)
    bSizer11 = wx.BoxSizer(wx.VERTICAL)
    self.item3 = wx.RadioButton(self.m_panel2, wx.ID_ANY, u"1.50", wx.DefaultPosition, wx.Size(- 1, 20), 0)
    bSizer11.Add(self.item3, 0, wx.ALL, 5)
    self.item4 = wx.RadioButton(self.m_panel2, wx.ID_ANY, u"2.00", wx.DefaultPosition, wx.DefaultSize, 0)
    bSizer11.Add(self.item4, 0, wx.ALL, 5)
    bSizer8.Add(bSizer11, 0, 0, 5)
    self.m_panel2.SetSizer(bSizer8)
    self.m_panel2.Layout()
    bSizer8.Fit(self.m_panel2)
    bSizer6.Add(self.m_panel2, 1, wx.EXPAND | wx.ALL, 5)
    bSizer13 = wx.BoxSizer(wx.HORIZONTAL)
    self.m_staticText25 = wx.StaticText(self, wx.ID_ANY, u"Quatity:", wx.DefaultPosition, wx.DefaultSize, 0)
    self.m_staticText25.Wrap(- 1)
    self.m_staticText25.SetFont(wx.Font(15, 70, 90, 92, False, wx.EmptyString))
    bSizer13.Add(self.m_staticText25, 0, wx.ALL | wx.EXPAND, 5)
    add_quantity_choiceChoices = [u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"10"]
    self.add_quantity_choice = wx.Choice(self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize,
        add_quantity_choiceChoices, 0)
    self.add_quantity_choice.SetSelection(0)
    bSizer13.Add(self.add_quantity_choice, 0, wx.ALL, 5)
    self.ok_button = wx.Button(self, wx.ID_ANY, u"OK", wx.DefaultPosition, wx.DefaultSize, 0)
    bSizer13.Add(self.ok_button, 1, wx.ALL | wx.EXPAND, 5)
    self.cancel_button = wx.Button(self, wx.ID_ANY, u"Cancel", wx.DefaultPosition, wx.DefaultSize, 0)
    bSizer13.Add(self.cancel_button, 1, wx.ALL, 5)
    bSizer6.Add(bSizer13, 0, wx.EXPAND, 5)
    self.SetSizer(bSizer6)
    self.Layout()
    self.Centre(wx.BOTH)

    self.Bind(wx.EVT_CLOSE, self.cancelFunc)
    self.ok_button.Bind(wx.EVT_BUTTON, self.okFunc)
    self.cancel_button.Bind(wx.EVT_BUTTON, self.cancelFunc)
DEDENT
----------------------------------------

def __init__(self, parent, total) :
INDENT
    self.total = total
    wx.Dialog.__init__(self, parent, id = wx.ID_ANY, title = wx.EmptyString, pos = wx.DefaultPosition,
        size = wx.Size(257, 165), style = wx.DEFAULT_DIALOG_STYLE)
    self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)
    bSizer13 = wx.BoxSizer(wx.VERTICAL)
    self.totalText = wx.StaticText(self, wx.ID_ANY, u"Total is:", wx.DefaultPosition, wx.DefaultSize, 0)
    self.totalText.Wrap(- 1)
    self.totalText.SetFont(wx.Font(20, 70, 90, 90, False, wx.EmptyString))
    bSizer13.Add(self.totalText, 0, wx.ALL | wx.EXPAND, 5)
    self.totalText1 = wx.StaticText(self, wx.ID_ANY, u"?", wx.DefaultPosition, wx.DefaultSize, 0)
    self.totalText1.Wrap(- 1)
    self.totalText1.SetFont(wx.Font(20, 70, 90, 90, False, wx.EmptyString))
    self.totalText1.SetLabel(str(total))

    bSizer13.Add(self.totalText1, 0, wx.ALL, 5)
    self.SetSizer(bSizer13)
    self.Layout()
    self.Centre(wx.BOTH)

    self.Bind(wx.EVT_CLOSE, self.cancelFunc)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42316495_42323088_203_234
42316495_42323088_5_79
Title: wxPython - Display text from two dialogs printed on a third dialog 
----------------------------------------

def __init__(self, parent, total) :
INDENT
    self.total = total
    wx.Dialog.__init__(self, parent, id = wx.ID_ANY, title = wx.EmptyString, pos = wx.DefaultPosition,
        size = wx.Size(257, 165), style = wx.DEFAULT_DIALOG_STYLE)
    self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)
    bSizer13 = wx.BoxSizer(wx.VERTICAL)
    self.totalText = wx.StaticText(self, wx.ID_ANY, u"Total is:", wx.DefaultPosition, wx.DefaultSize, 0)
    self.totalText.Wrap(- 1)
    self.totalText.SetFont(wx.Font(20, 70, 90, 90, False, wx.EmptyString))
    bSizer13.Add(self.totalText, 0, wx.ALL | wx.EXPAND, 5)
    self.totalText1 = wx.StaticText(self, wx.ID_ANY, u"?", wx.DefaultPosition, wx.DefaultSize, 0)
    self.totalText1.Wrap(- 1)
    self.totalText1.SetFont(wx.Font(20, 70, 90, 90, False, wx.EmptyString))
    self.totalText1.SetLabel(str(total))

    bSizer13.Add(self.totalText1, 0, wx.ALL, 5)
    self.SetSizer(bSizer13)
    self.Layout()
    self.Centre(wx.BOTH)

    self.Bind(wx.EVT_CLOSE, self.cancelFunc)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Dialog.__init__(self, parent, id = wx.ID_ANY, title = wx.EmptyString, pos = wx.DefaultPosition,
        size = wx.Size(500, 141), style = wx.DEFAULT_DIALOG_STYLE)
    self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)
    bSizer6 = wx.BoxSizer(wx.VERTICAL)
    self.m_panel2 = wx.Panel(self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL)
    bSizer8 = wx.BoxSizer(wx.HORIZONTAL)
    bSizer42 = wx.BoxSizer(wx.VERTICAL)
    self.m_staticText61 = wx.StaticText(self.m_panel2, wx.ID_ANY, u"item1", wx.DefaultPosition, wx.DefaultSize, 0)
    self.m_staticText61.Wrap(- 1)
    bSizer42.Add(self.m_staticText61, 0, wx.ALL, 5)
    self.m_staticText62 = wx.StaticText(self.m_panel2, wx.ID_ANY, u"item2", wx.DefaultPosition, wx.DefaultSize, 0)
    self.m_staticText62.Wrap(- 1)
    bSizer42.Add(self.m_staticText62, 0, wx.ALL, 5)
    bSizer8.Add(bSizer42, 0, wx.EXPAND, 5)
    bSizer43 = wx.BoxSizer(wx.VERTICAL)
    bSizer43.AddSpacer((80, 0), 1, wx.EXPAND, 5)
    bSizer8.Add(bSizer43, 0, wx.EXPAND, 5)
    bSizer11 = wx.BoxSizer(wx.VERTICAL)
    self.item1 = wx.RadioButton(self.m_panel2, wx.ID_ANY, u"7.50", wx.DefaultPosition, wx.Size(- 1, 20), 0)
    bSizer11.Add(self.item1, 0, wx.ALL, 5)
    self.item2 = wx.RadioButton(self.m_panel2, wx.ID_ANY, u"8.00", wx.DefaultPosition, wx.DefaultSize, 0)
    bSizer11.Add(self.item2, 0, wx.ALL, 5)
    bSizer8.Add(bSizer11, 0, 0, 5)
    self.m_panel2.SetSizer(bSizer8)
    self.m_panel2.Layout()
    bSizer8.Fit(self.m_panel2)
    bSizer6.Add(self.m_panel2, 1, wx.EXPAND | wx.ALL, 5)
    bSizer13 = wx.BoxSizer(wx.HORIZONTAL)
    self.m_staticText25 = wx.StaticText(self, wx.ID_ANY, u"Quatity:", wx.DefaultPosition, wx.DefaultSize, 0)
    self.m_staticText25.Wrap(- 1)
    self.m_staticText25.SetFont(wx.Font(15, 70, 90, 92, False, wx.EmptyString))
    bSizer13.Add(self.m_staticText25, 0, wx.ALL | wx.EXPAND, 5)
    quantity_choiceChoices = [u"1", u"2", u"3", u"4", u"5", u"6", u"7", u"8", u"9", u"10"]
    self.quantity_choice = wx.Choice(self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, quantity_choiceChoices, 0)
    self.quantity_choice.SetSelection(0)
    bSizer13.Add(self.quantity_choice, 0, wx.ALL, 5)
    self.ok_button = wx.Button(self, wx.ID_ANY, u"OK", wx.DefaultPosition, wx.DefaultSize, 0)
    bSizer13.Add(self.ok_button, 1, wx.ALL | wx.EXPAND, 5)
    self.cancel_button = wx.Button(self, wx.ID_ANY, u"Cancel", wx.DefaultPosition, wx.DefaultSize, 0)
    bSizer13.Add(self.cancel_button, 1, wx.ALL, 5)
    bSizer6.Add(bSizer13, 0, wx.EXPAND, 5)
    self.SetSizer(bSizer6)
    self.Layout()
    self.Centre(wx.BOTH)

    self.Bind(wx.EVT_CLOSE, self.cancelFunc)
    self.ok_button.Bind(wx.EVT_BUTTON, self.okFunc)
    self.cancel_button.Bind(wx.EVT_BUTTON, self.cancelFunc)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42322774_42322875_7_12
42322774_42323190_3_43
Title: Dictionary with 3 dictionaries in it 
----------------------------------------

def add_scores(superList, scoreList, scoreType) :
INDENT
    for studentID, value in scoreList.items() :
    INDENT
        if studentID not in superList.keys() :
        INDENT
            superList [studentID] = {}
        DEDENT
        superList [studentID] [scoreType] = value
    DEDENT
DEDENT
----------------------------------------

def add_scores(scores, description, records = None) :
INDENT
    records = copy.deepcopy(records) if records else {}
    for student_id, student_scores in scores.items() :
    INDENT
        record = records.setdefault(student_id, {})
        record [description] = record.get(description, []) + student_scores
    DEDENT
    return records
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42324419_42324537_1_17
42324419_51917813_1_16
Title: Karatsuba Multiplication Implementation 
----------------------------------------

def karat(x, y) :
INDENT
    if len(str(x)) == 1 or len(str(y)) == 1 :
    INDENT
        return x * y
    DEDENT
    else :
    INDENT
        m = max(len(str(x)), len(str(y)))
        m2 = m / / 2
        a = x / / 10 ** (m2)
        b = x % 10 ** (m2)
        c = y / / 10 ** (m2)
        d = y % 10 ** (m2)
        z0 = karat(b, d)
        z1 = karat((a + b), (c + d))
        z2 = karat(a, c)
        return (z2 * 10 ** (2 * m2)) + ((z1 - z2 - z0) * 10 ** (m2)) + (z0)
    DEDENT
DEDENT
----------------------------------------

def karat(x, y) :
INDENT
    if len(str(x)) < 3 or len(str(y)) < 3 :
    INDENT
        return x * y
    DEDENT
    n = max(len(str(x)), len(str(y))) / / 2
    a = x / / 10 ** (n)
    b = x % 10 ** (n)
    c = y / / 10 ** (n)
    d = y % 10 ** (n)
    z0 = karat(b, d)
    z1 = karat((a + b), (c + d))
    z2 = karat(a, c)
    return ((10 ** (2 * n)) * z2) + ((10 ** n) * (z1 - z2 - z0)) + z0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42328584_42328709_1_16
42328584_42328746_1_37
Title: Creating a dictionary linking each word of a text file to a list of lines where it occurs in the file 
----------------------------------------

def dictionary(file) :
INDENT
    in_file = open(ficheiro, 'r')
    words = []
    d = {}
    lines = in_file.readlines()
    for line in lines :
    INDENT
        words = words + line.split(' ')
    DEDENT
    for j in words :
    INDENT
        if (j not in d) :
        INDENT
            d [j] = []
            for i in range(len(lines)) :
            INDENT
                if j in lines [i] :
                INDENT
                    d [j].append(i)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return d
DEDENT
----------------------------------------

def dictionary(filename) :
INDENT
    result = dict()

    for idx, line in enumerate(open(filename)) :
    INDENT

        words = line.strip().split()

        for w in words :
        INDENT
            if w not in result :
            INDENT
                result [w] = []

            DEDENT
            result [w].append(idx)

        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42329495_42329611_19_48
42329495_42330168_18_49
Title: python guessing game excersise 
----------------------------------------

def generationProcess() :
INDENT
    global userguess
    global generatednumber
    if int(userguess) == generatednumber :
    INDENT
        print ('You have guessed the number. Congratulations.')
        global playAgain
        playAgain = input('Want to play again? y/n: ')
        if playAgain == 'y' :
        INDENT
            generateNumber()
            userguess = input('Pick a new number between 1-9: ')
            generationProcess()
        DEDENT
        if playAgain == 'n' :
        INDENT
            print ('The game has ended. You have played: ')
            print (int(playedGames))
            print ('games')
            playAgain = 'x'

        DEDENT
    DEDENT
    if int(userguess) > generatednumber :
    INDENT
        print ('You have guessed too high.')
        global conConfirm
        conConfirm = input('Guess again?: c/quit: ')
        conGame()
    DEDENT
    if int(userguess) < generatednumber :
    INDENT
        print ('You have guessed too low.')
        conConfirm = str(input('Guess again?: c/quit: '))
        conGame()

    DEDENT
DEDENT
----------------------------------------

def generationProcess() :
INDENT
    global userguess, guesses, playedGames, generatednumber
    while True :
    INDENT
        if userguess == generatednumber :
        INDENT
            print ('You have guessed the number. Congratulations.')
            playedGames += 1
            global playAgain
            playAgain = input('Want to play again? y/n: ')
            if playAgain == 'y' :
            INDENT
                generatednumber = generateNumber()
                userguess = input('Pick a new number between 1-9: ')
                generationProcess()
            DEDENT
            if playAgain == 'n' :
            INDENT
                print ('The game has ended. You have played: ' + str(playedGames) + ' games')
            DEDENT
        DEDENT
        elif int(userguess) > generatednumber :
        INDENT
            print ('You have guessed too high.')
            guesses += 1
            conConfirm = str(input('Guess again?: c/quit: '))
            conGame(conConfirm)
        DEDENT
        elif int(userguess) < generatednumber :
        INDENT

            guesses += 1
            print ('You have guessed too low.')
            conConfirm = str(input('Guess again?: c/quit: '))
            conGame(conConfirm)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42329495_42329611_49_61
42329495_42330168_50_55
Title: python guessing game excersise 
----------------------------------------

def conGame() :
INDENT
    global conConfirm
    if conConfirm == 'c' :
    INDENT
        global userguess
        userguess = int(input('Your new guess please: '))
        generationProcess()
    DEDENT
    if conConfirm == 'quit' :
    INDENT
        print ('The game has ended. You have played: ')
        print (int(playedGames))
        print ('games')
        conConfirm = 'x'
    DEDENT
DEDENT
----------------------------------------

def conGame(conConfirm) :
INDENT
    global userguess
    if conConfirm == 'c' :
    INDENT
        userguess = int(input('Your new guess please: '))
        generationProcess()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42333689_42333806_3_12
42333689_42334249_2_12
Title: How to speed up one hot encoder code 
----------------------------------------

def ohc(x) :
INDENT
    elem_to_idx = {}
    for e in x :
    INDENT
        if e not in elem_to_idx :
        INDENT
            elem_to_idx [e] = len(elem_to_idx)
        DEDENT
    DEDENT
    c = len(elem_to_idx)
    X = np.zeros((len(x), c))
    for idx, val in enumerate(x) :
    INDENT
        X [idx, elem_to_idx [val]] = 1
    DEDENT
    return X
DEDENT
----------------------------------------

def ohc(x) :
INDENT
    u = list(set(x))
    c = len(u)
    X = np.zeros((len(x), c))
    for idx, val in enumerate(x) :
    INDENT
        for i in range(c) :
        INDENT
            if val == u [i] :
            INDENT
                X [idx, i] = 1
            DEDENT
        DEDENT
    DEDENT
    return X

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4233628_4233671_1_13
4233628_4233800_20_26
Title: Override __mul__ from a child class using parent implementation: leads to problems 
----------------------------------------

def __mul__(self, other) :
INDENT
    if isinstance(other, MyFloatExt) :
    INDENT
        return MyFloatExt(self.a * other.a)
    DEDENT
    if type(other) == (int, long, float) :
    INDENT
        return MyFloatExt(self.a * other)
    DEDENT
    else :
    INDENT
        return MyFloat.__mul__(self, other)

    DEDENT
DEDENT
----------------------------------------

def __mul__(self, other) :
INDENT
    if isinstance(other, Number) :
    INDENT
        return type(self)(self.a * other)
    DEDENT
    else :
    INDENT
        return super(MyFloatExt, self).__mul__(other)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42336328_42336459_1_10
42336328_42336521_1_8
Title: Python - Use a class method to decorate other class methods 
----------------------------------------

def _with_plug(fn) :
INDENT
    print ("wrapping", fn.__name__)
    def wrapper(self, * args, ** kwds) :
    INDENT
        print ("wrapper called")
        self.probe = [self.connection, ".plug()"]
        fn(self, * args, ** kwds)
        self.probe.append(".unplug()")
    DEDENT
    return wrapper

DEDENT
----------------------------------------

def _with_plug(fn) :
INDENT
    def wrapper(self, * args, ** kwargs) :
    INDENT
        self.probe = self.connection.plug()
        fn(self, * args, ** kwargs)
        self.probe.unplug()
    DEDENT
    return wrapper

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42365286_42439871_21_26
42365286_42439871_52_57
Title: luigi dependencies change at runtime 
----------------------------------------

def output(self) :
INDENT
    targets = []
    for i in range(self.num_targets) :
    INDENT
        targets.append(luigi.LocalTarget("  {}/{}_{}.txt".format(self.get_dir(), self.get_prefix(), i)))
        return targets
    DEDENT
DEDENT
----------------------------------------

def output(self) :
INDENT
    targets = []
    for target in self.input() :
    INDENT
        targets.append(luigi.LocalTarget(RunPipelineOnSmallChunk.clean_input_path(target.path)))
    DEDENT
    return targets
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42371720_42371891_1_14
42371720_42374503_4_17
Title: How to count specific elements before an element in a list? 
----------------------------------------

def formula(l) :
INDENT
    count_zero = 0
    result = []
    for i in l :
    INDENT
        if i == 1 :
        INDENT
            result.append(3 * count_zero)
            count_zero = 0
        DEDENT
        elif i == 0 :
        INDENT
            count_zero += 1
        DEDENT
    DEDENT
    return result

DEDENT
----------------------------------------

def formula(list) :
INDENT
    track = []
    start = 0
    for i, n in enumerate(list) :
    INDENT
        count_list_chunk = list [start : i]
        if count_list_chunk.count(0) > 0 and n ! = 0 :
        INDENT
            start = i
        DEDENT
        if n ! = 0 :
        INDENT
            track.append(count_list_chunk.count(0) * 3)
        DEDENT
    DEDENT
    return track
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42376584_42376714_4_10
42376584_42392576_4_14
Title: How to compare exact list elements in 2 same length list? 
----------------------------------------

def listCompare(lst1, lst2) :
INDENT
    matches = 0
    for i in range(0, len(lst1)) :
    INDENT
        if lst1 [i] == lst2 [i] :
        INDENT
            matches += 1
        DEDENT
    DEDENT
    return matches
DEDENT
----------------------------------------

def listCompare(lst1, lst2) :
INDENT
    i = 0
    counter = 0
    for j in lst1 :
    INDENT
        if lst1 [i] == lst2 [i] :
        INDENT
            counter += 1
            i += 1
        DEDENT
        else :
        INDENT
            i += 1
        DEDENT
    DEDENT
    return counter
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42381385_42399305_29_36
42381385_42399305_63_72
Title: "in Python3/tkinter is it possible to create a toolbar into a separate class but still allowing it to interact with the main app?" 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)
    self.master = master
    self.pack(side = tk.BOTTOM, fill = tk.X)
    self.centerlabel = ttk.Label(self, text = "Center stuff goes here")
    self.centerlabel.pack()

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    super().__init__(master)
    self.master = master
    self.pack(side = tk.TOP, fill = tk.X)
    self.button1 = ttk.Button(self, text = "One", command = self.button_one)
    self.button2 = ttk.Button(self, text = "Two", command = self.button_two)
    self.button1.grid(row = 0, column = 0)
    self.button2.grid(row = 0, column = 1)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42381385_42399305_29_36
42381385_42399305_9_22
Title: "in Python3/tkinter is it possible to create a toolbar into a separate class but still allowing it to interact with the main app?" 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)
    self.master = master
    self.pack(side = tk.BOTTOM, fill = tk.X)
    self.centerlabel = ttk.Label(self, text = "Center stuff goes here")
    self.centerlabel.pack()

DEDENT
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)

    self.my_toolbar = Toolbar(self)
    self.my_statusbar = StatusBar(self)
    self.my_statusbar.set("This is the statusbar")
    self.centerframe = CenterFrame(self)
    self.pack(side = tk.TOP, expand = True, fill = tk.BOTH)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42381385_42399305_29_36
42381385_42400067_9_28
Title: "in Python3/tkinter is it possible to create a toolbar into a separate class but still allowing it to interact with the main app?" 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)
    self.master = master
    self.pack(side = tk.BOTTOM, fill = tk.X)
    self.centerlabel = ttk.Label(self, text = "Center stuff goes here")
    self.centerlabel.pack()

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.mainframe = ttk.Frame(master)
    self.topframe = ttk.Frame(self.mainframe)
    self.centerframe = ttk.Frame(self.mainframe)
    self.bottomframe = ttk.Frame(self.mainframe)
    self.my_toolbar = Toolbar(self.topframe)
    self.my_statusbar = StatusBar(self.mainframe)
    self.my_statusbar.set("This is the statusbar")
    self.centerlabel = ttk.Label(self.centerframe, text = "Center stuff goes here")
    self.centerlabel.pack()
    self.topframe.pack(side = TOP, fill = X)
    self.centerframe.pack(side = TOP, fill = BOTH)
    self.bottomframe.pack(side = BOTTOM, fill = X)
    self.mainframe.pack(side = TOP, expand = True, fill = BOTH)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42381385_42399305_63_72
42381385_42399305_9_22
Title: "in Python3/tkinter is it possible to create a toolbar into a separate class but still allowing it to interact with the main app?" 
----------------------------------------

def __init__(self, master) :
INDENT
    super().__init__(master)
    self.master = master
    self.pack(side = tk.TOP, fill = tk.X)
    self.button1 = ttk.Button(self, text = "One", command = self.button_one)
    self.button2 = ttk.Button(self, text = "Two", command = self.button_two)
    self.button1.grid(row = 0, column = 0)
    self.button2.grid(row = 0, column = 1)

DEDENT
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)

    self.my_toolbar = Toolbar(self)
    self.my_statusbar = StatusBar(self)
    self.my_statusbar.set("This is the statusbar")
    self.centerframe = CenterFrame(self)
    self.pack(side = tk.TOP, expand = True, fill = tk.BOTH)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42381385_42399305_63_72
42381385_42400067_9_28
Title: "in Python3/tkinter is it possible to create a toolbar into a separate class but still allowing it to interact with the main app?" 
----------------------------------------

def __init__(self, master) :
INDENT
    super().__init__(master)
    self.master = master
    self.pack(side = tk.TOP, fill = tk.X)
    self.button1 = ttk.Button(self, text = "One", command = self.button_one)
    self.button2 = ttk.Button(self, text = "Two", command = self.button_two)
    self.button1.grid(row = 0, column = 0)
    self.button2.grid(row = 0, column = 1)

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.mainframe = ttk.Frame(master)
    self.topframe = ttk.Frame(self.mainframe)
    self.centerframe = ttk.Frame(self.mainframe)
    self.bottomframe = ttk.Frame(self.mainframe)
    self.my_toolbar = Toolbar(self.topframe)
    self.my_statusbar = StatusBar(self.mainframe)
    self.my_statusbar.set("This is the statusbar")
    self.centerlabel = ttk.Label(self.centerframe, text = "Center stuff goes here")
    self.centerlabel.pack()
    self.topframe.pack(side = TOP, fill = X)
    self.centerframe.pack(side = TOP, fill = BOTH)
    self.bottomframe.pack(side = BOTTOM, fill = X)
    self.mainframe.pack(side = TOP, expand = True, fill = BOTH)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42381385_42399305_9_22
42381385_42400067_9_28
Title: "in Python3/tkinter is it possible to create a toolbar into a separate class but still allowing it to interact with the main app?" 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)

    self.my_toolbar = Toolbar(self)
    self.my_statusbar = StatusBar(self)
    self.my_statusbar.set("This is the statusbar")
    self.centerframe = CenterFrame(self)
    self.pack(side = tk.TOP, expand = True, fill = tk.BOTH)

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.mainframe = ttk.Frame(master)
    self.topframe = ttk.Frame(self.mainframe)
    self.centerframe = ttk.Frame(self.mainframe)
    self.bottomframe = ttk.Frame(self.mainframe)
    self.my_toolbar = Toolbar(self.topframe)
    self.my_statusbar = StatusBar(self.mainframe)
    self.my_statusbar.set("This is the statusbar")
    self.centerlabel = ttk.Label(self.centerframe, text = "Center stuff goes here")
    self.centerlabel.pack()
    self.topframe.pack(side = TOP, fill = X)
    self.centerframe.pack(side = TOP, fill = BOTH)
    self.bottomframe.pack(side = BOTTOM, fill = X)
    self.mainframe.pack(side = TOP, expand = True, fill = BOTH)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42383334_42383518_1_12
42383334_42383648_1_9
Title: Python Decorator override function argument 
----------------------------------------

def override(* override_args, ** override_kwargs) :
INDENT
    def outer(f) :
    INDENT
        def inner(* args, ** kwargs) :
        INDENT
            min_args_length = min(len(args), len(override_args))
            args = list(args)
            for i in xrange(min_args_length) :
            INDENT
                args [i] = override_args [i]
            DEDENT
            kwargs.update(override_kwargs)
            return f(* args, ** kwargs)
        DEDENT
        return inner
    DEDENT
    return outer
DEDENT
----------------------------------------

def override(dec_animal) :
INDENT
    def outer(func) :
    INDENT
        def inner(animal_to_be_ignored, ** kwargs) :
        INDENT
            return func(dec_animal, ** kwargs)
        DEDENT
        return inner
        return outer

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42383334_42383518_2_10
42383334_42383648_2_9
Title: Python Decorator override function argument 
----------------------------------------

def outer(f) :
INDENT
    def inner(* args, ** kwargs) :
    INDENT
        min_args_length = min(len(args), len(override_args))
        args = list(args)
        for i in xrange(min_args_length) :
        INDENT
            args [i] = override_args [i]
        DEDENT
        kwargs.update(override_kwargs)
        return f(* args, ** kwargs)
    DEDENT
    return inner
DEDENT
----------------------------------------

def outer(func) :
INDENT
    def inner(animal_to_be_ignored, ** kwargs) :
    INDENT
        return func(dec_animal, ** kwargs)
    DEDENT
    return inner
    return outer

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42401110_42401671_16_22
42401110_42403290_26_32
Title: keeping track of own objects on tkinter canvas 
----------------------------------------

def change_colors() :
INDENT
    global current_color
    current_color = "white" if current_color == "black" else "black"
    for id in items :
    INDENT
        canvas.itemconfig(id, fill = current_color)
    DEDENT
    root.after(1000, change_colors)
DEDENT
----------------------------------------

def change_colors() :
INDENT
    for id in canvas.find_withtag(BUBBLE_TAG) :
    INDENT
        current_color = canvas.itemcget(id, 'fill')
        new_color = 'black' if current_color == 'white' else 'white'
        mapping [id].change_color(new_color)
    DEDENT
    root.after(1000, change_colors)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42414784_42453758_27_37
42414784_42453758_5_17
Title: How do I hide current window while opening a new one using PyQt5 
----------------------------------------

def setupUi(self, Dialog) :
INDENT
    Dialog.setObjectName("Dialog")
    Dialog.resize(508, 300)
    self.buttonBox = QtWidgets.QDialogButtonBox(Dialog)
    self.buttonBox.setGeometry(QtCore.QRect(150, 250, 341, 32))
    self.buttonBox.setOrientation(QtCore.Qt.Horizontal)
    self.buttonBox.setStandardButtons(QtWidgets.QDialogButtonBox.Cancel | QtWidgets.QDialogButtonBox.Ok)
    self.buttonBox.setObjectName("buttonBox")
    self.buttonBox.accepted.connect(Dialog.accept)
    self.buttonBox.rejected.connect(Dialog.reject)
    QtCore.QMetaObject.connectSlotsByName(Dialog)
DEDENT
----------------------------------------

def setupUi(self, MainWindow) :
INDENT
    MainWindow.setObjectName("MainWindow")
    MainWindow.resize(442, 205)
    self.centralwidget = QtWidgets.QWidget(MainWindow)
    self.centralwidget.setObjectName("centralwidget")
    self.pushButton = QtWidgets.QPushButton(self.centralwidget)
    self.pushButton.setGeometry(QtCore.QRect(180, 80, 75, 23))
    self.pushButton.setObjectName("pushButton")
    MainWindow.setCentralWidget(self.centralwidget)
    self.retranslateUi(MainWindow)
    QtCore.QMetaObject.connectSlotsByName(MainWindow)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42420650_42421170_1_13
42420650_42421309_7_28
Title: summing nested dictionary values in python 
----------------------------------------

def orangecap(d) :
INDENT
    first_run = 1
    for match in d :
    INDENT
        for player in d [match] :
        INDENT
            if first_run == 1 :
            INDENT
                first_run = 0
                topscore = d [match] [player]
                playername = d [match]
            DEDENT
            elif d [match] [player] > topscore :
            INDENT
                topscore = d [match] [player]
                playername = player
            DEDENT
        DEDENT
    DEDENT
    return [playername, topscore]
DEDENT
----------------------------------------

def orangecap(matches) :
INDENT
    players_and_scores = {}
    top_players_and_scores = []
    for match in matches :
    INDENT
        for player, score in matches [match].items() :
        INDENT
            try :
            INDENT
                players_and_scores [player] += score
            DEDENT
            except :
            INDENT
                players_and_scores [player] = score

            DEDENT
        DEDENT
    DEDENT
    for player, score in players_and_scores.items() :
    INDENT
        if score == max(players_and_scores.values()) :
        INDENT
            top_players_and_scores.append((player, score))

        DEDENT
    DEDENT
    return top_players_and_scores
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42422331_42422433_33_40
42422331_42422451_1_8
Title: Delete the duplicate arrays inside an array in python 
----------------------------------------

def unique_elements(l) :
INDENT
    last = object()
    for item in l :
    INDENT
        if item == last :
        INDENT
            continue
        DEDENT
        yield item
        last = item
    DEDENT
DEDENT
----------------------------------------

def unique_elements(l) :
INDENT
    last = object()
    for item in l :
    INDENT
        if item == last :
        INDENT
            continue
        DEDENT
        yield item
        last = item
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42422466_42423653_12_23
42422466_42423653_47_54
Title: PyQt4 matplotlib does not plot my real time data 
----------------------------------------

def __init__(self, parent = None, * args, ** kwargs) :
INDENT
    self.fig = plt.figure()
    self.ax = self.fig.add_subplot(111)
    self.ax.grid(True)
    super(CustomFigCanvas, self).__init__(self.fig)
    self.setParent(parent)
    self.init_figure()
    self.timer = QtCore.QTimer(self)
    self.timer.timeout.connect(self.updateFigure)
    self.timer.start(1000)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(App, self).__init__(parent)
    self.tab = QtGui.QWidget()
    self.setCentralWidget(self.tab)
    self.tablayout = QtGui.QVBoxLayout(self.tab)
    self.canvas = CustomFigCanvas()
    self.tablayout.addWidget(self.canvas)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42422466_42423653_12_23
42422466_42423766_14_21
Title: PyQt4 matplotlib does not plot my real time data 
----------------------------------------

def __init__(self, parent = None, * args, ** kwargs) :
INDENT
    self.fig = plt.figure()
    self.ax = self.fig.add_subplot(111)
    self.ax.grid(True)
    super(CustomFigCanvas, self).__init__(self.fig)
    self.setParent(parent)
    self.init_figure()
    self.timer = QtCore.QTimer(self)
    self.timer.timeout.connect(self.updateFigure)
    self.timer.start(1000)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    self.fig = plt.figure(1)
    self.ax = self.fig.add_subplot(111)
    self.ax.grid(True)
    super(mplCanvas, self).__init__(figure = self.fig)
    self.setParent(parent)
    self.init_figure()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42422466_42423653_47_54
42422466_42423766_14_21
Title: PyQt4 matplotlib does not plot my real time data 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(App, self).__init__(parent)
    self.tab = QtGui.QWidget()
    self.setCentralWidget(self.tab)
    self.tablayout = QtGui.QVBoxLayout(self.tab)
    self.canvas = CustomFigCanvas()
    self.tablayout.addWidget(self.canvas)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    self.fig = plt.figure(1)
    self.ax = self.fig.add_subplot(111)
    self.ax.grid(True)
    super(mplCanvas, self).__init__(figure = self.fig)
    self.setParent(parent)
    self.init_figure()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42424869_42442775_21_30
42424869_42442775_53_61
Title: In Python3/tkinter how to intercept when the user clicks the close button on a Toplevel window 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)
    self.master = master
    self.button1 = ttk.Button(self.topframe, text = "One", command = self.button_one)
    self.btn_remessas = ttk.Button(self.topframe, text = "Open/close Toplevel window", command = self.create_window2)
    self.button1.grid(row = 0, column = 0)
    self.btn_remessas.grid(row = 0, column = 1)
    self.topframe.pack(side = tk.TOP, fill = tk.X)
    self.mainframe.pack(side = tk.TOP, expand = True, fill = tk.BOTH)
DEDENT
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    self.mainframe = ttk.Frame(master, padding = "5 8 5 5")
    self.topframe = ttk.Frame(self.mainframe)
    self.button1 = ttk.Button(self.topframe, text = "button", command = self.button_function)
    self.button1.pack()
    self.topframe.pack(side = tk.TOP, fill = tk.X)
    self.mainframe.pack(side = tk.TOP, expand = True, fill = tk.BOTH)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42424869_42442775_21_30
42424869_42442775_9_19
Title: In Python3/tkinter how to intercept when the user clicks the close button on a Toplevel window 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)
    self.master = master
    self.button1 = ttk.Button(self.topframe, text = "One", command = self.button_one)
    self.btn_remessas = ttk.Button(self.topframe, text = "Open/close Toplevel window", command = self.create_window2)
    self.button1.grid(row = 0, column = 0)
    self.btn_remessas.grid(row = 0, column = 1)
    self.topframe.pack(side = tk.TOP, fill = tk.X)
    self.mainframe.pack(side = tk.TOP, expand = True, fill = tk.BOTH)
DEDENT
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)
    self.master = master
    self.mainframe = ttk.Frame(master)
    self.topframe = ttk.Frame(self.mainframe, padding = "5 8 5 5")
    self.topframe.pack(side = tk.TOP, fill = tk.X)
    self.mainframe.pack(side = tk.TOP, expand = True, fill = tk.BOTH)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42424869_42442775_53_61
42424869_42442775_9_19
Title: In Python3/tkinter how to intercept when the user clicks the close button on a Toplevel window 
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    self.mainframe = ttk.Frame(master, padding = "5 8 5 5")
    self.topframe = ttk.Frame(self.mainframe)
    self.button1 = ttk.Button(self.topframe, text = "button", command = self.button_function)
    self.button1.pack()
    self.topframe.pack(side = tk.TOP, fill = tk.X)
    self.mainframe.pack(side = tk.TOP, expand = True, fill = tk.BOTH)
DEDENT
----------------------------------------

def __init__(self, master, * args, ** kwargs) :
INDENT
    super().__init__(master, * args, ** kwargs)
    self.master = master
    self.mainframe = ttk.Frame(master)
    self.topframe = ttk.Frame(self.mainframe, padding = "5 8 5 5")
    self.topframe.pack(side = tk.TOP, fill = tk.X)
    self.mainframe.pack(side = tk.TOP, expand = True, fill = tk.BOTH)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42437964_42463864_20_33
42437964_42465570_7_21
Title: pyqt4 how to set text from line edit to label on button click 
----------------------------------------

def initUI(self) :
INDENT
    self.qle = QtGui.QLineEdit(self)
    self.qle.move(100, 0)
    sometext = self.qle.text
    self.lbl = QtGui.QLabel(self)
    self.lbl.move(100, 100)
    btn = QtGui.QPushButton("Ok", self)
    btn.move(30, 100)
    self.setGeometry(200, 200, 300, 200)
    self.show
DEDENT
----------------------------------------

def initUI(self) :
INDENT
    self.qle = QtGui.QLineEdit(self)
    self.qle.move(10, 10)
    self.lbl = QtGui.QLabel(self)
    self.lbl.setGeometry(10, 55, 200, 20)
    self.lbl.setText("Type Something and Press Ok!")
    btn = QtGui.QPushButton("Ok", self)
    btn.move(10, 100)
    btn.clicked.connect(self.buttonClicked)
    self.setGeometry(200, 200, 300, 200)
    self.show
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42449242_42449680_13_23
42449242_42449752_11_18
Title: Newton-Raphson's method user input and numerical output problems 
----------------------------------------

def newtons_method() :
INDENT
    guess = sp.sympify(float(input("Enter an initial guess: ")))
    symx = input("Input your function here: ")
    div = f(symx) / fprime(symx)
    for i in range(1, 10) :
    INDENT
        print (guess.evalf())
        nextGuess = guess - div.subs(x, guess)
        guess = nextGuess

    DEDENT
DEDENT
----------------------------------------

def newtons_method(f, fprime, symx) :
INDENT
    global eq
    eq = input("Input your function here: ")
    guess = int(input("Enter an initial guess: "))
    for i in range(1, 10) :
    INDENT
        nextGuess = guess - f(guess) / fprime(guess)
        print (nextGuess)
        guess = nextGuess
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42449830_42449953_1_15
42449830_42451355_1_15
Title: Making Anagrams : Temp Anagram length subtraction method 
----------------------------------------

def anagramlength(string1, string2) :
INDENT
    difference = {}

    for letter in string1 :
    INDENT
        if letter not in difference :
        INDENT
            difference [letter] = 0
        DEDENT
        difference [letter] += 1
    DEDENT
    for letter in string2 :
    INDENT
        if letter not in difference :
        INDENT
            difference [letter] = 0
        DEDENT
        difference [letter] -= 1
    DEDENT
    return sum(abs(n) for n in difference.values())
DEDENT
----------------------------------------

def anagramlength(string1, string2) :
INDENT
    temp = []
    if len(string1) > len(string2) :
    INDENT
        x = string2
        y = string1
    DEDENT
    else :
    INDENT
        x = string1
        y = string2
    DEDENT
    lenb = len(y)
    for c in x :
    INDENT
        if c in y :
        INDENT
            temp.append(c)
            y = list(y)
            y [y.index(c)] = None
        DEDENT
    DEDENT
    return (len(x) - len(temp)) + lenb - len(temp)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42449830_42451355_1_15
42449830_49405404_1_14
Title: Making Anagrams : Temp Anagram length subtraction method 
----------------------------------------

def anagramlength(string1, string2) :
INDENT
    temp = []
    if len(string1) > len(string2) :
    INDENT
        x = string2
        y = string1
    DEDENT
    else :
    INDENT
        x = string1
        y = string2
    DEDENT
    lenb = len(y)
    for c in x :
    INDENT
        if c in y :
        INDENT
            temp.append(c)
            y = list(y)
            y [y.index(c)] = None
        DEDENT
    DEDENT
    return (len(x) - len(temp)) + lenb - len(temp)
DEDENT
----------------------------------------

def anagramlength(str1, str2) :
INDENT
    dict = {}

    for char in str1 :
    INDENT
        if char not in dict :
        INDENT
            dict [char] = 0
        DEDENT
        dict [char] += 1
    DEDENT
    for char in str2 :
    INDENT
        if char not in dict :
        INDENT
            dict [char] = 0
        DEDENT
        dict [char] -= 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4245637_4245776_1_21
4245637_4246427_3_20
Title: Python input string error (don't want to use raw_input) 
----------------------------------------

def get_number(a, z) :
INDENT
    if a > z :
    INDENT
        a, z = z, a
    DEDENT
    while True :
    INDENT
        try :
        INDENT
            line = input('Please enter a number: ')
        DEDENT
        except EOFError :
        INDENT
            raise SystemExit()
        DEDENT
        else :
        INDENT
            if line :
            INDENT
                try :
                INDENT
                    number = int(line)
                    assert a < = number < = z
                DEDENT
                except ValueError :
                INDENT
                    print ('You must enter base 10 digits.')
                DEDENT
                except AssertionError :
                INDENT
                    print ('Your number must be in this range:', a, '-', z)
                DEDENT
                else :
                INDENT
                    return number
                DEDENT
            DEDENT
            else :
            INDENT
                print ('You must enter a number.')
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_number(a, z) :
INDENT
    if a > z :
    INDENT
        a, z = z, a
    DEDENT
    while True :
    INDENT
        line = get_line('Please enter a number: ')
        if line is None :
        INDENT
            sys.exit()
        DEDENT
        if line :
        INDENT
            number = str_to_int(line)
            if number is None :
            INDENT
                print ('You must enter base 10 digits.')
            DEDENT
            elif a < = number < = z :
            INDENT
                return number
            DEDENT
            else :
            INDENT
                print ('Your number must be in this range:', a, '-', z)
            DEDENT
        DEDENT
        else :
        INDENT
            print ('You must enter a number.')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42473402_42473459_1_14
42473402_42473574_16_26
Title: How do I have a category assigned to the hurricane based on it's wind speed In Python 
----------------------------------------

def category(windspeed) :
INDENT
    if windspeed < 74 :
    INDENT
        return 0
    DEDENT
    elif 75 < = windspeed < 96 :
    INDENT
        return 1
    DEDENT
    if 96 < = windspeed < 111 :
    INDENT
        return 2
    DEDENT
    elif 111 < = windspeed < 120 :
    INDENT
        return 3
    DEDENT
    elif 130 < = windspeed < 157 :
    INDENT
        return 4
    DEDENT
    else :
    INDENT
        return 5
    DEDENT
DEDENT
----------------------------------------

def category(windspeed, surgeamount) :
INDENT
    categorys = [1, 2, 3, 4, 5]
    for _windspeed in range(74, 95) :
    INDENT
        if _windspeed == windspeed :
        INDENT
            print "Storm category is", categorys [0]
            break
        DEDENT
    DEDENT
    else :
    INDENT
        for _windspeed in range(96, 157) :
        INDENT
            if _windspeed == windspeed :
            INDENT
                print "Storm category is", categorys [1]
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42481908_42483817_103_112
42481908_42483817_115_135
Title: Matplotlib functions in tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Start Page", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button = tk.Button(self, text = "Lets Begin",
        command = lambda : controller.show_frame(MainPage))
    button.pack()

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Graph Page!", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button1 = tk.Button(self, text = "Back to Home",
        command = lambda : controller.show_frame(StartPage))
    button1.pack()

    fig = mandelbrot_image()
    canvas = FigureCanvasTkAgg(fig, self)
    canvas.show()
    canvas.get_tk_widget().pack(side = tk.BOTTOM, fill = tk.BOTH, expand = True)
    toolbar = NavigationToolbar2TkAgg(canvas, self)
    toolbar.update()
    canvas._tkcanvas.pack(side = tk.TOP, fill = tk.BOTH, expand = True)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42481908_42483817_103_112
42481908_42483817_63_94
Title: Matplotlib functions in tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Start Page", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button = tk.Button(self, text = "Lets Begin",
        command = lambda : controller.show_frame(MainPage))
    button.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    tk.Tk.wm_title(self, "Mandelbrot Renderer")

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    menubar = tk.Menu(container)
    filemenu = tk.Menu(menubar, tearoff = 0)
    filemenu.add_separator()
    filemenu.add_command(label = "Exit", command = quit)
    menubar.add_cascade(label = "File", menu = filemenu)
    self.frames = {}
    for F in (StartPage, MainPage) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42481908_42483817_115_135
42481908_42483817_63_94
Title: Matplotlib functions in tkinter 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "Graph Page!", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button1 = tk.Button(self, text = "Back to Home",
        command = lambda : controller.show_frame(StartPage))
    button1.pack()

    fig = mandelbrot_image()
    canvas = FigureCanvasTkAgg(fig, self)
    canvas.show()
    canvas.get_tk_widget().pack(side = tk.BOTTOM, fill = tk.BOTH, expand = True)
    toolbar = NavigationToolbar2TkAgg(canvas, self)
    toolbar.update()
    canvas._tkcanvas.pack(side = tk.TOP, fill = tk.BOTH, expand = True)

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)

    tk.Tk.wm_title(self, "Mandelbrot Renderer")

    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    menubar = tk.Menu(container)
    filemenu = tk.Menu(menubar, tearoff = 0)
    filemenu.add_separator()
    filemenu.add_command(label = "Exit", command = quit)
    menubar.add_cascade(label = "File", menu = filemenu)
    self.frames = {}
    for F in (StartPage, MainPage) :
    INDENT

        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42509457_42512193_20_27
42509457_42516045_5_12
Title: turtle hop between doors 
----------------------------------------

def write_step(n) :
INDENT
    t.penup()
    px_distance = 20
    t.forward(px_distance)
    t.write("{}".format(n))
    t.back(px_distance)
    t.pendown()
DEDENT
----------------------------------------

def write_step(n, turtle) :
INDENT
    turtle.penup()
    y = turtle.ycor()
    turtle.sety(- 7)
    turtle.write(n, align = "center", font = FONT)
    turtle.sety(y)
    turtle.pendown()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42511814_42512653_18_26
42511814_42512726_9_15
Title: scrapy passing custom_settings to spider from script using CrawlerProcess.crawl() 
----------------------------------------

def parse(self, response) :
INDENT
    for quote in response.css('div.quote') :
    INDENT
        yield {
            'text' : quote.css('span.text::text').extract_first(),
            'author' : quote.css('small.author::text').extract_first(),
            'tags' : quote.css('div.tags a.tag::text').extract(),
            }

    DEDENT
DEDENT
----------------------------------------

def parse(self, response) :
INDENT
    for k, v in self.settings.items() :
    INDENT
        print ('{}: {}'.format(k, v))
    DEDENT
    yield {
        'headers' : response.body}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42522427_42522564_1_11
42522427_42522568_1_7
Title: How can I extract a two digit from a sentence using regex expression? 
----------------------------------------

def extract_number(message_text) :
INDENT
    regex_expression = 'What are the top ([0-9]{2}) trends on facebook'
    regex = re.compile(regex_expression)
    matches = regex.finditer(message_text)
    for match in matches :
    INDENT
        return match.group(1)

    DEDENT
    return None
DEDENT
----------------------------------------

def extract_number(message_text) :
INDENT
    regex_expression = 'What are the top ([a-zA-Z0-9]+) trends on facebook'
    regex = re.compile(regex_expression)
    matches = regex.findall(message_text)
    if matches :
    INDENT
        return matches [0]
    DEDENT
DEDENT
----------------------------------------
