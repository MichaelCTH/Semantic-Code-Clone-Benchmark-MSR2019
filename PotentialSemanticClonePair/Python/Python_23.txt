$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30195052_30195187_3_9
30195052_30195236_5_10
Title: How to end the loop using a method? 
----------------------------------------

def start(self) :
INDENT
    try :
    INDENT
        while True :
        INDENT
            self.stop()
        DEDENT
    DEDENT
    except StopIteration :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def start(self) :
INDENT
    self.running = True
    while self.running :
    INDENT
        self.running = not self.stop()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30195052_30195187_3_9
30195052_30195466_3_7
Title: How to end the loop using a method? 
----------------------------------------

def start(self) :
INDENT
    try :
    INDENT
        while True :
        INDENT
            self.stop()
        DEDENT
    DEDENT
    except StopIteration :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def start(self) :
INDENT
    while True :
    INDENT
        if self.stop() :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30195052_30195236_5_10
30195052_30195466_3_7
Title: How to end the loop using a method? 
----------------------------------------

def start(self) :
INDENT
    self.running = True
    while self.running :
    INDENT
        self.running = not self.stop()

    DEDENT
DEDENT
----------------------------------------

def start(self) :
INDENT
    while True :
    INDENT
        if self.stop() :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3020704_3031176_79_105
3020704_3031176_9_27
Title: Python - Bitmap won't draw/display on button 
----------------------------------------

def __init__(self, parent, ID, title) :
INDENT
    wx.Frame.__init__(self, parent, ID, title,
        wx.DefaultPosition, wx.Size(400, 400))
    self.CreateStatusBar()
    self.SetStatusText("Program testing custom button overlays")
    menu = wx.Menu()
    menu.Append(ID_ABOUT, "&About", "More information about this program")
    menu.AppendSeparator()
    menu.Append(ID_EXIT, "E&xit", "Terminate the program")
    menuBar = wx.MenuBar()
    menuBar.Append(menu, "&File");
    self.SetMenuBar(menuBar)

    s = r"D:\virtual_pc\mockup\mockupscreens\embed_images\toolbar\options.png"
    self.Button1 = Custom_Button(self, - 1,
        wx.Point(100, 100),
        wx.Bitmap(s),
        wx.Bitmap(s),
        wx.Bitmap(s))
    self.Button1.Show(True)
    EVT_MENU(self, ID_ABOUT, self.OnAbout)
    EVT_MENU(self, ID_EXIT, self.TimeToQuit)
DEDENT
----------------------------------------

def __init__(self, parent, id, Pos, Over_BMP, Norm_BMP, Push_BMP, ** kwargs) :
INDENT
    wx.PyControl.__init__(self, parent, id, ** kwargs)
    self.Bind(wx.EVT_LEFT_DOWN, self._onMouseDown)
    self.Bind(wx.EVT_LEFT_UP, self._onMouseUp)
    self.Bind(wx.EVT_LEAVE_WINDOW, self._onMouseLeave)
    self.Bind(wx.EVT_ENTER_WINDOW, self._onMouseEnter)
    self.Bind(wx.EVT_ERASE_BACKGROUND, self._onEraseBackground)
    self.Bind(wx.EVT_PAINT, self._onPaint)
    self.pos = Pos
    self.Over_bmp = Over_BMP
    self.Norm_bmp = Norm_BMP
    self.Push_bmp = Push_BMP
    self._mouseIn = False
    self._mouseDown = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30208044_33321657_12_18
30208044_43321072_20_29
Title: How to add list elements into dictionary 
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    for v in addedItems :
    INDENT
        if v in inventory.keys() :
        INDENT
            inventory [v] += 1
        DEDENT
        else :
        INDENT
            inventory [v] = 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    print ('Your inventory now has:')
    for item in addedItems :
    INDENT
        stuff [item] = stuff.get(item, 0) + 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30208044_33321657_12_18
30208044_46146960_12_19
Title: How to add list elements into dictionary 
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    for v in addedItems :
    INDENT
        if v in inventory.keys() :
        INDENT
            inventory [v] += 1
        DEDENT
        else :
        INDENT
            inventory [v] = 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    for item in addedItems :
    INDENT
        inventory.setdefault(item, 0)
        inventory [item] = inventory [item] + 1
    DEDENT
    return (inventory)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30208044_33321657_4_11
30208044_53179835_5_21
Title: How to add list elements into dictionary 
----------------------------------------

def displayInventory(inventory) :
INDENT
    print ('Inventory:')
    item_total = 0
    for k, v in inventory.items() :
    INDENT
        print (str(v) + ' ' + k)
        item_total = item_total + v
    DEDENT
    print ('Total number of items: ' + str(item_total))
DEDENT
----------------------------------------

def displayInventory(inventory) :
INDENT
    print ("Backpack:")
    itemTotal = 0
    for k, v in inventory.items() :
    INDENT
        if v > 1 :
        INDENT
            print (str(v) + ' ' + k + 's')
        DEDENT
        else :
        INDENT
            print (str(v) + ' ' + k)
        DEDENT
        itemTotal += v
    DEDENT
    print ("Total quantity of items: " + str(itemTotal))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30208044_41505410_1_8
30208044_43321072_20_29
Title: How to add list elements into dictionary 
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    for v in addedItems :
    INDENT
        if v in inventory.keys() :
        INDENT
            inventory [v] += 1
        DEDENT
        else :
        INDENT
            inventory [v] = 1
        DEDENT
    DEDENT
    return inventory
DEDENT
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    print ('Your inventory now has:')
    for item in addedItems :
    INDENT
        stuff [item] = stuff.get(item, 0) + 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30208044_41505410_1_8
30208044_46146960_12_19
Title: How to add list elements into dictionary 
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    for v in addedItems :
    INDENT
        if v in inventory.keys() :
        INDENT
            inventory [v] += 1
        DEDENT
        else :
        INDENT
            inventory [v] = 1
        DEDENT
    DEDENT
    return inventory
DEDENT
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    for item in addedItems :
    INDENT
        inventory.setdefault(item, 0)
        inventory [item] = inventory [item] + 1
    DEDENT
    return (inventory)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30208044_43321072_20_29
30208044_46146960_12_19
Title: How to add list elements into dictionary 
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    print ('Your inventory now has:')
    for item in addedItems :
    INDENT
        stuff [item] = stuff.get(item, 0) + 1

    DEDENT
DEDENT
----------------------------------------

def addToInventory(inventory, addedItems) :
INDENT
    for item in addedItems :
    INDENT
        inventory.setdefault(item, 0)
        inventory [item] = inventory [item] + 1
    DEDENT
    return (inventory)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30208044_43321072_5_14
30208044_53179835_5_21
Title: How to add list elements into dictionary 
----------------------------------------

def displayInventory(inventory) :
INDENT
    print ('Inventory:')
    item_total = 0
    for k, v in inventory.items() :
    INDENT
        print (str(v) + ' ' + k)
        item_total += v
    DEDENT
    print ("Total number of items: " + str(item_total))
DEDENT
----------------------------------------

def displayInventory(inventory) :
INDENT
    print ("Backpack:")
    itemTotal = 0
    for k, v in inventory.items() :
    INDENT
        if v > 1 :
        INDENT
            print (str(v) + ' ' + k + 's')
        DEDENT
        else :
        INDENT
            print (str(v) + ' ' + k)
        DEDENT
        itemTotal += v
    DEDENT
    print ("Total quantity of items: " + str(itemTotal))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30208044_46146960_4_11
30208044_53179835_5_21
Title: How to add list elements into dictionary 
----------------------------------------

def displayInventory(weapons) :
INDENT
    print ('Inventory')
    total = 0
    for k, v in weapons.items() :
    INDENT
        print (str(v), k)
        total += v
    DEDENT
    print ('Total number of items: ' + str(total))
DEDENT
----------------------------------------

def displayInventory(inventory) :
INDENT
    print ("Backpack:")
    itemTotal = 0
    for k, v in inventory.items() :
    INDENT
        if v > 1 :
        INDENT
            print (str(v) + ' ' + k + 's')
        DEDENT
        else :
        INDENT
            print (str(v) + ' ' + k)
        DEDENT
        itemTotal += v
    DEDENT
    print ("Total quantity of items: " + str(itemTotal))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30215470_30221940_26_37
30215470_30221940_5_13
Title: Close main window after opening a new one 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.frame = tk.Frame(master)
    master.title("a")
    self.quitButton = tk.Button(self.frame,
        text = 'Quit this TopLevel',
        width = 25, command = self.close_window)
    self.quitButton.pack()
    self.frame.pack()
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.lbl = tk.Label(master, text = "Label")
    self.lbl.pack()
    self.btn = tk.Button(master, text = "Button", command = self.command)
    self.btn.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30224933_30225485_125_154
30224933_30225485_56_73
Title: Send/sync variable/text over LAN in Python 3 
----------------------------------------

def __init__(self, parent, title = None) :
INDENT
    "Initialize a Dialog window that takes focus away from the parent."
    super().__init__(parent)
    self.withdraw()
    if parent.winfo_viewable() :
    INDENT
        self.transient(parent)
    DEDENT
    if title :
    INDENT
        self.title(title)
    DEDENT
    self.parent = parent
    self.result = None
    body = Frame(self)
    self.initial_focus = self.body(body)
    body.grid(sticky = NSEW, padx = 5, pady = 5)
    self.buttonbox()
    if not self.initial_focus :
    INDENT
        self.initial_focus = self
    DEDENT
    self.protocol('WM_DELETE_WINDOW', self.cancel)
    if self.parent is not None :
    INDENT
        self.geometry('+{}+{}'.format(parent.winfo_rootx() + 50,
                parent.winfo_rooty() + 50))
    DEDENT
    self.deiconify()
    self.initial_focus.focus_set()
    try :
    INDENT
        self.wait_visibility()
    DEDENT
    except tkinter.TclError :
    INDENT
        pass
    DEDENT
    else :
    INDENT
        self.grab_set()
        self.wait_window(self)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, master, ** kw) :
INDENT
    "Initialize the SimpleClient instance with the widgets it contains."
    super().__init__(master, ** kw)
    self.grid_rowconfigure(0, weight = 1)
    self.grid_columnconfigure(0, weight = 1)
    self.output_area = ScrolledText(self, width = 25, height = 4, wrap = WORD)
    self.input_area = Entry(self)
    self.corner = Sizegrip(self)
    self.output_area.grid(row = 0, column = 0, columnspan = 2, sticky = NSEW)
    self.input_area.grid(row = 1, column = 0, sticky = EW)
    self.corner.grid(row = 1, column = 1, sticky = SE)
    self.output_area ['state'] = DISABLED
    self.input_area.bind('<Return>', self.send)
    self.after_idle(self.connect)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30224933_30225485_164_174
30224933_30225485_218_225
Title: Send/sync variable/text over LAN in Python 3 
----------------------------------------

def buttonbox(self) :
INDENT
    "Create the standard buttons and Dialog bindings."
    box = Frame(self)
    w = Button(box, text = 'OK', width = 10, command = self.ok, default = ACTIVE)
    w.grid(row = 0, column = 0, padx = 5, pady = 5)
    w = Button(box, text = 'Cancel', width = 10, command = self.cancel)
    w.grid(row = 0, column = 1, padx = 5, pady = 5)
    self.bind('<Return>', self.ok)
    self.bind('<Escape>', self.cancel)
    box.grid()
DEDENT
----------------------------------------

def buttonbox(self) :
INDENT
    "Redefine the buttons at the bottom of the window."
    w = Button(self, text = 'Connect', width = 10, command = self.ok,
        default = ACTIVE)
    w.grid(sticky = E, padx = 5, pady = 5)
    self.bind('<Return>', self.ok)
    self.bind('<Escape>', self.cancel)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30224933_30225485_207_217
30224933_30225485_247_263
Title: Send/sync variable/text over LAN in Python 3 
----------------------------------------

def body(self, master) :
INDENT
    "Customize the Dialog window with some custom widgets."
    self.connection = None
    self.resizable(False, False)
    self.prompt = Label(master, text = 'Enter server IP address:')
    self.address = Entry(master)
    self.prompt.grid(sticky = W, padx = 30, pady = 2)
    self.address.grid(sticky = W, padx = 30)
DEDENT
----------------------------------------

def body(self, master) :
INDENT
    "Create the widgets for this Dialog and start the connection process."
    self.connection = None
    self.resizable(False, False)
    self.message = Label(master, text = 'Trying to connect to address ...')
    self.progress = Progressbar(master, orient = HORIZONTAL)
    self.message.grid(sticky = W, padx = 10, pady = 2)
    self.progress.grid(sticky = EW, padx = 10, pady = 2)
    self.progress.configure(mode = 'indeterminate', maximum = 30)
    self.progress.start()
    result = []
    start_thread(self.connect, result)
    self.after_idle(self.poll, result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30224933_30225485_269_275
30224933_30225485_74_82
Title: Send/sync variable/text over LAN in Python 3 
----------------------------------------

def connect(self, result) :
INDENT
    "Try connecting to the server address that was given."
    try :
    INDENT
        result.append(socket.create_connection(self.server_address, 10))
    DEDENT
    except socket.timeout :
    INDENT
        result.append(None)
    DEDENT
DEDENT
----------------------------------------

def connect(self) :
INDENT
    "Try connecting to a server to begin chatting."
    self.connection = Connector(self, 'Chat Client').connection
    if self.connection is None :
    INDENT
        self._root().destroy()
    DEDENT
    else :
    INDENT
        self.connection.setblocking(False)
        self.after_idle(self.update)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30236925_30267394_12_29
30236925_30267394_37_42
Title: Simpy; how to incorporate an unknown amount of interrupts 
----------------------------------------

def run(self) :
INDENT
    print ('start at time %s' % (self.env.now))
    try :
    INDENT
        yield self.env.timeout(10)
    DEDENT
    except simpy.Interrupt as interrupt :
    INDENT
        self.isInterrupted = not self.isInterrupted
        self.interruptions += 1
        print ('interrupted at time %s interrupted: %s interrupted by: %s' % (self.env.now, self.isInterrupted, interrupt.cause))
    DEDENT
    while (self.interruptions > 0) :
    INDENT
        self.interruptions = self.interruptions - 1
        try :
        INDENT
            yield self.env.timeout(5)
        DEDENT
        except simpy.Interrupt as interrupt :
        INDENT
            self.interruptions += 1
            print ('interrupted at time %s interrupted: %s interrupted by: %s' % (self.env.now, self.isInterrupted, interrupt.cause))
        DEDENT
    DEDENT
    print ('end at time %s' % (self.env.now))
DEDENT
----------------------------------------

def run(self, interrupted) :
INDENT
    for i in range(16) :
    INDENT
        yield self.env.timeout(5)
        if (not interrupted.action.processed) :
        INDENT
            interrupted.action.interrupt("interrupt nr: %s" % i)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30248995_36025637_11_19
30248995_50477123_11_26
Title: ANTLR4 and the Python target 
----------------------------------------

def main() :
INDENT
    lexer = HelloLexer(StdinStream())
    stream = CommonTokenStream(lexer)
    parser = HelloParser(stream)
    tree = parser.hi()
    printer = HelloPrintListener()
    walker = ParseTreeWalker()
    walker.walk(printer, tree)
DEDENT
----------------------------------------

def main() :
INDENT
    giveMeInput = input("say hello XXXX\n")
    print ("giveMeInput is {0}".format(giveMeInput))
    i_stream = InputStream(giveMeInput)
    lexer = HelloLexer(i_stream)
    t_stream = CommonTokenStream(lexer)
    parser = HelloParser(t_stream)
    tree = parser.hi()
    printer = HelloPrintListener()
    walker = ParseTreeWalker()
    walker.walk(printer, tree)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3025162_12115521_1_10
3025162_3025547_1_14
Title: Statistics: combinations in Python 
----------------------------------------

def choose(n, r) :
INDENT
    assert n > = 0
    assert 0 < = r < = n
    c = 1L
    denom = 1
    for (num, denom) in zip(xrange(n, n - r, - 1), xrange(1, r + 1, 1)) :
    INDENT
        c = (c * num) / / denom
    DEDENT
    return c
DEDENT
----------------------------------------

def choose(n, k) :
INDENT
    if 0 < = k < = n :
    INDENT
        ntok = 1
        ktok = 1
        for t in xrange(1, min(k, n - k) + 1) :
        INDENT
            ntok *= n
            ktok *= t
            n -= 1
        DEDENT
        return ntok / / ktok
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30257062_30260264_19_33
30257062_30260400_13_26
Title: Why does my code continue? 
----------------------------------------

def call_shape(shape) :
INDENT
    size = int(input("Enter size: "))
    while get_valid_size(size) :
    INDENT
        size = int(input("Enter size: "))
    DEDENT
    if shape == "square" :
    INDENT
        return print_square(size)
    DEDENT
    elif shape == "triangle" :
    INDENT
        return print_triangle(size)

    DEDENT
DEDENT
----------------------------------------

def call_shape(shape) :
INDENT
    size = int(input("Enter size: "))
    get_valid_size(size)
    if shape == "square" :
    INDENT
        print_square(size)
    DEDENT
    elif shape == "triangle" :
    INDENT
        print_triangle(size)
    DEDENT
    else :
    INDENT
        main()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30257062_30260264_1_18
30257062_30260400_1_12
Title: Why does my code continue? 
----------------------------------------

def main() :
INDENT
    shape = ""
    while shape ! = "q" :
    INDENT
        """main boss function"""
        shape = ""
        shape = input("Enter shape to draw (q to quit): ").lower()
        if shape == "q" :
        INDENT
            print ("Goodbye")
        DEDENT
        elif get_valid_shape(shape) :
        INDENT
            call_shape(shape)
        DEDENT
        else :
        INDENT
            print ("Unknown shape. Please try again")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    shape = input("Enter shape to draw (q to quit): ").lower()
    if shape == "q" :
    INDENT
        print ("Goodbye")
    DEDENT
    else :
    INDENT
        get_valid_shape(shape)
        call_shape(shape)
        main()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30257062_30260264_42_51
30257062_30260400_33_39
Title: Why does my code continue? 
----------------------------------------

def get_valid_shape(shape) :
INDENT
    shape_1 = shape
    shapes = ["square", "triangle", "q"]
    if shape_1 not in shapes :
    INDENT
        return False
    DEDENT
    else :
    INDENT
        return True

    DEDENT
DEDENT
----------------------------------------

def get_valid_shape(shape) :
INDENT
    while shape not in ["square", "triangle", "q"] :
    INDENT
        print ("Unknown shape. Please try again")
        main()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30278655_30279088_9_22
30278655_30279135_4_21
Title: Turtle shapes don't fill whole screen 
----------------------------------------

def rectangle(turtle) :
INDENT
    w = random.randint(10, 45)
    h = random.randint(10, 45)
    color = random.choice("aqua", "white")
    turtle.fillcolor(color)
    turtle.color(color)
    turtle.begin_fill()
    for i in range(2) :
    INDENT
        turtle.forward(h)
        turtle.right(90)
        turtle.forward(w)
        turtle.right(90)
    DEDENT
    turtle.end_fill()
DEDENT
----------------------------------------

def rectangle(a_turtle) :
INDENT
    w = random.randint(10, 45)
    h = random.randint(10, 45)
    color = random.randint(0, 2)
    if color == 0 :
    INDENT
        a_turtle.fillcolor("aqua")
        a_turtle.color("aqua")
    DEDENT
    else :
    INDENT
        a_turtle.fillcolor("white")
        a_turtle.color("white")
    DEDENT
    a_turtle.begin_fill()
    for i in range(2) :
    INDENT
        a_turtle.forward(h)
        a_turtle.right(90)
        a_turtle.forward(w)
        a_turtle.right(90)
    DEDENT
    a_turtle.end_fill()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30278704_30279265_121_128
30278704_30279295_120_127
Title: Arithmetic Encoding and Decoding Algorithm Python 
----------------------------------------

def main() :
INDENT
    count = 10
    encode_str = "heloworldheloworld"
    strlen = len(encode_str)
    every = 3
    encoded = encode(encode_str, every)
    decoded = decode(encoded, strlen, every)
DEDENT
----------------------------------------

def main() :
INDENT
    count = 10
    encode_str = "heloworldheloworld"
    strlen = len(encode_str)
    every = 3
    encoded = encode(encode_str, every)
    decoded = decode(encoded, strlen, every)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30281077_30281573_36_65
30281077_30281646_50_66
Title: Python tkinter checkboxes always returning value as 0 even when they are checked 
----------------------------------------

def checkToppings() :
INDENT
    toppingsList = ""
    olivesSelection = a.get()
    tomatoesSelection = b.get()
    pepperoniSelection = c.get()
    hotPeppersSelection = d.get()
    onionsSelection = e.get()
    hamSelection = f.get()
    sausageSelection = g.get()
    greenPeppersSelection = h.get()
    if (olivesSelection == 1) :
    INDENT
        toppingsList = toppingsList + olivesSelectionStr
    DEDENT
    if (tomatoesSelection == 1) :
    INDENT
        toppingsList = toppingsList + tomatoesSelectionStr
    DEDENT
    if (pepperoniSelection == 1) :
    INDENT
        toppingsList = toppingsList + pepperoniSelectionStr
    DEDENT
    if (hotPeppersSelection == 1) :
    INDENT
        toppingsList = toppingsList + hotPeppersSelectionStr
    DEDENT
    if (onionsSelection == 1) :
    INDENT
        toppingsList = toppingsList + onionsSelectionStr
    DEDENT
    if (hamSelection == 1) :
    INDENT
        toppingsList = toppingsList + hamSelectionStr
    DEDENT
    if (sausageSelection == 1) :
    INDENT
        toppingsList = toppingsList + sausageSelectionStr
    DEDENT
    if (greenPeppersSelection == 1) :
    INDENT
        toppingsList = toppingsList + greenPeppersSelectionStr
    DEDENT
    if toppingsList == "" :
    INDENT
        toppingsList = noToppingsStr
    DEDENT
    print (toppingsList)
DEDENT
----------------------------------------

def checkToppings() :
INDENT
    toppings = [var for val, var in zip((a.get(), b.get(), c.get(), d.get(),
                e.get(), f.get(), g.get(), h.get()),
            (olivesSelectionStr, tomatoesSelectionStr,
                pepperoniSelectionStr, hotPeppersSelectionStr,
                onionsSelectionStr, hamSelectionStr,
                sausageSelectionStr, greenPeppersSelectionStr))
        if val]
    if not toppings :
    INDENT
        return 'no toppings.'
    DEDENT
    elif len(toppings) == 1 :
    INDENT
        return toppings [0] + '.'
    DEDENT
    elif len(toppings) == 2 :
    INDENT
        return ' and '.join(toppings) + '.'
    DEDENT
    else :
    INDENT
        return ', '.join(toppings [: - 1]) + ', and ' + toppings [- 1] + '.'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3028786_3125289_1_13
3028786_4646974_232_251
Title: "How can I fix ""[Error 6] The handle is invalid."" with PySerial" 
----------------------------------------

def write(self, data) :
INDENT
    if not self.hComPort : raise portNotOpenError
    data = bytes(data)
    if data :
    INDENT

        n = win32.DWORD()
        err = win32.WriteFile(self.hComPort, data, len(data), ctypes.byref(n), self._overlappedWrite)
        if not err and win32.GetLastError() ! = win32.ERROR_IO_PENDING :
        INDENT
            raise SerialException("WriteFile failed (%s)" % ctypes.WinError())
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def write(self, data) :
INDENT
    if not self.hComPort : raise portNotOpenError
    if data :
    INDENT

        err, n = win32file.WriteFile(self.hComPort, data, self._overlappedWrite)
        if not err and win32.GetLastError() ! = win32.ERROR_IO_PENDING :
        INDENT
            raise SerialException("WriteFile failed (%s)" % ctypes.WinError())
        DEDENT
        n = win32file.GetOverlappedResult(self.hComPort, self._overlappedWrite, True)
        if n ! = len(data) :
        INDENT
            raise writeTimeoutError
        DEDENT
        return n
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30287918_30290077_1_10
30287918_30290546_13_28
Title: python fuction finding root( or zero) with minimum distance from real root epsilon 
----------------------------------------

def root(fnc, a, b, eps = 1e-8, maxtimes = None) :
INDENT
    if maxtimes == None : maxtimes = (int)(0.1 + math.ceil(math.log((b - a) / eps, 2.0) + 2))
    for counter in xrange(maxtimes + 1) :
    INDENT
        if fnc(a) > - eps : return a, - fnc(a)
        if fnc(b) < eps : return b, fnc(b)
        new_bound = (a + b) / 2.0
        print a, b, new_bound
        if fnc(new_bound) < 0 : a = new_bound
        else : b = new_bound
    DEDENT
    return new_bound, min(- fnc(a), fnc(b))
DEDENT
----------------------------------------

def root(f, a, b, eps = 1e-6) :
INDENT
    f_a = f(a)
    if abs(f_a) < eps :
    INDENT
        return a
    DEDENT
    f_b = f(b)
    if abs(f_b) < eps :
    INDENT
        return b
    DEDENT
    half = (b + a) / 2
    f_half = f(half)
    if sign(f_half) ! = sign(f_a) :
    INDENT
        return root(f, a, half, eps)
    DEDENT
    else :
    INDENT
        return root(f, half, b, eps)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294900_30294984_3_8
30294900_30295032_15_22
Title: Python random number generation 
----------------------------------------

def makelist(count) :
INDENT
    results = []
    for i in range(0, count) :
    INDENT
        results.append(random.randint(1, 100))
    DEDENT
    return results
DEDENT
----------------------------------------

def makelist(number) :
INDENT
    empty_list = []
    for i in range(0, number) :
    INDENT
        rand_number = random.randint(1, 100)
        empty_list.append(rand_number)
    DEDENT
    return empty_list

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294900_30294984_3_8
30294900_30295089_4_10
Title: Python random number generation 
----------------------------------------

def makelist(count) :
INDENT
    results = []
    for i in range(0, count) :
    INDENT
        results.append(random.randint(1, 100))
    DEDENT
    return results
DEDENT
----------------------------------------

def makelist(number) :
INDENT
    new_list = []
    for i in range(0, number) :
    INDENT
        new_rand = random.randint(1, 100)
        new_list.append(new_rand)
    DEDENT
    return new_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294900_30294984_3_8
30294900_30295181_17_25
Title: Python random number generation 
----------------------------------------

def makelist(count) :
INDENT
    results = []
    for i in range(0, count) :
    INDENT
        results.append(random.randint(1, 100))
    DEDENT
    return results
DEDENT
----------------------------------------

def makelist(c) :
INDENT
    lst = []
    for i in range(c) :
    INDENT
        lst.append(random.randint(1, 100))
    DEDENT
    return lst
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294900_30295032_15_22
30294900_30295181_17_25
Title: Python random number generation 
----------------------------------------

def makelist(number) :
INDENT
    empty_list = []
    for i in range(0, number) :
    INDENT
        rand_number = random.randint(1, 100)
        empty_list.append(rand_number)
    DEDENT
    return empty_list

DEDENT
----------------------------------------

def makelist(c) :
INDENT
    lst = []
    for i in range(c) :
    INDENT
        lst.append(random.randint(1, 100))
    DEDENT
    return lst
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294900_30295032_3_14
30294900_30295089_11_18
Title: Python random number generation 
----------------------------------------

def main() :
INDENT
    number = random.randint(6, 12)
    print 'the number is  {0}'.format(number)
    number_list = makelist(number)
    sorted_list = sorted(number_list)
    output_string = str(sorted_list [0])
    for i in range(1, number - 1) :
    INDENT
        concat = " {0}".format(str(sorted_list [i]))
        output_string += concat
    DEDENT
    print output_string
DEDENT
----------------------------------------

def main() :
INDENT
    number = random.randint(6, 12)
    print "the number is %s" % str(number)
    populated_list = makelist(number)
    populated_list.sort()
    for i in populated_list :
    INDENT
        print (str(i)),
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294900_30295032_3_14
30294900_30295181_3_16
Title: Python random number generation 
----------------------------------------

def main() :
INDENT
    number = random.randint(6, 12)
    print 'the number is  {0}'.format(number)
    number_list = makelist(number)
    sorted_list = sorted(number_list)
    output_string = str(sorted_list [0])
    for i in range(1, number - 1) :
    INDENT
        concat = " {0}".format(str(sorted_list [i]))
        output_string += concat
    DEDENT
    print output_string
DEDENT
----------------------------------------

def main() :
INDENT
    number = random.randint(6, 12)
    lst = makelist(number)
    lst.sort()
    for x in lst :
    INDENT
        print('%d ' % x, end = "")
    DEDENT
    print ('')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294900_30295089_4_10
30294900_30295181_17_25
Title: Python random number generation 
----------------------------------------

def makelist(number) :
INDENT
    new_list = []
    for i in range(0, number) :
    INDENT
        new_rand = random.randint(1, 100)
        new_list.append(new_rand)
    DEDENT
    return new_list
DEDENT
----------------------------------------

def makelist(c) :
INDENT
    lst = []
    for i in range(c) :
    INDENT
        lst.append(random.randint(1, 100))
    DEDENT
    return lst
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30318761_30319175_1_18
30318761_30319547_1_19
Title: Writing out results with function in.txt document when there's min and max? 
----------------------------------------

def parse_info() :
INDENT
    info = open("info.txt", "r")
    max_age = 0
    max_name = ''
    min_age = float('inf')
    min_name = ''
    for line in info :
    INDENT
        m_list = line.split(" ")
        if int(m_list [1]) > max_age :
        INDENT
            max_age = int(m_list [1])
            max_name = m_list [0]
        DEDENT
        elif int(m_list [1]) < min_age :
        INDENT
            min_age = int(m_list [1])
            min_name = m_list [0]
        DEDENT
    DEDENT
    info.close()
    return ((min_name, min_age), (max_name, max_age))
DEDENT
----------------------------------------

def parse_info() :
INDENT
    persons = set()
    for line in open('info.txt') :
    INDENT
        name, age = line.split()
        persons.add((int(age), name))

    DEDENT
    persons = sorted(list(persons))

    fd = open('new_info.txt', 'w')
    age, name = persons [0]
    fd.write('Youngest: %s %d\n' % (name, age))
    age, name = persons [- 1]
    fd.write('Oldest: %s %d\n' % (name, age))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30321337_30321586_3_11
30321337_30321845_3_12
Title: Python: group a list basing on pairs of items 
----------------------------------------

def group_and_split(mydata, static_mapping) :
INDENT
    remainder = copy.deepcopy(mydata)
    couples = []
    for couple in static_mapping :
    INDENT
        if couple [0] in mydata and couple [1] in mydata :
        INDENT
            remainder.remove(couple [0])
            remainder.remove(couple [1])
            couples.append(couple)
        DEDENT
    DEDENT
    return [couples, remainder]
DEDENT
----------------------------------------

def group_and_split(mydata, static_mapping) :
INDENT
    temp = set(mydata)
    couples = []
    remainder = deepcopy(mydata)
    for value1, value2 in static_mapping :
    INDENT
        if value1 in temp and value2 in temp :
        INDENT
            couples.append((value1, value2))
            remainder.remove(value1)
            remainder.remove(value2)
        DEDENT
    DEDENT
    return couples, remainder
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30321567_30322574_1_29
30321567_30322747_1_20
Title: How to make a program sort ages into age groups with my program? 
----------------------------------------

def parse_info(filename) :
INDENT
    max_age = 0
    max_name = ''
    min_age = float('inf')
    min_name = ''
    list_of_0_6 = []
    list_of_7_15 = []
    list_of_16_30 = []
    with open(filename, 'r') as info :
    INDENT
        lines = info.read().splitlines()
    DEDENT
    for line in lines :
    INDENT
        name, age = line.split()
        age = int(age)
        if age < min_age :
        INDENT
            min_age = age
            min_name = name
        DEDENT
        if age > max_age :
        INDENT
            max_age = age
            max_name = name
        DEDENT
        if age < 7 :
        INDENT
            list_of_0_6.append(line)
        DEDENT
        elif age < 16 :
        INDENT
            list_of_7_15.append(line)
        DEDENT
        else :
        INDENT
            list_of_16_30.append(line)
        DEDENT
    DEDENT
    return [min_name, str(min_age), max_name, str(max_age), list_of_0_6, list_of_7_15, list_of_16_30]
DEDENT
----------------------------------------

def parse_info(filepath) :
INDENT
    people_list = []
    groups = {"0-6" : [], "7-15" : [], "19-30" : []}
    with open(filepath, 'r') as info :
    INDENT
        for line in info :
        INDENT
            people_list.append({"name" : line.split(" ") [0], "age" : line.split(" ") [1]})
        DEDENT
        people_list = sorted(people_list, key = lambda k : k ['age'])
        youngest = people_list [0]
        oldest = people_list [- 1]
        for person in people_list :
        INDENT
            if 0 < = person ['age'] < 7 :
            INDENT
                groups ['0-6'].append(person)
            DEDENT
            elif 7 < = person ['age'] < 16 :
            INDENT
                groups ['7-15'].append(person)
            DEDENT
            elif 19 < = person ['age'] < = 30 :
            INDENT
                groups ['19-30'].append(person)
            DEDENT
        DEDENT
    DEDENT
    return youngest, oldest, groups

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30334424_30337026_13_20
30334424_30338048_47_54
Title: "Python ""shutdown / reboot raspberry pi"" script using a single button" 
----------------------------------------

def main(pin) :
INDENT
    while True :
    INDENT
        print "main loop"
        gpio.remove_event_detect(22)
        gpio.add_event_detect(22, gpio.RISING, callback = confirmation, bouncetime = 200)
        sleep(1)

    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    resetPin(22)
    while True :
    INDENT
        sleep(1)
        if gpio.event_detected(22) :
        INDENT
            confirmation(22)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30334424_30337026_21_30
30334424_30338048_10_22
Title: "Python ""shutdown / reboot raspberry pi"" script using a single button" 
----------------------------------------

def confirmation(pin) :
INDENT
    print "confirmation1"
    sleep(5)
    print "confirmation2"
    gpio.remove_event_detect(22)
    gpio.add_event_detect(22, gpio.RISING, callback = shutdown, bouncetime = 200)
    sleep(5)
    gpio.remove_event_detect(22)
    main(22)
DEDENT
----------------------------------------

def confirmation(pin) :
INDENT
    system('echo Press again to confirm Shut down menu! | wall -n')
    gpio.remove_event_detect(pin)
    gpio.add_event_detect(pin, gpio.RISING, bouncetime = 200)
    sleep(2)
    if gpio.event_detected(pin) :
    INDENT
        shutdown(pin)
    DEDENT
    else :
    INDENT

        system('echo Shut down canceled! | wall -n')
        main()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30334424_30337026_38_47
30334424_30338048_34_46
Title: "Python ""shutdown / reboot raspberry pi"" script using a single button" 
----------------------------------------

def shutdown(pin) :
INDENT
    print "shutdown"
    gpio.remove_event_detect(pin)
    gpio.add_event_detect(22, gpio.RISING, callback = reboot, bouncetime = 200)
    sleep(3)
    if rebootBool == 0 :
    INDENT
        print "halt"
    DEDENT
    exit(0)
DEDENT
----------------------------------------

def shutdown(pin) :
INDENT
    system('echo Press again if you want to reboot instead of shut down! | wall -n')
    gpio.remove_event_detect(pin)
    gpio.add_event_detect(pin, gpio.RISING, bouncetime = 200)
    sleep(2)
    if gpio.event_detected(pin) :
    INDENT
        reboot(pin)
    DEDENT
    else :
    INDENT
        call('halt', shell = False)
        exit(0)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30335257_34049583_1_10
30335257_34049583_2_9
Title: Sublime Text 3 Stop Auto-Complete From Committing on 'Space' 
----------------------------------------

def _show_auto_complete(self, view) :
INDENT
    def _show_auto_complete() :
    INDENT
        view.run_command('auto_complete', {
                'disable_auto_insert' : True,
                'api_completions_only' : True,
                'next_completion_if_showing' : False,
                'auto_complete_commit_on_tab' : True,
                })
    DEDENT
    sublime.set_timeout(_show_auto_complete, 0)
DEDENT
----------------------------------------

def _show_auto_complete() :
INDENT
    view.run_command('auto_complete', {
            'disable_auto_insert' : True,
            'api_completions_only' : True,
            'next_completion_if_showing' : False,
            'auto_complete_commit_on_tab' : True,
            })
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30338430_35982790_1_18
30338430_50269175_1_41
Title: Humanize numbers with python 
----------------------------------------

def humanize_number(value, fraction_point = 1) :
INDENT
    powers = [10 ** x for x in (12, 9, 6, 3, 0)]
    human_powers = ('T', 'B', 'M', 'K', '')
    is_negative = False
    if not isinstance(value, float) :
    INDENT
        value = float(value)
    DEDENT
    if value < 0 :
    INDENT
        is_negative = True
        value = abs(value)
    DEDENT
    for i, p in enumerate(powers) :
    INDENT
        if value > = p :
        INDENT
            return_value = str(round(value / (p / (10.0 ** fraction_point))) /
                (10 ** fraction_point)) + human_powers [i]
            break
        DEDENT
    DEDENT
    if is_negative :
    INDENT
        return_value = "-" + return_value
    DEDENT
    return return_value
DEDENT
----------------------------------------

def humanize_number(value, significant_digits = 3, strip_trailing_zeros = True) :
INDENT
    powers = [10 ** x for x in (12, 9, 6, 3, 0, - 3, - 6, - 9)]
    human_powers = ['T', 'B', 'M', 'K', '', 'm', u'Âµ', 'n']
    is_negative = False
    suffix = ''
    if not isinstance(value, float) :
    INDENT
        value = float(value)
    DEDENT
    if value < 0 :
    INDENT
        is_negative = True
        value = abs(value)
    DEDENT
    if value == 0 :
    INDENT
        decimal_places = max(0, significant_digits - 1)
    DEDENT
    elif.001 < = value < 1 :
    INDENT
        decimal_places = max(0, significant_digits - int(floor(log10(value))) - 1)
    DEDENT
    else :
    INDENT
        p = next((x for x in powers if value > = x), 10 ** - 9)
        i = powers.index(p)
        value = value / p
        before = int(log10(value)) + 1
        decimal_places = max(0, significant_digits - before)
        suffix = human_powers [i]
    DEDENT
    return_value = ("%." + str(decimal_places) + "f") % value
    if is_negative :
    INDENT
        return_value = "-" + return_value
    DEDENT
    if strip_trailing_zeros and '.' in return_value :
    INDENT
        return_value = return_value.rstrip('0').rstrip('.')
    DEDENT
    return return_value + suffix
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3033952_50265824_18_32
3033952_7257510_13_23
Title: Threading pool similar to the multiprocessing Pool? 
----------------------------------------

def run(self) :
INDENT
    while not self.done.is_set() :
    INDENT
        try :
        INDENT
            func, args, kwargs = self.tasks.get(block = True,
                timeout = self._TIMEOUT)
            try :
            INDENT
                func(* args, ** kwargs)
            DEDENT
            except Exception as e :
            INDENT
                print (e)
            DEDENT
            finally :
            INDENT
                self.tasks.task_done()
            DEDENT
        DEDENT
        except Empty as e :
        INDENT
            pass
        DEDENT
    DEDENT
    return
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        func, args, kargs = self.tasks.get()
        try :
        INDENT
            func(* args, ** kargs)
        DEDENT
        except Exception, e :
        INDENT
            print e
        DEDENT
        finally :
        INDENT
            self.tasks.task_done()

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30343225_30343393_11_17
30343225_30343536_6_14
Title: How to handle errors related to sys.argv[] in python ? 
----------------------------------------

def csv_open(self) :
INDENT
    if os.path.isfile(self.csv_path) :
    INDENT
        self.r = pd.read_csv(self.csv_path)
    DEDENT
    else :
    INDENT
        return self.r
    DEDENT
DEDENT
----------------------------------------

def csv_open(self) :
INDENT
    try :
    INDENT
        self.r = pd.read_csv(self.csv_path)
    DEDENT
    except IndexError :
    INDENT
        print "Cannot open the file: "
    DEDENT
    else :
    INDENT
        return self.r

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30345266_30346406_1_6
30345266_38221742_13_23
Title: Wagtail: Get previous or next sibling 
----------------------------------------

def prev_portrait(self) :
INDENT
    if self.get_prev_sibling() :
    INDENT
        return self.get_prev_sibling().url
    DEDENT
    else :
    INDENT
        return self.get_siblings().last().url
    DEDENT
DEDENT
----------------------------------------

def prev_portrait(self) :
INDENT
    previous_sibling = self.get_prev_sibling()
    if previous_sibling and previous_sibling.live :
    INDENT
        return previous_sibling.url
    DEDENT
    else :
    INDENT
        previous_published_siblings = self.get_prev_siblings(
            inclusive = False).live()
        if len(previous_published_siblings) :
        INDENT
            return previous_published_siblings [0].url
        DEDENT
        return self.get_siblings().live().last().url
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30345266_30346406_7_11
30345266_38221742_1_12
Title: Wagtail: Get previous or next sibling 
----------------------------------------

def next_portrait(self) :
INDENT
    if self.get_next_sibling() :
    INDENT
        return self.get_next_sibling().url
    DEDENT
    else :
    INDENT
        return self.get_siblings().first().url
    DEDENT
DEDENT
----------------------------------------

def next_portrait(self) :
INDENT
    next_sibling = self.get_next_sibling()
    if next_sibling and next_sibling.live :
    INDENT
        return next_sibling.url
    DEDENT
    else :
    INDENT
        next_published_siblings = self.get_next_siblings(
            inclusive = False).live()
        if len(next_published_siblings) :
        INDENT
            return next_published_siblings [0].url
        DEDENT
        return self.get_siblings().live().first().url
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30346359_30346511_1_12
30346359_30346542_1_11
Title: If and elif statement 
----------------------------------------

def run() :
INDENT
    a = 10
    b = 20
    c = 30
    if (a == 15) and (b == 20) and (c == 30) :
    INDENT
        print ('a is diff')
    DEDENT
    elif (a == 10) and (b == 20) and (c == 30) :
    INDENT
        print ('same')
    DEDENT
    elif (a == 15) and (b == 40) and (c == 30) :
    INDENT
        print ('a is diff')
    DEDENT
    else :
    INDENT
        print ('Other')
    DEDENT
DEDENT
----------------------------------------

def run() :
INDENT
    a = 10
    b = 20
    c = 30
    if a == 15 and b == 20 and c == 30 :
    INDENT
        print ('a is diff')
    DEDENT
    elif a == 10 and b == 20 and c == 30 :
    INDENT
        print ('same')
    DEDENT
    elif a == 15 and b == 40 and c == 30 :
    INDENT
        print ('a is diff')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3038034_18050229_12_22
3038034_3040042_11_22
Title: How can I make python be more friendly regarding reading and writing Unicode text files? 
----------------------------------------

def read_unicode(file_path) :
INDENT
    with io.open(file_path, 'rb') as f :
    INDENT
        data = f.read(4)
    DEDENT
    for bom, encoding, seek_to in _boms :
    INDENT
        if data.startswith(bom) :
        INDENT
            break
        DEDENT
    DEDENT
    else :
    INDENT
        encoding, seek_to = 'utf-8', 0
    DEDENT
    with io.open(file_path, 'r', encoding = encoding) as f :
    INDENT
        f.seek(seek_to)
        return f.read()
    DEDENT
DEDENT
----------------------------------------

def read_unicode(filename) :
INDENT
    the_text = open(filename, 'r').read()
    for bom, encoding in bomdict.items() :
    INDENT
        if the_text.startswith(bom) :
        INDENT
            logging.info('BOM found, using %s', encoding)
            the_text = the_text [len(bom) :]
            break
        DEDENT
    DEDENT
    else :
    INDENT
        logging.info('No BOM, using utf8')
        encoding = 'UTF8'
    DEDENT
    return the_text.decode(encoding)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30382556_30382909_2_11
30382556_30382926_3_10
Title: Python - Count number of times function passes through decorator 
----------------------------------------

def count_check(function, count = {}) :
INDENT
    count [function] = 0
    @ wraps(function)
    def increase_count(* args, ** kwargs) :
    INDENT
        count [function] += 1
        return function(* args, ** kwargs), count [function], sum(count.values())
    DEDENT
    return increase_count
DEDENT
----------------------------------------

def count_check(function) :
INDENT
    @ wraps(function)
    def increase_count(* args, ** kwargs) :
    INDENT
        global count
        count += 1
        return function(* args, ** kwargs), count
    DEDENT
    return increase_count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386262_10_15
30386194_30386282_3_8
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def makelist(random_int) :
INDENT
    num_list = []
    for count in range(random_int) :
    INDENT
        num_list.append(random.randint(1, 100))
    DEDENT
    return num_list
DEDENT
----------------------------------------

def makelist(i) :
INDENT
    list_ = []
    for c in range(i) :
    INDENT
        list_.append(random.randint(1, 100))
    DEDENT
    return list_
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386262_10_15
30386194_30386313_9_15
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def makelist(random_int) :
INDENT
    num_list = []
    for count in range(random_int) :
    INDENT
        num_list.append(random.randint(1, 100))
    DEDENT
    return num_list
DEDENT
----------------------------------------

def makelist(random_int) :
INDENT
    num_list = []
    for count in range(random_int) :
    INDENT
        rand = random.randint(1, 100)
        num_list.append(rand)
    DEDENT
    return num_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386262_10_15
30386194_30466974_12_17
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def makelist(random_int) :
INDENT
    num_list = []
    for count in range(random_int) :
    INDENT
        num_list.append(random.randint(1, 100))
    DEDENT
    return num_list
DEDENT
----------------------------------------

def makelist(list_length) :
INDENT
    global random_list
    random_list = []
    for x in range(list_length) :
    INDENT
        random_list.append(random.randint(0, 100))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386262_3_9
30386194_30386272_3_11
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 12)
    print (random_int)
    elements = makelist(random_int)
    for i in sorted(elements) :
    INDENT
        print (i,)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 13)
    print (random_int)
    rand_list = make_list(random_int)
    num_string = ""
    for i in sorted(rand_list) :
    INDENT
        num_string += str(i) + " "
    DEDENT
    return num_string
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386262_3_9
30386194_30386313_4_8
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 12)
    print (random_int)
    elements = makelist(random_int)
    for i in sorted(elements) :
    INDENT
        print (i,)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 12)
    print (random_int)
    for i in sorted(makelist(random_int)) :
    INDENT
        print i,
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386262_3_9
30386194_30466974_3_11
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 12)
    print (random_int)
    elements = makelist(random_int)
    for i in sorted(elements) :
    INDENT
        print (i,)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    global random_int
    random_int = random.randint(5, 13)
    print random_int
    makelist(random_int)
    random_list.sort
    string = ' '.join([str(x) for x in random_list])
    print string
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386272_3_11
30386194_30386313_4_8
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 13)
    print (random_int)
    rand_list = make_list(random_int)
    num_string = ""
    for i in sorted(rand_list) :
    INDENT
        num_string += str(i) + " "
    DEDENT
    return num_string
DEDENT
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 12)
    print (random_int)
    for i in sorted(makelist(random_int)) :
    INDENT
        print i,
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386272_3_11
30386194_30466974_3_11
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 13)
    print (random_int)
    rand_list = make_list(random_int)
    num_string = ""
    for i in sorted(rand_list) :
    INDENT
        num_string += str(i) + " "
    DEDENT
    return num_string
DEDENT
----------------------------------------

def main() :
INDENT
    global random_int
    random_int = random.randint(5, 13)
    print random_int
    makelist(random_int)
    random_list.sort
    string = ' '.join([str(x) for x in random_list])
    print string
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386282_3_8
30386194_30386313_9_15
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def makelist(i) :
INDENT
    list_ = []
    for c in range(i) :
    INDENT
        list_.append(random.randint(1, 100))
    DEDENT
    return list_
DEDENT
----------------------------------------

def makelist(random_int) :
INDENT
    num_list = []
    for count in range(random_int) :
    INDENT
        rand = random.randint(1, 100)
        num_list.append(rand)
    DEDENT
    return num_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386282_3_8
30386194_30466974_12_17
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def makelist(i) :
INDENT
    list_ = []
    for c in range(i) :
    INDENT
        list_.append(random.randint(1, 100))
    DEDENT
    return list_
DEDENT
----------------------------------------

def makelist(list_length) :
INDENT
    global random_list
    random_list = []
    for x in range(list_length) :
    INDENT
        random_list.append(random.randint(0, 100))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386313_4_8
30386194_30466974_3_11
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def main() :
INDENT
    random_int = random.randint(6, 12)
    print (random_int)
    for i in sorted(makelist(random_int)) :
    INDENT
        print i,
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    global random_int
    random_int = random.randint(5, 13)
    print random_int
    makelist(random_int)
    random_list.sort
    string = ' '.join([str(x) for x in random_list])
    print string
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30386194_30386313_9_15
30386194_30466974_12_17
Title: Program to generate a random length list of random numbers in Python 
----------------------------------------

def makelist(random_int) :
INDENT
    num_list = []
    for count in range(random_int) :
    INDENT
        rand = random.randint(1, 100)
        num_list.append(rand)
    DEDENT
    return num_list
DEDENT
----------------------------------------

def makelist(list_length) :
INDENT
    global random_list
    random_list = []
    for x in range(list_length) :
    INDENT
        random_list.append(random.randint(0, 100))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30410795_30410853_1_6
30410795_30410858_3_10
Title: print the ratio of Fibonacci numbers until a specific condition 
----------------------------------------

def F(n) :
INDENT
    a, b = 0, 1
    for i in range(0, n) :
    INDENT
        a, b = b, a + b
    DEDENT
    return a, b
DEDENT
----------------------------------------

def F(n) :
INDENT
    global a
    global b
    a, b = 0, 1
    for i in range(0, n) :
    INDENT
        a, b = b, a + b
    DEDENT
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30410795_30410853_1_6
30410795_30410877_1_5
Title: print the ratio of Fibonacci numbers until a specific condition 
----------------------------------------

def F(n) :
INDENT
    a, b = 0, 1
    for i in range(0, n) :
    INDENT
        a, b = b, a + b
    DEDENT
    return a, b
DEDENT
----------------------------------------

def F(n) :
INDENT
    a, b = 0, 1
    for i in range(0, n) :
    INDENT
        a, b = b, a + b
    DEDENT
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30410795_30410858_3_10
30410795_30410877_1_5
Title: print the ratio of Fibonacci numbers until a specific condition 
----------------------------------------

def F(n) :
INDENT
    global a
    global b
    a, b = 0, 1
    for i in range(0, n) :
    INDENT
        a, b = b, a + b
    DEDENT
    return a
DEDENT
----------------------------------------

def F(n) :
INDENT
    a, b = 0, 1
    for i in range(0, n) :
    INDENT
        a, b = b, a + b
    DEDENT
    return a
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30413458_30441868_19_27
30413458_30441868_8_16
Title: Adding Navigation Toolbar to the Figure (matplotlib and PyQt4) 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    self.canvas = MplCanvas()
    self.navi_toolbar = NavigationToolbar(self.canvas, self)
    self.vbl = QtGui.QVBoxLayout()
    self.vbl.addWidget(self.canvas)
    self.vbl.addWidget(self.navi_toolbar)
    self.setLayout(self.vbl)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.fig = Figure()
    self.ax = self.fig.add_subplot(111)
    FigureCanvas.__init__(self, self.fig)
    FigureCanvas.setSizePolicy(self, QtGui.QSizePolicy.Expanding, QtGui.QSizePolicy.Expanding)
    FigureCanvas.updateGeometry(self)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30423397_30423764_22_29
30423397_30423764_42_53
Title: How to make an animation of rocket motion in matplotlib? 
----------------------------------------

def __init__(self) :
INDENT
    self.x_data = []
    self.y_data = []
    self.fig, self.ax = plt.subplots()
    plt.ylabel(r'Position [m]', fontsize = 16)
    plt.xlabel('Time [s]', fontsize = 16)
    plt.title('Position with respect to time', fontsize = 18)
DEDENT
----------------------------------------

def __init__(self, xmax, ymax) :
INDENT
    self.x_data = []
    self.y_data = []
    self.fig = plt.figure()
    self.ax = plt.axes(xlim = (0, xmax), ylim = (0, ymax))
    self.line, = self.ax.plot(self.x_data, self.y_data)
    self.line.set_data([], [])
    plt.ylabel(r'Position [m]', fontsize = 16)
    plt.xlabel('Time [s]', fontsize = 16)
    plt.title('Position with respect to time', fontsize = 18)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3042856_3042891_12_23
3042856_3042966_7_20
Title: Python script to remove lines from file containing words in array 
----------------------------------------

def fixup(filename) :
INDENT
    print "fixup ", filename
    fin = open(filename)
    fout = open(filename2, "w")
    for line in fin :
    INDENT
        if line_offends(line, offending) :
        INDENT
            continue
        DEDENT
        fout.write(line)
    DEDENT
    fin.close()
    fout.close()

DEDENT
----------------------------------------

def fixup(filename) :
INDENT
    print "fixup ", filename
    fin = open(filename)
    fout = open(filename2, "w")
    for line in fin.readlines() :
    INDENT
        for item in offending :
        INDENT
            print "got one", line
            line = line.replace(item, "MUST DELETE")
            line = line.strip()
            fout.write(line)
        DEDENT
    DEDENT
    fin.close()
    fout.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3042856_3042899_6_15
3042856_3042966_7_20
Title: Python script to remove lines from file containing words in array 
----------------------------------------

def fixup(filename) :
INDENT
    fin = open(filename)
    fout = open(filename2, "w")
    for line in fin :
    INDENT
        if True in [item in line for item in offending] :
        INDENT
            continue
        DEDENT
        fout.write(line)
    DEDENT
    fin.close()
    fout.close()
DEDENT
----------------------------------------

def fixup(filename) :
INDENT
    print "fixup ", filename
    fin = open(filename)
    fout = open(filename2, "w")
    for line in fin.readlines() :
    INDENT
        for item in offending :
        INDENT
            print "got one", line
            line = line.replace(item, "MUST DELETE")
            line = line.strip()
            fout.write(line)
        DEDENT
    DEDENT
    fin.close()
    fout.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3043394_3048602_12_24
3043394_3048602_80_88
Title: "Python TCP Server writing to clients?" 
----------------------------------------

def __init__(self, who, sock, server) :
INDENT
    '''who - client address
        sock - client socket
        server - server object for this client
        '''
    self.who = who
    self.readbuf = ''
    self.writbuf = ''
    self.server = server
    self.sock = sock
DEDENT
----------------------------------------

def __init__(self, ip = '127.0.0.1', port = 9999) :
INDENT
    self.ssock = socket.socket()
    self.ssock.bind((ip, port))
    self.ssock.listen(5)
    self.readers = [self.ssock]
    self.data = {}
    self.writers = []
    self.quit = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30443942_44456072_29_38
30443942_44456072_77_88
Title: Python architecture to connect to remote sensor 
----------------------------------------

def __init__(self, callback) :
INDENT
    self.callback = callback
    context = zmq.Context()
    socket = context.socket(zmq.SUB)
    socket.bind('tcp://*:8081')
    self.stream = ZMQStream(socket)
    self.stream.on_recv(self.callback)
    socket.setsockopt(zmq.SUBSCRIBE, "")
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Handler, self).__init__(* args, ** kwargs)

    self.req_id = str(self.application.req_id) + "#"
    self.application.req_id += 1

    self.set_header("Access-Control-Allow-Origin", "*")
    self.set_header("Access-Control-Allow-Headers", "x-requested-with")
    self.set_header('Access-Control-Allow-Methods', 'POST, GET, OPTIONS, PUT')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30456691_30457145_57_64
30456691_30457145_71_85
Title: finding local maximum from fft of a signal 
----------------------------------------

def onselect(self, verts) :
INDENT
    path = Path(verts)
    self.ind = np.nonzero([path.contains_point(xy) for xy in self.xys]) [0]
    self.fc [:, - 1] = self.alpha_other
    self.fc [self.ind, - 1] = 1
    self.collection.set_facecolors(self.fc)
    self.canvas.draw_idle()
DEDENT
----------------------------------------

def onselect(xmin, xmax) :
INDENT
    indmin, indmax = np.searchsorted(x, (xmin, xmax))
    indmax = min(len(x) - 1, indmax)
    thisx = x [indmin : indmax]
    thisy = y [indmin : indmax]
    line2.set_data(thisx, thisy)
    ax2.set_xlim(thisx [0], thisx [- 1])
    ax2.set_ylim(thisy.min(), thisy.max())
    fig.canvas.draw()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30474315_30516872_14_35
30474315_30516872_75_105
Title: "wxPython Paint Damaged Clipped area" 
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Panel.__init__(self, parent, id)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.settings_sizer = wx.BoxSizer(wx.HORIZONTAL)
    p = MovablePanel(self, - 1)
    self.c = wx.CheckBox(self, - 1, label = "Ghosting On?")
    self.p = p
    self.i = 0
    self.settings_sizer.Add(self.c)
    self.sizer.Add(self.settings_sizer)
    self.sizer.Add(self.p)
    self.SetSizer(self.sizer)
    self.Layout()
    self.Bind(wx.EVT_CHECKBOX, self.OnCheck, self.c)
    self.Bind(wx.EVT_PAINT, self.OnPaint, self)
    self.Bind(wx.EVT_ERASE_BACKGROUND, self.OnErase, self)

DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Panel.__init__(self, parent, id)
    self.SetMinSize((300, 300))
    self.SetSize((300, 300))
    txt = wx.StaticText(self, - 1, label = "CLICK AND DRAG ME!")
    inst = wx.StaticText(self, - 1, label = instructions)
    font = wx.Font(18, wx.SWISS, wx.NORMAL, wx.BOLD)
    txt.SetFont(font)
    inst.SetFont(font)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(txt, flag = wx.ALIGN_CENTRE_VERTICAL | wx.ALIGN_CENTRE_HORIZONTAL)
    sizer.Add(inst, flag = wx.ALIGN_CENTRE_VERTICAL | wx.ALIGN_CENTRE_HORIZONTAL)
    self.SetSizer(sizer)
    self.SetBackgroundColour("PINK")
    self.LEFT_DOWN = False
    self.r = False
    self.Bind(wx.EVT_MOTION, self.OnMove, self)
    self.Bind(wx.EVT_LEFT_DOWN,
        self.OnClickDown,
        self)

    self.Bind(wx.EVT_LEFT_UP,
        self.OnClickUp,
        self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30489308_30489525_10_19
30489308_30489525_24_38
Title: creating a custom widget in tkinter 
----------------------------------------

def __init__(self, parent, label, default = "") :
INDENT
    tk.Frame.__init__(self, parent)
    self.label = tk.Label(self, text = label, anchor = "w")
    self.entry = tk.Entry(self)
    self.entry.insert(0, default)
    self.label.pack(side = "top", fill = "x")
    self.entry.pack(side = "bottom", fill = "x", padx = 4)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self, parent)
    self.label = tk.Label(self)
    self.e1 = CustomWidget(self, "First Name:", "Inigo")
    self.e2 = CustomWidget(self, "Last Name:", "Montoya")
    self.submitButton = tk.Button(self, text = "Submit", command = self.submit)
    self.e1.grid(row = 0, column = 0, sticky = "ew")
    self.e2.grid(row = 1, column = 0, sticky = "ew")
    self.label.grid(row = 2, column = 0, sticky = "ew")
    self.submitButton.grid(row = 4, column = 0)
    self.grid_columnconfigure(0, weight = 1)
    self.grid_rowconfigure(2, weight = 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30491282_30640795_11_18
30491282_30640795_41_69
Title: Threaded upload with timeout in Python and PySide 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(UploadThread, self).__init__(parent)
    self.endNow = False
    self.fileName = None
    self.sig = MySigObj()
    self.fileNames = []
    self.uploaded = []
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(ULoadWin, self).__init__(parent)
    self.upThread = UploadThread()
    self.sig = MySigObj()
    self.sig.tupSig.connect(self.upThread.setFileNames)
    self.upThread.sig.strSig.connect(self.txtMsgAppend)
    self.sig.tupSig.connect(self.upThread.setFileNames)
    self.layout = QtGui.QVBoxLayout()
    self.stButton = QtGui.QPushButton("Start")
    self.stButton.clicked.connect(self.uploadItems)
    self.stpButton = QtGui.QPushButton("Stop")
    self.stpButton.clicked.connect(self.killThread)
    self.testButton = QtGui.QPushButton("write txt\n not(?) blocked \nbelow")
    self.testButton.setMinimumHeight(28)
    self.testButton.clicked.connect(self.tstBlking)
    self.lbl = QtGui.QTextEdit()
    self.lbl.setMinimumHeight(325)
    self.lbl.setMinimumWidth(290)
    self.layout.addWidget(self.stButton)
    self.layout.addWidget(self.stpButton)
    self.layout.addWidget(self.testButton)
    self.layout.addWidget(self.lbl)
    self.setLayout(self.layout)
    self.l = ['a', 'list', 'of_files', 'we', 'will_pretend_to_upload', 'st', 'uploading']
    self.upThread.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30491282_30640795_23_38
30491282_30673296_10_23
Title: Threaded upload with timeout in Python and PySide 
----------------------------------------

def run(self) :
INDENT
    while self.fileNames :
    INDENT
        print (self.fileNames)
        time.sleep(2)
        name = self.fileNames.pop(0)
        s = 'uploaded file: ' + name + '\n'
        print (s)
        self.sig.strSig.emit(s)
        self.uploaded.append(name)
        if len(self.fileNames) == 0 :
        INDENT
            self.sig.strSig.emit("files transmitted: %s" % str(self.uploaded))
        DEDENT
    DEDENT
    else :
    INDENT
        time.sleep(1)

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while not self.stoprequest.isSet() :
    INDENT
        try :
        INDENT

            num = self.input_q.get(True, 0.1)
            print 'In thread, processing', num
            time.sleep(0.5)
            self.result_q.put(True)
        DEDENT
        except Queue.Empty as e :
        INDENT
            continue
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30518282_30530510_44_57
30518282_30530510_4_39
Title: wxPython Notebook Pages 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = 'Notebooks')
    panel = wx.Panel(self)
    notebook = wx.Notebook(panel)
    page_one = PageOne(notebook)
    notebook.AddPage(page_one, 'Page 1')
    main_sizer = wx.BoxSizer(wx.VERTICAL)
    main_sizer.Add(notebook, 1, wx.EXPAND)
    panel.SetSizer(main_sizer)
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    vbox_left = wx.BoxSizer(wx.VERTICAL)
    vbox_right = wx.BoxSizer(wx.VERTICAL)
    hbox = wx.BoxSizer(wx.HORIZONTAL)
    driveList = ["D:/", "E:/"]
    font = wx.Font(14, wx.SWISS, wx.NORMAL, wx.NORMAL)
    label = wx.StaticText(self, - 1, "Audio Source")
    label.SetFont(font)
    label.SetSize(label.GetBestSize())
    self.combo1 = wx.ComboBox(self, style = wx.CB_DROPDOWN, choices = driveList)
    self.listbox = wx.ListBox(self, 1, size = (380, 220))
    vbox_left.Add(label, 0, wx.BOTTOM | wx.TOP | wx.ALIGN_CENTER_HORIZONTAL, 5)
    vbox_left.Add(self.combo1, 0, wx.EXPAND | wx.ALIGN_CENTER_HORIZONTAL | wx.LEFT | wx.RIGHT, 15)
    vbox_left.Add(self.listbox, 1, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 15)
    label = wx.StaticText(self, - 1, "Local Disk")
    label.SetFont(font)
    label.SetSize(label.GetBestSize())
    self.combo2 = wx.ComboBox(self, style = wx.CB_DROPDOWN, choices = driveList)
    self.listbox = wx.ListBox(self, 0, size = (380, 220))
    vbox_right.Add(label, 0, wx.BOTTOM | wx.TOP | wx.ALIGN_CENTER_HORIZONTAL, 5)
    vbox_right.Add(self.combo2, 0, wx.EXPAND | wx.ALIGN_CENTER_HORIZONTAL | wx.LEFT | wx.RIGHT, 15)
    vbox_right.Add(self.listbox, 1, wx.EXPAND | wx.LEFT | wx.RIGHT | wx.TOP, 15)
    hbox.Add(vbox_left, 0, wx.EXPAND | wx.LEFT, 20)
    hbox.Add(vbox_right, 0, wx.EXPAND | wx.RIGHT, 20)
    self.SetSizer(hbox)
    self.Layout()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30520791_30522533_2_12
30520791_30523618_3_10
Title: "Python prime nos_ ""or"" operator issue" 
----------------------------------------

def prime() :
INDENT
    global count
    count = 0
    if n == 0 or n == 1 :
    INDENT
        count = 1
    DEDENT
    for i in range(n) :
    INDENT
        if i == 0 or i == 1 :
        INDENT
            count = 1
        DEDENT
        elif n % i == 0 :
        INDENT
            count += 1
        DEDENT
    DEDENT
    return count
DEDENT
----------------------------------------

def prime() :
INDENT
    global count
    global n
    count = 0
    for i in range(1, n) :
    INDENT
        if n % i == 0 :
        INDENT
            count += 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30521991_30522352_3_10
30521991_45706292_3_11
Title: Python recursively printing a tree from a list structure 
----------------------------------------

def print_list(lst, level = 0) :
INDENT
    print ('    ' * (level - 1) + '+---' * (level > 0) + lst [0])
    for l in lst [1 :] :
    INDENT
        if type(l) is list :
        INDENT
            print_list(l, level + 1)
        DEDENT
        else :
        INDENT
            print ('    ' * level + '+---' + l)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def print_list(lst, level = 0) :
INDENT
    for l in lst :
    INDENT
        if type(l) is not list :
        INDENT
            print ('    ' * (level - 1) + '+---' * (level > 0) + l)
        DEDENT
        elif type(l) is list :
        INDENT
            print_list(l, level + 1)
        DEDENT
        else :
        INDENT
            print ('    ' * level + '+---' + l)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3052427_3052565_5_11
3052427_3266169_12_20
Title: Validation on ManyToManyField before Save in Models.py 
----------------------------------------

def clean(self) :
INDENT
    cleaned_data = self.cleaned_data
    users = cleaned_data ['users']
    folder = cleaned_data ['folder']
    if users.filter(profile__company__in = folder.company.all()).count() > 0 :
    INDENT
        raise forms.ValidationError('One of the users of this Application works in one of the Folder companies!')
    DEDENT
    return cleaned_data
DEDENT
----------------------------------------

def clean(self) :
INDENT
    cleaned_data = self.cleaned_data
    user = cleaned_data ['user']
    role = cleaned_data ['role']
    if role.id ! = 1 :
    INDENT
        folder = cleaned_data ['application'].folder
        if len(filter(lambda x : x in user.profile.company.all(), folder.company.all())) > 0 :
        INDENT
            raise forms.ValidationError("One of the users of this Application works for one of the Repository's organisations!")
        DEDENT
    DEDENT
    return cleaned_data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30538055_30538909_26_54
30538055_30538909_7_19
Title: wxPython Acting on Element with Focus 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Notebook Tutorial",
        size = (600, 400))
    panel = wx.Panel(self)
    self.tab_num = 3
    self.notebook = wx.Notebook(panel)
    tabOne = TabPanel(self.notebook)
    self.notebook.AddPage(tabOne, "Tab 1")
    tabTwo = TabPanel(self.notebook)
    self.notebook.AddPage(tabTwo, "Tab 2")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.notebook, 1, wx.ALL | wx.EXPAND, 5)
    btn = wx.Button(panel, label = "Get Color")
    btn.Bind(wx.EVT_BUTTON, self.addPage)
    sizer.Add(btn)
    panel.SetSizer(sizer)
    self.Layout()
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    colors = ["red", "blue", "gray", "yellow", "green"]
    self.SetBackgroundColour(random.choice(colors))
    lbox = wx.ListBox(self, choices = colors)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(lbox, 0, wx.ALL, 10)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3054372_13088682_5_10
3054372_3054505_10_15
Title: Auto-register class methods using decorator 
----------------------------------------

def register(cls, * args) :
INDENT
    def decorator(fn) :
    INDENT
        cls.r [fn.__name__] = args
        return fn
    DEDENT
    return decorator
DEDENT
----------------------------------------

def register(* args) :
INDENT
    def decorator(f) :
    INDENT
        f.register = tuple(args)
        return f
    DEDENT
    return decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3054372_13088682_5_10
3054372_3054949_11_17
Title: Auto-register class methods using decorator 
----------------------------------------

def register(cls, * args) :
INDENT
    def decorator(fn) :
    INDENT
        cls.r [fn.__name__] = args
        return fn
    DEDENT
    return decorator
DEDENT
----------------------------------------

def register(* args) :
INDENT
    def wrapper(func) :
    INDENT
        func._prop = args
        return func
    DEDENT
    return wrapper

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3054372_3054505_10_15
3054372_3054949_11_17
Title: Auto-register class methods using decorator 
----------------------------------------

def register(* args) :
INDENT
    def decorator(f) :
    INDENT
        f.register = tuple(args)
        return f
    DEDENT
    return decorator
DEDENT
----------------------------------------

def register(* args) :
INDENT
    def wrapper(func) :
    INDENT
        func._prop = args
        return func
    DEDENT
    return wrapper

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30555701_30555798_10_26
30555701_30555889_8_18
Title: How do I make the output in this hangman game keep its previouse outputs? 
----------------------------------------

def turns(NumOfTries, w, score) :
INDENT
    UI = str(raw_input('Guess a letter (caps only): '))
    j = 0
    for i in w :
    INDENT
        if UI == i :
        INDENT
            score.append('Yes')
            UserGuesses [j] = UI
        DEDENT
        j = j + 1
    DEDENT
    print UserGuesses
    while NumOfTries > 0 :
    INDENT
        turns(NumOfTries - 1, w, score)
        break
    DEDENT
DEDENT
----------------------------------------

def turns(NumOfTries, word) :
INDENT
    score = 0
    guesses = set()
    for i in range(len(w)) :
    INDENT
        guess = str(raw_input('Guess a letter (caps only): '))
        guesses.add(guess)
        if guess in word :
        INDENT
            score += 1
        DEDENT
        print [c if c in guesses else "_" for c in w]
    DEDENT
    return score
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30562935_30562987_2_12
30562935_30563312_1_12
Title: Prevent Exceeding Maximum Recursion Depth 
----------------------------------------

def cycle(b, n, counter) :
INDENT
    total = 0
    for i in str(n) :
    INDENT
        for y in i :
        INDENT
            total += int(y) ** b
        DEDENT
    DEDENT
    counter += 1
    print (total)
    if counter == 10 :
    INDENT
        sys.exit()
    DEDENT
    else :
    INDENT
        cycle(b, total, counter)
    DEDENT
DEDENT
----------------------------------------

def cycle(b, n, seen) :
INDENT
    total = 0
    if n == 1 or n in seen :
    INDENT
        return n == 1
    DEDENT
    for i in str(n) :
    INDENT
        for y in i :
        INDENT
            total += int(y) ** b
        DEDENT
    DEDENT
    seen.add(n)
    n += 1
    return cycle(b, total, seen)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30591734_50832708_17_22
30591734_50832708_8_13
Title: Use same date/time format in DRF as for models.DateTimeField 
----------------------------------------

def to_representation(self, obj) :
INDENT
    if api_settings.DATE_FORMAT in formats.FORMAT_SETTINGS :
    INDENT
        return formats.date_format(obj, api_settings.DATE_FORMAT)
    DEDENT
    return super().to_representation(obj)

DEDENT
----------------------------------------

def to_representation(self, obj) :
INDENT
    if api_settings.DATETIME_FORMAT in formats.FORMAT_SETTINGS :
    INDENT
        return formats.date_format(obj, api_settings.DATETIME_FORMAT)
    DEDENT
    return super().to_representation(obj)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30642391_30642704_9_31
30642391_30643392_5_16
Title: How to draw a filled arc in matplotlib 
----------------------------------------

def filled_arc(center, r, theta1, theta2) :
INDENT
    phi = np.linspace(theta1, theta2, 100)

    x = center [0] + r * np.sin(np.radians(phi))

    yy = np.sqrt(r - x ** 2)
    yy = [- yy [i] if phi [i] > 90 and phi [i] < 270 else yy [i] for i in range(len(yy))]
    y = center [1] + np.array(yy)

    m = (y [- 1] - y [0]) / (x [- 1] - x [0])
    c = y [0] - m * x [0]
    y2 = m * x + c

    ax.fill_between(x, y, y2, color = col [theta1 / 45])

DEDENT
----------------------------------------

def filled_arc(center, radius, theta1, theta2, ax, color) :
INDENT
    circ = mpatches.Wedge(center, radius, theta1, theta2, fill = True, color = color)
    pt1 = (radius * (np.cos(theta1 * np.pi / 180.)) + center [0],
        radius * (np.sin(theta1 * np.pi / 180.)) + center [1])
    pt2 = (radius * (np.cos(theta2 * np.pi / 180.)) + center [0],
        radius * (np.sin(theta2 * np.pi / 180.)) + center [1])
    pt3 = center
    pol = mpatches.Polygon([pt1, pt2, pt3], color = ax.get_axis_bgcolor(),
        ec = ax.get_axis_bgcolor(), lw = 2)
    ax.add_patch(circ)
    ax.add_patch(pol)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30655873_30656152_1_16
30655873_30656370_3_13
Title: Ensure a only single member of a sublist is present in a Python list 
----------------------------------------

def ensure_at_most_one_number(combo) :
INDENT
    i = len(combo) - 1
    found_number = False
    while i > = 0 :
    INDENT
        try :
        INDENT
            int(combo [i])
            if found_number == True :
            INDENT
                del combo [i]
            DEDENT
            else :
            INDENT
                found_number = True
            DEDENT
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
        i -= 1
    DEDENT
    return combo
DEDENT
----------------------------------------

def ensure_at_most_one_number(combo, legal_numbers) :
INDENT
    random.shuffle(combo)
    first_number = True
    for i in range(len(combo) - 1, - 1, - 1) :
    INDENT
        if combo [i] in legal_numbers :
        INDENT
            if first_number :
            INDENT
                first_number = False
            DEDENT
            else :
            INDENT
                del combo [i]
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30664506_30664542_15_59
30664506_30664583_10_39
Title: How do I overlay two images with Chaco? 
----------------------------------------

def _plot_default(self) :
INDENT
    bottomImage = np.reshape(np.repeat(np.linspace(0, 5, 100), 100), (100, 100))
    topImage = np.eye(50)
    topImage = topImage * np.reshape(np.repeat(np.linspace(- 2, 2, 50), 50), (50, 50))
    topImage [topImage == 0] = np.nan
    bottomImageData = ImageData()
    bottomImageData.set_data(bottomImage)
    topImageData = ImageData()
    topImageData.set_data(topImage)
    plotData = ArrayPlotData(imgData = bottomImageData, imgData2 = topImageData)
    plot = Plot(plotData, name = 'My Plot')
    plot.img_plot("imgData")
    plot.img_plot("imgData2")
    plot.aspect_ratio = 1.0
    bottomRange = DataRange1D()
    bottomRange.sources = [plotData.get_data("imgData")]
    topRange = DataRange1D()
    topRange.sources = [plotData.get_data("imgData2")]
    plot.plots ['plot0'] [0].color_mapper = chaco.default_colormaps.gray(bottomRange)
    plot.plots ['plot1'] [0].color_mapper = chaco.default_colormaps.jet(topRange)
    colormapperBottom = plot.plots ['plot0'] [0].color_mapper
    colormapperTop = plot.plots ['plot1'] [0].color_mapper
    colorbarBottom = ColorBar(index_mapper = LinearMapper(range = colormapperBottom.range), color_mapper = colormapperBottom, orientation = 'v', resizable = 'v', width = 30, padding = 20)
    colorbarBottom.padding_top = plot.padding_top
    colorbarBottom.padding_bottom = plot.padding_bottom
    colorbarTop = ColorBar(index_mapper = LinearMapper(range = colormapperTop.range), color_mapper = colormapperTop, orientation = 'v', resizable = 'v', width = 30, padding = 20)
    colorbarTop.padding_top = plot.padding_top
    colorbarTop.padding_bottom = plot.padding_bottom
    container = HPlotContainer(resizable = "hv", bgcolor = 'transparent', fill_padding = True, padding = 0)
    container.spacing = 0
    container.add(plot)
    container.add(colorbarBottom)
    container.add(colorbarTop)
    return container
DEDENT
----------------------------------------

def _plot_default(self) :
INDENT
    x = linspace(- 5, 15.0, 100)
    y = jn(3, x)
    pd = ArrayPlotData(index = x, value = y)
    zoomable_plot = Plot(pd)
    zoomable_plot.plot(('index', 'value'),
        name = 'external', color = 'red', line_width = 3)

    zoom = ZoomTool(component = zoomable_plot,
        tool_mode = "box", always_on = False)
    zoomable_plot.overlays.append(zoom)
    zoomable_plot.tools.append(PanTool(zoomable_plot))

    inset_plot = Plot(pd)
    inset_plot.plot(('index', 'value'), color = 'blue')
    inset_plot.set(resizable = '',
        bounds = [250, 150],
        position = [450, 350],
        border_visible = True)

    container = OverlayPlotContainer()
    container.add(zoomable_plot)
    container.add(inset_plot)
    return container
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30676015_30676232_1_16
30676015_30676395_1_16
Title: python input check function not being called properly 
----------------------------------------

def converter() :
INDENT
    print 'Temperature Converter'
    unit = raw_input('Convert to Fahrenheit or Celsius? ')
    while 1 :
    INDENT
        temp = raw_input('Starting temperature? ')
        try :
        INDENT
            temp = float(temp)
        DEDENT
        except ValueError :
        INDENT
            print 'Not a valid temperature.'
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
    if unit.lower().startswith('f') :
    INDENT
        print "%f C = %f F" % (temp, temp * 9./ 5 + 32)
    DEDENT
    else :
    INDENT
        print "%f F = %f C" % (temp, (temp - 32) * 5./ 9)
    DEDENT
DEDENT
----------------------------------------

def converter() :
INDENT
    o_temp = float(raw_input('Enter a temperature (round to nearest integer): '))
    for i in str(o_temp) :
    INDENT
        if i not in ['1', '2', '3', '4', '5', '6', '7', '8', '9', '0', '.'] :
        INDENT
            print 'Invalid entry. Please enter only the numerical temperature measurement in integer format.'
        DEDENT
    DEDENT
    unit = raw_input('Convert to (F)ahrenheit or (C)elsius? ')
    if unit in ['f', 'F'] :
    INDENT
        n_temp = (9.0 / 5.0) * float(o_temp) + 32
        print '%f C = %f F' % (o_temp, n_temp)
    DEDENT
    elif unit in ['c', 'C'] :
    INDENT
        n_temp = (5.0 / 9.0) * (float(o_temp) - 32)
        print '%f F = %f C' % (o_temp, n_temp)
    DEDENT
    else :
    INDENT
        print 'Invalid entry. Please enter F for Fahrenheit or C for    Celsius'
        unit_input()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30686995_30687280_24_40
30686995_30690720_24_48
Title: a diff for nested dicts without converting to sets 
----------------------------------------

def added(self, old, new) :
INDENT
    for key in new :
    INDENT
        if key not in old :
        INDENT
            self.results.append({
                    'operation' : 'ADDED',
                    'field' : '.'.join(self.depth) + '.' + str(key),
                    'new' : new [key]})
        DEDENT
        elif type(old [key]) == dict and type(new [key]) == dict :
        INDENT
            self.depth.append(str(key))
            self.added(old [key], new [key])
        DEDENT
    DEDENT
    if self.depth :
    INDENT
        self.depth.pop()
    DEDENT
    else :
    INDENT
        return self.results
    DEDENT
DEDENT
----------------------------------------

def added(self, old, new) :
INDENT
    for key in new :
    INDENT
        if key not in old :
        INDENT
            if self.depth :
            INDENT
                self.results.append({
                        'operation' : 'ADDED',
                        'field' : '.'.join(self.depth) + '.' + str(key),
                        'new' : new [key]})
            DEDENT
            else :
            INDENT
                self.results.append({
                        'operation' : 'ADDED',
                        'field' : str(key),
                        'new' : new [key]})
            DEDENT
        DEDENT
        else :
        INDENT
            if type(old [key]) == dict and type(new [key]) == dict :
            INDENT
                self.depth.append(str(key))
                self.added(old [key], new [key])
            DEDENT
        DEDENT
    DEDENT
    if self.depth :
    INDENT
        self.depth.pop()
    DEDENT
    else :
    INDENT
        return self.results
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30686995_30687280_59_75
30686995_30690720_76_100
Title: a diff for nested dicts without converting to sets 
----------------------------------------

def deleted(self, old, new) :
INDENT
    for key in old :
    INDENT
        if key not in new :
        INDENT
            self.results.append({
                    'operation' : 'DELETED',
                    'field' : '.'.join(self.depth) + '.' + str(key),
                    'old' : old [key]})
        DEDENT
        elif type(old [key]) == dict and type(new [key]) == dict :
        INDENT
            self.depth.append(str(key))
            self.deleted(old [key], new [key])
        DEDENT
    DEDENT
    if self.depth :
    INDENT
        self.depth.pop()
    DEDENT
    else :
    INDENT
        return self.results
    DEDENT
DEDENT
----------------------------------------

def deleted(self, old, new) :
INDENT
    for key in old :
    INDENT
        if key not in new :
        INDENT
            if self.depth :
            INDENT
                self.results.append({
                        'operation' : 'DELETED',
                        'field' : '.'.join(self.depth) + '.' + str(key),
                        'old' : old [key]})
            DEDENT
            else :
            INDENT
                self.results.append({
                        'operation' : 'DELETED',
                        'field' : str(key),
                        'old' : old [key]})
            DEDENT
        DEDENT
        else :
        INDENT
            if type(old [key]) == dict and type(new [key]) == dict :
            INDENT
                self.depth.append(str(key))
                self.deleted(old [key], new [key])
            DEDENT
        DEDENT
    DEDENT
    if self.depth :
    INDENT
        self.depth.pop()
    DEDENT
    else :
    INDENT
        return self.results
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3071415_3071441_4_21
3071415_30801799_4_30
Title: Efficient method to calculate the rank vector of a list in Python 
----------------------------------------

def rankdata(a) :
INDENT
    n = len(a)
    ivec = rank_simple(a)
    svec = [a [rank] for rank in ivec]
    sumranks = 0
    dupcount = 0
    newarray = [0] * n
    for i in xrange(n) :
    INDENT
        sumranks += i
        dupcount += 1
        if i == n - 1 or svec [i] ! = svec [i + 1] :
        INDENT
            averank = sumranks / float(dupcount) + 1
            for j in xrange(i - dupcount + 1, i + 1) :
            INDENT
                newarray [ivec [j]] = averank
            DEDENT
            sumranks = 0
            dupcount = 0
        DEDENT
    DEDENT
    return newarray
DEDENT
----------------------------------------

def rankdata(a, method = 'average') :
INDENT
    n = len(a)
    ivec = rank_simple(a)
    svec = [a [rank] for rank in ivec]
    sumranks = 0
    dupcount = 0
    newarray = [0] * n
    for i in xrange(n) :
    INDENT
        sumranks += i
        dupcount += 1
        if i == n - 1 or svec [i] ! = svec [i + 1] :
        INDENT
            for j in xrange(i - dupcount + 1, i + 1) :
            INDENT
                if method == 'average' :
                INDENT
                    averank = sumranks / float(dupcount) + 1
                    newarray [ivec [j]] = averank
                DEDENT
                elif method == 'max' :
                INDENT
                    newarray [ivec [j]] = i + 1
                DEDENT
                elif method == 'min' :
                INDENT
                    newarray [ivec [j]] = i + 1 - dupcount + 1
                DEDENT
                else :
                INDENT
                    raise NameError('Unsupported method')
                DEDENT
            DEDENT
            sumranks = 0
            dupcount = 0

        DEDENT
    DEDENT
    return newarray
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30737372_30737634_50_66
30737372_30737634_6_30
Title: PyQt QVBoxLayout and missing widgets? 
----------------------------------------

def __init__(self) :
INDENT
    super(Polyhedra, self).__init__()

    self.central_widget = CentralWidget(self)
    self.setCentralWidget(self.central_widget)

    self.setGeometry(500, 500, 300, 300)
    self.setWindowTitle('Pyticle')
    self.show()

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(CentralWidget, self).__init__(parent)

    self.layout = QtGui.QVBoxLayout(self)
    self.pNames = QtGui.QLabel(self)
    polyNameInput = QtGui.QLineEdit(self)
    polyNameInput.textChanged [str].connect(self.onChanged)

    self.defaultPolyType = QtGui.QLabel("Random polyhedra", self)
    polyType = QtGui.QComboBox(self)
    polyType.addItem("Random polyhedra")
    polyType.addItem("Spheres")
    polyType.addItem("Waterman polyhedra")
    polyType.activated [str].connect(self.onActivated)
    self.layout.addWidget(polyNameInput)
    self.layout.addWidget(self.pNames)
    self.layout.addWidget(polyType)
    self.layout.addWidget(self.defaultPolyType)
    self.layout.addStretch()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30774281_30783010_26_34
30774281_40817493_26_34
Title: update matplotlib plot in tkinter GUI 
----------------------------------------

def plot(self, canvas, ax) :
INDENT
    for line in sys.stdout :
    INDENT
        theta = line [1]
        r = line [2]
        ax.plot(theta, r, linestyle = "None", maker = 'o')
        canvas.draw()
        ax.clear()

    DEDENT
DEDENT
----------------------------------------

def plot(self, canvas, ax) :
INDENT
    c = ['r', 'b', 'g']
    ax.clear()
    for i in range(3) :
    INDENT
        theta = np.random.uniform(0, 360, 10)
        r = np.random.uniform(0, 1, 10)
        ax.plot(theta, r, linestyle = "None", marker = 'o', color = c [i])
        canvas.draw()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30788122_30788434_17_23
30788122_30788621_9_13
Title: python for loops and dictionary values 
----------------------------------------

def search() :
INDENT
    name = raw_input("Please enter the first name: ")
    pids = search_fname(name)
    if pids ! = 0 :
    INDENT
        for pid in pids :
        INDENT
            print (pid)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def search() :
INDENT
    name = raw_input("Please enter the first name: ")
    entries = search_fname(name)
    for n in entries :
    INDENT
        print n ["fname"], n ["lname"], n ["phone"]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30788122_30788434_1_16
30788122_30788621_1_8
Title: python for loops and dictionary values 
----------------------------------------

def search_fname(name) :
INDENT
    name = str.capitalize(name)
    entries = []
    for n in phonebook :
    INDENT
        if name == n ["fname"] :
        INDENT
            entries.append("{}, {}, {}"
                .format(n ["fname"], n ["lname"], n ["phone"]))
        DEDENT
    DEDENT
    if len(entries) > 0 :
    INDENT
        return entries
    DEDENT
    return 0
DEDENT
----------------------------------------

def search_fname(name) :
INDENT
    name = str.capitalize(name)
    found = []
    for n in phonebook :
    INDENT
        if name == n ["fname"] :
        INDENT
            found.append(n)
        DEDENT
    DEDENT
    return found
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30813015_30813166_1_17
30813015_30813190_1_12
Title: Determining Longest run of Heads and Tails 
----------------------------------------

def LongestRun(n) :
INDENT
    my_t, my_h = 0, 0
    long_h, long_t = 0, 0
    for i in range(n) :
    INDENT
        if not random.randint(0, 1) :
        INDENT
            my_h += 1
            if my_t > long_t :
            INDENT
                long_t = my_t
            DEDENT
            my_t = 0
        DEDENT
        else :
        INDENT

            my_t += 1
            if my_h > long_h :
            INDENT
                long_h = my_h
            DEDENT
            my_h = 0
        DEDENT
    DEDENT
    print ("Longest run of heads was {}\nLongest run of tails was {}".format(long_h, long_t))
DEDENT
----------------------------------------

def LongestRun(myList, lookFor = 'H') :
INDENT
    current_longest = 0
    max_longest = 0
    for x in myList :
    INDENT
        if x == lookFor :
        INDENT
            current_longest += 1
            if current_longest > max_longest :
            INDENT
                max_longest = current_longest
            DEDENT
        DEDENT
        else :
        INDENT
            current_longest = 0
        DEDENT
    DEDENT
    return max_longest
DEDENT
----------------------------------------
