$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46571806_46571886_1_8
46571806_46572323_28_36
Title: Break or continue a while loop from a function 
----------------------------------------

def check_age(q) :
INDENT
    if not (16 < = int(q) < = 25) :
    INDENT
        print ("You are not in the age range for this survey")
    DEDENT
    if q == "foo" :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def check_age(reply) :
INDENT
    if reply == "foo" :
    INDENT
        raise ExitLoop
    DEDENT
    if not 16 < = int(reply) < = 25 :
    INDENT
        print ("You are not in the age range for this survey")
        return False
    DEDENT
    return True

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46571806_46572181_1_14
46571806_46572323_12_27
Title: Break or continue a while loop from a function 
----------------------------------------

def check_gender(q) :
INDENT
    if q == "f" :
    INDENT
        number_women = number_women + 1
    DEDENT
    elif q == "m" :
    INDENT
        number_men = number_men + 1

    DEDENT
    else :
    INDENT
        print ("Please answer M or F: ")
        q = input("Are you a male or female (M/F)? ").lower()
        check_gender(q)

    DEDENT
DEDENT
----------------------------------------

def check_gender(reply) :
INDENT
    global NUMBER_WOMEN, NUMBER_MEN
    while True :
    INDENT
        if reply == "f" :
        INDENT
            NUMBER_WOMEN += 1
            return
        DEDENT
        elif reply == "m" :
        INDENT
            NUMBER_MEN += 1
            return
        DEDENT
        elif reply == "foo" :
        INDENT
            raise ExitLoop
        DEDENT
        else :
        INDENT
            print ("Please answer M or F: ")
            reply = input("Are you a male or female (M/F)? ").lower()

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46591344_49239753_7_11
46591344_50989115_9_21
Title: Django Rest Framework - OPTIONS request - Get foreign key choices 
----------------------------------------

def get_field_info(self, field) :
INDENT
    field_info = super(MyMetaData, self).get_field_info(field)
    if isinstance(field, ManyRelatedField) :
    INDENT
        field_info ['choices'] = field.get_choices()
    DEDENT
    return field_info
DEDENT
----------------------------------------

def get_field_info(self, field) :
INDENT
    field_info = super(MyMetaData, self).get_field_info(field)
    if isinstance(field, (RelatedField, ManyRelatedField)) :
    INDENT
        field_info ['choices'] = [
            {
                'value' : choice_value,
                'display_name' : force_text(choice_name, strings_only = True)} for choice_value, choice_name in field.get_choices().items()
            ]
    DEDENT
    return field_info

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46614151_46615749_19_28
46614151_46615749_9_17
Title: To move a qbutton on a form 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QWidget.__init__(self, parent)
    buttons = {}
    for i in range(len(Blist)) :
    INDENT
        buttons [i] = lb('%d_%s' % (i, Blist [i] [0]), self)
        buttons [i].move(Blist [i] [1], Blist [i] [2])
        buttons [i].clicked.connect(self.bclick)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, t, parent = None) :
INDENT
    QPushButton.__init__(self, t, parent)
    self.setText(t.split("_") [1])
    self.setFixedHeight(ButtonH)
    self.setFixedWidth(ButtonW)
    self.setStyleSheet("background-color:white;")
    self.setObjectName(t.split("_") [0])
    self.setFont(QFont("Times", 12, QFont.StyleNormal))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46617360_46617470_1_15
46617360_46617714_1_20
Title: Getting wrong sum in program to condense a number to a single digit by adding the digits recursively in Python 2.7 
----------------------------------------

def single_digit(a) :
INDENT
    if - 10 < a < 10 :
    INDENT
        return a
    DEDENT
    n = a
    sum = 0
    while (n > 0) :
    INDENT
        r = n % 10
        sum += r
        n = n / 10
    DEDENT
    return single_digit(sum)

DEDENT
----------------------------------------

def single_digit(a) :
INDENT
    if a < 10 :
    INDENT
        return a
    DEDENT
    num = a
    sum_of_digits = 0

    while num > 0 :
    INDENT
        remainder = num % 10
        sum_of_digits += remainder
        num = num / / 10

    DEDENT
    if sum_of_digits > 10 :
    INDENT
        return single_digit(sum_of_digits)
    DEDENT
    else :
    INDENT
        return sum_of_digits
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46630254_46634873_6_21
46630254_46676349_4_21
Title: Python turtle error on closing screen - code from How to Think Like a Computer Scientist: Learning with Python 3 
----------------------------------------

def show_poly() :
INDENT
    try :
    INDENT
        n = int(input("How many sides do you want in your polygon?"))
        angle = 360 / n
        root = tk.Tk()
        canvas = turtle.ScrolledCanvas(root)
        canvas.pack(expand = True, fill = 'both')
        tess = turtle.RawTurtle(canvas)
        for i in range(n) :
        INDENT
            tess.forward(10)
            tess.left(angle)
        DEDENT
        time.sleep(3)
    DEDENT
    finally :
    INDENT
        root.destroy()

    DEDENT
DEDENT
----------------------------------------

def show_poly(turtle) :
INDENT
    n = 0
    while n < 3 :
    INDENT
        try :
        INDENT
            n = int(input("How many sides do you want in your polygon? "))
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
    DEDENT
    angle = 360 / n
    for _ in range(n) :
    INDENT
        turtle.forward(50)
        turtle.left(angle)
    DEDENT
    sleep(3)
    turtle.clear()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46634091_46634187_8_15
46634091_46635451_1_15
Title: Find longest substring in alphabetical order 
----------------------------------------

def longest_substring(s1) :
INDENT
    for i in range(len(alpha)) :
    INDENT
        for k in range(len(alpha)) :
        INDENT
            if alpha [i : k] in s1 :
            INDENT
                subs.append(alpha [i : k])
            DEDENT
        DEDENT
    DEDENT
    return max(subs, key = len)

DEDENT
----------------------------------------

def longest_substring(s1) :
INDENT
    max_index, max_len = 0, 0
    last_c = s1 [0]
    start, seq_len = 0, 1
    for i, c in enumerate(s1 [1 :]) :
    INDENT
        if c > = last_c :
        INDENT
            seq_len += 1
            if seq_len > max_len :
            INDENT
                max_index, max_len = start, seq_len
            DEDENT
        DEDENT
        else :
        INDENT
            seq_len = 0
            start = i + 1
        DEDENT
        last_c = c
    DEDENT
    return s1 [max_index : max_index + max_len]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46635681_46664891_14_21
46635681_46664891_23_30
Title: Close python Tkinter multiple dialogs 
----------------------------------------

def __init__(self) :
INDENT
    self.top = ChoiceData.top = Toplevel(App.root)
    self.label = Label(self.top, text = "ChoiceData")
    self.button = Button(self.top, text = "Ok", command = App.close)
    self.top.protocol("WM_DELETE_WINDOW", App.close)
    self.label.pack()
    self.button.pack()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.top = SelectData.top = Toplevel(App.root)
    self.label = Label(self.top, text = "SelectData")
    self.button = Button(self.top, text = "Ok", command = App.close)
    self.top.protocol("WM_DELETE_WINDOW", App.close)
    self.label.pack()
    self.button.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46637076_46637381_1_9
46637076_46637449_1_21
Title: How to return a nonetype from a list of strings? 
----------------------------------------

def string_avg_update(L) :
INDENT
    for x in range(len(L)) :
    INDENT
        split = L [x].split(',')
        for y in range(1, len(split)) :
        INDENT
            split [y] = float(split [y])
        DEDENT
        summation = sum(split [z] for z in range(1, len(split)))
        average = summation / (len(split) - 1)
        L [x] = average
    DEDENT
DEDENT
----------------------------------------

def string_avg_update(L) :
INDENT
    for i, record in enumerate(L) :
    INDENT
        grades = [float(grade) for grade in record.split(',') [1 :]]
        L [i] = sum(grades) / len(grades)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46638201_46638276_15_20
46638201_46638358_15_21
Title: (Python Beginner) Output file is empty in my code 
----------------------------------------

def process_seasons(input_file, output_file) :
INDENT
    season_number = 0
    for season in input_file :
    INDENT
        season_number += 1
    DEDENT
    process_season(output_file, season_number, season [0], season [1])
DEDENT
----------------------------------------

def process_seasons(input_file, output_file) :
INDENT
    season_number = 0
    for season in input_file :
    INDENT
        season_number += 1
        seas = season.split()
        process_season(output_file, season_number, seas [0], seas [1])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46639879_46639952_1_13
46639879_46641751_5_15
Title: Summation of results from a loop 
----------------------------------------

def subject(subjectsNum) :
INDENT
    totalSum = 0
    for i in range(subjectsNum) :
    INDENT

        subjectName = input("What is the subject name?")
        pagesQuantity = float(input("How many pages do you have to study?"))
        pagesTime = float(input("How long do you reckon it will take to study one page (in minutes)?"))
        totalTime = (pagesQuantity) * (pagesTime) / 60
        print ("The estimated time to study {} is {} hours".format(subjectName, totalTime))
        totalSum += totalTime
    DEDENT
    return totalSum

DEDENT
----------------------------------------

def subject() :
INDENT
    for i in range(1, subjectsNum + 1) :
    INDENT

        subjectName = input("What is the subject name?")
        pagesQuantity = float(input("How many pages do you have to study?"))
        pagesTime = float(input("How long do you reckon it will take to study one page (in minutes)?"))
        totalTime = (pagesQuantity) * (pagesTime) / 60
        print ("The estimated time to study %s is %s hours" % (subjectName, totalTime))
        Final_total_time.append(totalTime)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46642184_46642662_1_16
46642184_46642979_4_23
Title: how to continue for loop after exception? 
----------------------------------------

def do_connect(self) :
INDENT
    for host in self.hosts :
    INDENT
        try :
        INDENT
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(host ['ip'], port = int(host ['port']), username = host ['user'], timeout = 2)
        DEDENT
        except :
        INDENT
            continue
        DEDENT
        finally :
        INDENT
            if client._agent is None :
            INDENT
                pass
            DEDENT
            else :
            INDENT
                self.connections.append(client)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def do_connect(self) :
INDENT
    for host in self.hosts :
    INDENT

        client = paramiko.SSHClient()
        try :
        INDENT
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            client.connect(host ['ip'], port = int(host ['port']), username = host ['user'], timeout = 2)

        DEDENT
        except paramiko.SSHException as e :
        INDENT

            logger.exception("failed to connect to %(ip)s:%(port)s (user %(user)s)", host)
            continue
        DEDENT
        else :
        INDENT
            self.connections.append(client)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46646484_46646827_2_12
46646484_46646896_1_13
Title: "In Python is there a neater way than this of deciding whether to use gt or gte based on a boolean variable?" 
----------------------------------------

def get_items_in_date_range(all_items, start_date = None, end_date = None,
include_start_date = True, include_end_date = True) :
INDENT
    start_op = operator.ge if include_start_date else operator.gt
    end_op = operator.le if include_end_date else operator.lt
    filtered_items = all_items
    if start_date :
    INDENT
        filtered_items = [item for item in filtered_items if start_op(item, start_date)]
    DEDENT
    if end_date :
    INDENT
        filtered_items = [item for item in filtered_items if end_op(item, end_date)]
    DEDENT
    return filtered_items
DEDENT
----------------------------------------

def get_items_in_date_range(all_items, start_date = None, end_date = None,
include_start_date = True, include_end_date = True) :
INDENT
    if start_date is None :
    INDENT
        start_date = MIN_DATE
    DEDENT
    if end_date is None :
    INDENT
        end_date = MAX_DATE
    DEDENT
    items_in_date = []
    for item in all_items :
    INDENT
        is_in_range = start_date < item < end_date
        is_start = include_start_date and item == start_date
        is_end = include_end_date and item == end_date
        if is_in_range or is_start or is_end :
        INDENT
            item_in_date.append(item)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46653281_46653688_1_11
46653281_46654425_1_17
Title: How to return most repeated letter in python? 
----------------------------------------

def most_repeated_letters(word_1) :
INDENT
    lettersCount = {}
    for ch in word_1 :
    INDENT
        if ch not in lettersCount :
        INDENT
            lettersCount [ch] = 1
        DEDENT
        else :
        INDENT
            lettersCount [ch] += 1
        DEDENT
    DEDENT
    return max(lettersCount, key = lettersCount.get)

DEDENT
----------------------------------------

def most_repeated_letters(word_1) :
INDENT
    d = {}
    for letter in word_1 :
    INDENT
        if not d.get(letter) :
        INDENT
            d [letter] = 0
        DEDENT
        d [letter] = d.get(letter) + 1
    DEDENT
    ret = {}
    for k, v in d.iteritems() :
    INDENT
        if d [k] == max(d.values()) :
        INDENT
            ret [k] = v
        DEDENT
    DEDENT
    return ret
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46657482_46657947_9_15
46657482_46658030_6_12
Title: Adding a string onto each item in a list using functions 
----------------------------------------

def make_HOF(baseball_players) :
INDENT
    HOF = "Hall of Famer "
    for player in baseball_players :
    INDENT
        HOF_players.append(HOF + player)
    DEDENT
    return HOF_players
DEDENT
----------------------------------------

def make_HOF(titless_players) :
INDENT
    for player in titless_players :
    INDENT
        player = "Hall of Famer: " + player
        HOF_players.append(player)
    DEDENT
    return HOF_players
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4667881_4668265_4_17
4667881_4668971_4_33
Title: "How to write a ""&"" in button text in wxpython" 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (200, - 1))
    self.sizer = wx.BoxSizer(wx.HORIZONTAL)
    self.buttons = [
        wx.Button(self, - 1, "Button &One"),
        wx.Button(self, - 1, "Button &&Two"),
        ]
    for btn in self.buttons :
    INDENT
        self.sizer.Add(btn, 1, wx.EXPAND)
    DEDENT
    self.SetSizer(self.sizer)
    self.SetAutoLayout(1)
    self.sizer.Fit(self)
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (699, 570))
    fileMenu = wx.Menu()
    folder = wx.MenuItem(fileMenu, 1, "&Start", "Click here to start..")
    fileMenu.AppendItem(folder)
    about = wx.MenuItem(fileMenu, 2, '&About', "Test")
    fileMenu.AppendItem(about)
    quit = wx.MenuItem(fileMenu, 3, '&Quit', "Terminate the program")
    fileMenu.AppendItem(quit)
    menuBar = wx.MenuBar()
    menuBar.Append(fileMenu, "&File")
    self.Bind(wx.EVT_MENU, self.ShowButton, folder)
    self.SetMenuBar(menuBar)
    pndSummaryButton = wx.Button(self, 3, "Button &&Two", (130, 146))
    pndSummaryButton.name = "pndSummary"
    self.printArea2 = wx.TextCtrl(self, pos = (290, 146), size = (255, 25), style = wx.TE_READONLY)
    pndSummaryButton.SetFont(wx.Font(11, wx.SWISS, wx.NORMAL, wx.LIGHT))
    self.printArea2.SetFont(wx.Font(10, wx.SWISS, wx.NORMAL, wx.LIGHT))
    pndSummaryButton.SetBackgroundColour(wx.Colour(153, 0, 0))
    pndSummaryButton.SetForegroundColour(wx.Colour(255, 255, 255))
    pndSummaryButton.SetSize(pndSummaryButton.GetBestSize())
    self.Show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46697502_46697552_10_17
46697502_46698257_17_29
Title: How to move a sprite according to an angle in Pygame 
----------------------------------------

def __init__(self, x, y, direction, speed) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.Surface((16, 16))
    self.image.fill((255, 0, 0))
    self.rect = self.image.get_rect()
    self.rect.center = (x, y)
    self.direction = math.radians(direction)
    self.speed = speed
DEDENT
----------------------------------------

def __init__(self, pos, angle) :
INDENT
    super().__init__()
    self.image = pg.transform.rotate(BULLET_IMAGE, - angle)
    self.rect = self.image.get_rect(center = pos)

    offset = Vector2(40, 0).rotate(angle)
    self.pos = Vector2(pos) + offset

    self.velocity = Vector2(1, 0).rotate(angle) * 9
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46698586_46698695_2_12
46698586_46736035_2_13
Title: Using Flask to send form data to a database 
----------------------------------------

def update_audit() :
INDENT
    description = request.form.get('description')
    test_name = request.form.get('update_audit')
    cur = connect_db()
    with cur :
    INDENT
        cur.execute(
            'UPDATE audit SET description = ? '
            'WHERE test_name = ?;', (description, test_name,))

    DEDENT
    return render_template('clicked.html')
DEDENT
----------------------------------------

def update_audit() :
INDENT
    description = request.form.get('description')
    test_name = request.form.get('test_name')
    sql = 'UPDATE audit SET description=? WHERE test_name=?'
    conn = sqlite3.connect(DATABASE)
    cur = conn.cursor()
    cur.execute(sql, (description, test_name))
    conn.commit()
    conn.close()
    return render_template('clicked.html', data = (test_name, description))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46701452_46705535_1_11
46701452_46707256_1_13
Title: How to make the first and the last characters become the first and the second character and so on 
----------------------------------------

def encrypt(s) :
INDENT
    reversed = s [: : - 1]
    ret_str = ""
    length = len(reversed)
    for i in range(length / / 2) :
    INDENT
        ret_str += reversed [i] + reversed [length - 1 - i]
    DEDENT
    if (length % 2 == 1) :
    INDENT
        ret_str += reversed [length / / 2 + 1]
    DEDENT
    return ret_str
DEDENT
----------------------------------------

def encrypt(message) :
INDENT
    reversed_message = reversed(message)
    alternating_chars = (
        ''.join((i, j)) for i, j in zip(message, reversed_message)
        )
    alternating_chars = ''.join(
        list(alternating_chars))
    return alternating_chars [: len(message)]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46708345_46708757_1_28
46708345_46709505_8_19
Title: Python how to access dataframes inside dictionary? 
----------------------------------------

def readDatafromFile(path) :
INDENT
    from collections import defaultdict
    store_data = defaultdict(list)
    path = (path + "/data")
    os.chdir(path)
    filenames = glob.glob("*.txt")
    for filename in filenames :
    INDENT
        if filename.__contains__("_Sale") == 1 :
        INDENT
            Salesource = path + "/" + filename
            store_data ['sales'].append(pd.read_csv(Salesource, sep = ',', header = None))
        DEDENT
        elif filename.__contains__("_Emplo") == 1 :
        INDENT
            Empsource = path + "/" + filename
            store_data ['emp'].append(pd.read_csv(Empsource, sep = ',', header = None))
        DEDENT
        elif filename.__contains__("_Prod") == 1 :
        INDENT
            Prodsource = path + "/" + filename
            store_data ['prod'].append(pd.read_csv(Prodsource, sep = ',', header = None))
        DEDENT
        elif filename.__contains__("_Resou") == 1 :
        INDENT
            Ressource = path + "/" + filename
            store_data ['res'].append(pd.read_csv(Ressource, sep = ',', header = None))
        DEDENT
    DEDENT
    store_data ['sales'] = pd.concat(store_data ['sales'], ignore_index = True)
    store_data ['emp'] = pd.concat(store_data ['emp'], ignore_index = True)
    store_data ['prod'] = pd.concat(store_data ['prod'], ignore_index = True)
    store_data ['res'] = pd.concat(store_data ['res'], ignore_index = True)
    return (store_data)
DEDENT
----------------------------------------

def readDatafromFile(path) :
INDENT
    store_data = {}
    a = 0
    path = (path + "/data")
    os.chdir(path)
    filenames = glob.glob("*.txt")
    for filename in filenames :
    INDENT
        store_data [filename] = pd.read_csv(filename, sep = ',', header = None)
        a = a + 1
    DEDENT
    return (store_data)
    print (a)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46708345_46708757_1_28
46708345_46709622_8_32
Title: Python how to access dataframes inside dictionary? 
----------------------------------------

def readDatafromFile(path) :
INDENT
    from collections import defaultdict
    store_data = defaultdict(list)
    path = (path + "/data")
    os.chdir(path)
    filenames = glob.glob("*.txt")
    for filename in filenames :
    INDENT
        if filename.__contains__("_Sale") == 1 :
        INDENT
            Salesource = path + "/" + filename
            store_data ['sales'].append(pd.read_csv(Salesource, sep = ',', header = None))
        DEDENT
        elif filename.__contains__("_Emplo") == 1 :
        INDENT
            Empsource = path + "/" + filename
            store_data ['emp'].append(pd.read_csv(Empsource, sep = ',', header = None))
        DEDENT
        elif filename.__contains__("_Prod") == 1 :
        INDENT
            Prodsource = path + "/" + filename
            store_data ['prod'].append(pd.read_csv(Prodsource, sep = ',', header = None))
        DEDENT
        elif filename.__contains__("_Resou") == 1 :
        INDENT
            Ressource = path + "/" + filename
            store_data ['res'].append(pd.read_csv(Ressource, sep = ',', header = None))
        DEDENT
    DEDENT
    store_data ['sales'] = pd.concat(store_data ['sales'], ignore_index = True)
    store_data ['emp'] = pd.concat(store_data ['emp'], ignore_index = True)
    store_data ['prod'] = pd.concat(store_data ['prod'], ignore_index = True)
    store_data ['res'] = pd.concat(store_data ['res'], ignore_index = True)
    return (store_data)
DEDENT
----------------------------------------

def readDatafromFile(path) :
INDENT
    store_data = {}
    a = 0
    path = (path + "/data")
    os.chdir(path)
    filenames = glob.glob("*.txt")
    valid_file_names = [
        "_Sale",
        "_Emplo",
        "_Prod",
        "_Resou"]
    for filename in filenames :
    INDENT
        if any(val in filename for val in valid_file_names) :
        INDENT
            source_path = os.path.join(path, filename)
            filename = filename [: - 4]
            store_data [filename] = pd.read_csv(source_path, sep = ',', header = None)
            a = a + 1
        DEDENT
    DEDENT
    print (a)
    return store_data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46708345_46709505_8_19
46708345_46709622_8_32
Title: Python how to access dataframes inside dictionary? 
----------------------------------------

def readDatafromFile(path) :
INDENT
    store_data = {}
    a = 0
    path = (path + "/data")
    os.chdir(path)
    filenames = glob.glob("*.txt")
    for filename in filenames :
    INDENT
        store_data [filename] = pd.read_csv(filename, sep = ',', header = None)
        a = a + 1
    DEDENT
    return (store_data)
    print (a)
DEDENT
----------------------------------------

def readDatafromFile(path) :
INDENT
    store_data = {}
    a = 0
    path = (path + "/data")
    os.chdir(path)
    filenames = glob.glob("*.txt")
    valid_file_names = [
        "_Sale",
        "_Emplo",
        "_Prod",
        "_Resou"]
    for filename in filenames :
    INDENT
        if any(val in filename for val in valid_file_names) :
        INDENT
            source_path = os.path.join(path, filename)
            filename = filename [: - 4]
            store_data [filename] = pd.read_csv(source_path, sep = ',', header = None)
            a = a + 1
        DEDENT
    DEDENT
    print (a)
    return store_data
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46733360_46733739_3_22
46733360_46733776_1_16
Title: Python function that would take input into 64 bit and then change to 8bytes output 
----------------------------------------

def Pconvert(* varloadID) :
INDENT
    bits = [0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,]
    for x in varloadID :
    INDENT
        x -= 1
        bits [x] = 1
    DEDENT
    j = int(''.join(map(str, bits)), 2)
    print (j)
    bytestr = struct.pack('>Q', j).decode('cp1252')
    a = list()
    for i in bytestr :
    INDENT
        a.append(ord(i))
    DEDENT
    print (a.__len__())
    return a
DEDENT
----------------------------------------

def Pconvert(* varloadID) :
INDENT
    bits = [0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0,]
    for x in varloadID :
    INDENT
        bits [x - 1] = 1
    DEDENT
    print bits
    bytes = [bits [i * 8 : i * 8 + 8] for i in xrange(0, 8)]
    return map(lambda byte : int(''.join(map(str, byte)), 2), bytes)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46747147_46747514_24_33
46747147_46747567_7_17
Title: Why is multiprocessing.pool.map raising a PicklingError (Encoding)? 
----------------------------------------

def use_procs() :
INDENT
    p_pool = Pool(4)
    p_results = p_pool.map(worker, urls)
    p_pool.close()
    p_pool.join()
    print ('using procs instead of threads')
    print ([len(x) for x in p_results])
DEDENT
----------------------------------------

def use_procs() :
INDENT
    p_pool = Pool(4)
    p_results = p_pool.map(get_data, urls)
    p_pool.close()
    p_pool.join()
    print 'using procs instead of threads'
    print [len(x) for x in p_results]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46751474_46751666_1_17
46751474_46751731_3_11
Title: The number of ways to find unique numbers that sum to a number in Python 
----------------------------------------

def sums(sequence, target) :
INDENT
    n = len(sequence)
    total = 0
    for i1 in range(n) :
    INDENT
        v1 = sequence [i1]
        for i2 in range(i1 + 1, n) :
        INDENT
            v2 = sequence [i2]
            for i3 in range(i2 + 1, n) :
            INDENT
                v3 = sequence [i3]
                for i4 in range(i3 + 1, n) :
                INDENT
                    v4 = sequence [i4]
                    if v1 + v2 + v3 + v4 == target :
                    INDENT
                        total += 1
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return total
DEDENT
----------------------------------------

def sums(lst, n) :
INDENT
    count = 0
    for sample in list(itertools.combinations(lst, 4)) :
    INDENT
        if sum(sample) == n :
        INDENT
            count += 1
        DEDENT
    DEDENT
    return count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46756213_46757460_5_11
46756213_46764985_1_21
Title: How to add an option to view all (*) in Django? 
----------------------------------------

def get_queryset(self) :
INDENT
    if self.kwargs.get('company_type') == 'M' and self.kwargs.get("company_category") == "Indoor-Decorative" :
    INDENT
        return Company.objects.filter(companytype = "M", companydetails__category = "Indoor-Decorative")
    DEDENT
    elif self.kwargs.get('company_type') ! = '*' :
    INDENT
        return Company.objects.filter(companytype = self.kwargs ['company_type'])
    DEDENT
    else :
    INDENT
        return Company.objects.all()
    DEDENT
DEDENT
----------------------------------------

def get_queryset(self) :
INDENT
    for i in self.kwargs :
    INDENT
        if self.kwargs [i] == "*" :
        INDENT
            self.kwargs [i] = ""
        DEDENT
    DEDENT
    print (self.kwargs)
    print (len(self.kwargs))
    if len(self.kwargs) == 1 :
    INDENT
        queryset = Company.objects.filter(country__country__contains = self.kwargs ['country'])
        print (queryset.query, "\n", len(queryset))
        return queryset
    DEDENT
    elif len(self.kwargs) == 2 :
    INDENT
        queryset = Company.objects.filter(country__country__contains = self.kwargs ['country'],
            companytype__contains = self.kwargs ['company_type'])
        print (queryset.query, "\n", len(queryset))
        return queryset
    DEDENT
    elif len(self.kwargs) == 3 :
    INDENT
        queryset = Company.objects.filter(country__country__contains = self.kwargs ['company_country'],
            companytype__contains = self.kwargs ['company_type'],
            companydetails__category__contains = self.kwargs ['company_category'],)
        print (queryset.query, "\n", len(queryset))
        return queryset
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46756855_46762133_12_36
46756855_46762133_49_59
Title: Splash screen not showing with python3/gtk+ 
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.set_decorated(False)

    self.box = Gtk.Box()
    self.add(self.box)
    self.lbl = Gtk.Label()
    self.lbl.set_label("My app is loading...")
    self.box.pack_start(self.lbl, True, True, 0)

    self.set_auto_startup_notification(False)
    self.show_all()
    self.set_auto_startup_notification(True)

    GLib.timeout_add(100, self.loop)
    self.loops = 0

DEDENT
----------------------------------------

def __init__(self, global_var) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.lbl = Gtk.Label()
    self.lbl.set_label("Main window (started approx. %s)" % global_var)
    self.add(self.lbl)
    self.show_all()
    self.connect('destroy', Gtk.main_quit)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46756855_46762133_12_36
46756855_46823919_12_27
Title: Splash screen not showing with python3/gtk+ 
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.set_decorated(False)

    self.box = Gtk.Box()
    self.add(self.box)
    self.lbl = Gtk.Label()
    self.lbl.set_label("My app is loading...")
    self.box.pack_start(self.lbl, True, True, 0)

    self.set_auto_startup_notification(False)
    self.show_all()
    self.set_auto_startup_notification(True)

    GLib.timeout_add(100, self.loop)
    self.loops = 0

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Splash, self).__init__()

    self.window = Gtk.Window(Gtk.WindowType.POPUP)
    self.window.set_position(Gtk.WindowPosition.CENTER)
    self.window.connect('destroy', Gtk.main_quit)
    self.window.set_default_size(400, 250)

    box = Gtk.Box()
    lbl = Gtk.Label()
    lbl.set_label("My app is loading...")
    box.pack_start(lbl, True, True, 0)
    self.window.add(box)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46756855_46762133_12_36
46756855_46823919_43_68
Title: Splash screen not showing with python3/gtk+ 
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.set_decorated(False)

    self.box = Gtk.Box()
    self.add(self.box)
    self.lbl = Gtk.Label()
    self.lbl.set_label("My app is loading...")
    self.box.pack_start(self.lbl, True, True, 0)

    self.set_auto_startup_notification(False)
    self.show_all()
    self.set_auto_startup_notification(True)

    GLib.timeout_add(100, self.loop)
    self.loops = 0

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.lbl = Gtk.Label()
    self.lbl.set_label("Main window started")
    self.add(self.lbl)
    self.connect('destroy', Gtk.main_quit)

    print (("Starting splash"))
    splash = Splash()
    splash.start()
    print (("Simulate MainUI work"))
    sleep(5)

    splash.destroy()
    print (("Splash destroyed"))
    print (("Starting MainUI"))
    self.show_all()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46756855_46762133_49_59
46756855_46823919_12_27
Title: Splash screen not showing with python3/gtk+ 
----------------------------------------

def __init__(self, global_var) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.lbl = Gtk.Label()
    self.lbl.set_label("Main window (started approx. %s)" % global_var)
    self.add(self.lbl)
    self.show_all()
    self.connect('destroy', Gtk.main_quit)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Splash, self).__init__()

    self.window = Gtk.Window(Gtk.WindowType.POPUP)
    self.window.set_position(Gtk.WindowPosition.CENTER)
    self.window.connect('destroy', Gtk.main_quit)
    self.window.set_default_size(400, 250)

    box = Gtk.Box()
    lbl = Gtk.Label()
    lbl.set_label("My app is loading...")
    box.pack_start(lbl, True, True, 0)
    self.window.add(box)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46756855_46762133_49_59
46756855_46823919_43_68
Title: Splash screen not showing with python3/gtk+ 
----------------------------------------

def __init__(self, global_var) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.lbl = Gtk.Label()
    self.lbl.set_label("Main window (started approx. %s)" % global_var)
    self.add(self.lbl)
    self.show_all()
    self.connect('destroy', Gtk.main_quit)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.lbl = Gtk.Label()
    self.lbl.set_label("Main window started")
    self.add(self.lbl)
    self.connect('destroy', Gtk.main_quit)

    print (("Starting splash"))
    splash = Splash()
    splash.start()
    print (("Simulate MainUI work"))
    sleep(5)

    splash.destroy()
    print (("Splash destroyed"))
    print (("Starting MainUI"))
    self.show_all()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46756855_46823919_12_27
46756855_46823919_43_68
Title: Splash screen not showing with python3/gtk+ 
----------------------------------------

def __init__(self) :
INDENT
    super(Splash, self).__init__()

    self.window = Gtk.Window(Gtk.WindowType.POPUP)
    self.window.set_position(Gtk.WindowPosition.CENTER)
    self.window.connect('destroy', Gtk.main_quit)
    self.window.set_default_size(400, 250)

    box = Gtk.Box()
    lbl = Gtk.Label()
    lbl.set_label("My app is loading...")
    box.pack_start(lbl, True, True, 0)
    self.window.add(box)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self)

    self.set_position(Gtk.WindowPosition.CENTER)
    self.lbl = Gtk.Label()
    self.lbl.set_label("Main window started")
    self.add(self.lbl)
    self.connect('destroy', Gtk.main_quit)

    print (("Starting splash"))
    splash = Splash()
    splash.start()
    print (("Simulate MainUI work"))
    sleep(5)

    splash.destroy()
    print (("Splash destroyed"))
    print (("Starting MainUI"))
    self.show_all()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46762377_46762388_1_14
46762377_46762474_1_11
Title: Create a function that calculates the sum of a series 
----------------------------------------

def series_sum() :
INDENT
    n = input("Please enter a number greater than 0")
    if type(n, str) :
    INDENT
        try :
        INDENT
            n = int(n)
        DEDENT
        except :
        INDENT
            print 'enter integer value'
            return
        DEDENT
    DEDENT
    if n > = 0 :
    INDENT
        sum = 1000
        for i in range(1, n + 1) :
        INDENT
            sum += (1./ i) ** 2
        DEDENT
        return sum
    DEDENT
    return
DEDENT
----------------------------------------

def series_sum() :
INDENT
    n = input("Please enter an integer greater than 0")
    n = int(n)
    if n < 0 :
    INDENT
        return None
    DEDENT
    else :
    INDENT
        numbers = range(1, n + 1)
        total = 1000
        for number in numbers :
        INDENT
            total = total + 1 / n ** 2
        DEDENT
        return total
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46764778_46764930_1_11
46764778_46765086_1_14
Title: Create sorted list from dictionary of 2 keys and 2 tuples 
----------------------------------------

def printDictionary(dictionaryParm) :
INDENT
    for x in dictionaryParm :
    INDENT
        header = [x]
        value = list(dictionaryParm [x])
        value.sort()
        output = header + value
        for item in output :
        INDENT
            print (item)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def printDictionary(dictionaryParm) :
INDENT
    for x in dictionaryParm :
    INDENT
        header = []
        header.append(x)

        value = list(dictionaryParm.get(x))
        print value
        output = header + value
        for item in output :
        INDENT
            print item
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46774286_50294365_24_36
46774286_50294365_7_22
Title: change window/frame gtk3 pygtk and pass parameters 
----------------------------------------

def __init__(self, parent_window) :
INDENT
    super().__init__(spacing = 10)
    self.__parent_window = parent_window
    label_start = Gtk.Label("This is start page")
    self.pack_start(label_start, True, True, 0)
    new_game_button = Gtk.Button("NEW GAME")
    new_game_button.connect("clicked", self.start_new_game)
    new_game_button.set_border_width(20)
    new_game_button.set_valign(Gtk.Align.CENTER)
    self.pack_start(new_game_button, True, True, 0)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__(title = "Title of Window")
    self.set_border_width(20)
    self.set_default_size(300, 500)
    container = Gtk.Box()
    self.add(container)
    container.show()
    self.main = Main(self)
    container.add(self.main)
    self.first_page = FirstPage(self)
    container.add(self.first_page)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46774286_50294365_43_55
46774286_50294365_7_22
Title: change window/frame gtk3 pygtk and pass parameters 
----------------------------------------

def __init__(self, parent_window) :
INDENT
    super().__init__(spacing = 10)
    self.__parent_window = parent_window
    label_start = Gtk.Label("This is second page")
    self.pack_start(label_start, True, True, 0)
    return_button = Gtk.Button("END GAME")
    return_button.connect("clicked", self.return_start_page)
    return_button.set_border_width(20)
    return_button.set_valign(Gtk.Align.CENTER)
    self.pack_start(return_button, True, True, 0)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(MainWindow, self).__init__(title = "Title of Window")
    self.set_border_width(20)
    self.set_default_size(300, 500)
    container = Gtk.Box()
    self.add(container)
    container.show()
    self.main = Main(self)
    container.add(self.main)
    self.first_page = FirstPage(self)
    container.add(self.first_page)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46778623_46789599_20_27
46778623_46794777_31_39
Title: lazy loading child items Qtreeview 
----------------------------------------

def update_model(self, index) :
INDENT
    parent = self.model.itemFromIndex(index)
    for text in ["children1", "children2", "children3"] :
    INDENT
        children = QtGui.QStandardItem("{}_{}".format(parent.text(), text))
        parent.appendRow(children)
    DEDENT
    self.mytreeview.expand(index)

DEDENT
----------------------------------------

def update_model(self, index) :
INDENT
    parent_item = self.model.itemFromIndex(index)
    if not parent_item.rowCount() :
    INDENT
        for child_name_entry in parent_text_fileobject :
        INDENT
            child_item = QtGui.QStandardItem(child_name_entry.strip())
            child_item.setData("this is a child", QtCore.Qt.ToolTipRole)
            parent_item.appendRow(child_item)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46778623_46789599_5_14
46778623_46794777_13_22
Title: lazy loading child items Qtreeview 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    self.mytreeview = QtGui.QTreeView(self)
    self.setLayout(QtGui.QVBoxLayout())
    self.layout().addWidget(self.mytreeview)
    self.model = QtGui.QStandardItemModel(self.mytreeview)
    self.mytreeview.setModel(self.model)
    self.mytreeview.clicked.connect(self.update_model)
    self.initialise_model()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    self.mytreeview = QtGui.QTreeView()
    self.model = StandardItemModel(self.mytreeview)
    self.mytreeview.setModel(self.model)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.mytreeview)
    self.mytreeview.expanded.connect(self.update_model)
    self.initialise_model()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46780461_46780538_16_24
46780461_46780538_26_33
Title: Trouble with specific class inheritance behaviour 
----------------------------------------

def __init__(self) :
INDENT
    super().__init__()
    self.brawn = 2
    self.agility = 2
    self.intellect = 2
    self.cunning = 2,
    self.willpower = 2
    self.presence = 2
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super.__init__()
    self.brawn = 1
    self.agility = 3
    self.intellect = 3
    self.cunning = 2
    self.willpower = 3
    self.presence = 1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4678132_4678424_3_24
4678132_4686964_75_80
Title: "Separate first middle and last names (Python)" 
----------------------------------------

def process(file) :
INDENT
    for line in file :
    INDENT
        arr = line.split()
        if not arr :
        INDENT
            continue
        DEDENT
        last = arr.pop()
        n = len(arr)
        if n == 4 :
        INDENT
            first, middle = ' '.join(arr [: 2]), ' '.join(arr [2 :])
        DEDENT
        elif n == 3 :
        INDENT
            if arr [0] in ('M', 'Shk', 'BS') :
            INDENT
                first, middle = ' '.join(arr [: 2]), arr [- 1]
            DEDENT
            else :
            INDENT
                first, middle = arr [0], ' '.join(arr [1 :])
            DEDENT
        DEDENT
        elif n == 2 :
        INDENT
            first, middle = arr
        DEDENT
        else :
        INDENT
            continue
        DEDENT
        print 'First: %r' % first
        print 'Middle: %r' % middle
        print 'Last: %r' % last
    DEDENT
DEDENT
----------------------------------------

def process(inf, outf, fn) :
INDENT
    for line in inf :
    INDENT
        res = fn(line)
        if res is not None :
        INDENT
            outf.write(res)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4678132_4678511_2_16
4678132_4686964_41_61
Title: "Separate first middle and last names (Python)" 
----------------------------------------

def __init__(self, fullname) :
INDENT
    self.full = fullname
    s = self.full.split()
    try :
    INDENT
        self.first = " ".join(s [: 2]) if len(s [0]) == 1 else s [0]
        s = s [len(self.first.split()) :]
        self.middle = " ".join(s [: 2]) if len(s [0]) == 1 else s [0]
        s = s [len(self.middle.split()) :]
        self.last = " ".join(s [: 2]) if len(s [0]) == 1 else s [0]
    DEDENT
    finally :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def __init__(self, pre = None) :
INDENT
    super(NameSplitter, self).__init__()

    if pre is None :
    INDENT
        self.pre = set(['m', 'shk', 'bs'])
    DEDENT
    else :
    INDENT
        self.pre = set([s.lower() for s in pre])

    DEDENT
    self.isPre = lambda x, p = self.pre : x.lower() in p
    jn = lambda * args : ' '.join(* args)
    self.match = {}
    self.match [(3, ())] = lambda w, j = jn : (w [0], w [1], w [2])
    self.match [(4, (0,))] = lambda w, j = jn : (j(w [0], w [1]), w [2], w [3])
    self.match [(4, (1,))] = lambda w, j = jn : (w [0], j(w [1], w [2]), w [3])
    self.match [(5, (0, 2))] = lambda w, j = jn : (j(w [0], w [1]), j(w [2], w [3]), w [4])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46795812_46801182_16_28
46795812_46801182_44_55
Title: Pygame- How to shoot in direction of player sprite? 
----------------------------------------

def __init__(self, pos = (420, 420)) :
INDENT
    super(Player, self).__init__()
    self.image = pygame.Surface([20, 40], pygame.SRCALPHA)
    self.image.fill(RED)
    self.original_image = self.image
    self.rect = self.image.get_rect(center = pos)
    self.position = Vector2(pos)
    self.direction = Vector2(0, - 1)
    self.speed = 0
    self.angle_speed = 0
    self.angle = 0
DEDENT
----------------------------------------

def __init__(self, pos, direction, angle) :
INDENT
    super(Bullet, self).__init__()
    self.image = pygame.Surface([4, 10], pygame.SRCALPHA)
    self.image.fill(BLACK)
    self.image = pygame.transform.rotozoom(self.image, - angle, 1)
    self.rect = self.image.get_rect(center = pos)
    self.position = Vector2(pos)
    self.velocity = direction * 11
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46795812_46801182_29_40
46795812_46801182_56_64
Title: Pygame- How to shoot in direction of player sprite? 
----------------------------------------

def update(self) :
INDENT
    if self.angle_speed ! = 0 :
    INDENT

        self.direction.rotate_ip(self.angle_speed)
        self.angle += self.angle_speed
        self.image = pygame.transform.rotate(self.original_image, - self.angle)
        self.rect = self.image.get_rect(midtop = self.rect.midtop)
    DEDENT
    self.position += self.direction * self.speed
    self.rect.center = self.position

DEDENT
----------------------------------------

def update(self) :
INDENT
    self.position += self.velocity
    self.rect.center = self.position
    if self.rect.x < 0 or self.rect.x > SCREEN_WIDTH or self.rect.y < 0 or self.rect.y > SCREEN_HEIGHT :
    INDENT
        self.kill()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46798399_46799354_1_9
46798399_46799554_22_30
Title: How to put lists into one larger list in a certain order for certain conditions? - Python 3.x 
----------------------------------------

def get_newdeck(choice, P1, P2, P3) :
INDENT
    piles = [P1, P2, P3]
    piles [choice - 1], piles [1] = piles [1], piles [choice - 1]
    deck = []
    for pile in piles :
    INDENT
        deck.extend(pile)
    DEDENT
    return deck

DEDENT
----------------------------------------

def get_newdeck(choice, P1, P2, P3) :
INDENT
    deck = P1 + P3 + P2
    if choice == 1 :
    INDENT
        deck = P2 + P1 + P3
    DEDENT
    elif choice == 2 :
    INDENT
        deck = P1 + P2 + P3
    DEDENT
    return deck

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46803132_46803320_14_27
46803132_46803398_10_18
Title: String Slicing Into a list 
----------------------------------------

def one_frame(dna) :
INDENT
    c = 0
    q = 3
    dna_list = []
    dna_string = ""
    while (q < = len(dna)) :
    INDENT
        dna_string = dna [c : q]
        c = c + 3
        q = q + 3
        print dna_string
        if (dna_string == "atg") :
        INDENT
            dna_list.append(get_orf(dna [c - 3 :]))
        DEDENT
    DEDENT
    print dna_list
DEDENT
----------------------------------------

def one_frame(dna) :
INDENT
    c = 0
    dna_list = []
    while c < = len(dna) - 3 :
    INDENT
        dna_string = dna [c :]
        if dna_string.startswith("atg") :
        INDENT
            dna_list.append(get_orf(dna_string))
        DEDENT
        c += 1
    DEDENT
    return dna_list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46803132_46803320_1_13
46803132_46803398_1_9
Title: String Slicing Into a list 
----------------------------------------

def get_orf(dna_seq) :
INDENT
    for x in dna_seq :
    INDENT
        if ("taa" in dna_seq or "tag" in dna_seq or "tga" in dna_seq) :
        INDENT
            dna_seq = dna_seq.replace("taa", "")
            dna_seq = dna_seq.replace("tga", "")
            dna_seq = dna_seq.replace("tag", "")
            if ('atg' in dna_seq [3 :]) :
            INDENT
                dna_seq = "atg" + dna_seq [3 :].replace("atg", "")
            DEDENT
            return dna_seq
        DEDENT
        else :
        INDENT
            return dna_seq
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_orf(dna_seq) :
INDENT
    for counter, val in enumerate(dna_seq) :
    INDENT
        if val == "t" and counter < len(dna_seq) - 2 :
        INDENT
            if dna_seq [counter + 1 : counter + 3] in ["aa", "ag"] :
            INDENT
                return dna_seq [: counter]
            DEDENT
            if dna_seq [counter + 1 : counter + 3] == "ga" :
            INDENT
                return dna_seq [: counter]
            DEDENT
        DEDENT
    DEDENT
    return dna_seq
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46805555_46805904_28_33
46805555_46805904_46_58
Title: Python inventory of objects 
----------------------------------------

def __add__(self, other) :
INDENT
    if self == other :
    INDENT
        self.count += other.count
        return self
    DEDENT
    else :
    INDENT
        raise TypeError('Cannot add different Fruits.')
    DEDENT
DEDENT
----------------------------------------

def __add__(self, other) :
INDENT
    if isinstance(other, FruitBag) :
    INDENT
        pass
    DEDENT
    elif isinstance(other, FruitKind) :
    INDENT
        pass
    DEDENT
    else :
    INDENT
        raise NotImplementedError(
            'Cannot add instance of {} to Fruitbag.'
            .format(str(type(other))))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46819260_46940319_1_16
46819260_51731332_1_26
Title: Filtering Outliers - how to make median-based Hampel Function faster? 
----------------------------------------

def hampel(vals_orig, k = 7, t0 = 3) :
INDENT
    vals = vals_orig.copy()
    L = 1.4826
    rolling_median = vals.rolling(k).median()
    difference = np.abs(rolling_median - vals)
    median_abs_deviation = difference.rolling(k).median()
    threshold = t0 * L * median_abs_deviation
    outlier_idx = difference > threshold
    vals [outlier_idx] = np.nan
    return (vals)
DEDENT
----------------------------------------

def hampel(vals_orig, k = 7, t0 = 3) :
INDENT
    vals = vals_orig.copy()

    L = 1.4826
    rolling_median = vals.rolling(window = k, center = True).median()
    MAD = lambda x : np.median(np.abs(x - np.median(x)))
    rolling_MAD = vals.rolling(window = k, center = True).apply(MAD)
    threshold = t0 * L * rolling_MAD
    difference = np.abs(vals - rolling_median)
    '''
    Perhaps a condition should be added here in the case that the threshold value
    is 0.0; maybe do not mark as outlier. MAD may be 0.0 without the original values
    being equal. See differences between MAD vs SDV.
    '''
    outlier_idx = difference > threshold
    vals [outlier_idx] = np.nan
    return (vals)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46821761_46821827_1_13
46821761_46822127_3_13
Title: Looping input and finding average of list when q is inputed 
----------------------------------------

def listave(my_list) :
INDENT
    UserInput = ''
    while UserInput ! = 'q' :
    INDENT
        UserInput = input('Enter integer (q to quit:)')
        if UserInput == 'q' :
        INDENT
            break
        DEDENT
        try :
        INDENT
            x = float(UserInput)
            my_list.append(x)
        DEDENT
        except ValueError :
        INDENT
            print ('Only numeric values and "q" are acceptable inputs')
        DEDENT
    DEDENT
    print ('Average: ', float(sum(my_list) / len(my_list)))
DEDENT
----------------------------------------

def listave(list) :
INDENT
    UserInput = iter(partial(input, 'Enter integer (q to quit):'), 'q')
    for inp in UserInput :
    INDENT
        try :
        INDENT
            list.append(int(inp))
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
    DEDENT
    print ('Average: ', float(sum(list) / len(list)))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46821838_46821964_11_19
46821838_46822018_3_16
Title: How to create a list of dictionaries using for loop? 
----------------------------------------

def readVenueList(fd) :
INDENT
    c = reader(fd)
    hdr = ["name", "num", "cost"]
    for i in c :
    INDENT
        d = {}
        for el, v in enumerate(i) :
        INDENT
            d [hdr [el]] = v
        DEDENT
        yield d
    DEDENT
DEDENT
----------------------------------------

def readVenueList() :
INDENT
    venueList = []
    with open("venue.txt", "r") as f :
    INDENT
        for line in f :
        INDENT
            dic = {}
            items = [item.strip() for item in line.split(",")]
            dic ["name"] = items [0]
            dic ["num"] = items [1]
            dic ["cost"] = items [2]
            venueList.append(dic)
        DEDENT
    DEDENT
    return venueList
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46851971_46854113_2_27
46851971_46854113_39_72
Title: How to Pack with PyQt - how to make QFrame/Layout adapt to content 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QTextBrowser.__init__(self, parent)
    self.setContentsMargins(0, 0, 0, 0)
    self.setVerticalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    self.setHorizontalScrollBarPolicy(Qt.ScrollBarAlwaysOff)
    cstring = """
        QTextBrowser {
            border: 0;
            background-color: #<---->;
            margin: 0px;
            padding-left:0;
            padding-top:0;
            padding-bottom:0;
            padding-right:0;
        }
        """
    ncol = randint(300000, 999999)
    cstring = cstring.replace('<---->', str(ncol))
    self.setStyleSheet(cstring)
    self.document().contentsChange.connect(lambda : self.customGeometry())
    self.setSizePolicy(QSizePolicy.Preferred, QSizePolicy.Preferred)
    self.setContentsMargins(0, 0, 0, 0)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QScrollArea.__init__(self, parent)
    container = QFrame(self)
    layout = QGridLayout(container)
    layout.setSpacing(0)
    layout.setContentsMargins(0, 0, 0, 0)
    self.show()
    text = '''
                <table border="0" cellspacing="0" cellpadding="5" style="background-color: rgba(119, 212, 212, 0.7);"><![CDATA[
                <tr>
                    <td width="100"><![CDATA[
                        bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
                    </td>
                <tr>
                <tr>
                   <td>
                        bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla bla
                    </td>
                <tr>
                </table>
                '''
    for row in range(5) :
    INDENT
        for col in range(10) :
        INDENT
            box = Box(container)
            box.setText(text)
            box.show()
            layout.addWidget(box, row, col)
        DEDENT
    DEDENT
    self.setWidget(container)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46857615_46858160_28_33
46857615_46858160_8_26
Title: How to replace objects causing import errors with None during pickle load? 
----------------------------------------

def find_class(self, module, name) :
INDENT
    try :
    INDENT
        return super().find_class(module, name)
    DEDENT
    except AttributeError :
    INDENT
        return Dummy
    DEDENT
DEDENT
----------------------------------------

def find_class(self, module, name) :
INDENT
    try :
    INDENT
        if self.proto < 3 and self.fix_imports :
        INDENT
            if (module, name) in _compat_pickle.NAME_MAPPING :
            INDENT
                module, name = _compat_pickle.NAME_MAPPING [(module, name)]
            DEDENT
            elif module in _compat_pickle.IMPORT_MAPPING :
            INDENT
                module = _compat_pickle.IMPORT_MAPPING [module]
            DEDENT
        DEDENT
        __import__(module, level = 0)
        if self.proto > = 4 :
        INDENT
            return _getattribute(sys.modules [module], name) [0]
        DEDENT
        else :
        INDENT
            return getattr(sys.modules [module], name)
        DEDENT
    DEDENT
    except AttributeError :
    INDENT
        return Dummy

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46862849_46863027_14_23
46862849_46863140_9_18
Title: Integer remain integer but numbers with decimal will remain the decimal in my output answer? 
----------------------------------------

def odd(list) :
INDENT
    string = ""
    for number in list :
    INDENT
        number = float(number)
        if number % 2 ! = 0 :
        INDENT
            string += "~" + str(number)
        DEDENT
        if string.split('.') [- 1] == '0' :
        INDENT
            string = string.split('.') [0]
        DEDENT
    DEDENT
    return (string)
DEDENT
----------------------------------------

def odd(lst) :
INDENT
    string = ""
    for s in lst :
    INDENT
        number = float(s)
        if number % 2 ! = 0 :
        INDENT
            string += "~" + s
        DEDENT
    DEDENT
    return string

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46862849_46863027_4_13
46862849_46863140_1_8
Title: Integer remain integer but numbers with decimal will remain the decimal in my output answer? 
----------------------------------------

def even(list) :
INDENT
    string = ""
    for number in list :
    INDENT
        number = float(number)
        if number % 2 == 0 :
        INDENT
            string += "~" + str(number)
        DEDENT
        if string.split('.') [- 1] == '0' :
        INDENT
            string = string.split('.') [0]
        DEDENT
    DEDENT
    return (string)
DEDENT
----------------------------------------

def even(lst) :
INDENT
    string = ""
    for s in lst :
    INDENT
        number = float(s)
        if number % 2 == 0 :
        INDENT
            string += "~" + s
        DEDENT
    DEDENT
    return string
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46862849_46863140_1_8
46862849_46863204_4_13
Title: Integer remain integer but numbers with decimal will remain the decimal in my output answer? 
----------------------------------------

def even(lst) :
INDENT
    string = ""
    for s in lst :
    INDENT
        number = float(s)
        if number % 2 == 0 :
        INDENT
            string += "~" + s
        DEDENT
    DEDENT
    return string
DEDENT
----------------------------------------

def even(list) :
INDENT
    string = ""
    for number in list :
    INDENT
        number = float(number)
        if number.is_integer() :
        INDENT
            number = int(number)
        DEDENT
        if number % 2 == 0 :
        INDENT
            string += "~" + str(number)
        DEDENT
    DEDENT
    return (string)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46862849_46863140_9_18
46862849_46863204_14_23
Title: Integer remain integer but numbers with decimal will remain the decimal in my output answer? 
----------------------------------------

def odd(lst) :
INDENT
    string = ""
    for s in lst :
    INDENT
        number = float(s)
        if number % 2 ! = 0 :
        INDENT
            string += "~" + s
        DEDENT
    DEDENT
    return string

DEDENT
----------------------------------------

def odd(list) :
INDENT
    string = ""
    for number in list :
    INDENT
        number = float(number)
        if number.is_integer() :
        INDENT
            number = int(number)
        DEDENT
        if number % 2 ! = 0 :
        INDENT
            string += "~" + str(number)
        DEDENT
    DEDENT
    return (string)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46868482_46868677_1_15
46868482_46868946_1_20
Title: Using an index range to search ascii 
----------------------------------------

def cipher(phrase, shift) :
INDENT
    x = list(str(phrase))
    yy = ''
    print (x)
    for c in phrase :
    INDENT
        dec = ord(c) + shift
        while dec < 32 :
        INDENT
            dec = 127 - (32 - dec)
        DEDENT
        while dec > 126 :
        INDENT
            dec = 31 + (dec - 126)
        DEDENT
        yy += (chr(dec))
    DEDENT
    return yy
DEDENT
----------------------------------------

def cipher(phrase, shift) :
INDENT
    collector = []
    for c in phrase :
    INDENT
        i = ord(c)
        if i < 32 or i > 126 :
        INDENT
            raise ValueError('Char not in range [32, 126]: %s' % c)
        DEDENT
        i -= 32
        i += shift
        i %= 95
        i += 32
        d = chr(i)
        collector.append(d)
    DEDENT
    return phrase, ''.join(collector)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46876770_46876958_1_17
46876770_46880067_1_16
Title: How can I parse a host:port pair in Python 
----------------------------------------

def parse_hostport(hp) :
INDENT
    x = re.match('^(\[[0-9a-fA-F:]+\])(:(\d+))?$', hp)
    if x is not None :
    INDENT
        return x.group(1, 3)

    DEDENT
    splits = hp.split(':')
    if len(splits) == 1 :
    INDENT
        return splits + [None,]
    DEDENT
    elif len(splits) == 2 :
    INDENT
        return splits
    DEDENT
    raise ValueError("Invalid host:port input '%s'" % hp)
DEDENT
----------------------------------------

def parse_hostport(s, default_port = None) :
INDENT
    if s [- 1] == ']' :
    INDENT
        return (s, default_port)
    DEDENT
    out = s.rsplit(":", 1)
    if len(out) == 1 :
    INDENT

        port = default_port
    DEDENT
    else :
    INDENT
        try :
        INDENT
            port = int(out [1])
        DEDENT
        except ValueError :
        INDENT
            raise ValueError("Invalid host:port '%s'" % s)
        DEDENT
    DEDENT
    return (out [0], port)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46887816_46888118_1_11
46887816_46888145_1_10
Title: Storing variable inside of recursive function (python) 
----------------------------------------

def find_tuple(l, score = 0) :
INDENT
    for i, item in enumerate(l) :
    INDENT
        try :
        INDENT
            if item == 0 and l [i + 1] == 0 :
            INDENT
                score = score + 1
                print ("Number of tuples: {}".format(score))
                l = l [i + 2 :]
                return find_tuple(l, score)
            DEDENT
        DEDENT
        except :
        INDENT
            break
        DEDENT
    DEDENT
    return score
DEDENT
----------------------------------------

def find_tuple(l, score = 0) :
INDENT
    if len(l) < = 1 :
    INDENT
        return score
    DEDENT
    if l [0] == 0 and l [1] == 0 :
    INDENT
        score += 1
    DEDENT
    return find_tuple(l [2 :], score)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46901524_46901612_1_10
46901524_46901673_1_10
Title: Replace multiple characters in a string using a set of rules 
----------------------------------------

def applyRules(string, rules) :
INDENT
    mapping = str.maketrans(dict(x.split(':') for x in rules))
    while True :
    INDENT
        new = string.translate(mapping)
        if string == new :
        INDENT
            break
        DEDENT
        string = new
    DEDENT
    return new
DEDENT
----------------------------------------

def applyRules(char, rules) :
INDENT
    modified = char
    for rule in rules :
    INDENT
        r = rule.split(':')
        table = str.maketrans({r [0] : r [1]})
        modified = modified.translate(table)
    DEDENT
    return modified
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46924955_46937294_225_242
46924955_46937294_79_99
Title: Shipyard system linked list python 
----------------------------------------

def remove(self, Id, dest, cont) :
INDENT
    found = 0
    while cont.destination == dest and found == 0 :
    INDENT
        found = cont.remove(Id, cont.fpackage)
    DEDENT
    if found == 1 :
    INDENT
        if cont.fpackage == None :
        INDENT
            if cont.lt == None and cont.nt == None :
            INDENT
                self.FContainer = None
            DEDENT
            elif cont.lt == None and cont.nt ! = None :
            INDENT
                self.FContainer = cont.nt
            DEDENT
            elif cont.lt ! = None and cont.nt == None :
            INDENT
                cont.lt.nt = None
            DEDENT
            else :
            INDENT
                cont.lt.nt = cont.nt
                cont.nt.lt = cont.lt
            DEDENT
        DEDENT
    DEDENT
    elif cont.nt ! = None and cont.nt.destination < = dest and found ! = 1 :
    INDENT
        self.remove(Id, dest, cont.nt)
    DEDENT
DEDENT
----------------------------------------

def remove(self, Id, pack) :
INDENT
    found = 0
    noin = 0
    while found == 0 and noin == 0 :
    INDENT
        if self.fpackage.ID == Id :
        INDENT
            self.weight -= pack.weight
            self.fpackage = pack.nPack
            found = 1
        DEDENT
        elif pack.nPack == None :
        INDENT
            noin = 1
        DEDENT
        elif pack.nPack.ID == Id :
        INDENT
            self.weight -= pack.nPack.weight
            pack.nPack = pack.nPack.nPack
            found = 1
        DEDENT
        else :
        INDENT
            pack = pack.nPack
        DEDENT
    DEDENT
    if found == 0 and noin == 1 :
    INDENT
        return 2
    DEDENT
    elif found == 1 :
    INDENT
        return 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46931379_46931787_2_21
46931379_46931795_4_27
Title: Jump search algorithm in python 
----------------------------------------

def jump_search(arr, search) :
INDENT
    flag = 0
    interval = int(math.sqrt(len(arr)))
    for i in range(0, len(arr), interval) :
    INDENT
        if arr [i] > search :
        INDENT
            chunk = i
            flag = 1
            break
        DEDENT
        if arr [i] == search :
        INDENT
            return i
        DEDENT
    DEDENT
    if flag == 0 :
    INDENT
        c = i
        for j in arr [i :] :
        INDENT
            if j == search :
            INDENT
                return c
            DEDENT
            c += 1
        DEDENT
    DEDENT
    else :
    INDENT
        arr_ls = arr [chunk - interval : chunk]
        ind = [i for i, d in enumerate(arr_ls) if d == search]
        return chunk - interval + ind [0]
    DEDENT
DEDENT
----------------------------------------

def jump_search(arr, search) :
INDENT
    interval = int(math.sqrt(len(arr)))
    i = 0
    for i in range(0, len(arr), interval) :
    INDENT
        if arr [i] > search :
        INDENT
            break
        DEDENT
        if arr [i] == search :
        INDENT
            return i
        DEDENT
    DEDENT
    else :
    INDENT

        i += interval
    DEDENT
    last_chunk = arr [i - interval : i]

    for ind, val in enumerate(last_chunk) :
    INDENT
        if val == search :
        INDENT
            break
        DEDENT
    DEDENT
    else :
    INDENT
        return None
    DEDENT
    return i - interval + ind
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46937551_46938160_1_19
46937551_46939416_2_12
Title: Python program to returns how far away letters are in a string 
----------------------------------------

def janitor(word) :
INDENT
    left = [None] * 26
    right = [None] * 26
    widths = []
    for i, c in enumerate(word) :
    INDENT
        k = ord(c) - ord('a')
        if left [k] is None :
        INDENT
            left [k] = i
        DEDENT
        right [k] = i
    DEDENT
    for k in range(26) :
    INDENT
        if left [k] is None :
        INDENT
            width = 0
        DEDENT
        else :
        INDENT
            width = right [k] - left [k] + 1
        DEDENT
        widths.append(width)
    DEDENT
    return widths
DEDENT
----------------------------------------

def janitor(word) :
INDENT
    alphabets = string.ascii_lowercase
    result = [0] * 26
    for i in word :
    INDENT
        index = alphabets.find(i)
        if word.rfind(i) < 0 :
        INDENT
            result [index] = 0
        DEDENT
        else :
        INDENT
            result [index] = word.rfind(i) - word.find(i) + 1
        DEDENT
    DEDENT
    print (result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46937916_46938105_2_12
46937916_46938275_1_16
Title: Python - char and index match 
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = sum(x == y for x, y in zip(real, guess))

    c1, c2 = map(Counter, (real, guess))

    cows = sum(min(c1 [x], c2 [x]) for x in set(real) | set(guess)) - bulls
    print (bulls, cows)
DEDENT
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = 0
    cows = 0
    real_len = len(real)
    guess_len = len(guess)
    for i in range(real_len) :
    INDENT
        if i < guess_len and guess [i] == real [i] :
        INDENT
            bulls = bulls + 1
            print ("Bullseye!")
        DEDENT
        else :
        INDENT
            cows += 1
        DEDENT
    DEDENT
    if bulls == 0 :
    INDENT
        print ("No")
    DEDENT
    else :
    INDENT
        print ("Bulls: ", bulls, " Cows: ", cows)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46937916_46938105_2_12
46937916_46938314_1_13
Title: Python - char and index match 
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = sum(x == y for x, y in zip(real, guess))

    c1, c2 = map(Counter, (real, guess))

    cows = sum(min(c1 [x], c2 [x]) for x in set(real) | set(guess)) - bulls
    print (bulls, cows)
DEDENT
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = cows = 0
    for i, c in enumerate(guess) :
    INDENT
        if c in real :
        INDENT
            if real [i] == c :
            INDENT

                bulls += 1
            DEDENT
            else :
            INDENT
                cows += 1
            DEDENT
        DEDENT
    DEDENT
    print ('Bulls', bulls, 'Cows', cows)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46937916_46938105_2_12
46937916_46938675_1_11
Title: Python - char and index match 
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = sum(x == y for x, y in zip(real, guess))

    c1, c2 = map(Counter, (real, guess))

    cows = sum(min(c1 [x], c2 [x]) for x in set(real) | set(guess)) - bulls
    print (bulls, cows)
DEDENT
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = 0
    cows = 0
    for i in guess :
    INDENT
        if i == i in real :
        INDENT
            cows = cows + 1
            if guess.index(i) == real.index(i) :
            INDENT
                cows = cows - 1
                bulls = bulls + 1
            DEDENT
        DEDENT
    DEDENT
    print ("Bulls: " + str(bulls))
    print ("Cows: " + str(cows))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46937916_46938275_1_16
46937916_46938314_1_13
Title: Python - char and index match 
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = 0
    cows = 0
    real_len = len(real)
    guess_len = len(guess)
    for i in range(real_len) :
    INDENT
        if i < guess_len and guess [i] == real [i] :
        INDENT
            bulls = bulls + 1
            print ("Bullseye!")
        DEDENT
        else :
        INDENT
            cows += 1
        DEDENT
    DEDENT
    if bulls == 0 :
    INDENT
        print ("No")
    DEDENT
    else :
    INDENT
        print ("Bulls: ", bulls, " Cows: ", cows)
    DEDENT
DEDENT
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = cows = 0
    for i, c in enumerate(guess) :
    INDENT
        if c in real :
        INDENT
            if real [i] == c :
            INDENT

                bulls += 1
            DEDENT
            else :
            INDENT
                cows += 1
            DEDENT
        DEDENT
    DEDENT
    print ('Bulls', bulls, 'Cows', cows)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46937916_46938275_1_16
46937916_46938675_1_11
Title: Python - char and index match 
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = 0
    cows = 0
    real_len = len(real)
    guess_len = len(guess)
    for i in range(real_len) :
    INDENT
        if i < guess_len and guess [i] == real [i] :
        INDENT
            bulls = bulls + 1
            print ("Bullseye!")
        DEDENT
        else :
        INDENT
            cows += 1
        DEDENT
    DEDENT
    if bulls == 0 :
    INDENT
        print ("No")
    DEDENT
    else :
    INDENT
        print ("Bulls: ", bulls, " Cows: ", cows)
    DEDENT
DEDENT
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = 0
    cows = 0
    for i in guess :
    INDENT
        if i == i in real :
        INDENT
            cows = cows + 1
            if guess.index(i) == real.index(i) :
            INDENT
                cows = cows - 1
                bulls = bulls + 1
            DEDENT
        DEDENT
    DEDENT
    print ("Bulls: " + str(bulls))
    print ("Cows: " + str(cows))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46937916_46938314_1_13
46937916_46938675_1_11
Title: Python - char and index match 
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = cows = 0
    for i, c in enumerate(guess) :
    INDENT
        if c in real :
        INDENT
            if real [i] == c :
            INDENT

                bulls += 1
            DEDENT
            else :
            INDENT
                cows += 1
            DEDENT
        DEDENT
    DEDENT
    print ('Bulls', bulls, 'Cows', cows)
DEDENT
----------------------------------------

def bulls_and_cows(real, guess) :
INDENT
    bulls = 0
    cows = 0
    for i in guess :
    INDENT
        if i == i in real :
        INDENT
            cows = cows + 1
            if guess.index(i) == real.index(i) :
            INDENT
                cows = cows - 1
                bulls = bulls + 1
            DEDENT
        DEDENT
    DEDENT
    print ("Bulls: " + str(bulls))
    print ("Cows: " + str(cows))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46938046_46938116_1_6
46938046_46938498_1_11
Title: Create new lists from list where each list is 1 element shorter 
----------------------------------------

def breakdown(li) :
INDENT
    result = []
    for i in range(len(li) - 1, - 1, - 1) :
    INDENT
        result.append(li [: i + 1])
    DEDENT
    return result
DEDENT
----------------------------------------

def breakdown(a) :
INDENT
    y = []
    q = len(a)
    while q > 0 :
    INDENT
        y += [list(a)]
        a.pop()
        q -= 1
    DEDENT
    return y
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46941312_46941383_1_13
46941312_46941597_1_11
Title: python: create dictionary from lines of txt file 
----------------------------------------

def getFile() :
INDENT
    prose = str(input('Please enter the file path for your text file: '))
    dictionary = {}
    infile = open(prose, 'r')
    line_num = 1
    for line in infile :
    INDENT
        dictionary [line_num] = line
        line_num += 1
    DEDENT
    print (dictionary)
    infile.close()
DEDENT
----------------------------------------

def getFile(infile) :
INDENT
    prose = str(input('Please enter the file path for your text file: '))
    dictionary = {}
    infilelines = list(open(prose, 'r'))
    for line in enumerate(infilelines) :
    INDENT
        dictionary [line [0]] = line [1]
    DEDENT
    infile.close()
    return dictionary
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46943685_46943715_5_16
46943685_46943725_5_16
Title: python dictionary string operations 
----------------------------------------

def isim_donustur(isim) :
INDENT
    cikti = isim
    donusum = {'a' : 'Ankara', 'b' : 'Bursa', 'c' : 'Ceyhan'}

    result = []
    for letter in cikti :
    INDENT
        result.append(donusum [cikti])
    DEDENT
    print (' '.join(result))
DEDENT
----------------------------------------

def isim_donustur(isim) :
INDENT
    cikti = isim()
    donusum = {'a' : 'Ankara', 'b' : 'Bursa', 'c' : 'Ceyhan'}
    string = ''
    for char in cikti :
    INDENT
        string += donusum [char] + ' '
    DEDENT
    print (string)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46965927_46966112_5_14
46965927_46966115_7_16
Title: initialising Basic GUI in Python (using tkinter) 
----------------------------------------

def __init__(self, master) :
INDENT
    menu = Menu(master)
    master.config(menu = menu)
    subMenu = Menu(menu)
    menu.add_cascade(label = "File", menu = subMenu)
    subMenu.add_command(label = "Nothing", command = self.SayNothing)
    subMenu.add_command(label = "Exit", command = quit)
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    menu = Menu(master)
    master.config(menu = menu)
    subMenu = Menu(menu)
    menu.add_cascade(label = "File", menu = subMenu)
    subMenu.add_command(label = "Nothing", command = SayNothing)
    subMenu.add_command(label = "Exit", command = quit)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46972452_46972579_1_21
46972452_46972584_1_15
Title: cannot figure out why my letters are not rotating in the Caesar code in Python 
----------------------------------------

def caeser_encrypt(string, step) :
INDENT
    new_string = list(string)
    for i in range(len(new_string)) :
    INDENT
        new_ascii = ord(new_string [i]) + step
        if string [i] in ascii_uppercase :
        INDENT
            if new_ascii > 90 :
            INDENT
                new_ascii = new_ascii - 90 + 64
            DEDENT
            elif new_ascii < 65 :
            INDENT
                new_ascii = 91 - 65 - new_ascii
            DEDENT
        DEDENT
        if string [i] in ascii_lowercase :
        INDENT
            if new_ascii > 122 :
            INDENT
                new_ascii = new_ascii - 122 + 96
            DEDENT
            elif new_ascii < 97 :
            INDENT
                new_ascii = 123 - 97 - new_ascii
            DEDENT
        DEDENT
        new_string [i] = chr(new_ascii)
    DEDENT
    return ''.join(new_string)
DEDENT
----------------------------------------

def caeser_encrypt(string, step) :
INDENT
    new_string = list(string)
    for i, c in enumerate(new_string) :
    INDENT
        new_ascii = ord(c) + step
        if 'A' < = c < = 'Z' :
        INDENT
            new_ascii = ord('A') + (new_ascii - ord('A')) % 26
        DEDENT
        elif 'a' < = c < = 'z' :
        INDENT
            new_ascii = ord('a') + (new_ascii - ord('a')) % 26
        DEDENT
        new_string [i] = chr(new_ascii)
    DEDENT
    return ''.join(new_string)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46982733_47043930_33_45
46982733_47043930_52_72
Title: supervisor actor strategy for python 3 
----------------------------------------

def receiveMessage(self, message, sender) :
INDENT
    try :
    INDENT
        self.count += 1
        if isinstance(message, Greeting) :
        INDENT
            if (random.uniform(0, 1) > 0.5) :
            INDENT
                raise Exception("break............ id: " + str(message.id) + " [" + message.message + "]")
            DEDENT
            sleep(0.2)
            print ("id: " + str(message.id) + " [" + message.message + "]")
            self.send(sender, Remove(message.id))
        DEDENT
    DEDENT
    except Exception as e :
    INDENT
        print (e)
        self.send(sender, Reexecute(message.id))
    DEDENT
DEDENT
----------------------------------------

def receiveMessage(self, message, sender) :
INDENT
    if (self.hello == None) : self.hello = self.createActor(Hello)
    if isinstance(message, Add) :
    INDENT

        self.count += 1
        greeting = Greeting(self.count, message.value)
        print ("add: " + str(greeting))
        self.queue [self.count] = greeting
        greeting.sendTo = [self.hello, sender]
        self.send(self.hello, greeting)
    DEDENT
    elif isinstance(message, Remove) :
    INDENT
        print ("Remove: " + str(self.queue.get(message.id)))
        greeting = self.queue.pop(message.id)
        self.finalValue = self.finalValue + " " + str(greeting.message)
    DEDENT
    elif isinstance(message, Reexecute) :
    INDENT
        print ("reexecute: " + str(message.id))
        greeting = Greeting(message.id, str(self.queue.get(message.id)))
        greeting.sendTo = [self.hello, sender]
        self.send(self.hello, greeting)
    DEDENT
    elif isinstance(message, Print) :
    INDENT
        print (self.finalValue)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46983310_46992274_13_23
46983310_46993100_34_56
Title: To-Do List Python function 
----------------------------------------

def print_tasks(maskby) :
INDENT
    mask = df [df ['datetime'].dt.date.astype(str) == maskby].sort_values(by = 'datetime')
    s = ['These are your tasks for {}:\n'.format(maskby)]
    for ind, row in mask.iterrows() :
    INDENT
        name = row ["name"]
        stime = row ["datetime"].strftime("%H:%M")
        etime = (row ["datetime"] + datetime.timedelta(minutes = row ["length"])).strftime("%H:%M")
        desc = row ["description"]
        s.append(printformat.format(name, stime, etime, desc))
    DEDENT
    return ''.join(s)
DEDENT
----------------------------------------

def print_tasks(tasks, date) :
INDENT
    print ("*" * 40)
    dt = datetime.datetime.strptime('-'.join(str(i) for i in date), "%m-%d")
    dt_format = dt.strftime("%d %B")
    print ('These are your tasks for {}:'.format(dt_format))
    for task in sorted(tasks, key = lambda x : (x [3], x [4])) :
    INDENT
        if task [1 : 3] == date :
        INDENT
            name = task [0]
            duration = int(task [5])
            description = task [6]
            time = '-'.join(str(i) for i in task [3 : 5])
            stime = datetime.datetime.strptime(time, "%H-%M")
            etime = stime + datetime.timedelta(minutes = duration)
            print (printformat.format(name,
                    stime.strftime("%I:%M %p"),
                    etime.strftime("%I:%M %p"),
                    description))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46985420_46985499_1_13
46985420_46985575_1_12
Title: List Index Out of Range for list[0] 
----------------------------------------

def sum13(nums) :
INDENT
    if nums :
    INDENT
        sum = 0
        if nums [0] ! = 13 :
        INDENT
            sum += nums [0]
        DEDENT
        for i in range(1, len(nums)) :
        INDENT
            print 'Current number:', str(nums [i])
            print 'Previous number:', str(nums [i - 1])
            if nums [i] ! = 13 and nums [i - 1] ! = 13 :
            INDENT
                sum += nums [i]
            DEDENT
        DEDENT
        return sum
    DEDENT
    if not nums :
    INDENT
        print 'Empty list'
    DEDENT
DEDENT
----------------------------------------

def sum13(nums) :
INDENT
    sum = 0
    i = 0
    while i < len(nums) :
    INDENT
        x = nums [i]
        if x == 13 :
        INDENT

            i += 2
        DEDENT
        else :
        INDENT
            sum += x
            i += 1
        DEDENT
    DEDENT
    return sum
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46986727_46986783_1_14
46986727_46986786_1_14
Title: Summing numbers in a list except those between 6 and 7 
----------------------------------------

def sum67(nums) :
INDENT
    i = 0
    total = 0
    while i < len(nums) :
    INDENT
        if nums [i] == 6 :
        INDENT
            for i in range(i + 1, len(nums)) :
            INDENT
                if nums [i] == 7 :
                INDENT
                    break
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT
            total += nums [i]
        DEDENT
        i += 1
    DEDENT
    return total
DEDENT
----------------------------------------

def sum67(nums) :
INDENT
    active = True
    tot = 0
    for n in nums :
    INDENT
        if n == 6 :
        INDENT
            active = False
        DEDENT
        if active :
        INDENT
            tot += n
        DEDENT
        if n == 7 and not active :
        INDENT
            active = True
        DEDENT
    DEDENT
    return tot
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46991857_46992176_10_17
46991857_46997461_1_8
Title: python sqlite3 insert table error: cursor is not connected? 
----------------------------------------

def new_data_entry() :
INDENT
    name = 'Wendy'
    gender = 'F'
    frequency = 321
    year = '2006'
    c.execute("INSERT INTO babyName (name, gender, frequency, year) VALUES (?, ?, ?, ?)", (name, gender, frequency, year))
    cnn.commit()
DEDENT
----------------------------------------

def new_data_entry() :
INDENT
    name = 'Wendy'
    gender = 'F'
    frequency = 321
    year = '2006'
    c.execute("INSERT INTO babyName (name, gender, frequency, year) VALUES (%s, %s, %s, %s)", (name, gender, frequency, year))
    cnn.commit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46992286_46992311_2_12
46992286_46992348_1_9
Title: "How to return two values from a function that are created in the function? - Python" 
----------------------------------------

def FindingTwoPrimes(n, p1, p2) :
INDENT
    primeList = []
    for num in range(1, 101) :
    INDENT
        if all(num % i ! = 0 for i in range(2, num)) :
        INDENT
            primeList.append(num)
        DEDENT
    DEDENT
    lengthOfPrimelist = len(primeList)
    p1 = primeList [random.randint(0, lengthOfPrimelist)]
    p2 = primeList [random.randint(0, lengthOfPrimelist)]
    n = p1 * p2
    return [p1, p2, n]
DEDENT
----------------------------------------

def FindingTwoPrimes(primeList) :
INDENT
    lengthOfPrimelist = len(primeList)
    p1 = primeList [random.randint(0, lengthOfPrimelist)]
    p2 = primeList [random.randint(0, lengthOfPrimelist)]
    n = p1 * p2
    print ("p1 =", p1)
    print ("p2 =", p2)
    return n, p1, p2
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
46994436_46994448_4_24
46994436_46994749_1_36
Title: Create a JSON object in python 
----------------------------------------

def read_relationship(filename) :
INDENT
    data = []
    with open(filename, 'rb') as f :
    INDENT
        reader = csv.reader(f, delimiter = '\t')
        next(reader, None)
        for row in reader :
        INDENT
            data.append([{
                        'source' : {
                            'id' : row [0],
                            'start' : int(row [2]),
                            'end' : int(row [3]),
                            },
                        'target' : {
                            'id' : row [1],
                            'start' : int(row [4]),
                            'end' : int(row [5]),
                            },
                        }])
        DEDENT
    DEDENT
    with open('data/data.txt', 'w') as outfile :
    INDENT
        json.dump(data, outfile)
    DEDENT
DEDENT
----------------------------------------

def read_relationship(filename) :
INDENT
    data = []
    with open(filename) as f :
    INDENT
        f.next()
        for line in f :
        INDENT
            try :
            INDENT
                parts = line.rstrip().split('\t')
                query_name = parts [0]
                subject_name = parts [1]
                query_start = parts [2]
                query_end = parts [3]
                subject_start = parts [4]
                subject_end = parts [5]

                item = {
                    'source' : {
                        'id' : query_name,
                        'start' : subject_name,
                        'end' : query_start},
                    'target' : {
                        'id' : query_end,
                        'start' : subject_start,
                        'end' : subject_end}}
                data.append(item)
            DEDENT
            except ValueError :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    with open('data/data.txt', 'w') as outfile :
    INDENT
        json.dump(data, outfile)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47008436_47008984_1_10
47008436_47009246_4_14
Title: Convert data in a list to the correct type 
----------------------------------------

def clean_data(xs) :
INDENT
    clean_xs = list()
    for x in xs :
    INDENT
        try :
        INDENT
            converted_x = ast.literal_eval(x)
        DEDENT
        except ValueError :
        INDENT
            converted_x = x
        DEDENT
        clean_xs.append(converted_x)
    DEDENT
    return clean_xs
DEDENT
----------------------------------------

def clean_data(l) :
INDENT
    l1 = []
    for l2 in l :
    INDENT
        l3 = []
        for e in l2 :
        INDENT
            try :
            INDENT
                l3.append(ast.literal_eval(e))
            DEDENT
            except ValueError :
            INDENT
                l3.append(e)
            DEDENT
        DEDENT
        l1.append(l3)
    DEDENT
    return l1
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47021335_47021741_13_18
47021335_47021793_1_12
Title: Python : parasitic number 
----------------------------------------

def parasitic(number) :
INDENT
    rotated = rotateRight(number)
    if not rotated % number :
    INDENT
        return rotated / / number
    DEDENT
    else :
    INDENT
        return 0
    DEDENT
DEDENT
----------------------------------------

def parasitic(number) :
INDENT
    count = 0;
    getal = count * number;
    while getal ! = rotateLeft(number) and getal ! = rotateRight(number) :
    INDENT
        count += 1
        getal = int(count * number)
        if getal == rotateLeft(number) or getal == rotateRight(number) :
        INDENT
            print (count); print (getal);
            return (count)
        DEDENT
        else :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47024282_47025176_5_12
47024282_47034519_3_22
Title: Additional condition to function - Odoo v8 
----------------------------------------

def check_quantity(self) :
INDENT
    for line in self.order_lines :
    INDENT
        if line.isbn.qty_available and (line.qty > line.isbn.qty_available) :
        INDENT
            raise ValidationError("Quantity is invalid. %s" % line.qty)
        DEDENT
        if not line.isbn :
        INDENT
            raise ValidationError('Enter at least 1 ISBN to produce')
        DEDENT
        else :
        INDENT
            self.write({'state' : 'inprogress',},)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def check_quantity(self) :
INDENT
    for rec in self :
    INDENT
        if rec.order_lines :
        INDENT
            for line in rec.order_lines :
            INDENT
                if not line.isbn :
                INDENT
                    raise Warning(('Enter at least 1 ISBN to produce'))
                DEDENT
                if line.qty > line.isbn.qty_available :
                INDENT
                    raise Warning(('Quantity is invalid.'))
                DEDENT
                else :
                INDENT

                    rec.update({'state' : 'inprogress',},)

                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47025274_47039310_17_28
47025274_47039310_31_54
Title: Multilpe screen in wxpython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    grid = gridlib.Grid(self)
    grid.CreateGrid(25, 12)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(grid, 0, wx.EXPAND)
    self.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Panel Switcher Tutorial")
    self.panel_one = PanelOne(self)
    self.panel_two = PanelTwo(self)
    self.panel_two.Hide()
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.sizer.Add(self.panel_two, 1, wx.EXPAND)
    self.SetSizer(self.sizer)

    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    switch_panels_menu_item = fileMenu.Append(wx.ID_ANY,
        "Switch Panels",
        "Some text")
    self.Bind(wx.EVT_MENU, self.onSwitchPanels,
        switch_panels_menu_item)
    menubar.Append(fileMenu, '&File')
    self.SetMenuBar(menubar)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47037726_47037893_4_10
47037726_47038643_3_9
Title: Check if value of one key in json has another key 
----------------------------------------

def func(data) :
INDENT
    for index, value in data.items() :
    INDENT
        print index, value
        if isinstance(value, dict) :
        INDENT
            func(value)

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def func(obj, name = '') :
INDENT
    try :
    INDENT
        for key, value in obj.items() :
        INDENT
            func(value, key)
        DEDENT
    DEDENT
    except AttributeError :
    INDENT
        print ('{}: {}'.format(name, obj))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47046082_47046240_3_25
47046082_47046265_1_14
Title: How do I print the average value after the for loop? 
----------------------------------------

def guess(num_loops) :
INDENT
    total_tries = 0
    for i in range(num_loops) :
    INDENT
        the_num = random.randint(1, 100)
        print ('The number to guess is', the_num)
        comp_guess = random.randint(1, 100)
        print ('The computer guesses ', comp_guess)
        tries = 1
        while comp_guess ! = the_num :
        INDENT

            tries += 1
            print (tries)
            if comp_guess == the_num :
            INDENT
                break
            DEDENT
            else :
            INDENT
                comp_guess = random.randint(1, 100)
            DEDENT
        DEDENT
        total_tries += tries
        print ('The computer took', tries, 'guesses')
        print ('The computer guessed it right!')
    DEDENT
    print ('The computer guessed', (total_tries / num_loops), 'times on average')
DEDENT
----------------------------------------

def guess() :
INDENT
    the_num = random.randint(1, 100)
    print ('The number to guess is', the_num)
    comp_guess = random.randint(1, 100)
    print ('The computer guesses ', comp_guess)
    tries = 1
    while comp_guess ! = the_num :
    INDENT
        print ('The computer guesses ', comp_guess)
        tries += 1
        if comp_guess == the_num :
        INDENT
            break
        DEDENT
        else :
        INDENT
            comp_guess = random.randint(1, 100)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47047722_47047776_1_11
47047722_47047986_3_12
Title: Python: Average Prie per Year 
----------------------------------------

def clean_data(infile) :
INDENT
    lines = infile.readlines()
    total = 0.0
    num = 0
    for line in lines :
    INDENT
        spl = line.strip().split(":")
        total += float(spl [len(spl) - 1])
        num += 1
    DEDENT
    average = total / num
    print (average)
    return average
DEDENT
----------------------------------------

def clean_data() :
INDENT
    data = []
    for line in infile :
    INDENT
        data.append(line.strip().split(':'))
    DEDENT
    values = []
    for value in data :
    INDENT
        values.append(float(value [1]))
    DEDENT
    avg_price = sum(values) / len(values)
    print (avg_price)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47047834_47048133_18_28
47047834_47049493_10_21
Title: Drawing nested squares in Python turtle 
----------------------------------------

def cups(initial, incr, reps) :
INDENT
    start = initial
    for i in range(reps) :
    INDENT
        cup(start)
        t.pu()
        t.forward(incr / 2)
        t.left(90)
        start += incr

    DEDENT
DEDENT
----------------------------------------

def cups(turtle, initial, incr, reps) :
INDENT
    for length in range(0, incr * reps, incr) :
    INDENT
        cup(turtle, initial + length)
        turtle.forward(incr / 2)
        turtle.left(90)
        turtle.pendown()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47047834_47048133_5_17
47047834_47049493_3_9
Title: Drawing nested squares in Python turtle 
----------------------------------------

def cup(sideLength) :
INDENT
    t.pd()
    t.forward(sideLength)
    t.left(90)
    t.forward(sideLength)
    t.left(90)
    t.forward(sideLength)
    t.pu()
    t.left(90)
    t.forward(sideLength)
DEDENT
----------------------------------------

def cup(turtle, sideLength) :
INDENT
    for _ in range(3) :
    INDENT
        turtle.forward(sideLength)
        turtle.left(90)
    DEDENT
    turtle.penup()
    turtle.forward(sideLength)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47049035_47049959_1_21
47049035_47049962_1_15
Title: How to make a function that can allow two miss match str in python 
----------------------------------------

def g4_match(X, Y) :
INDENT
    N = "TAG"
    K = "L"
    D = "E"
    spl_mismatch, mismatch = (0, 0)
    for x, y in zip(X, Y) :
    INDENT
        if x ! = y and x ! = 'X' :
        INDENT
            if x == 'N' and y in N :
            INDENT
                spl_mismatch += 1
            DEDENT
            elif x == 'K' and y in K :
            INDENT
                spl_mismatch += 1
            DEDENT
            elif x == 'D' and y in D :
            INDENT
                spl_mismatch += 1
            DEDENT
            else :
            INDENT
                mismatch += 1
            DEDENT
        DEDENT
    DEDENT
    if mismatch > 1 or spl_mismatch > 1 :
    INDENT
        return False
    DEDENT
    return True

DEDENT
----------------------------------------

def g4_match(X, Y) :
INDENT
    spl_match = 0
    if Y [0] == 'N' or Y [0] == 'T' or Y [0] == 'A' or Y [0] == 'G' :
    INDENT
        spl_match += 1
    DEDENT
    elif Y [1] == 'K' or Y [1] == 'L' :
    INDENT
        spl_match += 1
    DEDENT
    elif Y [3] == 'D' or Y [3] == 'E' :
    INDENT
        spl_match += 1
    DEDENT
    if spl_match > 1 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47049035_47049959_1_21
47049035_47050377_1_22
Title: How to make a function that can allow two miss match str in python 
----------------------------------------

def g4_match(X, Y) :
INDENT
    N = "TAG"
    K = "L"
    D = "E"
    spl_mismatch, mismatch = (0, 0)
    for x, y in zip(X, Y) :
    INDENT
        if x ! = y and x ! = 'X' :
        INDENT
            if x == 'N' and y in N :
            INDENT
                spl_mismatch += 1
            DEDENT
            elif x == 'K' and y in K :
            INDENT
                spl_mismatch += 1
            DEDENT
            elif x == 'D' and y in D :
            INDENT
                spl_mismatch += 1
            DEDENT
            else :
            INDENT
                mismatch += 1
            DEDENT
        DEDENT
    DEDENT
    if mismatch > 1 or spl_mismatch > 1 :
    INDENT
        return False
    DEDENT
    return True

DEDENT
----------------------------------------

def g4_match(X, Y) :
INDENT
    spl_match = 0
    if Y [0] == 'N' or 'T' or 'A' or 'G' :
    INDENT
        spl_match += 1
    DEDENT
    if Y [1] == 'K' or 'L' :
    INDENT
        spl_match += 1
    DEDENT
    if Y [3] == 'D' or 'E' :
    INDENT
        spl_match += 1
    DEDENT
    if spl_match > 1 :
    INDENT
        return False
    DEDENT
    mismatch, spl_mismatch = 0, 0
    for x, y in zip(X, Y) :
    INDENT
        if not (x == 'X' and y == x) :
        INDENT
            if (y in spl_amino) :
            INDENT
                spl_mismatch += 1
            DEDENT
            else :
            INDENT
                mismatch += 1
            DEDENT
        DEDENT
        if mismatch > 1 or spl_mismatch > 1 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47049035_47049962_1_15
47049035_47050377_1_22
Title: How to make a function that can allow two miss match str in python 
----------------------------------------

def g4_match(X, Y) :
INDENT
    spl_match = 0
    if Y [0] == 'N' or Y [0] == 'T' or Y [0] == 'A' or Y [0] == 'G' :
    INDENT
        spl_match += 1
    DEDENT
    elif Y [1] == 'K' or Y [1] == 'L' :
    INDENT
        spl_match += 1
    DEDENT
    elif Y [3] == 'D' or Y [3] == 'E' :
    INDENT
        spl_match += 1
    DEDENT
    if spl_match > 1 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False

    DEDENT
DEDENT
----------------------------------------

def g4_match(X, Y) :
INDENT
    spl_match = 0
    if Y [0] == 'N' or 'T' or 'A' or 'G' :
    INDENT
        spl_match += 1
    DEDENT
    if Y [1] == 'K' or 'L' :
    INDENT
        spl_match += 1
    DEDENT
    if Y [3] == 'D' or 'E' :
    INDENT
        spl_match += 1
    DEDENT
    if spl_match > 1 :
    INDENT
        return False
    DEDENT
    mismatch, spl_mismatch = 0, 0
    for x, y in zip(X, Y) :
    INDENT
        if not (x == 'X' and y == x) :
        INDENT
            if (y in spl_amino) :
            INDENT
                spl_mismatch += 1
            DEDENT
            else :
            INDENT
                mismatch += 1
            DEDENT
        DEDENT
        if mismatch > 1 or spl_mismatch > 1 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47066728_47089791_18_28
47066728_47089791_5_13
Title: Combine @property with another decorator 
----------------------------------------

def deco(f) :
INDENT
    f.wrapped = True
    def wrap(* args, ** kwargs) :
    INDENT
        if not is_android :
        INDENT
            return params
        DEDENT
        return f()
    DEDENT
    wrap.__decorated_by_mobile__ = True
    return wrap
DEDENT
----------------------------------------

def deco(f) :
INDENT
    def wrap(* args, ** kwargs) :
    INDENT
        if is_android :
        INDENT
            return params
        DEDENT
        return f()
    DEDENT
    wrap.__decorated_by_mobile__ = True
    return wrap
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47067036_47067264_23_27
47067036_47075566_1_13
Title: getting data from nested Dictionary in Python 
----------------------------------------

def search(values, lookup) :
INDENT
    for k in values :
    INDENT
        if any(lookup in str(s) for s in k.values()) :
        INDENT
            return k
        DEDENT
    DEDENT
    return None
DEDENT
----------------------------------------

def search(values, lookup) :
INDENT
    result = []
    for item in values :
    INDENT
        for key, value in item.items() :
        INDENT
            if lookup in value :
            INDENT
                if item not in result :
                INDENT
                    result.append(item)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    if result :
    INDENT
        return result
    DEDENT
    else :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47076156_47077767_77_83
47076156_47079070_2_11
Title: Implementation of class based Tower of Hanoi with stacks solution error 
----------------------------------------

def __init__(self, disks = 3, pegs = 3) :
INDENT
    self.origin = Peg('origin')
    self.destiny = Peg('destiny')
    self.aux = [Peg('aux{}'.format(i)) for i in range(1, pegs - 1)]
    for i in range(disks, 0, - 1) :
    INDENT
        self.origin.push(Disk(i))
    DEDENT
DEDENT
----------------------------------------

def __init__(self, numDisks, src, spare, dest) :
INDENT
    self.numDisks = numDisks
    self.towers = {
        src : Stack(),
        spare : Stack(),
        dest : Stack()}
    for i in range(n, 0, - 1) :
    INDENT
        self.towers [src].push(i);
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47090039_47090260_5_15
47090039_47090271_2_10
Title: Class for custom GUI element not showing 
----------------------------------------

def __init__(self, master = None, ** kwargs) :
INDENT
    super().__init__(master, kwargs)
    self.label = tk.Label(self, text = "Enter here:")
    self.entry = tk.Entry(self)
    self.label.pack()
    self.entry.pack()

DEDENT
----------------------------------------

def __init__(self, mainwindow) :
INDENT
    super(Mypanel, self).__init__(mainwindow)
    self.label = tk.Label(self, text = "Enter here:")
    self.entry = tk.Entry(self)
    self.label.pack()
    self.entry.pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47096150_47096320_1_8
47096150_47096640_1_6
Title: Python3: for-loop break and else (if statement) 
----------------------------------------

def validationHelper(myDict, myList) :
INDENT
    for key in myDict :
    INDENT
        for value in myDict [key] [0] :
        INDENT
            for item in myList :
            INDENT
                if value == item :
                INDENT
                    return "String is valid"
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return "Warning: String is NOT valid"
DEDENT
----------------------------------------

def validationHelper(myDict, myList) :
INDENT
    for item in myList :
    INDENT
        if item in myDict.values() :
        INDENT
            return ("String is valid")
        DEDENT
    DEDENT
    return ("String is NOT valid")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47096150_47096320_1_8
47096150_47106518_1_6
Title: Python3: for-loop break and else (if statement) 
----------------------------------------

def validationHelper(myDict, myList) :
INDENT
    for key in myDict :
    INDENT
        for value in myDict [key] [0] :
        INDENT
            for item in myList :
            INDENT
                if value == item :
                INDENT
                    return "String is valid"
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return "Warning: String is NOT valid"
DEDENT
----------------------------------------

def validationHelper(myDict, myList) :
INDENT
    if any(v in myList for val in myDict.values() for v in val [0]) :
    INDENT
        validationHelper.true = "String is valid"
    DEDENT
    else :
    INDENT
        validationHelper.true = "Warning: String is NOT valid"
    DEDENT
DEDENT
----------------------------------------
