$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16640662_16640706_1_17
16640662_16640719_15_25
Title: Looking for values in Python Dictionaries 
----------------------------------------

def sumDivisors(num, divisorSums = {}) :
INDENT
    if num in divisorSums :
    INDENT
        return divisorSums [num]
    DEDENT
    total = 0
    if num == 1 :
    INDENT
        return 0
    DEDENT
    for i in xrange(num / 2, 0, - 1) :
    INDENT
        if not num % i :
        INDENT
            total += i
        DEDENT
    DEDENT
    divisorSums [num] = total
    return total
DEDENT
----------------------------------------

def sumDivisors(num) :
INDENT
    if num == 1 : return 0
    l = {}
    for i in xrange(num / 2, 0, - 1) :
    INDENT
        if num % i == 0 :
        INDENT
            l.update(divisors(i))
            l.update(divisors(num / i))
            l [i] = 1
            l [num / i] = 1
            break
        DEDENT
    DEDENT
    return sum(v for v in l)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16641704_16641724_3_12
16641704_16641745_2_8
Title: Assembling output from a recursive function? 
----------------------------------------

def get_file_list(directory = os.getcwd()) :
INDENT
    def file_list(directory, files) :
    INDENT
        for i in os.listdir(directory) :
        INDENT
            if os.path.isdir(i) :
            INDENT
                file_list(i, files)
                continue
            DEDENT
            files.append(i)
        DEDENT
        return files
    DEDENT
    return file_list(directory, [])
DEDENT
----------------------------------------

def get_file_list(files, directory = os.getcwd()) :
INDENT
    for i in os.listdir(directory) :
    INDENT
        if os.path.isdir(i) :
        INDENT
            get_file_list(files, i)
            continue
        DEDENT
        files.append(i)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1665511_1665550_12_20
1665511_1665550_2_11
Title: Python equivalent to atoi / atof 
----------------------------------------

def atof(s) :
INDENT
    try :
    INDENT
        return float(s)
    DEDENT
    except :
    INDENT
        if not s :
        INDENT
            return 0.0
        DEDENT
        return atof(s [: - 1])

    DEDENT
DEDENT
----------------------------------------

def atof(s) :
INDENT
    s, _, _ = s.partition(' ')
    while s :
    INDENT
        try :
        INDENT
            return float(s)
        DEDENT
        except :
        INDENT
            s = s [: - 1]
        DEDENT
    DEDENT
    return 0.0

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16667082_16669755_41_53
16667082_16669755_5_20
Title: wxPython childframes interaction 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, wx.GetApp().TopWindow, wx.ID_ANY, 'Child1')
    panel = wx.Panel(self, - 1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    button = wx.Button(panel, - 1, 'Open Child2')
    sizer.Add(button, 0, wx.CENTER | wx.ALL, 5)
    panel.SetSizer(sizer)
    self.Bind(wx.EVT_BUTTON, self.GetParent().onButton2, button)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, 'Parent')
    panel = wx.Panel(self, - 1)
    sizer = wx.BoxSizer(wx.VERTICAL)
    button = wx.Button(panel, - 1, 'Open Child1')
    button2 = wx.Button(panel, - 1, 'Open Child2')
    sizer.Add(button, 0, wx.CENTER | wx.ALL, 5)
    sizer.Add(button2, 0, wx.CENTER | wx.ALL, 5)
    panel.SetSizer(sizer)
    self.Bind(wx.EVT_BUTTON, self.onButton, button)
    self.Bind(wx.EVT_BUTTON, self.onButton2, button2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16672530_16672970_7_18
16672530_26694270_10_16
Title: cursor tracking using matplotlib and twinx 
----------------------------------------

def __call__(self, event) :
INDENT
    if event.inaxes is None :
    INDENT
        return
    DEDENT
    ax = self.ax
    if ax ! = event.inaxes :
    INDENT
        inv = ax.transData.inverted()
        x, y = inv.transform(np.array((event.x, event.y)).reshape(1, 2)).ravel()
    DEDENT
    elif ax == event.inaxes :
    INDENT
        x, y = event.xdata, event.ydata
    DEDENT
    else :
    INDENT
        return
    DEDENT
    logger.debug('{n}: ({x:0.2f}, {y:0.2f})'.format(n = self.name, x = x, y = y))
DEDENT
----------------------------------------

def __call__(self, event) :
INDENT
    if event.inaxes is None :
    INDENT
        return
    DEDENT
    x, y1 = ax1.transData.inverted().transform((event.x, event.y))
    x, y2 = ax2.transData.inverted().transform((event.x, event.y))
    logger.debug('(x,y1,y2)=({x:0.2f}, {y1:0.2f}, {y2:0.2f})'.format(x = x, y1 = y1, y2 = y2))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16678605_16678666_1_13
16678605_16679550_7_13
Title: "Simulate several rounds of rock paper and scissors" 
----------------------------------------

def simul(n) :
INDENT
    score = 0
    for i in range(n) :
    INDENT
        p1 = choose_rps()
        p2 = choose_rps()
        result = rps(p1, p2)
        score += result
    DEDENT
    if score < 0 :
    INDENT
        print ('Player 1')
    DEDENT
    elif score == 0 :
    INDENT
        print ('Tie')
    DEDENT
    else :
    INDENT
        print ('Player 2')
    DEDENT
DEDENT
----------------------------------------

def simul(n) :
INDENT
    p1 = rand_RPSLK()
    p2 = rand_RPSLK()
    choice = lambda px : 'PSKLR'.index(next(px))
    score = sum([[0, 1, - 1, 1, - 1] [choice(p1) - choice(p2)] for i in xrange(n)])
    winner_idx = 0 if score > 0 else 1 if score < 0 else 2
    print ['Player 1', 'Player 2', 'Tie'] [winner_idx]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16688464_16688577_1_15
16688464_16688713_1_11
Title: Slimming down a function 
----------------------------------------

def process_ancestors(relation_dict, name) :
INDENT
    name_found = search_name(relation_dict, name)
    if not name_found :
    INDENT
        return "Unknown person"
    DEDENT
    ancestor_list = []
    person = find_parent(relation_dict, name)
    while person is not None :
    INDENT
        ancestor_list.append(person)
        person = find_parent(relation_dict, person)
    DEDENT
    if not ancestor_list :
    INDENT
        return "No known ancestors"
    DEDENT
    return ", ".join(ancestor_list)
DEDENT
----------------------------------------

def process_ancestors(relation_dict, name) :
INDENT
    if not search_name(relation_dict, name) :
    INDENT
        return "Unknown person"
    DEDENT
    else :
    INDENT
        ancestor_list = list(ancestors(relation_dict, name))
        if not ancestor_list :
        INDENT
            return "Unknown parent"
        DEDENT
        else :
        INDENT
            return ", ".join(ancestor_list)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16688464_16688598_1_12
16688464_16688713_1_11
Title: Slimming down a function 
----------------------------------------

def process_ancestors(relation_dict, name) :
INDENT
    name_found = search_name(relation_dict, name)
    if not name_found :
    INDENT
        return "Unknown person"
    DEDENT
    ancestor_list = []
    person = name
    person = find_parent(relation_dict, person)
    while person is not None :
    INDENT
        ancestor_list.append(person)
        person = find_parent(relation_dict, person)
    DEDENT
    return ", ".join(ancestor_list) if ancestor_list else "No known ancestors"
DEDENT
----------------------------------------

def process_ancestors(relation_dict, name) :
INDENT
    if not search_name(relation_dict, name) :
    INDENT
        return "Unknown person"
    DEDENT
    else :
    INDENT
        ancestor_list = list(ancestors(relation_dict, name))
        if not ancestor_list :
        INDENT
            return "Unknown parent"
        DEDENT
        else :
        INDENT
            return ", ".join(ancestor_list)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16712506_16713214_1_27
16712506_16723844_1_41
Title: De-uglify memcache boilerplate in Python 
----------------------------------------

def cached(func) :
INDENT
    def _cached(* args) :
    INDENT
        cacheable = settings.cache.lifetime is not None

        cache_key = '{0}-{1}-{2}'.format(func.__module__, func.__name__, args [0])

        if cacheable :
        INDENT
            result = memcache.get(cache_key)
            if result is not None :
            INDENT
                return result

            DEDENT
        DEDENT
        result = func(args [0])

        if cacheable and result is not None :
        INDENT
            memcache.set(cache_key, result, settings.cache.lifetime)
        DEDENT
        return result
    DEDENT
    return _cached
DEDENT
----------------------------------------

def cached(lifetime = settings.cache.default_lifetime, extra_key = None) :
INDENT
    def _cached(func) :
    INDENT
        @ functools.wraps(func)
        def wrapper(* args, ** kwargs) :
        INDENT
            resolved_lifetime = lifetime(* args) if hasattr(lifetime, '__call__') else lifetime
            if resolved_lifetime is not None :
            INDENT

                items = kwargs.items()
                items.sort()
                hashable_args = (args, tuple(items))
                args_key = hashlib.md5(pickle.dumps(hashable_args)).hexdigest()

                cache_key = '{0}-{1}-{2}-{3}'.format(
                    func.__module__,
                    func.__name__,
                    args_key,
                    extra_key() if hasattr(extra_key, '__call__') else extra_key)

                result = memcache.get(cache_key)
                if result is not None :
                INDENT
                    return result

                DEDENT
            DEDENT
            result = func(* args, ** kwargs)

            if resolved_lifetime is not None and result is not None :
            INDENT
                memcache.set(cache_key, result, resolved_lifetime)
            DEDENT
            return result
        DEDENT
        return wrapper
    DEDENT
    return _cached
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16712506_16713214_2_25
16712506_16723844_2_40
Title: De-uglify memcache boilerplate in Python 
----------------------------------------

def _cached(* args) :
INDENT
    cacheable = settings.cache.lifetime is not None

    cache_key = '{0}-{1}-{2}'.format(func.__module__, func.__name__, args [0])

    if cacheable :
    INDENT
        result = memcache.get(cache_key)
        if result is not None :
        INDENT
            return result

        DEDENT
    DEDENT
    result = func(args [0])

    if cacheable and result is not None :
    INDENT
        memcache.set(cache_key, result, settings.cache.lifetime)
    DEDENT
    return result
DEDENT
----------------------------------------

def _cached(func) :
INDENT
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        resolved_lifetime = lifetime(* args) if hasattr(lifetime, '__call__') else lifetime
        if resolved_lifetime is not None :
        INDENT

            items = kwargs.items()
            items.sort()
            hashable_args = (args, tuple(items))
            args_key = hashlib.md5(pickle.dumps(hashable_args)).hexdigest()

            cache_key = '{0}-{1}-{2}-{3}'.format(
                func.__module__,
                func.__name__,
                args_key,
                extra_key() if hasattr(extra_key, '__call__') else extra_key)

            result = memcache.get(cache_key)
            if result is not None :
            INDENT
                return result

            DEDENT
        DEDENT
        result = func(* args, ** kwargs)

        if resolved_lifetime is not None and result is not None :
        INDENT
            memcache.set(cache_key, result, resolved_lifetime)
        DEDENT
        return result
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16739373_16739502_1_21
16739373_16739618_1_16
Title: Printing the output of a Line search 
----------------------------------------

def main() :
INDENT
    import os
    filelist = list()
    filed = open('out.txt', 'w')
    searchfile = open("asdf.csv")
    for lines in searchfile :
    INDENT
        if "Sequence" in lines :
        INDENT
            print lines
            filelist.append(lines)
        DEDENT
    DEDENT
    TheString = " ".join(filelist)
    searchfile.close()
    filed.write(TheString)
    filed.close()
DEDENT
----------------------------------------

def main() :
INDENT
    seq = "Sequence"
    record = file("out.txt", "w")
    search = file("in.csv", "r")
    output = list()
    for line in search :
    INDENT
        if seq in line : output.append(line)
    DEDENT
    search.close()
    record.write(" ".join(output))
    record.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16755072_16755139_12_20
16755072_41161972_14_22
Title: Trouble passing inputs of User-Defined function to other functions and summing returned values 
----------------------------------------

def rental_car_cost(days) :
INDENT
    cost = 40
    if days > = 7 :
    INDENT
        return days * cost - 50
    DEDENT
    elif days > = 3 :
    INDENT
        return days * cost - 20
    DEDENT
    else :
    INDENT
        return days * cost
    DEDENT
DEDENT
----------------------------------------

def rental_car_cost(days) :
INDENT
    day = 40
    cost = days * day
    if days > = 7 :
    INDENT
        cost = cost - 50
    DEDENT
    elif days > = 3 :
    INDENT
        cost = cost - 20
    DEDENT
    return cost
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16764661_16768371_1_15
16764661_16768409_20_29
Title: Scraping within a url using scrapy 
----------------------------------------

def parse(self, response) :
INDENT
    hxs = HtmlXPathSelector(response)
    sites = hxs.select("//span[@class='pl']")
    for site in sites :
    INDENT
        item = CraigslistItem()
        item ['title'] = site.select('a/text()').extract()
        item ['link'] = site.select('a/@href').extract()
        if item ['link'] :
        INDENT
            if 'http://' not in item ['link'] :
            INDENT
                item ['link'] = urljoin(response.url, item ['link'])
            DEDENT
            yield Request(item ['link'],
                meta = {'item' : item},
                callback = self.anchor_page)

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def parse(self, response) :
INDENT
    hxs = HtmlXPathSelector(response)
    sites = hxs.select("//span[@class='pl']")
    items = []
    for site in sites :
    INDENT
        item = CraigslistItem()
        item ['title'] = site.select('.//a/text()').extract() [0]
        item ['link'] = site.select('.//a/@href').extract() [0]
        items.append(item)
    DEDENT
    return items
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16782666_16782756_14_29
16782666_16782756_73_83
Title: What is the proper way to delineate modules and classes in Python? 
----------------------------------------

def get(self) :
INDENT
    if id == 0 :
    INDENT
        raise self.ctx.ApplicationError(404, ("No note with id 0 exists"))
    DEDENT
    cursor = self.ctx.db.conn.cursor()
    cursor.execute("select note, date from %s.notes where id=%s" %
        (self.ctx.db.DB_NAME, str(self.id)))
    data = cursor.fetchone()
    if not data :
    INDENT
        raise self.ctx.ApplicationError(404, ("No note with id "
                + self.id + " was found"))
    DEDENT
    self.note = data [0]
    self.date = data [1]
    return self
DEDENT
----------------------------------------

def get(self, user, context) :
INDENT
    cursor = context.db.conn.cursor()
    cursor.execute("select id, note, date from %s.notes where owner=%s" %
        (context.db.DB_NAME, str(user ["id"])))
    note = cursor.fetchone()
    while note :
    INDENT
        self.collection.append(Note(note [0], note [1], note [2]))
        note = cursor.fetchone()
    DEDENT
    return self
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16796558_16799905_33_37
16796558_16799905_43_53
Title: "ndb models decorators nested functions" 
----------------------------------------

def check_requirements(self, * a, ** kw) :
INDENT
    if not self.auth.get_user_by_session() :
    INDENT
        self.redirect('/', abort = True)
    DEDENT
    else :
    INDENT
        return handler(self, * a, ** kw)
    DEDENT
DEDENT
----------------------------------------

def check_requirements(self, * a, ** kw) :
INDENT
    companies = ndb.get_multi(* a)

    if not self.user.key in reduce(lambda x, y : x if x ! = y else y, map(lambda c : c.administrator, companies)) :
    INDENT
        return self.jwrite(error = 'Permission denied. Administrator required.')
    DEDENT
    else :
    INDENT
        return handler(self, * a, ** kw)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16796558_16799905_33_37
16796558_16799905_58_66
Title: "ndb models decorators nested functions" 
----------------------------------------

def check_requirements(self, * a, ** kw) :
INDENT
    if not self.auth.get_user_by_session() :
    INDENT
        self.redirect('/', abort = True)
    DEDENT
    else :
    INDENT
        return handler(self, * a, ** kw)
    DEDENT
DEDENT
----------------------------------------

def check_requirements(self, * a, ** kw) :
INDENT
    companies = ndb.get_multi(* a)

    if not self.user.key in reduce(lambda x, y : x if x ! = y else y, map(lambda c : c.manager + c.administrator, companies)) :
    INDENT
        return self.jwrite(error = 'Permission denied. Manager or Administrator required.')
    DEDENT
    else :
    INDENT
        return handler(self, * a, ** kw)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16796558_16799905_43_53
16796558_16799905_58_66
Title: "ndb models decorators nested functions" 
----------------------------------------

def check_requirements(self, * a, ** kw) :
INDENT
    companies = ndb.get_multi(* a)

    if not self.user.key in reduce(lambda x, y : x if x ! = y else y, map(lambda c : c.administrator, companies)) :
    INDENT
        return self.jwrite(error = 'Permission denied. Administrator required.')
    DEDENT
    else :
    INDENT
        return handler(self, * a, ** kw)
    DEDENT
DEDENT
----------------------------------------

def check_requirements(self, * a, ** kw) :
INDENT
    companies = ndb.get_multi(* a)

    if not self.user.key in reduce(lambda x, y : x if x ! = y else y, map(lambda c : c.manager + c.administrator, companies)) :
    INDENT
        return self.jwrite(error = 'Permission denied. Manager or Administrator required.')
    DEDENT
    else :
    INDENT
        return handler(self, * a, ** kw)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16806200_16808434_5_21
16806200_16811914_4_18
Title: Tkinter - Text widget shrinks when Scrollbar is added 
----------------------------------------

def __init__(self, master) :
INDENT
    frame = Frame(master)
    Label(master).grid(row = 4)
    results_txtbx = Text(master)
    results_scrbr = Scrollbar(master)
    results_scrbr.grid(row = 3, column = 2)
    results_scrbr.config(command = results_txtbx.yview)

    results_txtbx.config(width = 20, height = 4,
        wrap = NONE, yscrollcommand = results_scrbr.set)
    results_txtbx.grid(row = 3, column = 1, padx = 4)

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    tk.Frame.__init__(self, master, borderwidth = 1, relief = "sunken")
    self.label = tk.Label(self)
    self.results_txtbx = tk.Text(self, width = 20, height = 4, wrap = "none",
        borderwidth = 0, highlightthickness = 0)
    self.results_scrbr = tk.Scrollbar(self, orient = "vertical",
        command = self.results_txtbx.yview)
    self.results_txtbx.configure(yscrollcommand = self.results_scrbr.set)
    self.label.grid(row = 1, columnspan = 2)
    self.results_scrbr.grid(row = 0, column = 1, sticky = "ns")
    self.results_txtbx.grid(row = 0, column = 0, sticky = "nsew")
    self.grid_rowconfigure(0, weight = 1)
    self.grid_columnconfigure(0, weight = 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16806200_16808434_5_21
16806200_16826804_5_53
Title: Tkinter - Text widget shrinks when Scrollbar is added 
----------------------------------------

def __init__(self, master) :
INDENT
    frame = Frame(master)
    Label(master).grid(row = 4)
    results_txtbx = Text(master)
    results_scrbr = Scrollbar(master)
    results_scrbr.grid(row = 3, column = 2)
    results_scrbr.config(command = results_txtbx.yview)

    results_txtbx.config(width = 20, height = 4,
        wrap = NONE, yscrollcommand = results_scrbr.set)
    results_txtbx.grid(row = 3, column = 1, padx = 4)

DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    tk.Frame.__init__(self, master)
    self.label = tk.Label(self)

    self.main_menu = tk.Menu(self)
    self.file_menu = tk.Menu(self.main_menu, tearoff = 0)
    self.file_menu.add_command(label = "Exit", command = self.quit)
    self.main_menu.add_cascade(label = "File", menu = self.file_menu)
    self.master.config(menu = self.main_menu)

    self.question_lbl = tk.Label(self, text = "Question #: ", padx = 12, pady = 6)
    self.question_lbl.grid(row = 0, sticky = "w")
    tk.Label(self, text = "Hint: ").grid(row = 1, sticky = "w", padx = 12, pady = 6)
    tk.Label(self, text = "Answer: ").grid(row = 2, sticky = "w", padx = 12, pady = 6)
    tk.Label(self, text = "Results: ").grid(row = 3, sticky = "nw", padx = 12, pady = 6)
    tk.Label(self).grid(row = 4)

    self.question_txtbx = tk.Entry(self)
    self.question_txtbx.config(width = 60)
    self.question_txtbx.grid(row = 0, column = 1, padx = 12, columnspan = 3, sticky = "w")
    self.help_txtbx = tk.Entry(self)
    self.help_txtbx.config(width = 40)
    self.help_txtbx.grid(row = 1, column = 1, columnspan = 2, padx = 12, sticky = "w")
    self.answer_txtbx = tk.Entry(self)
    self.answer_txtbx.config(width = 40)
    self.answer_txtbx.grid(row = 2, column = 1, columnspan = 2, padx = 12, sticky = "w")
    self.results_label = tk.Label(self)
    self.results_txtbx = tk.Text(self.results_label, width = 10, height = 4, wrap = "none", borderwidth = 1, highlightthickness = 1)
    self.results_scrbr = tk.Scrollbar(self.results_label, orient = "vertical", command = self.results_txtbx.yview)
    self.results_txtbx.configure(yscrollcommand = self.results_scrbr.set)
    self.label.grid(row = 1)
    self.results_label.grid(row = 3, column = 1, padx = 11, sticky = "w")
    self.results_scrbr.grid(row = 0, column = 1, sticky = "nse")
    self.results_txtbx.grid(row = 0, column = 0, sticky = "w")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16806200_16811914_4_18
16806200_16826804_5_53
Title: Tkinter - Text widget shrinks when Scrollbar is added 
----------------------------------------

def __init__(self, master) :
INDENT
    tk.Frame.__init__(self, master, borderwidth = 1, relief = "sunken")
    self.label = tk.Label(self)
    self.results_txtbx = tk.Text(self, width = 20, height = 4, wrap = "none",
        borderwidth = 0, highlightthickness = 0)
    self.results_scrbr = tk.Scrollbar(self, orient = "vertical",
        command = self.results_txtbx.yview)
    self.results_txtbx.configure(yscrollcommand = self.results_scrbr.set)
    self.label.grid(row = 1, columnspan = 2)
    self.results_scrbr.grid(row = 0, column = 1, sticky = "ns")
    self.results_txtbx.grid(row = 0, column = 0, sticky = "nsew")
    self.grid_rowconfigure(0, weight = 1)
    self.grid_columnconfigure(0, weight = 1)
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    tk.Frame.__init__(self, master)
    self.label = tk.Label(self)

    self.main_menu = tk.Menu(self)
    self.file_menu = tk.Menu(self.main_menu, tearoff = 0)
    self.file_menu.add_command(label = "Exit", command = self.quit)
    self.main_menu.add_cascade(label = "File", menu = self.file_menu)
    self.master.config(menu = self.main_menu)

    self.question_lbl = tk.Label(self, text = "Question #: ", padx = 12, pady = 6)
    self.question_lbl.grid(row = 0, sticky = "w")
    tk.Label(self, text = "Hint: ").grid(row = 1, sticky = "w", padx = 12, pady = 6)
    tk.Label(self, text = "Answer: ").grid(row = 2, sticky = "w", padx = 12, pady = 6)
    tk.Label(self, text = "Results: ").grid(row = 3, sticky = "nw", padx = 12, pady = 6)
    tk.Label(self).grid(row = 4)

    self.question_txtbx = tk.Entry(self)
    self.question_txtbx.config(width = 60)
    self.question_txtbx.grid(row = 0, column = 1, padx = 12, columnspan = 3, sticky = "w")
    self.help_txtbx = tk.Entry(self)
    self.help_txtbx.config(width = 40)
    self.help_txtbx.grid(row = 1, column = 1, columnspan = 2, padx = 12, sticky = "w")
    self.answer_txtbx = tk.Entry(self)
    self.answer_txtbx.config(width = 40)
    self.answer_txtbx.grid(row = 2, column = 1, columnspan = 2, padx = 12, sticky = "w")
    self.results_label = tk.Label(self)
    self.results_txtbx = tk.Text(self.results_label, width = 10, height = 4, wrap = "none", borderwidth = 1, highlightthickness = 1)
    self.results_scrbr = tk.Scrollbar(self.results_label, orient = "vertical", command = self.results_txtbx.yview)
    self.results_txtbx.configure(yscrollcommand = self.results_scrbr.set)
    self.label.grid(row = 1)
    self.results_label.grid(row = 3, column = 1, padx = 11, sticky = "w")
    self.results_scrbr.grid(row = 0, column = 1, sticky = "nse")
    self.results_txtbx.grid(row = 0, column = 0, sticky = "w")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16808076_16808522_11_27
16808076_16808524_11_16
Title: Binary Search Tree operations 
----------------------------------------

def AddNode(self, data, node = None) :
INDENT
    if not node :
    INDENT
        node = self.root
    DEDENT
    if self.root is None :
    INDENT
        self.root = TreeNode(data)
    DEDENT
    else :
    INDENT
        if data < node.data :
        INDENT
            if node.lLink is None :
            INDENT
                node.lLink = TreeNode(data)
            DEDENT
            else :
            INDENT
                self.AddNode(data, self.root.lLink)
            DEDENT
        DEDENT
        else :
        INDENT
            if node.rLink is None :
            INDENT
                node.rLink = TreeNode(data)
            DEDENT
            else :
            INDENT
                self.AddNode(data, self.root.rLink)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def AddNode(self, data) :
INDENT
    if self.root is None :
    INDENT
        self.root = TreeNode(data)
    DEDENT
    else :
    INDENT
        self.AddHelper(data, self.root)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1681269_12605800_1_11
1681269_7450757_1_22
Title: how code a function similar to itertools.product in python 2.5 
----------------------------------------

def product(* args, ** kwds) :
INDENT
    "Alternative fast implementation of product for python < 2.6"
    def cycle(values, uplevel) :
    INDENT
        for prefix in uplevel :
        INDENT
            for current in values :
            INDENT
                yield prefix + (current,)
            DEDENT
        DEDENT
    DEDENT
    stack = iter(((),))
    for level in tuple(map(tuple, args)) * kwds.get('repeat', 1) :
    INDENT
        stack = cycle(level, stack)
    DEDENT
    return stack
DEDENT
----------------------------------------

def product(* iterables) :
INDENT
    nIters = len(iterables)
    lstLenths = []
    lstRemaining = [1]
    for i in xrange(nIters - 1, - 1, - 1) :
    INDENT
        m = len(iterables [i])
        lstLenths.insert(0, m)
        lstRemaining.insert(0, m * lstRemaining [0])
    DEDENT
    nProducts = lstRemaining.pop(0)
    for p in xrange(nProducts) :
    INDENT
        lstVals = []
        for i in xrange(nIters) :
        INDENT
            j = p / lstRemaining [i] % lstLenths [i]
            lstVals.append(iterables [i] [j])
        DEDENT
        yield tuple(lstVals)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16826815_16840146_4_35
16826815_18198539_3_14
Title: Generating k numbers of hash value with python 
----------------------------------------

def getHash(key, hashseed, m, k) :
INDENT
    salt = str(hashseed)
    hashed_password = hashlib.sha256(key + salt).hexdigest()
    if k > 32 : raise Error("k should be less than 32")
    if k < = 1 : raise Error("k should be more than 2")
    result = []
    index = 0

    while True :
    INDENT
        value = int(hashed_password [index : index + 2], 16) % m
        index += 2

        while True :
        INDENT
            if value not in result :
            INDENT
                result.append(value)
                break
            DEDENT
            value = int(hashed_password [index : index + 2], 16) % m
            index += 2
        DEDENT
        if len(result) == k : break
    DEDENT
    return result
DEDENT
----------------------------------------

def getHash(key, m, k) :
INDENT
    result = set()
    seed = 1
    while True :
    INDENT
        if len(result) == k :
        INDENT
            return list(result)
        DEDENT
        else :
        INDENT
            b = mmh3.hash(key, seed) % m
            result.add(b)
            seed += 10
            print result
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16857883_16859944_11_17
16857883_16859944_34_45
Title: Need a thread-safe asynchronous message queue 
----------------------------------------

def run(self) :
INDENT
    while 1 :
    INDENT
        if some_condition :
        INDENT
            self.dispatch_message(some_message)
        DEDENT
        else :
        INDENT
            sleep(0.1)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    dispatcher_thread.register_interest(self)
    while 1 :
    INDENT

        message = self.queue.get()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16885748_16885830_3_20
16885748_16886458_1_16
Title: Python breaking and transposing a large list into smaller lists 
----------------------------------------

def transpose_into(data, sizes) :
INDENT
    parts = [([], size) for size in sizes]

    iterparts = itertools.cycle(parts)
    for value in data :
    INDENT
        for group, size in itertools.islice(iterparts, len(parts)) :
        INDENT
            if len(group) < size :
            INDENT
                group.append(value)
                break
            DEDENT
        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
    return [group for group, size in parts]
DEDENT
----------------------------------------

def transpose_into(x, splits) :
INDENT
    max_col = max(splits)
    res = [[None] * split for split in splits]
    col = 0
    xiter = iter(x)
    while True :
    INDENT
        for sub_list in res :
        INDENT
            try :
            INDENT
                sub_list [col]
                sub_list [col] = next(xiter)
            DEDENT
            except IndexError :
            INDENT
                continue
            DEDENT
        DEDENT
        col += 1
        if col > max_col :
        INDENT
            break
        DEDENT
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16892827_16893522_46_58
16892827_16895338_34_48
Title: How to tell python scrapy to move to the next start URL 
----------------------------------------

def parse_item(self, response) :
INDENT
    hxs = HtmlXPathSelector(response)
    items = []
    for mail in hxs.select('//body//text()').re(r'[\w.-]+@[\w.-]+') :
    INDENT
        item = MailItem()
        item ['url'] = response.url
        item ['mail'] = mail
        items.append(item)
    DEDENT
    hostname = urlparse(response.url).hostname
    self.parsed_hostnames.add(hostname)
    return items
DEDENT
----------------------------------------

def parse_item(self, response) :
INDENT
    hxs = HtmlXPathSelector(response)
    items = []
    mails = hxs.select('//body//text()').re(r'[\w.-]+@[\w.-]+')
    if mails :
    INDENT
        for mail in mails :
        INDENT
            item = MailItem()
            item ['url'] = response.url
            item ['mail'] = mail
            items.append(item)
            hostname = urlparse(response.url).hostname
            self.parsed_hostnames.add(hostname)
        DEDENT
    DEDENT
    return items
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16900589_16900786_11_32
16900589_16900967_11_37
Title: How to load a contact sheet of images with PySide? 
----------------------------------------

def initUI(self) :
INDENT
    hbox = QtGui.QHBoxLayout(self)

    img_fold = "C:/my_contacts"
    for img in os.listdir(img_fold) :
    INDENT
        img_path = os.path.join(img_fold, img)
        pixmap = QtGui.QPixmap(img_path)
        lbl = QtGui.QLabel(self)
        lbl.setPixmap(pixmap)
        hbox.addWidget(lbl)
    DEDENT
    self.setLayout(hbox)
    self.setGeometry(300, 300, 280, 170)
    self.setWindowTitle('Image viewer')
    self.show()
DEDENT
----------------------------------------

def initUI(self) :
INDENT
    self.img_fold = r"C:\Users\abhishek.garg\Desktop\New folder"
    self.widget_layout = QtGui.QVBoxLayout(self)
    self.scrollarea = QtGui.QScrollArea()
    self.scrollarea.setWidgetResizable(True)
    self.widget_layout.addWidget(self.scrollarea)
    self.widget = QtGui.QWidget()
    self.layout = QtGui.QVBoxLayout(self.widget)
    self.scrollarea.setWidget(self.widget)
    self.layout.setAlignment(QtCore.Qt.AlignHCenter)
    for img in os.listdir(self.img_fold) :
    INDENT
        img_path = os.path.join(self.img_fold, img)
        pixmap = QtGui.QPixmap(img_path)
        lbl = QtGui.QLabel(self)
        lbl.setPixmap(pixmap)
        self.layout.addWidget(lbl)

    DEDENT
    self.setGeometry(300, 300, 280, 170)
    self.setWindowTitle('Image viewer')
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16903416_21613435_9_16
16903416_32409674_4_16
Title: How To: Python Pandas get current stock data 
----------------------------------------

def get_quote_today(symbol) :
INDENT
    response = urllib2.urlopen(YAHOO_TODAY % symbol)
    reader = csv.reader(response, delimiter = ",", quotechar = '"')
    for row in reader :
    INDENT
        if row [0] == symbol :
        INDENT
            return row

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def get_quote_today(symbol) :
INDENT
    url = "http://download.finance.yahoo.com/d/quotes.csv?s=%s&f=d1t1ohgl1vl1"
    new_quote = pd.read_csv(url % symbol,
        names = [u'Date', u'time', u'Open', u'High', u'Low',
            u'Close', u'Volume', u'Adj Close'])

    stamp = pd.to_datetime(new_quote.Date + " " + new_quote.time)
    new_quote.index = stamp
    return new_quote.iloc [:, 2 :]

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16907151_16908280_23_44
16907151_16908280_46_56
Title: Gtk MessageDialog causes segfault (PYGObject) 
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Frame.__init__(self)
    self.connect("delete-event", Gtk.main_quit)
    self.set_shadow_type(Gtk.ShadowType.NONE)
    self.set_border_width(45)
    vbox = Gtk.VBox(spacing = 10)
    hbox = Gtk.HBox(spacing = 10)
    text = Gtk.Label()
    text.set_markup("<b><big>Doing stuff...</big></b>")
    self.spinner = Gtk.Spinner()
    self.spinner.set_size_request(30, 30)
    self.spinner.start()
    hbox.pack_start(text, True, True, 10)
    hbox.pack_start(self.spinner, True, True, 10)
    vbox.pack_start(hbox, True, True, 10)
    self.add(vbox)

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Frame.__init__(self)
    self.set_shadow_type(Gtk.ShadowType.NONE)
    self.set_border_width(150)
    label = Gtk.Label("Hello")
    box = Gtk.VBox()
    box.pack_start(label, True, True, 0)
    self.add(box)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16907186_17460964_8_15
16907186_17537814_102_111
Title: Python model inheritance and order of model declaration 
----------------------------------------

def __getitem__(self, key) :
INDENT
    class tmp(object) :
    INDENT
        pass
    DEDENT
    tmp.__name__ = key
    if (not key in self.keys()) :
    INDENT
        self.prognosis()
        print self.insanity()
    DEDENT
    return self.setdefault(key, tmp)
DEDENT
----------------------------------------

def __getitem__(self, key) :
INDENT
    if (not key in self.keys()) :
    INDENT
        if (hasattr(__builtins__, key)) :
        INDENT
            return getattr(__builtins__, key)
        DEDENT
        else :
        INDENT
            if (not key in self.keys()) :
            INDENT
                self.sanity_check()
            DEDENT
            return self.setdefault(key, rebase_meta(key, (object,), {}))
        DEDENT
    DEDENT
    else :
    INDENT
        return dict.__getitem__(self, key)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16912533_16912648_1_20
16912533_16912705_1_16
Title: How to repeat function in Python depending on output? 
----------------------------------------

def read_the_file(output) :
INDENT
    while True :
    INDENT
        print """
        Do you want me to read your newly created file?
        Type [Y]es or [N]o
            """
        question = raw_input("><![CDATA[ ")
        if question == 'yes' or question == 'Y' or question == 'y' :
        INDENT
            with open(output, 'r') as f :
            INDENT
                reading = f.read()
            DEDENT
            print "BEGINNING OF FILE\n\n" + reading + "\n END OF FILE"
            break
        DEDENT
        elif question == 'no' or question == 'N' or question == 'n' :
        INDENT
            sys.exit [1]
        DEDENT
        else :
        INDENT
            print "wrong input"
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def read_the_file(output) :
INDENT
    reading = open(output, "rb").read()
    while True :
    INDENT
        question = raw_input("Do you want me to read your newly created file?\
                        Type [Y]es or [N]o :")
        if question in ["Yes", "yes", "YES", "y", "Y"] :
        INDENT
            print "BEGINNING OF FILE\n\n" + reading + "\n END OF FILE"
            break
        DEDENT
        elif question in ["NO", "no", "n", "N"] :
        INDENT
            sys.exit [1]
        DEDENT
        else :
        INDENT
            print "wrong input"
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16915966_16979189_12_21
16915966_40946022_26_34
Title: Using matplotlib.animate to animate a contour plot in python 
----------------------------------------

def animate(i) :
INDENT
    z = var [i, :, 0, :].T
    cont = plt.contourf(x, y, z, 25)
    if (tslice == 0) :
    INDENT
        plt.title(r't = %1.2e' % t [i])
    DEDENT
    else :
    INDENT
        plt.title(r't = %i' % i)
    DEDENT
    return cont
DEDENT
----------------------------------------

def animate(i) :
INDENT
    global cont
    z = some_data(i)
    for c in cont.collections :
    INDENT
        c.remove()
    DEDENT
    cont = plt.contourf(x, y, z, cvals)
    plt.title('t = %i:  %.2f' % (i, z [5, 5]))
    return cont
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16923773_16923999_1_26
16923773_16925905_3_14
Title: Manhattan grid directions with random walk 
----------------------------------------

def manhattan(x, y) :
INDENT
    'int,int==>nonetype'
    import random
    res = []
    for i in range(x) :
    INDENT
        res.append([])
    DEDENT
    for i in res :
    INDENT
        for j in range(y) :
        INDENT
            i.append(0)
        DEDENT
    DEDENT
    position = (x / / 2 + 1, y / / 2 + 1)
    z = position [0]
    v = position [1]
    while z ! = - 1 and z ! = x and v ! = - 1 and v ! = y :
    INDENT
        res [z] [v] += 1
        direction = random.randrange(1, 5)
        if direction == 1 :
        INDENT
            v += 1
        DEDENT
        elif direction == 2 :
        INDENT
            z += 1
        DEDENT
        elif direction == 3 :
        INDENT
            v -= 1
        DEDENT
        else :
        INDENT
            z -= 1
        DEDENT
    DEDENT
    for i in res :
    INDENT
        print (i)
    DEDENT
DEDENT
----------------------------------------

def manhattan(n, m) :
INDENT
    grid = [[0,] * m for _ in xrange(n)]
    directions = [[- 1, 0], [1, 0], [0, - 1], [0, 1]]
    pt = [n / / 2, m / / 2]
    while pt [0] > = 0 and pt [0] < n and pt [1] > = 0 and pt [1] < m :
    INDENT
        grid [pt [0]] [pt [1]] += 1
        d = random.choice(directions)
        pt [0] += d [0]
        pt [1] += d [1]
    DEDENT
    return grid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16940971_16941218_1_10
16940971_16941247_1_10
Title: "def function : if nothing selected  return a list of all the objects" 
----------------------------------------

def correct_value(selection = None) :
INDENT
    if selection is None :
    INDENT

        objs = cmds.ls('*_control')
        return objs
    DEDENT
    if not isinstance(selection, list) :
    INDENT
        selection = [selection]
        objs = selection
        return objs
    DEDENT
DEDENT
----------------------------------------

def correct_value(* args) :
INDENT
    if not args :
    INDENT
        objs = cmds.ls('*_control')
        return objs
    DEDENT
    elif len(args) == 1 :
    INDENT
        selection = args
        objs = selection
        return objs
    DEDENT
    else :
    INDENT
        raise TypeError
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16952464_16952510_1_11
16952464_16952597_1_14
Title: While loops (Python) 
----------------------------------------

def num_rushes(slope_height, rush_height_gain, back_sliding) :
INDENT
    if rush_height_gain < slope_height and rush_height_gain - back_sliding < 1 :
    INDENT
        raise Exception("this is not going to work very well")
    DEDENT
    current_height = rushes = 0
    while current_height < slope_height :
    INDENT
        rushes += 1
        current_height += rush_height_gain
        if current_height > = slope_height :
        INDENT
            break
        DEDENT
        current_height -= back_sliding
    DEDENT
    return rushes
DEDENT
----------------------------------------

def num_rushes(slope_height, rush_height_gain, back_sliding) :
INDENT
    current_height = 0
    rushes = 0
    while current_height < slope_height :
    INDENT

        current_height += rush_height_gain
        rushes += 1
        if current_height < slope_height :
        INDENT
            current_height -= back_sliding
        DEDENT
    DEDENT
    return rushes
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1696305_1696320_21_41
1696305_1824915_8_16
Title: Python: stop execution after a maximum time 
----------------------------------------

def run(self) :
INDENT
    print time.time()
    while self.running :
    INDENT

        time.sleep(10)
        for pClass in self.processList :
        INDENT
            currentTime = time.time()
            if pClass.poll() == None :
            INDENT

                (time_, overall, timeout) = self.processList [pClass]
                overall = overall + (currentTime - time_)
                print "%f seconds passed from running of process %d" % (overall, pClass.pid)
                if overall > timeout :
                INDENT
                    pClass.kill()
                    del self.processList [pClass]
                DEDENT
                else :
                INDENT
                    self.processList [pClass] = (currentTime, overall, timeout)
                DEDENT
            DEDENT
            else :
            INDENT
                del self.processList [pClass]
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    self.event.wait(self.timeout)
    if not self.event.isSet() :
    INDENT
        try :
        INDENT
            os.kill(self.pid, signal.SIGKILL)
        DEDENT
        except OSError, e :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17000300_17001701_5_37
17000300_17002109_3_19
Title: Find monotonic sequences in a list? 
----------------------------------------

def process(lst) :
INDENT
    def sublist(deq) :
    INDENT
        sub = [deq.popleft()]
        while deq and deq [0] > = sub [- 1] :
        INDENT
            sub.append(deq.popleft())
        DEDENT
        return sub

    DEDENT
    deq = deque(lst)
    output = []
    ret = []
    while deq :
    INDENT
        ret.append(sublist(deq))
    DEDENT
    return ret
DEDENT
----------------------------------------

def process(lst) :
INDENT
    if len(lst) < 1 :
    INDENT
        return lst

    DEDENT
    state = type('State', (object,), dict(prev = lst [0], n = 0))
    def grouper(x) :
    INDENT
        if x < state.prev :
        INDENT
            state.n += 1
        DEDENT
        state.prev = x
        return state.n
    DEDENT
    return [list(g) for k, g in itertools.groupby(lst, grouper)]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17043317_17044655_10_17
17043317_17044655_24_32
Title: Make tkinter toplevel window that doesn't close with parent 
----------------------------------------

def __init__(self, master, sentinel, ** kwargs) :
INDENT
    title = kwargs.pop('title')
    self.sentinel = sentinel
    tk.Toplevel.__init__(self, master, ** kwargs)
    self.protocol("WM_DELETE_WINDOW", self.ondelete)
    self.label = tk.Label(self, text = title)
    self.label.pack(padx = 10, pady = 10)
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    self.master = master
    sentinel = Sentinel()
    parent = Window(master, sentinel, title = 'Parent')
    child = Window(master, sentinel, title = 'Child')
    self._ref = weakref.ref(sentinel, self.no_sentinel)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17044259_17044392_1_13
17044259_51903139_2_14
Title: python - how to check if table exists? 
----------------------------------------

def checkTableExists(dbcon, tablename) :
INDENT
    dbcur = dbcon.cursor()
    dbcur.execute("""
        SELECT COUNT(*)
        FROM information_schema.tables
        WHERE table_name = '{0}'
        """.format(tablename.replace('\'', '\'\'')))
    if dbcur.fetchone() [0] == 1 :
    INDENT
        dbcur.close()
        return True
    DEDENT
    dbcur.close()
    return False
DEDENT
----------------------------------------

def checkTableExists(dbcon, tablename) :
INDENT
    dbcur = dbcon.cursor()
    try :
    INDENT
        dbcur.execute("SELECT * FROM {}".format(tablename))
        return True
    DEDENT
    except cx_Oracle.DatabaseError as e :
    INDENT
        x = e.args [0]
        if x.code == 942 :
        INDENT
            return False
        DEDENT
        else :
        INDENT
            raise e
        DEDENT
    DEDENT
    finally :
    INDENT
        dbcur.close()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17048308_17048819_3_15
17048308_17053302_1_10
Title: How to dict folders? 
----------------------------------------

def f(folder) :
INDENT
    mape = {}
    sez = os.listdir(folder)
    for ts in sez :
    INDENT

        fullName = folder + '/' + ts
        if os.path.isfile(fullName) :
        INDENT
            size = os.path.getsize(fullName)
            mape [ts] = size
        DEDENT
        else :
        INDENT
            mape [ts] = f(fullName)
        DEDENT
    DEDENT
    return (mape)
DEDENT
----------------------------------------

def f(map, n = 0) :
INDENT
    dictionary = beforeF(map)
    for key in dictionary.keys() :
    INDENT
        fullName = map + '\\' + key
        if path.isdir(fullName) :
        INDENT
            print (n * '\t' + key + ':')
            f(fullName, n + 1)
        DEDENT
        else :
        INDENT
            print (n * '\t' + key + ' (' + str(dictionary [key]) + ')')
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17054397_17055699_9_17
17054397_17055865_10_18
Title: Broadcasting and receiving data with Python 
----------------------------------------

def run(self) :
INDENT
    for i in range(10) :
    INDENT
        print 'start thread'
        cs = socket(AF_INET, SOCK_DGRAM)
        cs.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        cs.setsockopt(SOL_SOCKET, SO_BROADCAST, 1)
        cs.sendto('This is a test', ('192.168.1.3', 4499))
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    print 'start thread'
    cs = socket(AF_INET, SOCK_DGRAM)
    cs.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
    cs.setsockopt(SOL_SOCKET, SO_BROADCAST, 1)
    time.sleep(0.1)
    cs.sendto('This is a test', ('192.168.65.255', port))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17062499_17062582_6_18
17062499_17062592_4_16
Title: Changing the order of creation of instances is changing their behaviour Python 
----------------------------------------

def __init__(self, array) :
INDENT
    self.ing = []
    self.rmax = []
    self.rmin = []
    self.lmax = []
    self.lmin = []
    self.answer = 0
    self.ing = list(array)
    self.rightmax()
    self.rightmin()
    self.leftmax()
    self.leftmin()
    self.calculate()
DEDENT
----------------------------------------

def __init__(self, array) :
INDENT
    self.ing = list(array)
    rmax = []
    rmin = []
    lmax = []
    lmin = []
    answer = 0
    self.rightmax()
    self.rightmin()
    self.leftmax()
    self.leftmin()
    self.calculate()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17065730_17065946_1_15
17065730_17066065_4_19
Title: Python: Using two while loops to create grid. No for loops 
----------------------------------------

def create_grid(grid) :
INDENT
    y = 0
    size = LENGTH * WIDTH
    table = ''
    while y < LENGTH :
    INDENT
        x = 0
        while x < size :
        INDENT
            if x :
            INDENT
                table += '|'
            DEDENT
            table += grid [y + x]
            x += LENGTH
        DEDENT
        table += '\n'
        y += 1
    DEDENT
    return table
DEDENT
----------------------------------------

def create_grid(grid) :
INDENT
    x = 0
    y = 0
    table = ""
    while y < LENGTH :
    INDENT
        while x < WIDTH :
        INDENT
            table += grid [WIDTH * x + y] + '|'
            x += 1
        DEDENT
        print "\n"
        y += 1
    DEDENT
    return table
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17088072_17088151_1_16
17088072_17088153_5_18
Title: Combine two python decorators into one 
----------------------------------------

def requireAuthentication(json = False) :
INDENT
    def decorator(fn) :
    INDENT
        def wrapper(** kwargs) :
        INDENT
            if "user" in request.session :
            INDENT
                return fn(** kwargs)

            DEDENT
            if json :
            INDENT
                return {
                    "exception" : "NotAuthorized",
                    "error" : "You are not authorized, please log on"}
            DEDENT
            redirect('/login?url={0}{1}'.format(request.path, ("?" + request.query_string if request.query_string else '')))
        DEDENT
        return wrapper
    DEDENT
    return decorator
DEDENT
----------------------------------------

def requireAuthentication(fn) :
INDENT
    @ functools.wraps(fn)
    def decorator(* args, ** kwargs) :
    INDENT
        if "user" in request.session :
        INDENT
            return fn(* args, ** kwargs)
        DEDENT
        if json :
        INDENT
            return {
                "exception" : "NotAuthorized",
                "error" : "You are not authorized, please log on"}
        DEDENT
        return redirect('/login?url={0}{1}'.format(request.path,
                ("?" + request.query_string if request.query_string else '')))
    DEDENT
    return decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17088072_17088151_2_15
17088072_17088153_7_17
Title: Combine two python decorators into one 
----------------------------------------

def decorator(fn) :
INDENT
    def wrapper(** kwargs) :
    INDENT
        if "user" in request.session :
        INDENT
            return fn(** kwargs)

        DEDENT
        if json :
        INDENT
            return {
                "exception" : "NotAuthorized",
                "error" : "You are not authorized, please log on"}
        DEDENT
        redirect('/login?url={0}{1}'.format(request.path, ("?" + request.query_string if request.query_string else '')))
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def decorator(* args, ** kwargs) :
INDENT
    if "user" in request.session :
    INDENT
        return fn(* args, ** kwargs)
    DEDENT
    if json :
    INDENT
        return {
            "exception" : "NotAuthorized",
            "error" : "You are not authorized, please log on"}
    DEDENT
    return redirect('/login?url={0}{1}'.format(request.path,
            ("?" + request.query_string if request.query_string else '')))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17088072_17088153_4_19
17088072_17088153_5_18
Title: Combine two python decorators into one 
----------------------------------------

def requireAuthentication(json = False) :
INDENT
    def requireAuthentication(fn) :
    INDENT
        @ functools.wraps(fn)
        def decorator(* args, ** kwargs) :
        INDENT
            if "user" in request.session :
            INDENT
                return fn(* args, ** kwargs)
            DEDENT
            if json :
            INDENT
                return {
                    "exception" : "NotAuthorized",
                    "error" : "You are not authorized, please log on"}
            DEDENT
            return redirect('/login?url={0}{1}'.format(request.path,
                    ("?" + request.query_string if request.query_string else '')))
        DEDENT
        return decorator
    DEDENT
    return requireAuthentication
DEDENT
----------------------------------------

def requireAuthentication(fn) :
INDENT
    @ functools.wraps(fn)
    def decorator(* args, ** kwargs) :
    INDENT
        if "user" in request.session :
        INDENT
            return fn(* args, ** kwargs)
        DEDENT
        if json :
        INDENT
            return {
                "exception" : "NotAuthorized",
                "error" : "You are not authorized, please log on"}
        DEDENT
        return redirect('/login?url={0}{1}'.format(request.path,
                ("?" + request.query_string if request.query_string else '')))
    DEDENT
    return decorator
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17092970_17094060_20_29
17092970_17142798_6_16
Title: How to link parent and children to each other? 
----------------------------------------

def set_parent(self, other) :
INDENT
    if self._parent is not None :
    INDENT
        if self._parent.has_child(self) :
        INDENT
            self._parent.remove_child(self)
        DEDENT
    DEDENT
    self._parent = other
    if isinstance(other, Node) :
    INDENT
        other.add_child(self)
    DEDENT
DEDENT
----------------------------------------

def set_parent(self, parent) :
INDENT
    if self._parent :
    INDENT
        self._parent._children.remove(self)
    DEDENT
    self._parent = parent
    if self._parent :
    INDENT
        self._parent._children.append(self)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17115722_17115987_3_15
17115722_17119890_4_11
Title: get deepest nested list 
----------------------------------------

def get_deepest(L) :
INDENT
    def get_dpst(L, maxdepth) :
    INDENT
        deepest_tup = (L, maxdepth)
        for e in L :
        INDENT
            is_list = any(isinstance(e, list) for e in L)
            if is_list :
            INDENT
                tup = get_dpst(e, maxdepth + 1)
                if tup [1] > deepest_tup [1] :
                INDENT
                    deepest_tup = tup
                DEDENT
            DEDENT
        DEDENT
        return deepest_tup
    DEDENT
    tup = get_dpst(L, 0)
    return tup [0]
DEDENT
----------------------------------------

def get_deepest(L, depth = 0) :
INDENT
    global max_depth, deepest_list
    if depth > max_depth :
    INDENT
        max_depth = depth
        deepest_list = L
    DEDENT
    for x in L :
    INDENT
        if isinstance(x, list) :
        INDENT
            get_deepest(x, depth + 1)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17119154_17119261_1_20
17119154_27633738_3_10
Title: Python decorator optional argument 
----------------------------------------

def logged(* setting_args, ** setting_kwargs) :
INDENT
    no_args = False
    if len(setting_args) == 1 and not setting_kwargs and callable(setting_args [0]) :
    INDENT

        func = setting_args [0]
        no_args = True
    DEDENT
    def outer(func) :
    INDENT
        @ wraps(func)
        def with_logging(* args, ** kwargs) :
        INDENT
            print "{} was called".format(func.__name__)
            print "Setting args are: {}".format(setting_args)
            print "Setting keyword args are: {}".format(setting_kwargs)
            return func(* args, ** kwargs)
        DEDENT
        return with_logging
    DEDENT
    if no_args :
    INDENT
        return outer(func)
    DEDENT
    else :
    INDENT
        return outer
    DEDENT
DEDENT
----------------------------------------

def logged(var = None) :
INDENT
    def outer(func) :
    INDENT
        @ wraps(func)
        def with_logging(* args, ** kwargs) :
        INDENT
            print func.__name__ + " was called"
            return func(* args, ** kwargs)
        DEDENT
        return with_logging
    DEDENT
    return outer
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17119154_28186967_43_48
17119154_28186967_54_59
Title: Python decorator optional argument 
----------------------------------------

def decorator(f) :
INDENT
    @ wraps(f)
    def wrapper(* args, ** kwargs) :
    INDENT
        return "".join([f.__name__, ' ', start_val,
                f(* args, ** kwargs), end_val])
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def decorator(f) :
INDENT
    @ wraps(f)
    def wrapper(* args, ** kwargs) :
    INDENT
        return "".join([f.__name__, ' ', start_val,
                f(* args, ** kwargs), end_val])
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17119154_28186967_43_48
17119154_28186967_6_37
Title: Python decorator optional argument 
----------------------------------------

def decorator(f) :
INDENT
    @ wraps(f)
    def wrapper(* args, ** kwargs) :
    INDENT
        return "".join([f.__name__, ' ', start_val,
                f(* args, ** kwargs), end_val])
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def decorator(f) :
INDENT
    args_names = inspect.getargspec(f) [0]
    def wrapper(* new_args, ** new_kwargs) :
    INDENT
        defaults = dict(defined_defaults, ** new_kwargs)
        if len(new_args) == 0 :
        INDENT
            return f(** defaults)
        DEDENT
        elif len(new_args) == 1 and callable(new_args [0]) :
        INDENT
            return f(** defaults)(new_args [0])
        DEDENT
        else :
        INDENT
            too_many_args = False
            if len(new_args) > len(args_names) :
            INDENT
                too_many_args = True
            DEDENT
            else :
            INDENT
                for i in range(len(new_args)) :
                INDENT
                    arg = new_args [i]
                    arg_name = args_names [i]
                    defaults [arg_name] = arg
                DEDENT
            DEDENT
            if len(defaults) > len(args_names) :
            INDENT
                too_many_args = True
            DEDENT
            if not too_many_args :
            INDENT
                final_defaults = []
                for name in args_names :
                INDENT
                    final_defaults.append(defaults [name])
                DEDENT
                return f(* final_defaults)
            DEDENT
            if too_many_args :
            INDENT
                raise TypeError("{0}() takes {1} argument(s) "
                    "but {2} were given".
                    format(f.__name__,
                        len(args_names),
                        len(defaults)))
            DEDENT
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17119154_28186967_54_59
17119154_28186967_6_37
Title: Python decorator optional argument 
----------------------------------------

def decorator(f) :
INDENT
    @ wraps(f)
    def wrapper(* args, ** kwargs) :
    INDENT
        return "".join([f.__name__, ' ', start_val,
                f(* args, ** kwargs), end_val])
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def decorator(f) :
INDENT
    args_names = inspect.getargspec(f) [0]
    def wrapper(* new_args, ** new_kwargs) :
    INDENT
        defaults = dict(defined_defaults, ** new_kwargs)
        if len(new_args) == 0 :
        INDENT
            return f(** defaults)
        DEDENT
        elif len(new_args) == 1 and callable(new_args [0]) :
        INDENT
            return f(** defaults)(new_args [0])
        DEDENT
        else :
        INDENT
            too_many_args = False
            if len(new_args) > len(args_names) :
            INDENT
                too_many_args = True
            DEDENT
            else :
            INDENT
                for i in range(len(new_args)) :
                INDENT
                    arg = new_args [i]
                    arg_name = args_names [i]
                    defaults [arg_name] = arg
                DEDENT
            DEDENT
            if len(defaults) > len(args_names) :
            INDENT
                too_many_args = True
            DEDENT
            if not too_many_args :
            INDENT
                final_defaults = []
                for name in args_names :
                INDENT
                    final_defaults.append(defaults [name])
                DEDENT
                return f(* final_defaults)
            DEDENT
            if too_many_args :
            INDENT
                raise TypeError("{0}() takes {1} argument(s) "
                    "but {2} were given".
                    format(f.__name__,
                        len(args_names),
                        len(defaults)))
            DEDENT
        DEDENT
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_20_31
17139451_17139639_39_57
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    ResultsPanelTitle = 'Results:'
    self.ResultsTitle = wx.StaticText(self, id = - 1, label = ResultsPanelTitle)
    self.Results = wx.TextCtrl(self, id = - 1, size = (300, 500), style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.ResultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.Results, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    titleText = 'Wx Question'
    wx.Frame.__init__(self, None, title = titleText, size = (600, 300), style = wx.DEFAULT_FRAME_STYLE)
    frame_panel = wx.Panel(self)
    RightPanel = resultsPanel(frame_panel)
    LeftPanel = chkbxPanel(frame_panel, RightPanel)
    RightPanel.CheckedBxs = LeftPanel.ChkBx.GetCheckedStrings()
    RightPanel.CheckedBxs = ('one', 'two')
    panelCtrls_horzSizer = wx.BoxSizer(wx.HORIZONTAL)
    panelCtrls_horzSizer.Add(LeftPanel)
    panelCtrls_horzSizer.Add(RightPanel)
    framePanel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    framePanel_vertSizer.Add(panelCtrls_horzSizer)
    frame_panel.SetSizer(framePanel_vertSizer)
    frame_panel.Fit()
    self.SetSize((600, 600))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_20_31
17139451_17139639_4_18
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    ResultsPanelTitle = 'Results:'
    self.ResultsTitle = wx.StaticText(self, id = - 1, label = ResultsPanelTitle)
    self.Results = wx.TextCtrl(self, id = - 1, size = (300, 500), style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.ResultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.Results, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()

DEDENT
----------------------------------------

def __init__(self, parent, resultsPanel) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    List = ['one', 'two', 'three']
    Prompt = 'Please Make a Choice'
    self.ChkBx = wx.CheckListBox(self, id = - 1, choices = List, size = (- 1, 200))
    self.ChkBx.Bind(wx.EVT_CHECKLISTBOX, lambda e : resultsPanel.changed(self.ChkBx.GetCheckedStrings()))
    self.PromptChkBx = wx.StaticText(self, id = - 1, label = Prompt)
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.ChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_20_31
17139451_17147520_17_40
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    ResultsPanelTitle = 'Results:'
    self.ResultsTitle = wx.StaticText(self, id = - 1, label = ResultsPanelTitle)
    self.Results = wx.TextCtrl(self, id = - 1, size = (300, 500), style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.ResultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.Results, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    choices = ['one', 'two', 'three']
    prompt = 'Please Make a Choice'
    self.chkBx = wx.CheckListBox(self, choices = choices, size = (- 1, 200))
    self.PromptChkBx = wx.StaticText(self, label = prompt)

    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0,
        flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.chkBx, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_20_31
17139451_17147520_44_75
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    ResultsPanelTitle = 'Results:'
    self.ResultsTitle = wx.StaticText(self, id = - 1, label = ResultsPanelTitle)
    self.Results = wx.TextCtrl(self, id = - 1, size = (300, 500), style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.ResultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.Results, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    resultsPanelTitle = 'Results:'
    self.resultsTitle = wx.StaticText(self, label = resultsPanelTitle)
    self.results = wx.TextCtrl(self, size = (300, 500),
        style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.CheckedBxs = ()
    lenofcb = len(self.CheckedBxs)
    typeofcb = type(self.CheckedBxs)
    self.results.AppendText('How Many Boxes are Checkd:\n')
    self.results.AppendText(str(lenofcb) + '\n')
    self.results.AppendText(str(typeofcb) + '\n')
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.resultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.results, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_20_31
17139451_17147520_78_105
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    ResultsPanelTitle = 'Results:'
    self.ResultsTitle = wx.StaticText(self, id = - 1, label = ResultsPanelTitle)
    self.Results = wx.TextCtrl(self, id = - 1, size = (300, 500), style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.ResultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.Results, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    titleText = 'Wx Question'
    wx.Frame.__init__(self, None, title = titleText, size = (600, 300), style = wx.DEFAULT_FRAME_STYLE)

    frame_panel = wx.Panel(self)

    leftPanel = ChkbxPanel(frame_panel)
    self.rightPanel = ResultsPanel(frame_panel)

    panelCtrls_horzSizer = wx.BoxSizer(wx.HORIZONTAL)
    panelCtrls_horzSizer.Add(leftPanel)
    panelCtrls_horzSizer.Add(self.rightPanel)
    framePanel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    framePanel_vertSizer.Add(panelCtrls_horzSizer)
    frame_panel.SetSizer(framePanel_vertSizer)
    frame_panel.Fit()
    self.SetSize((600, 600))
    leftPanel.chkBx.Bind(wx.EVT_CHECKLISTBOX, self.onCheckBox)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_39_57
17139451_17139639_4_18
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self) :
INDENT
    titleText = 'Wx Question'
    wx.Frame.__init__(self, None, title = titleText, size = (600, 300), style = wx.DEFAULT_FRAME_STYLE)
    frame_panel = wx.Panel(self)
    RightPanel = resultsPanel(frame_panel)
    LeftPanel = chkbxPanel(frame_panel, RightPanel)
    RightPanel.CheckedBxs = LeftPanel.ChkBx.GetCheckedStrings()
    RightPanel.CheckedBxs = ('one', 'two')
    panelCtrls_horzSizer = wx.BoxSizer(wx.HORIZONTAL)
    panelCtrls_horzSizer.Add(LeftPanel)
    panelCtrls_horzSizer.Add(RightPanel)
    framePanel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    framePanel_vertSizer.Add(panelCtrls_horzSizer)
    frame_panel.SetSizer(framePanel_vertSizer)
    frame_panel.Fit()
    self.SetSize((600, 600))
DEDENT
----------------------------------------

def __init__(self, parent, resultsPanel) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    List = ['one', 'two', 'three']
    Prompt = 'Please Make a Choice'
    self.ChkBx = wx.CheckListBox(self, id = - 1, choices = List, size = (- 1, 200))
    self.ChkBx.Bind(wx.EVT_CHECKLISTBOX, lambda e : resultsPanel.changed(self.ChkBx.GetCheckedStrings()))
    self.PromptChkBx = wx.StaticText(self, id = - 1, label = Prompt)
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.ChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_39_57
17139451_17147520_17_40
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self) :
INDENT
    titleText = 'Wx Question'
    wx.Frame.__init__(self, None, title = titleText, size = (600, 300), style = wx.DEFAULT_FRAME_STYLE)
    frame_panel = wx.Panel(self)
    RightPanel = resultsPanel(frame_panel)
    LeftPanel = chkbxPanel(frame_panel, RightPanel)
    RightPanel.CheckedBxs = LeftPanel.ChkBx.GetCheckedStrings()
    RightPanel.CheckedBxs = ('one', 'two')
    panelCtrls_horzSizer = wx.BoxSizer(wx.HORIZONTAL)
    panelCtrls_horzSizer.Add(LeftPanel)
    panelCtrls_horzSizer.Add(RightPanel)
    framePanel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    framePanel_vertSizer.Add(panelCtrls_horzSizer)
    frame_panel.SetSizer(framePanel_vertSizer)
    frame_panel.Fit()
    self.SetSize((600, 600))
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    choices = ['one', 'two', 'three']
    prompt = 'Please Make a Choice'
    self.chkBx = wx.CheckListBox(self, choices = choices, size = (- 1, 200))
    self.PromptChkBx = wx.StaticText(self, label = prompt)

    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0,
        flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.chkBx, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_39_57
17139451_17147520_44_75
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self) :
INDENT
    titleText = 'Wx Question'
    wx.Frame.__init__(self, None, title = titleText, size = (600, 300), style = wx.DEFAULT_FRAME_STYLE)
    frame_panel = wx.Panel(self)
    RightPanel = resultsPanel(frame_panel)
    LeftPanel = chkbxPanel(frame_panel, RightPanel)
    RightPanel.CheckedBxs = LeftPanel.ChkBx.GetCheckedStrings()
    RightPanel.CheckedBxs = ('one', 'two')
    panelCtrls_horzSizer = wx.BoxSizer(wx.HORIZONTAL)
    panelCtrls_horzSizer.Add(LeftPanel)
    panelCtrls_horzSizer.Add(RightPanel)
    framePanel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    framePanel_vertSizer.Add(panelCtrls_horzSizer)
    frame_panel.SetSizer(framePanel_vertSizer)
    frame_panel.Fit()
    self.SetSize((600, 600))
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    resultsPanelTitle = 'Results:'
    self.resultsTitle = wx.StaticText(self, label = resultsPanelTitle)
    self.results = wx.TextCtrl(self, size = (300, 500),
        style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.CheckedBxs = ()
    lenofcb = len(self.CheckedBxs)
    typeofcb = type(self.CheckedBxs)
    self.results.AppendText('How Many Boxes are Checkd:\n')
    self.results.AppendText(str(lenofcb) + '\n')
    self.results.AppendText(str(typeofcb) + '\n')
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.resultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.results, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_4_18
17139451_17147520_17_40
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent, resultsPanel) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    List = ['one', 'two', 'three']
    Prompt = 'Please Make a Choice'
    self.ChkBx = wx.CheckListBox(self, id = - 1, choices = List, size = (- 1, 200))
    self.ChkBx.Bind(wx.EVT_CHECKLISTBOX, lambda e : resultsPanel.changed(self.ChkBx.GetCheckedStrings()))
    self.PromptChkBx = wx.StaticText(self, id = - 1, label = Prompt)
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.ChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    choices = ['one', 'two', 'three']
    prompt = 'Please Make a Choice'
    self.chkBx = wx.CheckListBox(self, choices = choices, size = (- 1, 200))
    self.PromptChkBx = wx.StaticText(self, label = prompt)

    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0,
        flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.chkBx, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_4_18
17139451_17147520_44_75
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent, resultsPanel) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    List = ['one', 'two', 'three']
    Prompt = 'Please Make a Choice'
    self.ChkBx = wx.CheckListBox(self, id = - 1, choices = List, size = (- 1, 200))
    self.ChkBx.Bind(wx.EVT_CHECKLISTBOX, lambda e : resultsPanel.changed(self.ChkBx.GetCheckedStrings()))
    self.PromptChkBx = wx.StaticText(self, id = - 1, label = Prompt)
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.ChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    resultsPanelTitle = 'Results:'
    self.resultsTitle = wx.StaticText(self, label = resultsPanelTitle)
    self.results = wx.TextCtrl(self, size = (300, 500),
        style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.CheckedBxs = ()
    lenofcb = len(self.CheckedBxs)
    typeofcb = type(self.CheckedBxs)
    self.results.AppendText('How Many Boxes are Checkd:\n')
    self.results.AppendText(str(lenofcb) + '\n')
    self.results.AppendText(str(typeofcb) + '\n')
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.resultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.results, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17139639_4_18
17139451_17147520_78_105
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent, resultsPanel) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    List = ['one', 'two', 'three']
    Prompt = 'Please Make a Choice'
    self.ChkBx = wx.CheckListBox(self, id = - 1, choices = List, size = (- 1, 200))
    self.ChkBx.Bind(wx.EVT_CHECKLISTBOX, lambda e : resultsPanel.changed(self.ChkBx.GetCheckedStrings()))
    self.PromptChkBx = wx.StaticText(self, id = - 1, label = Prompt)
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.ChkBx, proportion = 0, flag = wx.ALIGN_LEFT)
    self.SetSizer(self.panel_vertSizer)
    self.Fit()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    titleText = 'Wx Question'
    wx.Frame.__init__(self, None, title = titleText, size = (600, 300), style = wx.DEFAULT_FRAME_STYLE)

    frame_panel = wx.Panel(self)

    leftPanel = ChkbxPanel(frame_panel)
    self.rightPanel = ResultsPanel(frame_panel)

    panelCtrls_horzSizer = wx.BoxSizer(wx.HORIZONTAL)
    panelCtrls_horzSizer.Add(leftPanel)
    panelCtrls_horzSizer.Add(self.rightPanel)
    framePanel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    framePanel_vertSizer.Add(panelCtrls_horzSizer)
    frame_panel.SetSizer(framePanel_vertSizer)
    frame_panel.Fit()
    self.SetSize((600, 600))
    leftPanel.chkBx.Bind(wx.EVT_CHECKLISTBOX, self.onCheckBox)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17147520_17_40
17139451_17147520_44_75
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    choices = ['one', 'two', 'three']
    prompt = 'Please Make a Choice'
    self.chkBx = wx.CheckListBox(self, choices = choices, size = (- 1, 200))
    self.PromptChkBx = wx.StaticText(self, label = prompt)

    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0,
        flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.chkBx, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    resultsPanelTitle = 'Results:'
    self.resultsTitle = wx.StaticText(self, label = resultsPanelTitle)
    self.results = wx.TextCtrl(self, size = (300, 500),
        style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.CheckedBxs = ()
    lenofcb = len(self.CheckedBxs)
    typeofcb = type(self.CheckedBxs)
    self.results.AppendText('How Many Boxes are Checkd:\n')
    self.results.AppendText(str(lenofcb) + '\n')
    self.results.AppendText(str(typeofcb) + '\n')
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.resultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.results, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17147520_17_40
17139451_17147520_78_105
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    choices = ['one', 'two', 'three']
    prompt = 'Please Make a Choice'
    self.chkBx = wx.CheckListBox(self, choices = choices, size = (- 1, 200))
    self.PromptChkBx = wx.StaticText(self, label = prompt)

    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.PromptChkBx, proportion = 0,
        flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.chkBx, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    titleText = 'Wx Question'
    wx.Frame.__init__(self, None, title = titleText, size = (600, 300), style = wx.DEFAULT_FRAME_STYLE)

    frame_panel = wx.Panel(self)

    leftPanel = ChkbxPanel(frame_panel)
    self.rightPanel = ResultsPanel(frame_panel)

    panelCtrls_horzSizer = wx.BoxSizer(wx.HORIZONTAL)
    panelCtrls_horzSizer.Add(leftPanel)
    panelCtrls_horzSizer.Add(self.rightPanel)
    framePanel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    framePanel_vertSizer.Add(panelCtrls_horzSizer)
    frame_panel.SetSizer(framePanel_vertSizer)
    frame_panel.Fit()
    self.SetSize((600, 600))
    leftPanel.chkBx.Bind(wx.EVT_CHECKLISTBOX, self.onCheckBox)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17139451_17147520_44_75
17139451_17147520_78_105
Title: Passing a tuple between two Panels in wxPython 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent, id = - 1)
    resultsPanelTitle = 'Results:'
    self.resultsTitle = wx.StaticText(self, label = resultsPanelTitle)
    self.results = wx.TextCtrl(self, size = (300, 500),
        style = (wx.TE_MULTILINE | wx.TE_READONLY | wx.TE_DONTWRAP))
    self.CheckedBxs = ()
    lenofcb = len(self.CheckedBxs)
    typeofcb = type(self.CheckedBxs)
    self.results.AppendText('How Many Boxes are Checkd:\n')
    self.results.AppendText(str(lenofcb) + '\n')
    self.results.AppendText(str(typeofcb) + '\n')
    self.panel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    self.panel_vertSizer.Add(self.resultsTitle, proportion = 0, flag = wx.ALIGN_LEFT)
    self.panel_vertSizer.Add(self.results, proportion = 0, flag = wx.ALIGN_LEFT)

    self.SetSizer(self.panel_vertSizer)

    self.Fit()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    titleText = 'Wx Question'
    wx.Frame.__init__(self, None, title = titleText, size = (600, 300), style = wx.DEFAULT_FRAME_STYLE)

    frame_panel = wx.Panel(self)

    leftPanel = ChkbxPanel(frame_panel)
    self.rightPanel = ResultsPanel(frame_panel)

    panelCtrls_horzSizer = wx.BoxSizer(wx.HORIZONTAL)
    panelCtrls_horzSizer.Add(leftPanel)
    panelCtrls_horzSizer.Add(self.rightPanel)
    framePanel_vertSizer = wx.BoxSizer(wx.VERTICAL)
    framePanel_vertSizer.Add(panelCtrls_horzSizer)
    frame_panel.SetSizer(framePanel_vertSizer)
    frame_panel.Fit()
    self.SetSize((600, 600))
    leftPanel.chkBx.Bind(wx.EVT_CHECKLISTBOX, self.onCheckBox)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17140339_17142608_18_23
17140339_17142608_6_12
Title: gevent using Queue get and socket recv at the same time 
----------------------------------------

def _run(self) :
INDENT
    self.running = True
    while self.running :
    INDENT
        msg = self.sock.recv(128)
        print 'socket:', msg
    DEDENT
DEDENT
----------------------------------------

def _run(self) :
INDENT
    self.running = True
    while self.running :
    INDENT
        msg = self.queue.get()
        print 'queue:', msg
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17140850_17141282_33_39
17140850_17141441_1_20
Title: How to parse a string and return a nested array? 
----------------------------------------

def foo(s) :
INDENT
    valiad = check(s)
    if valiad :
    INDENT
        return valiad
    DEDENT
    cs = list(s)
    return _foo(cs)
DEDENT
----------------------------------------

def foo(s) :
INDENT
    def foo_helper(level = 0) :
    INDENT
        try :
        INDENT
            token = next(tokens)
        DEDENT
        except StopIteration :
        INDENT
            if level ! = 0 :
            INDENT
                raise Exception('missing closing paren')
            DEDENT
            else :
            INDENT
                return []
            DEDENT
        DEDENT
        if token == ')' :
        INDENT
            if level == 0 :
            INDENT
                raise Exception('missing opening paren')
            DEDENT
            else :
            INDENT
                return []
            DEDENT
        DEDENT
        elif token == '(' :
        INDENT
            return [foo_helper(level + 1)] + foo_helper(level)
        DEDENT
        else :
        INDENT
            return [token] + foo_helper(level)
        DEDENT
    DEDENT
    tokens = iter(s)
    return foo_helper()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17140850_17141282_33_39
17140850_17141498_3_28
Title: How to parse a string and return a nested array? 
----------------------------------------

def foo(s) :
INDENT
    valiad = check(s)
    if valiad :
    INDENT
        return valiad
    DEDENT
    cs = list(s)
    return _foo(cs)
DEDENT
----------------------------------------

def foo(x) :
INDENT
    matches = re.findall('[a-z]{2,}', x)
    for m in matches :
    INDENT

        x = x.replace(m, '","'.join(y for y in list(m)))

    DEDENT
    x = x.replace(')', '"],"')
    x = x.replace('(', '",["')

    x = '["' + x + '"]'

    x = x.replace('"",', '')
    x = x.replace(',""', '')
    try :
    INDENT
        return json.loads(x)
    DEDENT
    except :
    INDENT
        return "error"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17140850_17141282_33_39
17140850_17141899_1_18
Title: How to parse a string and return a nested array? 
----------------------------------------

def foo(s) :
INDENT
    valiad = check(s)
    if valiad :
    INDENT
        return valiad
    DEDENT
    cs = list(s)
    return _foo(cs)
DEDENT
----------------------------------------

def foo(xs) :
INDENT
    stack = [[]]
    for x in xs :
    INDENT
        if x == '(' :
        INDENT
            stack [- 1].append([])
            stack.append(stack [- 1] [- 1])
        DEDENT
        elif x == ')' :
        INDENT
            stack.pop()
            if not stack :
            INDENT
                return 'error: opening bracket is missing'
            DEDENT
        DEDENT
        else :
        INDENT
            stack [- 1].append(x)
        DEDENT
    DEDENT
    if len(stack) > 1 :
    INDENT
        return 'error: closing bracket is missing'
    DEDENT
    return stack.pop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17140850_17141441_1_20
17140850_17141498_3_28
Title: How to parse a string and return a nested array? 
----------------------------------------

def foo(s) :
INDENT
    def foo_helper(level = 0) :
    INDENT
        try :
        INDENT
            token = next(tokens)
        DEDENT
        except StopIteration :
        INDENT
            if level ! = 0 :
            INDENT
                raise Exception('missing closing paren')
            DEDENT
            else :
            INDENT
                return []
            DEDENT
        DEDENT
        if token == ')' :
        INDENT
            if level == 0 :
            INDENT
                raise Exception('missing opening paren')
            DEDENT
            else :
            INDENT
                return []
            DEDENT
        DEDENT
        elif token == '(' :
        INDENT
            return [foo_helper(level + 1)] + foo_helper(level)
        DEDENT
        else :
        INDENT
            return [token] + foo_helper(level)
        DEDENT
    DEDENT
    tokens = iter(s)
    return foo_helper()
DEDENT
----------------------------------------

def foo(x) :
INDENT
    matches = re.findall('[a-z]{2,}', x)
    for m in matches :
    INDENT

        x = x.replace(m, '","'.join(y for y in list(m)))

    DEDENT
    x = x.replace(')', '"],"')
    x = x.replace('(', '",["')

    x = '["' + x + '"]'

    x = x.replace('"",', '')
    x = x.replace(',""', '')
    try :
    INDENT
        return json.loads(x)
    DEDENT
    except :
    INDENT
        return "error"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17140850_17141441_1_20
17140850_17141899_1_18
Title: How to parse a string and return a nested array? 
----------------------------------------

def foo(s) :
INDENT
    def foo_helper(level = 0) :
    INDENT
        try :
        INDENT
            token = next(tokens)
        DEDENT
        except StopIteration :
        INDENT
            if level ! = 0 :
            INDENT
                raise Exception('missing closing paren')
            DEDENT
            else :
            INDENT
                return []
            DEDENT
        DEDENT
        if token == ')' :
        INDENT
            if level == 0 :
            INDENT
                raise Exception('missing opening paren')
            DEDENT
            else :
            INDENT
                return []
            DEDENT
        DEDENT
        elif token == '(' :
        INDENT
            return [foo_helper(level + 1)] + foo_helper(level)
        DEDENT
        else :
        INDENT
            return [token] + foo_helper(level)
        DEDENT
    DEDENT
    tokens = iter(s)
    return foo_helper()
DEDENT
----------------------------------------

def foo(xs) :
INDENT
    stack = [[]]
    for x in xs :
    INDENT
        if x == '(' :
        INDENT
            stack [- 1].append([])
            stack.append(stack [- 1] [- 1])
        DEDENT
        elif x == ')' :
        INDENT
            stack.pop()
            if not stack :
            INDENT
                return 'error: opening bracket is missing'
            DEDENT
        DEDENT
        else :
        INDENT
            stack [- 1].append(x)
        DEDENT
    DEDENT
    if len(stack) > 1 :
    INDENT
        return 'error: closing bracket is missing'
    DEDENT
    return stack.pop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17140850_17141498_3_28
17140850_17141899_1_18
Title: How to parse a string and return a nested array? 
----------------------------------------

def foo(x) :
INDENT
    matches = re.findall('[a-z]{2,}', x)
    for m in matches :
    INDENT

        x = x.replace(m, '","'.join(y for y in list(m)))

    DEDENT
    x = x.replace(')', '"],"')
    x = x.replace('(', '",["')

    x = '["' + x + '"]'

    x = x.replace('"",', '')
    x = x.replace(',""', '')
    try :
    INDENT
        return json.loads(x)
    DEDENT
    except :
    INDENT
        return "error"
    DEDENT
DEDENT
----------------------------------------

def foo(xs) :
INDENT
    stack = [[]]
    for x in xs :
    INDENT
        if x == '(' :
        INDENT
            stack [- 1].append([])
            stack.append(stack [- 1] [- 1])
        DEDENT
        elif x == ')' :
        INDENT
            stack.pop()
            if not stack :
            INDENT
                return 'error: opening bracket is missing'
            DEDENT
        DEDENT
        else :
        INDENT
            stack [- 1].append(x)
        DEDENT
    DEDENT
    if len(stack) > 1 :
    INDENT
        return 'error: closing bracket is missing'
    DEDENT
    return stack.pop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17146625_17163661_18_34
17146625_17163661_37_44
Title: I thought that everything in matplotlib is a QWidget. Apparently Figure is not. My interface accepts QWidgets. What to do? 
----------------------------------------

def __init__(self, parent = None, width = 5, height = 4, dpi = 100) :
INDENT
    fig = Figure(figsize = (width, height), dpi = dpi)
    self.axes = fig.add_subplot(111)

    self.axes.hold(False)
    self.compute_initial_figure()
    FigureCanvas.__init__(self, fig)
    self.setParent(parent)
    FigureCanvas.setSizePolicy(self,
        QtGui.QSizePolicy.Expanding,
        QtGui.QSizePolicy.Expanding)
    FigureCanvas.updateGeometry(self)

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    MplCanvas.__init__(self, * args, ** kwargs)
    timer = QtCore.QTimer(self)
    QtCore.QObject.connect(timer,
        QtCore.SIGNAL("timeout()"),
        self.update_figure)
    timer.start(1000)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17167283_17169369_26_34
17167283_17169369_48_59
Title: Tkinter threading 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.queue = Queue.Queue()
    self.gui = GuiPart(master, self.queue)
    self.running = True
    self.thread = threading.Thread(target = self.workerThread1)
    self.thread.start()
    self.periodicCall()
DEDENT
----------------------------------------

def __init__(self, master = None, completetext = "") :
INDENT
    tk.Toplevel.__init__(self, master)
    self.geometry("400x300+400+250")
    self.title("RSAM BCT")
    tk.Label(self, text = "REDCOME SLICE", fg = "red").pack()
    tk.Label(self, text = "BCT - Basic Configuration Test", fg = "red").pack()
    tk.Label(self, text = completetext, fg = "dark green").pack()
    tk.Label(self, text = "Trunk 1: Port 1: Phone 1: 760-450-4500", fg = "black").pack()
    tk.Label(self, text = "Trunk 1: Port 2: Phone 2: 760-450-4501", fg = "black").pack()
    tk.Button(self, text = "    Exit    ", command = self.destroy).pack()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17167283_17169369_26_34
17167283_17169369_7_16
Title: Tkinter threading 
----------------------------------------

def __init__(self, master) :
INDENT
    self.master = master
    self.queue = Queue.Queue()
    self.gui = GuiPart(master, self.queue)
    self.running = True
    self.thread = threading.Thread(target = self.workerThread1)
    self.thread.start()
    self.periodicCall()
DEDENT
----------------------------------------

def __init__(self, master, queue) :
INDENT
    self.queue = queue
    self.master = master
    self.master.geometry("300x100+400+250")
    self.master.title("RSAM BCT")
    tk.Label(master, text = "REDCOM SLICE", fg = "red").pack()
    tk.Label(master, text = "BCT - Basic Configuration Test", fg = "red").pack()
    tk.Label(master, text = "Please wait...", fg = "black").pack()
    tk.Label(master, text = "Estimated time: 3 min 6 sec", fg = "black").pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17167283_17169369_48_59
17167283_17169369_7_16
Title: Tkinter threading 
----------------------------------------

def __init__(self, master = None, completetext = "") :
INDENT
    tk.Toplevel.__init__(self, master)
    self.geometry("400x300+400+250")
    self.title("RSAM BCT")
    tk.Label(self, text = "REDCOME SLICE", fg = "red").pack()
    tk.Label(self, text = "BCT - Basic Configuration Test", fg = "red").pack()
    tk.Label(self, text = completetext, fg = "dark green").pack()
    tk.Label(self, text = "Trunk 1: Port 1: Phone 1: 760-450-4500", fg = "black").pack()
    tk.Label(self, text = "Trunk 1: Port 2: Phone 2: 760-450-4501", fg = "black").pack()
    tk.Button(self, text = "    Exit    ", command = self.destroy).pack()

DEDENT
----------------------------------------

def __init__(self, master, queue) :
INDENT
    self.queue = queue
    self.master = master
    self.master.geometry("300x100+400+250")
    self.master.title("RSAM BCT")
    tk.Label(master, text = "REDCOM SLICE", fg = "red").pack()
    tk.Label(master, text = "BCT - Basic Configuration Test", fg = "red").pack()
    tk.Label(master, text = "Please wait...", fg = "black").pack()
    tk.Label(master, text = "Estimated time: 3 min 6 sec", fg = "black").pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17174891_17175979_4_25
17174891_17176578_1_27
Title: How can I generate all possible strings given a grammar rule? 
----------------------------------------

def generate_strings(rule) :
INDENT
    if not rule :
    INDENT
        return [""]
    DEDENT
    begin, end = rule [0], rule [1 :]
    if begin == '[' :
    INDENT
        i = end.find(']')
        if i == - 1 :
        INDENT
            raise Exception("Unmatched '['")
        DEDENT
        alt = flatten([generate_strings(a) for a in [end [0 : i], ""]])
        end = end [i + 1 :]
        return [a + e for e in generate_strings(end) for a in alt]
    DEDENT
    if begin == '(' :
    INDENT
        i = end.find(')')
        if i == - 1 :
        INDENT
            raise Exception("Unmatched '('")
        DEDENT
        alt = flatten([generate_strings(a) for a in end [0 : i].split('|')])
        end = end [i + 1 :]
        return [a + e for e in generate_strings(end) for a in alt]
    DEDENT
    if begin in [']', ')', '|'] :
    INDENT
        raise Exception("Unexpected " + begin)
    DEDENT
    return [begin + e for e in generate_strings(end)]
DEDENT
----------------------------------------

def generate_strings(rule) :
INDENT
    if not rule :
    INDENT
        yield ""
    DEDENT
    else :
    INDENT
        begin, end = rule [0], rule [1 :]
        if begin == '[' :
        INDENT
            i = end.find(']')
            if i == - 1 :
            INDENT
                raise ValueError("Unmatched '['")
            DEDENT
            optional, end = end [: i], end [i + 1 :]
            for e in generate_strings(end) :
            INDENT
                yield e
                yield optional + e
            DEDENT
        DEDENT
        elif begin == '(' :
        INDENT
            i = end.find(')')
            if i == - 1 :
            INDENT
                raise ValueError("Unmatched '('")
            DEDENT
            parts, end = end [: i].split('|'), end [i + 1 :]
            for e in generate_strings(end) :
            INDENT
                for p in parts :
                INDENT
                    yield p + e
                DEDENT
            DEDENT
        DEDENT
        elif begin in '])|' :
        INDENT
            raise ValueError("Unexpected " + begin)
        DEDENT
        else :
        INDENT
            for e in generate_strings(end) :
            INDENT
                yield begin + e
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17182690_17182719_1_12
17182690_17182854_3_19
Title: For loop that prints every line to a file. Error 
----------------------------------------

def write_file(filename, rabbitlist, foxlist, finallist, averagefox, averagerabbit) :
INDENT
    outfile = open(str(filename) + ".csv", 'w')

    finalresult = "\n".join(", ".join(map(str, l)) for l in finallist)
    outfile.write(str("Day, Foxes, Rabbits, , Average Foxes, Average Rabbits\n"))
    lastline = [0, foxlist [0], rabbitlist [0], " ", averagefox, averagerabbit]
    for item in lastline :
    INDENT
        outfile.write(" %s" % item)
    DEDENT
    outfile.close()
DEDENT
----------------------------------------

def write_file(filename,
rabbitlist,
foxlist,
finallist,
averagefox,
averagerabbit) :
INDENT
    header_row = ['Day', 'Foxes', 'Rabbits', ' ', 'Average Foxes', 'Average Rabbits']
    with open(filename, 'w') as f :
    INDENT
        writer = csv.writer(f, delimiter = ',')
        writer.writerow(header_row)
        writer.writerows(finallist)
        writer.writerow([0,
                foxlist [0],
                rabbitlist [0],
                " ",
                averagefox,
                averagerabbit])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17191316_17191594_1_17
17191316_17191754_12_19
Title: multiple python decorators 
----------------------------------------

def decorator2(method_to_decorate) :
INDENT
    @ wraps(method_to_decorate)
    def wrapper2(self, request, * args, ** kwargs) :
    INDENT
        result = method_to_decorate(self, request, * args, ** kwargs)
        if isinstance(result, tuple) and result and result [0] == 'failure' :
        INDENT
            return result
        DEDENT
        else :
        INDENT
            if decorator2_s_test_was_successful :
            INDENT
                return result
            DEDENT
            else :
            INDENT
                return ('another failure', 'message')
            DEDENT
        DEDENT
    DEDENT
    return wrapper2
DEDENT
----------------------------------------

def decorator2(f) :
INDENT
    @ wraps(f)
    def wrapper(a) :
    INDENT
        if a > = 2 :
        INDENT
            return f(a)
        DEDENT
        return 'failed in decorator 2'
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1719262_1719271_1_15
1719262_1719660_1_10
Title: Jython exception handling within loops 
----------------------------------------

def wait_p_long(times, compID_name, ppty_name, ppty_value, compID_cell = None) :
INDENT
    from marathon.playback import *
    """
    Wrapper around wait_p which takes exactly the same parameters as wait_p,
    except that an extra first parameter is used to specify the number of times
    wait_p is called.
    """
    for i in range(times) :
    INDENT
        try :
        INDENT
            wait_p(compID_name, ppty_name, ppty_value, compID_cell)
        DEDENT
        except :
        INDENT
            if i == times - 1 :
            INDENT
                raise
            DEDENT
            else :
            INDENT
                print "wait_p failed, trying again"
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def wait_p_long(times, compID_name, ppty_name, ppty_value, compID_cell = None) :
INDENT
    from marathon.playback import *
    for i in range(times - 1) :
    INDENT
        try :
        INDENT
            wait_p(compID_name, ppty_name, ppty_value, compID_cell)
            break
        DEDENT
        except :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            wait_p(compID_name, ppty_name, ppty_value, compID_cell)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17225920_17248940_11_21
17225920_17271593_7_18
Title: Python: Tkinter Treeview Searchable 
----------------------------------------

def search(self, item = '') :
INDENT
    children = self.tree.get_children(item)
    for child in children :
    INDENT
        text = self.tree.item(child, 'text')
        if text.startswith(self.entry.get()) :
        INDENT
            self.tree.selection_set(child)
            return True
        DEDENT
        else :
        INDENT
            res = self.search(child)
            if res :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def search(self, pattern, item = '') :
INDENT
    children = self.get_children(item)
    for child in children :
    INDENT
        text = self.item(child, 'text')
        if text.lower().startswith(pattern.lower()) :
        INDENT
            self.selection_set(child)
            self.see(child)
            return True
        DEDENT
        else :
        INDENT
            res = self.search(pattern, child)
            if res :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17254840_17255869_11_17
17254840_50610515_15_21
Title: Unable to create models on Flask-admin 
----------------------------------------

def __init__(self, title, body, createdate, updatedate, status, user_id) :
INDENT
    self.title = title
    self.body = body
    self.create_date = create_date
    self.update_date = update_date
    self.status = status
    self.user_id = user_id
DEDENT
----------------------------------------

def __init__(self, article_title = "", posted_time = None, updated_time = None, image = "", article_body = "", slug = "") :
INDENT
    self.slug = slugify(article_title)
    self.article_title = article_title
    self.posted_time = posted_time
    self.updated_time = updated_time
    self.image = image
    self.article_body = article_body
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17263170_17263336_3_10
17263170_17263343_4_12
Title: Cannot plot anything or display pylab frame in new process using python multiprocessing 
----------------------------------------

def test() :
INDENT
    import matplotlib.pyplot as plt
    frac = [10, 10, 10, 10, 10, 10, 40]
    labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
    plt.pie(frac, labels = labels, autopct = '%1.1f%%')
    plt.title('test', bbox = {'facecolor' : '0.8', 'pad' : 5})
    plt.show()
DEDENT
----------------------------------------

def test() :
INDENT
    frac = [10, 10, 10, 10, 10, 10, 40]
    labels = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
    ion()
    hold(False)
    pie(frac, labels = labels, autopct = '%1.1f%%')
    title('test', bbox = {'facecolor' : '0.8', 'pad' : 5})
    draw()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17263894_17278048_10_37
17263894_17278048_111_135
Title: wxpython wx.TextCtr not sizing while using wx.TE_MULTILINE 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    distros = ['None', 'Option 1', 'Option 2', 'Option 3', 'Option 4']
    cb = wx.ComboBox(self, pos = (35, 40), choices = distros,
        style = wx.CB_READONLY)
    cb.Bind(wx.EVT_COMBOBOX, self.OnSelect)
    self.txtfilein1 = wx.TextCtrl(self, - 1, pos = (35, 112), size = (300, 165), style = wx.TE_MULTILINE)
    self.pathoutdir = wx.TextCtrl(self, - 1, pos = (35, 320), size = (300, 25))
    self.buttonout = wx.Button(self, - 1, "Open", pos = (350, 318))
    self.buttonout.Bind(wx.EVT_BUTTON, self.openoutdir)
    self.buttonGo = wx.Button(self, - 1, "Go", pos = (120, 370))
    self.buttonGo.Bind(wx.EVT_BUTTON, self.go)
    self.buttonClose = wx.Button(self, - 1, "Quit", pos = (235, 370))
    self.buttonClose.Bind(wx.EVT_BUTTON, self.OnClose)
    provider = '''Provider'''
    inputtxt = '''Enter text'''
    outputtxt = '''Output Directory'''
    wx.StaticText(self, - 1, provider, (33, 22), style = wx.ALIGN_CENTRE)
    wx.StaticText(self, - 1, inputtxt, (33, 90), style = wx.ALIGN_CENTRE)
    wx.StaticText(self, - 1, outputtxt, (33, 300), style = wx.ALIGN_CENTRE)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Panel 1", size = (550, 650))
    self.panel_one = PanelOne(self)
    self.panel_two = PanelTwo(self)
    self.panel_two.Hide()
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.sizer.Add(self.panel_two, 1, wx.EXPAND)
    self.SetSizer(self.sizer)
    self.myStatusBar = self.CreateStatusBar()
    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    fileMenu.Append(99, "&Panel 1", "Panel 1")
    fileMenu.Append(100, "&Panel 2", "Panel 2")
    self.Bind(wx.EVT_MENU, self.onSwitchPanels1, id = 99)
    self.Bind(wx.EVT_MENU, self.onSwitchPanels2, id = 100)
    menubar.Append(fileMenu, '&File')
    self.SetMenuBar(menubar)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17263894_17278048_10_37
17263894_17278048_64_82
Title: wxpython wx.TextCtr not sizing while using wx.TE_MULTILINE 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    distros = ['None', 'Option 1', 'Option 2', 'Option 3', 'Option 4']
    cb = wx.ComboBox(self, pos = (35, 40), choices = distros,
        style = wx.CB_READONLY)
    cb.Bind(wx.EVT_COMBOBOX, self.OnSelect)
    self.txtfilein1 = wx.TextCtrl(self, - 1, pos = (35, 112), size = (300, 165), style = wx.TE_MULTILINE)
    self.pathoutdir = wx.TextCtrl(self, - 1, pos = (35, 320), size = (300, 25))
    self.buttonout = wx.Button(self, - 1, "Open", pos = (350, 318))
    self.buttonout.Bind(wx.EVT_BUTTON, self.openoutdir)
    self.buttonGo = wx.Button(self, - 1, "Go", pos = (120, 370))
    self.buttonGo.Bind(wx.EVT_BUTTON, self.go)
    self.buttonClose = wx.Button(self, - 1, "Quit", pos = (235, 370))
    self.buttonClose.Bind(wx.EVT_BUTTON, self.OnClose)
    provider = '''Provider'''
    inputtxt = '''Enter text'''
    outputtxt = '''Output Directory'''
    wx.StaticText(self, - 1, provider, (33, 22), style = wx.ALIGN_CENTRE)
    wx.StaticText(self, - 1, inputtxt, (33, 90), style = wx.ALIGN_CENTRE)
    wx.StaticText(self, - 1, outputtxt, (33, 300), style = wx.ALIGN_CENTRE)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.frame = parent
    distros = ['None', 'Option 1', 'Option 2', 'Option 3', 'Option 4']
    cb = wx.ComboBox(self, pos = (35, 40), choices = distros,
        style = wx.CB_READONLY)
    cb.Bind(wx.EVT_COMBOBOX, self.OnSelect)
    self.txtfilein = wx.TextCtrl(self, - 1, pos = (35, 114), size = (300, 25))
    self.buttonfilein = wx.Button(self, - 1, " Open File ", pos = (350, 111))
    self.buttonfilein.Bind(wx.EVT_BUTTON, self.openfile)
    self.pathindir = wx.TextCtrl(self, - 1, pos = (35, 174), size = (300, 25))
    self.buttonin = wx.Button(self, - 1, "Open Directory", pos = (350, 170))
    self.buttonin.Bind(wx.EVT_BUTTON, self.openindir)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17263894_17278048_111_135
17263894_17278048_64_82
Title: wxpython wx.TextCtr not sizing while using wx.TE_MULTILINE 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Panel 1", size = (550, 650))
    self.panel_one = PanelOne(self)
    self.panel_two = PanelTwo(self)
    self.panel_two.Hide()
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.panel_one, 1, wx.EXPAND)
    self.sizer.Add(self.panel_two, 1, wx.EXPAND)
    self.SetSizer(self.sizer)
    self.myStatusBar = self.CreateStatusBar()
    menubar = wx.MenuBar()
    fileMenu = wx.Menu()
    fileMenu.Append(99, "&Panel 1", "Panel 1")
    fileMenu.Append(100, "&Panel 2", "Panel 2")
    self.Bind(wx.EVT_MENU, self.onSwitchPanels1, id = 99)
    self.Bind(wx.EVT_MENU, self.onSwitchPanels2, id = 100)
    menubar.Append(fileMenu, '&File')
    self.SetMenuBar(menubar)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.frame = parent
    distros = ['None', 'Option 1', 'Option 2', 'Option 3', 'Option 4']
    cb = wx.ComboBox(self, pos = (35, 40), choices = distros,
        style = wx.CB_READONLY)
    cb.Bind(wx.EVT_COMBOBOX, self.OnSelect)
    self.txtfilein = wx.TextCtrl(self, - 1, pos = (35, 114), size = (300, 25))
    self.buttonfilein = wx.Button(self, - 1, " Open File ", pos = (350, 111))
    self.buttonfilein.Bind(wx.EVT_BUTTON, self.openfile)
    self.pathindir = wx.TextCtrl(self, - 1, pos = (35, 174), size = (300, 25))
    self.buttonin = wx.Button(self, - 1, "Open Directory", pos = (350, 170))
    self.buttonin.Bind(wx.EVT_BUTTON, self.openindir)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17267790_17267988_18_22
17267790_44702445_9_18
Title: "In Python how can I call copy.deepcopy in my implementation of __deepcopy__()?" 
----------------------------------------

def __deepcopy__(self, memo) :
INDENT
    new_kwargs = dict((k, getattr(self, attr, None)) for attr in self.dont_deepcopy)
    for attr in self.deepcopy_attributes :
    INDENT
        new_kwargs [attr] = copy.deepcopy(getattr(self, attr, None))
    DEDENT
    return self.__class__(** new_kwargs)
DEDENT
----------------------------------------

def __deepcopy__(self, memo) :
INDENT
    for attr in self.dont_deepcopy() :
    INDENT
        val = getattr(self, attr, None)
        if val is not None :
        INDENT
            memo [id(val)] = val
        DEDENT
    DEDENT
    deepcopy_method = self.__deepcopy__
    self.__deepcopy__ = None
    result = copy.deepcopy(self, memo)
    self.__deepcopy__ = deepcopy_method
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17299364_30839396_1_111
17299364_31903105_1_58
Title: Insert row into Excel spreadsheet using openpyxl in Python 
----------------------------------------

def insert_rows(self, row_idx, cnt, above = False, copy_style = True, fill_formulae = True) :
INDENT
    CELL_RE = re.compile("(?P<col>\$?[A-Z]+)(?P<row>\$?\d+)")
    row_idx = row_idx - 1 if above else row_idx
    def replace(m) :
    INDENT
        row = m.group('row')
        prefix = "$" if row.find("$") ! = - 1 else ""
        row = int(row.replace("$", ""))
        row += cnt if row > row_idx else 0
        return m.group('col') + prefix + str(row)

    DEDENT
    old_cells = set()
    old_fas = set()
    new_cells = dict()
    new_fas = dict()
    for c in self._cells.values() :
    INDENT

        old_coor = c.coordinate

        if c.data_type == Cell.TYPE_FORMULA :
        INDENT
            c.value = CELL_RE.sub(
                replace,
                c.value)
            if old_coor in self.formula_attributes and 'ref' in self.formula_attributes [old_coor] :
            INDENT
                self.formula_attributes [old_coor] ['ref'] = CELL_RE.sub(
                    replace,
                    self.formula_attributes [old_coor] ['ref'])

            DEDENT
        DEDENT
        if c.row > row_idx :
        INDENT
            old_coor = c.coordinate
            old_cells.add((c.row, c.col_idx))
            c.row += cnt
            new_cells [(c.row, c.col_idx)] = c
            if old_coor in self.formula_attributes :
            INDENT
                old_fas.add(old_coor)
                fa = self.formula_attributes [old_coor].copy()
                new_fas [c.coordinate] = fa
            DEDENT
        DEDENT
    DEDENT
    for coor in old_cells :
    INDENT
        del self._cells [coor]
    DEDENT
    self._cells.update(new_cells)
    for fa in old_fas :
    INDENT
        del self.formula_attributes [fa]
    DEDENT
    self.formula_attributes.update(new_fas)

    for row in range(len(self.row_dimensions) - 1 + cnt, row_idx + cnt, - 1) :
    INDENT
        new_rd = copy.copy(self.row_dimensions [row - cnt])
        new_rd.index = row
        self.row_dimensions [row] = new_rd
        del self.row_dimensions [row - cnt]

    DEDENT
    row_idx += 1
    for row in range(row_idx, row_idx + cnt) :
    INDENT

        new_rd = copy.copy(self.row_dimensions [row - 1])
        new_rd.index = row
        self.row_dimensions [row] = new_rd
        for col in range(1, self.max_column) :
        INDENT
            col = get_column_letter(col)
            cell = self.cell('%s%d' % (col, row))
            cell.value = None
            source = self.cell('%s%d' % (col, row - 1))
            if copy_style :
            INDENT
                cell.number_format = source.number_format
                cell.font = source.font.copy()
                cell.alignment = source.alignment.copy()
                cell.border = source.border.copy()
                cell.fill = source.fill.copy()
            DEDENT
            if fill_formulae and source.data_type == Cell.TYPE_FORMULA :
            INDENT
                s_coor = source.coordinate
                if s_coor in self.formula_attributes and 'ref' not in self.formula_attributes [s_coor] :
                INDENT
                    fa = self.formula_attributes [s_coor].copy()
                    self.formula_attributes [cell.coordinate] = fa
                DEDENT
                cell.value = re.sub(
                    "(\$?[A-Z]{1,3}\$?)%d" % (row - 1),
                    lambda m : m.group(1) + str(row),
                    source.value)
                cell.data_type = Cell.TYPE_FORMULA

            DEDENT
        DEDENT
    DEDENT
    for cr_idx, cr in enumerate(self.merged_cell_ranges) :
    INDENT
        self.merged_cell_ranges [cr_idx] = CELL_RE.sub(
            replace,
            cr)
    DEDENT
DEDENT
----------------------------------------

def insert_rows(self, row_idx, cnt, above = False, copy_style = True, fill_formulae = True) :
INDENT
    skip_list = []
    try :
    INDENT
        idx = row_idx - 1 if above else row_idx
        for (new, old) in zip(range(self.max_row + cnt, idx + cnt, - 1), range(self.max_row, idx, - 1)) :
        INDENT
            for c_idx in range(1, self.max_column) :
            INDENT
                col = self.cell(row = 1, column = c_idx).column
                print ("Copying %s%d to %s%d." % (col, old, col, new))
                source = self ["%s%d" % (col, old)]
                target = self ["%s%d" % (col, new)]
                if source.coordinate in skip_list :
                INDENT
                    continue
                DEDENT
                if source.coordinate in self.merged_cells :
                INDENT
                    for _range in self.merged_cell_ranges :
                    INDENT
                        merged_cells_list = [x for x in cells_from_range(_range)] [0]
                        if source.coordinate in merged_cells_list :
                        INDENT
                            skip_list = merged_cells_list
                            self.unmerge_cells(_range)
                            new_range = re.sub(str(old), str(new), _range)
                            self.merge_cells(new_range)
                            break
                        DEDENT
                    DEDENT
                DEDENT
                if source.data_type == Cell.TYPE_FORMULA :
                INDENT
                    target.value = re.sub(
                        "(\$?[A-Z]{1,3})%d" % (old),
                        lambda m : m.group(1) + str(new),
                        source.value)
                DEDENT
                else :
                INDENT
                    target.value = source.value
                DEDENT
                target.number_format = source.number_format
                target.font = source.font.copy()
                target.alignment = source.alignment.copy()
                target.border = source.border.copy()
                target.fill = source.fill.copy()
            DEDENT
        DEDENT
        idx = idx + 1
        for row in range(idx, idx + cnt) :
        INDENT
            for c_idx in range(1, self.max_column) :
            INDENT
                col = self.cell(row = 1, column = c_idx).column
                cell = self ["%s%d" % (col, row)]
                cell.value = None
                source = self ["%s%d" % (col, row - 1)]
                if copy_style :
                INDENT
                    cell.number_format = source.number_format
                    cell.font = source.font.copy()
                    cell.alignment = source.alignment.copy()
                    cell.border = source.border.copy()
                    cell.fill = source.fill.copy()
                DEDENT
                if fill_formulae and source.data_type == Cell.TYPE_FORMULA :
                INDENT

                    cell.value = re.sub(
                        "(\$?[A-Z]{1,3})%d" % (row - 1),
                        lambda m : m.group(1) + str(row),
                        source.value)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1730600_2629704_114_128
1730600_2629704_66_77
Title: Principal component analysis in Python 
----------------------------------------

def __init__(self, A, axis = 0, scale = True, verbose = 1) :
INDENT
    self.mean = A.mean(axis = axis)
    if verbose :
    INDENT
        print "Center -= A.mean:", self.mean
    DEDENT
    A -= self.mean
    if scale :
    INDENT
        std = A.std(axis = axis)
        self.std = np.where(std, std, 1.)
        if verbose :
        INDENT
            print "Center /= A.std:", self.std
        DEDENT
        A /= self.std
    DEDENT
    else :
    INDENT
        self.std = np.ones(A.shape [- 1])
    DEDENT
    self.A = A
DEDENT
----------------------------------------

def __init__(self, A, fraction = 0.90) :
INDENT
    assert 0 < = fraction < = 1
    self.U, self.d, self.Vt = np.linalg.svd(A, full_matrices = False)
    assert np.all(self.d [: - 1] > = self.d [1 :])
    self.eigen = self.d ** 2
    self.sumvariance = np.cumsum(self.eigen)
    self.sumvariance /= self.sumvariance [- 1]
    self.npc = np.searchsorted(self.sumvariance, fraction) + 1
    self.dinv = np.array([1 / d if d > self.d [0] * 1e-6 else 0 for d in self.d])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17330139_40389411_1_20
17330139_51786707_1_19
Title: Python - Printing a dictionary as a horizontal table with headers 
----------------------------------------

def printTable(myDict, colList = None, sep = '\uFFFA') :
INDENT
    if not colList : colList = list(myDict [0].keys() if myDict else [])
    myList = [colList]
    for item in myDict : myList.append([str(item [col] or '') for col in colList])
    colSize = [max(map(len, (sep.join(col)).split(sep))) for col in zip(* myList)]
    formatStr = ' | '.join(["{{:<{}}}".format(i) for i in colSize])
    line = formatStr.replace(' | ', '-+-').format(* ['-' * i for i in colSize])
    item = myList.pop(0); lineDone = False
    while myList :
    INDENT
        if all(not i for i in item) :
        INDENT
            item = myList.pop(0)
            if line and (sep ! = '\uFFFA' or not lineDone) : print (line); lineDone = True
        DEDENT
        row = [i.split(sep, 1) for i in item]
        print (formatStr.format(* [i [0] for i in row]))
        item = [i [1] if len(i) > 1 else '' for i in row]
    DEDENT
DEDENT
----------------------------------------

def printTable(myDict, colList = None) :
INDENT
    if not colList :
    INDENT
        colList = list(myDict [0].keys() if myDict else [])
    DEDENT
    myList = [colList]
    for item in myDict :
    INDENT
        myList.append([str(item [col] or '') for col in colList])
    DEDENT
    colSize = [max(map(len, col)) for col in zip(* myList)]
    for i in range(0, len(myList) + 1) [: : - 1] :
    INDENT
        myList.insert(i, ['-' * i for i in colSize])
    DEDENT
    formatStr = ' | '.join(["{{:<{}}}".format(i) for i in colSize])
    formatSep = '-+-'.join(["{{:<{}}}".format(i) for i in colSize])
    for item in myList :
    INDENT
        if item [0] [0] == '-' :
        INDENT
            print (formatSep.format(* item))
        DEDENT
        else :
        INDENT
            print (formatStr.format(* item))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17335973_17336065_2_10
17335973_17336523_1_10
Title: Review: Built-In Functions 
----------------------------------------

def distance_from_zero(n) :
INDENT
    try :
    INDENT
        x = ast.literal_eval(n)
        if isinstance(x, (int, float)) :
        INDENT
            var = abs(x)
            print type(var)
            return var
        DEDENT
    DEDENT
    except :
    INDENT
        print "No!"
    DEDENT
DEDENT
----------------------------------------

def distance_from_zero(n) :
INDENT
    try :
    INDENT
        n = int(n)
    DEDENT
    except ValueError :
    INDENT
        try :
        INDENT
            n = float(n)
        DEDENT
        except ValueError :
        INDENT
            print "Not a number!"
            n = float("NaN")
        DEDENT
    DEDENT
    return abs(n)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17375984_17376030_3_10
17375984_17376211_3_15
Title: Remove common letters in strings 
----------------------------------------

def remove_common(x, y) :
INDENT
    count = lambda x : collections.Counter(c for c in x.lower() if c.isalpha())
    cx, cy = count(x), count(y)
    diff = cx - cy
    rev_diff = cy - cx
    assert len(rev_diff) == 0, "%s in y and not x" % "".join(rev_diff.elements())
    return "".join(sorted(diff.elements()))
DEDENT
----------------------------------------

def remove_common(x, y) :
INDENT
    sort = lambda x : "".join(c for c in sorted(x.lower()) if c.isalpha())
    x, y = list(sort(x)), list(sort(y))
    cx = collections.Counter(x)
    cy = collections.Counter(y)
    cx.subtract(cy)
    result = ""
    for letter, count in cx.iteritems() :
    INDENT
        for i in range(abs(count)) :
        INDENT
            result += letter
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1738250_1738519_112_126
1738250_1738519_37_47
Title: Pylons and Memcached 
----------------------------------------

def fetch_by_field(cls, field, value) :
INDENT
    orm_object = None
    matched_primary_key = True
    for key in cls._sa_class_manager.mapper.primary_key :
    INDENT
        if field.key ! = key.key :
        INDENT
            matched_primary_key = False
        DEDENT
    DEDENT
    if matched_primary_key :
    INDENT
        orm_object = cls.get_cached_instance('(' + str(value) + ')')
    DEDENT
    if orm_object is None :
    INDENT
        orm_object = super(MemcachedORMObject, cls).fetch_by_field(field, value)
        if orm_object is not None :
        INDENT
            orm_object.set_cached_instance()
        DEDENT
    DEDENT
    return orm_object
DEDENT
----------------------------------------

def fetch_by_field(cls, field, value) :
INDENT
    session = SQLA_SESSION()
    try :
    INDENT
        class_object = session.query(cls).filter(field == value).one()
    DEDENT
    except sqlalchemy.orm.exc.NoResultFound :
    INDENT
        class_object = None
    DEDENT
    finally :
    INDENT
        session.close()
    DEDENT
    return class_object
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17393592_17394277_5_17
17393592_17397203_5_23
Title: How do I speed up fractal generation with numpy arrays? 
----------------------------------------

def newton_fractal(xmin, xmax, ymin, ymax, xres, yres) :
INDENT
    arr = np.array([[x + y * 1j for x in np.linspace(xmin, xmax, xres)] for y in np.linspace(ymin, ymax, yres)], dtype = "complex")
    f = np.poly1d([1, 0, 0, - 1])
    fp = np.polyder(f)
    counts = np.zeros(shape = arr.shape)
    for i in count() :
    INDENT
        f_g = f(arr)
        converged = np.abs(f_g) < = 0.00001
        counts [np.where(np.logical_and(converged, counts == 0))] = i
        if np.all(converged) :
        INDENT
            return counts
        DEDENT
        arr -= f_g / fp(arr)
    DEDENT
DEDENT
----------------------------------------

def newton_fractal(xmin, xmax, ymin, ymax, xres, yres) :
INDENT
    yarr, xarr = np.meshgrid(np.linspace(xmin, xmax, xres), np.linspace(ymin, ymax, yres) * 1j)
    arr = yarr + xarr
    ydim, xdim = arr.shape
    arr = arr.flatten()
    f = np.poly1d([1, 0, 0, - 1])
    fp = np.polyder(f)
    counts = np.zeros(shape = arr.shape)
    unconverged = np.ones(shape = arr.shape, dtype = bool)
    indices = np.arange(len(arr))
    for i in count() :
    INDENT
        f_g = f(arr [unconverged])
        new_unconverged = np.abs(f_g) > 0.00001
        counts [indices [unconverged] [~ new_unconverged]] = i
        if not np.any(new_unconverged) :
        INDENT
            return counts.reshape((ydim, xdim))
        DEDENT
        unconverged [unconverged] = new_unconverged
        arr [unconverged] -= f_g [new_unconverged] / fp(arr [unconverged])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17393592_17394277_5_17
17393592_34631071_12_32
Title: How do I speed up fractal generation with numpy arrays? 
----------------------------------------

def newton_fractal(xmin, xmax, ymin, ymax, xres, yres) :
INDENT
    arr = np.array([[x + y * 1j for x in np.linspace(xmin, xmax, xres)] for y in np.linspace(ymin, ymax, yres)], dtype = "complex")
    f = np.poly1d([1, 0, 0, - 1])
    fp = np.polyder(f)
    counts = np.zeros(shape = arr.shape)
    for i in count() :
    INDENT
        f_g = f(arr)
        converged = np.abs(f_g) < = 0.00001
        counts [np.where(np.logical_and(converged, counts == 0))] = i
        if np.all(converged) :
        INDENT
            return counts
        DEDENT
        arr -= f_g / fp(arr)
    DEDENT
DEDENT
----------------------------------------

def newton_fractal(f, xmin, xmax, ymin, ymax, xres, yres, tolerance, maxiters) :
INDENT
    yarr, xarr = np.meshgrid(np.linspace(xmin, xmax, xres), np.linspace(ymin, ymax, yres) * 1j)
    arr = yarr + xarr
    ydim, xdim = arr.shape
    arr = arr.flatten()
    fp = np.polyder(f, m = 1)
    counts = np.zeros(shape = arr.shape)
    unconverged = np.ones(shape = arr.shape, dtype = bool)
    indices = np.arange(len(arr))
    iters = 0
    for i in itertools.count() :
    INDENT
        f_g = f(arr [unconverged])
        new_unconverged = np.abs(f_g) > tolerance
        counts [indices [unconverged] [~ new_unconverged]] = i
        if not np.any(new_unconverged) or iters > = maxiters :
        INDENT
            return counts.reshape((ydim, xdim))
        DEDENT
        iters += 1
        unconverged [unconverged] = new_unconverged
        arr [unconverged] -= f_g [new_unconverged] / fp(arr [unconverged])

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17437634_17438315_11_21
17437634_17438524_38_62
Title: Python board game with tkinter 
----------------------------------------

def on_click(event, i, j) :
INDENT
    global player
    board [i] [j] ['bg'] = player
    for ii, jj in IT.product(range(i - 1, i + 2), range(j - 1, j + 2)) :
    INDENT
        if ii < 0 or ii > = rows or jj < 0 or jj > = cols : continue
        neighbor = board [ii] [jj]
        if neighbor ['bg'] ! = 'grey' and (ii, jj) ! = (i, j) :
        INDENT
            neighbor ['bg'] = other [neighbor ['bg']]
        DEDENT
    DEDENT
    check_for_winner()
    player = other [player]
DEDENT
----------------------------------------

def on_click(i, j, event) :
INDENT
    global counter
    if counter < 100 :
    INDENT
        if board [i] [j] == None :
        INDENT
            color = "green" if counter % 2 else "red"
            enemycolor = "red" if counter % 2 else "green"
            event.widget.config(bg = color)
            board [i] [j] = color
            for k in range(- 1, 2) :
            INDENT
                for l in range(- 1, 2) :
                INDENT
                    try :
                    INDENT
                        if board [i + k] [j + l] == enemycolor :
                        INDENT
                            board [i + k] [j + l] = color
                        DEDENT
                    DEDENT
                    except IndexError :
                    INDENT
                        pass
                    DEDENT
                DEDENT
            DEDENT
            counter += 1
            global gameframe
            gameframe.destroy()
            redraw()
            root.wm_title(enemycolor + "'s turn")
        DEDENT
        else :
        INDENT
            messagebox.showinfo("Alert", "This square is already occupied!")
        DEDENT
        check_board()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17465110_17465282_1_13
17465110_17465384_1_17
Title: "Whats the most Pythonic way of handling different mutually-exclusive function inputs?" 
----------------------------------------

def relations(a = None, b = None, c = None, d = None) :
INDENT
    if a is not None :
    INDENT
        pass
    DEDENT
    elif b is not None :
    INDENT
        a = b - 1
    DEDENT
    elif c is not None :
    INDENT
        a = 2 * c
    DEDENT
    elif d is not None :
    INDENT
        a = d ** 2
    DEDENT
    else :
    INDENT
        raise TypeError('At least one argument needed')
    DEDENT
DEDENT
----------------------------------------

def relations(** kwargs) :
INDENT
    if 'a' in kwargs :
    INDENT
        a = kwargs ['a']
    DEDENT
    elif 'b' in kwargs :
    INDENT
        a = kwargs ['b'] - 1
    DEDENT
    elif 'c' in kwargs :
    INDENT
        a = kwargs ['c'] * 2
    DEDENT
    elif 'd' in kwargs :
    INDENT
        a = kwargs ['d'] ** 2
    DEDENT
    else :
    INDENT
        raise TypeError('missing an argument')
    DEDENT
    b = 1 + a
    c = 0.5 * a
    d = a ** 0.5
    return a, b, c, d
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17465110_17465282_1_13
17465110_17465822_1_14
Title: "Whats the most Pythonic way of handling different mutually-exclusive function inputs?" 
----------------------------------------

def relations(a = None, b = None, c = None, d = None) :
INDENT
    if a is not None :
    INDENT
        pass
    DEDENT
    elif b is not None :
    INDENT
        a = b - 1
    DEDENT
    elif c is not None :
    INDENT
        a = 2 * c
    DEDENT
    elif d is not None :
    INDENT
        a = d ** 2
    DEDENT
    else :
    INDENT
        raise TypeError('At least one argument needed')
    DEDENT
DEDENT
----------------------------------------

def relations(** kwargs) :
INDENT
    if len(kwargs) ! = 1 or not set('abcd').intersection(kwargs) :
    INDENT
        raise ValueError('Invalid parameters')
    DEDENT
    vtype, v = kwargs.popitem()
    functions = {
        'a' : lambda x : x, 'b' : lambda x : x - 1,
        'c' : lambda x : x * 2, 'd' : lambda x : x ** 2}
    a = functions [vtype](v)
    b = 1 + a
    c = 0.5 * a
    d = a ** 0.5
    return a, b, c, d
DEDENT
----------------------------------------
