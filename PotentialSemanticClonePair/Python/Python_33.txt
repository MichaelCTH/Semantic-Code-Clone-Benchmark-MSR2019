$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37437101_42007731_12_29
37437101_42007731_53_61
Title: Python: Change Color of frame root.configure(background='red') don't work 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "GUi")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    F1.config()
    self.frames = {}
    for F in (StartPage, PageOne) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.config(bg = "black")
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "Page One", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button1 = ttk.Button(self, text = "Back to Home",
        command = lambda : controller.show_frame(StartPage))
    button1.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37437101_42007731_37_51
37437101_42007731_53_61
Title: Python: Change Color of frame root.configure(background='red') don't work 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    ttk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "GUI", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button = ttk.Button(self, text = "Visit Page One",
        command = lambda : controller.show_frame(PageOne))

    button2 = ttk.Button(self, text = "Ok",
        command = lambda : controller.label2)
    button.pack()
    button2.pack()

DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "Page One", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    button1 = ttk.Button(self, text = "Back to Home",
        command = lambda : controller.show_frame(StartPage))
    button1.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3744048_3744154_3_30
3744048_3744199_69_74
Title: python: how to merge a list into clusters? 
----------------------------------------

def MergeThat(a) :
INDENT
    index = {}
    for t0, t1 in a :
    INDENT
        if t0 not in index and t1 not in index :
        INDENT
            index [t0] = set()
            index [t1] = index [t0]
        DEDENT
        elif t0 in index and t1 in index :
        INDENT
            index [t0] |= index [t1]
            oldt1 = index [t1]
            for x in index.keys() :
            INDENT
                if index [x] is oldt1 :
                INDENT
                    index [x] = index [t0]
                DEDENT
            DEDENT
        DEDENT
        elif t0 not in index :
        INDENT
            index [t0] = index [t1]
        DEDENT
        else :
        INDENT
            index [t1] = index [t0]
        DEDENT
        assert index [t0] is index [t1]
        index [t0].add(t0)
        index [t0].add(t1)
    DEDENT
    return sorted([tuple(sorted(x)) for x in set(map(frozenset, index.values()))], key = len, reverse = True)
DEDENT
----------------------------------------

def MergeThat(L) :
INDENT
    answer, merges = collapse(L)
    while merges :
    INDENT
        answer, merges = collapse(answer)
    DEDENT
    return sortByLength(answer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37446249_37446739_1_25
37446249_37446779_1_18
Title: How to create a sorted list given two already sorted lists ( cannot modify either given lists ) 
----------------------------------------

def merge_lists(list1, list2) :
INDENT
    sortedList = []
    pointer1 = 0
    pointer2 = 0
    while pointer1 < len(list1) and pointer2 < len(list2) :
    INDENT
        if list1 [pointer1] < list2 [pointer2] :
        INDENT
            sortedList.append(list1 [pointer1])
            pointer1 += 1
        DEDENT
        elif list1 [pointer1] > list2 [pointer2] :
        INDENT
            sortedList.append(list2 [pointer2])
            pointer2 += 1
        DEDENT
        else :
        INDENT
            sortedList.append(list1 [pointer1])
            pointer1 += 1
        DEDENT
    DEDENT
    while pointer1 < len(list1) :
    INDENT
        sortedList.append(list1 [pointer1])
        pointer1 += 1
    DEDENT
    while pointer2 < len(list2) :
    INDENT
        sortedList.append(list2 [pointer2])
        pointer2 += 1
    DEDENT
    return sortedList
DEDENT
----------------------------------------

def merge_lists(list1, list2) :
INDENT
    sortedList = []
    pointer1 = 0
    pointer2 = 0
    while pointer1 < len(list1) and pointer2 < len(list2) :
    INDENT
        if list1 [pointer1] < list2 [pointer2] :
        INDENT
            sortedList.append(list1 [pointer1])
            pointer1 += 1
        DEDENT
        elif list2 [pointer2] < list1 [pointer1] :
        INDENT
            sortedList.append(list2 [pointer2])
            pointer2 += 1
        DEDENT
        elif list1 [pointer1] == list2 [pointer2] :
        INDENT
            sortedList.append(list1 [pointer1])
            sortedList.append(list2 [pointer2])
            pointer1 += 1
            pointer2 += 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37450923_37453376_9_29
37450923_37457848_9_20
Title: tkinter widget not showing up 
----------------------------------------

def initialize(self) :
INDENT
    self.parent.title("RUN ON START TEST")
    self.parent.grid_rowconfigure(0, weight = 1)
    self.parent.grid_columnconfigure(0, weight = 1)
    self.parent.config(background = "red")
    self.frame = Tk.Frame(self.parent)
    self.frame.pack(fill = Tk.X, padx = 5, pady = 5)
    self.topEntry = Tk.Entry(self.frame, bg = "#006600", fg = "#00ff00")
    self.topEntry.grid(column = 0, row = 1, sticky = "ew")

    yesBut = Tk.Button(self.frame, text = "Yes")
    yesBut.grid(column = 1, row = 1)
    query = Tk.Label(self.frame, fg = "#00ff00", bg = "#001a00", anchor = "w")
    query.grid(column = 1, row = 0, columnspan = 2, sticky = "ew")

DEDENT
----------------------------------------

def initialize(self) :
INDENT
    self.config(bg = "#001a00")
    self.topEntry = Tkinter.Entry(self, bg = "#006600", fg = "#00ff00")
    self.topEntry.grid(column = 0, row = 1, sticky = "EW")
    yesBut = Tkinter.Button(self, text = "Yes")
    yesBut.grid(column = 1, row = 1)
    query = Tkinter.Label(self, fg = "#00ff00", bg = "#001a00", anchor = "w")
    query.grid(column = 1, row = 0, columnspan = 2, sticky = "EW")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37463035_37463406_16_26
37463035_37463579_16_22
Title: Multiplication in a variable 
----------------------------------------

def multiplication(num) :
INDENT
    total = int(num [0]) * 3
    total += int(num [1]) * 1
    total += int(num [2]) * 3
    total += int(num [3]) * 1
    total += int(num [4]) * 3
    total += int(num [5]) * 1
    total += int(num [6]) * 3
    return total
DEDENT
----------------------------------------

def multiplication() :
INDENT
    total = 0
    for i, m in enumerate([3, 1, 3, 1, 3, 1, 3]) :
    INDENT
        total += int(num [i]) * m
    DEDENT
    return total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37488837_37489108_1_12
37488837_37490646_1_9
Title: How do I check a text file line-by-line to detect if there are duplicates? 
----------------------------------------

def checkInsultsFile(numInsults = 1000, file = "Insults.txt") :
INDENT
    lines = open(file, 'r').readlines()
    dict = {}
    for line in lines :
    INDENT
        dict [line] = dict.get(line, 0) + 1
    DEDENT
    for k, v in dict.iteritems() :
    INDENT
        if v > 1 :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def checkInsultsFile(file) :
INDENT
    with open(file, 'r') as f :
    INDENT
        lines = [line.strip() for line in f]
    DEDENT
    check = set(lines)
    if len(lines) == len(check) :
    INDENT
        return False
    DEDENT
    elif len(check) < len(lines) :
    INDENT
        return True
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37488912_37489540_15_25
37488912_37489727_14_28
Title: pythonic way to index list of objects 
----------------------------------------

def __setattr__(self, name, value) :
INDENT
    if name in ("_proxy", "collection") :
    INDENT
        object.__setattr__(self, name, value)
    DEDENT
    else :
    INDENT
        proxied = self._proxy
        collection = self._collection
        old = getattr(proxied, name)
        setattr(proxy, name, value)
        collection.signal_change(proxied, name, old, value)

    DEDENT
DEDENT
----------------------------------------

def __setattr__(self, name, value) :
INDENT
    try :
    INDENT
        index = MyObject.indexes [name]
    DEDENT
    except KeyError :
    INDENT
        index = weakref.WeakValueDictionary()
        MyObject.indexes [name] = index
    DEDENT
    try :
    INDENT
        old_val = getattr(self, name)
        del index [old_val]
    DEDENT
    except (KeyError, AttributeError) :
    INDENT
        pass
    DEDENT
    object.__setattr__(self, name, value)
    index [value] = self

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37491992_37492107_4_22
37491992_37492807_4_23
Title: mutliple entry widgets and one button widget in tkinter 
----------------------------------------

def __init__(self, root) :
INDENT
    root.geometry("550x145+500+300")
    self.l1 = Label(root, text = "Enter the prescription dose to three (3) decimal places [cGy]")
    self.l1.pack()
    self.e1 = Entry(root)
    self.e1.pack()
    self.l2 = Label(root, text = "Save new excel file as...")
    self.l2.pack()
    self.e2 = Entry(root)
    self.e2.pack()
    self.l3 = Label(root, text = "click 'OK', and then close window.")
    self.l3.pack()
    self.b = Button(root, text = "OK", command = self.submit)
    self.b.pack()
DEDENT
----------------------------------------

def __init__(self, root) :
INDENT
    root.geometry("550x145+500+300")
    l = tk.Label(root, text = "Enter the prescription dose to three (3) decimal places [cGy]")
    l.pack()
    self.dosage = tk.StringVar()
    e = tk.Entry(root, textvariable = self.dosage)
    e.pack()
    l = tk.Label(root, text = "Save new excel file as...")
    l.pack()
    self.savename = tk.StringVar()
    e = tk.Entry(root, textvariable = self.savename)
    e.pack()
    l = tk.Label(root, text = "Enter the data and then close window.")
    l.pack()
    root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37497559_37497630_4_18
37497559_37497630_5_15
Title: Python Pandas Identify Duplicated rows with Additional Column 
----------------------------------------

def rename_dup(df) :
INDENT
    def rename_dup(df, c, dfnew) :
    INDENT
        dfnondup = df.drop_duplicates(['PplNum', 'RoomNum'])
        dfnondup ['C'] = pd.Series([c] * len(dfnondup), index = dfnondup.index)
        dfnew = pd.concat([dfnew, dfnondup], axis = 0)
        c += 1
        dfdup = df [df.duplicated(['PplNum', 'RoomNum'])]
        if dfdup.empty :
        INDENT
            return dfnew, c
        DEDENT
        else :
        INDENT
            return rename_dup(dfdup, c, dfnew)
        DEDENT
    DEDENT
    return rename_dup(df, 1, pd.DataFrame())

DEDENT
----------------------------------------

def rename_dup(df, c, dfnew) :
INDENT
    dfnondup = df.drop_duplicates(['PplNum', 'RoomNum'])
    dfnondup ['C'] = pd.Series([c] * len(dfnondup), index = dfnondup.index)
    dfnew = pd.concat([dfnew, dfnondup], axis = 0)
    c += 1
    dfdup = df [df.duplicated(['PplNum', 'RoomNum'])]
    if dfdup.empty :
    INDENT
        return dfnew, c
    DEDENT
    else :
    INDENT
        return rename_dup(dfdup, c, dfnew)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37503399_37503493_3_10
37503399_37503895_1_7
Title: Python function not returning anything 
----------------------------------------

def equip(x) :
INDENT
    global bag_sword
    if x == "iron sword" :
    INDENT
        if "iron sword" in bag_sword :
        INDENT
            print "You can't have 2 weapons equipped!"
        DEDENT
        else :
        INDENT
            bag_sword.append("iron sword")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def equip(item, slot, inventory) :
INDENT
    if inventory [slot] == item :
    INDENT
        print 'Already equipped.'
    DEDENT
    else :
    INDENT
        inventory [slot] = item
        print item.capitalize(), 'equipped.'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37523457_37523701_2_16
37523457_37524940_7_19
Title: Got Failed to decode JSON object when calling a POST request in flask python 
----------------------------------------

def create_task() :
INDENT
    try :
    INDENT
        blob = request.get_json(force = True)
    DEDENT
    except :
    INDENT
        abort(400)
    DEDENT
    if not 'title' in blob :
    INDENT
        abort(400)
    DEDENT
    task = {
        'id' : tasks [- 1] ['id'] + 1,
        'title' : blob ['title'],
        'description' : blob.get('description', ""),
        'done' : False}
    tasks.append(task)
    return jsonify({'task' : task})
DEDENT
----------------------------------------

def create_task() :
INDENT
    if not request.json or 'title' not in request.json :
    INDENT
        abort(400)
    DEDENT
    task = {
        'id' : tasks [- 1] ['id'] + 1,
        'title' : request.json ['title'],
        'description' : request.json.get('description', ""),
        'done' : False}
    tasks.append(task)
    response = {"task" : task}
    return jsonify(response), 201
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37541052_37541806_14_26
37541052_37541987_17_27
Title: Trying to find substrings in large string 
----------------------------------------

def printAll(dna) :
INDENT
    start = 0
    while True :
    INDENT
        loc = dna.find("atg", start)
        if loc == - 1 :
        INDENT
            break
        DEDENT
        stop = findStopIndex(dna, loc + 3)
        if stop :
        INDENT
            gene = dna [loc : stop + 3]
            print (gene.upper())
        DEDENT
        start = loc + 3
    DEDENT
    return
DEDENT
----------------------------------------

def printAll(dna) :
INDENT
    gene = None
    start = 0
    while (True) :
    INDENT
        loc = dna.find("atg", start)
        if (loc == - 1) : break
        stop = findStopIndex(dna, loc + 3)
        gene = dna [loc : stop + 3]
        print gene.upper()
        start = loc + len(gene) + 3
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37541052_37541806_14_26
37541052_37542380_9_24
Title: Trying to find substrings in large string 
----------------------------------------

def printAll(dna) :
INDENT
    start = 0
    while True :
    INDENT
        loc = dna.find("atg", start)
        if loc == - 1 :
        INDENT
            break
        DEDENT
        stop = findStopIndex(dna, loc + 3)
        if stop :
        INDENT
            gene = dna [loc : stop + 3]
            print (gene.upper())
        DEDENT
        start = loc + 3
    DEDENT
    return
DEDENT
----------------------------------------

def printAll(dna) :
INDENT
    dna = dna.upper()
    start = 0
    while True :
    INDENT
        loc = dna.find("ATG", start)
        if loc == - 1 :
        INDENT
            break
        DEDENT
        try :
        INDENT
            stop = findStopIndex(dna, loc + 3)
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            print (dna [loc : stop + 3])
        DEDENT
        start = loc + 3
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37541052_37541806_1_13
37541052_37542380_1_8
Title: Trying to find substrings in large string 
----------------------------------------

def findStopIndex(dna, index) :
INDENT
    stop1 = dna.find("tga", index)
    if (stop1 == - 1 or (stop1 - index) % 3 ! = 0) :
    INDENT
        stop1 = len(dna)
    DEDENT
    stop2 = dna.find("taa", index)
    if (stop2 == - 1 or (stop2 - index) % 3 ! = 0) :
    INDENT
        stop2 = len(dna)
    DEDENT
    stop3 = dna.find("tag", index)
    if (stop3 == - 1 or (stop3 - index) % 3 ! = 0) :
    INDENT
        stop3 = len(dna)
    DEDENT
    end_sequence = min(stop1, stop2, stop3) if min(stop1, stop2, stop3) < 60 else None
    return end_sequence
DEDENT
----------------------------------------

def findStopIndex(dna, index) :
INDENT
    stops = []
    for tag in ["TGA", "TAA", "TAG"] :
    INDENT
        stop = dna.find(tag, index)
        if stop > = 0 and (stop - index) % 3 == 0 :
        INDENT
            stops.append(stop)
        DEDENT
    DEDENT
    return min(stops)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37541052_37541987_17_27
37541052_37542380_9_24
Title: Trying to find substrings in large string 
----------------------------------------

def printAll(dna) :
INDENT
    gene = None
    start = 0
    while (True) :
    INDENT
        loc = dna.find("atg", start)
        if (loc == - 1) : break
        stop = findStopIndex(dna, loc + 3)
        gene = dna [loc : stop + 3]
        print gene.upper()
        start = loc + len(gene) + 3
    DEDENT
DEDENT
----------------------------------------

def printAll(dna) :
INDENT
    dna = dna.upper()
    start = 0
    while True :
    INDENT
        loc = dna.find("ATG", start)
        if loc == - 1 :
        INDENT
            break
        DEDENT
        try :
        INDENT
            stop = findStopIndex(dna, loc + 3)
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
        else :
        INDENT
            print (dna [loc : stop + 3])
        DEDENT
        start = loc + 3
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37541052_37541987_1_16
37541052_37542380_1_8
Title: Trying to find substrings in large string 
----------------------------------------

def findStopIndex(dna, index) :
INDENT
    stop1 = dna.find("tga", index)
    if (stop1 == - 1 or (stop1 - index) % 3 ! = 0) :
    INDENT
        stop1 = len(dna)
    DEDENT
    stop2 = dna.find("taa", index)
    if (stop2 == - 1 or (stop2 - index) % 3 ! = 0) :
    INDENT
        stop2 = len(dna)
    DEDENT
    stop3 = dna.find("tag", index)
    if (stop3 == - 1 or (stop3 - index) % 3 ! = 0) :
    INDENT
        stop3 = len(dna)
    DEDENT
    return min(stop1, min(stop2, stop3))
DEDENT
----------------------------------------

def findStopIndex(dna, index) :
INDENT
    stops = []
    for tag in ["TGA", "TAA", "TAG"] :
    INDENT
        stop = dna.find(tag, index)
        if stop > = 0 and (stop - index) % 3 == 0 :
        INDENT
            stops.append(stop)
        DEDENT
    DEDENT
    return min(stops)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37583355_37583840_20_26
37583355_37584325_3_16
Title: How to check whether ManytoMany has values before saving Model? 
----------------------------------------

def fingers_changed(sender, ** kwargs) :
INDENT
    instance = kwargs.pop('instance', None)
    instance.num_fingers = instance.fingers.count()
    if instance.fingers.filter(is_a_thumb = True) :
    INDENT
        instance.has_thumb = True
    DEDENT
    instance.save()
DEDENT
----------------------------------------

def fingers_changed(sender, ** kwargs) :
INDENT
    if kwargs ['action'] == 'post_add' :
    INDENT
        hand = kwargs ['instance']
        hand.num_fingers = hand.fingers.count()
        hand.has_thumb = hand.fingers.filter(is_a_thumb = True).exists()
        hand.save()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37589165_37712706_1_38
37589165_37714284_3_32
Title: Drawing an antialiased circle as described by Xaolin Wu 
----------------------------------------

def draw_antialiased_circle(renderer, position, radius, alpha_max = sdl2.SDL_ALPHA_OPAQUE) :
INDENT
    def _draw_points(i, j) :
    INDENT
        local_coord = [(i * (- 1) ** (k % 2), j * (- 1) ** (k / / 2)) for k in range(4)]
        local_coord += [(j_, i_) for i_, j_ in local_coord]
        for i_, j_ in local_coord :
        INDENT
            sdl2.SDL_RenderDrawPoint(renderer, position.x + i_, position.y + j_)
        DEDENT
    DEDENT
    def set_alpha_color(alpha, r = 255, g = 255, b = 255) :
    INDENT
        sdl2.SDL_SetRenderDrawColor(renderer, r, g, b, alpha)
    DEDENT
    i, j, T = radius, 0, 0

    set_alpha_color(alpha_max)
    _draw_points(i, 0)
    while i > j :
    INDENT
        j += 1
        d = math.ceil(math.sqrt(radius ** 2 - j ** 2))

        i -= 1 if d < T else 0
        """
        Draw 8 points for i and i-1 keeping the total opacity constant
        and equal to :alpha_max:.
        """
        alpha = int(d / radius * alpha_max)
        for i_, alpha_ in zip((i, i - 1), (alpha, alpha_max - alpha)) :
        INDENT
            set_alpha_color(alpha_)
            _draw_points(i_, j)
        DEDENT
        T = d
    DEDENT
DEDENT
----------------------------------------

def draw_antialiased_circle(outer_radius) :
INDENT
    def _draw_point(x, y, alpha) :
    INDENT
        print ('%d:%d @ %f' % (x, y, alpha))
    DEDENT
    i = 0
    j = outer_radius
    last_fade_amount = 0
    fade_amount = 0
    MAX_OPAQUE = 100.0
    while i < j :
    INDENT
        height = math.sqrt(max(outer_radius * outer_radius - i * i, 0))
        fade_amount = MAX_OPAQUE * (math.ceil(height) - height)
        if fade_amount < last_fade_amount :
        INDENT

            j -= 1
        DEDENT
        last_fade_amount = fade_amount

        fade_amount_i = int(fade_amount)

        _draw_point(i, j, MAX_OPAQUE - fade_amount_i)
        _draw_point(i, j - 1, fade_amount_i)
        i += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37599568_37600337_1_9
37599568_37602213_2_6
Title: "Least common multiple of n numbers using recursion" 
----------------------------------------

def nod(a, b) :
INDENT
    if b == 0 :
    INDENT
        return a
    DEDENT
    else :
    INDENT
        if a > b :
        INDENT
            return nod(b, a % b)
        DEDENT
        else :
        INDENT
            return nod(a, b % a)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def nod(a, b) :
INDENT
    if b == 0 :
    INDENT
        return a
    DEDENT
    else :
    INDENT
        return nod(b, a % b)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37600483_37764149_30_39
37600483_37764149_4_12
Title: QtUdpSocket still listening on port after closing MainWindow 
----------------------------------------

def __init__(self, parent) :
INDENT
    super(mainMainWindow, self).__init__(parent)
    self.setWindowTitle("Main Main Window")
    myUdpMainWindow = udpMainWindow(self)
    myUdpMainWindow.show()
    self.listenSocket = QtNetwork.QUdpSocket()
    btn = QtGui.QPushButton("Listen to port 12345")
    btn.clicked.connect(self.connect_udp)
    self.setCentralWidget(btn)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(udpMainWindow, self).__init__(parent)
    self.setWindowTitle("UDP Main Window")
    self.listenSocket = QtNetwork.QUdpSocket()
    btn = QtGui.QPushButton("Listen to port 12345")
    btn.clicked.connect(self.start_listening)
    self.setCentralWidget(btn)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37629819_37630047_1_13
37629819_37640881_1_12
Title: Printing out all the numbers in a list if the sum of those numbers exceed 100. 
----------------------------------------

def solve(arr) :
INDENT
    index = 0
    total = 0
    end = len(arr)
    flag = False
    while index < len(arr) and not flag :
    INDENT
        total += arr [index]
        index += 1
        if total > 100 :
        INDENT
            end = index
            flag = True
        DEDENT
    DEDENT
    print(* arr [0 : end], sep = ' ')
DEDENT
----------------------------------------

def solve(l) :
INDENT
    i = - 1
    j = 0
    cur = []
    while (i < (len(l) - 1) and sum(cur) < = 100) :
    INDENT
        i += 1
        j = l [i]
        if sum(cur) + j > 100 :
        INDENT
            pass
        DEDENT
        print(j, end = " ")
        cur.append(j)
    DEDENT
    print ()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37632730_37632851_1_9
37632730_37632853_1_8
Title: Python function returns empty list 
----------------------------------------

def translate(a) :
INDENT
    trs = {"merry" : "god", "christmas" : "jul", "and" : "och", "happy" : "gott", "new" : "nytt", "year" : "ar"}
    translated = []
    for i in a.split(" ") :
    INDENT
        for k, v in trs.iteritems() :
        INDENT
            if i == k :
            INDENT
                translated.append(trs [i])
            DEDENT
        DEDENT
    DEDENT
    return translated
DEDENT
----------------------------------------

def translate(a) :
INDENT
    trs = {"merry" : "god", "christmas" : "jul", "and" : "och", "happy" : "gott", "new" : "nytt", "year" : "ar"}
    translated = []
    for i in a.split(" ") :
    INDENT
        if i in trs :
        INDENT
            translated.append(trs [i])
        DEDENT
    DEDENT
    return " ".join(translated)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37640171_37640315_5_54
37640171_37641558_4_35
Title: Setting variables in a function and importing them 
----------------------------------------

def read() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            file = open("agData.txt", "r")
        DEDENT
        except :
        INDENT
            exec (open("agCreation.py").read())
            break
        DEDENT
        break
    DEDENT
    file = open("agData.txt", "r")
    data = file.readlines(0)
    encrypFName = data [0]
    encrypSName = data [1]
    encrypAge = data [2]
    encrypGender = data [3]
    encrypHealth = data [4]
    encrypMaxHealth = data [5]
    encrypArmour = data [6]
    encrypMaxArmour = data [7]
    encrypHealthPotions = data [8]
    encrypExp = data [9]
    encrypMaxExp = data [10]
    encrypLevel = data [11]
    encrypGold = data [12]
    encrypMaxGold = data [13]
    encrypPowerLevel = data [14]
    encrypMaxPowerExp = data [15]
    encrypPowerExp = data [16]
    encrypStage = data [17]
    conf = Conf()
    conf.fName = encrypFName.strip()
    conf.sName = encrypSName.strip()
    conf.age = encrypAge.strip()
    conf.gender = encrypGender.strip()
    conf.health = encrypHealth.strip()
    conf.maxHealth = encrypMaxHealth.strip()
    conf.armour = encrypArmour.strip()
    conf.maxArmour = encrypArmour.strip()
    conf.healthPotions = encrypHealthPotions.strip()
    conf.exp = encrypExp.strip()
    conf.maxExp = encrypMaxExp.strip()
    conf.level = encrypLevel.strip()
    conf.gold = encrypGold.strip()
    conf.maxGold = encrypMaxGold.strip()
    conf.powerLevel = encrypPowerLevel.strip()
    conf.maxPowerExp = encrypMaxPowerExp.strip()
    conf.powerExp = encrypPowerExp.strip()
    conf.stage = encrypStage.strip()
    return conf
DEDENT
----------------------------------------

def read() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            file = open("agData.txt", "r")
        DEDENT
        except :
        INDENT
            exec (open("agCreation.py").read())
            break
        DEDENT
        break
    DEDENT
    file = open("agData.txt", "r")
    data = file.readlines(0)
    conf = Conf()
    conf.fName = data [0].strip()
    conf.sName = data [1].strip()
    conf.age = data [2].strip()
    conf.gender = data [3].strip()
    conf.health = data [4].strip()
    conf.maxHealth = data [5].strip()
    conf.armour = data [6].strip()
    conf.maxArmour = data [7].strip()
    conf.healthPotions = data [8].strip()
    conf.exp = data [9].strip()
    conf.maxExp = data [10].strip()
    conf.level = data [11].strip()
    conf.gold = data [12].strip()
    conf.maxGold = data [13].strip()
    conf.powerLevel = data [14].strip()
    conf.maxPowerExp = data [15].strip()
    conf.powerExp = data [16].strip()
    conf.stage = data [17].strip()
    return conf
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37640171_37640594_10_56
37640171_37641558_4_35
Title: Setting variables in a function and importing them 
----------------------------------------

def read() :
INDENT
    try :
    INDENT
        open("agData.txt", "r")
    DEDENT
    except :
    INDENT
        exec (open("agCreation.py").read())
    DEDENT
    file = open("agData.txt", "r")
    data = file.readlines(0)
    encrypFName = data [0]
    encrypSName = data [1]
    encrypAge = data [2]
    encrypGender = data [3]
    encrypHealth = data [4]
    encrypMaxHealth = data [5]
    encrypArmour = data [6]
    encrypMaxArmour = data [7]
    encrypHealthPotions = data [8]
    encrypExp = data [9]
    encrypMaxExp = data [10]
    encrypLevel = data [11]
    encrypGold = data [12]
    encrypMaxGold = data [13]
    encrypPowerLevel = data [14]
    encrypMaxPowerExp = data [15]
    encrypPowerExp = data [16]
    encrypStage = data [17]
    conf = Conf()
    conf.fName = encrypFName.strip()
    conf.sName = encrypSName.strip()
    conf.age = encrypAge.strip()
    conf.gender = encrypGender.strip()
    conf.health = encrypHealth.strip()
    conf.maxHealth = encrypMaxHealth.strip()
    conf.armour = encrypArmour.strip()
    conf.maxArmour = encrypArmour.strip()
    conf.healthPotions = encrypHealthPotions.strip()
    conf.exp = encrypExp.strip()
    conf.maxExp = encrypMaxExp.strip()
    conf.level = encrypLevel.strip()
    conf.gold = encrypGold.strip()
    conf.maxGold = encrypMaxGold.strip()
    conf.powerLevel = encrypPowerLevel.strip()
    conf.maxPowerExp = encrypMaxPowerExp.strip()
    conf.powerExp = encrypPowerExp.strip()
    conf.stage = encrypStage.strip()
    return conf
DEDENT
----------------------------------------

def read() :
INDENT
    while True :
    INDENT
        try :
        INDENT
            file = open("agData.txt", "r")
        DEDENT
        except :
        INDENT
            exec (open("agCreation.py").read())
            break
        DEDENT
        break
    DEDENT
    file = open("agData.txt", "r")
    data = file.readlines(0)
    conf = Conf()
    conf.fName = data [0].strip()
    conf.sName = data [1].strip()
    conf.age = data [2].strip()
    conf.gender = data [3].strip()
    conf.health = data [4].strip()
    conf.maxHealth = data [5].strip()
    conf.armour = data [6].strip()
    conf.maxArmour = data [7].strip()
    conf.healthPotions = data [8].strip()
    conf.exp = data [9].strip()
    conf.maxExp = data [10].strip()
    conf.level = data [11].strip()
    conf.gold = data [12].strip()
    conf.maxGold = data [13].strip()
    conf.powerLevel = data [14].strip()
    conf.maxPowerExp = data [15].strip()
    conf.powerExp = data [16].strip()
    conf.stage = data [17].strip()
    return conf
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37643316_37643389_4_9
37643316_37643410_3_8
Title: Check boolean from another function 
----------------------------------------

def functionA(x, bool) :
INDENT
    global bool1
    if x is 0 :
    INDENT
        bool1 = True

    DEDENT
DEDENT
----------------------------------------

def functionA(x) :
INDENT
    if x is 0 :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37643778_37644808_1_10
37643778_46782714_1_14
Title: Change each character in string to the next character in alphabet 
----------------------------------------

def LetterChanges(word) :
INDENT
    zabc = 'abcdefghijklmonpqrstuvwxyzabc'
    ab_st = list(zabc)
    new_word = []
    for letter in list(word.lower().strip()) :
    INDENT
        new_word.append(ab_st [zabc.index(letter) + 1])
    DEDENT
    new_word = "".join(new_word)
    return new_word

DEDENT
----------------------------------------

def LetterChanges(st) :
INDENT
    index = 0
    new_word = ""
    alphapet = "abcdefghijklmnopqrstuvwxyzacd"
    for i in st.lower() :
    INDENT
        if i.islower() :
        INDENT
            index = alphapet.index(i) + 1
            new_word += alphapet [index]
        DEDENT
        else :
        INDENT
            new_word += i
        DEDENT
    DEDENT
    return new_word

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37668326_37668327_33_47
37668326_37668327_7_17
Title: Get child of box in a dialog in python Gtk3 
----------------------------------------

def __init__(self, parent) :
INDENT
    Gtk.Dialog.__init__(self, "My Dialog", parent, 0,
        (Gtk.STOCK_CANCEL, Gtk.ResponseType.CANCEL,
            Gtk.STOCK_OK, Gtk.ResponseType.OK))
    self.set_default_size(150, 100)
    self.box = self.get_content_area()
    self.box.set_border_width(6)
    self.cal = Gtk.Calendar()
    self.box.add(self.cal)
    self.show_all()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Gtk.Window.__init__(self, title = "Titulo")
    self.connect("delete_event", Gtk.main_quit)
    self.set_border_width(6)
    button = Gtk.Button("Open Dialog")
    button.connect("clicked", self.on_button_clicked)
    self.add(button)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37681848_37683224_9_20
37681848_37683470_35_50
Title: I can't get my class to work in pygame 
----------------------------------------

def move(self, walk1, still, walk2, sprite) :
INDENT
    self.timer = clock.tick()
    if self.timer > 9 :
    INDENT
        self.timer = 0
        if sprite == walk1 :
        INDENT
            self.sprite = still
        DEDENT
        elif sprite == still :
        INDENT
            self.sprite = walk2
        DEDENT
        elif sprite == walk2 :
        INDENT
            self.sprite = walk1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def move(self, direction) :
INDENT
    self.direction = direction
    if direction == 'left' :
    INDENT
        self.x -= 1
        self.sprite = self.lwalk
    DEDENT
    elif direction == 'right' :
    INDENT
        self.x += 1
        self.sprite = self.rwalk
    DEDENT
    elif direction == 'up' :
    INDENT
        self.y += 1
        self.sprite = self.fwalk
    DEDENT
    else :
    INDENT
        self.y -= 1
        self.sprite = self.bwalk
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37702642_37836348_7_23
37702642_37922685_1_49
Title: Draw half infinite lines? 
----------------------------------------

def __init__(self, changeX, levelsY, pen = None) :
INDENT
    pg.GraphicsObject.__init__(self)
    self.changeX = changeX
    self.levelsY = levelsY
    self.maxRange = [None, None]
    self.moving = False
    self.movable = False
    self.mouseHovering = False
    pen = (200, 200, 100)
    self.setPen(pen)
    self.setHoverPen(color = (255, 0, 0), width = self.pen.width())
    self.currentPen = self.pen

DEDENT
----------------------------------------

def __init__(self, listOfcouplesOfThresholdAndItsDate, pen = None) :
INDENT
    pg.GraphicsObject.__init__(self)
    self.listOfcouplesOfThresholdAndItsDate = listOfcouplesOfThresholdAndItsDate
    self.maxRange = [None, None]
    self.moving = False
    self.movable = False
    self.mouseHovering = False
    pen = (200, 200, 100)
    self.setPen(pen)
    self.setHoverPen(color = (255, 0, 0), width = self.pen.width())
    self.currentPen = self.pen

    def paint(self, p, * args) :
    INDENT
        br = self.boundingRect()
        p.setPen(self.currentPen)
        if len(self.listOfcouplesOfThresholdAndItsDate) == 0 :
        INDENT
            pass
        DEDENT
        elif len(self.listOfcouplesOfThresholdAndItsDate) == 1 :
        INDENT
            threshold = self.listOfcouplesOfThresholdAndItsDate [0] [1]
            date = self.listOfcouplesOfThresholdAndItsDate [0] [0]
            p.drawLine(pg.Point(date, threshold), pg.Point(br.right(), threshold))
        DEDENT
        else :
        INDENT

            threshold = self.listOfcouplesOfThresholdAndItsDate [0] [1]
            date = self.listOfcouplesOfThresholdAndItsDate [0] [0]
            i = 0
            for i in range(0, len(self.listOfcouplesOfThresholdAndItsDate) - 2) :
            INDENT
                threshold = self.listOfcouplesOfThresholdAndItsDate [i] [1]
                date = self.listOfcouplesOfThresholdAndItsDate [i] [0]
                nexteDate = self.listOfcouplesOfThresholdAndItsDate [i + 1] [0]
                nextThreshold = self.listOfcouplesOfThresholdAndItsDate [i + 1] [1]
                p.drawLine(pg.Point(date, threshold), pg.Point(nexteDate, threshold))
                p.drawLine(pg.Point(nexteDate, threshold), pg.Point(nexteDate, nextThreshold))

            DEDENT
            threshold = self.listOfcouplesOfThresholdAndItsDate [- 2] [1]
            date = self.listOfcouplesOfThresholdAndItsDate [- 2] [0]
            nexteDate = self.listOfcouplesOfThresholdAndItsDate [- 1] [0]
            nextThreshold = self.listOfcouplesOfThresholdAndItsDate [- 1] [1]
            p.drawLine(pg.Point(date, threshold), pg.Point(nexteDate, threshold))
            p.drawLine(pg.Point(nexteDate, threshold), pg.Point(nexteDate, nextThreshold))
            p.drawLine(pg.Point(nexteDate, nextThreshold), pg.Point(br.right(), nextThreshold))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37738877_37739052_5_15
37738877_37758802_2_14
Title: How Do I Fix My Code So It Can print() Out The Results I Want? 
----------------------------------------

def __init__(self, name, role, health, attack, defense) :
INDENT
    self.name = name
    self.level = 1
    self.totexp = 0
    self.role = role
    self.health = health
    self.attack = attack
    self.defense = defense
    self.exp = 0

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.name = ""
    self.role = ""
    self.health = 0
    self.health_now = 0
    self.health_gained = 0
    self.attack = 0
    self.defense = 0
    self.glob()
    self.add_name()
    self.add_role()
    self.print_info()
    self.menu()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37748105_37748485_5_14
37748105_46825841_8_20
Title: How to use progressbar module with urlretrieve 
----------------------------------------

def show_progress(count, block_size, total_size) :
INDENT
    if pbar is None :
    INDENT
        pbar = ProgressBar(maxval = total_size)
    DEDENT
    downloaded += block_size
    pbar.update(block_size)
    if downloaded == total_size :
    INDENT
        pbar.finish()
        pbar = None
        downloaded = 0
    DEDENT
DEDENT
----------------------------------------

def show_progress(block_num, block_size, total_size) :
INDENT
    global pbar
    if pbar is None :
    INDENT
        pbar = progressbar.ProgressBar(maxval = total_size)
    DEDENT
    downloaded = block_num * block_size
    if downloaded < total_size :
    INDENT
        pbar.update(downloaded)
    DEDENT
    else :
    INDENT
        pbar.finish()
        pbar = None

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3774919_23599876_128_137
3774919_23599876_50_58
Title: Python DNS Server 
----------------------------------------

def init(self, bind = ("0.0.0.0", 53), server = "8.8.8.8", port = 53,
verbose = False) :
INDENT
    if verbose :
    INDENT
        Debugger().register(self)
    DEDENT
    self.resolver = Resolver(server, port).register(self)
    self.server = Server(bind).register(self)

DEDENT
----------------------------------------

def init(self, server, port, channel = channel) :
INDENT
    self.server = server
    self.port = int(port)
    self.transport = UDPClient(0, channel = self.channel).register(self)
    self.protocol = DNS(channel = self.channel).register(self)
    self.handler = ReturnResponse(channel = self.channel).register(self)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37758228_37758362_10_16
37758228_37758374_11_16
Title: Python TypeError: 'type' object does not support item assignment 
----------------------------------------

def find(self, desiredSum) :
INDENT
    for nums in itertools.combinations(self.numbers, 2) :
    INDENT
        if sum(nums) == desiredSum :
        INDENT
            return True
        DEDENT
    DEDENT
    return False

DEDENT
----------------------------------------

def find(self, n) :
INDENT
    for i, v in enumerate(self.__data) :
    INDENT
        for x, v2 in enumerate(self.__data) :
        INDENT
            if i ! = x and v + v2 == n :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37758228_37758374_11_16
37758228_37758662_6_11
Title: Python TypeError: 'type' object does not support item assignment 
----------------------------------------

def find(self, n) :
INDENT
    for i, v in enumerate(self.__data) :
    INDENT
        for x, v2 in enumerate(self.__data) :
        INDENT
            if i ! = x and v + v2 == n :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------

def find(self, n) :
INDENT
    for nums in itertools.combinations(self.added_items, 2) :
    INDENT
        if sum(nums) == n :
        INDENT
            return True
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37791945_37792299_1_12
37791945_37802458_3_17
Title: python split array into runs/sequences - preferably numpy 
----------------------------------------

def split_list(list, sub_list_size = 3) :
INDENT
    sublists = []
    for i in range(0, len(list), sub_list_size) :
    INDENT
        start = i
        end = i + sub_list_size
        sublists.append(list [start : end])
    DEDENT
    return sublists

DEDENT
----------------------------------------

def split_list(mylist) :
INDENT
    d = np.diff(mylist)

    breaks = list(np.arange(len(mylist) - 1) [d ! = 1] + 1)
    slices = zip([0] + breaks, breaks + [len(mylist)])
    int_list = [mylist [a : b] for a, b in slices]
    chopped = [chop(l) for l in int_list]
    return list(chain.from_iterable(chopped))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37802129_37802176_1_8
37802129_37802193_3_16
Title: "Fibonacci in python recursively into a list" 
----------------------------------------

def Fib() :
INDENT
    a, b = 0, 1
    yield a
    yield b
    while True :
    INDENT
        a, b = b, a + b
        yield b
    DEDENT
DEDENT
----------------------------------------

def Fib(n) :
INDENT
    if arr [n] ! = - 1 :
    INDENT
        return arr [n]
    DEDENT
    if n == 0 :
    INDENT
        arr [0] = 0
        return 0
    DEDENT
    elif n == 1 :
    INDENT
        arr [1] = 1;
        return 1
    DEDENT
    else :
    INDENT
        arr [n] = Fib(n - 1) + Fib(n - 2);
        return arr [n];
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37803100_37804235_1_10
37803100_37804723_5_10
Title: How to write maximum value of tree view in odoo? 
----------------------------------------

def _amount_line(self, cr, uid, ids, field_names, arg = None, context = None) :
INDENT
    res = {}
    for obj in self.browse(cr, uid, ids, context = context) :
    INDENT
        max = 0
        for data in obj.combine2 :
        INDENT
            if data.mega_wat > max :
            INDENT
                max = data.mega_wat
            DEDENT
        DEDENT
        res [obj.id] = max
    DEDENT
    return res
DEDENT
----------------------------------------

def _amount_line(self, cr, uid, ids, context = None) :
INDENT
    res = {}
    for fd in self.browse(cr, uid, ids, context) :
    INDENT
        res [fd.id] = max([dv.mega_wat for dv in fd.combine2])
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3783626_3783647_3_28
3783626_5286267_3_22
Title: Regular expression to parse a commented configuration file 
----------------------------------------

def fn(line) :
INDENT
    comment = ""
    if line [0] == "#" :
    INDENT
        comment = line
        line = ""
    DEDENT
    else :
    INDENT
        idx = re.search(r"[^\\]#", line)
        if idx ! = None :
        INDENT
            comment = line [idx.start() + 1 :]
            line = line [: idx.start() + 1]

        DEDENT
    DEDENT
    idx = re.search(r"=", line)
    if idx == None :
    INDENT
        key = line
        val = ""
    DEDENT
    else :
    INDENT
        key = line [: idx.start()]
        val = line [idx.start() + 1 :]
    DEDENT
    val = val.replace("\\#", "#")
    return (key.strip(), val.strip(), comment.strip())
DEDENT
----------------------------------------

def fn(line) :
INDENT
    match = re.search(
        r"""^          # Anchor to start of line
        (\s*)          # $1: Zero or more leading ws chars
        (?:            # Begin group for optional var=value.
          (\S+)        # $2: Variable name. One or more non-spaces.
          (\s*=\s*)    # $3: Assignment operator, optional ws
          (            # $4: Everything up to comment or EOL.
            [^#\\]*    # Unrolling the loop 1st normal*.
            (?:        # Begin (special normal*)* construct.
              \\.      # special is backslash-anything.
              [^#\\]*  # More normal*.
            )*         # End (special normal*)* construct.
          )            # End $4: Value.
        )?             # End group for optional var=value.
        ((?:\#.*)?)    # $5: Optional comment.
        $              # Anchor to end of line""",
        line, re.MULTILINE | re.VERBOSE)
    return match.groups()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37877895_37878226_1_21
37877895_37878423_1_25
Title: How to round a number to a chosen integer 
----------------------------------------

def roundGrade(grades) :
INDENT
    if (- 5 < grades < - 1.5) :
    INDENT
        gradesRounded = - 3
    DEDENT
    elif (- 1.5 < = grades < 1.5) :
    INDENT
        gradesRounded = 00
    DEDENT
    elif (1.5 < = grades < 3) :
    INDENT
        gradesRounded = 2
    DEDENT
    elif (3 < = grades < 5.5) :
    INDENT
        gradesRounded = 4
    DEDENT
    elif (5.5 < = grades < 8.5) :
    INDENT
        gradesRounded = 7
    DEDENT
    elif (8.5 < = grades < 11) :
    INDENT
        gradesRounded = 10
    DEDENT
    elif (11 < = grades < 15) :
    INDENT
        gradesRounded = 12
    DEDENT
    return gradesRounded

DEDENT
----------------------------------------

def roundGrade(grades_in) :
INDENT
    grades_out = []
    for grades in grades_in :
    INDENT
        if grades < - 5 or grades > 15 :
        INDENT
            gradesRounded = '??'
            print ('Grade input out of range ({:})!'.format(grades))
        DEDENT
        if (- 5 < grades < - 1.5) :
        INDENT
            gradesRounded = '-3'
        DEDENT
        elif (- 1.5 < = grades < 1.5) :
        INDENT
            gradesRounded = '00'
        DEDENT
        elif (1.5 < = grades < 3) :
        INDENT
            gradesRounded = '2'
        DEDENT
        elif (3 < = grades < 5.5) :
        INDENT
            gradesRounded = '4'
        DEDENT
        elif (5.5 < = grades < 8.5) :
        INDENT
            gradesRounded = '7'
        DEDENT
        elif (8.5 < = grades < 11) :
        INDENT
            gradesRounded = '10'
        DEDENT
        elif (11 < = grades < 15) :
        INDENT
            gradesRounded = '12'
        DEDENT
        grades_out.append(gradesRounded)
    DEDENT
    return grades_out
    grades_in = [- 7, - 2.1, 0.1, 6.3, 8.9, 9]
    print (roundGrade(grades_in))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37878815_37879391_1_7
37878815_37880433_1_9
Title: Automatically change def. parameter by using loop 
----------------------------------------

def test(x, y, z) :
INDENT
    for i in range(12) :
    INDENT
        x -= z
        x *= 1 + y
    DEDENT
    return x

DEDENT
----------------------------------------

def test(x, y, z) :
INDENT
    count = 0
    while count ! = 12 :
    INDENT
        x -= z
        x = x * ((1 + y))
        count += 1
    DEDENT
    print "test", x, y, z, count
    return x
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37883015_37914677_23_31
37883015_38039701_17_29
Title: using decorators to persist python objects 
----------------------------------------

def new_func(* args) :
INDENT
    if tuple(args) not in cache :
    INDENT
        cache [tuple(args)] = original_func(* args)

        save_data()
    DEDENT
    return cache [args]
DEDENT
----------------------------------------

def new_func(* args) :
INDENT
    try :
    INDENT
        try :
        INDENT
            hash(args)
        DEDENT
        except TypeError :
        INDENT
            return original_func(* args)
        DEDENT
        if tuple(args) not in cache :
        INDENT
            cache [tuple(args)] = original_func(* args)
            save_data()
        DEDENT
        return cache [args]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37883015_37914677_7_33
37883015_38039701_7_31
Title: using decorators to persist python objects 
----------------------------------------

def decorator(original_func) :
INDENT
    try :
    INDENT
        cache = pickle.load(open(filename, 'r'))
    DEDENT
    except (IOError, ValueError) :
    INDENT
        cache = {}

    DEDENT
    def save_data() :
    INDENT
        pickle.dump(cache, open(filename, "w"))

    DEDENT
    @ functools.wraps(original_func)
    def new_func(* args) :
    INDENT
        if tuple(args) not in cache :
        INDENT
            cache [tuple(args)] = original_func(* args)

            save_data()
        DEDENT
        return cache [args]
    DEDENT
    return new_func
DEDENT
----------------------------------------

def decorator(original_func) :
INDENT
    try :
    INDENT
        cache = pickle.load(open(filename, 'r'))
    DEDENT
    except (IOError, ValueError) :
    INDENT
        cache = {}
    DEDENT
    def save_data() :
    INDENT
        pickle.dump(cache, open(filename, "w"))
    DEDENT
    @ functools.wraps(original_func)
    def new_func(* args) :
    INDENT
        try :
        INDENT
            try :
            INDENT
                hash(args)
            DEDENT
            except TypeError :
            INDENT
                return original_func(* args)
            DEDENT
            if tuple(args) not in cache :
            INDENT
                cache [tuple(args)] = original_func(* args)
                save_data()
            DEDENT
            return cache [args]
        DEDENT
    DEDENT
    return new_func
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3789372_34301571_1_28
3789372_3789491_1_16
Title: Python: Can we convert a ctypes structure to a dictionary? 
----------------------------------------

def getdict(struct) :
INDENT
    result = {}
    def get_value(value) :
    INDENT
        if (type(value) not in [int, long, float, bool]) and not bool(value) :
        INDENT

            value = None
        DEDENT
        elif hasattr(value, "_length_") and hasattr(value, "_type_") :
        INDENT

            value = get_array(value)
        DEDENT
        elif hasattr(value, "_fields_") :
        INDENT

            value = getdict(value)
        DEDENT
        return value
    DEDENT
    def get_array(array) :
    INDENT
        ar = []
        for value in array :
        INDENT
            value = get_value(value)
            ar.append(value)
        DEDENT
        return ar
    DEDENT
    for f in struct._fields_ :
    INDENT
        field = f [0]
        value = getattr(struct, field)
        value = get_value(value)
        result [field] = value
    DEDENT
    return result
DEDENT
----------------------------------------

def getdict(struct) :
INDENT
    result = {}
    for field, _ in struct._fields_ :
    INDENT
        value = getattr(struct, field)
        if (type(value) not in [int, long, float, bool]) and not bool(value) :
        INDENT

            value = None
        DEDENT
        elif hasattr(value, "_length_") and hasattr(value, "_type_") :
        INDENT

            value = list(value)
        DEDENT
        elif hasattr(value, "_fields_") :
        INDENT

            value = getdict(value)
        DEDENT
        result [field] = value
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37894253_37894656_1_8
37894253_37894881_1_8
Title: "How to find an item in a list (without using ""in"" method)?" 
----------------------------------------

def search(a_list, value) :
INDENT
    for item in a_list :
    INDENT
        if item == value :
        INDENT
            print ("Value found")
            break
        DEDENT
    DEDENT
    else :
    INDENT
        print ("Value not found")
    DEDENT
DEDENT
----------------------------------------

def search(inset, item) :
INDENT
    print(item, end = "")
    if inset & set((item,)) :
    INDENT
        print (" found")
    DEDENT
    else :
    INDENT
        print (" not found")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37929016_37931273_17_33
37929016_37931273_41_57
Title: RuntimeError: Can not put single artist in more than one figure when using matplotlib 1.5 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    tk.Tk.wm_title(self, "Example")
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    frame = Example(container, self)
    self.frames [Example] = frame
    frame.grid(row = 0, column = 0, sticky = "nsew")
    self.show_frame(Example)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    self.canvas = FigureCanvasTkAgg(first_figure, self)
    self.canvas.get_tk_widget().pack()
    self.toolbar = NavigationToolbar2TkAgg(self.canvas, self)
    self.toolbar.update()
    self.canvas._tkcanvas.pack(fill = tk.BOTH, expand = True)
    plot1_sub1.plot([1, 2, 3])
    plot1_sub2.plot([4, 5, 6])
    plot2_sub1.plot([4, 5, 6])
    plt.text(.5, 1.5, '211', figure = plot1_sub1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37929956_37929989_9_19
37929956_51621527_9_15
Title: when i do yield from inside __next__. why does it return generator object? 
----------------------------------------

def __next__(self) :
INDENT
    if self._ix is None :
    INDENT
        self._ix = 0
    DEDENT
    try :
    INDENT
        item = self.s [self._ix]
    DEDENT
    except IndexError :
    INDENT
        raise StopIteration
    DEDENT
    self._ix += 1
    return item
DEDENT
----------------------------------------

def __next__(self) :
INDENT
    self.index += 1
    if self.index > = len(self.s) :
    INDENT
        raise StopIteration
    DEDENT
    return self.s [self.index]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37930408_37930501_1_17
37930408_37930542_1_15
Title: breaking a loop when enter is pressed 
----------------------------------------

def main() :
INDENT
    myfile = open('friends.txt', 'w')
    friend = raw_input('Enter first name of friend or Enter to quit')
    age = int(raw_input('Enter age (integer) of this friend'))
    while friend ! = '' :
    INDENT
        while True :
        INDENT
            myfile.write(friend + '\n')
            myfile.write(str(age) + '\n')
            friend = raw_input('Enter first name of friend or Enter to quit')
            if not friend :
            INDENT
                break
            DEDENT
            age = int(raw_input('Enter age (integer) of this friend'))
        DEDENT
        print ('File was created')
        myfile.close()
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    myfile = open('friends.txt', 'w')
    while True :
    INDENT
        friend = input('Enter first name of friend or Enter to quit: ')
        if not friend :
        INDENT
            myfile.close()
            break
        DEDENT
        else :
        INDENT
            age = input('Enter age (integer) of this friend: ')
            myfile.write(friend + '\n')
            myfile.write(str(age) + '\n')

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37931927_37932098_1_19
37931927_50762571_4_15
Title: Why is flask's jsonify method slow? 
----------------------------------------

def jsonify(* args, ** kwargs) :
INDENT
    indent = None
    separators = (',', ':')
    if current_app.config ['JSONIFY_PRETTYPRINT_REGULAR'] and not request.is_xhr :
    INDENT
        indent = 2
        separators = (', ', ': ')
    DEDENT
    if args and kwargs :
    INDENT
        raise TypeError('jsonify() behavior undefined when passed both args and kwargs')
    DEDENT
    elif len(args) == 1 :
    INDENT
        data = args [0]
    DEDENT
    else :
    INDENT
        data = args or kwargs
    DEDENT
    return current_app.response_class(
        (dumps(data, indent = indent, separators = separators), '\n'),
        mimetype = current_app.config ['JSONIFY_MIMETYPE'])
DEDENT
----------------------------------------

def jsonify(* args, ** kwargs) :
INDENT
    if args and kwargs :
    INDENT
        raise TypeError('jsonify() behavior undefined when passed both args and kwargs')
    DEDENT
    elif len(args) == 1 :
    INDENT
        data = args [0]
    DEDENT
    else :
    INDENT
        data = args or kwargs
    DEDENT
    return current_app.response_class(
        dumps(data) + '\n',
        mimetype = current_app.config ['JSONIFY_MIMETYPE'])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37941039_37956012_16_27
37941039_37956012_5_14
Title: PyQt transparent background image partially black 
----------------------------------------

def __init__(self) :
INDENT
    super(BackgroundIssue, self).__init__()
    self._widget = BackgroundWidget()
    self.setCentralWidget(self._widget)
    self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
    self.setAttribute(QtCore.Qt.WA_TranslucentBackground, True)
    self.resize(1002, 660)
    self.setWindowTitle("Partially Black Background Image")
    self.show()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(BackgroundWidget, self).__init__()
    palette = QtGui.QPalette()
    palette.setBrush(QtGui.QPalette.Background, QtGui.QBrush(QtGui.QPixmap("res/img/background.png")))
    self.setAutoFillBackground(True)
    self.setPalette(palette)
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37943629_37944307_14_23
37943629_37944580_11_28
Title: Function not called by reference causes self.root to be None 
----------------------------------------

def insertt(self, root, node) :
INDENT
    if root == None :
    INDENT
        root = node
    DEDENT
    elif node.data < root.data :
    INDENT
        root.left = self.insertt(root.left, node)
    DEDENT
    else :
    INDENT
        root.right = self.insertt(root.right, node)
    DEDENT
    return root
DEDENT
----------------------------------------

def insertt(self, root, data) :
INDENT
    if root == None :
    INDENT

        self.root = node(data)
    DEDENT
    else :
    INDENT
        if root.data > data :
        INDENT
            if root.left == None :
            INDENT
                root.left = node(data)
            DEDENT
            else :
            INDENT
                self.insertt(root.left, data)
            DEDENT
        DEDENT
        else :
        INDENT
            if root.right == None :
            INDENT
                root.right = node(data)
            DEDENT
            else :
            INDENT
                self.insertt(root.right, data)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37943629_37944307_27_34
37943629_37944580_31_36
Title: Function not called by reference causes self.root to be None 
----------------------------------------

def printtall(self, root, indent) :
INDENT
    if root == None :
    INDENT
        print ". " * indent + "(empty)"
    DEDENT
    else :
    INDENT
        print ". " * indent + str(root.data)
        self.printtall(root.left, indent + 1)
        self.printtall(root.right, indent + 1)
    DEDENT
DEDENT
----------------------------------------

def printtall(self, root) :
INDENT
    if root ! = None :
    INDENT
        self.printtall(root.left)
        print (root.data)
        self.printtall(root.right)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37948996_37949617_1_15
37948996_37949966_16_23
Title: python dictionary iteration usage error 
----------------------------------------

def scan(* words) :
INDENT
    src = {frozenset(direction) : 'direction',
        frozenset(verb) : 'verb',
        frozenset(stop) : 'stop',
        frozenset(noun) : 'noun',
        frozenset(number) : 'number'}
    for word in words :
    INDENT
        for k, v in src.items() :
        INDENT
            if word in k :
            INDENT
                yield word, v
                break
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def scan(word, * words) :
INDENT
    words = word.split() if not words else words
    for word in words :
    INDENT
        for k, v in src.items() :
        INDENT
            if word in v :
            INDENT
                print ((word, k))
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37965669_51251614_3_25
37965669_52457536_8_24
Title: How do I link the CrossHairTool in bokeh over several plots? 
----------------------------------------

def add_vlinked_crosshairs(fig1, fig2) :
INDENT
    cross1 = CrosshairTool()
    cross2 = CrosshairTool()
    fig1.add_tools(cross1)
    fig2.add_tools(cross2)
    js_move = '''
        if(cb_obj.x >= fig.x_range.start && cb_obj.x <= fig.x_range.end &&
           cb_obj.y >= fig.y_range.start && cb_obj.y <= fig.y_range.end)
        {
            cross.spans.height.computed_location = cb_obj.sx
        }
        else
        {
            cross.spans.height.computed_location = null
        }
    '''
    js_leave = 'cross.spans.height.computed_location = null'
    args = {'cross' : cross2, 'fig' : fig1}
    fig1.js_on_event('mousemove', CustomJS(args = args, code = js_move))
    fig1.js_on_event('mouseleave', CustomJS(args = args, code = js_leave))
    args = {'cross' : cross1, 'fig' : fig2}
    fig2.js_on_event('mousemove', CustomJS(args = args, code = js_move))
    fig2.js_on_event('mouseleave', CustomJS(args = args, code = js_leave))
DEDENT
----------------------------------------

def add_vlinked_crosshairs(fig1, fig2) :
INDENT
    cross1 = CrosshairTool()
    cross2 = CrosshairTool()
    fig1.add_tools(cross1)
    fig2.add_tools(cross2)
    js_move = '''if(cb_obj.x >= fig.x_range.start && cb_obj.x <= fig.x_range.end && cb_obj.y >= fig.y_range.start && cb_obj.y <= fig.y_range.end)
                    { cross.spans.height.computed_location = cb_obj.sx }
                 else 
                    { cross.spans.height.computed_location = null }'''
    js_leave = 'cross.spans.height.computed_location = null'
    args = {'cross' : cross2, 'fig' : fig1}
    fig1.js_on_event('mousemove', CustomJS(args = args, code = js_move))
    fig1.js_on_event('mouseleave', CustomJS(args = args, code = js_leave))
    args = {'cross' : cross1, 'fig' : fig2}
    fig2.js_on_event('mousemove', CustomJS(args = args, code = js_move))
    fig2.js_on_event('mouseleave', CustomJS(args = args, code = js_leave))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37981121_37981259_1_10
37981121_37981570_1_8
Title: How to print strings from a defined function 
----------------------------------------

def me() :
INDENT
    myName = raw_input("What is your name? ")
    myAge = int(raw_input("How old are you? "))
    myHeight = int(raw_input("How tall are you? "))
    myJob = raw_input("What is your job? ")
    print myName
    print myAge
    print myHeight
    print myJob
DEDENT
----------------------------------------

def me() :
INDENT
    info = dict()
    info ['name'] = raw_input("What is your name? ")
    info ['age'] = int(raw_input("How old are you? "))
    info ['height'] = int(raw_input("How tall are you? "))
    info ['job'] = raw_input("What is your job? ")
    return info
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
37998300_38001061_5_14
37998300_38016024_5_10
Title: python gettext: specify locale in _() 
----------------------------------------

def translation_function(language) :
INDENT
    try :
    INDENT
        lang = gettext.translation('simple', localedir = 'locale', languages = [language])
        lang.install()
        while True :
        INDENT
            print (_("Running translator"), ": %s" % language)
            time.sleep(1.0)
        DEDENT
    DEDENT
    except KeyboardInterrupt :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def translation_function(quit_flag, language) :
INDENT
    lang = gettext.translation('simple', localedir = 'locale', languages = [language])
    while not quit_flag.is_set() :
    INDENT
        print (lang.gettext("Running translator"), ": %s" % language)
        time.sleep(1.0)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38020127_38020981_10_14
38020127_38150268_4_10
Title: make QTableView column read-only using Python 
----------------------------------------

def flags(self, index) :
INDENT
    if (index.column() == 2) :
    INDENT
        return Qt.ItemIsEnabled | Qt.ItemIsSelectable | Qt.ItemIsEditable
    DEDENT
    else :
    INDENT
        return Qt.ItemIsEnabled | Qt.ItemIsSelectable
    DEDENT
DEDENT
----------------------------------------

def flags(self, index) :
INDENT
    if (index.column() == 4) :
    INDENT
        return QtCore.Qt.ItemIsEnabled
    DEDENT
    elif (index.column() == 6) :
    INDENT
        return QtCore.Qt.ItemIsEnabled
    DEDENT
    else :
    INDENT
        return QtCore.Qt.ItemIsEnabled | QtCore.Qt.ItemIsSelectable | QtCore.Qt.ItemIsEditable
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38034984_38035014_3_18
38034984_38035881_4_23
Title: Python requests post doing nothing 
----------------------------------------

def login(self, usr, pw) :
INDENT
    login_url = 'https://kissanime.to/Login'
    sess = requests.Session()

    payload = {
        'username' : usr,
        'password' : pw,
        'redirect' : ''}

    scraper_sess = cfscrape.create_scraper(sess)
    a = scraper_sess.post(login_url, data = json.dumps(payload))
    print (a.text)
    print (a.status_code)
DEDENT
----------------------------------------

def login(self, usr, pw) :
INDENT
    login_url = 'https://kissanime.to/Login'

    self.r = cfscrape.create_scraper()
    login_page = self.r.get(login_url)

    browser = mechanicalsoup.Browser(self.r)
    soup = BeautifulSoup(login_page.text, 'html.parser')

    login_form = soup.find('form', {'id' : 'formLogin'})

    login_form.find('input', {'name' : 'username'}) ['value'] = usr
    login_form.find('input', {'name' : 'password'}) ['value'] = pw
    browser.submit(login_form, login_page.url)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38056_11784942_5_23
38056_7008599_1_14
Title: How do you check in Linux with Python if a process is still running? 
----------------------------------------

def process_exists(proc, id = 0) :
INDENT
    ps = subprocess.Popen("ps -A", shell = True, stdout = subprocess.PIPE)
    ps_pid = ps.pid
    output = ps.stdout.read()
    ps.stdout.close()
    ps.wait()
    for line in output.split("\n") :
    INDENT
        if line ! = "" and line ! = None :
        INDENT
            fields = line.split()
            pid = fields [0]
            pname = fields [3]
            if (id == 0) :
            INDENT
                if (pname == proc) :
                INDENT
                    return True
                DEDENT
            DEDENT
            else :
            INDENT
                if (pid == proc) :
                INDENT
                    return True
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def process_exists(proc_name) :
INDENT
    ps = subprocess.Popen("ps ax -o pid= -o args= ", shell = True, stdout = subprocess.PIPE)
    ps_pid = ps.pid
    output = ps.stdout.read()
    ps.stdout.close()
    ps.wait()
    for line in output.split("\n") :
    INDENT
        res = re.findall("(\d+) (.*)", line)
        if res :
        INDENT
            pid = int(res [0] [0])
            if proc_name in res [0] [1] and pid ! = os.getpid() and pid ! = ps_pid :
            INDENT
                return True
            DEDENT
        DEDENT
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38066944_38067012_1_13
38066944_38067068_1_11
Title: Converting ratio to floating points 
----------------------------------------

def ratio_to_float(ratio) :
INDENT
    res = []
    for r in ratio :
    INDENT
        [numer, denum] = r.split(":")
        numer = int(numer)
        denum = int(denum)
        if denum == 0 :
        INDENT
            num = math.inf
        DEDENT
        else :
        INDENT
            num = (numer) / (denum)
        DEDENT
        res.append(num)
    DEDENT
    return res
DEDENT
----------------------------------------

def ratio_to_float(ratio) :
INDENT
    try :
    INDENT
        numer, denum = ratio.split(" : ")
    DEDENT
    except ValueError :
    INDENT
        print (repr(ratio))
        raise
    DEDENT
    if int(denum) == 0 :
    INDENT
        num = math.inf
    DEDENT
    else :
    INDENT
        num = int(numer) / int(denum)
    DEDENT
    return num
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38066944_38067012_1_13
38066944_38067383_6_15
Title: Converting ratio to floating points 
----------------------------------------

def ratio_to_float(ratio) :
INDENT
    res = []
    for r in ratio :
    INDENT
        [numer, denum] = r.split(":")
        numer = int(numer)
        denum = int(denum)
        if denum == 0 :
        INDENT
            num = math.inf
        DEDENT
        else :
        INDENT
            num = (numer) / (denum)
        DEDENT
        res.append(num)
    DEDENT
    return res
DEDENT
----------------------------------------

def ratio_to_float(value) :
INDENT
    if not isinstance(value, str) :
    INDENT
        return value
    DEDENT
    s = value.translate(str.maketrans(':', '/', ' '))
    try :
    INDENT
        return float(Fraction(s))
    DEDENT
    except ZeroDivisionError :
    INDENT
        return pd.np.nan
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38066944_38067068_1_11
38066944_38067383_6_15
Title: Converting ratio to floating points 
----------------------------------------

def ratio_to_float(ratio) :
INDENT
    try :
    INDENT
        numer, denum = ratio.split(" : ")
    DEDENT
    except ValueError :
    INDENT
        print (repr(ratio))
        raise
    DEDENT
    if int(denum) == 0 :
    INDENT
        num = math.inf
    DEDENT
    else :
    INDENT
        num = int(numer) / int(denum)
    DEDENT
    return num
DEDENT
----------------------------------------

def ratio_to_float(value) :
INDENT
    if not isinstance(value, str) :
    INDENT
        return value
    DEDENT
    s = value.translate(str.maketrans(':', '/', ' '))
    try :
    INDENT
        return float(Fraction(s))
    DEDENT
    except ZeroDivisionError :
    INDENT
        return pd.np.nan
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38107874_38108133_4_13
38107874_38108870_5_12
Title: Beautifulsoup4 - Trying to get the data using a while loop 
----------------------------------------

def check() :
INDENT
    url = 'https://somewebsite.net/'
    source_code = requests.get(url)
    plain_text = source_code.text
    soup = BeautifulSoup(plain_text, 'html.parser')
    for a in soup.findAll('a') :
    INDENT
        if a.has_attr('href') :
        INDENT
            print ('b')
        DEDENT
        else :
        INDENT
            print ('a')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def check() :
INDENT
    url = 'https://somewebsite.net/'
    source_code = requests.get(url)
    plain_text = source_code.text
    soup = BeautifulSoup(plain_text, 'html.parser')
    return soup.find("a", href = True)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38128337_38129071_1_12
38128337_38129247_2_13
Title: While loop break condition not working 
----------------------------------------

def cinpt() :
INDENT
    with open("test", 'r') as finp :
    INDENT
        inside_region_of_interest = False
        for line in finp :
        INDENT
            if line.strip().startswith("start") :
            INDENT
                inside_region_of_interest = True
            DEDENT
            elif line.startswith("---------------") :
            INDENT
                inside_region_of_interest = False
            DEDENT
            elif inside_region_of_interest :
            INDENT
                sdata = line
                print (sdata.strip())
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def cinpt() :
INDENT
    with open("test", 'r') as finp :
    INDENT
        started = False
        for line in finp :
        INDENT
            if started :
            INDENT
                if line.startswith("---------------") :
                INDENT
                    break
                DEDENT
                else :
                INDENT
                    print (line.strip())
                DEDENT
            DEDENT
            elif line.strip().startswith("start") :
            INDENT
                started = True
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38138842_44039063_4_23
38138842_51152323_1_7
Title: How to check whether two words are anagrams python 
----------------------------------------

def anagram(a, b) :
INDENT
    arra = split(a)
    arrb = split(b)
    arra.sort()
    arrb.sort()
    if (len(arra) == len(arrb)) :
    INDENT
        if (arra == arrb) :
        INDENT
            print ("True")
        DEDENT
        else :
        INDENT
            ana = 0;
            print ("False");
        DEDENT
    DEDENT
    else :
    INDENT
        print ("False");
    DEDENT
DEDENT
----------------------------------------

def anagram(str1, str2) :
INDENT
    l1 = list(str1)
    l2 = list(str2)
    if sorted(l1) == sorted(l2) :
    INDENT
        print ("yess")
    DEDENT
    else :
    INDENT
        print ("noo")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38149955_38150089_7_14
38149955_44840480_1_13
Title: "Iterating again prime factors loop python" 
----------------------------------------

def prime_factors(n) :
INDENT
    L = []
    i = range(1, n + 1)
    for x in i :
    INDENT
        if n % x == 0 :
        INDENT
            if is_prime(x) :
            INDENT
                L.append(x)
            DEDENT
        DEDENT
    DEDENT
    return L
DEDENT
----------------------------------------

def prime_factors(n) :
INDENT
    L = []
    i = range(2, n + 1)
    for x in i :
    INDENT
        if n % x == 0 :
        INDENT
            L.append(x)
            while n % x == 0 :
            INDENT
                n = n / x
            DEDENT
        DEDENT
        if n == 1 :
        INDENT
            break
        DEDENT
    DEDENT
    return L
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38161065_38161105_10_16
38161065_38161808_13_17
Title: Newbie Debugging a Python Code 
----------------------------------------

def create(self) :
INDENT
    a = C(self, self.count)
    for i in range(10) :
    INDENT
        a.print_name()
    DEDENT
    print self.items
DEDENT
----------------------------------------

def create(self) :
INDENT
    a = C(self.count)
    for i in range(10) :
    INDENT
        a.print_name()
    DEDENT
    print C.b
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38171017_38171918_19_34
38171017_38175123_1_23
Title: Python - breaking while loop with function (Raspberry Pi) 
----------------------------------------

def main() :
INDENT
    k = 0
    cancel = Cancel()
    while True :
    INDENT
        l.clear()
        b.hue(1.5)
        l.set_cursor_position(0, 1)
        l.write("%s" % k)
        if cancel.is_cancelled :
        INDENT
            break
        DEDENT
        k = k + 1
        sleep(1)
    DEDENT
    l.clear()
    b.off()
    signal.pause()
    exit(0)
DEDENT
----------------------------------------

def main() :
INDENT
    global i
    i = 0
    k = 0
    while True :
    INDENT
        l.clear()
        b.hue(1.5)
        l.set_cursor_position(0, 1)
        l.write("%s" % k)
        @ t.on(t.CANCEL)
        def cancel(ch, evt) :
        INDENT
            global i
            i = 1
            return
        DEDENT
        if i == 1 :
        INDENT
            break
        DEDENT
        k = k + 1
        sleep(1)
    DEDENT
    l.clear()
    b.off()
    cmd = 'pkill python'
    os(cmd)
    signal.pause()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38177013_38177299_1_15
38177013_38177333_1_18
Title: Calculating square root using only integer math in python 
----------------------------------------

def isqrt(n) :
INDENT
    if n > = 0 :
    INDENT
        if n == 0 :
        INDENT
            return 0
        DEDENT
        a, b = divmod(n.bit_length(), 2)
        x = 2 ** (a + b)
        while True :
        INDENT
            y = (x + n / / x) >> 1
            if y > = x :
            INDENT
                return x
            DEDENT
            x = y
        DEDENT
    DEDENT
    else :
    INDENT
        raise ValueError("negative number")
    DEDENT
DEDENT
----------------------------------------

def isqrt(n) :
INDENT
    if n < = 1 :
    INDENT
        return n
    DEDENT
    hi, hisq = 2, 4
    while hisq < = n :
    INDENT
        hi <<= 1
        hisq <<= 2
    DEDENT
    lo = hi >> 1
    while hi - lo > 1 :
    INDENT
        mid = (lo + hi) >> 1
        if mid * mid < = n :
        INDENT
            lo = mid
        DEDENT
        else :
        INDENT
            hi = mid
        DEDENT
    DEDENT
    assert lo + 1 == hi
    assert lo ** 2 < = n < hi ** 2
    return lo
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38192974_38193321_3_32
38192974_38193891_1_19
Title: How can I return similar filenames on one line 
----------------------------------------

def main() :
INDENT
    directory = input("What is the directory? ")
    current = None
    similar = []
    for file in sorted(os.listdir(directory)) :
    INDENT
        if file.endswith(".wav") :
        INDENT
            with wave.open(file, 'rb') as f :
            INDENT
                frames = f.getnframes()
                rate = f.getframerate()
            DEDENT
            total_seconds = frames / float(rate)
            minutes = total_seconds / 60
            seconds = total_seconds % 60
            hours = minutes / 60
            minutes = minutes % 60
            duration = '%.2d:%.2d:%.2d' % (hours, minutes, seconds)
            txt = file [: - 4] + " " + duration
            value = file.split("-") [3]
            if not current == None :
            INDENT
                if value == current :
                INDENT
                    similar.append(txt)
                DEDENT
                else :
                INDENT
                    print (" ".join(similar))
                    similar = []
                DEDENT
            DEDENT
            else :
            INDENT
                current = value
                similar.append(txt)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    directory = input("What is the directory? ")
    dic_file = {}
    list_file = []
    for file in sorted(os.listdir(directory)) :
    INDENT
        if file.endswith(".wav") :
        INDENT
            with wave.open(file, 'rb') as f :
            INDENT
                frames = f.getnframes()
                rate = f.getframerate()
                total_seconds = frames / float(rate)
                minutes = total_seconds / 60
                seconds = total_seconds % 60
                hours = minutes / 60
                minutes = minutes % 60
                duration = '%.2d:%.2d:%.2d' % (hours, minutes, seconds)
                list_file.append(file)
                dic_file.setdefault(file, duration)
            DEDENT
        DEDENT
    DEDENT
    return dic_file, list_file
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3819354_19616433_5_17
3819354_5928294_4_16
Title: In Tkinter is there any way to make a widget not visible?  
----------------------------------------

def __init__(self, parent, title = "How to Cheat and Hide Text") :
INDENT
    Toplevel.__init__(self, parent)
    parent.geometry("250x250+100+150")
    if title :
    INDENT
        self.title(title)
    DEDENT
    parent.withdraw()
    self.parent = parent
    self.result = None
    dialog = Frame(self)
    self.initial_focus = self.dialog(dialog)
    dialog.pack()

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    self.frame = tk.Frame(self)
    self.frame.pack(side = "top", fill = "both", expand = True)
    self.label = tk.Label(self, text = "Hello, world")
    button1 = tk.Button(self, text = "Click to hide label",
        command = self.hide_label)
    button2 = tk.Button(self, text = "Click to show label",
        command = self.show_label)
    self.label.pack(in_ = self.frame)
    button1.pack(in_ = self.frame)
    button2.pack(in_ = self.frame)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38199616_38506107_30_38
38199616_52170048_36_47
Title: How to put a table into a QMessageBox 
----------------------------------------

def addTableWidget(self, parentItem) :
INDENT
    self.tableWidget = QtGui.QTableWidget(parentItem)
    self.tableWidget.setGeometry(QtCore.QRect(0, 0, 540, 250))
    self.tableWidget.setObjectName('tableWidget')
    self.tableWidget.setColumnCount(5)
    self.tableWidget.setRowCount(6)

DEDENT
----------------------------------------

def addTableWidget(self, parentItem) :
INDENT
    self.l = QtWidgets.QVBoxLayout()
    self.tableWidget = QtWidgets.QTableWidget(parentItem)
    self.tableWidget.setObjectName('tableWidget')
    self.tableWidget.setColumnCount(5)
    self.tableWidget.setRowCount(6)
    self.tableWidget.move(30, 80)
    self.tableWidget.resize(500, 170)
    self.l.addWidget(self.tableWidget)
    self.setLayout(self.l)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38199616_38506107_5_29
38199616_52170048_5_35
Title: How to put a table into a QMessageBox 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QMessageBox.__init__(self)
    self.setSizeGripEnabled(True)
    self.setWindowTitle('Hello MessageBox ???')

    self.addButton(QtGui.QPushButton('Accept'), QtGui.QMessageBox.YesRole)
    self.addButton(QtGui.QPushButton('Reject'), QtGui.QMessageBox.NoRole)
    self.addButton(QtGui.QPushButton('Cancel'), QtGui.QMessageBox.RejectRole)

    self.addTableWidget(self)

    currentClick = self.exec_()
    if currentClick == 0 :
    INDENT
        print 'Accept'
    DEDENT
    if currentClick == 1 :
    INDENT
        print 'Reject'
    DEDENT
    if currentClick == 2 :
    INDENT
        print 'Cancel'
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    QtWidgets.QMessageBox.__init__(self)
    self.setSizeGripEnabled(True)
    self.setWindowTitle('Hello MessageBox ???')
    self.setIcon(self.Question)
    self.setText("Hello MessageBox")
    self.addButton(
        QtWidgets.QPushButton('Accept'),
        QtWidgets.QMessageBox.YesRole)
    self.addButton(
        QtWidgets.QPushButton('Reject'),
        QtWidgets.QMessageBox.NoRole)
    self.addButton(
        QtWidgets.QPushButton('Cancel'),
        QtWidgets.QMessageBox.RejectRole)
    self.addTableWidget(self)
    currentClick = self.exec_()
    if currentClick == 0 :
    INDENT
        print ('Accept')
    DEDENT
    if currentClick == 1 :
    INDENT
        print ('Reject')
    DEDENT
    if currentClick == 2 :
    INDENT
        print ('Cancel')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38212206_38216153_12_24
38212206_38216153_2_10
Title: tkinter Multiple Buttons Colour Change 
----------------------------------------

def __init__(self, master) :
INDENT
    self._master = master
    self._btn_matrix = []
    for col in range(8) :
    INDENT
        row_matrix = []
        for row in range(8) :
        INDENT
            btn = tk.Button(master, text = '(%d, %d)' % (col, row), bg = 'white',
                command = lambda x = row, y = col : self.update(x, y))
            btn.grid(row = row, column = col)
            row_matrix.append(btn)
        DEDENT
        self._btn_matrix.append(row_matrix)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, master) :
INDENT
    self._master = master
    for col in range(8) :
    INDENT
        for row in range(8) :
        INDENT
            btn = tk.Button(master, text = '(%d, %d)' % (col, row), bg = 'white')
            btn ['command'] = lambda b = btn : b.config(bg = 'black')
            btn.grid(row = row, column = col)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38225164_38226320_1_17
38225164_38228737_1_10
Title: argparse - Different mandatory / available parameters per action 
----------------------------------------

def create_parser() :
INDENT
    parser = ArgumentParser(description = 'Parser for Backup / Consistency Check')
    parser.add_argument('--database', '-d', dest = 'db', help = 'Database name', choices = get_active_database_list())
    parser.add_argument('--timeout', '-t', dest = 'timeout', help = 'Timeout limit (in minutes)')
    subparsers = parser.add_subparsers()
    parser_backup = subparsers.add_parser('backup', help = 'Run a backup')
    parser_backup.set_defaults(action = 'backup')
    parser_backup.add_argument('dest', help = 'Where to backup to')
    parser_check = subparsers.add_parser('consistency_check', help = 'Run a consistency check')
    parser_check.set_defaults(action = 'consistency_check')
    parser_check.add_argument('source', help = 'What file to check for consistency')
    return parser
DEDENT
----------------------------------------

def create_parser() :
INDENT
    parser = ArgumentParser(description = 'Parser for Backup / Consistency Check')
    parser.add_argument('--database', '-d', dest = 'db', help = 'Database name', choices = get_active_database_list())
    parser.add_argument('--action', '-a', help = 'Action option', choices = actions)
    parser.add_argument('target', help = 'target for backup or check')
    parser.add_argument('--clean', '-c', help = 'Clean')
    parser.add_argument('--force', help = 'force clean')
    return parser
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38275585_38277813_17_27
38275585_38277813_28_36
Title: Adding Color to new style ipython (v5) prompt 
----------------------------------------

def in_prompt_tokens(self, cli = None) :
INDENT
    path = os.path.basename(os.getcwd())
    return [
        (Token.Prompt, '<'),
        (Token.PromptNum, '~/' + path),
        (Token.Prompt, '>'),
        (Token.Prompt, '['),
        (Token.PromptNum, str(self.shell.execution_count)),
        (Token.Prompt, ']: '),
        ]
DEDENT
----------------------------------------

def in_prompt_tokens(self, cli = None) :
INDENT
    path = os.path.basename(os.getcwd())
    return [
        (Token.PromptNum, str(self.shell.execution_count)),
        (Token.Prompt, ':'),
        (Token.PromptNum, '~/' + path),
        (Token.Prompt, '$ '),
        ]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38301595_38304133_26_53
38301595_38323121_5_32
Title: Python. Calculate dimension totals for list of dictionaries 
----------------------------------------

def calc_totals(input_list, dimension_list, aggregate) :
INDENT
    if not input_list :
    INDENT
        return []

    DEDENT
    dd = lambda : defaultdict(dd)
    result = dd()

    combos = tuple(chain.from_iterable(combinations(dimension_list, n) for n in range(1, len(dimension_list) + 1)))

    for row in src :
    INDENT
        for combo in combos :
        INDENT
            target = result

            for dim in dimensions :
            INDENT
                key = '_all_' if dim in combo else row [dim]
                target = target [key]
            DEDENT
            for metric, func in aggregate.items() :
            INDENT
                target [metric] = func(target.get(metric, 0), row [metric])

            DEDENT
        DEDENT
    DEDENT
    return list(flatten(dimension_list, result))
DEDENT
----------------------------------------

def calc_totals(input_list, dimensions, metric_func_dict) :
INDENT
    dimensions = set(dimensions)
    totals = []
    dim_combs = list(powerset(dimensions)) [1 : - 1]
    for dim_comb in dim_combs :
    INDENT
        current_dims = dimensions.difference(set(dim_comb))
        grouper = itemgetter(* current_dims)
        for key, group in groupby(sorted(input_list, key = grouper), grouper) :
        INDENT
            if type(key) == str :
            INDENT
                temp_dict = dict(zip(list(current_dims), [key]))
            DEDENT
            else :
            INDENT
                temp_dict = dict(zip(list(current_dims), key))
            DEDENT
            for metric in metric_func_dict :
            INDENT
                temp_dict [metric] = []
            DEDENT
            for item in group :
            INDENT
                for metric in metric_func_dict :
                INDENT
                    temp_dict [metric].append(item [metric])
                DEDENT
            DEDENT
            for metric in metric_func_dict :
            INDENT
                method_to_call = getattr(np, metric_func_dict [metric])
                temp_dict [metric] = method_to_call(temp_dict [metric])
            DEDENT
            for dim in dim_comb :
            INDENT
                temp_dict [dim] = '_all_'
            DEDENT
            totals.append(temp_dict)
        DEDENT
    DEDENT
    return totals
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38309911_38315578_16_37
38309911_38315578_53_63
Title: How to add a screen onto another screen in kivy? 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(VelhaGame, self).__init__(** kwargs)
    self.game_window = BoxLayout(orientation = "vertical")
    self.add_widget(self.game_window)
    self.game_table = GridLayout(cols = 3, rows = 3)
    for i in range(9) :
    INDENT
        button = Button(text = '', font_size = "100sp")
        button.bind(on_release = self.player_turn)
        self.game_table.add_widget(button)
        self.buttons.append(button)
    DEDENT
    self.player1 = True
    self.clear_button = Button(on_press = self.clear, text = 'Clear', font_size = "40sp")
    self.game_window.add_widget(self.game_table)
    self.game_window.add_widget(self.clear_button)

DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(MainMenu, self).__init__(** kwargs)
    self.cols = 1
    self.rows = 2
    self.button_play = Button(text = 'PLAY', font_size = "40sp")
    self.button_play.bind(on_release = self.play)
    self.add_widget(self.button_play)
    self.button_exit = Button(text = 'EXIT', font_size = 40)
    self.button_exit.bind(on_release = self.exit)
    self.add_widget(self.button_exit)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38322349_38323171_9_58
38322349_38323346_6_31
Title: PyQt having a status bar & menu bar QWidget 
----------------------------------------

def initUI(self) :
INDENT
    QtGui.QToolTip.setFont(QtGui.QFont('SansSerif', 10))
    self.setToolTip('This is a <b>QWidget</b> Window widget')
    exitAction = QtGui.QAction(QtGui.QIcon('exit-icon-2.png'), '&Exit', self)
    exitAction.setShortcut('Ctrl+Q')
    exitAction.setStatusTip('Exit/Terminate application')
    exitAction.triggered.connect(QtGui.qApp.quit)
    self.statusBar()
    menubar = self.menuBar()
    menubar.setToolTip('This is a <b>QWidget</b> for MenuBar')
    fileMenu = menubar.addMenu('&File')
    fileMenu.addAction(exitAction)
    toolbar = self.addToolBar('Exit')
    toolbar.addAction(exitAction)

    centralWidget = QtGui.QWidget()

    centralLayout = QtGui.QHBoxLayout()

    qbtn = QtGui.QPushButton('Quit', self)
    qbtn.setToolTip('This is a <b>QPushButton</b> widget')
    qbtn.clicked.connect(self.launchAAA)
    qbtn.resize(qbtn.sizeHint())
    qbtn.move(170, 190)

    centralLayout.addWidget(qbtn)

    centralWidget.setLayout(centralLayout)

    self.setCentralWidget(centralWidget)
    self.setGeometry(500, 180, 400, 400)
    self.setWindowTitle('Quit button with Message')
    self.show()
DEDENT
----------------------------------------

def initUI(self) :
INDENT
    QToolTip.setFont(QFont('SansSerif', 10))
    self.setToolTip('This is a <b>QWidget</b> Window widget')
    exitAction = QAction(QIcon('exit-icon-2.png'), '&Exit', self)
    exitAction.setShortcut('Ctrl+Q')
    exitAction.setStatusTip('Exit/Terminate application')
    exitAction.triggered.connect(qApp.quit)
    self.statusBar()
    menubar = self.menuBar()
    menubar.setToolTip('This is a <b>QWidget</b> for MenuBar')
    fileMenu = menubar.addMenu('&File')
    fileMenu.addAction(exitAction)
    toolbar = self.addToolBar('Exit')
    toolbar.addAction(exitAction)

    content = ExampleContent(self)
    self.setCentralWidget(content)
    self.setGeometry(500, 180, 400, 400)
    self.setWindowTitle('Quit button with Message')
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38343008_38343391_11_18
38343008_38343995_10_16
Title: Using files with python 
----------------------------------------

def enter(forbid) :
INDENT
    words = give()
    for letter in words :
    INDENT
        if letter in forbid :
        INDENT
            return False
        DEDENT
        else :
        INDENT
            print words
            return True
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def enter(forbid) :
INDENT
    words = give()
    for w in words :
    INDENT
        if all([letter not in forbid for letter in w]) :
        INDENT
            print w
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38343008_38343391_1_10
38343008_38343995_3_9
Title: Using files with python 
----------------------------------------

def give() :
INDENT
    fin = open('words2.txt', 'r')
    line = fin.readlines()
    words = []
    for line in fin :
    INDENT
        word = line.split(" ")
        for i in word :
        INDENT
            print i
            words.append(i)
        DEDENT
    DEDENT
    return words
DEDENT
----------------------------------------

def give() :
INDENT
    result = []
    with open('words2.txt', mode = 'rt') as fin :
    INDENT
        for line in fin :
        INDENT
            result += line.split()
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38346013_38347202_1_17
38346013_53541528_1_15
Title: Binary search in a Python list 
----------------------------------------

def search(lst, target) :
INDENT
    min = 0
    max = len(lst) - 1
    avg = (min + max) / 2

    while (min < max) :
    INDENT
        if (lst [avg] == target) :
        INDENT
            return avg
        DEDENT
        elif (lst [avg] < target) :
        INDENT
            return avg + 1 + search(lst [avg + 1 :], target)
        DEDENT
        else :
        INDENT
            return search(lst [: avg], target)

        DEDENT
    DEDENT
    return avg
DEDENT
----------------------------------------

def search(arr, item, start, end) :
INDENT
    if end - start == 1 :
    INDENT
        if arr [start] == item :
        INDENT
            return start
        DEDENT
        else :
        INDENT
            return - 1;
        DEDENT
    DEDENT
    halfWay = int((end - start) / 2)
    if arr [start + halfWay] > item :
    INDENT
        return search(arr, item, start, end - halfWay)
    DEDENT
    else :
    INDENT
        return search(arr, item, start + halfWay, end)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3834949_3834968_6_12
3834949_3834969_1_12
Title: Python line remover 
----------------------------------------

def fixup(filename) :
INDENT
    with open(filename) as fin :
    INDENT
        with open(filename2, "w") as fout :
        INDENT
            for line in fin :
            INDENT
                if any(item in line for item in offending) :
                INDENT
                    continue
                DEDENT
                fout.write(line)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def fixup(source, target, badWords) :
INDENT
    fin = open(source)
    fout = open(target, "w")
    for line in fin :
    INDENT
        if any((word in line) for word in badWords) :
        INDENT
            continue
        DEDENT
        fout.write(line)
    DEDENT
    fin.close()
    fout.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38351268_38351719_4_9
38351268_38351962_10_15
Title: Python - Multiple decorators to a method malfunctioning 
----------------------------------------

def my_decorator(fn) :
INDENT
    def wrapper(fn_arg1, fn_arg2) :
    INDENT
        out = fn(fn_arg1, fn_arg2)
        print "I am the wrapper and I can access the method args \"{}:{}\"".format(fn_arg1, fn_arg2)
        return out
    DEDENT
    return wrapper
DEDENT
----------------------------------------

def my_decorator(fn) :
INDENT
    def wrapper(fn_arg1, fn_arg2) :
    INDENT
        print "I am the wrapper and I can access the method args \"{}:{}\"".format(fn_arg1, fn_arg2)
        return fn(fn_arg1, fn_arg2)
    DEDENT
    return wrapper
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38352061_38359230_10_28
38352061_38359230_43_64
Title: How to SetFoucus to mainpanel or mainframe 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "Secondary Frame")
    panel = wx.Panel(self)
    msg = "Enter a Message to send to the main frame"
    instructions = wx.StaticText(panel, label = msg)
    self.msgTxt = wx.TextCtrl(panel, value = "")
    closeBtn = wx.Button(panel, label = "Send and Close")
    closeBtn.Bind(wx.EVT_BUTTON, self.onSendAndClose)
    sizer = wx.BoxSizer(wx.VERTICAL)
    flags = wx.ALL | wx.CENTER
    sizer.Add(instructions, 0, flags, 5)
    sizer.Add(self.msgTxt, 0, flags, 5)
    sizer.Add(closeBtn, 0, flags, 5)
    panel.SetSizer(sizer)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    self.frame = parent
    Publisher().subscribe(self.showFrame, ("show.mainframe"))

    self.pubsubText = wx.TextCtrl(self, value = "")

    self.pubsubText.Bind(wx.EVT_LEFT_DOWN, self.hideFrame)

    Btn = wx.Button(self, label = "Change")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.pubsubText, 0, wx.ALL | wx.CENTER, 5)
    sizer.Add(Btn, 0, wx.ALL | wx.CENTER, 5)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
383728_383983_1_11
383728_399756_3_47
Title: Can I reduce the computational complexity of this? 
----------------------------------------

def table(n) :
INDENT
    if n == 2 : return 1
    if n % 4 ! = 1 : return
    mod = 0
    a1 = n - 1
    for a in xrange(1, a1, 2) :
    INDENT
        mod += a
        while mod > = n : mod -= n
        if mod == a1 : return a / / 2 + 1
    DEDENT
DEDENT
----------------------------------------

def table(n) :
INDENT
    if n == 2 : return 1
    if n % 4 ! = 1 : return
    a1 = n - 1
    def inversemod(a, p) :
    INDENT
        x, y = xgcd(a, p)
        return x % p
    DEDENT
    def xgcd(a, b) :
    INDENT
        x_sign = 1
        if a < 0 : a = - a; x_sign = - 1
        x = 1; y = 0; r = 0; s = 1
        while b ! = 0 :
        INDENT
            (c, q) = (a % b, a / / b)
            (a, b, r, s, x, y) = (b, c, x - q * r, y - q * s, r, s)
        DEDENT
        return (x * x_sign, y)
    DEDENT
    def mul(x, y) :
    INDENT
        return ((x [0] * y [0] + a1 * y [1] * x [1]) % n, (x [0] * y [1] + x [1] * y [0]) % n)
    DEDENT
    def pow(x, nn) :
    INDENT
        ans = (1, 0)
        xpow = x
        while nn ! = 0 :
        INDENT
            if nn % 2 ! = 0 :
            INDENT
                ans = mul(ans, xpow)
            DEDENT
            xpow = mul(xpow, xpow)
            nn >>= 1
        DEDENT
        return ans
    DEDENT
    for z in range(2, n) :
    INDENT
        u, v = pow((1, z), a1 / / 2)
        if v ! = 0 :
        INDENT
            vinv = inversemod(v, n)
            if (vinv * vinv) % n == a1 :
            INDENT
                vinv %= n
                if vinv < = n / / 2 :
                INDENT
                    return vinv
                DEDENT
                else :
                INDENT
                    return n - vinv

                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38380678_38380955_29_37
38380678_38382008_1_10
Title: How can I traverse a deeply nested dictionary which has lists and other dictionaries within it in Python? 
----------------------------------------

def unpack_filter(curr_filter) :
INDENT
    for f in curr_filter ['filters'] :
    INDENT
        if 'filters' in f :
        INDENT
            unpack_filter(f)
        DEDENT
        else :
        INDENT
            for key, value in f.iteritems() :
            INDENT
                print '{0} : {1}'.format(key, value)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def unpack_filter(curr_filter) :
INDENT
    for f in curr_filter :
    INDENT
        if f == 'filters' :
        INDENT
            unpack_filter(curr_filter [f])
        DEDENT
        elif f == 'predicate' :
        INDENT
            print curr_filter [f]
        DEDENT
        elif 'filters' in f or 'predicate' in f :
        INDENT
            unpack_filter(f)
        DEDENT
        else :
        INDENT
            print f
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38408224_38408979_3_12
38408224_38546501_1_13
Title: How to calculate Eb(k) of networks with Python? 
----------------------------------------

def log_binning(x, y, bin_count = 35) :
INDENT
    max_x = np.log10(max(x))
    max_y = np.log10(max(y))
    max_base = max([max_x, max_y])
    xx = [i for i in x if i > 0]
    min_x = np.log10(np.min(xx))
    bins = np.logspace(min_x, max_base, num = bin_count)
    bin_means_y = (np.histogram(x, bins, weights = y) [0] / np.histogram(x, bins) [0])
    bin_means_x = (np.histogram(x, bins, weights = x) [0] / np.histogram(x, bins) [0])
    return bin_means_x, bin_means_y
DEDENT
----------------------------------------

def log_binning(x, y, bin_count = 50) :
INDENT
    max_x = np.log10(max(x))
    max_y = np.log10(max(y))
    max_base = max([max_x, max_y])
    xx = [i for i in x if i > 0]
    min_x = np.log10(np.min(xx))
    bins = np.logspace(min_x, max_base, num = bin_count)
    hist = np.histogram(x, bins) [0]
    nonzero_mask = np.logical_not(hist == 0)
    hist [hist == 0] = 1
    bin_means_y = (np.histogram(x, bins, weights = y) [0] / hist)
    bin_means_x = (np.histogram(x, bins, weights = x) [0] / hist)
    return bin_means_x [nonzero_mask], bin_means_y [nonzero_mask]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3842410_3843053_4_12
3842410_3843153_22_29
Title: Is there a way to cleanly exit out of a thread which is processing data from a (never-ending) generator? 
----------------------------------------

def run(self) :
INDENT
    self.generator = self.func()
    try :
    INDENT
        for x in self.generator :
        INDENT
            print x
            time.sleep(1)
        DEDENT
    DEDENT
    except GeneratorExit :
    INDENT
        pass
    DEDENT
    print 'DONE'
DEDENT
----------------------------------------

def run() :
INDENT
    try :
    INDENT
        self.running = True
        producer = Thread(target = self.produce)
        producer.start()
        self.consume()
    DEDENT
    finally :
    INDENT
        self.running = False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38437619_38438062_1_40
38437619_38438086_1_16
Title: Delete line in file 
----------------------------------------

def delete_result() :
INDENT
    with open('minigolf.txt', 'r') as f :
    INDENT
        text_file = f.readlines()

    DEDENT
    if '\r' in text_file [0] :
    INDENT
        if '\n' in text_file [0] :
        INDENT
            newline = '\r\n'
        DEDENT
        else :
        INDENT
            newline = '\r'
        DEDENT
    DEDENT
    else :
    INDENT
        newline = '\n'
    DEDENT
    text_file = [t [: - len(newline)]
        if t [- len(newline) :] == newline else t for t in text_file]
    users = set()
    for line_number, line in enumerate(text_file) :
    INDENT
        print line_number + 1, line
        users.add(line [: line.index(';')].lower())

    DEDENT
    result = None
    while not result :
    INDENT
        delete_player = raw_input('Which user do you want to delete? ')
        try :
        INDENT
            result = str(delete_player).lower()
            assert result in users
        DEDENT
        except ValueError :
        INDENT
            print ('Sorry, I couldn\'t parse that user.')
        DEDENT
        except AssertionError :
        INDENT
            print ('Sorry, I couldn\'t find that user.')
            result = None

        DEDENT
    DEDENT
    new_file = [t + newline for t in text_file
        if t [: t.index(';')].lower() ! = result]
    with open('minigolf.txt', 'w') as f :
    INDENT
        f.writelines(new_file)
    DEDENT
DEDENT
----------------------------------------

def delete_result() :
INDENT
    with open('minigolf.txt', 'r') as f :
    INDENT
        results = f.readlines()
        print (results)
    DEDENT
    user = raw_input('which user do you want to delete')
    for res in results :
    INDENT
        if user.lower() in res :
        INDENT
            results.remove(res)
            with open('minigolf.txt', 'w') as f :
            INDENT
                f.writelines(results)
                return 'user was found and removed'
            DEDENT
        DEDENT
    DEDENT
    return 'user was not found'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38437619_38438062_1_40
38437619_38438523_1_21
Title: Delete line in file 
----------------------------------------

def delete_result() :
INDENT
    with open('minigolf.txt', 'r') as f :
    INDENT
        text_file = f.readlines()

    DEDENT
    if '\r' in text_file [0] :
    INDENT
        if '\n' in text_file [0] :
        INDENT
            newline = '\r\n'
        DEDENT
        else :
        INDENT
            newline = '\r'
        DEDENT
    DEDENT
    else :
    INDENT
        newline = '\n'
    DEDENT
    text_file = [t [: - len(newline)]
        if t [- len(newline) :] == newline else t for t in text_file]
    users = set()
    for line_number, line in enumerate(text_file) :
    INDENT
        print line_number + 1, line
        users.add(line [: line.index(';')].lower())

    DEDENT
    result = None
    while not result :
    INDENT
        delete_player = raw_input('Which user do you want to delete? ')
        try :
        INDENT
            result = str(delete_player).lower()
            assert result in users
        DEDENT
        except ValueError :
        INDENT
            print ('Sorry, I couldn\'t parse that user.')
        DEDENT
        except AssertionError :
        INDENT
            print ('Sorry, I couldn\'t find that user.')
            result = None

        DEDENT
    DEDENT
    new_file = [t + newline for t in text_file
        if t [: t.index(';')].lower() ! = result]
    with open('minigolf.txt', 'w') as f :
    INDENT
        f.writelines(new_file)
    DEDENT
DEDENT
----------------------------------------

def delete_result() :
INDENT
    with open('minigolf.txt', 'r') as f :
    INDENT
        results = f.readlines()
        print "\n".join(results)
    DEDENT
    delete_player = raw_input("Who's result do you want to delete?")
    deleted = False
    for res in results :
    INDENT
        if delete_player.lower() in res.lower() :
        INDENT
            results.remove(res)
            with open('minigolf.txt', 'w') as f :
            INDENT
                f.writelines(results)
                print "User was found and removed"
                deleted = True

            DEDENT
        DEDENT
    DEDENT
    if not deleted :
    INDENT
        print "User not found..."
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38437619_38438086_1_16
38437619_38438523_1_21
Title: Delete line in file 
----------------------------------------

def delete_result() :
INDENT
    with open('minigolf.txt', 'r') as f :
    INDENT
        results = f.readlines()
        print (results)
    DEDENT
    user = raw_input('which user do you want to delete')
    for res in results :
    INDENT
        if user.lower() in res :
        INDENT
            results.remove(res)
            with open('minigolf.txt', 'w') as f :
            INDENT
                f.writelines(results)
                return 'user was found and removed'
            DEDENT
        DEDENT
    DEDENT
    return 'user was not found'
DEDENT
----------------------------------------

def delete_result() :
INDENT
    with open('minigolf.txt', 'r') as f :
    INDENT
        results = f.readlines()
        print "\n".join(results)
    DEDENT
    delete_player = raw_input("Who's result do you want to delete?")
    deleted = False
    for res in results :
    INDENT
        if delete_player.lower() in res.lower() :
        INDENT
            results.remove(res)
            with open('minigolf.txt', 'w') as f :
            INDENT
                f.writelines(results)
                print "User was found and removed"
                deleted = True

            DEDENT
        DEDENT
    DEDENT
    if not deleted :
    INDENT
        print "User not found..."
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38455468_38456126_3_11
38455468_38456533_3_11
Title: How do I append a list of multiple objects to the end of a file path? 
----------------------------------------

def size() :
INDENT
    d_path = '/home/Jake/Documents/sizes'
    x = list()
    for i in range(0, 84) :
    INDENT
        tmp = 'size_' + str(i)
        p = os.path.join(d_path, tmp)
        x.append(p)
    DEDENT
    return x
DEDENT
----------------------------------------

def size() :
INDENT
    d_path = '/home/Jake/Documents/sizes'
    x = []
    p = []
    for i in range(0, 84) :
    INDENT
        x.append('size_{:02}'.format(i))
        p.append(os.path.join(d_path, x [i]))
    DEDENT
    return p
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38506808_40609245_5_12
38506808_40609245_98_140
Title: PyQt4 force view to fetchMore from QAbstractItemModel 
----------------------------------------

def __init__(self, batch_size = 100, max_num_nodes = 1000) :
INDENT
    QtCore.QAbstractListModel.__init__(self)
    self.batch_size = batch_size
    self.nodes = []
    for i in range(0, self.batch_size) :
    INDENT
        self.nodes.append('node ' + str(i))
    DEDENT
    self.max_num_nodes = max(self.batch_size, max_num_nodes)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtWidgets.QMainWindow.__init__(self, parent)
    self.max_num_nodes = 10000
    self.batch_size = 100
    self.model = DelayedFetchingListModel(batch_size = self.batch_size, max_num_nodes = self.max_num_nodes)
    self.view = ListView()
    self.view.setModel(self.model)
    self.view.selectionModel().currentChanged.connect(self.onCurrentItemChanged)
    index = self.model.index(0, 0, QtCore.QModelIndex())
    self.view.selectionModel().clearSelection()
    self.view.selectionModel().select(index, QtCore.QItemSelectionModel.Select)
    self.spinBox = QtWidgets.QSpinBox()
    self.spinBox.setMinimum(0)
    self.spinBox.setMaximum(self.max_num_nodes - 1)
    self.spinBox.setSingleStep(1)
    self.spinBox.valueChanged.connect(self.onSpinBoxNewValue)
    self.progressBar = QtWidgets.QProgressBar()
    self.progressBar.setRange(0, self.max_num_nodes)
    self.progressBar.setValue(0)
    self.progressBar.valueChanged.connect(self.onProgressBarValueChanged)
    self.statusBar = QtWidgets.QStatusBar()
    self.statusBar.hide()
    self.layout = QtWidgets.QVBoxLayout()
    self.layout.addWidget(self.view)
    self.layout.addWidget(self.spinBox)
    self.layout.addWidget(self.progressBar)
    self.layout.addWidget(self.statusBar)
    self.window = QtWidgets.QWidget()
    self.window.setLayout(self.layout)
    self.setCentralWidget(self.window)
    self.timer = QtCore.QBasicTimer()
    self.timerPeriod = 1000
    self.timer.start(self.timerPeriod, self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3853722_32974697_3_10
3853722_43139055_8_26
Title: Python argparse: How to insert newline in the help text? 
----------------------------------------

def _fill_text(self, text, width, indent) :
INDENT
    text = self._whitespace_matcher.sub(' ', text).strip()
    paragraphs = text.split('|n ')
    multiline_text = ''
    for paragraph in paragraphs :
    INDENT
        formatted_paragraph = _textwrap.fill(paragraph, width, initial_indent = indent, subsequent_indent = indent) + '\n\n'
        multiline_text = multiline_text + formatted_paragraph
    DEDENT
    return multiline_text
DEDENT
----------------------------------------

def _fill_text(self, text, width, indent) :
INDENT
    if text.startswith('R|') :
    INDENT
        paragraphs = text [2 :].splitlines()
        rebroken = [argparse._textwrap.wrap(tpar, width) for tpar in paragraphs]
        rebrokenstr = []
        for tlinearr in rebroken :
        INDENT
            if (len(tlinearr) == 0) :
            INDENT
                rebrokenstr.append("")
            DEDENT
            else :
            INDENT
                for tlinepiece in tlinearr :
                INDENT
                    rebrokenstr.append(tlinepiece)
                DEDENT
            DEDENT
        DEDENT
        return '\n'.join(rebrokenstr)

    DEDENT
    return argparse.RawDescriptionHelpFormatter._fill_text(self, text, width, indent)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38545225_38547146_22_49
38545225_38547146_55_84
Title: Run-length encoding program 
----------------------------------------

def run_length_encode(text) :
INDENT
    result = []
    position = 0

    while position < len(text) :
    INDENT

        letter = text [position]
        position += 1
        count = 1

        while position < len(text) and text [position] == letter :
        INDENT

            count += 1
            position += 1

        DEDENT
        result.append((letter, count))

    DEDENT
    return ''.join('{}{}'.format(letter, count) for letter, count in result)
DEDENT
----------------------------------------

def run_length_encode(text) :
INDENT
    result = []

    current_letter = None
    count = 0

    for letter in text :
    INDENT
        if letter == current_letter :
        INDENT
            count += 1
        DEDENT
        else :
        INDENT
            if count > 0 :
            INDENT
                result.append((current_letter, count))

            DEDENT
            current_letter = letter
            count = 1

        DEDENT
    DEDENT
    result.append((current_letter, count))

    return ''.join('{}{}'.format(letter, count) for letter, count in result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38545225_38547146_22_49
38545225_38547146_5_16
Title: Run-length encoding program 
----------------------------------------

def run_length_encode(text) :
INDENT
    result = []
    position = 0

    while position < len(text) :
    INDENT

        letter = text [position]
        position += 1
        count = 1

        while position < len(text) and text [position] == letter :
        INDENT

            count += 1
            position += 1

        DEDENT
        result.append((letter, count))

    DEDENT
    return ''.join('{}{}'.format(letter, count) for letter, count in result)
DEDENT
----------------------------------------

def run_length_encode(text) :
INDENT
    def encode_single_run(match) :
    INDENT
        return '{}{}'.format(match.group(1), len(match.group(0)))

    DEDENT
    return re.sub(r'(.)\1*', encode_single_run, text)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38545225_38547146_55_84
38545225_38547146_5_16
Title: Run-length encoding program 
----------------------------------------

def run_length_encode(text) :
INDENT
    result = []

    current_letter = None
    count = 0

    for letter in text :
    INDENT
        if letter == current_letter :
        INDENT
            count += 1
        DEDENT
        else :
        INDENT
            if count > 0 :
            INDENT
                result.append((current_letter, count))

            DEDENT
            current_letter = letter
            count = 1

        DEDENT
    DEDENT
    result.append((current_letter, count))

    return ''.join('{}{}'.format(letter, count) for letter, count in result)
DEDENT
----------------------------------------

def run_length_encode(text) :
INDENT
    def encode_single_run(match) :
    INDENT
        return '{}{}'.format(match.group(1), len(match.group(0)))

    DEDENT
    return re.sub(r'(.)\1*', encode_single_run, text)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
38548075_38552214_10_26
38548075_38552214_33_48
Title: Kivy get TextInput from Popup 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(MyWidget, self).__init__(** kwargs)
    self.orientation = "vertical"
    self.name_input = TextInput(text = 'name')
    self.add_widget(self.name_input)
    self.save_button = Button(text = "Save")
    self.save_button.bind(on_press = self.save)
    self.save_popup = SaveDialog(self)
    self.add_widget(self.save_button)

DEDENT
----------------------------------------

def __init__(self, my_widget, ** kwargs) :
INDENT
    super(SaveDialog, self).__init__(** kwargs)
    self.my_widget = my_widget
    self.content = BoxLayout(orientation = "horizontal")
    self.save_button = Button(text = 'Save')
    self.save_button.bind(on_press = self.save)
    self.cancel_button = Button(text = 'Cancel')
    self.cancel_button.bind(on_press = self.cancel)
    self.content.add_widget(self.save_button)
    self.content.add_widget(self.cancel_button)
DEDENT
----------------------------------------
