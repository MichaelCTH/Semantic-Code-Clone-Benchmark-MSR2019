$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12326493_12326677_4_12
12326493_12327295_3_12
Title: Extracting attributes out of the XML using Python 
----------------------------------------

def xml_to_dict(tree) :
INDENT
    d = {}
    if tree.text :
    INDENT
        d [tree.tag] = tree.text
    DEDENT
    elif len(tree) < 0 :
    INDENT
        d [tree.tag] = {}
    DEDENT
    else :
    INDENT
        d [tree.tag] = map(xml_to_dict, tree)
    DEDENT
    return d
DEDENT
----------------------------------------

def xml_to_dict(root) :
INDENT
    assert empty(root.tail), 'tail is not supported'
    d = root.attrib
    assert root.tag not in d, 'tag and attribute name conflict'
    if len(root) > 0 :
    INDENT
        assert empty(root.text), 'text and chilren conflict'
        d [root.tag] = map(xml_to_dict, root)
    DEDENT
    elif not empty(root.text) :
    INDENT
        d [root.tag] = root.text
    DEDENT
    return d
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12338802_12338836_10_15
12338802_33375592_5_11
Title: How efficient is this Python Code for the fibonacci sequence? 
----------------------------------------

def fib(n) :
INDENT
    if n & 1 :
    INDENT
        return powLF(n) [1]
    DEDENT
    else :
    INDENT
        L, F = powLF(n / / 2)
        return L * F
    DEDENT
DEDENT
----------------------------------------

def fib(n) :
INDENT
    if n < 2 :
    INDENT
        return 1
    DEDENT
    MProd = M.copy()
    for _ in xrange(n - 2) :
    INDENT
        MProd *= M
    DEDENT
    return MProd [0, 0] + MProd [0, 1]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1234672_1234689_1_10
1234672_1235642_5_13
Title: Introspecting a given function's nested (local) functions in Python 
----------------------------------------

def f() :
INDENT
    x = [1]
    def get() :
    INDENT
        print 'get', x [0]
        x [0] -= 1
    DEDENT
    def post() :
    INDENT
        print 'post', x [0]
        x [0] += 1
    DEDENT
    return (get, post)
DEDENT
----------------------------------------

def f() :
INDENT
    funcs = FunctionCollector()
    @ funcs.register
    def get() :
    INDENT
        return 'get'
    DEDENT
    @ funcs.register
    def put() :
    INDENT
        return 'put'
    DEDENT
    return funcs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1234672_1234689_1_10
1234672_1235801_4_10
Title: Introspecting a given function's nested (local) functions in Python 
----------------------------------------

def f() :
INDENT
    x = [1]
    def get() :
    INDENT
        print 'get', x [0]
        x [0] -= 1
    DEDENT
    def post() :
    INDENT
        print 'post', x [0]
        x [0] += 1
    DEDENT
    return (get, post)
DEDENT
----------------------------------------

def f() :
INDENT
    x, y = 1, 2
    def get() :
    INDENT
        print 'get'
    DEDENT
    def post() :
    INDENT
        print 'post'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1234672_1235642_5_13
1234672_1235801_4_10
Title: Introspecting a given function's nested (local) functions in Python 
----------------------------------------

def f() :
INDENT
    funcs = FunctionCollector()
    @ funcs.register
    def get() :
    INDENT
        return 'get'
    DEDENT
    @ funcs.register
    def put() :
    INDENT
        return 'put'
    DEDENT
    return funcs
DEDENT
----------------------------------------

def f() :
INDENT
    x, y = 1, 2
    def get() :
    INDENT
        print 'get'
    DEDENT
    def post() :
    INDENT
        print 'post'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12374781_12380595_1_11
12374781_18586551_1_12
Title: How to find all neighbors of a given point in a delaunay triangulation using scipy.spatial.Delaunay? 
----------------------------------------

def find_neighbors(pindex, triang) :
INDENT
    neighbors = list()
    for simplex in triang.vertices :
    INDENT
        if pindex in simplex :
        INDENT
            neighbors.extend([simplex [i] for i in range(len(simplex)) if simplex [i] ! = pindex])
            '''
            this is a one liner for if a simplex contains the point we`re interested in,
            extend the neighbors list by appending all the *other* point indices in the simplex
            '''
        DEDENT
    DEDENT
    return list(set(neighbors))
DEDENT
----------------------------------------

def find_neighbors(tess, points) :
INDENT
    neighbors = {}
    for point in range(points.shape [0]) :
    INDENT
        neighbors [point] = []
    DEDENT
    for simplex in tess.simplices :
    INDENT
        neighbors [simplex [0]] += [simplex [1], simplex [2]]
        neighbors [simplex [1]] += [simplex [2], simplex [0]]
        neighbors [simplex [2]] += [simplex [0], simplex [1]]
    DEDENT
    return neighbors
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12374781_12380595_1_11
12374781_34842626_3_11
Title: How to find all neighbors of a given point in a delaunay triangulation using scipy.spatial.Delaunay? 
----------------------------------------

def find_neighbors(pindex, triang) :
INDENT
    neighbors = list()
    for simplex in triang.vertices :
    INDENT
        if pindex in simplex :
        INDENT
            neighbors.extend([simplex [i] for i in range(len(simplex)) if simplex [i] ! = pindex])
            '''
            this is a one liner for if a simplex contains the point we`re interested in,
            extend the neighbors list by appending all the *other* point indices in the simplex
            '''
        DEDENT
    DEDENT
    return list(set(neighbors))
DEDENT
----------------------------------------

def find_neighbors(tess) :
INDENT
    neighbors = defaultdict(set)
    for simplex in tess.simplices :
    INDENT
        for idx in simplex :
        INDENT
            other = set(simplex)
            other.remove(idx)
            neighbors [idx] = neighbors [idx].union(other)
        DEDENT
    DEDENT
    return neighbors
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12374781_18586551_1_12
12374781_34842626_3_11
Title: How to find all neighbors of a given point in a delaunay triangulation using scipy.spatial.Delaunay? 
----------------------------------------

def find_neighbors(tess, points) :
INDENT
    neighbors = {}
    for point in range(points.shape [0]) :
    INDENT
        neighbors [point] = []
    DEDENT
    for simplex in tess.simplices :
    INDENT
        neighbors [simplex [0]] += [simplex [1], simplex [2]]
        neighbors [simplex [1]] += [simplex [2], simplex [0]]
        neighbors [simplex [2]] += [simplex [0], simplex [1]]
    DEDENT
    return neighbors
DEDENT
----------------------------------------

def find_neighbors(tess) :
INDENT
    neighbors = defaultdict(set)
    for simplex in tess.simplices :
    INDENT
        for idx in simplex :
        INDENT
            other = set(simplex)
            other.remove(idx)
            neighbors [idx] = neighbors [idx].union(other)
        DEDENT
    DEDENT
    return neighbors
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12377013_12377059_1_31
12377013_50132227_4_13
Title: Is there a library function in Python to turn a generator-function into a function returning a list? 
----------------------------------------

def listify(fn = None, wrapper = list) :
INDENT
    def listify_return(fn) :
    INDENT
        @ wraps(fn)
        def listify_helper(* args, ** kw) :
        INDENT
            return wrapper(fn(* args, ** kw))
        DEDENT
        return listify_helper
    DEDENT
    if fn is None :
    INDENT
        return listify_return
    DEDENT
    return listify_return(fn)
DEDENT
----------------------------------------

def listify(func) :
INDENT
    @ wraps(func)
    def new_func(* args, ** kwargs) :
    INDENT
        r = func(* args, ** kwargs)
        if isinstance(r, GeneratorType) :
        INDENT
            return list(r)
        DEDENT
        else :
        INDENT
            return r
        DEDENT
    DEDENT
    return new_func
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12397339_12397415_1_16
12397339_12405371_1_16
Title: Python: Convert a nested list of tuples of lists into a dictionary? 
----------------------------------------

def tuple2dict(data) :
INDENT
    d = {}
    for item in data :
    INDENT
        if len(item) == 1 and isinstance(item, tuple) :
        INDENT

            item = item [0]
            key = item [0]
            value = item [1]
            d [key] = value
            continue
        DEDENT
        key = item [0]
        value = item [1]
        if hasattr(value, '__getitem__') :
        INDENT
            value = tuple2dict(value)
        DEDENT
        d [key] = value
    DEDENT
    return d
DEDENT
----------------------------------------

def tuple2dict(_obj) :
INDENT
    _dict = {}
    for item in _obj :
    INDENT
        if isinstance(item, tuple) or isinstance(item, list) :
        INDENT
            if isinstance(item [0], basestring) :
            INDENT
                _dict [item [0]] = tuple2dict(item [1])
            DEDENT
            else :
            INDENT
                if isinstance(item [0], tuple) :
                INDENT

                    _key = item [0] [0]
                    if _key in _dict :
                    INDENT
                        _dict [_key] = " ".join([_dict [_key], item [0] [1]])
                    DEDENT
                    else :
                    INDENT
                        _dict [_key] = item [0] [1]
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return _dict
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12424686_12435077_3_12
12424686_12477374_1_11
Title: Mock patch method and an attribute 
----------------------------------------

def mock_requests_post(self, url, data = None) :
INDENT
    mock_response = Mock()
    mock_response.content = 'my test response content'
    url = self.encode_url(url, data)
    if url :
    INDENT
        mock_response.url_called = self.fixtures [url]
    DEDENT
    return mock_response
DEDENT
----------------------------------------

def mock_requests_post(self, url, data = None) :
INDENT
    url = self.encode_url(url, data)
    class classWithAttributes(object) :
    INDENT
        content = json.dumps(self.fixtures [url])
    DEDENT
    if url :
    INDENT
        return classWithAttributes()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12447880_12458027_1_23
12447880_38406429_7_19
Title: Finding a Eulerian Tour 
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    tour = []
    current_vertex = graph [0] [0]
    tour.append(current_vertex)
    while len(graph) > 0 :
    INDENT
        print (graph, current_vertex)
        for edge in graph :
        INDENT
            if current_vertex in edge :
            INDENT
                if edge [0] == current_vertex :
                INDENT
                    current_vertex = edge [1]
                DEDENT
                else :
                INDENT
                    current_vertex = edge [0]
                DEDENT
                graph.remove(edge)
                tour.append(current_vertex)
                break
            DEDENT
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    return tour
DEDENT
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    search = [[[], graph [0] [0], graph]]
    while search :
    INDENT
        path, node, unexplore = search.pop()
        path += [node]
        if not unexplore :
        INDENT
            return path
        DEDENT
        for edge in unexplore :
        INDENT
            if node in edge :
            INDENT
                search += [[path, next_node(edge, node), remove_edge(unexplore, edge)]]
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12447880_12458027_1_23
12447880_41660393_9_97
Title: Finding a Eulerian Tour 
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    tour = []
    current_vertex = graph [0] [0]
    tour.append(current_vertex)
    while len(graph) > 0 :
    INDENT
        print (graph, current_vertex)
        for edge in graph :
        INDENT
            if current_vertex in edge :
            INDENT
                if edge [0] == current_vertex :
                INDENT
                    current_vertex = edge [1]
                DEDENT
                else :
                INDENT
                    current_vertex = edge [0]
                DEDENT
                graph.remove(edge)
                tour.append(current_vertex)
                break
            DEDENT
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    return tour
DEDENT
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    edges = graph
    graph = {}
    degree = {}
    start = edges [0] [0]
    count_e = 0
    for e in edges :
    INDENT
        if not e [0] in graph :
        INDENT
            graph [e [0]] = {}
        DEDENT
        if not e [0] in degree :
        INDENT
            degree [e [0]] = 0
        DEDENT
        if not e [1] in graph :
        INDENT
            graph [e [1]] = {}
        DEDENT
        if not e [1] in degree :
        INDENT
            degree [e [1]] = 0
        DEDENT
        graph [e [0]] [e [1]] = 1
        graph [e [1]] [e [0]] = 1
        degree [e [0]] += 1
        degree [e [1]] += 1
        count_e += 1
    DEDENT
    max_d = 0
    this_ = 0
    for v, d in degree.items() :
    INDENT
        if not d % 2 == 0 :
        INDENT
            return False
        DEDENT
        if d > max_d :
        INDENT
            this_ = v
            max_d = d
        DEDENT
    DEDENT
    visited_e = {}
    def is_visited(i, j) :
    INDENT
        key = str(sorted([i, j]))
        if key in visited_e :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            visited_e [key] = True
            return False
        DEDENT
    DEDENT
    start = this_
    route = [start]
    indexof = {}
    indexof [start] = 0
    while count_e > 0 :
    INDENT
        flag = False
        for to_v in graph [this_] :
        INDENT
            if not is_visited(to_v, this_) :
            INDENT
                route.append([to_v])
                indexof [to_v] = len(route) - 1
                degree [to_v] -= 1
                if degree [to_v] == 0 :
                INDENT
                    del degree [to_v]
                DEDENT
                degree [this_] -= 1
                if degree [this_] == 0 :
                INDENT
                    del degree [this_]
                DEDENT
                this_ = to_v
                flag = True
                count_e -= 1
                break
            DEDENT
        DEDENT
        if not flag :
        INDENT
            break
        DEDENT
    DEDENT
    for key, v in degree.items() :
    INDENT
        if v < = 0 :
        INDENT
            continue
        DEDENT
        try :
        INDENT
            ind = indexof [key]
        DEDENT
        except Exception as e :
        INDENT
            continue
        DEDENT
        this_ = key
        while count_e > 0 :
        INDENT
            flag = False
            for to_v in graph [this_] :
            INDENT
                if not is_visited(to_v, this_) :
                INDENT
                    route [ind].append(to_v)
                    degree [to_v] -= 1
                    degree [this_] -= 1
                    this_ = to_v
                    flag = True
                    count_e -= 1
                    break
                DEDENT
            DEDENT
            if not flag :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    route_ref = []
    for r in route :
    INDENT
        if type(r) == list :
        INDENT
            for _r in r :
            INDENT
                route_ref.append(_r)
            DEDENT
        DEDENT
        else :
        INDENT
            route_ref.append(r)
        DEDENT
    DEDENT
    return route_ref
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12447880_12458027_1_23
12447880_45139321_1_47
Title: Finding a Eulerian Tour 
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    tour = []
    current_vertex = graph [0] [0]
    tour.append(current_vertex)
    while len(graph) > 0 :
    INDENT
        print (graph, current_vertex)
        for edge in graph :
        INDENT
            if current_vertex in edge :
            INDENT
                if edge [0] == current_vertex :
                INDENT
                    current_vertex = edge [1]
                DEDENT
                else :
                INDENT
                    current_vertex = edge [0]
                DEDENT
                graph.remove(edge)
                tour.append(current_vertex)
                break
            DEDENT
        DEDENT
        else :
        INDENT
            return False
        DEDENT
    DEDENT
    return tour
DEDENT
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    nodes = set()
    for i in graph :
    INDENT
        if not i [0] in nodes :
        INDENT
            nodes.add(i [0])
        DEDENT
        if not i [1] in nodes :
        INDENT
            nodes.add(i [1])
        DEDENT
    DEDENT
    tour = []
    tempstack = []
    graphtemp = []
    current_vertex = graph [0] [0]
    tour.append(current_vertex)
    tempstack.append(current_vertex)
    last_edge = ()
    count = 0
    while len(set(tempstack)) + 1 < len(nodes) or (count == 0 or tour [0] ! = tour [len(tour) - 1]) :
    INDENT
        count += 1
        flag = False
        for edge in graph :
        INDENT
            if current_vertex in edge and edge ! = last_edge :
            INDENT
                if current_vertex == edge [0] :
                INDENT
                    current_vertex = edge [1]
                DEDENT
                else :
                INDENT
                    current_vertex = edge [0]
                DEDENT
                last_edge = edge
                graphtemp.append(edge)
                graph.remove(edge)
                tour.append(current_vertex)
                tempstack.append(current_vertex)
                flag = True
                break
            DEDENT
        DEDENT
        if flag == False :
        INDENT
            tour.remove(current_vertex)
            current_vertex = tempstack [0]
            tempstack.remove(tempstack [0])
            graph.append(graphtemp [0])
            graphtemp.remove(graphtemp [0])

        DEDENT
    DEDENT
    return tour

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12447880_38406429_7_19
12447880_41660393_9_97
Title: Finding a Eulerian Tour 
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    search = [[[], graph [0] [0], graph]]
    while search :
    INDENT
        path, node, unexplore = search.pop()
        path += [node]
        if not unexplore :
        INDENT
            return path
        DEDENT
        for edge in unexplore :
        INDENT
            if node in edge :
            INDENT
                search += [[path, next_node(edge, node), remove_edge(unexplore, edge)]]
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    edges = graph
    graph = {}
    degree = {}
    start = edges [0] [0]
    count_e = 0
    for e in edges :
    INDENT
        if not e [0] in graph :
        INDENT
            graph [e [0]] = {}
        DEDENT
        if not e [0] in degree :
        INDENT
            degree [e [0]] = 0
        DEDENT
        if not e [1] in graph :
        INDENT
            graph [e [1]] = {}
        DEDENT
        if not e [1] in degree :
        INDENT
            degree [e [1]] = 0
        DEDENT
        graph [e [0]] [e [1]] = 1
        graph [e [1]] [e [0]] = 1
        degree [e [0]] += 1
        degree [e [1]] += 1
        count_e += 1
    DEDENT
    max_d = 0
    this_ = 0
    for v, d in degree.items() :
    INDENT
        if not d % 2 == 0 :
        INDENT
            return False
        DEDENT
        if d > max_d :
        INDENT
            this_ = v
            max_d = d
        DEDENT
    DEDENT
    visited_e = {}
    def is_visited(i, j) :
    INDENT
        key = str(sorted([i, j]))
        if key in visited_e :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            visited_e [key] = True
            return False
        DEDENT
    DEDENT
    start = this_
    route = [start]
    indexof = {}
    indexof [start] = 0
    while count_e > 0 :
    INDENT
        flag = False
        for to_v in graph [this_] :
        INDENT
            if not is_visited(to_v, this_) :
            INDENT
                route.append([to_v])
                indexof [to_v] = len(route) - 1
                degree [to_v] -= 1
                if degree [to_v] == 0 :
                INDENT
                    del degree [to_v]
                DEDENT
                degree [this_] -= 1
                if degree [this_] == 0 :
                INDENT
                    del degree [this_]
                DEDENT
                this_ = to_v
                flag = True
                count_e -= 1
                break
            DEDENT
        DEDENT
        if not flag :
        INDENT
            break
        DEDENT
    DEDENT
    for key, v in degree.items() :
    INDENT
        if v < = 0 :
        INDENT
            continue
        DEDENT
        try :
        INDENT
            ind = indexof [key]
        DEDENT
        except Exception as e :
        INDENT
            continue
        DEDENT
        this_ = key
        while count_e > 0 :
        INDENT
            flag = False
            for to_v in graph [this_] :
            INDENT
                if not is_visited(to_v, this_) :
                INDENT
                    route [ind].append(to_v)
                    degree [to_v] -= 1
                    degree [this_] -= 1
                    this_ = to_v
                    flag = True
                    count_e -= 1
                    break
                DEDENT
            DEDENT
            if not flag :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    route_ref = []
    for r in route :
    INDENT
        if type(r) == list :
        INDENT
            for _r in r :
            INDENT
                route_ref.append(_r)
            DEDENT
        DEDENT
        else :
        INDENT
            route_ref.append(r)
        DEDENT
    DEDENT
    return route_ref
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12447880_38406429_7_19
12447880_45139321_1_47
Title: Finding a Eulerian Tour 
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    search = [[[], graph [0] [0], graph]]
    while search :
    INDENT
        path, node, unexplore = search.pop()
        path += [node]
        if not unexplore :
        INDENT
            return path
        DEDENT
        for edge in unexplore :
        INDENT
            if node in edge :
            INDENT
                search += [[path, next_node(edge, node), remove_edge(unexplore, edge)]]
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    nodes = set()
    for i in graph :
    INDENT
        if not i [0] in nodes :
        INDENT
            nodes.add(i [0])
        DEDENT
        if not i [1] in nodes :
        INDENT
            nodes.add(i [1])
        DEDENT
    DEDENT
    tour = []
    tempstack = []
    graphtemp = []
    current_vertex = graph [0] [0]
    tour.append(current_vertex)
    tempstack.append(current_vertex)
    last_edge = ()
    count = 0
    while len(set(tempstack)) + 1 < len(nodes) or (count == 0 or tour [0] ! = tour [len(tour) - 1]) :
    INDENT
        count += 1
        flag = False
        for edge in graph :
        INDENT
            if current_vertex in edge and edge ! = last_edge :
            INDENT
                if current_vertex == edge [0] :
                INDENT
                    current_vertex = edge [1]
                DEDENT
                else :
                INDENT
                    current_vertex = edge [0]
                DEDENT
                last_edge = edge
                graphtemp.append(edge)
                graph.remove(edge)
                tour.append(current_vertex)
                tempstack.append(current_vertex)
                flag = True
                break
            DEDENT
        DEDENT
        if flag == False :
        INDENT
            tour.remove(current_vertex)
            current_vertex = tempstack [0]
            tempstack.remove(tempstack [0])
            graph.append(graphtemp [0])
            graphtemp.remove(graphtemp [0])

        DEDENT
    DEDENT
    return tour

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12447880_41660393_9_97
12447880_45139321_1_47
Title: Finding a Eulerian Tour 
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    edges = graph
    graph = {}
    degree = {}
    start = edges [0] [0]
    count_e = 0
    for e in edges :
    INDENT
        if not e [0] in graph :
        INDENT
            graph [e [0]] = {}
        DEDENT
        if not e [0] in degree :
        INDENT
            degree [e [0]] = 0
        DEDENT
        if not e [1] in graph :
        INDENT
            graph [e [1]] = {}
        DEDENT
        if not e [1] in degree :
        INDENT
            degree [e [1]] = 0
        DEDENT
        graph [e [0]] [e [1]] = 1
        graph [e [1]] [e [0]] = 1
        degree [e [0]] += 1
        degree [e [1]] += 1
        count_e += 1
    DEDENT
    max_d = 0
    this_ = 0
    for v, d in degree.items() :
    INDENT
        if not d % 2 == 0 :
        INDENT
            return False
        DEDENT
        if d > max_d :
        INDENT
            this_ = v
            max_d = d
        DEDENT
    DEDENT
    visited_e = {}
    def is_visited(i, j) :
    INDENT
        key = str(sorted([i, j]))
        if key in visited_e :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            visited_e [key] = True
            return False
        DEDENT
    DEDENT
    start = this_
    route = [start]
    indexof = {}
    indexof [start] = 0
    while count_e > 0 :
    INDENT
        flag = False
        for to_v in graph [this_] :
        INDENT
            if not is_visited(to_v, this_) :
            INDENT
                route.append([to_v])
                indexof [to_v] = len(route) - 1
                degree [to_v] -= 1
                if degree [to_v] == 0 :
                INDENT
                    del degree [to_v]
                DEDENT
                degree [this_] -= 1
                if degree [this_] == 0 :
                INDENT
                    del degree [this_]
                DEDENT
                this_ = to_v
                flag = True
                count_e -= 1
                break
            DEDENT
        DEDENT
        if not flag :
        INDENT
            break
        DEDENT
    DEDENT
    for key, v in degree.items() :
    INDENT
        if v < = 0 :
        INDENT
            continue
        DEDENT
        try :
        INDENT
            ind = indexof [key]
        DEDENT
        except Exception as e :
        INDENT
            continue
        DEDENT
        this_ = key
        while count_e > 0 :
        INDENT
            flag = False
            for to_v in graph [this_] :
            INDENT
                if not is_visited(to_v, this_) :
                INDENT
                    route [ind].append(to_v)
                    degree [to_v] -= 1
                    degree [this_] -= 1
                    this_ = to_v
                    flag = True
                    count_e -= 1
                    break
                DEDENT
            DEDENT
            if not flag :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    route_ref = []
    for r in route :
    INDENT
        if type(r) == list :
        INDENT
            for _r in r :
            INDENT
                route_ref.append(_r)
            DEDENT
        DEDENT
        else :
        INDENT
            route_ref.append(r)
        DEDENT
    DEDENT
    return route_ref
DEDENT
----------------------------------------

def find_eulerian_tour(graph) :
INDENT
    nodes = set()
    for i in graph :
    INDENT
        if not i [0] in nodes :
        INDENT
            nodes.add(i [0])
        DEDENT
        if not i [1] in nodes :
        INDENT
            nodes.add(i [1])
        DEDENT
    DEDENT
    tour = []
    tempstack = []
    graphtemp = []
    current_vertex = graph [0] [0]
    tour.append(current_vertex)
    tempstack.append(current_vertex)
    last_edge = ()
    count = 0
    while len(set(tempstack)) + 1 < len(nodes) or (count == 0 or tour [0] ! = tour [len(tour) - 1]) :
    INDENT
        count += 1
        flag = False
        for edge in graph :
        INDENT
            if current_vertex in edge and edge ! = last_edge :
            INDENT
                if current_vertex == edge [0] :
                INDENT
                    current_vertex = edge [1]
                DEDENT
                else :
                INDENT
                    current_vertex = edge [0]
                DEDENT
                last_edge = edge
                graphtemp.append(edge)
                graph.remove(edge)
                tour.append(current_vertex)
                tempstack.append(current_vertex)
                flag = True
                break
            DEDENT
        DEDENT
        if flag == False :
        INDENT
            tour.remove(current_vertex)
            current_vertex = tempstack [0]
            tempstack.remove(tempstack [0])
            graph.append(graphtemp [0])
            graphtemp.remove(graphtemp [0])

        DEDENT
    DEDENT
    return tour

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12483512_12484048_6_17
12483512_12484058_5_12
Title: python multiprocessing apply_async only uses one process 
----------------------------------------

def testFunc(file) :
INDENT
    result = []
    print "Working in Process #%d" % (os.getpid())
    with open(file, 'r') as f :
    INDENT
        for line in f :
        INDENT
            if 'dog' in line :
            INDENT
                result.append(line)
            DEDENT
        DEDENT
    DEDENT
    return result

DEDENT
----------------------------------------

def testFunc(file) :
INDENT
    message = ("Working in Process #%d" % (os.getpid()))
    for line in file :
    INDENT
        if 'dog' in line :
        INDENT
            results.append(line)
        DEDENT
    DEDENT
    return message
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12524994_16594637_6_18
12524994_43826298_31_37
Title: Encrypt & Decrypt using PyCrypto AES 256 
----------------------------------------

def decrypt(quotedEncodedEncrypted) :
INDENT
    key = 'SecretKey'
    encodedEncrypted = urllib2.unquote(quotedEncodedEncrypted)
    cipher = AES.new(key)
    decrypted = cipher.decrypt(base64.b64decode(encodedEncrypted)) [: 16]
    for i in range(1, len(base64.b64decode(encodedEncrypted)) / 16) :
    INDENT
        cipher = AES.new(key, AES.MODE_CBC, base64.b64decode(encodedEncrypted) [(i - 1) * 16 : i * 16])
        decrypted += cipher.decrypt(base64.b64decode(encodedEncrypted) [i * 16 :]) [: 16]
    DEDENT
    return decrypted.strip()
DEDENT
----------------------------------------

def decrypt(self, enc) :
INDENT
    if enc is None or len(enc) == 0 :
    INDENT
        raise NameError("No value given to decrypt")
    DEDENT
    enc = base64.b64decode(enc)
    iv = enc [: 16]
    cipher = AES.new(self.key.encode('utf-8'), AES.MODE_CBC, iv)
    return re.sub(b'\x00*$', b'', cipher.decrypt(enc [16 :])).decode('utf-8')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12524994_16594637_6_18
12524994_44662262_31_45
Title: Encrypt & Decrypt using PyCrypto AES 256 
----------------------------------------

def decrypt(quotedEncodedEncrypted) :
INDENT
    key = 'SecretKey'
    encodedEncrypted = urllib2.unquote(quotedEncodedEncrypted)
    cipher = AES.new(key)
    decrypted = cipher.decrypt(base64.b64decode(encodedEncrypted)) [: 16]
    for i in range(1, len(base64.b64decode(encodedEncrypted)) / 16) :
    INDENT
        cipher = AES.new(key, AES.MODE_CBC, base64.b64decode(encodedEncrypted) [(i - 1) * 16 : i * 16])
        decrypted += cipher.decrypt(base64.b64decode(encodedEncrypted) [i * 16 :]) [: 16]
    DEDENT
    return decrypted.strip()
DEDENT
----------------------------------------

def decrypt(key, iv, ciphertext) :
INDENT
    assert len(key) == key_bytes
    iv_int = int(iv.encode('hex'), 16)
    ctr = Counter.new(AES.block_size * 8, initial_value = iv_int)

    aes = AES.new(key, AES.MODE_CTR, counter = ctr)

    plaintext = aes.decrypt(ciphertext)
    return plaintext
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12524994_43826298_22_30
12524994_44662262_10_30
Title: Encrypt & Decrypt using PyCrypto AES 256 
----------------------------------------

def encrypt(self, raw) :
INDENT
    if raw is None or len(raw) == 0 :
    INDENT
        raise NameError("No value given to encrypt")
    DEDENT
    raw = raw + '\0' * (self.blk_sz - len(raw) % self.blk_sz)
    raw = raw.encode('utf-8')
    iv = Random.new().read(AES.block_size)
    cipher = AES.new(self.key.encode('utf-8'), AES.MODE_CBC, iv)
    return base64.b64encode(iv + cipher.encrypt(raw)).decode('utf-8')
DEDENT
----------------------------------------

def encrypt(key, plaintext) :
INDENT
    assert len(key) == key_bytes
    iv = Random.new().read(AES.block_size)

    iv_int = int(binascii.hexlify(iv), 16)

    ctr = Counter.new(AES.block_size * 8, initial_value = iv_int)

    aes = AES.new(key, AES.MODE_CTR, counter = ctr)

    ciphertext = aes.encrypt(plaintext)
    return (iv, ciphertext)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12524994_43826298_31_37
12524994_44662262_31_45
Title: Encrypt & Decrypt using PyCrypto AES 256 
----------------------------------------

def decrypt(self, enc) :
INDENT
    if enc is None or len(enc) == 0 :
    INDENT
        raise NameError("No value given to decrypt")
    DEDENT
    enc = base64.b64decode(enc)
    iv = enc [: 16]
    cipher = AES.new(self.key.encode('utf-8'), AES.MODE_CBC, iv)
    return re.sub(b'\x00*$', b'', cipher.decrypt(enc [16 :])).decode('utf-8')
DEDENT
----------------------------------------

def decrypt(key, iv, ciphertext) :
INDENT
    assert len(key) == key_bytes
    iv_int = int(iv.encode('hex'), 16)
    ctr = Counter.new(AES.block_size * 8, initial_value = iv_int)

    aes = AES.new(key, AES.MODE_CTR, counter = ctr)

    plaintext = aes.decrypt(ciphertext)
    return plaintext
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12557376_12557389_1_12
12557376_26189064_3_10
Title: python repeat program while true 
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        again = raw_input("Would you like to play again? Enter y/n: ")
        if again == "n" :
        INDENT
            print ("Thanks for Playing!")
            return
        DEDENT
        elif again == "y" :
        INDENT
            print ("Lets play again..")
        DEDENT
        else :
        INDENT
            print ("You should enter either \"y\" or \"n\".")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    while True :
    INDENT
        number = raw_input('Please Enter a number between 1 and 10: ')
        if number == '5' :
        INDENT
            print 'You Got It!! It\'s number ' + number
            return
        DEDENT
        else :
        INDENT
            print 'Please try again!'
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12612821_12612838_1_12
12612821_12612863_1_11
Title: How to take this for loop and make it into a while loop python 
----------------------------------------

def splitList(myList, option) :
INDENT
    snappyList = []
    i = 0
    while i < len(myList) :
    INDENT
        if option == 0 :
        INDENT
            if myList [i] > 0 :
            INDENT
                snappyList.append(myList [i])
            DEDENT
        DEDENT
        if option == 1 :
        INDENT
            if myList [i] < 0 :
            INDENT
                snappyList.append(myList [i])
            DEDENT
        DEDENT
        i += 1
    DEDENT
    return (snappyList)
DEDENT
----------------------------------------

def splitList(myList, option) :
INDENT
    snappyList = []
    while len(myList) > 0 :
    INDENT
        i = myList.pop()
        if option == 0 :
        INDENT
            if i > 0 :
            INDENT
                snappyList.append(i)
            DEDENT
        DEDENT
        if option == 1 :
        INDENT
            if i < 0 :
            INDENT
                snappyList.append(i)
            DEDENT
        DEDENT
    DEDENT
    return snappyList
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12612821_12612838_1_12
12612821_12612904_1_15
Title: How to take this for loop and make it into a while loop python 
----------------------------------------

def splitList(myList, option) :
INDENT
    snappyList = []
    i = 0
    while i < len(myList) :
    INDENT
        if option == 0 :
        INDENT
            if myList [i] > 0 :
            INDENT
                snappyList.append(myList [i])
            DEDENT
        DEDENT
        if option == 1 :
        INDENT
            if myList [i] < 0 :
            INDENT
                snappyList.append(myList [i])
            DEDENT
        DEDENT
        i += 1
    DEDENT
    return (snappyList)
DEDENT
----------------------------------------

def splitList(myList, option) :
INDENT
    snappyList = []
    myList_iter = iter(myList)
    sentinel = object()
    while True :
    INDENT
        i = next(myList_iter, sentinel)
        if i == sentinel :
        INDENT
            break
        DEDENT
        if option == 0 :
        INDENT
            if i > 0 :
            INDENT
                snappyList.append(i)
            DEDENT
        DEDENT
        if option == 1 :
        INDENT
            if i < 0 :
            INDENT
                snappyList.append(i)
            DEDENT
        DEDENT
    DEDENT
    return (snappyList)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12612821_12612863_1_11
12612821_12612904_1_15
Title: How to take this for loop and make it into a while loop python 
----------------------------------------

def splitList(myList, option) :
INDENT
    snappyList = []
    while len(myList) > 0 :
    INDENT
        i = myList.pop()
        if option == 0 :
        INDENT
            if i > 0 :
            INDENT
                snappyList.append(i)
            DEDENT
        DEDENT
        if option == 1 :
        INDENT
            if i < 0 :
            INDENT
                snappyList.append(i)
            DEDENT
        DEDENT
    DEDENT
    return snappyList
DEDENT
----------------------------------------

def splitList(myList, option) :
INDENT
    snappyList = []
    myList_iter = iter(myList)
    sentinel = object()
    while True :
    INDENT
        i = next(myList_iter, sentinel)
        if i == sentinel :
        INDENT
            break
        DEDENT
        if option == 0 :
        INDENT
            if i > 0 :
            INDENT
                snappyList.append(i)
            DEDENT
        DEDENT
        if option == 1 :
        INDENT
            if i < 0 :
            INDENT
                snappyList.append(i)
            DEDENT
        DEDENT
    DEDENT
    return (snappyList)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12615869_12615922_3_18
12615869_12617687_9_13
Title: Finding k non contiguous random numbers with uniform probability in the range 1..n 
----------------------------------------

def noncontiguoussample(n, k) :
INDENT
    total_skips = n - k

    skip_cutoffs = random.sample(range(total_skips + 1), k)
    skip_cutoffs.sort()

    samples = []
    for index, skip_spot in enumerate(skip_cutoffs) :
    INDENT

        samples.append(1 + index + skip_spot)
    DEDENT
    return samples
DEDENT
----------------------------------------

def noncontiguoussample(n, k) :
INDENT
    while True :
    INDENT
        s = random.sample(xrange(1, n + 1), k)
        if is_valid_choice(s) :
        INDENT
            return s
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12626413_12626460_3_24
12626413_12626534_3_25
Title: wins on average 
----------------------------------------

def play(till_jackpot_count) :
INDENT
    game_data_per_jackpot = [{'plays' : 0, 'wins' : 0}]
    wheel_values = xrange(36)
    wheels = [0, 0, 0]
    while till_jackpot_count > = len(game_data_per_jackpot) :
    INDENT
        wheels = [random.choice(wheel_values) for wheel in wheels]
        game_data_per_jackpot [- 1] ['plays'] += 1
        print '%d plays since last jackpot' % game_data_per_jackpot [- 1] ['plays']
        print '%d wins since last jackpot' % game_data_per_jackpot [- 1] ['wins']
        print '%d total plays' % sum([data ['plays'] for data in game_data_per_jackpot])
        print '%d total wins' % sum([data ['wins'] for data in game_data_per_jackpot])
        print '%d total jackpots' % (len(game_data_per_jackpot) - 1)
        print 'this play: {} {} {}'.format(* wheels)
        if len(set(wheels)) == 1 :
        INDENT
            if wheels [0] == 7 :
            INDENT
                print 'jackpot!'
                game_data_per_jackpot.append({'plays' : 0, 'wins' : 0})
            DEDENT
            else :
            INDENT
                print 'win!'
                game_data_per_jackpot [- 1] ['wins'] += 1
            DEDENT
        DEDENT
    DEDENT
    return game_data_per_jackpot [: - 1]
DEDENT
----------------------------------------

def play() :
INDENT
    a = 1
    wins = 0
    while a > 0 :
    INDENT
        l1 = random.randrange(36)
        l2 = random.randrange(36)
        l3 = random.randrange(36)
        print l1, l2, l3
        if l1 == l2 == l3 == 7 :
        INDENT
            break
        DEDENT
        elif l1 == l2 == l3 :
        INDENT

            wins += 1
        DEDENT
        else :
        INDENT
            a += 1
            print 'sorry...  try again'
            print 'attempt', a
        DEDENT
    DEDENT
    return a, wins

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12642031_12642147_1_28
12642031_12642685_1_26
Title: Merge Sort Index Error 
----------------------------------------

def merge(seq, p, q, r) :
INDENT
    n1 = q - p + 1
    n2 = r - q
    left_arr = seq [p : n1]
    right_arr = seq [n1 : r + 1]
    j = 0
    i = 0
    for k in xrange(p, r + 1) :
    INDENT
        if left_arr [i] < = right_arr [j] :
        INDENT
            seq [k] = left_arr [i]
            i += 1
            if i > n1 - 1 :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            seq [k] = right_arr [j]
            j += 1
            if j > n2 - 1 :
            INDENT
                break
            DEDENT
        DEDENT
    DEDENT
    if i > = len(left_arr) :
    INDENT
        seq [k + 1 :] = right_arr [j :]
    DEDENT
    elif j > = len(right_arr) :
    INDENT
        seq [k + 1 :] = left_arr [i :]
    DEDENT
    return seq
DEDENT
----------------------------------------

def merge(seq, p, q, r) :
INDENT
    left = seq [p : q + 1]
    right = seq [q + 1 :]
    i = 0
    j = 0

    while i < len(left) and j < len(right) :
    INDENT
        if left [i] < = right [j] :
        INDENT
            seq [i + j] = left [i]
            i += 1
        DEDENT
        else :
        INDENT
            seq [i + j] = right [j]
            j += 1

        DEDENT
    DEDENT
    if j == len(right) :
    INDENT
        seq [i + j :] = left [i :]
    DEDENT
    elif i == len(left) :
    INDENT
        seq [i + j :] = right [j :]
    DEDENT
    print seq
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12661211_12661561_1_11
12661211_12661864_5_21
Title: Can't seem to get pyqt countdown timer to work 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    self.ui = Ui_relogiocc()
    self.ui.setupUi(self)
    self.timer = QtCore.QTimer()
    text = "%d:%02d" % (180 / 60, 180 % 60)
    self.ui.QLCDNumber.display(text)
    self.ui.iniciar.clicked.connect(self.startTimerDisplay)
    self.timer.timeout.connect(self.updateTimerDisplay)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QMainWindow.__init__(self, parent)
    self.central = QWidget(self)
    self.hbox = QHBoxLayout(self.central)
    self.lcd = QLCDNumber(self.central)
    self.timer = QTimer(self)
    self.start_time = 20
    self.lcd.display("%d:%02d" % (self.start_time / 60, self.start_time % 60))
    self.start_button = QPushButton("Start", self.central)
    self.hbox.addWidget(self.lcd)
    self.hbox.addWidget(self.start_button)
    self.setCentralWidget(self.central)
    self.start_button.clicked.connect(self.restartTimer)
    self.timer.timeout.connect(self.updateLCD)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12674389_23316447_1_15
12674389_38698889_1_7
Title: highest palindrome with 3 digit numbers in python 
----------------------------------------

def palindrome(n) :
INDENT
    maxNumberWithNDigits = int('9' * n)
    product = maxNumberWithNDigits * maxNumberWithNDigits

    while True :
    INDENT
        if str(product) == str(product) [: : - 1] : break;
        product -= 1
    DEDENT
    return product
DEDENT
----------------------------------------

def palindrome(y) :
INDENT
    z = str(y)
    w = z [: : - 1]
    if (w == z) :
    INDENT
        return 0
    DEDENT
    elif (w ! = z) :
    INDENT
        return 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12674537_12674777_1_20
12674537_12682691_1_22
Title: loop over tree like structure 
----------------------------------------

def foo(lst, path) :
INDENT
    if type(lst [0]) ! = type(array([])) :
    INDENT
        return [path + [(lst [0], lst [1])], path + [(lst [1], lst [2])]]
    DEDENT
    i = 0
    ret = []
    while i < len(lst) :
    INDENT
        node = lst [i]
        successor = lst [i + 1] if i + 1 < len(lst) else None
        if type(node) == type(array([])) :
        INDENT
            if type(successor) == list :
            INDENT
                children = successor
                ret.extend(foo(children, path + [(node [0], node [1])]))
                ret.extend(foo(children, path + [(node [1], node [2])]))
                i += 1
            DEDENT
            else :
            INDENT
                ret.append(path + [(node [0], node [1])])
                ret.append(path + [(node [1], node [2])])
            DEDENT
        DEDENT
        i += 1
    DEDENT
    return ret
DEDENT
----------------------------------------

def foo(m) :
INDENT
    for i in range(0, len(m), 2) :
    INDENT
        for j in range(len(m [i]) - 1) :
        INDENT
            current = tuple(m [i] [j : (j + 2)])
            mm = m [i + 1]
            if (len(mm) % 2 ! = 0 or (len(mm) > 1 and not type(mm [1] [0]) is types.ListType)) :
            INDENT
                currentl = mm [j]
                for k in range(0, len(currentl) - 1) :
                INDENT
                    yield current, tuple(currentl [k : (k + 2)])
                DEDENT
            DEDENT
            else :
            INDENT
                for res in foo(mm [2 * j : 2 * j + 2]) :
                INDENT
                    if type(res) is types.TupleType and len(res) > 1 and not type(res [0]) is types.TupleType :
                    INDENT
                        yield current, res
                    DEDENT
                    else :
                    INDENT

                        c = [current]
                        c += res
                        yield tuple(c)
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12696979_12697409_11_19
12696979_12697409_24_36
Title: Python - start two processes to run indefinitely 
----------------------------------------

def run(self) :
INDENT
    i = 0
    while i < 5 :
    INDENT
        print 'putting'
        self.q.put('foo %d' % i)
        i += 1
        time.sleep(.5)
    DEDENT
    self.q.put('|STOP|')
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        try :
        INDENT
            value = self.q.get(False)
            print value
            if value == '|STOP|' :
            INDENT
                print 'done'
                break;
            DEDENT
        DEDENT
        except Empty :
        INDENT
            print 'Nothing to process atm'
            time.sleep(.2)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12711397_12711477_1_7
12711397_12711515_1_9
Title: Python: Recursive function to find the largest number in the list 
----------------------------------------

def Max(list) :
INDENT
    if len(list) == 1 :
    INDENT
        return list [0]
    DEDENT
    else :
    INDENT
        m = Max(list [1 :])
        return m if m > list [0] else list [0]
    DEDENT
DEDENT
----------------------------------------

def Max(lis, maxx = - float("inf")) :
INDENT
    if len(lis) == 1 :
    INDENT
        return maxx if maxx > lis [0] else lis [0]
    DEDENT
    else :
    INDENT
        m = lis [0] if lis [0] > maxx else maxx
        return Max(lis [1 :], m)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12739897_12741174_6_16
12739897_12742182_1_12
Title: Python create Buttons and Entry widget 
----------------------------------------

def __init__(self, parent) :
INDENT
    Frame.__init__(self, parent)
    buttons = Frame(parent)
    buttons.pack(side = TOP)
    for letter in 'ABCDEF' :
    INDENT
        Button(buttons, text = letter).pack(side = LEFT)
    DEDENT
    Entry(parent, width = 50).pack(side = LEFT)
    Button(parent, text = 'OK').pack(side = RIGHT)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    Frame.__init__(self, parent)
    self.grid()
    for i, c in enumerate("ABCDEF") :
    INDENT
        self.button = Button(parent, text = c)
        self.button.grid(row = 1, column = i + 1)
    DEDENT
    self.myentrybox = Entry(parent, width = 50)
    self.myentrybox.grid(row = 2, column = 1, columnspan = 6)
    self.button = Button(parent, text = "OK")
    self.button.grid(row = 2, column = 7)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12755568_32318750_1_13
12755568_45619781_1_8
Title: How does Python insertion sort work? 
----------------------------------------

def insertionSort(alist) :
INDENT
    for index in range(1, len(alist)) :
    INDENT

        currentvalue = alist [index]
        position = index
        while position > 0 and alist [position - 1] > currentvalue :
        INDENT
            alist [position] = alist [position - 1]
            print (alist)
            position -= 1
        DEDENT
        alist [position] = currentvalue
    DEDENT
DEDENT
----------------------------------------

def insertionSort(list) :
INDENT
    for outerIndex in range(len(list)) :
    INDENT
        for innerIndex in range(outerIndex, 0, - 1) :
        INDENT
            if list [innerIndex] > = list [innerIndex - 1] :
            INDENT
                break
            DEDENT
            list [innerIndex], list [innerIndex - 1] = list [innerIndex - 1], list [innerIndex]
        DEDENT
    DEDENT
    return list
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12807875_12810203_5_14
12807875_12869911_5_42
Title: Qt4: tinting a QIcon 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QWidget.__init__(self)
    self.label = QtGui.QLabel(self)
    self.label.setPixmap(QtGui.QPixmap('image.jpg'))
    self.button = QtGui.QPushButton('Tint', self)
    self.button.clicked.connect(self.handleButton)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.label)
    layout.addWidget(self.button)
DEDENT
----------------------------------------

def __init__(self, image, parent = None) :
INDENT
    super(Tinter, self).__init__(parent)
    self.pixmap = QtGui.QPixmap(image)
    self.normal = QtGui.QLabel()
    self.normal.setPixmap(self.pixmap)
    self.tinted = QtGui.QLabel()
    self.red = QtGui.QSlider(QtCore.Qt.Horizontal)
    self.red.setRange(0, 255)
    self.red.sliderMoved.connect(self.applyTint)
    self.green = QtGui.QSlider(QtCore.Qt.Horizontal)
    self.green.setRange(0, 255)
    self.green.sliderMoved.connect(self.applyTint)
    self.blue = QtGui.QSlider(QtCore.Qt.Horizontal)
    self.blue.setRange(0, 255)
    self.blue.sliderMoved.connect(self.applyTint)
    self.alpha = QtGui.QSlider(QtCore.Qt.Horizontal)
    self.alpha.setRange(0, 255)
    self.alpha.setValue(128)
    self.alpha.sliderMoved.connect(self.applyTint)

    controlLayout = QtGui.QFormLayout()
    controlLayout.addRow('red', self.red)
    controlLayout.addRow('green', self.green)
    controlLayout.addRow('blue', self.blue)
    controlLayout.addRow('alpha', self.alpha)
    layout = QtGui.QHBoxLayout()
    layout.addWidget(self.normal)
    layout.addWidget(self.tinted)
    layout.addLayout(controlLayout)
    self.setLayout(layout)
    self.applyTint()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12853067_12888446_2_26
12853067_12888446_59_66
Title: Django: Cleaning up redis connection after client disconnects from stream 
----------------------------------------

def __init__(self,
rcon_or_url = settings.EVENTS_PUBSUB_URL,
channels = None,
buffer_key = settings.EVENTS_BUFFER_KEY,
last_event_id = None) :
INDENT
    if isinstance(rcon_or_url, redis.StrictRedis) :
    INDENT
        self.rcon = rcon_or_url
    DEDENT
    elif isinstance(rcon_or_url, basestring) :
    INDENT
        self.rcon = redis.StrictRedis(** utils.parse_redis_url(rcon_or_url))
    DEDENT
    if channels is None :
    INDENT
        channels = [settings.EVENTS_PUBSUB_CHANNEL]
    DEDENT
    self.channels = channels
    self.buffer_key = buffer_key
    self.last_event_id = last_event_id
    self.pubsub = self.rcon.pubsub()
    self.pubsub.subscribe(channels)

    for channel in self.channels :
    INDENT

        sender = Sender(self.rcon, channel, None)
        sender.publish('_flush', tags = ['hidden'])
    DEDENT
DEDENT
----------------------------------------

def __init__(self, rcon_or_url, channels, buffer_key = None,
last_event_id = None, * args, ** kwargs) :
INDENT
    self.listener = Listener(rcon_or_url, channels, buffer_key,
        last_event_id)
    super(SSEResponse, self).__init__(self.listener,
        mimetype = 'text/event-stream',
        * args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12859349_12876021_1_11
12859349_12876874_1_15
Title: Suppress unreachable errors in PyDev? 
----------------------------------------

def __call__(self, * args) :
INDENT
    if not 'SIGALRM' in dir(signal) :
    INDENT
        return self.function(* args)
    DEDENT
    old = signal.signal(signal.SIGALRM, self.handle_timeout)
    signal.alarm(self.timeout)
    try :
    INDENT
        result = self.function(* args)
    DEDENT
    finally :
    INDENT
        signal.signal(signal.SIGALRM, old)
    DEDENT
    signal.alarm(0)
    return result
DEDENT
----------------------------------------

def __call__(self, * args) :
INDENT
    if not hasattr(signal, 'SIGALRM') :
    INDENT
        return self.function(* args)
    DEDENT
    sigalrm = getattr(signal, 'SIGALRM')
    alarm = getattr(signal, 'alarm')
    old = signal.signal(sigalrm, self.handle_timeout)
    alarm(self.timeout)
    try :
    INDENT
        result = self.function(* args)
    DEDENT
    finally :
    INDENT
        signal.signal(sigalrm, old)
    DEDENT
    alarm(0)
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1286626_1286650_2_11
1286626_1286814_2_10
Title: python scooping and recursion 
----------------------------------------

def foo(me, t) :
INDENT
    global total
    if t < 0 :
    INDENT
        return
    DEDENT
    if t == 0 :
    INDENT
        total = total + 1
        return
    DEDENT
    for i in range(1, me + 1) :
    INDENT
        total = total + 1
        return foo(i, t - i)
    DEDENT
DEDENT
----------------------------------------

def foo(me, t) :
INDENT
    global total
    if t < 0 :
    INDENT
        return
    DEDENT
    total = total + 1
    if t == 0 :
    INDENT
        return
    DEDENT
    return foo(1, t - 1)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12867114_12874413_10_44
12867114_12874413_12_19
Title: substituting __iadd__ doesn't work as expected for += operator 
----------------------------------------

def __init__(self, matrix) :
INDENT
    class CustomWrapper(object) :
    INDENT
        def __init__(self, matrix) :
        INDENT
            assert matrix.dtype == numpy.uint8
            self.overflow_matrix = matrix
            self.overflow_lower_range = float(0)
            self.overflow_upper_range = float(2 ** 8 - 1)
            for op in OverflowPreventer.bypass_operators :
            INDENT
                setattr(CustomWrapper, op, getattr(self.overflow_matrix, op))
            DEDENT
        DEDENT
        def _overflow_operator(self, b, forward_operator) :
        INDENT
            m, lr, ur = self.overflow_matrix, self.overflow_lower_range, self.overflow_upper_range
            assert type(b) in (int, float)
            reverse_operator = OverflowPreventer.inverse_operator [forward_operator]
            uro = getattr(ur, reverse_operator)
            lro = getattr(lr, reverse_operator)
            afo = getattr(m, forward_operator)
            overflows = m > uro(b)
            underflows = m < lro(b)
            afo(b)
            m [overflows] = ur
            m [underflows] = lr
            return self
        DEDENT
        def __getattr__(self, attr) :
        INDENT
            if hasattr(self.wrapped, attr) :
            INDENT
                return getattr(self.wrapped, attr)
            DEDENT
            else :
            INDENT
                raise AttributeError
            DEDENT
        DEDENT
    DEDENT
    self.wrapper = CustomWrapper(matrix)
    import functools
    for op in OverflowPreventer.inverse_operator.keys() :
    INDENT
        setattr(CustomWrapper, op, functools.partial(self.wrapper._overflow_operator, forward_operator = op))
    DEDENT
DEDENT
----------------------------------------

def __init__(self, matrix) :
INDENT
    assert matrix.dtype == numpy.uint8
    self.overflow_matrix = matrix
    self.overflow_lower_range = float(0)
    self.overflow_upper_range = float(2 ** 8 - 1)
    for op in OverflowPreventer.bypass_operators :
    INDENT
        setattr(CustomWrapper, op, getattr(self.overflow_matrix, op))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12879208_12879220_1_28
12879208_12879337_3_19
Title: Refactor this views code 
----------------------------------------

def average(request) :
INDENT
    cal_list = []
    cal_list2 = []
    cal_list3 = []
    exams = Test.objects.filter(test__test_name__iexact = "one")
    for item in exams :
    INDENT
        cal_list.append(int(item.start))
        cal_list2.append(int(item.s1))
        cal_list3.append(int(item.s2))
    DEDENT
    result = sum(cal_list) / float(165) * 100
    result = result / len(cal_list)
    result = int(round(result))
    result = str(result) + '%'
    result2 = sum(cal_list2) / float(165) * 100
    result2 = result2 / len(cal_list2)
    result2 = int(round(result2))
    result2 = str(result2) + '%'
    result3 = sum(cal_list3) / float(165) * 100
    result3 = result3 / len(cal_list3)
    result3 = int(round(result3))
    result3 = str(result3) + '%'
    return direct_to_template(request, 'a.html', {'result' : result, 'result2' : result2, 'result3' : result3})
DEDENT
----------------------------------------

def average(request) :
INDENT
    queryset = Test.objects.filter(test__test_name__iexact = "one")
    total = queryset.count()
    results = queryset.aggregate(
        result1 = models.Sum('start'),
        result2 = models.Sum('s1'),
        result3 = models.Sum('s2'))
    def transform(resultsum) :
    INDENT
        result = resultsum / float(165) * 100
        result = result / total
        result = int(round(result))
        result = str(result) + '%'
        return result
    DEDENT
    result1 = transform(results ['result1'])
    result2 = transform(results ['result2'])
    result3 = transform(results ['result3'])
    return direct_to_template(request, 'a.html', {'result' : result1, 'result2' : result2, 'result3' : result3})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1288498_1288600_5_15
1288498_48240536_10_18
Title: Using the same decorator (with arguments) with functions and methods 
----------------------------------------

def __call__(self, func) :
INDENT
    @ wraps(func)
    def inner(* args, ** kwargs) :
    INDENT
        try :
        INDENT
            if args [0].method in self.methods :
            INDENT
                return func(* args, ** kwargs)
            DEDENT
        DEDENT
        except AttributeError :
        INDENT
            if args [1].method in self.methods :
            INDENT
                return func(* args, ** kwargs)
            DEDENT
        DEDENT
        return HttpResponseMethodNotAllowed(self.methods)
    DEDENT
    return inner
DEDENT
----------------------------------------

def __call__(self, * args, ** kwargs) :
INDENT
    if not self._wrapped :
    INDENT
        if self._obj :
        INDENT
            self._wrapped = self._wrap_method(self._func)
            self._wrapped = functools.partial(self._wrapped, self._obj)
        DEDENT
        else :
        INDENT
            self._wrapped = self._wrap_function(self._func)
        DEDENT
    DEDENT
    return self._wrapped(* args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12897374_25345327_1_12
12897374_42554212_1_10
Title: Get unique values from a list in python 
----------------------------------------

def unique(a) :
INDENT
    k = 0
    while k < len(a) :
    INDENT
        if a [k] in a [k + 1 :] :
        INDENT
            a.pop(k)
        DEDENT
        else :
        INDENT
            k = k + 1

        DEDENT
    DEDENT
    return a
DEDENT
----------------------------------------

def unique(sequence) :
INDENT
    seen = set()
    for value in sequence :
    INDENT
        if value in seen :
        INDENT
            continue
        DEDENT
        seen.add(value)
        yield value
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12923733_12928750_1_14
12923733_12962279_1_16
Title: Splitting list of possibly nested function expressions in Python 
----------------------------------------

def split_fns(fns) :
INDENT
    paren_stack_level = 0
    last_pos = 0
    output = []
    for curr_pos, curr_char in enumerate(fns) :
    INDENT
        if curr_char == "(" :
        INDENT
            paren_stack_level += 1
        DEDENT
        elif curr_char == ")" :
        INDENT
            paren_stack_level -= 1
            if not paren_stack_level :
            INDENT
                output.append(fns [last_pos : curr_pos + 1].lstrip(" ,"))
                last_pos = curr_pos + 1
            DEDENT
        DEDENT
    DEDENT
    return output
DEDENT
----------------------------------------

def split_fns(fns) :
INDENT
    level = 0
    stack = [[]]
    for ch in fns :
    INDENT
        if level == 0 and ch in [' ', ','] :
        INDENT
            continue
        DEDENT
        stack [- 1].append(ch)
        if ch == "(" :
        INDENT
            level += 1
        DEDENT
        elif ch == ")" :
        INDENT
            level -= 1
            if level == 0 :
            INDENT
                stack.append([])
            DEDENT
        DEDENT
    DEDENT
    return ["".join(t) for t in stack if t]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12953542_12954474_36_52
12953542_12977439_12_18
Title: Why does SimpleHTTPServer redirect to ?querystring/ when I request ?querystring? 
----------------------------------------

def do_GET(self) :
INDENT
    path = self.path
    self.uri = path.split("/") [1 :]
    actions = {
        "folder" : self.folder,
        }
    resource = self.uri [0]
    if not resource :
    INDENT
        return self.get_static_content()
    DEDENT
    action = actions.get(resource)
    if action :
    INDENT
        print "action from looking up '%s' is:" % resource, action
        return self.wfile.write(action())
    DEDENT
    SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)

DEDENT
----------------------------------------

def do_GET(self) :
INDENT
    if '?' in self.path :
    INDENT
        self.path = self.path.split('?') [0]
    DEDENT
    SimpleHTTPServer.SimpleHTTPRequestHandler.do_GET(self)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12979760_12981149_1_21
12979760_12981215_1_39
Title: Wait for successful response from API Call 
----------------------------------------

def returnJSONQuestion(questionId) :
INDENT
    randomSleep()
    jsondata = None
    url = 'http://answers.yahooapis.com/AnswersService/V1/getQuestion?appid=APPIDREMOVED8&question_id={0}&output=json'
    format_url = url.format(questionId)
    try :
    INDENT
        request = urllib2.Request(format_url)
        urlobject = urllib2.urlopen(request)
        time.sleep(10)
        jsondata = json.loads(urlobject.read().decode("utf-8"))
        print jsondata
    DEDENT
    except urllib2.HTTPError, e :
    INDENT
        print e.code
        logging.exception("Exception")
    DEDENT
    except urllib2.URLError, e :
    INDENT
        print e.reason
        logging.exception("Exception")
    DEDENT
    except (json.decoder.JSONDecodeError, ValueError) :
    INDENT
        print 'Question ID ' + questionId + ' Decode JSON has failed'
        logging.info("This qid didn't work " + questionId)
    DEDENT
    return jsondata
DEDENT
----------------------------------------

def returnJSONQuestion(questionId) :
INDENT
    url = 'http://answers.yahooapis.com/AnswersService/V1/getQuestion?appid=APPIDREMOVED8&question_id={0}&output=json'
    format_url = url.format(questionId)
    try :
    INDENT
        request = urllib2.Request(format_url)

        tries = 5
        while tries > = 0 :
        INDENT
            try :
            INDENT
                urlobject = urllib2.urlopen(request)
                jsondata = json.load(urlobject)
                print jsondata
                return jsondata
            DEDENT
            except :
            INDENT
                if tries == 0 :
                INDENT
                    raise
                DEDENT
                else :
                INDENT

                    time.sleep(3)
                    tries -= 1
                    continue
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    except urllib2.HTTPError, e :
    INDENT
        print e.code
        logging.exception("Exception")
        raise
    DEDENT
    except urllib2.URLError, e :
    INDENT
        print e.reason
        logging.exception("Exception")
        raise
    DEDENT
    except (json.decoder.JSONDecodeError, ValueError) :
    INDENT
        print 'Question ID ' + questionId + ' Decode JSON has failed'
        logging.info("This qid didn't work " + questionId)
        raise
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12993788_12994135_13_21
12993788_12994135_3_11
Title: I keep getting a naming error when i try to run this piece of code (Python) 
----------------------------------------

def __init__(self) :
INDENT
    super(DiceRoll, self).__init__(self)
    game_won = False
    p1_playing = p2_playing = True
    current_turn = 1
    current_players = [self.player1_title, self.player2_title]
    while game_won == False and p1_playing == True and p2_playing == True :
    INDENT
        if raw_input("Type 'Roll' to start your turn %s" % current_players [current_turn]).lower() == "roll" :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    select_game = raw_input("Do you want to start the game? ")
    if select_game.lower() == "yes" :
    INDENT
        self.player1_title = raw_input("What is Player 1's title? ").lower().title()
        self.player2_title = raw_input("What is Player 1's title? ").lower().title()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13003007_13003056_1_13
13003007_13003097_1_16
Title: What did I do wrong with this function? 
----------------------------------------

def insert_sequence(dna1, dna2, number) :
INDENT
    '''(str, str, int) -> str
    Return the DNA sequence obtained by inserting the second DNA sequence
    at the given index. (You can assume that the index is valid.)  

    >>> insert_sequence('CCGG', 'AT', 2)
    'CCATGG'
    >>> insert_sequence('TTGC', 'GG', 2)
    'TTGGGC'
    '''
    return dna1 [: number] + dna2 + dna1 [number :]
DEDENT
----------------------------------------

def insert_sequence(dna1, dna2, number) :
INDENT
    result = '';
    for ind, x in enumerate(dna1) :
    INDENT
        if ind == number :
        INDENT
            result = result + dna2 + x
        DEDENT
        else :
        INDENT
            result = result + x

        DEDENT
    DEDENT
    print (result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13003007_13003056_1_13
13003007_13003106_1_12
Title: What did I do wrong with this function? 
----------------------------------------

def insert_sequence(dna1, dna2, number) :
INDENT
    '''(str, str, int) -> str
    Return the DNA sequence obtained by inserting the second DNA sequence
    at the given index. (You can assume that the index is valid.)  

    >>> insert_sequence('CCGG', 'AT', 2)
    'CCATGG'
    >>> insert_sequence('TTGC', 'GG', 2)
    'TTGGGC'
    '''
    return dna1 [: number] + dna2 + dna1 [number :]
DEDENT
----------------------------------------

def insert_sequence(dna1, dna2, number) :
INDENT
    index = 0
    result = '';
    for char in dna1 :
    INDENT
        if index == number :
        INDENT
            result = result + dna2
            result = result + char
            index += len(dna2) + 1
        DEDENT
        else :
        INDENT
            result = result + char
            index += 1
        DEDENT
    DEDENT
    print (result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13003007_13003056_1_13
13003007_13003190_1_11
Title: What did I do wrong with this function? 
----------------------------------------

def insert_sequence(dna1, dna2, number) :
INDENT
    '''(str, str, int) -> str
    Return the DNA sequence obtained by inserting the second DNA sequence
    at the given index. (You can assume that the index is valid.)  

    >>> insert_sequence('CCGG', 'AT', 2)
    'CCATGG'
    >>> insert_sequence('TTGC', 'GG', 2)
    'TTGGGC'
    '''
    return dna1 [: number] + dna2 + dna1 [number :]
DEDENT
----------------------------------------

def insert_sequence(dna1, dna2, number) :
INDENT
    index = 0
    result = ''
    for character in dna1 :
    INDENT
        if index == number :
        INDENT
            result = result + dna2
        DEDENT
        result = result + character
        index += 1
    DEDENT
    print (result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13003007_13003097_1_16
13003007_13003190_1_11
Title: What did I do wrong with this function? 
----------------------------------------

def insert_sequence(dna1, dna2, number) :
INDENT
    result = '';
    for ind, x in enumerate(dna1) :
    INDENT
        if ind == number :
        INDENT
            result = result + dna2 + x
        DEDENT
        else :
        INDENT
            result = result + x

        DEDENT
    DEDENT
    print (result)
DEDENT
----------------------------------------

def insert_sequence(dna1, dna2, number) :
INDENT
    index = 0
    result = ''
    for character in dna1 :
    INDENT
        if index == number :
        INDENT
            result = result + dna2
        DEDENT
        result = result + character
        index += 1
    DEDENT
    print (result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13022307_13022330_15_27
13022307_13023164_4_10
Title: Why will my program that finds double letters not execute? Python 
----------------------------------------

def find_three_double(fin) :
INDENT
    count = 0
    for w in fin :
    INDENT
        w = w.strip()
        if three_double(w) :
        INDENT
            print w
            count = count + 1
        DEDENT
    DEDENT
    if count == 0 :
    INDENT
        print '<None found>'
    DEDENT
    else :
    INDENT
        print count, 'found'
    DEDENT
DEDENT
----------------------------------------

def find_three_double(words_file) :
INDENT
    for word in words_file :
    INDENT
        word = word.strip()
        if sum(sum(1 for i in g) == 2 for k, g in groupby(word)) == 3 :
        INDENT
            print word
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13032993_13260586_91_100
13032993_13282160_1_13
Title: Why does FigureCanvasTkAgg disables mouse scroll event in scrolled matplotlib GUI? 
----------------------------------------

def rollWheel(self, event) :
INDENT
    direction = 0
    if event.num == 5 or event.delta == - 120 :
    INDENT
        direction = 1
    DEDENT
    if event.num == 4 or event.delta == 120 :
    INDENT
        direction = - 1
    DEDENT
    self.canvas.yview_scroll(direction, UNITS)
DEDENT
----------------------------------------

def rollWheel(event) :
INDENT
    direction = 0
    if event.num == 5 or event.delta == - 120 :
    INDENT
        direction = 1
    DEDENT
    if event.num == 4 or event.delta == 120 :
    INDENT
        direction = - 1
    DEDENT
    canvas.yview_scroll(direction, UNITS)
    canvas.bind_all('<MouseWheel>', lambda event : rollWheel(event))
    canvas.bind_all('<Button-4>', lambda event : rollWheel(event))
    canvas.bind_all('<Button-5>', lambda event : rollWheel(event))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13055423_13057010_22_33
13055423_13070454_16_31
Title: Virtual column in QTableView? 
----------------------------------------

def data(self, index, role = Qt.DisplayRole) :
INDENT
    if index.isValid() :
    INDENT
        col = index.column()
        spot = self.items [index.row()]
        if role == Qt.DisplayRole :
        INDENT
            if col == 0 or col == 1 :
            INDENT
                return self.items [index.row()] [col]
            DEDENT
            elif col == 2 :
            INDENT
                return self.items [index.row()] [0] + self.items [index.row()] [1]
            DEDENT
            elif col == 3 :
            INDENT
                return self.items [index.row()] [2]
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def data(self, index, role = QtCore.Qt.DisplayRole) :
INDENT
    if role == QtCore.Qt.DisplayRole and index.column() == 2 :
    INDENT
        return sum(self.data(self.index(index.row(), i)).toInt() [0] for i in range(2))
    DEDENT
    if index.column() > 2 :
    INDENT

        index = self.index(index.row(), index.column() - 1)
    DEDENT
    return super(Model, self).data(index, role)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13059540_27736150_21_39
13059540_44840585_1_10
Title: "Using Python reverse an integer and tell if palindrome" 
----------------------------------------

def palindrome(n) :
INDENT
    total = 0
    while n > 0 :
    INDENT
        a = n % 10
        n //= 10

        total += a
    DEDENT
    if total == n :
    INDENT
        x = "This number has a palindrome"
    DEDENT
    else :
    INDENT
        x = ""
    DEDENT
    return x
DEDENT
----------------------------------------

def palindrome(x) :
INDENT
    a = ""
    x = str(x)
    for i in range(len(x), 0, - 1) :
    INDENT
        a += x [i - 1]
        print a
    DEDENT
    if a == x :
    INDENT
        return True
    DEDENT
    else :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13073855_13074419_1_18
13073855_13074533_7_17
Title: Python: script to import multiple LANDSAT images to Grass GIS 
----------------------------------------

def import_tifs(dirpath) :
INDENT
    for dirpath, dirname, filenames in os.walk(dirpath) :
    INDENT
        for tif_file in filenames :
        INDENT
            if tif_file.upper().endswith('.tif') :
            INDENT

                full_path = os.path.join(dirpath, tif_file)

                grass.message('Importing %s -> %s@%s...' % (full_path, tif_file, dirpath))
                grass.run_command('r.in.gdal',
                    flags = 'o',
                    input = full_path,
                    output = tif_file,
                    quiet = True,
                    overwrite = True)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def import_tifs(dirpath) :
INDENT
    for dirpath, dirname, filenames in os.walk(dirpath) :
    INDENT
        for filename in filenames :
        INDENT
            name, extension = os.path.splitext(filename)
            if extension.lower() == ".tif" :
            INDENT
                filepath = os.path.join(dirpath, filename)
                print (filepath, name, dirpath)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13074847_13075071_5_14
13074847_41283064_2_8
Title: Catching exception in context manager __enter__() 
----------------------------------------

def __enter__(self) :
INDENT
    try :
    INDENT
        raise Exception("Oops in __enter__")
    DEDENT
    except :
    INDENT
        if self.__exit__(* sys.exc_info()) :
        INDENT
            self.enter_ok = False
        DEDENT
        else :
        INDENT
            raise
        DEDENT
    DEDENT
    return self
DEDENT
----------------------------------------

def __enter__(self) :
INDENT
    try :
    INDENT
        pass
    DEDENT
    except Exception as e :
    INDENT
        self.__exit__(e)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13075804_13075863_1_11
13075804_13077449_15_21
Title: Search dir and subdirs 
----------------------------------------

def grep(regex, base_dir) :
INDENT
    matches = list()
    for dirpath, dirname, files in os.walk(base_dir) :
    INDENT
        for directory in dirname :
        INDENT
            for filename in os.listdir(directory) :
            INDENT
                with open(os.path.join(base_dir, directory, filename)) as fh :
                INDENT
                    content = fh.read()
                    matches = matches + re.findall(regex, content)
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return matches
DEDENT
----------------------------------------

def grep(regex, base_dir = ".") :
INDENT
    matches = []
    for dir, files in walktree(base_dir) :
    INDENT
        for file in files :
        INDENT
            filename = os.path.join(dir, file)
            matches.append(find_file_matches(filename, regex))
        DEDENT
    DEDENT
    return matches
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13078350_13078515_2_10
13078350_13078520_9_15
Title: How to handle these class-function calls the Pythonic way? 
----------------------------------------

def __init__(self, dictionary) :
INDENT
    self.input = dictionary
    if len(dictionary) > 1 :
    INDENT
        print 'More than 1'
        self.command = Chemistry(self.input)
    DEDENT
    else :
    INDENT
        print 'Less or equal'
        self.command = English(self.input)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, pages) :
INDENT
    if type(pages) == Page :
    INDENT
        self.pages = [pages]
    DEDENT
    elif type(pages) == list :
    INDENT
        self.pages = pages
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13114359_13120242_5_24
13114359_25232369_7_26
Title: How to take input from Tkinter 
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tk()
    self.root.wm_title("Question 7")
    self.label = Label(self.root, text = "Enter your weight in pounds.")
    self.label.pack()

    self.entrytext = StringVar()
    Entry(self.root, textvariable = self.entrytext).pack()
    self.buttontext = StringVar()
    self.buttontext.set("Calculate")
    Button(self.root, textvariable = self.buttontext, command = self.clicked1).pack()
    self.label = Label(self.root, text = "")
    self.label.pack()
    self.root.mainloop()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tk.Tk()
    self.root.wm_title("Question 7")
    self.label = Tk.Label(self.root, text = "Enter your weight in pounds.")
    self.label.pack()
    self.weight_in_kg = Tk.StringVar()
    Tk.Entry(self.root, textvariable = self.weight_in_kg).pack()
    self.buttontext = Tk.StringVar()
    self.buttontext.set("Calculate")
    Tk.Button(self.root,
        textvariable = self.buttontext,
        command = self.clicked1).pack()
    self.label = Tk.Label(self.root, text = "")
    self.label.pack()
    self.root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13144010_13144812_1_32
13144010_13144930_2_9
Title: How do I replace parts of a string? 
----------------------------------------

def generate_next_fmla(complete_fmla, partial_fmla, symbol) :
INDENT
    if '-' in complete_fmla :
    INDENT
        raise ValueError("comple_fmla contains '-'")
    DEDENT
    partial_fmla = partial_fmla.replace(' ', '')
    if len(complete_fmla) ! = len(partial_fmla) :
    INDENT
        raise ValueError("complete_fmla does not have the same lenght as partial_fmla")
    DEDENT
    if symbol not in complete_fmla or symbol in partial_fmla :
    INDENT
        return partial_fmla

    DEDENT
    result = ''
    for i in range(len(partial_fmla)) :
    INDENT
        if partial_fmla [i] == '-' and complete_fmla [i] == symbol :
        INDENT

            result += symbol
        DEDENT
        else :
        INDENT

            result += partial_fmla [i]
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def generate_next_fmla(s_str, fmla, c_char) :
INDENT
    i = 0
    for s in s_str :
    INDENT
        if c_char is s : lst_fmla.append(c_char)
        elif fmla [i] ! = '-' : lst_fmla.append(fmla [i])
        else : lst_fmla.append('-')
        i = i + 1
    DEDENT
    print (''.join(lst_fmla))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13146064_13146364_20_31
13146064_13146494_9_16
Title: Simple Python Webserver to save file 
----------------------------------------

def do_GET(self) :
INDENT
    response = """
        <html><body>
        <form enctype="multipart/form-data" method="post"><![CDATA[
        <p>File: <input type="file" name="file"><![CDATA[</p>
        <p><input type="submit" value="Upload"><![CDATA[</p>
        </form>
        </body></html>
        """
    self.respond(response)
DEDENT
----------------------------------------

def do_GET(self) :
INDENT
    if self.path == '/store.json' :
    INDENT
        with open(self.store_path) as fh :
        INDENT
            self.send_response(200)
            self.send_header('Content-type', 'text/json')
            self.end_headers()
            self.wfile.write(fh.read().encode())
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13146064_13146364_6_19
13146064_13146494_17_27
Title: Simple Python Webserver to save file 
----------------------------------------

def do_POST(self) :
INDENT
    form = cgi.FieldStorage(
        fp = self.rfile,
        headers = self.headers,
        environ = {'REQUEST_METHOD' : 'POST',
            'CONTENT_TYPE' : self.headers ['Content-Type'],
            })
    filename = form ['file'].filename
    data = form ['file'].file.read()
    open("/tmp/%s" % filename, "wb").write(data)
    self.respond("uploaded %s, thanks" % filename)
DEDENT
----------------------------------------

def do_POST(self) :
INDENT
    if self.path == '/store.json' :
    INDENT
        length = self.headers ['content-length']
        data = self.rfile.read(int(length))
        with open(self.store_path, 'w') as fh :
        INDENT
            fh.write(data.decode())
        DEDENT
        self.send_response(200)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13161694_13162011_1_10
13161694_13162049_7_26
Title: "Python defining a function and accessing it" 
----------------------------------------

def Jumble_One_Word(word) :
INDENT
    if len(word) < = 2 :
    INDENT
        return word
    DEDENT
    first_letter = word [0]
    last_letter = word [- 1]
    letters = list(word [1 : - 1])
    random.shuffle(letters)
    middle_letters = "".join(letters)
    return "".join([first_letter, middle_letters, last_letter])
DEDENT
----------------------------------------

def Jumble_One_Word(x) :
INDENT
    if len(x) > 2 :
    INDENT

        first_letter = x [0]
        last_letter = x [- 1]
        letters = list(x [1 : - 1])
        random.shuffle(letters)
        middle_letters = "".join(letters)
        final_word = "".join([first_letter, middle_letters, last_letter])
        return final_word

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1318935_1319109_1_14
1318935_1327425_1_22
Title: Python list filtering: remove subsets from list of lists 
----------------------------------------

def is_sublist_of_any_list(cand, lists) :
INDENT
    def is_sublist_of_list(cand, target) :
    INDENT
        try :
        INDENT
            i = 0
            for c in cand :
            INDENT
                i = 1 + target.index(c, i)
            DEDENT
            return True
        DEDENT
        except ValueError :
        INDENT
            return False
        DEDENT
    DEDENT
    return any(is_sublist_of_list(cand, target) for target in lists if len(cand) < = len(target))

DEDENT
----------------------------------------

def is_sublist_of_any_list(cand, lists) :
INDENT
    def is_sublist_of_list(cand, target) :
    INDENT
        try :
        INDENT
            i = 0
            try :
            INDENT
                start = target.index(cand [0])
            DEDENT
            except :
            INDENT
                return False
            DEDENT
            while start < (len(target) + len(cand)) - start :
            INDENT
                if cand == target [start : len(cand)] :
                INDENT
                    return True
                DEDENT
                else :
                INDENT
                    start = target.index(cand [0], start + 1)
                DEDENT
            DEDENT
        DEDENT
        except ValueError :
        INDENT
            return False

        DEDENT
    DEDENT
    return any(is_sublist_of_list(cand, target) for target in lists if len(cand) < = len(target))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1318935_1319109_3_11
1318935_1327425_3_19
Title: Python list filtering: remove subsets from list of lists 
----------------------------------------

def is_sublist_of_list(cand, target) :
INDENT
    try :
    INDENT
        i = 0
        for c in cand :
        INDENT
            i = 1 + target.index(c, i)
        DEDENT
        return True
    DEDENT
    except ValueError :
    INDENT
        return False
    DEDENT
DEDENT
----------------------------------------

def is_sublist_of_list(cand, target) :
INDENT
    try :
    INDENT
        i = 0
        try :
        INDENT
            start = target.index(cand [0])
        DEDENT
        except :
        INDENT
            return False
        DEDENT
        while start < (len(target) + len(cand)) - start :
        INDENT
            if cand == target [start : len(cand)] :
            INDENT
                return True
            DEDENT
            else :
            INDENT
                start = target.index(cand [0], start + 1)
            DEDENT
        DEDENT
    DEDENT
    except ValueError :
    INDENT
        return False

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13190758_18731796_8_20
13190758_28279397_7_21
Title: Django : Case insensitive matching of username from auth user? 
----------------------------------------

def authenticate(self, username = None, password = None) :
INDENT
    username = username.lower()
    if '@' in username :
    INDENT
        kwargs = {'email' : username}
    DEDENT
    else :
    INDENT
        kwargs = {'username' : username}
    DEDENT
    try :
    INDENT
        user = User.objects.get(** kwargs)
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except User.DoesNotExist :
    INDENT
        return None
    DEDENT
DEDENT
----------------------------------------

def authenticate(self, username = None, password = None, ** kwargs) :
INDENT
    UserModel = get_user_model()
    if username is None :
    INDENT
        username = kwargs.get(UserModel.USERNAME_FIELD)
    DEDENT
    try :
    INDENT
        d = {'%s__iexact' % UserModel.USERNAME_FIELD : username}
        user = UserModel.objects.get(** d)
        if user.check_password(password) :
        INDENT
            return user
        DEDENT
    DEDENT
    except UserModel.DoesNotExist :
    INDENT

        UserModel().set_password(password)
    DEDENT
    return None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1319763_1320202_8_12
1319763_1320943_8_13
Title: Key-ordered dict in Python 
----------------------------------------

def __setitem__(self, k, v) :
INDENT
    if k not in self.d :
    INDENT
        self.L.append(k)
        self.sorted = False
    DEDENT
    self.d [k] = v
DEDENT
----------------------------------------

def __setitem__(self, k, v) :
INDENT
    if not k in self.d :
    INDENT
        idx = bisect.bisect(self.l, k)
        self.l.insert(idx, k)
        self.d [k] = v
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13206798_26549002_1_11
13206798_32740120_9_20
Title: somethig like cron (timer) in gevent 
----------------------------------------

def run_regularly(self, function, interval, * args, ** kwargs) :
INDENT
    while True :
    INDENT
        before = time.time()
        function(* args, ** kwargs)
        duration = time.time() - before
        if duration < interval :
        INDENT
            gevent.sleep(interval - duration)
        DEDENT
        else :
        INDENT
            warning("function %s duration exceeded %f interval (took %f)" % (
                    function.__name__, interval, duration))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def run_regularly(function, intervals, sleep_time = 0.1, round_length = 1) :
INDENT
    _, init = divmod(time.time(), 1)
    gevent.sleep(1 - init)
    while True :
    INDENT
        before = time.time()
        _, offset = divmod(before, round_length)
        for div in intervals :
        INDENT
            function(sleep_time, div)
            after = time.time() - before
            if after < (div * round_length) :
            INDENT
                gevent.sleep((div * round_length) - after - (offset / len(intervals)))
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13210822_13213165_4_16
13210822_24524759_7_29
Title: How can I align the text in a StatusBar to the right in wxPython? 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.StatusBar.__init__(self, parent, - 1)
    self.SetFieldsCount(2)
    self.SetStatusWidths([- 1, - 1])

    self.version_label = wx.StaticText(self, - 1, 'Version: ' + VERSION)
    self.reposition_version_label()

    self.Bind(wx.EVT_SIZE, self.on_resize)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent)
    version = "v. 1.0.32 (2012-11-03)"
    version_size = wx.Window.GetTextExtent(self, version)

    self.CreateStatusBar(2)

    self.SetStatusWidths([- 1, version_size.width])
    self.SetStatusText("left status bar text", 0)
    self.SetStatusText(version, 1)
    self.Show()

    run_version_updates = threading.Thread(target = self.thread_version_updating)
    run_version_updates.start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13212814_13212826_1_10
13212814_13212839_1_10
Title: changing values inside a local space by a function in that local space 
----------------------------------------

def foo() :
INDENT
    foobar = []
    def bar() :
    INDENT
        foobar [0] = 'foobaz'
    DEDENT
    foobar [0] = 'foobar'
    print foobar [0]
    bar()
    print foobar [0]
DEDENT
----------------------------------------

def foo() :
INDENT
    def bar() :
    INDENT
        foobar = 'foobaz'
        return foobar
    DEDENT
    foobar = 'foobar'
    print foobar
    foobar = bar()
    print foobar
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13215215_13215255_7_16
13215215_13215520_20_31
Title: Python Tkinter Animation 
----------------------------------------

def __init__(self) :
INDENT
    self.root = Tk()
    self.canvas = Canvas(self.root, width = 400, height = 400)
    self.canvas.pack()
    self.alien1 = self.canvas.create_oval(20, 260, 120, 360, outline = 'white', fill = 'blue')
    self.alien2 = self.canvas.create_oval(2, 2, 40, 40, outline = 'white', fill = 'red')
    self.canvas.pack()
    self.root.after(0, self.animation)
    self.root.mainloop()
DEDENT
----------------------------------------

def __init__(self, master, ** kwargs) :
INDENT
    self.master = master
    self.canvas = tk.Canvas(self.master, width = 400, height = 400)
    self.canvas.pack()
    self.aliens = [
        Alien(self.canvas, 20, 260, 120, 360,
            outline = 'white', fill = 'blue'),
        Alien(self.canvas, 2, 2, 40, 40, outline = 'white', fill = 'red'),
        ]
    self.canvas.pack()
    self.master.after(0, self.animation)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13219041_13220164_4_9
13219041_13221622_4_9
Title: How can I speed up transition matrix creation in Numpy? 
----------------------------------------

def increment_counts_in_matrix_from_chain(markov_chain, transition_counts_matrix) :
INDENT
    for i in xrange(1, len(markov_chain)) :
    INDENT
        old_state = markov_chain [i - 1]
        new_state = markov_chain [i]
        transition_counts_matrix [old_state, new_state] += 1
    DEDENT
DEDENT
----------------------------------------

def increment_counts_in_matrix_from_chain(markov_chain, transition_counts_matrix) :
INDENT
    for i in xrange(1, len(markov_chain)) :
    INDENT
        old_state = markov_chain [i - 1]
        new_state = markov_chain [i]
        transition_counts_matrix [old_state, new_state] += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13225312_13227128_1_10
13225312_13228021_3_10
Title: Interleave two lists of different length in python v. 2? 
----------------------------------------

def interleave(lista, listb) :
INDENT
    (tempa, tempb) = ([i for i in reversed(lista)], [i for i in reversed(listb)])
    result = []
    while tempa or tempb :
    INDENT
        if tempa :
        INDENT
            result.append(tempa.pop())
        DEDENT
        if tempb :
        INDENT
            result.append(tempb.pop())
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def interleave(lst1, lst2) :
INDENT
    minlen = min(len(lst1), len(lst2))
    tail = lst1 [minlen :] + lst2 [minlen :]
    result = []
    for t in zip(lst1, lst2) :
    INDENT
        result.extend(t)
    DEDENT
    return result + tail
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13248487_13248703_12_26
13248487_15770889_1_16
Title: (semi-) automatic generation of argparsers for functions 
----------------------------------------

def main(db, header, sqlcmd, delimiter = "|", * scripts) :
INDENT
    "A script to run queries and SQL scripts on a database"
    yield 'Working on %s' % db.bind.url
    if sqlcmd :
    INDENT
        result = db.bind.execute(sqlcmd)
        if header :
        INDENT
            yield delimiter.join(result.keys())
        DEDENT
        for row in result :
        INDENT
            yield delimiter.join(map(str, row))
        DEDENT
    DEDENT
    for script in scripts :
    INDENT
        db.bind.execute(open(script).read())
        yield 'executed %s' % script
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    parser = argparse.ArgumentParser(description = 'hyde - a python static website generator',
        epilog = 'Use %(prog)s {command} -h to get help on individual commands')
    parser.add_argument('-v', '--version', action = 'version', version = '%(prog)s ' + __version__)
    parser.add_argument('-s', '--sitepath', action = 'store', default = '.', help = "Location of the hyde site")
    subcommands = parser.add_subparsers(title = "Hyde commands",
        description = "Entry points for hyde")
    init_command = subcommands.add_parser('init', help = 'Create a new hyde site')
    init_command.set_defaults(run = init)
    init_command.add_argument('-t', '--template', action = 'store', default = 'basic', dest = 'template',
        help = 'Overwrite the current site if it exists')
    init_command.add_argument('-f', '--force', action = 'store_true', default = False, dest = 'force',
        help = 'Overwrite the current site if it exists')
    args = parser.parse_args()
    args.run(args)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13264388_13264569_2_19
13264388_13264889_11_28
Title: Python -- Determine Frequency of numbers showing up in dice rolls 
----------------------------------------

def roll_dice(n) :
INDENT
    d = defaultdict(int)
    for i in range(n) :
    INDENT
        res = roll()
        d [res] += 1
        print (res)
    DEDENT
    print ("RESULTS")
    for key, value in sorted(d.items()) :
    INDENT
        percent = float(value) / n * 100
        print ('{0:2d}:{1:4d}\t({2:6f}%)\t{3}'.format(key, value, percent, int(percent) * '*'))
    DEDENT
DEDENT
----------------------------------------

def roll_dice(npts) :
INDENT
    bins = dict([(n, 0) for n in xrange(2, 13, 1)])
    for n in xrange(npts) :
    INDENT
        idx = roll()
        print idx
        bins [idx] = bins [idx] + 1
    DEDENT
    for n in xrange(2, 13, 1) :
    INDENT
        pct = bins [n] / float(npts) * 100.0
        pct_star = ''
        for i in xrange(int(math.floor(pct))) :
        INDENT
            pct_star = pct_star + '*'
        DEDENT
        str = "{0:.1f}%".format(pct).rjust(5, ' ')
        print "{0:2d}:  {1:5d} ({2:s})  {3:s}".format(n, bins [n], str, pct_star)
    DEDENT
    print "------------------"
    print "{0:10d} rolls".format(npts)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1327362_1327494_6_16
1327362_1327564_3_11
Title: Code refactoring with python decorators? 
----------------------------------------

def wrapper(* args) :
INDENT
    if self.show :
    INDENT
        print "inside", f
    DEDENT
    rv = f(* args)
    if self.show :
    INDENT
        print "outside", f
    DEDENT
    return rv
DEDENT
----------------------------------------

def wrapper(parm1, parm2) :
INDENT
    if parm1 :
    INDENT
        code_chunk_1
    DEDENT
    func(parm1, parm2)
    if parm2 :
    INDENT
        code_chunk_2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13276124_13276448_14_27
13276124_13276845_11_17
Title: Check if parent thread is running 
----------------------------------------

def parent() :
INDENT
    quitEvent = Event()
    t = Thread(target = child, args = (quitEvent,))
    t.start()
    try :
    INDENT
        time.sleep(2)
        raise Exception("Parent thread raises exception")
    DEDENT
    finally :
    INDENT
        quitEvent.set()
    DEDENT
    t.join()

DEDENT
----------------------------------------

def parent() :
INDENT
    t = threading.Thread(target = child)
    t.start()
    for i in range(10) :
    INDENT
        print ('parent alife')
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13276124_13276448_5_13
13276124_13276845_3_10
Title: Check if parent thread is running 
----------------------------------------

def child(quit) :
INDENT
    for _ in xrange(10) :
    INDENT
        if quit.isSet() :
        INDENT
            print "Parent is dead. Leaving child."
            return
        DEDENT
        print "Child alive"
        time.sleep(.5)
    DEDENT
DEDENT
----------------------------------------

def child() :
INDENT
    while True :
    INDENT
        time.sleep(1)
        if not parent_thread.isAlive() :
        INDENT
            break
        DEDENT
        print ('child alife')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13309523_13310007_3_15
13309523_14371369_3_14
Title: Create a facebook notification with Django package facepy : [15] (#15) This method must be called with an app access_token 
----------------------------------------

def notify_self(request) :
INDENT
    token = request.facebook.user.oauth_token.token
    token_app = facepy.utils.get_application_access_token('APP_ID', 'APP_SECRET_ID')
    graph = GraphAPI(token)
    graph.post(
        path = 'me/notifications',
        template = '#Text of the notification',
        href = 'URL',
        access_token = token_app)
    return HttpResponse('<script type=\'text/javascript\'>top.location.href = \'URL\'</script>')
DEDENT
----------------------------------------

def notify_self(request) :
INDENT
    token_app = facepy.utils.get_application_access_token(
        settings.FACEBOOK_APPLICATION_ID,
        settings.FACEBOOK_APPLICATION_SECRET_KEY)
    graph = GraphAPI(token_app)
    graph.post(
        path = '%s/notifications' % request.facebook.user.facebook_id,
        template = '#Text of the notification',
        href = 'my targe URL',
        )
    return 'etc'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13309523_14371369_3_14
13309523_15148236_3_12
Title: Create a facebook notification with Django package facepy : [15] (#15) This method must be called with an app access_token 
----------------------------------------

def notify_self(request) :
INDENT
    token_app = facepy.utils.get_application_access_token(
        settings.FACEBOOK_APPLICATION_ID,
        settings.FACEBOOK_APPLICATION_SECRET_KEY)
    graph = GraphAPI(token_app)
    graph.post(
        path = '%s/notifications' % request.facebook.user.facebook_id,
        template = '#Text of the notification',
        href = 'my targe URL',
        )
    return 'etc'
DEDENT
----------------------------------------

def notify_self(request) :
INDENT
    token_app = facepy.utils.get_application_access_token('APP_ID', 'APP_SECRET_ID')
    graph = GraphAPI(token_app)
    graph.post(
        path = 'me/notifications',
        template = '#Text of the notification',
        href = 'URL')
    return HttpResponse('<script type=\'text/javascript\'>top.location.href = \'URL\'</script>')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13313069_13317528_2_11
13313069_21976794_8_14
Title: keeping a variable inside a range in python 
----------------------------------------

def __new__(cls, * args, ** kwargs) :
INDENT
    lower, upper = bounds = kwargs.pop('bounds')
    val = int.__new__(cls, * args, ** kwargs)
    val = lower if val < lower else upper if val > upper else val
    val = super(BoundedInt, cls).__new__(cls, val)
    val._bounds = bounds
    return val
DEDENT
----------------------------------------

def __new__(cls, name, bases, attrs) :
INDENT
    classobj = type.__new__(cls, name, bases, attrs)
    for name, meth in ((n, m) for n, m in vars(int).items() if n in cls._ops) :
    INDENT
        setattr(classobj, name, cls._WrappedMethod(cls, meth))
    DEDENT
    return classobj
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13314626_13391683_66_95
13314626_13423957_7_26
Title: Local solar time function from UTC and longitude 
----------------------------------------

def hour_angle(dt, longit) :
INDENT
    y = dt.year
    m = dt.month
    d = dt.day + ((dt.second / 60.0 + dt.minute) / 60 + dt.hour) / 24.0

    ra, _ = coords(y, m, d)

    if m < = 2 :
    INDENT
        y -= 1
        m += 12
    DEDENT
    a = y / 100
    b = 2 - a + a / 4
    jd = int(365.25 * (y + 4716)) + int(30.6 * (m + 1)) + d + b - 1524.5

    t = (jd - 2451545.0) / 36525
    theta = 280.46061837 + 360.98564736629 * (jd - 2451545) +.000387933 * t ** 2 - t ** 3 / 38710000

    ha = (theta + longit - ra / DEG_TO_RAD) % 360
    return ha
DEDENT
----------------------------------------

def hour_angle(dt, longit, latit, elev) :
INDENT
    obs = ephem.Observer()
    obs.date = dt.strftime('%Y/%m/%d %H:%M:%S')
    obs.lon = longit
    obs.lat = latit
    obs.elevation = elev
    sun = ephem.Sun()
    sun.compute(obs)
    ra = ephem.degrees(sun.g_ra) - 2 * ephem.pi

    jd = ephem.julian_date(dt)
    t = (jd - 2451545.0) / 36525
    theta = 280.46061837 + 360.98564736629 * (jd - 2451545) +.000387933 * t ** 2 - t ** 3 / 38710000

    ha = (theta + longit - ra * 180 / ephem.pi) % 360
    return ha
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13314626_13391683_96_112
13314626_13424528_10_25
Title: Local solar time function from UTC and longitude 
----------------------------------------

def main() :
INDENT
    if len(sys.argv) ! = 4 :
    INDENT
        print 'Usage: hour_angle.py [YYYY/MM/DD] [HH:MM:SS] [longitude]'
        sys.exit()
    DEDENT
    else :
    INDENT
        dt = datetime.strptime(sys.argv [1] + ' ' + sys.argv [2], '%Y/%m/%d %H:%M:%S')
        longit = float(sys.argv [3])
    DEDENT
    ha = hour_angle(dt, longit)
    days = ha / 360
    if days > 0.5 :
    INDENT
        days -= 0.5
    DEDENT
    td = timedelta(days = days)
    solar_time = datetime.combine(dt.date(), time(12)) + td
    print solar_time
DEDENT
----------------------------------------

def main() :
INDENT
    if len(sys.argv) ! = 4 :
    INDENT
        print 'Usage: hour_angle.py [YYYY/MM/DD] [HH:MM:SS] [longitude]'
        sys.exit()
    DEDENT
    else :
    INDENT
        dt = datetime.strptime(sys.argv [1] + ' ' + sys.argv [2], '%Y/%m/%d %H:%M:%S')
        longit = float(sys.argv [3])
    DEDENT
    gamma = 2 * pi / 365 * (dt.timetuple().tm_yday - 1 + float(dt.hour - 12) / 24)
    eqtime = 229.18 * (0.000075 + 0.001868 * cos(gamma) - 0.032077 * sin(gamma) - 0.014615 * cos(2 * gamma) - 0.040849 * sin(2 * gamma))
    decl = 0.006918 - 0.399912 * cos(gamma) + 0.070257 * sin(gamma) - 0.006758 * cos(2 * gamma) + 0.000907 * sin(2 * gamma) - 0.002697 * cos(3 * gamma) + 0.00148 * sin(3 * gamma)
    time_offset = eqtime + 4 * longit
    tst = dt.hour * 60 + dt.minute + dt.second / 60 + time_offset
    solar_time = datetime.combine(dt.date(), time(0)) + timedelta(minutes = tst)
    print solar_time
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13314626_13423957_27_49
13314626_13424528_10_25
Title: Local solar time function from UTC and longitude 
----------------------------------------

def main() :
INDENT
    if len(sys.argv) ! = 6 :
    INDENT
        print 'Usage: hour_angle.py [YYYY/MM/DD] [HH:MM:SS] [longitude] [latitude] [elev]'
        sys.exit()
    DEDENT
    else :
    INDENT
        dt = datetime.strptime(sys.argv [1] + ' ' + sys.argv [2], '%Y/%m/%d %H:%M:%S')
        longit = float(sys.argv [3])
        latit = float(sys.argv [4])
        elev = float(sys.argv [5])

    DEDENT
    ha = hour_angle(dt, longit, latit, elev)

    days = ha / 360
    if days > 0.5 :
    INDENT
        days -= 0.5
    DEDENT
    td = timedelta(days = days)

    solar_time = datetime.combine(dt.date(), time(12)) + td
    print solar_time
DEDENT
----------------------------------------

def main() :
INDENT
    if len(sys.argv) ! = 4 :
    INDENT
        print 'Usage: hour_angle.py [YYYY/MM/DD] [HH:MM:SS] [longitude]'
        sys.exit()
    DEDENT
    else :
    INDENT
        dt = datetime.strptime(sys.argv [1] + ' ' + sys.argv [2], '%Y/%m/%d %H:%M:%S')
        longit = float(sys.argv [3])
    DEDENT
    gamma = 2 * pi / 365 * (dt.timetuple().tm_yday - 1 + float(dt.hour - 12) / 24)
    eqtime = 229.18 * (0.000075 + 0.001868 * cos(gamma) - 0.032077 * sin(gamma) - 0.014615 * cos(2 * gamma) - 0.040849 * sin(2 * gamma))
    decl = 0.006918 - 0.399912 * cos(gamma) + 0.070257 * sin(gamma) - 0.006758 * cos(2 * gamma) + 0.000907 * sin(2 * gamma) - 0.002697 * cos(3 * gamma) + 0.00148 * sin(3 * gamma)
    time_offset = eqtime + 4 * longit
    tst = dt.hour * 60 + dt.minute + dt.second / 60 + time_offset
    solar_time = datetime.combine(dt.date(), time(0)) + timedelta(minutes = tst)
    print solar_time
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13366830_13366858_1_11
13366830_30958226_3_12
Title: Collatz conjecture sequence 
----------------------------------------

def collatz_sequence(x) :
INDENT
    seq = [x]
    if x < 1 :
    INDENT
        return []
    DEDENT
    while x > 1 :
    INDENT
        if x % 2 == 0 :
        INDENT
            x = x / 2
        DEDENT
        else :
        INDENT
            x = 3 * x + 1
        DEDENT
        seq.append(x)
    DEDENT
    return seq
DEDENT
----------------------------------------

def collatz_sequence(x) :
INDENT
    global seq
    seq.append(x)
    if x == 1 :
    INDENT
        return
    DEDENT
    if (x % 2) == 0 :
    INDENT
        collatz_sequence(x / 2)
    DEDENT
    else :
    INDENT
        collatz_sequence((x * 3) + 1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13379823_13382631_5_15
13379823_13412638_3_9
Title: How to vectorize a simple for loop in Python/Numpy 
----------------------------------------

def is_less(a, b) :
INDENT
    i = 0
    while i < len(a) :
    INDENT
        if a [i] < b [i] :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            if a [i] > b [i] :
            INDENT
                return False
            DEDENT
        DEDENT
        i += 1
    DEDENT
    return False
DEDENT
----------------------------------------

def is_less(a, b) :
INDENT
    for i in range(len(a) - 1, - 1, - 1) :
    INDENT
        if a [i] < b [i] : return True
        elif a [i] > b [i] : return False
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13390835_13391080_18_23
13390835_13391080_6_13
Title: I have a complicated model issues... more info inside 
----------------------------------------

def clean(self) :
INDENT
    if (self.user.modelas.all().count() > 2) :
    INDENT
        raise ValidationError(
            "User may create may only create 3 modelAs ")
    DEDENT
    super(ModelA, self).clean()
DEDENT
----------------------------------------

def clean(self) :
INDENT
    if (self.modelA.modelbs.all().count() > 2) :
    INDENT
        raise ValidationError(
            "ModelA may create may only create 3 modelBs ")
    DEDENT
    super(ModelB, self).clean()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13392555_13397267_14_25
13392555_13397267_46_67
Title: Removing a QGraphicsItem's parent 
----------------------------------------

def __init__(self, position, parent = None) :
INDENT
    super(Test_Box, self).__init__(parent)

    self.setFlags(self.flags() |
        QGraphicsItem.ItemIsSelectable |
        QGraphicsItem.ItemIsMovable |
        QGraphicsItem.ItemIsFocusable |
        QGraphicsItem.ItemSendsScenePositionChanges)
    self.setPos(position)

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(Window, self).__init__(parent)
    self.scene = QGraphicsScene()
    self.item1 = Test_Box(QPointF(0, 0))
    self.item2 = Test_Box(QPointF(20, 20))
    self.item11 = Test_Box(QPointF(10, 5), self.item1)
    self.scene.addItem(self.item1)
    self.scene.addItem(self.item2)
    self.view = QGraphicsView(self.scene)
    self.listItems = QPushButton('list')
    self.listItems.clicked.connect(self.printItems)
    layout = QHBoxLayout()
    layout.addWidget(self.view)
    layout.addWidget(self.listItems)
    self.setLayout(layout)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13401296_13404223_5_11
13401296_13409383_5_10
Title: How to encrypt all possible strings in a defined character set python? 
----------------------------------------

def decrypt() :
INDENT
    hash1 = input("Please enter the hash: ")
    salt = input("Please enter the salt: ")
    charSet = string.ascii_letters + string.digits
    for wordchars in product(charSet, repeat = 2) :
    INDENT
        hash2 = crypt.crypt(''.join(wordchars), salt = salt)
        print (hash2)
    DEDENT
DEDENT
----------------------------------------

def decrypt(crypted, charset = ascii_letters + digits) :
INDENT
    for candidate in map(''.join, product(charset, repeat = 4)) :
    INDENT
        if crypted == crypt(candidate, crypted) :
        INDENT
            return candidate
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13407560_13407757_1_12
13407560_13407773_1_5
Title: Python reverse integer using recursion 
----------------------------------------

def reverseDisplay(number) :
INDENT
    if number < 10 :
    INDENT
        return number
    DEDENT
    first_digit = number % 10
    the_rest = reverseDisplay(number / / 10)
    ex = 0
    while 1 :
    INDENT
        ex = ex + 1
        if number / / (pow(10, ex)) == 0 :
        INDENT
            break
        DEDENT
    DEDENT
    ex = ex - 1
    return first_digit * pow(10, ex) + the_rest
DEDENT
----------------------------------------

def reverseDisplay(number) :
INDENT
    if number < 10 :
    INDENT
        return number
    DEDENT
    else :
    INDENT
        return int(str(number % 10) + str(reverseDisplay(number / / 10)))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13407560_13407757_1_12
13407560_27177347_1_14
Title: Python reverse integer using recursion 
----------------------------------------

def reverseDisplay(number) :
INDENT
    if number < 10 :
    INDENT
        return number
    DEDENT
    first_digit = number % 10
    the_rest = reverseDisplay(number / / 10)
    ex = 0
    while 1 :
    INDENT
        ex = ex + 1
        if number / / (pow(10, ex)) == 0 :
        INDENT
            break
        DEDENT
    DEDENT
    ex = ex - 1
    return first_digit * pow(10, ex) + the_rest
DEDENT
----------------------------------------

def reverseDisplay(variable) :
INDENT
    if variable / / 10 == 0 :
    INDENT
        print(variable, end = '')
        return
    DEDENT
    else :
    INDENT
        first = variable % 10
        every_dig_after = variable / / 10
        return reverseDisplay(variable % 10), reverseDisplay(every_dig_after)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13407560_13407757_1_12
13407560_36619583_1_8
Title: Python reverse integer using recursion 
----------------------------------------

def reverseDisplay(number) :
INDENT
    if number < 10 :
    INDENT
        return number
    DEDENT
    first_digit = number % 10
    the_rest = reverseDisplay(number / / 10)
    ex = 0
    while 1 :
    INDENT
        ex = ex + 1
        if number / / (pow(10, ex)) == 0 :
        INDENT
            break
        DEDENT
    DEDENT
    ex = ex - 1
    return first_digit * pow(10, ex) + the_rest
DEDENT
----------------------------------------

def reverseDisplay(number, k) :
INDENT
    if number > 0 :
    INDENT
        i = (k) * 10 + number % 10
        j = number / / 10
        return reverseDisplay(j, i)
    DEDENT
    else :
    INDENT
        return k
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13407560_13407773_1_5
13407560_27177347_1_14
Title: Python reverse integer using recursion 
----------------------------------------

def reverseDisplay(number) :
INDENT
    if number < 10 :
    INDENT
        return number
    DEDENT
    else :
    INDENT
        return int(str(number % 10) + str(reverseDisplay(number / / 10)))
    DEDENT
DEDENT
----------------------------------------

def reverseDisplay(variable) :
INDENT
    if variable / / 10 == 0 :
    INDENT
        print(variable, end = '')
        return
    DEDENT
    else :
    INDENT
        first = variable % 10
        every_dig_after = variable / / 10
        return reverseDisplay(variable % 10), reverseDisplay(every_dig_after)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13407560_13407773_1_5
13407560_36619583_1_8
Title: Python reverse integer using recursion 
----------------------------------------

def reverseDisplay(number) :
INDENT
    if number < 10 :
    INDENT
        return number
    DEDENT
    else :
    INDENT
        return int(str(number % 10) + str(reverseDisplay(number / / 10)))
    DEDENT
DEDENT
----------------------------------------

def reverseDisplay(number, k) :
INDENT
    if number > 0 :
    INDENT
        i = (k) * 10 + number % 10
        j = number / / 10
        return reverseDisplay(j, i)
    DEDENT
    else :
    INDENT
        return k
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13407560_27177347_1_14
13407560_36619583_1_8
Title: Python reverse integer using recursion 
----------------------------------------

def reverseDisplay(variable) :
INDENT
    if variable / / 10 == 0 :
    INDENT
        print(variable, end = '')
        return
    DEDENT
    else :
    INDENT
        first = variable % 10
        every_dig_after = variable / / 10
        return reverseDisplay(variable % 10), reverseDisplay(every_dig_after)

    DEDENT
DEDENT
----------------------------------------

def reverseDisplay(number, k) :
INDENT
    if number > 0 :
    INDENT
        i = (k) * 10 + number % 10
        j = number / / 10
        return reverseDisplay(j, i)
    DEDENT
    else :
    INDENT
        return k
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13421671_13421897_7_21
13421671_13423799_7_23
Title: Why is this Python script occasionally recursive? 
----------------------------------------

def match(giver) :
INDENT
    giverGender = givers [giver]
    Found = False
    while not Found :
    INDENT
        index = random.randrange(len(receivers))
        receiver = receivers.keys() [index]
        receiverGender = receivers.values() [index]
        if giver ! = receiver and giverGender == receiverGender :
        INDENT
            Found = True
            del receivers [receiver]
        DEDENT
    DEDENT
    return giver + ' to ' + receiver

DEDENT
----------------------------------------

def match(giver, receiver) :
INDENT
    for i in giver :
    INDENT

        rec = receiver [randint(0, len(receiver) - 1)]

        if len(receiver) == 2 :
        INDENT
            rec = receiver [1]

        DEDENT
        while i == rec :
        INDENT
            rec = receiver [randint(0, len(receiver) - 1)]
        DEDENT
        print i + " gives to " + rec
        receiver.remove(rec)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13423919_13424002_1_9
13423919_13424088_4_10
Title: Computing N Grams using Python 
----------------------------------------

def ngrams(input, n) :
INDENT
    input = input.split(' ')
    output = {}
    for i in range(len(input) - n + 1) :
    INDENT
        g = ' '.join(input [i : i + n])
        output.setdefault(g, 0)
        output [g] += 1
    DEDENT
    return output
DEDENT
----------------------------------------

def ngrams(message, n = 1) :
INDENT
    it = iter(message.split())
    window = deque(islice(it, n), maxlen = n)
    yield tuple(window)
    for item in it :
    INDENT
        window.append(item)
        yield tuple(window)
    DEDENT
DEDENT
----------------------------------------
