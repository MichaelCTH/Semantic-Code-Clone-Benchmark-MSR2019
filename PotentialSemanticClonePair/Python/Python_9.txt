$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18391038_18391327_55_63
18391038_18391327_82_103
Title: Deleting and Redrawing Matplotlib Animation 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.ui = Ui_MainWindow()
    self.direction = 'up'
    self.maxRadius = 0.3
    self.ui.setupUi(self, self.direction, self.maxRadius)
    self.ui.pushButton.clicked.connect(self.changeStuff)
    self.animation = self.ui.mplWidget.animate()
DEDENT
----------------------------------------

def __init__(self, parent = None, direction = 'up', maxRadius = 0.3) :
INDENT
    self.figure = Figure()
    super(MplWidget, self).__init__(self.figure)
    self.setParent(parent)
    self.axes = self.figure.add_subplot(111, projection = '3d')
    self.axes.set_xlabel("x label")
    self.axes.set_ylabel("y label")
    self.axes.set_zlabel("z label")
    self.axes.set_xlim3d([- 1, 1])
    self.axes.set_ylim3d([- 1, 1])
    self.axes.set_zlim3d([- 1, 1])
    self.axes.set_aspect('equal')
    if direction == 'up' :
    INDENT
        self.c = 1
    DEDENT
    elif direction == 'down' :
    INDENT
        self.c = - 1
    DEDENT
    else :
    INDENT
        self.c = 1
    DEDENT
    self.maxRadius = maxRadius
    self.frames = 50
    self.plot_handle = self.func_plot(self.frames)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18393572_18394154_18_22
18393572_18394154_6_17
Title: Assigning multiple variables in Python line-by-line analysis 
----------------------------------------

def add(name, * arg) :
INDENT
    if d.get(name) :
    INDENT
        d [name].add(arg)
    DEDENT
    else :
    INDENT
        d.update({name : phone(arg)})
    DEDENT
DEDENT
----------------------------------------

def add(self, arg) :
INDENT
    for i in self.phone :
    INDENT
        for j in arg :
        INDENT
            if i == j :
            INDENT
                print ("error")
                return 0
            DEDENT
        DEDENT
    DEDENT
    if len(self.phone) + len(arg) < = 3 :
    INDENT
        for j in arg :
        INDENT
            self.phone.append(j)
        DEDENT
    DEDENT
    else :
    INDENT
        print ("error")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18408881_18409472_1_14
18408881_18526083_19_25
Title: Leak when run subprocess in python 
----------------------------------------

def deactivateMetadataDevice(input_dmd_lun_wwn) :
INDENT
    status_cmd = False
    ps = subprocess.Popen('/sbin/pvremove /dev/mapper/' + input_dmd_lun_wwn, shell = True, stdout = subprocess.PIPE, stderr = subprocess.STDOUT)
    for line in ps.stdout :
    INDENT
        print line
        if 'wiped' in line :
        INDENT
            status_cmd = True
        DEDENT
    DEDENT
    ps.wait()
    if status_cmd is False :
    INDENT
        raise Warning('\t\t PV /dev/mapper/' + input_dmd_lun_wwn + ' belongs to Volume Group')
    DEDENT
    return status_cmd
DEDENT
----------------------------------------

def deactivateMetadataDevice(input_dmd_lun_wwn) :
INDENT
    status_cmd = False
    if 'wiped' in check_output(["/sbin/pvremove", "/dev/mapper/" + input_dmd_lun_wwn]) :
    INDENT
        status_cmd = True
    DEDENT
    return status_cmd
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18412463_18412943_1_15
18412463_18413053_1_17
Title: BlackJack Class Difficulties 
----------------------------------------

def get_value(self) :
INDENT
    value = 0
    for x in self.hand :
    INDENT
        if x > = 'A' :
        INDENT
            if x ! = 'A' :
            INDENT
                value += 10
            DEDENT
            else :
            INDENT
                if value > 6 :
                INDENT
                    value += 1
                DEDENT
                else :
                INDENT
                    value += 11
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT
            value += int(x)
        DEDENT
    DEDENT
    return value
DEDENT
----------------------------------------

def get_value(self) :
INDENT
    self.value = 0
    aces11 = 0
    for x in self.hand.split(',') :
    INDENT
        x = x.strip()
        if x in '2345678910' :
        INDENT
            self.value += int(x)
        DEDENT
        elif x == 'A' :
        INDENT
            self.value += 11
            aces11 += 1
        DEDENT
        else :
        INDENT
            self.value += 10
        DEDENT
        while self.value > 17 and aces11 > 0 :
        INDENT
            aces11 -= 1
            self.value -= 10
        DEDENT
    DEDENT
    return (self.value)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18418_15434620_1_12
18418_9979995_1_23
Title: Elegant way to remove items from sequence in Python? 
----------------------------------------

def filter_inplace(conditionFunc, list, reversed = False) :
INDENT
    index = 0
    while index < len(list) :
    INDENT
        item = list [index]
        shouldRemove = not conditionFunc(item)
        if reversed : shouldRemove = not shouldRemove
        if shouldRemove :
        INDENT
            list.remove(item)
        DEDENT
        else :
        INDENT
            index += 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def filter_inplace(func, original_list) :
INDENT
    new_list_size = 0
    for item in original_list :
    INDENT
        if func(item) :
        INDENT
            original_list [new_list_size] = item
            new_list_size += 1

        DEDENT
    DEDENT
    tail_size = len(original_list) - new_list_size
    while tail_size :
    INDENT
        original_list.pop()
        tail_size -= 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18427233_18427502_1_13
18427233_25111834_1_11
Title: Trying to turn fizzbuzz into a function in python 3 
----------------------------------------

def fizzbuzz(n) :
INDENT
    result = []
    for x in range(1, n + 1) :
    INDENT
        if x % 3 == 0 and x % 5 == 0 :
        INDENT
            result.append("fizz buzz")
        DEDENT
        elif x % 3 == 0 :
        INDENT
            result.append('fizz')
        DEDENT
        elif x % 5 == 0 :
        INDENT
            result.append('buzz')
        DEDENT
        else :
        INDENT
            result.append(str(x))
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def fizzbuzz(n) :
INDENT
    for x in range(1, n + 1) :
    INDENT
        if not x % 15 :
        INDENT
            yield 'fizz buzz'
        DEDENT
        elif not x % 3 :
        INDENT
            yield 'fizz'
        DEDENT
        elif not x % 5 :
        INDENT
            yield 'buzz'
        DEDENT
        else :
        INDENT
            yield x
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18432293_18432570_1_14
18432293_18432805_52_59
Title: Python: Refactor code to remove global variable 
----------------------------------------

def game() :
INDENT
    correct = 0
    while True :
    INDENT
        nums = gen_randoms(lower, higher)
        this_equation = gen_equation(nums)
        gen_answer = evaluate(this_equation)
        user_answer = int(raw_input("What is the answer? "))
        if user_answer == gen_answer :
        INDENT
            correct += 1
            print 'Correct!'
            print 'Current streak: %s' % str(correct)
        DEDENT
        else :
        INDENT
            print 'Incorrect!'
            correct = 0
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def game(self, correct) :
INDENT
    nums = self.gen_randoms(self.lower, self.higher)
    this_equation = self.gen_equation(nums)
    gen_answer = self.evaluate(this_equation)
    self.compare_answers(gen_answer)
    self.game()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18432293_18432570_1_14
18432293_18433251_5_23
Title: Python: Refactor code to remove global variable 
----------------------------------------

def game() :
INDENT
    correct = 0
    while True :
    INDENT
        nums = gen_randoms(lower, higher)
        this_equation = gen_equation(nums)
        gen_answer = evaluate(this_equation)
        user_answer = int(raw_input("What is the answer? "))
        if user_answer == gen_answer :
        INDENT
            correct += 1
            print 'Correct!'
            print 'Current streak: %s' % str(correct)
        DEDENT
        else :
        INDENT
            print 'Incorrect!'
            correct = 0
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def game() :
INDENT
    correct = 0
    play_again = 'Y'
    while play_again.lower() == 'y' :
    INDENT
        lower = int(raw_input("Enter a lower integer constraint: "))
        higher = int(raw_input("Enter a higher integer constraint: "))
        nums = gen_randoms(lower, higher)
        this_equation = gen_equation(nums)
        gen_answer = evaluate(this_equation)
        if compare_answers(gen_answer) :
        INDENT
            correct += 1
            print ('You were right! Your winning streak is {0}'.format(correct))
        DEDENT
        else :
        INDENT
            print ('Sorry, your answer was wrong. :(')
            correct = 0
        DEDENT
        play_again = raw_input('Would you like to play again? (Y/N): ')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18432293_18432682_1_13
18432293_18432805_39_51
Title: Python: Refactor code to remove global variable 
----------------------------------------

def compare_answers(gen_answer, game, correct) :
INDENT
    user_answer = int(raw_input("What is the answer? "))
    if user_answer == gen_answer :
    INDENT
        correct += 1
        print 'Correct!'
        print 'Current streak: %s' % str(correct)
        game(correct)
    DEDENT
    else :
    INDENT
        print 'Incorrect!'
        correct = 0
        game(correct)

    DEDENT
DEDENT
----------------------------------------

def compare_answers(self, gen_answer) :
INDENT
    user_answer = int(raw_input("What is the answer? "))
    if user_answer == gen_answer :
    INDENT
        self.correct += 1
        print 'Correct!'
        print 'Current streak: %s' % str(self.correct)
        self.game(self.correct)
    DEDENT
    else :
    INDENT
        print 'Incorrect!'
        self.correct = 0
        self.game(self.correct)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18432293_18432805_52_59
18432293_18433251_5_23
Title: Python: Refactor code to remove global variable 
----------------------------------------

def game(self, correct) :
INDENT
    nums = self.gen_randoms(self.lower, self.higher)
    this_equation = self.gen_equation(nums)
    gen_answer = self.evaluate(this_equation)
    self.compare_answers(gen_answer)
    self.game()

DEDENT
----------------------------------------

def game() :
INDENT
    correct = 0
    play_again = 'Y'
    while play_again.lower() == 'y' :
    INDENT
        lower = int(raw_input("Enter a lower integer constraint: "))
        higher = int(raw_input("Enter a higher integer constraint: "))
        nums = gen_randoms(lower, higher)
        this_equation = gen_equation(nums)
        gen_answer = evaluate(this_equation)
        if compare_answers(gen_answer) :
        INDENT
            correct += 1
            print ('You were right! Your winning streak is {0}'.format(correct))
        DEDENT
        else :
        INDENT
            print ('Sorry, your answer was wrong. :(')
            correct = 0
        DEDENT
        play_again = raw_input('Would you like to play again? (Y/N): ')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18435787_18479676_1_18
18435787_24774786_1_12
Title: Adding field that isn't in model to serializer in Django REST framework 
----------------------------------------

def restore_object(self, attrs, instance = None) :
INDENT
    if instance is not None :
    INDENT
        instance.email = attrs.get('email', instance.email)
        instance.author = attrs.get('author', instance.author)
        instance.url = attrs.get('url', instance.url)
        instance.content = attrs.get('content', instance.content)
        instance.ip = attrs.get('ip', instance.ip)
        instance.post_title = attrs.get('post_title', instance.post_title)
        instance.post_url = attrs.get('post_url', instance.post_url)
        return instance
    DEDENT
    commenter_pw = attrs.get('commenter_pw')
    del attrs ['commenter_pw']

    comment = Comment(** attrs)
    comment.commenter_password = commenter_pw
    return comment
DEDENT
----------------------------------------

def restore_object(self, attrs, instance = None) :
INDENT
    commenter_pw = attrs.pop('comment_pw', None)
    obj = super(
        CommentCreateSerializer, self).restore_object(attrs, instance = instance)
    if commenter_pw :
    INDENT
        obj.commenter_pw = commenter_pw
    DEDENT
    return obj
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18437053_18437215_1_12
18437053_18437453_1_15
Title: save values in database using django 
----------------------------------------

def applicationvalue(request) :
INDENT
    if request.method == 'POST' :
    INDENT

        getintable = applicationform(request.POST)
        getintable.save()
        print getjobtitle
        return HttpResponse(getintable)
    DEDENT
    else :
    INDENT
        return render_to_response('registration/applicationform.html')
    DEDENT
DEDENT
----------------------------------------

def applicationvalue(request) :
INDENT
    if request.method == 'POST' :
    INDENT

        form = ApplicationForm(request.POST)
        if form.is_valid() :
        INDENT

            application_object = form.save()
            return HttpResponse("Some HTML code")
        DEDENT
    DEDENT
    else :
    INDENT
        form = ApplicationForm()

    DEDENT
    return render_to_response('registration/applicationform.html', {'form' : form})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18455921_18456251_1_8
18455921_18456440_1_8
Title: Generalizing a method in Python 
----------------------------------------

def createDailyAvg(w, m) :
INDENT
    dailyAvg = [[], []]
    i = 0
    while i < 35140 :
    INDENT
        dailyAvg [0].append(np.mean(w [i : i + 95]))
        dailyAvg [1].append(np.mean(m [i : i + 95]))
        i += 95
    DEDENT
    return dailyAvg
DEDENT
----------------------------------------

def createDailyAvg(p) :
INDENT
    dailyAvg = []
    i = 0
    while i < 35140 :
    INDENT
        dailyAvg.append(np.mean(p [i : i + 96]))
        i += 96
    DEDENT
    return dailyAvg
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18473850_18474403_7_14
18473850_26740476_1_10
Title: Creating instances of Django proxy models from their base class 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Check, self).__init__(* args, ** kwargs)
    if self.check_type :
    INDENT
        map = {'TypeA' : Check_A,
            'TypeB' : Check_B,
            'TypeC' : Check_C}
        self.__class__ = map.get(self.check_type, Check)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    super(Analysis, self).__init__(* args, ** kwargs)
    if not self.__type and type(self) == Analysis :
    INDENT
        raise Exception("We should never create a base Analysis object. Please create a child proxy class instead.")
    DEDENT
    for _class in Analysis.__subclasses__() :
    INDENT
        if self.check_type == _class.__name__ :
        INDENT
            self.__class__ = _class
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18479819_18490155_28_36
18479819_18491214_24_33
Title: How to dynamically modify the title of the window about wx.FileDropTarget 
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, size = (450, 400))
    self.text = wx.TextCtrl(self, - 1, style = wx.TE_MULTILINE)
    dt = FileDrop(self.text, self)
    self.text.SetDropTarget(dt)
    self.Centre()
    self.Show(True)
DEDENT
----------------------------------------

def __init__(self, parent, id) :
INDENT
    wx.Frame.__init__(self, parent, id, title = "", size = (450, 400))
    self.text = wx.TextCtrl(self, - 1, style = wx.TE_MULTILINE | wx.TE_RICH2)
    dt = FileDrop(self.text, self)
    self.text.SetDropTarget(dt)
    self.Centre()
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1850463_1850485_5_16
1850463_1850592_6_13
Title: Adding an argument to a decorator 
----------------------------------------

def __call__(self, f) :
INDENT
    print 'Decorator arguments:', self.arg1
    def wrapped_f(request, * args, ** kwargs) :
    INDENT
        if kwargs.get('shared', True) :
        INDENT
            from django.http import Http404
            raise Http404('not availiable for sharing')
        DEDENT
        f(request, * args, ** kwargs)
    DEDENT
    return wrapped_f
DEDENT
----------------------------------------

def __call__(self, request, * args, ** kwargs) :
INDENT
    if kwargs.get(self.attr_name, True) :
    INDENT
        from django.http import Http404
        raise Http404('not availiable for sharing')
    DEDENT
    return self.view(request, * args, ** kwargs)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18532827_18533909_36_51
18532827_18533909_4_26
Title: Using wxPython to get input from user 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.Frame.__init__(self, parent, title = title, size = (- 1, - 1))
    self.panel = wx.Panel(self)
    self.Bind(wx.EVT_CLOSE, self.OnCloseWindow)
    self.btn = wx.Button(self.panel, - 1, "Name-a-matic")
    self.Bind(wx.EVT_BUTTON, self.GetName, self.btn)
    self.txt = wx.TextCtrl(self.panel, - 1, size = (140, - 1))
    self.txt.SetValue('name goes here')
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.btn)
    sizer.Add(self.txt)
    self.panel.SetSizer(sizer)
    self.Show()
DEDENT
----------------------------------------

def __init__(self, parent, id = - 1, title = "Enter Name!") :
INDENT
    wx.Dialog.__init__(self, parent, id, title, size = (- 1, - 1))
    self.mainSizer = wx.BoxSizer(wx.VERTICAL)
    self.buttonSizer = wx.BoxSizer(wx.HORIZONTAL)
    self.label = wx.StaticText(self, label = "Enter Name:")
    self.field = wx.TextCtrl(self, value = "", size = (300, 20))
    self.okbutton = wx.Button(self, label = "OK", id = wx.ID_OK)
    self.mainSizer.Add(self.label, 0, wx.ALL, 8)
    self.mainSizer.Add(self.field, 0, wx.ALL, 8)
    self.buttonSizer.Add(self.okbutton, 0, wx.ALL, 8)
    self.mainSizer.Add(self.buttonSizer, 0, wx.ALL, 0)
    self.Bind(wx.EVT_BUTTON, self.onOK, id = wx.ID_OK)
    self.Bind(wx.EVT_TEXT_ENTER, self.onOK)
    self.SetSizer(self.mainSizer)
    self.result = None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1855095_1855118_5_10
1855095_36132604_4_25
Title: How to create a zip archive of a directory 
----------------------------------------

def zipdir(path, ziph) :
INDENT
    for root, dirs, files in os.walk(path) :
    INDENT
        for file in files :
        INDENT
            ziph.write(os.path.join(root, file))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def zipdir(path, ziph) :
INDENT
    for root, dirs, files in os.walk(path) :
    INDENT
        if root.replace(path, '') == '' :
        INDENT
            prefix = ''
        DEDENT
        else :
        INDENT

            prefix = root.replace(path, '') + '/'
            if (prefix [0] == '/') :
            INDENT
                prefix = prefix [1 :]
            DEDENT
        DEDENT
        for filename in files :
        INDENT
            actual_file_path = root + '/' + filename
            zipped_file_path = prefix + filename
            zipf.write(actual_file_path, zipped_file_path)

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18553931_18558115_43_51
18553931_18558115_53_67
Title: Using a wx.gauge in a wx.wizard 
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.wizard.WizardPageSimple.__init__(self, parent)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.text = wx.StaticText(self, - 1,
        "This is the First Page")
    self.sizer.Add(self.text, 0, wx.ALIGN_CENTER | wx.ALL, 5)

DEDENT
----------------------------------------

def __init__(self, parent, title) :
INDENT
    wx.wizard.WizardPageSimple.__init__(self, parent)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.status = wx.StaticText(self, - 1, "This is the Second Page")
    self.gauge = wx.Gauge(self, - 1, name = "Guage")
    self.sizer.Add(self.status, 0, wx.ALIGN_CENTER | wx.ALL, 5)
    self.sizer.Add(self.gauge, 0,
        wx.EXPAND | wx.ALIGN_CENTER_HORIZONTAL | wx.ALL, 10)
    self.SetSizer(self.sizer)
    self.gauge_pos = 0
    self.timer = wx.Timer(self)
    self.Bind(wx.EVT_TIMER, self.on_gauge_timer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18572534_18572967_1_12
18572534_18573268_1_10
Title: "How to convert an int to base 9 with no 0's?" 
----------------------------------------

def base9(x) :
INDENT
    sign = 1
    if x < 0 :
    sign = - 1
    x *= - 1
    result = 0
    index = 0
    while x > 0 :
    INDENT
        result += (x % 9) * 10 ** index
        x /= 9
        index += 1
    DEDENT
    return result * sign
DEDENT
----------------------------------------

def base9(x) :
INDENT
    digits = []
    base9_int = 0
    while x > 0 :
    INDENT
        digits.append(x % 9)
        x = int(x / 9)
    DEDENT
    for x in digits [: : - 1] :
    INDENT
        base9_int = base9_int * 10 + x
    DEDENT
    return base9_int
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18579911_18593825_31_45
18579911_18593825_60_72
Title: wxPython - How to make a loading bar display while another process is occurring? 
----------------------------------------

def __init__(self) :
INDENT
    wx.Dialog.__init__(self, None, title = "Progress")
    self.count = 0
    self.progress = wx.Gauge(self, range = 20)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.progress, 0, wx.EXPAND)
    self.SetSizer(sizer)

    Publisher().subscribe(self.updateProgress, "update")

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY, "Tutorial")

    panel = wx.Panel(self, wx.ID_ANY)
    self.btn = btn = wx.Button(panel, label = "Start Thread")
    btn.Bind(wx.EVT_BUTTON, self.onButton)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(btn, 0, wx.ALL | wx.CENTER, 5)
    panel.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18603860_18604105_4_12
18603860_18604255_1_11
Title: Sorting and Organization of letter frequency - python 
----------------------------------------

def me() :
INDENT
    info = input("what file would you like to select? ")
    filehandle = open(info, "r")
    data = filehandle.read().upper()
    char_counter = collections.Counter(data)
    for char, count in char_counter.most_common() :
    INDENT
        if char in string.ascii_uppercase :
        INDENT
            print (char, count)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def me() :
INDENT
    info = input("what file would you like to select?")
    filehandle = open(info, "r")
    data = filehandle.read()
    case = data.upper()
    s = ('ABCDEFGHIJKLMNOPQRSTUVWXYZ')
    result = []
    for i in range(26) :
    INDENT
        result.append((s [i], case.count(s [i])))
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1863236_1863274_1_10
1863236_1863286_3_8
Title: grep -r in python 
----------------------------------------

def grep_r(pattern, dir) :
INDENT
    r = re.compile(pattern)
    for parent, dnames, fnames in os.walk(dir) :
    INDENT
        for fname in fnames :
        INDENT
            filename = os.path.join(parent, fname)
            if os.path.isfile(filename) :
            INDENT
                with open(filename) as f :
                INDENT
                    for line in f :
                    INDENT
                        if r.search(line) :
                        INDENT
                            yield line
                        DEDENT
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def grep_r(regex, dir) :
INDENT
    for root, dirs, files in os.walk(dir) :
    INDENT
        for f in files :
        INDENT
            for m in grep(regex, os.path.join(root, f)) :
            INDENT
                yield m
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1863236_1863286_9_12
1863236_1864383_18_24
Title: grep -r in python 
----------------------------------------

def grep(regex, filename) :
INDENT
    for i, line in enumerate(open(filename)) :
    INDENT
        if re.match(regex, line) :
        INDENT
            yield "%s:%d: %s" % (os.path.basename(filename), i + 1, line)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def grep(dir_name, s_pat) :
INDENT
    pat = re.compile(s_pat)
    for dirpath, dirnames, filenames in os.walk(dir_name) :
    INDENT
        for fname in filenames :
        INDENT
            fullname = os.path.join(dirpath, fname)
            file_match(fullname, pat)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18643754_18644227_7_18
18643754_18644469_7_29
Title: Python multiprocess Process never terminates 
----------------------------------------

def request_manager(req_list) :
INDENT
    try :
    INDENT

        responce = pool.map(process_request, req_list, CHUNK_SIZE)
        responce = pool.map_async(process_request, req_list, CHUNK_SIZE)
    DEDENT
    except Exception, e :
    INDENT
        logging.error(traceback.print_exc())

    DEDENT
DEDENT
----------------------------------------

def request_manager(req_list) :
INDENT
    try :
    INDENT

        pool = []
        for req in req_list :
        INDENT
            MPQ.put(req)

            worker = multiprocessing.Process(target = process_request, args = (MPQ,))
            worker.daemon = True
            worker.start()
            pool.append(worker)

        DEDENT
        MPQ.join()
        for p in pool : p.terminate()
    DEDENT
    except Exception, e :
    INDENT
        logging.error(traceback.print_exc())

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18643754_18644469_30_38
18643754_18658735_2_9
Title: Python multiprocess Process never terminates 
----------------------------------------

def process_request(MPQ) :
INDENT
    try :
    INDENT
        while True :
        INDENT
            req = MPQ.get()
            dr = urllib2.urlopen(req)
            MPQ.task_done()
        DEDENT
    DEDENT
    except Exception, e :
    INDENT
        logging.error(traceback.print_exc())
    DEDENT
DEDENT
----------------------------------------

def process_request(req) :
INDENT
    try :
    INDENT
        dr = urllib2.urlopen(req, timeout = 30)
    DEDENT
    except Exception, e :
    INDENT
        logging.error(traceback.print_exc())

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18643754_18644469_7_29
18643754_18658735_20_25
Title: Python multiprocess Process never terminates 
----------------------------------------

def request_manager(req_list) :
INDENT
    try :
    INDENT

        pool = []
        for req in req_list :
        INDENT
            MPQ.put(req)

            worker = multiprocessing.Process(target = process_request, args = (MPQ,))
            worker.daemon = True
            worker.start()
            pool.append(worker)

        DEDENT
        MPQ.join()
        for p in pool : p.terminate()
    DEDENT
    except Exception, e :
    INDENT
        logging.error(traceback.print_exc())

    DEDENT
DEDENT
----------------------------------------

def request_manager(req_list) :
INDENT
    try :
    INDENT
        resp = POOL.map_async(process_request, req_list, CHUNK_SIZE, callback = sig_end)
    DEDENT
    except Exception, e :
    INDENT
        logging.error(traceback.print_exc())
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18650159_18650248_1_6
18650159_18650281_1_6
Title: Write before and after decorator 
----------------------------------------

def say_hello(f) :
INDENT
    def wrap(* args, ** kwargs) :
    INDENT
        print "Hello"
        return f(* args, ** kwargs)
    DEDENT
    return wrap
DEDENT
----------------------------------------

def say_hello(f) :
INDENT
    def wrap() :
    INDENT
        print "Hello"
        f()
    DEDENT
    return wrap
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18650159_18650248_7_13
18650159_18650281_7_12
Title: Write before and after decorator 
----------------------------------------

def say_bye(f) :
INDENT
    def wrap(* args, ** kwargs) :
    INDENT
        return_value = f(* args, ** kwargs)
        print "Bye"
        return return_value
    DEDENT
    return wrap
DEDENT
----------------------------------------

def say_bye(f) :
INDENT
    def wrap() :
    INDENT
        f()
        print "Bye"
    DEDENT
    return wrap
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18672956_18673250_14_25
18672956_18674020_1_7
Title: Code throws TypeError: unsupported operand type(s) for -: 'int' and 'list' 
----------------------------------------

def move(lst, u) :
INDENT
    q = []
    if u [0] ! = 0 :
    INDENT
        index = u [0]
        for i, elem in enumerate(lst) :
        INDENT
            q.append([lst [j - index] [i] * p_move] for j in range(len(elem)))
        DEDENT
    DEDENT
    elif u [1] ! = 0 :
    INDENT
        index = u [1]
        for i, elem in enumerate(lst) :
        INDENT
            q.append([lst [i] [j - index] * p_move] for j in range(len(elem)))
        DEDENT
    DEDENT
    return q
DEDENT
----------------------------------------

def move(motions) :
INDENT
    index0, index1 = 0, 0
    for m in motions :
    INDENT
        index0 += m [0]
        index1 += m [1]
        yield (index0, index1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18675956_18676177_25_34
18675956_18676393_27_37
Title: Python Dictionaries - Calling the definition 
----------------------------------------

def compute_grades(students) :
INDENT
    for student in students :
    INDENT
        print ('-' * 23)
        for key, value in student.items() :
        INDENT
            if isinstance(value, str) :
            INDENT
                formatted_value = value
            DEDENT
            else :
            INDENT
                formatted_value = average(value)
            DEDENT
            print ("%s: %s" % (key.title(), formatted_value))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def compute_grades(students) :
INDENT
    for student in students :
    INDENT
        print "-" * 15
        print student ["name"]
        for key in student.keys() :
        INDENT
            if isinstance(student [key], str) :
            INDENT
                key_value = student [key]
            DEDENT
            else :
            INDENT
                key_value = average(student [key])
            DEDENT
            if key ! = "name" :
            INDENT
                print ("%s: %s" % (key.title(), key_value))
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18675956_18676177_25_34
18675956_18676475_27_36
Title: Python Dictionaries - Calling the definition 
----------------------------------------

def compute_grades(students) :
INDENT
    for student in students :
    INDENT
        print ('-' * 23)
        for key, value in student.items() :
        INDENT
            if isinstance(value, str) :
            INDENT
                formatted_value = value
            DEDENT
            else :
            INDENT
                formatted_value = average(value)
            DEDENT
            print ("%s: %s" % (key.title(), formatted_value))
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def compute_grades(ourstudents) :
INDENT
    for student in ourstudents :
    INDENT
        print "-" * 15
        print student ["name"]
        for field, value in student.items() :
        INDENT
            try :
            INDENT
                average = sum(value) / float(len(value))
                print "{0}: {1}".format(field.title(), average)
            DEDENT
            except TypeError :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18675956_18676393_27_37
18675956_18676475_27_36
Title: Python Dictionaries - Calling the definition 
----------------------------------------

def compute_grades(students) :
INDENT
    for student in students :
    INDENT
        print "-" * 15
        print student ["name"]
        for key in student.keys() :
        INDENT
            if isinstance(student [key], str) :
            INDENT
                key_value = student [key]
            DEDENT
            else :
            INDENT
                key_value = average(student [key])
            DEDENT
            if key ! = "name" :
            INDENT
                print ("%s: %s" % (key.title(), key_value))
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def compute_grades(ourstudents) :
INDENT
    for student in ourstudents :
    INDENT
        print "-" * 15
        print student ["name"]
        for field, value in student.items() :
        INDENT
            try :
            INDENT
                average = sum(value) / float(len(value))
                print "{0}: {1}".format(field.title(), average)
            DEDENT
            except TypeError :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18700573_18700869_14_20
18700573_18701945_17_22
Title: Python - Function array class 
----------------------------------------

def execute(self) :
INDENT
    if not getattr(self, 'functions', None) :
    INDENT
        self.functions = [self.f1, self.f2, self.f3]
        random.shuffle(self.functions)
    DEDENT
    return self.functions.pop()

DEDENT
----------------------------------------

def execute(self) :
INDENT
    func = self.f.pop()
    if not self.f :
    INDENT
        self.reset()
    DEDENT
    return func()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18712772_18713006_9_16
18712772_18714995_1_12
Title: How to return a generator in Python 
----------------------------------------

def func() :
INDENT
    sql = "select some rows"
    dbconn = connect_and_open_database()
    cursor = dbconn.cursor()
    cursor.execute(sql)
    yield cursor_iter(cursor)
    dbclose()
DEDENT
----------------------------------------

def func() :
INDENT
    sql = " select some rows "
    dbconn = "connect and open to dtabase code"
    n = 0
    ret = execute(sql, n)
    while ret is not None :
    INDENT
        yield ret
        n += 1
        ret = execute(sql, n)
    DEDENT
    dbclose()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18715688_18715879_3_9
18715688_38405402_5_11
Title: Find common substring between two strings 
----------------------------------------

def _iter() :
INDENT
    for a, b in zip(sa, sb) :
    INDENT
        if a == b :
        INDENT
            yield a
        DEDENT
        else :
        INDENT
            return
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def _iter() :
INDENT
    for z in zip(* strings) :
    INDENT
        if z.count(z [0]) == len(z) :
        INDENT
            yield z [0]
        DEDENT
        else :
        INDENT
            return
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18715688_18717762_1_13
18715688_42882629_1_14
Title: Find common substring between two strings 
----------------------------------------

def longestSubstringFinder(string1, string2) :
INDENT
    answer = ""
    len1, len2 = len(string1), len(string2)
    for i in range(len1) :
    INDENT
        match = ""
        for j in range(len2) :
        INDENT
            if (i + j < len1 and string1 [i + j] == string2 [j]) :
            INDENT
                match += string2 [j]
            DEDENT
            else :
            INDENT
                if (len(match) > len(answer)) : answer = match
                match = ""
            DEDENT
        DEDENT
    DEDENT
    return answer
DEDENT
----------------------------------------

def longestSubstringFinder(string1, string2) :
INDENT
    answer = ""
    len1, len2 = len(string1), len(string2)
    for i in range(len1) :
    INDENT
        for j in range(len2) :
        INDENT
            lcs_temp = 0
            match = ''
            while ((i + lcs_temp < len1) and (j + lcs_temp < len2) and string1 [i + lcs_temp] == string2 [j + lcs_temp]) :
            INDENT
                match += string2 [j + lcs_temp]
                lcs_temp += 1
            DEDENT
            if (len(match) > len(answer)) :
            INDENT
                answer = match
            DEDENT
        DEDENT
    DEDENT
    return answer
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18720138_18777494_37_49
18720138_18911698_64_69
Title: Visitor pattern (from bottom to top) 
----------------------------------------

def visit(self, node) :
INDENT
    ret = True
    for child in node.children :
    INDENT
        v = child.accept(self)
        if not v and ret :
        INDENT
            ret = False

        DEDENT
    DEDENT
    if not node.check() :
    INDENT
        ret = False
    DEDENT
    return ret
DEDENT
----------------------------------------

def visit(self, node) :
INDENT
    if len(node.children) > 0 :
    INDENT
        for child in node.children :
        INDENT
            child.accept(self)
        DEDENT
    DEDENT
    node.check()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18720138_18777494_37_49
18720138_18911698_71_79
Title: Visitor pattern (from bottom to top) 
----------------------------------------

def visit(self, node) :
INDENT
    ret = True
    for child in node.children :
    INDENT
        v = child.accept(self)
        if not v and ret :
        INDENT
            ret = False

        DEDENT
    DEDENT
    if not node.check() :
    INDENT
        ret = False
    DEDENT
    return ret
DEDENT
----------------------------------------

def visit(self, node) :
INDENT
    results = []
    if len(node.children) > 0 :
    INDENT
        for child in node.children :
        INDENT
            child.accept(self)
            results.append(child.result)
        DEDENT
        node.result = all(results)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18731919_18732599_1_25
18731919_18754234_1_31
Title: Deterministic python generator for K disparate M-sized subsets of a set 
----------------------------------------

def gen_subsets_special(full_set, M, K) :
INDENT
    from itertools import combinations
    elements = list(full_set)

    index2count = dict((i, 0) for i in range(len(elements)))
    seen = set()
    for _ in xrange(K) :
    INDENT
        bycount = sorted(index2count, key = index2count.get)

        for raw in combinations(bycount, M) :
        INDENT
            raw = tuple(sorted(raw))
            if raw not in seen :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            return
        DEDENT
        seen.add(raw)
        for i in raw :
        INDENT
            index2count [i] += 1
        DEDENT
        yield set(elements [i] for i in raw)
    DEDENT
DEDENT
----------------------------------------

def gen_subsets_special(full_set, M, seed = 123456) :
INDENT
    import random
    from random import sample
    random.seed(seed)
    elements = list(full_set)
    N = len(elements)
    hi = set(range(N))
    lo = set()
    while True :
    INDENT
        assert not (hi & lo)
        assert len(lo | hi) == N
        if len(hi) > M :
        INDENT

            ixhi = set(sample(hi, M))
            ixlo = set()
            hi -= ixhi
            lo |= ixhi
            assert hi
        DEDENT
        else :
        INDENT

            ixhi = hi.copy()
            ixlo = set(sample(lo, M - len(ixhi)))
            hi |= lo - ixlo
            lo = ixlo
        DEDENT
        assert not (ixlo & ixhi)
        ix = ixlo | ixhi
        assert len(ix) == M
        yield set(elements [i] for i in ix)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18733213_18829697_2_9
18733213_18869461_10_17
Title: Fade Between Two Music Tracks in-progress in Pygame 
----------------------------------------

def __init__(self, song1, song2) :
INDENT
    self.song1 = song1
    self.song2 = song2
    self.lefttoright = False
    self.starttime = 0
    self.endtime = 0

DEDENT
----------------------------------------

def __init__(self, fname) :
INDENT
    super(Fader, self).__init__()
    assert isinstance(fname, basestring)
    self.sound = pygame.mixer.Sound(fname)
    self.increment = 0.01
    self.next_vol = 1
    Fader.instances.append(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18750926_18751938_16_39
18750926_18752139_14_29
Title: Recursive method of shrinking triangles in Python 
----------------------------------------

def drawTriangles(size, depth, baseTriangle = False) :
INDENT
    if (depth < 1) :
    INDENT
        pass
    DEDENT
    else :
    INDENT
        drawTriangle(size)
        drawTriangles(size / 2, depth - 1)
        if baseTriangle :
        INDENT
            return
        DEDENT
        turtle.up()
        turtle.left(30)
        turtle.forward(- size)
        turtle.right(120)
        turtle.forward(size * 2)
        turtle.left(90)
        turtle.down()
        drawTriangle(size)
        drawTriangles(size / 2, depth - 1)
        turtle.up()
        turtle.left(30)
        turtle.forward(- size)
        turtle.left(60)
        turtle.forward(size * 2)
        turtle.right(90)
        turtle.down()
    DEDENT
DEDENT
----------------------------------------

def drawTriangles(size, depth) :
INDENT
    size = float(size)
    if (depth > 0) :
    INDENT
        drawTriangle(size)
        turtle.left(30)
        turtle.forward(size)
        turtle.right(30)
        drawTriangles(size / 2, depth - 1)
        turtle.right(90)
        turtle.forward(size)
        turtle.left(90)
        drawTriangles(size / 2, depth - 1)
        turtle.left(150)
        turtle.forward(size)
        turtle.right(150)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1875497_1875575_2_13
1875497_1875588_2_13
Title: Dynamic function with local variables 
----------------------------------------

def __metaclass__(name, bases, dict) :
INDENT
    for i in range(5) :
    INDENT
        def asclosure() :
        INDENT
            ci = i
            def fget(self) :
            INDENT
                return ci
            DEDENT
            return fget
        DEDENT
        dict ['f%d' % i] = property(asclosure())
    DEDENT
    return type(name, bases, dict)
DEDENT
----------------------------------------

def __metaclass__(name, bases, dict) :
INDENT
    def makeprop(i) :
    INDENT
        def fget(self) :
        INDENT
            return i
        DEDENT
        return property(fget)
    DEDENT
    for i in range(5) :
    INDENT
        dict ['f%d' % i] = makeprop(i)
    DEDENT
    return type(name, bases, dict)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_23524128_37_64
18761766_23705472_2_23
Title: Mergesort Python 
----------------------------------------

def _merge(self, dest, working, low, mid, high) :
INDENT
    i = 0
    j = 0
    inversions = 0
    while (low + i < mid) and (mid + j < high) :
    INDENT
        if self.compare(self.key(dest [low + i]), self.key(dest [mid + j])) :
        INDENT
            working [low + i + j] = dest [low + i]
            i += 1
        DEDENT
        else :
        INDENT
            working [low + i + j] = dest [mid + j]
            inversions += (mid - (low + i))
            j += 1
        DEDENT
    DEDENT
    while low + i < mid :
    INDENT
        working [low + i + j] = dest [low + i]
        i += 1
    DEDENT
    while mid + j < high :
    INDENT
        working [low + i + j] = dest [mid + j]
        j += 1
    DEDENT
    for k in range(low, high) :
    INDENT
        dest [k] = working [k]
    DEDENT
    return inversions

DEDENT
----------------------------------------

def _merge(self, left, right) :
INDENT
    nl = len(left)
    nr = len(right)
    result = [0] * (nl + nr)
    i = 0
    j = 0
    for k in range(len(result)) :
    INDENT
        if nl > i and nr > j :
        INDENT
            if left [i] < = right [j] :
            INDENT
                result [k] = left [i]
                i += 1
            DEDENT
            else :
            INDENT
                result [k] = right [j]
                j += 1
            DEDENT
        DEDENT
        elif nl == i :
        INDENT
            result [k] = right [j]
            j += 1
        DEDENT
        else :
        INDENT
            result [k] = left [i]
            i += 1
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27030552_1_15
18761766_27132544_1_9
Title: Mergesort Python 
----------------------------------------

def merge_sort(x) :
INDENT
    if len(x) < 2 : return x
    result, mid = [], int(len(x) / 2)
    y = merge_sort(x [: mid])
    z = merge_sort(x [mid :])
    while (len(y) > 0) and (len(z) > 0) :
    INDENT
        if y [0] > z [0] : result.append(z.pop(0))
        else : result.append(y.pop(0))
    DEDENT
    result.extend(y + z)
    return result
DEDENT
----------------------------------------

def merge_sort(sequence) :
INDENT
    if len(sequence) < 2 :
    INDENT
        return sequence

    DEDENT
    m = len(sequence) / / 2
    return merge(merge_sort(sequence [: m]), merge_sort(sequence [m :]))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27030552_1_15
18761766_37871898_2_23
Title: Mergesort Python 
----------------------------------------

def merge_sort(x) :
INDENT
    if len(x) < 2 : return x
    result, mid = [], int(len(x) / 2)
    y = merge_sort(x [: mid])
    z = merge_sort(x [mid :])
    while (len(y) > 0) and (len(z) > 0) :
    INDENT
        if y [0] > z [0] : result.append(z.pop(0))
        else : result.append(y.pop(0))
    DEDENT
    result.extend(y + z)
    return result
DEDENT
----------------------------------------

def merge_sort(arr) :
INDENT
    if len(arr) < 2 :
    INDENT
        return arr
    DEDENT
    half = len(arr) / / 2
    left = merge_sort(arr [: half])
    right = merge_sort(arr [half :])
    out = []
    li = ri = 0
    while True :
    INDENT
        if li > = len(left) :
        INDENT
            out.extend(right [ri :])
            break
        DEDENT
        if ri > = len(right) :
        INDENT
            out.extend(left [li :])
            break
        DEDENT
        if left [li] < right [ri] :
        INDENT
            out.append(left [li])
            li += 1
        DEDENT
        else :
        INDENT
            out.append(right [ri])
            ri += 1
        DEDENT
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27030552_1_15
18761766_39675173_21_28
Title: Mergesort Python 
----------------------------------------

def merge_sort(x) :
INDENT
    if len(x) < 2 : return x
    result, mid = [], int(len(x) / 2)
    y = merge_sort(x [: mid])
    z = merge_sort(x [mid :])
    while (len(y) > 0) and (len(z) > 0) :
    INDENT
        if y [0] > z [0] : result.append(z.pop(0))
        else : result.append(y.pop(0))
    DEDENT
    result.extend(y + z)
    return result
DEDENT
----------------------------------------

def merge_sort(arr, p, r) :
INDENT
    if p < r :
    INDENT
        q = (p + r) / / 2
        merge_sort(arr, p, q)
        merge_sort(arr, q + 1, r)
        merge(arr, p, q, r)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27030552_1_15
18761766_49186433_1_10
Title: Mergesort Python 
----------------------------------------

def merge_sort(x) :
INDENT
    if len(x) < 2 : return x
    result, mid = [], int(len(x) / 2)
    y = merge_sort(x [: mid])
    z = merge_sort(x [mid :])
    while (len(y) > 0) and (len(z) > 0) :
    INDENT
        if y [0] > z [0] : result.append(z.pop(0))
        else : result.append(y.pop(0))
    DEDENT
    result.extend(y + z)
    return result
DEDENT
----------------------------------------

def merge_sort(arr) :
INDENT
    if len(arr) < 2 :
    INDENT
        return arr [:]
    DEDENT
    middle_of_arr = len(arr) / 2
    left = arr [0 : middle_of_arr]
    right = arr [middle_of_arr :]
    left_side = merge_sort(left)
    right_side = merge_sort(right)
    return merge(left_side, right_side)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27132544_10_25
18761766_31453147_4_22
Title: Mergesort Python 
----------------------------------------

def merge(left, right) :
INDENT
    result = []
    i = j = 0
    while i < len(left) and j < len(right) :
    INDENT
        if left [i] < right [j] :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    result += left [i :]
    result += right [j :]
    return result

DEDENT
----------------------------------------

def merge(left, right, compare) :
INDENT
    result = []
    i, j = 0, 0
    while i < len(left) and j < len(right) :
    INDENT
        if compare(left [i], right [j]) :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    while i < len(left) :
    INDENT
        result.append(left [i])
        i += 1
    DEDENT
    while j < len(right) :
    INDENT
        result.append(right [j])
        j += 1
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27132544_10_25
18761766_39675173_1_20
Title: Mergesort Python 
----------------------------------------

def merge(left, right) :
INDENT
    result = []
    i = j = 0
    while i < len(left) and j < len(right) :
    INDENT
        if left [i] < right [j] :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    result += left [i :]
    result += right [j :]
    return result

DEDENT
----------------------------------------

def merge(arr, p, q, r) :
INDENT
    n1 = q - p + 1
    n2 = r - q
    right, left = [], []
    for i in range(n1) :
    INDENT
        left.append(arr [p + i])
    DEDENT
    for j in range(n2) :
    INDENT
        right.append(arr [q + j + 1])
    DEDENT
    left.append(float('inf'))
    right.append(float('inf'))
    i = j = 0
    for k in range(p, r + 1) :
    INDENT
        if left [i] < = right [j] :
        INDENT
            arr [k] = left [i]
            i += 1
        DEDENT
        else :
        INDENT
            arr [k] = right [j]
            j += 1

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27132544_10_25
18761766_39683605_1_19
Title: Mergesort Python 
----------------------------------------

def merge(left, right) :
INDENT
    result = []
    i = j = 0
    while i < len(left) and j < len(right) :
    INDENT
        if left [i] < right [j] :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    result += left [i :]
    result += right [j :]
    return result

DEDENT
----------------------------------------

def merge(x) :
INDENT
    if len(x) == 1 :
    INDENT
        return x
    DEDENT
    else :
    INDENT
        mid = int(len(x) / 2)
        l = merge(x [: mid])
        r = merge(x [mid :])
    DEDENT
    i = j = 0
    result = []
    while i < len(l) and j < len(r) :
    INDENT
        if l [i] < r [j] :
        INDENT
            result.append(l [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(r [j])
            j += 1
        DEDENT
    DEDENT
    result += l [i :]
    result += r [j :]
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27132544_10_25
18761766_43569560_1_41
Title: Mergesort Python 
----------------------------------------

def merge(left, right) :
INDENT
    result = []
    i = j = 0
    while i < len(left) and j < len(right) :
    INDENT
        if left [i] < right [j] :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    result += left [i :]
    result += right [j :]
    return result

DEDENT
----------------------------------------

def merge(a, low, mid, high) :
INDENT
    l = a [low : mid + 1]
    r = a [mid + 1 : high + 1]
    k = 0; i = 0; j = 0;
    c = [0 for i in range(low, high + 1)]
    while (i < len(l) and j < len(r)) :
    INDENT
        if (l [i] < = r [j]) :
        INDENT

            c [k] = (l [i])
            k += 1
            i += 1
        DEDENT
        else :
        INDENT
            c [k] = (r [j])
            j += 1
            k += 1
        DEDENT
    DEDENT
    while (i < len(l)) :
    INDENT
        c [k] = (l [i])
        k += 1
        i += 1
    DEDENT
    while (j < len(r)) :
    INDENT
        c [k] = (r [j])
        k += 1
        j += 1
    DEDENT
    a [low : high + 1] = c
    def mergesort(a, low, high) :
    INDENT
        if (high > low) :
        INDENT
            mid = (low + high) / / 2

            mergesort(a, low, mid)
            mergesort(a, mid + 1, high)
            merge(a, low, mid, high)
        DEDENT
    DEDENT
    a = [12, 8, 3, 2, 9, 0]
    mergesort(a, 0, len(a) - 1)
    print (a)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27132544_10_25
18761766_49186433_11_24
Title: Mergesort Python 
----------------------------------------

def merge(left, right) :
INDENT
    result = []
    i = j = 0
    while i < len(left) and j < len(right) :
    INDENT
        if left [i] < right [j] :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    result += left [i :]
    result += right [j :]
    return result

DEDENT
----------------------------------------

def merge(left_side, right_side) :
INDENT
    result = []
    while len(left_side) > 0 or len(right_side) > 0 :
    INDENT
        if len(left_side) > 0 and len(right_side) > 0 :
        INDENT
            if left_side [0] < = right_side [0] :
            INDENT
                result.append(left_side.pop(0))
            DEDENT
            else :
            INDENT
                result.append(right_side.pop(0))
            DEDENT
        DEDENT
        elif len(left_side) > 0 :
        INDENT
            result.append(left_side.pop(0))
        DEDENT
        elif len(right_side) > 0 :
        INDENT
            result.append(right_side.pop(0))
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27132544_1_9
18761766_37871898_2_23
Title: Mergesort Python 
----------------------------------------

def merge_sort(sequence) :
INDENT
    if len(sequence) < 2 :
    INDENT
        return sequence

    DEDENT
    m = len(sequence) / / 2
    return merge(merge_sort(sequence [: m]), merge_sort(sequence [m :]))

DEDENT
----------------------------------------

def merge_sort(arr) :
INDENT
    if len(arr) < 2 :
    INDENT
        return arr
    DEDENT
    half = len(arr) / / 2
    left = merge_sort(arr [: half])
    right = merge_sort(arr [half :])
    out = []
    li = ri = 0
    while True :
    INDENT
        if li > = len(left) :
        INDENT
            out.extend(right [ri :])
            break
        DEDENT
        if ri > = len(right) :
        INDENT
            out.extend(left [li :])
            break
        DEDENT
        if left [li] < right [ri] :
        INDENT
            out.append(left [li])
            li += 1
        DEDENT
        else :
        INDENT
            out.append(right [ri])
            ri += 1
        DEDENT
    DEDENT
    return out
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27132544_1_9
18761766_39675173_21_28
Title: Mergesort Python 
----------------------------------------

def merge_sort(sequence) :
INDENT
    if len(sequence) < 2 :
    INDENT
        return sequence

    DEDENT
    m = len(sequence) / / 2
    return merge(merge_sort(sequence [: m]), merge_sort(sequence [m :]))

DEDENT
----------------------------------------

def merge_sort(arr, p, r) :
INDENT
    if p < r :
    INDENT
        q = (p + r) / / 2
        merge_sort(arr, p, q)
        merge_sort(arr, q + 1, r)
        merge(arr, p, q, r)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27132544_1_9
18761766_49186433_1_10
Title: Mergesort Python 
----------------------------------------

def merge_sort(sequence) :
INDENT
    if len(sequence) < 2 :
    INDENT
        return sequence

    DEDENT
    m = len(sequence) / / 2
    return merge(merge_sort(sequence [: m]), merge_sort(sequence [m :]))

DEDENT
----------------------------------------

def merge_sort(arr) :
INDENT
    if len(arr) < 2 :
    INDENT
        return arr [:]
    DEDENT
    middle_of_arr = len(arr) / 2
    left = arr [0 : middle_of_arr]
    right = arr [middle_of_arr :]
    left_side = merge_sort(left)
    right_side = merge_sort(right)
    return merge(left_side, right_side)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27353183_29_45
18761766_31453147_23_30
Title: Mergesort Python 
----------------------------------------

def mergeSort(inputList) :
INDENT
    listlen = len(inputList)
    if listlen == 1 :
    INDENT
        return inputList
    DEDENT
    else :
    INDENT
        newlist = []
        if listlen % 2 == 0 :
        INDENT
            for i in range(listlen / 2) :
            INDENT
                newlist.append(mergeList(inputList [2 * i], inputList [2 * i + 1]))
            DEDENT
        DEDENT
        else :
        INDENT
            for i in range((listlen + 1) / 2) :
            INDENT
                if 2 * i + 1 < listlen :
                INDENT
                    newlist.append(mergeList(inputList [2 * i], inputList [2 * i + 1]))
                DEDENT
                else :
                INDENT
                    newlist.append(inputList [2 * i])
                DEDENT
            DEDENT
        DEDENT
        return mergeSort(newlist)
    DEDENT
DEDENT
----------------------------------------

def mergeSort(L, compare = operator.lt) :
INDENT
    if len(L) < 2 :
    INDENT
        return L [:]
    DEDENT
    else :
    INDENT
        middle = int(len(L) / 2)
        left = mergeSort(L [: middle], compare)
        right = mergeSort(L [middle :], compare)
        return merge(left, right, compare)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_27353183_29_45
18761766_39770991_1_33
Title: Mergesort Python 
----------------------------------------

def mergeSort(inputList) :
INDENT
    listlen = len(inputList)
    if listlen == 1 :
    INDENT
        return inputList
    DEDENT
    else :
    INDENT
        newlist = []
        if listlen % 2 == 0 :
        INDENT
            for i in range(listlen / 2) :
            INDENT
                newlist.append(mergeList(inputList [2 * i], inputList [2 * i + 1]))
            DEDENT
        DEDENT
        else :
        INDENT
            for i in range((listlen + 1) / 2) :
            INDENT
                if 2 * i + 1 < listlen :
                INDENT
                    newlist.append(mergeList(inputList [2 * i], inputList [2 * i + 1]))
                DEDENT
                else :
                INDENT
                    newlist.append(inputList [2 * i])
                DEDENT
            DEDENT
        DEDENT
        return mergeSort(newlist)
    DEDENT
DEDENT
----------------------------------------

def mergeSort(alist) :
INDENT
    print ("Splitting ", alist)
    if len(alist) > 1 :
    INDENT
        mid = len(alist) / / 2
        lefthalf = alist [: mid]
        righthalf = alist [mid :]
        mergeSort(lefthalf)
        mergeSort(righthalf)
        i = 0
        j = 0
        k = 0
        while i < len(lefthalf) and j < len(righthalf) :
        INDENT
            if lefthalf [i] < righthalf [j] :
            INDENT
                alist [k] = lefthalf [i]
                i = i + 1
            DEDENT
            else :
            INDENT
                alist [k] = righthalf [j]
                j = j + 1
            DEDENT
            k = k + 1
        DEDENT
        while i < len(lefthalf) :
        INDENT
            alist [k] = lefthalf [i]
            i = i + 1
            k = k + 1
        DEDENT
        while j < len(righthalf) :
        INDENT
            alist [k] = righthalf [j]
            j = j + 1
            k = k + 1
        DEDENT
    DEDENT
    print ("Merging ", alist)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_31453147_23_30
18761766_39770991_1_33
Title: Mergesort Python 
----------------------------------------

def mergeSort(L, compare = operator.lt) :
INDENT
    if len(L) < 2 :
    INDENT
        return L [:]
    DEDENT
    else :
    INDENT
        middle = int(len(L) / 2)
        left = mergeSort(L [: middle], compare)
        right = mergeSort(L [middle :], compare)
        return merge(left, right, compare)
    DEDENT
DEDENT
----------------------------------------

def mergeSort(alist) :
INDENT
    print ("Splitting ", alist)
    if len(alist) > 1 :
    INDENT
        mid = len(alist) / / 2
        lefthalf = alist [: mid]
        righthalf = alist [mid :]
        mergeSort(lefthalf)
        mergeSort(righthalf)
        i = 0
        j = 0
        k = 0
        while i < len(lefthalf) and j < len(righthalf) :
        INDENT
            if lefthalf [i] < righthalf [j] :
            INDENT
                alist [k] = lefthalf [i]
                i = i + 1
            DEDENT
            else :
            INDENT
                alist [k] = righthalf [j]
                j = j + 1
            DEDENT
            k = k + 1
        DEDENT
        while i < len(lefthalf) :
        INDENT
            alist [k] = lefthalf [i]
            i = i + 1
            k = k + 1
        DEDENT
        while j < len(righthalf) :
        INDENT
            alist [k] = righthalf [j]
            j = j + 1
            k = k + 1
        DEDENT
    DEDENT
    print ("Merging ", alist)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_31453147_4_22
18761766_39675173_1_20
Title: Mergesort Python 
----------------------------------------

def merge(left, right, compare) :
INDENT
    result = []
    i, j = 0, 0
    while i < len(left) and j < len(right) :
    INDENT
        if compare(left [i], right [j]) :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    while i < len(left) :
    INDENT
        result.append(left [i])
        i += 1
    DEDENT
    while j < len(right) :
    INDENT
        result.append(right [j])
        j += 1
    DEDENT
    return result

DEDENT
----------------------------------------

def merge(arr, p, q, r) :
INDENT
    n1 = q - p + 1
    n2 = r - q
    right, left = [], []
    for i in range(n1) :
    INDENT
        left.append(arr [p + i])
    DEDENT
    for j in range(n2) :
    INDENT
        right.append(arr [q + j + 1])
    DEDENT
    left.append(float('inf'))
    right.append(float('inf'))
    i = j = 0
    for k in range(p, r + 1) :
    INDENT
        if left [i] < = right [j] :
        INDENT
            arr [k] = left [i]
            i += 1
        DEDENT
        else :
        INDENT
            arr [k] = right [j]
            j += 1

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_31453147_4_22
18761766_39683605_1_19
Title: Mergesort Python 
----------------------------------------

def merge(left, right, compare) :
INDENT
    result = []
    i, j = 0, 0
    while i < len(left) and j < len(right) :
    INDENT
        if compare(left [i], right [j]) :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    while i < len(left) :
    INDENT
        result.append(left [i])
        i += 1
    DEDENT
    while j < len(right) :
    INDENT
        result.append(right [j])
        j += 1
    DEDENT
    return result

DEDENT
----------------------------------------

def merge(x) :
INDENT
    if len(x) == 1 :
    INDENT
        return x
    DEDENT
    else :
    INDENT
        mid = int(len(x) / 2)
        l = merge(x [: mid])
        r = merge(x [mid :])
    DEDENT
    i = j = 0
    result = []
    while i < len(l) and j < len(r) :
    INDENT
        if l [i] < r [j] :
        INDENT
            result.append(l [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(r [j])
            j += 1
        DEDENT
    DEDENT
    result += l [i :]
    result += r [j :]
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_31453147_4_22
18761766_43569560_1_41
Title: Mergesort Python 
----------------------------------------

def merge(left, right, compare) :
INDENT
    result = []
    i, j = 0, 0
    while i < len(left) and j < len(right) :
    INDENT
        if compare(left [i], right [j]) :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    while i < len(left) :
    INDENT
        result.append(left [i])
        i += 1
    DEDENT
    while j < len(right) :
    INDENT
        result.append(right [j])
        j += 1
    DEDENT
    return result

DEDENT
----------------------------------------

def merge(a, low, mid, high) :
INDENT
    l = a [low : mid + 1]
    r = a [mid + 1 : high + 1]
    k = 0; i = 0; j = 0;
    c = [0 for i in range(low, high + 1)]
    while (i < len(l) and j < len(r)) :
    INDENT
        if (l [i] < = r [j]) :
        INDENT

            c [k] = (l [i])
            k += 1
            i += 1
        DEDENT
        else :
        INDENT
            c [k] = (r [j])
            j += 1
            k += 1
        DEDENT
    DEDENT
    while (i < len(l)) :
    INDENT
        c [k] = (l [i])
        k += 1
        i += 1
    DEDENT
    while (j < len(r)) :
    INDENT
        c [k] = (r [j])
        k += 1
        j += 1
    DEDENT
    a [low : high + 1] = c
    def mergesort(a, low, high) :
    INDENT
        if (high > low) :
        INDENT
            mid = (low + high) / / 2

            mergesort(a, low, mid)
            mergesort(a, mid + 1, high)
            merge(a, low, mid, high)
        DEDENT
    DEDENT
    a = [12, 8, 3, 2, 9, 0]
    mergesort(a, 0, len(a) - 1)
    print (a)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_31453147_4_22
18761766_49186433_11_24
Title: Mergesort Python 
----------------------------------------

def merge(left, right, compare) :
INDENT
    result = []
    i, j = 0, 0
    while i < len(left) and j < len(right) :
    INDENT
        if compare(left [i], right [j]) :
        INDENT
            result.append(left [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(right [j])
            j += 1
        DEDENT
    DEDENT
    while i < len(left) :
    INDENT
        result.append(left [i])
        i += 1
    DEDENT
    while j < len(right) :
    INDENT
        result.append(right [j])
        j += 1
    DEDENT
    return result

DEDENT
----------------------------------------

def merge(left_side, right_side) :
INDENT
    result = []
    while len(left_side) > 0 or len(right_side) > 0 :
    INDENT
        if len(left_side) > 0 and len(right_side) > 0 :
        INDENT
            if left_side [0] < = right_side [0] :
            INDENT
                result.append(left_side.pop(0))
            DEDENT
            else :
            INDENT
                result.append(right_side.pop(0))
            DEDENT
        DEDENT
        elif len(left_side) > 0 :
        INDENT
            result.append(left_side.pop(0))
        DEDENT
        elif len(right_side) > 0 :
        INDENT
            result.append(right_side.pop(0))
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_37871898_2_23
18761766_39675173_21_28
Title: Mergesort Python 
----------------------------------------

def merge_sort(arr) :
INDENT
    if len(arr) < 2 :
    INDENT
        return arr
    DEDENT
    half = len(arr) / / 2
    left = merge_sort(arr [: half])
    right = merge_sort(arr [half :])
    out = []
    li = ri = 0
    while True :
    INDENT
        if li > = len(left) :
        INDENT
            out.extend(right [ri :])
            break
        DEDENT
        if ri > = len(right) :
        INDENT
            out.extend(left [li :])
            break
        DEDENT
        if left [li] < right [ri] :
        INDENT
            out.append(left [li])
            li += 1
        DEDENT
        else :
        INDENT
            out.append(right [ri])
            ri += 1
        DEDENT
    DEDENT
    return out
DEDENT
----------------------------------------

def merge_sort(arr, p, r) :
INDENT
    if p < r :
    INDENT
        q = (p + r) / / 2
        merge_sort(arr, p, q)
        merge_sort(arr, q + 1, r)
        merge(arr, p, q, r)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_37871898_2_23
18761766_49186433_1_10
Title: Mergesort Python 
----------------------------------------

def merge_sort(arr) :
INDENT
    if len(arr) < 2 :
    INDENT
        return arr
    DEDENT
    half = len(arr) / / 2
    left = merge_sort(arr [: half])
    right = merge_sort(arr [half :])
    out = []
    li = ri = 0
    while True :
    INDENT
        if li > = len(left) :
        INDENT
            out.extend(right [ri :])
            break
        DEDENT
        if ri > = len(right) :
        INDENT
            out.extend(left [li :])
            break
        DEDENT
        if left [li] < right [ri] :
        INDENT
            out.append(left [li])
            li += 1
        DEDENT
        else :
        INDENT
            out.append(right [ri])
            ri += 1
        DEDENT
    DEDENT
    return out
DEDENT
----------------------------------------

def merge_sort(arr) :
INDENT
    if len(arr) < 2 :
    INDENT
        return arr [:]
    DEDENT
    middle_of_arr = len(arr) / 2
    left = arr [0 : middle_of_arr]
    right = arr [middle_of_arr :]
    left_side = merge_sort(left)
    right_side = merge_sort(right)
    return merge(left_side, right_side)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_39675173_1_20
18761766_39683605_1_19
Title: Mergesort Python 
----------------------------------------

def merge(arr, p, q, r) :
INDENT
    n1 = q - p + 1
    n2 = r - q
    right, left = [], []
    for i in range(n1) :
    INDENT
        left.append(arr [p + i])
    DEDENT
    for j in range(n2) :
    INDENT
        right.append(arr [q + j + 1])
    DEDENT
    left.append(float('inf'))
    right.append(float('inf'))
    i = j = 0
    for k in range(p, r + 1) :
    INDENT
        if left [i] < = right [j] :
        INDENT
            arr [k] = left [i]
            i += 1
        DEDENT
        else :
        INDENT
            arr [k] = right [j]
            j += 1

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def merge(x) :
INDENT
    if len(x) == 1 :
    INDENT
        return x
    DEDENT
    else :
    INDENT
        mid = int(len(x) / 2)
        l = merge(x [: mid])
        r = merge(x [mid :])
    DEDENT
    i = j = 0
    result = []
    while i < len(l) and j < len(r) :
    INDENT
        if l [i] < r [j] :
        INDENT
            result.append(l [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(r [j])
            j += 1
        DEDENT
    DEDENT
    result += l [i :]
    result += r [j :]
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_39675173_1_20
18761766_43569560_1_41
Title: Mergesort Python 
----------------------------------------

def merge(arr, p, q, r) :
INDENT
    n1 = q - p + 1
    n2 = r - q
    right, left = [], []
    for i in range(n1) :
    INDENT
        left.append(arr [p + i])
    DEDENT
    for j in range(n2) :
    INDENT
        right.append(arr [q + j + 1])
    DEDENT
    left.append(float('inf'))
    right.append(float('inf'))
    i = j = 0
    for k in range(p, r + 1) :
    INDENT
        if left [i] < = right [j] :
        INDENT
            arr [k] = left [i]
            i += 1
        DEDENT
        else :
        INDENT
            arr [k] = right [j]
            j += 1

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def merge(a, low, mid, high) :
INDENT
    l = a [low : mid + 1]
    r = a [mid + 1 : high + 1]
    k = 0; i = 0; j = 0;
    c = [0 for i in range(low, high + 1)]
    while (i < len(l) and j < len(r)) :
    INDENT
        if (l [i] < = r [j]) :
        INDENT

            c [k] = (l [i])
            k += 1
            i += 1
        DEDENT
        else :
        INDENT
            c [k] = (r [j])
            j += 1
            k += 1
        DEDENT
    DEDENT
    while (i < len(l)) :
    INDENT
        c [k] = (l [i])
        k += 1
        i += 1
    DEDENT
    while (j < len(r)) :
    INDENT
        c [k] = (r [j])
        k += 1
        j += 1
    DEDENT
    a [low : high + 1] = c
    def mergesort(a, low, high) :
    INDENT
        if (high > low) :
        INDENT
            mid = (low + high) / / 2

            mergesort(a, low, mid)
            mergesort(a, mid + 1, high)
            merge(a, low, mid, high)
        DEDENT
    DEDENT
    a = [12, 8, 3, 2, 9, 0]
    mergesort(a, 0, len(a) - 1)
    print (a)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_39675173_1_20
18761766_49186433_11_24
Title: Mergesort Python 
----------------------------------------

def merge(arr, p, q, r) :
INDENT
    n1 = q - p + 1
    n2 = r - q
    right, left = [], []
    for i in range(n1) :
    INDENT
        left.append(arr [p + i])
    DEDENT
    for j in range(n2) :
    INDENT
        right.append(arr [q + j + 1])
    DEDENT
    left.append(float('inf'))
    right.append(float('inf'))
    i = j = 0
    for k in range(p, r + 1) :
    INDENT
        if left [i] < = right [j] :
        INDENT
            arr [k] = left [i]
            i += 1
        DEDENT
        else :
        INDENT
            arr [k] = right [j]
            j += 1

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def merge(left_side, right_side) :
INDENT
    result = []
    while len(left_side) > 0 or len(right_side) > 0 :
    INDENT
        if len(left_side) > 0 and len(right_side) > 0 :
        INDENT
            if left_side [0] < = right_side [0] :
            INDENT
                result.append(left_side.pop(0))
            DEDENT
            else :
            INDENT
                result.append(right_side.pop(0))
            DEDENT
        DEDENT
        elif len(left_side) > 0 :
        INDENT
            result.append(left_side.pop(0))
        DEDENT
        elif len(right_side) > 0 :
        INDENT
            result.append(right_side.pop(0))
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_39675173_21_28
18761766_49186433_1_10
Title: Mergesort Python 
----------------------------------------

def merge_sort(arr, p, r) :
INDENT
    if p < r :
    INDENT
        q = (p + r) / / 2
        merge_sort(arr, p, q)
        merge_sort(arr, q + 1, r)
        merge(arr, p, q, r)

    DEDENT
DEDENT
----------------------------------------

def merge_sort(arr) :
INDENT
    if len(arr) < 2 :
    INDENT
        return arr [:]
    DEDENT
    middle_of_arr = len(arr) / 2
    left = arr [0 : middle_of_arr]
    right = arr [middle_of_arr :]
    left_side = merge_sort(left)
    right_side = merge_sort(right)
    return merge(left_side, right_side)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_39683605_1_19
18761766_43569560_1_41
Title: Mergesort Python 
----------------------------------------

def merge(x) :
INDENT
    if len(x) == 1 :
    INDENT
        return x
    DEDENT
    else :
    INDENT
        mid = int(len(x) / 2)
        l = merge(x [: mid])
        r = merge(x [mid :])
    DEDENT
    i = j = 0
    result = []
    while i < len(l) and j < len(r) :
    INDENT
        if l [i] < r [j] :
        INDENT
            result.append(l [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(r [j])
            j += 1
        DEDENT
    DEDENT
    result += l [i :]
    result += r [j :]
    return result
DEDENT
----------------------------------------

def merge(a, low, mid, high) :
INDENT
    l = a [low : mid + 1]
    r = a [mid + 1 : high + 1]
    k = 0; i = 0; j = 0;
    c = [0 for i in range(low, high + 1)]
    while (i < len(l) and j < len(r)) :
    INDENT
        if (l [i] < = r [j]) :
        INDENT

            c [k] = (l [i])
            k += 1
            i += 1
        DEDENT
        else :
        INDENT
            c [k] = (r [j])
            j += 1
            k += 1
        DEDENT
    DEDENT
    while (i < len(l)) :
    INDENT
        c [k] = (l [i])
        k += 1
        i += 1
    DEDENT
    while (j < len(r)) :
    INDENT
        c [k] = (r [j])
        k += 1
        j += 1
    DEDENT
    a [low : high + 1] = c
    def mergesort(a, low, high) :
    INDENT
        if (high > low) :
        INDENT
            mid = (low + high) / / 2

            mergesort(a, low, mid)
            mergesort(a, mid + 1, high)
            merge(a, low, mid, high)
        DEDENT
    DEDENT
    a = [12, 8, 3, 2, 9, 0]
    mergesort(a, 0, len(a) - 1)
    print (a)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_39683605_1_19
18761766_49186433_11_24
Title: Mergesort Python 
----------------------------------------

def merge(x) :
INDENT
    if len(x) == 1 :
    INDENT
        return x
    DEDENT
    else :
    INDENT
        mid = int(len(x) / 2)
        l = merge(x [: mid])
        r = merge(x [mid :])
    DEDENT
    i = j = 0
    result = []
    while i < len(l) and j < len(r) :
    INDENT
        if l [i] < r [j] :
        INDENT
            result.append(l [i])
            i += 1
        DEDENT
        else :
        INDENT
            result.append(r [j])
            j += 1
        DEDENT
    DEDENT
    result += l [i :]
    result += r [j :]
    return result
DEDENT
----------------------------------------

def merge(left_side, right_side) :
INDENT
    result = []
    while len(left_side) > 0 or len(right_side) > 0 :
    INDENT
        if len(left_side) > 0 and len(right_side) > 0 :
        INDENT
            if left_side [0] < = right_side [0] :
            INDENT
                result.append(left_side.pop(0))
            DEDENT
            else :
            INDENT
                result.append(right_side.pop(0))
            DEDENT
        DEDENT
        elif len(left_side) > 0 :
        INDENT
            result.append(left_side.pop(0))
        DEDENT
        elif len(right_side) > 0 :
        INDENT
            result.append(right_side.pop(0))
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18761766_43569560_1_41
18761766_49186433_11_24
Title: Mergesort Python 
----------------------------------------

def merge(a, low, mid, high) :
INDENT
    l = a [low : mid + 1]
    r = a [mid + 1 : high + 1]
    k = 0; i = 0; j = 0;
    c = [0 for i in range(low, high + 1)]
    while (i < len(l) and j < len(r)) :
    INDENT
        if (l [i] < = r [j]) :
        INDENT

            c [k] = (l [i])
            k += 1
            i += 1
        DEDENT
        else :
        INDENT
            c [k] = (r [j])
            j += 1
            k += 1
        DEDENT
    DEDENT
    while (i < len(l)) :
    INDENT
        c [k] = (l [i])
        k += 1
        i += 1
    DEDENT
    while (j < len(r)) :
    INDENT
        c [k] = (r [j])
        k += 1
        j += 1
    DEDENT
    a [low : high + 1] = c
    def mergesort(a, low, high) :
    INDENT
        if (high > low) :
        INDENT
            mid = (low + high) / / 2

            mergesort(a, low, mid)
            mergesort(a, mid + 1, high)
            merge(a, low, mid, high)
        DEDENT
    DEDENT
    a = [12, 8, 3, 2, 9, 0]
    mergesort(a, 0, len(a) - 1)
    print (a)
DEDENT
----------------------------------------

def merge(left_side, right_side) :
INDENT
    result = []
    while len(left_side) > 0 or len(right_side) > 0 :
    INDENT
        if len(left_side) > 0 and len(right_side) > 0 :
        INDENT
            if left_side [0] < = right_side [0] :
            INDENT
                result.append(left_side.pop(0))
            DEDENT
            else :
            INDENT
                result.append(right_side.pop(0))
            DEDENT
        DEDENT
        elif len(left_side) > 0 :
        INDENT
            result.append(left_side.pop(0))
        DEDENT
        elif len(right_side) > 0 :
        INDENT
            result.append(right_side.pop(0))
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18782620_18782802_3_14
18782620_18786173_3_28
Title: "Regex match when spaces are removed how to delete the matched chars from the original string with spaces?" 
----------------------------------------

def foo(name, legal_ids) :
INDENT
    name_stream = name.replace(' ', '')
    for id in legal_ids :
    INDENT

        name_stream = name_stream.replace(id, '')
    DEDENT
    name_stream_it = iter(name_stream)
    return ''.join(next(name_stream_it) if e ! = ' ' else ' ' for e in name)
DEDENT
----------------------------------------

def foo(name, legal_ids) :
INDENT
    re_code = re.compile(legal_ids)
    name_stream = name.replace(' ', '')
    comp_id_re = re_code.search(name_stream)
    if comp_id_re :
    INDENT

        company_id = comp_id_re.group()
        name_stream = re.sub(re_code, '', name_stream).strip()
        if comp_id_re.start() > 0 :
        INDENT

            name_stream_it = iter(name_stream)
            final_name = ''.join(next(name_stream_it) if e ! = ' ' else ' ' for e in name)
        DEDENT
        else :
        INDENT

            name_stream_it = iter(name_stream [: : - 1])
            final_name = ''.join(next(name_stream_it) if e ! = ' ' else ' ' for e in name [: : - 1])
            final_name = final_name [: : - 1]
        DEDENT
    DEDENT
    else :
    INDENT
        company_id = ''
        final_name = name
    DEDENT
    return (final_name.strip(), company_id)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18790270_18791226_4_12
18790270_19067466_5_13
Title: python decorator parameter using variable from function its wrapping 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    keys = [func.__name__] + [str(kwargs.get(name)) for name in sorted(names)] + [str(args [position]) for position in positions]
    cache_key = '_'.join(keys)
    cached_value = cache.get(cache_key)
    if cached_value :
    INDENT
        return cached_value
    DEDENT
    value = func(* args, ** kwargs)
    cache.set(cache_key, value)
    return cached_value
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    key = (func.__name__, keyfunc(* args, ** kwargs))
    try :
    INDENT
        return func.cache [cache_key]
    DEDENT
    except KeyError :
    INDENT
        value = func(* args, ** kwargs)
        func.cache.set(cache_key, value)
        return value
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18791882_18791912_1_35
18791882_18791952_4_20
Title: Python - How to make program go back to the top of the code instead of closing 
----------------------------------------

def start() :
INDENT
    print ("Welcome to the converter toolkit made by Alan.")
    while True :
    INDENT
        op = input("Please input what operation you wish to perform. 1 for Fahrenheit to Celsius, 2 for meters to centimetres and 3 for megabytes to gigabytes")
        if op == "1" :
        INDENT
            f1 = input("Please enter your fahrenheit temperature: ")
            f1 = int(f1)
            a1 = (f1 - 32) / 1.8
            a1 = str(a1)
            print (a1 + " celsius")
        DEDENT
        elif op == "2" :
        INDENT
            m1 = input("Please input your the amount of meters you wish to convert: ")
            m1 = int(m1)
            m2 = (m1 * 100)
            m2 = str(m2)
            print (m2 + " m")
        DEDENT
        if op == "3" :
        INDENT
            mb1 = input("Please input the amount of megabytes you want to convert")
            mb1 = int(mb1)
            mb2 = (mb1 / 1024)
            mb3 = (mb2 / 1024)
            mb3 = str(mb3)
            print (mb3 + " GB")
        DEDENT
        else :
        INDENT
            print ("Sorry, that was an invalid command!")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def start() :
INDENT
    print ("Welcome to the converter toolkit made by Alan.")
    op = input("Please input what operation you wish to perform. 1 for Fahrenheit to Celsius, 2 for meters to centimetres and 3 for megabytes to gigabytes")
    if op == "1" :
    INDENT

        invalid_input = False

    DEDENT
    elif op == "2" :
    INDENT

        invalid_input = False
    DEDENT
    elif op == "3" :
    INDENT

        invalid_input = False
    DEDENT
    else :
    INDENT
        print ("Sorry, that was an invalid command!")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18793601_18793946_1_22
18793601_18793970_1_29
Title: Loop not iterating 
----------------------------------------

def run_simulation() :
INDENT
    print ()
    RABBIT_BIRTH_RATE = 0.01
    FOX_BIRTH_RATE = 0.005
    INTERACT = 0.00001
    SUCCESS = 0.01
    x = 0
    y = 1
    FOXES = int(input("Enter the initial number of foxes: "))
    print ()
    RABBITS = int(input("Enter the initial number of rabbit: "))
    print ()
    DAYS = int(input("Enter the number of days to run the simulation: "))
    print ()
    print ("Day\t", "Rabbits\t", "Foxes\t")
    print (0, "\t", RABBITS, "\t", "\t", FOXES, "\t")
    for i in range(1, DAYS + 1) :
    INDENT
        RABBITS += round((RABBIT_BIRTH_RATE * RABBITS) - (INTERACT * RABBITS * FOXES))
        FOXES += round((INTERACT * SUCCESS * RABBITS * FOXES) - (FOX_BIRTH_RATE * FOXES))
        y = y + x
        print (i, "\t", (RABBITS), "\t", "\t", (FOXES), "\t")
    DEDENT
DEDENT
----------------------------------------

def run_simulation() :
INDENT
    RABBIT_BIRTH_RATE = 0.01
    FOX_BIRTH_RATE = 0.005
    INTERACT = 0.00001
    SUCCESS = 0.01
    x = 0
    y = 1
    FOXES = eval(str(input("Enter the initial number of foxes: ")))
    RABBITS = eval(str(input("Enter the initial number of rabbits: ")))
    DAYS = eval(str(input("Enter the number of days to run the simulation: ")))
    print ("Day\t", "Rabbits\t", "Foxes\t")
    print (0, "\t", RABBITS, "\t", "\t", FOXES, "\t")
    count = 0
    while count < DAYS :
    INDENT
        RABBITS_DELTA = round((RABBIT_BIRTH_RATE * RABBITS) - (INTERACT * RABBITS * FOXES))
        FOXES_DELTA = round((INTERACT * SUCCESS * RABBITS * FOXES) - (FOX_BIRTH_RATE * FOXES))
        y = y + x
        RABBITS += RABBITS_DELTA
        FOXES += FOXES_DELTA
        print (y, "\t", (RABBITS), "\t", "\t", (FOXES), "\t")
        count += 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18797866_18798280_5_30
18797866_41033496_5_39
Title: Change color based on recursion depth Python Turtle 
----------------------------------------

def drawzig2(depth, size) :
INDENT
    if depth == 0 :
    INDENT
        pass
    DEDENT
    elif depth :
    INDENT
        pencolor(colors [depth % len(colors)])
        left(90)
        fd(size / 2)
        right(90)
        fd(size)
        left(45)
        drawzig2(depth - 1, size / 2)
        right(45)
        fd(- size)
        left(90)
        fd(- size)
        right(90)
        fd(- size)
        left(45)
        drawzig2(depth - 1, size / 2)
        right(45)
        fd(size)
        left(90)
        fd(size / 2)
        right(90)
    DEDENT
DEDENT
----------------------------------------

def drawzig2(turtle, depth, size) :
INDENT
    if depth == 0 :
    INDENT
        return
    DEDENT
    color = turtle.pencolor()
    turtle.pencolor(colors [depth % len(colors)])
    turtle.left(90)
    turtle.fd(size / 2)
    turtle.right(90)
    turtle.fd(size)
    turtle.left(45)
    drawzig2(turtle, depth - 1, size / 2)
    turtle.right(45)
    turtle.bk(size)
    turtle.left(90)
    turtle.bk(size)
    turtle.right(90)
    turtle.bk(size)
    turtle.left(45)
    drawzig2(turtle, depth - 1, size / 2)
    turtle.right(45)
    turtle.fd(size)
    turtle.left(90)
    turtle.fd(size / 2)
    turtle.right(90)
    turtle.pencolor(color)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1880404_1880642_6_23
1880404_2211056_17_34
Title: Using a file to store optparse arguments 
----------------------------------------

def main() :
INDENT
    config = ConfigParser.ConfigParser()
    config.read(CONFIG_FILENAME)
    parser = OptionParser()
    parser.add_option("-l",
        "--language",
        dest = "language",
        help = "The UI language",
        default = config.get("Localization", "language"))
    parser.add_option("-f",
        "--flag",
        dest = "flag",
        help = "The country flag",
        default = config.get("Localization", "flag"))
    print parser.parse_args()
DEDENT
----------------------------------------

def main() :
INDENT
    my_defaults = {'verbose' : False, 'config_only_variable' : 42}

    opts, args = getParser(my_defaults).parse_args()
    if opts.loadconfig is not None :
    INDENT

        config_file_values = {'verbose' : True}
        my_defaults.update(config_file_values)
        opts, args = getParser(my_defaults).parse_args()
    DEDENT
    print opts.verbose
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18805956_18940178_39_46
18805956_18940178_3_16
Title: matplotlib pick_event returns incorrect pressed keys 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "matplotlib pick_event problem")
    self.plotarea = PlotPanel(self)
    self.mainSizer = wx.BoxSizer(wx.HORIZONTAL)
    self.mainSizer.Add(self.plotarea, 1, wx.EXPAND)
    self.SetSizer(self.mainSizer)
    self.mainSizer.Fit(self)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.figure = mplFigure(figsize = (9, 6))
    self.ax = self.figure.add_subplot(111)
    self.ax.plot([1, 2, 3, 4], [2, 3, 5, 8], marker = "o", markersize = 20, picker = 10, linestyle = "None")
    self.canvas = mplCanvas(self, - 1, self.figure)
    self.figure.canvas.mpl_connect('pick_event', self.onClick)
    self.canvas.Bind(wx.EVT_KEY_DOWN, self._on_key_down)
    self.canvas.Bind(wx.EVT_KEY_UP, self._on_key_up)
    self.states = {"cmd" : False, "ctrl" : False, "shift" : False}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18805956_18940178_39_46
18805956_18940178_49_62
Title: matplotlib pick_event returns incorrect pressed keys 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, - 1, "matplotlib pick_event problem")
    self.plotarea = PlotPanel(self)
    self.mainSizer = wx.BoxSizer(wx.HORIZONTAL)
    self.mainSizer.Add(self.plotarea, 1, wx.EXPAND)
    self.SetSizer(self.mainSizer)
    self.mainSizer.Fit(self)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    pre = wx.PreDialog()
    pre.SetExtraStyle(wx.DIALOG_EX_CONTEXTHELP)
    pre.Create(parent, - 1, "sample dialog", size = (200, 100), style = wx.CAPTION | wx.RESIZE_BORDER)
    self.PostCreate(pre)
    self.parent = parent
    self.Bind(wx.EVT_KEY_DOWN, self.parent._on_key_down)
    self.Bind(wx.EVT_KEY_UP, self.parent._on_key_up)
    btn = wx.Button(self, - 1, "OK")
    btn.Bind(wx.EVT_BUTTON, self._OnClick)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18805956_18940178_3_16
18805956_18940178_49_62
Title: matplotlib pick_event returns incorrect pressed keys 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.figure = mplFigure(figsize = (9, 6))
    self.ax = self.figure.add_subplot(111)
    self.ax.plot([1, 2, 3, 4], [2, 3, 5, 8], marker = "o", markersize = 20, picker = 10, linestyle = "None")
    self.canvas = mplCanvas(self, - 1, self.figure)
    self.figure.canvas.mpl_connect('pick_event', self.onClick)
    self.canvas.Bind(wx.EVT_KEY_DOWN, self._on_key_down)
    self.canvas.Bind(wx.EVT_KEY_UP, self._on_key_up)
    self.states = {"cmd" : False, "ctrl" : False, "shift" : False}
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    pre = wx.PreDialog()
    pre.SetExtraStyle(wx.DIALOG_EX_CONTEXTHELP)
    pre.Create(parent, - 1, "sample dialog", size = (200, 100), style = wx.CAPTION | wx.RESIZE_BORDER)
    self.PostCreate(pre)
    self.parent = parent
    self.Bind(wx.EVT_KEY_DOWN, self.parent._on_key_down)
    self.Bind(wx.EVT_KEY_UP, self.parent._on_key_up)
    btn = wx.Button(self, - 1, "OK")
    btn.Bind(wx.EVT_BUTTON, self._OnClick)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18833759_18833845_1_25
18833759_24558107_3_31
Title: Python Prime number checker 
----------------------------------------

def isprime(n) :
INDENT
    n = abs(int(n))

    if n < 2 :
    INDENT
        return False

    DEDENT
    if n == 2 :
    INDENT
        return True

    DEDENT
    if not n & 1 :
    INDENT
        return False

    DEDENT
    for x in range(3, int(n ** 0.5) + 1, 2) :
    INDENT
        if n % x == 0 :
        INDENT
            return False
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def isprime() :
INDENT
    total = 0
    factors = (1, a)
    pfactors = range(1, a + 1)

    if a == 1 or a == 0 :
    INDENT
        print "%d is NOT prime" % a
    DEDENT
    elif a == 2 :
    INDENT
        print "%d is  prime" % a
    DEDENT
    elif a % 2 == 0 :
    INDENT
        print "%d is NOT prime" % a
    DEDENT
    else :
    INDENT
        for number in pfactors :
        INDENT
            if (a % number) == 0 :
            INDENT
                total += number
            DEDENT
        DEDENT
        if total ! = sum(factors) :
        INDENT
            print "%d is NOT prime" % a
        DEDENT
        else :
        INDENT
            print "%d is  prime" % a
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18846024_49289496_4_15
18846024_49289822_3_17
Title: get list of named loglevels 
----------------------------------------

def get_logging_level_names() :
INDENT
    try :
    INDENT
        level_names = logging._levelToName
    DEDENT
    except AttributeError :
    INDENT
        level_names = logging._levelNames

    DEDENT
    return copy.copy(level_names)
DEDENT
----------------------------------------

def get_logging_level_names() :
INDENT
    try :
    INDENT
        level_to_name = logging._levelToName
        level_vals = level_to_name.keys()
    DEDENT
    except AttributeError :
    INDENT
        level_to_name = logging._levelNames
        level_vals = [key for key in level_to_name.keys() if isinstance(key, int)]
    DEDENT
    level_vals = sorted(level_vals)
    level_names = [level_to_name [val] for val in level_vals]
    return level_names
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18849318_18849636_1_9
18849318_18851112_6_17
Title: Not able to inline replace using re.sub and io.StringIO in Python 
----------------------------------------

def regFind(regx, sub_text, a_file) :
INDENT
    for line in a_file :
    INDENT
        match = regx.search(line)
        if match :
        INDENT
            replaced_line = re.sub(regx, sub_text, line)
            line = replaced_line
        DEDENT
        yield line
    DEDENT
DEDENT
----------------------------------------

def regFind(regx, sub_text, filename) :
INDENT
    for line in fileinput.input([filename],
        inplace = True,
        backup = '.bak') :
    INDENT
        match = regx.search(line)
        if match :
        INDENT
            line = regx.sub(sub_text, line)
        DEDENT
        sys.stdout.write(line)
        yield line

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18873066_37124230_13_19
18873066_51705288_13_22
Title: Pretty JSON Formatting in IPython Notebook 
----------------------------------------

def _ipython_display_(self) :
INDENT
    display_html('<div id="{}" style="height: 600px; width:100%;"><![CDATA[</div>'.format(self.uuid), raw = True)
    display_javascript("""
        require(["https://rawgit.com/caldwell/renderjson/master/renderjson.js"], function() {
        document.getElementById('%s').appendChild(renderjson(%s))
        });
        """ % (self.uuid, self.json_str), raw = True)
DEDENT
----------------------------------------

def _ipython_display_(self) :
INDENT
    display_html('<div id="{}" style="height: 600px; width:100%;"><![CDATA[</div>'.format(self.uuid),
        raw = True)
    display_javascript("""
        require(["https://rawgit.com/caldwell/renderjson/master/renderjson.js"], function() {
          renderjson.set_show_to_level(1)
          document.getElementById('%s').appendChild(renderjson(%s))
        });
        """ % (self.uuid, self.json_str), raw = True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18925241_18950990_16_27
18925241_19075963_22_29
Title: Send additional variable during PyQt PushButton click 
----------------------------------------

def toggleLED(self, pressed) :
INDENT
    source = self.sender()
    if pressed :
    INDENT
        source.setText('Off')
        self.serial.write(source.value)
        self.serial.write('L')
    DEDENT
    else :
    INDENT
        source.setText('On')
        self.serial.write(source.value)
        self.serial.write('H')
    DEDENT
DEDENT
----------------------------------------

def toggleLED(self, pressed, clikedBtn) :
INDENT
    if pressed :
    INDENT
        clickedBtn.setText("On")
    DEDENT
    else :
    INDENT
        clickedBtn.setText("Off")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18925241_18950990_3_15
18925241_19075963_3_21
Title: Send additional variable during PyQt PushButton click 
----------------------------------------

def initUI(self) :
INDENT
    btn1 = QPushButton('Off', self)
    btn1.setCheckable(True)
    btn1.value = 1
    btn1.clicked.connect(selftoggleLED)
    btn2 = QPushButton('Off', self)
    btn2.setCheckable(True)
    btn2.value = 2
    btn2.clicked.connect(selftoggleLED)

DEDENT
----------------------------------------

def initUI(self) :
INDENT
    btn1 = QPushButton('Off', self)
    btn1.setCheckable(True)
    btn1.LedOn = 0
    btn1.clicked.connect(selftoggleLED(1))
    btn2 = QPushButton('Off', self)
    btn2.setCheckable(True)
    btn2.LedOn = 0

    btns = [btn1, btn2]
    map(lambda btn : btn.clicked.connect(lambda pressed : self.toggleLED(pressed, btn)), btns)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18939464_18947381_14_23
18939464_18966938_7_20
Title: Most Efficient Way of Passing Data Between UI and Data Modules in Tkinter 
----------------------------------------

def __init__(self) :
INDENT
    self.x = 1
    self.y = 2
    self.GI = GUI()
    self.print_test()
    self.increment_vars()
    self.print_test()
    self.GI.increment_vars()
    self.print_test()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    root = tk.Tk()
    self.x = 3
    self.y = 4
    self.descr = tk.StringVar()
    tk.Label(root, textvariable = self.descr).grid()
    tk.Button(root, text = '"Generate" Data',
        command = self.increment_vars).grid(row = 1)
    self.dp = Data_Processor()
    self.increment_vars()
    root.mainloop()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18941674_18969336_15_22
18941674_18969336_6_13
Title: How to show CrossHair of wx.DC in wxpython? 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Panel.__init__(self, * args, ** kwargs)
    self.img = wx.Image('test.jpg')
    self.bmp = wx.BitmapFromImage(self.img)
    self.Bind(wx.EVT_MOTION, self.OnMouseMove)
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.coordinates = (0, 0)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, * args, ** kwargs)
    vbox = wx.BoxSizer(wx.VERTICAL)
    self.SetSizer(vbox)
    self.panel = MyPanel(self)
    vbox.Add(self.panel, 2, wx.EXPAND)
    self.Show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18948382_18948512_3_13
18948382_18950469_1_27
Title: Run length encoding in Python 
----------------------------------------

def runLengthEncode(plainText) :
INDENT
    res = []
    for k, i in groupby(plainText) :
    INDENT
        run = list(i)
        if (len(run) > 4) :
        INDENT
            res.append("/{:02}{}".format(len(run), k))
        DEDENT
        else :
        INDENT
            res.extend(run)
        DEDENT
    DEDENT
    return "".join(res)
DEDENT
----------------------------------------

def runLengthEncode(plainText) :
INDENT
    res = ''
    a = ''
    count = 0
    for i in plainText :
    INDENT
        count += 1
        if a.count(i) > 0 :
        INDENT
            a += i
        DEDENT
        else :
        INDENT
            if len(a) > 4 :
            INDENT
                if len(a) < 10 :
                INDENT
                    res += "/0" + str(len(a)) + a [0] [: 1]
                DEDENT
                else :
                INDENT
                    res += "/" + str(len(a)) + a [0] [: 1]
                DEDENT
                a = i
            DEDENT
            else :
            INDENT
                res += a
                a = i
            DEDENT
        DEDENT
        if count == len(plainText) :
        INDENT
            if len(a) > 4 :
            INDENT
                if len(a) < 10 :
                INDENT
                    res += "/0" + str(len(a)) + a [0] [: 1]
                DEDENT
                else :
                INDENT
                    res += "/" + str(len(a)) + a [0] [: 1]
                DEDENT
            DEDENT
            else :
            INDENT
                res += a
            DEDENT
        DEDENT
    DEDENT
    return (res)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18951389_18951399_1_9
18951389_18951650_1_8
Title: Reversing a String in Python Recursively 
----------------------------------------

def reverse(text) :
INDENT
    lst = []
    for i in range(0, len(text)) :
    INDENT

        lst.append(text [len(text) - (i + 1)])
    DEDENT
    lst = ''.join(lst)
    print lst
DEDENT
----------------------------------------

def reverse(input_string) :
INDENT
    if len(input_string) == 1 :
    INDENT
        print input_string [len(input_string) - 1]
        return input_string
    DEDENT
    else :
    INDENT
        print input_string [len(input_string) - 1]
        return input_string [len(input_string) - 1] + reverse(input_string [: len(input_string) - 1])
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
18957860_18959589_9_15
18957860_18988813_16_22
Title: Extracting data from nested tuples 
----------------------------------------

def makeList(tree) :
INDENT
    if len(tree) == 2 :
    INDENT
        return tree [1]
    DEDENT
    else :
    INDENT
        for i in range(1, len(tree)) :
        INDENT
            return [tree [len(tree) - 1] [1], makeList(tree [i])]
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def makeList(tree) :
INDENT
    if len(tree) == 2 :
    INDENT
        return [tree [1]]
    DEDENT
    left = tree [1]
    right = tree [2]
    return [leaves(left), leaves(right)]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19000121_19000573_5_19
19000121_19002385_4_26
Title: reverse order of python 
----------------------------------------

def reverse(s) :
INDENT
    p = re.compile(r'\w+')
    for m in p.finditer(s) :
    INDENT
        word = m.group()
        if word :
        INDENT
            p = s.partition(word)
            l = list(p)
            index = p.index(word)
            l [index] = l [index] [: : - 1]
            l2 = list(l [index])
            l2 [0], l2 [- 1] = l2 [- 1], l2 [0]
            l [index] = ''.join(l2)
            s = ''.join(l)
        DEDENT
    DEDENT
    return s
DEDENT
----------------------------------------

def reverse(string_) :
INDENT
    specchar = [(i, ltr) for i, ltr in enumerate(string_) if ltr in SPECIALCHARS]
    if specchar :
    INDENT

        newstring = ''.join(c for c in string_ if c not in SPECIALCHARS)
        newstring = newstring [: : - 1]
        offset = 0
        for pos, char in specchar :
        INDENT
            if pos + 1 + offset > = len(newstring) :
            INDENT

                newstring += char
            DEDENT
            else :
            INDENT

                newstring = newstring [: pos + offset] + char + newstring [pos + offset :]
                offset += 1
            DEDENT
        DEDENT
        return newstring
    DEDENT
    else :
    INDENT
        return string_ [: : - 1]

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19002469_19007761_4_28
19002469_23657142_28_40
Title: Update a MongoEngine document using a python dict? 
----------------------------------------

def update_document(document, data_dict) :
INDENT
    def field_value(field, value) :
    INDENT
        if field.__class__ in (fields.ListField, fields.SortedListField) :
        INDENT
            return [
                field_value(field.field, item) for item in value
                ]
        DEDENT
        if field.__class__ in (
            fields.EmbeddedDocumentField,
            fields.GenericEmbeddedDocumentField,
            fields.ReferenceField,
            fields.GenericReferenceField) :
        INDENT
            return field.document_type(** value)
        DEDENT
        else :
        INDENT
            return value
        DEDENT
    DEDENT
    [setattr(
            document, key,
            field_value(document._fields [key], value)) for key, value in data_dict.items()]
    return document
DEDENT
----------------------------------------

def update_document(doc, data) :
INDENT
    for key, value in data.iteritems() :
    INDENT
        if hasattr(doc, key) :
        INDENT
            value = field_value(doc._fields [key], value)
            setattr(doc, key, value)
        DEDENT
        else :
        INDENT
            pass
        DEDENT
    DEDENT
    return doc
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19002469_19007761_6_22
19002469_23657142_3_27
Title: Update a MongoEngine document using a python dict? 
----------------------------------------

def field_value(field, value) :
INDENT
    if field.__class__ in (fields.ListField, fields.SortedListField) :
    INDENT
        return [
            field_value(field.field, item) for item in value
            ]
    DEDENT
    if field.__class__ in (
        fields.EmbeddedDocumentField,
        fields.GenericEmbeddedDocumentField,
        fields.ReferenceField,
        fields.GenericReferenceField) :
    INDENT
        return field.document_type(** value)
    DEDENT
    else :
    INDENT
        return value
    DEDENT
DEDENT
----------------------------------------

def field_value(field, value) :
INDENT
    if field.__class__ in (ListField, SortedListField) :
    INDENT
        return [
            field_value(field.field, item) for item in value]
    DEDENT
    elif field.__class__ in (
        EmbeddedDocumentField,
        GenericEmbeddedDocumentField,
        ReferenceField,
        GenericReferenceField) :
    INDENT

        embedded_doc = field.document_type()
        update_document(embedded_doc, value)
        return embedded_doc
    DEDENT
    else :
    INDENT
        return value

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19003803_19009643_31_47
19003803_19009643_52_61
Title: Adding and removing tkinter frames - keeping track of instances 
----------------------------------------

def __init__(self, parent, name) :
INDENT
    tk.Frame.__init__(self, parent)
    self.parent = parent
    self.e1 = tk.Entry(self)
    self.e2 = tk.Entry(self)
    self.e3 = tk.Entry(self)
    label = tk.Label(self, text = name, anchor = "center")
    add_button = tk.Button(self, text = "Add", command = self.parent.Add)
    remove_button = tk.Button(self, text = "Remove", command = lambda : self.parent.Remove(self))
    label.pack(side = "top", fill = "x")
    self.e1.pack(side = "top", fill = "x")
    self.e2.pack(side = "top", fill = "x")
    self.e3.pack(side = "top", fill = "x")
    add_button.pack(side = "top")
    remove_button.pack(side = "top")
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    tk.Tk.__init__(self)
    self.master_frame = tk.Frame(self)
    self.master_frame.grid()
    self.all_instances = FrameGroup(self.master_frame)
    self.all_instances.grid()

    self.all_instances.Add()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19004482_19004704_1_12
19004482_19005245_1_17
Title: Can Lists cope with a million items? 
----------------------------------------

def reduceOutputListToPossibleMatches(outputList, detailsList) :
INDENT
    for outputItem in outputList :
    INDENT
        isFound = False
        for detailsItem in detailsList :
        INDENT
            if detailsItem [14] == outputItem [4] :
            INDENT
                if isfound :
                INDENT
                    detailsItem [30] = "1"
                    break
                DEDENT
                isFound = True
            DEDENT
        DEDENT
        else :
        INDENT
            yield detailsItem
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def reduceOutputListToPossibleMatches(outputList, detailsList) :
INDENT
    details = {}
    for detailsItem in detailsList :
    INDENT
        key = detailsItem [14]
        if key in details :
        INDENT
            details [key].append(detailsItem)
        DEDENT
        else :
        INDENT
            details [key] = [detailsItem]
        DEDENT
    DEDENT
    for outputItem in outputList :
    INDENT
        key = outputItem [4]
        if key in details :
        INDENT
            for item in details [key] :
            INDENT
                if len(details [key]) > 1 :
                INDENT
                    item [30] = "1"
                DEDENT
                yield item
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19031857_19032158_7_12
19031857_19032386_3_8
Title: introspect current thread in python 
----------------------------------------

def func(identifier) :
INDENT
    while threading.get_ident() ! = marked_thread_for_cancellation :
    INDENT
        time.sleep(1)
        print ('{} is alive'.format(identifier))
    DEDENT
    print ('{} is dead'.format(identifier))
DEDENT
----------------------------------------

def func() :
INDENT
    if threading.current_thread() is marked_thread_for_cancellation :
    INDENT
        print 'cancel'
    DEDENT
    else :
    INDENT
        print 'otherwise'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19040057_19040075_3_13
19040057_19040458_3_10
Title: How To Have User Input Date and Subtract from It 
----------------------------------------

def ObtainDate() :
INDENT
    isValid = False
    while not isValid :
    INDENT
        userIn = raw_input("Type Date: mm/dd/yy: ")
        try :
        INDENT
            d1 = datetime.strptime(userIn, "%m/%d/%y")
            isValid = True
        DEDENT
        except :
        INDENT
            print "Invalid Format!\n"
        DEDENT
    DEDENT
    return d1
DEDENT
----------------------------------------

def ObtainDate() :
INDENT
    while True :
    INDENT
        userIn = raw_input("Type Date: mm/dd/yy: ")
        try :
        INDENT
            return datetime.strptime(userIn, "%m/%d/%y")
        DEDENT
        except ValueError :
        INDENT
            print "Invalid Format!\n"
        DEDENT
    DEDENT
DEDENT
----------------------------------------
