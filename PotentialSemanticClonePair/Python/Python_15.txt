$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22748225_22763718_51_104
22748225_22763718_9_33
Title: The converted .py file of Qt is not working for opening new window 
----------------------------------------

def setupUi(self, NewWindow) :
INDENT
    self.NewWindow = NewWindow
    self.NewWindow.setObjectName(_fromUtf8("NewWindow"))
    self.NewWindow.resize(439, 225)
    self.centralwidget = QtGui.QWidget(NewWindow)
    self.centralwidget.setObjectName(_fromUtf8("centralwidget"))
    self.pushButton_2 = QtGui.QPushButton(self.centralwidget)
    self.pushButton_2.setGeometry(QtCore.QRect(170, 140, 99, 27))
    self.pushButton_2.setObjectName(_fromUtf8("pushButton_2"))
    self.widget = QtGui.QWidget(self.centralwidget)
    self.widget.setGeometry(QtCore.QRect(40, 30, 365, 89))
    self.widget.setObjectName(_fromUtf8("widget"))
    self.verticalLayout = QtGui.QVBoxLayout(self.widget)
    self.verticalLayout.setObjectName(_fromUtf8("verticalLayout"))
    self.horizontalLayout_2 = QtGui.QHBoxLayout()
    self.horizontalLayout_2.setObjectName(_fromUtf8("horizontalLayout_2"))
    self.label_3 = QtGui.QLabel(self.widget)
    self.label_3.setObjectName(_fromUtf8("label_3"))
    self.horizontalLayout_2.addWidget(self.label_3)
    self.lineEdit = QtGui.QLineEdit(self.widget)
    self.lineEdit.setObjectName(_fromUtf8("lineEdit"))
    self.horizontalLayout_2.addWidget(self.lineEdit)
    self.label_4 = QtGui.QLabel(self.widget)
    self.label_4.setObjectName(_fromUtf8("label_4"))
    self.horizontalLayout_2.addWidget(self.label_4)
    self.lineEdit_2 = QtGui.QLineEdit(self.widget)
    self.lineEdit_2.setObjectName(_fromUtf8("lineEdit_2"))
    self.horizontalLayout_2.addWidget(self.lineEdit_2)
    self.verticalLayout.addLayout(self.horizontalLayout_2)
    self.pushButton = QtGui.QPushButton(self.widget)
    self.pushButton.setObjectName(_fromUtf8("pushButton"))
    self.verticalLayout.addWidget(self.pushButton)
    self.horizontalLayout = QtGui.QHBoxLayout()
    self.horizontalLayout.setObjectName(_fromUtf8("horizontalLayout"))
    self.label = QtGui.QLabel(self.widget)
    self.label.setObjectName(_fromUtf8("label"))
    self.horizontalLayout.addWidget(self.label)
    self.label_2 = QtGui.QLabel(self.widget)
    self.label_2.setObjectName(_fromUtf8("label_2"))
    self.horizontalLayout.addWidget(self.label_2)
    self.verticalLayout.addLayout(self.horizontalLayout)
    self.menubar = QtGui.QMenuBar(NewWindow)
    self.menubar.setGeometry(QtCore.QRect(0, 0, 439, 25))
    self.menubar.setObjectName(_fromUtf8("menubar"))
    self.statusbar = QtGui.QStatusBar(NewWindow)
    self.statusbar.setObjectName(_fromUtf8("statusbar"))
    self.retranslateUi(NewWindow)
    QtCore.QMetaObject.connectSlotsByName(NewWindow)
    self.pushButton.clicked.connect(self.sum)

DEDENT
----------------------------------------

def setupUi(self, MainWindow) :
INDENT
    self.mainwindow = MainWindow
    MainWindow.setObjectName(_fromUtf8("MainWindow"))
    MainWindow.resize(400, 300)
    self.centralWidget = QtGui.QWidget(MainWindow)
    self.centralWidget.setObjectName(_fromUtf8("centralWidget"))
    self.mMyButton = QtGui.QPushButton(self.centralWidget)
    self.mMyButton.setGeometry(QtCore.QRect(140, 90, 99, 27))
    self.mMyButton.setObjectName(_fromUtf8("mMyButton"))
    MainWindow.setCentralWidget(self.centralWidget)
    self.menuBar = QtGui.QMenuBar(MainWindow)
    self.menuBar.setGeometry(QtCore.QRect(0, 0, 400, 25))
    self.menuBar.setObjectName(_fromUtf8("menuBar"))
    MainWindow.setMenuBar(self.menuBar)
    self.mainToolBar = QtGui.QToolBar(MainWindow)
    self.mainToolBar.setObjectName(_fromUtf8("mainToolBar"))
    MainWindow.addToolBar(QtCore.Qt.TopToolBarArea, self.mainToolBar)
    self.statusBar = QtGui.QStatusBar(MainWindow)
    self.statusBar.setObjectName(_fromUtf8("statusBar"))
    MainWindow.setStatusBar(self.statusBar)
    self.retranslateUi(MainWindow)
    QtCore.QMetaObject.connectSlotsByName(MainWindow)
    self.mMyButton.clicked.connect(self.showNewWindow)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22770598_22771092_23_37
22770598_22772298_1_14
Title: locating city that serves the most other cities within a given radius 
----------------------------------------

def locateFacilities(cities, radius) :
INDENT
    cities = [City(idx, name) for idx, name in enumerate(data [0])]
    for city in cities : city.makeNeighbours(cities, radius)
    facilities = []
    while cities :
    INDENT
        mostNeighbours = sorted(cities, key = lambda c : - len(c.neighbours)) [0]
        for city in cities :
        INDENT
            city.removeNeighbour(mostNeighbours)
        DEDENT
        for city in mostNeighbours.neighbours :
        INDENT
            cities.remove(city)
        DEDENT
        cities.remove(mostNeighbours)
        facilities.append(mostNeighbours)
    DEDENT
    print ('Place facilities at:')
    for facility in facilities :
    INDENT
        print (facility.name)
    DEDENT
DEDENT
----------------------------------------

def locateFacilities(data, r) :
INDENT
    n = len(data [0])
    served = [False] * n
    facilities = []
    while not all(served) :
    facilities.sort()
    return facilities
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22773579_22774434_3_24
22773579_22774899_51_63
Title: Issue with program to approximate sin and cosine values 
----------------------------------------

def main() :
INDENT
    print ()
    print ("Program to approximate sin and cos.")
    print ("You will be asked to enter an angle and \na number of terms.")
    print ("Written by ME")
    print ()
    sinx = 0
    cosx = 0
    x = int(input("Enter an angle (in degrees): "))
    terms = int(input("Enter the number of terms to use: "))
    print ()
    x = x / 180.0 * math.pi;
    for i in range(1, terms + 1) :
    INDENT
        sinx = sinx + getSin(i, x)
        cosx = cosx + getCos(i, x)
    DEDENT
    print ("Cos:{0}, Sinus:{1}".format(cosx, sinx));
DEDENT
----------------------------------------

def main() :
INDENT
    print (
        "\nProgram to approximate sin and cos."
        "\nYou will be asked to enter an angle and"
        "\na number of terms.")
    theta = get_float("Enter an angle (in degrees): ")
    terms = get_int("Number of terms to use: ")
    print ("sin({}) = {}".format(theta, calc_sin(radians(theta), terms)))
    print ("cos({}) = {}".format(theta, calc_cos(radians(theta), terms)))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22773579_22774434_3_24
22773579_22791396_19_33
Title: Issue with program to approximate sin and cosine values 
----------------------------------------

def main() :
INDENT
    print ()
    print ("Program to approximate sin and cos.")
    print ("You will be asked to enter an angle and \na number of terms.")
    print ("Written by ME")
    print ()
    sinx = 0
    cosx = 0
    x = int(input("Enter an angle (in degrees): "))
    terms = int(input("Enter the number of terms to use: "))
    print ()
    x = x / 180.0 * math.pi;
    for i in range(1, terms + 1) :
    INDENT
        sinx = sinx + getSin(i, x)
        cosx = cosx + getCos(i, x)
    DEDENT
    print ("Cos:{0}, Sinus:{1}".format(cosx, sinx));
DEDENT
----------------------------------------

def main() :
INDENT
    print "\nProgram to approximate sin and cos."
    print "You will be asked to enter an angle and \na number of terms."
    x = int(input("Enter an angle (in degrees): "))
    terms = int(input("Enter the number of terms to use: "))
    print
    x = x * RadInDeg;
    cosx, sinx = getCosSin(x, terms)
    print cosx, sinx
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22773579_22774899_51_63
22773579_22791396_19_33
Title: Issue with program to approximate sin and cosine values 
----------------------------------------

def main() :
INDENT
    print (
        "\nProgram to approximate sin and cos."
        "\nYou will be asked to enter an angle and"
        "\na number of terms.")
    theta = get_float("Enter an angle (in degrees): ")
    terms = get_int("Number of terms to use: ")
    print ("sin({}) = {}".format(theta, calc_sin(radians(theta), terms)))
    print ("cos({}) = {}".format(theta, calc_cos(radians(theta), terms)))
DEDENT
----------------------------------------

def main() :
INDENT
    print "\nProgram to approximate sin and cos."
    print "You will be asked to enter an angle and \na number of terms."
    x = int(input("Enter an angle (in degrees): "))
    terms = int(input("Enter the number of terms to use: "))
    print
    x = x * RadInDeg;
    cosx, sinx = getCosSin(x, terms)
    print cosx, sinx
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22774570_22775275_22_36
22774570_22775275_4_16
Title: Creating two button methods Python 
----------------------------------------

def __init__(self, coords = (0, 0, 100, 100)) :
INDENT
    self.win = GraphWin()
    self.win.setCoords(* coords)

    self.buttons = []

    self.win.setMouseHandler(self._callback)
    self._quit = False

    self.create_button("Quit", (Point(10, 10), Point(40, 40)), Point(20, 20), self.quit)
    self.create_button("Confess", (Point(50, 50), Point(80, 80)), Point(60, 60), self.confess)
DEDENT
----------------------------------------

def __init__(self, text, text_pos, rect_pos, win, callback) :
INDENT
    self.win = win
    self.text = Text(text_pos, text)
    self.text.draw(self.win)

    self.coords = [rect_pos [0].x, rect_pos [0].y, rect_pos [1].x, rect_pos [1].y]
    self.rect = Rectangle(* rect_pos)
    self.rect.draw(self.win)

    self.callback = callback
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22792082_22792414_5_10
22792082_22792621_7_13
Title: Infinite loop in python 
----------------------------------------

def loop(self) :
INDENT
    var = 1
    while var == 1 :
    INDENT
        self.input()

    DEDENT
DEDENT
----------------------------------------

def loop() :
INDENT
    global input
    var = 1
    while var == 1 :
    INDENT
        input = input()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22829078_22829887_38_67
22829078_22829887_8_31
Title: Opening a text file in another window using push button in PyQt 
----------------------------------------

def setupUi(self, MainWindow) :
INDENT
    MainWindow.setObjectName(_fromUtf8("MainWindow"))
    MainWindow.resize(559, 207)
    self.centralWidget = QtGui.QWidget(MainWindow)
    self.centralWidget.setObjectName(_fromUtf8("centralWidget"))
    self.label = QtGui.QLabel(self.centralWidget)
    self.label.setGeometry(QtCore.QRect(20, 40, 111, 17))
    self.label.setObjectName(_fromUtf8("label"))
    self.lineEdit = QtGui.QLineEdit(self.centralWidget)
    self.lineEdit.setGeometry(QtCore.QRect(130, 40, 411, 25))
    self.lineEdit.setObjectName(_fromUtf8("lineEdit"))
    self.pushButton = QtGui.QPushButton(self.centralWidget)
    self.pushButton.setGeometry(QtCore.QRect(200, 90, 151, 27))
    self.pushButton.setObjectName(_fromUtf8("pushButton"))
    MainWindow.setCentralWidget(self.centralWidget)
    self.menuBar = QtGui.QMenuBar(MainWindow)
    self.menuBar.setGeometry(QtCore.QRect(0, 0, 559, 23))
    self.menuBar.setObjectName(_fromUtf8("menuBar"))
    MainWindow.setMenuBar(self.menuBar)
    self.mainToolBar = QtGui.QToolBar(MainWindow)
    self.mainToolBar.setObjectName(_fromUtf8("mainToolBar"))
    MainWindow.addToolBar(QtCore.Qt.TopToolBarArea, self.mainToolBar)
    self.statusBar = QtGui.QStatusBar(MainWindow)
    self.statusBar.setObjectName(_fromUtf8("statusBar"))
    MainWindow.setStatusBar(self.statusBar)
    self.retranslateUi(MainWindow)
    QtCore.QObject.connect(self.pushButton, QtCore.SIGNAL("clicked()"), self.OpenIT)
    QtCore.QMetaObject.connectSlotsByName(MainWindow)
DEDENT
----------------------------------------

def setupUi(self, TextFile, file) :
INDENT
    self.text = open(file, "r").read()
    TextFile.setObjectName(_fromUtf8("TextFile"))
    TextFile.resize(683, 531)
    self.scrollArea = QtGui.QScrollArea(TextFile)
    self.scrollArea.setGeometry(QtCore.QRect(10, 50, 661, 471))
    self.scrollArea.setWidgetResizable(True)
    self.scrollArea.setObjectName(_fromUtf8("scrollArea"))
    self.scrollAreaWidgetContents = QtGui.QWidget()
    self.scrollAreaWidgetContents.setGeometry(QtCore.QRect(0, 0, 657, 467))
    self.scrollAreaWidgetContents.setObjectName(_fromUtf8("scrollAreaWidgetContents"))
    self.textEdit = QtGui.QTextEdit(self.scrollAreaWidgetContents)
    self.textEdit.setGeometry(QtCore.QRect(0, 0, 661, 461))
    self.textEdit.setObjectName(_fromUtf8("textEdit"))
    self.textEdit.setText(self.text)
    self.scrollArea.setWidget(self.scrollAreaWidgetContents)
    self.label = QtGui.QLabel(TextFile)
    self.label.setGeometry(QtCore.QRect(280, 20, 67, 17))
    self.label.setObjectName(_fromUtf8("label"))
    self.retranslateUi(TextFile)
    QtCore.QMetaObject.connectSlotsByName(TextFile)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22856198_22857102_3_27
22856198_41804600_1_28
Title: How to get unread messages and set message read flags over IMAP using Python? 
----------------------------------------

def read(username, password, sender_of_interest) :
INDENT
    imap = imaplib.IMAP4_SSL("imap.gmail.com", 993)
    imap.login(username, password)
    imap.select('INBOX')

    status, response = imap.search(None, 'INBOX', '(UNSEEN)')
    unread_msg_nums = response [0].split()

    print len(unread_msg_nums)
    status, response = imap.search(None, '(UNSEEN)', '(FROM "%s")' % (sender_of_interest))
    unread_msg_nums = response [0].split()
    da = []
    for e_id in unread_msg_nums :
    INDENT
        _, response = imap.fetch(e_id, '(UID BODY[TEXT])')
        da.append(response [0] [1])
    DEDENT
    print da
    for e_id in unread_msg_nums :
    INDENT
        imap.store(e_id, '+FLAGS', '\Seen')
    DEDENT
DEDENT
----------------------------------------

def read(username, password, sender_of_interest = None) :
INDENT
    imap = imaplib.IMAP4_SSL("imap.gmail.com", 993)
    imap.login(username, password)
    imap.select('INBOX')

    if sender_of_interest :
    INDENT
        status, response = imap.uid('search', None, 'UNSEEN', 'FROM {0}'.format(sender_of_interest))
    DEDENT
    else :
    INDENT
        status, response = imap.uid('search', None, 'UNSEEN')
    DEDENT
    if status == 'OK' :
    INDENT
        unread_msg_nums = response [0].split()
    DEDENT
    else :
    INDENT
        unread_msg_nums = []
    DEDENT
    data_list = []
    for e_id in unread_msg_nums :
    INDENT
        data_dict = {}
        e_id = e_id.decode('utf-8')
        _, response = imap.uid('fetch', e_id, '(RFC822)')
        html = response [0] [1].decode('utf-8')
        email_message = email.message_from_string(html)
        data_dict ['mail_to'] = email_message ['To']
        data_dict ['mail_subject'] = email_message ['Subject']
        data_dict ['mail_from'] = email.utils.parseaddr(email_message ['From'])
        data_dict ['body'] = email_message.get_payload()
        data_list.append(data_dict)
    DEDENT
    print (data_list)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22887906_22888120_23_32
22887906_22888120_4_14
Title: How to use a turtle superclass 
----------------------------------------

def __init__(self, name, radius, mass, colour, dist, vel_x, vel_y,
shape = 'circle') :
INDENT
    SolarElement.__init__(self, name, radius, mass, colour,
        shape = shape)
    self.dist = dist
    self.vel_x = vel_x
    self.vel_y = vel_y
    self.x_pos = sun.radius + self.dist + self.radius
    self.y_pos = 0
DEDENT
----------------------------------------

def __init__(self, name, radius, mass, colour, shape = 'circle') :
INDENT
    super(SolarElement, self).__init__(shape = shape)
    self.name = name
    self.radius = radius
    self.mass = mass
    self.colour = colour
    self.color(self.colour)
    self.shapesize(self.radius / 50)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22887906_22888120_23_32
22887906_22888171_19_28
Title: How to use a turtle superclass 
----------------------------------------

def __init__(self, name, radius, mass, colour, dist, vel_x, vel_y,
shape = 'circle') :
INDENT
    SolarElement.__init__(self, name, radius, mass, colour,
        shape = shape)
    self.dist = dist
    self.vel_x = vel_x
    self.vel_y = vel_y
    self.x_pos = sun.radius + self.dist + self.radius
    self.y_pos = 0
DEDENT
----------------------------------------

def __init__(self, Name, Radius, Mass, Colour, Dist, velX, velY) :
INDENT
    super(solar_element, self).__init__()
    solar_element.__init__(self, Name, Radius, Mass, Colour)
    Turtle.__init__(self, shape = "circle")
    self.Dist = Dist
    self.velX = velX
    self.velY = velY
    self.x_pos = sun.Radius + self.Dist + self.Radius
    self.y_pos = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22887906_22888120_23_32
22887906_22888171_4_12
Title: How to use a turtle superclass 
----------------------------------------

def __init__(self, name, radius, mass, colour, dist, vel_x, vel_y,
shape = 'circle') :
INDENT
    SolarElement.__init__(self, name, radius, mass, colour,
        shape = shape)
    self.dist = dist
    self.vel_x = vel_x
    self.vel_y = vel_y
    self.x_pos = sun.radius + self.dist + self.radius
    self.y_pos = 0
DEDENT
----------------------------------------

def __init__(self, Name, Radius, Mass, Colour) :
INDENT
    super(solar_element, self).__init__()
    self.Name = Name
    self.Radius = Radius
    self.Mass = Mass
    self.Colour = Colour
    self.color(self.Colour)
    self.shapesize(self.Radius / 50)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22887906_22888120_4_14
22887906_22888171_19_28
Title: How to use a turtle superclass 
----------------------------------------

def __init__(self, name, radius, mass, colour, shape = 'circle') :
INDENT
    super(SolarElement, self).__init__(shape = shape)
    self.name = name
    self.radius = radius
    self.mass = mass
    self.colour = colour
    self.color(self.colour)
    self.shapesize(self.radius / 50)

DEDENT
----------------------------------------

def __init__(self, Name, Radius, Mass, Colour, Dist, velX, velY) :
INDENT
    super(solar_element, self).__init__()
    solar_element.__init__(self, Name, Radius, Mass, Colour)
    Turtle.__init__(self, shape = "circle")
    self.Dist = Dist
    self.velX = velX
    self.velY = velY
    self.x_pos = sun.Radius + self.Dist + self.Radius
    self.y_pos = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22887906_22888171_19_28
22887906_22888171_4_12
Title: How to use a turtle superclass 
----------------------------------------

def __init__(self, Name, Radius, Mass, Colour, Dist, velX, velY) :
INDENT
    super(solar_element, self).__init__()
    solar_element.__init__(self, Name, Radius, Mass, Colour)
    Turtle.__init__(self, shape = "circle")
    self.Dist = Dist
    self.velX = velX
    self.velY = velY
    self.x_pos = sun.Radius + self.Dist + self.Radius
    self.y_pos = 0
DEDENT
----------------------------------------

def __init__(self, Name, Radius, Mass, Colour) :
INDENT
    super(solar_element, self).__init__()
    self.Name = Name
    self.Radius = Radius
    self.Mass = Mass
    self.Colour = Colour
    self.color(self.Colour)
    self.shapesize(self.Radius / 50)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22895308_22895455_1_10
22895308_22895658_1_18
Title: How to find a root for a mathematical function using Intermediate value theorem? 
----------------------------------------

def find_root(f, a, b, EPS = 0.0001) :
INDENT
    if f(a) == 0 : return a
    if f(b) == 0 : return b
    if f(a) * f(b) > 0 : return None
    c = (a + b) / 2
    while (abs(f(c)) > EPS) :
    INDENT
        if f(a) * f(c) < 0 : b = c
        else : a = c
        c = (a + b) / 2
    DEDENT
    return c
DEDENT
----------------------------------------

def find_root(f, a, b, EPS = 0.001) :
INDENT
    fa = f(a)
    fb = f(b)
    if fa * fb > 0 :
    INDENT
        return None
    DEDENT
    while abs(fa) > EPS and abs(fb) > EPS :
    INDENT
        c = (a + b) / 2.0
        fc = f(c)
        if fa * fc > = 0 :
        INDENT
            a = c
            fa = fc
        DEDENT
        else :
        INDENT
            b = c
            fb = fc
        DEDENT
    DEDENT
    if abs(fa) < = EPS :
    INDENT
        return a
    DEDENT
    else :
    INDENT
        return b
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22921626_22957839_34_38
22921626_22957839_53_57
Title: How to compose to functions several times? 
----------------------------------------

def nested(arg) :
INDENT
    gen = nest(func, arg)
    for i in range(n) :
    INDENT
        next(gen)
    DEDENT
    return next(gen)
DEDENT
----------------------------------------

def nested(a) :
INDENT
    gen = nest(self, a)
    for i in range(n) :
    INDENT
        next(gen)
    DEDENT
    return next(gen)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22937110_22937377_3_19
22937110_22937638_2_10
Title: "How can I get a list like this [303132333435] when i give ""in between 30 and 35"" to a python function" 
----------------------------------------

def get_values(myString) :
INDENT
    res = []
    m = re.search('in between\s+(\d+)\s+and\s+(\d+)', myString, re.IGNORECASE)
    p = re.search('in \[([\d, ]*)\]', myString, re.IGNORECASE)
    if m ! = None :
    INDENT
        lower = int(m.group(1))
        upper = int(m.group(2))
        res.extend(range(lower, upper))
    DEDENT
    if p ! = None :
    INDENT
        res.extend([int(x) for x in p.group(1).split(',')])

    DEDENT
    res = list(set(res)) if res ! = None else []
    return res
DEDENT
----------------------------------------

def get_values(sql) :
INDENT
    sql = sql.upper()
    between_regex = '(\d+)\s+AND\s+(\d+)'
    ranges = [range(int(a), int(b)) for a, b in re.findall(between_regex, sql)]
    in_regex = '\[(.*)]'
    ranges += [[int(y) for y in x.split(',')] for x in re.findall(in_regex, sql)]
    return [x for r in ranges for x in r]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22947733_22948033_1_8
22947733_22948692_2_16
Title: split a string but keep type 
----------------------------------------

def try_cast(val) :
INDENT
    try :
    INDENT
        if float(val) - int(val) > 0.01 :
        INDENT
            return float(val)
        DEDENT
        return int(val)
    DEDENT
    except :
    INDENT
        return val
    DEDENT
DEDENT
----------------------------------------

def try_cast(val) :
INDENT
    try :
    INDENT
        format = "%Y-%m-%d %H:%M:%S"
        return datetime.strptime(val, format)
    DEDENT
    except :
    INDENT
        pass
    DEDENT
    try :
    INDENT
        if float(val) == int(val) :
        INDENT
            return int(val)
        DEDENT
        return float(val)
    DEDENT
    except :
    INDENT
        return val
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22950800_22950863_1_18
22950800_22950886_1_10
Title: Pythonic way to extract first line of a tabular file to a list 
----------------------------------------

def firstline_to_list(fvar) :
INDENT
    import csv, sys
    with open(fvar, 'r') as tsvfile :
    INDENT
        tabreader = csv.reader(tsvfile, delimiter = '\t')
        try :
        INDENT
            if sys.version > '3' :
            INDENT
                result = next(tabreader)
            DEDENT
            else :
            INDENT
                result = tabreader.next()
            DEDENT
        DEDENT
        except StopIteration :
        INDENT
            result = None
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def firstline_to_list(fvar) :
INDENT
    import csv
    with open(fvar, 'r') as tsvfile :
    INDENT
        tabreader = csv.reader(tsvfile, delimiter = '\t')
        for row in tabreader :
        INDENT
            return row
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22962794_22965422_56_94
22962794_22969681_47_97
Title: Collapse sub-trees in a tree with average distance to tips < x 
----------------------------------------

def parse(tree) :
INDENT
    buff = ''
    stack = Stack()
    while True :
    INDENT
        c = tree [0]
        if c == ';' : break
        tree = tree [1 :]
        if c == '(' :
        INDENT
            stack.push(c)
            continue
        DEDENT
        if c in ':,' :
        INDENT
            if buff : stack.push(buff)
            buff = ''
            continue
        DEDENT
        if c == ')' :
        INDENT
            if buff : stack.push(buff)
            buff = ''
            popped = ''
            children = []
            while True :
            INDENT
                weight = stack.pop()
                if weight == '(' : break
                weight = float(weight)
                child = stack.pop()
                if isinstance(child, Tree) :
                INDENT
                    child.weight = weight
                DEDENT
                else :
                INDENT
                    child = Node(weight, child)
                DEDENT
                children.append(child)
            DEDENT
            stack.push(Tree(0, children))
            continue
        DEDENT
        buff += c
    DEDENT
    return stack.pop()
DEDENT
----------------------------------------

def parse(tree) :
INDENT
    stack = Stack()
    stack.push(Tree())
    buff = ''
    pos = - 1
    tree = tree.strip()
    while True :
    INDENT
        pos += 1
        c = tree [0]
        tree = tree [1 :].strip()
        if tree : la = tree [0]
        if c == '(' :
        INDENT
            if buff :
            INDENT
                raise UnexpectedSymbolException(
                    'Unexpected symbol {} at position {}.'.format(c, pos))
            DEDENT
            if la == '(' : stack.push(Tree())
            else : stack.push(Node())
            continue
        DEDENT
        if c == ')' :
        INDENT
            parseNameOrLength(stack, buff)
            buff = ''
            child = stack.pop()
            stack.peek().children.append(child)
            continue
        DEDENT
        if c in ',;' :
        INDENT
            parseNameOrLength(stack, buff)
            buff = ''
            if c == ';' : return stack.pop()
            child = stack.pop()
            stack.peek().children.append(child)
            if la == '(' : stack.push(Tree())
            else : stack.push(Node())
            continue
        DEDENT
        if c == ':' :
        INDENT
            if stack.peek() == ':' :
            INDENT
                raise UnexpectedSymbolException(
                    'Unexpected symbol {} at position {}.'.format(c, pos))
            DEDENT
            stack.peek().name = buff
            stack.push(':')
            buff = ''
            continue
        DEDENT
        buff += c
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22964441_22964561_1_12
22964441_22965664_4_18
Title: Recursive function for tuple 
----------------------------------------

def rabbit(rocks, prev = 0) :
INDENT
    if rocks [0] - prev > 50 :
    INDENT
        return - 1
    DEDENT
    p = rocks [0]
    for i, x in enumerate(rocks) :
    INDENT
        if x - prev > 50 :
        INDENT
            ret = rabbit(rocks [i :], p)
            if ret > = 0 :
            INDENT
                ret += 1
            DEDENT
            return ret
        DEDENT
        p = x
    DEDENT
    return 1
DEDENT
----------------------------------------

def rabbit(rocks, hop = 50) :
INDENT
    if not rocks :
    INDENT
        raise ValueError('No rocks')
    DEDENT
    step = rocks [0]
    steps = [step]
    while True :
    INDENT
        x = bisect.bisect_right(rocks, step + hop)
        step = rocks [x - 1]
        steps.append(step)
        if x == len(rocks) :
        INDENT
            break
        DEDENT
        elif rocks [x] - step > hop :
        INDENT
            raise ValueError('Too far between {0} and {1}'
                ''.format(rocks [x], step))
        DEDENT
    DEDENT
    return steps
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22964637_22972091_4_11
22964637_23017898_8_20
Title: PyQT4 Javascript Alert 
----------------------------------------

def __init__(self) :
INDENT
    QtWebKit.QWebPage.__init__(self)
    self.cookies = QtNetwork.QNetworkCookieJar(self)
    self.cookies.setAllCookies(
        [QtNetwork.QNetworkCookie('enurl_bak', '1')])
    self.networkAccessManager().setCookieJar(self.cookies)
    self.mainFrame().loadFinished.connect(self.handleLoadFinished)
DEDENT
----------------------------------------

def __init__(self, url) :
INDENT
    self.app = QApplication(sys.argv)
    QWebPage.__init__(self)
    self.loadFinished.connect(self._loadFinished)
    self.mainFrame().load(QUrl(url))
    self.cookie = QNetworkCookie()
    self.cookie.setDomain('.nowgoal.com')
    self.cookie.setName('enurl_bak')
    self.cookiejar = QNetworkCookieJar()
    self.cookiejar.setAllCookies([self.cookie])
    self.networkAccessManager().setCookieJar(self.cookiejar)
    self.app.exec_()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22995048_22995234_1_11
22995048_22995400_1_12
Title: split list into sublists 
----------------------------------------

def split_list(lst, a) :
INDENT
    list1 = []
    list2 = []
    for i in lst :
    INDENT
        if i < = a :
        INDENT
            list1.append(i)
        DEDENT
        elif i > a :
        INDENT
            list2.append(i)
        DEDENT
    DEDENT
    return (list1, list2)
DEDENT
----------------------------------------

def split_list(lst, a) :
INDENT
    list1 = []
    list2 = []
    for x in range(len(lst) - 1, - 1, - 1) :
    INDENT
        if lst [x] < = a :
        INDENT
            list1.append(lst [x])
            del lst [x]
        DEDENT
        elif lst [x] > a :
        INDENT
            list2.append(lst [x])
            del lst [x]
        DEDENT
    DEDENT
    return (list1, list2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23000565_23000627_1_10
23000565_23000675_1_13
Title: Recursion in memory 
----------------------------------------

def rec(x) :
INDENT
    if x < 2 :
    INDENT
        return 1
    DEDENT
    else :
    INDENT
        print "x = ", x
        a = rec(x - 1)
        print "a = ", a
        b = rec(x - 2)
        print "b = ", b
        return a + b
    DEDENT
DEDENT
----------------------------------------

def rec(x, depth = 0) :
INDENT
    print " " * (depth * 3), "x =", x
    if x < 2 :
    INDENT
        print " " * (depth * 3), "=> 1"
        return 1
    DEDENT
    else :
    INDENT
        a = rec(x - 1, depth + 1)
        print " " * (depth * 3), "a =", a
        b = rec(x - 2, depth + 1)
        print " " * (depth * 3), "b =", b
        print " " * (depth * 3), "=>", a + b
        return a + b
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23022263_23024381_15_23
23022263_23024381_65_99
Title: PyQt: How to get QListWidget's listItem .data() on dropEvent 
----------------------------------------

def __init__(self, type, name, parent = None) :
INDENT
    super(ThumbListWidget, self).__init__(parent)
    self.setObjectName(name)
    self.setIconSize(QtCore.QSize(124, 124))
    self.setDragDropMode(QtGui.QAbstractItemView.DragDrop)
    self.setSelectionMode(QtGui.QAbstractItemView.ExtendedSelection)
    self.setAcceptDrops(True)
    self._dropping = False
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(QtGui.QMainWindow, self).__init__()
    self.listItems = {}
    myQWidget = QtGui.QWidget()
    myBoxLayout = QtGui.QVBoxLayout()
    myQWidget.setLayout(myBoxLayout)
    self.setCentralWidget(myQWidget)
    self.listWidgetA = ThumbListWidget(self, 'MainTree')
    self.listWidgetB = ThumbListWidget(self, 'SecondaryTree')
    self.listWidgetB.setDragDropMode(QtGui.QAbstractItemView.DropOnly)
    for i in range(3) :
    INDENT
        listItemA = QtGui.QListWidgetItem()
        listItemA.setText('A' + '%04d' % i)
        self.listWidgetA.addItem(listItemA)
        myClassInstA = MyClassA()
        listItemA.setData(QtCore.Qt.UserRole, myClassInstA)
        listItemB = QtGui.QListWidgetItem()
        listItemB.setText('B' + '%04d' % i)
        self.listWidgetB.addItem(listItemB)
        myClassInstB = MyClassB()
        listItemB.setData(QtCore.Qt.UserRole, myClassInstB)
    DEDENT
    myBoxLayout.addWidget(self.listWidgetA)
    myBoxLayout.addWidget(self.listWidgetB)
    self.connect(self.listWidgetB, QtCore.SIGNAL("dropped"), self.droppedOnB)
    self.listWidgetB.clicked.connect(self.itemClicked)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23033642_23048809_12_18
23033642_23048809_20_26
Title: Dynamically update python property setter method 
----------------------------------------

def locked(self) :
INDENT
    value = None
    if hasattr(self, 'meta') :
    INDENT
        self.meta.setdefault("locked", False)
        value = self.meta.get("locked")
    DEDENT
    return value
DEDENT
----------------------------------------

def locked(self, value) :
INDENT
    locked = None
    if hasattr(self, 'locked') :
    INDENT
        if value in [None, True, False] :
        INDENT
            locked = value
        DEDENT
        self.meta ['locked'] = locked
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23055222_23055324_12_18
23055222_23055709_10_15
Title: Check for open text file 
----------------------------------------

def main() :
INDENT
    myThread = MyThread('test.txt')
    myThread.start()
    while myThread.isAlive() :
    INDENT
        print "Still Alive"
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    myThread = MyThread('test.txt')
    myThread.start()
    while myThread.isAlive() :
    INDENT
        print "Still Alive"
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23071374_23074134_25_35
23071374_23074134_5_15
Title: How do I present 1 string per page?? (PyQt/Python) 
----------------------------------------

def __init__(self, question, parent = None) :
INDENT
    super(Question, self).__init__(parent)
    self.question = QtGui.QLabel(question, self)
    self.answer = QtGui.QLineEdit(self)
    self.submit = QtGui.QPushButton('Submit', self)
    form = QtGui.QFormLayout()
    form.addRow(self.question, self.answer)
    layout = QtGui.QVBoxLayout(self)
    layout.addLayout(form)
    layout.addWidget(self.submit)
DEDENT
----------------------------------------

def __init__(self, questions, parent = None) :
INDENT
    super(StartTest, self).__init__(parent)
    self.stack = QtGui.QStackedWidget(self)
    self.setCentralWidget(self.stack)
    for index, question in enumerate(questions) :
    INDENT
        page = Question(question, self)
        page.submit.clicked [()].connect(
            lambda index = index : self.handleSubmit(index))
        self.stack.addWidget(page)
    DEDENT
    self.answers = []
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23076781_23076892_11_34
23076781_23077082_1_11
Title: Python Problems 
----------------------------------------

def main() :
INDENT
    global date
    try :
    INDENT
        year = int(input('Please enter a year: '))
        if 1982 < year > 2048 :
        INDENT
            print ("Year is out of range")
        DEDENT
        else :
        INDENT
            date = easterCal(year)
        DEDENT
        if 22 < = date < = 31 :
        INDENT
            print ('Easter date for year {0} is March,{1}'.format(year, date))
        DEDENT
        elif 32 < = date < = 56 :
        INDENT
            print ('Easter date for year {0} is April,{1}'.format(year, date - 31))
        DEDENT
        else :
        INDENT
            print ('Incorrect.')
        DEDENT
    DEDENT
    except NameError :
    INDENT
        print ('Please enter date in numbers')
    DEDENT
    except :
    INDENT
        print ('There was a problem, try again.')
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    year = int(input('Please enter a year: '))
    if 1982 < year < 2048 :
    INDENT
        date = easterCal(year)
        if 22 < = date < = 31 :
        INDENT
            print ('Easter date for year {0} is March,{1}'.format(year, date))
        DEDENT
        elif 32 < = date < = 56 :
        INDENT
            print ('Easter date for year {0} is April,{1}'.format(year, date - 31))
        DEDENT
    DEDENT
    else :
    INDENT
        print ("Year is out of range")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23078073_23078112_1_18
23078073_23078183_1_10
Title: Finding time difference and print as string 
----------------------------------------

def time_difference(time1, time2) :
INDENT
    start_hour, start_min, start_sec = time1
    end_hour, end_min, end_sec = time2
    lst = []
    if len(time2) < = 0 and len(time1) < = 0 :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        a = time2 [0] - time1 [0]
        b = time2 [1] - time1 [1]
        c = time2 [2] - time1 [2]
        x = (a, b, c)
        lst = []
        for i in x :
        INDENT
            if i not in lst :
            INDENT
                lst.append(i)
            DEDENT
        DEDENT
        return ":".join("{:02d}".format(x) for x in lst)
    DEDENT
DEDENT
----------------------------------------

def time_difference(time1, time2) :
INDENT
    totalSecond1 = time1 [0] * 3600 + time1 [1] * 60 + time1 [2]
    totalSecond2 = time2 [0] * 3600 + time2 [1] * 60 + time2 [2]
    diffSeconds = totalSecond2 - totalSecond1
    hours = diffSeconds / 3600
    diffSeconds -= hours * 3600
    minutes = diffSeconds / 60
    diffSeconds -= minutes * 60
    print "%02d:%02d:%02d" % (hours, minutes, diffSeconds)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23078073_23078112_1_18
23078073_23078206_1_20
Title: Finding time difference and print as string 
----------------------------------------

def time_difference(time1, time2) :
INDENT
    start_hour, start_min, start_sec = time1
    end_hour, end_min, end_sec = time2
    lst = []
    if len(time2) < = 0 and len(time1) < = 0 :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        a = time2 [0] - time1 [0]
        b = time2 [1] - time1 [1]
        c = time2 [2] - time1 [2]
        x = (a, b, c)
        lst = []
        for i in x :
        INDENT
            if i not in lst :
            INDENT
                lst.append(i)
            DEDENT
        DEDENT
        return ":".join("{:02d}".format(x) for x in lst)
    DEDENT
DEDENT
----------------------------------------

def time_difference(time1, time2) :
INDENT
    start_hour, start_min, start_sec = time1
    end_hour, end_min, end_sec = time2
    lst = []
    if len(time2) < = 0 and len(time1) < = 0 :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        a = str(time2 [0] - time1 [0])
        b = str(time2 [1] - time1 [1])
        c = str(time2 [2] - time1 [2])
        if len(c) < 2 :
        INDENT
            c = "0" + c
        DEDENT
        if len(b) < 2 :
        INDENT
            b = "0" + b
        DEDENT
        x = (a, b, c)
        lst = ""
        for i in x :
        INDENT
            lst += i + ":"
        DEDENT
        return lst [: - 1]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23078073_23078183_1_10
23078073_23078206_1_20
Title: Finding time difference and print as string 
----------------------------------------

def time_difference(time1, time2) :
INDENT
    totalSecond1 = time1 [0] * 3600 + time1 [1] * 60 + time1 [2]
    totalSecond2 = time2 [0] * 3600 + time2 [1] * 60 + time2 [2]
    diffSeconds = totalSecond2 - totalSecond1
    hours = diffSeconds / 3600
    diffSeconds -= hours * 3600
    minutes = diffSeconds / 60
    diffSeconds -= minutes * 60
    print "%02d:%02d:%02d" % (hours, minutes, diffSeconds)
DEDENT
----------------------------------------

def time_difference(time1, time2) :
INDENT
    start_hour, start_min, start_sec = time1
    end_hour, end_min, end_sec = time2
    lst = []
    if len(time2) < = 0 and len(time1) < = 0 :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        a = str(time2 [0] - time1 [0])
        b = str(time2 [1] - time1 [1])
        c = str(time2 [2] - time1 [2])
        if len(c) < 2 :
        INDENT
            c = "0" + c
        DEDENT
        if len(b) < 2 :
        INDENT
            b = "0" + b
        DEDENT
        x = (a, b, c)
        lst = ""
        for i in x :
        INDENT
            lst += i + ":"
        DEDENT
        return lst [: - 1]
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23107951_23111183_10_25
23107951_23113464_5_25
Title: How to add a Status to this PySide based ui 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QMainWindow.__init__(self, parent)
    self.setMinimumSize(300, 300)
    self.status_bar = MyStatusBar(self)
    self.status_bar.setGeometry(QtCore.QRect(0, 0, 50, 50))
    self.status_bar.showMessage('Ready')
    self.quit_button = QtGui.QPushButton(self)
    self.quit_button.clicked.connect(self.close)
    self.quit_button.setGeometry(QtCore.QRect(100, 100, 100, 35))
    self.quit_button.setText("Close")

DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    self.central_widget = QtGui.QWidget(self)
    self.quit = QtGui.QPushButton("Quit", self)
    self.setGeometry(300, 300, 250, 150)
    layout = QtGui.QVBoxLayout(self.central_widget)
    layout.addWidget(self.quit)
    self.status = QtGui.QStatusBar(self)
    layout = QtGui.QVBoxLayout(self)
    layout.setContentsMargins(0, 0, 0, 0)
    layout.addWidget(self.widget)
    layout.addStretch()
    layout.addWidget(self.status)
    self.status.showMessage('Ready')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23116911_34619440_11_23
23116911_34620370_1_8
Title: All Permutations of a String in Python (Recursive) 
----------------------------------------

def perms(v) :
INDENT
    if not hasattr(perms, 'original') :
    INDENT
        perms.original = v
        perms.list = []
    DEDENT
    nv = v [1 :] + v [0]
    perms.list.append(nv)
    if perms.original == nv :
    INDENT
        l = perms.list
        del perms.original
        del perms.list
        return l
    DEDENT
    return perms(nv)
DEDENT
----------------------------------------

def perms(s) :
INDENT
    if (len(s) == 1) : return [s]
    result = []
    for i, v in enumerate(s) :
    INDENT
        result += [v + p for p in perms(s [: i] + s [i + 1 :])]
    DEDENT
    return result

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23146627_23146721_1_15
23146627_23147069_1_7
Title: Returning multiple values from a Python function 
----------------------------------------

def calculateTuitionIncrease(cost, increase, years) :
INDENT
    counter = 0

    costsPerYear = []
    while counter < years :
    INDENT
        increasedCost = (cost) + (cost * increase)
        costPerYear.append(increasedCost)
        counter = counter + 1
    DEDENT
    return costsPerYear
DEDENT
----------------------------------------

def calculateTuitionIncrease(cost, increase, years) :
INDENT
    counter = 0
    while counter < = years :
    INDENT
        counter += 1
        yield (cost) + (cost * increase)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23147701_23148122_1_14
23147701_23149248_1_11
Title: Reading data from file using Python cPickle 
----------------------------------------

def read_file() :
INDENT
    if os.path.exists('InputFile.bak') :
    INDENT
        with open('InputFile.bak', 'rb') as fname :
        INDENT
            while True :
            INDENT
                try :
                INDENT
                    item_name = cPickle.load(fname)
                    for k, v in item_name.iteritems() :
                    INDENT
                        print v [0], "\t", v [1], "\t", k
                    DEDENT
                DEDENT
                except EOFError :
                INDENT
                    break
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        item_name = {}
    DEDENT
DEDENT
----------------------------------------

def read_file() :
INDENT
    fname = 'InputFile.bak'
    if os.path.exists(fname) :
    INDENT
        fsize = os.path.getsize(fname)
        with open(fname, 'rb') as fh :
        INDENT
            while fh.tell() < fsize :
            INDENT
                item = cPickle.load(fh)
                for k, v in item.iteritems() :
                INDENT
                    print v [0], "\t", v [1], "\t", k
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        item_name = {}
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23161341_23161601_14_27
23161341_23161601_4_12
Title: Drawing on a Panel within a Sizer 
----------------------------------------

def __init__(self, parent, id, text, angle, font = None, * args, ** kwargs) :
INDENT
    super(RotatedText, self).__init__(parent, id, * args, ** kwargs)
    self.text = text
    self.font = font
    self.angle = angle
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.Bind(wx.EVT_SIZE, self.OnSize)

    dc = wx.MemoryDC()
    self.text_width, self.text_height = dc.GetTextExtent(self.text)
    self.SetMinSize((self.text_height, self.text_width))
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Win, self).__init__(None, wx.ID_ANY)
    self.p = wx.Panel(self, wx.ID_ANY)
    self.p.SetSizer(wx.BoxSizer())
    self.rt = RotatedText(self.p, wx.ID_ANY, 'hello', 90, size = (60, 60))
    self.p.GetSizer().Add(self.rt)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23170754_23170848_3_14
23170754_23170935_1_20
Title: "Python closure local variable scope error" 
----------------------------------------

def get_audio_callback(pt_ref) :
INDENT
    def callback(in_data, frame_count, time_info, status) :
    INDENT
        pt = pt_ref [0]
        for i in range(frame_count) :
        INDENT
            ind = (i + pt) % n
        DEDENT
        return (a, b)
    DEDENT
    return callback
DEDENT
----------------------------------------

def get_audio_callback(pt) :
INDENT
    def callback(in_data, frame_count, time_info, status) :
    INDENT
        wave = np.ndarray((frame_count, 2))
        for i in range(frame_count) :
        INDENT
            ind = (i + callback.pt) % n
            wave [i, 0] = float(x [ind]) * 2
            wave [i, 1] = float(y [ind]) * 2
        DEDENT
        callback.pt = callback.pt + frame_count
        return (encode(wave), pyaudio.paContinue)
    DEDENT
    callback.pt = pt
    return callback
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23170754_23170848_5_13
23170754_23170935_3_17
Title: "Python closure local variable scope error" 
----------------------------------------

def callback(in_data, frame_count, time_info, status) :
INDENT
    pt = pt_ref [0]
    for i in range(frame_count) :
    INDENT
        ind = (i + pt) % n
    DEDENT
    return (a, b)
DEDENT
----------------------------------------

def callback(in_data, frame_count, time_info, status) :
INDENT
    wave = np.ndarray((frame_count, 2))
    for i in range(frame_count) :
    INDENT
        ind = (i + callback.pt) % n
        wave [i, 0] = float(x [ind]) * 2
        wave [i, 1] = float(y [ind]) * 2
    DEDENT
    callback.pt = callback.pt + frame_count
    return (encode(wave), pyaudio.paContinue)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23176217_23176249_1_15
23176217_23176316_1_9
Title: Trying to display initials in Python 
----------------------------------------

def main() :
INDENT
    name = input('Type your name and press ENTER. ')
    name_list = name.split()
    print (name_list)
    first = name_list [0] [0]
    second = name_list [1] [0]
    last = name_list [2] [0]
    print (first.upper(), '.', second.upper(), '.', last.upper())
DEDENT
----------------------------------------

def main() :
INDENT
    name = input('Type your name and press ENTER. ')
    name_list = name.split()
    for part in name_list :
    INDENT
        print(part [0].upper() + ". ", end = "")
    DEDENT
    print ()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23184238_23184533_1_17
23184238_23185624_3_26
Title: Python: is_correct_sequence (no doubles) 
----------------------------------------

def is_correct_sequence(seq) :
INDENT
    for i in range(len(seq)) :
    INDENT
        if seq [i] is not None and (seq [i] < = 1 and seq [i] > = len(seq)) :
        INDENT
            return False
        DEDENT
        elif seq [i] is not None and type(seq [i]) ! = int :
        INDENT
            return False
        DEDENT
        else :
        INDENT
            for i in range(len(seq) - 1) :
            INDENT
                for j in range(i + 1, len(seq)) :
                INDENT
                    if seq [i] == seq [j] and seq [i] is not None and seq [j] is not None :
                    INDENT
                        return False
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def is_correct_sequence(seq) :
INDENT
    len_seq = len(seq)
    counts = Counter(seq)
    for value, count in counts.items() :
    INDENT
        if (value is not None and (
                (count > 1 or not isinstance(value, int)) or
                (value < 1 or value > len_seq))) :
        INDENT
            return False
        DEDENT
    DEDENT
    return True

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23186388_23186436_1_19
23186388_23186477_1_12
Title: returning to a select point in python 3 
----------------------------------------

def name_email(name) :
INDENT
    correct_email = False
    email = str(input('what is your email: '))
    print ()
    try :
    INDENT
        while '@' not in email :
        INDENT
            print ('email invalid, please try again \n')
            email = str(input('what is your email: '))

        DEDENT
    DEDENT
    except :
    INDENT
        raise ValueError
    DEDENT
    print ('name and email accepted \n')
    print ('name: ', name)
    print ('email: ', email)
    print ()
DEDENT
----------------------------------------

def name_email(name) :
INDENT
    correct_email = False
    while correct_email == False :
    INDENT
        email = input('what is your email: ')
        if '@' in email :
        INDENT
            print ('name and email accepted \n')
            print ('name: ', name)
            print ('email: ', email)
            correct_email = True
        DEDENT
        else :
        INDENT
            print ('email invalid, please try again \n')
        DEDENT
    DEDENT
    return email
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23208491_23208551_1_17
23208491_23208574_1_29
Title: Program ignoring if elif statements 
----------------------------------------

def main() :
INDENT
    print ("Opening Account List now...\n")
    with open('Charge Accounts.txt') as inf :
    INDENT
        numbers = [int(line) for line in inf]
    DEDENT
    print (numbers, '\n')
    while True :
    INDENT
        accnumber = int(input("Please enter an account number (or -1 to exit): "))
        if accnumber == - 1 :
        INDENT
            print ("Goodbye!")
            break
        DEDENT
        elif accnumber not in numbers :
        INDENT
            print ("The account number you have typed in is invalid.")
        DEDENT
        else :
        INDENT
            print ("The account number you have selected is valid.")
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    print ("Opening Account List now...\n")
    infile = open('CHarge Accounts.txt', 'r')
    numbers = infile.readlines()
    infile.close()
    index = 0
    while index < len(numbers) :
    INDENT
        numbers [index] = int(numbers [index])
        index += 1
    DEDENT
    print (numbers, '\n')
    x = 0
    while x == 0 :
    INDENT
        accnumber = int(input("Please type in the account number you'd like to change, or type in -1 to exit."))
        if (accnumber not in numbers) and (accnumber ! = - 1) :
        INDENT
            print ("The account number you have typed in is invalid.")
        DEDENT
        elif (accnumber in numbers) and (accnumber ! = - 1) :
        INDENT
            print ("The account number you have selected is valid.")
        DEDENT
        elif accnumber == - 1 :
        INDENT
            print ("Goodbye!")
            x = 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2322642_2322711_12_20
2322642_2322812_11_16
Title: Index and Slice a Generator in Python 
----------------------------------------

def __getitem__(self, index) :
INDENT
    try :
    INDENT
        max_idx = index.stop
    DEDENT
    except AttributeError :
    INDENT
        max_idx = index
    DEDENT
    n = max_idx - len(self.already_computed) + 1
    if n > 0 :
    INDENT
        self.already_computed.extend(itertools.islice(self.it, n))
    DEDENT
    return self.already_computed [index]
DEDENT
----------------------------------------

def __getitem__(self, index) :
INDENT
    self.it, cpy = itertools.tee(self.it)
    if type(index) is slice :
    INDENT
        return list(itertools.islice(cpy, index.start, index.stop, index.step))
    DEDENT
    else :
    INDENT
        return next(itertools.islice(cpy, index, index + 1))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2322642_2322812_11_16
2322642_2322909_8_15
Title: Index and Slice a Generator in Python 
----------------------------------------

def __getitem__(self, index) :
INDENT
    self.it, cpy = itertools.tee(self.it)
    if type(index) is slice :
    INDENT
        return list(itertools.islice(cpy, index.start, index.stop, index.step))
    DEDENT
    else :
    INDENT
        return next(itertools.islice(cpy, index, index + 1))
    DEDENT
DEDENT
----------------------------------------

def __getitem__(self, index) :
INDENT
    try :
    INDENT
        max_idx = index.stop
    DEDENT
    except AttributeError :
    INDENT
        max_idx = index
    DEDENT
    while max_idx > = len(self) :
    INDENT
        self.append(next(self.it))
    DEDENT
    return list.__getitem__(self, index)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23230947_23231250_1_16
23230947_23231459_3_26
Title: Python filter nested dict given list of key names 
----------------------------------------

def fltr(d, vals) :
INDENT
    if isinstance(d, dict) :
    INDENT
        vals_to_del = []
        for k in d :
        INDENT
            if k in vals :
            INDENT
                continue
            DEDENT
            if not isinstance(d [k], list) and not isinstance(d [k], dict) :
            INDENT
                if k not in vals :
                INDENT
                    vals_to_del.append(k)
                DEDENT
            DEDENT
            else :
            INDENT
                fltr(d [k], vals)
            DEDENT
        DEDENT
        for k in vals_to_del :
        INDENT
            del d [k]
        DEDENT
    DEDENT
    elif isinstance(d, list) :
    INDENT
        for i in d :
        INDENT
            fltr(i, vals)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def fltr(node, vals) :
INDENT
    if isinstance(node, dict) :
    INDENT
        retVal = {}
        for key in node :
        INDENT
            if key in vals :
            INDENT
                retVal [key] = copy.deepcopy(node [key])
            DEDENT
            elif isinstance(node [key], list) or isinstance(node [key], dict) :
            INDENT
                child = fltr(node [key], vals)
                if child :
                INDENT
                    retVal [key] = child
                DEDENT
            DEDENT
        DEDENT
        if retVal :
        INDENT
            return retVal
        DEDENT
        else :
        INDENT
            return None
        DEDENT
    DEDENT
    elif isinstance(node, list) :
    INDENT
        retVal = []
        for entry in node :
        INDENT
            child = fltr(entry, vals)
            if child :
            INDENT
                retVal.append(child)
            DEDENT
        DEDENT
        if retVal :
        INDENT
            return retVal
        DEDENT
        else :
        INDENT
            return None
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23258545_23269105_1_10
23258545_25101051_2_13
Title: "Project Euler #2 in ""Python""" 
----------------------------------------

def fib(number) :
INDENT
    series = [1, 1]
    lastnum = (series [len(series) - 1] + series [len(series) - 2])
    _sum = 0
    while lastnum < number :
    INDENT
        if lastnum % 2 == 0 :
        INDENT
            _sum += lastnum
        DEDENT
        series.append(lastnum)
        lastnum = (series [len(series) - 1] + series [len(series) - 2])
    DEDENT
    return series, _sum
DEDENT
----------------------------------------

def fib(x) :
INDENT
    if x in dict :
    INDENT
        return dict [x]
    DEDENT
    if x == 1 :
    INDENT
        f = 1
    DEDENT
    elif x == 2 :
    INDENT
        f = 2
    DEDENT
    else :
    INDENT
        f = fib(x - 1) + fib(x - 2)
    DEDENT
    dict [x] = f
    return f
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23259116_23259156_1_12
23259116_23259291_1_18
Title: Python - If more inputs return error (How to do) 
----------------------------------------

def calculator(input) :
INDENT
    if len(input) > 2 :
    INDENT
        print "Please only one input"
        break
    DEDENT
    else :
    INDENT
        if input [0] == "sqrt" :
        INDENT
            if input [1] < 0 :
            INDENT
                return "No square root for negative numbers"
            DEDENT
            else :
            INDENT
                ans = (input [1]) ** (0.5)
                return ans
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def calculator(* args) :
INDENT
    input = args [0]
    num1 = args [1]
    numberOfArguments = len(args)
    print input
    print num1
    print len(args)
    if numberOfArguments > 2 :
    INDENT
        print "Please only one input"
    DEDENT
    else :
    INDENT
        if input == "sqrt" :
        INDENT
            print "we will perform sqrt now"
            if num1 < 0 :
            INDENT
                return "No square root for negative numbers"
            DEDENT
            else :
            INDENT
                ans = (num1) ** (0.5)
                print "square root result is ", ans
                return ans
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23269230_23362995_1_17
23269230_23388241_19_30
Title: Python parallel execution - how to debug efficiently? 
----------------------------------------

def func(args) :
INDENT
    try :
    INDENT

        time.sleep(random.randint(1, 4))
        ret = args ["Np"] - args ["index"]
        if args ["index"] == args ["problemIndex"] :
        INDENT
            ret = 1 / (args ["index"] - args ["problemIndex"])
        DEDENT
        if args ["runParallel"] :
        INDENT

            args ["q"].put((args ["index"], ret))
        DEDENT
        else :
        INDENT
            return ret
        DEDENT
    DEDENT
    except Exception as e :
    INDENT
        logging.exception(e)
        raise
    DEDENT
DEDENT
----------------------------------------

def func(args) :
INDENT
    time.sleep(random.randint(1, 4))
    ret = args ["Np"] - args ["index"]

    if args ["index"] == args ["problemIndex"] :
    INDENT
        ret = 1 / (args ["index"] - args ["problemIndex"])

    DEDENT
    return (args ["index"], ret)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23269230_23363453_5_21
23269230_23388241_31_48
Title: Python parallel execution - how to debug efficiently? 
----------------------------------------

def mpFunctionReportError(kwargs) :
INDENT
    queue = kwargs.pop('queue')
    f = kwargs.pop('f')
    rslt = None
    try :
    INDENT
        rslt = f(** kwargs)
        queue.put(rslt)
    DEDENT
    except Exception, e :
    INDENT
        queue.put([e, traceback.format_exc(e)])
    DEDENT
    return
DEDENT
----------------------------------------

def mpFunctionReportError(args) :
INDENT
    rslt = None
    q = args ["q"]
    rslt = {"index" : args ["index"],
        "args" : None,
        "error" : None,
        "traceback" : None}
    try :
    INDENT
        rslt ["result"] = func(args)
        q.put(rslt)
    DEDENT
    except Exception as e :
    INDENT
        rslt ["result"] = None
        rslt ["error"] = e
        rslt ["args"] = str(args)
        rslt ["traceback"] = traceback.format_exc(e)
        q.put(rslt)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2328495_2328859_11_24
2328495_2337084_2_11
Title: Python code optimization (20x slower than C) 
----------------------------------------

def quickCheck(n) :
INDENT
    if n in quickCache : return quickCache [n]
    partial_c = (sqrt(1 + 24 * (n))) / - 6
    c = 1 / 6 + partial_c
    if int(c.real) == c.real :
    INDENT
        quickCache [n] = True
        return True
    DEDENT
    c = c - 2 * partial_c
    if int(c.real) == c.real :
    INDENT
        quickCache [n] = True
        return True
    DEDENT
    quickCache [n] = False
    return False
DEDENT
----------------------------------------

def quickCheck(n) :
INDENT
    partial_c = sqrt(1 + 24 * n) / - 6
    c = 1 / 6 + partial_c
    if abs(int(c) - c) < EPS :
    INDENT
        return True
    DEDENT
    c = 1 / 6 - partial_c
    if abs(int(c) - c) < EPS :
    INDENT
        return True
    DEDENT
    return False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2328495_2328859_1_31
2328495_2337084_15_24
Title: Python code optimization (20x slower than C) 
----------------------------------------

def main() :
INDENT
    maxNumber = 5000
    diff = 1000
    p = {}
    quickCache = {}
    for i in range(maxNumber) :
    INDENT
        p [i] = i * (3 * i - 1) / 2
    DEDENT
    def quickCheck(n) :
    INDENT
        if n in quickCache : return quickCache [n]
        partial_c = (sqrt(1 + 24 * (n))) / - 6
        c = 1 / 6 + partial_c
        if int(c.real) == c.real :
        INDENT
            quickCache [n] = True
            return True
        DEDENT
        c = c - 2 * partial_c
        if int(c.real) == c.real :
        INDENT
            quickCache [n] = True
            return True
        DEDENT
        quickCache [n] = False
        return False
    DEDENT
    for i in range(1, maxNumber) :
    INDENT
        mi = p [i]
        for g in range(i + 1, maxNumber) :
        INDENT
            ma = p [g]
            if ma - mi < diff and quickCheck(ma - mi) and quickCheck(ma + mi) :
            INDENT
                print ('New couple ', ma, mi)
                diff = ma - mi
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def main(maxNumber) :
INDENT
    diff = 1000
    for i in range(1, maxNumber) :
    INDENT
        for g in range(i + 1, maxNumber) :
        INDENT
            if p(g) - p(i) > = diff :
            INDENT
                break
            DEDENT
            if quickCheck(p(g) - p(i)) and quickCheck(p(g) + p(i)) :
            INDENT
                print ('New couple ', p(g), p(i), p(g) - p(i))
                diff = p(g) - p(i)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23285558_23287543_6_14
23285558_29382449_3_10
Title: "datetime.date(2014 4 25) is not JSON serializable in Django" 
----------------------------------------

def default(self, obj) :
INDENT
    if hasattr(obj, 'isoformat') :
    INDENT
        return obj.isoformat()
    DEDENT
    elif isinstance(obj, decimal.Decimal) :
    INDENT
        return float(obj)
    DEDENT
    elif isinstance(obj, ModelState) :
    INDENT
        return None
    DEDENT
    else :
    INDENT
        return json.JSONEncoder.default(self, obj)
    DEDENT
DEDENT
----------------------------------------

def default(self, obj) :
INDENT
    if isinstance(obj, datetime) :
    INDENT
        return obj.strftime('%Y-%m-%dT%H:%M:%SZ')
    DEDENT
    elif isinstance(obj, date) :
    INDENT
        return obj.strftime('%Y-%m-%d')
    DEDENT
    return json.JSONEncoder.default(self, obj)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23303827_23303928_1_15
23303827_23304079_3_18
Title: How to check if a user input is a float 
----------------------------------------

def gold_room() :
INDENT
    while True :
    INDENT
        print "This room is full of gold. What percent of it do you take?"
        try :
        INDENT
            how_much = float(raw_input("><![CDATA[ "))
            if how_much < = 50 :
            INDENT
                print "Nice, you're not greedy, you win!"
                exit(0)
            DEDENT
            else :
            INDENT
                dead("You greedy bastard!")
            DEDENT
        DEDENT
        except ValueError :
        INDENT
            print "Man, learn to type a number."
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def gold_room() :
INDENT
    print ("This room is full of gold. What percent of it do you take?")
    try :
    INDENT
        how_much = float(raw_input("><![CDATA[ "))
    DEDENT
    except ValueError :
    INDENT
        print ("Man, learn to type a number.")
        gold_room()
        return
    DEDENT
    if how_much < = GREEDY_LIMIT :
    INDENT
        print "Nice, you're not greedy, you win!"
        exit(0)
    DEDENT
    else :
    INDENT
        dead("You greedy bastard!")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23304290_23328507_2_12
23304290_23370367_3_11
Title: Is it possible to have different level names for different handlers in Python Logging 
----------------------------------------

def format(self, record) :
INDENT
    if record.levelname == 'ERROR' :
    INDENT
        record.levelname = 'MAJOR'
    DEDENT
    elif record.levelname == 'WARNING' :
    INDENT
        record.levelname = 'MINOR'
    DEDENT
    result = super(MyFormatter, self).format(record)
    if record.levelname == 'MAJOR' :
    INDENT
        record.levelname = 'ERROR'
    DEDENT
    elif record.levelname == 'MINOR' :
    INDENT
        record.levelname = 'WARNING'
    DEDENT
    return result
DEDENT
----------------------------------------

def format(self, record) :
INDENT
    orig_levelname = record.levelname
    if record.levelname == 'ERROR' :
    INDENT
        record.levelname = 'MAJOR'
    DEDENT
    elif record.levelname == 'WARNING' :
    INDENT
        record.levelname = 'MINOR'
    DEDENT
    result = Formatter.format(self, record)
    record.levelname = orig_levelname
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23318715_23318824_1_18
23318715_23319190_1_15
Title: Python Selecting menu choice 
----------------------------------------

def menu() :
INDENT
    mybool == True
    userInput = input("Instructions\nCatering\nPackages\n>>> ")
    b = userInput.lower() [0]
    if b == 'a' :
    INDENT
        mybool = True
    DEDENT
    elif b == 'i' :
    INDENT
        Instructions()
    DEDENT
    elif b == 'c' :
    INDENT
        Catering()
    DEDENT
    elif b == 'p' :
    INDENT
        if mybool == True :
        INDENT
            Packages()
        DEDENT
        else :
        INDENT
            input('Here is where we display a prompt! ')
        DEDENT
    DEDENT
    else :
    INDENT
        print ("Error")
    DEDENT
DEDENT
----------------------------------------

def menu() :
INDENT
    while True :
    INDENT
        u_in = raw_input("Input Here:: ")
        u = u_in.lower()
        if u_in == "" :
        INDENT
            continue
        DEDENT
        elif u == "i" :
        INDENT
            Instructions()
        DEDENT
        elif u == "c" :
        INDENT
            Catering()
        DEDENT
        elif u == "p" :
        INDENT
            Packages()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23374354_23374511_6_37
23374354_23374538_6_29
Title: Python: Tkinter active and deactive entry space with checkutton 
----------------------------------------

def __init__(self) :
INDENT
    Frame.__init__(self)
    self.master.title("input")
    self.master.minsize(150, 50)
    self.grid(sticky = E + W + N + S)
    top = self.winfo_toplevel()
    top.rowconfigure(0, weight = 1)
    top.columnconfigure(0, weight = 1)
    for i in range(1) : self.rowconfigure(i, weight = 1)
    self.columnconfigure(1, weight = 1)
    self.label0 = Label(self, text = "Data:    ")
    self.label0.grid(row = 0, column = 0, padx = 2)
    self.entry11 = Entry(self)
    self.entry11.grid(row = 0, column = 1, pady = 2, padx = 2, sticky = E + W + N + S)
    self.CheckVar_theta = IntVar()
    self.check = Checkbutton(self, text = "", variable = self.CheckVar_theta, onvalue = 0, offvalue = 1)
    self.check.grid(row = 0, column = 3, pady = 0, padx = 0, sticky = E + W + N + S)
    self.update()
    def update(self) :
    INDENT
        if self.CheckVar_theta.get() == 1 :
        INDENT
            self.entry11.config(state = NORMAL)
        DEDENT
        else :
        INDENT
            self.entry11.config(state = DISABLED)
        DEDENT
        self.master.after(100, self.update)
    DEDENT
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    Frame.__init__(self)
    self.master.title("input")
    self.master.minsize(150, 50)
    self.grid(sticky = E + W + N + S)
    top = self.winfo_toplevel()
    top.rowconfigure(0, weight = 1)
    top.columnconfigure(0, weight = 1)
    for i in range(1) : self.rowconfigure(i, weight = 1)
    self.columnconfigure(1, weight = 1)
    self.label0 = Label(self, text = "Data:    ")
    self.label0.grid(row = 0, column = 0, padx = 2)
    self.entry11 = Entry(self)
    self.entry11.grid(row = 0, column = 1, pady = 2, padx = 2, sticky = E + W + N + S)
    self.CheckVar_theta = IntVar()
    self.check = Checkbutton(self, text = "", variable = self.CheckVar_theta,
        onvalue = 0, offvalue = 1, command = self.switch)
    self.check.grid(row = 0, column = 3, pady = 0, padx = 0, sticky = E + W + N + S)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23383665_23391192_18_30
23383665_23391192_42_50
Title: Concept of different systems of measurement in Django project 
----------------------------------------

def __init__(self, default_unit = None, attrs = None) :
INDENT
    self.default_unit = default_unit
    _widgets = [
        widgets.NumberInput(attrs = attrs),
        widgets.Select(attrs = attrs, choices = unit_types),
        ]
    super(NumberUnitWidget, self).__init__(_widgets, attrs)

DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    _widget = NumberUnitWidget(default_unit = kwargs ['initial'] [0])
    fields = [
        DecimalField(label = "Number!"),
        ChoiceField(choices = unit_types)]
    super(NumberUnitField, self).__init__(fields = fields, widget = _widget, * args, ** kwargs)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23389450_23389644_22_48
23389450_23405796_40_50
Title: Hangman game code 
----------------------------------------

def hangman(word, numLetters) :
INDENT
    print 'Welcome to the game, Hangman!'
    print 'I am thinking of a word that is', numLetters, 'letters long'
    remainingGuesses = 8
    letters = 'abcdefghijklmnopqrstuvwxyz'
    try :
    INDENT

        filled_word.emptyWord
    DEDENT
    except :
    INDENT
        filled_word.emptyWord = ['_'] * numLetters
    DEDENT
    while '_' in filled_word.emptyWord and remainingGuesses > 0 :
    INDENT
        print 'You have', remainingGuesses, 'guesses left'
        print 'Available letters:', letters
        guess = raw_input("Please guess a letter:")
        if guess in letters :
        INDENT
            filled_word(word, guess)
            letters = unused_letters(letters, guess)
        DEDENT
        else :
        INDENT
            print 'You guessed: %s, which is not in Available letters: %s' % (guess, ''.join(letters))
            print 'Current word: %s' % ''.join(filled_word.emptyWord)
        DEDENT
        remainingGuesses -= 1
    DEDENT
DEDENT
----------------------------------------

def hangman() :
INDENT
    hangman_word = choose_word()
    print 'Welcome to the game, Hangman!'
    print 'I am thinking of a word that is', hangman_word ['length'], 'letters long.'
    hidden_word = ''.join(['_'] * hangman_word ['length'])
    no_guesses = 8
    letters = 'abcdefghijklmnopqrstuvwxyz'
    guess_letter(hangman_word ['word'], hidden_word, no_guesses, letters)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23389588_23390124_117_139
23389588_23390124_36_66
Title: python code doesn't not execute nor does give any error 
----------------------------------------

def enter(self) :
INDENT
    print ("You rush through the whole ship as you try to reach the escape pod")
    print ("before the ship explodes. You get to the chamber with the escape pods")
    print ("and now have to get into one to get out of this ship. There are 5 pods")
    print ("in all and all are marked from 1 to 5. Which escape pod will you choose?")
    right_pod = randint(1, 5)
    guess = input("[pod#]>")
    if int(guess) ! = right_pod :
    INDENT
        print ("You jump into the %s pod and hit the eject button" % guess)
        print ("The pod escape into the void of space, then")
        print ("implodes as the hull ruptures crushing your")
        print ("whole body")
        return 'death'
    DEDENT
    elif int(guess) == right_pod :
    INDENT
        print ("You jump into the %s pod and hit the eject button" % guess)
        print ("The pod easily slides out into the space heading to the planet below")
        print ("As it flies to the planet you see the ship exploding")
        print ("You won!")
        return "finished"

    DEDENT
DEDENT
----------------------------------------

def enter(self) :
INDENT
    print ("The Gothoms of Planet Parcel # 25 have invade your ship and ")
    print ("killed all your crew members. You are the last one to survive.")
    print ("Your last mission is to get the neutron destruction bomb from ")
    print ("the Laser Weapons Armory and use it to destroy the bridge and get")
    print ("to the escape pod from where you can escape after putting in the")
    print ("correct pod.")
    print ("\n")
    print ("Meanwhile you are in the central corridor where a Gothom stands")
    print ("in front of you. You need to kill him if you want to proceed to")
    print ("the Laser Weapons Armory. What will you do now - 'shoot', 'dodge' or       'tell him a joke'")
    action = input("><![CDATA[")
    if action == "shoot" :
    INDENT
        print ("You try to shoot him but he reacts faster than your expectations")
        print ("and kills you")
        return 'death'
    DEDENT
    elif action == "dodge" :
    INDENT
        print ("You thought that you will escape his vision. Poor try lad!")
        print ("He kills you")
        return 'death'
    DEDENT
    elif action == "tell him a joke" :
    INDENT
        print ("You seem to have told him a pretty funny joke and while he laughs")
        print ("you stab him and the Gothom is killed. Nice start!")
        return 'laser_weapon_armory'
    DEDENT
    else :
    INDENT
        print ("DOES NOT COMPUTE!")
        return 'central_corridor'

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23389588_23390124_117_139
23389588_23390124_68_92
Title: python code doesn't not execute nor does give any error 
----------------------------------------

def enter(self) :
INDENT
    print ("You rush through the whole ship as you try to reach the escape pod")
    print ("before the ship explodes. You get to the chamber with the escape pods")
    print ("and now have to get into one to get out of this ship. There are 5 pods")
    print ("in all and all are marked from 1 to 5. Which escape pod will you choose?")
    right_pod = randint(1, 5)
    guess = input("[pod#]>")
    if int(guess) ! = right_pod :
    INDENT
        print ("You jump into the %s pod and hit the eject button" % guess)
        print ("The pod escape into the void of space, then")
        print ("implodes as the hull ruptures crushing your")
        print ("whole body")
        return 'death'
    DEDENT
    elif int(guess) == right_pod :
    INDENT
        print ("You jump into the %s pod and hit the eject button" % guess)
        print ("The pod easily slides out into the space heading to the planet below")
        print ("As it flies to the planet you see the ship exploding")
        print ("You won!")
        return "finished"

    DEDENT
DEDENT
----------------------------------------

def enter(self) :
INDENT
    print ("You enter into the Laser Weapon Armory. There is dead silence")
    print ("and no signs of  any Gothom. You find the bomb placed in a box")
    print ("which is secured by a key. Guess the key and gain access to neutron ")
    print ("destruction bomb and move ahead. You will get 3 chances. ")
    print ("-----------")
    print ("Guess the 3-digit key")
    key = "%d%d%d" % (randint(0, 9), randint(0, 9), randint(0, 9))
    guess_count = 0
    guess = input("[keypad]>")
    while guess_count < 3 and guess ! = key :
    INDENT
        print ("That was a wrong guess")
        guess_count += 1
        print ("You have %d chances left" % (3 - guess_count))
    DEDENT
    if guess_count == key :
    INDENT
        print ("You have entered the right key and gained access to he neutron")
        print ("destruction bomb. You grab the bomb and run as fast as you can")
        print (" to the bridge where you must place it in the right place")
        return 'the_bridge'
    DEDENT
    else :
    INDENT
        print ("The time is over and the Gothoms bomb up the entire ship and")
        print ("you die")
        return 'death'

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23389588_23390124_117_139
23389588_23390124_94_115
Title: python code doesn't not execute nor does give any error 
----------------------------------------

def enter(self) :
INDENT
    print ("You rush through the whole ship as you try to reach the escape pod")
    print ("before the ship explodes. You get to the chamber with the escape pods")
    print ("and now have to get into one to get out of this ship. There are 5 pods")
    print ("in all and all are marked from 1 to 5. Which escape pod will you choose?")
    right_pod = randint(1, 5)
    guess = input("[pod#]>")
    if int(guess) ! = right_pod :
    INDENT
        print ("You jump into the %s pod and hit the eject button" % guess)
        print ("The pod escape into the void of space, then")
        print ("implodes as the hull ruptures crushing your")
        print ("whole body")
        return 'death'
    DEDENT
    elif int(guess) == right_pod :
    INDENT
        print ("You jump into the %s pod and hit the eject button" % guess)
        print ("The pod easily slides out into the space heading to the planet below")
        print ("As it flies to the planet you see the ship exploding")
        print ("You won!")
        return "finished"

    DEDENT
DEDENT
----------------------------------------

def enter(self) :
INDENT
    print ("You burst onto the bridge with the neutron destruction bomb")
    print ("and surprise 5 Gothoms who are trying to destroy the ship ")
    print ("They haven't taken their weapons out as they see the bomb")
    print ("under your arm and are afraid by it as they want to see the")
    print ("bomb set off. What will you do now - throw the bomb or slowly place the bomb")
    action = input("><![CDATA[")
    if action == "throw the bomb" :
    INDENT
        print ("In a panic you throw the bomb at the Gothoms and as you try to")
        print ("escape into the door the Gothoms shot at your back and you are killed.")
        print ("As you die you see a Gothom trying to disarm the bomb and you die")
        print ("knowing that they will blow up the ship eventually.")
        return 'death'
    DEDENT
    elif action == "slowly place the bomb" :
    INDENT
        print ("You inch backward to the door, open it, and then carefully")
        print ("place the bomb on the floor pointing your blaster at it.")
        print ("Then you immediately shut the door and lock the door so")
        print ("that the Gothoms can't get out. Now as the bomb is placed")
        print ("you run to the escape pod to get off this tin can.")
        return 'escape_pod'

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23389588_23390124_36_66
23389588_23390124_68_92
Title: python code doesn't not execute nor does give any error 
----------------------------------------

def enter(self) :
INDENT
    print ("The Gothoms of Planet Parcel # 25 have invade your ship and ")
    print ("killed all your crew members. You are the last one to survive.")
    print ("Your last mission is to get the neutron destruction bomb from ")
    print ("the Laser Weapons Armory and use it to destroy the bridge and get")
    print ("to the escape pod from where you can escape after putting in the")
    print ("correct pod.")
    print ("\n")
    print ("Meanwhile you are in the central corridor where a Gothom stands")
    print ("in front of you. You need to kill him if you want to proceed to")
    print ("the Laser Weapons Armory. What will you do now - 'shoot', 'dodge' or       'tell him a joke'")
    action = input("><![CDATA[")
    if action == "shoot" :
    INDENT
        print ("You try to shoot him but he reacts faster than your expectations")
        print ("and kills you")
        return 'death'
    DEDENT
    elif action == "dodge" :
    INDENT
        print ("You thought that you will escape his vision. Poor try lad!")
        print ("He kills you")
        return 'death'
    DEDENT
    elif action == "tell him a joke" :
    INDENT
        print ("You seem to have told him a pretty funny joke and while he laughs")
        print ("you stab him and the Gothom is killed. Nice start!")
        return 'laser_weapon_armory'
    DEDENT
    else :
    INDENT
        print ("DOES NOT COMPUTE!")
        return 'central_corridor'

    DEDENT
DEDENT
----------------------------------------

def enter(self) :
INDENT
    print ("You enter into the Laser Weapon Armory. There is dead silence")
    print ("and no signs of  any Gothom. You find the bomb placed in a box")
    print ("which is secured by a key. Guess the key and gain access to neutron ")
    print ("destruction bomb and move ahead. You will get 3 chances. ")
    print ("-----------")
    print ("Guess the 3-digit key")
    key = "%d%d%d" % (randint(0, 9), randint(0, 9), randint(0, 9))
    guess_count = 0
    guess = input("[keypad]>")
    while guess_count < 3 and guess ! = key :
    INDENT
        print ("That was a wrong guess")
        guess_count += 1
        print ("You have %d chances left" % (3 - guess_count))
    DEDENT
    if guess_count == key :
    INDENT
        print ("You have entered the right key and gained access to he neutron")
        print ("destruction bomb. You grab the bomb and run as fast as you can")
        print (" to the bridge where you must place it in the right place")
        return 'the_bridge'
    DEDENT
    else :
    INDENT
        print ("The time is over and the Gothoms bomb up the entire ship and")
        print ("you die")
        return 'death'

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23389588_23390124_36_66
23389588_23390124_94_115
Title: python code doesn't not execute nor does give any error 
----------------------------------------

def enter(self) :
INDENT
    print ("The Gothoms of Planet Parcel # 25 have invade your ship and ")
    print ("killed all your crew members. You are the last one to survive.")
    print ("Your last mission is to get the neutron destruction bomb from ")
    print ("the Laser Weapons Armory and use it to destroy the bridge and get")
    print ("to the escape pod from where you can escape after putting in the")
    print ("correct pod.")
    print ("\n")
    print ("Meanwhile you are in the central corridor where a Gothom stands")
    print ("in front of you. You need to kill him if you want to proceed to")
    print ("the Laser Weapons Armory. What will you do now - 'shoot', 'dodge' or       'tell him a joke'")
    action = input("><![CDATA[")
    if action == "shoot" :
    INDENT
        print ("You try to shoot him but he reacts faster than your expectations")
        print ("and kills you")
        return 'death'
    DEDENT
    elif action == "dodge" :
    INDENT
        print ("You thought that you will escape his vision. Poor try lad!")
        print ("He kills you")
        return 'death'
    DEDENT
    elif action == "tell him a joke" :
    INDENT
        print ("You seem to have told him a pretty funny joke and while he laughs")
        print ("you stab him and the Gothom is killed. Nice start!")
        return 'laser_weapon_armory'
    DEDENT
    else :
    INDENT
        print ("DOES NOT COMPUTE!")
        return 'central_corridor'

    DEDENT
DEDENT
----------------------------------------

def enter(self) :
INDENT
    print ("You burst onto the bridge with the neutron destruction bomb")
    print ("and surprise 5 Gothoms who are trying to destroy the ship ")
    print ("They haven't taken their weapons out as they see the bomb")
    print ("under your arm and are afraid by it as they want to see the")
    print ("bomb set off. What will you do now - throw the bomb or slowly place the bomb")
    action = input("><![CDATA[")
    if action == "throw the bomb" :
    INDENT
        print ("In a panic you throw the bomb at the Gothoms and as you try to")
        print ("escape into the door the Gothoms shot at your back and you are killed.")
        print ("As you die you see a Gothom trying to disarm the bomb and you die")
        print ("knowing that they will blow up the ship eventually.")
        return 'death'
    DEDENT
    elif action == "slowly place the bomb" :
    INDENT
        print ("You inch backward to the door, open it, and then carefully")
        print ("place the bomb on the floor pointing your blaster at it.")
        print ("Then you immediately shut the door and lock the door so")
        print ("that the Gothoms can't get out. Now as the bomb is placed")
        print ("you run to the escape pod to get off this tin can.")
        return 'escape_pod'

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23389588_23390124_68_92
23389588_23390124_94_115
Title: python code doesn't not execute nor does give any error 
----------------------------------------

def enter(self) :
INDENT
    print ("You enter into the Laser Weapon Armory. There is dead silence")
    print ("and no signs of  any Gothom. You find the bomb placed in a box")
    print ("which is secured by a key. Guess the key and gain access to neutron ")
    print ("destruction bomb and move ahead. You will get 3 chances. ")
    print ("-----------")
    print ("Guess the 3-digit key")
    key = "%d%d%d" % (randint(0, 9), randint(0, 9), randint(0, 9))
    guess_count = 0
    guess = input("[keypad]>")
    while guess_count < 3 and guess ! = key :
    INDENT
        print ("That was a wrong guess")
        guess_count += 1
        print ("You have %d chances left" % (3 - guess_count))
    DEDENT
    if guess_count == key :
    INDENT
        print ("You have entered the right key and gained access to he neutron")
        print ("destruction bomb. You grab the bomb and run as fast as you can")
        print (" to the bridge where you must place it in the right place")
        return 'the_bridge'
    DEDENT
    else :
    INDENT
        print ("The time is over and the Gothoms bomb up the entire ship and")
        print ("you die")
        return 'death'

    DEDENT
DEDENT
----------------------------------------

def enter(self) :
INDENT
    print ("You burst onto the bridge with the neutron destruction bomb")
    print ("and surprise 5 Gothoms who are trying to destroy the ship ")
    print ("They haven't taken their weapons out as they see the bomb")
    print ("under your arm and are afraid by it as they want to see the")
    print ("bomb set off. What will you do now - throw the bomb or slowly place the bomb")
    action = input("><![CDATA[")
    if action == "throw the bomb" :
    INDENT
        print ("In a panic you throw the bomb at the Gothoms and as you try to")
        print ("escape into the door the Gothoms shot at your back and you are killed.")
        print ("As you die you see a Gothom trying to disarm the bomb and you die")
        print ("knowing that they will blow up the ship eventually.")
        return 'death'
    DEDENT
    elif action == "slowly place the bomb" :
    INDENT
        print ("You inch backward to the door, open it, and then carefully")
        print ("place the bomb on the floor pointing your blaster at it.")
        print ("Then you immediately shut the door and lock the door so")
        print ("that the Gothoms can't get out. Now as the bomb is placed")
        print ("you run to the escape pod to get off this tin can.")
        return 'escape_pod'

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23404409_23576091_3_11
23404409_23588113_9_17
Title: Using decorators with MapReduce mapper/reducer functions? 
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    try :
    INDENT
        function(* args, ** kwargs)
    DEDENT
    except Exception, e :
    INDENT
        client = Client(sentry_id)
        client.captureException(exc_info = sys.exc_info())
        if raise_exception :
        INDENT
            raise
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def wrapper(* args, ** kwargs) :
INDENT
    try :
    INDENT
        return fn(* args, ** kwargs)
    DEDENT
    except Exception as e :
    INDENT
        client = Client(sentry_id)
        client.captureException(
            exc_info = sys.exc_info())
        if raise_exception :
        INDENT
            raise e
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23418081_23418144_3_13
23418081_23418194_1_11
Title: Range function and list 
----------------------------------------

def main() :
INDENT
    numbers = int(input("How many numbers are in the list "))
    lowest = int(input("Please enter the lowest range value to start with: "))
    highest = int(input("Please enter the highest range value to end with "))
    if len(range(lowest, highest + 2, 2)) ! = numbers :
    INDENT
        print ("The number of numbers requested is unexpected!")
        exit(1)
    DEDENT
    for i in range(lowest, highest + 2, 2) :
    INDENT
        print (i)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    numbers = int(input("How many numbers are in the list "))
    lowest = int(input("Please enter the lowest range value to start with: "))
    highest = int(input("Please enter the highest range value to end with "))
    if (highest + 2 - lowest) / 2 == numbers :
    INDENT
        for i in range(lowest, highest + 2, 2) :
        INDENT
            print (i)
        DEDENT
    DEDENT
    else :
    INDENT
        print ('no coinciden los numeros, vuelve a intentarlo')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23419356_24314851_6_21
23419356_46225318_6_26
Title: How to create a color wheel using turtle graphics? 
----------------------------------------

def draw_color_wheel(colors, radius, center = (0, 0)) :
INDENT
    slice_angle = 360 / len(colors)
    heading, position = 90, (center [0] + radius, center [1])
    for color in colors :
    INDENT
        turtle.color(color, color)
        turtle.penup()
        turtle.goto(position)
        turtle.setheading(heading)
        turtle.pendown()
        turtle.begin_fill()
        turtle.circle(radius, extent = slice_angle)
        heading, position = turtle.heading(), turtle.position()
        turtle.penup()
        turtle.goto(center)
        turtle.end_fill()
    DEDENT
DEDENT
----------------------------------------

def draw_color_wheel(colors, radius, center = (0, 0)) :
INDENT
    slice_angle = 360 / len(colors)
    yertle = Turtle(visible = False)
    yertle.penup()
    yertle.begin_poly()
    yertle.sety(radius)
    yertle.circle(- radius, extent = slice_angle)
    yertle.home()
    yertle.end_poly()
    screen.register_shape('slice', yertle.get_poly())
    yertle.shape('slice')
    yertle.setposition(center)
    for color in colors :
    INDENT
        yertle.color(color)
        yertle.stamp()
        yertle.left(slice_angle)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23420410_23439144_100_110
23420410_23439144_5_13
Title: Newb: best way to reference a calling class 
----------------------------------------

def init2(self, pos, imageFileName, collide, alpha) :
INDENT
    drawn.add(self)
    updated.add(self)
    if collide :
    INDENT
        collidable.add(self)
    DEDENT
    if alpha :
    INDENT
        self.image = pygame.image.load(imageFileName).convert_alpha()
    DEDENT
    else :
    INDENT
        self.image = pygame.image.load(imageFileName).convert()
    DEDENT
    self.rect = self.image.get_rect()
    self.rect.center = pos
DEDENT
----------------------------------------

def init2(self, pos, imageFileName) :
INDENT
    self.right = pygame.image.load(imageFileName).convert_alpha()
    self.left = pygame.transform.flip(self.right, True, False)
    self.vertical = pygame.transform.rotate(self.right, 90)
    self.image = self.right
    if self not in projectiles :
    INDENT
        self.direction = "right"
    DEDENT
    self.rect = self.image.get_rect()
    self.rect.center = pos
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23420410_23439144_117_132
23420410_23439144_222_252
Title: Newb: best way to reference a calling class 
----------------------------------------

def __init__(self, pos, image, health, projectile_count, fire_rate, team, speed, impermeable = False, special_reload = {}) :
INDENT
    Moveable.__init__(self, pos, image)
    self.projectiles = []
    for number in range(projectile_count) :
    INDENT
        self.projectiles.append(None)
    DEDENT
    self.health = health
    self.team = team
    team.add(self)
    drawn.add(self)
    collidable.add(self)
    updated.add(self)
    self.firetime = fire_rate
    self.fire_rate = fire_rate
    self.reload = special_reload
    self.speed = speed
    self.impermeable = impermeable
DEDENT
----------------------------------------

def __init__(self, pos, direction, image, destructcount, damager = False, boomtrigger = False, simple = True, parent = None, arc = False, explodable = False, countdown = None) :
INDENT
    Moveable.__init__(self, pos, image)
    self.arc = arc
    self.destructCountDown = destructcount
    self.full = destructcount
    if self.arc == True :
    INDENT
        magnitude = math.sqrt(direction [0] * direction [0] + direction [1] * direction [1])
        if explodable == True :
        INDENT
            time = float(self.full) - float(countdown) / 2.0
        DEDENT
        else :
        INDENT
            time = float(self.full) / 2.0
        DEDENT
        self.change = float(magnitude) / float(time)
    DEDENT
    self.parent = parent
    drawn.add(self)
    if boomtrigger ! = False :
    INDENT
        explosion_triggers.add(self)
    DEDENT
    if damager ! = False :
    INDENT
        self.damage = damager
        damagers.add(self)
    DEDENT
    self.directions = list(direction)
    self.explodable = explodable
    self.delay = 0
    if simple == True :
    INDENT
        if abs(self.directions [1]) > abs(self.directions [0]) :
        INDENT
            self.image = self.vertical
            self.rect = self.image.get_rect()
            self.rect.center = pos
        DEDENT
    DEDENT
    else :
    INDENT
        self.image = pygame.transform.rotate(self.vertical, math.degrees(math.atan2(direction [0], direction [1])))
        self.rect = self.image.get_rect()
        self.rect.center = pos
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23440402_23440723_41_50
23440402_23440723_5_17
Title: Python Tkinter: How do you create a toplevel window and destroy the previous window? 
----------------------------------------

def __init__(self, questionsdict) :
INDENT
    self.root = Tk()
    self.root.withdraw()
    self.questions(questionsdict)
    self.root.deiconify()
    c = Button(self.root, text = 'Click me to exit', command = self.root.destroy, width = 30).grid(row = 2, sticky = 'ew')
    Label(self.root, text = 'Quiz is Complete', width = 30, background = 'red').grid(row = 0, sticky = 'ew')
    mainloop()
DEDENT
----------------------------------------

def __init__(self, parent, question, right, wrong) :
INDENT
    self.answer = right
    self.top = top = Toplevel(parent)
    Label(self.top, text = question, width = 25).grid()
    a1 = random.choice([right, wrong])
    self.option_1 = Button(self.top, text = a1, width = 25, command = lambda : self.check(1))
    self.option_1.grid()
    a2 = right
    if a1 == right :
    INDENT
        a2 = wrong
    DEDENT
    self.option_2 = Button(self.top, text = a2, width = 25, command = lambda : self.check(2))
    self.option_2.grid()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23449799_23449913_15_20
23449799_23449965_17_27
Title: Writing strings to file using class - empty output 
----------------------------------------

def write_file(self) :
INDENT
    with open("cloud.txt", "w") as my_file :
    INDENT
        for word in self.wordlist :
        INDENT
            my_file.write(word + "\n")

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def write_file(self) :
INDENT
    my_file = open("cloud.txt", "w")

    for word in self.wordlist :
    INDENT
        my_file.write(word + "\n")
    DEDENT
    my_file.close()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23449799_23449913_15_20
23449799_23450008_17_23
Title: Writing strings to file using class - empty output 
----------------------------------------

def write_file(self) :
INDENT
    with open("cloud.txt", "w") as my_file :
    INDENT
        for word in self.wordlist :
        INDENT
            my_file.write(word + "\n")

        DEDENT
    DEDENT
DEDENT
----------------------------------------

def write_file(self) :
INDENT
    my_file = open("cloud.txt", "w")
    for word in self.wordlist :
    INDENT
        my_file.write(word + "\n")
    DEDENT
    my_file.close()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23449799_23449965_17_27
23449799_23450008_17_23
Title: Writing strings to file using class - empty output 
----------------------------------------

def write_file(self) :
INDENT
    my_file = open("cloud.txt", "w")

    for word in self.wordlist :
    INDENT
        my_file.write(word + "\n")
    DEDENT
    my_file.close()

DEDENT
----------------------------------------

def write_file(self) :
INDENT
    my_file = open("cloud.txt", "w")
    for word in self.wordlist :
    INDENT
        my_file.write(word + "\n")
    DEDENT
    my_file.close()

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
234512_234674_29_39
234512_234674_48_55
Title: Splitting strings in python 
----------------------------------------

def handle_word(self, word) :
INDENT
    if word.startswith('[') :
    INDENT
        self.parser.bracket_mode()
        self.parser.mode.handle_word(word [1 :])
    DEDENT
    elif word.startswith('"') :
    INDENT
        self.parser.quote_mode()
        self.parser.mode.handle_word(word [1 :])
    DEDENT
    else :
    INDENT
        self.parser.result.append(word)

    DEDENT
DEDENT
----------------------------------------

def handle_word(self, word) :
INDENT
    if word.endswith(self.end_marker) :
    INDENT
        self.result.append(word [: - 1])
        self.parser.result.append(' '.join(self.result))
        self.parser.initial_mode()
    DEDENT
    else :
    INDENT
        self.result.append(word)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23452218_23452825_19_28
23452218_23452825_45_56
Title: Proper use of QThread.currentThreadId() 
----------------------------------------

def run(self, m = 10) :
INDENT
    logthread('worker.run')
    for x in range(m) :
    INDENT
        y = x + 2
        time.sleep(0.001)
    DEDENT
    logthread('worker.run finished')
    self.done.emit()

DEDENT
----------------------------------------

def run(self) :
INDENT
    logthread('mainwin.run')
    self.workerThread = QtCore.QThread()
    self.worker.moveToThread(self.workerThread)
    self.worker.done.connect(self.workerDone)
    self.btn.clicked.connect(self.worker.run)
    self.btn2.clicked.connect(self.runWorkerHere)
    self.workerThread.start()
    self.show()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23455728_23479973_1_33
23455728_38440332_3_18
Title: Scikit-learn balanced subsampling 
----------------------------------------

def balanced_subsample(x, y, subsample_size = 1.0) :
INDENT
    class_xs = []
    min_elems = None
    for yi in np.unique(y) :
    INDENT
        elems = x [(y == yi)]
        class_xs.append((yi, elems))
        if min_elems == None or elems.shape [0] < min_elems :
        INDENT
            min_elems = elems.shape [0]
        DEDENT
    DEDENT
    use_elems = min_elems
    if subsample_size < 1 :
    INDENT
        use_elems = int(min_elems * subsample_size)
    DEDENT
    xs = []
    ys = []
    for ci, this_xs in class_xs :
    INDENT
        if len(this_xs) > use_elems :
        INDENT
            np.random.shuffle(this_xs)
        DEDENT
        x_ = this_xs [: use_elems]
        y_ = np.empty(use_elems)
        y_.fill(ci)
        xs.append(x_)
        ys.append(y_)
    DEDENT
    xs = np.concatenate(xs)
    ys = np.concatenate(ys)
    return xs, ys
DEDENT
----------------------------------------

def balanced_subsample(y, size = None) :
INDENT
    subsample = []
    if size is None :
    INDENT
        n_smp = y.value_counts().min()
    DEDENT
    else :
    INDENT
        n_smp = int(size / len(y.value_counts().index))
    DEDENT
    for label in y.value_counts().index :
    INDENT
        samples = y [y == label].index.values
        index_range = range(samples.shape [0])
        indexes = np.random.choice(index_range, size = n_smp, replace = False)
        subsample += samples [indexes].tolist()
    DEDENT
    return subsample
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23472424_23476593_1_13
23472424_23478810_1_10
Title: Removing entire rows that contain a zero in two Pandas series 
----------------------------------------

def logscatfit(x, y, title) :
INDENT
    xvals2 = np.arange(- 2, 6, 1)
    keepThese = (x > 0) & (y > 0)
    a = x [keepThese]
    b = y [keepTheese]
    a = np.log(a)
    b = np.log(b)
    plt.scatter(a, b, c = 'g', marker = 'x', s = 35)
    slope, intercept, r_value, p_value, std_err = stats.linregress(a, b)
    plt.plot(xvals2, (xvals2 * slope + intercept), color = 'red')
    plt.title(title)
    plt.show()
    print "Slope is:", slope, ". Intercept is:", intercept, ". R-value is:", r_value, ". P-value is:", p_value, ". Std_err is:", std_err
DEDENT
----------------------------------------

def logscatfit(df, x_col_name, y_col_name, title) :
INDENT
    two_cols = df [[x_col_name, y_col_name]]
    mask = two_cols.apply(lambda x : (x == 0).any(), axis = 1)
    df_to_use = df [mask]
    x = df_to_use [x_col_name]
    y = df_to_use [y_col_name]

    a = n.log(x)
    etc
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23493538_23493947_22_29
23493538_23493947_31_48
Title: How would I set individual colours for each widget item? 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MainWindow, self).__init__(parent)
    self.central_widget = QtGui.QStackedWidget()
    self.setCentralWidget(self.central_widget)
    Login_Widget = LoginPage(self)
    self.central_widget.addWidget(Login_Widget)
    self.central_widget.setCurrentWidget(Login_Widget)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(LoginPage, self).__init__(parent)
    self.Username = QtGui.QLineEdit(self)
    self.Password = QtGui.QLineEdit(self)
    self.Password.setEchoMode(QtGui.QLineEdit.Password)
    self.buttonLogin = QtGui.QPushButton('Login', self)
    self.cancelButton = QtGui.QPushButton('Cancel', self)
    loginLayout = QtGui.QFormLayout()
    loginLayout.addRow("Username", self.Username)
    loginLayout.addRow("Password", self.Password)
    horizontallayout = QtGui.QHBoxLayout()
    horizontallayout.addWidget(self.buttonLogin)
    horizontallayout.addWidget(self.cancelButton)
    layout = QtGui.QVBoxLayout(self)
    layout.addLayout(loginLayout)
    layout.addLayout(horizontallayout)
    self.setLayout(layout)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23560235_23581906_100_114
23560235_23581906_142_147
Title: Moving background pygame 
----------------------------------------

def update(self) :
INDENT
    self.rect.centerx += self.dx
    self.rect.centery += self.dy
    if self.rect.top > 600 :
    INDENT
        self.reset()

    DEDENT
    if pygame.sprite.groupcollide(enemySprites, laserSprites, 1, 1) :
    INDENT
        explosionSprites.add(EnemyExplosion(self.rect.center))

    DEDENT
    if pygame.sprite.groupcollide(enemySprites, playerSprite, 1, 1) :
    INDENT
        explosionSprites.add(EnemyExplosion(self.rect.center))
        explosionSprites.add(PlayerExplosion(self.rect.center))
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    self.counter = self.counter + 1
    if self.counter == self.maxcount :
    INDENT
        self.kill()
        exit()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23560235_23581906_100_114
23560235_23581906_54_79
Title: Moving background pygame 
----------------------------------------

def update(self) :
INDENT
    self.rect.centerx += self.dx
    self.rect.centery += self.dy
    if self.rect.top > 600 :
    INDENT
        self.reset()

    DEDENT
    if pygame.sprite.groupcollide(enemySprites, laserSprites, 1, 1) :
    INDENT
        explosionSprites.add(EnemyExplosion(self.rect.center))

    DEDENT
    if pygame.sprite.groupcollide(enemySprites, playerSprite, 1, 1) :
    INDENT
        explosionSprites.add(EnemyExplosion(self.rect.center))
        explosionSprites.add(PlayerExplosion(self.rect.center))
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    key = pygame.key.get_pressed()

    if key [K_UP] :
    INDENT
        self.rect.centery += - 3
    DEDENT
    if key [K_DOWN] :
    INDENT
        self.rect.centery += 3
    DEDENT
    if key [K_RIGHT] :
    INDENT
        self.rect.centerx += 3
    DEDENT
    if key [K_LEFT] :
    INDENT
        self.rect.centerx += - 3

    DEDENT
    if key [K_SPACE] :
    INDENT
        self.lasertimer = self.lasertimer + 1
        if self.lasertimer == self.lasermax :
        INDENT
            laserSprites.add(Laser(self.rect.midtop))
            self.lasertimer = 0

        DEDENT
    DEDENT
    self.rect.bottom = min(self.rect.bottom, 600)
    self.rect.top = max(self.rect.top, 0)
    self.rect.right = min(self.rect.right, 800)
    self.rect.left = max(self.rect.left, 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23560235_23581906_100_114
23560235_23581906_86_91
Title: Moving background pygame 
----------------------------------------

def update(self) :
INDENT
    self.rect.centerx += self.dx
    self.rect.centery += self.dy
    if self.rect.top > 600 :
    INDENT
        self.reset()

    DEDENT
    if pygame.sprite.groupcollide(enemySprites, laserSprites, 1, 1) :
    INDENT
        explosionSprites.add(EnemyExplosion(self.rect.center))

    DEDENT
    if pygame.sprite.groupcollide(enemySprites, playerSprite, 1, 1) :
    INDENT
        explosionSprites.add(EnemyExplosion(self.rect.center))
        explosionSprites.add(PlayerExplosion(self.rect.center))
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    if self.rect.right > 800 :
    INDENT
        self.kill()
    DEDENT
    else :
    INDENT
        self.rect.move_ip(0, - 15)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23560235_23581906_142_147
23560235_23581906_54_79
Title: Moving background pygame 
----------------------------------------

def update(self) :
INDENT
    self.counter = self.counter + 1
    if self.counter == self.maxcount :
    INDENT
        self.kill()
        exit()
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    key = pygame.key.get_pressed()

    if key [K_UP] :
    INDENT
        self.rect.centery += - 3
    DEDENT
    if key [K_DOWN] :
    INDENT
        self.rect.centery += 3
    DEDENT
    if key [K_RIGHT] :
    INDENT
        self.rect.centerx += 3
    DEDENT
    if key [K_LEFT] :
    INDENT
        self.rect.centerx += - 3

    DEDENT
    if key [K_SPACE] :
    INDENT
        self.lasertimer = self.lasertimer + 1
        if self.lasertimer == self.lasermax :
        INDENT
            laserSprites.add(Laser(self.rect.midtop))
            self.lasertimer = 0

        DEDENT
    DEDENT
    self.rect.bottom = min(self.rect.bottom, 600)
    self.rect.top = max(self.rect.top, 0)
    self.rect.right = min(self.rect.right, 800)
    self.rect.left = max(self.rect.left, 0)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23560235_23581906_142_147
23560235_23581906_86_91
Title: Moving background pygame 
----------------------------------------

def update(self) :
INDENT
    self.counter = self.counter + 1
    if self.counter == self.maxcount :
    INDENT
        self.kill()
        exit()
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    if self.rect.right > 800 :
    INDENT
        self.kill()
    DEDENT
    else :
    INDENT
        self.rect.move_ip(0, - 15)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23560235_23581906_54_79
23560235_23581906_86_91
Title: Moving background pygame 
----------------------------------------

def update(self) :
INDENT
    key = pygame.key.get_pressed()

    if key [K_UP] :
    INDENT
        self.rect.centery += - 3
    DEDENT
    if key [K_DOWN] :
    INDENT
        self.rect.centery += 3
    DEDENT
    if key [K_RIGHT] :
    INDENT
        self.rect.centerx += 3
    DEDENT
    if key [K_LEFT] :
    INDENT
        self.rect.centerx += - 3

    DEDENT
    if key [K_SPACE] :
    INDENT
        self.lasertimer = self.lasertimer + 1
        if self.lasertimer == self.lasermax :
        INDENT
            laserSprites.add(Laser(self.rect.midtop))
            self.lasertimer = 0

        DEDENT
    DEDENT
    self.rect.bottom = min(self.rect.bottom, 600)
    self.rect.top = max(self.rect.top, 0)
    self.rect.right = min(self.rect.right, 800)
    self.rect.left = max(self.rect.left, 0)
DEDENT
----------------------------------------

def update(self) :
INDENT
    if self.rect.right > 800 :
    INDENT
        self.kill()
    DEDENT
    else :
    INDENT
        self.rect.move_ip(0, - 15)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23562366_27115700_4_13
23562366_34418317_4_14
Title: How do i get value present in a merged cell 
----------------------------------------

def getValueWithMergeLookup(sheet, col, row) :
INDENT
    idx = '{0}{1}'.format(get_column_letter(col), row)
    for range_ in sheet.merged_cell_ranges :
    INDENT
        cells = list(cells_from_range(range_)) [0]
        if idx in cells :
        INDENT
            return sheet.cell(cells [0]).value
        DEDENT
    DEDENT
    return sheet.cell(row = row, column = col).value
DEDENT
----------------------------------------

def getValueWithMergeLookup(sheet, cell) :
INDENT
    idx = cell.coordinate
    for range_ in sheet.merged_cell_ranges :
    INDENT
        merged_cells = list(openpyxl.utils.rows_from_range(range_))
        for row in merged_cells :
        INDENT
            if idx in row :
            INDENT
                return sheet.cell(merged_cells [0] [0]).value
            DEDENT
        DEDENT
    DEDENT
    return sheet.cell(idx).value
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23582793_23582879_3_14
23582793_23582942_1_6
Title: split a list into two lists of odd-numbered entries and even -numbered entries 
----------------------------------------

def odd_even(L) :
INDENT
    even = []
    odd = []
    for x in L :
    INDENT
        if x % 2 == 0 :
        INDENT
            even.append(x)
        DEDENT
        else :
        INDENT
            odd.append(x)
        DEDENT
    DEDENT
    return even, odd
DEDENT
----------------------------------------

def odd_even(numbers) :
INDENT
    result = [], []
    for number in numbers :
    INDENT
        result [number % 2].append(number)
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23582793_23582888_1_11
23582793_23582942_1_6
Title: split a list into two lists of odd-numbered entries and even -numbered entries 
----------------------------------------

def odd_even(L) :
INDENT
    even = []
    odd = []
    for x in L :
    INDENT
        if x % 2 == 0 :
        INDENT
            even.append(x)
        DEDENT
        else :
        INDENT
            odd.append(x)
        DEDENT
    DEDENT
    return even, odd

DEDENT
----------------------------------------

def odd_even(numbers) :
INDENT
    result = [], []
    for number in numbers :
    INDENT
        result [number % 2].append(number)
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23596702_23596703_3_18
23596702_23596910_3_8
Title: Iterating over partitions in Python 
----------------------------------------

def partitions(items, k) :
INDENT
    N = len(items)
    def pairwise(iterable) :
    INDENT
        a, b = tee(iterable)
        next(b, None)
        return izip(a, b)
    DEDENT
    def applyPart(part, items) :
    INDENT
        lists = []
        for l, h in pairwise([0] + part + [N]) :
        INDENT
            lists.append(items [l : h])
        DEDENT
        return lists
    DEDENT
    for part in combinations(range(1, N), k - 1) :
    INDENT
        yield applyPart(list(part), items)
    DEDENT
DEDENT
----------------------------------------

def partitions(seq, k) :
INDENT
    for c in product(xrange(1, len(seq) + 1), repeat = k) :
    INDENT
        if sum(c) == len(seq) :
        INDENT
            it = iter(seq)
            yield [list(islice(it, x)) for x in c]
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23596702_23596703_3_18
23596702_23597028_3_13
Title: Iterating over partitions in Python 
----------------------------------------

def partitions(items, k) :
INDENT
    N = len(items)
    def pairwise(iterable) :
    INDENT
        a, b = tee(iterable)
        next(b, None)
        return izip(a, b)
    DEDENT
    def applyPart(part, items) :
    INDENT
        lists = []
        for l, h in pairwise([0] + part + [N]) :
        INDENT
            lists.append(items [l : h])
        DEDENT
        return lists
    DEDENT
    for part in combinations(range(1, N), k - 1) :
    INDENT
        yield applyPart(list(part), items)
    DEDENT
DEDENT
----------------------------------------

def partitions(items, k) :
INDENT
    def split(indices) :
    INDENT
        i = 0
        for j in indices :
        INDENT
            yield items [i : j]
            i = j
        DEDENT
        yield items [i :]
    DEDENT
    for indices in combinations(range(1, len(items)), k - 1) :
    INDENT
        yield list(split(indices))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23596702_23596910_3_8
23596702_23597028_3_13
Title: Iterating over partitions in Python 
----------------------------------------

def partitions(seq, k) :
INDENT
    for c in product(xrange(1, len(seq) + 1), repeat = k) :
    INDENT
        if sum(c) == len(seq) :
        INDENT
            it = iter(seq)
            yield [list(islice(it, x)) for x in c]
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def partitions(items, k) :
INDENT
    def split(indices) :
    INDENT
        i = 0
        for j in indices :
        INDENT
            yield items [i : j]
            i = j
        DEDENT
        yield items [i :]
    DEDENT
    for indices in combinations(range(1, len(items)), k - 1) :
    INDENT
        yield list(split(indices))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23636249_23636339_1_16
23636249_23636492_1_14
Title: How to make something outside a loop happen when the inside is true 
----------------------------------------

def add_pairing() :
INDENT
    found = False
    letter = input("What letter would you like to add?")
    symbol = input("\nWhat symbol would you like to pair with")
    for clue in clues :
    INDENT
        if letter in clue :
        INDENT
            print ("You have entered an invalid letter ")
            break
        DEDENT
        elif symbol in clue :
        INDENT
            print ("You have entered an invalid symbol")
            break
        DEDENT
    DEDENT
    else :
    INDENT
        print ("The pairing has been added")
        clues.append(letter + symbol)
        print (clues)
        return clues
    DEDENT
DEDENT
----------------------------------------

def add_pairing() :
INDENT
    found = False
    letter = input("What letter would you like to add?")
    symbol = input("\nWhat symbol would you like to pair with")
    if any(letter in clue for clue in clues) :
    INDENT
        print ("You have entered an invalid letter")
    DEDENT
    elif any(symbol in clue for clue in clues) :
    INDENT
        print ("You have entered an invalid symbol")
    DEDENT
    else :
    INDENT
        print ("The pairing has been added")
        clues.append(letter + symbol)
        print (clues)
        return clues
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23638949_23639241_4_13
23638949_38208919_2_10
Title: "Translating a string to ""robber's language""" 
----------------------------------------

def translate(mytext) :
INDENT
    for i in mytext :
    INDENT
        if i not in consonants :
        INDENT
            newtext.append(i)
        DEDENT
        else :
        INDENT
            newtext.append(i)
            newtext.append('o')
            newtext.append(i)
        DEDENT
    DEDENT
    print (newtext)
DEDENT
----------------------------------------

def translate(mytext) :
INDENT
    newtext = ""
    for i in mytext :
    INDENT
        if i in consonants :
        INDENT
            newtext += i + 'o' + i
        DEDENT
        else :
        INDENT
            newtext += i
        DEDENT
    DEDENT
    return newtext
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23638949_23639241_4_13
23638949_43046898_1_10
Title: "Translating a string to ""robber's language""" 
----------------------------------------

def translate(mytext) :
INDENT
    for i in mytext :
    INDENT
        if i not in consonants :
        INDENT
            newtext.append(i)
        DEDENT
        else :
        INDENT
            newtext.append(i)
            newtext.append('o')
            newtext.append(i)
        DEDENT
    DEDENT
    print (newtext)
DEDENT
----------------------------------------

def translate(n) :
INDENT
    b = ""
    consonant = "bcdfghjklmnpqrstvwxyz"
    for letters in n :
    INDENT
        b += letters
        if letters in consonant :
        INDENT
            b += "0" + letters
        DEDENT
        else :
        INDENT
            return ("Vowel")
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23650576_23652110_11_20
23650576_23652110_21_28
Title: Python Multiprocessing.Process how to reuse a process? 
----------------------------------------

def run(self) :
INDENT
    if self.burn_in : interface.burn_in()
    self.interface.sample(self.mcmc.options.runs)
    self.interface.update(self.mcmc)
    if True :
    INDENT
        self.result_queue.put(SENTINEL)
    DEDENT
    else :
    INDENT
        self.result_queue.put(self.mcmc)
    DEDENT
DEDENT
----------------------------------------

def run(result_queue) :
INDENT
    while True :
    INDENT
        instance = result_queue.get(True)
        if instance == SENTINEL :
        INDENT
            break
        DEDENT
        worker = Worker(result_queue, instance)
        worker.run()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23681948_23682008_1_21
23681948_27337924_1_17
Title: Get index of closest value with binary search 
----------------------------------------

def binarySearch(data, val) :
INDENT
    highIndex = len(data) - 1
    lowIndex = 0
    while highIndex > lowIndex :
    INDENT
        index = (highIndex + lowIndex) / 2
        sub = data [index]
        if data [lowIndex] == val :
        INDENT
            return [lowIndex, lowIndex]
        DEDENT
        elif sub == val :
        INDENT
            return [index, index]
        DEDENT
        elif data [highIndex] == val :
        INDENT
            return [highIndex, highIndex]
        DEDENT
        elif sub > val :
        INDENT
            if highIndex == index :
            INDENT
                return sorted([highIndex, lowIndex])
            DEDENT
            highIndex = index
        DEDENT
        else :
        INDENT
            if lowIndex == index :
            INDENT
                return sorted([highIndex, lowIndex])
            DEDENT
            lowIndex = index
        DEDENT
    DEDENT
    return sorted([highIndex, lowIndex])
DEDENT
----------------------------------------

def binarySearch(data, val) :
INDENT
    lo, hi = 0, len(data) - 1
    best_ind = lo
    while lo < = hi :
    INDENT
        mid = lo + (hi - lo) / 2
        if data [mid] < val :
        INDENT
            lo = mid + 1
        DEDENT
        elif data [mid] > val :
        INDENT
            hi = mid - 1
        DEDENT
        else :
        INDENT
            best_ind = mid
            break
        DEDENT
        if abs(data [mid] - val) < abs(data [best_ind] - val) :
        INDENT
            best_ind = mid
        DEDENT
    DEDENT
    return best_ind
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23683819_23689432_26_40
23683819_23689432_3_16
Title: How to reference Tkinter widgets inside classes in python 
----------------------------------------

def __init__(self, parent, operator) :
INDENT
    Frame.__init__(self, parent)

    self.operator = operator

    self.num1 = Entry(self)
    self.num2 = Entry(self)

    self.num1.grid(row = 0, column = 0)
    Label(self, text = self.operator).grid(row = 0, column = 1)
    self.num2.grid(row = 0, column = 2)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    Frame.__init__(self, parent)

    self.divide = MyEntry(self, '/')
    self.multiply = MyEntry(self, '*')
    self.divide.pack()
    self.multiply.pack()
    Button(self, text = 'Calculate', command = self._print_result).pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23718950_23719049_1_10
23718950_23719241_1_17
Title: Replacing multiple words in a string from a file 
----------------------------------------

def main() :
INDENT
    sentence = {}
    sentence = input("enter a sentence to translate\n")
    slang_file = open('slang.txt', 'r')
    for line in slang_file :
    INDENT
        slangword, unslang = line.strip().split(":")
        if slangword in sentence.split(" ") :
        INDENT
            sentence = sentence.replace(slangword + " ", unslang + " ")
            sentence = sentence.replace(" " + slangword, " " + unslang)
        DEDENT
    DEDENT
    print (sentence)
DEDENT
----------------------------------------

def main() :
INDENT
    sentence = input("enter a sentence to translate\n")
    slang_dict = {}
    slang_file = open('slang.txt', 'r')
    for line in slang_file :
    INDENT
        slangword, unslang = line.split(":")
        slang_dict [slangword] = unslang
    DEDENT
    result = ""
    for item in sentence.split() :
    INDENT
        if item in slang_dict.keys() :
        INDENT
            result += slang_dict [item]
        DEDENT
        else :
        INDENT
            result += item
        DEDENT
        result += " "
    DEDENT
    print result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
23718950_23719049_1_10
23718950_23720100_1_39
Title: Replacing multiple words in a string from a file 
----------------------------------------

def main() :
INDENT
    sentence = {}
    sentence = input("enter a sentence to translate\n")
    slang_file = open('slang.txt', 'r')
    for line in slang_file :
    INDENT
        slangword, unslang = line.strip().split(":")
        if slangword in sentence.split(" ") :
        INDENT
            sentence = sentence.replace(slangword + " ", unslang + " ")
            sentence = sentence.replace(" " + slangword, " " + unslang)
        DEDENT
    DEDENT
    print (sentence)
DEDENT
----------------------------------------

def main() :
INDENT
    slang_file = open("slang.txt")

    tmp_list = []

    for line in slang_file :
    INDENT

        line = line.strip()

        tmp_list.append(line.split(":"))

    DEDENT
    slang = {}

    for key, value in tmp_list :
    INDENT
        slang [key] = value

    DEDENT
    sentence = input("enter a sentence to translate\n")

    print (
        re.sub(r"\w+", lambda m : slang.get(m.group(), m.group()), sentence))
DEDENT
----------------------------------------
