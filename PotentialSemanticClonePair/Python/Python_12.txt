$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_138_145
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_138_145
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_138_145
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_138_145
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_138_145
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_138_145
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return []
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_150_157
20330480_20338108_174_179
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_150_157
20330480_20338108_184_189
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_150_157
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_150_157
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_150_157
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_150_157
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_150_157
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_150_157
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + []
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_162_169
20330480_20338108_174_179
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_162_169
20330480_20338108_184_189
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_162_169
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_162_169
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_162_169
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_162_169
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_162_169
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_162_169
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_174_179
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_174_179
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_174_179
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_174_179
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_174_179
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_174_179
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 0 :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_184_189
20330480_20338108_21_38
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_184_189
20330480_20338108_43_55
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_184_189
20330480_20338108_4_16
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_184_189
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_184_189
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_184_189
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if LIST :
    INDENT
        return [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    else :
    INDENT
        return LIST
    DEDENT
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_21_38
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)

    DEDENT
    return LIST
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_43_55
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST [- 1]
        del LIST [- 1]
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_4_16
20330480_20338108_60_74
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_4_16
20330480_20338108_79_89
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_4_16
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > = 1 :
    INDENT
        v = LIST [- 1]
    DEDENT
    if len(LIST) > 1 :
    INDENT
        del LIST [- 1]
        dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        del LIST [- 1]

    DEDENT
    LIST.insert(0, v)
    return LIST
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_60_74
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT

        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT

        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20330480_20338108_79_89
20330480_20338108_94_101
Title: Reversing a list through iteration 
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        v = LIST.pop(- 1)
        dreh(LIST)
        LIST.insert(0, v)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        v = LIST.pop(- 1)
        LIST.insert(0, v)
    DEDENT
    return LIST
DEDENT
----------------------------------------

def dreh(LIST) :
INDENT
    if len(LIST) > 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)] + dreh(LIST)
    DEDENT
    elif len(LIST) == 1 :
    INDENT
        LIST [:] = [LIST.pop(- 1)]
    DEDENT
    return LIST
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20366779_21962542_17_26
20366779_21962542_47_58
Title: Nesting widgets in kivy 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(RootWidget, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(1, 0, 0, 1)
        self.rect = Rectangle(
            size = self.size,
            pos = self.pos,
            text = "some junk!")
    DEDENT
    mybackground = Background()
    self.add_widget(mybackground)
DEDENT
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Holder, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(0.25, 0.25, 0.25, 1)
        self.rect = Rectangle(
            size = self.size,
            pos = self.pos,
            text = "More stuff!")
    DEDENT
    c1 = Circley(label = "Label 1")
    c2 = Circley(label = "Label 2")
    self.add_widget(c1)
    self.add_widget(c2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20366779_21962542_17_26
20366779_21962542_68_76
Title: Nesting widgets in kivy 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(RootWidget, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(1, 0, 0, 1)
        self.rect = Rectangle(
            size = self.size,
            pos = self.pos,
            text = "some junk!")
    DEDENT
    mybackground = Background()
    self.add_widget(mybackground)
DEDENT
----------------------------------------

def __init__(self, label = 'label', ** kwargs) :
INDENT
    super(Circley, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(0, 1, 0, 1)
        self.circ = Ellipse(
            size = self.size,
            pos = self.pos,
            text = label)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20366779_21962542_32_41
20366779_21962542_68_76
Title: Nesting widgets in kivy 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Background, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(1, 1, 1, 1)
        self.rect = Rectangle(
            size = self.size,
            pos = self.pos,
            text = "More stuff!")
    DEDENT
    myholder = Holder()
    self.add_widget(myholder)
DEDENT
----------------------------------------

def __init__(self, label = 'label', ** kwargs) :
INDENT
    super(Circley, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(0, 1, 0, 1)
        self.circ = Ellipse(
            size = self.size,
            pos = self.pos,
            text = label)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20366779_21962542_47_58
20366779_21962542_68_76
Title: Nesting widgets in kivy 
----------------------------------------

def __init__(self, ** kwargs) :
INDENT
    super(Holder, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(0.25, 0.25, 0.25, 1)
        self.rect = Rectangle(
            size = self.size,
            pos = self.pos,
            text = "More stuff!")
    DEDENT
    c1 = Circley(label = "Label 1")
    c2 = Circley(label = "Label 2")
    self.add_widget(c1)
    self.add_widget(c2)
DEDENT
----------------------------------------

def __init__(self, label = 'label', ** kwargs) :
INDENT
    super(Circley, self).__init__(** kwargs)
    with self.canvas.before :
    INDENT
        Color(0, 1, 0, 1)
        self.circ = Ellipse(
            size = self.size,
            pos = self.pos,
            text = label)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2036772_2036833_1_6
2036772_2036856_1_9
Title: How to keep count in a recursive function? [python] 
----------------------------------------

def countSubStringMatchRecursive(target, key, start_index = 0) :
INDENT
    index = target.find(key, start_index)
    if index > = 0 :
    INDENT
        return countSubStringMatchRecursive(target, key, index + len(key)) + 1
    DEDENT
    return 0
DEDENT
----------------------------------------

def countSubStringMatchRecursive(target, key, count = 0) :
INDENT
    index = target.find(key)
    if index > = 0 :
    INDENT
        count += 1
        target = target [index + len(key) :]
        count = countSubStringMatchRecursive(target, key, count)
    DEDENT
    return count
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2036772_2036833_1_6
2036772_9249369_2_8
Title: How to keep count in a recursive function? [python] 
----------------------------------------

def countSubStringMatchRecursive(target, key, start_index = 0) :
INDENT
    index = target.find(key, start_index)
    if index > = 0 :
    INDENT
        return countSubStringMatchRecursive(target, key, index + len(key)) + 1
    DEDENT
    return 0
DEDENT
----------------------------------------

def countSubStringMatchRecursive(target, key) :
INDENT
    index = find(target, key)
    if index > - 1 :
    INDENT
        return countSubStringMatchRecursive(target [index + 1 :], key) + 1
    DEDENT
    return 0

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2036772_2036856_1_9
2036772_9249369_2_8
Title: How to keep count in a recursive function? [python] 
----------------------------------------

def countSubStringMatchRecursive(target, key, count = 0) :
INDENT
    index = target.find(key)
    if index > = 0 :
    INDENT
        count += 1
        target = target [index + len(key) :]
        count = countSubStringMatchRecursive(target, key, count)
    DEDENT
    return count
DEDENT
----------------------------------------

def countSubStringMatchRecursive(target, key) :
INDENT
    index = find(target, key)
    if index > - 1 :
    INDENT
        return countSubStringMatchRecursive(target [index + 1 :], key) + 1
    DEDENT
    return 0

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20425922_20429949_1_6
20425922_20429949_7_11
Title: how can i figure the order of complexity? 
----------------------------------------

def f1(lst1) :
INDENT
    i = 2
    while i < len(lst1) :
    INDENT
        print (lst1 [i])
        i **= 2
    DEDENT
DEDENT
----------------------------------------

def f1(lst2) :
INDENT
    i = 2
    while i < len(lst2) :
    INDENT
        print (lst2 [i])
        i **= 2
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
204308_204481_12_20
204308_204481_3_9
Title: Checking for member existence in Python 
----------------------------------------

def singleton(self) :
INDENT
    try :
    INDENT
        return self.instance
    DEDENT
    except AttributeError :
    INDENT
        self.instance = Bar()
        return self.instance

    DEDENT
DEDENT
----------------------------------------

def singleton(self) :
INDENT
    if not hasattr(self, 'instance') :
    INDENT
        self.instance = Foo()
    DEDENT
    return self.instance

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20439062_20439396_5_20
20439062_20439407_23_32
Title: "Making An ""Any Key"" Interuptable Python Timer" 
----------------------------------------

def countup() :
INDENT
    i = 0
    while True :
    INDENT
        print i
        i += 1
        time.sleep(1)
        while sys.stdin in select.select([sys.stdin], [], [], 0) [0] :
        INDENT
            line = sys.stdin.readline()
            if line :
            INDENT
                r = raw_input("Restart?")
                if r.lower() == "y" :
                INDENT
                    countdown()
                DEDENT
                else :
                INDENT
                    break
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    countup()
DEDENT
----------------------------------------

def countup() :
INDENT
    try :
    INDENT
        thread.start_new_thread(input_thread, ())
        for i in range(1000000) :
        INDENT
            print i
            time.sleep(1)
        DEDENT
    DEDENT
    except KeyboardInterrupt :
    INDENT
        Z = raw_input("restart timer? ")
        if Z == 'y' or Z == 'Y' :
        INDENT
            countup()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20439243_20439514_3_31
20439243_20439574_2_19
Title: tables & functions - Pythonic code 
----------------------------------------

def __init__(self, path, sep) :
INDENT
    try :
    INDENT
        f = open(path, "r")
        read_file = f.read()
        f.close()
    DEDENT
    except :
    INDENT
        print "ERROR"
        return
    DEDENT
    table = read_file.split("\n")
    for i in range(len(table)) :
    INDENT
        table [i] = table [i].split(sep)
    DEDENT
    if len(table) > 0 :
    INDENT
        for i in range(len(table [0])) :
        INDENT
            if table [0] [i] in table [0] [0 : i] :
            INDENT
                raise ValueError
            DEDENT
        DEDENT
        rowNamesFound = []
        for i in range(1, len(table)) :
        INDENT
            if len(table [i]) ! = len(table [0]) :
            INDENT
                raise ValueError
            DEDENT
            if table [i] [0] in rowNamesFound :
            INDENT
                raise ValueError
            DEDENT
            rowNamesFound.append(table [i] [0])
        DEDENT
    DEDENT
    self.nestedList = table
    print table
DEDENT
----------------------------------------

def __init__(self, path, sep) :
INDENT
    try :
    INDENT
        with open(path, 'r') as f :
        INDENT
            lines = [l.strip() for l in f]
        DEDENT
    DEDENT
    except :
    INDENT
        print ('There was an error')
        return
    DEDENT
    data = [line.split(sep) for line in lines]
    headers = data [0]
    data = data [1 :]
    if len(set(headers)) ! = len(headers) :
    INDENT
        raise ValueError
    DEDENT
    if any(len(line) ! = len(headers) for line in data) :
    INDENT
        raise ValueError
    DEDENT
    firstCol = [line [0] for line in data]
    if len(set(firstCol)) ! = len(firstCol) :
    INDENT
        raise ValueError
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20442029_20442148_1_12
20442029_20442169_1_11
Title: Binary search program keeps getting max recursion depth error 
----------------------------------------

def binary_search(lst, target, ub, lb) :
INDENT
    mid = (ub + lb) / 2
    if ub < lb :
    INDENT
        return 'No target value found'
    DEDENT
    elif target == lst [mid] :
    INDENT
        return target
    DEDENT
    elif target > lst [mid] :
    INDENT
        mid = (mid + ub) / 2
        return binary_search(lst, target, ub, mid)
    DEDENT
    elif target < lst [mid] :
    INDENT
        mid = (mid + lb) / 2
        return binary_search(lst, target, mid, lb)
    DEDENT
DEDENT
----------------------------------------

def binary_search(lst, target, ub, lb) :
INDENT
    mid = (ub + lb) / / 2
    while target ! = lst [mid] :
    INDENT
        if target > lst [mid] :
        INDENT
            lb = (mid + ub) / / 2
        DEDENT
        if target < lst [mid] :
        INDENT
            ub = (mid + lb) / / 2
        DEDENT
        if ub < lb :
        INDENT
            return 'No target value found'
        DEDENT
        mid = (ub + lb) / / 2
    DEDENT
    return mid
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20448435_20448954_12_19
20448435_20448954_29_34
Title: How do I catch NameError in Python? 
----------------------------------------

def chase(self, who) :
INDENT
    if isinstance(who, self.chases_what) :
    INDENT
        self.speak()
        print ('{} chases {} the {}'.format(self.name, who.name, who.__class__.__name__))
        who.speak()
    DEDENT
    else :
    INDENT
        print ("{} won't chase a {}".format(self.name, who.__class__.__name__))
    DEDENT
DEDENT
----------------------------------------

def chase(self, who) :
INDENT
    if self.chases :
    INDENT
        super(Cat, self).chase(who)
    DEDENT
    else :
    INDENT
        print ("{} won't chase anything".format(self.name))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20448435_20448954_12_19
20448435_20448954_42_48
Title: How do I catch NameError in Python? 
----------------------------------------

def chase(self, who) :
INDENT
    if isinstance(who, self.chases_what) :
    INDENT
        self.speak()
        print ('{} chases {} the {}'.format(self.name, who.name, who.__class__.__name__))
        who.speak()
    DEDENT
    else :
    INDENT
        print ("{} won't chase a {}".format(self.name, who.__class__.__name__))
    DEDENT
DEDENT
----------------------------------------

def chase(self, who) :
INDENT
    if self is who :
    INDENT
        print ("{} chases his own tail".format(self.name))
    DEDENT
    else :
    INDENT
        super(Dog, self).chase(who)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20452486_20458575_29_37
20452486_20458575_5_13
Title: Create QR-code in Python (PyQt) 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QWidget.__init__(self)
    self.label = QtGui.QLabel(self)
    self.edit = QtGui.QLineEdit(self)
    self.edit.returnPressed.connect(self.handleTextEntered)
    layout = QtGui.QVBoxLayout(self)
    layout.addWidget(self.label)
    layout.addWidget(self.edit)
DEDENT
----------------------------------------

def __init__(self, border, width, box_size) :
INDENT
    self.border = border
    self.width = width
    self.box_size = box_size
    size = (width + border * 2) * box_size
    self._image = QtGui.QImage(
        size, size, QtGui.QImage.Format_RGB16)
    self._image.fill(QtCore.Qt.white)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20457832_20458086_9_28
20457832_20469377_3_31
Title: tables in python - having some errors - not sure why 
----------------------------------------

def __init__(self, path, sep = ',') :
INDENT
    self.table = load_csv(path, delimiter = sep)
    if len(self.table) == 0 :
    INDENT
        raise ValueError('No data in file {}'.format(path))
    DEDENT
    self.header = self.table.pop(0)
    self.cols = len(self.header)
    self.labels = {}
    for i, row in enumerate(self.table, 1) :
    INDENT
        if len(row) ! = self.cols :
        INDENT
            raise ValueError('row {} contains {} items - should be {}'.format(i, len(row), self.cols))
        DEDENT
        lbl = row [0]
        if lbl in self.labels :
        INDENT
            raise ValueError('rows {} and {} - duplicate labels'.format(self.labels [lbl], i))
        DEDENT
        else :
        INDENT
            self.labels [lbl] = i - 1
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def __init__(self, path, sep) :
INDENT
    try :
    INDENT
        with open(path) as f :
        INDENT
            read_file = f.read()
        DEDENT
    DEDENT
    except :
    INDENT
        print "cannot create a table from this file"
        return
    DEDENT
    self.table = read_file.split('\n')
    self.table = [self.table [i].split(sep) for i in range(len(self.table))]

    if len(self.table) > 0 :
    INDENT
        for i in range(len(self.table [0])) :
        INDENT
            if self.table [0] [i] in self.table [0] [0 : i] :
            INDENT
                raise ValueError
            DEDENT
        DEDENT
    DEDENT
    row_names = []
    for i in range(1, len(self.table)) :
    INDENT
        if len(self.table [i]) ! = len(self.table [0]) :
        INDENT
            raise ValueError
        DEDENT
        if self.table [i] [0] in row_names :
        INDENT
            raise ValueError
        DEDENT
        row_names.append(self.table [i] [0])

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20462674_20462923_1_17
20462674_20463043_1_15
Title: Adding components of a list together for BlackJack 
----------------------------------------

def value() :
INDENT
    i = 0
    total_value = 0
    while i < len(player1_hand) :
    INDENT
        card = player1_hand [i]
        value = card [i]
        if value in ('T', 'J', 'Q', 'K') :
        INDENT
            total_value += 10
        DEDENT
        elif value == 'A' :
        INDENT
            print "Please choose between 1 and 11."
            value_a = input("---> ")
            total_value += value_a
        DEDENT
        else :
        INDENT
            total_value += value
        DEDENT
    DEDENT
    i += 1
    print (value)
    return
DEDENT
----------------------------------------

def value() :
INDENT
    hand_total = 0
    rank_values = {'2' : 2, '3' : 3, '4' : 4, '5' : 5, '6' : 6, '7' : 7, '8' : 8,
        '9' : 9, '10' : 10, 'J' : 10, 'Q' : 10, 'K' : 10}
    for i in xrange(len(player1_hand)) :
    INDENT
        card = player1_hand [i] [0]
        if card == 'A' :
        INDENT
            print "Please choose between 1 and 11."
            value_a = input("---> ")
            hand_total += int(value_a)
        DEDENT
        else :
        INDENT
            hand_total += rank_values [card]
        DEDENT
    DEDENT
    return hand_total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20470892_20495928_19_38
20470892_45696768_16_56
Title: How to place minor ticks on symlog scale? 
----------------------------------------

def __call__(self) :
INDENT
    'Return the locations of the ticks'
    majorlocs = self.axis.get_majorticklocs()

    minorlocs = []

    for i in xrange(1, len(majorlocs)) :
    INDENT
        majorstep = majorlocs [i] - majorlocs [i - 1]
        if abs(majorlocs [i - 1] + majorstep / 2) < self.linthresh :
        INDENT
            ndivs = 10
        DEDENT
        else :
        INDENT
            ndivs = 9
        DEDENT
        minorstep = majorstep / ndivs
        locs = np.arange(majorlocs [i - 1], majorlocs [i], minorstep) [1 :]
        minorlocs.extend(locs)
    DEDENT
    return self.raise_if_exceeds(np.array(minorlocs))
DEDENT
----------------------------------------

def __call__(self) :
INDENT
    majorlocs = self.axis.get_majorticklocs()
    if len(majorlocs) == 1 :
    INDENT
        return self.raise_if_exceeds(np.array([]))

    DEDENT
    dmlower = majorlocs [1] - majorlocs [0]
    dmupper = majorlocs [- 1] - majorlocs [- 2]

    if majorlocs [0] ! = 0.and ((majorlocs [0] ! = self.linthresh and dmlower > self.linthresh) or (dmlower == self.linthresh and majorlocs [0] < 0)) :
    INDENT
        majorlocs = np.insert(majorlocs, 0, majorlocs [0] * 10.)
    DEDENT
    else :
    INDENT
        majorlocs = np.insert(majorlocs, 0, majorlocs [0] - self.linthresh)

    DEDENT
    if majorlocs [- 1] ! = 0.and ((np.abs(majorlocs [- 1]) ! = self.linthresh and dmupper > self.linthresh) or (dmupper == self.linthresh and majorlocs [- 1] > 0)) :
    INDENT
        majorlocs = np.append(majorlocs, majorlocs [- 1] * 10.)
    DEDENT
    else :
    INDENT
        majorlocs = np.append(majorlocs, majorlocs [- 1] + self.linthresh)

    DEDENT
    minorlocs = []

    for i in xrange(1, len(majorlocs)) :
    INDENT
        majorstep = majorlocs [i] - majorlocs [i - 1]
        if abs(majorlocs [i - 1] + majorstep / 2) < self.linthresh :
        INDENT
            ndivs = self.nintervals
        DEDENT
        else :
        INDENT
            ndivs = self.nintervals - 1.
        DEDENT
        minorstep = majorstep / ndivs
        locs = np.arange(majorlocs [i - 1], majorlocs [i], minorstep) [1 :]
        minorlocs.extend(locs)
    DEDENT
    return self.raise_if_exceeds(np.array(minorlocs))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20478398_20478451_1_15
20478398_20478869_1_9
Title: Recursive return 
----------------------------------------

def algae(S, n) :
INDENT
    al = {'A' : 'AB', 'B' : 'A'}
    if n == 0 :
    INDENT
        return S
    DEDENT
    mystr = ""
    for symbol in S :
    INDENT

        mystr += al [symbol]
    DEDENT
    return algae(mystr, n - 1)
DEDENT
----------------------------------------

def algae(S, n) :
INDENT
    al = {'A' : 'AB', 'B' : 'A'}
    for i in range(n) :
    INDENT
        newS = ''
        for i in range(len(S)) :
        INDENT
            newS += al [S [i]]
        DEDENT
        S = newS
    DEDENT
    return S
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20483380_20483489_1_26
20483380_20483593_3_23
Title: "Mergesort in Python my first sorting algorithm what went wrong?" 
----------------------------------------

def mergesort(a) :
INDENT
    if len(a) < = 1 :
    INDENT
        return a
    DEDENT
    else :
    INDENT
        mid = len(a) / 2
        a = mergesort(a [: mid]) + mergesort(a [mid :])
        auxa = []
        j = 0
        k = mid
        while j < mid and k < len(a) :
        INDENT
            if a [j] < a [k] :
            INDENT
                auxa.append(a [j])
                j += 1
            DEDENT
            else :
            INDENT
                auxa.append(a [k])
                k += 1
            DEDENT
        DEDENT
        if j == mid :
        INDENT
            auxa.extend(a [k :])
        DEDENT
        if k == len(a) :
        INDENT
            auxa.extend(a [j : mid])

        DEDENT
        return auxa
    DEDENT
DEDENT
----------------------------------------

def mergesort(array) :
INDENT
    if len(array) < = 1 : return array
    midpoint = len(array) / 2
    left_array = deque(mergesort(array [: midpoint]))
    right_array = deque(mergesort(array [midpoint :]))
    merged_array = deque([])
    while len(left_array) and len(right_array) :
    INDENT
        if left_array [0] < right_array [0] :
        INDENT
            merged_array.append(left_array.popleft())
        DEDENT
        else :
        INDENT
            merged_array.append(right_array.popleft())
        DEDENT
    DEDENT
    merged_array.extend(left_array)
    merged_array.extend(right_array)
    return merged_array
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20483453_20483765_13_19
20483453_20484229_3_13
Title: Python nested loop - get next N lines 
----------------------------------------

def window(seq, n = 2) :
INDENT
    it = iter(seq)
    d = deque((next(it, None) for _ in xrange(n)), maxlen = n)
    yield pack(d)
    for e in it :
    INDENT
        d.append(e)
        yield pack(d)
    DEDENT
DEDENT
----------------------------------------

def window(seq, n = 2) :
INDENT
    "Returns a sliding window (of width n) over data from the iterable"
    "   s -> (s0,s1,...s[n-1]), (s1,s2,...,sn), ...                   "
    it = iter(seq)
    result = tuple(islice(it, n))
    if len(result) == n :
    INDENT
        yield result
    DEDENT
    for elem in it :
    INDENT
        result = result [1 :] + (elem,)
        yield result
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2052369_2052462_52_61
2052369_2052462_67_84
Title: Updating the wx.gauge without while-loop 
----------------------------------------

def __init__(self, parent, id, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, parent, id, * args, ** kwargs)
    self.queue = Queue.Queue()
    framesizer = wx.BoxSizer(wx.VERTICAL)
    self.panel = ThreadPanel(self, wx.ID_ANY)
    framesizer.Add(self.panel, 0, wx.EXPAND)
    self.SetSizerAndFit(framesizer)
    self.Bind(EVT_THREAD_TEXT_EVENT, self.OnThreadText)
DEDENT
----------------------------------------

def __init__(self, parent, id, * args, ** kwargs) :
INDENT
    wx.Panel.__init__(self, parent, * args, ** kwargs)
    vsizer = wx.BoxSizer(wx.VERTICAL)
    self.wordtc = wx.TextCtrl(self, id = wx.ID_ANY, value = '', size = (350, - 1))
    self.inst_text = wx.StaticText(self, wx.ID_ANY,
        label = 'Enter a list of space-separated words')
    self.out_tc = wx.TextCtrl(self, id = wx.ID_ANY, size = (350, 300),
        value = '', style = wx.TE_MULTILINE)
    self.start_button = wx.Button(self, wx.ID_ANY, label = 'Start Threads')
    vsizer.Add(self.inst_text, 0, wx.ALIGN_LEFT)
    vsizer.Add(self.wordtc, 0, wx.EXPAND)
    vsizer.Add(self.start_button)
    vsizer.Add((100, 100))
    vsizer.Add(self.out_tc, 0, wx.EXPAND)
    self.SetSizer(vsizer)
    self.Bind(wx.EVT_BUTTON, self.OnStartButton, self.start_button)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20527714_20527954_1_20
20527714_20531590_86_113
Title: Python Classes to make List of objects 
----------------------------------------

def main() :
INDENT
    inventory = Inventory()
    while True :
    INDENT
        classType = input('Is the vehicle a car, truck, or suv?  ')
        vehicle = None
        if classType == 'car' :
        INDENT

            vehicle = Car(make, model, year, mileage, price, doors)
        DEDENT
        elif classType == 'truck' :
        INDENT

            vehicle = Truck(make, model, year, mileage, price, drive)
        DEDENT
        elif classType == 'suv' :
        INDENT

            vehicle = SUV(make, model, year, mileage, price, passengers)
        DEDENT
        else : print ('Unkown vehicle type')
        if vehicle : inventory.addVehicle(vehicle)
        cont = input('Would you like to add another vehicle?  */n  ')
        if cont == 'n' : break
    DEDENT
    inventory.Display()
DEDENT
----------------------------------------

def main() :
INDENT
    inventory = []
    while True :
    INDENT
        classType = input('Is the vehicle a car, truck, or suv?  ')
        print (classType)
        make = input('Please enter the make of the %s: ' % classType)
        model = input('Please enter the model of the %s: ' % classType)
        year = input('Please enter the year of the %s: ' % classType)
        mileage = input('Please enter the mileage of the %s: ' % classType)
        price = input('Please enter the price of the %s: ' % classType)
        if classType == 'car' :
        INDENT
            x = input('Please enter the amount of doors on the car: ')
            inventory.append(Car(make, model, year, mileage, price, x))
        DEDENT
        elif classType == 'truck' :
        INDENT
            x = input('Please enter 2 wheel or 4 wheel drive for the truck: ')
            inventory.append(Truck(make, model, year, mileage, price, x))
        DEDENT
        elif classType == 'suv' :
        INDENT
            x = input('Please enter the capacity of the suv: ')
            inventory.append(SUV(make, model, year, mileage, price, x))
        DEDENT
        print ('\n\n')
        inventory [- 1].Display()
        cont = 'go'
        while cont not in ('y', 'n') :
        INDENT
            cont = input('Would you like to add another vehicle?  y/n  ')
        DEDENT
        if cont == 'n' :
        INDENT
            print (inventory)
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20564867_20567674_92_125
20564867_43953216_34_77
Title: Pygame Rotated Shooting 
----------------------------------------

def main() :
INDENT
    pygame.init()
    quit = False
    s = pygame.display.set_mode((300, 300))
    c = pygame.time.Clock()
    player = Actor()
    player.x, player.y, player.speed = 134, 134, 0
    actors = [player]
    while not quit :
    INDENT

        quit = pygame.event.get(pygame.QUIT)

        target_vector = normalize(sub(pygame.mouse.get_pos(), player.pos))

        aangle = 180 * angle(target_vector, [0, 1]) / math.pi
        if target_vector [0] < 0 :
        INDENT
            aangle *= - 1
        DEDENT
        player.angle = aangle
        if pygame.event.get(pygame.MOUSEBUTTONDOWN) :
        INDENT
            actors.append(fire(player.int_pos, player.angle, target_vector))
        DEDENT
        pygame.event.poll()
        for ar in actors :
        INDENT
            ar.update()
        DEDENT
        s.fill((255, 255, 255))
        for ar in actors :
        INDENT
            ar.draw(s)
        DEDENT
        pygame.display.flip()
        c.tick(60)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    clock = pg.time.Clock()
    cannon_img = pg.Surface((60, 22), pg.SRCALPHA)
    pg.draw.rect(cannon_img, pg.Color('grey19'), [0, 0, 35, 22])
    pg.draw.rect(cannon_img, pg.Color('grey19'), [35, 6, 35, 10])
    orig_cannon_img = cannon_img
    cannon = cannon_img.get_rect(center = (320, 240))
    angle = 0
    bullet_group = pg.sprite.Group()
    playing = True
    while playing :
    INDENT
        for event in pg.event.get() :
        INDENT
            if event.type == pg.QUIT :
            INDENT
                playing = False
            DEDENT
            elif event.type == pg.MOUSEBUTTONDOWN :
            INDENT
                if event.button == 1 :
                INDENT
                    bullet_group.add(Bullet(cannon.center, angle))
                DEDENT
            DEDENT
        DEDENT
        bullet_group.update()
        x, y = Vector2(pg.mouse.get_pos()) - cannon.center
        angle = math.degrees(math.atan2(y, x))
        cannon_img = pg.transform.rotate(orig_cannon_img, - angle)
        cannon = cannon_img.get_rect(center = cannon.center)

        screen.fill(pg.Color('darkseagreen4'))
        bullet_group.draw(screen)
        screen.blit(cannon_img, cannon)
        txt = FONT.render('angle {:.1f}'.format(angle), True, BLACK)
        screen.blit(txt, (10, 10))
        pg.draw.line(
            screen, pg.Color(150, 60, 20),
            cannon.center, pg.mouse.get_pos(), 2)
        pg.display.update()
        clock.tick(30)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20583465_20583545_4_10
20583465_20584568_3_13
Title: Find the number of consecutively increasing elements in a list 
----------------------------------------

def streak(last, x) :
INDENT
    if last and x > = last [- 1] :
    INDENT
        last.append(x)
        return last
    DEDENT
    return [x]

DEDENT
----------------------------------------

def streak(grades) :
INDENT
    def streak_rec(longest, challenger, previous, rest) :
    INDENT
        if rest == [] :
        INDENT
            return max(longest, challenger)
        DEDENT
        elif previous < = rest [0] :
        INDENT
            return streak_rec(longest, challenger + 1, rest [0], rest [1 :])
        DEDENT
        else :
        INDENT
            return streak_rec(max(longest, challenger), 1, rest [0], rest [1 :])
        DEDENT
    DEDENT
    return streak_rec(0, 0, 0, grades)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20633663_20635429_40_54
20633663_20635429_4_27
Title: "wxPython efficient way to create a settings dialog" 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    wx.Frame.__init__(self, * args, ** kwargs)
    self.panel = wx.Panel(self)
    self.button = wx.Button(self.panel, label = "Show settings")
    self.button.Bind(wx.EVT_BUTTON, self.onSettings)
    self.sizer = wx.BoxSizer()
    self.sizer.Add(self.button)
    self.panel.SetSizerAndFit(self.sizer)
    self.Show()
    self.settings = [False, False, False]
DEDENT
----------------------------------------

def __init__(self, settings, * args, ** kwargs) :
INDENT
    wx.Dialog.__init__(self, * args, ** kwargs)
    self.settings = settings
    self.panel = wx.Panel(self)
    self.button_ok = wx.Button(self.panel, label = "OK")
    self.button_cancel = wx.Button(self.panel, label = "Cancel")
    self.button_ok.Bind(wx.EVT_BUTTON, self.onOk)
    self.button_cancel.Bind(wx.EVT_BUTTON, self.onCancel)
    self.checkboxes = []
    for i in range(3) :
    INDENT
        checkbox = wx.CheckBox(self.panel, label = str(i))
        checkbox.SetValue(self.settings [i])
        self.checkboxes.append(checkbox)
    DEDENT
    self.sizer = wx.BoxSizer()
    for checkbox in self.checkboxes :
    INDENT
        self.sizer.Add(checkbox)
    DEDENT
    self.sizer.Add(self.button_ok)
    self.sizer.Add(self.button_cancel)
    self.panel.SetSizerAndFit(self.sizer)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20659456_20659725_5_13
20659456_20660005_7_16
Title: Python - Implementing a numerical equation solver (Newton-Raphson) 
----------------------------------------

def solve(f, approximation, h) :
INDENT
    current_approx = approximation
    prev_approximation = float("inf")
    while current_approx - prev_approx > = h :
    INDENT
        prev_approximation = current_approx
        current_approx = current_approx - (f(current_approx)) / derivative(f, current_approx, h)
    DEDENT
    return current_approx
DEDENT
----------------------------------------

def solve(f, x0, h) :
INDENT
    lastX = x0
    nextX = lastX + 10 * h
    while (abs(lastX - nextX) > h) :
    INDENT
        newY = f(nextX)
        print "f(", nextX, ") = ", newY
        lastX = nextX
        nextX = lastX - newY / derivative(f, lastX, h)
    DEDENT
    return nextX
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20722740_20722942_10_15
20722740_20722942_24_28
Title: Object level permissions in Django admin 
----------------------------------------

def get_object(self, queryset = None) :
INDENT
    obj = super(UserDataDetailView, self).get_object(queryset)
    if not user_has_access(obj, self.request) :
    INDENT
        raise Http404(u"Access Denied")
    DEDENT
    return obj
DEDENT
----------------------------------------

def get_object(self, queryset = None) :
INDENT
    obj = super(UserDataUpdateView, self).get_object(queryset)
    if not user_has_access(obj, self.request) :
    INDENT
        raise Http404(u"Access Denied")
    DEDENT
    return obj
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20732428_20734630_15_23
20732428_20734630_5_13
Title: Differents entry points with Google App Engine Python 
----------------------------------------

def get(self) :
INDENT
    template_values = {
        'handler' : 'We are in SampleHandler2',
        'param2' : param2}
    path = os.path.join(os.path.dirname(__file__), 'Sample.html')
    self.response.out.write(template.render(path, template_values))

DEDENT
----------------------------------------

def get(self) :
INDENT
    template_values = {
        'handler' : 'We are in SampleHandler',
        'param2' : param2}
    path = os.path.join(os.path.dirname(__file__), 'Sample.html')
    self.response.out.write(template.render(path, template_values))

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20734319_42362154_24_34
20734319_42362154_4_13
Title: How to write specific iptables rules using python-iptables 
----------------------------------------

def __init__(self) :
INDENT
    iptc.Rule.__init__(self)
    self.method = {'block' : self.block,
        'snat' : self.snat,
        'allow' : self.allow,
        'i_iface' : self.i_iface,
        'o_iface' : self.o_iface,
        'source' : self.source,
        'destination' : self.destination}
DEDENT
----------------------------------------

def __init__(self, table_name) :
INDENT
    self.table = iptc.Table(table_name)
    self.chains = dict()
    for i in self.table.chains :
    INDENT
        self.chains [i.name] = iptc.Chain(self.table, i.name)
    DEDENT
    self.method = {'append' : self.append,
        'insert' : self.insert}
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20745546_20745787_3_13
20745546_20749023_4_35
Title: Python: Need a Function that Runs Only at First Time Startup 
----------------------------------------

def create_key() :
INDENT
    filename = os.path.join(_here, 'passfile.txt')
    if os.path.isfile(filename) :
    INDENT
        with open(filename) as passfile :
        INDENT
            secret = passfile.read().strip()
        DEDENT
    DEDENT
    else :
    INDENT

        secret = ''.join([str(randint(1, i + 8)) for i in range(8)])
        with open(filename, 'w') as passfile :
        INDENT
            secret = passfile.write(secret)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def create_key() :
INDENT
    filePath = 'C:/------FILEPATH-------/'
    if os.path.exists(filePath) :
    INDENT
        if os.stat(filePath) [6] > 0 :
        INDENT
            with open(filePath, 'rb') as f :
            INDENT
                firstRun = pickle.load(f)
            DEDENT
        DEDENT
        else :
        INDENT
            with open(filePath, 'wb') as f :
            INDENT
                firstRun = 't'
                pickle.dump(firstRun, f)
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        with open(filePath, 'wb') as f :
        INDENT
            firstRun = 't'
            pickle.dump(firstRun, f)
        DEDENT
    DEDENT
    if firstRun == 't' :
    INDENT

        '''
        Put key generation code here
        '''

        with open(filePath, 'wb') as f :
        INDENT
            firstRun = 'f'
            pickle.dump(firstRun, f)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20764926_20765011_1_19
20764926_20766665_1_13
Title: "Combinations without using ""itertools.combinations""" 
----------------------------------------

def combinations(iterable, r) :
INDENT
    pool = tuple(iterable)
    n = len(pool)
    if r > n :
    INDENT
        return
    DEDENT
    indices = range(r)
    yield tuple(pool [i] for i in indices)
    while True :
    INDENT
        for i in reversed(range(r)) :
        INDENT
            if indices [i] ! = i + n - r :
            INDENT
                break
            DEDENT
        DEDENT
        else :
        INDENT
            return
        DEDENT
        indices [i] += 1
        for j in range(i + 1, r) :
        INDENT
            indices [j] = indices [j - 1] + 1
        DEDENT
        yield tuple(pool [i] for i in indices)
    DEDENT
DEDENT
----------------------------------------

def combinations(sequence, length, NULL = object()) :
INDENT
    if length < = 0 :
    INDENT
        combos = [NULL]
    DEDENT
    else :
    INDENT
        combos = []
        for i, item in enumerate(sequence, 1) :
        INDENT
            rem_items = sequence [i :]
            rem_combos = combinations(rem_items, length - 1)
            combos.extend(item if combo is NULL else [item, combo] for combo in rem_combos)
        DEDENT
    DEDENT
    return combos
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20767508_20767560_1_12
20767508_20768041_3_11
Title: Django Iterating over a dictionary which is in a list and showing the data in a template 
----------------------------------------

def calculateMark(mobile_a, mobile_b) :
INDENT
    mobiles_list = [mobile_a, mobile_b]
    results = []
    for mobile in mobiles_list :
    INDENT
        dimension = TechSpecificationAdd.objects.filter(mobile_name = mobile).values(dimension)
        body_material = TechSpecificationAdd.objects.filter(mobile_name = mobile).values(body_material)
        weight = TechSpecificationAdd.objects.filter(mobile_name = mobile).values(weight)
        results.append({'dimension' : dimension, 'body_material' : body_material, 'weight' : weight})
    DEDENT
    return render_to_response('compare.html', {'data' : results})
DEDENT
----------------------------------------

def calculateMark(request, mobile_a, mobile_b) :
INDENT
    mobiles_list = [mobile_a, mobile_b]
    results = []
    for mobile in mobiles_list :
    INDENT
        record = TechSpecificationAdd.objects.filter(mobile_name = mobile).values('dimension', 'body_material', 'weight')
        results += record
    DEDENT
    return render(request, 'compare.html', {'data' : results})
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20792152_23405677_11_27
20792152_23405677_29_35
Title: Setting Scrapy proxy middleware to rotate on each request 
----------------------------------------

def process_request(self, request, spider) :
INDENT
    if random.choice(xrange(1, 100)) < = 15 :
    INDENT
        log.msg('Changing proxy')
        tn = telnetlib.Telnet('127.0.0.1', 9051)
        tn.read_until("Escape character is '^]'.", 2)
        tn.write('AUTHENTICATE "<PASSWORD HERE>"\r\n')
        tn.read_until("250 OK", 2)
        tn.write("signal NEWNYM\r\n")
        tn.read_until("250 OK", 2)
        tn.write("quit\r\n")
        tn.close()
        log.msg('>>>> Proxy changed. Sleep Time')
        time.sleep(10)

    DEDENT
DEDENT
----------------------------------------

def process_request(self, request, spider) :
INDENT
    if random.choice(xrange(1, 100)) < = 30 :
    INDENT
        log.msg('Changing UserAgent')
        ua = random.choice(USER_AGENT_LIST)
        if ua :
        INDENT
            request.headers.setdefault('User-Agent', ua)
        DEDENT
        log.msg('>>>> UserAgent changed')
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20821072_20821228_13_32
20821072_20821299_7_12
Title: multithreading system calls in python 
----------------------------------------

def test_run(files_dir) :
INDENT
    queue = mp.Queue()

    procs = [mp.Process(target = worker, args = [queue]) for i in mp.cpu_count()]
    for p in procs :
    INDENT
        p.start()

    DEDENT
    files = os.listdir(files_dir)
    for f1, f2 in IT.product(files, repeat = 2) :
    INDENT
        queue.put((f1, f2))
    DEDENT
    for p in procs :
    INDENT
        queue.put(SENTINEL)
    DEDENT
    for p in procs :
    INDENT
        p.join()
    DEDENT
DEDENT
----------------------------------------

def test_run(pool) :
INDENT
    filelist = os.listdir(files_dir)
    for f1 in filelist :
    INDENT
        for f2 in filelist :
        INDENT
            pool.apply_async(worker, args = (f1, f2))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20822850_20822894_8_12
20822850_20824403_17_22
Title: Change python mro at runtime 
----------------------------------------

def hello(self) :
INDENT
    if not hasattr(self, 'msg_str') :
    INDENT
        A.hello(self)
        return
    DEDENT
    print "%s hello" % self.msg_str
DEDENT
----------------------------------------

def hello(self) :
INDENT
    try :
    INDENT
        print "%s hello" % self.msg_str
    DEDENT
    except AttributeError :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20883896_20898070_18_28
20883896_20898070_63_83
Title: matplotlib: how to constrain mouse event handling to top-most artist? 
----------------------------------------

def on_press(self, event) :
INDENT
    'on button press we will see if the mouse is over us and store some data'
    if event.inaxes ! = self.rect.axes : return
    contains, attrd = self.rect.contains(event)
    if not contains : return
    print 'event contains', self.rect.xy
    x0, y0 = self.rect.xy
    self.press = x0, y0, event.xdata, event.ydata
DEDENT
----------------------------------------

def on_press(self, event) :
INDENT
    if event.inaxes ! = self.ax : return
    for dr in self.drs :
    INDENT
        rect = dr.rect
        contains, attrd = rect.contains(event)
        if contains :
        INDENT
            zorder = rect.zorder
            try :
            INDENT
                if zorder > maxZorder :
                INDENT
                    maxZorder = zorder
                    rectToDrag = dr
                DEDENT
            DEDENT
            except NameError :
            INDENT
                maxZorder = zorder
                rectToDrag = dr
            DEDENT
        DEDENT
    DEDENT
    try :
    INDENT
        if rectToDrag :
        INDENT
            rectToDrag.on_press(event)
        DEDENT
    DEDENT
    except UnboundLocalError :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20900578_20966465_30_45
20900578_20966465_8_28
Title: How to display an image in a scrolled pannel 
----------------------------------------

def __init__(self, parent, title, width, height) :
INDENT
    super(WinFrame, self).__init__(parent,
        title = title,
        size = (width, height))
    self.imgPanel = ImgPanel(self)
    self.frameSizer = wx.BoxSizer(wx.HORIZONTAL)
    self.frameSizer.Add(self.imgPanel, 1, wx.EXPAND)
    self.SetAutoLayout(True)
    self.SetSizer(self.frameSizer)
    self.Layout()
    self.Centre()
    self.Show(True)

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    super(ImgPanel, self).__init__(parent,
        style = wx.SUNKEN_BORDER)
    self.bitmap = wx.StaticBitmap(parent = self)
    image = wx.Bitmap('image.jpg')
    self.bitmap.SetBitmap(image)
    self.imgSizer = wx.BoxSizer(wx.VERTICAL)
    self.imgSizer.Add(self.bitmap, 1, wx.EXPAND)
    self.SetSizer(self.imgSizer)
    self.SetAutoLayout(1)
    self.SetupScrolling()
    self.Bind(wx.EVT_PAINT, self.OnPaint)
    self.bitmap.Bind(wx.EVT_MOTION, self.OnMove)
    self.bitmap.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
    self.bitmap.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
    self.IsRectReady = False
    self.newRectPara = [0, 0, 0, 0]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20906699_20908605_47_61
20906699_20908605_66_88
Title: Difficulty with variables in a class 
----------------------------------------

def __init__(self) :
INDENT
    self.desc = ("Welcome to Anguem, a fully fledged Python adventure game. Please select Of the four major classes below\n")
    self.op1 = ("Knight: 6 STR, 9 END, 4 DEX, 5 WIS")
    self.op2 = ("Barbarian: 9 STR, 6 END, 5 DEX, 4 WIS")
    self.op3 = ("Ranger: 6 STR, 4 END, 9 DEX, 5 WIS")
    self.op4 = ("Wizard: 4 STR, 5 END, 6 DEX, 9 WIS")
    self.op5 = ("")
    self.extra = ("")

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.desc = ("Would you like to...")
    self.op1 = ("1. Start a new game")
    self.op2 = ("2. Load game")
    self.op3 = ("3. Quit game")
    self.op4 = ("")
    self.op5 = ("")
    self.extra = ("Tips of the play: " + tips [randomTip])

    self.exeOne = lambda : changeTo(p1SelectClass())
    self.exeTwo = lambda : pp("Loading and saving is currently unsupported in Anguem 0.2")
    self.exeThree = lambda : pp("quit goes here")
    self.exeFour = lambda : pp("Please select a valid option")
    self.exeFive = lambda : pp("Please select a valid option")
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20907797_20908296_14_30
20907797_20908523_2_8
Title: OOP how to get the script (a game) to run 
----------------------------------------

def enter(self) :
INDENT
    print (self.welcome)
    while (input(self.question + ' ') ! = self.answer) : pass
    if not self.connected : return
    print ('\nWhither goest thou?')
    for i, scene in enumerate(self.connected) :
    INDENT
        print ('{}: {}'.format(i, scene.name))
    DEDENT
    while True :
    INDENT
        try :
        INDENT
            i = int(input('? '))
            return self.connected [i]
        DEDENT
        except ValueError :
        INDENT
            print ('I understand thee not.')
        DEDENT
        except IndexError :
        INDENT
            print ('I understand thee not.')
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def enter(self) :
INDENT
    print "Some text describing the scene bla bla"
    raw = raw_input("Guess the number")
    if raw ! = "42" :
    INDENT
        return 'Scene1'
    DEDENT
    return 'Scene2'
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20926889_20926919_1_13
20926889_20926946_1_10
Title: Python: How to execute only parts of a function? 
----------------------------------------

def transpose(self, print_matrix = True) :
INDENT
    C = Z
    for i in range(0, self.rows) :
    INDENT
        for j in range(0, self.cols) :
        INDENT
            C.matrix [i] [j] = self.matrix [j] [i]

        DEDENT
    DEDENT
    if print_matrix :
    INDENT
        C.show()
    DEDENT
    return C
DEDENT
----------------------------------------

def transpose(self) :
INDENT
    C = Z
    for i in range(0, self.rows) :
    INDENT
        for j in range(0, self.cols) :
        INDENT
            C.matrix [i] [j] = self.matrix [j] [i]
        DEDENT
    DEDENT
    return C
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20926889_20926919_1_13
20926889_20926964_1_11
Title: Python: How to execute only parts of a function? 
----------------------------------------

def transpose(self, print_matrix = True) :
INDENT
    C = Z
    for i in range(0, self.rows) :
    INDENT
        for j in range(0, self.cols) :
        INDENT
            C.matrix [i] [j] = self.matrix [j] [i]

        DEDENT
    DEDENT
    if print_matrix :
    INDENT
        C.show()
    DEDENT
    return C
DEDENT
----------------------------------------

def transpose(self) :
INDENT
    C = Z
    for i in range(0, self.rows) :
    INDENT
        for j in range(0, self.cols) :
        INDENT
            C.matrix [i] [j] = self.matrix [j] [i]
        DEDENT
    DEDENT
    return C
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21002413_21002526_8_12
21002413_21009659_7_12
Title: Design flaw -- Trying to prevent cross-imports 
----------------------------------------

def update(self) :
INDENT
    self.lifetime += 1
    if self.lifetime > 30 :
    INDENT
        self.worldobjects.append(Cell(self.worldobjects))
        self.lifetime = 0
    DEDENT
DEDENT
----------------------------------------

def update(self) :
INDENT
    self.lifetime += 1
    if self.lifetime > 30 :
    INDENT
        WorldObjects.objects.append(Cell())
        self.lifetime = 0
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21007692_21007784_1_11
21007692_21007908_1_14
Title: simulate pulling marbles from a bag without replacement (efficiently) 
----------------------------------------

def pull_marbles(sample, population = 100) :
INDENT
    assert population % 2 == 0
    marbles = [x < population / 2 for x in range(0, population)]
    total_chosen = 0
    true_chosen = 0
    for i in range(0, sample) :
    INDENT
        choice = random.randint(0, population - i - 1)
        if marbles [choice] : true_chosen += 1
        total_chosen += 1
        del marbles [choice]
    DEDENT
    return true_chosen, total_chosen
DEDENT
----------------------------------------

def pull_marbles(sample, population = 100) :
INDENT
    from random import random
    assert population % 2 == 0
    chosen = []
    nTrue = population / 2.0
    nTotal = float(population)
    for _ in xrange(sample) :
    INDENT
        if random() < nTrue / nTotal :
        INDENT
            chosen.append(True)
            nTrue -= 1.0
        DEDENT
        else :
        INDENT
            chosen.append(False)
        DEDENT
        nTotal -= 1.0
    DEDENT
    return chosen
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21007692_21007784_1_11
21007692_21007943_1_10
Title: simulate pulling marbles from a bag without replacement (efficiently) 
----------------------------------------

def pull_marbles(sample, population = 100) :
INDENT
    assert population % 2 == 0
    marbles = [x < population / 2 for x in range(0, population)]
    total_chosen = 0
    true_chosen = 0
    for i in range(0, sample) :
    INDENT
        choice = random.randint(0, population - i - 1)
        if marbles [choice] : true_chosen += 1
        total_chosen += 1
        del marbles [choice]
    DEDENT
    return true_chosen, total_chosen
DEDENT
----------------------------------------

def pull_marbles(sample, population = 100) :
INDENT
    red = population / 2
    green = (population + 1) / 2
    for i in range(sample) :
    INDENT
        choice = random.randint(1, red + green)
        if choice < = red :
        INDENT
            red -= 1
        DEDENT
        else :
        INDENT
            green -= 1
        DEDENT
    DEDENT
    return (red, green)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21007692_21007908_1_14
21007692_21007943_1_10
Title: simulate pulling marbles from a bag without replacement (efficiently) 
----------------------------------------

def pull_marbles(sample, population = 100) :
INDENT
    from random import random
    assert population % 2 == 0
    chosen = []
    nTrue = population / 2.0
    nTotal = float(population)
    for _ in xrange(sample) :
    INDENT
        if random() < nTrue / nTotal :
        INDENT
            chosen.append(True)
            nTrue -= 1.0
        DEDENT
        else :
        INDENT
            chosen.append(False)
        DEDENT
        nTotal -= 1.0
    DEDENT
    return chosen
DEDENT
----------------------------------------

def pull_marbles(sample, population = 100) :
INDENT
    red = population / 2
    green = (population + 1) / 2
    for i in range(sample) :
    INDENT
        choice = random.randint(1, red + green)
        if choice < = red :
        INDENT
            red -= 1
        DEDENT
        else :
        INDENT
            green -= 1
        DEDENT
    DEDENT
    return (red, green)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21015034_21015138_23_33
21015034_21015138_38_46
Title: Creating a multi-window application in PySide 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(W2, self).__init__(parent)
    self.btn = QPushButton('Click2')
    vb = QVBoxLayout()
    vb.addWidget(self.btn)
    self.setLayout(vb)
    self.btn.clicked.connect(self.fireupWindows3)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(W3, self).__init__(parent)
    self.resize(300, 300)
    self.btn = QLabel('The Last Window')
    vb = QVBoxLayout()
    vb.addWidget(self.btn)
    self.setLayout(vb)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21015034_21015138_23_33
21015034_21015138_6_15
Title: Creating a multi-window application in PySide 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(W2, self).__init__(parent)
    self.btn = QPushButton('Click2')
    vb = QVBoxLayout()
    vb.addWidget(self.btn)
    self.setLayout(vb)
    self.btn.clicked.connect(self.fireupWindows3)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(W1, self).__init__(parent)
    self.btn = QPushButton('Click1')
    vb = QVBoxLayout()
    vb.addWidget(self.btn)
    self.setLayout(vb)
    self.btn.clicked.connect(self.fireupWindows2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21015034_21015138_38_46
21015034_21015138_6_15
Title: Creating a multi-window application in PySide 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(W3, self).__init__(parent)
    self.resize(300, 300)
    self.btn = QLabel('The Last Window')
    vb = QVBoxLayout()
    vb.addWidget(self.btn)
    self.setLayout(vb)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(W1, self).__init__(parent)
    self.btn = QPushButton('Click1')
    vb = QVBoxLayout()
    vb.addWidget(self.btn)
    self.setLayout(vb)
    self.btn.clicked.connect(self.fireupWindows2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21036762_21036969_23_30
21036762_40050622_5_10
Title: How to have a function exit after 1 hour in Python 
----------------------------------------

def on_success(self, data) :
INDENT
    print data ['text']
    with open('scratch1.json', 'ab') as outfile :
    INDENT
        json.dump(data, outfile, indent = 4)
    DEDENT
    with open('scratch2.json', 'ab') as xoutfile :
    INDENT
        json.dump(data, xoutfile, indent = 4)
    DEDENT
    return
DEDENT
----------------------------------------

def on_success(self, data) :
INDENT
    if dt.datetime.now() > self.stop_time :
    INDENT
        raise Exception('Time expired')
    DEDENT
    fileName = self.fileDirectory + 'Tweets_' + dt.datetime.now().strftime("%Y_%m_%d_%H") + '.txt'
    open(fileName, 'a').write(json.dumps(data) + '\n')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21059466_21059941_5_14
21059466_21060065_3_14
Title: Python Json parser 
----------------------------------------

def iterparse(j) :
INDENT
    decoder = json.JSONDecoder()
    pos = 0
    while True :
    INDENT
        matched = nonspace.search(j, pos)
        if not matched :
        INDENT
            break
        DEDENT
        pos = matched.start()
        decoded, pos = decoder.raw_decode(j, pos)
        yield decoded
    DEDENT
DEDENT
----------------------------------------

def iterparse(file_obj) :
INDENT
    decoder = json.JSONDecoder()
    buf = ""
    for line in file_obj :
    INDENT
        buf += line.strip()
        try :
        INDENT
            res = decoder.raw_decode(buf)
            buf = ""
            yield res [0]
        DEDENT
        except ValueError :
        INDENT
            pass
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21079941_21081371_7_14
21079941_29528738_12_25
Title: How can I kill a single shot QtCore.QTimer in PyQt4? 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QWidget.__init__(self, * args, ** kwargs)
    self.current_timer = None
    self.layout = QVBoxLayout(self)
    self.button = QPushButton('start timer')
    self.button.clicked.connect(self.start_timer)
    self.layout.addWidget(self.button)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QWidget.__init__(self, * args, ** kwargs)
    self.layout = QVBoxLayout(self)
    self.button = QPushButton('Start timer')
    self.button.clicked.connect(self.start_timer)
    self.layout.addWidget(self.button)
    self.timer = QTimer()
    self.timer.timeout.connect(self.hello)
    self.timer.setSingleShot(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21079941_21081371_7_14
21079941_42040915_12_29
Title: How can I kill a single shot QtCore.QTimer in PyQt4? 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QWidget.__init__(self, * args, ** kwargs)
    self.current_timer = None
    self.layout = QVBoxLayout(self)
    self.button = QPushButton('start timer')
    self.button.clicked.connect(self.start_timer)
    self.layout.addWidget(self.button)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    QWidget.__init__(self, * args, ** kwargs)
    self.layout = QVBoxLayout(self)
    self.button = QPushButton('Start timer')
    self.button.clicked.connect(self.start_timer)
    self.button1 = QPushButton('Stop timer')
    self.button1.clicked.connect(self.stop_timer)
    self.layout.addWidget(self.button)
    self.layout.addWidget(self.button1)
    self.timer = QTimer()
    self.timer.timeout.connect(self.hello)
    self.timer.setSingleShot(False)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21087631_21087828_3_8
21087631_21088422_7_13
Title: Choosing which fields appear in a modelform according to user 
----------------------------------------

def __init__(self, readonly_doctor = None, * args, ** kwargs) :
INDENT
    super(StudentForm, self).__init__(* args, ** kwargs)
    if readonly_doctor is not None :
    INDENT
        self.fields ['doctor'].widget.attrs ['readonly'] = True
        self.fields ['doctor'].initial = readonly_doctor
    DEDENT
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    user = kwargs.pop('user', AnonymousUser())
    super(PatientForm, self).__init__(* args, ** kwargs)
    if user.is_staff() :
    INDENT

        self.fields ['doctor'].widget = forms.HiddenInput()
        self.fields ['doctor'].initial = user
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21097355_21097610_4_19
21097355_21149451_1_19
Title: Trouble reading CSV into Django models with python DictReader 
----------------------------------------

def form_valid(self, form) :
INDENT
    new_group = form.save()
    with new_group.group_csv.open('rbU') as the_csv :
    INDENT
        fieldnames = ['c_type', 'f_name', 'q_type', 'ans', 'n_questions', 'bucket']
        data_file = csv.DictReader(the_csv, fieldnames = fieldnames, delimiter = ',', dialect = csv.excel)
        for row in data_file :
        INDENT
            new_card = Card(
                name = 'item',
                card_type = row ['c_type'],
                file_name = row ['f_name'],
                question_type = row ['q_type'],
                answer = row ['ans'],
                num_questions = row ['n_questions'],
                bucket = row ['bucket'],
                exam = new_exam)
            new_card.save()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def form_valid(self, form) :
INDENT
    new_group = form.save()
    print (new_exam.exam_csv.name)
    data = new_group.group_csv.read()
    rows = data.splitlines()
    for row in rows :
    INDENT
        columns = row.split(',')
        print (columns)
        new_card = Card(
            name = columns [0],
            card_type = columns [0],
            file_name = columns [1],
            question_type = int(columns [2]),
            answer = columns [3].replace('"', '').strip(),
            num_questions = columns [4],
            bucket = columns [5],
            group = new_group)
        print (new_card.name)
        new_card.save()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21099253_21099601_1_22
21099253_21099618_1_21
Title: For loop failing in two instances on python exercise 
----------------------------------------

def sum13(nums) :
INDENT
    unlucky_index = 0xFFFF
    sum = 0
    for i, num in enumerate(nums) :
    INDENT
        if num == 13 :
        INDENT
            unlucky_index = i
            continue
        DEDENT
        if i == unlucky_index + 1 :
        INDENT
            continue
        DEDENT
        sum += num
    DEDENT
    print "sum =", sum
    return sum
DEDENT
----------------------------------------

def sum13(nums) :
INDENT
    running_total = 0

    inums = iter(nums)
    for n in inums :
    INDENT
        if n == 13 :
        INDENT
            try :
            INDENT
                next(inums)

            DEDENT
            except StopIteration :
            INDENT
                break
            DEDENT
            continue
        DEDENT
        else :
        INDENT
            running_total += n
        DEDENT
    DEDENT
    return running_total
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21102293_21122445_16_33
21102293_50489652_22_35
Title: How to write to Kafka from Python logging module? 
----------------------------------------

def emit(self, record) :
INDENT
    if record.name == 'kafka' :
    INDENT
        return
    DEDENT
    try :
    INDENT

        msg = self.format(record)
        if self.key is None :
        INDENT
            self.producer.send_messages(msg)
        DEDENT
        else :
        INDENT
            self.producer.send(self.key, msg)
        DEDENT
    DEDENT
    except :
    INDENT
        import traceback
        ei = sys.exc_info()
        traceback.print_exception(ei [0], ei [1], ei [2], None, sys.stderr)
        del ei

    DEDENT
DEDENT
----------------------------------------

def emit(self, record) :
INDENT
    if 'kafka.' in record.name :
    INDENT
        return
    DEDENT
    try :
    INDENT

        msg = self.format(record)
        self.producer.send(self.topic, {'message' : msg})
        self.flush(timeout = 1.0)
    DEDENT
    except Exception :
    INDENT
        logging.Handler.handleError(self, record)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21128555_21128640_4_19
21128555_21128642_4_11
Title: What's the most pythonic way (if any) to refactor these nested for/else loops? 
----------------------------------------

def awesome(somestring) :
INDENT
    x = some_default_value
    vals = [do_something, do_something_else, do_another_thing]
    subs = [['AB', 'CD', 'EF'], ['12', '34', '56'], ['!@', '@#', '#$']]
    for val, substrings in zip(vals, subs) :
    INDENT
        if check(substrings, somestring) :
        INDENT
            x = val()
            break
        DEDENT
    DEDENT
    x += complicated_thing()
    if some_condition(x) :
    INDENT
        x += "Hello"
    DEDENT
    else :
    INDENT
        x += "World"
    DEDENT
    return x
DEDENT
----------------------------------------

def awesome(my_string) :
INDENT
    if is_substr(my_string, ["A", "B", "C"]) :
    INDENT
        x = do_something() + complicated_thing()
    DEDENT
    elif is_substr(my_string, ["1", "2", "3"]) :
    INDENT
        x = do_something_else() + complicated_thing()
    DEDENT
    elif is_substr(my_string, ["!", "#", "$"]) :
    INDENT
        x = do_another_thing() + complicated_thing()
    DEDENT
    return x + ("Hello" if some_condition(x) else "World")
DEDENT
----------------------------------------
