$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
136168_48087596_1_21
136168_7047765_1_29
Title: "Get last n lines of a file with Python similar to tail" 
----------------------------------------

def tail(f, window = 1) :
INDENT
    if window == 0 :
    INDENT
        return b''
    DEDENT
    BUFSIZE = 1024
    f.seek(0, 2)
    end = f.tell()
    nlines = window + 1
    data = []
    while nlines > 0 and end > 0 :
    INDENT
        i = max(0, end - BUFSIZE)
        nread = min(end, BUFSIZE)
        f.seek(i)
        chunk = f.read(nread)
        data.append(chunk)
        nlines -= chunk.count(b'\n')
        end -= nread
    DEDENT
    return b'\n'.join(b''.join(reversed(data)).splitlines() [- window :])
DEDENT
----------------------------------------

def tail(f, window = 20) :
INDENT
    if window == 0 :
    INDENT
        return []
    DEDENT
    BUFSIZ = 1024
    f.seek(0, 2)
    bytes = f.tell()
    size = window + 1
    block = - 1
    data = []
    while size > 0 and bytes > 0 :
    INDENT
        if bytes - BUFSIZ > 0 :
        INDENT

            f.seek(block * BUFSIZ, 2)
            data.insert(0, f.read(BUFSIZ))
        DEDENT
        else :
        INDENT

            f.seek(0, 0)
            data.insert(0, f.read(bytes))
        DEDENT
        linesFound = data [0].count('\n')
        size -= linesFound
        bytes -= BUFSIZ
        block -= 1
    DEDENT
    return ''.join(data).splitlines() [- window :]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
136168_5638389_1_15
136168_6813975_4_18
Title: "Get last n lines of a file with Python similar to tail" 
----------------------------------------

def tail(file, n = 1, bs = 1024) :
INDENT
    f = open(file)
    f.seek(- 1, 2)
    l = 1 - f.read(1).count('\n')
    B = f.tell()
    while n > = l and B > 0 :
    INDENT
        block = min(bs, B)
        B -= block
        f.seek(B, 0)
        l += f.read(block).count('\n')
    DEDENT
    f.seek(B, 0)
    l = min(l, n)
    lines = f.readlines() [- l :]
    f.close()
    return lines
DEDENT
----------------------------------------

def tail(filename, n) :
INDENT
    size = os.path.getsize(filename)
    with open(filename, "rb") as f :
    INDENT

        fm = mmap.mmap(f.fileno(), 0, mmap.MAP_SHARED, mmap.PROT_READ)
        try :
        INDENT
            for i in xrange(size - 1, - 1, - 1) :
            INDENT
                if fm [i] == '\n' :
                INDENT
                    n -= 1
                    if n == - 1 :
                    INDENT
                        break
                    DEDENT
                DEDENT
            DEDENT
            return fm [i + 1 if i else 0 :].splitlines()
        DEDENT
        finally :
        INDENT
            fm.close()
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
136168_5638389_1_15
136168_692616_1_20
Title: "Get last n lines of a file with Python similar to tail" 
----------------------------------------

def tail(file, n = 1, bs = 1024) :
INDENT
    f = open(file)
    f.seek(- 1, 2)
    l = 1 - f.read(1).count('\n')
    B = f.tell()
    while n > = l and B > 0 :
    INDENT
        block = min(bs, B)
        B -= block
        f.seek(B, 0)
        l += f.read(block).count('\n')
    DEDENT
    f.seek(B, 0)
    l = min(l, n)
    lines = f.readlines() [- l :]
    f.close()
    return lines
DEDENT
----------------------------------------

def tail(f, n, offset = None) :
INDENT
    avg_line_length = 74
    to_read = n + (offset or 0)
    while 1 :
    INDENT
        try :
        INDENT
            f.seek(- (avg_line_length * to_read), 2)
        DEDENT
        except IOError :
        INDENT

            f.seek(0)
        DEDENT
        pos = f.tell()
        lines = f.read().splitlines()
        if len(lines) > = to_read or pos == 0 :
        INDENT
            return lines [- to_read : offset and - offset or None], len(lines) > to_read or pos > 0
        DEDENT
        avg_line_length *= 1.3
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
136168_5638389_1_15
136168_7047765_1_29
Title: "Get last n lines of a file with Python similar to tail" 
----------------------------------------

def tail(file, n = 1, bs = 1024) :
INDENT
    f = open(file)
    f.seek(- 1, 2)
    l = 1 - f.read(1).count('\n')
    B = f.tell()
    while n > = l and B > 0 :
    INDENT
        block = min(bs, B)
        B -= block
        f.seek(B, 0)
        l += f.read(block).count('\n')
    DEDENT
    f.seek(B, 0)
    l = min(l, n)
    lines = f.readlines() [- l :]
    f.close()
    return lines
DEDENT
----------------------------------------

def tail(f, window = 20) :
INDENT
    if window == 0 :
    INDENT
        return []
    DEDENT
    BUFSIZ = 1024
    f.seek(0, 2)
    bytes = f.tell()
    size = window + 1
    block = - 1
    data = []
    while size > 0 and bytes > 0 :
    INDENT
        if bytes - BUFSIZ > 0 :
        INDENT

            f.seek(block * BUFSIZ, 2)
            data.insert(0, f.read(BUFSIZ))
        DEDENT
        else :
        INDENT

            f.seek(0, 0)
            data.insert(0, f.read(bytes))
        DEDENT
        linesFound = data [0].count('\n')
        size -= linesFound
        bytes -= BUFSIZ
        block -= 1
    DEDENT
    return ''.join(data).splitlines() [- window :]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
136168_6813975_4_18
136168_692616_1_20
Title: "Get last n lines of a file with Python similar to tail" 
----------------------------------------

def tail(filename, n) :
INDENT
    size = os.path.getsize(filename)
    with open(filename, "rb") as f :
    INDENT

        fm = mmap.mmap(f.fileno(), 0, mmap.MAP_SHARED, mmap.PROT_READ)
        try :
        INDENT
            for i in xrange(size - 1, - 1, - 1) :
            INDENT
                if fm [i] == '\n' :
                INDENT
                    n -= 1
                    if n == - 1 :
                    INDENT
                        break
                    DEDENT
                DEDENT
            DEDENT
            return fm [i + 1 if i else 0 :].splitlines()
        DEDENT
        finally :
        INDENT
            fm.close()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def tail(f, n, offset = None) :
INDENT
    avg_line_length = 74
    to_read = n + (offset or 0)
    while 1 :
    INDENT
        try :
        INDENT
            f.seek(- (avg_line_length * to_read), 2)
        DEDENT
        except IOError :
        INDENT

            f.seek(0)
        DEDENT
        pos = f.tell()
        lines = f.read().splitlines()
        if len(lines) > = to_read or pos == 0 :
        INDENT
            return lines [- to_read : offset and - offset or None], len(lines) > to_read or pos > 0
        DEDENT
        avg_line_length *= 1.3
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
136168_6813975_4_18
136168_7047765_1_29
Title: "Get last n lines of a file with Python similar to tail" 
----------------------------------------

def tail(filename, n) :
INDENT
    size = os.path.getsize(filename)
    with open(filename, "rb") as f :
    INDENT

        fm = mmap.mmap(f.fileno(), 0, mmap.MAP_SHARED, mmap.PROT_READ)
        try :
        INDENT
            for i in xrange(size - 1, - 1, - 1) :
            INDENT
                if fm [i] == '\n' :
                INDENT
                    n -= 1
                    if n == - 1 :
                    INDENT
                        break
                    DEDENT
                DEDENT
            DEDENT
            return fm [i + 1 if i else 0 :].splitlines()
        DEDENT
        finally :
        INDENT
            fm.close()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def tail(f, window = 20) :
INDENT
    if window == 0 :
    INDENT
        return []
    DEDENT
    BUFSIZ = 1024
    f.seek(0, 2)
    bytes = f.tell()
    size = window + 1
    block = - 1
    data = []
    while size > 0 and bytes > 0 :
    INDENT
        if bytes - BUFSIZ > 0 :
        INDENT

            f.seek(block * BUFSIZ, 2)
            data.insert(0, f.read(BUFSIZ))
        DEDENT
        else :
        INDENT

            f.seek(0, 0)
            data.insert(0, f.read(bytes))
        DEDENT
        linesFound = data [0].count('\n')
        size -= linesFound
        bytes -= BUFSIZ
        block -= 1
    DEDENT
    return ''.join(data).splitlines() [- window :]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
136168_692616_1_20
136168_7047765_1_29
Title: "Get last n lines of a file with Python similar to tail" 
----------------------------------------

def tail(f, n, offset = None) :
INDENT
    avg_line_length = 74
    to_read = n + (offset or 0)
    while 1 :
    INDENT
        try :
        INDENT
            f.seek(- (avg_line_length * to_read), 2)
        DEDENT
        except IOError :
        INDENT

            f.seek(0)
        DEDENT
        pos = f.tell()
        lines = f.read().splitlines()
        if len(lines) > = to_read or pos == 0 :
        INDENT
            return lines [- to_read : offset and - offset or None], len(lines) > to_read or pos > 0
        DEDENT
        avg_line_length *= 1.3
    DEDENT
DEDENT
----------------------------------------

def tail(f, window = 20) :
INDENT
    if window == 0 :
    INDENT
        return []
    DEDENT
    BUFSIZ = 1024
    f.seek(0, 2)
    bytes = f.tell()
    size = window + 1
    block = - 1
    data = []
    while size > 0 and bytes > 0 :
    INDENT
        if bytes - BUFSIZ > 0 :
        INDENT

            f.seek(block * BUFSIZ, 2)
            data.insert(0, f.read(BUFSIZ))
        DEDENT
        else :
        INDENT

            f.seek(0, 0)
            data.insert(0, f.read(bytes))
        DEDENT
        linesFound = data [0].count('\n')
        size -= linesFound
        bytes -= BUFSIZ
        block -= 1
    DEDENT
    return ''.join(data).splitlines() [- window :]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1364923_1364959_10_19
1364923_1365131_21_33
Title: "How to connect to a GObject signal in python without it keeping a reference to the connecter?" 
----------------------------------------

def __call__(self, * things) :
INDENT
    obj = self.weak_obj()
    fun = self.weak_fun()
    if obj is not None and fun is not None :
    INDENT
        return fun(obj, * things)
    DEDENT
    elif self.handle is not None :
    INDENT
        self.sender.disconnect(self.handle)
        self.handle = None
        self.sender = None
    DEDENT
DEDENT
----------------------------------------

def __call__(self, * args, ** kwargs) :
INDENT
    obj = self.wref()
    if obj :
    INDENT
        attr = getattr(obj, self.callback_attr)
        attr(* args, ** kwargs)
    DEDENT
    elif self.gobject_token :
    INDENT
        sender = args [0]
        sender.disconnect(self.gobject_token)
        self.gobject_token = None
    DEDENT
    elif self.dbus_token :
    INDENT
        self.dbus_token.remove()
        self.dbus_token = None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13650059_19243825_4_14
13650059_43109804_3_13
Title: Apply borders to all cells in a range with openpyxl 
----------------------------------------

def set_border(ws, cell_range) :
INDENT
    rows = ws.range(cell_range)
    for row in rows :
    INDENT
        row [0].style.borders.left.border_style = Border.BORDER_THIN
        row [- 1].style.borders.right.border_style = Border.BORDER_THIN
    DEDENT
    for c in rows [0] :
    INDENT
        c.style.borders.top.border_style = Border.BORDER_THIN
    DEDENT
    for c in rows [- 1] :
    INDENT
        c.style.borders.bottom.border_style = Border.BORDER_THIN

    DEDENT
DEDENT
----------------------------------------

def set_border(ws, cell_range) :
INDENT
    border = Border(left = Side(border_style = 'thin', color = '000000'),
        right = Side(border_style = 'thin', color = '000000'),
        top = Side(border_style = 'thin', color = '000000'),
        bottom = Side(border_style = 'thin', color = '000000'))
    rows = ws.iter_rows(cell_range)
    for row in rows :
    INDENT
        for cell in row :
        INDENT
            cell.border = border
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13676744_13684902_11_26
13676744_36087108_4_15
Title: Using the SQLAlchemy ORM inside an Alembic migration: how do I? 
----------------------------------------

def upgrade() :
INDENT
    mappings = [
        (x.id, _extract_publication_date(x.rendered_html)) for x in Tip.query
        ]
    op.add_column('tip', sa.Column('publication_date', sa.DateTime(timezone = True)))
    exp = sa.sql.case(value = tip.c.id, whens = (
            (op.inline_literal(id), op.inline_literal(publication_date)) for id, publication_date in mappings.iteritems()
            ))
    op.execute(tip.update().values({'publication_date' : exp}))

DEDENT
----------------------------------------

def upgrade() :
INDENT
    session = Session(bind = op.get_bind())

    instance1 = Model1(foo = 'bar')
    instance2 = Model2(monkey = 'banana')

    session.add(instance1)
    session.add(instance2)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13685386_31364297_6_33
13685386_50664367_6_23
Title: matplotlib (equal unit length): with 'equal' aspect ratio z-axis is not equal to x- and y- 
----------------------------------------

def set_axes_equal(ax) :
INDENT
    x_limits = ax.get_xlim3d()
    y_limits = ax.get_ylim3d()
    z_limits = ax.get_zlim3d()
    x_range = abs(x_limits [1] - x_limits [0])
    x_middle = np.mean(x_limits)
    y_range = abs(y_limits [1] - y_limits [0])
    y_middle = np.mean(y_limits)
    z_range = abs(z_limits [1] - z_limits [0])
    z_middle = np.mean(z_limits)

    plot_radius = 0.5 * max([x_range, y_range, z_range])
    ax.set_xlim3d([x_middle - plot_radius, x_middle + plot_radius])
    ax.set_ylim3d([y_middle - plot_radius, y_middle + plot_radius])
    ax.set_zlim3d([z_middle - plot_radius, z_middle + plot_radius])
DEDENT
----------------------------------------

def set_axes_equal(ax) :
INDENT
    limits = np.array([
            ax.get_xlim3d(),
            ax.get_ylim3d(),
            ax.get_zlim3d(),
            ])
    origin = np.mean(limits, axis = 1)
    radius = 0.5 * np.max(np.abs(limits [:, 1] - limits [:, 0]))
    set_axes_radius(ax, origin, radius)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13694465_13694547_1_16
13694465_13694601_3_18
Title: Shouldn't this Python function return 6 all the time? 
----------------------------------------

def mult(a, b) :
INDENT
    if b == 0 :
    INDENT
        return 0

    DEDENT
    rest = mult(a, b - 1)

    value = a + rest

    return value
DEDENT
----------------------------------------

def mult(a, b) :
INDENT
    global COUNTER
    COUNTER += 1
    print " " * COUNTER + "Called with", a, b
    if b == 0 :
    INDENT
        return 0
    DEDENT
    rest = mult(a, b - 1)
    value = a + rest
    COUNTER -= 1
    print " " * COUNTER, "Value:", value
    return value
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13713831_13713875_12_17
13713831_13793680_8_13
Title: Bezier Curve using static points 
----------------------------------------

def B(coorArr, i, j, t) :
INDENT
    if j == 0 :
    INDENT
        return coorArr [i]
    DEDENT
    return B(coorArr, i, j - 1, t) * (1 - t) + B(coorArr, i + 1, j - 1, t) * t

DEDENT
----------------------------------------

def B(coord, i, j, t) :
INDENT
    if j == 0 :
    INDENT
        return coord [i]
    DEDENT
    return (B(coord, i, j - 1, t) * (1 - t) +
        B(coord, i + 1, j - 1, t) * t)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13728392_22621923_6_15
13728392_48674553_28_50
Title: Moving average or running mean 
----------------------------------------

def add(self, val) :
INDENT
    self.values.append(val)
    self.count = self.count + 1
    i = self.count
    while i & 0x01 :
    INDENT
        i = i >> 1
        v0 = self.values.pop()
        v1 = self.values.pop()
        self.values.append(v0 + v1)
    DEDENT
DEDENT
----------------------------------------

def add(self, new) :
INDENT
    new = float(new)
    n = len(self._buffer)
    if n < self.buffer_size :
    INDENT
        self._buffer.append(new)
        if self._average ! = self._average :
        INDENT
            self._average = new
        DEDENT
        else :
        INDENT
            self._average *= n
            self._average += new
            self._average /= (n + 1)
        DEDENT
    DEDENT
    else :
    INDENT
        old = self._buffer [self._index]
        self._buffer [self._index] = new
        self._index += 1
        self._index %= self.buffer_size
        self._average -= old / self.buffer_size
        self._average += new / self.buffer_size

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13728392_40623822_2_14
13728392_41420229_3_14
Title: Moving average or running mean 
----------------------------------------

def running_mean(l, N) :
INDENT
    sum = 0
    result = list(0 for x in l)
    for i in range(0, N) :
    INDENT
        sum = sum + l [i]
        result [i] = sum / (i + 1)
    DEDENT
    for i in range(N, len(l)) :
    INDENT
        sum = sum - l [i - N] + l [i]
        result [i] = sum / N
    DEDENT
    return result
DEDENT
----------------------------------------

def running_mean(l, N) :
INDENT
    if (N / / 2) * 2 == N :
    INDENT
        N = N - 1
    DEDENT
    front = np.zeros(N / / 2)
    back = np.zeros(N / / 2)
    for i in range(1, (N / / 2) * 2, 2) :
    INDENT
        front [i / / 2] = np.convolve(l [: i], np.ones((i,)) / i, mode = 'valid')
    DEDENT
    for i in range(1, (N / / 2) * 2, 2) :
    INDENT
        back [i / / 2] = np.convolve(l [- i :], np.ones((i,)) / i, mode = 'valid')
    DEDENT
    return np.concatenate([front, np.convolve(l, np.ones((N,)) / N, mode = 'valid'), back [: : - 1]])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1376438_1376531_11_15
1376438_47666001_4_10
Title: How to make a repeating generator in Python 
----------------------------------------

def myxrange(n) :
INDENT
    i = 0
    while i < n :
    INDENT
        yield i
        i += 1
    DEDENT
DEDENT
----------------------------------------

def myxrange(n) :
INDENT
    i = 0
    while i < n :
    INDENT
        yield i
        i += 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13775322_13783740_125_154
13775322_13783740_56_73
Title: Python IM Program 
----------------------------------------

def __init__(self, parent, title = None) :
INDENT
    "Initialize a Dialog window that takes focus away from the parent."
    super().__init__(parent)
    self.withdraw()
    if parent.winfo_viewable() :
    INDENT
        self.transient(parent)
    DEDENT
    if title :
    INDENT
        self.title(title)
    DEDENT
    self.parent = parent
    self.result = None
    body = Frame(self)
    self.initial_focus = self.body(body)
    body.grid(sticky = NSEW, padx = 5, pady = 5)
    self.buttonbox()
    if not self.initial_focus :
    INDENT
        self.initial_focus = self
    DEDENT
    self.protocol('WM_DELETE_WINDOW', self.cancel)
    if self.parent is not None :
    INDENT
        self.geometry('+{}+{}'.format(parent.winfo_rootx() + 50,
                parent.winfo_rooty() + 50))
    DEDENT
    self.deiconify()
    self.initial_focus.focus_set()
    try :
    INDENT
        self.wait_visibility()
    DEDENT
    except tkinter.TclError :
    INDENT
        pass
    DEDENT
    else :
    INDENT
        self.grab_set()
        self.wait_window(self)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, master, ** kw) :
INDENT
    "Initialize the SimpleClient instance with the widgets it contains."
    super().__init__(master, ** kw)
    self.grid_rowconfigure(0, weight = 1)
    self.grid_columnconfigure(0, weight = 1)
    self.output_area = ScrolledText(self, width = 25, height = 4, wrap = WORD)
    self.input_area = Entry(self)
    self.corner = Sizegrip(self)
    self.output_area.grid(row = 0, column = 0, columnspan = 2, sticky = NSEW)
    self.input_area.grid(row = 1, column = 0, sticky = EW)
    self.corner.grid(row = 1, column = 1, sticky = SE)
    self.output_area ['state'] = DISABLED
    self.input_area.bind('<Return>', self.send)
    self.after_idle(self.connect)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13775322_13783740_164_174
13775322_13783740_218_225
Title: Python IM Program 
----------------------------------------

def buttonbox(self) :
INDENT
    "Create the standard buttons and Dialog bindings."
    box = Frame(self)
    w = Button(box, text = 'OK', width = 10, command = self.ok, default = ACTIVE)
    w.grid(row = 0, column = 0, padx = 5, pady = 5)
    w = Button(box, text = 'Cancel', width = 10, command = self.cancel)
    w.grid(row = 0, column = 1, padx = 5, pady = 5)
    self.bind('<Return>', self.ok)
    self.bind('<Escape>', self.cancel)
    box.grid()
DEDENT
----------------------------------------

def buttonbox(self) :
INDENT
    "Redefine the buttons at the bottom of the window."
    w = Button(self, text = 'Connect', width = 10, command = self.ok,
        default = ACTIVE)
    w.grid(sticky = E, padx = 5, pady = 5)
    self.bind('<Return>', self.ok)
    self.bind('<Escape>', self.cancel)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13775322_13783740_207_217
13775322_13783740_247_263
Title: Python IM Program 
----------------------------------------

def body(self, master) :
INDENT
    "Customize the Dialog window with some custom widgets."
    self.connection = None
    self.resizable(False, False)
    self.prompt = Label(master, text = 'Enter server IP address:')
    self.address = Entry(master)
    self.prompt.grid(sticky = W, padx = 30, pady = 2)
    self.address.grid(sticky = W, padx = 30)
DEDENT
----------------------------------------

def body(self, master) :
INDENT
    "Create the widgets for this Dialog and start the connection process."
    self.connection = None
    self.resizable(False, False)
    self.message = Label(master, text = 'Trying to connect to address ...')
    self.progress = Progressbar(master, orient = HORIZONTAL)
    self.message.grid(sticky = W, padx = 10, pady = 2)
    self.progress.grid(sticky = EW, padx = 10, pady = 2)
    self.progress.configure(mode = 'indeterminate', maximum = 30)
    self.progress.start()
    result = []
    start_thread(self.connect, result)
    self.after_idle(self.poll, result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13775322_13783740_269_275
13775322_13783740_74_82
Title: Python IM Program 
----------------------------------------

def connect(self, result) :
INDENT
    "Try connecting to the server address that was given."
    try :
    INDENT
        result.append(socket.create_connection(self.server_address, 10))
    DEDENT
    except socket.timeout :
    INDENT
        result.append(None)
    DEDENT
DEDENT
----------------------------------------

def connect(self) :
INDENT
    "Try connecting to a server to begin chatting."
    self.connection = Connector(self, 'Chat Client').connection
    if self.connection is None :
    INDENT
        self._root().destroy()
    DEDENT
    else :
    INDENT
        self.connection.setblocking(False)
        self.after_idle(self.update)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13781424_13781521_5_21
13781424_13781919_6_22
Title: Can you pretty this up? 
----------------------------------------

def getSurroundingTiles(self, tile, horizontal = True, vertical = True) :
INDENT
    index = list(self.getTiles()).index(tile)
    maxtile = self.sqrtnum - 1
    i = int(math.floor(index / self.sqrtnum))
    j = int(index % self.sqrtnum)
    surroundingTiles = []
    startat = 0 if horizontal else 4
    stopat = 8 if vertical else 4
    for di, dj in dij [startat : stopat] :
    INDENT
        if 0 < = i + di < = maxtile and 0 < = j + dj < = maxtile :
        INDENT
            surroundingTiles.append(self [i + di] [j + dj])
        DEDENT
    DEDENT
    return surroundingTiles
DEDENT
----------------------------------------

def getSurroundingTiles(self, tile, horizontal = True, vertical = True) :
INDENT
    index = list(self.getTiles()).index(tile)
    maxtile = self.sqrtnum - 1
    fhv = (horizontal, vertical)
    ij = (int(math.floor(index / self.sqrtnum)),
        int(index % self.sqrtnum))
    surroundingTiles = []
    for ihv in range(2) :
    INDENT
        if fhv [ihv] :
        INDENT
            for k in range(4) :
            INDENT
                n = [sum(p) for p in zip(ij, d [ihv] [k])]
                if all([0 < = n [i] < = maxtile for i in range(2)]) :
                INDENT
                    surroundingTiles.append(self [n [0]] [n [1]])
                DEDENT
            DEDENT
        DEDENT
    DEDENT
    return surroundingTiles
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13783107_13783390_3_24
13783107_13783394_6_33
Title: Animate using a pixmap or image sequence in Python with QT4 
----------------------------------------

def __init__(self) :
INDENT
    QtGui.QWidget.__init__(self)
    self.setAttribute(QtCore.Qt.WA_NoSystemBackground)
    self.setWindowFlags(QtCore.Qt.FramelessWindowHint)
    filename = "test.gif"
    size = QtGui.QImage(filename).size()
    self.setWindowTitle("Status")
    layout = QtGui.QVBoxLayout(self)
    layout.setMargin(0)
    self.movie = QtGui.QMovie(filename)
    self.label = QtGui.QLabel(self)
    self.label.setMovie(self.movie)
    layout.addWidget(self.label)
    self.resize(size)
    self.movie.start()
DEDENT
----------------------------------------

def __init__(self, gif, parent = None) :
INDENT
    super(MoviePlayer, self).__init__(parent)
    self.setGeometry(200, 200, 400, 400)
    self.setWindowTitle("QMovie to show animated gif")
    self.movie_screen = QLabel()
    self.movie_screen.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
    self.movie_screen.setAlignment(Qt.AlignCenter)
    btn_start = QPushButton("Start Animation")
    btn_start.clicked.connect(self.start)
    btn_stop = QPushButton("Stop Animation")
    btn_stop.clicked.connect(self.stop)
    main_layout = QVBoxLayout()
    main_layout.addWidget(self.movie_screen)
    main_layout.addWidget(btn_start)
    main_layout.addWidget(btn_stop)
    self.setLayout(main_layout)
    self.movie = QMovie(gif, QByteArray(), self)
    self.movie.setCacheMode(QMovie.CacheAll)
    self.movie.setSpeed(100)
    self.movie_screen.setMovie(self.movie)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13787122_13787230_6_14
13787122_13787474_6_17
Title: corpus from twitter 
----------------------------------------

def feed(username, messages = 50) :
INDENT
    template = 'https://api.twitter.com/1/statuses/user_timeline.json?' + 'include_entities=false&include_rts=true&screen_name=%s&count=%i'
    url = template % (username, messages)
    output = urllib2.urlopen(url)
    html = ''.join(output.readlines())
    tweet = json.loads(html)
    return list(map(lambda t : t ['text'], tweet))
DEDENT
----------------------------------------

def feed(ids) :
INDENT
    result = []
    template = 'https://api.twitter.com/1/statuses/show.json?id=%i&include_entities=true'
    for id in ids :
    INDENT
        url = template % id
        output = urllib2.urlopen(url)
        html = ''.join(output.readlines())
        tweet = json.loads(html)
        result.append(tweet ['text'])
    DEDENT
    return result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13805910_13805949_3_11
13805910_13805959_1_11
Title: Reference Before Assignment Error 
----------------------------------------

def guessFunc() :
INDENT
    guesses = 0
    while guess ! = num :
    INDENT
        guess = input("Guess a number between 1 and 10: \n")
        guess = int(guess)
        guesses += 1
    DEDENT
    print ("Congratulations, you got it right")
    return guesses
DEDENT
----------------------------------------

def guessFunc() :
INDENT
    global guesses
    guess = input("Guess a number between 1 and 10: \n")
    guess = int(guess)
    if guess == num :
    INDENT
        print ("Congratulations, you got it right")
    DEDENT
    else :
    INDENT
        guesses += 1
        guessFunc()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13827543_13830807_1_10
13827543_28634996_1_36
Title: Is there anyway to get the names of passed arguments to a function in python? 
----------------------------------------

def show(* x) :
INDENT
    for el in x :
    INDENT
        fl = None
        for gname, gobj in globals().iteritems() :
        INDENT
            if el == gobj :
            INDENT
                print '%s == %r' % (gname, el)
                fl = True
            DEDENT
        DEDENT
        if not fl :
        INDENT
            print 'There is no identifier assigned to %r in the global namespace' % el
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def show(x) :
INDENT
    from inspect import currentframe
    callingFrame = currentframe().f_back
    callingEnv = callingFrame.f_builtins.copy()
    callingEnv.update(callingFrame.f_globals)
    callingEnv.update(callingFrame.f_locals)

    possibleRoots = [item [0] for item in callingEnv.items() if item [1] == x]

    if not possibleRoots :
    INDENT
        root = '<unnamed>'
    DEDENT
    else :
    INDENT
        if len(possibleRoots) == 1 :
        INDENT
            root = str(possibleRoots [0])
        DEDENT
        else :
        INDENT

            root = '<'
            for possibleRoot in possibleRoots [: - 1] :
            INDENT
                root += str(possibleRoot) + ', '
            DEDENT
            root += 'or ' + str(possibleRoots [- 1]) + '>'
        DEDENT
    DEDENT
    print (root + ' = ' + str(x))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13835207_13840728_20_67
13835207_13840728_4_13
Title: binding to cursor movement doesnt change INSERT mark 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Text.__init__(self, * args, ** kwargs)

    private_callback = self.register(self._callback)
    self.tk.eval('''
            proc widget_proxy {actual_widget callback args} {

                # this prevents recursion if the widget is called
                # during the callback
                set flag ::dont_recurse(actual_widget)

                # call the real tk widget with the real args
                set result [uplevel [linsert $args 0 $actual_widget]]

                # call the callback and ignore errors, but only
                # do so on inserts, deletes, and changes in the 
                # mark. Otherwise we'll call the callback way too 
                # often.
                if {! [info exists $flag]} {
                    if {([lindex $args 0] in {insert replace delete}) ||
                        ([lrange $args 0 2] == {mark set insert})} {
                        # the flag makes sure that whatever happens in the
                        # callback doesn't cause the callbacks to be called again.
                        set $flag 1
                        catch {$callback $result {*}$args } callback_result
                        unset -nocomplain $flag
                    }
                }

                # return the result from the real widget command
                return $result
            }
            ''')
    self.tk.eval('''
            rename {widget} _{widget}
            interp alias {{}} ::{widget} {{}} widget_proxy _{widget} {callback}
        '''.format(widget = str(self), callback = private_callback))
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    tk.Frame.__init__(self, parent)
    self.text = CustomText(self, wrap = "word")
    self.text.pack(side = "top", fill = "both", expand = True)
    self.label = tk.Label(self, anchor = "w")
    self.label.pack(side = "bottom", fill = "x")

    self.text.set_callback(self.callback)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13835990_13879555_11_20
13835990_13879555_29_35
Title: "how to show txt on web by gaegoogle app enginepython" 
----------------------------------------

def get(self) :
INDENT
    upload_url = blobstore.create_upload_url('/upload')
    self.response.out.write('<html><body>')
    self.response.out.write('<form action="%s" method="POST" enctype="multipart/form-data"><![CDATA[' % upload_url)
    self.response.out.write("""Upload File: <input type="file" name="file"><![CDATA[<br> <input type="submit" name="submit" value="Submit"><![CDATA[ </form></body></html>""")
    for b in blobstore.BlobInfo.all() :
    INDENT

        self.response.out.write(u'<li><a href="/serve/%s"><![CDATA[%s</a>[%s]</li>' % (b.key(), b.filename, blobstore.BlobReader(b.key()).read()))
    DEDENT
DEDENT
----------------------------------------

def get(self, blob_key) :
INDENT
    blob_key = str(urllib.unquote(blob_key))
    if not blobstore.get(blob_key) :
    INDENT
        self.error(404)
    DEDENT
    else :
    INDENT
        self.send_blob(blobstore.BlobInfo.get(blob_key))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13844725_29542291_10_22
13844725_47371350_8_26
Title: Accessing response soap header using suds 
----------------------------------------

def get_headers(self, method) :
INDENT
    method = method.method
    binding = method.binding.output
    rtypes = binding.headpart_types(method, False)
    envns = ('SOAP-ENV', 'http://schemas.xmlsoap.org/soap/envelope/')
    soapenv = self.document.getChild('Envelope', envns)
    soapheaders = soapenv.getChild('Header', envns)
    nodes = soapheaders.children
    if len(nodes) :
    INDENT
        resolved = rtypes [0].resolve(nobuiltin = True)
        return binding.unmarshaller().process(nodes [0], resolved)
    DEDENT
    return None
DEDENT
----------------------------------------

def get_headers(self, method) :
INDENT
    Result = {}
    method = method.method
    binding = method.binding.output
    SHeaderElem = binding.headpart_types(method, False)
    envns = ('SOAP-ENV', 'http://schemas.xmlsoap.org/soap/envelope/')
    soapenv = self.document.getChild('Envelope', envns)
    soapheaders = soapenv.getChild('Header', envns)
    SHeaderNodes = soapheaders.children
    for Elem in SHeaderElem :
    INDENT
        for Node in SHeaderNodes :
        INDENT
            if (Node.name == Elem.name) :
            INDENT
                ElemRes = Elem.resolve(nobuiltin = True)
                NodeRes = binding.unmarshaller().process(Node, ElemRes)
                Result [Elem.name] = NodeRes
            DEDENT
        DEDENT
    DEDENT
    return Result
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13941735_13985085_18_48
13941735_13985085_4_15
Title: wxpython Gridsizer not fitting to panel 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent, size = (0, 0))
    pageSizer = wx.BoxSizer(wx.VERTICAL)
    self.grid = wx.GridSizer(0, 4, 5, 5)

    pageSizer.Add(self.grid, 1, wx.EXPAND | wx.ALL, 10)
    self.SetSizer(pageSizer)
    self.GenerateContent()

    self.Bind(wx.EVT_LEFT_DOWN, self.GenerateContent)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, title = 'wx.Notebook')
    book = wx.Notebook(self)

    page = MyPage(parent = book)
    book.AddPage(page, 'Page 1')
    book.AddPage(MyPage(book), 'Page 2')
    book.AddPage(MyPage(book), 'Page 3')
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13977511_13977902_19_28
13977511_13977902_5_13
Title: PyQt - PySide Custom Widget Won't Show 
----------------------------------------

def initUI(self) :
INDENT
    self.mw = MyWidget(self)
    layout = QHBoxLayout()
    layout.addWidget(self.mw)
    self.setLayout(layout)
    self.resize(250, 300)
    self.center()
    self.setWindowTitle('Custom Widget Example')
    self.show()
DEDENT
----------------------------------------

def initUI(self) :
INDENT
    self.btn = QPushButton('dia', self)
    self.le = QLineEdit(self)
    layout = QHBoxLayout()
    layout.addWidget(self.btn)
    layout.addWidget(self.le)
    self.setLayout(layout)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13979714_13980081_4_15
13979714_30824265_54_60
Title: Heap Sort: how to sort? 
----------------------------------------

def heapify(end, i) :
INDENT
    l = 2 * i + 1
    r = 2 * (i + 1)
    max = i
    if l < end and sqc [i] < sqc [l] :
    INDENT
        max = l
    DEDENT
    if r < end and sqc [max] < sqc [r] :
    INDENT
        max = r
    DEDENT
    if max ! = i :
    INDENT
        swap(i, max)
        heapify(end, max)
    DEDENT
DEDENT
----------------------------------------

def heapify(heapArr, op) :
INDENT
    if op == 1 :
    INDENT
        heapArr = prelocateUp(heapArr)
    DEDENT
    else :
    INDENT
        heapArr = prelocateDown(heapArr)
    DEDENT
    return heapArr
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13981824_13984032_37_43
13981824_13984032_8_18
Title: How can I find a substring and highlight it in QTextEdit? 
----------------------------------------

def __init__(self, fileInput, listKeywords, parent = None) :
INDENT
    super(highlightTextEdit, self).__init__(parent)
    highlightSyntax(QStringList(listKeywords), self)
    with open(fileInput, "r") as fInput :
    INDENT
        self.setPlainText(fInput.read())
    DEDENT
DEDENT
----------------------------------------

def __init__(self, listKeywords, parent = None) :
INDENT
    super(highlightSyntax, self).__init__(parent)
    brush = QBrush(Qt.darkBlue, Qt.SolidPattern)
    keyword = QTextCharFormat()
    keyword.setForeground(brush)
    keyword.setFontWeight(QFont.Bold)
    self.highlightingRules = [highlightRule(QRegExp("\\b" + key + "\\b"), keyword) for key in listKeywords
        ]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13981824_13984032_37_43
13981824_13988652_5_28
Title: How can I find a substring and highlight it in QTextEdit? 
----------------------------------------

def __init__(self, fileInput, listKeywords, parent = None) :
INDENT
    super(highlightTextEdit, self).__init__(parent)
    highlightSyntax(QStringList(listKeywords), self)
    with open(fileInput, "r") as fInput :
    INDENT
        self.setPlainText(fInput.read())
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyHighlighter, self).__init__(parent)
    text = """In this text I want to highlight this word and only this word.\n""" + """Any other word shouldn't be highlighted"""
    self.setText(text)
    cursor = self.textCursor()
    format = QtGui.QTextCharFormat()
    format.setBackground(QtGui.QBrush(QtGui.QColor("red")))
    pattern = "word"
    regex = QtCore.QRegExp(pattern)
    pos = 0
    index = regex.indexIn(self.toPlainText(), pos)
    while (index ! = - 1) :
    INDENT

        cursor.setPosition(index)
        cursor.movePosition(QtGui.QTextCursor.EndOfWord, 1)
        cursor.mergeCharFormat(format)
        pos = index + regex.matchedLength()
        index = regex.indexIn(self.toPlainText(), pos)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13981824_13984032_8_18
13981824_13988652_5_28
Title: How can I find a substring and highlight it in QTextEdit? 
----------------------------------------

def __init__(self, listKeywords, parent = None) :
INDENT
    super(highlightSyntax, self).__init__(parent)
    brush = QBrush(Qt.darkBlue, Qt.SolidPattern)
    keyword = QTextCharFormat()
    keyword.setForeground(brush)
    keyword.setFontWeight(QFont.Bold)
    self.highlightingRules = [highlightRule(QRegExp("\\b" + key + "\\b"), keyword) for key in listKeywords
        ]
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(MyHighlighter, self).__init__(parent)
    text = """In this text I want to highlight this word and only this word.\n""" + """Any other word shouldn't be highlighted"""
    self.setText(text)
    cursor = self.textCursor()
    format = QtGui.QTextCharFormat()
    format.setBackground(QtGui.QBrush(QtGui.QColor("red")))
    pattern = "word"
    regex = QtCore.QRegExp(pattern)
    pos = 0
    index = regex.indexIn(self.toPlainText(), pos)
    while (index ! = - 1) :
    INDENT

        cursor.setPosition(index)
        cursor.movePosition(QtGui.QTextCursor.EndOfWord, 1)
        cursor.mergeCharFormat(format)
        pos = index + regex.matchedLength()
        index = regex.indexIn(self.toPlainText(), pos)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13996130_14016704_12_26
13996130_14016769_4_20
Title: Qt QGraphicsDropShadowEffect is not showing 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(testShadow, self).__init__(parent)
    self.resize(94, 35)
    self.verticalLayout = QVBoxLayout(self)
    self.verticalLayout.setObjectName("verticalLayout")
    self.label = QLabel(self)
    self.label.setText("Text Label")
    self.shadow = QGraphicsDropShadowEffect(self)
    self.shadow.setBlurRadius(5)
    self.label.setGraphicsEffect(self.shadow)
    self.verticalLayout.addWidget(self.label)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Graphics, self).__init__()
    layout = QtGui.QVBoxLayout(self)
    layout.setMargin(0)
    shad = QtGui.QGraphicsDropShadowEffect(self)
    shad.setBlurRadius(5)
    self.scene = QtGui.QGraphicsScene(self)
    self.view = QtGui.QGraphicsView(self)
    self.view.setScene(self.scene)
    text = self.scene.addText("Drop Shadow!")
    text.setGraphicsEffect(shad)
    layout.addWidget(self.view)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
13998790_13999156_23_45
13998790_14000584_13_23
Title: Good Style in Python Objects 
----------------------------------------

def union(self, leader1, leader2) :
INDENT
    if leader2.leader is leader1 :
    INDENT
        return
    DEDENT
    if leader1.size > = leader2.size :
    INDENT
        newleader = leader1
        oldleader = leader2
    DEDENT
    else :
    INDENT
        newleader = leader2
        oldleader = leader1
    DEDENT
    newleader.size = leader1.size + leader2.size
    d = oldleader
    while d is not None :
    INDENT
        d.leader = newleader
        d = d.next
    DEDENT
    newleader.last.next = oldleader
    newleader.last = oldleader.last
    oldleader.size = 0
    oldleader.last = None
DEDENT
----------------------------------------

def union(self, leader1, leader2) :
INDENT
    rank1 = self.rank.get(leader1, 1)
    rank2 = self.rank.get(leader2, 1)
    if rank1 > rank2 :
    INDENT
        self.parent [leader2] = leader1
    DEDENT
    elif rank2 > rank1 :
    INDENT
        self.parent [leader1] = leader2
    DEDENT
    else :
    INDENT
        self.parent [leader2] = leader1
        self.rank [leader1] = rank1 + 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401738_1_24
1401721_1401852_3_20
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(input_list, groups) :
INDENT
    indices = dict((group, {}) for group in groups)
    output = []

    for row in input_list :
    INDENT
        newrow = []
        for group, element in zip(groups, row) :
        INDENT
            if element in indices [group] :
            INDENT
                index = indices [group] [element]
            DEDENT
            else :
            INDENT
                index = indices [group] [element] = len(indices [group])
            DEDENT
            newrow.append(index)
        DEDENT
        output.append(newrow)

    DEDENT
    lookup_dict = {}
    for group in indices :
    INDENT
        lookup_dict [group] = sorted(indices [group].keys(),
            lambda e1, e2 : indices [group] [e1] - indices [group] [e2])
    DEDENT
    return output, lookup_dict
DEDENT
----------------------------------------

def create_lookup_list(messages, labels) :
INDENT
    lookup = collections.defaultdict(set)
    for msg in messages :
    INDENT
        for l, v in zip(labels, msg) :
        INDENT
            lookup [l].add(v)

        DEDENT
    DEDENT
    for k, v in lookup.items() :
    INDENT
        lookup [k] = list(v)

    DEDENT
    lookup_list = []
    for msg in messages :
    INDENT
        lookup_list.append([lookup [l].index(v) for l, v in zip(labels, msg)])
    DEDENT
    return lookup_list, lookup
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401738_1_24
1401721_1401862_1_13
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(input_list, groups) :
INDENT
    indices = dict((group, {}) for group in groups)
    output = []

    for row in input_list :
    INDENT
        newrow = []
        for group, element in zip(groups, row) :
        INDENT
            if element in indices [group] :
            INDENT
                index = indices [group] [element]
            DEDENT
            else :
            INDENT
                index = indices [group] [element] = len(indices [group])
            DEDENT
            newrow.append(index)
        DEDENT
        output.append(newrow)

    DEDENT
    lookup_dict = {}
    for group in indices :
    INDENT
        lookup_dict [group] = sorted(indices [group].keys(),
            lambda e1, e2 : indices [group] [e1] - indices [group] [e2])
    DEDENT
    return output, lookup_dict
DEDENT
----------------------------------------

def create_lookup_list(data, keys) :
INDENT
    encoded = []
    table = dict([(key, []) for key in keys])
    for record in data :
    INDENT
        msg_int = []
        for key, value in zip(keys, record) :
        INDENT
            if value not in table [key] :
            INDENT
                table [key].append(value)
            DEDENT
            msg_int.append(table [key].index(value))
        DEDENT
        encoded.append(tuple(msg_int))
    DEDENT
    return encoded, table
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401738_1_24
1401721_1401890_3_14
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(input_list, groups) :
INDENT
    indices = dict((group, {}) for group in groups)
    output = []

    for row in input_list :
    INDENT
        newrow = []
        for group, element in zip(groups, row) :
        INDENT
            if element in indices [group] :
            INDENT
                index = indices [group] [element]
            DEDENT
            else :
            INDENT
                index = indices [group] [element] = len(indices [group])
            DEDENT
            newrow.append(index)
        DEDENT
        output.append(newrow)

    DEDENT
    lookup_dict = {}
    for group in indices :
    INDENT
        lookup_dict [group] = sorted(indices [group].keys(),
            lambda e1, e2 : indices [group] [e1] - indices [group] [e2])
    DEDENT
    return output, lookup_dict
DEDENT
----------------------------------------

def create_lookup_list(messages, schema) :
INDENT
    def mapped_rows(messages) :
    INDENT
        for row in messages :
        INDENT
            newRow = []
            for col, value in zip(schema, row) :
            INDENT
                if value not in lookups [col] :
                INDENT
                    lookups [col].append(value)
                DEDENT
                code = lookups [col].index(value)
                newRow.append(code)
            DEDENT
            yield newRow
        DEDENT
    DEDENT
    lookups = defaultdict(list)
    return list(mapped_rows(messages)), dict(lookups)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401738_1_24
1401721_1402043_1_15
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(input_list, groups) :
INDENT
    indices = dict((group, {}) for group in groups)
    output = []

    for row in input_list :
    INDENT
        newrow = []
        for group, element in zip(groups, row) :
        INDENT
            if element in indices [group] :
            INDENT
                index = indices [group] [element]
            DEDENT
            else :
            INDENT
                index = indices [group] [element] = len(indices [group])
            DEDENT
            newrow.append(index)
        DEDENT
        output.append(newrow)

    DEDENT
    lookup_dict = {}
    for group in indices :
    INDENT
        lookup_dict [group] = sorted(indices [group].keys(),
            lambda e1, e2 : indices [group] [e1] - indices [group] [e2])
    DEDENT
    return output, lookup_dict
DEDENT
----------------------------------------

def create_lookup_list(data, format) :
INDENT
    table = {}
    indices = []
    def get_index(item, form) :
    INDENT
        row = table.setdefault(form, [])
        try :
        INDENT
            return row.index(item)
        DEDENT
        except ValueError :
        INDENT
            n = len(row)
            row.append(item)
            return n
        DEDENT
    DEDENT
    for row in data :
    INDENT
        indices.append(tuple(get_index(item, form) for item, form in zip(row, format)))
    DEDENT
    return table, indices
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401738_1_24
1401721_1402381_4_10
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(input_list, groups) :
INDENT
    indices = dict((group, {}) for group in groups)
    output = []

    for row in input_list :
    INDENT
        newrow = []
        for group, element in zip(groups, row) :
        INDENT
            if element in indices [group] :
            INDENT
                index = indices [group] [element]
            DEDENT
            else :
            INDENT
                index = indices [group] [element] = len(indices [group])
            DEDENT
            newrow.append(index)
        DEDENT
        output.append(newrow)

    DEDENT
    lookup_dict = {}
    for group in indices :
    INDENT
        lookup_dict [group] = sorted(indices [group].keys(),
            lambda e1, e2 : indices [group] [e1] - indices [group] [e2])
    DEDENT
    return output, lookup_dict
DEDENT
----------------------------------------

def create_lookup_list(data, domains) :
INDENT
    domain_keys = defaultdict(lambda : defaultdict(count().next))
    out = []
    for row in data :
    INDENT
        out.append(tuple(domain_keys [dom] [val] for val, dom in zip(row, domains)))
    DEDENT
    lookup_table = dict((k, sorted(d, key = d.get)) for k, d in domain_keys.items())
    return out, lookup_table
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401852_3_20
1401721_1401862_1_13
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(messages, labels) :
INDENT
    lookup = collections.defaultdict(set)
    for msg in messages :
    INDENT
        for l, v in zip(labels, msg) :
        INDENT
            lookup [l].add(v)

        DEDENT
    DEDENT
    for k, v in lookup.items() :
    INDENT
        lookup [k] = list(v)

    DEDENT
    lookup_list = []
    for msg in messages :
    INDENT
        lookup_list.append([lookup [l].index(v) for l, v in zip(labels, msg)])
    DEDENT
    return lookup_list, lookup
DEDENT
----------------------------------------

def create_lookup_list(data, keys) :
INDENT
    encoded = []
    table = dict([(key, []) for key in keys])
    for record in data :
    INDENT
        msg_int = []
        for key, value in zip(keys, record) :
        INDENT
            if value not in table [key] :
            INDENT
                table [key].append(value)
            DEDENT
            msg_int.append(table [key].index(value))
        DEDENT
        encoded.append(tuple(msg_int))
    DEDENT
    return encoded, table
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401852_3_20
1401721_1401890_3_14
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(messages, labels) :
INDENT
    lookup = collections.defaultdict(set)
    for msg in messages :
    INDENT
        for l, v in zip(labels, msg) :
        INDENT
            lookup [l].add(v)

        DEDENT
    DEDENT
    for k, v in lookup.items() :
    INDENT
        lookup [k] = list(v)

    DEDENT
    lookup_list = []
    for msg in messages :
    INDENT
        lookup_list.append([lookup [l].index(v) for l, v in zip(labels, msg)])
    DEDENT
    return lookup_list, lookup
DEDENT
----------------------------------------

def create_lookup_list(messages, schema) :
INDENT
    def mapped_rows(messages) :
    INDENT
        for row in messages :
        INDENT
            newRow = []
            for col, value in zip(schema, row) :
            INDENT
                if value not in lookups [col] :
                INDENT
                    lookups [col].append(value)
                DEDENT
                code = lookups [col].index(value)
                newRow.append(code)
            DEDENT
            yield newRow
        DEDENT
    DEDENT
    lookups = defaultdict(list)
    return list(mapped_rows(messages)), dict(lookups)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401852_3_20
1401721_1402043_1_15
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(messages, labels) :
INDENT
    lookup = collections.defaultdict(set)
    for msg in messages :
    INDENT
        for l, v in zip(labels, msg) :
        INDENT
            lookup [l].add(v)

        DEDENT
    DEDENT
    for k, v in lookup.items() :
    INDENT
        lookup [k] = list(v)

    DEDENT
    lookup_list = []
    for msg in messages :
    INDENT
        lookup_list.append([lookup [l].index(v) for l, v in zip(labels, msg)])
    DEDENT
    return lookup_list, lookup
DEDENT
----------------------------------------

def create_lookup_list(data, format) :
INDENT
    table = {}
    indices = []
    def get_index(item, form) :
    INDENT
        row = table.setdefault(form, [])
        try :
        INDENT
            return row.index(item)
        DEDENT
        except ValueError :
        INDENT
            n = len(row)
            row.append(item)
            return n
        DEDENT
    DEDENT
    for row in data :
    INDENT
        indices.append(tuple(get_index(item, form) for item, form in zip(row, format)))
    DEDENT
    return table, indices
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401852_3_20
1401721_1402381_4_10
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(messages, labels) :
INDENT
    lookup = collections.defaultdict(set)
    for msg in messages :
    INDENT
        for l, v in zip(labels, msg) :
        INDENT
            lookup [l].add(v)

        DEDENT
    DEDENT
    for k, v in lookup.items() :
    INDENT
        lookup [k] = list(v)

    DEDENT
    lookup_list = []
    for msg in messages :
    INDENT
        lookup_list.append([lookup [l].index(v) for l, v in zip(labels, msg)])
    DEDENT
    return lookup_list, lookup
DEDENT
----------------------------------------

def create_lookup_list(data, domains) :
INDENT
    domain_keys = defaultdict(lambda : defaultdict(count().next))
    out = []
    for row in data :
    INDENT
        out.append(tuple(domain_keys [dom] [val] for val, dom in zip(row, domains)))
    DEDENT
    lookup_table = dict((k, sorted(d, key = d.get)) for k, d in domain_keys.items())
    return out, lookup_table
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401862_1_13
1401721_1401890_3_14
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(data, keys) :
INDENT
    encoded = []
    table = dict([(key, []) for key in keys])
    for record in data :
    INDENT
        msg_int = []
        for key, value in zip(keys, record) :
        INDENT
            if value not in table [key] :
            INDENT
                table [key].append(value)
            DEDENT
            msg_int.append(table [key].index(value))
        DEDENT
        encoded.append(tuple(msg_int))
    DEDENT
    return encoded, table
DEDENT
----------------------------------------

def create_lookup_list(messages, schema) :
INDENT
    def mapped_rows(messages) :
    INDENT
        for row in messages :
        INDENT
            newRow = []
            for col, value in zip(schema, row) :
            INDENT
                if value not in lookups [col] :
                INDENT
                    lookups [col].append(value)
                DEDENT
                code = lookups [col].index(value)
                newRow.append(code)
            DEDENT
            yield newRow
        DEDENT
    DEDENT
    lookups = defaultdict(list)
    return list(mapped_rows(messages)), dict(lookups)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401862_1_13
1401721_1402043_1_15
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(data, keys) :
INDENT
    encoded = []
    table = dict([(key, []) for key in keys])
    for record in data :
    INDENT
        msg_int = []
        for key, value in zip(keys, record) :
        INDENT
            if value not in table [key] :
            INDENT
                table [key].append(value)
            DEDENT
            msg_int.append(table [key].index(value))
        DEDENT
        encoded.append(tuple(msg_int))
    DEDENT
    return encoded, table
DEDENT
----------------------------------------

def create_lookup_list(data, format) :
INDENT
    table = {}
    indices = []
    def get_index(item, form) :
    INDENT
        row = table.setdefault(form, [])
        try :
        INDENT
            return row.index(item)
        DEDENT
        except ValueError :
        INDENT
            n = len(row)
            row.append(item)
            return n
        DEDENT
    DEDENT
    for row in data :
    INDENT
        indices.append(tuple(get_index(item, form) for item, form in zip(row, format)))
    DEDENT
    return table, indices
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401862_1_13
1401721_1402381_4_10
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(data, keys) :
INDENT
    encoded = []
    table = dict([(key, []) for key in keys])
    for record in data :
    INDENT
        msg_int = []
        for key, value in zip(keys, record) :
        INDENT
            if value not in table [key] :
            INDENT
                table [key].append(value)
            DEDENT
            msg_int.append(table [key].index(value))
        DEDENT
        encoded.append(tuple(msg_int))
    DEDENT
    return encoded, table
DEDENT
----------------------------------------

def create_lookup_list(data, domains) :
INDENT
    domain_keys = defaultdict(lambda : defaultdict(count().next))
    out = []
    for row in data :
    INDENT
        out.append(tuple(domain_keys [dom] [val] for val, dom in zip(row, domains)))
    DEDENT
    lookup_table = dict((k, sorted(d, key = d.get)) for k, d in domain_keys.items())
    return out, lookup_table
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401890_3_14
1401721_1402043_1_15
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(messages, schema) :
INDENT
    def mapped_rows(messages) :
    INDENT
        for row in messages :
        INDENT
            newRow = []
            for col, value in zip(schema, row) :
            INDENT
                if value not in lookups [col] :
                INDENT
                    lookups [col].append(value)
                DEDENT
                code = lookups [col].index(value)
                newRow.append(code)
            DEDENT
            yield newRow
        DEDENT
    DEDENT
    lookups = defaultdict(list)
    return list(mapped_rows(messages)), dict(lookups)
DEDENT
----------------------------------------

def create_lookup_list(data, format) :
INDENT
    table = {}
    indices = []
    def get_index(item, form) :
    INDENT
        row = table.setdefault(form, [])
        try :
        INDENT
            return row.index(item)
        DEDENT
        except ValueError :
        INDENT
            n = len(row)
            row.append(item)
            return n
        DEDENT
    DEDENT
    for row in data :
    INDENT
        indices.append(tuple(get_index(item, form) for item, form in zip(row, format)))
    DEDENT
    return table, indices
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1401890_3_14
1401721_1402381_4_10
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(messages, schema) :
INDENT
    def mapped_rows(messages) :
    INDENT
        for row in messages :
        INDENT
            newRow = []
            for col, value in zip(schema, row) :
            INDENT
                if value not in lookups [col] :
                INDENT
                    lookups [col].append(value)
                DEDENT
                code = lookups [col].index(value)
                newRow.append(code)
            DEDENT
            yield newRow
        DEDENT
    DEDENT
    lookups = defaultdict(list)
    return list(mapped_rows(messages)), dict(lookups)
DEDENT
----------------------------------------

def create_lookup_list(data, domains) :
INDENT
    domain_keys = defaultdict(lambda : defaultdict(count().next))
    out = []
    for row in data :
    INDENT
        out.append(tuple(domain_keys [dom] [val] for val, dom in zip(row, domains)))
    DEDENT
    lookup_table = dict((k, sorted(d, key = d.get)) for k, d in domain_keys.items())
    return out, lookup_table
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1401721_1402043_1_15
1401721_1402381_4_10
Title: Convert list of objects to a list of integers and a lookup table 
----------------------------------------

def create_lookup_list(data, format) :
INDENT
    table = {}
    indices = []
    def get_index(item, form) :
    INDENT
        row = table.setdefault(form, [])
        try :
        INDENT
            return row.index(item)
        DEDENT
        except ValueError :
        INDENT
            n = len(row)
            row.append(item)
            return n
        DEDENT
    DEDENT
    for row in data :
    INDENT
        indices.append(tuple(get_index(item, form) for item, form in zip(row, format)))
    DEDENT
    return table, indices
DEDENT
----------------------------------------

def create_lookup_list(data, domains) :
INDENT
    domain_keys = defaultdict(lambda : defaultdict(count().next))
    out = []
    for row in data :
    INDENT
        out.append(tuple(domain_keys [dom] [val] for val, dom in zip(row, domains)))
    DEDENT
    lookup_table = dict((k, sorted(d, key = d.get)) for k, d in domain_keys.items())
    return out, lookup_table
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14019468_14024064_34_44
14019468_14024064_9_20
Title: PyQT4 and tiles animation 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtGui.QWidget.__init__(self, parent)
    self.resize(100, 100)
    layout = QtGui.QVBoxLayout(self)
    label = QtGui.QLabel()
    layout.addWidget(label)
    self.animation = SpriteAnimation('star-green.png', 80, 80, label)
    self.animation.play()

DEDENT
----------------------------------------

def __init__(self, image_path, sprite_width, sprite_height, label) :
INDENT
    pixmap = QtGui.QPixmap(image_path)
    width, height = pixmap.width(), pixmap.height()
    self.pixmaps = []
    for x in range(0, width, sprite_width) :
    INDENT
        for y in range(0, height, sprite_height) :
        INDENT
            self.pixmaps.append(pixmap.copy(x, y,
                    sprite_width, sprite_height))
        DEDENT
    DEDENT
    self._current_frame = 0
    self.label = label
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14044147_14044210_29_48
14044147_42013186_103_137
Title: Animated sprite from few images 
----------------------------------------

def main() :
INDENT
    pygame.init()
    screen = pygame.display.set_mode((250, 250))
    my_sprite = TestSprite()
    my_group = pygame.sprite.Group(my_sprite)
    while True :
    INDENT
        event = pygame.event.poll()
        if event.type == pygame.QUIT :
        INDENT
            pygame.quit()
            sys.exit(0)

        DEDENT
        my_group.update()
        my_group.draw(screen)
        pygame.display.flip()
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    images = load_images(path = 'temp')
    player = AnimatedSprite(position = (100, 100), images = images)
    all_sprites = pygame.sprite.Group(player)
    running = True
    while running :
    INDENT

        dt = clock.tick(FPS) / 1000
        for event in pygame.event.get() :
        INDENT
            if event.type == pygame.QUIT :
            INDENT
                running = False
            DEDENT
            elif event.type == pygame.KEYDOWN :
            INDENT
                if event.key == pygame.K_RIGHT :
                INDENT
                    player.velocity.x = 4
                DEDENT
                elif event.key == pygame.K_LEFT :
                INDENT
                    player.velocity.x = - 4
                DEDENT
                elif event.key == pygame.K_DOWN :
                INDENT
                    player.velocity.y = 4
                DEDENT
                elif event.key == pygame.K_UP :
                INDENT
                    player.velocity.y = - 4
                DEDENT
            DEDENT
            elif event.type == pygame.KEYUP :
            INDENT
                if event.key == pygame.K_RIGHT or event.key == pygame.K_LEFT :
                INDENT
                    player.velocity.x = 0
                DEDENT
                elif event.key == pygame.K_DOWN or event.key == pygame.K_UP :
                INDENT
                    player.velocity.y = 0
                DEDENT
            DEDENT
        DEDENT
        all_sprites.update(dt)
        screen.fill(BACKGROUND_COLOR)
        all_sprites.draw(screen)
        pygame.display.update()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14044147_14044210_9_19
14044147_42013186_32_58
Title: Animated sprite from few images 
----------------------------------------

def __init__(self) :
INDENT
    super(TestSprite, self).__init__()
    self.images = []
    self.images.append(load_image('image1.png'))
    self.images.append(load_image('image2.png'))

    self.index = 0
    self.image = self.images [self.index]
    self.rect = pygame.Rect(5, 5, 64, 64)
DEDENT
----------------------------------------

def __init__(self, position, images) :
INDENT
    super(AnimatedSprite, self).__init__()
    size = (32, 32)
    self.rect = pygame.Rect(position, size)
    self.images = images
    self.images_right = images
    self.images_left = [pygame.transform.flip(image, True, False) for image in images]
    self.index = 0
    self.image = images [self.index]
    self.velocity = pygame.math.Vector2(0, 0)
    self.animation_time = 0.1
    self.current_time = 0
    self.animation_frames = 6
    self.current_frame = 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14090353_14091797_33_45
14090353_14091797_58_71
Title: Sending messages between two widgets using Signals and Slots 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(widgetA, self).__init__(parent)
    self.lineEdit = QtGui.QLineEdit(self)
    self.lineEdit.setText("Hello!")
    self.button = QtGui.QPushButton("Send Message to B", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.layout = QtGui.QHBoxLayout(self)
    self.layout.addWidget(self.lineEdit)
    self.layout.addWidget(self.button)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(mainwindow, self).__init__(parent)
    self.button = QtGui.QPushButton("Click Me", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.setCentralWidget(self.button)
    self.widgetA = widgetA()
    self.widgetB = widgetB()
    self.widgetA.procStart.connect(self.widgetB.on_procStart)
    self.widgetB.procDone.connect(self.widgetA.on_widgetB_procDone)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14090353_14091797_33_45
14090353_41662354_58_71
Title: Sending messages between two widgets using Signals and Slots 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(widgetA, self).__init__(parent)
    self.lineEdit = QtGui.QLineEdit(self)
    self.lineEdit.setText("Hello!")
    self.button = QtGui.QPushButton("Send Message to B", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.layout = QtGui.QHBoxLayout(self)
    self.layout.addWidget(self.lineEdit)
    self.layout.addWidget(self.button)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(mainwindow, self).__init__(parent)
    self.button = QtWidgets.QPushButton("Click Me", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.setCentralWidget(self.button)
    self.widgetA = widgetA()
    self.widgetB = widgetB()
    self.widgetA.procStart.connect(self.widgetB.on_procStart)
    self.widgetB.procDone.connect(self.widgetA.on_widgetB_procDone)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14090353_14091797_58_71
14090353_14091797_9_19
Title: Sending messages between two widgets using Signals and Slots 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(mainwindow, self).__init__(parent)
    self.button = QtGui.QPushButton("Click Me", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.setCentralWidget(self.button)
    self.widgetA = widgetA()
    self.widgetB = widgetB()
    self.widgetA.procStart.connect(self.widgetB.on_procStart)
    self.widgetB.procDone.connect(self.widgetA.on_widgetB_procDone)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(widgetB, self).__init__(parent)
    self.lineEdit = QtGui.QLineEdit(self)
    self.button = QtGui.QPushButton("Send Message to A", self)
    self.layout = QtGui.QHBoxLayout(self)
    self.layout.addWidget(self.lineEdit)
    self.layout.addWidget(self.button)
    self.button.clicked.connect(self.on_button_clicked)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14090353_14091797_58_71
14090353_41662354_33_45
Title: Sending messages between two widgets using Signals and Slots 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(mainwindow, self).__init__(parent)
    self.button = QtGui.QPushButton("Click Me", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.setCentralWidget(self.button)
    self.widgetA = widgetA()
    self.widgetB = widgetB()
    self.widgetA.procStart.connect(self.widgetB.on_procStart)
    self.widgetB.procDone.connect(self.widgetA.on_widgetB_procDone)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(widgetA, self).__init__(parent)
    self.lineEdit = QtWidgets.QLineEdit(self)
    self.lineEdit.setText("Hello!")
    self.button = QtWidgets.QPushButton("Send Message to B", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.layout = QtWidgets.QHBoxLayout(self)
    self.layout.addWidget(self.lineEdit)
    self.layout.addWidget(self.button)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14090353_14091797_58_71
14090353_41662354_8_18
Title: Sending messages between two widgets using Signals and Slots 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(mainwindow, self).__init__(parent)
    self.button = QtGui.QPushButton("Click Me", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.setCentralWidget(self.button)
    self.widgetA = widgetA()
    self.widgetB = widgetB()
    self.widgetA.procStart.connect(self.widgetB.on_procStart)
    self.widgetB.procDone.connect(self.widgetA.on_widgetB_procDone)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(widgetB, self).__init__(parent)
    self.lineEdit = QtWidgets.QLineEdit(self)
    self.button = QtWidgets.QPushButton("Send Message to A", self)
    self.layout = QtWidgets.QHBoxLayout(self)
    self.layout.addWidget(self.lineEdit)
    self.layout.addWidget(self.button)
    self.button.clicked.connect(self.on_button_clicked)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14090353_14091797_9_19
14090353_41662354_58_71
Title: Sending messages between two widgets using Signals and Slots 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(widgetB, self).__init__(parent)
    self.lineEdit = QtGui.QLineEdit(self)
    self.button = QtGui.QPushButton("Send Message to A", self)
    self.layout = QtGui.QHBoxLayout(self)
    self.layout.addWidget(self.lineEdit)
    self.layout.addWidget(self.button)
    self.button.clicked.connect(self.on_button_clicked)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(mainwindow, self).__init__(parent)
    self.button = QtWidgets.QPushButton("Click Me", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.setCentralWidget(self.button)
    self.widgetA = widgetA()
    self.widgetB = widgetB()
    self.widgetA.procStart.connect(self.widgetB.on_procStart)
    self.widgetB.procDone.connect(self.widgetA.on_widgetB_procDone)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14090353_41662354_33_45
14090353_41662354_58_71
Title: Sending messages between two widgets using Signals and Slots 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(widgetA, self).__init__(parent)
    self.lineEdit = QtWidgets.QLineEdit(self)
    self.lineEdit.setText("Hello!")
    self.button = QtWidgets.QPushButton("Send Message to B", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.layout = QtWidgets.QHBoxLayout(self)
    self.layout.addWidget(self.lineEdit)
    self.layout.addWidget(self.button)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(mainwindow, self).__init__(parent)
    self.button = QtWidgets.QPushButton("Click Me", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.setCentralWidget(self.button)
    self.widgetA = widgetA()
    self.widgetB = widgetB()
    self.widgetA.procStart.connect(self.widgetB.on_procStart)
    self.widgetB.procDone.connect(self.widgetA.on_widgetB_procDone)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14090353_41662354_58_71
14090353_41662354_8_18
Title: Sending messages between two widgets using Signals and Slots 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(mainwindow, self).__init__(parent)
    self.button = QtWidgets.QPushButton("Click Me", self)
    self.button.clicked.connect(self.on_button_clicked)
    self.setCentralWidget(self.button)
    self.widgetA = widgetA()
    self.widgetB = widgetB()
    self.widgetA.procStart.connect(self.widgetB.on_procStart)
    self.widgetB.procDone.connect(self.widgetA.on_widgetB_procDone)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(widgetB, self).__init__(parent)
    self.lineEdit = QtWidgets.QLineEdit(self)
    self.button = QtWidgets.QPushButton("Send Message to A", self)
    self.layout = QtWidgets.QHBoxLayout(self)
    self.layout.addWidget(self.lineEdit)
    self.layout.addWidget(self.button)
    self.button.clicked.connect(self.on_button_clicked)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14123592_14125649_22_32
14123592_14125649_3_12
Title: Implementing signal handling on a sleep loop 
----------------------------------------

def __new__(cls, sig, action) :
INDENT
    if isinstance(action, SignalHandler) :
    INDENT
        handler = action
    DEDENT
    else :
    INDENT
        handler = super(SignalHandler, cls).__new__(cls)
        handler.action = action
        handler.blocking_actions = []
    DEDENT
    signal.signal(sig, handler)
    return handler
DEDENT
----------------------------------------

def __new__(cls, action) :
INDENT
    if isinstance(action, BlockingAction) :
    INDENT
        return action
    DEDENT
    else :
    INDENT
        new_action = super(BlockingAction, cls).__new__(cls)
        new_action.action = action
        new_action.active = False
        return new_action
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14140495_37209305_100_110
14140495_37209305_28_55
Title: "How to capture a video (AND audio) in python from a camera (or webcam)" 
----------------------------------------

def record(self) :
INDENT
    self.stream.start_stream()
    while (self.open == True) :
    INDENT
        data = self.stream.read(self.frames_per_buffer)
        self.audio_frames.append(data)
        if self.open == False :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def record(self) :
INDENT
    timer_start = time.time()
    timer_current = 0

    while (self.open == True) :
    INDENT
        ret, video_frame = self.video_cap.read()
        if (ret == True) :
        INDENT

            self.video_out.write(video_frame)
            self.frame_counts += 1

            time.sleep(0.16)

        DEDENT
        else :
        INDENT
            break
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14140495_37209305_111_127
14140495_37209305_56_69
Title: "How to capture a video (AND audio) in python from a camera (or webcam)" 
----------------------------------------

def stop(self) :
INDENT
    if self.open == True :
    INDENT
        self.open = False
        self.stream.stop_stream()
        self.stream.close()
        self.audio.terminate()
        waveFile = wave.open(self.audio_filename, 'wb')
        waveFile.setnchannels(self.channels)
        waveFile.setsampwidth(self.audio.get_sample_size(self.format))
        waveFile.setframerate(self.rate)
        waveFile.writeframes(b''.join(self.audio_frames))
        waveFile.close()
    DEDENT
    pass
DEDENT
----------------------------------------

def stop(self) :
INDENT
    if self.open == True :
    INDENT

        self.open = False
        self.video_out.release()
        self.video_cap.release()
        cv2.destroyAllWindows()
    DEDENT
    else :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14140495_37209305_12_27
14140495_37209305_82_99
Title: "How to capture a video (AND audio) in python from a camera (or webcam)" 
----------------------------------------

def __init__(self) :
INDENT
    self.open = True
    self.device_index = 0
    self.fps = 6
    self.fourcc = "MJPG"
    self.frameSize = (640, 480)
    self.video_filename = "temp_video.avi"
    self.video_cap = cv2.VideoCapture(self.device_index)
    self.video_writer = cv2.VideoWriter_fourcc(* self.fourcc)
    self.video_out = cv2.VideoWriter(self.video_filename, self.video_writer, self.fps, self.frameSize)
    self.frame_counts = 1
    self.start_time = time.time()

DEDENT
----------------------------------------

def __init__(self) :
INDENT
    self.open = True
    self.rate = 44100
    self.frames_per_buffer = 1024
    self.channels = 2
    self.format = pyaudio.paInt16
    self.audio_filename = "temp_audio.wav"
    self.audio = pyaudio.PyAudio()
    self.stream = self.audio.open(format = self.format,
        channels = self.channels,
        rate = self.rate,
        input = True,
        frames_per_buffer = self.frames_per_buffer)
    self.audio_frames = []

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1414581_1415182_1_13
1414581_1415324_1_12
Title: Python recursive program to prime factorize a number 
----------------------------------------

def prime_factorize(number) :
INDENT
    def recurse(factors, x, n) :
    INDENT
        if x < 2 : return factors
        if n > 1 + x ** 0.5 :
        INDENT
            factors.append(x)
            return factors
        DEDENT
        if x % n == 0 :
        INDENT
            factors.append(n)
            return recurse(factors, x / n, n)
        DEDENT
        else :
        INDENT
            return recurse(factors, x, n + 1)
        DEDENT
    DEDENT
    return recurse([], number, 2)
DEDENT
----------------------------------------

def prime_factorize(x) :
INDENT
    li = []
    while x > = 2 :
    INDENT
        until = int(math.sqrt(x)) + 1
        for i in xrange(2, until) :
        INDENT
            if not x % i :
            INDENT
                li.append(i)
                break
            DEDENT
        DEDENT
        else :
        INDENT
            li.append(x)
            return li
        DEDENT
        x //= i
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14148263_14151217_11_21
14148263_14151217_42_70
Title: "print cookies from QNetworkCookie PyQt4" 
----------------------------------------

def __init__(self, cookiesKey, parent = None) :
INDENT
    super(cookieJar, self).__init__(parent)
    self.mainWindow = parent
    self.cookiesKey = cookiesKey
    cookiesValue = self.mainWindow.settings.value(self.cookiesKey)
    if cookiesValue :
    INDENT
        cookiesList = QtNetwork.QNetworkCookie.parseCookies(cookiesValue)
        self.setAllCookies(cookiesList)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(myWindow, self).__init__(parent)
    self.cookiesKey = "cookies"
    self.centralwidget = QtGui.QWidget(self)
    self.tabWidget = QtGui.QTabWidget(self.centralwidget)
    self.tabWidget.setTabsClosable(True)
    self.verticalLayout = QtGui.QVBoxLayout(self.centralwidget)
    self.verticalLayout.addWidget(self.tabWidget)
    self.actionTabAdd = QtGui.QAction(self)
    self.actionTabAdd.setText("Add Tab")
    self.actionTabAdd.triggered.connect(self.on_actionTabAdd_triggered)
    self.lineEdit = QtGui.QLineEdit(self)
    self.lineEdit.setText("http://www.example.com")
    self.toolBar = QtGui.QToolBar(self)
    self.toolBar.addAction(self.actionTabAdd)
    self.toolBar.addWidget(self.lineEdit)
    self.addToolBar(QtCore.Qt.ToolBarArea(QtCore.Qt.TopToolBarArea), self.toolBar)
    self.setCentralWidget(self.tabWidget)
    self.settings = QtCore.QSettings()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14200721_14205494_64_81
14200721_14205494_8_18
Title: How to create a menu and submenus in Python curses? 
----------------------------------------

def __init__(self, stdscreen) :
INDENT
    self.screen = stdscreen
    curses.curs_set(0)
    submenu_items = [
        ('beep', curses.beep),
        ('flash', curses.flash)]
    submenu = Menu(submenu_items, self.screen)
    main_menu_items = [
        ('beep', curses.beep),
        ('flash', curses.flash),
        ('submenu', submenu.display)]
    main_menu = Menu(main_menu_items, self.screen)
    main_menu.display()
DEDENT
----------------------------------------

def __init__(self, items, stdscreen) :
INDENT
    self.window = stdscreen.subwin(0, 0)
    self.window.keypad(1)
    self.panel = panel.new_panel(self.window)
    self.panel.hide()
    panel.update_panels()
    self.position = 0
    self.items = items
    self.items.append(('exit', 'exit'))
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14215047_14215387_35_42
14215047_14215816_7_23
Title: What to do with thread being about to terminate? 
----------------------------------------

def run_in_background(self, callback, period = 0.5) :
INDENT
    if len([w for w in self.workers if not w.stopping]) > 0 :
    INDENT
        raise RuntimeError()
    DEDENT
    worker = Worker(callback, period, finished_callback = self.dispose)
    with self.workers_lock :
    INDENT
        self.workers.append(worker)
    DEDENT
    worker.start()
DEDENT
----------------------------------------

def run_in_background(self, callback, period = 0.5) :
INDENT
    if self.thread :
    INDENT
        raise RuntimeError
    DEDENT
    def worker(exit_condition) :
    INDENT
        exit_condition.acquire()
        worker.running = True
        while worker.running :
        INDENT
            if some_event() :
            INDENT
                callback(self)
            DEDENT
            exit_condition.wait(period)
        DEDENT
        exit_condition.release()
    DEDENT
    self.thread = (threading.Thread(target = worker, args = (self.exit_condition,)),
        worker)
    self.thread [0].start()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14215047_14215387_43_51
14215047_14215816_24_35
Title: What to do with thread being about to terminate? 
----------------------------------------

def stop_background(self, join = False) :
INDENT
    if len(self.workers) == 0 :
    INDENT
        raise RuntimeError()
    DEDENT
    for worker in self.workers :
    INDENT
        worker.request_stop()
    DEDENT
    if join :
    INDENT
        for worker in self.workers :
        INDENT
            worker.join()
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def stop_background(self) :
INDENT
    if not self.thread :
    INDENT
        raise RuntimeError
    DEDENT
    self.exit_condition.acquire()
    self.thread [1].running = False
    self.exit_condition.notify()
    self.exit_condition.release()
    self.thread [0].join()
    self.thread = None
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14217667_14218685_4_11
14217667_14481953_4_19
Title: Getting a fraction approximation from a list 
----------------------------------------

def searchratio(input_range) :
INDENT
    my_ratios = set()
    for x in itertools.combinations(input_range, 2) :
    INDENT
        y = x [0] / x [1]
        if y == 1 / 10 or (10 / 1 > y > 34561 / 43521) :
        INDENT
            my_ratios.add(x)
        DEDENT
    DEDENT
    return my_ratios
DEDENT
----------------------------------------

def searchratio(t, n, d) :
INDENT
    b = []
    a = float(n) / d
    t0 = t [0]
    x1 = bisect.bisect(t, t0 / a)
    print a, x1, t0
    lm = len(t) - 2
    for ti in t [x1 : lm] :
    INDENT
        x1 = bisect.bisect_left(t, ti * a)
        b.append([t [x1], ti])
        b.append([t [x1 + 1], ti])
    DEDENT
    b.sort(key = lambda x : abs(x [0] / float(x [1]) - a))
    return b

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14220557_14234514_22_36
14220557_14234514_7_12
Title: Can I expand a single string with the union of several regular expressions in python? 
----------------------------------------

def __init__(self, matches, re_pattern) :
INDENT
    self.groupindex = dict()
    offset = 0
    for p, m in zip(re_pattern, matches) :
    INDENT
        for k, v in sre_parse.parse(p).pattern.groupdict.iteritems() :
        INDENT
            self.groupindex [k] = v + offset
        DEDENT
        offset += len(m.groups())

    DEDENT
DEDENT
----------------------------------------

def __init__(self, matches) :
INDENT
    self.data = []
    for m in matches :
    INDENT
        self.data.extend(m.groups())
    DEDENT
    self.string = ""
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14236830_14241258_34_45
14236830_14241258_7_23
Title: How to re-display a QDialog after hiding it? 
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(myWindow, self).__init__(parent)
    self.buttonShow = QtGui.QPushButton(self)
    self.buttonShow.setText("Show Dialog")
    self.buttonShow.clicked.connect(self.on_buttonShow_clicked)
    self.layout = QtGui.QVBoxLayout(self)
    self.layout.addWidget(self.buttonShow)
    self.dialog = myDialog(self)
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    super(myDialog, self).__init__(parent)
    self.dialog = None
    self.buttonShow = QtGui.QPushButton(self)
    self.buttonShow.setText("Show Dialog")
    self.buttonShow.clicked.connect(self.on_buttonShow_clicked)
    self.buttonHide = QtGui.QPushButton(self)
    self.buttonHide.setText("Close")
    self.buttonHide.clicked.connect(self.on_buttonHide_clicked)
    self.layout = QtGui.QVBoxLayout(self)
    self.layout.addWidget(self.buttonShow)
    self.layout.addWidget(self.buttonHide)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14247066_14247249_1_14
14247066_14247276_1_21
Title: When Does a While Loop Break 
----------------------------------------

def setWorkDays(dayNameList) :
INDENT
    while self.count > 0 :
    INDENT
        for day in dayNameList :
        INDENT
            if day in self.freeDays or day in self.alDays or (day == 'Saturday' and self.satOff is True) :
            INDENT
                continue
            DEDENT
            elif day in self.programDays :
            INDENT
                yield day
            DEDENT
            elif self.preferredDay is not None and day in self.preferredDay :
            INDENT
                continue
            DEDENT
            else :
            INDENT
                yield day
            DEDENT
        DEDENT
        if self.preferredDay not in self.workDays :
        INDENT
            yield day
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def setWorkDays(dayNameList) :
INDENT
    workDays = []
    for day in dayNameList :
    INDENT
        if day in self.freeDays or day in self.alDays or (
            day == 'Saturday' and self.satOff) :
        INDENT
            continue
        DEDENT
        elif day in self.programDays :
        INDENT
            workDays.append(day)
            self.count -= 1
        DEDENT
        elif self.preferredDay is not None and day in self.preferredDay :
        INDENT
            continue
        DEDENT
        else :
        INDENT
            workDays.append(day)
            self.count -= 1
        DEDENT
        if self.count < = 0 :
        INDENT
            break
        DEDENT
    DEDENT
    else :
    INDENT
        if self.preferredDay not in self.workDays :
        INDENT
            workDays.append(self.preferredDay)
            self.count -= 1
        DEDENT
    DEDENT
    return workDays
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14247918_14261124_3_20
14247918_14281904_21_33
Title: "How would I implement ""tail"" over HTTP with Python Tornado?" 
----------------------------------------

def get(self) :
INDENT
    self.file = open('data/to_read.txt', 'r')
    self.pos = self.file.tell()
    def _read_file() :
    INDENT
        line = self.file.read()
        last_pos = self.file.tell()
        if not line :
        INDENT
            self.file.close()
            self.file = open('data/to_read.txt', 'r')
            self.file.seek(last_pos)
            pass
        DEDENT
        else :
        INDENT
            self.write(line)
            self.flush()
        DEDENT
        IOLoop.instance().add_timeout(time.time() + 1, _read_file)
    DEDENT
    _read_file()
DEDENT
----------------------------------------

def get(self) :
INDENT
    print "GOT REQUEST"
    self.p = subprocess.Popen(
        ["tail", "-f", options.inputfile, "-n+1"],
        stdout = subprocess.PIPE)
    self.write("<pre>")
    self.write("Hello, world\n")
    self.flush()
    self.stream = tornado.iostream.PipeIOStream(self.p.stdout.fileno())
    self.stream.read_until("\n", self.line_from_nettail)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14354171_14357169_11_18
14354171_14357169_124_131
Title: Add scrolling to a platformer in pygame 
----------------------------------------

def __init__(self, target, world_size) :
INDENT
    super().__init__()
    self.target = target
    self.cam = pygame.Vector2(0, 0)
    self.world_size = world_size
    if self.target :
    INDENT
        self.add(target)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, platforms, pos, * groups) :
INDENT
    super().__init__(Color("#0000FF"), pos)
    self.vel = pygame.Vector2((0, 0))
    self.onGround = False
    self.platforms = platforms
    self.speed = 8
    self.jump_strength = 10
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14354171_14357169_132_166
14354171_14357169_19_27
Title: Add scrolling to a platformer in pygame 
----------------------------------------

def update(self) :
INDENT
    pressed = pygame.key.get_pressed()
    up = pressed [K_UP]
    left = pressed [K_LEFT]
    right = pressed [K_RIGHT]
    running = pressed [K_SPACE]
    if up :
    INDENT
        if self.onGround : self.vel.y = - self.jump_strength
    DEDENT
    if left :
    INDENT
        self.vel.x = - self.speed
    DEDENT
    if right :
    INDENT
        self.vel.x = self.speed
    DEDENT
    if running :
    INDENT
        self.vel.x *= 1.5
    DEDENT
    if not self.onGround :
    INDENT

        self.vel += GRAVITY
        if self.vel.y > 100 : self.vel.y = 100
    DEDENT
    print (self.vel.y)
    if not (left or right) :
    INDENT
        self.vel.x = 0
    DEDENT
    self.rect.left += self.vel.x
    self.collide(self.vel.x, 0, self.platforms)
    self.rect.top += self.vel.y
    self.onGround = False;
    self.collide(0, self.vel.y, self.platforms)
DEDENT
----------------------------------------

def update(self, * args) :
INDENT
    super().update(* args)
    if self.target :
    INDENT
        x = - self.target.rect.center [0] + SCREEN_SIZE.width / 2
        y = - self.target.rect.center [1] + SCREEN_SIZE.height / 2
        self.cam += (pygame.Vector2((x, y)) - self.cam) * 0.05
        self.cam.x = max(- (self.world_size.width - SCREEN_SIZE.width), min(0, self.cam.x))
        self.cam.y = max(- (self.world_size.height - SCREEN_SIZE.height), min(0, self.cam.y))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14359936_14360079_1_14
14359936_14374653_1_13
Title: How would you implement a divisor function? 
----------------------------------------

def divisor_function(n) :
INDENT
    "Returns the sum of divisors of n"
    checked = {}
    factors = prime_factors(n)
    sum_of_divisors = 1
    for x in factors :
    INDENT
        if checked.get(x, False) :
        INDENT
            continue
        DEDENT
        else :
        INDENT
            count = factors.count(x)
            tmp = (x ** (count + 1) - 1) / / (x - 1)
            sum_of_divisors *= tmp
            checked [x] = True
        DEDENT
    DEDENT
    return sum_of_divisors
DEDENT
----------------------------------------

def divisor_function(n) :
INDENT
    "Returns the sum of divisors of n"
    factors = prime_factors(n)
    sum_of_divisors = 1
    count = 0; prev = 0;
    for x in factors :
    INDENT
        if x == prev :
        INDENT
            count += 1
        DEDENT
        else :
        INDENT
            if prev : sum_of_divisors *= (prev ** (count + 1) - 1) / / (prev - 1)
            count = 1; prev = x;
        DEDENT
    DEDENT
    if prev : sum_of_divisors *= (prev ** (count + 1) - 1) / / (prev - 1)
    return sum_of_divisors
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14363791_14363882_1_14
14363791_14364016_1_10
Title: Reading and manipulating a file in python 
----------------------------------------

def ints(filename) :
INDENT
    a = []
    f = open(filename, "r")
    lines = f.readlines()
    f.close()
    for line in lines :
    INDENT
        for character in line :
        INDENT
            try :
            INDENT
                a.append(int(character))
            DEDENT
            except ValueError :
            INDENT
                pass
            DEDENT
        DEDENT
    DEDENT
    return a
DEDENT
----------------------------------------

def ints(filename) :
INDENT
    with open(filename, "r") as f :
    INDENT
        for line in f :
        INDENT
            for number in line.split() :
            INDENT
                try :
                INDENT
                    yield int(number)
                DEDENT
                except ValueError :
                INDENT
                    pass
                DEDENT
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14368400_14369192_20_25
14368400_14369192_34_43
Title: Advice on GUI timer to display background thread's elapsed time? 
----------------------------------------

def run(self) :
INDENT
    while self.parent().isRunning() :
    INDENT
        self.timeElapsed.emit(time.time() - self.timeStart)
        time.sleep(1)

    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    self.timerThread.start(time.time())
    iterations = 3
    while iterations :
    INDENT
        print "Running {0}".format(self.__class__.__name__)
        iterations -= 1
        time.sleep(2)

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14370083_14370186_1_16
14370083_14370311_1_18
Title: How to assign variables inside functions correctly / how to add 1 for every recursive loop? 
----------------------------------------

def lenRecur(aStr, recurse = False) :
INDENT
    if not recurse :
    INDENT
        lenRecur.number = 0
    DEDENT
    print "lenRecur number is ", lenRecur.number
    '''
    aStr: a string

    returns: int, the length of aStr
    '''
    if aStr == '' :
    INDENT
        return 0
    DEDENT
    else :
    INDENT
        print aStr
        lenRecur.number += 1
        print "else number is ", lenRecur.number
        return lenRecur(aStr [: - 1], True)
    DEDENT
DEDENT
----------------------------------------

def lenRecur(aStr) :
INDENT
    def lenRecurHelper(aStr, num = 0) :
    INDENT
        print "lenRecur number is ", number
        if not aStr :
        INDENT
            return num
        DEDENT
        print aStr
        lenRecurHelper(aStr [: - 1], num + 1)
    DEDENT
    return lenRecurHelper(aStr)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14402837_14403012_13_18
14402837_14403012_4_11
Title: Optional argument for each positional argument 
----------------------------------------

def __call__(self, parser, namespace, values, option_string = None) :
INDENT
    try :
    INDENT
        parser.last_positional_values.append(values)
    DEDENT
    except AttributeError :
    INDENT
        pass
    DEDENT
DEDENT
----------------------------------------

def __call__(self, parser, namespace, values, option_string = None) :
INDENT
    lst = getattr(namespace, self.dest)
    lst.append(values)
    parser.last_positional_values = lst
    all_positional = getattr(namespace, 'all_positional', [])
    all_positional.append(lst)
    namespace.all_positional = all_positional
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14430263_14430418_43_54
14430263_14430418_7_32
Title: creating subclass form class returning pandas dataFrame 
----------------------------------------

def __init__(self, frameType = 'All') :
INDENT
    myClass.__init__(self, frameType)
    def addingCol(cObject) :
    INDENT
        print 'CURRENT cObject \n%s' % cObject
        cObject ['average'] = cObject.mean(axis = 1)
        print 'THIS WORKS IN GENERAL\n%s' % str(cObject ['average'])
        return cObject
    DEDENT
    addingCol(self.cObject)
DEDENT
----------------------------------------

def __init__(self, frameType = 'All') :
INDENT
    def method1() :
    INDENT
        myFrame = pd.DataFrame(
            {'c1' : [1, 2, 3], 'c2' : [4, 5, 6], 'c3' : [7, 8, 9]})
        return myFrame
    DEDENT
    def method2() :
    INDENT
        myFrame = pd.DataFrame(
            {'c1' : [.1,.2,.3], 'c2' : [.4,.5,.6], 'c3' : [.7,.8,.9]})
        return myFrame
    DEDENT
    def makingChoice(self) :
    INDENT
        if self.frameType == 'All' :
        INDENT
            variable = method1() + method2()
        DEDENT
        elif self.frameType == 'a' :
        INDENT
            variable = method1()
        DEDENT
        elif self.frameType == 'b' :
        INDENT
            variable = method2()
        DEDENT
        else :
        INDENT
            variable = pd.DataFrame(
                {'c1' : [0, 0, 0], 'c2' : [0, 0, 0], 'c3' : [0, 0, 0]})
        DEDENT
        return variable
    DEDENT
    self.frameType = frameType
    self.cObject = makingChoice(self)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14436499_14436681_3_11
14436499_14437796_3_11
Title: saving top output using python 
----------------------------------------

def repeat() :
INDENT
    print (time.ctime())
    threading.Timer(10, repeat).start()
    f = open('ss.txt', 'w')
    top = os.system("sudo top -p 2948")
    s = str(top)
    text = f.write(s)
    print text
DEDENT
----------------------------------------

def repeat(seconds, filename) :
INDENT
    while True :
    INDENT
        print (time.ctime())
        f = open(filename, 'w')
        top = os.system("sudo top -p 2948")
        s = str(top)
        time.sleep(seconds)
        f.write(s)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14438928_14439273_1_17
14438928_14439300_1_11
Title: Python zip a sub folder and not the entire folder path 
----------------------------------------

def makeArchive(fileList, archive, path_prefix = None) :
INDENT
    try :
    INDENT
        a = zipfile.ZipFile(archive, 'w', zipfile.ZIP_DEFLATED)
        for f in fileList :
        INDENT
            print "archiving file %s" % (f)
            if path_prefix is None :
            INDENT
                a.write(f)
            DEDENT
            else :
            INDENT
                a.write(f, f [len(path_prefix) :] if f.startswith(path_prefix) else f)
            DEDENT
        DEDENT
        a.close()
        return True
    DEDENT
    except : return False
DEDENT
----------------------------------------

def makeArchive(fileList, archive, root) :
INDENT
    a = zipfile.ZipFile(archive, 'w', zipfile.ZIP_DEFLATED)
    for f in fileList :
    INDENT
        print "archiving file %s" % (f)
        a.write(f, os.path.relpath(f, root))
    DEDENT
    a.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14459993_25023944_15_26
14459993_39300853_19_43
Title: tkinter listbox drag and drop with python 
----------------------------------------

def shiftSelection(self, event) :
INDENT
    i = self.nearest(event.y)
    if i < self.curIndex :
    INDENT
        x = self.get(i)
        self.delete(i)
        self.insert(i + 1, x)
        self.curIndex = i
    DEDENT
    elif i > self.curIndex :
    INDENT
        x = self.get(i)
        self.delete(i)
        self.insert(i - 1, x)
        self.curIndex = i
    DEDENT
DEDENT
----------------------------------------

def shiftSelection(self, event) :
INDENT
    i = self.nearest(event.y)
    if self.curState == 1 :
    INDENT
        self.selection_set(self.curIndex)
    DEDENT
    else :
    INDENT
        self.selection_clear(self.curIndex)
    DEDENT
    if i < self.curIndex :
    INDENT

        x = self.get(i)
        selected = self.selection_includes(i)
        self.delete(i)
        self.insert(i + 1, x)
        if selected :
        INDENT
            self.selection_set(i + 1)
        DEDENT
        self.curIndex = i
    DEDENT
    elif i > self.curIndex :
    INDENT

        x = self.get(i)
        selected = self.selection_includes(i)
        self.delete(i)
        self.insert(i - 1, x)
        if selected :
        INDENT
            self.selection_set(i - 1)
        DEDENT
        self.curIndex = i
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14472849_14473540_1_10
14472849_14475975_26_35
Title: Deletion in wxpython's list control 
----------------------------------------

def OnButton(self, e) :
INDENT
    itemIndex = self.list.GetNextItem(itemIndex,
        wx.LIST_NEXT_ALL,
        wx.LIST_STATE_SELECTED);
    print itemIndex
    if itemIndex == - 1 :
    INDENT
        print "Nothing Selected";
        print "SELECTED:", self.list.GetItemText(itemIndex);
    DEDENT
DEDENT
----------------------------------------

def OnButton(self, e) :
INDENT
    current_items = self.list.GetItemCount() - 1
    while ((current_items) > = 0) :
    INDENT
        if (self.list.GetItemText(current_items) == "1" or self.list.GetItemText(current_items) == "2") :
        INDENT
            self.list.DeleteItem(current_items)
            wx.MessageBox("Delete item ", 'Delete Information', wx.OK)
        DEDENT
        else :
        INDENT
            break
        DEDENT
        current_items -= 1
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14493694_14493807_3_22
14493694_14493829_1_12
Title: How can I shorten this if statement? 
----------------------------------------

def direction(self, start, end) :
INDENT
    s_width, s_height, e_width, e_height = start [0], start [1], end [0], end [1]

    if s_height < e_height and s_width < e_width :
    INDENT
        return 'right'
    DEDENT
    elif s_height < e_height and s_width > e_width :
    INDENT
        return 'up'
    DEDENT
    elif s_height < e_height :
    INDENT
        return 'up_right'
    DEDENT
    elif s_height > e_height and s_width < e_width :
    INDENT
        return 'down'
    DEDENT
    elif s_height > e_height and s_width > e_width :
    INDENT
        return 'left'
    DEDENT
    elif s_height > e_height :
    INDENT
        return 'down_left'
    DEDENT
    elif s_height == e_height and s_width < e_width :
    INDENT
        return 'down_right'
    DEDENT
    else :
    INDENT
        return 'up_left'
    DEDENT
DEDENT
----------------------------------------

def direction(self, start, end) :
INDENT
    delta = (end [0] - start [0], end [1] - start [1])
    s = []
    if delta [1] > 0 : s.append("up")
    elif delta [1] < 0 : s.append("down")
    if delta [0] > 0 : s.append("right")
    elif delta [0] < 0 : s.append("left")
    return s
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14516873_14516917_1_13
14516873_14516925_1_12
Title: How do I test for exceptions in if-statements in python? 
----------------------------------------

def reporter(f, x) :
INDENT
    try :
    INDENT
        if f(x) :
        INDENT
            return "Generic"
        DEDENT
        return "No Problem"
    DEDENT
    except ValueError :
    INDENT
        return 'Value'
    DEDENT
    except TypeError :
    INDENT
        return 'Type'
    DEDENT
    except E2OddException :
    INDENT
        return 'E2Odd'
    DEDENT
DEDENT
----------------------------------------

def reporter(f, x) :
INDENT
    try :
    INDENT
        if f(x) is None :
        INDENT
            return 'no problem'
        DEDENT
        else :
        INDENT
            return 'generic'
        DEDENT
    DEDENT
    except ValueError :
    INDENT
        return 'Value'
    DEDENT
    except E2OddException :
    INDENT
        return 'E2Odd'
    DEDENT
    except E2Exception :
    INDENT
        return 'E2'
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14557431_14558101_1_17
14557431_14619468_1_21
Title: How to get the right values for mouse hold-and-drag boxing 
----------------------------------------

def mouseMotion(self, buttons, pos) :
INDENT
    if self.pressing == True :
    INDENT
        diffx = self.start [0] - pos [0]
        diffy = self.start [1] - pos [1]
        width = abs(self.start [0] - pos [0])
        height = abs(self.start [1] - pos [1])
        if diffx > = 0 :
        INDENT
            if diffy > = 0 :
            INDENT
                self.box = pygame.Rect(self.start, width, height)
            DEDENT
            else :
            INDENT
                self.box = pygame.Rect(self.start [0], pos [1], width, height)
            DEDENT
        DEDENT
        else :
        INDENT
            if diffy > = 0 :
            INDENT
                self.box = pygame.Rect(pos [0], self.start [1], width, height)
            DEDENT
            else :
            INDENT
                self.box = pygame.Rect(pos, width, height)
            DEDENT
        DEDENT
        pygame.draw.rect(self.screen, (0, 0, 0), self.box, 1)
    DEDENT
DEDENT
----------------------------------------

def mouseMotion(self, buttons, pos, rel) :
INDENT
    if self.pressing == True :
    INDENT
        diffx = self.start [0] - pos [0]
        diffy = self.start [1] - pos [1]
        width = abs(self.start [0] - pos [0])
        height = abs(self.start [1] - pos [1])
        if diffx > 0 and diffy > 0 :
        INDENT
            width = (width - (width * 2))
            height = (height - (height * 2))
        DEDENT
        elif diffx > 0 and diffy < = 0 :
        INDENT
            width = (width - (width * 2))
        DEDENT
        elif diffx < = 0 and diffy > 0 :
        INDENT
            height = (height - (height * 2))
        DEDENT
        elif diffx < 0 and diffy < 0 :
        INDENT
            pass
        DEDENT
        dimensions = (width, height)
        self.box = pygame.Rect(self.start, dimensions)
        pygame.draw.rect(self.screen, (0, 0, 0), self.box, 1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14566570_14569881_12_28
14566570_24606817_7_16
Title: How to use Flask-Script and Gunicorn 
----------------------------------------

def get_options(self) :
INDENT
    return (
        Option('-H', '--host',
            dest = 'host',
            default = self.host),
        Option('-p', '--port',
            dest = 'port',
            type = int,
            default = self.port),
        Option('-w', '--workers',
            dest = 'workers',
            type = int,
            default = self.workers),
        )
DEDENT
----------------------------------------

def get_options(self) :
INDENT
    from gunicorn.config import make_settings
    settings = make_settings()
    options = (
        Option(* klass.cli, action = klass.action) for setting, klass in settings.iteritems() if klass.cli
        )
    return options
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14566570_14569881_12_28
14566570_45422563_6_15
Title: How to use Flask-Script and Gunicorn 
----------------------------------------

def get_options(self) :
INDENT
    return (
        Option('-H', '--host',
            dest = 'host',
            default = self.host),
        Option('-p', '--port',
            dest = 'port',
            type = int,
            default = self.port),
        Option('-w', '--workers',
            dest = 'workers',
            type = int,
            default = self.workers),
        )
DEDENT
----------------------------------------

def get_options(self) :
INDENT
    from gunicorn.config import make_settings
    settings = make_settings()
    options = (
        Option(* klass.cli, dest = klass.name, default = klass.default) for setting, klass in settings.items() if klass.cli
        )
    return options
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14566570_24606817_7_16
14566570_45422563_6_15
Title: How to use Flask-Script and Gunicorn 
----------------------------------------

def get_options(self) :
INDENT
    from gunicorn.config import make_settings
    settings = make_settings()
    options = (
        Option(* klass.cli, action = klass.action) for setting, klass in settings.iteritems() if klass.cli
        )
    return options
DEDENT
----------------------------------------

def get_options(self) :
INDENT
    from gunicorn.config import make_settings
    settings = make_settings()
    options = (
        Option(* klass.cli, dest = klass.name, default = klass.default) for setting, klass in settings.items() if klass.cli
        )
    return options
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14568370_14570111_168_176
14568370_14570111_62_72
Title: Twisted deferreds firing in undesired way 
----------------------------------------

def __init__(self, smtp_server, imap_server, username, password) :
INDENT
    self.smtp_server, self.smtp_port = smtp_server.split(":")
    self.imap_server, self.imap_port = imap_server.split(":")
    self.username = username
    self.password = password
    self.imap_connection = IMAP4ClientFactory(username, password)

DEDENT
----------------------------------------

def __init__(self, username, password, mailbox = "INBOX", login_insecure = False) :
INDENT
    self.ctx = ssl.ClientContextFactory()
    self.username = username
    self.password = password
    self.mailbox = mailbox
    self.login_insecure = login_insecure

    self.deferred = Deferred()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14568452_14568487_2_14
14568452_14568677_2_10
Title: Decorator to tag functions as callable 
----------------------------------------

def tag(self, * tags) :
INDENT
    tags = set(tags)
    def decorator(func) :
    INDENT
        if hasattr(func, "_tags") :
        INDENT
            func._tags.update(tags)
        DEDENT
        else :
        INDENT
            func._tags = tags
        DEDENT
        @ functools.wraps(func)
        def wrapper(* args, ** kwargs) :
        INDENT
            return func(* args, ** kwargs) if self & func._tags else None
        DEDENT
        wrapper._tags = func._tags
        return wrapper
    DEDENT
    return decorator
DEDENT
----------------------------------------

def tag(self, tag_list) :
INDENT
    def decorator(func) :
    INDENT
        if set(tag_list) & self :
        INDENT
            return func
        DEDENT
        else :
        INDENT
            return do_nothing
        DEDENT
    DEDENT
    return decorator

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14568452_14568487_4_13
14568452_14568677_3_7
Title: Decorator to tag functions as callable 
----------------------------------------

def decorator(func) :
INDENT
    if hasattr(func, "_tags") :
    INDENT
        func._tags.update(tags)
    DEDENT
    else :
    INDENT
        func._tags = tags
    DEDENT
    @ functools.wraps(func)
    def wrapper(* args, ** kwargs) :
    INDENT
        return func(* args, ** kwargs) if self & func._tags else None
    DEDENT
    wrapper._tags = func._tags
    return wrapper
DEDENT
----------------------------------------

def decorator(func) :
INDENT
    if set(tag_list) & self :
    INDENT
        return func
    DEDENT
    else :
    INDENT
        return do_nothing
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14573849_14573975_1_12
14573849_14574044_1_10
Title: "Python if statement and float" 
----------------------------------------

def readtwo() :
INDENT
    tfile = open("/sys/bus/w1/devices/28-0000040de8fc/w1_slave")
    text = tfile.read()
    tfile.close()
    secondline = text.split("\n") [1]
    temperaturedata = secondline.split(" ") [9]
    temperature = temperaturedata [2 :]
    if temperature == '-0062' :
    INDENT
        return ("#error")
    DEDENT
    else :
    INDENT
        temperature = float(temperature) / 1000
        return (temperature)
    DEDENT
DEDENT
----------------------------------------

def readtwo() :
INDENT
    with open("/sys/bus/w1/devices/28-0000040de8fc/w1_slave", 'r') as f :
    INDENT
        secondline = f.readlines() [1]
    DEDENT
    temp = secondline.split(' ') [9] [2 :]
    if '-62' in temp :
    INDENT
        return '#error'
    DEDENT
    else :
    INDENT
        return float(temp) / 1000
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
14583560_14586679_4_16
14583560_46862778_1_13
Title: Selenium: retrieve data that loads while scrolling down 
----------------------------------------

def get_items(items) :
INDENT
    print len(items)
    wd.execute_script("window.scrollTo(0, document.body.scrollHeight);")

    sleep(5)
    while len(wd.find_elements_by_class_name('stream-item')) > len(items) :
    INDENT
        items = wd.find_elements_by_class_name('stream-item')
        print items
        wd.execute_script("window.scrollTo(0, document.body.scrollHeight);")
    DEDENT
    return items
DEDENT
----------------------------------------

def get_items(items) :
INDENT
    item_nb = [0, 1]
    while (item_nb [- 1] > item_nb [- 2]) :
    INDENT

        items = wd.find_elements_by_class_name('stream-item')
        time.sleep(5)
        browser.execute_script("window.scrollTo(0, document.body.scrollHeight);")
        item_nb.append(len(items))
    DEDENT
    return items
DEDENT
----------------------------------------
