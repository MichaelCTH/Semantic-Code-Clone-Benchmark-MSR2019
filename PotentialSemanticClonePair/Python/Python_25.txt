$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31556882_31557596_33_43
31556882_31557596_9_25
Title: OOP tkinter: How to set focus (and add text) to entry? 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    ttk.Frame.__init__(self, parent)
    self.controller = controller
    label = ttk.Label(self, text = "StartPage", font = LARGE_FONT)
    label.pack(padx = 10, pady = 10)
    but_1 = ttk.Button(self, text = "Page 1",
        command = self.page_one_command)
    but_1.pack(padx = 10, pady = 10)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = ttk.Frame(self)
    container.pack(side = tk.TOP, fill = tk.BOTH, expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in [StartPage, PageOne] :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31556882_31557596_51_70
31556882_31557596_9_25
Title: OOP tkinter: How to set focus (and add text) to entry? 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    ttk.Frame.__init__(self, parent)
    label = ttk.Label(self, text = "Page One", font = LARGE_FONT)
    label.pack(pady = 10, padx = 10)
    frame_answ = ttk.Frame(self)
    frame_answ.pack(side = tk.TOP, fill = tk.X)
    self.useranswer = tk.StringVar()
    self.entry_answ = ttk.Entry(self, textvariable = self.useranswer, font = ANSWER_FONT, justify = tk.CENTER)
    self.entry_answ.pack(fill = tk.X)
    frame_button = ttk.Frame(self)
    frame_button.pack(padx = 10, pady = 10)
    but_next = ttk.Button(frame_button, text = "back", state = tk.NORMAL,
        command = lambda : controller.show_frame(StartPage))
    but_next.pack(side = tk.LEFT)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = ttk.Frame(self)
    container.pack(side = tk.TOP, fill = tk.BOTH, expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.frames = {}
    for F in [StartPage, PageOne] :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31609394_31610398_1_19
31609394_31612267_1_13
Title: Merge two lists of tuples with timestamps and queue lengths 
----------------------------------------

def merge(a, b) :
INDENT
    l1 = [(t, value, 1) for (t, value) in a]
    l2 = [(t, value, 2) for (t, value) in b]
    events = l1 + l2
    events.sort()
    last_time = - 1
    result = []
    c1 = 0
    c2 = 0
    for t, value, index in events :
    INDENT
        if index == 1 :
        INDENT
            c1 = value
        DEDENT
        if index == 2 :
        INDENT
            c2 = value
        DEDENT
        if t == last_time :
        INDENT
            result.pop()
        DEDENT
        result.append((t, c1 + c2))
        last_time = t
    DEDENT
    return result
DEDENT
----------------------------------------

def merge(tup) :
INDENT
    events = list();
    i = 0
    for l in tup :
    INDENT
        events += [(t, value, i) for (t, value) in l]
        i += 1
    DEDENT
    events.sort(key = lambda x : x [0])
    result = dict()
    time = [0 for i in tup]
    for t, value, index in events :
    INDENT
        time [index] = value
        result [t] = sum(time)
    DEDENT
    return sorted(result.items())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31625379_31625471_10_17
31625379_31625578_9_17
Title: manipulating entry text value in tkinter 
----------------------------------------

def create_widgets(self) :
INDENT
    self.frame = Frame(self)
    my_entry = StringVar()
    my_entry.set("Search here")
    self.entry = Entry(self.frame, text = my_entry)
    self.entry.pack()
    self.frame.pack()
DEDENT
----------------------------------------

def create_widgets(self) :
INDENT
    self.frame = Frame(self)
    self.entry = Entry(self.frame)
    self.entry.modified = False
    self.entry.insert(0, "Search Here!")
    self.entry.bind("<Key>", self.entry_key)
    self.entry.pack()
    self.frame.pack()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31628130_31628143_1_11
31628130_31628149_1_19
Title: "Why do requests return ""None""?" 
----------------------------------------

def get(url) :
INDENT
    if not url.startswith('http://') :
    INDENT
        url = 'http://' + url
    DEDENT
    if not url.startswith('http://www.') :
    INDENT
        url = 'http://www.' + url [7 :]
    DEDENT
    response = requests.get(url)
    if response.status_code == 200 :
    INDENT
        return 'ok'
    DEDENT
    else :
    INDENT
        return 'error'
    DEDENT
DEDENT
----------------------------------------

def get(url) :
INDENT
    if url [: 7] == 'http://' :
    INDENT
        if url [7 : 11] == 'www.' :
        INDENT
            print url
            response = requests.get(url)
            if response.status_code == 200 :
            INDENT
                return 'ok'
            DEDENT
            else :
            INDENT
                return 'error'
            DEDENT
        DEDENT
        else :
        INDENT
            print (url)
            url = 'http://www.' + url [7 :]
            return get(url)
        DEDENT
    DEDENT
    else :
    INDENT
        print (url)
        url = 'http://' + url
        return get(url)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31631705_31636633_3_24
31631705_31664193_35_58
Title: Randomized Vigenere Cipher with Python 
----------------------------------------

def buildVigenere() :
INDENT
    symbols = """!"#$%&'()*+,-./0123456789:;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\] ^_`abcdefghijklmnopqrstuvwxyz{|}~"""
    n = len(symbols)
    eTable = [[0 for i in range(len(symbols))] for i in range(len(symbols))]
    dTable = [[0 for i in range(len(symbols))] for i in range(len(symbols))]

    for i in range(n) :
    INDENT
        temp = symbols
        for j in range(n) :
        INDENT
            r = random.randrange(len(temp))
            eTable [i] [j] = temp [r]
            print (r, len(temp), j, len(symbols), temp [r])
            print (ord(temp [r]) - 32)
            dTable [j] [(ord(temp [r]) - 32)] = chr(i + 32)
            temp = temp.replace(temp [r], '')
        DEDENT
    DEDENT
    print dTable
DEDENT
----------------------------------------

def buildVigenere(self) :
INDENT
    random.seed(self.seed)
    temp = list(self.symbols)
    random.shuffle(temp)
    temp = ''.join(temp)
    for sym in temp :
    INDENT
        random.seed(self.seed)
        myList = []
        for i in range(len(temp)) :
        INDENT
            r = random.randrange(len(temp))
            if r not in myList :
            INDENT
                myList.append(r)
            DEDENT
            else :
            INDENT
                while (r in myList) :
                INDENT
                    r = random.randrange(len(temp))
                DEDENT
                myList.append(r)
            DEDENT
            while (self.Table [i] [r] ! = 0) :
            INDENT
                r = (r + 1) % len(temp)
            DEDENT
            self.Table [i] [r] = sym

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3163903_3163976_113_136
3163903_3163976_252_264
Title: Storing Application Sensitive Data 
----------------------------------------

def clear(self, service = None, user = None) :
INDENT
    key = self._get_regkey()
    try :
    INDENT
        data = self._get_registrydata(key)
        if service is None :
        INDENT
            if user is None :
            INDENT
                data = {}
            DEDENT
            else :
            INDENT
                for (s, u) in data.keys() :
                INDENT
                    if u == user :
                    INDENT
                        del data [s, u]
                    DEDENT
                DEDENT
            DEDENT
        DEDENT
        else :
        INDENT
            if user is None :
            INDENT
                for (s, u) in data.keys() :
                INDENT
                    if s == service :
                    INDENT
                        del data [s, u]
                    DEDENT
                DEDENT
            DEDENT
            else :
            INDENT
                if (service, user) in data :
                INDENT
                    del data [service, user]

                DEDENT
            DEDENT
        DEDENT
        self._put_registrydata(key, data)
    DEDENT
    finally :
    INDENT
        key.Close()
    DEDENT
DEDENT
----------------------------------------

def clear(self, service = None, user = None) :
INDENT
    attrs = {'application' : self.application}
    if user is not None :
    INDENT
        attrs ["user"] = user
    DEDENT
    if service is not None :
    INDENT
        attrs ["server"] = service
    DEDENT
    try :
    INDENT
        items = gkey.find_items_sync(gkey.ITEM_NETWORK_PASSWORD, attrs)
    DEDENT
    except gkey.NoMatchError :
    INDENT
        return
    DEDENT
    for item in items :
    INDENT
        gkey.item_delete_sync(self._keyring, item.item_id)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3163903_3163976_20_30
3163903_3163976_213_220
Title: Storing Application Sensitive Data 
----------------------------------------

def __init__(self, application = None) :
INDENT
    if application is None :
    INDENT
        self.application = os.path.basename(sys.argv [0])
    DEDENT
    else :
    INDENT
        self.application = application
    DEDENT
DEDENT
----------------------------------------

def __init__(self, name, server, protocol) :
INDENT
    self._name = name
    self._server = server
    self._protocol = protocol
    self._keyring = k = gkey.get_default_keyring_sync()
    import pdb; pdb.set_trace()
    print dir(k)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3163903_3163976_226_235
3163903_3163976_86_98
Title: Storing Application Sensitive Data 
----------------------------------------

def set(self, service, user, password) :
INDENT
    attrs = {
        "application" : self.application,
        "user" : user,
        "server" : service,
        }
    gkey.item_create_sync(self._keyring,
        gkey.ITEM_NETWORK_PASSWORD, self.application, attrs, password, True)
DEDENT
----------------------------------------

def set(self, service, user, password) :
INDENT
    salt = self.salt(service, user)
    encrypted = self.Win32CryptProtectData(
        '%s' % password, salt)
    key = self._get_regkey()
    try :
    INDENT
        data = self._get_registrydata(key)
        data [service, user] = (salt, encrypted)
        self._put_registrydata(key, data)
    DEDENT
    finally :
    INDENT
        key.Close()
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3163903_3163976_236_251
3163903_3163976_99_112
Title: Storing Application Sensitive Data 
----------------------------------------

def get(self, service, user, getpass = None, cache = False) :
INDENT
    attrs = {
        "application" : self.application,
        "user" : user,
        "server" : service}
    try :
    INDENT
        items = gkey.find_items_sync(gkey.ITEM_NETWORK_PASSWORD, attrs)
    DEDENT
    except gkey.NoMatchError :
    INDENT
        if getpass is not None :
        INDENT
            password = getpass()
            if cache :
            INDENT
                self.set(service, user, password)
            DEDENT
            return password
        DEDENT
        raise KeyError((service, user))
    DEDENT
    return items [0].secret
DEDENT
----------------------------------------

def get(self, service, user, getpass = None, cache = False) :
INDENT
    data = self._get_registrydata()
    try :
    INDENT
        salt, encrypted = data [service, user]
        decrypted = self.Win32CryptUnprotectData(encrypted, salt)
    DEDENT
    except KeyError :
    INDENT
        if getpass is not None :
        INDENT
            password = getpass()
            if cache :
            INDENT
                self.set(service, user, password)
            DEDENT
            return password
        DEDENT
        raise
    DEDENT
    return decrypted
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31641194_31647727_17_26
31641194_31647727_34_47
Title: How can I implement pygame.sprite.spritecollide to my pygame 
----------------------------------------

def __init__(self, start_pos, up_key, down_key) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.surface.Surface((20, 100))
    self.image.fill(pygame.color.Color('White'))
    self.image.set_colorkey(pygame.color.Color('Black'))
    self.rect = self.image.get_rect(topleft = start_pos)
    self.mask = pygame.mask.from_surface(self.image)
    self.up_key, self.down_key = up_key, down_key
DEDENT
----------------------------------------

def __init__(self, start_pos) :
INDENT
    pygame.sprite.Sprite.__init__(self)
    self.image = pygame.surface.Surface((20, 20))
    self.rect = self.image.get_rect(center = start_pos)
    pygame.draw.circle(self.image, pygame.color.Color('White'), self.image.get_rect().center, 10)
    self.image.set_colorkey(pygame.color.Color('Black'))
    self.mask = pygame.mask.from_surface(self.image)
    self.move_v = (1, 0.7)

    self.pos = self.rect.center
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31641222_31641433_2_15
31641222_31641576_16_21
Title: How to give a __init__ parameter when initializing a class through a dictionary? 
----------------------------------------

def next_scene(name) :
INDENT
    global previous_scene
    scene_type = maps [name]

    new_scene = scene_type(previous_scene)

    previous_scene = new_scene

    return new_scene
DEDENT
----------------------------------------

def next_scene(self) :
INDENT
    try :
    INDENT
        return self.__class__.all [self._next_scene]
    DEDENT
    except KeyError :
    INDENT
        raise KeyError("There's no %s Scene." % self._next_scene)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31705005_31713946_1_29
31705005_52455001_4_42
Title: How to map a Python Dict to a Big Query Schema 
----------------------------------------

def map_dict_to_bq_schema(source_dict, schema, dest_dict) :
INDENT
    for field in schema ['fields'] :
    INDENT
        if field ['name'] in source_dict :
        INDENT
            if field ['type'].lower() == 'record' and 'fields' in field :
            INDENT
                if 'mode' in field and field ['mode'].lower() == 'repeated' :
                INDENT
                    dest_dict [field ['name']] = []
                    for item in source_dict [field ['name']] :
                    INDENT
                        new_item = {}
                        map_dict_to_bq_schema(item, field, new_item)
                        dest_dict [field ['name']].append(new_item)
                    DEDENT
                DEDENT
                else :
                INDENT
                    dest_dict [field ['name']] = {}
                    map_dict_to_bq_schema(source_dict [field ['name']], field, dest_dict [field ['name']])
                DEDENT
            DEDENT
            elif 'mode' in field and field ['mode'].lower() == 'repeated' :
            INDENT
                dest_dict [field ['name']] = []
                for item in source_dict [field ['name']] :
                INDENT
                    dest_dict [field ['name']].append(item)
                DEDENT
            DEDENT
            else :
            INDENT
                dest_dict [field ['name']] = source_dict [field ['name']]
                format_value_bq(source_dict [field ['name']], field ['type'])
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def map_dict_to_bq_schema(source_dict, schema, dest_dict = None) :
INDENT
    if dest_dict is None :
    INDENT
        dest_dict = dict()

    DEDENT
    if not isinstance(schema, list) :
    INDENT

        schema = [schema]
    DEDENT
    for field in schema :
    INDENT
        if field.name in source_dict :
        INDENT
            if field.field_type == "RECORD" and len(field.fields) > 0 :
            INDENT
                if field.mode == "REPEATED" :
                INDENT
                    dest_dict [field.name] = []
                    for item in source_dict [field.name] :
                    INDENT
                        new_item = {}
                        map_dict_to_bq_schema(item, field, new_item)
                        dest_dict [field.name].append(new_item)
                    DEDENT
                DEDENT
                else :
                INDENT
                    dest_dict [field.name] = {}
                    map_dict_to_bq_schema(source_dict [field.name], field, dest_dict [field.name])
                DEDENT
            DEDENT
            elif field.mode == "REPEATED" :
            INDENT
                if field.name in source_dict :
                INDENT
                    dest_dict [field.name] = []
                    for item in source_dict [field.name] :
                    INDENT
                        dest_dict [field.name].append(item)
                    DEDENT
                DEDENT
                else :
                INDENT
                    dest_dict [field.name] = [""]
                DEDENT
            DEDENT
            else :
            INDENT
                dest_dict [field.name] = source_dict [field.name]
            DEDENT
        DEDENT
    DEDENT
    return dest_dict
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31712386_31910275_10_23
31712386_32021013_30_50
Title: loading matplotlib object into reportlab 
----------------------------------------

def drawOn(self, canv, x, y, _sW = 0) :
INDENT
    if _sW > 0 and hasattr(self, 'hAlign') :
    INDENT
        a = self.hAlign
        if a in ('CENTER', 'CENTRE', TA_CENTER) :
        INDENT
            x += 0.5 * _sW
        DEDENT
        elif a in ('RIGHT', TA_RIGHT) :
        INDENT
            x += _sW
        DEDENT
        elif a not in ('LEFT', TA_LEFT) :
        INDENT
            raise ValueError("Bad hAlign value " + str(a))
        DEDENT
    DEDENT
    canv.saveState()
    canv.drawImage(self.img_data, x, y, self.img_width, self.img_height)
    canv.restoreState()

DEDENT
----------------------------------------

def drawOn(self, canv, x, y, _sW = 0) :
INDENT
    if _sW > 0 and hasattr(self, 'hAlign') :
    INDENT
        a = self.hAlign
        if a in ('CENTER', 'CENTRE', TA_CENTER) :
        INDENT
            x += 0.5 * _sW
        DEDENT
        elif a in ('RIGHT', TA_RIGHT) :
        INDENT
            x += _sW
        DEDENT
        elif a not in ('LEFT', TA_LEFT) :
        INDENT
            raise ValueError("Bad hAlign value " + str(a))
        DEDENT
    DEDENT
    canv.saveState()
    img = self.img_data
    if isinstance(img, PdfDict) :
    INDENT
        xscale = self.img_width / img.BBox [2]
        yscale = self.img_height / img.BBox [3]
        canv.translate(x, y)
        canv.scale(xscale, yscale)
        canv.doForm(makerl(canv, img))
    DEDENT
    else :
    INDENT
        canv.drawImage(img, x, y, self.img_width, self.img_height)
    DEDENT
    canv.restoreState()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31737745_31737804_1_15
31737745_46905370_13_27
Title: Python call function again if incorrect input 
----------------------------------------

def choose_colour() :
INDENT
    print "Select colour:"
    print "1. Red"
    print "2. Blue"
    print "3. Green"
    selection = raw_input()
    while selection not in ("1", "2", "3") :
    INDENT
        print "Please choose a valid option"
        selection = raw_input()
    DEDENT
    if selection == "1" :
    INDENT
        colour = "Red"
    DEDENT
    elif selection == "2" :
    INDENT
        colour = "Blue"
    DEDENT
    elif selection == "3" :
    INDENT
        colour = "Green"
    DEDENT
DEDENT
----------------------------------------

def choose_colour() :
INDENT
    Colors = ["Red", "Blue", "Green"]
    print ("Select colour:")
    for Item in Colors :
    INDENT
        print (str(Colors.index(Item) + 1) + ". " + Item)
    DEDENT
    print ("")
    Choice = - 1
    while Choice < = 0 or Choice > len(Colors) :
    INDENT
        Choice = int(Input("Your choice: "))
    DEDENT
    print ("You choosed " + Colors [Choice - 1])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31757455_31757594_34_47
31757455_31815514_7_13
Title: Python calculate ORFs from any arbitrary reading frame 
----------------------------------------

def get_orfs(dna) :
INDENT
    header, seqf = dna
    seqr = seqf [: : - 1].translate(revtrans)
    def readgroup(seq, group) :
    INDENT
        return list(x.start() for x in group.finditer(seq))
    DEDENT
    f = get_longest(readgroup(seqf, start), readgroup(seqf, end))
    r = get_longest(readgroup(seqr, start), readgroup(seqr, end))
    (length, index), s, direction = max((f, seqf, 'forward'), (r, seqr, 'reverse'))
    return length, header, direction, s [index : index + length]

DEDENT
----------------------------------------

def get_orfs(nuc) :
INDENT
    orfs = []
    for m in startP.finditer(nuc, overlapped = True) :
    INDENT
        pro = Seq.Seq(nuc) [m.start() :].translate(to_stop = True)
        orfs.append(nuc [m.start() : m.start() + len(pro) * 3 + 3])
    DEDENT
    return orfs
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31763724_50908327_1_22
31763724_51943212_2_15
Title: LeetCode Python TwoSums 
----------------------------------------

def twoSum(self, nums, target) :
INDENT
    if target % 2 == 0 and target / 2 in nums :
    INDENT
        i = 0
        for x in range(len(nums)) :
        INDENT
            if nums [x] == target / 2 :
            INDENT
                i += 1
            DEDENT
        DEDENT
        if i > = 2 :
        INDENT
            return nums.index(target / 2), nums.index(target / 2, nums.index(target / 2) + 1)
        DEDENT
    DEDENT
    elif target == 0 :
    INDENT
        for x in nums :
        INDENT
            if - x in nums :
            INDENT
                return nums.index(x), nums.index(- x)
            DEDENT
        DEDENT
    DEDENT
    else :
    INDENT
        for x in nums :
        INDENT
            if x ! = target / 2 and abs(x) < = abs(target) and target - x in nums :
            INDENT
                return nums.index(x), nums.index(target - x)
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def twoSum(self, nums, target) :
INDENT
    nums = sorted(nums)
    for i in range(len(nums)) :
    INDENT
        to_find = target - nums [i]
        left, ryt = 0, len(nums) - 1
        while left < ryt :
        INDENT
            mid = (left + ryt) / / 2
            if mid ! = i and nums [mid] == to_find :
            INDENT
                return [i, mid]
            DEDENT
            elif nums [mid] > to_find :
            INDENT
                ryt = mid - 1
            DEDENT
            else :
            INDENT
                left = mid + 1
            DEDENT
        DEDENT
    DEDENT
    return [- 1, - 1]
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31787191_31870277_7_18
31787191_31921828_4_19
Title: How do I customize the text of the select options in the api browser? 
----------------------------------------

def choices(self) :
INDENT
    queryset = self.get_queryset()
    if queryset is None :
    INDENT
        return {}
    DEDENT
    return OrderedDict([
            (
                six.text_type(self.to_representation(item)),
                six.text_type(item.get_full_name())) for item in queryset
            ])
DEDENT
----------------------------------------

def choices(self) :
INDENT
    queryset = self.child_relation.queryset
    iterable = queryset.all() if (hasattr(queryset, 'all')) else queryset
    items_and_representations = [
        (item, self.child_relation.to_representation(item)) for item in iterable
        ]
    return OrderedDict([
            (
                six.text_type(item_representation),
                item.get_full_name(),
                ) for item, item_representation in items_and_representations
            ])

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31827858_32244691_21_32
31827858_32403033_7_13
Title: Python Queue consumer 
----------------------------------------

def run(self) :
INDENT
    done = False
    while not done :
    INDENT
        queue_ret = queue.get()
        if queue_ret is None :
        INDENT
            done = True
        DEDENT
        else :
        INDENT
            print ("Retrieved", queue_ret)
        DEDENT
        queue.task_done()
    DEDENT
    print ("Consumer Finished")
DEDENT
----------------------------------------

def run(self) :
INDENT
    while queue.not_empty :
    INDENT
        queue_ret = self.queue.get()
        print ("Retrieved", queue_ret)
        self.queue.task_done()

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31832323_31832551_14_19
31832323_31832551_25_37
Title: Need help on producer and consumer thread in python 
----------------------------------------

def run(self) :
INDENT
    started = True
    for i in self.list_items :
    INDENT
        queue.put(str(i))
    DEDENT
    running = False
DEDENT
----------------------------------------

def run(self) :
INDENT
    while not started :
    INDENT
        sleep(0)
    DEDENT
    while running :
    INDENT
        try :
        INDENT
            queue_ret = queue.get(block = False)
        DEDENT
        except Empty :
        INDENT
            sleep(0)
            continue
        DEDENT
        print ("Retrieved", queue_ret)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31832323_31832551_14_19
31832323_31832802_9_14
Title: Need help on producer and consumer thread in python 
----------------------------------------

def run(self) :
INDENT
    started = True
    for i in self.list_items :
    INDENT
        queue.put(str(i))
    DEDENT
    running = False
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        queue_ret = queue.get()
        if queue_ret is _im_done :
        INDENT
            break
        DEDENT
        '''normal execution'''
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31832323_31832551_25_37
31832323_31832802_9_14
Title: Need help on producer and consumer thread in python 
----------------------------------------

def run(self) :
INDENT
    while not started :
    INDENT
        sleep(0)
    DEDENT
    while running :
    INDENT
        try :
        INDENT
            queue_ret = queue.get(block = False)
        DEDENT
        except Empty :
        INDENT
            sleep(0)
            continue
        DEDENT
        print ("Retrieved", queue_ret)
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        queue_ret = queue.get()
        if queue_ret is _im_done :
        INDENT
            break
        DEDENT
        '''normal execution'''
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31837976_31838738_3_15
31837976_31839950_1_21
Title: Summarizing dictionary with top two choices 
----------------------------------------

def summarize_inventory(inventory) :
INDENT
    sort_key = lambda(code,(cat, price, sold)) : (cat, - price)
    group_key = lambda(code,(cat, price, sold)) : cat
    new_dict = {}
    sorted_inventory = sorted(inventory.iteritems(), key = sort_key)
    for cat, group in groupby(sorted_inventory, key = group_key) :
    INDENT
        group = list(group)
        if len(group) > 1 :
        INDENT
            for (code, item) in group [: 2] :
            INDENT
                new_dict [code] = item
            DEDENT
        DEDENT
    DEDENT
    return new_dict
DEDENT
----------------------------------------

def summarize_inventory(inventory, top_n = 2) :
INDENT
    sort_key = lambda(id,(category, price, sold)) : (category, price)
    group_key = lambda(id,(category, price, sold)) : category
    items_by_category = (
        (category, list(items)) for category, items in itertools.groupby(
            sorted(inventory.iteritems(), key = sort_key),
            group_key)
        )

    inventory_summary = dict(itertools.chain.from_iterable(
            items [- 1 * top_n :] for category, items in items_by_category
            if len(items) > = top_n
            ))
    return inventory_summary
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31843292_31843293_24_33
31843292_31859213_1_22
Title: Unit testing a method that iterates through loops 
----------------------------------------

def direct(self) :
INDENT
    output_list = []
    for data_type, group in self.data_groups.items() :
    INDENT
        output_list.append(data_type)
        output_list.append(group)
        for consumer_name in self.consumers_list [data_type] :
        INDENT
            for record in group :
            INDENT
                output_list.append(record.values() [0])
            DEDENT
        DEDENT
    DEDENT
    return output_list
DEDENT
----------------------------------------

def direct(self, test = False) :
INDENT
    if test :
    INDENT
        output_list = []
    DEDENT
    for data_type, group in self.data_groups.items() :
    INDENT
        if test :
        INDENT
            output_list.append(data_type)
            output_list.append(group)
        DEDENT
        for consumer_name in self.consumers_list [data_type] :
        INDENT
            for record in group :
            INDENT
                consumer = self.get_consumer(consumer_name,
                    record, test = test)
                consumer_output = consumer.run()
                if not consumer_output :
                INDENT
                    raise Exception('consumer failed')
                DEDENT
                output_list.append(consumer_output)
            DEDENT
        DEDENT
    DEDENT
    if test :
    INDENT
        return output_list
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31843292_31843293_6_19
31843292_31859213_1_22
Title: Unit testing a method that iterates through loops 
----------------------------------------

def direct(self) :
INDENT
    for data_type, group in self.data_groups.items() :
    INDENT
        for consumer_name in self.consumers_list [data_type] :
        INDENT
            for record in group :
            INDENT
                consumer = self.get_consumer(consumer_name,
                    record)
                consumer_output = consumer.do_something()
            DEDENT
        DEDENT
    DEDENT
    return True
DEDENT
----------------------------------------

def direct(self, test = False) :
INDENT
    if test :
    INDENT
        output_list = []
    DEDENT
    for data_type, group in self.data_groups.items() :
    INDENT
        if test :
        INDENT
            output_list.append(data_type)
            output_list.append(group)
        DEDENT
        for consumer_name in self.consumers_list [data_type] :
        INDENT
            for record in group :
            INDENT
                consumer = self.get_consumer(consumer_name,
                    record, test = test)
                consumer_output = consumer.run()
                if not consumer_output :
                INDENT
                    raise Exception('consumer failed')
                DEDENT
                output_list.append(consumer_output)
            DEDENT
        DEDENT
    DEDENT
    if test :
    INDENT
        return output_list
    DEDENT
    return True
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31861792_31872116_1_11
31861792_47467005_1_10
Title: How to show Matrix in Sphinx Docs? 
----------------------------------------

def Matrix_func() :
INDENT
    """
    ::

             [1  4  7 ]
       M  =  [2  5  8 ] 
             [3  6  9 ]

    More text...

    """
DEDENT
----------------------------------------

def Matrix_func() :
INDENT
    r"""
    .. math::

        M = \begin{bmatrix}
                1 & 4 & 7 \\
                2 & 5 & 8 \\
                3 & 6 & 9
            \end{bmatrix}
    """
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31864099_31864286_1_13
31864099_31864473_1_14
Title: How do I return a set of n consecutive integers given n and an iterable? 
----------------------------------------

def consec(n, iterable) :
INDENT
    result = set()
    prev = None
    count = 0
    for item in iterable :
    INDENT
        if item == prev :
        INDENT
            count += 1
            if count == n :
            INDENT
                result.add(prev)
            DEDENT
        DEDENT
        else :
        INDENT
            prev = item
            count = 1
        DEDENT
    DEDENT
    return result
DEDENT
----------------------------------------

def consec(n, l) :
INDENT
    it = iter(l)
    prev = next(it)
    st = set()
    while prev ! = "" :
    INDENT
        for i in range(n - 1) :
        INDENT
            ele = next(it, "")
            if ele ! = prev or ele == "" :
            INDENT
                break
            DEDENT
            prev = ele
        DEDENT
        else :
        INDENT
            st.add(ele)
        DEDENT
        prev = ele
    DEDENT
    return st
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31867515_31867599_3_12
31867515_31867695_3_20
Title: Code stops working after input; why? I'm not sure. Password generator 
----------------------------------------

def password() :
INDENT
    password = []
    name = input('Enter your name')
    if name ! = 'QUIT' :
    INDENT
        pn = input('Enter your pets name')
        bday = input('Enter your birthday month')
        date = input('Enter the date you were born')
        for s in name, pn, bday :
        INDENT
            password.extend(random.sample(s, 3))
        DEDENT
        return '{}{}'.format(''.join(password), date)
    DEDENT
DEDENT
----------------------------------------

def password() :
INDENT
    name = input('Enter your name: ')
    if name == 'QUIT' :
    INDENT
        return
    DEDENT
    pn = input('Enter your pets name: ')
    bday = input('Enter your birthday month: ')
    date = input('Enter the date you were born: ')
    password_parts = []
    password_parts.append(''.join(random.sample(name, 3)))
    password_parts.append(''.join(random.sample(pn, 3)))
    password_parts.append(''.join(random.sample(bday, 3)))
    password_parts.append(date)
    return "Your password is: " + ''.join(password_parts)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31867515_31867599_3_12
31867515_31868910_1_17
Title: Code stops working after input; why? I'm not sure. Password generator 
----------------------------------------

def password() :
INDENT
    password = []
    name = input('Enter your name')
    if name ! = 'QUIT' :
    INDENT
        pn = input('Enter your pets name')
        bday = input('Enter your birthday month')
        date = input('Enter the date you were born')
        for s in name, pn, bday :
        INDENT
            password.extend(random.sample(s, 3))
        DEDENT
        return '{}{}'.format(''.join(password), date)
    DEDENT
DEDENT
----------------------------------------

def password() :
INDENT
    import random
    while True :
    INDENT
        password = []
        name = input('Enter your name')
        if name == 'QUIT' :
        INDENT
            return
        DEDENT
        pn = input('Enter your pets name')
        bday = input('Enter your birthday month')
        date = input('Enter the date you were born')
        pw = random.sample(name, 3)
        password.append(pw)
        pw1 = random.sample(pn, 3)
        password.append(pw1)
        pw2 = random.sample(bday, 3)
    DEDENT
    print 'Your security code is', password + date
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31867515_31867695_3_20
31867515_31868910_1_17
Title: Code stops working after input; why? I'm not sure. Password generator 
----------------------------------------

def password() :
INDENT
    name = input('Enter your name: ')
    if name == 'QUIT' :
    INDENT
        return
    DEDENT
    pn = input('Enter your pets name: ')
    bday = input('Enter your birthday month: ')
    date = input('Enter the date you were born: ')
    password_parts = []
    password_parts.append(''.join(random.sample(name, 3)))
    password_parts.append(''.join(random.sample(pn, 3)))
    password_parts.append(''.join(random.sample(bday, 3)))
    password_parts.append(date)
    return "Your password is: " + ''.join(password_parts)
DEDENT
----------------------------------------

def password() :
INDENT
    import random
    while True :
    INDENT
        password = []
        name = input('Enter your name')
        if name == 'QUIT' :
        INDENT
            return
        DEDENT
        pn = input('Enter your pets name')
        bday = input('Enter your birthday month')
        date = input('Enter the date you were born')
        pw = random.sample(name, 3)
        password.append(pw)
        pw1 = random.sample(pn, 3)
        password.append(pw1)
        pw2 = random.sample(bday, 3)
    DEDENT
    print 'Your security code is', password + date
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31875_11517201_3_16
31875_1810367_3_9
Title: "Is there a simple elegant way to define singletons?" 
----------------------------------------

def __new__(cls, * args, ** kwds) :
INDENT
    self = "__self__"
    if not hasattr(cls, self) :
    INDENT
        instance = object.__new__(cls)
        instance.init(* args, ** kwds)
        setattr(cls, self, instance)
    DEDENT
    return getattr(cls, self)
DEDENT
----------------------------------------

def __new__(cls, * args, ** kwargs) :
INDENT
    if not cls._instance :
    INDENT
        cls._instance = super(Singleton, cls).__new__(
            cls, * args, ** kwargs)
    DEDENT
    return cls._instance

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31876213_31895925_1_27
31876213_39662126_1_34
Title: how to use limit in django rest framework generics.RetrieveAPIView 
----------------------------------------

def get_object(self) :
INDENT
    queryset = self.filter_queryset(self.get_queryset())

    lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
    assert lookup_url_kwarg in self.kwargs, (
        'Expected view %s to be called with a URL keyword argument '
        'named "%s". Fix your URL conf, or set the `.lookup_field` '
        'attribute on the view correctly.' %
        (self.__class__.__name__, lookup_url_kwarg))
    filter_kwargs = {self.lookup_field : self.kwargs [lookup_url_kwarg]}
    obj = get_object_or_404(queryset, ** filter_kwargs)

    self.check_object_permissions(self.request, obj)
    return obj
DEDENT
----------------------------------------

def get_object(self) :
INDENT
    queryset = self.filter_queryset(self.get_queryset())
    lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
    assert lookup_url_kwarg in self.kwargs, (
        'Expected view %s to be called with a URL keyword argument '
        'named "%s". Fix your URL conf, or set the `.lookup_field` '
        'attribute on the view correctly.' %
        (self.__class__.__name__, lookup_url_kwarg))
    filter_kwargs = {self.lookup_field : self.kwargs [lookup_url_kwarg]}

    queryset = _get_queryset(queryset)
    try :
    INDENT
        return queryset.get(** filter_kwargs)
    DEDENT
    except AttributeError :
    INDENT
        klass__name = queryset.__name__ if isinstance(queryset, type) else queryset.__class__.__name__
        raise ValueError(
            "First argument to get_object_or_404() must be a Model, Manager, "
            "or QuerySet, not '%s'." % klass__name)
    DEDENT
    except queryset.model.DoesNotExist :
    INDENT
        res = {"success" : "false", "code" : 404, "message" : 'Product Not found'}
        raise CustomValidation(res, 404)
    DEDENT
    self.check_object_permissions(self.request, obj)
    return obj
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31878917_31990032_26_41
31878917_31990032_44_77
Title: Python GTK - switch between widgets - embed a tree in widget or window 
----------------------------------------

def __init__(self) :
INDENT
    super(clTableLog, self).__init__(15, 15, True)
    self.set_row_spacings(5)
    self.btnSaveLogAs = gtk.Button("Save log as...")
    self.attach(self.btnSaveLogAs, 6, 9, 13, 14)
    self.btnSaveLogAs.show()
    self.btnRefresh = gtk.Button("Refresh")
    self.attach(self.btnRefresh, 12, 14, 5, 6)
    self.btnRefresh.show()
    self.btnClearALL = gtk.Button("Clear all")
    self.attach(self.btnClearALL, 12, 14, 6, 7)
    self.btnClearALL.show()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(PyApp, self).__init__()
    self.set_title("Utilities Testing Tool")
    self.set_size_request(700, 500)
    self.set_position(gtk.WIN_POS_CENTER)
    mb = gtk.MenuBar()

    treem = gtk.MenuItem("Tree Window")
    treem.connect("button_press_event", self.open_tree_widget)
    logm = gtk.MenuItem("Log Window")
    logm.connect("button_press_event", self.open_log_widget)
    exit = gtk.MenuItem("Exit")
    exit.connect("button_press_event", gtk.main_quit)
    mb.append(treem)
    mb.append(logm)
    mb.append(exit)

    self.vbox = gtk.VBox(False, 2)
    self.vbox.pack_start(mb, False, False, 0)
    self.tableTreeWindow = self.create_table_tree()
    self.tableLogWindow = self.create_table_log()
    self.tableLogWindow.show()
    self.vbox.pack_start(self.tableTreeWindow)
    self.add(self.vbox)
    self.connect("destroy", gtk.main_quit)
    self.show_all()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31878917_31990032_26_41
31878917_31990032_5_24
Title: Python GTK - switch between widgets - embed a tree in widget or window 
----------------------------------------

def __init__(self) :
INDENT
    super(clTableLog, self).__init__(15, 15, True)
    self.set_row_spacings(5)
    self.btnSaveLogAs = gtk.Button("Save log as...")
    self.attach(self.btnSaveLogAs, 6, 9, 13, 14)
    self.btnSaveLogAs.show()
    self.btnRefresh = gtk.Button("Refresh")
    self.attach(self.btnRefresh, 12, 14, 5, 6)
    self.btnRefresh.show()
    self.btnClearALL = gtk.Button("Clear all")
    self.attach(self.btnClearALL, 12, 14, 6, 7)
    self.btnClearALL.show()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(clTableTree, self).__init__(15, 15, True)
    self.set_row_spacings(5)
    self.btnStartTest = gtk.Button("Start testing Process")
    self.attach(self.btnStartTest, 6, 9, 13, 14)
    self.btnActivate = gtk.Button("Activate")
    self.attach(self.btnActivate, 12, 14, 3, 4)
    self.btnDeactivate = gtk.Button("Deactivate")
    self.attach(self.btnDeactivate, 12, 14, 4, 5)
    self.btnDuplicateNode = gtk.Button("Duplicate Node")
    self.attach(self.btnDuplicateNode, 12, 14, 5, 6)
    self.btnDeleteNode = gtk.Button("Delete Node")
    self.attach(self.btnDeleteNode, 12, 14, 6, 7)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31878917_31990032_44_77
31878917_31990032_5_24
Title: Python GTK - switch between widgets - embed a tree in widget or window 
----------------------------------------

def __init__(self) :
INDENT
    super(PyApp, self).__init__()
    self.set_title("Utilities Testing Tool")
    self.set_size_request(700, 500)
    self.set_position(gtk.WIN_POS_CENTER)
    mb = gtk.MenuBar()

    treem = gtk.MenuItem("Tree Window")
    treem.connect("button_press_event", self.open_tree_widget)
    logm = gtk.MenuItem("Log Window")
    logm.connect("button_press_event", self.open_log_widget)
    exit = gtk.MenuItem("Exit")
    exit.connect("button_press_event", gtk.main_quit)
    mb.append(treem)
    mb.append(logm)
    mb.append(exit)

    self.vbox = gtk.VBox(False, 2)
    self.vbox.pack_start(mb, False, False, 0)
    self.tableTreeWindow = self.create_table_tree()
    self.tableLogWindow = self.create_table_log()
    self.tableLogWindow.show()
    self.vbox.pack_start(self.tableTreeWindow)
    self.add(self.vbox)
    self.connect("destroy", gtk.main_quit)
    self.show_all()
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(clTableTree, self).__init__(15, 15, True)
    self.set_row_spacings(5)
    self.btnStartTest = gtk.Button("Start testing Process")
    self.attach(self.btnStartTest, 6, 9, 13, 14)
    self.btnActivate = gtk.Button("Activate")
    self.attach(self.btnActivate, 12, 14, 3, 4)
    self.btnDeactivate = gtk.Button("Deactivate")
    self.attach(self.btnDeactivate, 12, 14, 4, 5)
    self.btnDuplicateNode = gtk.Button("Duplicate Node")
    self.attach(self.btnDuplicateNode, 12, 14, 5, 6)
    self.btnDeleteNode = gtk.Button("Delete Node")
    self.attach(self.btnDeleteNode, 12, 14, 6, 7)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31901403_31902121_3_15
31901403_31903072_1_15
Title: Calculating value between squares of two integers 
----------------------------------------

def sqrt_approx(num) :
INDENT
    fnum = int(floor(num))
    i = 0
    while True :
    INDENT
        if i * i < = fnum :
        INDENT
            minsq = i
        DEDENT
        if i * i > = num :
        INDENT
            maxsq = i
            break
        DEDENT
        i = i + 1
    DEDENT
    assert minsq ** 2 < = num < = maxsq ** 2
    return minsq, maxsq
DEDENT
----------------------------------------

def sqrt_approx(n) :
INDENT
    if n < = 1 :
    INDENT
        return n, n
    DEDENT
    inf = 1
    sup = n
    while sup > inf + 1 :
    INDENT
        guess = (inf + sup) / 2
        g2 = guess * guess
        if g2 == n :
        INDENT
            return guess, guess
        DEDENT
        elif g2 < n :
        INDENT
            inf = guess
        DEDENT
        else :
        INDENT
            sup = guess
        DEDENT
    DEDENT
    return inf, sup
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31904948_31905229_2_10
31904948_31906538_2_11
Title: How to design a class containing related member variables efficiently? 
----------------------------------------

def __init__(self, n = None, half = None, square = None) :
INDENT
    self._n = 0
    if n is not None :
    INDENT
        self.n = n
    DEDENT
    if half is not None :
    INDENT
        self.half = half
    DEDENT
    if square is not None :
    INDENT
        self.square = square
    DEDENT
DEDENT
----------------------------------------

def __init__(self, n = None, half = None, square = None) :
INDENT
    if all(arg is None for arg in (n, half, square)) :
    INDENT
        raise ValueError("Must supply at least one arg.")
    DEDENT
    if n is not None :
    INDENT
        self.n = n
    DEDENT
    elif half is not None :
    INDENT
        self.half = half
    DEDENT
    elif square is not None :
    INDENT
        self.square = square
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31905255_31906497_19_29
31905255_31906497_42_62
Title: How to terminate Producer-Consumer threads from main thread in Python? 
----------------------------------------

def run(self) :
INDENT
    out_q = self.kwargs.get('queue')
    while self.running :
    INDENT

        out_q.put(10)
        time.sleep(0.1)
    DEDENT
    print 'producer {name} terminated\n'.format(name = self.name)
DEDENT
----------------------------------------

def run(self) :
INDENT
    in_q = self.kwargs.get('queue')

    while self.producer_alive or not in_q.empty() :
    INDENT
        try :
        INDENT
            data = in_q.get(timeout = 1)
        DEDENT
        except Empty, e :
        INDENT
            pass
        DEDENT
        if isinstance(data, int) :
        INDENT
            for i in xrange(data + 10 ** 6) :
            INDENT
                pass
            DEDENT
        DEDENT
        else :
        INDENT
            pass
        DEDENT
    DEDENT
    print 'Consumer {name} terminated (Is producer alive={pstatus}, Is Queue empty={qstatus})!\n'.format(
        name = self.name, pstatus = self.producer_alive, qstatus = in_q.empty())
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31910346_31910410_4_13
31910346_40907304_3_13
Title: Recursive Python Simple Function 
----------------------------------------

def countSubStringMatchRecursive(target, key) :
INDENT
    match = target.find(key)
    if match ! = - 1 :
    INDENT
        next_target = target [match + 1 :]
        return 1 + countSubStringMatchRecursive(next_target, key)
    DEDENT
    else :
    INDENT
        return 0

    DEDENT
DEDENT
----------------------------------------

def countSubStringMatchRecursive(target, key) :
INDENT
    match = target.find(key)
    if match ! = - 1 :
    INDENT
        global answers
        answers.append(match)
        next_target = target [match + 1 :]
        countSubStringMatchRecursive(next_target, key)
    DEDENT
    return len(answers)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31910935_31915319_16_24
31910935_31916599_94_116
Title: How can I read arguments by a program running in the background? 
----------------------------------------

def main() :
INDENT
    parseArguments()
    import select
    while (True) :
    INDENT
        while select.select([sys.stdin], [], [], 0) [0] :
        INDENT
            myList.append(sys.stdin.readline().strip())
        DEDENT
        print (myList)
        time.sleep(10)
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    end = False
    MAX = 5
    while not end and MAX > 0 :
    INDENT
        s = socket.socket(socket.AF_INET)
        try :
        INDENT
            s.bind((IFACE, PORT))
        DEDENT
        except Exception :
        INDENT
            s.close()
            s = None
        DEDENT
        if s :
        INDENT
            try :
            INDENT
                server(s)
            DEDENT
            finally :
            INDENT
                s.close()
                return
            DEDENT
        DEDENT
        else :
        INDENT
            if DEBUG :
            INDENT
                print ("CLIENT", " ", 6 - MAX)
            DEDENT
            end = client()
        DEDENT
        MAX -= 1
        time.sleep(1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31910935_31915319_7_15
31910935_31916599_15_35
Title: How can I read arguments by a program running in the background? 
----------------------------------------

def parseArguments() :
INDENT
    parser = argparse.ArgumentParser(description = "example")
    parser.add_argument('-a', '--addElement', help = 'adds an element to the list')
    args = parser.parse_args()
    if args.addElement :
    INDENT
        myList.append(args.addElement)
    DEDENT
DEDENT
----------------------------------------

def parseArguments() :
INDENT
    parser = argparse.ArgumentParser(description = "example")
    parser.add_argument('-a', '--addElement',
        help = 'adds an element to the list')
    parser.add_argument('-q', '--quit', action = 'store_true',
        help = 'closes main service')
    parser.add_argument('-d', '--debug', action = 'store_true',
        help = 'display debug information')
    args = parser.parse_args()
    if args.quit :
    INDENT
        senddata("QUIT\n")
        sys.exit(0)
    DEDENT
    if args.debug :
    INDENT
        DEBUG = True
    DEDENT
    if args.addElement :
    INDENT
        myList.append(args.addElement)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31915081_31915182_13_19
31915081_31915182_3_10
Title: Python: Global variables in threads 
----------------------------------------

def run(self) :
INDENT
    global a
    global b
    while True :
    INDENT
        print a
        print b
        b -= 1
    DEDENT
DEDENT
----------------------------------------

def run(self) :
INDENT
    global a
    global b
    while True :
    INDENT
        a += 1

    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31918960_33350380_4_14
31918960_48652975_18_45
Title: Boto3 to download all files from a S3 Bucket 
----------------------------------------

def download_dir(client, resource, dist, local = '/tmp', bucket = 'your_bucket') :
INDENT
    paginator = client.get_paginator('list_objects')
    for result in paginator.paginate(Bucket = bucket, Delimiter = '/', Prefix = dist) :
    INDENT
        if result.get('CommonPrefixes') is not None :
        INDENT
            for subdir in result.get('CommonPrefixes') :
            INDENT
                download_dir(client, resource, subdir.get('Prefix'), local, bucket)
            DEDENT
        DEDENT
        if result.get('Contents') is not None :
        INDENT
            for file in result.get('Contents') :
            INDENT
                if not os.path.exists(os.path.dirname(local + os.sep + file.get('Key'))) :
                INDENT
                    os.makedirs(os.path.dirname(local + os.sep + file.get('Key')))
                DEDENT
                resource.meta.client.download_file(bucket, file.get('Key'), local + os.sep + file.get('Key'))
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def download_dir(client, bucket, path, target) :
INDENT
    if not path.endswith('/') :
    INDENT
        path += '/'
    DEDENT
    paginator = client.get_paginator('list_objects_v2')
    for result in paginator.paginate(Bucket = bucket, Prefix = path) :
    INDENT
        for key in result ['Contents'] :
        INDENT

            rel_path = key ['Key'] [len(path) :]
            if not key ['Key'].endswith('/') :
            INDENT
                local_file_path = os.path.join(target, rel_path)
                local_file_dir = os.path.dirname(local_file_path)
                assert_dir_exists(local_file_dir)
                client.download_file(bucket, key ['Key'], local_file_path)

            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3192437_3192495_2_16
3192437_3192646_5_23
Title: how do i make this python code less ugly 
----------------------------------------

def __init__(self, pyQueryRow) :
INDENT
    get_column = lambda index : pyQueryRow.find('td').eq(index).text()
    self.crn = get_column(0)
    self.course = get_column(1)
    self.title = get_column(2)
    self.tipe = get_column(3)
    self.cr_hours = get_column(4)
    self.seats = get_column(5)
    self.instructor = get_column(6)
    self.days = get_column(7)
    self.begin = get_column(8)
    self.end = get_column(9)
    self.location = get_column(10)
    self.exam = get_column(11)
DEDENT
----------------------------------------

def __init__(self, pyQueryRow) :
INDENT
    course_row_mapping = {
        'crn' : 0,
        'course' : 1,
        'title' : 2,
        'tipe' : 3,
        'cr_hours' : 4,
        'seats' : 5,
        'instructor' : 6,
        'days' : 7,
        'begin' : 8,
        'end' : 9,
        'location' : 10,
        'exam' : 11,
        }
    for name, col in course_row_mapping.iteritems() :
    INDENT
        setattr(self, name, Course.get_column(pyQueryRow, col))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31951903_31952664_4_16
31951903_31963191_5_22
Title: Dynamically choose argument for which to minimize a function in python using scipy.optimize 
----------------------------------------

def make_model(* fixed) :
INDENT
    template = textwrap.dedent("""
        def func(variable, {fixed}):
            {variable} = variable
            return 4*(b-a)**2 + 5*(c-d)**2
        """)
    variable = set(('a', 'b', 'c', 'd')).difference(fixed)
    ns = dict()
    funcstr = template.format(variable = ', '.join(variable), fixed = ', '.join(fixed))
    print (funcstr)
    exec funcstr in ns
    return ns ['func']
DEDENT
----------------------------------------

def make_model(n, * fixed) :
INDENT
    template = textwrap.dedent("""
        import numpy as np
        def fm(arr):
            return np.std(arr)
        def func(variable, {fixed}):
            {variable} = variable
            return fm([""" + ",".join(["a" + str(i) for i in range(n)]) + """])
        """)
    settuple = tuple(['a' + str(i) for i in range(n)])
    variable = set(settuple).difference(fixed)
    ns = dict()
    funcstr = template.format(variable = ', '.join(variable), fixed = ', '.join(fixed))
    print (funcstr)
    exec funcstr in ns
    return ns ['func']

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31995804_32078446_112_132
31995804_32078446_37_54
Title: StopWatch on Tkinter ...Creating a Class 
----------------------------------------

def update_time(self) :
INDENT
    if (self.running == True) :
    INDENT

        self.timer [2] -= 1
        if (self.timer [2] < 0) :
        INDENT
            self.timer [2] = 100
            self.timer [1] -= 1
        DEDENT
        if (self.timer [1] < 0) :
        INDENT
            self.timer [1] = 60
            self.timer [1] -= 1
            self.timer [0] -= 1
        DEDENT
        self.timeString = str(self.timer [0]) + ':' + str(self.timer [1]) + ':' + str(self.timer [2])
        self.show.config(text = self.timeString)
    DEDENT
    root.after(10, self.update_time)

DEDENT
----------------------------------------

def update_time(self) :
INDENT
    if (self.running == True) :
    INDENT

        self.timer [2] += 1
        if (self.timer [2] > = 100) :
        INDENT
            self.timer [2] = 0
            self.timer [1] += 1
        DEDENT
        if (self.timer [1] > = 60) :
        INDENT
            self.timer [0] += 1
            self.timer [1] = 0
        DEDENT
        self.timeString = str(self.timer [0]) + ':' + str(self.timer [1]) + ':' + str(self.timer [2])
        self.show.config(text = self.timeString)
    DEDENT
    root.after(10, self.update_time)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
31995804_32078446_17_36
31995804_32078446_86_111
Title: StopWatch on Tkinter ...Creating a Class 
----------------------------------------

def widgets(self) :
INDENT
    self.timeFrame = LabelFrame(root, text = 'Counts Up')
    self.timeFrame.grid(row = 0, column = 0, sticky = W)
    self.resetButton = Button(self.timeFrame, text = 'Reset', command = self.resetTime)
    self.resetButton.grid(row = 2, column = 1)
    self.pauseButton = Button(self.timeFrame, text = 'Pause', command = self.pause)
    self.pauseButton.grid(row = 1, column = 1)
    self.startButton = Button(self.timeFrame, text = 'Start', command = self.start)
    self.startButton.grid(row = 0, column = 1)
    self.show = Label(self.timeFrame, text = '00:00:00', font = ('Helvetica', 30))
    self.show.grid(row = 0, column = 0)
    self.quit = Button(self.timeFrame, text = 'QUIT', command = self.quit)
    self.quit.grid(row = 3, column = 1)

DEDENT
----------------------------------------

def widgets(self) :
INDENT
    self.timeFrame = LabelFrame(root, text = 'Counts Down')
    self.timeFrame.grid(row = 2, column = 0, sticky = W)
    self.resetButton = Button(self.timeFrame, text = 'Reset', command = self.resetTime)
    self.resetButton.grid(row = 2, column = 1)
    self.pauseButton = Button(self.timeFrame, text = 'Pause', command = self.pause)
    self.pauseButton.grid(row = 1, column = 1)
    self.startButton = Button(self.timeFrame, text = 'Start', command = self.start)
    self.startButton.grid(row = 0, column = 1)
    self.show = Label(self.timeFrame, text = '00:00:00', font = ('Helvetica', 30))
    self.show.grid(row = 0, column = 0)
    self.addMinute = Button(self.timeFrame, text = 'Add Minute', command = self.addMinute)
    self.addMinute.grid(row = 2, column = 0)
    self.addSecond = Button(self.timeFrame, text = 'Add Second', command = self.addSecond)
    self.addSecond.grid(row = 3, column = 0)
    self.quit = Button(self.timeFrame, text = 'QUIT', command = self.quit)
    self.quit.grid(row = 3, column = 1)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32020029_32020452_6_23
32020029_32077829_1_31
Title: How to get selected menu item in wxPython? 
----------------------------------------

def __init__(self, parent, id) :
INDENT
    self.frame = wx.Frame(None)
    menu_bar = wx.MenuBar()
    menu1 = wx.Menu()
    menu_item_1 = menu1.Append(- 1, "&Option #1")
    menu_item_2 = menu1.Append(- 1, "&Option #2")
    menu_item_3 = menu1.Append(- 1, "&Exit...")
    menu_bar.Append(menu1, "&File")
    self.frame.SetMenuBar(menu_bar)
    self.frame.Bind(wx.EVT_MENU, partial(self.option_chosen, 1),
        menu_item_1)
    self.frame.Bind(wx.EVT_MENU, partial(self.option_chosen, 2),
        menu_item_2)
    self.frame.Bind(wx.EVT_MENU, self.on_close, menu_item_3)
    self.frame.Show(True)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    self.frame = wx.Frame.__init__(self, * args, ** kwds)
    self.menubar = wx.MenuBar()
    menu1 = wx.Menu()
    menu_item_1 = menu1.Append(wx.ID_OPEN, "&File")
    menu_item_2 = menu1.Append(wx.ID_EXIT, "&Exit...")
    self.list_of_things = ["Thing No 1", "Thing No 2", "Thing No 3"]
    list_used = wx.Menu()
    thing_count = 101
    for thing in self.list_of_things :
    INDENT
        t1 = wx.MenuItem(list_used, thing_count, thing)
        list_used.AppendItem(t1)
        thing_count += 1
    DEDENT
    thing_end = wx.MenuItem(list_used, 199, 'End of List')
    list_used.AppendItem(thing_end)
    menu1.AppendMenu(wx.ID_FILE, '&Things', list_used)
    self.menubar.Append(menu1, "&File")
    self.SetMenuBar(self.menubar)
    i_count = 101
    for i in self.list_of_things :
    INDENT
        self.Bind(wx.EVT_MENU, self.OnThingOpen, id = i_count)
        i_count = i_count + 1
    DEDENT
    self.Bind(wx.EVT_MENU, self.OnThingEnd, id = 199)
    self.Bind(wx.EVT_MENU, self.OnClose, id = wx.ID_EXIT)
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32020029_32020452_6_23
32020029_32095835_5_40
Title: How to get selected menu item in wxPython? 
----------------------------------------

def __init__(self, parent, id) :
INDENT
    self.frame = wx.Frame(None)
    menu_bar = wx.MenuBar()
    menu1 = wx.Menu()
    menu_item_1 = menu1.Append(- 1, "&Option #1")
    menu_item_2 = menu1.Append(- 1, "&Option #2")
    menu_item_3 = menu1.Append(- 1, "&Exit...")
    menu_bar.Append(menu1, "&File")
    self.frame.SetMenuBar(menu_bar)
    self.frame.Bind(wx.EVT_MENU, partial(self.option_chosen, 1),
        menu_item_1)
    self.frame.Bind(wx.EVT_MENU, partial(self.option_chosen, 2),
        menu_item_2)
    self.frame.Bind(wx.EVT_MENU, self.on_close, menu_item_3)
    self.frame.Show(True)
DEDENT
----------------------------------------

def __init__(self, * args, ** kwds) :
INDENT
    self.frame = wx.Frame.__init__(self, * args, ** kwds)
    self.menubar = wx.MenuBar()
    self.CreateStatusBar()
    self.SetStatusText("Demonstration of wxPython")
    menu1 = wx.Menu()
    menu_item_1 = menu1.Append(wx.ID_OPEN, "&File")
    menu_item_2 = menu1.Append(wx.ID_EXIT, "&Exit...")
    self.list_of_things = ["Thing No 1", "Thing No 2", "Thing No 3"]
    list_used = wx.Menu()
    thing_count = 101
    for thing in self.list_of_things :
    INDENT
        t1 = wx.MenuItem(list_used, thing_count, thing)
        list_used.AppendItem(t1)
        thing_count += 1
    DEDENT
    thing_end = wx.MenuItem(list_used, 199, 'End of List')
    list_used.AppendItem(thing_end)
    menu1.AppendMenu(wx.ID_FILE, '&Things', list_used)
    menu1.SetHelpString(wx.ID_FILE, 'Select from the list of things')
    self.menubar.Append(menu1, "&File")
    self.SetMenuBar(self.menubar)
    i_count = 101
    for i in self.list_of_things :
    INDENT
        self.Bind(wx.EVT_MENU, self.OnThingOpen, id = i_count)
        i_count = i_count + 1
    DEDENT
    self.Bind(wx.EVT_MENU, self.OnThingEnd, id = 199)
    self.Bind(wx.EVT_MENU, self.OnClose, id = wx.ID_EXIT)
    self.Show(True)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32035496_32079915_44_74
32035496_32079915_8_22
Title: How to access from child to widget in parent window? 
----------------------------------------

def __init__(self) :
INDENT
    wx.Frame.__init__(self, None, wx.ID_ANY,
        "Notebook Tutorial",
        size = (600, 400))
    panel = MyPanel(self)
    self.tab_num = 3
    self.notebook = wx.Notebook(panel)
    tabOne = TabPanel(self.notebook)
    self.notebook.AddPage(tabOne, "Tab 1")
    tabTwo = TabPanel(self.notebook)
    self.notebook.AddPage(tabTwo, "Tab 2")
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(self.notebook, 1, wx.ALL | wx.EXPAND, 5)
    self.btn = wx.Button(panel, label = "Get Color")
    sizer.Add(self.btn)
    panel.SetSizer(sizer)
    self.Layout()

    pub.subscribe(self.change_button, 'button_listener')
    self.Show()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    colors = ["red", "blue", "gray", "yellow", "green"]
    self.color = random.choice(colors)
    self.SetBackgroundColour(self.color)
    self.Bind(wx.EVT_LEFT_DCLICK, self.update_button)
    lbox = wx.ListBox(self, choices = colors)
    sizer = wx.BoxSizer(wx.VERTICAL)
    sizer.Add(lbox, 0, wx.ALL, 10)
    self.SetSizer(sizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32037769_32037963_5_15
32037769_32038100_4_11
Title: How do I link python tkinter widgets created in a for loop? 
----------------------------------------

def __init__(self, root) :
INDENT
    self.button_list = []
    self.entry_list = []
    for w in range(5) :
    INDENT
        button = Button(root, text = "submit", command = functools.partial(self.enabling, idx = w))
        button.grid(row = w, column = 0)
        self.button_list.append(button)
        entry1 = Entry(root, state = "disabled")
        entry1.grid(row = w, column = 1)
        self.entry_list.append(entry1)
    DEDENT
DEDENT
----------------------------------------

def __init__(self, root) :
INDENT
    for w in range(5) :
    INDENT
        entry = Entry(root, state = "disabled")
        button = Button(root, text = "submit",
            command = lambda e = entry : self.enabling(e))
        button.grid(row = w, column = 0)
        entry.grid(row = w, column = 1)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32056337_32056589_7_13
32056337_32076803_7_16
Title: Python: can numba work with arrays of strings in nopython mode? 
----------------------------------------

def numba_str(txt, sample) :
INDENT
    x = 0
    for i in xrange(txt.size) :
    INDENT
        if txt [i] == sample :
        INDENT
            x += 1
        DEDENT
    DEDENT
    return x
DEDENT
----------------------------------------

def numba_str(txt) :
INDENT
    x = 0
    for i in xrange(txt.shape [0]) :
    INDENT
        if (txt [i, 0] == 116 and
            txt [i, 1] == 101 and
            txt [i, 2] == 120 and
            txt [i, 3] == 116) :
        INDENT
            x += 1
        DEDENT
    DEDENT
    return x
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32058290_32058612_73_83
32058290_32058612_98_112
Title: ipython startup config for spyder IDE 
----------------------------------------

def decorator(Base) :
INDENT
    def __subclasshook__(Class, Subclass) :
    INDENT
        if Class is Base :
        INDENT
            all_ancestor_attrs = [ancestor_class.__dict__.keys() for ancestor_class in Subclass.__mro__]
            if all(method in all_ancestor_attrs for method in methods) :
            INDENT
                return True
            DEDENT
        DEDENT
        return NotImplemented
    DEDENT
    Base.__subclasshook__ = classmethod(__subclasshook__)
    return Base
DEDENT
----------------------------------------

def decorator(Base) :
INDENT
    def checker(Other) :
    INDENT
        return all(hasattr(Other, a) for a in attributes)
    DEDENT
    def __subclasshook__(cls, Other) :
    INDENT
        if checker(Other) :
        INDENT
            return True
        DEDENT
        return NotImplemented
    DEDENT
    def __instancecheck__(cls, Other) :
    INDENT
        return checker(Other)
    DEDENT
    Base.__metaclass__.__subclasshook__ = classmethod(__subclasshook__)
    Base.__metaclass__.__instancecheck__ = classmethod(__instancecheck__)
    return Base
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32061507_32061675_5_16
32061507_50192580_20_36
Title: Moving A Rectangle in Pygame 
----------------------------------------

def handle_keys(self) :
INDENT
    key = pygame.key.get_pressed()
    dist = 1
    if key [pygame.K_LEFT] :
    INDENT
        self.rect.move_ip(- 1, 0)
    DEDENT
    if key [pygame.K_RIGHT] :
    INDENT
        self.rect.move_ip(1, 0)
    DEDENT
    if key [pygame.K_UP] :
    INDENT
        self.rect.move_ip(0, - 1)
    DEDENT
    if key [pygame.K_DOWN] :
    INDENT
        self.rect.move_ip(0, 1)
    DEDENT
DEDENT
----------------------------------------

def handle_keys(self) :
INDENT
    for e in pygame.event.get() :
    INDENT
        if e.type == QUIT :
        INDENT
            pygame.quit(); exit()
        DEDENT
        elif e.type == KEYDOWN :
        INDENT
            key = e.key
            if key == K_LEFT :
            INDENT
                self.draw_rect(- 1, 0)
            DEDENT
            elif key == K_RIGHT :
            INDENT
                self.draw_rect(1, 0)
            DEDENT
            elif key == K_UP :
            INDENT
                self.draw_rect(0, - 1)
            DEDENT
            elif key == K_DOWN :
            INDENT
                self.draw_rect(0, 1)
            DEDENT
            elif key == K_ESCAPE :
            INDENT
                pygame.quit(); exit()
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32064460_32064654_142_157
32064460_32064654_34_64
Title: Line numbers and Syntax Highlighting don't work on different tabs 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, * args, ** kwargs)
    self.fileName = "Untitled Document"
    self.content = ""
    self.previousContent = ""
    self.language = "Python"
    self.row = "0"
    self.column = "0"
    self.startCol = 0
    self.tabs = []
    self.notebook = ttk.Notebook(self)
    self.menubar()
    self.createtext()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Text.__init__(self, * args, ** kwargs)
    self.tk.eval('''
            proc widget_proxy {widget widget_command args} {

                # call the real tk widget command with the real args
                set result [uplevel [linsert $args 0 $widget_command]]

                # generate the event for certain types of commands
                if {([lindex $args 0] in {insert replace delete}) ||
                    ([lrange $args 0 2] == {mark set insert}) || 
                    ([lrange $args 0 1] == {xview moveto}) ||
                    ([lrange $args 0 1] == {xview scroll}) ||
                    ([lrange $args 0 1] == {yview moveto}) ||
                    ([lrange $args 0 1] == {yview scroll})} {

                    event generate  $widget <<Change>> -when tail
                }

                # return the result from the real widget command
                return $result
            }
            ''')
    self.tk.eval('''
            rename {widget} _{widget}
            interp alias {{}} ::{widget} {{}} widget_proxy {widget} _{widget}
        '''.format(widget = str(self)))
    self.comment = False
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32064460_32064654_142_157
32064460_32064654_66_95
Title: Line numbers and Syntax Highlighting don't work on different tabs 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Frame.__init__(self, * args, ** kwargs)
    self.fileName = "Untitled Document"
    self.content = ""
    self.previousContent = ""
    self.language = "Python"
    self.row = "0"
    self.column = "0"
    self.startCol = 0
    self.tabs = []
    self.notebook = ttk.Notebook(self)
    self.menubar()
    self.createtext()
DEDENT
----------------------------------------

def __init__(self, parent, filename, parentwindow) :
INDENT
    self.fileName = "Untitled Document"
    self.content = ""
    self.previousContent = ""
    self.parentwindow = parentwindow
    self.language = "Python"
    self.parent = parent
    self.filename = filename
    self.tab1 = ttk.Frame(parent)
    self.text = CustomText(self.tab1, bd = 0, font = ("Courier", 9))
    self.vsb = tk.Scrollbar(self.tab1, orient = tk.VERTICAL)
    self.text.configure(yscrollcommand = self.vsb.set)
    self.vsb.configure(command = self.text.yview)
    self.linenumbers = TextLineNumbers(self.tab1, width = 55)
    self.linenumbers.attach(self.text)
    self.vsb.pack(side = tk.RIGHT, fill = tk.Y)
    self.linenumbers.pack(side = "left", fill = "y")
    self.text.pack(side = "right", fill = "both", expand = True)
    parent.add(self.tab1, text = filename)
    self.bottomLabel()
    self.text.bind("<<Change>>", self._on_change)
    self.text.bind("<Configure>", self._on_change)
    self.text.bind("<KeyRelease>", self.keypress)
    self.text.bind("<Button-1>", self.keypress)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32064460_32064654_34_64
32064460_32064654_66_95
Title: Line numbers and Syntax Highlighting don't work on different tabs 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Text.__init__(self, * args, ** kwargs)
    self.tk.eval('''
            proc widget_proxy {widget widget_command args} {

                # call the real tk widget command with the real args
                set result [uplevel [linsert $args 0 $widget_command]]

                # generate the event for certain types of commands
                if {([lindex $args 0] in {insert replace delete}) ||
                    ([lrange $args 0 2] == {mark set insert}) || 
                    ([lrange $args 0 1] == {xview moveto}) ||
                    ([lrange $args 0 1] == {xview scroll}) ||
                    ([lrange $args 0 1] == {yview moveto}) ||
                    ([lrange $args 0 1] == {yview scroll})} {

                    event generate  $widget <<Change>> -when tail
                }

                # return the result from the real widget command
                return $result
            }
            ''')
    self.tk.eval('''
            rename {widget} _{widget}
            interp alias {{}} ::{widget} {{}} widget_proxy {widget} _{widget}
        '''.format(widget = str(self)))
    self.comment = False
DEDENT
----------------------------------------

def __init__(self, parent, filename, parentwindow) :
INDENT
    self.fileName = "Untitled Document"
    self.content = ""
    self.previousContent = ""
    self.parentwindow = parentwindow
    self.language = "Python"
    self.parent = parent
    self.filename = filename
    self.tab1 = ttk.Frame(parent)
    self.text = CustomText(self.tab1, bd = 0, font = ("Courier", 9))
    self.vsb = tk.Scrollbar(self.tab1, orient = tk.VERTICAL)
    self.text.configure(yscrollcommand = self.vsb.set)
    self.vsb.configure(command = self.text.yview)
    self.linenumbers = TextLineNumbers(self.tab1, width = 55)
    self.linenumbers.attach(self.text)
    self.vsb.pack(side = tk.RIGHT, fill = tk.Y)
    self.linenumbers.pack(side = "left", fill = "y")
    self.text.pack(side = "right", fill = "both", expand = True)
    parent.add(self.tab1, text = filename)
    self.bottomLabel()
    self.text.bind("<<Change>>", self._on_change)
    self.text.bind("<Configure>", self._on_change)
    self.text.bind("<KeyRelease>", self.keypress)
    self.text.bind("<Button-1>", self.keypress)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32128205_32128643_6_14
32128205_32130365_1_10
Title: Convert curl to Pycurl. 
----------------------------------------

def assign(key, name) :
INDENT
    url = "http://xxx/rest/api/2/issue/" + key
    headers = {'Content-type' : 'application/json', 'Accept' : 'application/json'}
    data = json.dumps({"fields" : {"assignee" : {"name" : name}}})
    r = requests.put(url, data = data, headers = headers, auth = requests.auth.HTTPBasicAuth('fred', 'fred'))
    print (r.status_code)
    print (r.json())
DEDENT
----------------------------------------

def assign(self, key, name) :
INDENT
    self._startCurl()
    self.c.setopt(pycurl.URL, "http://xxx/rest/api/2/issue/" + key)
    self.c.setopt(pycurl.HTTPHEADER, ['Content-Type: application/json', 'Accept: application/json'])
    self.c.setopt(pycurl.USERPWD, "fred:fred")
    self.c.setopt(pycurl.CUSTOMREQUEST, "PUT")
    data = json.dumps({"fields" : {"assignee" : {"name" : name}}})
    self.c.setopt(pycurl.POSTFIELDS, data)
    self.c.perform()
    self.c.close()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32136745_32137218_1_11
32136745_32138240_3_19
Title: Continue (save state) in nested recursive method 
----------------------------------------

def deep_search(url, deq = deque(maxlen = 1)) :
INDENT
    if is_leaf(url) :
    INDENT
        return get_data(url)
    DEDENT
    try :
    INDENT
        for url in get_subcategories(url) :
        INDENT
            if deq [0] == url :
            INDENT
                deep_search(url, deq)
            DEDENT
        DEDENT
    DEDENT
    except :
    INDENT
        deq.append(url)
    DEDENT
DEDENT
----------------------------------------

def deep_search(url, last_saved_path = None) :
INDENT
    if is_leaf(url) :
    INDENT
        if last_saved_path :
        INDENT
            if path_reached(last_saved_path) :
            INDENT
                data = get_data(url)
            DEDENT
        DEDENT
        else :
        INDENT
            data = get_data(url)
        DEDENT
        save_to_file(current_path)
    DEDENT
    else :
    INDENT
        for index, url in enumerate(get_subcategories(url)) :
        INDENT
            current_path.append(index)
            deep_search(url, last_saved_path)
            del current_path [- 1]

        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32149972_32150490_1_15
32149972_32150511_10_19
Title: My script does not delete the last char 
----------------------------------------

def OnKeyboardEvent(event) :
INDENT
    LOG_FILE = open('log.txt', 'a')
    if event.Ascii == 8 :
    INDENT
        pos = LOG_FILE.tell() - 1
        if pos > = 0 :
        INDENT
            LOG_FILE.seek(pos)
            LOG_FILE.truncate(pos)
        DEDENT
    DEDENT
    elif event.Ascii == 13 or event.Ascii == 9 :
    INDENT
        LOG_FILE.write("\n")
    DEDENT
    else :
    INDENT
        LOG_FILE.write(str(chr(event.Ascii)))

    DEDENT
    LOG_FILE.close()
    return True
DEDENT
----------------------------------------

def OnKeyboardEvent(self, event) :
INDENT
    if event.Ascii == 8 :
    INDENT
        self._txt = self._txt [: - 1]
    DEDENT
    elif event.Ascii == 13 or event.Ascii == 9 :
    INDENT
        self._txt += "\n"
        self._file.write(self._txt)
        self._txt = ""
    DEDENT
    else :
    INDENT
        self._txt += str(chr(event.Ascii))
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32152907_32186054_119_164
32152907_32186054_12_21
Title: How to sort and filter using QAbstractTableModel instead of QSortFilterProxyModel 
----------------------------------------

def __init__(self, * args) :
INDENT
    QtGui.QWidget.__init__(self, * args)
    vLayout = QtGui.QVBoxLayout(self)
    self.setLayout(vLayout)
    self.tableModel = TableModel()
    self.searchLine = QtGui.QLineEdit()
    vLayout.addWidget(self.searchLine)
    self.searchLine.textEdited.connect(self.searchLineEditied)
    self.searchLine.returnPressed.connect(self.searchLineEditied)
    self.tableView = QtGui.QTableView(self)
    self.tableView.setSortingEnabled(True)
    self.tableView.horizontalHeader().setResizeMode(QtGui.QHeaderView.Stretch)
    self.tableView.setShowGrid(False)
    self.tableView.setSelectionBehavior(QtGui.QTableView.SelectRows)
    self.tableView.setAlternatingRowColors(True)
    self.delegate = ItemDelegate(self.tableView)
    self.tableView.setItemDelegate(self.delegate)
    self.tableView.clicked.connect(self.viewClicked)
    vLayout.addWidget(self.tableView)
    for row in range(15) :
    INDENT
        if row % 2 : category = 'Pet'
        else : category = 'Birds'
        item = Item(category = category, ID = row, name = '%s_%s' % (category, row))
        self.tableModel.insertRows(row, item)
    DEDENT
    self.tableView.setModel(self.tableModel)
    self.combo = QtGui.QComboBox()
    self.combo.addItems(['Pet', 'Birds'])
    self.combo.activated.connect(self.comboActivated)
    vLayout.addWidget(self.combo)
    currentComboCategory = self.combo.currentText()
    self.tableModel.setFilter(currentComboCategory)
    self.horizontalHeader = self.tableView.horizontalHeader()
    self.horizontalHeader.sortIndicatorChanged.connect(self.headerTriggered)
    self.addComboDelegates()
DEDENT
----------------------------------------

def __init__(self, parent = None) :
INDENT
    QtCore.QAbstractTableModel.__init__(self, parent)
    self.currentItems = []
    self.items = []
    self.filterCategory = None
    self.searchField = None
    self.mainColumn = 0
    self.order = QtCore.Qt.SortOrder.DescendingOrder
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32159610_32160235_5_11
32159610_32166919_3_13
Title: Merging a dict class attribute through the class hierarchy 
----------------------------------------

def __call__(self, * args, ** kwargs) :
INDENT
    obj = type.__call__(self)
    obj.defaults = _DEFAULTS [obj.__class__.__name__]
    for klass in obj.__class__.__bases__ :
    INDENT
        if klass.__name__ in _DEFAULTS :
        INDENT
            obj.defaults.update(_DEFAULTS [klass.__name__])
        DEDENT
    DEDENT
    return obj
DEDENT
----------------------------------------

def __call__(self, * args, ** kwargs) :
INDENT
    obj = type.__call__(self)
    for klass in obj.__class__.__mro__ :
    INDENT
        if klass == obj.__class__ or klass == Base or not issubclass(klass, Base) :
        INDENT
            continue
        DEDENT
        if hasattr(klass, 'DEFAULTS') :
        INDENT
            d = klass.DEFAULTS.copy()
            d.update(obj.DEFAULTS)
            obj.DEFAULTS = d
        DEDENT
    DEDENT
    return obj
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32172252_32172274_1_10
32172252_32172308_1_8
Title: Adding print statement to ValueError exception 
----------------------------------------

def string_checker(action) :
INDENT
    try :
    INDENT
        check = isinstance(action, basestring)
        if check :
        INDENT
            return True
        DEDENT
        else :
        INDENT
            raise ValueError
        DEDENT
    DEDENT
    except ValueError :
    INDENT
        print "We need a string here!"
        return None
    DEDENT
DEDENT
----------------------------------------

def string_checker(action) :
INDENT
    try :
    INDENT
        assert isinstance(action, basestring)
        return True
    DEDENT
    except AssertionError :
    INDENT
        print "We need a string here!"
        return None
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32174550_32175257_1_50
32174550_32183535_67_81
Title: points code program 
----------------------------------------

def main() :
INDENT
    events = []
    houses = []
    scores = {}
    print "Welcome!\n"
    print "Please enter how many houses there is:"
    n_houses = int(raw_input("><![CDATA[>"))
    print "Please enter houses names:"
    for n in range(n_houses) :
    INDENT
        print "House", n + 1
        house_name = raw_input("><![CDATA[>")
        houses.append(house_name)

    DEDENT
    print "Please enter the number of events there is"
    n_events = int(raw_input("><![CDATA[>"))
    print "Please enter the event names"
    for n in range(n_events) :
    INDENT
        print "Event", n + 1
        event_name = raw_input("><![CDATA[>")
        events.append(event_name)

    DEDENT
    for event in events :
    INDENT
        for house in houses :
        INDENT
            print "Please enter the score for House %s in the event %s" % (house, event)
            score = int(raw_input("><![CDATA[>"))

            if house not in scores :
            INDENT
                scores [house] = []

            DEDENT
            scores [house].append(score)
        DEDENT
    DEDENT
    print "\nThe result is:"
    for house, score in sorted(scores.items(),
        key = lambda x : sum(x [1]),
        reverse = True) :
    INDENT
        print "House %s. Total Score: %i" % (house, sum(score))
    DEDENT
DEDENT
----------------------------------------

def main() :
INDENT
    print ("Welcome!\n")
    n_events = get_number_of_events()
    events_names = get_events_names(n_events)
    print ()
    data = get_data(events_names)
    print ()
    for house_name, event_data in data :
    INDENT
        print ("House " + house_name)
        for event_name, score in event_data :
        INDENT
            print ("\tEvent: %s Score: %i" % (event_name, score))
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32184786_32186343_8_15
32184786_32559466_10_30
Title: How to get the value of amount_total of sale.order from another model? 
----------------------------------------

def _amount_all(self, cr, uid, ids, field_name, arg, context = None) :
INDENT
    res = super(SaleOrder, self)._amount_all(cr, uid, ids, field_name, arg, context = context)
    currency_pool = self.pool.get('res.currency')
    for order in self.browse(cr, uid, ids, context = context) :
    INDENT
        line_amount = sum([line.price_subtotal for line in order.order_line if line.is_delivery])
        currency = order.pricelist_id.currency_id
        res [order.id] ['amount_delivery'] = currency_pool.round(cr, uid, currency, line_amount)
    DEDENT
    return res
DEDENT
----------------------------------------

def _amount_all(self, cr, uid, ids, field_name, arg, context = None) :
INDENT
    cur_obj = self.pool.get('res.currency')
    res = {}
    for order in self.browse(cr, uid, ids, context = context) :
    INDENT
        res [order.id] = {
            'amount_untaxed' : 0.0,
            'amount_tax' : 0.0,
            'amount_total' : 0.0,
            'amount_my_total' : 'my default value when total = 0'}
        val = val1 = 0.0
        cur = order.pricelist_id.currency_id
        for line in order.order_line :
        INDENT
            val1 += line.price_subtotal
            val += self._amount_line_tax(cr, uid, line, context = context)
        DEDENT
        res [order.id] ['amount_tax'] = cur_obj.round(cr, uid, cur, val)
        res [order.id] ['amount_untaxed'] = cur_obj.round(cr, uid, cur, val1)
        res [order.id] ['amount_total'] = res [order.id] ['amount_untaxed'] + res [order.id] ['amount_tax']
        res [order.id] ['amount_my_total'] = my_module.my_function(res [order.id] ['amount_total'])
    DEDENT
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32200262_32200418_1_15
32200262_40592236_1_12
Title: "Pythonjoin() function adding space between words" 
----------------------------------------

def censor(text, word) :
INDENT
    text = text.split(" ")
    asterisks = []
    text_with_asterisks = []
    for item in text :
    INDENT
        if item not in word :
        INDENT
            text_with_asterisks.append(item)
        DEDENT
        else :
        INDENT
            asterisks = []
            for letter in word :
            INDENT
                asterisks.append("*")
            DEDENT
            text_with_asterisks.append(''.join(asterisks))
        DEDENT
    DEDENT
    return (" ".join(text_with_asterisks))
DEDENT
----------------------------------------

def censor(text, censor_w) :
INDENT
    splitted_text = text.split(" ")
    asterics = "*" * len(censor_w)
    result = []
    for word in splitted_text :
    INDENT
        if word == censor :
        INDENT
            result.append(asterics)
        DEDENT
        else :
        INDENT
            result.append(word)
        DEDENT
    DEDENT
    return " ".join(result)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32203639_32208393_31_46
32203639_32208393_4_19
Title: "In tkinter how can I access variables created in one window in a different one?" 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO DE PRECIOS", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    self.controller = controller
    val1 = tk.IntVar()
    val2 = tk.IntVar()
    self.test1 = tk.Spinbox(self, values = (1, 2, 4, 8), textvariable = val1,
        command = lambda : self.setVarSpin1(val1.get())).pack()
    self.test2 = tk.Spinbox(self, values = (1, 2, 4, 8), textvariable = val2,
        command = lambda : self.setVarSpin2(val2.get())).pack()
    button1 = tk.Button(self, width = 20, text = "Calculo Final",
        command = lambda : controller.show_frame(PageOne)).pack()
    button2 = tk.Button(self, width = 20, text = "Calculo Actividades",
        command = lambda : controller.show_frame(PageTwo)).pack()
DEDENT
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.varSpin1 = 1
    self.varSpin2 = 1
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32203639_32208393_31_46
32203639_32208393_51_58
Title: "In tkinter how can I access variables created in one window in a different one?" 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO DE PRECIOS", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    self.controller = controller
    val1 = tk.IntVar()
    val2 = tk.IntVar()
    self.test1 = tk.Spinbox(self, values = (1, 2, 4, 8), textvariable = val1,
        command = lambda : self.setVarSpin1(val1.get())).pack()
    self.test2 = tk.Spinbox(self, values = (1, 2, 4, 8), textvariable = val2,
        command = lambda : self.setVarSpin2(val2.get())).pack()
    button1 = tk.Button(self, width = 20, text = "Calculo Final",
        command = lambda : controller.show_frame(PageOne)).pack()
    button2 = tk.Button(self, width = 20, text = "Calculo Actividades",
        command = lambda : controller.show_frame(PageTwo)).pack()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO FINAL", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, width = 20, text = "Volver al menu principal",
        command = lambda : self.callback()).pack()
    self.controller = controller
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32203639_32208393_31_46
32203639_32208393_63_70
Title: "In tkinter how can I access variables created in one window in a different one?" 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO DE PRECIOS", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    self.controller = controller
    val1 = tk.IntVar()
    val2 = tk.IntVar()
    self.test1 = tk.Spinbox(self, values = (1, 2, 4, 8), textvariable = val1,
        command = lambda : self.setVarSpin1(val1.get())).pack()
    self.test2 = tk.Spinbox(self, values = (1, 2, 4, 8), textvariable = val2,
        command = lambda : self.setVarSpin2(val2.get())).pack()
    button1 = tk.Button(self, width = 20, text = "Calculo Final",
        command = lambda : controller.show_frame(PageOne)).pack()
    button2 = tk.Button(self, width = 20, text = "Calculo Actividades",
        command = lambda : controller.show_frame(PageTwo)).pack()
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO ACTIVIDADES", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, width = 20, text = "Volver al menu principal",
        command = lambda : self.callback()).pack()
    self.controller = controller
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32203639_32208393_4_19
32203639_32208393_51_58
Title: "In tkinter how can I access variables created in one window in a different one?" 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.varSpin1 = 1
    self.varSpin2 = 1
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO FINAL", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, width = 20, text = "Volver al menu principal",
        command = lambda : self.callback()).pack()
    self.controller = controller
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32203639_32208393_4_19
32203639_32208393_63_70
Title: "In tkinter how can I access variables created in one window in a different one?" 
----------------------------------------

def __init__(self, * args, ** kwargs) :
INDENT
    tk.Tk.__init__(self, * args, ** kwargs)
    container = tk.Frame(self)
    container.pack(side = "top", fill = "both", expand = True)
    container.grid_rowconfigure(0, weight = 1)
    container.grid_columnconfigure(0, weight = 1)
    self.varSpin1 = 1
    self.varSpin2 = 1
    self.frames = {}
    for F in (StartPage, PageOne, PageTwo) :
    INDENT
        frame = F(container, self)
        self.frames [F] = frame
        frame.grid(row = 0, column = 0, sticky = "nsew")
    DEDENT
    self.show_frame(StartPage)
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO ACTIVIDADES", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, width = 20, text = "Volver al menu principal",
        command = lambda : self.callback()).pack()
    self.controller = controller
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32203639_32208393_51_58
32203639_32208393_63_70
Title: "In tkinter how can I access variables created in one window in a different one?" 
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO FINAL", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, width = 20, text = "Volver al menu principal",
        command = lambda : self.callback()).pack()
    self.controller = controller
DEDENT
----------------------------------------

def __init__(self, parent, controller) :
INDENT
    tk.Frame.__init__(self, parent)
    label = tk.Label(self, text = "CALCULO ACTIVIDADES", font = TITLE_FONT)
    label.pack(side = "top", fill = "x", pady = 10)
    button = tk.Button(self, width = 20, text = "Volver al menu principal",
        command = lambda : self.callback()).pack()
    self.controller = controller
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32211212_32267973_22_30
32211212_32267973_45_55
Title: How to return values from pool threads in Python? 
----------------------------------------

def run(self) :
INDENT
    for task in self.source() :
    INDENT
        if task is None :
        INDENT
            self.queue.put(None)
            break
        DEDENT
        logging.info('Recorded %s' % task)
        self.queue.put(task)
    DEDENT
    return
DEDENT
----------------------------------------

def run(self) :
INDENT
    while True :
    INDENT
        logging.info('Getting task')
        task = self.queue.get()
        if task is None :
        INDENT
            break
        DEDENT
        processed_result = self.processing_function(task)
        logging.info(processed_result)
    DEDENT
    return
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32213921_32420103_110_123
32213921_32420103_131_137
Title: Share plugin resources with implemented permission rules 
----------------------------------------

def __iter__(self) :
INDENT
    proxied = get_proxied(self)
    for key in proxied :
    INDENT
        if not isinstance(key, immutable_scalar_types) :
        INDENT
            raise NotImplementedError(
                "keys of type {} not supported in "
                "ImmutableProxyMapping".format(type(key)))
        DEDENT
        yield key

    DEDENT
DEDENT
----------------------------------------

def __iter__(self) :
INDENT
    proxied = get_proxied(self)
    for value in proxied :
    INDENT
        if isinstance(value, immutable_safe) :
        INDENT
            yield value
        DEDENT
        yield immutable_proxy_for(value)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32229767_32229976_4_10
32229767_32229990_3_9
Title: Using decorator yields NameError on a defined function 
----------------------------------------

def cached_execution(* args, ** kwargs) :
INDENT
    if proc in cache :
    INDENT
        if args in cache [proc] :
        INDENT
            return cache [proc] [args]
        DEDENT
    DEDENT
    res = proc(args [0])
    cache [proc] = {args : res}
    return res
DEDENT
----------------------------------------

def cached_execution(* args, ** kwargs) :
INDENT
    if proc in cache :
    INDENT
        if args in cache [proc] :
        INDENT
            return cache [proc] [args]
        DEDENT
    DEDENT
    res = proc(* args)
    cache [proc] = {args : res}
    return res
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32231278_32233649_11_20
32231278_32233649_25_59
Title: How to change value of existing item's string in wxPython ObjectListView list_ctrl 
----------------------------------------

def __init__(self, tin, zip_code, plus4, name, address) :
INDENT
    self.tin = tin
    self.zip_code = zip_code
    self.plus4 = plus4
    self.name = name
    self.address = address

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent = parent)
    mainSizer = wx.BoxSizer(wx.VERTICAL)
    self.columns = {0 : 'tin',
        1 : 'zip_code',
        2 : 'plus4',
        3 : 'name',
        4 : 'address'}
    self.test_data = [Results("123456789", "50158", "0065", "Patti Jones",
            "111 Centennial Drive"),
        Results("978561236", "90056", "7890", "Brian Wilson",
            "555 Torque Maui"),
        Results("456897852", "70014", "6545", "Mike Love",
            "304 Cali Bvld")]
    self.resultsOlv = ObjectListView(self, style = wx.LC_REPORT | wx.SUNKEN_BORDER)
    self.resultsOlv.cellEditMode = ObjectListView.CELLEDIT_SINGLECLICK
    self.setResults()
    self.column_cbo = wx.ComboBox(self, value = 'tin',
        choices = self.columns.values())
    modify_btn = wx.Button(self, label = 'Modify Column 1 Cells')
    modify_btn.Bind(wx.EVT_BUTTON, self.onModify)
    mainSizer.Add(self.resultsOlv, 1, wx.EXPAND | wx.ALL, 5)
    mainSizer.Add(self.column_cbo, 0, wx.CENTER | wx.ALL, 5)
    mainSizer.Add(modify_btn, 0, wx.CENTER | wx.ALL, 5)
    self.SetSizer(mainSizer)

DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32234986_32235888_1_21
32234986_32254483_1_33
Title: Duplicate Django Model Instance and All Foreign Keys Pointing to It 
----------------------------------------

def duplicate(self) :
INDENT
    kwargs = {}
    for field in self._meta.fields :
    INDENT
        kwargs [field.name] = getattr(self, field.name)
    DEDENT
    kwargs.pop('id')
    new_instance = self.__class__(** kwargs)
    new_instance.save()

    fkeys_qs = self.fkeys.all()
    new_fkeys = []
    for fkey in fkey_qs :
    INDENT
        fkey_kwargs = {}
        for field in fkey._meta.fields :
        INDENT
            fkey_kwargs [field.name] = getattr(fkey, field.name)
        DEDENT
        fkey_kwargs.pop('id')
        fkey_kwargs ['foreign_key_field'] = new_instance.id
        new_fkeys.append(fkey_qs.model(** fkey_kwargs))
    DEDENT
    fkeys_qs.model.objects.bulk_create(new_fkeys)
    return new_instance
DEDENT
----------------------------------------

def duplicate(self) :
INDENT
    fks_to_copy = list(self.fkeys_a.all()) + list(self.fkeys_b.all())

    self.pk = None
    self.save()
    foreign_keys = {}
    for fk in fks_to_copy :
    INDENT
        fk.pk = None

        try :
        INDENT

            foreign_keys [fk.__class__].append(fk)
        DEDENT
        except KeyError :
        INDENT
            foreign_keys [fk.__class__] = [fk]

        DEDENT
    DEDENT
    for cls, list_of_fks in foreign_keys.items() :
    INDENT
        cls.objects.bulk_create(list_of_fks)
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3224412_3224480_9_21
3224412_3224688_10_20
Title: "Learning Python is there a better way to write this?" 
----------------------------------------

def convert(args) :
INDENT
    if len(args) < 2 :
    INDENT
        return 1
    DEDENT
    t = args [1]
    if args [0] == '-f' :
    INDENT
        print "%s Fahrenheit is %s Celsius" % (t, to_c(int(t)))
        return 0
    DEDENT
    elif args [0] == '-c' :
    INDENT
        print "%s Celsius is %s Fahrenheit" % (t, to_f(int(t)))
        return 0
    DEDENT
    else :
    INDENT
        return 1
    DEDENT
DEDENT
----------------------------------------

def convert(args) :
INDENT
    if len(args) ! = 2 :
    INDENT
        raise RuntimeError("List of two elememts required")
    DEDENT
    t = int(args [1])
    if args [0] == '-f' :
    INDENT
        print "{0} Fahrenheit is {1} Celsius".format(t, round(to_c(t)))
    DEDENT
    elif args [0] == '-c' :
    INDENT
        print "{0} Celsius is {1} Fahrenheit".format(t, round(to_f(t)))
    DEDENT
    else :
    INDENT
        raise RuntimeError("First element should be -c or -f")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3224412_3224480_9_21
3224412_3224925_13_36
Title: "Learning Python is there a better way to write this?" 
----------------------------------------

def convert(args) :
INDENT
    if len(args) < 2 :
    INDENT
        return 1
    DEDENT
    t = args [1]
    if args [0] == '-f' :
    INDENT
        print "%s Fahrenheit is %s Celsius" % (t, to_c(int(t)))
        return 0
    DEDENT
    elif args [0] == '-c' :
    INDENT
        print "%s Celsius is %s Fahrenheit" % (t, to_f(int(t)))
        return 0
    DEDENT
    else :
    INDENT
        return 1
    DEDENT
DEDENT
----------------------------------------

def convert(args) :
INDENT
    opts = None
    try :
    INDENT
        opts, args = getopt(args, "f:c:")
    DEDENT
    except GetoptError as e :
    INDENT
        print e
    DEDENT
    if not opts or len(opts) ! = 1 :
    INDENT
        usage()
        return 1
    DEDENT
    converters = {
        '-f' : (to_c, '{0} Fahrenheit is {1} Celsius'),
        '-c' : (to_f, '{0} Celsius is {1} Fahrenheit')}

    scale, temp = opts [0] [0], int(opts [0] [1])
    converter = converters [scale] [0]
    output = converters [scale] [1]
    print output.format(temp, converter(temp))
    return 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3224412_3224688_10_20
3224412_3224925_13_36
Title: "Learning Python is there a better way to write this?" 
----------------------------------------

def convert(args) :
INDENT
    if len(args) ! = 2 :
    INDENT
        raise RuntimeError("List of two elememts required")
    DEDENT
    t = int(args [1])
    if args [0] == '-f' :
    INDENT
        print "{0} Fahrenheit is {1} Celsius".format(t, round(to_c(t)))
    DEDENT
    elif args [0] == '-c' :
    INDENT
        print "{0} Celsius is {1} Fahrenheit".format(t, round(to_f(t)))
    DEDENT
    else :
    INDENT
        raise RuntimeError("First element should be -c or -f")
    DEDENT
DEDENT
----------------------------------------

def convert(args) :
INDENT
    opts = None
    try :
    INDENT
        opts, args = getopt(args, "f:c:")
    DEDENT
    except GetoptError as e :
    INDENT
        print e
    DEDENT
    if not opts or len(opts) ! = 1 :
    INDENT
        usage()
        return 1
    DEDENT
    converters = {
        '-f' : (to_c, '{0} Fahrenheit is {1} Celsius'),
        '-c' : (to_f, '{0} Celsius is {1} Fahrenheit')}

    scale, temp = opts [0] [0], int(opts [0] [1])
    converter = converters [scale] [0]
    output = converters [scale] [1]
    print output.format(temp, converter(temp))
    return 0
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32261645_32261669_17_23
32261645_32261669_8_15
Title: Unbound Method With Class Instance 
----------------------------------------

def __init__(self) :
INDENT
    super(Pitcher, self).__init__()
    self.ip = ''
    self.era = ''
    self.strikeouts = ''
    self.walks = ''
    self.sv = ''
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Fielder, self).__init__()
    self.bats = ''
    self.throws = ''
    self.avg = ''
    self.hr = ''
    self.rbi = ''
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32262623_32263696_7_15
32262623_32266956_8_24
Title: wxpython move drawn point with mouse 
----------------------------------------

def __init__(self, parent) :
INDENT
    self.parent = parent
    self.parameters = [36, 36, 30]
    self.advance = 3
    self.parent.Bind(wx.EVT_PAINT, self.on_paint)
    self.timer = wx.Timer(self.parent)
    self.parent.Bind(wx.EVT_TIMER, self.on_timer, self.timer)
    self.timer.Start(100)
DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Frame.__init__(self, parent, id = wx.ID_ANY, size = wx.Size(500, 500))
    bSizer1 = wx.BoxSizer(wx.VERTICAL)
    self.m_panel = wx.Panel(self, wx.ID_ANY)
    bSizer1.Add(self.m_panel, 3, wx.EXPAND | wx.ALL, 5)
    self.bmp = wx.EmptyBitmap(500, 500)
    self.staticBMP = wx.StaticBitmap(self.m_panel, wx.ID_ANY, self.bmp)
    self.SetSizer(bSizer1)

    self.staticBMP.Bind(wx.EVT_LEFT_DOWN, self.OnLeftDown)
    self.staticBMP.Bind(wx.EVT_LEFT_UP, self.OnLeftUp)
    self.staticBMP.Bind(wx.EVT_MOTION, self.OnMove)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32267460_32268098_3_13
32267460_32270724_9_22
Title: Increment Alphabet Python 
----------------------------------------

def resolve(item) :
INDENT
    print (item)
    num = int(re.search(r'\d+', item [0]).group())
    p11 = re.search(r'(\w)(\w)', item [0]).group(1)
    p12 = re.search(r'(\w)(\w)', item [0]).group(2)
    p21 = re.search(r'(\w)(\w)', item [1]).group(1)
    p22 = re.search(r'(\w)(\w)', item [1]).group(2)
    print (p11, p12, p21, p22)
    for word in range(ord(p11), ord(p21) + 1) :
    INDENT
        for word2 in range(ord(p12) if ord(p11) == word else ord('A'), (ord(p22) if ord(p21) == word else ord('Z')) + 1) :
        INDENT
            yield chr(word) + chr(word2) + str(num)
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def resolve(item) :
INDENT
    start_split = re.split("(\d+)", item [0])
    end_split = re.split("(\d+)", item [1])
    trailing = end_split [1]
    start = convert_to_range(start_split [0])
    end = convert_to_range(end_split [0])
    cols = [' ' + string.ascii_uppercase] * len(end_split [0])
    for x in itertools.islice(itertools.product(* cols), start, end + 1) :
    INDENT
        step = "".join(x).lstrip(" ")
        if ' ' in step :
        INDENT
            continue
        DEDENT
        yield step + trailing
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32274854_32275015_33_40
32274854_32275015_9_18
Title: Reference a global object within python tkinter application 
----------------------------------------

def __init__(self, master, id) :
INDENT
    Tkinter.Label.__init__(self, master)
    self._id = str(id)
    self._text = Tkinter.StringVar()
    self._text.set(self._id)
    self.config(textvariable = self._text, width = 3)
    self.bind("<Button-1>", self._onSelect)
DEDENT
----------------------------------------

def __init__(self, root) :
INDENT
    self._root = root
    self._root.protocol("WM_DELETE_WINDOW", self._applicationExit)
    self._string = Tkinter.StringVar()
    self.setLabel('None')
    self._label = Tkinter.Label(self._root, textvariable = self._string,
        width = 10)
    self._label.grid(row = 0, column = 0, padx = 5, pady = 5)
    self._createBoxOverview()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32284395_32285982_1_6
32284395_32297622_27_37
Title: Should extra layers be added just to support __repr__? 
----------------------------------------

def term(token) :
INDENT
    def fn(text) :
    INDENT
        return text.split(token)
    DEDENT
    fn.func_name = "term(token={0!r})".format(token)
    return fn
DEDENT
----------------------------------------

def term(token) :
INDENT
    @ reprcorate
    def fn(text) :
    INDENT
        @ reprcorate
        def fn2(fn2arg) :
        INDENT
            print (token, text, fn2arg)
        DEDENT
        return fn2
    DEDENT
    return fn
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32286419_32286596_1_12
32286419_32288046_3_15
Title: Defining a dictionary in Python 3 
----------------------------------------

def verifylogin() :
INDENT
    people = {}
    with open("moosebook.txt", "r") as f :
    INDENT
        for line in f.read().splitlines() :
        INDENT
            items = line.split(",")
            person = {}
            person ['username'] = items [0]
            person ['password'] = items [1]
            person ['Gender'] = items [2]
            person ['Career'] = items [3]
            people [items [0]] = person
            print (people [items [0]])
        DEDENT
    DEDENT
DEDENT
----------------------------------------

def verifylogin() :
INDENT
    people = {}
    with open("moosebook.txt", "r") as f :
    INDENT
        for person in csv.DictReader(f) :
        INDENT
            print ("Person: ", person)
            username = person ['username']
            del person ['username']
            people [username] = person
        DEDENT
    DEDENT
    print ("People:", people)
    print ("Wilma's career:", people ['Wilma'] ['Career'])
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32297197_34996642_14_23
32297197_34996642_25_47
Title: Update wxpython figure canvas with new figure 
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.shell = Shell(self)
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.sizer.Add(self.shell, 1, wx.GROW)
    self.SetSizer(self.sizer)
    self.Layout()
    self.Fit()

DEDENT
----------------------------------------

def __init__(self, parent) :
INDENT
    wx.Panel.__init__(self, parent)
    self.parent = parent
    self.sizer = wx.BoxSizer(wx.VERTICAL)
    self.figure = Figure(figsize = (8, 6.1), dpi = 60)
    self.ax = self.figure.add_subplot(1, 1, 1)
    self.enlarged_figure = Figure(figsize = (8, 6.1), dpi = 100)
    self.ax2 = self.enlarged_figure.add_subplot(2, 1, 2)
    self.canvas = FigureCanvas(self, - 1, self.figure)
    self.canvas.Show()
    self.enlarged_canvas = FigureCanvas(self, - 1, self.enlarged_figure)
    self.enlarged_canvas.Show()
    self.shellpanel = ShellPanel(self)
    s1 = wx.BoxSizer(wx.VERTICAL)
    s1.Add(self.canvas, 0, wx.GROW)
    s1.Add(self.shellpanel, 1, wx.EXPAND)
    self.sizer.Add(s1, 5, wx.GROW)
    self.SetSizer(self.sizer)
    self.Layout()
    self.Fit()
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32303391_32404927_1_38
32303391_52752300_3_13
Title: Drawing a snowflake using recursion 
----------------------------------------

def makeFlake(length, depth, isRoot = True) :
INDENT
    if depth > 0 :
    INDENT
        forward(length)
        makeFlake(length / / 3, depth - 1, False)
        backward(length)
        left(60)
        forward(length)
        makeFlake(length / / 3, depth - 1, False)
        backward(length)
        left(60)
        forward(length)
        makeFlake(length / / 3, depth - 1, False)
        backward(length)
        left(60)
        forward(length)
        if isRoot == True :
        INDENT
            makeFlake(length / / 3, depth - 1, False)
        DEDENT
        backward(length)
        left(60)
        forward(length)
        makeFlake(length / / 3, depth - 1, False)
        backward(length)
        left(60)
        forward(length)
        makeFlake(length / / 3, depth - 1, False)
        backward(length)
        left(60)
    DEDENT
DEDENT
----------------------------------------

def makeFlake(length, depth, isRoot = True) :
INDENT
    if depth > 0 :
    INDENT
        for branch in range(6) :
        INDENT
            if isRoot or branch ! = 3 :
            INDENT
                forward(length)
                makeFlake(length / 3, depth - 1, False)
                backward(length)
            DEDENT
            left(60)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32303614_32303754_3_8
32303614_32304617_6_13
Title: python multiprocessing: processes don't work 
----------------------------------------

def func(my_id, q, begin, end) :
INDENT
    global myarray
    print ('Process %d has range: %d - %d' % (my_id, begin, end))
    for i in range(begin, end) :
    INDENT
        q.put((i, i * 2))
    DEDENT
DEDENT
----------------------------------------

def func(begin, end) :
INDENT
    print ('*' * 5)
    print ('begin=%d' % (begin))
    for i in range(begin, end) :
    INDENT
        for j in range(10) :
        INDENT
            with lock :
            INDENT
                myarray [i] [j] = 1
            DEDENT
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32317739_32407428_27_44
32317739_32407428_5_23
Title: Qt.ScrollBarAsNeeded not showing scrollbar when it's actually needed 
----------------------------------------

def __init__(self, alignment = 0, parent = None) :
INDENT
    super().__init__(parent)
    self.mainWidget = QtWidgets.QWidget(self)
    self.mainLayout = QtWidgets.QVBoxLayout(self.mainWidget)
    self.mainLayout.setAlignment(alignment)
    self.mainLayout.setContentsMargins(0, 0, 0, 0)
    self.mainLayout.setSpacing(0)
    self.setContentsMargins(0, 0, 0, 0)
    self.setFrameStyle(QtWidgets.QFrame.NoFrame)
    self.setFixedWidth(Pane.MinWidth)
    self.setHorizontalScrollBarPolicy(QtCore.Qt.ScrollBarAlwaysOff)
    self.setVerticalScrollBarPolicy(QtCore.Qt.ScrollBarAsNeeded)
    self.setSizePolicy(QtWidgets.QSizePolicy.Maximum,
        QtWidgets.QSizePolicy.Ignored)
    self.setWidgetResizable(True)
    self.setWidget(self.mainWidget)
    self.verticalScrollBar().installEventFilter(self)
DEDENT
----------------------------------------

def __init__(self) :
INDENT
    super(Window, self).__init__()
    widget = QtWidgets.QWidget(self)
    layout = QtWidgets.QHBoxLayout(widget)
    self.mdi = QtWidgets.QMdiArea(self)
    self.leftScroll = Pane(
        QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft, self)
    self.rightScroll = Pane(
        QtCore.Qt.AlignTop | QtCore.Qt.AlignLeft, self)
    layout.addWidget(self.leftScroll)
    layout.addWidget(self.mdi)
    layout.addWidget(self.rightScroll)
    self.setCentralWidget(widget)
    for scroll in self.leftScroll, self.rightScroll :
    INDENT
        for index in range(4) :
        INDENT
            widget = QtWidgets.QTextEdit()
            widget.setText('one two three four five')
            scroll.addWidget(widget)
        DEDENT
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3232943_14048316_1_16
3232943_32357112_2_13
Title: Update value of a nested dictionary of varying depth 
----------------------------------------

def update(d, u, depth = - 1) :
INDENT
    for k, v in u.iteritems() :
    INDENT
        if isinstance(v, Mapping) and not depth == 0 :
        INDENT
            r = update(d.get(k, {}), v, depth = max(depth - 1, - 1))
            d [k] = r
        DEDENT
        elif isinstance(d, Mapping) :
        INDENT
            d [k] = u [k]
        DEDENT
        else :
        INDENT
            d = {k : u [k]}
        DEDENT
    DEDENT
    return d
DEDENT
----------------------------------------

def update(d, u) :
INDENT
    for k, v in u.iteritems() :
    INDENT
        if isinstance(d, collections.Mapping) :
        INDENT
            if isinstance(v, collections.Mapping) :
            INDENT
                r = update(d.get(k, {}), v)
                d [k] = r
            DEDENT
            else :
            INDENT
                d [k] = u [k]
            DEDENT
        DEDENT
        else :
        INDENT
            d = {k : u [k]}
        DEDENT
    DEDENT
    return d
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3232943_31861045_2_12
3232943_32357112_2_13
Title: Update value of a nested dictionary of varying depth 
----------------------------------------

def update(orig_dict, new_dict) :
INDENT
    for key, val in dict(new_dict).iteritems() :
    INDENT
        if isinstance(val, collections.Mapping) :
        INDENT
            tmp = update(orig_dict.get(key, {}), val)
            orig_dict [key] = tmp
        DEDENT
        elif isinstance(val, list) :
        INDENT
            orig_dict [key] = (orig_dict [key] + val)
        DEDENT
        else :
        INDENT
            orig_dict [key] = new_dict [key]
        DEDENT
    DEDENT
    return orig_dict
DEDENT
----------------------------------------

def update(d, u) :
INDENT
    for k, v in u.iteritems() :
    INDENT
        if isinstance(d, collections.Mapping) :
        INDENT
            if isinstance(v, collections.Mapping) :
            INDENT
                r = update(d.get(k, {}), v)
                d [k] = r
            DEDENT
            else :
            INDENT
                d [k] = u [k]
            DEDENT
        DEDENT
        else :
        INDENT
            d = {k : u [k]}
        DEDENT
    DEDENT
    return d
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32333870_35705477_4_43
32333870_41600150_25_67
Title: How can I show a km ruler on a cartopy / matplotlib plot? 
----------------------------------------

def scale_bar(ax, length = None, location = (0.5, 0.05), linewidth = 3) :
INDENT
    llx0, llx1, lly0, lly1 = ax.get_extent(ccrs.PlateCarree())

    sbllx = (llx1 + llx0) / 2
    sblly = lly0 + (lly1 - lly0) * location [1]
    tmc = ccrs.TransverseMercator(sbllx, sblly)
    x0, x1, y0, y1 = ax.get_extent(tmc)
    sbx = x0 + (x1 - x0) * location [0]
    sby = y0 + (y1 - y0) * location [1]

    if not length :
    INDENT
        length = (x1 - x0) / 5000
        ndim = int(np.floor(np.log10(length)))
        length = round(length, - ndim)
        def scale_number(x) :
        INDENT
            if str(x) [0] in ['1', '2', '5'] : return int(x)
            else : return scale_number(x - 10 ** ndim)
        DEDENT
        length = scale_number(length)

    DEDENT
    bar_xs = [sbx - length * 500, sbx + length * 500]
    ax.plot(bar_xs, [sby, sby], transform = tmc, color = 'k', linewidth = linewidth)
    ax.text(sbx, sby, str(length) + ' km', transform = tmc,
        horizontalalignment = 'center', verticalalignment = 'bottom')
DEDENT
----------------------------------------

def scale_bar(ax, proj, length, location = (0.5, 0.05), linewidth = 3,
units = 'km', m_per_unit = 1000) :
INDENT
    x0, x1, y0, y1 = ax.get_extent(proj.as_geodetic())
    utm = ccrs.UTM(utm_from_lon((x0 + x1) / 2))
    x0, x1, y0, y1 = ax.get_extent(utm)
    sbcx, sbcy = x0 + (x1 - x0) * location [0], y0 + (y1 - y0) * location [1]
    bar_xs = [sbcx - length * m_per_unit / 2, sbcx + length * m_per_unit / 2]
    buffer = [patheffects.withStroke(linewidth = 5, foreground = "w")]
    ax.plot(bar_xs, [sbcy, sbcy], transform = utm, color = 'k',
        linewidth = linewidth, path_effects = buffer)
    buffer = [patheffects.withStroke(linewidth = 3, foreground = "w")]
    t0 = ax.text(sbcx, sbcy, str(length) + ' ' + units, transform = utm,
        horizontalalignment = 'center', verticalalignment = 'bottom',
        path_effects = buffer, zorder = 2)
    left = x0 + (x1 - x0) * 0.05
    t1 = ax.text(left, sbcy, u'\u25B2\nN', transform = utm,
        horizontalalignment = 'center', verticalalignment = 'bottom',
        path_effects = buffer, zorder = 2)
    ax.plot(bar_xs, [sbcy, sbcy], transform = utm, color = 'k',
        linewidth = linewidth, zorder = 3)
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32360921_32361091_12_17
32360921_32361091_2_7
Title: python classes using functions of other classes 
----------------------------------------

def __init__(self, name, conveyors) :
INDENT
    self.list_conveyors = list(conveyors)
    self.naam = name
    for c in conveyors :
    INDENT
        c.zone = self
    DEDENT
DEDENT
----------------------------------------

def __init__(self, name, zones) :
INDENT
    self.list_zones = list(zones)
    self.name = name
    for zone in zones :
    INDENT
        zone.plc = self
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32368499_32368781_1_18
32368499_32369562_1_10
Title: What is wrong with following code in Python? 
----------------------------------------

def _check_contact_number(self, cr, uid, ids, context = None) :
INDENT
    for rec in self.browse(cr, uid, ids, context = context) :
    INDENT
        if rec.contact_number :
        INDENT
            size = len(str(rec.contact_number))
            if size < 10 :
            INDENT
                return False
            DEDENT
        DEDENT
        if not contact_number :
        INDENT
            return {}
            contact_number = rec.contact_number.replace('.', '')
            contact_number = rec.contact_number.replace(' ', '')
        DEDENT
        if not contact_number.isdigit() :
        INDENT
            return False
        DEDENT
        return {}
    DEDENT
    _constraints = [
        (_check_contact_number, 'Enter valid phone number...!', ['contact_number']),
        ]
DEDENT
----------------------------------------

def _check_contact_number(self, cr, uid, ids, context = None) :
INDENT
    for rec in self.browse(cr, uid, ids, context = context) :
    INDENT
        if rec.contact_number :
        INDENT
            if len(str(rec.contact_number)) < 10 :
            INDENT
                return False
            DEDENT
            contact_number = str(rec.contact_number).replace('.', '').replace(' ', '')
            if not contact_number.isdigit() :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32368499_32368781_1_18
32368499_32395347_3_12
Title: What is wrong with following code in Python? 
----------------------------------------

def _check_contact_number(self, cr, uid, ids, context = None) :
INDENT
    for rec in self.browse(cr, uid, ids, context = context) :
    INDENT
        if rec.contact_number :
        INDENT
            size = len(str(rec.contact_number))
            if size < 10 :
            INDENT
                return False
            DEDENT
        DEDENT
        if not contact_number :
        INDENT
            return {}
            contact_number = rec.contact_number.replace('.', '')
            contact_number = rec.contact_number.replace(' ', '')
        DEDENT
        if not contact_number.isdigit() :
        INDENT
            return False
        DEDENT
        return {}
    DEDENT
    _constraints = [
        (_check_contact_number, 'Enter valid phone number...!', ['contact_number']),
        ]
DEDENT
----------------------------------------

def _check_contact_number(self) :
INDENT
    contact_number = self.contact_number.replace('.', '').replace(' ', '')
    if len(contact_number) < 10 :
    INDENT
        raise exceptions.ValidationError(
            "Phone number has to contain at least 10 digits!")
    DEDENT
    if not contact_number.isdigit() :
    INDENT
        raise exceptions.ValidationError(
            "Phone number can only contain digits, spaces and dots!")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32368499_32368897_1_24
32368499_32369562_1_10
Title: What is wrong with following code in Python? 
----------------------------------------

def _check_contact_number(self, cr, uid, ids, context = None) :
INDENT
    for rec in self.browse(cr, uid, ids, context = context) :
    INDENT

        contact_number = rec.contact_number.replace('.', '')
        contact_number = rec.contact_number.replace(' ', '')
        contact_number = rec.contact_number.replace('-', '')
        if rec.contact_number :
        INDENT
            size = len(str(rec.contact_number))
            if size < 10 :
            INDENT
                return False
            DEDENT
        DEDENT
        if not contact_number :
        INDENT
            return {}
        DEDENT
        if not contact_number.isdigit() :
        INDENT
            return False
        DEDENT
        return {}
    DEDENT
    _constraints = [
        (_check_contact_number, 'Enter valid phone number...!',
            ['contact_number']),
        ]
DEDENT
----------------------------------------

def _check_contact_number(self, cr, uid, ids, context = None) :
INDENT
    for rec in self.browse(cr, uid, ids, context = context) :
    INDENT
        if rec.contact_number :
        INDENT
            if len(str(rec.contact_number)) < 10 :
            INDENT
                return False
            DEDENT
            contact_number = str(rec.contact_number).replace('.', '').replace(' ', '')
            if not contact_number.isdigit() :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32368499_32368897_1_24
32368499_32395347_3_12
Title: What is wrong with following code in Python? 
----------------------------------------

def _check_contact_number(self, cr, uid, ids, context = None) :
INDENT
    for rec in self.browse(cr, uid, ids, context = context) :
    INDENT

        contact_number = rec.contact_number.replace('.', '')
        contact_number = rec.contact_number.replace(' ', '')
        contact_number = rec.contact_number.replace('-', '')
        if rec.contact_number :
        INDENT
            size = len(str(rec.contact_number))
            if size < 10 :
            INDENT
                return False
            DEDENT
        DEDENT
        if not contact_number :
        INDENT
            return {}
        DEDENT
        if not contact_number.isdigit() :
        INDENT
            return False
        DEDENT
        return {}
    DEDENT
    _constraints = [
        (_check_contact_number, 'Enter valid phone number...!',
            ['contact_number']),
        ]
DEDENT
----------------------------------------

def _check_contact_number(self) :
INDENT
    contact_number = self.contact_number.replace('.', '').replace(' ', '')
    if len(contact_number) < 10 :
    INDENT
        raise exceptions.ValidationError(
            "Phone number has to contain at least 10 digits!")
    DEDENT
    if not contact_number.isdigit() :
    INDENT
        raise exceptions.ValidationError(
            "Phone number can only contain digits, spaces and dots!")
    DEDENT
DEDENT
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
32368499_32369562_1_10
32368499_32395347_3_12
Title: What is wrong with following code in Python? 
----------------------------------------

def _check_contact_number(self, cr, uid, ids, context = None) :
INDENT
    for rec in self.browse(cr, uid, ids, context = context) :
    INDENT
        if rec.contact_number :
        INDENT
            if len(str(rec.contact_number)) < 10 :
            INDENT
                return False
            DEDENT
            contact_number = str(rec.contact_number).replace('.', '').replace(' ', '')
            if not contact_number.isdigit() :
            INDENT
                return False
            DEDENT
        DEDENT
        return True
    DEDENT
DEDENT
----------------------------------------

def _check_contact_number(self) :
INDENT
    contact_number = self.contact_number.replace('.', '').replace(' ', '')
    if len(contact_number) < 10 :
    INDENT
        raise exceptions.ValidationError(
            "Phone number has to contain at least 10 digits!")
    DEDENT
    if not contact_number.isdigit() :
    INDENT
        raise exceptions.ValidationError(
            "Phone number can only contain digits, spaces and dots!")
    DEDENT
DEDENT
----------------------------------------
