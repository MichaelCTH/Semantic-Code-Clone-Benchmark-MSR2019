$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42878643_42878739_1_11
42878643_42878750_1_18
Title: how to check a string for a specific character 
----------------------------------------

char *strrchr (const char *s, int c) {
    int index = 0;
    for (int i = 0; i < strlen (s); i++) {
        if (s[i] == c)
            index = i;
    }
    if (index == -1)
        return NULL;
    else
        return &s[index];
}
----------------------------------------

char *strrchr (const char *s, int c) {
    size_t index = 0;
    bool found = false;
    c = (char) c;
    if (!c)
        return (char *) s + strlen (s);
    for (size_t i = 0; s[i]; i++) {
        if (s[i] == c) {
            index = i;
            found = true;
        }
    }
    if (found)
        return (char *) s + index;
    return NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42878643_42878739_1_11
42878643_42879222_1_14
Title: how to check a string for a specific character 
----------------------------------------

char *strrchr (const char *s, int c) {
    int index = 0;
    for (int i = 0; i < strlen (s); i++) {
        if (s[i] == c)
            index = i;
    }
    if (index == -1)
        return NULL;
    else
        return &s[index];
}
----------------------------------------

char *strrchr (const char *s, int c) {
    char *result = NULL;
    for (c = (char) c;; s++) {
        if (*s == c) {
            result = (char *) s;
        }
        if (*s == '\0') {
            break;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42878643_42878750_1_18
42878643_42879222_1_14
Title: how to check a string for a specific character 
----------------------------------------

char *strrchr (const char *s, int c) {
    size_t index = 0;
    bool found = false;
    c = (char) c;
    if (!c)
        return (char *) s + strlen (s);
    for (size_t i = 0; s[i]; i++) {
        if (s[i] == c) {
            index = i;
            found = true;
        }
    }
    if (found)
        return (char *) s + index;
    return NULL;
}
----------------------------------------

char *strrchr (const char *s, int c) {
    char *result = NULL;
    for (c = (char) c;; s++) {
        if (*s == c) {
            result = (char *) s;
        }
        if (*s == '\0') {
            break;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42890110_42890856_1_23
42890110_42891092_1_16
Title: "Why does this code segment used to reverse print a singly connected linked list not work as expected?" 
----------------------------------------

void printRev (void *l) {
    list_sll *list = (list_sll *) l;
    int i = list->noOfNodes;
    node_sll subject = {0, list->start};
    node_sll *front = NULL;
    while (i != 0) {
        node_sll *current = &subject;
        while (current->next != front)
            current = current->next;
        --i;
        printf ("%d. %d\n", i, current -> data);
        front = current;
    }
}
----------------------------------------

int printRev (void *l) {
    list_sll *list = (list_sll *) l;
    int i = list->noOfNodes - 1;
    node_sll *subject = list->start;
    node_sll *front = NULL;
    do {
        while (subject->next != front)
            subject = subject->next;
        printf ("%d. %d\n", i, subject -> data);
        front = subject;
        subject = list->start;
        --i;
    }
    while (front != list->start);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42895420_42895802_26_85
42895420_42895802_88_141
Title: FILE reading and sorting a link list 
----------------------------------------

student *buildStudentList (char *studentFile, student *head) {
    FILE *cfptr = fopen (studentFile, "r");
    if (cfptr == NULL) {
        printf ("\nFIle could not be opened\n");
        return 0;
    }
    if (head == NULL) {
        head = malloc (sizeof (student));
        head->next = NULL;
        head->firstName = malloc (35);
        head->lastName = malloc (35);
        fscanf (cfptr, "%s %s %d %d", head -> firstName, head -> lastName, & head -> priority, & head -> readingLevel);
    }
    student *current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = malloc (sizeof (student));
    current = current->next;
    current->firstName = malloc (sizeof (student) * 35);
    current->lastName = malloc (sizeof (student) * 35);
    while (fscanf (cfptr, "%s %s %d %d", current->firstName, current->lastName, &current->priority, &current->readingLevel) != EOF) {
        student *current = head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = malloc (sizeof (student));
        current = current->next;
        current->firstName = malloc (sizeof (student) * 35);
        current->lastName = malloc (sizeof (student) * 35);
    }
    return head;
}
----------------------------------------

student *buildStudentList (char *studentFile, student *head) {
    FILE *cfptr = fopen (studentFile, "r");
    student *current;
    student *tail;
    char firstName [5000];
    char lastName [5000];
    if (cfptr == NULL) {
        printf ("\nFIle could not be opened\n");
        return 0;
    }
    tail = NULL;
    for (current = head; current != NULL; current = current->next)
        tail = current;
    while (1) {
        current = malloc (sizeof (student));
        current->next = NULL;
        if (fscanf (cfptr, "%s %s %d %d", firstName, lastName, &current->priority, &current->readingLevel) == EOF) {
            free (current);
            break;
        }
        current->firstName = strdup (firstName);
        current->lastName = strdup (lastName);
        if (head == NULL)
            head = current;
        else
            tail->next = current;
        tail = current;
    }
    fclose (cfptr);
    return head;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42896138_42896352_3_14
42896138_42896373_2_19
Title: Constant Variable in Switch Case in C language 
----------------------------------------

int main () {
    int num = 3;
    switch (num) {
    case var :
        printf ("constant var");
        break;
    }
    return 0;
}
----------------------------------------

int main () {
    int num = 3;
    switch (num) {
    case 3 :
        printf ("constant var");
        break;
    case 4 :
        printf ("Test case");
        break;
    default :
        printf ("Default case");
        break;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42903600_42930859_37_51
42903600_42945853_25_36
Title: Ring Buffer on C 
----------------------------------------

int pushBack (struct ringBuffer *buffer, char *data) {
    if (buffer->used == buffer->capacity) {
        printf ("Capacity error\n");
        buffer->bufferData = 0;
    }
    memcpy ((ringBuffer *) buffer -> head, data, buffer -> size);
    buffer->head = buffer->head + buffer->size;
    if (buffer->head == (char) buffer->bufferEnd) {
        buffer->head = (char) buffer->bufferData;
    }
    buffer->used++;
    return 0;
}
----------------------------------------

int pushBack (struct ringBuffer *buffer, char *data, int size) {
    if (size > buffer->size - buffer->used)
        return -1;
    for (; size > 0 && buffer->used < buffer->size; buffer->used++, size--) {
        *buffer->head = *data;
        buffer->head++;
        data++;
        if (buffer->head == buffer->end)
            buffer->head = buffer->bufferData;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42903600_42930859_53_67
42903600_42945853_38_49
Title: Ring Buffer on C 
----------------------------------------

int popFront (struct ringBuffer *buffer, char *data) {
    if (buffer->used == 0) {
        printf ("Buffer is clear\n");
    }
    memcpy (data, (ringBuffer *) buffer -> tail, buffer -> size);
    buffer->tail = (char) buffer->tail + buffer->size;
    if (buffer->tail == (char) buffer->bufferEnd) {
        buffer->tail = (char) buffer->bufferData;
    }
    buffer->used--;
    return 0;
}
----------------------------------------

int popFront (struct ringBuffer *buffer, char *data, int size) {
    if (size > buffer->used)
        return -1;
    for (; size > 0 && buffer->used > 0; buffer->used--, size--) {
        *data = *buffer->tail;
        buffer->tail++;
        data++;
        if (buffer->tail == buffer->end)
            buffer->tail = buffer->bufferData;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42903600_42930859_53_67
42903600_42983502_49_60
Title: Ring Buffer on C 
----------------------------------------

int popFront (struct ringBuffer *buffer, char *data) {
    if (buffer->used == 0) {
        printf ("Buffer is clear\n");
    }
    memcpy (data, (ringBuffer *) buffer -> tail, buffer -> size);
    buffer->tail = (char) buffer->tail + buffer->size;
    if (buffer->tail == (char) buffer->bufferEnd) {
        buffer->tail = (char) buffer->bufferData;
    }
    buffer->used--;
    return 0;
}
----------------------------------------

int popFront (struct ringBuffer *buffer) {
    if (buffer->head != buffer->tail) {
        buffer->head++;
        if (buffer->head == buffer->size) {
            buffer->head = 0;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42903600_42930859_69_98
42903600_42983502_62_109
Title: Ring Buffer on C 
----------------------------------------

int main () {
    struct ringBuffer buffer;
    int size = 6;
    int capacity = 10;
    bufferInitialization (& buffer, capacity, size);
    char *data [] = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20"};
    for (int i = 0; i < size; i++) {
        printf ("Push: data[%d] = %d\n", i, * data [i]);
        pushBack (& buffer, (char *) data [i]);
    }
    printf ("\n");
    for (int i = 0; i < size; i++) {
        printf ("PushBack: queue[%d] = %s\n", i, (ringBuffer *) popFront (& buffer, (char *) data [i]));
    }
    printf ("\n");
    for (int i = 0; i < size; i++) {
        printf ("PopFront: data[%d] = %s : %s\n", i, * data [i]);
        pushBack (& buffer, (char *) data [i]);
    }
    printf ("\n");
    system ("pause");
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    struct ringBuffer buffer;
    int size = 8;
    int data [] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30};
    int dataSize = sizeof (data) / sizeof (data[0]);
    bufferInitialization (& buffer, size);
    printf ("Head : %d - Tail: %d\n", buffer.head, buffer.tail);
    pushBack (& buffer, 5);
    printf ("Head : %d - Tail: %d\n", buffer.head, buffer.tail);
    popFront (& buffer);
    printf ("Head : %d - Tail: %d\n", buffer.head, buffer.tail);
    printf ("\nnumElements in data = %d : bufferSize = %d\n\n", dataSize, size);
    bufferFree (& buffer);
    printf ("INITIALIZATION\n");
    bufferInitialization (& buffer, size);
    printf ("Head : %d - Tail: %d\n", buffer.head, buffer.tail);
    printf ("\nPUSHBACK\n\n");
    for (int i = 0; i < dataSize; i++) {
        pushBack (& buffer, data [i]);
        printf ("Head : %d - Tail : %d :: Data = %d (data[%d])   \n", buffer.head, buffer.tail, data [i], i);
        popFront (& buffer);
    }
    popFront (& buffer);
    printf ("Head : %d - Tail : %d :: (popFront)\n", buffer.head, buffer.tail);
    printf ("\nbufferData check:\n");
    for (int i = 0; i < size; i++) {
        printf ("[%d] = %d  ", i, buffer.bufferData [i]);
    }
    printf ("\nHead : %d - Tail : %d\n", buffer.head, buffer.tail);
    bufferFree (& buffer);
    system ("pause");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42903600_42945853_38_49
42903600_42983502_49_60
Title: Ring Buffer on C 
----------------------------------------

int popFront (struct ringBuffer *buffer, char *data, int size) {
    if (size > buffer->used)
        return -1;
    for (; size > 0 && buffer->used > 0; buffer->used--, size--) {
        *data = *buffer->tail;
        buffer->tail++;
        data++;
        if (buffer->tail == buffer->end)
            buffer->tail = buffer->bufferData;
    }
    return 0;
}
----------------------------------------

int popFront (struct ringBuffer *buffer) {
    if (buffer->head != buffer->tail) {
        buffer->head++;
        if (buffer->head == buffer->size) {
            buffer->head = 0;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42910246_42910602_3_20
42910246_42910676_2_17
Title: Why is scanf skipping the input here? 
----------------------------------------

int main () {
    char another;
    int num;
    do {
        printf ("enter the number ");
        scanf ("%d", & num);
        printf ("square of %d is %d\n", num, num * num);
        printf ("want to check another number y/n ");
        scanf (" %c", & another);
    }
    while (another == 'y');
    return 0;
}
----------------------------------------

int main () {
    char another, nl;
    int num;
    do {
        printf ("enter the number");
        scanf ("%d%c", & num, & nl);
        printf ("square of%d is %d\n", num, num * num);
        printf ("want to check another number y/n: ");
        scanf ("%c", & another);
        printf ("%c", another);
    }
    while (another == 'y');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42910246_42910602_3_20
42910246_42912002_2_19
Title: Why is scanf skipping the input here? 
----------------------------------------

int main () {
    char another;
    int num;
    do {
        printf ("enter the number ");
        scanf ("%d", & num);
        printf ("square of %d is %d\n", num, num * num);
        printf ("want to check another number y/n ");
        scanf (" %c", & another);
    }
    while (another == 'y');
    return 0;
}
----------------------------------------

int main () {
    char another, nl;
    int num;
    do {
        printf ("enter the number");
        scanf ("%d%c", & num, & nl);
        fseek (stdin, 0, SEEK_END);
        printf ("square of%d is %d\n", num, num * num);
        printf ("want to check another number y/n: ");
        scanf ("%c", & another);
        fseek (stdin, 0, SEEK_END);
        printf ("%c", another);
    }
    while (another == 'y');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42978501_42978660_2_16
42978501_42979148_5_22
Title: pointer string is not taking input in C programming 
----------------------------------------

int main () {
    int w, p = 0;
    char *name [1000];
    char line [1024];
    for (w = 0; p != 2; w++) {
        printf ("Add a name: ");
        fgets (line, 1024, stdin);
        name[w] = malloc (strlen (line) +1);
        strcpy (name [w], line);
        printf ("Want to add another one?\n1 for yes\n2 for no\n");
        scanf ("%d", & p);
    }
}
----------------------------------------

int main () {
    int w = 0;
    int ret = 0;
    int p = 1;
    char line [1024];
    char **tab = (char **) malloc (1000 * sizeof (char *));
    for (w = 0; p == 1; w++) {
        printf ("Add a name: ");
        ret = read (0, &line, 1024);
        line[ret] = 0;
        printf (line);
        tab[w] = strdup (line);
        printf ("Want to add another one?\n1 for yes\n2 for no\n");
        scanf ("%d", & p);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42985344_42987601_1_10
42985344_42989301_1_12
Title: Reversing a Linked List using recursion in C 
----------------------------------------

void reverse (LL_t *L) {
    if (L->head != L->tail) {
        node_t *node = L->head;
        L->head = node->next;
        node->next = NULL;
        reverse (L);
        L->tail = L->tail->next = node;
    }
}
----------------------------------------

void reverse (LL_t *L) {
    node_t *head;
    if (L->head == NULL || L->head->next == NULL)
        return;
    head = L->head;
    L->head = head->next;
    reverse (L);
    head->next->next = head;
    head->next = NULL;
    L->tail = head;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42991150_42991938_24_44
42991150_42992178_35_67
Title: Linked List not printing 
----------------------------------------

int main () {
    struct Node *newNode = (struct Node *) malloc (sizeof (struct Node));
    struct Node *head = newNode;
    struct Node *temp = newNode;
    head->d = 1;
    int i = 0;
    printf ("Enter 3 numbers");
    for (i = 0; i < 3; i++) {
        struct Node *newNode = (struct Node *) malloc (sizeof (struct Node));
        scanf ("%d", & temp -> d);
        temp->next = newNode;
        temp = temp->next;
    }
    printList (head);
    return 0;
}
----------------------------------------

int main () {
    struct Node *newNode = NULL;
    struct Node *headNode = NULL;
    struct Node *temp = NULL;
    int i = 0;
    int data = 0;
    printf ("Enter 3 numbers\n");
    for (i = 0; i < 3; i++) {
        scanf ("%d", & data);
        newNode = createNode ();
        if (NULL == newNode)
            break;
        newNode->d = data;
        if (headNode == NULL) {
            headNode = newNode;
            temp = newNode;
        }
        else {
            temp->next = newNode;
            temp = temp->next;
        }
    }
    printList (headNode);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
42997455_42998210_7_22
42997455_50736700_91_109
Title: Counting number of vowels in input of given words 
----------------------------------------

int main (void) {
    char s1 [51];
    int i, v;
    while (scanf ("%50s", s1) == 1) {
        for (i = v = 0; s1[i] != '\0'; i++) {
            if (isVowel (s1[i])) {
                v++;
            }
        }
        printf ("%d\n", v);
        if (isExit (s1))
            break;
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    if (argc < 2) {
        printf ("Usage: %s <str1> <str2> ...\n", argv [0]);
        return -1;
    }
    for (i = 1; i < argc; i++) {
        printf ("[%s]\n", argv [i]);
        print_vowel_cnt (argv [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43004791_43005044_5_24
43004791_43005150_3_21
Title: how to increment an array in c 
----------------------------------------

int main () {
    int array *, i, n;
    printf ("Enter size of array:\n");
    scanf ("%d", & n);
    array = malloc (n * sizeof (int));
    array += n;
    free (array);
    return 0;
}
----------------------------------------

void main (void) {
    struct info {
        int a;
        int b;
    };
    struct info array [10];
    struct info *p;
    int n;
    p = &(array[0]);
    printf ("sizeof(*p): %zu\n", sizeof (* p));
    for (n = 0; n < 10; n++) {
        printf ("address: %p\n", p);
        p += 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4300569_4300671_1_20
4300569_4300731_4_17
Title: sscanf - get nth word in a sentence 
----------------------------------------

int set_to_nth_word (char *word, const char *input, int n) {
    int chars_used;
    word[0] = '\0';
    while (n > 0 && sscanf (input, "%s%n", word, &chars_used) > 0) {
        input += chars_used;
        n--;
    }
    if (n > 0) {
        printf ("You didn't enter enough values\n");
        return 0;
    }
    return 1;
}
----------------------------------------

int set_to_nth_word (char *word, const char *input, int n) {
    int i;
    size_t used = 0;
    char convert [1000];
    static const char convertPattern [] = " %*s";
    static const char convertReal [] = " %s";
    if ((unsigned) n > sizeof convert / sizeof convertPattern - 1)
        return 0;
    for (i = 1; i < n; ++i)
        used += sprintf (convert +used, "%s", convertPattern);
    sprintf (convert + used, "%s", convertReal);
    return sscanf (input, convert, word) == 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43032130_43032214_4_25
43032130_43032410_1_14
Title: How to break out of loop for blank input 
----------------------------------------

int main (void) {
    while (1) {
        char buf [200];
        int integer;
        printf ("enter integer: ");
        fflush (stdout);
        if (!fgets (buf, sizeof buf, stdin)) {
            break;
        }
        buf[strcspn (buf, "\n")] = '\0';
        if (buf[0] == '\0') {
            break;
        }
        sscanf (buf, "%d", & integer);
    }
    return 0;
}
----------------------------------------

int main () {
    while (1) {
        int integer;
        char input [1024];
        printf ("enter integer:");
        fgets (input, sizeof (input), stdin);
        if (strcmp (input, "\n") == 0)
            break;
        integer = atoi (input);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43032130_43032214_4_25
43032130_45847442_1_12
Title: How to break out of loop for blank input 
----------------------------------------

int main (void) {
    while (1) {
        char buf [200];
        int integer;
        printf ("enter integer: ");
        fflush (stdout);
        if (!fgets (buf, sizeof buf, stdin)) {
            break;
        }
        buf[strcspn (buf, "\n")] = '\0';
        if (buf[0] == '\0') {
            break;
        }
        sscanf (buf, "%d", & integer);
    }
    return 0;
}
----------------------------------------

int main () {
    while (1) {
        int integer = -1;
        printf ("enter integer:");
        scanf ("%d", & integer);
        if (integer == -1)
            break;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43032130_43032410_1_14
43032130_45847442_1_12
Title: How to break out of loop for blank input 
----------------------------------------

int main () {
    while (1) {
        int integer;
        char input [1024];
        printf ("enter integer:");
        fgets (input, sizeof (input), stdin);
        if (strcmp (input, "\n") == 0)
            break;
        integer = atoi (input);
    }
    return 0;
}
----------------------------------------

int main () {
    while (1) {
        int integer = -1;
        printf ("enter integer:");
        scanf ("%d", & integer);
        if (integer == -1)
            break;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43035832_43035899_3_26
43035832_51324733_3_25
Title: C program that calculates weekly pay and overtime pay not working? Debugging 
----------------------------------------

int main () {
    double payrate;
    double hours;
    double weeklypay = hours * payrate;
    double overtimehours = hours - 40;
    double overtimepay = weeklypay * 1.5;
    double overtimesalary = weeklypay + (overtimehours * overtimepay);
    printf ("What is your standard hourly pay rate?\n");
    scanf ("%d", & payrate);
    printf ("How many hours do you work in a week?\n");
    scanf ("%d", & hours);
    if (hours <= 40)
        printf ("This means your weekly pay is %d . \n", weeklypay);
    else
        printf ("This means your weekly pay is %d . \n", overtimesalary);
    return 0;
}
----------------------------------------

int main () {
    int payrate;
    int hours;
    printf ("What is your standard hourly pay rate? \n");
    scanf ("%d", & payrate);
    printf ("How many hours do you work in a week? \n");
    scanf ("%d", & hours);
    int weeklypay = hours * payrate;
    int overtimehours = hours - 40;
    int overtimepay = weeklypay * 1.5;
    int overtimesalary = weeklypay + (overtimehours * overtimepay);
    if (hours <= 40)
        printf ("This means your weekly pay is %d . \n", weeklypay);
    else
        printf ("This means your weekly pay is %d . \n", overtimesalary);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43059810_43061511_163_211
43059810_43120731_264_288
Title: Why isn't my global allocation structure updating values correctly? 
----------------------------------------

int main (int argc, char *argv []) {
    int input [NUMBER_OF_RESOURCES];
    for (int i = 0; i < NUMBER_OF_RESOURCES; ++i)
        input[i] = 10;
    if (argc > NUMBER_OF_RESOURCES) {
        for (int i = 0; i < NUMBER_OF_RESOURCES; ++i) {
            input[i] = strtol (argv[i + 1], NULL, 10);
        }
    }
    int result;
    for (int i = 0; i < NUMBER_OF_RESOURCES; ++i) {
        available[i] = input[i];
    }
    for (int i = 0; i < NUMBER_OF_CUSTOMERS; ++i) {
        for (int j = 0; j < NUMBER_OF_RESOURCES; ++j) {
            maximum[i][j] = input[j] - 4;
            need[i][j] = 2;
        }
    }
    Thread threads [NUMBER_OF_CUSTOMERS];
    struct ThreadParams params [NUMBER_OF_CUSTOMERS];
    for (int i = 0; i < NUMBER_OF_CUSTOMERS; ++i) {
        printf ("Creating customer %d\n", i + 1);
        params[i].req[0] = 2;
        params[i].req[1] = 2;
        params[i].req[2] = 2;
        params[i].threadNum = i;
        result = startThread (threads +i, &request_resources, params +i);
    }
    for (int i = 0; i < NUMBER_OF_CUSTOMERS; ++i) {
        joinThread (threads + i);
    }
    printf ("Done\n");
    return 0;
}
----------------------------------------

int main () {
    printf ("1st Run:\n" "========\n" "\n");
    run (& testSetSafe1);
    printf ("\n");
    printf ("2nd Run:\n" "========\n" "\n");
    run (& testSetSafe2);
    printf ("\n");
    printf ("3rd Run:\n" "========\n" "\n");
    run (& testSetUnsafe);
    printf ("\n");
    printf ("Done.\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43078142_43078399_15_25
43078142_43079002_21_34
Title: subset sum with negative values in c or c++ 
----------------------------------------

int main (void) {
    int set [] = {3, 34, 2, 12, 5, 8};
    int n = sizeof (set) / sizeof (set[0]);
    int sum = 6;
    if (isSubsetSum (set, n, sum, 0) == true)
        printf ("Found a subset");
    else
        printf ("No subset");
    return 0;
}
----------------------------------------

int main () {
    int set [] = {-3, 34, -2, 12, 5, 8};
    int sum = 0;
    int i;
    int n = sizeof (set) / sizeof (set[0]);
    int min = -3;
    for (i = 0; i < 6; i++)
        set[i] -= min;
    if (isSubsetSum (set, n, sum, -min) == true)
        printf ("Found a subset");
    else
        printf ("No subset");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43083284_43083359_3_13
43083284_43083476_1_16
Title: Reversing array elements in C programming 
----------------------------------------

void reverse (int a [], int i) {
    int j = 7, b;
    for (i = 0; i <= 7; i++) {
        b = a[i];
        a[i] = a[j];
        a[j] = b;
        j--;
    }
}
----------------------------------------

void reverse (int a [], int len) {
    int i;
    int j = len - 1, b;
    for (i = 0; i < len / 2; i++) {
        b = a[i];
        a[i] = a[j];
        a[j] = b;
        j--;
    }
    for (i = 0; i < len; i++) {
        printf ("Element %d is: %d\n", i, a [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43098969_43099052_106_121
43098969_43108136_25_57
Title: c - dynamically allocate variable names 
----------------------------------------

int main (int argc, char **argv) {
    Mapping myVarMap;
    char *varName;
    int i;
    getVariablesFromUser (& myVarMap);
    printf ("%d variables added by user\n", myVarMap.NumEntries);
    for (i = 0; i < myVarMap.NumEntries; i++) {
        LookUp_Entry *entry = &(myVarMap.mapping[i]);
        char *name = entry->Name;
        printf ("Entry #%d: %s = %d\n", i + 1, name, lookup (& myVarMap, name));
    }
}
----------------------------------------

int main (void) {
    int n, i, numindex;
    char *variableline, *vartemp;
    char keys [] = "1234567890";
    printf ("Enter n\n");
    scanf ("%d\n", & n);
    printf ("Enter %d lines\n", n);
    int *variable_values = malloc (n * sizeof (int));
    for (i = 0; i < n; i++) {
        variableline = inputString (stdin, 10);
        numindex = strcspn (variableline, keys);
        vartemp = malloc (strlen (variableline));
        strncpy (vartemp, variableline + numindex, strlen (variableline) - numindex);
        *(variable_values + i) = atoi (vartemp);
    }
    printf ("The variable values are:\n");
    for (i = 0; i < n; i++)
        printf ("%d\n", variable_values[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43122396_43122572_5_26
43122396_43126363_1_20
Title: Print the contents of the file 
----------------------------------------

void print_the_file (void) {
    int file_desc;
    char a_byte;
    size_t err;
    file_desc = open ("my_bin_file.bin", O_RDONLY, S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
    if (file_desc == -1) {
        printf ("file open failed\n");
        return;
    }
    do {
        err = read (file_desc, &a_byte, 1);
        if (err > 0) {
            printf ("%02x", a_byte);
        }
    }
    while (err > 0);
}
----------------------------------------

void print_the_file () {
    FILE *file_hndl = fopen ("my_bin_file.bin", "rb");
    if (file_hndl == NULL) {
        printf ("file open failed");
    }
    else {
        while (!feof (file_hndl) && !ferror (file_hndl)) {
            int c = fgetc (file_hndl);
            if (c != EOF) {
                printf ("%02x", c);
            }
        }
        fclose (file_hndl);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43124415_43125457_53_98
43124415_43157833_97_180
Title: Read from csv file into 2d array and sort the array using c 
----------------------------------------

int main () {
    FILE *fp = fopen ("file1.csv", "r");
    if (fp == NULL) {
        exit (1);
    }
    char buff [1024 + 1];
    int c, i = 0, len = 10;
    struct row *rows = malloc (sizeof (*rows) * len);
    struct row *temp = rows;
    while (fgets (buff, 1024, (FILE *) fp)) {
        if (i == len - 1) {
            len += 10;
            temp = realloc (rows, sizeof (*rows) * len);
            if (temp == NULL) {
                exit (1);
            }
            rows = temp;
        }
        line_to_row (buff, & rows [i]);
        i++;
    }
    fclose (fp);
    if (i == 0) {
        return 0;
    }
    len = i;
    temp = realloc (rows, sizeof (*rows) * len);
    if (temp == NULL) {
        exit (1);
    }
    rows = temp;
    qsort (rows, len, sizeof (* rows), & cmp);
    for (i = 0; i < len; i++) {
        printf ("%d\n", rows [i].id);
    }
    free (rows);
    return 0;
}
----------------------------------------

int main () {
    char *filename = "grades.csv";
    int rows = getSize (filename);
    printf ("There are %d lines in file grades.csv.\n\n", rows);
    FILE *stream = fopen ("grades.csv", "r");
    Row *row = malloc (sizeof (*row) * rows);
    char line [1024];
    int i = 0;
    printf ("Original:\n");
    printf ("+--------+");
    printf ("-----------+");
    printf ("-------+");
    printf ("------+");
    printf ("-------+\n");
    printf ("| Student|    Exam 1 | Exam 2|Exam 3| Grade |\n");
    while (fgets (line, 1024, stream) != NULL) {
        printf ("+--------+");
        printf ("-----------+");
        printf ("-------+");
        printf ("------+");
        printf ("-------+\n");
        sscanf (line, "%d,%d,%d,%d,%c", & row [i].id, & row [i].exam1, & row [i].exam2, & row [i].exam3, & row [i].grade);
        printf ("| %d |\t %-4d|\t %-4d|\t%-4d|\t%-4c|\n", row [i].id, row [i].exam1, row [i].exam2, row [i].exam3, row [i].grade);
        i++;
    }
    printf ("+--------+");
    printf ("-----------+");
    printf ("-------+");
    printf ("------+");
    printf ("-------+\n");
    printf ("\n\n");
    printf ("Sorted:\n");
    sort (row, rows);
    printf ("+--------+");
    printf ("-----------+");
    printf ("-------+\n");
    printf ("| Index  |  Student  | Grade |\n");
    for (i = 0; i < rows; i++) {
        printf ("+--------+");
        printf ("-----------+");
        printf ("-------+\n");
        printf ("| %-5d  |  %-5d   |\t %-4c|\n", i + 1, row [i].id, row [i].grade);
    }
    printf ("+--------+");
    printf ("-----------+");
    printf ("-------+\n");
    int sid;
    int ex = 0;
    while (1) {
        printf ("\n\nEnter student ID (-1 to quit): ");
    start :
        scanf ("%d", &sid);
        if (sid == -1) {
            return 0;
        }
        else if (sid > 100000 && sid < 999999) {
            binarySearch (row, rows, sid);
            printf ("\n\nEnter student ID (-1 to quit): ");
            goto start;
        }
        else {
            printf ("\nERROR and enter again ([100000,9999999] and -1 to quit): ");
            goto start;
        }
    }
    fclose (stream);
    free (row);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43141277_43141363_1_11
43141277_43141386_1_12
Title: Why can we not return a structure to a function? 
----------------------------------------

struct distance add (struct distance d1, struct distance d2) {
    d1.feet += d2.feet;
    d1.inches += d2.inches;
    while (d1.inches > 12) {
        ++d1.feet;
        d1.inches -= 12;
    }
    return d1;
}
----------------------------------------

distance add (struct distance d1, struct distance d2) {
    struct distance d3;
    d3.feet = d2.feet + d1.feet;
    d3.inch = d2.inch + d1.inch;
    if (d3.inch > 12) {
        d3.inch -= 12;
        ++d3.feet;
    }
    return d3;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43141277_43141363_1_11
43141277_43149319_28_37
Title: Why can we not return a structure to a function? 
----------------------------------------

struct distance add (struct distance d1, struct distance d2) {
    d1.feet += d2.feet;
    d1.inches += d2.inches;
    while (d1.inches > 12) {
        ++d1.feet;
        d1.inches -= 12;
    }
    return d1;
}
----------------------------------------

struct distance add (struct distance d1, struct distance d2) {
    d3.feet = d2.feet + d1.feet;
    d3.inch = d2.inch + d1.inch;
    while (d3.inch > 12) {
        d3.inch -= 12;
        ++d3.feet;
        return d3;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43141277_43141386_1_12
43141277_43149319_28_37
Title: Why can we not return a structure to a function? 
----------------------------------------

distance add (struct distance d1, struct distance d2) {
    struct distance d3;
    d3.feet = d2.feet + d1.feet;
    d3.inch = d2.inch + d1.inch;
    if (d3.inch > 12) {
        d3.inch -= 12;
        ++d3.feet;
    }
    return d3;
}
----------------------------------------

struct distance add (struct distance d1, struct distance d2) {
    d3.feet = d2.feet + d1.feet;
    d3.inch = d2.inch + d1.inch;
    while (d3.inch > 12) {
        d3.inch -= 12;
        ++d3.feet;
        return d3;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43143301_43143692_5_28
43143301_43144167_7_21
Title: Creating a password scrambler 
----------------------------------------

static char *scramblePassword (char *pwd, char *result) {
    char cipher [] = {'k', 's', 'z', 'h', 'x', 'b', 'p', 'j', 'v', 'c', 'g', 'f', 'q', 'n', 't', 'm'};
    size_t i;
    for (i = 0; i < strlen (pwd); i++) {
        int cc = (int) pwd[i];
        result[i] = cipher[(cc / 16)] + cipher[cc % 16];
    }
    result[i] = 0;
    return result;
}
----------------------------------------

static char *scramblePassword (char *pwd, char *result) {
    char cipher [] = "kszhxbpjvcgfqnm";
    int i;
    for (i = 0; i < (int) strlen (pwd); i++) {
        int cc = (int) pwd[i];
        result[i] = cipher[((int) floor (cc / 16) + cc % 16) % sizeof cipher];
    }
    result[i] = 0;
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43149156_43149452_11_38
43149156_43149732_1_17
Title: How to pass a full array in an array of pointers 
----------------------------------------

int main () {
    int arr1 [] = {3, 9, 6, 7};
    int arr2 [] = {2, 5, 5};
    int arr3 [] = {0};
    int arr4 [] = {1, 6};
    int arr5 [] = {4, 5, 6, 2, 1};
    int *pArr [LEN] = {arr1, arr2, arr3, arr4, arr5};
    int i = 0;
    for (i = 0; i < LEN; i++) {
        sortArrValues (pArr [i]);
    }
    for (int i = 0; i < LEN; i++) {
        for (int j = 0; j < pArr[i][0] + 1; j++)
            printf ("%d ", pArr[i][j]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int arr1 [] = {3, 9, 6, 7};
    int arr2 [] = {2, 5, 5};
    int arr3 [] = {0};
    int arr4 [] = {1, 6};
    int arr5 [] = {4, 5, 6, 2, 1};
    int *pArr [] = {arr1, arr2, arr3, arr4, arr5};
    int i = 0;
    for (i = 0; i < LEN; i++) {
        sortArrValues (& pArr [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43149156_43149452_44_60
43149156_43149732_20_38
Title: How to pass a full array in an array of pointers 
----------------------------------------

void sortArrValues (int *arr) {
    int tmp = 0;
    int i = 0;
    for (i = 1; i < *arr; i++) {
        if (arr[i] > arr[i + 1]) {
            tmp = arr[i];
            arr[i] = arr[i + 1];
            arr[i + 1] = tmp;
            i = 0;
        }
    }
}
----------------------------------------

void sortArrValues (int **arr) {
    int tmp = 0;
    int i = 0, j = 0;
    for (i = 0; i < (**arr) - 1; i++) {
        for (j = i + 1; j < (**arr) - 1; j++) {
            if ((*arr)[i + 1] > (*arr)[j + 1]) {
                tmp = (*arr)[i + 1];
                (*arr)[i + 1] = (*arr)[j + 1];
                (*arr)[j + 1] = tmp;
            }
        }
        printf ("%d ", (* arr) [i + 1]);
    }
    printf ("%d\n", (* arr) [i + 1]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43152811_43153047_39_56
43152811_43187224_30_46
Title: array inside function 
----------------------------------------

int main () {
    const char *question [] = {"I don't talk a lot", "I have people around me", "I love nature", "I talk about science", "And bla bla bla"};
    for (i = 0; i < SIZE; i++) {
        printf ("%s :\nYour Score: ", question [i]);
        scanf ("%d", & scoreList [i]);
    }
    int smallest = findSmall (scoreList);
    int largest = findLarge (scoreList);
    int total = findTotal (scoreList, smallest, largest);
    printf ("smallest: %d, largest: %d, total: %d\n", smallest, largest, total);
    return 0;
}
----------------------------------------

int main () {
    const char question [NUMBER_OF_QUESTIONS] [MAX_SIZE_ALLOTED_TO_EACH_QUESTION] = {"1. Am the life of the party.", "2. Feel little concern for others.", "3. Am always prepared.", "4. Get stressed out easily.", "5. Have a rich vocabulary.", "6. Don't talk a lot.", "7. Am interested in people.", "8. Leave my belongings around.", "9. Am relaxed most of the time.", "10. Have difficulty understanding abstract ideas."};
    for (i = 0; i < NUMBER_OF_QUESTIONS; i++) {
        printf ("%s :\nYour Score: ", question [i]);
        scanf ("%d", & scoreList [i]);
    }
    Extroversion (scoreList);
    Agreeableness (scoreList);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43165276_43165576_11_71
43165276_43165748_11_85
Title: Add value of playing cards - with pointers and structures 
----------------------------------------

void getHandValue (struct player_hand *hnd_ptr, char size, char size2) {
    int first_card;
    int second_card;
    scanf ("%c %c", & hnd_ptr -> card1, & hnd_ptr -> card2);
    printf ("Enter Cards: %c %c", & hnd_ptr -> card1, & hnd_ptr -> card2);
    if (hnd_ptr->card1 <= '9' && hnd_ptr->card1 >= '2') {
        first_card = (int) hnd_ptr->card1 - 48;
    }
    else if (hnd_ptr->card1 == 'T' || hnd_ptr->card1 == 'K' || hnd_ptr->card1 == 'Q' || hnd_ptr->card1 == 'J') {
        first_card = 10;
    }
    else if (hnd_ptr->card1 == 'A') {
        first_card = 11;
    }
    else {
        printf ("Not a valid card: %c", hnd_ptr -> card1);
        return;
    }
    if (hnd_ptr->card2 <= '9' && hnd_ptr->card2 >= '2') {
        second_card = (int) hnd_ptr->card2 - 48;
    }
    else if (hnd_ptr->card2 == 'T' || hnd_ptr->card2 == 'K' || hnd_ptr->card2 == 'Q' || hnd_ptr->card2 == 'J') {
        second_card = 10;
    }
    else if (hnd_ptr->card2 == 'A') {
        if (hnd_ptr->card1 == 'A')
            second_card = 1;
        else
            second_card = 11;
    }
    else {
        printf ("Not a valid card: %c", hnd_ptr -> card2);
        return;
    }
    printf ("\nThe total card value is: %d", first_card + second_card);
}
----------------------------------------

void getHandValue (struct player_hand *hnd_ptr, int size) {
    int first_card;
    int second_card;
    for (int i = 0; i < size; i++) {
        printf ("\nenter cards for hand %d (card1 card2): ", i);
        if (scanf ("%c %c%*c", &hnd_ptr[i].card1, &hnd_ptr[i].card2) != 2) {
            fprintf (stderr, "error: invalid entry.\n");
            return;
        }
        printf ("you entered: %c %c\n", hnd_ptr [i].card1, hnd_ptr [i].card2);
    }
    for (int i = 0; i < size; i++) {
        if (hnd_ptr[i].card1 <= '9' && hnd_ptr[i].card1 >= '2') {
            first_card = (int) hnd_ptr[i].card1 - '0';
        }
        else if (hnd_ptr[i].card1 == 'T' || hnd_ptr[i].card1 == 'K' || hnd_ptr[i].card1 == 'Q' || hnd_ptr[i].card1 == 'J') {
            first_card = 10;
        }
        else if (hnd_ptr[i].card1 == 'A') {
            first_card = 11;
        }
        else {
            printf ("Not a valid card: %c", hnd_ptr [i].card1);
            return;
        }
        if (hnd_ptr[i].card2 <= '9' && hnd_ptr[i].card2 >= '2') {
            second_card = (int) hnd_ptr[i].card2 - '0';
        }
        else if (hnd_ptr[i].card2 == 'T' || hnd_ptr[i].card2 == 'K' || hnd_ptr[i].card2 == 'Q' || hnd_ptr[i].card2 == 'J') {
            second_card = 10;
        }
        else if (hnd_ptr[i].card2 == 'A') {
            if (hnd_ptr[i].card1 == 'A')
                second_card = 1;
            else
                second_card = 11;
        }
        else {
            printf ("Not a valid card: %c", hnd_ptr [i].card2);
            return;
        }
        printf ("\nThe total cards value (hand %d) is: %d\n", i, first_card + second_card);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43193752_43193784_1_17
43193752_43193924_1_16
Title: C: return a value from a recursive call 
----------------------------------------

int find (char *a, trie_node *node) {
    int i, temp;
    if ((a != NULL && a[0] != '\n') && node->children[a[0] - 97] == NULL) {
        return 0;
    }
    else if ((a != NULL && a[0] != '\n') && node->children[a[0] - 97] != NULL) {
        temp = a[0];
        a++;
        return find (a, node->children[temp - 97]);
    }
    return node->num_children;
}
----------------------------------------

int find (char *a, trie_node *node, int result) {
    int i, temp;
    if ((a != NULL && a[0] != '\n') && node->children[a[0] - 97] == NULL) {
        result = 0;
    }
    else if ((a != NULL && a[0] != '\n') && node->children[a[0] - 97] != NULL) {
        temp = a[0];
        a++;
        result = find (a, node->children[temp - 97], result);
    }
    else {
        result = node->num_children;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43224706_43225037_1_32
43224706_43225151_3_39
Title: How to write the algorithm of this matrix in this ascending order in C.Where is error in my code? 
----------------------------------------

int main () {
    int a = 7;
    int n = 4;
    int array [4] [4];
    for (int c = 0; c < n; ++c) {
        for (int r = 0; r < n; ++r) {
            if (c % 2 == 0) {
                array[r][c] = a + c * n + r;
            }
            else {
                array[r][c] = a + c * n + n - r - 1;
            }
        }
    }
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            printf ("%d ", array [i] [j]);
        }
        printf ("\n");
    }
}
----------------------------------------

int main (void) {
    int a;
    int i = 0, j = 0, n;
    printf ("Insert the value of n: ");
    scanf ("%d", & n);
    printf ("Insert the value of a number: ");
    scanf ("%d", & a);
    int matrix [n] [n];
    for (i = 0; i < n * n; i++) {
        if (((i / n) % 2) == 0) {
            matrix[i % n][i / n] = a++;
        }
        else {
            matrix[n - (i % n) - 1][i / n] = a++;
        }
    }
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            printf ("%d\t", matrix [i] [j]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43268733_43269171_4_34
43268733_43269424_7_56
Title: Longest and Shortest word in a file C programming 
----------------------------------------

int main () {
    const int max_word_length = 60;
    char longest [max_word_length];
    char shortest [max_word_length];
    char current [max_word_length];
    size_t longest_length = 0;
    size_t shortest_length = max_word_length;
    size_t current_length = 0;
    freopen ("input", "r", stdin);
    freopen ("output", "w", stdout);
    while (scanf ("%s", current) > 0) {
        current_length = strlen (current);
        if (current_length > longest_length) {
            longest_length = current_length;
            strcpy (longest, current);
        }
        if (current_length < shortest_length) {
            shortest_length = current_length;
            strcpy (shortest, current);
        }
    }
    printf ("%s %s", shortest, longest);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp;
    char str [60];
    char *largest = (char *) malloc (MAX_WORD_LENGTH);
    char *smallest = (char *) malloc (MAX_WORD_LENGTH);
    int smallest_len = MAX_WORD_LENGTH, largest_len = 0;
    if (argc == 2) {
        fp = fopen (argv[1], "r");
    }
    else {
        printf ("Argument error.");
        return (-1);
    }
    if (fp == NULL) {
        printf ("Error opening file.");
        return (-1);
    }
    while (fgets (str, 60, fp) != NULL) {
        char *temp = strtok (str, " ");
        while (temp != NULL) {
            if (strlen (temp) > largest_len) {
                strcpy (largest, temp);
                largest_len = strlen (largest);
            }
            if (strlen (temp) < smallest_len) {
                strcpy (smallest, temp);
                smallest_len = strlen (smallest);
            }
            temp = strtok (NULL, " ");
        }
    }
    printf ("The largest word in the file is: %s\n", largest);
    printf ("The smallest word in the file is: %s\n", smallest);
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43270761_43270904_3_14
43270761_43272016_12_43
Title: Recursion or extracting a variable 
----------------------------------------

void base_aux (unsigned int n, unsigned int base, unsigned int x) {
    if (n > (base - 1) || 32 - x > 0) {
        base_aux (n / base, base, ++ x);
        printf ("%u", n % base);
    }
    else {
        printf ("%u", n);
    }
}
----------------------------------------

void base_aux (unsigned int n, unsigned int base) {
    if (base > sizeof (characters)) {
        printf ("base %u exceeding max of %lu", base, (unsigned long) sizeof (characters));
        return;
    }
    unsigned int digits = 0;
    unsigned int tmp = UINT_MAX;
    while (tmp) {
        tmp /= base;
        ++digits;
    }
    char buffer [digits];
    memset (buffer, '0', sizeof (buffer));
    base_aux2 (n, base, buffer + sizeof (buffer));
    printf ("%.*s\n", (int) sizeof (buffer), buffer);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43270761_43270904_3_14
43270761_43273786_1_10
Title: Recursion or extracting a variable 
----------------------------------------

void base_aux (unsigned int n, unsigned int base, unsigned int x) {
    if (n > (base - 1) || 32 - x > 0) {
        base_aux (n / base, base, ++ x);
        printf ("%u", n % base);
    }
    else {
        printf ("%u", n);
    }
}
----------------------------------------

void base_aux (unsigned int n, unsigned int base, unsigned int x) {
    if (n > (base - 1)) {
        base_aux (n / base, base, ++ x);
        printf ("%u", n % base);
    }
    else {
        ++x;
        zero_int (32 - x);
        printf ("%u", n);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43270761_43272016_12_43
43270761_43273786_1_10
Title: Recursion or extracting a variable 
----------------------------------------

void base_aux (unsigned int n, unsigned int base) {
    if (base > sizeof (characters)) {
        printf ("base %u exceeding max of %lu", base, (unsigned long) sizeof (characters));
        return;
    }
    unsigned int digits = 0;
    unsigned int tmp = UINT_MAX;
    while (tmp) {
        tmp /= base;
        ++digits;
    }
    char buffer [digits];
    memset (buffer, '0', sizeof (buffer));
    base_aux2 (n, base, buffer + sizeof (buffer));
    printf ("%.*s\n", (int) sizeof (buffer), buffer);
}
----------------------------------------

void base_aux (unsigned int n, unsigned int base, unsigned int x) {
    if (n > (base - 1)) {
        base_aux (n / base, base, ++ x);
        printf ("%u", n % base);
    }
    else {
        ++x;
        zero_int (32 - x);
        printf ("%u", n);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43274014_43274240_1_12
43274014_43275264_1_21
Title: Optimised range checking and returning a value 
----------------------------------------

int GetScalingFactor (int input) {
    if (input < 13107)
        return 72816;
    else if (input < 19660)
        return 81918;
    else if (input < 26214)
        return 93621;
    else if (input < 32767)
        return 109225;
    else if (input < 39321)
        return 131070;
    else if (input < 45874)
        return 163837;
    else if (input < 52428)
        return 218450;
    else if (input < 58981)
        return 327675;
    else
        return 0;
}
----------------------------------------

int GetScalingFactor (int input) {
    static const int factors [] = {72816, 72816, 81918, 93621, 109225, 131070, 163837, 218450, 327675};
    if (input < 0) {
        input = 0;
    }
    else {
        input = (input * 2 + 1) / 13107;
        if (input >= sizeof (factors) / sizeof (factors[0])) {
            return 0;
        }
    }
    return factors[input];
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43285228_43285411_7_32
43285228_43285521_8_20
Title: Nested for loop array random numbers 
----------------------------------------

int main (void) {
    int number [SIZE];
    int n = 7;
    int i = 0;
    srand ((unsigned int) time (NULL));
    while (i < n) {
        int value = rand () % SIZE + 1;
        int j = 0;
        while (j < i && number[j] != value)
            j++;
        if (j == i)
            number[i++] = value;
    }
    for (i = 0; i < n; i++)
        printf ("%d ", number[i]);
    putchar ('\n');
    getchar ();
    return 0;
}
----------------------------------------

int main (void) {
    int i, j;
    int had [SIZE] = {0};
    srand ((unsigned) time (NULL));
    for (i = 0; i < VALS; i++) {
        do {
            j = rand () % SIZE;
        }
        while (had[j] != 0);
        had[j] = 1;
        printf ("%d ", j + 1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43289868_43289991_9_25
43289868_43294323_27_72
Title: How to put values into array structs? 
----------------------------------------

void MakeAccount () {
    int id;
    int input_money;
    char name [30];
    printf ("--Make Account--\n");
    printf ("Input ID : ");
    scanf ("%d", & id);
    printf ("Insert Money : ");
    scanf ("%d", & input_money);
    printf ("Your Name? : ");
    scanf ("%s", name);
    accountarray[number++].id = id;
    accountarray[number++].money = input_money;
    memcpy (accountarray [number ++].name, name, strlen (name));
}
----------------------------------------

void MakeAccount () {
    int id;
    int input_money;
    char name [MAX_STR_LEN];
    int scanfStatus;
    printf ("--Make Account--\n");
    printf ("Input ID : ");
    scanfStatus = scanf ("%d", &id);
    if (1 != scanfStatus) {
        perror ("scanf for account id failed");
        exit (EXIT_FAILURE);
    }
    printf ("Insert Money : ");
    scanfStatus = scanf ("%d", &input_money);
    if (1 != scanfStatus) {
        perror ("scanf for account money failed");
        exit (EXIT_FAILURE);
    }
    printf ("Your Name? : ");
    scanfStatus = scanf ("%29s", name);
    if (1 != scanfStatus) {
        perror ("scanf for account name failed");
        exit (EXIT_FAILURE);
    }
    accountarray[number].id = id;
    accountarray[number].money = input_money;
    strcpy (accountarray [number].name, name);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43293188_43293373_9_17
43293188_43297441_6_19
Title: C Program to Calculate Hypotenuse 
----------------------------------------

int main (void) {
    double b1, b2, counter;
    for (counter = 0; counter <= 2; counter++) {
        printf ("Enter values for two sides: ");
        scanf ("%lf %lf", & b1, & b2);
        printf ("%.2f\n", hypotenuse (b1, b2));
    }
    return 0;
}
----------------------------------------

int main (void) {
    double side1, side2, side3, counter;
    side3 = 1;
    for (counter = 0; counter <= 2; counter++) {
        printf ("Enter values for two sides: ");
        scanf ("%lf %lf", & side1, & side2);
        printf ("%.2f\n", hypotenuse (side1, side2, side3));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43297629_43297744_1_16
43297629_43297781_1_16
Title: c - Array which contains multiple table with one malloc() 
----------------------------------------

int *initiallizeArray (int *rows) {
    int i = 0, j = 0;
    int *twoDArray;
    printf ("Enter a number: ");
    scanf ("%d", rows);
    twoDArray = (int *) malloc (sizeof (int) * 2 * (*rows));
    for (i = 0; i < *rows; i++) {
        for (j = 0; j < *rows; j++) {
            twoDArray[i * (*rows) + j] = (i + 1) * (j + 1);
        }
    }
    return twoDArray;
}
----------------------------------------

int *initiallizeArray (int *rows) {
    int i = 0, j = 0;
    int *mult_table = NULL;
    printf ("Enter a number: ");
    scanf ("%d", rows);
    mult_table = malloc ((sizeof *mult_table) * (*rows) * (*rows));
    for (i = 0; i < *rows; i++) {
        for (j = 0; j < *rows; j++) {
            mult_table[i * (*rows) + j] = (i + 1) * (j + 1);
        }
    }
    return mult_table;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43357429_43357593_3_18
43357429_43357802_4_24
Title: C: Write into file as multiple columns 
----------------------------------------

int main (void) {
    int pos [] = {1, 3, 3, 5, 6, 7, 0, 37, 8, 34, 5, 3, 5, 6, 3, 1, 7, 8};
    int len = sizeof (pos) / sizeof (*pos);
    int col_len = 5;
    for (int i = 0; i < col_len; ++i) {
        for (int j = i; j < len; j += col_len) {
            printf ("%2d ", pos [j]);
        }
        puts ("");
    }
}
----------------------------------------

int main () {
    int v [18] = {1, 3, 3, 5, 6, 7, 0, 37, 8, 34, 5, 3, 5, 6, 3, 1, 7, 8};
    int i = 0, adder = 0, done = 0;
    while (1) {
        if (done == 19)
            break;
        done++;
        if (i <= 18) {
            printf ("%d ", v [i]);
            i = i + 5;
        }
        if (i > 18) {
            printf ("\n");
            adder++;
            i = adder;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43359263_43359488_3_20
43359263_43360354_6_18
Title: returning two variables that have multiple values 
----------------------------------------

int findN (double xI, double xF, double h []) {
    int i = 0;
    int n;
    h[i] = 0.1;
    do {
        i++;
        printf_s ("%8.5f \n", * h);
        n = ((xF - xI) / (*h));
        h[i] = h[i - 1] / 10;
        printf_s ("%6d \n", n);
    }
    while (h[i] >= 0.00001);
    return n;
}
----------------------------------------

nh findN (double xI, double xF) {
    nh retval;
    retval.h = 0.1;
    do {
        printf_s ("%8.5f\n", retval.h);
        retval.n = ((xF - xI) / retval.h);
        retval.h = retval.h / 10;
        printf_s ("%6d\n", retval.n);
    }
    while (retval.h >= 0.00001);
    return retval;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43360368_43360826_8_42
43360368_43365036_31_43
Title: Transform 1D char array to 2D char array without allocating memory 
----------------------------------------

int main (void) {
    char cmd [MAXB] = "", **arr = calloc (MAX, sizeof *arr), *delim = " \n";
    size_t n = 0, max = MAX;
    while (fgets (cmd, MAXB, stdin)) {
        size_t len = strlen (cmd);
        if (cmd[len - 1] == '\n')
            cmd[--len] = 0;
        for (char *p = strtok (cmd, delim); p; p = strtok (NULL, delim)) {
            arr[n++] = p;
            if (n == max) {
                void *tmp = realloc (arr, (max + MAX) * sizeof *arr);
                if (!tmp) {
                    fprintf (stderr, "error: memory exhausted.\n");
                    break;
                }
                arr = tmp;
                memset (arr + max, 0, MAX * sizeof * arr);
                max += MAX;
            }
        }
        for (int i = 0; i < (int) n; i++)
            printf ("arr[%2d]: %s\n", i, arr[i]);
    }
    free (arr);
    return 0;
}
----------------------------------------

int main (void) {
    char str [] = "a bcd ef hijk lmmopq";
    size_t size = count_spaces (str) + 1;
    char *ptr_arr [size];
    tokenize (str, size, ptr_arr);
    for (size_t i = 0; i < size; i++) {
        puts (ptr_arr [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43364389_43364613_10_33
43364389_43364957_3_29
Title: Wrong values - Breaking big char into int Array 
----------------------------------------

int main (void) {
    char str [3];
    char stringArr [] = "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16 07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48";
    int Arr [20] [20] = {0};
    int num;
    int liner, row;
    int i, j;
    char *current = stringArr;
    for (i = 0; i < 20; i++) {
        for (j = 0; j < 20; j++) {
            Arr[i][j] = convertTwoDigitsToInt (current);
            printf ("%2d  ", Arr [i] [j]);
            current += 3;
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    char stringArr [] = "08 02 22 97 38 15 00 40 00 75 04 05 07 78 52 12 50 77 91 08 49 49 99 40 17 81 18 57 60 87 17 40 98 43 69 48 04 56 62 00 81 49 31 73 55 79 14 29 93 71 40 67 53 88 30 03 49 13 36 65 52 70 95 23 04 60 11 42 69 24 68 56 01 32 56 71 37 02 36 91 22 31 16 71 51 67 63 89 41 92 36 54 22 40 40 28 66 33 13 80 24 47 32 60 99 03 45 02 44 75 33 53 78 36 84 20 35 17 12 50 32 98 81 28 64 23 67 10 26 38 40 67 59 54 70 66 18 38 64 70 67 26 20 68 02 62 12 20 95 63 94 39 63 08 40 91 66 49 94 21 24 55 58 05 66 73 99 26 97 17 78 78 96 83 14 88 34 89 63 72 21 36 23 09 75 00 76 44 20 45 35 14 00 61 33 97 34 31 33 95 78 17 53 28 22 75 31 67 15 94 03 80 04 62 16 14 09 53 56 92 16 39 05 42 96 35 31 47 55 58 88 24 00 17 54 24 36 29 85 57 86 56 00 48 35 71 89 07 05 44 44 37 44 60 21 58 51 54 17 58 19 80 81 68 05 94 47 69 28 73 92 13 86 52 17 77 04 89 55 40 04 52 08 83 97 35 99 16  07 97 57 32 16 26 26 79 33 27 98 66 88 36 68 87 57 62 20 72 03 46 33 67 46 55 12 32 63 93 53 69 04 42 16 73 38 25 39 11 24 94 72 18 08 46 29 32 40 62 76 36 20 69 36 41 72 30 23 88 34 62 99 69 82 67 59 85 74 04 36 16 20 73 35 29 78 31 90 01 74 31 49 71 48 86 81 16 23 57 05 54 01 70 54 71 83 51 54 69 16 92 33 48 61 43 52 01 89 19 67 48";
    int Arr [20] [20];
    int i, j;
    size_t strIndex = 0;
    size_t strLength = sizeof (stringArr) - 1;
    for (i = 0; i < 20; i++) {
        for (j = 0; j < 20; j++) {
            if (strIndex < strLength) {
                sscanf (& stringArr [strIndex], "%02d ", & Arr [i] [j]);
                strIndex += 3;
                printf (" %2d", Arr [i] [j]);
            }
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43380813_43381302_17_30
43380813_43397387_28_54
Title: Creating a Deck of Cards using linked list 
----------------------------------------

void add_card (card **headp, card **tailp, int face, const char *suit) {
    card *temp = (card *) malloc (sizeof (card));
    temp->face_val = face;
    strcpy (temp -> suit, suit);
    if (*headp == NULL) {
        *headp = temp;
        *tailp = temp;
    }
    else {
        (*tailp)->next = temp;
        *tailp = temp;
    }
}
----------------------------------------

void add_card (card **headp, card **tailp, int face, char suit) {
    card *temp = malloc (sizeof (card));
    if (!temp) {
        perror ("malloc failed");
        exit (EXIT_FAILURE);
    }
    temp->face_val = face;
    temp->suit = suit;
    temp->next = *headp;
    if (*headp == NULL) {
        *headp = temp;
        *tailp = temp;
    }
    else {
        (*tailp)->next = temp;
        *tailp = temp;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43380813_43381302_33_50
43380813_43397387_57_83
Title: Creating a Deck of Cards using linked list 
----------------------------------------

void create_deck (card **headp, card **tailp) {
    int i = 1;
    while (i <= 13) {
        int j = 1;
        while (j <= 4) {
            if (j == 1)
                add_card (headp, tailp, i, SPADE);
            if (j == 2)
                add_card (headp, tailp, i, HEART);
            if (j == 3)
                add_card (headp, tailp, i, DIAMONDS);
            if (j == 4)
                add_card (headp, tailp, i, CLUB);
            j++;
        }
        i++;
    }
}
----------------------------------------

void create_deck (card **headp, card **tailp) {
    for (int i = 1; i <= MAX_CARDS_IN_SUIT; i++) {
        for (int j = 1; j <= MAX_SUITS; j++) {
            switch (j) {
            case 1 :
                add_card (headp, tailp, i, SPADE);
                break;
            case 2 :
                add_card (headp, tailp, i, HEART);
                break;
            case 3 :
                add_card (headp, tailp, i, DIAMONDS);
                break;
            case 4 :
                add_card (headp, tailp, i, CLUB);
                break;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43382845_43383262_8_39
43382845_43383301_11_33
Title: Display specific row of an array using pointer and addressing techniques 
----------------------------------------

int main (void) {
    int array [10] [10];
    int i, j;
    int *p;
    int add = 0;
    p = (int *) array;
    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            array[i][j] = add;
            add++;
        }
    }
    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            printf ("%d ", array [i] [j]);
        }
        printf (" \n");
    }
    showRow (p, 2, 3);
    showCol (p, 2, 3);
}
----------------------------------------

int main () {
    int array [10] [10];
    int i, j;
    int add = 0;
    for (i = 0; i < 10; i++) {
        for (j = 0; j < 10; j++) {
            array[i][j] = add;
            add++;
        }
    }
    showRow (& array, 1, 10);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43402066_43402277_4_15
43402066_43402292_18_35
Title: C functions input variables 
----------------------------------------

int min_hour (int hour [], int n) {
    int earliest = 0;
    for (int i = 1; i < n; i++) {
        if (hour[earliest] > hour[i]) {
            earliest = i;
        }
    }
    return earliest;
}
----------------------------------------

int min_hour (int *hour, int n) {
    if (!hour || !n) {
        fprintf (stderr, "min_hour() error: invalid parameter.\n");
        return -1;
    }
    int earliest = hour[0], idx = 0;
    for (int i = 1; i < n; i++)
        if (hour[i] < earliest) {
            earliest = hour[i];
            idx = i;
        }
    return idx;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43417529_43417612_11_21
43417529_43417709_12_29
Title: Trying to make a function in C that copies one string onto another 
----------------------------------------

int main (void) {
    char *s1 = "Barrel";
    size_t len = strlen (s1) + 1;
    char *e1 = malloc (len);
    printf ("mainStr is: %s\n", s1);
    strcopy1 (s1, e1, len);
    printf ("mainStr is: %s\n", s1);
    printf ("emptyStr is: %s\n", e1);
    free (e1);
}
----------------------------------------

int main (void) {
    char *s1 = "Barrel";
    char *e1 = {0};
    e1 = malloc (strlen (s1) +1);
    if (e1) {
        printf ("mainStr is: %s\n", s1);
        printf ("emptyStr is: %s\n", e1);
        strcopy1 (s1, e1, 7);
        printf ("mainStr is: %s\n", s1);
        printf ("emptyStr is: %s\n", e1);
        free (e1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43423584_43423756_1_18
43423584_43423856_3_24
Title: Decimal to Binary convert in C 
----------------------------------------

int main () {
    int myDecimal, quo, rem;
    int i = 0;
    int myArray [3] = {0};
    printf ("Enter valid decimal number: \n");
    scanf ("%d", & myDecimal);
    quo = myDecimal;
    while (quo > 0) {
        quo = myDecimal / 2;
        rem = myDecimal % 2;
        myArray[i] = rem;
        myDecimal = quo;
        i++;
    }
    printf ("Binary: %d %d %d", myArray [2], myArray [1], myArray [0]);
    return 0;
}
----------------------------------------

int main () {
    int myDecimal, quo, rem;
    int i = 0;
    int myArray [3];
    printf ("Enter valid decimal number: ");
    scanf ("%d", & myDecimal);
    while (myDecimal > 0) {
        quo = myDecimal / 2;
        rem = myDecimal % 2;
        myArray[i] = rem;
        myDecimal = quo;
        i++;
    }
    myArray[i] = quo;
    for (i = 2; i >= 0; i--) {
        printf ("%d", myArray [i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43425263_43425347_7_37
43425263_43440217_6_43
Title: Unexpected output while using Pipes 
----------------------------------------

int main () {
    pid_t pid;
    int fds [2];
    int ret;
    char ch [20];
    memset (ch, '\0', 20);
    ret = pipe (fds);
    if (ret == -1) {
        perror ("pipe failed");
        exit (0);
    }
    pid = fork ();
    if (pid == 0) {
        printf ("Child process\n");
        write (fds [1], "Hello", 5);
    }
    if (pid > 0) {
        printf ("Parent Process\n");
        read (fds [0], ch, 15);
        printf ("%s\n", ch);
    }
}
----------------------------------------

int main (void) {
    pid_t pid;
    int fds [2];
    int ret;
    char ch [20];
    memset (ch, 'X', sizeof (ch) - 1);
    ch[sizeof (ch) - 1] = '\0';
    ret = pipe (fds);
    if (ret == -1) {
        perror ("pipe failed");
        exit (0);
    }
    pid = fork ();
    if (pid == 0) {
        printf ("Child process\n");
        write (fds [1], "Hello", 5);
    }
    else if (pid > 0) {
        printf ("Parent Process\n");
        int nbytes = read (fds[0], ch, 15);
        printf ("[%s]\n", ch);
        printf ("[%.*s]\n", nbytes, ch);
        ch[nbytes] = '\0';
        printf ("[%s]\n", ch);
    }
    else
        fprintf (stderr, "fork() failed\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43431205_43431658_36_45
43431205_43435416_60_73
Title: Sum of dices rolls 
----------------------------------------

int main (int argc, char **argv) {
    int ndice, sides, ok;
    ok = argc == 2 && sscanf (argv[1], "%dd%d", &ndice, &sides) == 2;
    if (!ok || ndice < 1 || ndice > 1000 || sides < 1 || sides > 100) {
        fprintf (stderr, "Usage: %s <n>d<sides>. For example: 3d6\n", argv [0]);
        return 1;
    }
    dice_sum_probabilities (ndice, sides);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    uint32_t n, p, s;
    n = argc > 1 ? (uint32_t) strtoul (argv[1], NULL, 10) : 2;
    s = argc > 2 ? (uint32_t) strtoul (argv[2], NULL, 10) : 6;
    for (p = n; p <= s * n; p++) {
        double prob = ppns (p, n, s);
        printf (" points: %3" PRIu32 ", probablility: %8.4lf\n", p, prob);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43435260_43435318_4_38
43435260_43435437_4_17
Title: Concatenate size_t and char* in C 
----------------------------------------

int main (void) {
    size_t sz = 100;
    char *length = "LEN";
    int n;
    n = snprintf (NULL, 0, "%zu%s", sz, length);
    if (n < 0) {
        fprintf (stderr, "Error in snprintf() size evaluation\n");
        exit (EXIT_FAILURE);
    }
    size_t result_sz = n + 1;
    char *result = malloc (result_sz);
    if (result == NULL) {
        fprintf (stderr, "Allocation error\n");
        exit (EXIT_FAILURE);
    }
    n = snprintf (result, result_sz, "%zu%s", sz, length);
    if (n < 0) {
        fprintf (stderr, "Error in snprintf() write\n");
        exit (EXIT_FAILURE);
    }
    printf ("%s\n", result);
    free (result);
    return 0;
}
----------------------------------------

int main () {
    size_t sz = 100;
    const char length [] = "LEN";
    const size_t buffersz = 24;
    char buffer [buffersz];
    int count = snprintf (buffer, buffersz, "%zu%s", sz, length);
    printf ("%d  %s", count, buffer);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43443529_43443842_8_24
43443529_43444046_1_19
Title: Converting Number to Integer 
----------------------------------------

long getData (char *data) {
    char *end;
    errno = 0;
    long x = strtol (data, &end, 10);
    if ((errno == ERANGE && (x == LONG_MAX || x == LONG_MIN)) || (errno != 0 && x == 0)) {
        errno = ERANGE;
        return LONG_MIN;
    }
    return x;
}
----------------------------------------

int getData (const char *data) {
    char *endptr;
    errno = 0;
    long x = strtol (data, &end, 10);
    if (data == end) {
        printf ("No conversion <%s>\n", data);
    }
    else if (errno) {
        printf ("Overflow/implementation defined error, %d, <%s>\n", errno == ERANGE, data);
    }
    if (x < INT_MIN || x > INT_MAX) {
        printf ("Overflow (long to int), %ld <%s>\n", x, data);
        x = x < 0 ? INT_MIN : INT_MAX;
        errno = ERANGE;
    }
    return (int) x;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43451964_43452046_1_26
43451964_43452402_1_22
Title: How to read the next character after space in C? 
----------------------------------------

int main () {
    char ch;
    bool had_space;
    int i = 0, count = 0;
    had_space = true;
    while (scanf ("%c", &ch) != EOF) {
        if (ch == '\n')
            count = 0;
        if (ch == ' ')
            count++;
        char array [count + 1];
        if (ch == ' ')
            had_space = true;
        else if (had_space)
            array[i++] = ch;
    }
    return 0;
}
----------------------------------------

int main () {
    char ch;
    char array [1024];
    int i = 0, count = 0;
    int status = 1;
    while (scanf ("%c", &ch) != EOF) {
        if (ch == '\n') {
            break;
        }
        if (ch == ' ') {
            status = 1;
            continue;
        }
        if (status == 1) {
            status = 0;
            array[i++] = ch;
        }
    }
    array[i++] = ' ';
    printf ("%s", array);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43456375_43456938_1_24
43456375_43456947_4_24
Title: Function that returns 1 if two arrays are completely different and 0 if there's a common element 
----------------------------------------

int meme (char s1 [], char s2 []) {
    int i = 0;
    int different;
    int str1_len = strlen (s1);
    int str2_len = strlen (s2);
    if (str1_len > str2_len)
        str1_len = str2_len;
    do {
        if (s1[i] == s2[i]) {
            printf ("Common\n");
            different = 0;
        }
        else {
            different = 1;
        }
        i++;
    }
    while (str1_len--);
    return different;
}
----------------------------------------

int meme (char s1 [], char s2 []) {
    int i = 0;
    int len_s1 = 0;
    int len_s2 = 0;
    int different = 0;
    len_s1 = strlen (s1);
    len_s2 = strlen (s2);
    if (len_s1 == len_s2) {
        for (i = 0; i < len_s1; i++) {
            if (s1[i] != s2[i]) {
                different = 1;
                break;
            }
        }
        else {different = 1;
    }
    return different;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43456375_43456938_1_24
43456375_43458182_1_11
Title: Function that returns 1 if two arrays are completely different and 0 if there's a common element 
----------------------------------------

int meme (char s1 [], char s2 []) {
    int i = 0;
    int different;
    int str1_len = strlen (s1);
    int str2_len = strlen (s2);
    if (str1_len > str2_len)
        str1_len = str2_len;
    do {
        if (s1[i] == s2[i]) {
            printf ("Common\n");
            different = 0;
        }
        else {
            different = 1;
        }
        i++;
    }
    while (str1_len--);
    return different;
}
----------------------------------------

bool meme (char s1 [], char s2 []) {
    int i = 0;
    while (s1[i] != NULL && s2[i] != NULL) {
        if (s1[i] == s2[i])
            return false;
        i += 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43456375_43456947_4_24
43456375_43458182_1_11
Title: Function that returns 1 if two arrays are completely different and 0 if there's a common element 
----------------------------------------

int meme (char s1 [], char s2 []) {
    int i = 0;
    int len_s1 = 0;
    int len_s2 = 0;
    int different = 0;
    len_s1 = strlen (s1);
    len_s2 = strlen (s2);
    if (len_s1 == len_s2) {
        for (i = 0; i < len_s1; i++) {
            if (s1[i] != s2[i]) {
                different = 1;
                break;
            }
        }
        else {different = 1;
    }
    return different;
}
----------------------------------------

bool meme (char s1 [], char s2 []) {
    int i = 0;
    while (s1[i] != NULL && s2[i] != NULL) {
        if (s1[i] == s2[i])
            return false;
        i += 1;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43504433_43505048_34_44
43504433_43505128_10_51
Title: creating a linked list with 100 nodes each containing a random number C 
----------------------------------------

int main () {
    int T = 100;
    node *root = NULL;
    while (T-- > 0) {
        int r = rand () % 200;
        root = insert_node (root, r);
    }
    print (root);
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    srand (time (NULL));
    node *head = NULL;
    for (int i = 0; i < 100; i++) {
        node *newnode = malloc (sizeof *newnode);
        if (!newnode) {
            fprintf (stderr, "error: memory exhausted node '%d'.\n", i);
            break;
        }
        newnode->number = rand () % 100;
        newnode->next = NULL;
        if (!head)
            head = newnode;
        else {
            node *iter = head;
            for (; iter->next; iter = iter->next) {
            }
            iter->next = newnode;
        }
    }
    int j = 0;
    for (node *iter = head; iter; iter = iter->next)
        printf ("node[%3d] : %3d,       addr: %p, next: %p\n", j++, iter->number, (void *) iter, (void *) iter->next);
    node *victim = NULL;
    for (node *iter = head; iter; iter = iter->next) {
        if (victim)
            free (victim);
        victim = iter;
    }
    if (victim)
        free (victim);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43505815_43507441_12_46
43505815_43511143_1_29
Title: C exiting a program correctly 
----------------------------------------

int main () {
    char *args [2] = {"DD", NULL};
    int D, waitVal3, waitVal4, rc, waitStatus;
    D = fork ();
    if (D == -1) {
        printf ("fork failed\n");
        exit (1);
    }
    if (D == 0) {
        rc = execv ("/some/path/to/DD", args);
        printf ("execv failed: errno: %d\n", errno);
        exit (1);
    }
    if (D != 0) {
        printf ("\nPid = %d Code AA: created proccess Pid = %d (code DD)\n", getpid (), D);
    }
    waitVal4 = wait (&waitStatus);
    waitVal3 = (waitVal4);
    printf ("WAIT VAL: %d", waitVal3);
    if (waitVal3 == D) {
        printf ("\nPid = %d Code AA: process Pid = %d terminated\n", getpid (), D);
    }
    return 0;
}
----------------------------------------

int main () {
    char *args [2] = {"DD", NULL};
    int waitVal3, waitVal4, rc, waitStatus;
    pid_t D;
    D = fork ();
    if (D == -1) {
        printf ("fork failed\n");
        exit (1);
    }
    if (D == 0) {
        if (execv ("/home/ubuntu/workspace/C/DD", args) == -1) {
            printf ("execv failed: errno: %d\n", errno);
            exit (1);
        }
        if (waitpid (D, &waitStatus, 0) == -1) {
            printf ("Error waiting child process.\n");
            exit (1);
        }
        printf ("\nPid = %d Code AA: process Pid = %d terminated\n", getpid (), D);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43525394_43525622_1_29
43525394_43525738_1_40
Title: Search and delete from linked list 
----------------------------------------

void vymazstudenta (STUDENT **head, const char *priezvisko) {
    STUDENT *traverse = *head;
    STUDENT *previous = NULL;
    while (traverse != NULL) {
        if (strcmp (traverse->priezvisko, priezvisko) == 0) {
            if (previous == NULL) {
                *head = traverse->next;
            }
            else {
                previous->next = traverse->next;
            }
            free (traverse);
            return;
        }
        else {
            previous = traverse;
            traverse = traverse->next;
        }
    }
    fprintf (stderr, "Student %s sa nenasiel.\n", priezvisko);
    return;
}
----------------------------------------

void vymazstudenta (STUDENT **head, const char *priezvisko) {
    if (*head == NULL) {
        return;
    }
    if (!strcmp (*head->priezvisko, priezvisko)) {
        STUDENT *hladany = *head;
        *head = *head->next;
        free (hladany);
        return;
    }
    STUDENT *traverse = *head->next;
    STUDENT *previous = *head;
    while (traverse != NULL) {
        if (!strcmp (traverse->priezvisko, priezvisko)) {
            previous->next = traverse->next;
            free (traverse);
            return;
        }
        previous = traverse;
        traverse = traverse->next;
    }
    fprintf (stderr, "Student %s sa nenasiel.\n", priezvisko);
    return;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43525394_43525622_1_29
43525394_43525787_1_36
Title: Search and delete from linked list 
----------------------------------------

void vymazstudenta (STUDENT **head, const char *priezvisko) {
    STUDENT *traverse = *head;
    STUDENT *previous = NULL;
    while (traverse != NULL) {
        if (strcmp (traverse->priezvisko, priezvisko) == 0) {
            if (previous == NULL) {
                *head = traverse->next;
            }
            else {
                previous->next = traverse->next;
            }
            free (traverse);
            return;
        }
        else {
            previous = traverse;
            traverse = traverse->next;
        }
    }
    fprintf (stderr, "Student %s sa nenasiel.\n", priezvisko);
    return;
}
----------------------------------------

void vymazstudenta (STUDENT **head, const char *priezvisko) {
    STUDENT *tmp = NULL;
    if (*head != NULL) {
        if (strcmp (head->priezvisko, priezvisko) == 0) {
            tmp = *head;
            *head = (*head)->next;
        }
        else {
            STUDENT *traverse = *head;
            while (traverse->next != NULL && strcmp (traverse->next->priezvisko, priezvisko) != 0) {
                traverse = traverse->next;
            }
            if (traverse->next != NULL) {
                tmp = traverse->next;
                traverse->next = traverse->next->next;
            }
        }
    }
    if (tmp != NULL) {
        free (tmp);
    }
    else {
        fprintf (stderr, "Student %s sa nenasiel.\n", priezvisko);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43525394_43525738_1_40
43525394_43525787_1_36
Title: Search and delete from linked list 
----------------------------------------

void vymazstudenta (STUDENT **head, const char *priezvisko) {
    if (*head == NULL) {
        return;
    }
    if (!strcmp (*head->priezvisko, priezvisko)) {
        STUDENT *hladany = *head;
        *head = *head->next;
        free (hladany);
        return;
    }
    STUDENT *traverse = *head->next;
    STUDENT *previous = *head;
    while (traverse != NULL) {
        if (!strcmp (traverse->priezvisko, priezvisko)) {
            previous->next = traverse->next;
            free (traverse);
            return;
        }
        previous = traverse;
        traverse = traverse->next;
    }
    fprintf (stderr, "Student %s sa nenasiel.\n", priezvisko);
    return;
}
----------------------------------------

void vymazstudenta (STUDENT **head, const char *priezvisko) {
    STUDENT *tmp = NULL;
    if (*head != NULL) {
        if (strcmp (head->priezvisko, priezvisko) == 0) {
            tmp = *head;
            *head = (*head)->next;
        }
        else {
            STUDENT *traverse = *head;
            while (traverse->next != NULL && strcmp (traverse->next->priezvisko, priezvisko) != 0) {
                traverse = traverse->next;
            }
            if (traverse->next != NULL) {
                tmp = traverse->next;
                traverse->next = traverse->next->next;
            }
        }
    }
    if (tmp != NULL) {
        free (tmp);
    }
    else {
        fprintf (stderr, "Student %s sa nenasiel.\n", priezvisko);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4352768_4352928_5_28
4352768_4353045_7_42
Title: How do I declare an array of undefined or no initial size? 
----------------------------------------

int main (int argc, char **argv) {
    int *data;
    const int datacount = 50;
    data = malloc (sizeof (int) * datacount);
    if (!data) {
        perror ("Error allocating memory");
        abort ();
    }
    memset (data, 0, sizeof (int) * datacount);
    data[0] = 1;
    data[2] = 15;
    data[49] = 66;
    for (int i = 0; i < datacount; ++i) {
        printf ("Element %d: %d\n", i, data [i]);
    }
}
----------------------------------------

int main (int argc, char **argv) {
    int buf_size = 0;
    int buf_used = 0;
    char *buf = NULL;
    char *tmp = NULL;
    char c;
    int i = 0;
    while ((c = getchar ()) != EOF) {
        if (buf_used == buf_size) {
            buf_size += 20;
            tmp = realloc (buf, buf_size);
            if (!tmp)
                fatal_error ();
            buf = tmp;
        }
        buf[buf_used] = c;
        ++buf_used;
    }
    puts ("\n\n*** Dump of stdin ***\n");
    for (i = 0; i < buf_used; ++i) {
        putchar (buf [i]);
    }
    free (buf);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43548740_43549227_17_40
43548740_43549793_62_109
Title: Counting semaphore using SysV 
----------------------------------------

int main (void) {
    key_t sem0_k, sem1_k;
    sem0_k = ftok ("/tmp", '0');
    sem1_k = ftok ("/tmp", '1');
    sem0 = semget (sem0_k, 1, (IPC_CREAT | IPC_EXCL | 0666));
    sem1 = semget (sem1_k, 1, (IPC_CREAT | IPC_EXCL | 0666));
    pthread_t tids [3];
    pthread_create (tids + 2, NULL, t2, NULL);
    sleep (1);
    pthread_create (tids + 1, NULL, t1, NULL);
    sleep (1);
    pthread_create (tids + 0, NULL, t0, NULL);
    for (int i = 0; i < 3; i++)
        pthread_join (tids[i], NULL);
    semctl (sem0, 0, IPC_RMID, NULL);
    semctl (sem1, 0, IPC_RMID, NULL);
    return 0;
}
----------------------------------------

int main (void) {
    void (*funct []) = {thread_1, thread_2, thread_3};
    key_t semkey;
    char i;
    union semun {
        int val;
        struct semid_ds *buf;
        unsigned short *array;
        struct seminfo *__buf;
    } arg;
    pthread_t thread_id [3];
    semkey = ftok ("/tmp", 'a');
    if (semkey < 0)
        perror ("Cannot Create Semaphore Key");
    else {
        sem_id = semget (semkey, 2, (IPC_CREAT | IPC_EXCL | 0666));
        if (sem_id < 0)
            perror ("Cannot create semaphore\n");
        else {
        }
    }
    for (i = 0; i < 3; i++) {
        if (pthread_create (&thread_id[i], NULL, funct[i], NULL) < 0)
            perror ("Cannot Create thread\n");
    }
    for (i = 0; i < 3; i++)
        pthread_join (thread_id[i], NULL);
    if (semctl (sem_id, 0, IPC_RMID, NULL) == -1)
        perror ("semctl");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43550095_43550787_1_24
43550095_43550814_1_14
Title: how can i solve this when i try to return a 2d struct from a function 
----------------------------------------

struct cache **createCache (int numset, int blocksize, int cachesize) {
    cache **out;
    int numcache = (int) ((cachesize / blocksize) * numset);
    size_t headerSize = sizeof (*out) * numset;
    size_t bodySize = sizeof (**out) * numcache;
    out = malloc (headerSize +(bodySize * numset));
    if (out == NULL) {
        return NULL;
    }
    int i, j;
    for (i = 0; i < numset; i++) {
        out[i] = (cache *) (((char *) out) + (headerSize + bodySize * i));
        for (j = 0; j < numcache; j++) {
            out[i][j].tag = "0";
            out[i][j].vaild = 0;
            out[i][j].data = "0";
        }
    }
    return out;
}
----------------------------------------

CACHE **createCache (int ncache, int nset) {
    CACHE **out;
    out = calloc (ncache, sizeof (CACHE *));
    if (!out)
        return NULL;
    int i;
    for (i = 0; i < nset; i++) {
        out[i] = calloc (nset, sizeof (CACHE));
    }
    return out;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43550095_43550787_1_24
43550095_43551643_1_21
Title: how can i solve this when i try to return a 2d struct from a function 
----------------------------------------

struct cache **createCache (int numset, int blocksize, int cachesize) {
    cache **out;
    int numcache = (int) ((cachesize / blocksize) * numset);
    size_t headerSize = sizeof (*out) * numset;
    size_t bodySize = sizeof (**out) * numcache;
    out = malloc (headerSize +(bodySize * numset));
    if (out == NULL) {
        return NULL;
    }
    int i, j;
    for (i = 0; i < numset; i++) {
        out[i] = (cache *) (((char *) out) + (headerSize + bodySize * i));
        for (j = 0; j < numcache; j++) {
            out[i][j].tag = "0";
            out[i][j].vaild = 0;
            out[i][j].data = "0";
        }
    }
    return out;
}
----------------------------------------

struct cache **createCache (int numset, int blocksize, int cachesize) {
    int numcache = (int) ((cachesize / blocksize) * numset);
    struct cache **out = malloc (sizeof (struct cache *) * numset);
    int i, j;
    for (i = 0; i < numset; i++) {
        out[i] = malloc (sizeof (struct cache) * numcache);
        for (j = 0; j < numcache; j++) {
            out[i][j].tag = malloc (sizeof (char));
            out[i][j].data = malloc (sizeof (char));
            strcpy (out [i] [j].tag, "0");
            out[i][j].vaild = 0;
            strcpy (out [i] [j].data, "0");
        }
    }
    return out;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43550095_43550814_1_14
43550095_43551643_1_21
Title: how can i solve this when i try to return a 2d struct from a function 
----------------------------------------

CACHE **createCache (int ncache, int nset) {
    CACHE **out;
    out = calloc (ncache, sizeof (CACHE *));
    if (!out)
        return NULL;
    int i;
    for (i = 0; i < nset; i++) {
        out[i] = calloc (nset, sizeof (CACHE));
    }
    return out;
}
----------------------------------------

struct cache **createCache (int numset, int blocksize, int cachesize) {
    int numcache = (int) ((cachesize / blocksize) * numset);
    struct cache **out = malloc (sizeof (struct cache *) * numset);
    int i, j;
    for (i = 0; i < numset; i++) {
        out[i] = malloc (sizeof (struct cache) * numcache);
        for (j = 0; j < numcache; j++) {
            out[i][j].tag = malloc (sizeof (char));
            out[i][j].data = malloc (sizeof (char));
            strcpy (out [i] [j].tag, "0");
            out[i][j].vaild = 0;
            strcpy (out [i] [j].data, "0");
        }
    }
    return out;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43556443_43556524_4_25
43556443_43575445_4_28
Title: "Segmentation fault basic File Input/Output" 
----------------------------------------

int main (void) {
    FILE *sptr = fopen ("source.txt", "r");
    FILE *dptr = fopen ("destination.txt", "w");
    int ch = 0;
    if (sptr == NULL) {
        printf ("Error in opening source file.\n");
        exit (1);
    }
    if (dptr == NULL) {
        printf ("Error in opening destination file.\n");
        exit (1);
    }
    while ((ch = fgetc (sptr)) != EOF)
        fputc (ch, dptr);
    fclose (sptr);
    fclose (dptr);
    return 0;
}
----------------------------------------

int main (void) {
    FILE *sptr = NULL;
    FILE *dptr = NULL;
    int ch = 0;
    if ((sptr = fopen ("source.txt", "r")) == NULL) {
        perror ("fopen to read source.txt failed");
        exit (EXIT_FAILURE);
    }
    if ((dptr = fopen ("destination.txt", "w")) == NULL) {
        perror ("fopen to trucante/write destination.txt failed");
        exit (EXIT_FAILURE);
    }
    while ((ch = fgetc (sptr)) != EOF)
        fputc (ch, dptr);
    fclose (sptr);
    fclose (dptr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43565670_43565854_47_61
43565670_43566383_35_53
Title: String from user input that gets converted into a letter pattern. 
----------------------------------------

int main () {
    char input [MAX_INPUT_SIZE];
    do {
        printf ("Please enter your string: ");
        fgets (input, MAX_INPUT_SIZE, stdin);
        input[strlen (input) - 1] = '\0';
    }
    while (check_input (input));
    print_output (input);
    return 0;
}
----------------------------------------

int main (void) {
    char pattern [20];
    while (fputs (prompt, stdout), fflush (stdout), fgets (pattern, sizeof pattern, stdin)) {
        pattern[strcspn (pattern, "\n")] = 0;
        char *p = pattern;
        if (invalid (p)) {
            continue;
        }
        while (*p) {
            int n = strtoul (p, &p, 10);
            while (n--)
                putchar (*p);
            ++p;
        }
        puts ("");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43566923_43569041_4_38
43566923_43569249_3_20
Title: How do I take a file name and an int from the terminal and pass them into a c program to be used as parameters? 
----------------------------------------

int main (int argc, char *argv []) {
    int c = 0;
    if (argc != 3) {
        printf ("usage: ./a.out file number\n");
        return 1;
    }
    char *file = argv[1];
    int n = atoi (argv[2]);
    FILE *inptr = fopen (file, "read");
    if (inptr == NULL) {
        printf ("error\n");
        return 2;
    }
    int num = 0;
    int ch = getc (inptr);
    while (ch != EOF) {
        fscanf (inptr, "%d", & num);
        while (num != 0) {
            int d = num % 10;
            if (d == n) {c ++;
        }
        num /= 10;
    }
    ch = getc (inptr);
}
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp = argc > 1 ? fopen (argv[1], "r") : stdin;
    int c, srchc = argc > 2 ? *argv[2] : '1', n = 0;
    if (!fp) {
        fprintf (stderr, "error: file open failed '%s'.\n", argv [1]);
        return 1;
    }
    while ((c = fgetc (fp)) != EOF)
        if (c == srchc)
            n++;
    printf ("'%c' appeared %d times\n", srchc, n);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43572630_43572720_4_30
43572630_43572756_3_13
Title: How can I print this pattern? 
----------------------------------------

int main () {
    int i, j, k, l;
    char c = '*';
    for (i = 1; i <= 5; i++) {
        for (j = 5; j >= i; j--) {
            printf ("%c", c);
        }
        for (k = 1; k < i; k++) {
            printf ("  ");
        }
        for (l = 5; l >= i; l--) {
            printf ("%c", c);
        }
        printf ("\n");
    }
    getch ();
    return 0;
}
----------------------------------------

int main (void) {
    char stars [10] = "*********";
    char spaces [10] = "         ";
    int i = 0;
    for (i = 0; i < 5; i++) {
        printf ("%.*s%.*s%.*s\n", 5 - i, stars, i * 2, spaces, 5 - i, stars);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43598022_43599330_1_36
43598022_43627864_2_24
Title: Can't get my program to load a text file in 
----------------------------------------

int load (const char filename [], struct item inven [], size_t max_items) {
    FILE *fptr = fopen (filename, "r");
    if (fptr == NULL) {
        fprintf (stderr, "Couldn't open %s for reading: %s\n", filename, strerror (errno));
        exit (1);
    }
    char line [1024];
    int num_items = 0;
    while ((fgets (line, 1024, fptr) != NULL)) {
        if (num_items >= max_items) {
            fprintf (stderr, "There were more lines than space to store them");
            break;
        }
        if (sscanf (line, "%d %19s", &inven[num_items].itemID, inven[num_items].itemname) != 2) {
            fprintf (stderr, "Could not understand '%s'\nSkipping.\n", line);
            continue;
        }
        num_items++;
    }
    fclose (fptr);
    return num_items;
}
----------------------------------------

int load (struct item inven []) {
    FILE *fptr = fopen ("inven.txt", "r");
    if (!fptr) {
        perror ("fopen to read 'inven.txt' failed");
        return 0;
    }
    int count = 0;
    while (count < MAX && 2 == fscanf (fptr, "%d %19s", &inven[count].itemID, inven[count].itemname)) {
        count++;
    }
    fclose (fptr);
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43598022_43599330_1_36
43598022_43639897_365_390
Title: Can't get my program to load a text file in 
----------------------------------------

int load (const char filename [], struct item inven [], size_t max_items) {
    FILE *fptr = fopen (filename, "r");
    if (fptr == NULL) {
        fprintf (stderr, "Couldn't open %s for reading: %s\n", filename, strerror (errno));
        exit (1);
    }
    char line [1024];
    int num_items = 0;
    while ((fgets (line, 1024, fptr) != NULL)) {
        if (num_items >= max_items) {
            fprintf (stderr, "There were more lines than space to store them");
            break;
        }
        if (sscanf (line, "%d %19s", &inven[num_items].itemID, inven[num_items].itemname) != 2) {
            fprintf (stderr, "Could not understand '%s'\nSkipping.\n", line);
            continue;
        }
        num_items++;
    }
    fclose (fptr);
    return num_items;
}
----------------------------------------

int load (int count, struct item inven []) {
    FILE *fptr;
    if ((fptr = fopen ("inven.txt", "r")) == NULL) {
        fprintf (stderr, "could not open inven.txt\n");
        return 0;
    }
    while ((fscanf (fptr, " ID = %d Name = %s Des = %s On Hand = %d Unit Price = %lf", &inven[count].itemID, inven[count].itemname, inven[count].itemdes, &inven[count].itemOH, &inven[count].itemUP)) == 2) {
        count++;
        if (count >= MAX) {
            break;
        }
    }
    fclose (fptr);
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43598022_43627864_2_24
43598022_43639897_365_390
Title: Can't get my program to load a text file in 
----------------------------------------

int load (struct item inven []) {
    FILE *fptr = fopen ("inven.txt", "r");
    if (!fptr) {
        perror ("fopen to read 'inven.txt' failed");
        return 0;
    }
    int count = 0;
    while (count < MAX && 2 == fscanf (fptr, "%d %19s", &inven[count].itemID, inven[count].itemname)) {
        count++;
    }
    fclose (fptr);
    return count;
}
----------------------------------------

int load (int count, struct item inven []) {
    FILE *fptr;
    if ((fptr = fopen ("inven.txt", "r")) == NULL) {
        fprintf (stderr, "could not open inven.txt\n");
        return 0;
    }
    while ((fscanf (fptr, " ID = %d Name = %s Des = %s On Hand = %d Unit Price = %lf", &inven[count].itemID, inven[count].itemname, inven[count].itemdes, &inven[count].itemOH, &inven[count].itemUP)) == 2) {
        count++;
        if (count >= MAX) {
            break;
        }
    }
    fclose (fptr);
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43628224_43629297_1_31
43628224_43631109_1_36
Title: Attempting to split and store arrays similar to strtok 
----------------------------------------

char **split_at (char *s, char d) {
    int numdelim = 0;
    char *t = s;
    while (*t) {
        numdelim += *t == d;
        ++t;
    }
    char **final = (char **) malloc ((numdelim + 2) * sizeof (char *));
    char **f = final;
    t = s;
    while (*t) {
        if (*t == d) {
            char *n = (char *) malloc (t -s + 1);
            *f++ = n;
            while (s != t)
                *n++ = *s++;
            *n = 0;
        }
        ++t;
    }
    *f = NULL;
    return final;
}
----------------------------------------

char **split_at (char *s, char d) {
    int numdelim = 0;
    int x;
    for (x = 0; s[x] != '\0'; x++) {
        if (s[x] == d) {
            numdelim++;
        }
    }
    int a = 0;
    int b = 0;
    char **final = (char **) malloc ((numdelim + 1) * sizeof (char *));
    for (int i = 0; i <= numdelim; i++) {
        int sizeofj = 0;
        while ((s[a] != d) && (a < x)) {
            sizeofj++;
            a++;
        }
        final[i] = (char *) malloc (sizeofj);
        a++;
        int j = 0;
        while (j < sizeofj) {
            final[i][j] = s[b];
            j++;
            b++;
        }
        final[i][j] = '\0';
        b++;
    }
    return final;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43651807_43652039_1_12
43651807_43652868_13_27
Title: C strings and pointers 
----------------------------------------

void add (struct wordlist **pp, char *value) {
    struct wordlist *new;
    new = malloc (sizeof (*new));
    new->value = value;
    for (; (*pp) != NULL; (*pp) = (*pp)->next) {
        if (compare ((*pp), new) > 0) {
            break;
        }
    }
    new->next = (*pp);
    (*pp) = new;
}
----------------------------------------

void add (struct wordlist *pp, char *value) {
    struct wordlist *new;
    new = malloc (sizeof (*new));
    new->value = value;
    for (; pp->next != NULL; pp = pp->next) {
        if (compare (pp->next, new) > 0) {
            break;
        }
    }
    new->next = pp->next;
    pp->next = new;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43697803_43699428_7_64
43697803_43701822_7_73
Title: How can I share the memory when i call fork() ? 
----------------------------------------

int main (void) {
    int *arr;
    pid_t pid;
    int state;
    int c, i, j;
    arr = mmap (NULL, 10 * sizeof (int), PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_SHARED, -1, 0);
    if (arr == MAP_FAILED) {
        printf ("mmap failed\n");
        exit (- 1);
    }
    pid = fork ();
    if (pid == -1) {
        printf ("can't fork, error\n");
        exit (- 1);
    }
    else if (pid == 0) {
        printf ("\nProducer is created.\n");
        printf ("array: ");
        for (c = 0; c < 10; c++) {
            printf ("%d ", arr [c]);
            arr[c] = c + 1;
        }
    }
    else {
        pid = wait (&state);
        sleep (1);
        printf ("\nConsumer takes control of array");
        printf ("\narray:");
        for (j = 0; j < 10; j++) {
            printf (" %d", arr [j]);
        }
        printf ("\nConsumer is done.");
        printf ("\narray: ");
        for (i = 0; i < 10; i++) {
            arr[i] = -1;
            printf ("%d ", arr [i]);
        }
        printf ("\ndone\n");
    }
    munmap (arr, 10 * sizeof (int));
    return 0;
}
----------------------------------------

int main (void) {
    int fd [2], nbytes;
    pid_t pid;
    int arr [10] = {0,};
    int readbuffer [10];
    int state, c, i, j;
    pipe (fd);
    if ((pid = fork ()) == -1) {
        printf ("can't fork, error\n");
        exit (- 1);
    }
    else if (pid == 0) {
        close (fd [0]);
        printf ("\nProducer is created.\n");
        printf ("array: ");
        for (c = 0; c < 10; c++) {
            printf ("%d ", arr [c]);
            arr[c] = c + 1;
        }
        write (fd [1], arr, (sizeof (int) * 10));
        exit (0);
    }
    else {
        close (fd [1]);
        pid = wait (&state);
        sleep (1);
        printf ("\nConsumer takes control of array");
        nbytes = read (fd[0], arr, (sizeof (int) * 10));
        printf ("\narray:");
        for (j = 0; j < 10; j++) {
            printf (" %d", arr [j]);
        }
        printf ("\nConsumer is done.");
        printf ("\narray: ");
        for (i = 0; i < 10; i++) {
            arr[i] = -1;
            printf ("%d ", arr [i]);
        }
        printf ("\ndone\n");
        exit (0);
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43700903_43708923_48_109
43700903_43775498_121_149
Title: Scanf() function isn't taking string input 
----------------------------------------

int main (void) {
    size_t numTestCases;
    fastRead (& numTestCases);
    for (size_t testCase = 1; testCase <= numTestCases; testCase++) {
        size_t count = 0;
        int ch;
        while ((ch = getchar_unlocked ()) != '\n') {
            if (ch == 'a' || ch == 'd' || ch == 'g' || ch == 'j' || ch == 'm' || ch == 'p' || ch == 't' || ch == 'w' || ch == ' ') {
                count += 1;
            }
            else if (ch == 'b' || ch == 'e' || ch == 'h' || ch == 'k' || ch == 'n' || ch == 'q' || ch == 'u' || ch == 'x') {
                count += 2;
            }
            else if (ch == 'c' || ch == 'f' || ch == 'i' || ch == 'l' || ch == 'o' || ch == 'r' || ch == 'v' || ch == 'y') {
                count += 3;
            }
            else if (ch == 's' || ch == 'z') {
                count += 4;
            }
        }
        printf ("Case #%lu: %lu\n", testCase, count);
        putchar_unlocked ('\n');
    }
    return 0;
}
----------------------------------------

int main (void) {
    size_t numTestCases;
    fastRead (& numTestCases);
    for (size_t testCase = 1; testCase <= numTestCases; testCase++) {
        size_t keypresses = 0;
        int ch;
        while ((ch = getchar_unlocked ()) != '\n') {
            if (' ' == ch)
                keypresses += 1;
            else
                keypresses += keyPressCounts[ch - 'a'];
        }
        char outputLine [MAX_OUTPUT_LEN];
        strcpy (outputLine, "Case #");
        sprintf (& outputLine [strlen (outputLine)], "%lu", testCase);
        strcat (outputLine, ": ");
        sprintf (& outputLine [strlen (outputLine)], "%lu", keypresses);
        puts (outputLine);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43707009_43707320_6_32
43707009_43708115_6_25
Title: C - How would I extract Even numbers from an array and place them into another array called EvenNumbers? 
----------------------------------------

int main () {
    int array [] = {10, 2, 9, 3, 1, 98, 8};
    int *even_numbers;
    int i, nb_even_numbers;
    for (i = 0, nb_even_numbers = 0; i < MAX; i++) {
        if (array[i] % 2 == 0)
            nb_even_numbers++;
    }
    even_numbers = malloc (sizeof (int) * nb_even_numbers);
    if (!even_numbers) {
        perror ("malloc");
        return 1;
    }
    for (i = 0, nb_even_numbers = 0; i < MAX; i++) {
        if (array[i] % 2 == 0)
            even_numbers[nb_even_numbers++] = array[i];
    }
    free (even_numbers);
    return 0;
}
----------------------------------------

int main (void) {
    int array [] = {10, 2, 9, 3, 1, 98, 8}, i, n = sizeof array / sizeof *array, even [n], esize = 0;
    EvenNumber (array, even, n, & esize);
    printf ("array: ");
    for (i = 0; i < n; i++)
        printf (" %2d", array[i]);
    printf ("\neven : ");
    for (i = 0; i < esize; i++)
        printf (" %2d", even[i]);
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43728469_43728687_5_32
43728469_43728851_1_23
Title: Spit array with strtok and store tokens in unique null terminated strings 
----------------------------------------

int main () {
    char cmd [255] = "";
    char arg [20] = "";
    char arg2 [20] = "";
    char arg3 [20] = "";
    char *p;
    fgets (cmd, 255, stdin);
    p = strtok (cmd, " ");
    if (p != NULL) {
        strcpy (arg, p);
        p = strtok (NULL, " ");
        if (p != NULL) {
            strcpy (arg2, p);
            p = strtok (NULL, "");
            if (p != NULL) {
                strcpy (arg3, p);
            }
        }
    }
    printf (" arg=%s\n arg2=%s\n arg3=%s\n", arg, arg2, arg3);
    return 0;
}
----------------------------------------

int main (void) {
    char cmd [255];
    char argv [3] [20];
    char *token;
    char *tstr = " ";
    fgets (cmd, sizeof cmd, stdin);
    token = strtok (cmd, tstr);
    int i = 0;
    while (token != NULL) {
        strcpy (argv [i], token);
        printf ("%s\n", argv [i]);
        token = strtok (NULL, tstr);
        i++;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43728469_43728687_5_32
43728469_43730482_6_23
Title: Spit array with strtok and store tokens in unique null terminated strings 
----------------------------------------

int main () {
    char cmd [255] = "";
    char arg [20] = "";
    char arg2 [20] = "";
    char arg3 [20] = "";
    char *p;
    fgets (cmd, 255, stdin);
    p = strtok (cmd, " ");
    if (p != NULL) {
        strcpy (arg, p);
        p = strtok (NULL, " ");
        if (p != NULL) {
            strcpy (arg2, p);
            p = strtok (NULL, "");
            if (p != NULL) {
                strcpy (arg3, p);
            }
        }
    }
    printf (" arg=%s\n arg2=%s\n arg3=%s\n", arg, arg2, arg3);
    return 0;
}
----------------------------------------

int main (void) {
    char cmd [256];
    if (fgets (cmd, sizeof cmd, stdin)) {
        char arg [ARG_LEN + 1], arg2 [ARG_LEN + 1], arg3 [ARG_LEN + 1];
        char *args [] = {arg, arg2, arg3, NULL};
        char **pp = args;
        const char *delimiter = " \t\n";
        for (char *p = strtok (cmd, delimiter); p && *pp; p = strtok (NULL, delimiter)) {
            strncpy (* pp, p, ARG_LEN);
            (*pp++)[ARG_LEN] = 0;
        }
        for (size_t i = 0; args + i < pp; ++i) {
            printf ("argument #%zu: '%s'\n", i + 1, args [i]);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43728469_43728851_1_23
43728469_43730482_6_23
Title: Spit array with strtok and store tokens in unique null terminated strings 
----------------------------------------

int main (void) {
    char cmd [255];
    char argv [3] [20];
    char *token;
    char *tstr = " ";
    fgets (cmd, sizeof cmd, stdin);
    token = strtok (cmd, tstr);
    int i = 0;
    while (token != NULL) {
        strcpy (argv [i], token);
        printf ("%s\n", argv [i]);
        token = strtok (NULL, tstr);
        i++;
    }
    return 0;
}
----------------------------------------

int main (void) {
    char cmd [256];
    if (fgets (cmd, sizeof cmd, stdin)) {
        char arg [ARG_LEN + 1], arg2 [ARG_LEN + 1], arg3 [ARG_LEN + 1];
        char *args [] = {arg, arg2, arg3, NULL};
        char **pp = args;
        const char *delimiter = " \t\n";
        for (char *p = strtok (cmd, delimiter); p && *pp; p = strtok (NULL, delimiter)) {
            strncpy (* pp, p, ARG_LEN);
            (*pp++)[ARG_LEN] = 0;
        }
        for (size_t i = 0; args + i < pp; ++i) {
            printf ("argument #%zu: '%s'\n", i + 1, args [i]);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43770168_43770232_3_16
43770168_43791892_8_66
Title: How to copy the returned token by strtok in c 
----------------------------------------

int main (void) {
    FILE *fp = fopen ("somefile", "r");
    char temp [3] [20];
    if (fp != NULL) {
        char line [1024];
        while (fgets (line, sizeof line, fp) != NULL) {
            if (sscanf (line, "%19[^,],%19[^,],%19[^\n]", temp[0], temp[1], temp[2]) == 3) {
                printf ("%s\n%s\n%s\n\n", temp [0], temp [1], temp [2]);
            }
        }
        fclose (fp);
    }
    return 0;
}
----------------------------------------

int main (void) {
    FILE *f = fopen ("somefile", "r");
    if (!f) {
        perror ("fopen to read somefile failed");
        exit (EXIT_FAILURE);
    }
    char *temp [MAX_PARAMETERS];
    if (NULL == (temp[0] = malloc (MAX_LENGTH))) {
        perror ("malloc failed");
        exit (EXIT_FAILURE);
    }
    if (NULL == (temp[1] = malloc (MAX_LENGTH))) {
        perror ("malloc failed");
        exit (EXIT_FAILURE);
    }
    if (NULL == (temp[2] = malloc (MAX_LENGTH))) {
        perror ("malloc failed");
        exit (EXIT_FAILURE);
    }
    char line [1024];
    while (fgets (line, sizeof line, f)) {
        int i;
        char *pch = strtok (line, ",");
        for (i = 0; i < 3 && pch; i++) {
            strcpy (temp [i], pch);
            pch = strtok (NULL, ",");
        }
        if (MAX_PARAMETERS != i) {
            printf ("failed to extract all parameters from line: %s\n", line);
        }
        else {
            for (int j = 0; j < MAX_PARAMETERS; j++) {
                printf ("%s\n", temp [j]);
            }
        }
    }
    fclose (f);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43777163_43777786_7_37
43777163_43792424_11_69
Title: write() doesn't write the data 
----------------------------------------

int main (int argc, char *argv []) {
    int fd1, fd2;
    size_t len, nbytes;
    ssize_t bytes_read;
    struct stat st;
    fd1 = open ("./file1.txt", O_RDWR);
    if ((fd1 != -1) && (fstat (fd1, &st) == 0)) {
        len = st.st_size;
    }
    fd2 = open ("./file2.txt", O_WRONLY | O_CREAT | O_TRUNC, 0644);
    char buf [len];
    nbytes = sizeof (buf);
    if ((fd1 != -1) && (fd2 != -1)) {
        bytes_read = read (fd1, buf, nbytes);
        write (fd2, buf, nbytes);
        close (fd1);
        close (fd2);
    }
    else {
        printf ("error \n");
        exit (- 1);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int fd1;
    int fd2;
    ssize_t bytes_read;
    if (3 != argc) {
        fprintf (stderr, "USAGE: %s inputFileName outputFileName\n", argv [0]);
        exit (EXIT_FAILURE);
    }
    if (0 > (fd1 = open (argv[1], O_RDONLY))) {
        perror ("open for input file failed");
        exit (EXIT_FAILURE);
    }
    if (0 > (fd2 = open (argv[2], O_WRONLY | O_CREAT | O_TRUNC, 0644))) {
        perror ("open for output file failed");
        close (fd1);
        exit (EXIT_FAILURE);
    }
    char buf [MAX_BUF_LEN];
    while ((bytes_read = read (fd1, buf, MAX_BUF_LEN))) {
        if (0 > bytes_read) {
            perror ("read failed");
            break;
        }
        else {
            ssize_t bytes_written = write (fd2, buf, (size_t) bytes_read);
            if (bytes_read != bytes_written) {
                fprintf (stderr, "bytes read: %ld, bytes written: %ld\n", bytes_read, bytes_written);
                break;
            }
        }
    }
    close (fd1);
    close (fd2);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43802570_43802571_102_112
43802570_43803593_25_33
Title: How to convert a sum of money to Indian currency format(Indian number format)? 
----------------------------------------

int main () {
    char lp_number [255];
    int lv_l;
    char *formated_number;
    printf ("Enter the lp_number\n");
    fgets (lp_number, 255, stdin);
    lv_l = strlen (lp_number);
    formated_number = convertToInrFormat (lp_number, lv_l);
    puts (formated_number);
}
----------------------------------------

int main (int argc, char *argv []) {
    for (int i = 1; i < argc; i++) {
        char *input = argv[i];
        char *output = convertToInrFormat (input);
        printf ("%s -> %s\n", input, output);
        free (output);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43802570_43802571_5_100
43802570_43803593_5_23
Title: How to convert a sum of money to Indian currency format(Indian number format)? 
----------------------------------------

char *convertToInrFormat (char *lp_number, int lv_l) {
    char *lp_fnumber = '\0';
    char *lp_p = '\0';
    int lv_index = 0;
    int lv_nsize = 0;
    int lv_zerocount = 0;
    int sign_count = 0;
    int expo_count = 0;
    int lv_i = 0;
    int lv_j = 0;
    if (lp_number[0] == '-') {
        sign_count++;
    }
    lv_zerocount = strspn (lp_number +sign_count, "0");
    if (lp_number[sign_count + lv_zerocount] == '.') {
        lv_zerocount = lv_zerocount - 1;
    }
    if (lv_zerocount > 0) {
        memmove (lp_number + sign_count, lp_number + lv_zerocount + sign_count, strlen (lp_number));
    }
    while (lp_number[sign_count] != '.' && lp_number[sign_count] != '\0') {
        expo_count++;
        sign_count++;
    }
    lv_l = strlen (lp_number);
    if (expo_count > 3) {
        lv_nsize = lv_l + (expo_count / 2 - 1) + 1;
        lp_fnumber = (char *) malloc (lv_nsize);
        if (lp_fnumber != NULL) {
            if (lp_number[0] == '-') {
                lp_fnumber[0] = lp_number[0];
                lv_j++;
                memmove (lp_number, lp_number + 1, strlen (lp_number));
                lv_l--;
                if (expo_count % 2 != 0) {
                    lp_fnumber[1] = lp_number[0];
                    lv_j++;
                    memmove (lp_number, lp_number + 1, strlen (lp_number));
                    expo_count--;
                }
            }
            else if (expo_count % 2 != 0) {
                lp_fnumber[0] = lp_number[0];
                lv_j = lv_j + 1;
                memmove (lp_number, lp_number + 1, strlen (lp_number));
                expo_count--;
            }
            lp_p = strchr (lp_number, '.');
            if (lp_p != NULL) {
                lv_index = lp_p - lp_number;
            }
            while (lv_i < expo_count) {
                lp_fnumber[lv_j++] = lp_number[lv_i++];
                if (lv_i + 2 < expo_count && lv_i % 2 != 0)
                    lp_fnumber[lv_j++] = ',';
            }
            if (lv_index != 0) {
                while (lp_number[lv_index] != '\0') {
                    lp_fnumber[lv_j++] = lp_number[lv_index++];
                }
            }
            lp_fnumber[lv_j] = '\0';
        }
        return lp_fnumber;
    }
    else {
        return lp_number;
    }
}
----------------------------------------

char *convertToInrFormat (const char *s) {
    const char *src = s + strspn (s, " \t\r\n");
    int len = strspn (src, "0123456789");
    int destlen = len + (len > 3 ? len / 2 - 1 : len == 0);
    char *dest = malloc (destlen +1);
    if (dest != NULL) {
        int i = 0, j = 0;
        while (i < len) {
            dest[j++] = src[i++];
            if (i + 2 < len && ((i ^ len) & 1))
                dest[j++] = ',';
        }
        if (len == 0) {
            dest[j++] = '0';
        }
        dest[j] = '\0';
    }
    return dest;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43803429_43803734_1_21
43803429_43804477_1_30
Title: Segmentation fault in C code function 
----------------------------------------

int QueueDeleteNext (Queue *myQueue, char value) {
    Node *current_node, *previous_node;
    previous_node = NULL;
    for (current_node = myQueue->front; current_node != NULL; previous_node = current_node, current_node = current_node->next) {
        if (current_node->gender == value) {
            if (previous_node == NULL) {
                myQueue->front = myQueue->back = NULL;
            }
            else {
                previous_node->next = current_node->next;
                if (previous_node->next == NULL) {
                    myQueue->back = previous_node;
                }
            }
            free (current_node);
            return 1;
        }
    }
    return 0;
}
----------------------------------------

int QueueDeleteNext (struct Queue *q, char value) {
    struct Node *prev = NULL;
    struct Node *curr = q->front;
    int count = 0;
    while (curr) {
        if (curr->gender == value) {
            struct Node *nn = curr;
            if (prev == NULL) {
                q->front = curr->next;
            }
            else {
                prev->next = curr->next;
            }
            if (curr == q->back)
                q->back = prev;
            curr = curr->next;
            free (nn);
            count++;
        }
        else {
            prev = curr;
            curr = curr->next;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43838910_43839070_5_18
43838910_43839206_5_24
Title: merge two strings of different sizes in C 
----------------------------------------

char *zip (char *a, char *b) {
    char *c = malloc ((strlen (a) + strlen (b) + 1) * sizeof (char)), *p = c;
    if (c) {
        while (*a || *b) {
            if (*a)
                *p++ = *a++;
            if (*b)
                *p++ = *b++;
        }
        *p = '\0';
    }
    return c;
}
----------------------------------------

char *zip (char *A, char *B) {
    char *C;
    int k = 0;
    C = (char *) malloc (strlen (A) +strlen (B) + 1);
    while (*A != '\0' || *B != '\0') {
        if (*A != '\0') {
            C[k++] = *A;
            ++A;
        }
        if (*B != '\0') {
            C[k++] = *B;
            ++B;
        }
    }
    C[k] = '\0';
    return C;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43839257_43839503_1_11
43839257_43839587_28_42
Title: "Need to be ""pointed"" in the right direction beginning C programming" 
----------------------------------------

int read (char words [] [31]) {
    FILE *file;
    int i, j, count = 0;
    file = fopen ("words.txt", "r");
    for (i = 0; i < 7; i++) {
        count += (1 == fscanf (file, "%s", words[i]));
    }
    return count;
}
----------------------------------------

int read (void *array) {
    FILE *file = fopen (DATA_FILE, "r");
    if (file == NULL) {
        perror ("fopen:");
        exit (EXIT_FAILURE);
    }
    char *words = array;
    int rows;
    for (rows = 0; rows < MAX_ROWS; ++rows, words += COLS) {
        if (fscanf (file, "%" S (MAX_WORD_LENGTH) "s", words) == EOF)
            break;
    }
    fclose (file);
    return rows;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
43847195_43847613_4_22
43847195_43847754_17_25
Title: How to check certain chars in string in C? 
----------------------------------------

int main () {
    char toCheck [5] = {'a', 'e', 'i', 'o', 'u'};
    char userstring [25];
    int i;
    printf ("Enter your string : \n");
    scanf ("%s", userstring);
    for (i = 0; i < SIZE; i++) {
        if (strchr (userstring, toCheck[i]) == NULL)
            break;
    }
    if (i == SIZE)
        printf ("All Required Characters present");
    else
        printf ("All Required Characters not present");
    return 0;
}
----------------------------------------

int main (void) {
    char input [256];
    fgets (input, sizeof input, stdin);
    input[strcspn (input, "\n")] = 0;
    if (containsAll (input, "aeiuo"))
        puts ("yes");
    else
        puts ("no");
}
----------------------------------------
