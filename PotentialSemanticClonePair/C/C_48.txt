$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44426000_44426134_5_19
44426000_44426234_4_27
Title: How do I make a vertical graph based on inputs? 
----------------------------------------

int main (void) {
    int height [DATA_MAX_LEN], length = 0, max = 0;
    for (int len = 0, h; len < DATA_MAX_LEN && scanf ("%d", &h) == 1; ++len) {
        height[length++] = h;
        if (height[length - 1] > max) {
            max = height[length - 1];
        }
    }
    while (max--) {
        for (int i = 0; i < length; ++i) {
            putchar (height [i] > max ? '#' : ' ');
        }
        putchar ('\n');
    }
}
----------------------------------------

int main (void) {
    int st [MAX];
    int n = 0;
    int i, j;
    int max_value = -1;
    while (scanf ("%d", st +n) != EOF) {
        if (st[n] > max_value)
            max_value = st[n];
        ++n;
    }
    for (i = max_value; i > 0; --i) {
        for (j = 0; j < n; ++j) {
            if (st[j] >= i)
                printf ("#");
            else
                printf (" ");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4445450_4445513_3_11
4445450_46586095_4_19
Title: how to convert the string to hex code of the ASCII in C 
----------------------------------------

int main (int argc, char *argv []) {
    char buf [255] = {0};
    char yourString [255] = {"Hello"};
    for (size_t i = 0; i < strlen (yourString); i++) {
        sprintf (buf, "%s%x", buf, yourString [i]);
    }
    printf (buf + '\n');
    return 0;
}
----------------------------------------

int main (void) {
    unsigned char word [17], unsigned outword [33];
    int i, len;
    printf ("Intro word:");
    fgets (word, sizeof (word), stdin);
    len = strlen (word);
    if (word[len - 1] == '\n')
        word[--len] = '\0';
    for (i = 0; i < len; i++) {
        sprintf (outword + i * 2, "%02X", word [i]);
    }
    printf ("%s\n", outword);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44472509_44479209_32_66
44472509_44480954_24_33
Title: Error while trying to run a program to find primes within a given range in C 
----------------------------------------

int main (void) {
    int low = 60;
    int high = 80;
    printf ("Enter the lower limit of the range \n");
    if (1 != scanf ("%d", &low)) {
        perror ("scanf for first number failed");
        exit (EXIT_FAILURE);
    }
    printf ("Enter the higher limit of the range \n");
    if (1 != scanf ("%d", &high)) {
        perror ("scanf for second number failed");
        exit (EXIT_FAILURE);
    }
    if (low < 0 || low > high) {
        printf ("the numbers must be >= 0 and the first number: %d must be <= the second number: %d\n", low, high);
    }
    else {
        prime (low, high);
    }
    return 0;
}
----------------------------------------

int main () {
    int i, j;
    printf ("Enter the lower limit of the range \n");
    scanf ("%d", & i);
    printf ("Enter the higher limit of the range \n");
    scanf ("%d", & j);
    prime (i, j);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44472509_44479209_5_29
44472509_44480954_2_23
Title: Error while trying to run a program to find primes within a given range in C 
----------------------------------------

void prime (int low, int high) {
    int b;
    int g;
    int r;
    printf ("The prime numbers in this range are: \n");
    for (int a = low; a <= high; a++) {
        r = 0;
        for (b = 2; b < a - 1; b++) {
            g = a % b;
            if (g == 0)
                break;
            r++;
        }
        if (r == a - 3)
            printf ("%d \n", a);
    }
}
----------------------------------------

void prime (int low, int high) {
    int a, b, g, r;
    printf ("The prime numbers in this range are: \n");
    if (low == 1)
        low++;
    if (low == 0)
        low = low + 2;
    for (a = low; a <= high; a++) {
        r = 0;
        for (b = 2; b < a; b++) {
            g = a % b;
            if (g == 0)
                break;
            r++;
        }
        if (r == a - 2)
            printf ("%d \n", a);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44472886_44472936_1_22
44472886_44473093_21_40
Title: Segmentation Fault when printing a linked list recursively 
----------------------------------------

int main (void) {
    struct node *nodes [MAX];
    for (int i = 0; i < MAX; i++) {
        nodes[i] = malloc (sizeof (struct node));
        if (nodes[i] == NULL) {
            fprintf (stderr, "memory allocation failure\n");
            exit (1);
        }
        nodes[i]->value = i + 1;
        nodes[i]->next = NULL;
        if (i > 0) {
            nodes[i - 1]->next = nodes[i];
        }
    }
    printRecursively (nodes [0]);
    for (int i = 0; i < MAX; i++) {
        free (nodes [i]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    struct node *nodes [MAX + 1];
    int i = MAX;
    nodes[i] = NULL;
    for (; i != 0; i--) {
        nodes[i - 1] = malloc (sizeof (struct node));
        nodes[i - 1]->value = i;
        nodes[i - 1]->next = nodes[i];
    }
    printRecursively (nodes [0]);
    for (i = 0; i < MAX; i++)
        free (nodes[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44472886_44472936_1_22
44472886_44480264_24_41
Title: Segmentation Fault when printing a linked list recursively 
----------------------------------------

int main (void) {
    struct node *nodes [MAX];
    for (int i = 0; i < MAX; i++) {
        nodes[i] = malloc (sizeof (struct node));
        if (nodes[i] == NULL) {
            fprintf (stderr, "memory allocation failure\n");
            exit (1);
        }
        nodes[i]->value = i + 1;
        nodes[i]->next = NULL;
        if (i > 0) {
            nodes[i - 1]->next = nodes[i];
        }
    }
    printRecursively (nodes [0]);
    for (int i = 0; i < MAX; i++) {
        free (nodes [i]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    struct node *nodes [MAX] = {NULL};
    for (int i = 0; i < MAX; i++) {
        nodes[i] = malloc (sizeof (struct node));
        nodes[i]->value = i + 1;
        nodes[i]->next = NULL;
        if (i > 0) {
            nodes[i - 1]->next = nodes[i];
        }
    }
    printRecursively (nodes [0]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44472886_44473093_21_40
44472886_44480264_24_41
Title: Segmentation Fault when printing a linked list recursively 
----------------------------------------

int main (void) {
    struct node *nodes [MAX + 1];
    int i = MAX;
    nodes[i] = NULL;
    for (; i != 0; i--) {
        nodes[i - 1] = malloc (sizeof (struct node));
        nodes[i - 1]->value = i;
        nodes[i - 1]->next = nodes[i];
    }
    printRecursively (nodes [0]);
    for (i = 0; i < MAX; i++)
        free (nodes[i]);
    return 0;
}
----------------------------------------

int main (void) {
    struct node *nodes [MAX] = {NULL};
    for (int i = 0; i < MAX; i++) {
        nodes[i] = malloc (sizeof (struct node));
        nodes[i]->value = i + 1;
        nodes[i]->next = NULL;
        if (i > 0) {
            nodes[i - 1]->next = nodes[i];
        }
    }
    printRecursively (nodes [0]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44486795_44487046_5_19
44486795_44510429_4_32
Title: How to read Texts/Numbers from a File in C 
----------------------------------------

int main () {
    FILE *file;
    char strings [200];
    char phoneNumber [MAXPHLEN];
    float localCharges, internationalCharges, roamingCharges;
    file = fopen ("Phone Bill.txt", "r");
    if (file != NULL) {
        fgets (strings, sizeof strings, file);
        while ((fscanf (file, "%49s%f%f%f", phoneNumber, &localCharges, &internationalCharges, &roamingCharges)) == 4) {
            printf ("%s %0.f %0.f %0.f\n", phoneNumber, localCharges, internationalCharges, roamingCharges);
        }
        fclose (file);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char strings [200];
    FILE *fp = fopen ("Phone Bill.txt", "r");
    if (!fp) {
        perror ("fopen to read Phone Bill.txt failed");
        exit (EXIT_FAILURE);
    }
    while (fgets (strings, sizeof (strings), fp)) {
        puts (strings);
    }
    if (!feof (fp)) {
        perror ("read of Phone Bill.txt failed");
        fclose (fp);
        exit (EXIT_FAILURE);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44487509_44500142_18_33
44487509_44509345_19_40
Title: "Segmentation Fault when pushing string to the stack "" C """ 
----------------------------------------

int main (int charc, char *argv []) {
    char *val = malloc (256);
    push ("One");
    push ("Two");
    printStack ();
    printf ("Push a new String to the stack: ");
    scanf (" %s", val);
    push (val);
    printStack ();
    printf ("Push a new String to the stack: ");
    scanf (" %s", val);
    push (val);
    printStack ();
    free (val);
}
----------------------------------------

int main (int charc, char *argv []) {
    printf ("Welcome to fun with stacks to get a list of full commands enter 'HELP'\n");
    char *val;
    char *usr_chc = malloc (256);
    do {
        printf ("Enter your choice to PUSH, POP, PRINT or EXIT\n");
        scanf ("%s", usr_chc);
        if (strcmp (usr_chc, "PUSH") == 0 || strcmp (usr_chc, "push") == 0) {
            val = malloc (256);
            printf ("Push a new String to the stack: ");
            scanf (" %s", val);
            push (val);
            printStack ();
        }
        else if (strcmp (usr_chc, "POP") == 0 || strcmp (usr_chc, "pop") == 0) {
            pop ();
        }
        else if (strcmp (usr_chc, "PRINT") == 0 || strcmp (usr_chc, "print") == 0) {
            printStack ();
        }
        else if (strcmp (usr_chc, "HELP") == 0 || strcmp (usr_chc, "help") == 0) {
            printf ("The list of commandds\n POP - to pop the top node off the stack\n PUSH to add new data to the stack \n PRINT - Print the stack data\n EXIT to quit the program\n");
        }
    }
    while (strcmp (usr_chc, "EXIT") != 0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44491456_44491643_5_51
44491456_44491654_4_36
Title: Counting number of integer inputs in C 
----------------------------------------

int main () {
    int num [20];
    printf ("Enter 4 integers: ");
    char read [100];
    fgets (read, 100, stdin);
    int count = 0;
    char *endptr = NULL;
    char *nextptr = read;
    do {
        num[count] = strtol (nextptr, &endptr, 10);
        if (errno == ERANGE) {
            printf ("Number out of range.\n");
            exit (EXIT_FAILURE);
        }
    }
    while (nextptr != endptr && (++count < 20) && (nextptr = endptr));
    char tmp [2];
    if (sscanf (nextptr, "%1s", tmp) != EOF) {
        printf ("Nothing other than numbers such as '%s' should be in the input\n", tmp);
        exit (EXIT_FAILURE);
    }
    if (count < 4) {
        printf ("You've entered less than 4 numbers.\n");
        exit (EXIT_FAILURE);
    }
    else if (count > 4) {
        printf ("You've entered more than 4 numbers.\n");
        exit (EXIT_FAILURE);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int num [20];
    int i = 0;
    if (argc != 5) {
        printf ("\n");
        printf ("Input must consist of 4 integers\n");
        exit (0);
    }
    while (argc != 1) {
        num[i] = atoi (argv[i + 1]);
        argc--;
        i++;
    }
    if (sol_for_24 (num)) {
        printf ("\n");
        printf ("Yes! 24 is reachable from { %d, %d, %d, %d }\n", num [0], num [1], num [2], num [3]);
    }
    else {
        printf ("\n");
        printf (sol_for_24 (num) ? "\n" : "Noooo :( 24 is unreachable from { %d, %d, %d, %d }\n", num [0], num [1], num [2], num [3]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44503899_44504437_21_38
44503899_44505514_1_16
Title: calculating amount based on uneven ranges in C 
----------------------------------------

void findBill (int table [], float ar [], int size) {
    int i, j, amt, slice;
    float bill;
    for (i = 0; i < 7; i++) {
        amt = table[i];
        bill = 0.f;
        for (j = 0;
        amt > 0 && j < NUM_RATES;
        ++ j) {slice = MIN (amnt, RATE_TABLE [j].slice);
        bill += (slice * RATE_TABLE[j].ppu);
        amt -= slice;
    }
    ar[i] = bill;
}
----------------------------------------

void findBill (int table [], float arr [], int size) {
    int levels [] = {75, 50, 40, 30, 25, 20, 15, 10, 5, 0};
    float costs [] = {120, 110, 105, 90, 75, 50, 30, 15, 7, 3};
    int level_cnt = sizeof (levels) / sizeof (int);
    for (int i = 0; i < size; i++) {
        arr[i] = 0;
        for (int c = 0; c < level_cnt; c++) {
            if (table[i] > levels[c]) {
                arr[i] += (table[i] - levels[c]) * costs[c];
                table[i] = levels[c];
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44535066_44535203_5_28
44535066_44536144_6_48
Title: Trying to count the lines of text that is printed when reading a file using C programming language 
----------------------------------------

int main (void) {
    FILE *p_file = 0;
    char name [100];
    char st [100];
    printf ("what file\n");
    scanf ("%s", name);
    p_file = fopen (name, "r");
    int count = 0;
    while (fgets (st, sizeof st, p_file) != NULL) {
        count = count + 1;
        printf ("%d:  ", count);
        printf ("%s", st);
    }
    fclose (p_file);
    return 0;
}
----------------------------------------

int main (void) {
    FILE *fp;
    char filename [FILENAME_MAX + 1] = "";
    int line_no, line_no_width, ch, pre_ch;
    printf ("Filename? ");
    fflush (stdout);
    fgets (filename, sizeof filename, stdin);
    filename[strcspn (filename, "\n")] = 0;
    putchar ('\n');
    if ((fp = fopen (filename, "r")) == NULL) {
        perror ("fopen:");
        exit (EXIT_FAILURE);
    }
    line_no = 0;
    while ((ch = fgetc (fp)) != EOF) {
        if (ch == '\n') {
            ++line_no;
        }
        pre_ch = ch;
    }
    if (pre_ch != '\n')
        ++line_no;
    for (line_no_width = 0; line_no; line_no /= 10)
        ++line_no_width;
    line_no = 0;
    pre_ch = '\n';
    rewind (fp);
    while ((ch = fgetc (fp)) != EOF) {
        if (pre_ch == '\n') {
            ++line_no;
            printf ("%*d: ", line_no_width, line_no);
        }
        putchar (ch);
        pre_ch = ch;
    }
    fclose (fp);
    if (pre_ch != '\n')
        putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44536146_44536681_4_36
44536146_44539332_4_34
Title: Defining malloc array size with scanf and initialising 
----------------------------------------

int main (void) {
    int elements = 0;
    printf ("How many Elements will you enter? ");
    if ((1 != scanf ("%d", &elements)) || (elements < 1)) {
        printf ("Reading number failed.\n");
        return 1;
    }
    int *elementArray = malloc (sizeof (int) * elements);
    int i = 0;
    while ((i < elements) && ((0 == i) || (0 != elementArray[i - 1]))) {
        printf ("Element %d: ", i + 1);
        if (1 != scanf ("%d", &elementArray[i])) {
            printf ("Reading value failed!\n");
            free (elementArray);
            return 1;
        }
        i++;
    }
    if (i < elements) {
        printf ("Stopped early because 0 was entered.\n");
    }
    free (elementArray);
    return 0;
}
----------------------------------------

int main (void) {
    int elements = 0;
    printf ("How many Elements will you enter?");
    scanf ("%d", & elements);
    int *elementArray = (int *) malloc (sizeof (int) * elements);
    int i = 0, elm;
    for (i = 0; i < elements; i++) {
        printf ("Element %d: ", i);
        scanf ("%d", & elm);
        *(elementArray + i) = elm;
    }
    for (i = 0; i < elements; i++)
        printf ("%d", *(elementArray + i));
    free (elementArray);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44551886_45165645_2_75
44551886_45784452_2_65
Title: Nesting of different loops in C 
----------------------------------------

int main () {
    int num, incentive;
    int salary = 1500;
    float w_hr, avg_time, LOP, tot_sal;
    int tot_hr = 50;
    printf ("Enter the no. of projects allocated\n");
    scanf ("%d", & num);
    printf ("Enter the no. of working hours\n");
    scanf ("%f", & w_hr);
    if (num <= 10) {
        if (w_hr < tot_hr) {
            avg_time = w_hr / num;
            printf ("Average Time Taken(Hrs)\n%f", avg_time);
        }
        else if (w_hr > 50 && w_hr <= 55) {
            LOP = 0.5;
            tot_sal = (((100 - LOP) / 100) * salary);
            printf ("You have exceeded the timeline\n");
            printf ("Your Salary is Rs.%.2f", tot_sal);
        }
        else if (w_hr > 55 && w_hr <= 60) {
            LOP = 1.0;
            tot_sal = (((100 - LOP) / 100) * salary);
            printf ("You have exceeded the timeline\n");
            printf ("You Salary is Rs.%.2f", tot_sal);
        }
        else if (w_hr > 60 && w_hr <= 70) {
            LOP = 1.5;
            tot_sal = (((100 - LOP) / 100) * salary);
            printf ("You have exceeded the timeline\n");
            printf ("Your Salary is Rs.%.2f", tot_sal);
        }
        else
            printf ("Invalid input");
    }
    else {
        printf ("The maximum limit on project count has been specified as %d. SORRY!!", num);
    }
    while (w_hr < tot_hr) {
        if (avg_time < 5) {
            incentive = 5000;
            tot_sal = salary + incentive;
            printf ("Your Salary is %.f", tot_sal);
        }
        else if (avg_time >= 5 && avg_time < 7) {
            incentive = 2000;
            tot_sal = salary + incentive;
            printf ("Your Salary is %.f", tot_sal);
        }
        else if (avg_time >= 7 && avg_time < 10) {
            incentive = 1500;
            tot_sal = salary + incentive;
            printf ("Your Salary is %.f", tot_sal);
        }
        else {
            incentive = 500;
            tot_sal = salary + incentive;
            printf ("Your Salary is %.f", tot_sal);
        }
    }
    return 0;
}
----------------------------------------

int main () {
    int num, incentive;
    int salary = 1500;
    float w_hr, avg_time, LOP, tot_sal;
    int tot_hr = 50;
    printf ("Enter the no.of projects allocated\n");
    scanf ("%d", & num);
    printf ("Enter the no.of working hours\n");
    scanf ("%f", & w_hr);
    if (num <= 10) {
        if (w_hr < tot_hr) {
            avg_time = w_hr / num;
            printf ("Average Time Taken (Hrs)\n%.1f", avg_time);
            if (avg_time < 5.0) {
                incentive = 5000;
                tot_sal = salary * num + incentive;
                printf ("\nYour Salary is Rs.%.f", tot_sal);
            }
            else if (avg_time >= 5.0 && avg_time < 7.0) {
                incentive = 2000;
                tot_sal = salary * num + incentive;
                printf ("\nYour Salary is Rs.%.f", tot_sal);
            }
            else if (avg_time >= 7.0 && avg_time < 10.0) {
                incentive = 1500;
                tot_sal = salary * num + incentive;
                printf ("\nYour Salary is Rs.%.f", tot_sal);
            }
            else {
                incentive = 500;
                tot_sal = salary * num + incentive;
                printf ("\nYour Salary is Rs.%.f", tot_sal);
            }
        }
        else if (w_hr > 50 && w_hr <= 55) {
            LOP = 0.5;
            tot_sal = num * (((100 - LOP) / 100) * salary);
            printf ("You have exceeded the timeline\n");
            printf ("\nYour Salary is Rs.%.f", tot_sal);
        }
        else if (w_hr > 55 && w_hr <= 60) {
            LOP = 1.0;
            tot_sal = (((100 - LOP) / 100) * salary);
            printf ("You have exceeded the timeline\n");
            printf ("\nYour Salary is Rs.%.2f", tot_sal);
        }
        else if (w_hr > 60 && w_hr <= 70) {
            LOP = 1.5;
            tot_sal = (((100 - LOP) / 100) * salary);
            printf ("You have exceeded the timeline\n");
            printf ("\nYour Salary is Rs.%.2f", tot_sal);
        }
        else
            printf ("\nInvalid input");
    }
    else {
        printf ("The maximum limit on project count has been specified as 10. Sorry!!");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44552574_44552873_12_23
44552574_44552973_1_10
Title: Code to remove all occurrences of a character from a string isn't working — but why? 
----------------------------------------

void squeeze (char *s, int c) {
    int i, j;
    for (i = j = 0; *(s + i) != '\0'; i++) {
        if (*(s + i) != c) {
            *(s + j) = *(s + i);
            j++;
        }
    }
    *(s + j) = '\0';
}
----------------------------------------

void squeeze (char *s, int c) {
    int i, j;
    for (i = j = 0; s[i] != '0'; i++) {
        if (s[i] != 'c') {
            s[j] = s[i];
            j++;
        }
    }
    s[j] = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44570213_45100974_3_16
44570213_45397174_1_16
Title: checking String's First letter for Special case and check the String with Space? 
----------------------------------------

int main () {
    char a [100], b [100], c [100], d [100];
    gets (a);
    gets (b);
    gets (c);
    gets (d);
    if (d[0] >= 0 && d[0] <= 64)
        printf ("no");
    else if (a[0] == d[0] || b[0] == d[0] || c[0] == d[0])
        printf ("yes");
    else
        printf ("no");
}
----------------------------------------

void main () {
    char a [256], b [256], c [256], d [256];
    fgets (a, 256, stdin);
    fgets (b, 256, stdin);
    fgets (c, 256, stdin);
    fgets (d, 256, stdin);
    if ((a[0] < 'A' || a[0] > 'Z') || (b[0] < 'A' || b[0] > 'Z') || (c[0] < 'A' || c[0] > 'Z') || (d[0] < 'A' || d[0] > 'Z'))
        printf ("\nno");
    else if (d[0] == a[0] || d[0] == b[0] || d[0] == c[0])
        printf ("\nyes");
    else
        printf ("\nno");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44570213_45100974_3_16
44570213_45522317_3_25
Title: checking String's First letter for Special case and check the String with Space? 
----------------------------------------

int main () {
    char a [100], b [100], c [100], d [100];
    gets (a);
    gets (b);
    gets (c);
    gets (d);
    if (d[0] >= 0 && d[0] <= 64)
        printf ("no");
    else if (a[0] == d[0] || b[0] == d[0] || c[0] == d[0])
        printf ("yes");
    else
        printf ("no");
}
----------------------------------------

int main () {
    char a [50], b [50], c [50], ch [50];
    fgets (a, 50, stdin);
    fgets (b, 50, stdin);
    fgets (c, 50, stdin);
    fgets (ch, 50, stdin);
    if ((a[0] >= 'A' && a[0] <= 'Z') && (b[0] >= 'A' && b[0] <= 'Z') && (c[0] >= 'A' && c[0] <= 'Z') && (ch[0] >= 'A' && ch[0] <= 'Z')) {
        if (a[0] == ch[0] || b[0] == ch[0] || c[0] == ch[0]) {
            printf ("yes");
        }
        else {
            printf ("no");
        }
    }
    else {
        printf ("no");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44570213_45397174_1_16
44570213_45522317_3_25
Title: checking String's First letter for Special case and check the String with Space? 
----------------------------------------

void main () {
    char a [256], b [256], c [256], d [256];
    fgets (a, 256, stdin);
    fgets (b, 256, stdin);
    fgets (c, 256, stdin);
    fgets (d, 256, stdin);
    if ((a[0] < 'A' || a[0] > 'Z') || (b[0] < 'A' || b[0] > 'Z') || (c[0] < 'A' || c[0] > 'Z') || (d[0] < 'A' || d[0] > 'Z'))
        printf ("\nno");
    else if (d[0] == a[0] || d[0] == b[0] || d[0] == c[0])
        printf ("\nyes");
    else
        printf ("\nno");
}
----------------------------------------

int main () {
    char a [50], b [50], c [50], ch [50];
    fgets (a, 50, stdin);
    fgets (b, 50, stdin);
    fgets (c, 50, stdin);
    fgets (ch, 50, stdin);
    if ((a[0] >= 'A' && a[0] <= 'Z') && (b[0] >= 'A' && b[0] <= 'Z') && (c[0] >= 'A' && c[0] <= 'Z') && (ch[0] >= 'A' && ch[0] <= 'Z')) {
        if (a[0] == ch[0] || b[0] == ch[0] || c[0] == ch[0]) {
            printf ("yes");
        }
        else {
            printf ("no");
        }
    }
    else {
        printf ("no");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44610273_44610362_3_20
44610273_44610763_7_29
Title: Strings of characters using pointers 
----------------------------------------

int points_converter (const char *input, char *output) {
    int count = 0;
    while (*input) {
        if (isalpha (*input)) {
            output[0] = '*';
            output[1] = '*';
            output += 2;
            count++;
        }
        else {
            *output = *input;
            output++;
        }
        input++;
    }
    *output = 0;
    return count;
}
----------------------------------------

bool points_converter (char str []) {
    bool f = false;
    char *temp = malloc (strlen (str) *2 + 1);
    char *s = str, *d = temp;
    if (!temp) {
        perror ("malloc:");
        return f;
    }
    for (; *s; s++) {
        if (isalpha ((unsigned char) *s)) {
            f = true;
            *d++ = '*';
            *d++ = '*';
        }
        else {
            *d++ = *s;
        }
    }
    *d = 0;
    strcpy (str, temp);
    free (temp);
    return f;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44611281_44611563_1_20
44611281_44611694_9_24
Title: c programming array element subtraction 
----------------------------------------

int difference (int *r, const int *a, int na, const int *b, int nb) {
    int nr, found;
    memcpy (r, a, na * sizeof (int));
    nr = na;
    for (i = 0; i < nb; ++i) {
        found = find (b[i], r, nr);
        if (found >= 0) {
            nr = remove (found, r, nr);
        }
    }
    return nr;
}
----------------------------------------

size_t difference (void *dest, size_t dest_size, void const *x, size_t x_size, void const *y, size_t y_size, size_t size, int (*compare) (void const *, void const *)) {
    typedef unsigned char item [size];
    item const *a = x, *b = y;
    item *d = dest;
    size_t cursor = 0, d_size = 0;
    for (size_t x = 0; x < x_size; x++) {
        item *ptr = bsearch (a +x, b +cursor, y_size -cursor, size, compare);
        if (ptr) {
            cursor = ptr - b;
        }
        else {
            memcpy (d [d_size ++], a [x], sizeof (item));
        }
    }
    return d_size;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44614118_44614453_6_29
44614118_44614503_6_33
Title: "While reading two array in c through scanf the second one somehow modify the first" 
----------------------------------------

int main (void) {
    char a [N];
    char b [K];
    int i = 0;
    printf ("first word\n\n\n");
    scanf ("%6s", a);
    for (i = 0; a[i] != '\0' && i < N; i++) {
        printf ("%c", a [i]);
    }
    putchar ('\n');
    printf ("second word \n\n\n");
    scanf ("%2s", b);
    for (i = 0; b[i] != '\0' && i < K; i++) {
        printf ("%c", b [i]);
    }
    putchar ('\n');
    return 0;
}
----------------------------------------

int main (void) {
    char a [N], b [K];
    int i = 0;
    printf ("enter first word: ");
    if (scanf ("%5s", a) != 1) {
        fprintf (stderr, "error: invalid input - a.\n");
        return 1;
    }
    for (i = 0; a[i] && i < N; i++)
        printf ("%c", a[i]);
    putchar ('\n');
    printf ("enter second word: ");
    if (scanf ("%1s", b) != 1) {
        fprintf (stderr, "error: invalid input - b.\n");
        return 1;
    }
    for (i = 0; b[i] && i < N; i++)
        printf ("%c", b[i]);
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44619093_44619630_1_19
44619093_44619753_31_61
Title: How to find all occurrences and all position of a substring in a string? 
----------------------------------------

int main () {
    const char *string = "abaaab";
    const char *toSearch = "aa";
    int nrOfOccurences = 0;
    printf ("searching for occurences of '%s' in string '%s':\n", string, toSearch);
    const char *pos = string;
    while (pos) {
        pos = strstr (pos, toSearch);
        if (pos) {
            printf ("found occurence at position %td\n", pos - string);
            nrOfOccurences++;
            pos++;
        }
    }
    nrOfOccurences = findRecursive (string, toSearch, 0, 0);
    printf ("nr of occurences: %d\n", nrOfOccurences);
    return 0;
}
----------------------------------------

int main (void) {
    char *str, *sub;
    size_t len1, len2, i, count = 0;
    printf ("Inserisci stringa principale :\n");
    str = my_getline (stdin);
    printf ("Immetti sottostringa da cercare :\n");
    sub = my_getline (stdin);
    if (str && sub) {
        len1 = strlen (str);
        len2 = strlen (sub);
        for (i = 0; i + len2 <= len1; i++) {
            if (!memcmp (str +i, sub, len2)) {
                count++;
                printf ("Sottostringa trovata all'indice : %zu\n", i);
            }
        }
        if (count == 0) {
            printf ("Sottostringa non trovata\n");
        }
    }
    free (str);
    free (sub);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44642911_44643000_8_30
44642911_44661375_12_56
Title: Executable for the writer file with mkfifo halts 
----------------------------------------

int main () {
    int fd;
    char *myfifo = "./myfifo";
    int PID = fork ();
    if (PID == 0) {
        execl ("./reader.o", "reader", (char *) NULL);
    }
    mkfifo (myfifo, 0777);
    fd = open (myfifo, O_WRONLY);
    write (fd, "Rock and roll baby\0", sizeof ("Rock and roll baby"));
    close (fd);
    unlink (myfifo);
    return 0;
}
----------------------------------------

int main (void) {
    char *myfifo = "./myfifo";
    if (mkfifo (myfifo, 0777) != 0) {
        write (STDERR_FILENO, "Failed to create FIFO\n", sizeof ("Failed to create FIFO\n") - 1);
    }
    int PID = fork ();
    if (PID == 0) {
        execl (READER, "reader", (char *) NULL);
        write (STDERR_FILENO, "Failed to execute reader\n", sizeof ("Failed to execute reader\n") - 1);
        exit (EXIT_FAILURE);
    }
    if (PID < 0) {
        write (STDERR_FILENO, "Failed to fork\n", sizeof ("Failed to fork\n") - 1);
        exit (EXIT_FAILURE);
    }
    int fd = open (myfifo, O_WRONLY);
    if (fd < 0) {
        write (STDERR_FILENO, "Failed to open FIFO for writing\n", sizeof ("Failed to open FIFO for writing\n") - 1);
        unlink (myfifo);
        exit (EXIT_FAILURE);
    }
    write (fd, "Rock and roll baby", sizeof ("Rock and roll baby"));
    close (fd);
    unlink (myfifo);
    int corpse;
    int status;
    while ((corpse = wait (&status)) > 0)
        printf ("Child %d exited with status 0x%.4X\n", corpse, status);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44648270_44648459_4_36
44648270_44649259_4_30
Title: "Tried to create sorting program but isn't working as expected" 
----------------------------------------

int main () {
    int arr [20], i, j, n, temp;
    printf ("Enter number of elements  : ");
    scanf ("%d", & n);
    printf ("\nEnter the elements of the array : ");
    for (i = 0; i < n; i++)
        scanf ("%d", &arr[i]);
    for (i = 0; i < n; i++) {
        for (j = 0; j < arr[i]; j++) {
            assert (j < n);
            assert (i + 1 < n);
            if (arr[i + 1] < arr[i]) {
                temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
            }
        }
    }
    printf ("\nThe sorted list is : \n");
    for (i = 0; i < n; i++)
        printf ("\n arr[%d] : %d", i, arr[i]);
    return 0;
}
----------------------------------------

int main () {
    int arr [20], i, j, n, temp;
    printf ("Enter number of elements  : ");
    scanf ("%d", & n);
    printf ("\nEnter the elements of the array : ");
    for (i = 0; i < n; i++)
        scanf ("%d", &arr[i]);
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++)
            if (arr[i] < arr[j]) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
    }
    printf ("\nThe sorted list is : \n");
    for (i = 0; i < n; i++)
        printf ("\n arr[%d] : %d", i, arr[i]);
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44692811_44693331_2_22
44692811_44693905_2_26
Title: Why it is this program not finding pairs in an array that sum to a given value? 
----------------------------------------

int main () {
    const int rows = 5;
    const int cols = 4;
    int sum = 11;
    int i, j, i1, j1;
    int a [rows] [cols] = {{-1, 2, 3, 4}, {5, 3, -2, 1}, {6, 7, 2, -3}, {2, 9, 1, 4}, {2, 1, -2, 0}};
    for (i = 0; i < rows; i++)
        for (j = 0; j < cols; j++)
            for (i1 = i + 1; i1 < rows; i1++)
                for (j1 = 0; j1 < cols; j1++)
                    if (a[i][j] + a[i1][j1] == sum)
                        printf ("[%d %d](%d); [%d %d](%d)\n", i, j, a[i][j], i1, j1, a[i1][j1]);
}
----------------------------------------

int main () {
    int a [5] [5] = {{-1, 2, 3, 4}, {5, 3, -2, 1}, {6, 7, 2, -3}, {2, 9, 1, 4}, {2, 1, -2, 0}};
    int sum = 11, i, j, k, l;
    for (i = 0; i < 5; i++) {
        for (j = i + 1; j < 5; j++) {
            for (k = 0; k < 5; k++) {
                for (l = 0; l < 5; l++) {
                    if (a[i][k] + a[j][l] == sum)
                        printf ("a[%d][%d] = %d\ta[%d][%d] = %d\n", i, k, a[i][k], j, l, a[j][l]);
                }
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44701222_44701861_4_29
44701222_44702219_1_32
Title: can someone explain why the modulo function in this code isn't working? 
----------------------------------------

int main (void) {
    float amount;
    int cents, quarters, dimes, nickels, pennies, coins;
    do {
        printf ("How much money are you owed?");
        amount = get_float ();
    }
    while (amount <= 0.0);
    cents = (int) (amount * 100 + 0.5);
    quarters = cents / 25;
    cents %= 25;
    dimes = cents / 10;
    cents %= 10;
    nickels = cents / 5;
    cents %= 5;
    pennies = cents;
    coins = quarters + dimes + nickels + pennies;
    printf ("%d coins: %d quarter, %d dimes, %d nickels, %d pennies\n", coins, quarters, dimes, nickels, pennies);
    return 0;
}
----------------------------------------

int main (void) {
    float dollars;
    int cents;
    int coins;
    do {
        printf ("O hai! How much change is owed?");
        dollars = get_float ();
    }
    while (dollars < 0);
    cents = roundf (dollars *100);
    coins = cents / 25;
    cents = cents % 25;
    if (cents < 25) {
        coins += (cents / 10);
        cents = cents % 10;
    }
    if (cents < 10) {
        coins += (cents / 5);
        cents = cents % 5;
    }
    if (cents < 5) {
        coins += (cents / 1);
        cents = cents % 1;
    }
    printf ("%d\n", coins);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44740888_44741059_4_38
44740888_44741857_3_40
Title: Cannot Copy a Text File through fwrite and fread in C 
----------------------------------------

int main (void) {
    FILE *f, *fp;
    char buff [512];
    size_t bytes;
    fp = fopen ("File.txt", "rb");
    if (fp == NULL) {
        fprintf (stderr, "Cannot open source file!\n");
        exit (1);
    }
    f = fopen ("append.txt", "ab+");
    if (f == NULL) {
        fprintf (stderr, "Cannot open target file!\n");
        fclose (fp);
        exit (1);
    }
    while ((bytes = fread (buff, 1, sizeof buff, fp)) != 0) {
        if (fwrite (buff, 1, bytes, 1, f) != bytes) {
            fprintf (stderr, "Error writing to the target file\n");
            break;
        }
        printf ("Appending...\n\n");
    }
    rewind (f);
    while ((bytes = fread (buff, 1, sizeof buff, f)) != 0) {
        printf ("%.*s", (int) bytes, buff);
    }
    fclose (fp);
    fclose (f);
    return 0;
}
----------------------------------------

int main (void) {
    const char src_file [] = "File.txt";
    FILE *fp = fopen (src_file, "rb");
    if (fp == NULL) {
        fprintf (stderr, "Cannot Open Source File '%s'!\n", src_file);
        return (1);
    }
    const char tgt_file [] = "append.txt";
    FILE *f = fopen (tgt_file, "ab+");
    if (f == NULL) {
        fprintf (stderr, "Cannot Open Target File '%s'!\n", tgt_file);
        fclose (fp);
        return (1);
    }
    char buff [512];
    int bytes;
    while ((bytes = fread (buff, sizeof (char), sizeof (buff), fp)) > 0) {
        fwrite (buff, sizeof (char), bytes, f);
        printf ("Appending...\n\n");
    }
    rewind (f);
    while ((bytes = fread (buff, sizeof (char), sizeof (buff), f)) > 0)
        printf ("%.*s", bytes, buff);
    fclose (fp);
    fclose (f);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44743387_44743547_12_35
44743387_44745565_4_20
Title: Printing the all possible paths of the n x n matrix in C 
----------------------------------------

void printPath (int x, int y, char path [], int n) {
    char buff [12];
    sprintf (buff, "( %d , %d )", x, y);
    strcat (path, buff);
    if (x == n - 1 && y == n - 1) {
        printf ("%s", path);
        printf ("\n");
    }
    else if (x == n - 1)
        printPath (x, y +1, path, n);
    else if (y == n - 1)
        printPath (x +1, y, path, n);
    else {
        printPath (x + 1, y, path, n);
        printPath (x, y + 1, path, n);
    }
    int len1 = strlen (path);
    int len2 = strlen (buff);
    path[len1 - len2] = '\0';
}
----------------------------------------

static void printPath (int x, int y, int n, char path [], size_t size, size_t pos) {
    pos += snprintf (path +pos, size -pos, "( %d , %d )", x, y);
    if (pos >= size) {
        fprintf (stderr, "path is too small\n");
        exit (1);
    }
    if (x == n - 1 && y == n - 1) {
        printf ("%s\n", path);
    }
    else {
        if (x < n - 1)
            printPath (x +1, y, n, path, size, pos);
        if (y < n - 1)
            printPath (x, y +1, n, path, size, pos);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44745734_44745841_29_40
44745734_44746628_4_16
Title: Converting words from camelCase to snake_case in C 
----------------------------------------

int main (void) {
    char inbuf [512];
    char outbuf [1024];
    while (fgets (inbuf, 512, stdin)) {
        toSnakeCase (outbuf, 1024, inbuf);
        fputs (outbuf, stdout);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int c;
    while ((c = getchar ()) != EOF) {
        if (isupper (c)) {
            putchar ('_');
            putchar (tolower (c));
        }
        else {
            putchar (c);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44745734_44745841_29_40
44745734_44746660_4_27
Title: Converting words from camelCase to snake_case in C 
----------------------------------------

int main (void) {
    char inbuf [512];
    char outbuf [1024];
    while (fgets (inbuf, 512, stdin)) {
        toSnakeCase (outbuf, 1024, inbuf);
        fputs (outbuf, stdout);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char input [100];
    const size_t N = sizeof (input) / sizeof (*input);
    int c;
    size_t i = 0;
    while (i + 1 < N && (c = getchar ()) != EOF && c != '\n') {
        if (isupper (c)) {
            input[i++] = '_';
            c = tolower (c);
        }
        if (i + 1 != N)
            input[i++] = c;
    }
    input[i] = '\0';
    puts (input);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44745734_44746628_4_16
44745734_44746660_4_27
Title: Converting words from camelCase to snake_case in C 
----------------------------------------

int main (void) {
    int c;
    while ((c = getchar ()) != EOF) {
        if (isupper (c)) {
            putchar ('_');
            putchar (tolower (c));
        }
        else {
            putchar (c);
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char input [100];
    const size_t N = sizeof (input) / sizeof (*input);
    int c;
    size_t i = 0;
    while (i + 1 < N && (c = getchar ()) != EOF && c != '\n') {
        if (isupper (c)) {
            input[i++] = '_';
            c = tolower (c);
        }
        if (i + 1 != N)
            input[i++] = c;
    }
    input[i] = '\0';
    puts (input);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44764707_1_18
44764678_44765193_2_17
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n, i, j;
    printf ("Ingrese la cantidad de filas:\n");
    scanf ("%d", & n);
    for (i = n; i >= 0; i--) {
        for (j = 0; j < i; j++) {
            printf ("*");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n, i, j;
    printf ("Ingrese la cantidad de filas:\n");
    scanf ("%d", & n);
    for (i = n; i > 0; i--) {
        for (j = n - i; j > 0; j--) {
            printf (" ");
        }
        for (j = i; j > 0; j--) {
            printf ("*");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44764707_1_18
44764678_44765738_4_20
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n, i, j;
    printf ("Ingrese la cantidad de filas:\n");
    scanf ("%d", & n);
    for (i = n; i >= 0; i--) {
        for (j = 0; j < i; j++) {
            printf ("*");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n;
    printf ("Enter number of stars: ");
    fflush (stdout);
    if (scanf ("%d", &n) == 1 && n > 0 && n < 1000) {
        putchar ('\n');
        char stars [n];
        char space [n];
        memset (stars, '*', n);
        memset (space, ' ', n);
        for (int i = 0; i < n; i++)
            printf ("%.*s%.*s\n", i, space, n -i, stars);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44764707_1_18
44764678_44766759_5_17
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n, i, j;
    printf ("Ingrese la cantidad de filas:\n");
    scanf ("%d", & n);
    for (i = n; i >= 0; i--) {
        for (j = 0; j < i; j++) {
            printf ("*");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int n = argc > 1 ? atoi (argv[1]) : 5;
    char stars [n + 1];
    memset (stars, '*', n);
    stars[n] = 0;
    for (int i = 0; i < n; i++)
        printf ("%*s\n", n, stars +i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44764707_1_18
44764678_44766879_4_13
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n, i, j;
    printf ("Ingrese la cantidad de filas:\n");
    scanf ("%d", & n);
    for (i = n; i >= 0; i--) {
        for (j = 0; j < i; j++) {
            printf ("*");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n, chk;
    chk = scanf ("%d", &n);
    if ((chk != 1) || (n < 1) || (n > 32)) {
        fprintf (stderr, "Invalid n.\n");
        exit (EXIT_FAILURE);
    }
    for (int i = n; i > 0; i--)
        printf ("%*.*s%*.*s\n", n -i, n -i, " ", i, i, "************************");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44765193_2_17
44764678_44765738_4_20
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n, i, j;
    printf ("Ingrese la cantidad de filas:\n");
    scanf ("%d", & n);
    for (i = n; i > 0; i--) {
        for (j = n - i; j > 0; j--) {
            printf (" ");
        }
        for (j = i; j > 0; j--) {
            printf ("*");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n;
    printf ("Enter number of stars: ");
    fflush (stdout);
    if (scanf ("%d", &n) == 1 && n > 0 && n < 1000) {
        putchar ('\n');
        char stars [n];
        char space [n];
        memset (stars, '*', n);
        memset (space, ' ', n);
        for (int i = 0; i < n; i++)
            printf ("%.*s%.*s\n", i, space, n -i, stars);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44765193_2_17
44764678_44766759_5_17
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n, i, j;
    printf ("Ingrese la cantidad de filas:\n");
    scanf ("%d", & n);
    for (i = n; i > 0; i--) {
        for (j = n - i; j > 0; j--) {
            printf (" ");
        }
        for (j = i; j > 0; j--) {
            printf ("*");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int n = argc > 1 ? atoi (argv[1]) : 5;
    char stars [n + 1];
    memset (stars, '*', n);
    stars[n] = 0;
    for (int i = 0; i < n; i++)
        printf ("%*s\n", n, stars +i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44765193_2_17
44764678_44766879_4_13
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n, i, j;
    printf ("Ingrese la cantidad de filas:\n");
    scanf ("%d", & n);
    for (i = n; i > 0; i--) {
        for (j = n - i; j > 0; j--) {
            printf (" ");
        }
        for (j = i; j > 0; j--) {
            printf ("*");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n, chk;
    chk = scanf ("%d", &n);
    if ((chk != 1) || (n < 1) || (n > 32)) {
        fprintf (stderr, "Invalid n.\n");
        exit (EXIT_FAILURE);
    }
    for (int i = n; i > 0; i--)
        printf ("%*.*s%*.*s\n", n -i, n -i, " ", i, i, "************************");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44765738_4_20
44764678_44766759_5_17
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n;
    printf ("Enter number of stars: ");
    fflush (stdout);
    if (scanf ("%d", &n) == 1 && n > 0 && n < 1000) {
        putchar ('\n');
        char stars [n];
        char space [n];
        memset (stars, '*', n);
        memset (space, ' ', n);
        for (int i = 0; i < n; i++)
            printf ("%.*s%.*s\n", i, space, n -i, stars);
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int n = argc > 1 ? atoi (argv[1]) : 5;
    char stars [n + 1];
    memset (stars, '*', n);
    stars[n] = 0;
    for (int i = 0; i < n; i++)
        printf ("%*s\n", n, stars +i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44765738_4_20
44764678_44766879_4_13
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (void) {
    int n;
    printf ("Enter number of stars: ");
    fflush (stdout);
    if (scanf ("%d", &n) == 1 && n > 0 && n < 1000) {
        putchar ('\n');
        char stars [n];
        char space [n];
        memset (stars, '*', n);
        memset (space, ' ', n);
        for (int i = 0; i < n; i++)
            printf ("%.*s%.*s\n", i, space, n -i, stars);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n, chk;
    chk = scanf ("%d", &n);
    if ((chk != 1) || (n < 1) || (n > 32)) {
        fprintf (stderr, "Invalid n.\n");
        exit (EXIT_FAILURE);
    }
    for (int i = n; i > 0; i--)
        printf ("%*.*s%*.*s\n", n -i, n -i, " ", i, i, "************************");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44764678_44766759_5_17
44764678_44766879_4_13
Title: how to arrange asterisks in triangle 
----------------------------------------

int main (int argc, char **argv) {
    int n = argc > 1 ? atoi (argv[1]) : 5;
    char stars [n + 1];
    memset (stars, '*', n);
    stars[n] = 0;
    for (int i = 0; i < n; i++)
        printf ("%*s\n", n, stars +i);
    return 0;
}
----------------------------------------

int main (void) {
    int n, chk;
    chk = scanf ("%d", &n);
    if ((chk != 1) || (n < 1) || (n > 32)) {
        fprintf (stderr, "Invalid n.\n");
        exit (EXIT_FAILURE);
    }
    for (int i = n; i > 0; i--)
        printf ("%*.*s%*.*s\n", n -i, n -i, " ", i, i, "************************");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44768107_44768508_1_19
44768107_44770936_4_25
Title: C - How to Obtain a Time in C Using a Struct 
----------------------------------------

int main (void) {
    Date date;
    char buff [100];
    time_t now = time (0);
    struct tm now_t = *localtime (&now);
    strftime (buff, 100, "%d-%m-%Y %H:%M:%S", & now_t);
    date.year = now_t.tm_year + 1900;
    date.month = now_t.tm_mon + 1;
    date.day = now_t.tm_mday;
    date.hour.hour = now_t.tm_hour;
    date.hour.minute = now_t.tm_min;
    date.hour.second = now_t.tm_sec;
    return 0;
}
----------------------------------------

int main (void) {
    time_t seconds;
    struct tm date;
    struct tm *resultp;
    char buffer [80];
    const char *format = "%m-%d-%Y %H:%M:%S";
    setenv ("TZ", "PST8PDT", 1);
    tzset ();
    seconds = time (NULL);
    resultp = localtime_r (&seconds, &date);
    if (resultp != NULL) {
        strftime (buffer, 80, format, resultp);
        printf ("Current local date and time: %s", buffer);
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44768659_44768859_16_36
44768659_44768928_9_21
Title: Concatenate two arrays using pointers (C code provided) 
----------------------------------------

int main (void) {
    int array_a [N1] = {2, 4, 6};
    int array_b [N2] = {1, 3, 5};
    int array_c [N3];
    int *p_a = array_a;
    int *p_b = array_b;
    int *p_c = array_c;
    int *result = concat (p_c, p_b, N2, p_a, N1);
    for (const int *p = p_c; p != result; ++p) {
        printf ("%d ", * p);
    }
    putchar ('\n');
    return 0;
}
----------------------------------------

int main () {
    int i;
    const int array_a [3] = {2, 4, 6}, array_b [3] = {1, 3, 5};
    int array_c [6];
    concat (array_a, array_b, array_c, 3);
    for (i = 0; i < 6; i++) {
        printf ("array_c[%d]=%d\n", i, array_c [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44803964_44804444_1_27
44803964_44808409_3_18
Title: Generic function for multiple arrays of same datatypes in c? 
----------------------------------------

void func (int array_number) {
    int *arr;
    int len, i;
    switch (array_number) {
    case 1 :
        arr = arr1;
        len = sizeof (arr1) / sizeof (arr1[0]);
        break;
    case 2 :
        arr = arr2;
        len = sizeof (arr2) / sizeof (arr2[0]);
        break;
    case 3 :
        arr = arr3;
        len = sizeof (arr3) / sizeof (arr3[0]);
        break;
    default :
        return;
    }
    for (int i = 0; i < len; i++) {
        arr[i] = i;
    }
}
----------------------------------------

void func (int array_index) {
    const struct xx {
        int *ptr;
        size_t length;
    } arrays [] = {{arr1, sizeof arr1 / sizeof arr1[0]}, {arr2, sizeof arr2 / sizeof arr2[0]}, {arr3, sizeof arr3 / sizeof arr3[0]}};
    const size_t n = sizeof arrays / sizeof arrays[0];
    if (array_index > 0 && array_index <= n) {
        array_index--;
        func_helper (arrays [array_index].ptr, arrays [array_index].length);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44807302_44814430_34_51
44807302_52905687_38_78
Title: Create C timer in macOS 
----------------------------------------

int main (int argc, char const *argv []) {
    pthread_t t1;
    Timer args;
    args.fn = &hello_world;
    args.timer_delegate = should_kill_thread;
    args.seconds = 1;
    int id = pthread_create (&t1, NULL, timer_run, &args);
    if (id) {
        printf ("ERROR; return code from pthread_create() is %d\n", id);
        exit (EXIT_FAILURE);
    }
    pthread_join (t1, NULL);
    printf ("%s\n", "DONE");
    return 0;
}
----------------------------------------

int main (int argc, const char *argv []) {
    signal (SIGINT, & sigtrap);
    queue = dispatch_queue_create ("timerQueue", 0);
    timer1 = dispatch_source_create (DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    timer2 = dispatch_source_create (DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
    dispatch_source_set_event_handler (timer1, ^ {vector1 (timer1);});
    dispatch_source_set_event_handler (timer2, ^ {vector2 (timer2);});
    dispatch_source_set_cancel_handler (timer1, ^ {dispatch_release (timer1); dispatch_release (queue); printf ("end\n"); exit (0);});
    dispatch_source_set_cancel_handler (timer2, ^ {dispatch_release (timer2); dispatch_release (queue); printf ("end\n"); exit (0);});
    dispatch_time_t start = dispatch_time (DISPATCH_TIME_NOW, NSEC_PER_SEC);
    dispatch_source_set_timer (timer1, start, NSEC_PER_SEC / 5, 0);
    dispatch_source_set_timer (timer2, start, NSEC_PER_SEC / 2, 0);
    printf ("start\n");
    dispatch_resume (timer1);
    dispatch_resume (timer2);
    while (1) {
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44812443_44812916_9_32
44812443_44813672_5_25
Title: C change words beginning with lowercase to capital in text file 
----------------------------------------

int main (void) {
    FILE *fp = fopen ("test.txt", "r+");
    char buffer [MAX] [LEN];
    if (fp == NULL)
        exit (EXIT_FAILURE);
    int count = 0;
    while (count < MAX && fgets (buffer[count], LEN, fp)) {
        if (buffer [count] [strlen (buffer [count]) - 1] == '\n') buffer [count] [strl$ if (islower (buffer [count] [0])) buffer [count] [0] = (char) toupper (buffer [count] [0]);
        count++;
    }
    fseek (fp, 0, SEEK_SET);
    for (int i = 0; i < count; ++i)
        fprintf (fp, "%s\n", buffer[i]);
    fclose (fp);
    return 0;
}
----------------------------------------

int main () {
    FILE *fp;
    int zeichen;
    fp = fopen ("test.txt", "r+");
    if (fp == NULL) {
        printf ("Die Datei konnte nicht geoeffnet werden.\n");
        exit (EXIT_FAILURE);
    }
    while ((zeichen = fgetc (fp)) != EOF) {
        if (zeichen == ' ') {
            zeichen = fgetc (fp);
            fseek (fp, - 1, SEEK_CUR);
            fputc (toupper (zeichen), fp);
        }
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44818181_44818329_19_57
44818181_44818665_1_31
Title: can anyone explain me how does this function work? 
----------------------------------------

char *my_getline (FILE *stream) {
    char *buf = malloc (GETLINE_CHUNK);
    if (!buf)
        return 0;
    *buf = 0;
    size_t pos = 0;
    while (fgets (buf +pos, GETLINE_CHUNK, stream)) {
        char *nlPos = strchr (buf, '\n');
        if (nlPos) {
            *nlPos = 0;
            xrealloc (& buf, nlPos - buf + 1);
            return buf;
        }
        pos = strlen (buf);
        xrealloc (& buf, pos + GETLINE_CHUNK);
        if (!buf)
            return 0;
    }
    if (*buf == 0) {
        free (buf);
        buf = 0;
    }
    return buf;
}
----------------------------------------

char *my_getline (FILE *stream) {
    char *line = NULL;
    size_t pos = 0;
    int c;
    while ((c = getc (stream)) != EOF) {
        char *newp = realloc (line, pos +2);
        if (newp == NULL) {
            free (line);
            return NULL;
        }
        line = newp;
        if (c == '\n')
            break;
        line[pos++] = (char) c;
    }
    if (line) {
        line[pos] = '\0';
    }
    return line;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44823539_44823683_5_30
44823539_44823737_1_26
Title: Algorithm for removing chars from string and dynamically resizing it upon removal 
----------------------------------------

char *remove_quotations (char *str) {
    size_t len = strlen (str);
    for (size_t i = 0; i < len; ++i) {
        if (str[i] == '\'') {
            memmove (str + i, str + i + 1, len - i);
            --len;
        }
    }
    char *tmp = realloc (str, len +1);
    if (!tmp) {
        free (str);
        return 0;
    }
    return tmp;
}
----------------------------------------

char *remove_quotations (char *str) {
    int len = strlen (str);
    char *str_temp;
    for (int i = 0; i < len; i++) {
        if (str[i] == '\'') {
            for (int j = i; j < len; j++) {
                str[j] = str[j + 1];
            }
            len--;
        }
    }
    str_temp = realloc (str, len +1);
    if (!str_temp) {
        printf ("Memory allocation error!\n");
        free (str);
        return NULL;
    }
    return str_tmp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44845270_44845715_4_39
44845270_44845743_15_49
Title: How do I add another case when there is no prime number between a range(x != y) 
----------------------------------------

void main () {
    int num, x, y, i, count;
    int primecounter = 0;
    scanf ("%d\n%d", & x, & y);
    if (x < 0 || y < 0) {
        printf ("\nNegative integers cannot be prime\n");
    }
    else {
        for (num = x; num <= y; num++) {
            count = 0;
            for (i = 2; i <= num / 2; i++) {
                if (num % i == 0) {
                    count++;
                    break;
                }
            }
            if (count == 0 && num != 1) {
                printf ("\n%d ", num);
                primecounter++;
            }
        }
        if (primecounter == 0) {
            printf ("There are no prime numbers in the range %d to %d\n", x, y);
        }
    }
}
----------------------------------------

int main () {
    int num, x, y, i, count;
    scanf ("%d\n%d", & x, & y);
    if (x > y) {
        int temp = x;
        x = y;
        y = temp;
    }
    if (x < 0 || y < 0) {
        printf ("Negative integers cannot be prime\n");
    }
    else {
        count = 0;
        for (num = x; num <= y; num++) {
            if (checkPrime (num)) {
                count++;
                printf ("%d ", num);
            }
        }
        if (count == 0)
            printf ("There are no prime numbers in the range %d to %d", x, y);
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44846333_44846449_1_18
44846333_44850798_7_74
Title: Partitioning inputs in scanf 
----------------------------------------

int main () {
    char str [10000];
    float number;
    scanf ("%s", str);
    char *at_pos = strrchr (str, '@');
    if (at_pos) {
        number = atof (at_pos +1);
        printf ("%s %f\n", str, number);
    }
    else {
    }
}
----------------------------------------

int main (void) {
    char str [10000];
    char c;
    float f;
    float power = 10;
    int counter = 0;
    c = getchar ();
    str[counter] = c;
    counter++;
    c = getchar ();
    while (c != '@') {
        if (c == 10) {
            printf ("I can't find the '@' there. =)\n\n");
            return 0;
        }
        str[counter++] = c;
        c = getchar ();
    }
    c = getchar ();
    f = c - '0';
    c = getchar ();
    while (c != 10 && c != '.') {
        f = f * 10 + (c - '0');
        c = getchar ();
    }
    c = getchar ();
    f += (c - '0') / power;
    c = getchar ();
    power *= 10;
    while (c != 10) {
        f += (c - '0') / power;
        power *= 10;
        c = getchar ();
    }
    printf ("%s @ %f", str, f);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44846333_44846449_1_18
44846333_44850798_86_139
Title: Partitioning inputs in scanf 
----------------------------------------

int main () {
    char str [10000];
    float number;
    scanf ("%s", str);
    char *at_pos = strrchr (str, '@');
    if (at_pos) {
        number = atof (at_pos +1);
        printf ("%s %f\n", str, number);
    }
    else {
    }
}
----------------------------------------

int main (void) {
    char str [1000];
    char c;
    float f;
    float power = 10;
    int counter = 0;
    c = getchar ();
    str[counter] = c;
    counter++;
    c = getchar ();
    while (c != '@') {
        if (c == 10) {
            printf ("I can't find the '@' there. =)\n\n");
            return 0;
        }
        str[counter++] = c;
        c = getchar ();
    }
    c = getchar ();
    f = c - '0';
    c = getchar ();
    while (c != 10 && c != '.') {
        f = f * 10 + (c - '0');
        c = getchar ();
    }
    c = getchar ();
    f += (c - '0') / power;
    c = getchar ();
    power *= 10;
    while (c != 10) {
        f += (c - '0') / power;
        power *= 10;
        c = getchar ();
    }
    printf ("%s @ %f", str, f);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44853765_44854067_15_38
44853765_44867173_11_32
Title: reading string twice? What's the prob? C 
----------------------------------------

int add (char *str1, char *str2) {
    if (str1 == NULL)
        str1 = "";
    if (str2 == NULL)
        str2 = "";
    int counter = 0;
    int i;
    int len1 = strlen (str1);
    int len2 = strlen (str2);
    for (i = 0; i < len1; ++i)
        if (str1[i] == 'e')
            counter++;
    for (i = 0; i < len2; ++i)
        if (str2[i] == 'e')
            counter++;
    return counter;
}
----------------------------------------

int add (char *str1, char *str2) {
    int res = 0;
    for (size_t index = 0; index < strlen (str1); index++) {
        if (str1[index] == 'e') {
            res++;
        }
    }
    for (size_t index = 0; index < strlen (str2); index++) {
        if (str2[index] == 'e') {
            res++;
        }
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44853765_44854067_40_57
44853765_44867173_45_90
Title: reading string twice? What's the prob? C 
----------------------------------------

int main (void) {
    char line1 [1024], line2 [1024];
    fgets (line1, sizeof line1, stdin);
    fgets (line2, sizeof line2, stdin);
    cut_nl (line1);
    cut_nl (line2);
    printf ("sumOf 'e': %d\n", add (line1, line2));
    return 0;
}
----------------------------------------

int main (void) {
    char c = 'A';
    int opt = 0;
    char s1 [20] = "";
    char s2 [20] = "";
    while (c != 27) {
        printf ("" "1. Set Strings\n" "2. calc\n" "3. quit\n");
        if (1 != scanf ("%d", &opt)) {
            perror ("scanf for menu option failed");
            exit (EXIT_FAILURE);
        }
        switch (opt) {
        case 1 :
            printf ("Enter first string, max 19 chars: ");
            fill (s1);
            printf ("Enter second string, max 19 chars: ");
            fill (s2);
            break;
        case 2 :
            printf ("sumOf 'e'= %d\n", add (s1, s2));
            break;
        case 3 :
            c = 27;
            break;
        default :
            printf (" %d is an invalid selection\n", opt);
            break;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44856193_44857808_1_18
44856193_44864857_45_59
Title: Redirecting a pointer by reference in a Binary-Search-Tree 
----------------------------------------

struct TElem *bst_Search (struct bst *T, TKey c, struct Node **posins) {
    struct Node *q = T->root;
    posins = &(T->root);
    while (q)
        if (q->key == c)
            return q->elem;
        else if (c < q->key) {
            q = q->left;
            posins = &q;
        }
        else {
            q = q->right;
            posins = q;
        }
    return NULL;
}
----------------------------------------

struct TElem *bst_Search (struct bst *T, TKey c, struct Node ***posins) {
    *posins = &T->root;
    while (**posins) {
        int cmp = TKeyCmp (c, (**posins)->key);
        if (cmp == 0)
            return (**posins)->elem;
        else if (cmp < 0)
            *posins = &(**posins)->left;
        else
            *posins = &(**posins)->right;
    }
    return NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44857324_44857485_5_25
44857324_44857809_5_20
Title: How do I deal with multiple spaces before or in between the words in CS50's initials (more comfortable)? 
----------------------------------------

int main (void) {
    char line [1024];
    fgets (line, sizeof line, stdin);
    char *token, *src = line;
    while (token = strtok (src, " \t")) {
        src = NULL;
        printf ("%c", toupper (* token));
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    char *p = NULL;
    printf ("Name: ");
    string s = get_string ();
    for (p = s; *p; p++)
        if (isalpha (*p) && (p == s || (*(p - 1) == ' ')))
            putchar (toupper (*p));
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44857324_44857485_5_25
44857324_44858419_6_26
Title: How do I deal with multiple spaces before or in between the words in CS50's initials (more comfortable)? 
----------------------------------------

int main (void) {
    char line [1024];
    fgets (line, sizeof line, stdin);
    char *token, *src = line;
    while (token = strtok (src, " \t")) {
        src = NULL;
        printf ("%c", toupper (* token));
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    int wasSpace = 1;
    printf ("Name: ");
    string s = get_string ();
    for (int i = 0; i < strlen (s); i++) {
        if (wasSpace && s[i] != ' ') {
            wasSpace = 0;
            printf ("%c", toupper (s [i]));
        }
        else if (s[i] == ' ') {
            wasSpace = 1;
        }
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44857324_44857809_5_20
44857324_44858419_6_26
Title: How do I deal with multiple spaces before or in between the words in CS50's initials (more comfortable)? 
----------------------------------------

int main (void) {
    char *p = NULL;
    printf ("Name: ");
    string s = get_string ();
    for (p = s; *p; p++)
        if (isalpha (*p) && (p == s || (*(p - 1) == ' ')))
            putchar (toupper (*p));
    putchar ('\n');
    return 0;
}
----------------------------------------

int main (void) {
    int wasSpace = 1;
    printf ("Name: ");
    string s = get_string ();
    for (int i = 0; i < strlen (s); i++) {
        if (wasSpace && s[i] != ' ') {
            wasSpace = 0;
            printf ("%c", toupper (s [i]));
        }
        else if (s[i] == ' ') {
            wasSpace = 1;
        }
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44863295_45002488_380_402
44863295_45022490_12_69
Title: "Draw rectangles circles or arbitrary polygons in a m x n matrix" 
----------------------------------------

int main (void) {
    int r, c;
    matrix m = MATRIX_INIT;
    if (pnm_matrix (stdin, &m)) {
        fprintf (stderr, "Cannot parse standard input.\n");
        return EXIT_FAILURE;
    }
    fprintf (stderr, "Read %d rows, %d columns, from standard input.\n", m.rows, m.cols);
    printf ("P5\n%d %d\n255\n", m.cols, m.rows);
    for (r = 0; r < m.rows; r++)
        for (c = 0; c < m.cols; c++)
            if (m.data[r * m.rowstride + c * m.colstride] == 0)
                putchar (255);
            else
                putchar (0);
    return EXIT_SUCCESS;
}
----------------------------------------

int main (int argc, char **argv) {
    xcb_connection_t *c = xcb_connect (0, 0);
    xcb_screen_t *s = xcb_setup_roots_iterator (xcb_get_setup (c)).data;
    int w, h, n, depth = s->root_depth, win_class = XCB_WINDOW_CLASS_INPUT_OUTPUT, format = XCB_IMAGE_FORMAT_Z_PIXMAP;
    xcb_colormap_t colormap = s->default_colormap;
    xcb_drawable_t win = xcb_generate_id (c);
    xcb_gcontext_t gc = xcb_generate_id (c);
    xcb_pixmap_t pixmap = xcb_generate_id (c);
    xcb_generic_event_t *ev;
    xcb_image_t *image;
    NSVGimage *shapes = NULL;
    NSVGrasterizer *rast = NULL;
    char *data = NULL;
    unsigned *dp;
    size_t i, len;
    uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, value_mask = XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS, values [] = {s->black_pixel, value_mask};
    if (argc < 2)
        return -1;
    if ((data = stbi_load (argv[1], &w, &h, &n, 4)))
        ;
    else if ((shapes = nsvgParseFromFile (argv[1], "px", 96.0f))) {
        w = (int) shapes->width;
        h = (int) shapes->height;
        rast = nsvgCreateRasterizer ();
        data = malloc (w *h * 4);
        nsvgRasterize (rast, shapes, 0, 0, 1, data, w, h, w * 4);
    }
    else
        return -1;
    for (i = 0, len = w * h, dp = (unsigned *) data; i < len; i++)
        dp[i] = dp[i] & 0xff00ff00 | ((dp[i] >> 16) & 0xFF) | ((dp[i] << 16) & 0xFF0000);
    xcb_create_window (c, depth, win, s -> root, 0, 0, w, h, 1, win_class, s -> root_visual, mask, values);
    xcb_create_pixmap (c, depth, pixmap, win, w, h);
    xcb_create_gc (c, gc, pixmap, 0, NULL);
    image = xcb_image_create_native (c, w, h, format, depth, data, w *h * 4, data);
    xcb_image_put (c, pixmap, gc, image, 0, 0, 0);
    xcb_image_destroy (image);
    xcb_map_window (c, win);
    xcb_flush (c);
    while ((ev = xcb_wait_for_event (c))) {
        switch (ev->response_type & ~0x80) {
        case XCB_EXPOSE :
            {
                xcb_expose_event_t *x = (xcb_expose_event_t *) ev;
                xcb_copy_area (c, pixmap, win, gc, x -> x, x -> y, x -> x, x -> y, x -> width, x -> height);
                xcb_flush (c);
            }
            break;
        case XCB_BUTTON_PRESS :
            goto end;
        default :
            break;
        }
    }
end :
    xcb_free_pixmap (c, pixmap);
    xcb_disconnect (c);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44863295_45002488_380_402
44863295_45097709_49_71
Title: "Draw rectangles circles or arbitrary polygons in a m x n matrix" 
----------------------------------------

int main (void) {
    int r, c;
    matrix m = MATRIX_INIT;
    if (pnm_matrix (stdin, &m)) {
        fprintf (stderr, "Cannot parse standard input.\n");
        return EXIT_FAILURE;
    }
    fprintf (stderr, "Read %d rows, %d columns, from standard input.\n", m.rows, m.cols);
    printf ("P5\n%d %d\n255\n", m.cols, m.rows);
    for (r = 0; r < m.rows; r++)
        for (c = 0; c < m.cols; c++)
            if (m.data[r * m.rowstride + c * m.colstride] == 0)
                putchar (255);
            else
                putchar (0);
    return EXIT_SUCCESS;
}
----------------------------------------

void main () {
    figure_t figures [NUM_FIGURES] = {make_rect (0, 0, 40, 40), make_elipse (256, 128, 80, 40),
    }
    for (uint32_t x = 0; x < width; ++x) {
        for (uint32_t y = 0; y < height; ++x) {
            for (uint32_t figure_ii = 0; figure_ii < NUM_FIGURES; ++figure_ii) {
                if (figures[figure_ii]->is_pixel_belongs (x, y)) {
                    image[x][y] = 1;
                    break;
                }
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44863295_45022490_12_69
44863295_45097709_49_71
Title: "Draw rectangles circles or arbitrary polygons in a m x n matrix" 
----------------------------------------

int main (int argc, char **argv) {
    xcb_connection_t *c = xcb_connect (0, 0);
    xcb_screen_t *s = xcb_setup_roots_iterator (xcb_get_setup (c)).data;
    int w, h, n, depth = s->root_depth, win_class = XCB_WINDOW_CLASS_INPUT_OUTPUT, format = XCB_IMAGE_FORMAT_Z_PIXMAP;
    xcb_colormap_t colormap = s->default_colormap;
    xcb_drawable_t win = xcb_generate_id (c);
    xcb_gcontext_t gc = xcb_generate_id (c);
    xcb_pixmap_t pixmap = xcb_generate_id (c);
    xcb_generic_event_t *ev;
    xcb_image_t *image;
    NSVGimage *shapes = NULL;
    NSVGrasterizer *rast = NULL;
    char *data = NULL;
    unsigned *dp;
    size_t i, len;
    uint32_t mask = XCB_CW_BACK_PIXEL | XCB_CW_EVENT_MASK, value_mask = XCB_EVENT_MASK_EXPOSURE | XCB_EVENT_MASK_BUTTON_PRESS, values [] = {s->black_pixel, value_mask};
    if (argc < 2)
        return -1;
    if ((data = stbi_load (argv[1], &w, &h, &n, 4)))
        ;
    else if ((shapes = nsvgParseFromFile (argv[1], "px", 96.0f))) {
        w = (int) shapes->width;
        h = (int) shapes->height;
        rast = nsvgCreateRasterizer ();
        data = malloc (w *h * 4);
        nsvgRasterize (rast, shapes, 0, 0, 1, data, w, h, w * 4);
    }
    else
        return -1;
    for (i = 0, len = w * h, dp = (unsigned *) data; i < len; i++)
        dp[i] = dp[i] & 0xff00ff00 | ((dp[i] >> 16) & 0xFF) | ((dp[i] << 16) & 0xFF0000);
    xcb_create_window (c, depth, win, s -> root, 0, 0, w, h, 1, win_class, s -> root_visual, mask, values);
    xcb_create_pixmap (c, depth, pixmap, win, w, h);
    xcb_create_gc (c, gc, pixmap, 0, NULL);
    image = xcb_image_create_native (c, w, h, format, depth, data, w *h * 4, data);
    xcb_image_put (c, pixmap, gc, image, 0, 0, 0);
    xcb_image_destroy (image);
    xcb_map_window (c, win);
    xcb_flush (c);
    while ((ev = xcb_wait_for_event (c))) {
        switch (ev->response_type & ~0x80) {
        case XCB_EXPOSE :
            {
                xcb_expose_event_t *x = (xcb_expose_event_t *) ev;
                xcb_copy_area (c, pixmap, win, gc, x -> x, x -> y, x -> x, x -> y, x -> width, x -> height);
                xcb_flush (c);
            }
            break;
        case XCB_BUTTON_PRESS :
            goto end;
        default :
            break;
        }
    }
end :
    xcb_free_pixmap (c, pixmap);
    xcb_disconnect (c);
    return 0;
}
----------------------------------------

void main () {
    figure_t figures [NUM_FIGURES] = {make_rect (0, 0, 40, 40), make_elipse (256, 128, 80, 40),
    }
    for (uint32_t x = 0; x < width; ++x) {
        for (uint32_t y = 0; y < height; ++x) {
            for (uint32_t figure_ii = 0; figure_ii < NUM_FIGURES; ++figure_ii) {
                if (figures[figure_ii]->is_pixel_belongs (x, y)) {
                    image[x][y] = 1;
                    break;
                }
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44876022_44876157_1_12
44876022_44876206_18_36
Title: Calling a function into an other function in C 
----------------------------------------

int getIntLimited (int lowerLimit, int upperLimit) {
    int value;
    value = getInt ();
    if (value > lowerLimit && value < upperLimit) {
        return value;
    }
    else {
        printf ("Invalid value, %d < %d > %d: ", lowerLimit, value, upperLimit);
        printf ("\n");
    }
    return value;
}
----------------------------------------

int getIntLimited (int lowerLimit, int upperLimit) {
    int iVal;
    iVal = getInt ();
    printf (" %d \n", iVal);
    if ((iVal > lowerLimit) && (iVal < upperLimit)) {
        printf ("OK in bound\n");
        return iVal;
    }
    else {
        printf ("Invalid value, %d < value > %d: ", lowerLimit, upperLimit);
        printf ("\n");
        exit (0);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44883997_44884148_1_19
44883997_44884224_6_22
Title: Segmentation fault in C (beginner) 
----------------------------------------

int main (int argc, char *argv []) {
    struct passwd str;
    struct passwd *pointer;
    if (argc <= 1) {
        printf ("ERROR");
        exit (0);
    }
    pointer = getpwnam (argv[1]);
    if (pointer) {
        str = *pointer;
        printf ("user: %d /ngroup: %d\r\n", str.pw_uid, str.pw_gid);
        printf ("user: %d /ngroup: %d\r\n", pointer -> pw_uid, pointer -> pw_gid);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc < 2) {
        printf ("usage: %s username", argv [0]);
        return 1;
    }
    struct passwd *pointer = getpwnam (argv[1]);
    if (pointer == NULL) {
        printf ("user: %s does not exist\n", argv [1]);
        return 1;
    }
    printf ("uid: %d\ngroup: %d\n", pointer -> pw_uid, pointer -> pw_gid);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4490554_4490597_1_12
4490554_4490641_4_20
Title: i can't hold old entries 
----------------------------------------

void push (int p, int *ptr) {
    static int i = 0;
    int b;
    ptr[i] = b;
    for (b = 0; b <= i; b++) {
        printf ("%d", ptr [b]);
        printf ("\n");
    }
    i++;
    if (i >= 10)
        i = 0;
}
----------------------------------------

void push (int p) {
    static int i = 0;
    static int ptr [10];
    ptr[i] = p;
    int b;
    for (b = 0; b <= i; b++) {
        printf ("ptr[%d] --> %d\n", b, ptr [b]);
    }
    printf ("\n");
    i++;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44916527_44916649_2_23
44916527_44917118_3_30
Title: Majority element in an array.It 
----------------------------------------

int main () {
    int maj, count, n = 7;
    int arr [] = {1, 2, 2, 2, 2, 3, 4};
    int isFound = 0;
    for (int i = 0; i < n; i++) {
        maj = arr[i];
        count = 1;
        isFound = 0;
        for (int j = i + 1; j < n; j++) {
            if (arr[j] == maj)
                count++;
        }
        if (count > n / 2) {
            isFound = 1;
            break;
        }
    }
    if (isFound)
        printf ("%d ", maj);
    else
        printf ("no major element");
    return 0;
}
----------------------------------------

int main (void) {
    int a [] = {1, 2, 2, 2, 2, 3, 4};
    const size_t N = sizeof (a) / sizeof (*a);
    size_t i = 0;
    for (; i < (N + 1) / 2; i++) {
        size_t count = 1;
        for (size_t j = i + 1; count < N / 2 + 1 && j < N; j++) {
            if (a[i] == a[j])
                ++count;
        }
        if (!(count < N / 2 + 1))
            break;
    }
    if (i != (N + 1) / 2) {
        printf ("The majority is %d\n", a [i]);
    }
    else {
        puts ("There is no majority element");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44922135_44922332_1_18
44922135_44922393_1_14
Title: "Max difference between two adjacent values in an array C" 
----------------------------------------

int main (int argc, char **argv) {
    int n = 6;
    int tab [6] = {1, 2, 8, 4, 5, 6};
    int diff = abs (tab[1] - tab[0]), maxdiff = diff, i;
    for (i = 2; i < n; i++) {
        diff = abs (tab[i] - tab[i - 1]);
        if (diff > maxdiff)
            maxdiff = diff;
    }
    printf ("Max difference: %d\n", maxdiff);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    const int n = 6;
    int tab [n] = {1, 2, 8, 4, 5, 26};
    if (n <= 1)
        return 0;
    else {
        int maxdiff = INT_MIN;
        for (int i = 1; i < n; i++)
            maxdiff = max (maxdiff, abs (tab[i] - tab[i - 1]));
        printf ("%d\n", maxdiff);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44922135_44922332_1_18
44922135_44922412_4_19
Title: "Max difference between two adjacent values in an array C" 
----------------------------------------

int main (int argc, char **argv) {
    int n = 6;
    int tab [6] = {1, 2, 8, 4, 5, 6};
    int diff = abs (tab[1] - tab[0]), maxdiff = diff, i;
    for (i = 2; i < n; i++) {
        diff = abs (tab[i] - tab[i - 1]);
        if (diff > maxdiff)
            maxdiff = diff;
    }
    printf ("Max difference: %d\n", maxdiff);
    return 0;
}
----------------------------------------

int main () {
    int n = 6;
    int tab [] = {1, 2, 8, 4, 5, 6};
    int maxdiff = 0;
    for (int i = 1; i < n; i++) {
        int diff = abs (tab[i] - tab[i - 1]);
        if (diff > maxdiff) {
            maxdiff = diff;
        }
    }
    printf ("%d\n", maxdiff);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44922135_44922393_1_14
44922135_44922412_4_19
Title: "Max difference between two adjacent values in an array C" 
----------------------------------------

int main (int argc, char **argv) {
    const int n = 6;
    int tab [n] = {1, 2, 8, 4, 5, 26};
    if (n <= 1)
        return 0;
    else {
        int maxdiff = INT_MIN;
        for (int i = 1; i < n; i++)
            maxdiff = max (maxdiff, abs (tab[i] - tab[i - 1]));
        printf ("%d\n", maxdiff);
    }
    return 0;
}
----------------------------------------

int main () {
    int n = 6;
    int tab [] = {1, 2, 8, 4, 5, 6};
    int maxdiff = 0;
    for (int i = 1; i < n; i++) {
        int diff = abs (tab[i] - tab[i - 1]);
        if (diff > maxdiff) {
            maxdiff = diff;
        }
    }
    printf ("%d\n", maxdiff);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44936627_44936745_1_20
44936627_44937084_5_19
Title: Abort trap 6 in array joining function 
----------------------------------------

int *join_arrays (unsigned int arr1N, int arr1 [], unsigned int arr2N, int arr2 [], unsigned int arr3N, int arr3 []) {
    int tableLen = arr1N + arr2N + arr3N;
    printf ("%d\n", tableLen);
    int *table = malloc (tableLen * sizeof (int));
    int tableOffset = 0;
    for (int i = 0; i < arr1N; i++) {
        table[tableOffset++] = arr1[i];
    }
    for (int i = 0; i < arr2N; i++) {
        table[tableOffset++] = arr2[i];
    }
    for (int i = 0; i < arr3N; i++) {
        table[tableOffset++] = arr3[i];
    }
    return table;
}
----------------------------------------

int *join_arrays (const int a1 [], size_t n1, const int a2 [], size_t n2, const int a3 [], size_t n3) {
    int *joined = malloc ((n1 + n2 + n3) * sizeof (int));
    if (joined != NULL) {
        memcpy (joined, a1, n1 * sizeof (int));
        memcpy (joined + n1, a2, n2 * sizeof (int));
        memcpy (joined + n1 + n2, a3, n3 * sizeof (int));
    }
    return joined;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44938148_44938285_3_31
44938148_44938383_3_19
Title: How many times a digit show up 
----------------------------------------

int main () {
    int arr [10] = {7, 7, 3, 2, 9, 8, 5, 1, 7, 9};
    int max = 0;
    int most;
    for (int i = 0; i < 10; i++) {
        int tmp = arr[i], count = 0;
        if (tmp == max)
            continue;
        for (int j = 0; j < 10; j++) {
            count += arr[j] == tmp ? 1 : 0;
        }
        if (count > max) {
            max = count;
            most = tmp;
        }
    }
    printf ("Most frequent: %d\ occurs: %d\n", most, max);
    return 0;
}
----------------------------------------

int main () {
    int arr [10] = {7, 7, 3, 2, 9, 8, 5, 1, 7, 9};
    int occur [10] = {NULL};
    int max = 0;
    for (int i = 0; i < 10; ++i)
        ++occur[arr[i]];
    for (int i = 1; i < 10; ++i)
        if (occur[i] > occur[max])
            max = i;
    printf ("Most frequent: %d\ occurs: %d\n", max, occur [max]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44957313_44958821_4_26
44957313_44959301_9_27
Title: Eliminating IF statement from this code 
----------------------------------------

char *text_entry () {
    int ch;
    size_t pos;
    static char input [20];
    while ((ch = getchar ()) != '\n' && ch != EOF) {
    }
    for (pos = 0; pos < sizeof input; pos++) {
        ch = getchar ();
        if (ch == '\n' || ch == EOF)
            break;
        input[pos] = ch;
    }
    if (!pos)
        return NULL;
    if (pos + sizeof ".txt" > sizeof input)
        return NULL;
    memcpy (input + pos, ".txt", sizeof ".txt");
    return input;
}
----------------------------------------

const char *text_entry (char *buffer, size_t buffer_size, char *extension) {
    int maxsize = buffer_size - strlen (extension) - 1;
    char *user_input;
    int user_input_len;
    do {
        user_input = readline ("Enter a file name: ");
        user_input_len = strlen (user_input);
        if (user_input_len > maxsize) {
            printf ("The name is too long! %d characters maximum. Try again.\n", maxsize);
            free (user_input);
        }
    }
    while (!user_input_len || user_input_len > maxsize);
    strcpy (buffer, user_input);
    free (user_input);
    strcat (buffer, extension);
    printf ("%s\n", buffer);
    return buffer;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44958293_44959296_57_69
44958293_51868137_1_14
Title: segmentation fault in binary tree in C 
----------------------------------------

void traverse (node *root) {
    if (root == NULL) {
        printf ("E");
        return;
    }
    printf ("%d (", root -> value);
    traverse (root -> left);
    printf (") (");
    traverse (root -> right);
    printf (")");
}
----------------------------------------

void traverse (struct node **root) {
    if (*root == NULL) {
        printf ("TREE EMPTY");
        return 0;
    }
    while ((*root) != NULL) {
        printf ("%d", (* root) -> value);
        traverse ((* root) -> left);
        traverse ((* root) -> right);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44974592_44977075_15_28
44974592_44977151_54_71
Title: Rotate a string in C 
----------------------------------------

int main (int argc, char const *argv []) {
    int k = 1;
    int n = 5;
    char a [] = "HELLO";
    reverse (& a [n - k], k);
    reverse (a, n - k);
    reverse (a, n);
    for (int i = 0;
    i < n;
    i ++) {printf ("%c\n", a [i]);
}
----------------------------------------

int main (int argc, char *argv []) {
    ssize_t rshift;
    char *s;
    if (argc != 3) {
        fprintf (stderr, "usage: %s N STR\n" "Rotate STR right by N or left by -N\n", argv [0]);
        return 2;
    }
    rshift = strtol (argv[1], NULL, 10);
    s = argv[2];
    printf ("%s\n", rotatestr (s, rshift));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44988383_44988542_3_35
44988383_44988862_3_17
Title: Multiplying the numbers of a String 
----------------------------------------

int main () {
    char input [30];
    int i, num = 0, v = 1;
    scanf ("%[^\n]s", input);
    for (i = 0; input[i] == ' '; i++)
        ;
    while (input[i] != '\0') {
        if (input[i] == ' ') {
            v *= num;
            num = 0;
            while (input[++i] == ' ')
                ;
            continue;
        }
        num *= 10;
        num += input[i] - '0';
        i++;
    }
    if (input[i - 1] != ' ') {
        v *= num;
    }
    printf ("%i\n", v);
    return 0;
}
----------------------------------------

int main () {
    char str [30];
    char *token;
    long int mul = 1;
    gets (str);
    token = strtok (str, " ");
    while (token != NULL) {
        mul = mul * atoi (token);
        token = strtok (NULL, " ");
    }
    printf ("%ld", mul);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44992851_44992914_3_23
44992851_44993006_4_27
Title: How to bitshift an array of ints? 
----------------------------------------

int main (void) {
    int array_size = 5;
    int array [] = {5, 1, 2, 3, 4};
    int i;
    for (i = array_size - 2; i >= 0; i--) {
        array[i + 1] = array[i];
        if (i == 0)
            array[i] = 0;
    }
    int j;
    for (j = 0; j < array_size; j++)
        printf ("%d ", array[j]);
    printf ("\n");
    return 0;
}
----------------------------------------

int main () {
    int i;
    int arr [5] = {1, 2, 3, 4};
    for (i = 0; i < 4; i++)
        printf ("%d ", arr[i]);
    printf ("\n");
    memmove (arr + 1, arr, 4 * sizeof (int));
    arr[0] = 5;
    printf ("After memmove:\n");
    for (i = 0; i < 5; i++)
        printf ("%d ", arr[i]);
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
44993081_44993159_6_16
44993081_44993420_4_20
Title: "C program to input date as dd-mm-yy and display date as January 3rd 1999" 
----------------------------------------

int main () {
    struct tm tm;
    char buf [255];
    memset (& tm, 0, sizeof (struct tm));
    strptime ("3-1-1999", "%d-%m-%Y ", & tm);
    strftime (buf, sizeof (buf), "%d %b %Y", & tm);
    puts (buf);
    exit (EXIT_SUCCESS);
}
----------------------------------------

int main () {
    struct tm tm_info;
    char buffer [255];
    char days [32] [5] = {" ", "1st", "2nd", "3rd", "4th", "5th", "6th", "7th", "8th", "9th", "10th", "11th", "12th", "13th", "14th", "15th", "16th", "17th", "18th", "19th", "20th", "21st", "22nd", "23rd", "24th", "25th", "26th", "27th", "28th", "29th", "30th", "31st"};
    strptime ("09-07-2017", "%d-%m-%Y ", & tm_info);
    strftime (buffer, 26, "%B", & tm_info);
    printf ("%s ", buffer);
    strftime (buffer, 26, "%d", & tm_info);
    int day = int (buffer [0] - '0') * 10 + int (buffer [1] - '0');
    printf ("%s, ", days [day]);
    strftime (buffer, 26, "%Y", & tm_info);
    printf ("%s ", buffer);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45003514_45003802_14_35
45003514_45003955_5_33
Title: Simple C program to read a file line by line 
----------------------------------------

int main (void) {
    FILE *fp;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    fp = fopen ("/home/developer/CLionProjects/untitled4/download.out", "r");
    if (fp == NULL)
        exit (EXIT_FAILURE);
    int count = 0;
    while ((read = getline (&line, &len, fp)) != -1) {
        if (count == 0)
            printf ("%s", line);
        else
            printf ("%s\n", replace_char (line, ' ', '\0'));
        count++;
    }
    fclose (fp);
    if (line)
        free (line);
    exit (EXIT_SUCCESS);
}
----------------------------------------

int main (int argc, char **argv) {
    char buf [MAXC] = "";
    int line = 1;
    FILE *fp = argc > 1 ? fopen (argv[1], "r") : stdin;
    if (!fp) {
        fprintf (stderr, "error: file open failed '%s'.\n", argv [1]);
        return 1;
    }
    while (fgets (buf, sizeof buf, fp)) {
        char et [MAXC] = "";
        if (line == 1)
            printf ("%d : %s", line, buf);
        else {
            if (sscanf (buf, "%s", et) != 1) {
                fprintf (stderr, "error: invalid conversion, line %d\n", line);
                return 1;
            }
            printf ("%d : %s\n", line, et);
        }
        line++;
    }
    if (fp != stdin)
        fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45043815_45046522_28_74
45043815_45153144_33_80
Title: From C to GMP implementation 
----------------------------------------

void analyzeAdd (mpz_t n) {
    mpz_t r;
    mpz_init (r);
    mpz_set_ui (r, 0);
    while (1) {
        int compare = mpz_cmp_ui (n, 100000000000000);
        if (compare > 0) {
            printf ("Not a palindrome!\n");
            break;
        }
        rev (r, n);
        printf ("stage:  ");
        mpz_out_str (stdout, 10, n);
        printf (" + ");
        mpz_out_str (stdout, 10, r);
        printf ("\n");
        mpz_add (n, n, r);
        if (palindrome (r, n)) {
            printf ("Palindrome: ");
            mpz_out_str (stdout, 10, n);
            printf ("\n");
            break;
        }
        else if (mpz_cmp_ui (n, 100000000000000) > 0) {
            printf ("Not a palindrome\n");
        }
    }
}
----------------------------------------

void analyzeAdd (mpz_t n) {
    mpz_t l;
    mpz_t r;
    mpz_init (r);
    mpz_set_ui (r, 0);
    int k = 0;
    while (1) {
        k = k + 1;
        if (k > 400) {
            break;
        }
        rev (r, n);
        mpz_add (n, n, r);
        if (palindrome (r, n)) {
            if (k > 20) {
                printf ("Number of stage: %d ", k);
                printf ("Palindrome: ");
                mpz_out_str (stdout, 10, n);
                printf ("\n");
            }
            break;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45043815_45134755_3_27
45043815_45153144_82_104
Title: From C to GMP implementation 
----------------------------------------

int main () {
    int k;
    mpz_t l;
    mpz_t n;
    mpz_init (n);
    mpz_init (l);
    printf ("Number to analysis: ");
    gmp_scanf ("%Zd", l);
    gmp_printf ("%s the mpz number %Zd\n", "You have entered", l);
    do {
        mpz_set (n, l);
        analyzeAdd (n);
        mpz_add_ui (l, l, 1);
    }
    while (false);
    gmp_printf ("%s is equal %Zd\n", "Now the n", n);
    return 0;
}
----------------------------------------

int main () {
    mpz_t l;
    mpz_t n;
    mpz_init (l);
    printf ("Give number: ");
    gmp_scanf ("%Zd", l);
    do {
        mpz_set (n, l);
        gmp_printf ("Number: %Zd \n", l);
        analyzeAdd (n);
        mpz_add_ui (l, l, 1);
    }
    while (1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45077642_45078266_1_29
45077642_45078669_3_15
Title: "how to store upto 1000000000 elements" 
----------------------------------------

int main () {
    unsigned long num_tests;
    scanf ("%lu", & num_tests);
    int *array_n = malloc ((size_t) num_tests * sizeof (*array));
    if (!array_n) {
        fputs ("couldn't allocate array_n\n", stderr);
        return 1;
    }
    int *array_b = malloc ((size_t) num_tests * sizeof (*array));
    if (!array_b) {
        fputs ("couldn't allocate array_b\n", stderr);
        free (array_n);
        return 1;
    }
    size_t i, j;
    for (i = 0; i < num_tests; i++) {
        scanf ("%d %d", & array_n [i], & array_b [i]);
    }
    free (array_b);
    free (array_n);
}
----------------------------------------

int main () {
    int k, t, N, B, max, num_tests;
    scanf ("%d", & num_tests);
    while (num_tests--) {
        scanf ("%d %d", & N, & B);
        for (k = N / B, max = 0; k > 0; k--) {
            t = (N - k * B) * k;
            if (t > max)
                max = t;
        }
        printf ("%d\n", max);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45087020_45087408_1_15
45087020_45087439_27_41
Title: creating insert sorted void function 
----------------------------------------

void insertSorted (BSTree *tree, int data) {
    if (!*tree) {
        tree = createNode (data);
    }
    else if (data < (*tree)->data) {
        (*tree)->left = insertSorted ((*tree)->left, data);
    }
    else
        (*tree)->right = insertSorted ((*tree)->right, data);
    return tree;
}
----------------------------------------

void insertSorted (BSTree *tree, int data) {
    if (*tree == NULL) {
        *tree = createNode (data);
    }
    else if (data < (*tree)->data) {
        insertSorted (& (* tree) -> left, data);
    }
    else {
        insertSorted (& (* tree) -> right, data);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45118405_45118990_4_27
45118405_45119244_13_102
Title: scanf from the buffer is not working properly 
----------------------------------------

int main (void) {
    int operation, number1, number2, result;
    printf ("Please enter the number of the operation you would like to perform:\n" "1. Bitwise OR\n" "2. Bitwise NOT\n" "3. Bitwise COMPARE\n" "4. Exit\n");
    if (scanf ("%i", &operation) != 1)
        return 1;
    if (operation == 1) {
        printf ("You chose Bitwise OR operation.\n");
        printf ("Please enter the first number: ");
        if (scanf ("%i", &number1) != 1)
            return 1;
        printf ("Please enter the second number: ");
        if (scanf ("%i", &number2) != 1)
            return 1;
        result = number1 | number2;
        printf ("%d (0x%x) | %d (0x%x) = %d (0x%x)\n", number1, number1, number2, number2, result, result);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char operation;
    int basetype;
    int number1;
    char num1;
    puts ("Please enter the number of the operation you would like to perform:");
    printf ("%s", "1. Bitwise OR\n" "2. Bitwise NOT\n" "3. Bitwise COMPARE\n" "4. Exit");
    if (1 != scanf (" %c", &operation)) {
        perror ("scanf for operation failed");
        exit (EXIT_FAILURE);
    }
    switch (operation) {
    case Bitwise_OR :
        printf ("You chose Bitwise OR operation.");
        printf ("\nPlease enter the first number:");
        if (1 != scanf (" %c", &num1)) {
            perror ("scanf for first number failed");
            exit (EXIT_FAILURE);
        }
        printf ("\nPlease specify the base(10/16):");
        if (1 != scanf ("%d", &basetype)) {
            perror ("scanf for base failed");
            exit (EXIT_FAILURE);
        }
        switch (basetype) {
        case 10 :
            while (num1 != 10) {
                number1 = num1 - '0';
                if (number1 >= 1 && number1 <= 9) {
                    printf ("ok");
                }
                else
                    printf ("not ok");
                scanf (" %c", & num1);
            }
            break;
        case 16 :
            break;
        default :
            puts ("base must be 10 or 16");
            break;
        }
        break;
    case Bitwise_NOT :
        break;
    case Bitwise_COMPARE :
        break;
    case Exit :
        break;
    default :
        break;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45123533_45123581_3_14
45123533_45123828_3_27
Title: checking the end of a c string array 
----------------------------------------

int main () {
    char cstr [10] = "Test";
    size_t len;
    for (len = 0; cstr[len]; ++len)
        ;
    if (sizeof (cstr) > len + 1) {
        cstr[len++] = 's';
        cstr[len] = '\0';
    }
    printf ("%s\n", cstr);
}
----------------------------------------

int main (int argc, char **argv) {
    char plural [10] = "", *def = "school";
    int len = 0, max = sizeof plural - 1;
    if (argc == 1) {
        char *p = def;
        for (int i = 0; *p && i < max; i++, len++)
            plural[i] = *p++;
    }
    else
        len = snprintf (plural, max, "%s", argv[1]);
    if (len >= max) {
        fprintf (stderr, "error: adding 's' will exceed array size.\n");
        return 1;
    }
    plural[len] = 's';
    printf ("original : %s\nappended : %s\n", argc > 1 ? argv [1] : def, plural);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45136080_45136348_3_42
45136080_45136461_1_153
Title: Bermudez C Chapter 5 P 2: No use of arrays or loops for ascending order 
----------------------------------------

int main () {
    int a, b, c, d, e, temp;
    printf ("Program 5.2: Ascending Order of Values\n");
    printf ("======================================\n\n");
    printf ("Enter first value: ");
    scanf ("%d", & a);
    printf ("Enter second value: ");
    scanf ("%d", & b);
    printf ("Enter third value: ");
    scanf ("%d", & c);
    printf ("Enter fourth value: ");
    scanf ("%d", & d);
    printf ("Enter fifth value: ");
    scanf ("%d", & e);
    printf ("\nRe-arranged in ascending order: \n");
    printf ("===============================\n\n");
    if (a > b) {
        temp = a;
        a = b;
        b = temp;
    }
    if (d > e) {
        temp = d;
        d = e;
        e = temp;
    }
    if (c > e) {
        temp = c;
        c = e;
        e = temp;
    }
    if (c > d) {
        temp = c;
        c = d;
        d = temp;
    }
    if (a > d) {
        temp = a;
        a = d;
        d = temp;
    }
    if (a > c) {
        temp = a;
        a = c;
        c = temp;
    }
    if (b > e) {
        temp = b;
        b = e;
        e = temp;
    }
    if (b > d) {
        temp = b;
        b = d;
        d = temp;
    }
    if (b > c) {
        temp = b;
        b = c;
        c = temp;
    }
    printf ("%d %d %d %d %d\n", a, b, c, d, e);
    return 0;
}
----------------------------------------

int main () {
    int a, b, c, d, e;
    scanf ("%d", & a);
    scanf ("%d", & b);
    scanf ("%d", & c);
    scanf ("%d", & d);
    scanf ("%d", & e);
    int a_count = 0;
    int b_count = 0;
    int c_count = 0;
    int d_count = 0;
    int e_count = 0;
    int first, second, third, fourth, fifth;
    if (a > b)
        ++a_count;
    if (a > c)
        ++a_count;
    if (a > d)
        ++a_count;
    if (a > e)
        ++a_count;
    if (b > a)
        ++b_count;
    if (b > c)
        ++b_count;
    if (b > d)
        ++b_count;
    if (b > e)
        ++b_count;
    if (c > a)
        ++c_count;
    if (c > b)
        ++c_count;
    if (c > d)
        ++c_count;
    if (c > e)
        ++c_count;
    if (d > a)
        ++d_count;
    if (d > b)
        ++d_count;
    if (d > c)
        ++d_count;
    if (d > e)
        ++d_count;
    if (e > a)
        ++e_count;
    if (e > b)
        ++e_count;
    if (e > c)
        ++e_count;
    if (e > d)
        ++e_count;
    switch (a_count) {
    case 0 :
        first = a;
        break;
    case 1 :
        second = a;
        break;
    case 2 :
        third = a;
        break;
    case 3 :
        fourth = a;
        break;
    case 4 :
        fifth = a;
        break;
    }
    switch (b_count) {
    case 0 :
        first = b;
        break;
    case 1 :
        second = b;
        break;
    case 2 :
        third = b;
        break;
    case 3 :
        fourth = b;
        break;
    case 4 :
        fifth = b;
        break;
    }
    switch (c_count) {
    case 0 :
        first = c;
        break;
    case 1 :
        second = c;
        break;
    case 2 :
        third = c;
        break;
    case 3 :
        fourth = c;
        break;
    case 4 :
        fifth = c;
        break;
    }
    switch (d_count) {
    case 0 :
        first = d;
        break;
    case 1 :
        second = d;
        break;
    case 2 :
        third = d;
        break;
    case 3 :
        fourth = d;
        break;
    case 4 :
        fifth = d;
        break;
    }
    switch (e_count) {
    case 0 :
        first = e;
        break;
    case 1 :
        second = e;
        break;
    case 2 :
        third = e;
        break;
    case 3 :
        fourth = e;
        break;
    case 4 :
        fifth = e;
        break;
    }
    printf ("%d %d %d %d %d\n", first, second, third, fourth, fifth);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45152411_45152784_40_64
45152411_45153313_55_71
Title: How to find max element in an unknown type array in c (using pointers to functions) 
----------------------------------------

int main (void) {
    size_t result;
    int array [4] = {1, 3, 7, 0};
    float array_f [4] = {1.23, 6.57, 9.89, 11.56};
    char array_s [5] [6] = {"jess", "ron", "tom", "mia", "alex"};
    const char *array_str [5] = {"jess", "ron", "tom", "mia", "alex"};
    result = maxElement (array, sizeof (array) / sizeof (*array), sizeof (*array), compareInt);
    printf ("int result: %d\n", array [result]);
    result = maxElement (array_f, sizeof (array_f) / sizeof (*array_f), sizeof (*array_f), compareFloat);
    printf ("float result: %f\n", array_f [result]);
    result = maxElement (array_s, sizeof (array_s) / sizeof (*array_s), sizeof (*array_s), compareChars);
    printf ("string result: %s\n", array_s [result]);
    result = maxElement (array_str, sizeof (array_str) / sizeof (*array_str), sizeof (*array_str), compareString);
    printf ("string result: %s\n", array_str [result]);
    return 0;
}
----------------------------------------

int main (void) {
    int i_array [4] = {11, 3, 7, 0};
    double d_array [4] = {1.23, 6.57, 9.89, 11.56};
    char *s_array [5] = {"jess", "ron", "tom", "mia", "alex"};
    printInt (i_array, 4);
    int i_max = *(int*) maxElement (i_array, 4, sizeof (int), &compareInt);
    printDbl (d_array, 4);
    double d_max = *(double*) maxElement (d_array, 4, sizeof (double), &compareDbl);
    printStr (s_array, 5);
    char *s_max = *(char**) maxElement (s_array, 5, sizeof (char *), &compareStr);
    printf ("Max integer: %d\n", i_max);
    printf ("Max double:  %.2f\n", d_max);
    printf ("Max string:  [%s]\n", s_max);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45152411_45152784_40_64
45152411_45153435_43_54
Title: How to find max element in an unknown type array in c (using pointers to functions) 
----------------------------------------

int main (void) {
    size_t result;
    int array [4] = {1, 3, 7, 0};
    float array_f [4] = {1.23, 6.57, 9.89, 11.56};
    char array_s [5] [6] = {"jess", "ron", "tom", "mia", "alex"};
    const char *array_str [5] = {"jess", "ron", "tom", "mia", "alex"};
    result = maxElement (array, sizeof (array) / sizeof (*array), sizeof (*array), compareInt);
    printf ("int result: %d\n", array [result]);
    result = maxElement (array_f, sizeof (array_f) / sizeof (*array_f), sizeof (*array_f), compareFloat);
    printf ("float result: %f\n", array_f [result]);
    result = maxElement (array_s, sizeof (array_s) / sizeof (*array_s), sizeof (*array_s), compareChars);
    printf ("string result: %s\n", array_s [result]);
    result = maxElement (array_str, sizeof (array_str) / sizeof (*array_str), sizeof (*array_str), compareString);
    printf ("string result: %s\n", array_str [result]);
    return 0;
}
----------------------------------------

int main (void) {
    int array [4] = {1, 3, 7, 0};
    float array_f [4] = {1.23, 6.57, 9.89, 11.56};
    char string [5] [6] = {"jess", "ron", "tom", "mia", "alex"};
    printf ("%d\n", * (int *) maxElement (array, 4, sizeof (int), compareInt));
    printf ("%f\n", * (float *) maxElement (array_f, 4, sizeof (float), compareFloat));
    printf ("%s\n", (char *) maxElement (string, 5, sizeof (char [6]), compareString));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45152411_45153182_10_18
45152411_45153313_14_26
Title: How to find max element in an unknown type array in c (using pointers to functions) 
----------------------------------------

void *maxElement (void *arr, int size, int (*comp) (void **, void **)) {
    int i;
    void *max = arr;
    void *cur = arr;
    for (i = 1; i < size; i++) {
        comp (& max, & cur);
    }
    return max;
}
----------------------------------------

void *maxElement (void *arr, size_t number, size_t size, int (*comp) (const void *, const void *)) {
    char *base = arr;
    void *max = base;
    for (size_t i = 1; i < number; i++) {
        if (comp (&base[i * size], max) > 0)
            max = &base[i * size];
    }
    return max;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45152411_45153182_10_18
45152411_45153435_4_20
Title: How to find max element in an unknown type array in c (using pointers to functions) 
----------------------------------------

void *maxElement (void *arr, int size, int (*comp) (void **, void **)) {
    int i;
    void *max = arr;
    void *cur = arr;
    for (i = 1; i < size; i++) {
        comp (& max, & cur);
    }
    return max;
}
----------------------------------------

void *maxElement (const void *base, size_t nmemb, size_t size, int comp (const void *, const void *)
) {
    const void *max = base;
    for (size_t i = 1; i < nmemb; i++) {
        if (comp (max, (const char *) base + i * size) < 0) {
            max = (const char *) base + i * size;
        }
    }
    return (void *) max;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45152411_45153313_14_26
45152411_45153435_4_20
Title: How to find max element in an unknown type array in c (using pointers to functions) 
----------------------------------------

void *maxElement (void *arr, size_t number, size_t size, int (*comp) (const void *, const void *)) {
    char *base = arr;
    void *max = base;
    for (size_t i = 1; i < number; i++) {
        if (comp (&base[i * size], max) > 0)
            max = &base[i * size];
    }
    return max;
}
----------------------------------------

void *maxElement (const void *base, size_t nmemb, size_t size, int comp (const void *, const void *)
) {
    const void *max = base;
    for (size_t i = 1; i < nmemb; i++) {
        if (comp (max, (const char *) base + i * size) < 0) {
            max = (const char *) base + i * size;
        }
    }
    return (void *) max;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45152411_45153313_55_71
45152411_45153435_43_54
Title: How to find max element in an unknown type array in c (using pointers to functions) 
----------------------------------------

int main (void) {
    int i_array [4] = {11, 3, 7, 0};
    double d_array [4] = {1.23, 6.57, 9.89, 11.56};
    char *s_array [5] = {"jess", "ron", "tom", "mia", "alex"};
    printInt (i_array, 4);
    int i_max = *(int*) maxElement (i_array, 4, sizeof (int), &compareInt);
    printDbl (d_array, 4);
    double d_max = *(double*) maxElement (d_array, 4, sizeof (double), &compareDbl);
    printStr (s_array, 5);
    char *s_max = *(char**) maxElement (s_array, 5, sizeof (char *), &compareStr);
    printf ("Max integer: %d\n", i_max);
    printf ("Max double:  %.2f\n", d_max);
    printf ("Max string:  [%s]\n", s_max);
    return 0;
}
----------------------------------------

int main (void) {
    int array [4] = {1, 3, 7, 0};
    float array_f [4] = {1.23, 6.57, 9.89, 11.56};
    char string [5] [6] = {"jess", "ron", "tom", "mia", "alex"};
    printf ("%d\n", * (int *) maxElement (array, 4, sizeof (int), compareInt));
    printf ("%f\n", * (float *) maxElement (array_f, 4, sizeof (float), compareFloat));
    printf ("%s\n", (char *) maxElement (string, 5, sizeof (char [6]), compareString));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45192223_45202816_34_88
45192223_45224350_36_141
Title: How to search through an array of struct C programming 
----------------------------------------

int main (void) {
    FILE *filePtr;
    int index, count;
    char line [LEN_LINE + 1];
    player_t players [MAX_LINES];
    filePtr = fopen ("Shrimp.txt", "r");
    if (filePtr == NULL) {
        printf ("Unable to open file.\n");
    }
    else {
        index = 0, count;
        while (index < MAX_LINES && fgets (line, LEN_LINE, filePtr)) {
            if (14 == sscanf (line, "%i %s %s %s %s %s %i %i %i %i %i %i %s %s", &players[index].jerseyNumber, players[index].firstName, players[index].lastName, players[index].position, players[index].battingHand, players[index].throwingHand, &players[index].birthYear, &players[index].birthMonth, &players[index].birthDay, &players[index].heightFeet, &players[index].heightInches, &players[index].weight, players[index].status, players[index].mlbStatus)) {
                index++;
            }
        }
        fclose (filePtr);
        count = index;
        for (index = 0; index < count; index = index + 1) {
            displayPlayer (& players [index]);
        }
        int jerseyNumber;
        int i;
        printf ("Enter jersey number for the player: ");
        scanf ("%i", & jerseyNumber);
        for (i = 0; i <= MAX_PLAYERS; i++) {
            if (jerseyNumber == players[i].jerseyNumber) {
                printf ("The player's name is %s %s\n", players [i].firstName, players [i].lastName);
            }
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    FILE *filePtr;
    int index, count, i;
    char line [LEN_LINE + 1];
    char userChoice;
    char repeat;
    player_t players [MAX_LINES];
    filePtr = fopen ("Shrimp.txt", "r");
    if (filePtr == NULL) {
        printf ("Unable to open file.\n");
    }
    else {
        index = 0;
        while (index < MAX_LINES && fgets (line, LEN_LINE, filePtr)) {
            if (14 == sscanf (line, "%i %30s %30s %5s %5s %5s %i %i %i %i %i %i %10s %5s", &players[index].jerseyNumber, players[index].firstName, players[index].lastName, players[index].position, players[index].battingHand, players[index].throwingHand, &players[index].birthYear, &players[index].birthMonth, &players[index].birthDay, &players[index].heightFeet, &players[index].heightInches, &players[index].weight, players[index].status, players[index].mlbStatus)) {
                index++;
            }
        }
        fclose (filePtr);
        count = index;
        displayWelcome ();
        do {
            printf ("Choose how you would like to search.\nEnter A to display all players information.\
                \nEnter N to search a player based on name.\nEnter J to search a player based on jersey number.\
                \nEnter P to search a player based on position.\nEnter your choice: ");
            scanf ("%c", & userChoice);
            if (userChoice == 'A' || userChoice == 'a') {
                for (index = 0; index < count; index = index + 1) {
                    displayPlayer (& players [index]);
                }
            }
            if (userChoice == 'J' || userChoice == 'j') {
                int jerseyNumber;
                printf ("Enter jersey number for the player: ");
                scanf ("%i", & jerseyNumber);
                for (i = 0; i <= MAX_PLAYERS; i++) {
                    if (jerseyNumber == players[i].jerseyNumber) {
                        singleDisplay (& players [i]);
                    }
                }
            }
            if (userChoice == 'N' || userChoice == 'n') {
                char playerName [LEN_NAME + 1];
                printf ("Enter name for the player: ");
                scanf ("%s", playerName);
                for (i = 0; i <= MAX_PLAYERS; i++) {
                    if (strcmp (playerName, players[i].firstName) == 0) {
                        singleDisplay (& players [i]);
                    }
                }
            }
            if (userChoice == 'P' || userChoice == 'p') {
                char playerPosition [LEN_NAME + 1];
                printf ("Enter position for the player: ");
                scanf ("%s", playerPosition);
                for (i = 0; i <= MAX_PLAYERS; i++) {
                    if (strcmp (playerPosition, players[i].position) == 0) {
                        singleDisplay (& players [i]);
                    }
                }
            }
            printf ("Would you like to search again?\nEnter Y or y for Yes or any other character to exit this program!\n");
            scanf ("\n%c", & repeat);
        }
        while (repeat == 'Y' || repeat == 'y');
    }
    resultsProvided ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45207429_45215873_42_108
45207429_45216894_21_60
Title: Monk and Power of Time DataStructure query 
----------------------------------------

int main () {
    char *line;
    int num_tasks, iter;
    int *current_order, *desired_order;
    line = (char *) malloc (MAX_LINE_LEN);
    if (!line) {
        exit (1);
    }
    if (fgets (&line[0], MAX_LINE_LEN, stdin) != &line[0]) {
        free (line);
        exit (1);
    }
    num_tasks = atoi (line);
    if (fgets (&line[0], MAX_LINE_LEN, stdin) != &line[0]) {
        free (line);
        exit (1);
    }
    current_order = load_array (line, num_tasks);
    if (!current_order) {
        free (line);
        exit (1);
    }
    if (fgets (&line[0], MAX_LINE_LEN, stdin) != &line[0]) {
        free (line);
        exit (1);
    }
    desired_order = load_array (line, num_tasks);
    if (!desired_order) {
        free (line);
        free (current_order);
        exit (1);
    }
    iter = 0;
    while (num_tasks) {
        ++iter;
        if (current_order[0] == desired_order[0]) {
            pop_front (desired_order, num_tasks);
            pop_front (current_order, num_tasks);
            --num_tasks;
        }
        else {
            move_first_to_last (current_order, num_tasks);
        }
    }
    printf ("%d\n", iter);
    free (current_order);
    free (desired_order);
    free (line);
    return 0;
}
----------------------------------------

int main () {
    int co [100], io [100];
    int n, i, j, count = 0, ptime = 0;
    scanf ("%d", & n);
    for (i = 0; i < n; i++)
        scanf ("%d", &co[i]);
    for (i = 0; i < n; i++)
        scanf ("%d", &io[i]);
    while (count != n) {
        while (co[0] != io[0]) {
            int *p;
            int size = n - count;
            p = move_last (co, size);
            ptime++;
        }
        if (co[0] == io[0]) {
            int *p;
            int size = n - count;
            p = remove_first (co, size);
            remove_first (io, size);
            size = size - 1;
            count++;
            ptime++;
        }
    }
    printf ("%d", ptime);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45207429_45215873_42_108
45207429_45222862_3_34
Title: Monk and Power of Time DataStructure query 
----------------------------------------

int main () {
    char *line;
    int num_tasks, iter;
    int *current_order, *desired_order;
    line = (char *) malloc (MAX_LINE_LEN);
    if (!line) {
        exit (1);
    }
    if (fgets (&line[0], MAX_LINE_LEN, stdin) != &line[0]) {
        free (line);
        exit (1);
    }
    num_tasks = atoi (line);
    if (fgets (&line[0], MAX_LINE_LEN, stdin) != &line[0]) {
        free (line);
        exit (1);
    }
    current_order = load_array (line, num_tasks);
    if (!current_order) {
        free (line);
        exit (1);
    }
    if (fgets (&line[0], MAX_LINE_LEN, stdin) != &line[0]) {
        free (line);
        exit (1);
    }
    desired_order = load_array (line, num_tasks);
    if (!desired_order) {
        free (line);
        free (current_order);
        exit (1);
    }
    iter = 0;
    while (num_tasks) {
        ++iter;
        if (current_order[0] == desired_order[0]) {
            pop_front (desired_order, num_tasks);
            pop_front (current_order, num_tasks);
            --num_tasks;
        }
        else {
            move_first_to_last (current_order, num_tasks);
        }
    }
    printf ("%d\n", iter);
    free (current_order);
    free (desired_order);
    free (line);
    return 0;
}
----------------------------------------

int main () {
    int N, Num;
    cin >> N;
    queue < int > Q;
    for (int i = 0; i < N; i++) {
        cin >> Num;
        Q.push (Num);
    }
    int a [N];
    for (int i = 0; i < N; i++)
        cin >> a[i];
    int total_time = 0, executed_job = 0;
    while (!Q.empty ()) {
        int job = Q.front ();
        if (job == a[executed_job]) {
            Q.pop ();
            total_time++;
            executed_job++;
        }
        else {
            Q.pop ();
            Q.push (job);
            total_time++;
        }
    }
    cout << total_time << endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45207429_45216894_21_60
45207429_45222862_3_34
Title: Monk and Power of Time DataStructure query 
----------------------------------------

int main () {
    int co [100], io [100];
    int n, i, j, count = 0, ptime = 0;
    scanf ("%d", & n);
    for (i = 0; i < n; i++)
        scanf ("%d", &co[i]);
    for (i = 0; i < n; i++)
        scanf ("%d", &io[i]);
    while (count != n) {
        while (co[0] != io[0]) {
            int *p;
            int size = n - count;
            p = move_last (co, size);
            ptime++;
        }
        if (co[0] == io[0]) {
            int *p;
            int size = n - count;
            p = remove_first (co, size);
            remove_first (io, size);
            size = size - 1;
            count++;
            ptime++;
        }
    }
    printf ("%d", ptime);
    return 0;
}
----------------------------------------

int main () {
    int N, Num;
    cin >> N;
    queue < int > Q;
    for (int i = 0; i < N; i++) {
        cin >> Num;
        Q.push (Num);
    }
    int a [N];
    for (int i = 0; i < N; i++)
        cin >> a[i];
    int total_time = 0, executed_job = 0;
    while (!Q.empty ()) {
        int job = Q.front ();
        if (job == a[executed_job]) {
            Q.pop ();
            total_time++;
            executed_job++;
        }
        else {
            Q.pop ();
            Q.push (job);
            total_time++;
        }
    }
    cout << total_time << endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45211559_45212013_4_27
45211559_45212439_1_33
Title: Finding nth power of integer m through C program without pow() 
----------------------------------------

int main () {
    int m, n, i;
    double p = 1.0;
    printf ("Enter the number and its power (exponent)\n");
    scanf ("%d%d", & m, & n);
    if (n == 0) {
        printf ("%d raised to %d is: %f", m, n, p);
    }
    else if (n > 0) {
        for (i = 0; i < n; i++)
            p *= m;
        printf ("%d raised to %d is: %f", m, n, p);
    }
    else {
        n = -n;
        for (i = 0; i < n; i++)
            p *= m;
        printf ("%d raised to %d is: %f", m, - n, 1 / p);
    }
}
----------------------------------------

void main () {
    signed int m, n;
    int i;
    float p;
    printf ("Enter the number and its power (exponent)\n");
    scanf ("%d%d", & m, & n);
    p = 1;
    if (n == 0) {
        printf ("%d raised to %d is: %f", m, n, p);
    }
    if (n > 0) {
        for (i = 0; i < n; i++)
            p *= m;
        printf ("%d raised to %d is: %f", m, n, p);
    }
    if (n < 0) {
        n = -n;
        for (i = 0; i < n; i++) {
            p *= m;
        }
        printf ("%d raised to %d is: %f", m, - n, 1 / p);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45244560_45244668_1_14
45244560_45245201_1_11
Title: How do i print all the odd numbers? 
----------------------------------------

int main () {
    int x = 14;
    while (1) {
        if (x % 2 == 0) {
            x++;
            continue;
        }
        if (x >= 156) {
            break;
        }
        printf ("%d\n", x ++);
    }
    return 0;
}
----------------------------------------

int main () {
    int y = 15;
    while (y) {
        if (y == 157)
            break;
        printf ("%d ", y);
        y += 2;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45244560_45244668_1_14
45244560_45247417_3_12
Title: How do i print all the odd numbers? 
----------------------------------------

int main () {
    int x = 14;
    while (1) {
        if (x % 2 == 0) {
            x++;
            continue;
        }
        if (x >= 156) {
            break;
        }
        printf ("%d\n", x ++);
    }
    return 0;
}
----------------------------------------

int main (void) {
    for (int y = 14;; y++) {
        if (y == 156)
            break;
        if (y % 2 == 0)
            continue;
        printf ("%d\n", y);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45244560_45245201_1_11
45244560_45247417_3_12
Title: How do i print all the odd numbers? 
----------------------------------------

int main () {
    int y = 15;
    while (y) {
        if (y == 157)
            break;
        printf ("%d ", y);
        y += 2;
    }
    return 0;
}
----------------------------------------

int main (void) {
    for (int y = 14;; y++) {
        if (y == 156)
            break;
        if (y % 2 == 0)
            continue;
        printf ("%d\n", y);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45258912_45260153_3_23
45258912_45260557_7_32
Title: Extracting two numerical characters of a string and and placing them in an integer (C Programming) 
----------------------------------------

int main (void) {
    char str [] = "1234567";
    int i1, i2;
    {
        const char *i1p = str, *i2p;
        if (!*str || !str[1]) {
            fprintf (stderr, "'%s' is too short string.", str);
            return 1;
        }
        for (const char *p = str; *p && p[1]; ++p)
            i2p = p;
        i1 = d22i (i1p);
        i2 = d22i (i2p);
    }
    printf ("%d %d\n", i1, i2);
}
----------------------------------------

int main (void) {
    char str [] = "1234567", buf1 [NCHR + 1] = "", buf2 [NCHR + 1] = "";
    int i1 = 0, i2 = 0;
    for (int i = 0; i < NCHR; i++) {
        buf1[i] = str[i];
        buf2[i] = str[i + NOFF];
    }
    errno = 0;
    i1 = (int) strtol (buf1, NULL, 10);
    i2 = (int) strtol (buf2, NULL, 10);
    if (errno) {
        fprintf (stderr, "error: failed converstion for i1 or l2.\n");
        return 1;
    }
    printf ("i1 = %d\ni2 = %d\n", i1, i2);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
45270833_45271056_1_11
45270833_45271368_7_31
Title: Reverse a linked list without using a pointer to pointer 
----------------------------------------

void reverse (struct node *head) {
    struct node *curr = head;
    struct node *next = NULL;
    struct node *prev = NULL;
    while (curr) {
        next = curr->next;
        curr->next = prev;
        prev = curr;
        curr = next;
    }
}
----------------------------------------

void reverse (struct node *h) {
    if (!h || !h->next) {
        return;
    }
    struct node *tail = h->next;
    while (tail->next) {
        tail = tail->next;
    }
    swap (h, tail);
    struct node *p = NULL;
    struct node *c = tail;
    do {
        struct node *n = c->next;
        c->next = p;
        p = c;
        c = n;
    }
    while (c->next != tail);
    h->next = c;
}
----------------------------------------
