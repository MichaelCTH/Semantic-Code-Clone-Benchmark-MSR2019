$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10020954_10023313_1_26
10020954_10026686_4_14
Title: "Converting a string of digits to an integer storing the result" 
----------------------------------------

void MyFNatoi (const char *str, int *value) {
    if (value == NULL)
        return;
    *value = 0;
    if (str != NULL) {
        int negative = 0;
        if (*str == '-') {
            negative = 1;
            str++;
        }
        while (*str && isdigit (*str)) {
            *value = (*value * 10) + (*str++ - '0');
        }
        if (negative)
            *value *= -1;
    }
}
----------------------------------------

void MyFNatoi (char *numArray, int *value) {
    int i;
    *value = 0;
    for (i = 0; i < 10 && numArray[i] != 0; i++) {
        if (numArray[i] >= Zero && numArray[i] <= Nine) {
            *value = *value * 10 + (numArray[i] - Zero);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10045158_10045263_3_57
10045158_10045417_5_40
Title: Extracting individual digits from a long in C 
----------------------------------------

int main () {
    int number;
    printf ("Enter a positive number: ");
    do {
        scanf ("%ld", & number);
        if (number < 0) {
            printf ("invalid input...enter a positive integer: ");
            continue;
        }
        else
            break;
    }
    while (1);
    int a = -1;
    int b = -1;
    int c = -1;
    int d = -1;
    int e = -1;
    int f = -1;
    int g = -1;
    int h = -1;
    int i = -1;
    while (number > 0) {
        if (a < 0)
            a = number % 10;
        else if (b < 0)
            b = number % 10;
        else if (c < 0)
            c = number % 10;
        else if (d < 0)
            d = number % 10;
        else if (e < 0)
            e = number % 10;
        else if (f < 0)
            f = number % 10;
        else if (g < 0)
            g = number % 10;
        else if (h < 0)
            h = number % 10;
        else if (i < 0)
            i = number % 10;
        number /= 10;
    }
    printf ("%i", a);
    printf ("%i", b);
    printf ("%i", c);
    printf ("%i", d);
    printf ("%i", e);
    printf ("%i", f);
    printf ("%i", g);
    printf ("%i", h);
    printf ("%i", i);
    return 0;
}
----------------------------------------

int main (int argc, const char *argv []) {
    int enter_num, temp_num, sum = 0;
    int divisor, digit, count = 0;
    printf ("Please enter number\n");
    scanf ("%d", & enter_num);
    temp_num = enter_num;
    while (temp_num != 0) {
        temp_num = temp_num / 10;
        count++;
    }
    temp_num = enter_num;
    printf ("Individual digits in the entered number are ");
    do {
        divisor = (int) (alePow (10.0, --count));
        digit = temp_num / divisor;
        temp_num = temp_num % divisor;
        printf (" %d", digit);
        sum = sum + digit;
    }
    while (count != 0);
    printf ("\nSum of the digits is = %d\n", sum);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10087113_10087626_3_20
10087113_18003423_5_19
Title: How many levels of pointers can we have? 
----------------------------------------

int main () {
    const int size = 200;
std :
    : cout << "#include <iostream>\n\n";
std :
    : cout << "int main()\n{\n";
std :
    : cout << "    int i0 = " << size << ";";
    for (int i = 1; i < size; ++i) {
    std :
        : cout << "    int ";
        for (int j = 0; j < i; ++j)
        std :
        : cout << "*";
    std :
        : cout << " i" << i << " = &i" << i - 1 << ";\n";
    }
std :
    : cout << "    std::cout << ";
    for (int i = 1; i < size; ++i)
    std :
    : cout << "*";
std :
    : cout << "i" << size - 1 << " << \"\\n\";\n";
std :
    : cout << "    return 0;\n}\n";
    return 0;
}
----------------------------------------

int main () {
    int number = 0;
    int * * ptr = new int * [CBlockSize];
    ptr[0] = &number;
    for (int i = 1;
    i < CBlockSize;
    ++ i) ptr [i] = reinterpret_cast < int * > (& ptr [i - 1]);
    for (int i = CBlockSize - 1; i >= 0; --i)
    std :
    : cout << i << " " << (int) ptr [i] << "->" << * ptr [i] << std : : endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10096599_10097167_17_65
10096599_10101276_36_53
Title: Bitwise operations equivalent of greater than operator 
----------------------------------------

int main () {
    while (1) {
        unsigned int a, b;
        printf ("Enter two unsigned integers separated by spaces: ");
        scanf ("%u %u", & a, & b);
        getchar ();
        printBin (a);
        printBin (b);
        printSep ();
        unsigned int ltb = ~a & b;
        unsigned int gtb = a & ~b;
        ltb |= ltb >> 1;
        ltb |= ltb >> 2;
        ltb |= ltb >> 4;
        ltb |= ltb >> 8;
        ltb |= ltb >> 16;
        unsigned int isGt = gtb & ~ltb;
        isGt |= isGt >> 1;
        isGt |= isGt >> 2;
        isGt |= isGt >> 4;
        isGt |= isGt >> 8;
        isGt |= isGt >> 16;
        isGt &= 1;
        printBin (ltb);
        printBin (gtb);
        printSep ();
        printBin (isGt);
    }
}
----------------------------------------

int main () {
    int j;
    scanf ("%d%d", & a, & b);
    ma = a;
    mb = b;
    i = (sizeof (int) * 8) - 1;
    j = 1 << i;
    ((a & j) && flipnum (&a, &a_neg));
    ((b & j) && flipnum (&b, &b_neg));
    j = 1 << (i - 1);
    recursive_check (j);
    (!stop && printf ("numbers are same..\n"));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10100070_10100379_6_74
10100070_10100446_10_105
Title: Could not able to understand Obfuscated C Code 
----------------------------------------

main () {
    struct llll1 *ll11, *l1l, *l1, *ll1l, *malloc ();
    unsigned long l1ll;
    long l11, ll, l;
    unsigned short *lll1, *lllll;
    for (l = 1 - 1; l < 14; putchar ("\t\"8)>l\"9!.)>vl"[l] ^ 'L'), ++l)
        ;
    scanf ("%d", & l);
    l1l = malloc (sizeof (struct llll1));
    l1l->lll1l = 1 - 1;
    l1l->ll1l1 = 1 - 1;
    ll11 = malloc (sizeof (struct llll1));
    ll11->lll1l = 1 - 1;
    ll11->ll1l1 = 1 - 1;
    (l1 = l1l)->lll[l1l->lll[1 - 1] = 1] = 0xFFFF;
    for (l11 = 1 + 1; l11 <= l; ++l11) {
        l1 = ll11;
        lll1 = (ll1l = (ll11 = l1l))->lll;
        lllll = (l1l = l1)->lll;
        ll = (l1ll = 1 - 1);
        for (; ll1l->lll1l || 0xFFFF != *lll1;) {
            l1ll += l11 * *lll1++;
            *lllll++ = l1ll % 10000;
            l1ll /= 10000;
            if (++ll > 1000) {
                if (!l1->lll1l) {
                    l1->lll1l = malloc (sizeof (struct llll1));
                    l1->lll1l->lll1l = 1 - 1;
                    l1->lll1l->ll1l1 = 1 - 1;
                    l1->lll1l->ll1l1 = l1;
                }
                lllll = (l1 = l1->lll1l)->lll;
                ll = 1 - 1;
                lll1 = (ll1l = ll1l->lll1l)->lll;
            }
        }
        for (; l1ll;) {
            *lllll++ = l1ll % 10000;
            l1ll /= 10000;
            if (++ll >= 1000) {
                if (!l1->lll1l) {
                    l1->lll1l = malloc (sizeof (struct llll1));
                    l1->lll1l->lll1l = 1 - 1;
                    l1->lll1l->ll1l1 = 1 - 1;
                    l1->lll1l->ll1l1 = l1;
                }
                lllll = (l1 = l1->lll1l)->lll;
                ll = 1 - 1;
            }
        }
        *lllll = 0xFFFF;
    }
    for (l = (ll = 1 - 1); (l < 1000) && (l1->lll[l] != 0xFFFF); ++l)
        ;
    for (; l1; l1 = l1->ll1l1, l = 1000) {
        for (--l; l >= 1 - 1; --l, ++ll)
            printf ((ll) ? ((ll % 19) ? "%04d" : (ll = 19, "\n%04d")) : "%4d", l1->lll[l]);
    }
    putchar (10);
}
----------------------------------------

main () {
    struct StructName *structC, *structD, *structE, *structF, *malloc ();
    unsigned long unsignedLongA;
    long longA, longB, longC = 0;
    unsigned short *unsignedShortA, *unsignedShortB;
    printf ("%s", "Enter a number: ");
    scanf ("%d", & longC);
    structD = malloc (sizeof (struct StructName));
    structD->structA = 0;
    structD->structB = 0;
    structC = malloc (sizeof (struct StructName));
    structC->structA = 0;
    structC->structB = 0;
    (structE = structD)->unsignedShortArrayA[structD->unsignedShortArrayA[0] = 1] = 0xFFFF;
    for (longA = 1 + 1; longA <= longC; ++longA) {
        structE = structC;
        unsignedShortA = (structF = (structC = structD))->unsignedShortArrayA;
        unsignedShortB = (structD = structE)->unsignedShortArrayA;
        longB = (unsignedLongA = 0);
        for (; structF->structA || 0xFFFF != *unsignedShortA;) {
            unsignedLongA += longA * *unsignedShortA++;
            *unsignedShortB++ = unsignedLongA % 10000;
            unsignedLongA /= 10000;
            if (++longB > 1000) {
                if (!structE->structA) {
                    structE->structA = malloc (sizeof (struct StructName));
                    structE->structA->structA = 0;
                    structE->structA->structB = 0;
                    structE->structA->structB = structE;
                }
                unsignedShortB = (structE = structE->structA)->unsignedShortArrayA;
                longB = 0;
                unsignedShortA = (structF = structF->structA)->unsignedShortArrayA;
            }
        }
        for (; unsignedLongA;) {
            *unsignedShortB++ = unsignedLongA % 10000;
            unsignedLongA /= 10000;
            if (++longB >= 1000) {
                if (!structE->structA) {
                    structE->structA = malloc (sizeof (struct StructName));
                    structE->structA->structA = 0;
                    structE->structA->structB = 0;
                    structE->structA->structB = structE;
                }
                unsignedShortB = (structE = structE->structA)->unsignedShortArrayA;
                longB = 0;
            }
        }
        *unsignedShortB = 0xFFFF;
    }
    for (longC = (longB = 1 - 1); (longC < 1000) && (structE->unsignedShortArrayA[longC] != 0xFFFF); ++longC) {
    }
    for (; structE; structE = structE->structB, longC = 1000) {
        for (--longC; longC >= 0; --longC, ++longB) {
            printf ((longB) ? ((longB % 19) ? "%04d" : (longB = 19, "\n%04d")) : "%4d", structE -> unsignedShortArrayA [longC]);
        }
    }
    putchar (10);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10143494_10143787_1_16
10143494_10143870_1_13
Title: Passing and modifying mutlidimensional arrays in C/C++ 
----------------------------------------

void faceRotateACW (char *face [CUBE_DIM] [CUBE_DIM]) {
    for (int i = 0; i < CUBE_DIM; ++i) {
        for (int j = i; j < CUBE_DIM; ++j) {
            char *tmpFace = face[i][j];
            face[i][j] = face[j][i];
            face[j][i] = tmpFace;
        }
        for (int j = 0; j < CUBE_DIM / 2; ++j) {
            char *tmpFace = face[i][j];
            face[i][j] = face[i][CUBE_DIM - 1 - j];
            face[i][CUBE_DIM - 1 - j] = tmpFace;
        }
    }
}
----------------------------------------

void faceRotateACW (char (*face) [CUBE_DIM] [CUBE_DIM]) {
    char tempFace [CUBE_DIM] [CUBE_DIM];
    for (int y = 0; y < CUBE_DIM; y++) {
        for (int x = 0; x < CUBE_DIM; x++) {
            tempFace[y][CUBE_DIM - 1 - x] = (*face)[x][y];
        }
    }
    for (int a = 0; a < CUBE_DIM; a++) {
        for (int b = 0; b < CUBE_DIM; b++) {
            (*face)[a][b] = tempFace[a][b];
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1015533_1015549_1_12
1015533_1016181_2_20
Title: simple C problem 
----------------------------------------

int main () {
    int x;
    int sum = 0;
    for (x = 1; x <= 1000; x++)
        if (x % 3 == 0 || x % 5 == 0)
            sum += x;
    printf ("%d\n", sum);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    int const mult3 = (1000 - 1) / 3;
    int const mult5 = (1000 - 1) / 5;
    int const mult15 = (1000 - 1) / 15;
    int sum3 = 0;
    int sum5 = 0;
    int sum15 = 0;
    int soln;
    for (i = 1; i <= mult3; i++) {
        sum3 += 3 * i;
    }
    for (i = 1; i <= mult5; i++) {
        sum5 += 5 * i;
    }
    for (i = 1; i <= mult15; i++) {
        sum15 += 15 * i;
    }
    soln = sum3 + sum5 - sum15;
    printf ("%d\n", soln);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10189845_10193120_12_30
10189845_32586850_12_35
Title: How to implement a timer in c? 
----------------------------------------

int main (int argc, char **argv) {
    struct sigaction sact;
    int num_sent = 0;
    sigemptyset & sact.sa_mask);
    sact.sa_flags = 0;
    sact.sa_handler = sigalrm_handler;
    sigaction (SIGALRM, & sact, NULL);
    alarm (60);
    while (!stop) {
        send_a_packet ();
        num_sent++;
    }
    printf ("sent %d packets\n", num_sent);
    exit (0);
}
----------------------------------------

int main () {
    struct sigaction sa;
    struct itimerval timer;
    memset (& sa, 0, sizeof (sa));
    sa.sa_handler = &timer_handler;
    sigaction (SIGVTALRM, & sa, NULL);
    timer.it_value.tv_sec = 1;
    timer.it_value.tv_usec = 0;
    timer.it_interval.tv_sec = 1;
    timer.it_interval.tv_usec = 0;
    setitimer (ITIMER_VIRTUAL, & timer, NULL);
    while (1)
        ;
    sleep (1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10203425_10203486_1_13
10203425_10203626_1_29
Title: Biggest of 3 numbers code confused me 
----------------------------------------

main () {
    int a, b, c;
    printf ("enter three numbers: ");
    scanf ("%d %d %d", & a, & b, & c);
    if (a > b && a > c)
        printf ("%d is greatest", a);
    else if (b > a && b > c)
        printf ("%d is greatest", b);
    else
        printf ("%d is greatest", c);
}
----------------------------------------

main () {
    int a, b, c;
    printf ("enter three numbers: ");
    scanf ("%d %d %d", & a, & b, & c);
    if (a >= b) {
        if (a >= c) {
            printf ("%d is greatest", a);
        }
        else {
            printf ("%d is greatest", c);
        }
    }
    else {
        if (b >= c) {
            printf ("%d is greatest", b);
        }
        else {
            printf ("%d is greatest", c);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10203425_10203486_1_13
10203425_10204259_1_20
Title: Biggest of 3 numbers code confused me 
----------------------------------------

main () {
    int a, b, c;
    printf ("enter three numbers: ");
    scanf ("%d %d %d", & a, & b, & c);
    if (a > b && a > c)
        printf ("%d is greatest", a);
    else if (b > a && b > c)
        printf ("%d is greatest", b);
    else
        printf ("%d is greatest", c);
}
----------------------------------------

main () {
    int a, b, c;
    printf ("enter three numbers");
    scanf ("%d %d %d", & a, & b, & c);
    if (a > b && a > c)
        printf ("%d is greatest\n", a);
    else if (b > c)
        printf ("%d is greatest\n", b);
    else
        printf ("%d is greatest\n", c);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10203425_10203626_1_29
10203425_10204259_1_20
Title: Biggest of 3 numbers code confused me 
----------------------------------------

main () {
    int a, b, c;
    printf ("enter three numbers: ");
    scanf ("%d %d %d", & a, & b, & c);
    if (a >= b) {
        if (a >= c) {
            printf ("%d is greatest", a);
        }
        else {
            printf ("%d is greatest", c);
        }
    }
    else {
        if (b >= c) {
            printf ("%d is greatest", b);
        }
        else {
            printf ("%d is greatest", c);
        }
    }
}
----------------------------------------

main () {
    int a, b, c;
    printf ("enter three numbers");
    scanf ("%d %d %d", & a, & b, & c);
    if (a > b && a > c)
        printf ("%d is greatest\n", a);
    else if (b > c)
        printf ("%d is greatest\n", b);
    else
        printf ("%d is greatest\n", c);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10223900_10224080_1_20
10223900_10224273_11_24
Title: execv call in C 
----------------------------------------

int main (int argc, char *argv []) {
    sigset_t signal_mask;
    signal (SIGHUP, hup_func);
    sigaddset (& signal_mask, SIGHUP);
    sigprocmask (SIG_UNBLOCK, & signal_mask, NULL);
    args = argv;
    a = args[0];
    printf ("%s\n", a);
    while (1) {
        printf ("test\n");
        sleep (10);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int b = 0;
    printf ("setting signal handler for SIGHUP\n");
    signal (SIGHUP, hup_func);
    args = argv;
    a = argv[0];
    printf ("Before entering while %s\n", a);
    while (1) {
        printf ("In while %d\n", ++ b);
        sleep (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10238670_28273096_3_16
10238670_44921997_5_35
Title: C/C++ program that prints its own source code as its output 
----------------------------------------

int main (void) {
    char a [20], ch;
    FILE *fp;
    sprintf (a, __FILE__);
    fp = fopen (a, "r");
    while ((ch = fgetc (fp)) != EOF)
        printf ("%c", ch);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char q = 34;
    string l [] = {" ", "#include <iostream>       //1 line   ", "#include <string>     //2 line    ", "using namespace std;      //3 line    ", "              //4 line    ", "int main(int argc, char* argv[])  //5th line  ", "{", "        char q = 34;          //7th line  ", "        string l[] = {        //8th line  ", "        };                //9th resume printing end part of code  ", "        for(int i = 0; i < 9; i++)        //10th first half code ", "                cout << l[i] << endl;     //11th line", "        for(int i = 0; i < 18; i++)   //12th whole code ", "                cout << l[0] + q + l[i] + q + ',' << endl;    13th line", "        for(int i = 9; i < 18; i++)   //14th last part of code", "                cout << l[i] << endl;     //15th line", "        return 0;         //16th line", "}             //17th line",};
    for (int i = 0; i < 9; i++)
        cout << l[i] << endl;
    for (int i = 0; i < 18; i++)
        cout << l[0] + q + l[i] + q + ',' << endl;
    13th
    line for (int i = 9;
    i < 18;
    i ++) cout << l [i] << endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1024389_1024396_4_23
1024389_1024446_4_18
Title: Print an int in binary representation using C 
----------------------------------------

char *int2bin (unsigned n, char *buf) {
    static char static_buf [BITS + 1];
    int i;
    if (buf == NULL)
        buf = static_buf;
    for (i = BITS - 1; i >= 0; --i) {
        buf[i] = (n & 1) ? '1' : '0';
        n >>= 1;
    }
    buf[BITS] = '\0';
    return buf;
}
----------------------------------------

char *int2bin (int i) {
    size_t bits = sizeof (int) * CHAR_BIT;
    char *str = malloc (bits +1);
    if (!str)
        return NULL;
    str[bits] = 0;
    unsigned u = *(unsigned*) &i;
    for (; bits--; u >>= 1)
        str[bits] = u & 1 ? '1' : '0';
    return str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1024389_1024417_51_63
1024389_27842273_1_23
Title: Print an int in binary representation using C 
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    for (i = 0; i < 32; ++i) {
        printf ("%d = ", i);
        printbits (i);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int number, i, size, mask;
    size = sizeof (int);
    mask = 1 << (size * 8 - 1);
    printf ("Enter integer: ");
    scanf ("%d", & number);
    printf ("Integer is :\t%d 0x%X\n", number, number);
    printf ("Bin format :\t");
    for (i = 0; i < size * 8; ++i) {
        if ((i % 4 == 0) && (i != 0)) {
            printf (" ");
        }
        printf ("%u", number & mask ? 1 : 0);
        number = number << 1;
    }
    printf ("\n");
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10309107_10310401_64_90
10309107_37084580_6_21
Title: C program days between two dates 
----------------------------------------

int main (void) {
    dt d2 = {28, 10, 2018};
    dt d1 = {30, 6, 2006};
    int days;
    int d1_pt = 0, d2_pt = 0;
    if (d1.year > d2.year)
        d1_pt += 100;
    else
        d2_pt += 100;
    if (d1.month > d2.month)
        d1_pt += 10;
    else
        d2_pt += 10;
    if (d1.day > d2.day)
        d1_pt += 1;
    else
        d2_pt += 1;
    days = (d1_pt > d2_pt) ? minus (d1, d2) : minus (d2, d1);
    print_dt (d1);
    print_dt (d2);
    printf ("number of days: %d \n", days);
    return 0;
}
----------------------------------------

int main (int argc, char const *argv []) {
    int days_add, days_sub, c_date, c_month, b_date, b_month, c_year, b_year;
    cout << "Current Date(dd mm yyyy): ";
    cin >> c_date >> c_month >> c_year;
    cout << "Birth Date(dd mm yyyy): ";
    cin >> b_date >> b_month >> b_year;
    int offset_month [12] = {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
    days_add = c_date + offset_month[c_month - 1];
    days_sub = b_date + offset_month[b_month - 1];
    int total_days = (c_year - b_year) * 365.2422 + days_add - days_sub + 1;
    cout << "Total days: " << total_days << "\n";
    int total_seconds = total_days * 24 * 60 * 60;
    cout << "Total seconds: " << total_seconds << "\n";
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10313759_10314030_18_31
10313759_10314283_15_32
Title: LinkedList adding Element 
----------------------------------------

void addLL (LL *head) {
    LL *newNode;
    LL *tail = getLastNode (head);
    newNode = malloc (sizeof (LL));
    if (newNode != NULL) {
        newNode->next = NULL;
        if (!head)
            head = newNode;
        else
            tail->next = newNode;
    }
}
----------------------------------------

void addLL (LL **head) {
    LL *newNode;
    LL *tail = getLastNode (*head);
    newNode = malloc (sizeof (LL));
    if (newNode != DEF_NULL) {
        newNode->ID = -1;
        newNode->TCB = -1;
        newNode->next = DEF_NULL;
        if (!*head)
            *head = newNode;
        else
            tail->next = newNode;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10313759_10314030_33_43
10313759_10314283_46_57
Title: LinkedList adding Element 
----------------------------------------

int countLL (LL *head) {
    int elements = 0;
    LL *temp = head;
    while (temp->next != NULL) {
        temp = temp->next;
        elements++;
    }
    return elements;
}
----------------------------------------

int countLL (LL *head) {
    int elements = 0;
    LL *temp = head;
    if (head) {
        do {
            temp = temp->next;
            elements++;
        }
        while (temp != DEF_NULL);
    }
    return elements;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10313759_10314195_41_54
10313759_10314283_59_69
Title: LinkedList adding Element 
----------------------------------------

int main () {
    unsigned count;
    addLL (& globhead);
    count = countLL (globhead);
    printf ("count = %u\n", count);
    addLL (& globhead);
    count = countLL (globhead);
    printf ("count = %u\n", count);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    LL *list = 0;
    printf ("LL test\n");
    addLL (& list);
    printf ("length = %d\n", countLL (list));
    addLL (& list);
    printf ("length = %d\n", countLL (list));
    addLL (& list);
    printf ("length = %d\n", countLL (list));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10345263_10349953_10_28
10345263_10352530_9_32
Title: Validating CSV format 
----------------------------------------

bool isValid (char *str) {
    if (*str == '\n')
        return true;
    if (*str == ' ') {
        while (*++str == ' ')
            ;
        if (*str == '\n')
            return true;
        else
            return false;
    }
    if (isdigit (*str++)) {
        do {
            if (*str == '\n')
                return true;
        }
        while (*str++ == ',' && isdigit (*str++));
        return false;
    }
    return false;
}
----------------------------------------

bool isValid (FILE *fp) {
    int ch;
    while (EOF != (ch = fgetc (fp))) {
        if (ch == '\n')
            continue;
        if (ch == ' ') {
            while ((ch = fgetc (fp)) == ' ')
                ;
            if (ch == '\n')
                continue;
            else
                return false;
        }
        if (isdigit (ch)) {
            do {
                if ((ch = fgetc (fp)) == '\n')
                    goto cont;
            }
            while (ch == ',' && isdigit (fgetc (fp)));
            return false;
        }
        return false;
    cont :
        ;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10345263_10349953_32_67
10345263_10352530_34_47
Title: Validating CSV format 
----------------------------------------

int main (void) {
    char line [BUFF_SIZE];
redo :
    fgets (line, BUFF_SIZE, stdin);
    if (NULL == strchr (line, '\n')) {
        fprintf (stderr, "You have exceeded the number of characters that can be entered.\n");
        fflush (stdin);
        goto redo;
    }
    if (isValid (line))
        printf ("OK\n");
    else
        printf ("NG\n");
    return 0;
}
----------------------------------------

int main (void) {
    FILE *file;
    file = stdin;
    if (isValid (file))
        printf ("OK");
    else
        printf ("NG");
    fclose (file);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10345263_10349953_32_67
10345263_10355042_5_28
Title: Validating CSV format 
----------------------------------------

int main (void) {
    char line [BUFF_SIZE];
redo :
    fgets (line, BUFF_SIZE, stdin);
    if (NULL == strchr (line, '\n')) {
        fprintf (stderr, "You have exceeded the number of characters that can be entered.\n");
        fflush (stdin);
        goto redo;
    }
    if (isValid (line))
        printf ("OK\n");
    else
        printf ("NG\n");
    return 0;
}
----------------------------------------

int main (void) {
    int ch;
    while (EOF != (ch = getchar ())) {
        if (ch == ' ') {
            while (' ' == (ch = getchar ()))
                ;
            goto CR;
        }
        if (isdigit (ch)) {
            while (',' == (ch = getchar ()))
                if (isdigit (getchar ()))
                    continue;
                else
                    goto NG;
            goto CR;
        }
    CR :
        if (ch != '\n')
            goto NG;
    }
    printf ("OK");
    return EXIT_SUCCESS;
NG :
    printf ("NG");
    return EXIT_FAILURE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10345263_10349953_32_67
10345263_10370347_8_54
Title: Validating CSV format 
----------------------------------------

int main (void) {
    char line [BUFF_SIZE];
redo :
    fgets (line, BUFF_SIZE, stdin);
    if (NULL == strchr (line, '\n')) {
        fprintf (stderr, "You have exceeded the number of characters that can be entered.\n");
        fflush (stdin);
        goto redo;
    }
    if (isValid (line))
        printf ("OK\n");
    else
        printf ("NG\n");
    return 0;
}
----------------------------------------

int main (void) {
    int ch;
    Status pre_stat, stat;
    pre_stat = stat = START;
    while (EOF != (ch = getchar ())) {
        switch (ch) {
        case '\n' :
            stat = CR;
            if (pre_stat == START || pre_stat == SPC || pre_stat == NUM) {
                pre_stat = START;
            }
            else
                goto NG;
            break;
        case ' ' :
            stat = SPC;
            if (pre_stat == START || pre_stat == SPC) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        case '0' :
        case '1' :
        case '2' :
        case '3' :
        case '4' :
        case '5' :
        case '6' :
        case '7' :
        case '8' :
        case '9' :
            stat = NUM;
            if (pre_stat == START || pre_stat == COMMA) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        case ',' :
            stat = COMMA;
            if (pre_stat == NUM) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        default :
            goto NG;
        }
    }
    printf ("OK");
    return EXIT_SUCCESS;
NG :
    printf ("NG");
    return EXIT_FAILURE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10345263_10352530_34_47
10345263_10355042_5_28
Title: Validating CSV format 
----------------------------------------

int main (void) {
    FILE *file;
    file = stdin;
    if (isValid (file))
        printf ("OK");
    else
        printf ("NG");
    fclose (file);
    return 0;
}
----------------------------------------

int main (void) {
    int ch;
    while (EOF != (ch = getchar ())) {
        if (ch == ' ') {
            while (' ' == (ch = getchar ()))
                ;
            goto CR;
        }
        if (isdigit (ch)) {
            while (',' == (ch = getchar ()))
                if (isdigit (getchar ()))
                    continue;
                else
                    goto NG;
            goto CR;
        }
    CR :
        if (ch != '\n')
            goto NG;
    }
    printf ("OK");
    return EXIT_SUCCESS;
NG :
    printf ("NG");
    return EXIT_FAILURE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10345263_10352530_34_47
10345263_10370347_8_54
Title: Validating CSV format 
----------------------------------------

int main (void) {
    FILE *file;
    file = stdin;
    if (isValid (file))
        printf ("OK");
    else
        printf ("NG");
    fclose (file);
    return 0;
}
----------------------------------------

int main (void) {
    int ch;
    Status pre_stat, stat;
    pre_stat = stat = START;
    while (EOF != (ch = getchar ())) {
        switch (ch) {
        case '\n' :
            stat = CR;
            if (pre_stat == START || pre_stat == SPC || pre_stat == NUM) {
                pre_stat = START;
            }
            else
                goto NG;
            break;
        case ' ' :
            stat = SPC;
            if (pre_stat == START || pre_stat == SPC) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        case '0' :
        case '1' :
        case '2' :
        case '3' :
        case '4' :
        case '5' :
        case '6' :
        case '7' :
        case '8' :
        case '9' :
            stat = NUM;
            if (pre_stat == START || pre_stat == COMMA) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        case ',' :
            stat = COMMA;
            if (pre_stat == NUM) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        default :
            goto NG;
        }
    }
    printf ("OK");
    return EXIT_SUCCESS;
NG :
    printf ("NG");
    return EXIT_FAILURE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10345263_10355042_5_28
10345263_10370347_8_54
Title: Validating CSV format 
----------------------------------------

int main (void) {
    int ch;
    while (EOF != (ch = getchar ())) {
        if (ch == ' ') {
            while (' ' == (ch = getchar ()))
                ;
            goto CR;
        }
        if (isdigit (ch)) {
            while (',' == (ch = getchar ()))
                if (isdigit (getchar ()))
                    continue;
                else
                    goto NG;
            goto CR;
        }
    CR :
        if (ch != '\n')
            goto NG;
    }
    printf ("OK");
    return EXIT_SUCCESS;
NG :
    printf ("NG");
    return EXIT_FAILURE;
}
----------------------------------------

int main (void) {
    int ch;
    Status pre_stat, stat;
    pre_stat = stat = START;
    while (EOF != (ch = getchar ())) {
        switch (ch) {
        case '\n' :
            stat = CR;
            if (pre_stat == START || pre_stat == SPC || pre_stat == NUM) {
                pre_stat = START;
            }
            else
                goto NG;
            break;
        case ' ' :
            stat = SPC;
            if (pre_stat == START || pre_stat == SPC) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        case '0' :
        case '1' :
        case '2' :
        case '3' :
        case '4' :
        case '5' :
        case '6' :
        case '7' :
        case '8' :
        case '9' :
            stat = NUM;
            if (pre_stat == START || pre_stat == COMMA) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        case ',' :
            stat = COMMA;
            if (pre_stat == NUM) {
                pre_stat = stat;
            }
            else
                goto NG;
            break;
        default :
            goto NG;
        }
    }
    printf ("OK");
    return EXIT_SUCCESS;
NG :
    printf ("NG");
    return EXIT_FAILURE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10348239_23537110_2_17
10348239_23555496_2_39
Title: a c program that converts decimal to 36 different bases but there's a simple error 
----------------------------------------

main () {
    int n, rem, m = 0, i;
    int a [100], base;
    scanf ("%d%d", & n, & base);
    while (n) {
        rem = n % base;
        if (rem < 10)
            a[m++] = rem + '0';
        else
            a[m++] = 'A' + rem - 10;
        n /= base;
    }
    while (m--)
        printf ("%c", a[m]);
}
----------------------------------------

main () {
    int rem, m = 0, i, n;
    int a [100], base;
    float num, t, j;
    scanf ("%f%d", & num, & base);
    n = (int) num;
    t = num - n;
    j = 1.0 / base;
    while (n) {
        rem = n % base;
        if (rem < 10)
            a[m++] = rem + '0';
        else
            a[m++] = 'A' + rem - 10;
        n /= base;
    }
    while (m--)
        printf ("%c", a[m]);
    printf (".");
    m = 0;
    while (t > 0.00001) {
        rem = 0;
        if (t > j) {
            for (i = 1; (j * i) < t; i++)
                ;
            rem = i - 1;
        }
        if (rem == 0)
            a[m++] = 0;
        else if (rem < 10)
            a[m++] = rem + '0';
        else
            a[m++] = 'A' + rem - 10;
        t -= (j * rem);
        j /= base;
    }
    for (i = 0; i < m; i++)
        printf ("%c", a[i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10350520_10350769_3_26
10350520_10352537_4_14
Title: using timer for delay 
----------------------------------------

void Delay (int amount) {
    int start = TimerReg;
    int elapsed;
    int rolled_over = 0;
    int last_time = start;
    do {
        int timer_reg = TimerReg;
        if (last_time > timer_reg) {
            rolled_over += ROLLOVER_INTERVAL - start;
            start = 0;
        }
        last_time = timer_reg;
        if (rolled_over == 0) {
            elapsed = timer_reg - start;
        }
        else {
            elapsed = timer_reg + rolled_over;
        }
    }
    while (elapsed < amount);
}
----------------------------------------

void Delay (int amount) {
    int start = TimerReg;
    int elapsed;
    do {
        eleapsed = TimerReg - start;
        if (elapsed < 0)
            eplapsed += (TimerMaxValue + 1);
    }
    while (elapsed < amount);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10352953_10353169_1_12
10352953_10353586_2_24
Title: C using malloc and duplicating array 
----------------------------------------

student_record *answer4 (student_record *p, unsigned int n) {
    uint8_t *data, *pos;
    size_t size = sizeof (student_record);
    data = malloc (size *n);
    pos = data;
    for (unsigned int i = 0; i < n; i++, pos = &pos[size])
        memcpy (pos, p, size);
    return (student_record *) data;
}
----------------------------------------

student_record *answer4 (student_record *student, unsigned int n) {
    student_record *Result = NULL;
    student_record *Result = malloc (sizeof (student_record) * n);
    student_record *dest = Result;
    int i;
    for (i = 0; i < n; i++) {
        *dest = *student;
        dest++;
    }
    return Result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10369434_10369602_1_21
10369434_10369604_1_24
Title: 2 questions on typedef struct and averages on grades. Am I doing it correctly In C? 
----------------------------------------

double getGrades () {
    double average;
    double grade;
    double total = 0;
    int count = 0;
    while (1) {
        printf ("Enter grade: ");
        scanf ("%d", & grade);
        if (grade < 0) {
            if (count == 0) {
                average = 0;
                break;
            }
            average = total / count;
            break;
        }
        count++;
        total += grade;
    }
    return average;
}
----------------------------------------

double getGrades (int *max) {
    int sum = 0;
    int input;
    int i = 0;
    *max = 0;
    printf ("Enter Grade #%d:\n", i + 1);
    scanf ("%d", & input);
    while (input > 0) {
        if (*max < input) {
            *max = input;
        }
        sum = sum + input;
        i++;
        printf ("Enter Grade #%d:\n", i + 1);
        scanf ("%d", & input);
    }
    return i ? ((double) sum / i) : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10376147_10376195_16_54
10376147_10398759_12_37
Title: Accessing dynamically allocated nested struct in C 
----------------------------------------

int main (int argc, char *argv []) {
    int i = 0;
    outer *outerArray;
    outer2 *outer2Array;
    outer *outerReference;
    outer2 *outer2Reference;
    outerArray = malloc (20 * sizeof (outer));
    for (i = 0; i < 10; ++i) {
        outerReference = outerArray + i;
        sprintf (outerReference -> innerStruct.address, "outer struct %d", i);
    }
    outer2Array = malloc (20 * sizeof (outer2));
    for (i = 0; i < 10; ++i) {
        outer2Reference = outer2Array + i;
        outer2Reference->innerStruct = malloc (sizeof (inner));
        sprintf (outer2Reference -> innerStruct -> address, "outer2 struct %d", i);
    }
    for (i = 0; i < 10; ++i) {
        printf ("outer: %-20s, outer2: %-20s\n", outerArray [i].innerStruct.address, outer2Array [i].innerStruct -> address);
        free (outer2Array [i].innerStruct);
    }
    free (outer2Array);
    free (outerArray);
    return 0;
}
----------------------------------------

int main () {
    int i = 0;
    outer *outerArray;
    outer *outerReference;
    outerArray = malloc (20 * sizeof (*outerArray));
    for (i = 0; i < 10; i++) {
        outerReference = outerArray + i;
        outerReference->innerStruct = malloc (10 * sizeof (*outerReference->innerStruct));
    }
    printf ("address: '%s'\n", outerArray [3].innerStruct [4].address);
    strcpy (outerArray [3].innerStruct [4].address, "<emtpy>");
    printf ("address: '%s'\n", outerArray [3].innerStruct [4].address);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1042110_12762166_3_15
1042110_43788768_29_41
Title: Using scanf() in C++ programs is faster than using cin? 
----------------------------------------

int main (int argc, char **argv) {
    int parity = 0;
    int x;
std :
    : ios : : sync_with_stdio (false);
    while (std : : cin >> x) parity ^= x;
std :
    : cout << parity << std : : endl;
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int parity = 0;
    unsigned int x;
    while (1 != (scanuint (&x))) {
        parity ^= x;
    }
    parity ^= x;
    printf ("%d\n", parity);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10456654_28849279_4_47
10456654_29707300_4_32
Title: Print star ('*') diamond in C with nested loops? 
----------------------------------------

int main () {
    int n = 0, star = 0, space = 0, ct2 = 0, ct3 = 1;
    cin >> n;
    ct2 = n / 2;
    for (int ct = 0; ct < (n / 2); ct++) {
        for (space; space < ct2; space++) {
            cout << " ";
        }
        ct2--;
        space = 0;
        for (star; star < ct3; star++) {
            cout << "*";
        }
        ct3 += 2;
        star = 0;
        cout << endl;
    }
    ct3 = n;
    ct2 = 0;
    space = 0;
    star = 0;
    for (int ct = 0; ct < (n / 2); ct++) {
        for (star; star < ct3; star++) {
            cout << "*";
        }
        cout << endl;
        ct3 -= 2;
        star = 0;
        ct2++;
        space = 0;
        for (space; space < ct2; space++) {
            cout << " ";
        }
    }
    cout << "*" << endl;
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int num, middle, spaceCount, starCount;
    printf ("Enter a num:");
    scanf ("%d", & num);
    middle = (num - 1) / 2;
    for (int i = 0; i < num; i++) {
        spaceCount = abs (middle -i);
        starCount = num - 2 * abs (middle -i);
        for (int c = 0; c < spaceCount; c++)
            printf (" ");
        for (int c = 0; c < starCount; c++)
            printf ("*");
        for (int c = 0; c < spaceCount; c++)
            printf (" ");
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10456654_28849279_4_47
10456654_30365495_5_41
Title: Print star ('*') diamond in C with nested loops? 
----------------------------------------

int main () {
    int n = 0, star = 0, space = 0, ct2 = 0, ct3 = 1;
    cin >> n;
    ct2 = n / 2;
    for (int ct = 0; ct < (n / 2); ct++) {
        for (space; space < ct2; space++) {
            cout << " ";
        }
        ct2--;
        space = 0;
        for (star; star < ct3; star++) {
            cout << "*";
        }
        ct3 += 2;
        star = 0;
        cout << endl;
    }
    ct3 = n;
    ct2 = 0;
    space = 0;
    star = 0;
    for (int ct = 0; ct < (n / 2); ct++) {
        for (star; star < ct3; star++) {
            cout << "*";
        }
        cout << endl;
        ct3 -= 2;
        star = 0;
        ct2++;
        space = 0;
        for (space; space < ct2; space++) {
            cout << " ";
        }
    }
    cout << "*" << endl;
    return 0;
}
----------------------------------------

int main () {
    int numStars = 1, numSpaces = 10;
    while (numSpaces > 0) {
        for (int i = 0; i < numSpaces; i++) {
            cout << " ";
        }
        for (int i = 0; i < numStars; i++) {
            cout << "*";
        }
        cout << "\n";
        numStars += 2;
        numSpaces--;
    }
    while (numStars > 0) {
        for (int i = 0; i < numSpaces; i++) {
            cout << " ";
        }
        for (int i = 0; i < numStars; i++) {
            cout << "*";
        }
        cout << "\n";
        numStars -= 2;
        numSpaces++;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10456654_29369516_2_23
10456654_40255657_2_73
Title: Print star ('*') diamond in C with nested loops? 
----------------------------------------

main () {
    int i, j, k, n;
    scanf ("%d", & n);
    n = (n + 1) / 2;
    for (i = 1; i <= n; i++) {
        for (j = n; j >= i; j--)
            printf (" ");
        for (k = 1; k <= (2 * i - 1); k++)
            printf ("*");
        printf ("\n");
    }
    for (i = 1; i <= (n - 1); i++) {
        for (j = 0; j <= i; j++)
            printf (" ");
        for (k = (2 * n - 3); k >= (2 * i - 1); k--)
            printf ("*");
        printf ("\n");
    }
}
----------------------------------------

main () {
    int n, i, j;
    printf ("Enter a number: ");
    scanf ("%d", & n);
    for (i = 1; i <= n; i++) {
        for (j = i; j <= n + 1; j++) {
            printf (" ");
        }
        for (j = 1; j <= 1; j++) {
            printf ("*");
        }
        for (j = 1; j < i - 1; j++) {
            printf (" ");
        }
        for (j = 1; j < i; j++) {
            printf (" ");
        }
        for (j = 1; j <= 1; j++) {
            if (i != n - (n - 1))
                printf ("*");
        }
        printf ("\n");
    }
    for (i = 1; i <= n; i++) {
        for (j = 1; j <= i + 2; j++) {
            printf (" ");
        }
        for (j = 1; j <= 1; j++) {
            if (i != n)
                printf ("*");
        }
        for (j = i; j < n - 2; j++) {
            printf (" ");
        }
        for (j = i; j < n - 1; j++) {
            printf (" ");
        }
        for (j = 1; j <= 1; j++) {
            if (i < n - 1)
                printf ("*");
        }
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10456654_29707300_4_32
10456654_30365495_5_41
Title: Print star ('*') diamond in C with nested loops? 
----------------------------------------

int main (int argc, char **argv) {
    int num, middle, spaceCount, starCount;
    printf ("Enter a num:");
    scanf ("%d", & num);
    middle = (num - 1) / 2;
    for (int i = 0; i < num; i++) {
        spaceCount = abs (middle -i);
        starCount = num - 2 * abs (middle -i);
        for (int c = 0; c < spaceCount; c++)
            printf (" ");
        for (int c = 0; c < starCount; c++)
            printf ("*");
        for (int c = 0; c < spaceCount; c++)
            printf (" ");
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int numStars = 1, numSpaces = 10;
    while (numSpaces > 0) {
        for (int i = 0; i < numSpaces; i++) {
            cout << " ";
        }
        for (int i = 0; i < numStars; i++) {
            cout << "*";
        }
        cout << "\n";
        numStars += 2;
        numSpaces--;
    }
    while (numStars > 0) {
        for (int i = 0; i < numSpaces; i++) {
            cout << " ";
        }
        for (int i = 0; i < numStars; i++) {
            cout << "*";
        }
        cout << "\n";
        numStars -= 2;
        numSpaces++;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10466036_10466128_20_31
10466036_10466160_9_22
Title: Slide Algorithm 
----------------------------------------

int main (void) {
    int i;
    int arr [] = {1, 2, 3, 4, 5};
    slide_arr (arr, _countof (arr), 2);
    for (i = 0; i < _countof (arr); i++) {
        printf ("%d, ", arr [i]);
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    int i;
    int size = 4;
    int arr [4] = {1, 2, 3, 4};
    for (i = 0; i < size; i++) {
        printf ("%d, ", arr [i]);
    }
    printf ("\n");
    for (i = size - 1; i > 0; i--) {
        swap (& arr [i], & arr [i - 1]);
    }
    for (i = 0;
    i < size;
    i ++) {printf ("%d, ", arr [i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10466036_10466128_20_31
10466036_12720745_2_15
Title: Slide Algorithm 
----------------------------------------

int main (void) {
    int i;
    int arr [] = {1, 2, 3, 4, 5};
    slide_arr (arr, _countof (arr), 2);
    for (i = 0; i < _countof (arr); i++) {
        printf ("%d, ", arr [i]);
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    int i;
    int len = 5;
    int arr = {1, 2, 3, 4, 5};
    int last = arr[len - 1];
    for (i = len - 1; i > 0; i--)
        arr[i] = arr[i - 1];
    arr[0] = last;
    retrurn 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10466036_10466160_9_22
10466036_12720745_2_15
Title: Slide Algorithm 
----------------------------------------

int main () {
    int i;
    int size = 4;
    int arr [4] = {1, 2, 3, 4};
    for (i = 0; i < size; i++) {
        printf ("%d, ", arr [i]);
    }
    printf ("\n");
    for (i = size - 1; i > 0; i--) {
        swap (& arr [i], & arr [i - 1]);
    }
    for (i = 0;
    i < size;
    i ++) {printf ("%d, ", arr [i]);
}
----------------------------------------

int main () {
    int i;
    int len = 5;
    int arr = {1, 2, 3, 4, 5};
    int last = arr[len - 1];
    for (i = len - 1; i > 0; i--)
        arr[i] = arr[i - 1];
    arr[0] = last;
    retrurn 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10490257_10490542_3_16
10490257_10491020_1_11
Title: Conversion from ASCII bit model to magnitude-only bit model 
----------------------------------------

int main (void) {
    char n [10];
    int x = 0;
redo :
    printf ("Enter three digit, nonnegative: ");
    if (4 != scanf ("%1[1-9]%1[0-9]%1[0-9]%1[\n]", &n[0], &n[1], &n[2], &n[3])) {
        fflush (stdin);
        goto redo;
    }
    x = 100 * (n[0] - '0') + 10 * (n[1] - '0') + (n[2] - '0');
    printf ("The number is %d\n", x);
    return 0;
}
----------------------------------------

int main () {
    int x;
    printf ("Enter three digit, nonnegative: ");
    while (scanf ("%d", &x) != 1 || x < 100 || x > 999) {
        printf ("Not a valid input, try again: ");
        fflush (stdin);
    }
    printf ("The number is %d\n", x);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10490257_10490542_3_16
10490257_18108493_3_19
Title: Conversion from ASCII bit model to magnitude-only bit model 
----------------------------------------

int main (void) {
    char n [10];
    int x = 0;
redo :
    printf ("Enter three digit, nonnegative: ");
    if (4 != scanf ("%1[1-9]%1[0-9]%1[0-9]%1[\n]", &n[0], &n[1], &n[2], &n[3])) {
        fflush (stdin);
        goto redo;
    }
    x = 100 * (n[0] - '0') + 10 * (n[1] - '0') + (n[2] - '0');
    printf ("The number is %d\n", x);
    return 0;
}
----------------------------------------

int main (void) {
    char buf [10], *endp;
    unsigned long n;
    int c;
    for (;;) {
        fputs ("Enter three digit, nonnegative: ", stdout);
        fgets (buf, sizeof buf, stdin);
        n = strtoul (buf, &endp, 10);
        if (n <= 999 && *endp == '\n')
            break;
        puts ("?Redo from start");
        do
            c = getchar ();
        while (c != '\n' && c != EOF);
    }
    printf ("The number is %lu\n", n);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10490257_10491020_1_11
10490257_18108493_3_19
Title: Conversion from ASCII bit model to magnitude-only bit model 
----------------------------------------

int main () {
    int x;
    printf ("Enter three digit, nonnegative: ");
    while (scanf ("%d", &x) != 1 || x < 100 || x > 999) {
        printf ("Not a valid input, try again: ");
        fflush (stdin);
    }
    printf ("The number is %d\n", x);
    return 0;
}
----------------------------------------

int main (void) {
    char buf [10], *endp;
    unsigned long n;
    int c;
    for (;;) {
        fputs ("Enter three digit, nonnegative: ", stdout);
        fgets (buf, sizeof buf, stdin);
        n = strtoul (buf, &endp, 10);
        if (n <= 999 && *endp == '\n')
            break;
        puts ("?Redo from start");
        do
            c = getchar ();
        while (c != '\n' && c != EOF);
    }
    printf ("The number is %lu\n", n);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10492152_10492224_4_15
10492152_10492517_4_37
Title: "pointer to array  assign array" 
----------------------------------------

int main () {
    int a [] = {1, 2};
    int b [] = {3, 4};
    int **ptr;
    ptr = (int **) malloc (sizeof (int *) * 2);
    ptr[0] = a;
    ptr[1] = b;
    printf ("%3d %3d\n", ptr [0] [1], ptr [1] [1]);
    free (ptr);
}
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    int a [] = {1, 2};
    int b [] = {3, 4};
    int *ptr [2];
    ptr[0] = (int *) malloc (sizeof (int *) * 2);
    ptr[1] = (int *) malloc (sizeof (int *) * 5);
    for (i = 0; i < 2; i++)
        ptr[0][i] = i;
    for (i = 0; i < 5; i++)
        ptr[1][i] = i;
    for (i = 0; i < 2; i++)
        printf ("ptr[0][%03d] = %03d\n", i, ptr[0][i]);
    printf ("\n");
    for (i = 0; i < 5; i++)
        printf ("ptr[1][%03d] = %03d\n", i, ptr[1][i]);
    free (ptr [0]);
    free (ptr [1]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10522277_10523090_6_42
10522277_10572605_13_36
Title: How can I implement timeout for read() when reading from a serial port (C/C++) 
----------------------------------------

int main (void) {
    int fd = open ("/dev/ttyS0", O_RDWR | O_NOCTTY | O_NDELAY);
    char buf [10];
    int done = 0, inbuf = 0;
    struct timeval start, now;
    gettimeofday (& start, NULL);
    while (!done) {
        int bytesRead = read (fd, &buf[inbuf], sizeof buf - inbuf);
        if (bytesRead < 0) {
            error_processing_here ();
            continue;
        }
        if (bytesRead == 0) {
            gettimeofday (& now, NULL);
            if ((now.tv.sec - start.tv_sec) * 1000000 + now.tv.usec - start.tv_usec > timeout_value_in_microsecs) {
                done = 2;
                continue;
            }
            sleep (1);
            continue;
        }
        inbuf += bytesRead;
        if (we have read all we want) done = 1;
    }
    if (done == 2)
        timeout_condition_handling ();
    close (fd);
    return 0;
}
----------------------------------------

int main (void) {
    int fd = open ("/dev/ttyS0", O_RDWR | O_NOCTTY);
    char buf [1];
    if (signal (SIGALRM, sig_alarm) == SIG_ERR) {
        exit (0);
    }
    if (setjmp (env_alarm) != 0) {
        close (fd);
        printf ("Timeout Or Error\n");
        exit (0);
    }
    alarm (1);
    int bytesRead = read (fd, buf, 1);
    alarm (0);
    close (fd);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1053582_22157537_2_27
1053582_26586617_3_14
Title: How does this bitwise operation check for a power of 2? 
----------------------------------------

void main (void) {
    unsigned int a;
    unsigned int count = 0 unsigned int check = 1;
    unsigned int position = 0;
    unsigned int temp;
    for (i = 0; i < sizeof (int) * 8; i++) {
        temp = a & (check << i);
        if (temp) {
            position = i;
            count++;
        }
    }
    if (count == 1) {
        printf ("%d is 2 to the power of %d", a, position);
    }
    else {
        printf ("Not a power of 2");
    }
}
----------------------------------------

void main () {
    int a = 8;
    if ((a & (a - 1)) == 0) {
        printf ("the bit is power of 2  \n");
    }
    else {
        printf ("the bit is not power of 2\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10564670_10565120_10_44
10564670_45641442_7_23
Title: Is there any way to compile additional code at runtime in C or C++? 
----------------------------------------

int main (int argc, char **argv) {
    ofstream f ("tmp.cpp");
    f << "#include<stdlib.h>\n#include \"structs.h\"\n extern \"C\" void F(S &s) { s.a += s.a; s.b *= s.b; }\n";
    f.close ();
    system ("/usr/bin/gcc -shared tmp.cpp -o libtmp.so");
    void *fLib = dlopen ("./libtmp.so", RTLD_LAZY);
    if (!fLib) {
        cerr << "Cannot open library: " << dlerror () << '\n';
    }
    if (fLib) {
        int (* fn) (S &) = dlsym (fLib, "F");
        if (fn) {
            for (int i = 0; i < 11; i++) {
                S s;
                s.a = i;
                s.b = i;
                fn (s);
                cout << s.a << " " << s.b << endl;
            }
        }
        dlclose (fLib);
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    cl_int e = 0;
    cl_platform_id platform = 0;
    cl_device_id device = 0;
    e = clGetPlatformIDs (1, &platform, 0);
    if (e)
        exit (e);
    e = clGetDeviceIDs (platform, CL_DEVICE_TYPE_ALL, 1, &device, 0);
    if (e)
        exit (e);
    cl_context context = clCreateContext (0, 1, &device, 0, 0, &e);
    if (e)
        exit (e);
    cl_command_queue queue = clCreateCommandQueue (context, device, 0, &e);
    if (e)
        exit (e);
    cl_program program = clCreateProgramWithSource (context, argc, (const char **) argv, 0, &e);
    cl_kernel kernel = 0;
    if (e)
        exit (e);
    e = clBuildProgram (program, 1, &device, 0, 0, 0);
    if (e)
        exit (e);
    e = clCreateKernelsInProgram (program, 1, &kernel, 0);
    if (e)
        exit (e);
    e = clSetKernelArg (kernel, 0, sizeof (int), &argc);
    if (e)
        exit (e);
    e = clEnqueueTask (queue, kernel, 0, 0, 0);
    if (e)
        exit (e);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10572559_10575698_5_15
10572559_11495924_7_34
Title: "In C: How do I check if an input file exist if the numbers in the file are int or float and if they are within a range?" 
----------------------------------------

int main () {
    FILE *fp;
    errno = 0;
    fp = fopen ("Not_exist.txt", "r");
    if (fp == NULL && errno == ENOENT)
        perror ("file does not exist");
    else
        fclose (fp);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    FILE *fp;
    int rc = 0;
    if (MIN_ARGS_SUPPLIED != argc) {
        printf ("Usage: file_detect file-name\n");
        rc = -1;
    }
    else {
        errno = 0;
        fp = fopen (argv[1], "r");
        if (fp == NULL || errno == ENOENT) {
            rc = errno;
        }
        else {
            fclose (fp);
        }
    }
    return rc;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1059756_1059783_18_34
1059756_1059963_20_33
Title: Confusion between pass by value and reference? 
----------------------------------------

int main () {
    float *x;
    float a, b;
    int num_vals = 10;
    fill_in_x (& x, num_vals);
    a = x[0];
    b = x[1] - x[0];
    printf ("%f\n", a);
    printf ("%f\n", b);
    function_using_a_and_b (a, b);
}
----------------------------------------

int main () {
    float *x;
    float a, b;
    int num_vals = 10;
    fill_in_x (& x, num_vals);
    a = x[0];
    b = x[1] - x[0];
    function_using_a_and_b (a, b);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10602265_10602375_1_23
10602265_10602396_1_22
Title: C: binary tree searching method 
----------------------------------------

data *search (struct data *node, int key) {
    if (node == NULL)
        return NULL;
    else {
        printf ("\n%d %d -", node -> number, key);
        if (node->number == key)
            return node;
        struct data *tmp;
        tmp = search (node->left, key);
        if (tmp)
            return tmp;
        tmp = search (node->right, key);
        if (tmp)
            return tmp;
    }
    return NULL;
}
----------------------------------------

data *search (struct data *node, int key) {
    data *found = NULL;
    if (node == NULL)
        return NULL;
    printf ("\n%d %d -", node -> number, key);
    if (node->number == key)
        return node;
    found = search (node->left, key);
    if (found)
        return found;
    found = search (node->right, key);
    if (found)
        return found;
    return NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1065153_1065424_1_13
1065153_1065852_16_47
Title: Scanning variable number of 'fields' from a text file 
----------------------------------------

int scan_vector (FILE *fh) {
    char pad [2];
    int i;
    if (fscanf (fh, "%d %1[:]", &v.Length, &pad) != 2)
        return -1;
    v.value = malloc (v.Length * sizeof (double));
    for (i = 0; i < v.Length; i++) {
        if (fscanf (fh, "%lf", &v.value[i]) != 1)
            return -1;
    }
    return 0;
}
----------------------------------------

_Bool scan_vector (FILE *file, struct vector *v) {
    char buffer [LINE_MAX];
    if (!fgets (buffer, sizeof (buffer), file))
        return 1;
    double values [VECTOR_SIZE_MAX];
    size_t size = 0;
    errno = 0;
    for (char *head = buffer, *tail = NULL;; ++size, head = tail) {
        while (isspace (*head))
            ++head;
        if (!*head)
            break;
        if (size >= VECTOR_SIZE_MAX)
            return 1;
        values[size] = strtod (head, &tail);
        if (errno || head == tail)
            return 1;
    }
    v->size = size;
    v->values = malloc (sizeof (double) * size);
    if (!v->values)
        return 1;
    memcpy (v -> values, values, sizeof (double) * size);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10652374_10652595_4_13
10652374_10655323_3_17
Title: ANSI C - Replacing blank characters without using arrays 
----------------------------------------

int main () {
    bool was_space;
    char c;
    while ((c = getchar ()) != EOF) {
        if (!was_space || c != ' ')
            putchar (c);
        was_space = c == ' ';
    }
    return 0;
}
----------------------------------------

int main () {
    int previous_char = 0;
    int latest_char;
    while ((latest_char = getchar ()) != EOF) {
        if (' ' != previous_char || ' ' != latest_char) {
            putchar (latest_char);
        }
        previous_char = latest_char;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10652374_10652595_4_13
10652374_10662766_2_22
Title: ANSI C - Replacing blank characters without using arrays 
----------------------------------------

int main () {
    bool was_space;
    char c;
    while ((c = getchar ()) != EOF) {
        if (!was_space || c != ' ')
            putchar (c);
        was_space = c == ' ';
    }
    return 0;
}
----------------------------------------

int main () {
    int input_char;
    int counter = 0;
    while ((input_char = getchar ()) != EOF) {
        if (input_char == ' ') {
            ++counter;
            if (counter == 1)
                putchar (input_char);
        }
        if (input_char != ' ') {
            putchar (input_char);
            counter = 0;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10652374_10655323_3_17
10652374_10662766_2_22
Title: ANSI C - Replacing blank characters without using arrays 
----------------------------------------

int main () {
    int previous_char = 0;
    int latest_char;
    while ((latest_char = getchar ()) != EOF) {
        if (' ' != previous_char || ' ' != latest_char) {
            putchar (latest_char);
        }
        previous_char = latest_char;
    }
    return 0;
}
----------------------------------------

int main () {
    int input_char;
    int counter = 0;
    while ((input_char = getchar ()) != EOF) {
        if (input_char == ' ') {
            ++counter;
            if (counter == 1)
                putchar (input_char);
        }
        if (input_char != ' ') {
            putchar (input_char);
            counter = 0;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10668504_10668528_4_18
10668504_12930480_2_18
Title: Segmentation Fault - C 
----------------------------------------

int main (int argc, char *argv []) {
    char s [BUF_SIZE];
    int ln;
    puts ("Enter String");
    gets (s);
    ln = strlen (s);
    char *dyn_s = (char *) malloc (strlen (s) +1);
    dyn_s = s;
    dyn_s[strlen (s)] = '\0';
    puts (dyn_s);
    return 0;
}
----------------------------------------

int main (void) {
    char *line = NULL;
    size_t count;
    char *dup_line;
    getline (& line, & count, stdin);
    dup_line = strdup (line);
    puts (dup_line);
    free (dup_line);
    free (line);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10672459_10672492_3_20
10672459_10672694_6_50
Title: How to create char[][] from txt file in C? 
----------------------------------------

int main () {
    FILE *pFile;
    int c;
    int n = 0;
    pFile = fopen ("myfile.txt", "r");
    if (pFile == NULL)
        perror ("Error opening file");
    else {
        do {
            c = fgetc (pFile);
            if (c == '$')
                n++;
        }
        while (c != EOF);
        fclose (pFile);
        printf ("The file contains %d dollar sign characters ($).\n", n);
    }
    return 0;
}
----------------------------------------

int main () {
    FILE *pFile;
    pFile = fopen ("250.txt", "r");
    if (pFile == NULL) {
        perror ("Error opening file");
    }
    else {
        char array [50] [50];
        int row, col;
        for (row = 0; row < 50; row++) {
            for (col = 0; col < 50; col++) {
                array[row][col] = fgetc (pFile);
            }
        }
        fclose (pFile);
        for (row = 0; row < 50; row++) {
            for (col = 0; col < 50; col++) {
                printf ("%c", array [row] [col]);
            }
            printf ("\n");
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10672459_10672492_3_20
10672459_10673009_4_23
Title: How to create char[][] from txt file in C? 
----------------------------------------

int main () {
    FILE *pFile;
    int c;
    int n = 0;
    pFile = fopen ("myfile.txt", "r");
    if (pFile == NULL)
        perror ("Error opening file");
    else {
        do {
            c = fgetc (pFile);
            if (c == '$')
                n++;
        }
        while (c != EOF);
        fclose (pFile);
        printf ("The file contains %d dollar sign characters ($).\n", n);
    }
    return 0;
}
----------------------------------------

int main () {
    FILE *fp;
    char data [50] [50];
    int count;
    if (NULL == (fp = fopen ("data.txt", "r"))) {
        perror ("file not open\n");
        exit (EXIT_FAILURE);
    }
    count = fread (&data[0][0], sizeof (char), 50 * 50, fp);
    fclose (fp);
    {
        int i;
        char *p = &data[0][0];
        for (i = 0; i < count; ++i)
            putchar (*p++);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10672459_10672694_6_50
10672459_10673009_4_23
Title: How to create char[][] from txt file in C? 
----------------------------------------

int main () {
    FILE *pFile;
    pFile = fopen ("250.txt", "r");
    if (pFile == NULL) {
        perror ("Error opening file");
    }
    else {
        char array [50] [50];
        int row, col;
        for (row = 0; row < 50; row++) {
            for (col = 0; col < 50; col++) {
                array[row][col] = fgetc (pFile);
            }
        }
        fclose (pFile);
        for (row = 0; row < 50; row++) {
            for (col = 0; col < 50; col++) {
                printf ("%c", array [row] [col]);
            }
            printf ("\n");
        }
    }
    return 0;
}
----------------------------------------

int main () {
    FILE *fp;
    char data [50] [50];
    int count;
    if (NULL == (fp = fopen ("data.txt", "r"))) {
        perror ("file not open\n");
        exit (EXIT_FAILURE);
    }
    count = fread (&data[0][0], sizeof (char), 50 * 50, fp);
    fclose (fp);
    {
        int i;
        char *p = &data[0][0];
        for (i = 0; i < count; ++i)
            putchar (*p++);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10678522_10678765_5_23
10678522_10678954_1_20
Title: how can I get this readdir code sample to search other directories 
----------------------------------------

static void lookup (const char *root, const char *arg) {
    size_t n;
    glob_t res;
    char **p;
    chdir (root);
    glob (arg, 0, 0, & res);
    n = res.gl_pathc;
    if (n < 1) {
        printf ("failed to find %s\n", arg);
    }
    else {
        for (p = res.gl_pathv; n; p++, n--) {
            printf ("found %s\n", * p);
        }
    }
    globfree (& res);
}
----------------------------------------

static int lookup (const char *dir, const char *arg) {
    DIR *dirp;
    struct dirent *dp;
    if ((dirp = opendir (dir)) == NULL) {
        perror (dir);
        return -1;
    }
    while ((dp = readdir (dirp)) != NULL) {
        if (!strcmp (dp->d_name, arg)) {
            break;
        }
    }
    (void) closedir (dirp);
    printf ("%s %s\n", dp ? "found" : "failed to find", arg);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1068849_1068937_119_175
1068849_43576219_1_14
Title: How do I determine the number of digits of an integer in C? 
----------------------------------------

int main (int c, char *v []) {
    int i, j, k, r;
    int s = 1;
    srand (time (NULL));
    for (j = 0; j < numof (rndnum); j++) {
        rndnum[j] = s * rand ();
        s = -s;
    }
    rndnum[0] = INT_MAX;
    rndnum[1] = INT_MIN;
    for (k = 0; k < numof (rndnum); k++) {
        rt[k] = (fn[1].fnptr) (rndnum[k]);
    }
    clk[0] = clock ();
    for (i = 1; i < numof (fn); i++) {
        for (j = 0; j < 10000; j++) {
            for (k = 0; k < numof (rndnum); k++) {
                r = (fn[i].fnptr) (rndnum[k]);
            }
        }
        clk[i] = clock ();
    }
    for (i = 1; i < numof (fn); i++) {
        printf ("Time for %s: %10d\n", fn [i].desc, (int) (clk [i] - clk [i - 1]));
    }
    return 0;
}
----------------------------------------

void main () {
    int a, i;
    printf ("Enter the number :");
    scanf ("%d", & a);
    while (a > 0) {
        a = a / 10;
        i++;
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1068849_18027868_164_223
1068849_43576219_1_14
Title: How do I determine the number of digits of an integer in C? 
----------------------------------------

int main (int c, char *v []) {
    int i, j, k, r;
    int s = 1;
    int p, n;
    p = n = 0;
    srand (time (NULL));
    for (j = 0; j < numof (rndnum); j++) {
        rndnum[j] = ((rand () & 2) - 1) * rand ();
    }
    rndnum[0] = INT_MAX;
    rndnum[1] = INT_MIN;
    for (k = 0; k < numof (rndnum); k++) {
        rt[k] = (fn[1].fnptr) (rndnum[k]);
    }
    clk[0] = clock ();
    for (i = 1; i < numof (fn); i++) {
        for (j = 0; j < 10000; j++) {
            for (k = 0; k < numof (rndnum); k++) {
                r = (fn[i].fnptr) (rndnum[k]);
            }
        }
        clk[i] = clock ();
    }
    for (i = 1; i < numof (fn); i++) {
        printf ("Time for %s: %10d\n", fn [i].desc, (int) (clk [i] - clk [i - 1]));
    }
    return 0;
}
----------------------------------------

void main () {
    int a, i;
    printf ("Enter the number :");
    scanf ("%d", & a);
    while (a > 0) {
        a = a / 10;
        i++;
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10715170_11054652_31_140
10715170_41597836_14_140
Title: Receiving RTSP stream using FFMPEG library 
----------------------------------------

int main (int argc, char **argv) {
    SwsContext *img_convert_ctx;
    AVFormatContext *context = avformat_alloc_context ();
    AVCodecContext *ccontext = avcodec_alloc_context ();
    int video_stream_index;
    av_register_all ();
    avformat_network_init ();
    if (avformat_open_input (&context, "rtsp://134.169.178.187:8554/h264.3gp", NULL, NULL) != 0) {
        return EXIT_FAILURE;
    }
    if (avformat_find_stream_info (context, NULL) < 0) {
        return EXIT_FAILURE;
    }
    for (int i = 0; i < context->nb_streams; i++) {
        if (context->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
            video_stream_index = i;
    }
    AVPacket packet;
    av_init_packet (& packet);
    AVFormatContext *oc = avformat_alloc_context ();
    AVStream *stream = NULL;
    int cnt = 0;
    av_read_play (context);
    AVCodec *codec = NULL;
    codec = avcodec_find_decoder (CODEC_ID_H264);
    if (!codec)
        exit (1);
    avcodec_get_context_defaults3 (ccontext, codec);
    avcodec_copy_context (ccontext, context -> streams [video_stream_index] -> codec);
std :
    : ofstream myfile;
    if (avcodec_open (ccontext, codec) < 0)
        exit (1);
    img_convert_ctx = sws_getContext (ccontext->width, ccontext->height, ccontext->pix_fmt, ccontext->width, ccontext->height, PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);
    int size = avpicture_get_size (PIX_FMT_YUV420P, ccontext->width, ccontext->height);
    uint8_t *picture_buf = (uint8_t *) (av_malloc (size));
    AVFrame *pic = avcodec_alloc_frame ();
    AVFrame *picrgb = avcodec_alloc_frame ();
    int size2 = avpicture_get_size (PIX_FMT_RGB24, ccontext->width, ccontext->height);
    uint8_t *picture_buf2 = (uint8_t *) (av_malloc (size2));
    avpicture_fill ((AVPicture *) pic, picture_buf, PIX_FMT_YUV420P, ccontext -> width, ccontext -> height);
    avpicture_fill ((AVPicture *) picrgb, picture_buf2, PIX_FMT_RGB24, ccontext -> width, ccontext -> height);
    while (av_read_frame (context, &packet) >= 0 && cnt < 1000) {
    std :
        : cout << "1 Frame: " << cnt << std : : endl;
        if (packet.stream_index == video_stream_index) {
        std :
            : cout << "2 Is Video" << std : : endl;
            if (stream == NULL) {
            std :
                : cout << "3 create stream" << std : : endl;
                stream = avformat_new_stream (oc, context->streams[video_stream_index]->codec->codec);
                avcodec_copy_context (stream -> codec, context -> streams [video_stream_index] -> codec);
                stream->sample_aspect_ratio = context->streams[video_stream_index]->codec->sample_aspect_ratio;
            }
            int check = 0;
            packet.stream_index = stream->id;
        std :
            : cout << "4 decoding" << std : : endl;
            int result = avcodec_decode_video2 (ccontext, pic, &check, &packet);
        std :
            : cout << "Bytes decoded " << result << " check " << check << std : : endl;
            if (cnt > 100) {
                sws_scale (img_convert_ctx, pic -> data, pic -> linesize, 0, ccontext -> height, picrgb -> data, picrgb -> linesize);
            std :
                : stringstream name;
                name << "test" << cnt << ".ppm";
                myfile.open (name.str ());
                myfile << "P3 " << ccontext->width << " " << ccontext->height << " 255\n";
                for (int y = 0; y < ccontext->height; y++) {
                    for (int x = 0; x < ccontext->width * 3; x++)
                        myfile << (int) (picrgb->data[0] + y * picrgb->linesize[0])[x] << " ";
                }
                myfile.close ();
            }
            cnt++;
        }
        av_free_packet (& packet);
        av_init_packet (& packet);
    }
    av_free (pic);
    av_free (picrgb);
    av_free (picture_buf);
    av_free (picture_buf2);
    av_read_pause (context);
    avio_close (oc -> pb);
    avformat_free_context (oc);
    return (EXIT_SUCCESS);
}
----------------------------------------

int main (int argc, char **argv) {
    SwsContext *img_convert_ctx;
    AVFormatContext *format_ctx = avformat_alloc_context ();
    AVCodecContext *codec_ctx = NULL;
    int video_stream_index;
    av_register_all ();
    avformat_network_init ();
    if (avformat_open_input (&format_ctx, "rtsp://134.169.178.187:8554/h264.3gp", NULL, NULL) != 0) {
        return EXIT_FAILURE;
    }
    if (avformat_find_stream_info (format_ctx, NULL) < 0) {
        return EXIT_FAILURE;
    }
    for (int i = 0; i < format_ctx->nb_streams; i++) {
        if (format_ctx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
            video_stream_index = i;
    }
    AVPacket packet;
    av_init_packet (& packet);
    AVFormatContext *output_ctx = avformat_alloc_context ();
    AVStream *stream = NULL;
    int cnt = 0;
    av_read_play (format_ctx);
    AVCodec *codec = NULL;
    codec = avcodec_find_decoder (AV_CODEC_ID_H264);
    if (!codec) {
        exit (1);
    }
    codec_ctx = avcodec_alloc_context3 (codec);
    avcodec_get_context_defaults3 (codec_ctx, codec);
    avcodec_copy_context (codec_ctx, format_ctx -> streams [video_stream_index] -> codec);
std :
    : ofstream output_file;
    if (avcodec_open2 (codec_ctx, codec, NULL) < 0)
        exit (1);
    img_convert_ctx = sws_getContext (codec_ctx->width, codec_ctx->height, codec_ctx->pix_fmt, codec_ctx->width, codec_ctx->height, AV_PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);
    int size = avpicture_get_size (AV_PIX_FMT_YUV420P, codec_ctx->width, codec_ctx->height);
    uint8_t *picture_buffer = (uint8_t *) (av_malloc (size));
    AVFrame *picture = av_frame_alloc ();
    AVFrame *picture_rgb = av_frame_alloc ();
    int size2 = avpicture_get_size (AV_PIX_FMT_RGB24, codec_ctx->width, codec_ctx->height);
    uint8_t *picture_buffer_2 = (uint8_t *) (av_malloc (size2));
    avpicture_fill ((AVPicture *) picture, picture_buffer, AV_PIX_FMT_YUV420P, codec_ctx -> width, codec_ctx -> height);
    avpicture_fill ((AVPicture *) picture_rgb, picture_buffer_2, AV_PIX_FMT_RGB24, codec_ctx -> width, codec_ctx -> height);
    while (av_read_frame (format_ctx, &packet) >= 0 && cnt < 1000) {
    std :
        : cout << "1 Frame: " << cnt << std : : endl;
        if (packet.stream_index == video_stream_index) {
        std :
            : cout << "2 Is Video" << std : : endl;
            if (stream == NULL) {
            std :
                : cout << "3 create stream" << std : : endl;
                stream = avformat_new_stream (output_ctx, format_ctx->streams[video_stream_index]->codec->codec);
                avcodec_copy_context (stream -> codec, format_ctx -> streams [video_stream_index] -> codec);
                stream->sample_aspect_ratio = format_ctx->streams[video_stream_index]->codec->sample_aspect_ratio;
            }
            int check = 0;
            packet.stream_index = stream->id;
        std :
            : cout << "4 decoding" << std : : endl;
            int result = avcodec_decode_video2 (codec_ctx, picture, &check, &packet);
        std :
            : cout << "Bytes decoded " << result << " check " << check << std : : endl;
            if (cnt > 100) {
                sws_scale (img_convert_ctx, picture -> data, picture -> linesize, 0, codec_ctx -> height, picture_rgb -> data, picture_rgb -> linesize);
            std :
                : stringstream file_name;
                file_name << "test" << cnt << ".ppm";
                output_file.open (file_name.str ().c_str ());
                output_file << "P3 " << codec_ctx->width << " " << codec_ctx->height << " 255\n";
                for (int y = 0; y < codec_ctx->height; y++) {
                    for (int x = 0; x < codec_ctx->width * 3; x++)
                        output_file << (int) (picture_rgb->data[0] + y * picture_rgb->linesize[0])[x] << " ";
                }
                output_file.close ();
            }
            cnt++;
        }
        av_free_packet (& packet);
        av_init_packet (& packet);
    }
    av_free (picture);
    av_free (picture_rgb);
    av_free (picture_buffer);
    av_free (picture_buffer_2);
    av_read_pause (format_ctx);
    avio_close (output_ctx -> pb);
    avformat_free_context (output_ctx);
    return (EXIT_SUCCESS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1071542_1071550_7_17
1071542_1071555_5_21
Title: In C - check if a char exists in a char array 
----------------------------------------

int main () {
    char *pch;
    char invalids [] = "@<>#";
    pch = (char *) memchr (invalids, 'p', strlen (invalids));
    if (pch != NULL)
        printf (p is an invalid character)
    else
        printf ("p valid character.\n");
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    const char *invalid_characters = "hz";
    char *mystring = "This is my test string";
    char *c = mystring;
    while (*c) {
        if (strchr (invalid_characters, *c)) {
            printf ("%c is in \"%s\"\n", * c, mystring);
        }
        c++;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10717723_10718012_1_18
10717723_10718027_1_18
Title: Delete space from string in ansi C 
----------------------------------------

const char *trim_str (char *input_str) {
    char *str = NULL;
    int len = strlen (input_str);
    str = (char *) malloc (len +1);
    int i = 0;
    while (i < len && (input_str[i] == ' ' || input_str[i] == '\t')) {
        ++i;
    }
    int j = 0;
    while (i < len && input_str[i] != ' ' && input_str[i] != '\t') {
        str[j] = input_str[i];
        ++j;
        ++i;
    }
    str[j] = '\0';
    return str;
}
----------------------------------------

const char *trim_str (char *input_str) {
    char *str = NULL;
    int len = strlen (input_str);
    int i = 0;
    int newSize = 0;
    for (i = 0; i < len - 1; i++) {
        if (input_str[i] == ' ')
            ;
        else
            newSize++;
    }
    str = malloc (newSize +1);
    str [newSize] = '\0' return str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10748901_10750371_21_41
10748901_10754467_21_46
Title: assigning all combinations of a variable number of variable objects 
----------------------------------------

int main (void) {
    const int N = 2;
    int n [N];
    int accum [N];
    int **p;
    int mult;
    int i, j;
    n[0] = 2;
    n[1] = 3;
    for (mult = 1, i = 0; i < N; mult *= n[i], ++i)
        ;
    p = malloc (mult * sizeof (int *));
    for (i = 0; i < mult; i++)
        p[i] = malloc (N * sizeof (int));
    recurse (n, accum, p, N, 0);
    for (i = 0; i < mult; ++i)
        for (j = 0; j < N; ++j)
            printf ("p[%d][%d] = %d\n", i, j, p[i][j]);
    for (i = 0; i < mult; i++)
        free (p[i]);
    free (p);
}
----------------------------------------

int main (void) {
    int **p, n [2], i, j;
    int sizeAll, sizeN;
    n[0] = 2;
    n[1] = 3;
    sizeAll = n[0] * n[1];
    sizeN = sizeof (n) / sizeof (int);
    p = (int **) malloc (sizeAll * sizeof (int *));
    for (i = 0; i < sizeAll; ++i) {
        p[i] = (int *) malloc (sizeN * sizeof (int));
        for (j = 0; j < sizeN; ++j)
            p[i][j] = -1;
    }
    recurse (p, n, sizeN, 0, sizeAll);
    for (i = 0; i < sizeAll; ++i)
        for (j = 0; j < sizeN; ++j)
            printf ("%d %d: %d\n", i, j, p[i][j]);
    for (i = 0; i < sizeAll; ++i)
        free (p[i]);
    free (p);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10748901_10750371_4_19
10748901_10754467_4_19
Title: assigning all combinations of a variable number of variable objects 
----------------------------------------

void recurse (int *n, int *accum, int **p, int N, int k) {
    static int comb;
    int i, j;
    if (k == 0)
        comb = 0;
    if (k == N) {
        for (i = 0; i < N; ++i)
            p[comb][i] = accum[i];
        comb++;
    }
    else
        for (i = 0; i < n[k]; ++i) {
            accum[k] = i;
            recurse (n, accum, p, N, k + 1);
        }
}
----------------------------------------

int recurse (int **p, int *n, int nclass, int classcount, int p_size) {
    int i, j, jmax, k, kmax;
    if (classcount == nclass)
        return 1;
    i = 0;
    kmax = n[classcount];
    while (i < p_size) {
        for (k = 0; k < kmax; ++k) {
            jmax = recurse (p, n, nclass, classcount +1, p_size);
            for (j = 0; j < jmax; ++j)
                p[i++][classcount] = k;
        }
    }
    return kmax * jmax;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10757575_16790887_22_138
10757575_19791431_33_118
Title: How to write a NTP client? 
----------------------------------------

void ntpdate () {
    char *hostname = "64.27.26.1";
    int portno = 123;
    int maxlen = 1024;
    long i;
    char msg [48] = {010, 0, 0, 0, 0, 0, 0, 0, 0};
    char * buf = new char [1024];
    struct protoent *proto;
    struct sockaddr_in server_addr;
    SOCKET s;
    time_t tmit;
    WSADATA wsaData;
    BYTE wsMajorVersion = 1;
    BYTE wsMinorVersion = 1;
    WORD wVersionRequested = MAKEWORD (wsMinorVersion, wsMajorVersion);
    if (WSAStartup (wVersionRequested, &wsaData) != 0) {
        _tprintf (_T ("Failed to load winsock stack\n"));
        WSACleanup ();
        return;
    }
    if (LOBYTE (wsaData.wVersion) != wsMajorVersion || HIBYTE (wsaData.wVersion) != wsMinorVersion) {
        _tprintf (_T ("Winsock stack does not support version which this program requires\n"));
        WSACleanup ();
        return;
    }
    proto = getprotobyname ("udp");
    int err = GetLastError ();
    s = socket (PF_INET, SOCK_DGRAM, proto->p_proto);
    if (s) {
        perror ("asd");
        printf ("socket=%d\n", s);
    }
    memset (& server_addr, 0, sizeof (server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr (hostname);
    server_addr.sin_port = htons (portno);
    printf ("sending data..\n");
    i = sendto (s, msg, sizeof (msg), 0, (struct sockaddr *) &server_addr, sizeof (server_addr));
    int iResult = -1;
    iResult = recv (s, buf, 1024, 0);
    if (iResult > 0)
        printf ("Bytes received: %d\n", iResult);
    else if (iResult == 0)
        printf ("Connection closed\n");
    else
        printf ("recv failed: %d\n", WSAGetLastError ());
    tmit = ntohl ((time_t) buf[10]);
    tmit -= 2208988800U;
    printf ("Time: %s", ctime (& tmit));
    i = time (0);
    printf ("System time is %d seconds off\n", i - tmit);
}
----------------------------------------

void ntpdate () {
    char *hostname = "163.117.202.33";
    int portno = 123;
    int maxlen = 1024;
    int i;
    unsigned char msg [48] = {010, 0, 0, 0, 0, 0, 0, 0, 0};
    unsigned long buf [maxlen];
    struct protoent *proto;
    struct sockaddr_in server_addr;
    int s;
    int tmit;
    proto = getprotobyname ("udp");
    s = socket (PF_INET, SOCK_DGRAM, proto->p_proto);
    perror ("socket");
    memset (& server_addr, 0, sizeof (server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr (hostname);
    server_addr.sin_port = htons (portno);
    printf ("sending data..\n");
    i = sendto (s, msg, sizeof (msg), 0, (struct sockaddr *) &server_addr, sizeof (server_addr));
    perror ("sendto");
    struct sockaddr saddr;
    socklen_t saddr_l = sizeof (saddr);
    i = recvfrom (s, buf, 48, 0, &saddr, &saddr_l);
    perror ("recvfr:");
    tmit = ntohl ((time_t) buf[10]);
    tmit -= 2208988800U;
    printf ("Time: %s", ctime (& tmit));
    i = time (0);
    printf ("System time is %d seconds off\n", i - tmit);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10757575_16790887_22_138
10757575_19815921_108_159
Title: How to write a NTP client? 
----------------------------------------

void ntpdate () {
    char *hostname = "64.27.26.1";
    int portno = 123;
    int maxlen = 1024;
    long i;
    char msg [48] = {010, 0, 0, 0, 0, 0, 0, 0, 0};
    char * buf = new char [1024];
    struct protoent *proto;
    struct sockaddr_in server_addr;
    SOCKET s;
    time_t tmit;
    WSADATA wsaData;
    BYTE wsMajorVersion = 1;
    BYTE wsMinorVersion = 1;
    WORD wVersionRequested = MAKEWORD (wsMinorVersion, wsMajorVersion);
    if (WSAStartup (wVersionRequested, &wsaData) != 0) {
        _tprintf (_T ("Failed to load winsock stack\n"));
        WSACleanup ();
        return;
    }
    if (LOBYTE (wsaData.wVersion) != wsMajorVersion || HIBYTE (wsaData.wVersion) != wsMinorVersion) {
        _tprintf (_T ("Winsock stack does not support version which this program requires\n"));
        WSACleanup ();
        return;
    }
    proto = getprotobyname ("udp");
    int err = GetLastError ();
    s = socket (PF_INET, SOCK_DGRAM, proto->p_proto);
    if (s) {
        perror ("asd");
        printf ("socket=%d\n", s);
    }
    memset (& server_addr, 0, sizeof (server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr (hostname);
    server_addr.sin_port = htons (portno);
    printf ("sending data..\n");
    i = sendto (s, msg, sizeof (msg), 0, (struct sockaddr *) &server_addr, sizeof (server_addr));
    int iResult = -1;
    iResult = recv (s, buf, 1024, 0);
    if (iResult > 0)
        printf ("Bytes received: %d\n", iResult);
    else if (iResult == 0)
        printf ("Connection closed\n");
    else
        printf ("recv failed: %d\n", WSAGetLastError ());
    tmit = ntohl ((time_t) buf[10]);
    tmit -= 2208988800U;
    printf ("Time: %s", ctime (& tmit));
    i = time (0);
    printf ("System time is %d seconds off\n", i - tmit);
}
----------------------------------------

void ntpdate (uint64_t *cachedTime, uint64_t *cachedTimeRef, uint64_t *cacheCertainty) {
    char hostname [] = "81.184.154.182";
    int portno = 123;
    int maxlen = 48;
    int i;
    uint64_t requestTime = currentTimeMillis ();
    uint64_t requestTicks = android : : elapsedRealtime ();
    char msg [48];
    memset (msg, 0, sizeof (msg));
    msg[0] = NTP_MODE_CLIENT | (NTP_VERSION << 3);
    writeTimeStamp (msg, TRANSMIT_TIME_OFFSET, requestTime);
    char buf [maxlen];
    struct sockaddr_in server_addr;
    int s;
    time_t tmit;
    s = socket (PF_INET, SOCK_DGRAM, IPPROTO_UDP);
    memset (& server_addr, 0, sizeof (server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr (hostname);
    server_addr.sin_port = htons (portno);
    i = sendto (s, msg, sizeof (msg), 0, (struct sockaddr *) &server_addr, sizeof (server_addr));
    struct sockaddr saddr;
    socklen_t saddr_l = sizeof (saddr);
    i = recvfrom (s, buf, sizeof (buf), 0, &saddr, &saddr_l);
    uint64_t responseTicks = android : : elapsedRealtime ();
    uint64_t responseTime = requestTime + (responseTicks - requestTicks);
    uint64_t originateTime = readTimeStamp (buf, ORIGINATE_TIME_OFFSET);
    uint64_t receiveTime = readTimeStamp (buf, RECEIVE_TIME_OFFSET);
    uint64_t transmitTime = readTimeStamp (buf, TRANSMIT_TIME_OFFSET);
    uint64_t roundTripTime = responseTicks - requestTicks - (transmitTime - receiveTime);
    int32_t clockOffset = ((receiveTime - originateTime) + (transmitTime - responseTime)) / 2;
    uint64_t mNtpTime = responseTime + clockOffset;
    uint64_t mNtpTimeReference = responseTicks;
    uint64_t mRoundTripTime = roundTripTime;
    uint64_t mCachedNtpTime = mNtpTime;
    uint64_t mCachedNtpElapsedRealtime = mNtpTimeReference;
    uint64_t mCachedNtpCertainty = mRoundTripTime / 2;
    *cachedTime = mCachedNtpTime;
    *cachedTimeRef = mNtpTimeReference;
    *cacheCertainty = mCachedNtpCertainty;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10757575_19791431_33_118
10757575_19815921_108_159
Title: How to write a NTP client? 
----------------------------------------

void ntpdate () {
    char *hostname = "163.117.202.33";
    int portno = 123;
    int maxlen = 1024;
    int i;
    unsigned char msg [48] = {010, 0, 0, 0, 0, 0, 0, 0, 0};
    unsigned long buf [maxlen];
    struct protoent *proto;
    struct sockaddr_in server_addr;
    int s;
    int tmit;
    proto = getprotobyname ("udp");
    s = socket (PF_INET, SOCK_DGRAM, proto->p_proto);
    perror ("socket");
    memset (& server_addr, 0, sizeof (server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr (hostname);
    server_addr.sin_port = htons (portno);
    printf ("sending data..\n");
    i = sendto (s, msg, sizeof (msg), 0, (struct sockaddr *) &server_addr, sizeof (server_addr));
    perror ("sendto");
    struct sockaddr saddr;
    socklen_t saddr_l = sizeof (saddr);
    i = recvfrom (s, buf, 48, 0, &saddr, &saddr_l);
    perror ("recvfr:");
    tmit = ntohl ((time_t) buf[10]);
    tmit -= 2208988800U;
    printf ("Time: %s", ctime (& tmit));
    i = time (0);
    printf ("System time is %d seconds off\n", i - tmit);
}
----------------------------------------

void ntpdate (uint64_t *cachedTime, uint64_t *cachedTimeRef, uint64_t *cacheCertainty) {
    char hostname [] = "81.184.154.182";
    int portno = 123;
    int maxlen = 48;
    int i;
    uint64_t requestTime = currentTimeMillis ();
    uint64_t requestTicks = android : : elapsedRealtime ();
    char msg [48];
    memset (msg, 0, sizeof (msg));
    msg[0] = NTP_MODE_CLIENT | (NTP_VERSION << 3);
    writeTimeStamp (msg, TRANSMIT_TIME_OFFSET, requestTime);
    char buf [maxlen];
    struct sockaddr_in server_addr;
    int s;
    time_t tmit;
    s = socket (PF_INET, SOCK_DGRAM, IPPROTO_UDP);
    memset (& server_addr, 0, sizeof (server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = inet_addr (hostname);
    server_addr.sin_port = htons (portno);
    i = sendto (s, msg, sizeof (msg), 0, (struct sockaddr *) &server_addr, sizeof (server_addr));
    struct sockaddr saddr;
    socklen_t saddr_l = sizeof (saddr);
    i = recvfrom (s, buf, sizeof (buf), 0, &saddr, &saddr_l);
    uint64_t responseTicks = android : : elapsedRealtime ();
    uint64_t responseTime = requestTime + (responseTicks - requestTicks);
    uint64_t originateTime = readTimeStamp (buf, ORIGINATE_TIME_OFFSET);
    uint64_t receiveTime = readTimeStamp (buf, RECEIVE_TIME_OFFSET);
    uint64_t transmitTime = readTimeStamp (buf, TRANSMIT_TIME_OFFSET);
    uint64_t roundTripTime = responseTicks - requestTicks - (transmitTime - receiveTime);
    int32_t clockOffset = ((receiveTime - originateTime) + (transmitTime - responseTime)) / 2;
    uint64_t mNtpTime = responseTime + clockOffset;
    uint64_t mNtpTimeReference = responseTicks;
    uint64_t mRoundTripTime = roundTripTime;
    uint64_t mCachedNtpTime = mNtpTime;
    uint64_t mCachedNtpElapsedRealtime = mNtpTimeReference;
    uint64_t mCachedNtpCertainty = mRoundTripTime / 2;
    *cachedTime = mCachedNtpTime;
    *cachedTimeRef = mNtpTimeReference;
    *cacheCertainty = mCachedNtpCertainty;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10763019_10763071_5_18
10763019_10763092_4_22
Title: C code not displaying the correct thing 
----------------------------------------

int main (void) {
    int fila [4], i, j;
    srand (rand ());
    for (i = 0; i != 4; i++) {
        fila[i] = rand () % 3 + 1;
    }
    for (i = 0; i != 4; fila[i]--, i += (fila[i] == 0)) {
        for (j = i; j != 4; j++) {
            printf ("[%d] ", fila [j]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int arr [4];
    int i;
    for (i = 0; i < 4; i++) {
        arr[i] = (rand () % 3) + 1;
    }
    for (i = 0; i < 4; i++) {
        while (arr[i]) {
            int j;
            for (j = i; j < 4; j++) {
                printf ("[%d]", arr [j]);
            }
            printf ("\n");
            arr[i]--;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10814342_10816814_1_29
10814342_10820044_3_21
Title: "Solving Mathematical logics placing digits in third number from digits of first and second number" 
----------------------------------------

long CreateThirdNumber (long firstNumber, long secondNumber) {
    long firstN = firstNumber;
    long secondN = secondNumber;
    long len1 = (long) Math.Truncate (Math.Log10 (firstNumber));
    long len2 = (long) Math.Truncate (Math.Log10 (secondNumber));
    long maxLen = Math.Max (len1, len2);
    long result = 0;
    long curPow = len1 + len2 + 1;
    for (int i = 0; i <= maxLen; i++) {
        if (len1 >= i) {
            long tenPwf = (long) Math.Pow (10, len1 -i);
            long firstD = firstN / tenPwf;
            firstN = firstN % tenPwf;
            result = result + firstD * (long) Math.Pow (10, curPow--);
        }
        if (len2 >= i) {
            long tenPws = (long) Math.Pow (10, len2 -i);
            long secondD = secondN / tenPws;
            result = result + secondD * (long) Math.Pow (10, curPow--);
            secondN = secondN % tenPws;
        }
    }
    return result;
}
----------------------------------------

long long int CreateThirdNumber (int firstNumber, int secondNumber) {
    char first [11], second [11], third [21];
    char *p1 = first, *p2 = second, *p3 = third;
    long long int ret;
    sprintf (first, "%d", firstNumber);
    sprintf (second, "%d", secondNumber);
    while (1) {
        if (*p1)
            *p3++ = *p1++;
        if (*p2)
            *p3++ = *p2++;
        if (*p1 == '\0' && *p2 == '\0')
            break;
    }
    *p3 = '\0';
    sscanf (third, "%lld", & ret);
    return ret;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1083304_27696714_12_32
1083304_51588814_12_25
Title: C/C++ counting the number of decimals? 
----------------------------------------

int main () {
    int counts;
    char *sign;
    char str [15];
    char *base;
    char *exp10;
    float real = 0.00001;
    sprintf (str, "%E", real);
    sign = (strpbrk (str, "+")) ? "+" : "-";
    base = strtok (str, sign);
    exp10 = strtok (NULL, sign);
    counts = atoi (exp10);
    printf ("[%d]\n", counts);
    return 0;
}
----------------------------------------

int main () {
    clrscr ();
    int count = 0;
    double d = 0;
    char intstr [10], fractstr [10];
    cout << "Enter a number";
    cin >> d;
    strcpy (intstr, intpart (d));
    strcpy (fractstr, fractpart (d));
    cout << intstr << '.' << fractstr;
    getche ();
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10844741_10844771_1_14
10844741_10844799_1_10
Title: removing leaves doesn't affect a BST - C 
----------------------------------------

void removeLeaves (struct Tree **T) {
    if ((*T)->left == NULL && (*T)->right == NULL) {
        printf ("removing %c\n", (* T) -> data);
        *T = NULL;
    }
    else {
        if ((*T)->left != NULL) {
            pruneTree ((* T) -> left);
        }
        if ((*T)->right != NULL) {
            pruneTree ((* T) -> right);
        }
    }
}
----------------------------------------

void removeLeaves (struct Tree * const T) {
    if (T->left != NULL) {
        removeLeaves (T -> left);
        T->left = NULL;
    }
    if (T->right != NULL) {
        removeLeaves (T -> right);
        T->right = NULL;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10864586_10864641_5_41
10864586_10864780_5_27
Title: C pointers inconsistency 
----------------------------------------

String *newString (const char *str) {
    String *newStr = (String *) malloc (sizeof (String));
    if (newStr == NULL) {
        printf ("ERROR: Out of memory\n");
        return NULL;
    }
    int count;
    for (count = 0; *(str + count) != '\0'; count++)
        ;
    count++;
    newStr->buffer = (char *) malloc (count * sizeof (char));
    if (newStr->buffer == NULL) {
        printf ("ERROR: Out of memory\n");
        return NULL;
    }
    char *pBuffer = newStr->buffer;
    while (*str != '\0')
        *(pBuffer++) = *(str++);
    *pBuffer = '\0';
    newStr->length = count;
    newStr->maxLength = count;
    printf ("newStr->buffer: %p\n", newStr -> buffer);
    return newStr;
}
----------------------------------------

String *newString (const char *str) {
    String *newStr = malloc (sizeof (String));
    if (!newStr) {
        fprintf (stderr, "ERROR: Out of memory\n");
        return NULL;
    }
    newStr->length = strlen (str);
    newStr->alloclength = newStr->length + 1;
    newStr->buffer = malloc (newStr->alloclength);
    if (!newStr->buffer) {
        fprintf (stderr, "ERROR: Out of memory\n");
        return NULL;
    }
    strcpy (newStr -> buffer, str);
    printf ("newStr->buffer: %p\n", newStr -> buffer);
    return newStr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10865929_10865951_11_29
10865929_17981705_19_44
Title: multithreading in C: passing a structure 
----------------------------------------

int main () {
    pthread_t thread [3];
    args ss [3];
    int index;
    for (index = 0; index < 3; index++) {
        ss[index].a = index;
        if (pthread_create (&thread[index], NULL, some_func, &ss[index])) {
            printf ("something is wrong creating the thread");
        }
    }
    pthread_join (thread [0], NULL);
    pthread_join (thread [1], NULL);
    pthread_join (thread [2], NULL);
    return 0;
}
----------------------------------------

int main () {
    pthread_t thread [10];
    args ss;
    int i, index = 0;
    ss.b = 's';
    if (pthread_mutex_init (&lock, NULL) != 0) {
        printf ("\n mutex init failed\n");
        return 1;
    }
    for (index = 0; index < 10; index++) {
        pthread_mutex_lock (& lock);
        ss.a = index;
        printf ("index=%d, ", ss.a);
        if (pthread_create (thread +index, NULL, some_func, (void *) &ss)) {
            usleep (10);
            printf ("something is wrong creating the thread");
        }
    }
    for (i = 0; i < 10; i++)
        pthread_join (thread[0], NULL);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10870235_10871935_26_53
10870235_10872188_5_20
Title: C: reading text into linked list 
----------------------------------------

int main () {
    FILE *fpointer;
    fpointer = fopen ("booklist.txt", "r");
    if (fpointer == NULL) {
        printf ("Booklist could not be opened.\n");
        exit (EXIT_FAILURE);
    }
    char Title [50 + 1];
    char Author [50 + 1];
    char Year [4 + 1];
    head = NULL;
    while (EOF != fscanf (fpointer, "%50[^:]%*c%50[^:]%*c%4[^\n]%*c", Title, Author, Year)) {
        addEntry (Title, Author, Year);
    }
    fclose (fpointer);
    int entryCount = numEntries ();
    printf ("There are %d entries in this Book list\n", entryCount);
    display ();
    free_book (head);
    return 0;
}
----------------------------------------

int main () {
    char line [] = "Absalom, Absalom!:William Faulkner:1936\n";
    char *p;
    char *Title;
    char *Author;
    char *Year;
    p = strtok (line, ":");
    Title = strdup (p);
    Author = strdup (strtok (NULL, ":"));
    Year = strdup (strtok (NULL, ": \n"));
    printf ("\"%s\",\"%s\",\"%s\"\n", Title, Author, Year);
    free (Title);
    free (Author);
    free (Year);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10876718_10878975_6_19
10876718_10879186_6_25
Title: How can I read a full string between a two double quote mark from a file in C 
----------------------------------------

int main () {
    FILE *fp;
    char buff [1024];
    char str [128];
    fp = fopen ("data.txt", "r");
    while (NULL != fgets (buff, sizeof (buff), fp)) {
        sscanf (buff, "%*[^\"]%*c%[^\"]%*c%*[^\n]%*c", str);
        printf ("%s\n", str);
    }
    fclose (fp);
    return 0;
}
----------------------------------------

int main () {
    FILE *fp;
    char buff [1024];
    char str [128];
    fp = fopen ("data.txt", "r");
    while (NULL != fgets (buff, sizeof (buff), fp)) {
        char *pf, *pb;
        int len;
        pf = strchr (buff, '\"');
        pb = strchr (pf +1, '\"');
        len = pb - pf - 1;
        memcpy (str, pf + 1, len);
        str[len] = '\0';
        printf ("%s\n", str);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10879420_10879468_44_60
10879420_10879707_32_65
Title: Using of shared variable by 10 pthreads 
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t params;
    params.id = 0;
    pthread_mutex_init (& params.mutex, NULL);
    int i;
    for (i = 0; i < 10; i++) {
        if (pthread_create (&threads[i], NULL, hello, &params))
            ;
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    return 0;
}
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t params;
    pthread_mutex_init (& params.mutex, NULL);
    pthread_cond_init (& params.done, NULL);
    pthread_mutex_lock (& params.mutex);
    int i;
    for (i = 0; i < 10; i++) {
        params.id = i;
        pthread_create (& threads [i], NULL, hello, & params);
        pthread_cond_wait (& params.done, & params.mutex);
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    pthread_mutex_destroy (& params.mutex);
    pthread_cond_destroy (& params.done);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10879420_10879468_44_60
10879420_10880066_25_44
Title: Using of shared variable by 10 pthreads 
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t params;
    params.id = 0;
    pthread_mutex_init (& params.mutex, NULL);
    int i;
    for (i = 0; i < 10; i++) {
        if (pthread_create (&threads[i], NULL, hello, &params))
            ;
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    return 0;
}
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t *params = 0;
    pthread_mutex_t main_mutex;
    pthread_mutex_init (& main_mutex, NULL);
    int i;
    for (i = 0; i < 10; i++) {
        params = new params_t ();
        params->id = i;
        params->mutex = &main_mutex;
        if (pthread_create (&threads[i], NULL, hello, params))
            ;
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10879420_10879468_44_60
10879420_48634168_28_50
Title: Using of shared variable by 10 pthreads 
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t params;
    params.id = 0;
    pthread_mutex_init (& params.mutex, NULL);
    int i;
    for (i = 0; i < 10; i++) {
        if (pthread_create (&threads[i], NULL, hello, &params))
            ;
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    return 0;
}
----------------------------------------

int main () {
    pthread_t thread;
    params_t *par;
    int i, status;
    for (i = 0; i < NUMTHREADS; i++) {
        par = (params_t *) malloc (sizeof (params_t));
        if (par == NULL) {
            printf ("allocating params_t");
            abort ();
        }
        par->id = i;
        status = pthread_create (&thread, NULL, hello, par);
        if (status != 0)
            exit (1);
    }
    sleep (3);
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10879420_10879707_32_65
10879420_10880066_25_44
Title: Using of shared variable by 10 pthreads 
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t params;
    pthread_mutex_init (& params.mutex, NULL);
    pthread_cond_init (& params.done, NULL);
    pthread_mutex_lock (& params.mutex);
    int i;
    for (i = 0; i < 10; i++) {
        params.id = i;
        pthread_create (& threads [i], NULL, hello, & params);
        pthread_cond_wait (& params.done, & params.mutex);
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    pthread_mutex_destroy (& params.mutex);
    pthread_cond_destroy (& params.done);
    return 0;
}
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t *params = 0;
    pthread_mutex_t main_mutex;
    pthread_mutex_init (& main_mutex, NULL);
    int i;
    for (i = 0; i < 10; i++) {
        params = new params_t ();
        params->id = i;
        params->mutex = &main_mutex;
        if (pthread_create (&threads[i], NULL, hello, params))
            ;
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10879420_10879707_32_65
10879420_48634168_28_50
Title: Using of shared variable by 10 pthreads 
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t params;
    pthread_mutex_init (& params.mutex, NULL);
    pthread_cond_init (& params.done, NULL);
    pthread_mutex_lock (& params.mutex);
    int i;
    for (i = 0; i < 10; i++) {
        params.id = i;
        pthread_create (& threads [i], NULL, hello, & params);
        pthread_cond_wait (& params.done, & params.mutex);
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    pthread_mutex_destroy (& params.mutex);
    pthread_cond_destroy (& params.done);
    return 0;
}
----------------------------------------

int main () {
    pthread_t thread;
    params_t *par;
    int i, status;
    for (i = 0; i < NUMTHREADS; i++) {
        par = (params_t *) malloc (sizeof (params_t));
        if (par == NULL) {
            printf ("allocating params_t");
            abort ();
        }
        par->id = i;
        status = pthread_create (&thread, NULL, hello, par);
        if (status != 0)
            exit (1);
    }
    sleep (3);
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10879420_10880066_12_22
10879420_48634168_12_26
Title: Using of shared variable by 10 pthreads 
----------------------------------------

void *hello (void *arg) {
    int id = 0;
    params_t *params = (params_t *) arg;
    if (params != 0) {
        id = params->id;
        delete params;
        params = 0;
    }
    printf ("Hello from %d\n", id);
}
----------------------------------------

void *hello (void *arg) {
    params_t *p = (params_t *) arg;
    int status;
    status = pthread_detach (pthread_self ());
    if (status != 0) {
        printf ("detaching thread\n");
        abort ();
    }
    printf ("Hello from %d\n", p -> id);
    free (p);
    return NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10879420_10880066_25_44
10879420_48634168_28_50
Title: Using of shared variable by 10 pthreads 
----------------------------------------

int main () {
    pthread_t threads [10];
    params_t *params = 0;
    pthread_mutex_t main_mutex;
    pthread_mutex_init (& main_mutex, NULL);
    int i;
    for (i = 0; i < 10; i++) {
        params = new params_t ();
        params->id = i;
        params->mutex = &main_mutex;
        if (pthread_create (&threads[i], NULL, hello, params))
            ;
    }
    for (i = 0; i < 10; i++) {
        pthread_join (threads [i], NULL);
    }
    return 0;
}
----------------------------------------

int main () {
    pthread_t thread;
    params_t *par;
    int i, status;
    for (i = 0; i < NUMTHREADS; i++) {
        par = (params_t *) malloc (sizeof (params_t));
        if (par == NULL) {
            printf ("allocating params_t");
            abort ();
        }
        par->id = i;
        status = pthread_create (&thread, NULL, hello, par);
        if (status != 0)
            exit (1);
    }
    sleep (3);
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10918078_10918400_1_13
10918078_10918420_1_18
Title: C two functions in one with casts 
----------------------------------------

void destroyList (void *ini, void *end, int listType) {
    NodeOne *aux = NULL;
    NodeOne **head = ini;
    NodeOne **tail = end;
    while (*head != NULL) {
        aux = *head;
        *head = (*head)->next;
        free (aux);
    }
    *tail = NULL;
}
----------------------------------------

void destroyList (void **ini, void **end, int listType) {
    void *aux;
    void *head = ini;
    void *tail = end;
    while (*head != NULL) {
        if (listType == 0) {
            aux = (NodeOne *) *head;
            *head = ((NodeOne *) *head)->next;
            free ((NodeOne *) aux;
        }
        else {
            ...same thing with casts to NodeTwo *...
        }
    }
    *tail = NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10968817_10968879_1_23
10968817_10969482_11_29
Title: Random guessing game (integer) - bug when entering string 
----------------------------------------

int main () {
    int secret, answer;
    char buff [128];
    srand ((unsigned) time (NULL));
    secret = rand () % 10 + 1;
    do {
        printf ("Guess a number between 1 and 10");
        scanf ("%s", buff);
        if ((answer = atoi (buff)) == 0) {
            printf ("\nPlease enter an integer\n\n");
            continue;
        }
        if (secret < answer)
            puts ("Guess a higher value");
        else if (secret > answer)
            puts ("Guess a lower value");
    }
    while (secret != answer);
    puts ("Congratz!");
    return 0;
}
----------------------------------------

int main () {
    char guess [3];
    int iGuess;
    do {
        printf ("Guess a number between 1 and 10");
        gets (guess);
        if (!isNumeric (guess)) {
            printf ("Invalid input");
            continue;
        }
        iGuess = atoi (guess);
        if (iGuess < secret)
            printf ("Higher");
        else if (iGuess > secret)
            printf ("Lower");
    }
    while (secret != iGuess);
    printf ("Congrats");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10972060_10972108_9_30
10972060_10972133_8_35
Title: C: How to store strings into a char *myArray[100] array? 
----------------------------------------

int main (void) {
    char myArray [MAX_NUMBER_OF_LINES] [MAX_LINE_LENGTH + 1];
    int numberLine = 0;
    FILE *file = fopen (filename, "r");
    if (file != NULL) {
        while (fgets (myArray[numberLine], MAX_LINE_LENGTH +1, file) != NULL) {
            numberLine++;
        }
        fclose (file);
    }
    for (int i = 0; i < numberLine; i++) {
        printf ("%d|%s", i, myArray [i]);
    }
}
----------------------------------------

int main (void) {
    char *myArray [MAX_NUMBER_OF_LINES];
    int numberLine = 0;
    FILE *file = fopen (filename, "r");
    if (file != NULL) {
        char line [128];
        while (fgets (line, sizeof line, file) != NULL) {
            myArray[numberLine] = (char *) malloc (sizeof line);
            strcpy (myArray [numberLine], line);
            numberLine++;
        }
        fclose (file);
    }
    for (int i = 0; i < numberLine; i++) {
        printf ("%d|%s", i, myArray [i]);
        free (myArray [i])
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
10996418_10997428_42_67
10996418_11005001_21_49
Title: Efficient integer compare function 
----------------------------------------

int main () {
    for (int i = 0; i < COUNT; i++) {
        for (int b = 0; b < sizeof (arr[i]); b++) {
            *((unsigned char *) &arr[i] + b) = rand ();
        }
    }
    int sum = 0;
    for (int l = 0; l < LOOPS; l++) {
        for (int i = 0; i < COUNT; i++) {
            for (int j = 0; j < COUNT; j++) {
                sum += COMPARE (arr[i], arr[j]);
            }
        }
    }
    printf ("%d=0\n", sum);
    return 0;
}
----------------------------------------

int main () {
    for (int i = 0; i < COUNT; i++) {
        for (int b = 0; b < sizeof (arr[i]); b++) {
            *((unsigned char *) &arr[i] + b) = rand ();
        }
    }
    vSInt32 vsum = _mm_set1_epi32 (0);
    for (int l = 0; l < LOOPS; l++) {
        for (int i = 0; i < COUNT; i++) {
            for (int j = 0; j < COUNT; j += 4) {
                vSInt32 v1 = _mm_loadu_si128 (&arr[i]);
                vSInt32 v2 = _mm_load_si128 (&arr[j]);
                vSInt32 v = COMPARE (v1, v2);
                vsum = _mm_add_epi32 (vsum, v);
            }
        }
    }
    printf ("vsum = %vd\n", vsum);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11015672_11015785_1_12
11015672_11016394_1_11
Title: gcc removes inline assembler code 
----------------------------------------

int main (void) {
    int x = 0;
    __asm__ __volatile__ ("" : "=r" (x));
    if (x) {
    handler :
        __asm__ __volatile__ ("jmp $0x0"
        );
    }
    return 0;
}
----------------------------------------

int main (void) {
    goto exit;
exit :
    __asm__ __volatile__ ("jmp 1f\n"
        "jmp $0x0\n"
        "1:\n"
    );
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11015672_11015785_1_12
11015672_48745576_1_15
Title: gcc removes inline assembler code 
----------------------------------------

int main (void) {
    int x = 0;
    __asm__ __volatile__ ("" : "=r" (x));
    if (x) {
    handler :
        __asm__ __volatile__ ("jmp $0x0"
        );
    }
    return 0;
}
----------------------------------------

int main (void) {
    {
        extern volatile unsigned int some_undefined_symbol;
        __asm__ __volatile__ (".pushsection .discard" : : : "memory");
        if (some_undefined_symbol)
            goto handler;
        __asm__ __volatile__ (".popsection" : : : "memory");
    }
    goto exit;
handler :
    __asm__ __volatile__ ("jmp 0x0"
    );
exit :
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11015672_11016394_1_11
11015672_48745576_1_15
Title: gcc removes inline assembler code 
----------------------------------------

int main (void) {
    goto exit;
exit :
    __asm__ __volatile__ ("jmp 1f\n"
        "jmp $0x0\n"
        "1:\n"
    );
    return 0;
}
----------------------------------------

int main (void) {
    {
        extern volatile unsigned int some_undefined_symbol;
        __asm__ __volatile__ (".pushsection .discard" : : : "memory");
        if (some_undefined_symbol)
            goto handler;
        __asm__ __volatile__ (".popsection" : : : "memory");
    }
    goto exit;
handler :
    __asm__ __volatile__ ("jmp 0x0"
    );
exit :
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11019557_11019675_1_11
11019557_11019773_4_16
Title: Create an array in a function in C 
----------------------------------------

int generateMatrices (int rows, int columns) {
    image = malloc (sizeof (int *) * rows;
    if (image == NULL)
        return 0;
    for (int i = 0; i < rows; i++) {
        image[i] = malloc (sizeof (int) * columns);
        if (image[i] == NULL)
            return 0;
    }
    return 1;
}
----------------------------------------

void generateMatrices () {
    if (image) {
        free (*image);
        free (image);
    }
    image = malloc (sizeof (int *) * width);
    image[0] = malloc (sizeof (int) * width * height);
    for (int i = 1; i < width; i++)
        image[i] = (image[0] + (i * height));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11102424_11114312_7_56
11102424_22950914_8_30
Title: Project Euler no. 16 
----------------------------------------

int main () {
    int array [1000] = {0};
    array[0] = 1;
    int i, j, cnt, div, carry, temp, sum;
    for (i = 0, cnt = 1; i < 1000; i++) {
        div = carry = 0;
        for (j = 0; j < 1000; j++) {
            if (carry != 0) {
                array[j] = (array[j] * 2) + carry;
                div = array[j] % 10;
                temp = array[j] / 10;
                array[j] = div;
                carry = temp;
            }
            else {
                array[j] = array[j] * 2;
                if (array[j] > 9) {
                    div = array[j] % 10;
                    carry = array[j] / 10;
                    array[j] = div;
                }
            }
        }
    }
    sum = temp = 0;
    printf ("The value of 2 ^ 1000 is : ");
    for (i = 999; i >= 0; i--) {
        if (array[i] || (temp)) {
            temp++;
            sum = sum + array[i];
            printf ("%d", array [i]);
        }
    }
    printf ("\nThe sum is : %d \n", sum);
    printf ("\nThe number of digits are : %d \n", temp);
    return 0;
}
----------------------------------------

int main (void) {
    for (int i = 0; i < POWER; i++)
        for (int n = 0, j = 0;; j++) {
            n += digits[j] * 2;
            digits[j] = n % 10;
            n /= 10;
            if (j == ndigits - 1) {
                if (!n)
                    break;
                ndigits++;
            }
        }
    int sum = 0;
    for (int i = 0; i < ndigits; i++)
        sum += digits[i];
    printf ("%d\n", sum);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11102424_11114312_7_56
11102424_28827700_5_30
Title: Project Euler no. 16 
----------------------------------------

int main () {
    int array [1000] = {0};
    array[0] = 1;
    int i, j, cnt, div, carry, temp, sum;
    for (i = 0, cnt = 1; i < 1000; i++) {
        div = carry = 0;
        for (j = 0; j < 1000; j++) {
            if (carry != 0) {
                array[j] = (array[j] * 2) + carry;
                div = array[j] % 10;
                temp = array[j] / 10;
                array[j] = div;
                carry = temp;
            }
            else {
                array[j] = array[j] * 2;
                if (array[j] > 9) {
                    div = array[j] % 10;
                    carry = array[j] / 10;
                    array[j] = div;
                }
            }
        }
    }
    sum = temp = 0;
    printf ("The value of 2 ^ 1000 is : ");
    for (i = 999; i >= 0; i--) {
        if (array[i] || (temp)) {
            temp++;
            sum = sum + array[i];
            printf ("%d", array [i]);
        }
    }
    printf ("\nThe sum is : %d \n", sum);
    printf ("\nThe number of digits are : %d \n", temp);
    return 0;
}
----------------------------------------

int main () {
    int a [10000] = {0};
    int m = 1;
    int carry = 0;
    a[0] = 1;
    long long int sum = 0;
    for (int i = 1; i <= 1000; i++) {
        for (int j = 0; j < m; j++) {
            int x = a[j] * 2 + carry;
            a[j] = x % 10;
            carry = x / 10;
        }
        while (carry != 0) {
            a[m++] = carry % 10;
            carry /= 10;
        }
    }
    for (int i = m - 1; i >= 0; i--)
        sum += a[i];
    printf ("%lld", sum);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11102424_22950914_8_30
11102424_28827700_5_30
Title: Project Euler no. 16 
----------------------------------------

int main (void) {
    for (int i = 0; i < POWER; i++)
        for (int n = 0, j = 0;; j++) {
            n += digits[j] * 2;
            digits[j] = n % 10;
            n /= 10;
            if (j == ndigits - 1) {
                if (!n)
                    break;
                ndigits++;
            }
        }
    int sum = 0;
    for (int i = 0; i < ndigits; i++)
        sum += digits[i];
    printf ("%d\n", sum);
    return 0;
}
----------------------------------------

int main () {
    int a [10000] = {0};
    int m = 1;
    int carry = 0;
    a[0] = 1;
    long long int sum = 0;
    for (int i = 1; i <= 1000; i++) {
        for (int j = 0; j < m; j++) {
            int x = a[j] * 2 + carry;
            a[j] = x % 10;
            carry = x / 10;
        }
        while (carry != 0) {
            a[m++] = carry % 10;
            carry /= 10;
        }
    }
    for (int i = m - 1; i >= 0; i--)
        sum += a[i];
    printf ("%lld", sum);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11117977_14778446_55_88
11117977_47918305_7_38
Title: How to use libevent and pthread together in C 
----------------------------------------

int main (int argc, char **argv) {
    if (argc < 2) {
        puts ("Timeout value missing.\n./demo <timeout>");
        return -1;
    }
    timeout = atof (argv[1]);
    struct ev_loop *loop = EV_DEFAULT;
    pthread_mutex_init (& lock, NULL);
    pthread_t thread;
    loop2 = ev_loop_new (0);
    ev_async_init (& async_watcher, async_cb);
    ev_async_start (loop2, & async_watcher);
    pthread_create (& thread, NULL, loop2thread, NULL);
    ev_timer_init (& timeout_watcher, timeout_cb, timeout, 0.);
    ev_timer_start (loop, & timeout_watcher);
    ev_loop (loop, 0);
    pthread_join (thread, NULL);
    pthread_mutex_destroy (& lock);
    return 0;
}
----------------------------------------

int main (void) {
    int32_t tid = 0, ret = -1;
    struct event_base *evbase;
    struct event *ev;
    int32_t *t_ret = &ret;
    struct timeval tv;
    evthread_use_pthreads ();
    ret = pthread_create (&tid, NULL, thread_func, NULL);
    evbase = event_base_new ();
    timer = event_new (evbase, -1, EV_PERSIST, callback_func, NULL);
    tv.tv_sec = 0;
    tv.tv_usec = 1000;
    evtimer_add (timer, & tv);
    event_base_dispatch (evbase);
    event_free (timer);
    event_base_free (evbase);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11140223_20494567_4_23
11140223_30811447_2_27
Title: "program that counts blanks tabs and newlines" 
----------------------------------------

int main () {
    printf ("Type and Press Enter. CTRL-Z for EOF:\n");
    int c;
    int b = 0;
    int t = 0;
    int nl = 0;
    while ((c = getchar ()) != EOF) {putchar (c);
    if (c == '\t')
        ++t;
    if (c == ' ')
        ++b;
    if (c == '\n') ++ nl
}
----------------------------------------

int main () {
    int c, nl, nb, nt;
    nl = 0;
    nb = 0;
    nt = 0;
    int flag = 1;
    while ((c = getchar ()) != EOF) {
        if (c == '\n') {
            ++nl;
            if (flag)
                ++nb;
            flag = 1;
        }
        else
            flag = 0;
        if (c == '\t')
            ++nt;
    }
    printf ("lines : %d, tabs: %d, blanks: %d", nl, nt, nb);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11143419_11144098_5_16
11143419_11148207_14_25
Title: Read a line of unknown format in C 
----------------------------------------

int main () {
    int c;
    while ((c = getchar ()) != EOF) {
        if (c == OLDCH)
            c = NEWCH;
        putchar (c);
    }
    return 0;
}
----------------------------------------

int main () {
    char line [256];
    FILE *fp;
    fp = fopen ("file.txt", "r");
    while (fscanf (fp, "%[^\n]%*[\n]", line) == 1) {
        printf ("%s\n", repchar (line, 'm', 'n'));
    }
    fclose (fp);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11183683_11183772_5_24
11183683_11192470_5_36
Title: How to split a char* to integer tables in C 
----------------------------------------

int main () {
    char string [] = "1 10 14 16", *next = NULL;
    int number [10] = {0}, noOfNumbers = 0, i = 0;
    next = strtok (string, " ");
    while (next != NULL) {
        number[noOfNumbers++] = atoi (next);
        next = strtok (NULL, " ");
    }
    for (i = 0; i < noOfNumbers; i++) {
        printf ("number[%d] = %d\n", i, number [i]);
    }
    return 0;
}
----------------------------------------

int main () {
    int i, j = 0, num = 0;
    int output [4];
    char temp [9] = {'\0'};
    char *input_string [] = {"1 10 14 16"};
    for (i = 0; *(*(input_string + 0) + i) != '\0';) {
        switch (*(*(input_string + 0) + i)) {
        case ' ' :
            i++;
            break;
        case '1' :
        case '2' :
        case '3' :
        case '4' :
        case '5' :
        case '6' :
        case '7' :
        case '8' :
        case '9' :
        case '0' :
            j = 0;
            while (*(*(input_string + 0) + i) != ' ' || j > 9) {
                temp[j] = *(*(input_string + 0) + i);
                i++;
                j++;
            }
            j++;
            temp[j] = '\0';
            output[num] = atoi (temp);
            num++;
            break;
        }
    }
    for (i = 0; i < 4; i++)
        printf ("%d ", output[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11219587_11220352_4_23
11219587_11220368_3_16
Title: Using sscanf() to output only 2 tokens from a line 
----------------------------------------

int main (void) {
    char buff [50];
    char *token;
    int number = 0;
    while (fgets (buff, sizeof (buff), stdin) != NULL) {
        if ((token = strtok (buff, " ")) != NULL) {
            ++number;
            while ((token = strtok (NULL, " ")) != NULL)
                ++number;
        }
        if (number == 2)
            printf ("Current line has two tokens\n");
        else
            printf ("current line has %d tokens\n", number);
        number = 0;
    }
    return 0;
}
----------------------------------------

int main (void) {
    char buff [50];
    char token1 [50], token2 [50];
    while (fgets (buff, sizeof (buff), stdin) != NULL) {
        if (sscanf (buff, "%s %s", token1, token2) == 2) {
            printf ("%s ", buff);
        }
    }
    return 0;
}
----------------------------------------
