$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_21156029_1_16
8106765_8106894_30_43
Title: Using strtok in c 
----------------------------------------

int main () {
    char str [] = "test string.";
    char *temp1;
    char *temp2;
    temp1 = strtok (str, " ");
    temp2 = strchr (str, ' ');
    if (temp2 != NULL)
        temp2++;
    printf ("Splitted string :%s, %s\n", temp1, temp2);
    return
}
----------------------------------------

int main () {
    char **tokens = tokenize ("test string.");
    char **it;
    for (it = tokens; it && *it; ++it) {
        printf ("%s\n", * it);
        free (*it);
    }
    free (tokens);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_21156029_1_16
8106765_8107930_4_13
Title: Using strtok in c 
----------------------------------------

int main () {
    char str [] = "test string.";
    char *temp1;
    char *temp2;
    temp1 = strtok (str, " ");
    temp2 = strchr (str, ' ');
    if (temp2 != NULL)
        temp2++;
    printf ("Splitted string :%s, %s\n", temp1, temp2);
    return
}
----------------------------------------

int main () {
    char str [] = "test string.";
    char *firstname = strtok (str, " ");
    char *lastname = strtok (NULL, " ");
    if (!lastname)
        lastname = "";
    printf ("%s, %s\n", lastname, firstname);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_21156029_1_16
8106765_8108355_42_60
Title: Using strtok in c 
----------------------------------------

int main () {
    char str [] = "test string.";
    char *temp1;
    char *temp2;
    temp1 = strtok (str, " ");
    temp2 = strchr (str, ' ');
    if (temp2 != NULL)
        temp2++;
    printf ("Splitted string :%s, %s\n", temp1, temp2);
    return
}
----------------------------------------

int main (void) {
    char str [] = "test string.";
    char **words;
    size_t len = 0;
    int i;
    words = split (str, " \t\r\n,.", &len);
    for (i = 0; i < len; ++i) {
        printf ("%s\n", words [i]);
    }
    free4split (words);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_8106848_7_32
8106765_8106894_30_43
Title: Using strtok in c 
----------------------------------------

int main () {
    char str [] = "test string.";
    char *names [MAX_NAMES] = {0};
    char *test;
    int i = 0;
    test = strtok (str, " ");
    while (test != NULL && i < MAX_NAMES) {
        names[i] = malloc (strlen (test) +1);
        strcpy (names [i ++], test);
        test = strtok (NULL, " ");
    }
    for (i = 0; i < MAX_NAMES; ++i) {
        if (names[i]) {
            puts (names [i]);
            free (names [i]);
            names[i] = 0;
        }
    }
    return 0;
}
----------------------------------------

int main () {
    char **tokens = tokenize ("test string.");
    char **it;
    for (it = tokens; it && *it; ++it) {
        printf ("%s\n", * it);
        free (*it);
    }
    free (tokens);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_8106848_7_32
8106765_8107930_4_13
Title: Using strtok in c 
----------------------------------------

int main () {
    char str [] = "test string.";
    char *names [MAX_NAMES] = {0};
    char *test;
    int i = 0;
    test = strtok (str, " ");
    while (test != NULL && i < MAX_NAMES) {
        names[i] = malloc (strlen (test) +1);
        strcpy (names [i ++], test);
        test = strtok (NULL, " ");
    }
    for (i = 0; i < MAX_NAMES; ++i) {
        if (names[i]) {
            puts (names [i]);
            free (names [i]);
            names[i] = 0;
        }
    }
    return 0;
}
----------------------------------------

int main () {
    char str [] = "test string.";
    char *firstname = strtok (str, " ");
    char *lastname = strtok (NULL, " ");
    if (!lastname)
        lastname = "";
    printf ("%s, %s\n", lastname, firstname);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_8106848_7_32
8106765_8108355_42_60
Title: Using strtok in c 
----------------------------------------

int main () {
    char str [] = "test string.";
    char *names [MAX_NAMES] = {0};
    char *test;
    int i = 0;
    test = strtok (str, " ");
    while (test != NULL && i < MAX_NAMES) {
        names[i] = malloc (strlen (test) +1);
        strcpy (names [i ++], test);
        test = strtok (NULL, " ");
    }
    for (i = 0; i < MAX_NAMES; ++i) {
        if (names[i]) {
            puts (names [i]);
            free (names [i]);
            names[i] = 0;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    char str [] = "test string.";
    char **words;
    size_t len = 0;
    int i;
    words = split (str, " \t\r\n,.", &len);
    for (i = 0; i < len; ++i) {
        printf ("%s\n", words [i]);
    }
    free4split (words);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_8106894_30_43
8106765_8107930_4_13
Title: Using strtok in c 
----------------------------------------

int main () {
    char **tokens = tokenize ("test string.");
    char **it;
    for (it = tokens; it && *it; ++it) {
        printf ("%s\n", * it);
        free (*it);
    }
    free (tokens);
    return 0;
}
----------------------------------------

int main () {
    char str [] = "test string.";
    char *firstname = strtok (str, " ");
    char *lastname = strtok (NULL, " ");
    if (!lastname)
        lastname = "";
    printf ("%s, %s\n", lastname, firstname);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_8106894_30_43
8106765_8108355_42_60
Title: Using strtok in c 
----------------------------------------

int main () {
    char **tokens = tokenize ("test string.");
    char **it;
    for (it = tokens; it && *it; ++it) {
        printf ("%s\n", * it);
        free (*it);
    }
    free (tokens);
    return 0;
}
----------------------------------------

int main (void) {
    char str [] = "test string.";
    char **words;
    size_t len = 0;
    int i;
    words = split (str, " \t\r\n,.", &len);
    for (i = 0; i < len; ++i) {
        printf ("%s\n", words [i]);
    }
    free4split (words);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_8107930_4_13
8106765_8108355_42_60
Title: Using strtok in c 
----------------------------------------

int main () {
    char str [] = "test string.";
    char *firstname = strtok (str, " ");
    char *lastname = strtok (NULL, " ");
    if (!lastname)
        lastname = "";
    printf ("%s, %s\n", lastname, firstname);
    return 0;
}
----------------------------------------

int main (void) {
    char str [] = "test string.";
    char **words;
    size_t len = 0;
    int i;
    words = split (str, " \t\r\n,.", &len);
    for (i = 0; i < len; ++i) {
        printf ("%s\n", words [i]);
    }
    free4split (words);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8147175_8147333_6_16
8147175_8147348_5_20
Title: How to convert long long ASCII hex values into a string? 
----------------------------------------

int main (void) {
    char myBuffer [9];
    long long myLongLong = 0x7177657274797569;
    char *c_ptr = (char *) &myLongLong;
    sprintf (myBuffer, "%c%c%c%c%c%c%c%c", c_ptr [0], c_ptr [1], c_ptr [2], c_ptr [3], c_ptr [4], c_ptr [5], c_ptr [6], c_ptr [7]);
    int x;
    cout << myBuffer;
    cin >> x;
    return 0;
}
----------------------------------------

int main (void) {
    char myBuffer [8];
    long long myLongLong = 0x7177657274797569;
    for (int i = 0; i < 8; i++) {
        myBuffer[i] = myLongLong >> (64 - (i + 1) * 8);
    }
    cout << myBuffer << endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8193512_8193606_1_15
8193512_8193634_4_13
Title: fork() used as for cycle condition generates race condition? 
----------------------------------------

int main () {
    int i;
    i = 2;
    while (i >= 1) {
        if (fork () != 0)
            break;
        printf ("%d\n", i);
        i--;
    }
    exit (EXIT_SUCCESS);
}
----------------------------------------

int main () {
    int i;
    for (i = 2; i >= 1; i--)
        if (fork ())
            break;
        else
            printf ("%d\n", i);
    exit (EXIT_SUCCESS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8208021_48614746_3_27
8208021_8210302_3_11
Title: How to increment a pointer address and pointer's value? 
----------------------------------------

int main () {
    static int x = 5;
    static int *p = &x;
    printf ("(int) p   => %d\n", (int) p);
    printf ("(int) p++ => %d\n", (int) p ++);
    x = 5;
    p = &x;
    printf ("(int) ++p => %d\n", (int) ++ p);
    x = 5;
    p = &x;
    printf ("++*p      => %d\n", ++ * p);
    x = 5;
    p = &x;
    printf ("++(*p)    => %d\n", ++ (* p));
    x = 5;
    p = &x;
    printf ("++*(p)    => %d\n", ++ * (p));
    x = 5;
    p = &x;
    printf ("*p++      => %d\n", * p ++);
    x = 5;
    p = &x;
    printf ("(*p)++    => %d\n", (* p) ++);
    x = 5;
    p = &x;
    printf ("*(p)++    => %d\n", * (p) ++);
    x = 5;
    p = &x;
    printf ("*++p      => %d\n", * ++ p);
    x = 5;
    p = &x;
    printf ("*(++p)    => %d\n", * (++ p));
    return 0;
}
----------------------------------------

int main () {
    int a = 100;
    int *p = &a;
    printf ("%p\n", (void *) p);
    ++(*p++);
    printf ("%p\n", (void *) p);
    printf ("%d\n", a);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8227296_8227312_1_18
8227296_8227609_4_22
Title: How to change vowels in a string to a symbol? 
----------------------------------------

int main (void) {
    char input [50];
    int i;
    printf ("Please enter a sentence: ");
    fgets (input, 50, stdin);
    for (i = 0; input[i] != '\0'; i++) {
        if (input[i] == 'a' || input[i] == 'e' || input[i] == 'i' || input[i] == 'o' || input[i] == 'u') {
            input[i] = '$';
        }
    }
    printf ("Your new sentence is: %s", input);
    return 0;
}
----------------------------------------

int main (void) {
    char input [50];
    char i;
    int j = 0;
    printf ("Please enter a sentence: ");
    fgets (input, 50, stdin);
    printf ("\ninput: %s", input);
    for (j = 0; input[j] != '\0'; j++) {
        if (input[j] == 'a' || input[j] == 'e' || input[j] == 'i' || input[j] == 'o' || input[j] == 'u') {
            input[j] = '$';
        }
    }
    printf ("Your new sentence is: %s", input);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8239946_8240138_4_19
8239946_8247223_10_23
Title: How to use c time in linux to print the function running time? 
----------------------------------------

int main () {
    timeval begin;
    : : gettimeofday (& begin, 0);
    : : usleep (153);
    : : timeval current;
    : : gettimeofday (& current, (struct timezone *) 0);
    double elapsed = (current.tv_sec - begin.tv_sec) + ((current.tv_usec - begin.tv_usec) / 1000000.0F);
std :
    : cout << elapsed << std : : endl;
    return 0;
}
----------------------------------------

int main () {
    int i = 0;
    int p = (int) getpid ();
    clock_t cstart = clock ();
    clock_t cend = 0;
    for (i = 0; i < 1000000; i++) {
        long f = fib (i % 16);
        if (i % p == 0)
            printf ("i=%d, f=%ld\n", i, f);
    }
    cend = clock ();
    printf ("%.3f cpu sec\n", ((double) cend - (double) cstart) * 1.0e-6);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8259817_8259969_3_13
8259817_8260307_16_26
Title: How to track malloc and free? 
----------------------------------------

void *MyMalloc (int size) {
    char *buffer = (char *) malloc (size + sizeof (int));
    if (buffer == NULL)
        return NULL;
    usedMemory += size;
    int *sizeBox = (int *) buffer;
    *sizeBox = size;
    return buffer + sizeof (int);
}
----------------------------------------

void *MyMalloc (int size) {
    if (mem.current < MAXMEMBLOCKS) {
        mem.current += size;
        mem.memblocks[mem.current].size = size;
        mem.memblocks[mem.current].ptr = malloc (size);
        return mem.memblocks[mem.current++].ptr;
    }
    else {
        return NULL;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8293775_8309514_7_38
8293775_8325050_37_54
Title: Live graph for a C application 
----------------------------------------

int main (int argc, char **argv) {
    FILE *f;
    gsl_rng *r = NULL;
    const gsl_rng_type *T;
    int seed = 31456;
    double rndnum;
    T = gsl_rng_ranlxs2;
    r = gsl_rng_alloc (T);
    gsl_rng_set (r, seed);
    time_t t;
    t = time (NULL);
    f = fopen ("test.lgdat", "a");
    fprintf (f, "##;##\n");
    fprintf (f, "@LiveGraph test file.\n");
    fprintf (f, "Time;Dataset number\n");
    for (;;) {
        rndnum = gsl_ran_gaussian (r, 1);
        fprintf (f, "%f;%f\n", (double) t, rndnum);
        sleep (1);
        fflush (f);
        t = time (NULL);
    }
    gsl_rng_free (r);
    return 0;
}
----------------------------------------

int main (int argc, const char **argv) {
    bool plot = false;
    if (argc == 2 && strcmp (argv[1], "--plot-data") == 0)
        plot = true;
    if (plot)
        initializePlotting ();
    int i = 0;
    for (i = 0; i < 1000; i++) {
        double x = myRandom (), y = myRandom ();
        if (plot)
            plotPoint2d (x, y);
        else
            printf ("%f %f\n", x, y);
    }
    if (plot)
        uninitializePlotting ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8300888_37949828_1_19
8300888_42166389_1_15
Title: Calculating the sum of integers in an array 
----------------------------------------

int main () {
    int a [10];
    int i, j;
    int x = 0;
    printf ("Enter no of arrays:");
    scanf ("%d", & j);
    printf ("Enter nos:");
    for (i = 0; i < j; i++) {
        scanf ("%d", & a [i]);
    }
    for (i = 0; i < j; i++) {
        x = x + a[i];
    }
    printf ("Sum of Array=%d", x);
    return 0;
}
----------------------------------------

void main () {
    int array [10];
    int i;
    int sum = 0;
    for (i = 0; i < 11; i++) {
        scanf ("%d", & array [i]);
    }
    for (i = 0; i < 11; i++) {
        sum = sum + array[i];
    }
    printf ("%d", sum);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8310749_39267945_1_54
8310749_8311564_56_77
Title: Discrete Cosine Transform DCT implementation C 
----------------------------------------

void idct (float dctMatrix [8] [8]) {
    double idct, Cu, sum, Cv;
    int i, j, u, v;
    float idctMatrix [8] [8], greyLevel;
    FILE *fp = fopen ("mydata.csv", "a");
    fprintf (fp, "\n Inverse DCT");
    for (i = 0; i < 8; ++i) {
        for (j = 0; j < 8; ++j) {
            sum = 0.0;
            for (u = 0; u < 8; u++) {
                for (v = 0; v < 8; v++) {
                    if (u == 0) {
                        Cu = 1.0 / sqrt (2.0);
                    }
                    else {
                        Cu = 1.0;
                    }
                    if (v == 0) {
                        Cv = 1.0 / sqrt (2.0);
                    }
                    else {
                        Cv = (1.0);
                    }
                    greyLevel = dctMatrix[u][v];
                    idct = (greyLevel * Cu * Cv * cos ((2 * i + 1) * u * PI / 16.0) * cos ((2 * j + 1) * v * PI / 16.0));
                    sum += idct;
                }
            }
            idctMatrix[i][j] = 0.25 * sum;
            fprintf (fp, "\n %f", idctMatrix [i] [j]);
        }
        fprintf (fp, "\n");
    }
}
----------------------------------------

void idct (float **Matrix, float **DCTMatrix, int N, int M) {
    int i, j, u, v;
    for (u = 0; u < N; ++u) {
        for (v = 0; v < M; ++v) {
            Matrix[u][v] = 1 / 4.* DCTMatrix[0][0];
            for (i = 1; i < N; i++) {
                Matrix[u][v] += 1 / 2.* DCTMatrix[i][0];
            }
            for (j = 1; j < M; j++) {
                Matrix[u][v] += 1 / 2.* DCTMatrix[0][j];
            }
            for (i = 1; i < N; i++) {
                for (j = 1; j < M; j++) {
                    Matrix[u][v] += DCTMatrix[i][j] * cos (M_PI / ((float) N) * (u + 1./ 2.) * i) * cos (M_PI / ((float) M) * (v + 1./ 2.) * j);
                }
            }
            Matrix[u][v] *= 2./ ((float) N) * 2./ ((float) M);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8313956_8314221_6_40
8313956_8316501_64_86
Title: Find and replace function 
----------------------------------------

int main () {
    const char fileOrig [32] = "myOriginalFile.txt";
    const char fileRepl [32] = "myReplacedFile.txt";
    const char text2find [80] = "lookforme";
    const char text2repl [80] = "REPLACE_WITH_THIS";
    char buffer [MAX_LEN_SINGLE_LINE + 2];
    char *buff_ptr, *find_ptr;
    FILE *fp1, *fp2;
    size_t find_len = strlen (text2find);
    fp1 = fopen (fileOrig, "r");
    fp2 = fopen (fileRepl, "w");
    while (fgets (buffer, MAX_LEN_SINGLE_LINE +2, fp1)) {
        buff_ptr = buffer;
        while ((find_ptr = strstr (buff_ptr, text2find))) {
            while (buff_ptr < find_ptr)
                fputc ((int) *buff_ptr++, fp2);
            fputs (text2repl, fp2);
            buff_ptr += find_len;
        }
        fputs (buff_ptr, fp2);
    }
    fclose (fp2);
    fclose (fp1);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc == 5) {
        searchAndReplace (argv [1], argv [2], argv [3], argv [4]);
    }
    else if (argc == 1) {
        char origin_file [128];
        char destination_file [128];
        char search_string [128];
        char replacement_string [128];
        askUserForInput (origin_file, "Enter origin file please");
        askUserForInput (destination_file, "Enter destination file please");
        askUserForInput (search_string, "Enter search string please");
        askUserForInput (replacement_string, "Enter replacement string please");
        searchAndReplace (origin_file, destination_file, search_string, replacement_string);
    }
    else {
        printf ("Usage:\n %s <original_filename> <modified_filename> <string_to_search> <replacement_string>\n or" "%s without parameter for asking for input", argv [0], argv [0]);
        exit (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8341239_20292117_4_31
8341239_51781439_7_27
Title: Calculating the sum of digits times the length of string 
----------------------------------------

void main () {
    const int SIZE = 10;
    char myArray [SIZE];
    int length = 0, sum = 0;
    cout << "enter Array of digit from 1-9\n\n ";
    cin >> myArray;
    cout << myArray << endl;
    for (int i = 0; i < myArray[i]; i++) {
        if (!isspace (myArray[i]))
            length++;
    }
    cout << length << endl;
    for (int i = 0; i < length; i++) {
        sum += myArray[i] - '0';
    }
    cout << sum;
}
----------------------------------------

int main (int argc, char **argv) {
    char nums [] = "314156";
    int i, tmp;
    char tmpc [2];
    int length = strlen (nums);
    int results [LENGTH];
    results[0] = 0;
    tmpc[0] = nums[0];
    sscanf (tmpc, "%d", & tmp);
    results[1] = tmp;
    int result = results[1];
    for (i = 2; i < length; ++i) {
        tmpc[0] = nums[i];
        sscanf (tmpc, "%d", & tmp);
        result += tmp;
        results[i] = result;
    }
    printResults (results, length);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8341239_20292117_4_31
8341239_8343001_12_22
Title: Calculating the sum of digits times the length of string 
----------------------------------------

void main () {
    const int SIZE = 10;
    char myArray [SIZE];
    int length = 0, sum = 0;
    cout << "enter Array of digit from 1-9\n\n ";
    cin >> myArray;
    cout << myArray << endl;
    for (int i = 0; i < myArray[i]; i++) {
        if (!isspace (myArray[i]))
            length++;
    }
    cout << length << endl;
    for (int i = 0; i < length; i++) {
        sum += myArray[i] - '0';
    }
    cout << sum;
}
----------------------------------------

int main () {
    char nums [] = "314156";
    int size = sizeof (nums) / sizeof (char);
    int i;
    for (i = 0; i < size; ++i) {
        printf ("%d time loop sum is %d\n", i + 1, sum (nums [i]));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8341239_51781439_7_27
8341239_8343001_12_22
Title: Calculating the sum of digits times the length of string 
----------------------------------------

int main (int argc, char **argv) {
    char nums [] = "314156";
    int i, tmp;
    char tmpc [2];
    int length = strlen (nums);
    int results [LENGTH];
    results[0] = 0;
    tmpc[0] = nums[0];
    sscanf (tmpc, "%d", & tmp);
    results[1] = tmp;
    int result = results[1];
    for (i = 2; i < length; ++i) {
        tmpc[0] = nums[i];
        sscanf (tmpc, "%d", & tmp);
        result += tmp;
        results[i] = result;
    }
    printResults (results, length);
    return 0;
}
----------------------------------------

int main () {
    char nums [] = "314156";
    int size = sizeof (nums) / sizeof (char);
    int i;
    for (i = 0; i < size; ++i) {
        printf ("%d time loop sum is %d\n", i + 1, sum (nums [i]));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8371877_44884859_4_21
8371877_44893150_5_15
Title: Ncurses and Linux pipeline 
----------------------------------------

int main (int argc, char **argv) {
    FILE *f = fopen ("/dev/tty", "r+");
    SCREEN *screen = newterm (NULL, f, f);
    set_term (screen);
    fprintf (stdout, "hello\n");
    fprintf (stderr, "some error\n");
    mvprintw (0, 0, "hello ncurses");
    refresh ();
    getch ();
    endwin ();
    return 0;
}
----------------------------------------

int main (int _argc, char **_argv) {
    newterm (NULL, stderr, stdin);
    printw ("Hello World !!!");
    refresh ();
    getch ();
    printf ("GOT HERE");
    endwin ();
    printf ("GOT HERE");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8378079_8378130_1_25
8378079_8378149_1_21
Title: C - Call by Reference 
----------------------------------------

void insertNode (int data, node **qRef, node *parent) {
    node *q;
    int i;
    for (; (q = *qRef); parent = q) {
        if (q->left >= q->right) {
            q->right++;
            qRef = &q->rightChild;
        }
        else {
            q->left++;
            qRef = &q->leftChild;
        }
    }
    *qRef = q = createNode (data);
    q->parent = parent;
    q->key = generateKey (q);
    for (i = 0; table[i][1] != 0; i++) {
    }
    table[i][1] = q->data;
    table[i][0] = q->key;
}
----------------------------------------

void insertNode (int data, node **qRef, node *parent) {
    node *q = *qRef;
    if (q == NULL) {
        node *p = createNode (data);
        p->parent = parent;
        p->key = generateKey (p);
        int i;
        for (i = 0; table[i][1] != 0; i++)
            ;
        table[i][1] = p->data;
        table[i][0] = p->key;
        *qRef = p;
    }
    else if (q->left > q->right || q->left == q->right) {
        q->right++;
        insertNode (data, & (q -> rightChild), q);
    }
    else if (q->right > q->left) {
        q->left++;
        insertNode (data, & (q -> leftChild), q);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8403731_8407559_3_18
8403731_8414012_1_13
Title: GTK and scrolling text view 
----------------------------------------

GtkWidget *createConsoleBox () {
    GtkWidget *textArea = gtk_text_view_new ();
    GtkWidget *scrollbar = gtk_vscrollbar_new (gtk_text_view_get_vadjustment (GTK_TEXT_VIEW (textArea)));
    GtkWidget *textEntry = gtk_entry_new ();
    GtkWidget *console = gtk_table_new (3, 2, FALSE);
    gtk_table_attach_defaults (GTK_TABLE (console), textArea, 0, 1, 0, 1);
    gtk_table_attach_defaults (GTK_TABLE (console), scrollbar, 1, 2, 0, 1);
    gtk_table_attach_defaults (GTK_TABLE (console), textEntry, 0, 2, 1, 2);
    gtk_widget_set_size_request (textArea, 320, 240);
    return console;
}
----------------------------------------

GtkWidget *createConsoleBox () {
    GtkWidget *textArea = gtk_text_view_new ();
    GtkWidget *scrolledwindow = gtk_scrolled_window_new (NULL, NULL);
    GtkWidget *textEntry = gtk_entry_new ();
    GtkWidget *console = gtk_table_new (3, 1, FALSE);
    gtk_container_add (GTK_CONTAINER (scrolledwindow), textArea);
    gtk_table_attach_defaults (GTK_TABLE (console), scrolledwindow, 0, 1, 0, 1);
    gtk_table_attach_defaults (GTK_TABLE (console), textEntry, 0, 1, 1, 2);
    return console;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8429940_8433897_5_27
8429940_8437436_4_19
Title: parsing a string into separate strings 
----------------------------------------

int main () {
    char source [] = "v=0 o=sip_user IN 10230 22472 IP4 10.10.10.44 s=SIP_CALL c=IN IP4 10.10.10.44 m=audio 49152 RTP/AVP 0 8 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000";
    char *str [7];
    char *pf = source, *ps;
    int i;
    for (i = 0; i < 7; i++) {
        pf = strchr (pf, '=');
        ps = strchr (pf +1, '=');
        if (ps == NULL)
            ps = source + sizeof (source) / sizeof (char);
        else
            ps -= 2;
        pf -= 1;
        str[i] = (char *) malloc ((ps - pf + 1) * sizeof (char));
        strncpy (str [i], pf, ps - pf);
        pf += 2;
    }
    for (i = 0; i < 7; i++)
        printf ("str%d %s\n", i +1, str[i]);
    for (i = 0; i < 7; i++)
        free (str[i]);
    return 0;
}
----------------------------------------

int main () {
    char input [] = "v=0 o=sip_user IN 10230 22472 IP4 10.10.10.44 s=SIP_CALL c=IN IP4 10.10.10.44 m=audio 49152 RTP/AVP 0 8 a=rtpmap:0 PCMU/8000 a=rtpmap:8 PCMA/8000";
    char *parts [16] = {0};
    int top = 0;
    int i;
    char *s = input;
    while (top < 15 && (s = strchr (s, '='))) {
        parts[top++] = s - 1;
        s++;
    }
    for (i = 1; parts[i]; i++)
        parts[i][-1] = '\0';
    for (i = 0; parts[i]; i++)
        printf ("%s\n", parts[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
844847_39757678_11_25
844847_844853_8_23
Title: "peek at input buffer and flush extra characters in C" 
----------------------------------------

int main () {
    char input;
    scanf ("%c", & input);
    clear_buffer ();
    printf ("%c\n", input);
    scanf ("%c", & input);
    clear_buffer ();
    printf ("%c\n", input);
    return 0;
}
----------------------------------------

int main () {
    char buf [BUFSZ + 1];
    int rc = scanf ("%" xstr (BUFSZ) "[^\n]%*[^\n]", buf);
    if (!feof (stdin)) {
        getchar ();
    }
    while (rc == 1) {
        printf ("Your string is: %s\n", array);
        fflush (stdout);
        rc = scanf ("%" xstr (LENGTH) "[^\n]%*[^\n]", array);
        if (!feof (stdin)) {
            getchar ();
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8464936_16374718_1_14
8464936_42152871_1_19
Title: Caesar's Cipher Code 
----------------------------------------

void caesar (char cipher [], int shift) {
    int i = 0;
    while (cipher[i] != '\0') {
        if (cipher[i] >= 'A' && cipher[i] <= 'Z') {
            char newletter = cipher[i] - 'A';
            newletter += shift;
            newletter = newletter % 26;
            cipher[i] = newletter + 'A';
        }
        i++;
    }
    printf ("%s", cipher);
}
----------------------------------------

void caesar (char cipher [], int shift) {
    int i = 0;
    while (cipher[i] != '\0') {
        if (cipher[i] >= 'A' && cipher[i] <= 'Z') {
            char newletter = cipher[i] - 'A' + 26;
            newletter += shift;
            newletter = newletter % 26;
            cipher[i] = newletter + 'A';
        }
        else if (cipher[i] >= '0' && cipher[i] <= '9') {
            char newletter = cipher[i] - '0' + 10;
            newletter += shift;
            newletter = newletter % 10;
            cipher[i] = newletter + '0';
        }
        i++;
    }
    printf ("%s\n", cipher);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8465006_19315089_3_15
8465006_31072377_6_17
Title: How do I concatenate two strings in C? 
----------------------------------------

int main () {
    int a, l;
    char str [50], str1 [50], str3 [100];
    printf ("\nEnter a string: ");
    scanf ("%s", str);
    str3[0] = '\0';
    printf ("\nEnter the string which you want to concat with string one: ");
    scanf ("%s", str1);
    strcat (str3, str);
    strcat (str3, str1);
    printf ("\nThe string is %s\n", str3);
}
----------------------------------------

int main () {
    char s1 [] = "oppa";
    char s2 [] = "gangnam";
    char s3 [] = "style";
    {
        char result [STR_SIZE] = {0};
        snprintf (result, sizeof (result), "%s %s %s", s1, s2, s3);
        printf ("%s\n", result);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8465006_19315089_3_15
8465006_51695663_4_26
Title: How do I concatenate two strings in C? 
----------------------------------------

int main () {
    int a, l;
    char str [50], str1 [50], str3 [100];
    printf ("\nEnter a string: ");
    scanf ("%s", str);
    str3[0] = '\0';
    printf ("\nEnter the string which you want to concat with string one: ");
    scanf ("%s", str1);
    strcat (str3, str);
    strcat (str3, str1);
    printf ("\nThe string is %s\n", str3);
}
----------------------------------------

int main () {
    char str1 [MAX], str2 [MAX], str3 [MAX];
    int i, j = 0, count = 0;
    printf ("Input string 1: ");
    gets (str1);
    printf ("\nInput string 2: ");
    gets (str2);
    for (i = 0; str1[i] != '\0'; i++) {
        str3[i] = str1[i];
        count++;
    }
    for (i = count; str2[j] != '\0'; i++) {
        str3[i] = str2[j];
        j++;
    }
    str3[i] = '\0';
    printf ("\nConcatenated string : ");
    puts (str3);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8465006_19315089_3_15
8465006_8465127_5_22
Title: How do I concatenate two strings in C? 
----------------------------------------

int main () {
    int a, l;
    char str [50], str1 [50], str3 [100];
    printf ("\nEnter a string: ");
    scanf ("%s", str);
    str3[0] = '\0';
    printf ("\nEnter the string which you want to concat with string one: ");
    scanf ("%s", str1);
    strcat (str3, str);
    strcat (str3, str1);
    printf ("\nThe string is %s\n", str3);
}
----------------------------------------

int main (void) {
    const char str1 [] = "First";
    const char str2 [] = "Second";
    char *res;
    res = malloc (strlen (str1) +strlen (str2) + 1);
    if (!res) {
        fprintf (stderr, "malloc() failed: insufficient memory!\n");
        return EXIT_FAILURE;
    }
    strcpy (res, str1);
    strcat (res, str2);
    printf ("Result: '%s'\n", res);
    free (res);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8465006_31072377_6_17
8465006_51695663_4_26
Title: How do I concatenate two strings in C? 
----------------------------------------

int main () {
    char s1 [] = "oppa";
    char s2 [] = "gangnam";
    char s3 [] = "style";
    {
        char result [STR_SIZE] = {0};
        snprintf (result, sizeof (result), "%s %s %s", s1, s2, s3);
        printf ("%s\n", result);
    }
}
----------------------------------------

int main () {
    char str1 [MAX], str2 [MAX], str3 [MAX];
    int i, j = 0, count = 0;
    printf ("Input string 1: ");
    gets (str1);
    printf ("\nInput string 2: ");
    gets (str2);
    for (i = 0; str1[i] != '\0'; i++) {
        str3[i] = str1[i];
        count++;
    }
    for (i = count; str2[j] != '\0'; i++) {
        str3[i] = str2[j];
        j++;
    }
    str3[i] = '\0';
    printf ("\nConcatenated string : ");
    puts (str3);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8465006_31072377_6_17
8465006_8465127_5_22
Title: How do I concatenate two strings in C? 
----------------------------------------

int main () {
    char s1 [] = "oppa";
    char s2 [] = "gangnam";
    char s3 [] = "style";
    {
        char result [STR_SIZE] = {0};
        snprintf (result, sizeof (result), "%s %s %s", s1, s2, s3);
        printf ("%s\n", result);
    }
}
----------------------------------------

int main (void) {
    const char str1 [] = "First";
    const char str2 [] = "Second";
    char *res;
    res = malloc (strlen (str1) +strlen (str2) + 1);
    if (!res) {
        fprintf (stderr, "malloc() failed: insufficient memory!\n");
        return EXIT_FAILURE;
    }
    strcpy (res, str1);
    strcat (res, str2);
    printf ("Result: '%s'\n", res);
    free (res);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8465006_51695663_4_26
8465006_8465127_5_22
Title: How do I concatenate two strings in C? 
----------------------------------------

int main () {
    char str1 [MAX], str2 [MAX], str3 [MAX];
    int i, j = 0, count = 0;
    printf ("Input string 1: ");
    gets (str1);
    printf ("\nInput string 2: ");
    gets (str2);
    for (i = 0; str1[i] != '\0'; i++) {
        str3[i] = str1[i];
        count++;
    }
    for (i = count; str2[j] != '\0'; i++) {
        str3[i] = str2[j];
        j++;
    }
    str3[i] = '\0';
    printf ("\nConcatenated string : ");
    puts (str3);
    return 0;
}
----------------------------------------

int main (void) {
    const char str1 [] = "First";
    const char str2 [] = "Second";
    char *res;
    res = malloc (strlen (str1) +strlen (str2) + 1);
    if (!res) {
        fprintf (stderr, "malloc() failed: insufficient memory!\n");
        return EXIT_FAILURE;
    }
    strcpy (res, str1);
    strcat (res, str2);
    printf ("Result: '%s'\n", res);
    free (res);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8476379_8479993_22_31
8476379_8482373_3_14
Title: C Library function for converting a string of hex digits to ints? 
----------------------------------------

int main (void) {
    int values [10];
    int len = string_to_array ("17bzzf59c", values);
    int i = 0;
    for (i = 0; i < len; i++)
        printf ("%x ", values[i]);
    printf ("\n");
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    char data [] = "17bf59c";
    const int len = sizeof (data) / sizeof (char) - 1;
    int i, value [sizeof (data) / sizeof (char) - 1];
    for (i = 0; i < len; ++i)
        sscanf (data +i, "%1x", value +i);
    for (i = 0; i < len; ++i)
        printf ("0x%x\n", value[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8487380_8487628_20_40
8487380_8487738_14_26
Title: How to cast an integer to void pointer? 
----------------------------------------

int main (void) {
    struct th th [5];
    int t;
    int i;
    int status;
    void *ret;
    for (i = 0; i < 5; i++) {
        th[i].id = i;
        status = pthread_create (&th[i].thread, NULL, print, &th[i]);
        if (status) {
            printf ("Error creating threads\n");
            exit (0);
        }
    }
    for (i = 0; i < 5; i++) {
        pthread_join (th [i].thread, & ret);
        printf ("%d--->%d\n", th [i].id, th [i].ret);
    }
    pthread_exit (NULL);
}
----------------------------------------

int main () {
    int i;
    pthread_t threads [N];
    for (i = 0; i < N; i++) {
        pthread_create (& threads [i], NULL, thread_func, & i);
    }
    for (i = 0; i < N; i++) {
        pthread_join (threads [i], NULL);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8504776_8504842_1_20
8504776_8506557_1_12
Title: A node having itself in its adjacency list 
----------------------------------------

void buildList () {
    adj[0] = malloc (1 * sizeof (*v));
    adj[0]->num = 1;
    adj[0]->next = adj[0];
    Vertex *v = adj[0];
    while (v != v->next)
        v = v->next;
    int i;
    int num_nodes = 1;
    for (i = 1; i < num_nodes; i++) {
        v->next = malloc (1 * sizeof (*v));
        v = v->next;
        v->num = i;
        v->next = v;
    }
}
----------------------------------------

void buildList () {
    adj[0] = malloc (1 * sizeof (*adj[0]));
    if (adj[0] == NULL) {
        perror ("Allocation of Vertex failed\n");
        exit (EXIT_FAILURE);
    }
    adj[0]->num = 1;
    adj[0]->next = adj[0];
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8515782_8515973_3_15
8515782_8516829_4_22
Title: read string of character and assign it to an array 
----------------------------------------

int readBigNum (char *n) {
    char ch;
    int i = 0;
    while ((ch = getchar ()) != '\n') {
        if (ch < '0' || ch > '9') {
            return -1;
        }
        n[i++] = ch;
    }
    n[i] = '\0';
    return i;
}
----------------------------------------

int readBigNum (char *n, size_t len) {
    int ch;
    int i = 0;
    while ((ch = getchar ()) != EOF && i < (len - 1)) {
        if (ch == '\n')
            break;
        else if (! isdigit (ch))) return - 1;
        else
            n[i++] = (char) ch;
    }
    msg[i] = '\0';
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8518261_8518453_3_31
8518261_8518521_1_23
Title: C programming pointers and char array problems 
----------------------------------------

char *search_value (const struct PDB *llist, char *theMessage) {
    int realID = -7;
    int x = 0;
    int task = 0;
    char *received;
    theMessage[0] = '\0';
    printf ("Your choice: `Search'\n");
    printf ("Enter the value you want to find: ");
    scanf ("%d", & task);
    while (llist->data1 != NULL) {
        if (task == llist->taskID) {
            realID = llist->taskID;
            strcpy (theMessage, llist -> data1);
            break;
        }
    }
    return theMessage;
}
----------------------------------------

char *search_value (struct PDB *llist, char *theMessage, size_t theMessageMaxLength) {
    int realID = -7;
    int task = 0;
    printf ("Your choice: `Search'\n");
    printf ("Enter the value you want to find: ");
    scanf ("%d", & task);
    while (llist != NULL && llist->data1 != NULL) {
        if (task == llist->taskID) {
            realID = llist->taskID;
            strncpy (theMessage, llist -> data1, theMessageMaxLength);
            theMessage[theMessageMaxLength] = '\0';
            break;
        }
        llist = llist->next;
    }
    return theMessage;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8530934_21612535_8_22
8530934_8531545_12_39
Title: multiply two arrays with int values 
----------------------------------------

int main () {
    char a [MAX];
    char b [MAX];
    char *c;
    int la, lb;
    int i;
    printf ("Enter the first number : ");
    scanf ("%s", a);
    printf ("Enter the second number : ");
    scanf ("%s", b);
    printf ("Multiplication of two numbers : ");
    c = multiply (a, b);
    printf ("%s", c);
    return 0;
}
----------------------------------------

int main () {
    uint8_t n1 [N1_N] = {1, 2, 3};
    uint8_t n2 [N2_N] = {5, 6};
    uint8_t n3 [MAX_N];
    size_t n3_size = MAX_N;
    uint32_t n1_int;
    uint32_t n2_int;
    uint32_t result;
    print_array (n1, N1_N);
    printf (" * ");
    print_array (n2, N2_N);
    n1_int = array_to_ulong (n1, N1_N);
    n2_int = array_to_ulong (n2, N2_N);
    result = n1_int * n2_int;
    printf (" = %d = ", result);
    n3_size = ulong_to_array (n3, n3_size, result);
    print_array (n3, n3_size);
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8551383_16169029_1_12
8551383_19142828_3_21
Title: How to convert a hexadecimal string to a binary string in C 
----------------------------------------

void main (void) {
    char hex_number = 0x6E;
    char bit_number [8] = {0, 0, 0, 0, 0, 0, 0, 0};
    HexToBin (hex_number, bit_number);
    for (int i = 7; i > -1; i--)
        printf ("%d", bit_number[i]);
    printf ("\n");
    system ("pause");
}
----------------------------------------

int main () {
    long int binaryNumber, hexadecimalNumber = 0, j = 1, remainder;
    printf ("Enter any number any binary number: ");
    scanf ("%ld", & binaryNumber);
    while (binaryNumber != 0) {
        remainder = binaryNumber % 10;
        hexadecimalNumber = hexadecimalNumber + remainder * j;
        j = j * 2;
        binaryNumber = binaryNumber / 10;
    }
    printf ("Equivalent hexadecimal value: %X", hexadecimalNumber);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8551383_16169029_1_12
8551383_26739349_83_146
Title: How to convert a hexadecimal string to a binary string in C 
----------------------------------------

void main (void) {
    char hex_number = 0x6E;
    char bit_number [8] = {0, 0, 0, 0, 0, 0, 0, 0};
    HexToBin (hex_number, bit_number);
    for (int i = 7; i > -1; i--)
        printf ("%d", bit_number[i]);
    printf ("\n");
    system ("pause");
}
----------------------------------------

int main () {
    struct timespec before, after;
    unsigned long long checksum;
    int i;
    double elapsed;
    clock_gettime (CLOCK_MONOTONIC, & before);
    for (i = 0; i < NUMTESTS; i++) {
        test1 ();
    }
    clock_gettime (CLOCK_MONOTONIC, & after);
    checksum = 0;
    for (i = 0; i < TESTDATALEN / 2; i++) {
        checksum += result[i];
    }
    printf ("checksum: %llu\n", checksum);
    elapsed = difftime (after.tv_sec, before.tv_sec) + (after.tv_nsec - before.tv_nsec) / 1.0e9;
    printf ("arithmetic solution took %f seconds\n", elapsed);
    clock_gettime (CLOCK_MONOTONIC, & before);
    for (i = 0; i < NUMTESTS; i++) {
        test2 ();
    }
    clock_gettime (CLOCK_MONOTONIC, & after);
    checksum = 0;
    for (i = 0; i < TESTDATALEN / 2; i++) {
        checksum += result[i];
    }
    printf ("checksum: %llu\n", checksum);
    elapsed = difftime (after.tv_sec, before.tv_sec) + (after.tv_nsec - before.tv_nsec) / 1.0e9;
    printf ("256 entries table took %f seconds\n", elapsed);
    clock_gettime (CLOCK_MONOTONIC, & before);
    for (i = 0; i < NUMTESTS; i++) {
        test3 ();
    }
    clock_gettime (CLOCK_MONOTONIC, & after);
    checksum = 0;
    for (i = 0; i < TESTDATALEN / 2; i++) {
        checksum += result[i];
    }
    printf ("checksum: %llu\n", checksum);
    elapsed = difftime (after.tv_sec, before.tv_sec) + (after.tv_nsec - before.tv_nsec) / 1.0e9;
    printf ("32768 entries table took %f seconds\n", elapsed);
    clock_gettime (CLOCK_MONOTONIC, & before);
    for (i = 0; i < NUMTESTS; i++) {
        test4 ();
    }
    clock_gettime (CLOCK_MONOTONIC, & after);
    checksum = 0;
    for (i = 0; i < TESTDATALEN / 2; i++) {
        checksum += result[i];
    }
    printf ("checksum: %llu\n", checksum);
    elapsed = difftime (after.tv_sec, before.tv_sec) + (after.tv_nsec - before.tv_nsec) / 1.0e9;
    printf ("65536 entries table took %f seconds\n", elapsed);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8551383_19142828_3_21
8551383_26739349_83_146
Title: How to convert a hexadecimal string to a binary string in C 
----------------------------------------

int main () {
    long int binaryNumber, hexadecimalNumber = 0, j = 1, remainder;
    printf ("Enter any number any binary number: ");
    scanf ("%ld", & binaryNumber);
    while (binaryNumber != 0) {
        remainder = binaryNumber % 10;
        hexadecimalNumber = hexadecimalNumber + remainder * j;
        j = j * 2;
        binaryNumber = binaryNumber / 10;
    }
    printf ("Equivalent hexadecimal value: %X", hexadecimalNumber);
    return 0;
}
----------------------------------------

int main () {
    struct timespec before, after;
    unsigned long long checksum;
    int i;
    double elapsed;
    clock_gettime (CLOCK_MONOTONIC, & before);
    for (i = 0; i < NUMTESTS; i++) {
        test1 ();
    }
    clock_gettime (CLOCK_MONOTONIC, & after);
    checksum = 0;
    for (i = 0; i < TESTDATALEN / 2; i++) {
        checksum += result[i];
    }
    printf ("checksum: %llu\n", checksum);
    elapsed = difftime (after.tv_sec, before.tv_sec) + (after.tv_nsec - before.tv_nsec) / 1.0e9;
    printf ("arithmetic solution took %f seconds\n", elapsed);
    clock_gettime (CLOCK_MONOTONIC, & before);
    for (i = 0; i < NUMTESTS; i++) {
        test2 ();
    }
    clock_gettime (CLOCK_MONOTONIC, & after);
    checksum = 0;
    for (i = 0; i < TESTDATALEN / 2; i++) {
        checksum += result[i];
    }
    printf ("checksum: %llu\n", checksum);
    elapsed = difftime (after.tv_sec, before.tv_sec) + (after.tv_nsec - before.tv_nsec) / 1.0e9;
    printf ("256 entries table took %f seconds\n", elapsed);
    clock_gettime (CLOCK_MONOTONIC, & before);
    for (i = 0; i < NUMTESTS; i++) {
        test3 ();
    }
    clock_gettime (CLOCK_MONOTONIC, & after);
    checksum = 0;
    for (i = 0; i < TESTDATALEN / 2; i++) {
        checksum += result[i];
    }
    printf ("checksum: %llu\n", checksum);
    elapsed = difftime (after.tv_sec, before.tv_sec) + (after.tv_nsec - before.tv_nsec) / 1.0e9;
    printf ("32768 entries table took %f seconds\n", elapsed);
    clock_gettime (CLOCK_MONOTONIC, & before);
    for (i = 0; i < NUMTESTS; i++) {
        test4 ();
    }
    clock_gettime (CLOCK_MONOTONIC, & after);
    checksum = 0;
    for (i = 0; i < TESTDATALEN / 2; i++) {
        checksum += result[i];
    }
    printf ("checksum: %llu\n", checksum);
    elapsed = difftime (after.tv_sec, before.tv_sec) + (after.tv_nsec - before.tv_nsec) / 1.0e9;
    printf ("65536 entries table took %f seconds\n", elapsed);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8607754_8608005_1_22
8607754_8608038_2_17
Title: Why a recursive version of a function would be faster than an iterative one in C? 
----------------------------------------

int main () {
    struct timespec s1, e1, s2, e2;
    double d = 0.0;
    clock_gettime (CLOCK_MONOTONIC, & s1);
    d = descgraditer (100, 99, 0.01, 0.00001);
    clock_gettime (CLOCK_MONOTONIC, & e1);
    printf ("Minimum : %f\n", d);
    clock_gettime (CLOCK_MONOTONIC, & s2);
    d = descgrad (100, 99, 0.01, 0.00001);
    clock_gettime (CLOCK_MONOTONIC, & e2);
    printf ("Minimum : %f\n", d);
    uint64_t dif1 = timespecDiff (&e1, &s1) / 1000;
    uint64_t dif2 = timespecDiff (&e2, &s2) / 1000;
    printf ("time_iter:%llu ms, time_rec:%llu ms, ratio (dif1/dif2) :%g\n", dif1, dif2, ((double) ((double) dif1 / (double) dif2)));
    printf ("End. \n");
}
----------------------------------------

int main () {
    struct timespec s1, e1, s2, e2;
    int i;
    clock_gettime (CLOCK_MONOTONIC, & s1);
    for (i = 0; i < LOOPCOUNT; i++) {
        descgraditer (100, 99, 0.01, 0.00001);
    }
    clock_gettime (CLOCK_MONOTONIC, & e1);
    clock_gettime (CLOCK_MONOTONIC, & s2);
    for (i = 0;
    i < LOOPCOUNT;
    i ++) {descgrad (100, 99, 0.01, 0.00001);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8607754_8608005_1_22
8607754_8608719_26_47
Title: Why a recursive version of a function would be faster than an iterative one in C? 
----------------------------------------

int main () {
    struct timespec s1, e1, s2, e2;
    double d = 0.0;
    clock_gettime (CLOCK_MONOTONIC, & s1);
    d = descgraditer (100, 99, 0.01, 0.00001);
    clock_gettime (CLOCK_MONOTONIC, & e1);
    printf ("Minimum : %f\n", d);
    clock_gettime (CLOCK_MONOTONIC, & s2);
    d = descgrad (100, 99, 0.01, 0.00001);
    clock_gettime (CLOCK_MONOTONIC, & e2);
    printf ("Minimum : %f\n", d);
    uint64_t dif1 = timespecDiff (&e1, &s1) / 1000;
    uint64_t dif2 = timespecDiff (&e2, &s2) / 1000;
    printf ("time_iter:%llu ms, time_rec:%llu ms, ratio (dif1/dif2) :%g\n", dif1, dif2, ((double) ((double) dif1 / (double) dif2)));
    printf ("End. \n");
}
----------------------------------------

int main () {
    time_t s1, e1, d1, s2, e2, d2;
    int i, iter = 10000000;
    double a1, a2;
    s1 = time (NULL);
    for (i = 0; i < iter; i++) {
        a1 = descgraditer (100, 99, 0.01, 0.00001);
    }
    e1 = time (NULL);
    d1 = difftime (e1, s1);
    s2 = time (NULL);
    for (i = 0; i < iter; i++) {
        a2 = descgrad (100, 99, 0.01, 0.00001);
    }
    e2 = time (NULL);
    d2 = difftime (e2, s2);
    printf ("time_iter: %d s, time_rec: %d s, ratio (iter/rec): %f\n", d1, d2, (double) d1 / d2);
    printf ("return values: %f, %f\n", a1, a2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8607754_8608038_2_17
8607754_8608719_26_47
Title: Why a recursive version of a function would be faster than an iterative one in C? 
----------------------------------------

int main () {
    struct timespec s1, e1, s2, e2;
    int i;
    clock_gettime (CLOCK_MONOTONIC, & s1);
    for (i = 0; i < LOOPCOUNT; i++) {
        descgraditer (100, 99, 0.01, 0.00001);
    }
    clock_gettime (CLOCK_MONOTONIC, & e1);
    clock_gettime (CLOCK_MONOTONIC, & s2);
    for (i = 0;
    i < LOOPCOUNT;
    i ++) {descgrad (100, 99, 0.01, 0.00001);
}
----------------------------------------

int main () {
    time_t s1, e1, d1, s2, e2, d2;
    int i, iter = 10000000;
    double a1, a2;
    s1 = time (NULL);
    for (i = 0; i < iter; i++) {
        a1 = descgraditer (100, 99, 0.01, 0.00001);
    }
    e1 = time (NULL);
    d1 = difftime (e1, s1);
    s2 = time (NULL);
    for (i = 0; i < iter; i++) {
        a2 = descgrad (100, 99, 0.01, 0.00001);
    }
    e2 = time (NULL);
    d2 = difftime (e2, s2);
    printf ("time_iter: %d s, time_rec: %d s, ratio (iter/rec): %f\n", d1, d2, (double) d1 / d2);
    printf ("return values: %f, %f\n", a1, a2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8633524_8633655_1_12
8633524_8633700_1_21
Title: assigning var to var -- will it work? 
----------------------------------------

void str_assign (str *s1, const str *s2) {
    if (s1 != s2) {
        free (s1 -> buf);
        s1->len = s2->len;
        if ((s1->buf = (char *) malloc (s2->len + 1)) != 0)
            memcpy (s1->buf, s2->buf, s2->len + 1);
        else
            s1->len = 0;
    }
}
----------------------------------------

void str_assign (str *s1, str *s2) {
    if (s1 == s2)
        return;
    if (s1 != NULL)
        free (s1);
    if ((s1->buf = (char *) malloc (s2->len + 1)) == NULL) {
        printf ("ERROR: unable to allocate memory\n");
        return;
    }
    s1->len = s2->len;
    strncpy (s1 -> buf, s2 -> buf, s2 -> len);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8645935_8646077_9_18
8645935_8646687_4_19
Title: how to write content of an array to hard disk 
----------------------------------------

int main () {
    unsigned char bit_table_ [20] [40];
    for (int i = 0; i != 20; i++)
        for (int j = 0; j != 40; j++)
            bit_table_[i][j] = i ^ j;
    ofstream f ("c:/temp/bit_table.bin", ios : : binary | ios : : out);
    unsigned char *buf = &bit_table_[0][0];
    copy (buf, buf + sizeof (bit_table_), ostream_iterator < unsigned char > (f, ""));
    return 0;
}
----------------------------------------

int main () {
    ofstream outdata;
    int i;
    int array [5] = {4, 3, 6, 7, 12};
    outdata.open ("example.dat");
    if (!outdata) {
        cerr << "Error: file could not be opened" << endl;
        exit (1);
    }
    for (i = 0; i < 5; ++i)
        outdata << array[i] << endl;
    outdata.close ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8653017_8653064_28_65
8653017_8653073_4_38
Title: two dimensional array via pointer 
----------------------------------------

int main () {
    int y, z;
    int **x = NULL;
    int num_term = 5;
    int num_permutation = 5;
    int *pchk = NULL;
    x = (int **) malloc (num_permutation * sizeof (int *));
    for (y = 0; y < num_permutation; y++) {
        x[y] = (int *) malloc (num_term * sizeof (int));
        printf ("x[%d]: %p\n", y, x [y]);
    }
    permute (num_permutation, num_term, x);
    printf ("\nx:  ");
    for (z = 0; z < 5; z++) {
        printf (" %2d ", z);
    }
    printf ("\n");
    for (y = 0; y < num_permutation; y++) {
        pchk = x[y];
        printf ("%-4d", y);
        for (z = 0; z < num_term; z++) {
            printf (" %2d ", pchk [z]);
        }
        printf ("\n");
    }
    for (y = 0; y < num_permutation; y++) {
        free (x [y]);
    }
    free (x);
    return 0;
}
----------------------------------------

int main () {
    int row, column;
    int **matrix;
    int i, j, val;
    printf ("Enter rows: ");
    scanf ("%d", & row);
    printf ("Enter columns: ");
    scanf ("%d", & column);
    matrix = (int **) malloc (sizeof (int *) * row);
    if (matrix == NULL) {
        printf ("ERROR: unable to allocate memory \n");
        return -1;
    }
    for (i = 0; i < row; i++)
        matrix[i] = (int *) malloc (sizeof (int) * column);
    val = 1;
    for (i = 0; i < row; i++) {
        for (j = 0; j < column; j++) {
            matrix[i][j] = val++;
        }
    }
    for (i = 0; i < row; i++) {
        for (j = 0; j < column; j++) {
            printf ("%3d  ", matrix [i] [j]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8659304_8659526_1_15
8659304_8665572_4_18
Title: Passing two-dimensional array to a function by refrence (C Programming) 
----------------------------------------

int determinant (int *mat) {
    int det;
    int a = *((mat + 0) + 0);
    int b = *((mat + 0) + 1);
    int c = *((mat + 0) + 2);
    int d = *((mat + 1 * 3) + 0);
    int e = *((mat + 1 * 3) + 1);
    int f = *((mat + 1 * 3) + 2);
    int g = *((mat + 2 * 3) + 0);
    int h = *((mat + 2 * 3) + 1);
    int i = *((mat + 2 * 3) + 2);
    det = a * (e * i - h * f) - b * (d * i - g * f) + c * (d * h - e * g);
    return det;
}
----------------------------------------

int determinant (int *matrix1stMember) {
    int a, b, c, d, e, f, g, h, i;
    a = *(matrix1stMember + 0);
    b = *(matrix1stMember + 1);
    c = *(matrix1stMember + 2);
    d = *(matrix1stMember + 3);
    e = *(matrix1stMember + 4);
    f = *(matrix1stMember + 5);
    g = *(matrix1stMember + 6);
    h = *(matrix1stMember + 7);
    i = *(matrix1stMember + 8);
    return (a * (e * i - h * f) - b * (d * i - g * f) + c * (d * h - e * g));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8665758_8665849_25_36
8665758_8665908_10_25
Title: Trying to compare two strings 
----------------------------------------

int main () {
    char s1 [] = "test string1";
    char s2 [] = "test string";
    char s3 [] = "aaa";
    char s4 [] = "bbb";
    printf ("strcmp1(%s, %s) = %d \n", s1, s2, strcmp1 (s1, s2));
    printf ("strcmp2(%s, %s) = %d \n", s3, s4, strcmp2 (s3, s4));
    return 0;
}
----------------------------------------

int main (void) {
    const char msg [15] = "blueberry";
    int c, s [15], i, j, k, ok;
    for (i = 0; i < 15; i++)
        s[i] = 0;
    for (i = 0; i < 15 && (c = getchar ()) != '\n'; i++)
        s[i] = c;
    for (ok = 1, k = 0; msg[k] != '\0'; ++k)
        if (s[k] != msg[k])
            ok = 0;
        else
            s[k] = '.';
    for (j = 0; j < 15; ++j)
        printf ("%c ", msg[j]);
    printf ("\n");
    for (j = 0; j < 15; ++j)
        printf ("%c ", s[j]);
    printf ("\nresult = %s\n", ok ? "equal" : "non-equal");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8665758_8665849_25_36
8665758_8666002_4_46
Title: Trying to compare two strings 
----------------------------------------

int main () {
    char s1 [] = "test string1";
    char s2 [] = "test string";
    char s3 [] = "aaa";
    char s4 [] = "bbb";
    printf ("strcmp1(%s, %s) = %d \n", s1, s2, strcmp1 (s1, s2));
    printf ("strcmp2(%s, %s) = %d \n", s3, s4, strcmp2 (s3, s4));
    return 0;
}
----------------------------------------

int main (void) {
    const char msg [15] = "blueberry";
    int c;
    char s [15];
    int i = 0;
    int k = 0;
    int ok = 0;
    while (i < 15 && (c = getchar ()) != '\n') {
        s[i] = (char) c;
        ++i;
    }
    s[i] = '\0';
    printf ("input: %s\n", s);
    printf ("messg: %s\n", msg);
    for (k = 0; ok == 0 && msg[k] != '\0' && s[k] != '\0';) {
        if (s[k] != msg[k]) {
            ok = 1;
        }
        else {
            k++;
        }
    }
    if (ok == 1) {
        printf ("diff @ index %d -> %c\n", k, msg [k]);
    }
    else {
        printf ("no diff\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8665758_8665849_25_36
8665758_8667238_65_84
Title: Trying to compare two strings 
----------------------------------------

int main () {
    char s1 [] = "test string1";
    char s2 [] = "test string";
    char s3 [] = "aaa";
    char s4 [] = "bbb";
    printf ("strcmp1(%s, %s) = %d \n", s1, s2, strcmp1 (s1, s2));
    printf ("strcmp2(%s, %s) = %d \n", s3, s4, strcmp2 (s3, s4));
    return 0;
}
----------------------------------------

int main () {
    char str1 [16] = "blueberry";
    char str2 [16] = "blackberry";
    char dif1 [16] = "";
    char dif2 [16] = "";
    int len0;
    int len1;
    int len2;
    len0 = diff (str1, str2, &len1, &len2);
    strncpy (dif1, str1 + len0, len1);
    strncpy (dif2, str2 + len0, len2);
    if (len1 != 0 && len2 != 0) {
        printf ("%s different %s at position %d length %d (\"%s\")\n", str1, str2, len0, len1, dif1);
        printf ("%s different %s at position %d length %d (\"%s\")\n", str2, str1, len0, len2, dif2);
    }
    else {
        printf ("two string is same.");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8665758_8665908_10_25
8665758_8666002_4_46
Title: Trying to compare two strings 
----------------------------------------

int main (void) {
    const char msg [15] = "blueberry";
    int c, s [15], i, j, k, ok;
    for (i = 0; i < 15; i++)
        s[i] = 0;
    for (i = 0; i < 15 && (c = getchar ()) != '\n'; i++)
        s[i] = c;
    for (ok = 1, k = 0; msg[k] != '\0'; ++k)
        if (s[k] != msg[k])
            ok = 0;
        else
            s[k] = '.';
    for (j = 0; j < 15; ++j)
        printf ("%c ", msg[j]);
    printf ("\n");
    for (j = 0; j < 15; ++j)
        printf ("%c ", s[j]);
    printf ("\nresult = %s\n", ok ? "equal" : "non-equal");
}
----------------------------------------

int main (void) {
    const char msg [15] = "blueberry";
    int c;
    char s [15];
    int i = 0;
    int k = 0;
    int ok = 0;
    while (i < 15 && (c = getchar ()) != '\n') {
        s[i] = (char) c;
        ++i;
    }
    s[i] = '\0';
    printf ("input: %s\n", s);
    printf ("messg: %s\n", msg);
    for (k = 0; ok == 0 && msg[k] != '\0' && s[k] != '\0';) {
        if (s[k] != msg[k]) {
            ok = 1;
        }
        else {
            k++;
        }
    }
    if (ok == 1) {
        printf ("diff @ index %d -> %c\n", k, msg [k]);
    }
    else {
        printf ("no diff\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8665758_8665908_10_25
8665758_8667238_65_84
Title: Trying to compare two strings 
----------------------------------------

int main (void) {
    const char msg [15] = "blueberry";
    int c, s [15], i, j, k, ok;
    for (i = 0; i < 15; i++)
        s[i] = 0;
    for (i = 0; i < 15 && (c = getchar ()) != '\n'; i++)
        s[i] = c;
    for (ok = 1, k = 0; msg[k] != '\0'; ++k)
        if (s[k] != msg[k])
            ok = 0;
        else
            s[k] = '.';
    for (j = 0; j < 15; ++j)
        printf ("%c ", msg[j]);
    printf ("\n");
    for (j = 0; j < 15; ++j)
        printf ("%c ", s[j]);
    printf ("\nresult = %s\n", ok ? "equal" : "non-equal");
}
----------------------------------------

int main () {
    char str1 [16] = "blueberry";
    char str2 [16] = "blackberry";
    char dif1 [16] = "";
    char dif2 [16] = "";
    int len0;
    int len1;
    int len2;
    len0 = diff (str1, str2, &len1, &len2);
    strncpy (dif1, str1 + len0, len1);
    strncpy (dif2, str2 + len0, len2);
    if (len1 != 0 && len2 != 0) {
        printf ("%s different %s at position %d length %d (\"%s\")\n", str1, str2, len0, len1, dif1);
        printf ("%s different %s at position %d length %d (\"%s\")\n", str2, str1, len0, len2, dif2);
    }
    else {
        printf ("two string is same.");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8665758_8666002_4_46
8665758_8667238_65_84
Title: Trying to compare two strings 
----------------------------------------

int main (void) {
    const char msg [15] = "blueberry";
    int c;
    char s [15];
    int i = 0;
    int k = 0;
    int ok = 0;
    while (i < 15 && (c = getchar ()) != '\n') {
        s[i] = (char) c;
        ++i;
    }
    s[i] = '\0';
    printf ("input: %s\n", s);
    printf ("messg: %s\n", msg);
    for (k = 0; ok == 0 && msg[k] != '\0' && s[k] != '\0';) {
        if (s[k] != msg[k]) {
            ok = 1;
        }
        else {
            k++;
        }
    }
    if (ok == 1) {
        printf ("diff @ index %d -> %c\n", k, msg [k]);
    }
    else {
        printf ("no diff\n");
    }
    return 0;
}
----------------------------------------

int main () {
    char str1 [16] = "blueberry";
    char str2 [16] = "blackberry";
    char dif1 [16] = "";
    char dif2 [16] = "";
    int len0;
    int len1;
    int len2;
    len0 = diff (str1, str2, &len1, &len2);
    strncpy (dif1, str1 + len0, len1);
    strncpy (dif2, str2 + len0, len2);
    if (len1 != 0 && len2 != 0) {
        printf ("%s different %s at position %d length %d (\"%s\")\n", str1, str2, len0, len1, dif1);
        printf ("%s different %s at position %d length %d (\"%s\")\n", str2, str1, len0, len2, dif2);
    }
    else {
        printf ("two string is same.");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8685253_8685461_11_73
8685253_8685497_7_33
Title: txt to separate strings in c 
----------------------------------------

int main (void) {
    const char filename [] = "monologue.txt";
    FILE *fp;
    size_t i = 0;
    size_t len_data = 4;
    char *data = emalloc (len_data);
    int c;
    if ((fp = fopen (filename, "r")) == NULL)
        err_exit ("Error opening file %s\n", filename);
    while ((c = fgetc (fp)) != EOF) {
        if (c == '\n')
            c = ' ';
        if (i >= len_data) {
            assert (i == len_data);
            data = realloc (data, 2 * len_data);
            len_data *= 2;
        }
        data[i++] = c;
    }
    if (i >= len_data) {
        assert (i == len_data);
        data = erealloc (data, len_data +1);
        len_data++;
    }
    data[i] = '\0';
    fclose (fp);
    size_t len_wordlist = 16;
    size_t num_words = 0;
    char **wordlist = emalloc (len_wordlist * sizeof (char *));
    char *location = data;
    char *word;
    for (num_words = 0; (word = strtok (location, " ")) != NULL; num_words++) {
        if (num_words >= len_wordlist) {
            assert (num_words == len_wordlist);
            wordlist = erealloc (wordlist, 2 * len_wordlist * sizeof (char *));
            len_wordlist *= 2;
        }
        wordlist[num_words] = word;
        location = NULL;
    }
    for (i = 0; i < num_words; i++)
        printf ("%zu: %s\n", i, wordlist[i]);
    free (data);
    free (wordlist);
    return (0);
}
----------------------------------------

int main () {
    FILE *fp;
    int i = 0, j;
    char *words = NULL, *word = NULL, c;
    char *allwords [MAXWORDS];
    if ((fp = fopen ("monologue.txt", "r")) == NULL) {
        printf ("Error Opening File\n");
        exit (1);
    }
    while ((c = fgetc (fp)) != EOF) {
        if (c == '\n') {
            c = ' ';
        }
        words = (char *) realloc (words, ++i * sizeof (char));
        words[i - 1] = c;
    }
    word = strtok (words, " ");
    i = 0;
    while (word != NULL && i < MAXWORDS) {
        printf ("%s\n", word);
        allwords[i] = malloc (strlen (word));
        strcpy (allwords [i], word);
        word = strtok (NULL, " ");
        i++;
    }
    printf ("\nNow printing each saved string:\n");
    for (j = 0; j < i; j++)
        printf ("String %d: %s\n", j, allwords[j]);
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8707183_47561849_4_50
8707183_8707191_4_19
Title: script/tool to convert file to C/C++ source code array 
----------------------------------------

int main (int argc, char **argv) {
    assert (argc == 2);
    char *fn = argv[1];
    FILE *f = fopen (fn, "rb");
    FILE *fw = fopen ("array_name.c", "w");
    printf ("char array_name[] = {\n");
    fprintf (fw, "char hex_array[] = {\n");
    unsigned long n = 0;
    while ((!feof (f))) {
        unsigned char c;
        if (fread (&c, 1, 1, f) == 0)
            break;
        printf ("0x%.2X,", (int) c);
        fprintf (fw, "0x%.2X,", (int) c);
        ++n;
        if (n % 20 == 0) {
            printf ("\n");
            fprintf (fw, "\n");
        }
    }
    fseek (fw, - 1, SEEK_CUR);
    printf ("\b};\n");
    fprintf (fw, "};\n");
    fclose (f);
    fclose (fw);
}
----------------------------------------

int main (int argc, char **argv) {
    assert (argc == 2);
    char *fn = argv[1];
    FILE *f = fopen (fn, "rb");
    printf ("char a[] = {\n");
    unsigned long n = 0;
    while (!feof (f)) {
        unsigned char c;
        if (fread (&c, 1, 1, f) == 0)
            break;
        printf ("0x%.2X,", (int) c);
        ++n;
        if (n % 10 == 0)
            printf ("\n");
    }
    fclose (f);
    printf ("};\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8715034_40155458_31_61
8715034_8715105_9_28
Title: Print 2d array by calling a function print_array with argument the 2d array 
----------------------------------------

void main () {
    int i, j, l;
    int Big_arr [80] [100], Small_arr [20] [40];
    int x, y;
    clrscr ();
    printf ("\n Enter x and y values under 20X40:");
    scanf ("%d %d", & x, & y);
    if ((x != 0) && (y != 0)) {
        printf ("\n %dX%d", x, y);
        l = sizeof (Big_arr [0]) / sizeof (Big_arr [0] [0]);
        putvalue (l, x, y, (int *) Big_arr);
        printf ("\n Printing Big_arr");
        printmatrix (l, x, y, (int *) Big_arr);
        l = sizeof (Small_arr [0]) / sizeof (Small_arr [0] [0]);
        putvalue (l, x, y, (int *) Small_arr);
        printf ("\n Printing Small_arr");
        printmatrix (l, x, y, (int *) Small_arr);
    }
    else
        printf ("\n ***** Enter valied x and y values *****");
    getch ();
}
----------------------------------------

int main () {
    int m, n, i, j;
    int A [length] [length];
    printf ("Give dimensions of array (up to 100x100):\ni:\n");
    scanf ("%d", & i);
    printf ("j:\n");
    scanf ("%d", & j);
    srand (time (NULL));
    for (m = 0; m < i; m++) {
        for (n = 0; n < j; n++) {
            A[m][n] = rand () % 45 + 1;
            printf ("A[%d,%d]=%d\n", m, n, A [m] [n]);
        }
    }
    print_array (i, j, A);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8715034_8715105_30_41
8715034_8715141_1_12
Title: Print 2d array by calling a function print_array with argument the 2d array 
----------------------------------------

void print_array (int i, int j, int A [length] [length]) {
    printf ("\n");
    int m, n;
    for (m = 0; m < i; m++) {
        for (n = 0; n < j; n++) {
            printf ("A[%d,%d]=%d\n", m, n, A [m] [n]);
        }
    }
}
----------------------------------------

void print_array (int i, int j, int A [length] [length]) {
    printf ("\n");
    int m, n;
    for (m = 0; m < i; m++) {
        for (n = 0; n < j; n++) {
            printf ("A[%d,%d]=%d\n", m, n, A [m] [n]);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8746719_8850136_139_196
8746719_9527056_122_182
Title: gstreamer appsrc test application 
----------------------------------------

int main (int argc, char *argv []) {
    gst_app_t *app = &gst_app;
    GstBus *bus;
    GstStateChangeReturn state_ret;
    if (argc != 2) {
        printf ("File name not specified\n");
        return 1;
    }
    app->file = fopen (argv[1], "r");
    g_assert (app -> file);
    gst_init (NULL, NULL);
    app->pipeline = (GstPipeline *) gst_pipeline_new ("mypipeline");
    bus = gst_pipeline_get_bus (app->pipeline);
    gst_bus_add_watch (bus, (GstBusFunc) bus_callback, app);
    gst_object_unref (bus);
    app->src = (GstAppSrc *) gst_element_factory_make ("appsrc", "mysrc");
    app->decoder = gst_element_factory_make ("decodebin", "mydecoder");
    app->ffmpeg = gst_element_factory_make ("ffmpegcolorspace", "myffmpeg");
    app->xvimagesink = gst_element_factory_make ("xvimagesink", "myvsink");
    g_assert (app -> src);
    g_assert (app -> decoder);
    g_assert (app -> ffmpeg);
    g_assert (app -> xvimagesink);
    g_signal_connect (app -> src, "need-data", G_CALLBACK (start_feed), app);
    g_signal_connect (app -> src, "enough-data", G_CALLBACK (stop_feed), app);
    g_signal_connect (app -> decoder, "pad-added", G_CALLBACK (on_pad_added), app -> decoder);
    gst_bin_add_many (GST_BIN (app -> pipeline), (GstElement *) app -> src, app -> decoder, app -> ffmpeg, app -> xvimagesink, NULL);
    if (!gst_element_link ((GstElement *) app->src, app->decoder)) {
        g_warning ("failed to link src anbd decoder");
    }
    if (!gst_element_link (app->ffmpeg, app->xvimagesink)) {
        g_warning ("failed to link ffmpeg and xvsink");
    }
    state_ret = gst_element_set_state ((GstElement *) app->pipeline, GST_STATE_PLAYING);
    g_warning ("set state returned %d\n", state_ret);
    app->loop = g_main_loop_new (NULL, FALSE);
    printf ("Running main loop\n");
    g_main_loop_run (app -> loop);
    state_ret = gst_element_set_state ((GstElement *) app->pipeline, GST_STATE_NULL);
    g_warning ("set state null returned %d\n", state_ret);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    App *app = &s_app;
    GError *error = NULL;
    GstBus *bus;
    GstCaps *caps;
    gst_init (& argc, & argv);
    GST_DEBUG_CATEGORY_INIT (appsrc_pipeline_debug, "appsrc-pipeline", 0, "appsrc pipeline example");
    app->loop = g_main_loop_new (NULL, TRUE);
    app->timer = g_timer_new ();
    app->pipeline = gst_parse_launch ("appsrc name=mysource ! video/x-raw-rgb,width=640,height=480 ! ffmpegcolorspace ! videoscale method=1 ! xvimagesink", NULL);
    g_assert (app -> pipeline);
    bus = gst_pipeline_get_bus (GST_PIPELINE (app->pipeline));
    g_assert (bus);
    gst_bus_add_watch (bus, (GstBusFunc) bus_message, app);
    app->appsrc = gst_bin_get_by_name (GST_BIN (app->pipeline), "mysource");
    g_assert (app -> appsrc);
    g_assert (GST_IS_APP_SRC (app -> appsrc));
    g_signal_connect (app -> appsrc, "need-data", G_CALLBACK (start_feed), app);
    g_signal_connect (app -> appsrc, "enough-data", G_CALLBACK (stop_feed), app);
    caps = gst_video_format_new_caps (GST_VIDEO_FORMAT_RGB, 640, 480, 0, 1, 4, 3);
    gst_app_src_set_caps (GST_APP_SRC (app -> appsrc), caps);
    gst_element_set_state (app -> pipeline, GST_STATE_PLAYING);
    g_main_loop_run (app -> loop);
    GST_DEBUG ("stopping");
    gst_element_set_state (app -> pipeline, GST_STATE_NULL);
    gst_object_unref (bus);
    g_main_loop_unref (app -> loop);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8746719_8850136_21_58
8746719_9527056_30_68
Title: gstreamer appsrc test application 
----------------------------------------

static gboolean read_data (gst_app_t *app) {
    GstBuffer *buffer;
    guint8 *ptr;
    gint size;
    GstFlowReturn ret;
    ptr = g_malloc (BUFF_SIZE);
    g_assert (ptr);
    size = fread (ptr, 1, BUFF_SIZE, app->file);
    if (size == 0) {
        ret = gst_app_src_end_of_stream (app->src);
        g_debug ("eos returned %d at %d\n", ret, __LINE__);
        return FALSE;
    }
    buffer = gst_buffer_new ();
    GST_BUFFER_MALLOCDATA (buffer) = ptr;
    GST_BUFFER_SIZE (buffer) = size;
    GST_BUFFER_DATA (buffer) = GST_BUFFER_MALLOCDATA (buffer);
    ret = gst_app_src_push_buffer (app->src, buffer);
    if (ret != GST_FLOW_OK) {
        g_debug ("push buffer returned %d for %d bytes \n", ret, size);
        return FALSE;
    }
    if (size != BUFF_SIZE) {
        ret = gst_app_src_end_of_stream (app->src);
        g_debug ("eos returned %d at %d\n", ret, __LINE__);
        return FALSE;
    }
    return TRUE;
}
----------------------------------------

static gboolean read_data (App *app) {
    guint len;
    GstFlowReturn ret;
    gdouble ms;
    ms = g_timer_elapsed (app->timer, NULL);
    if (ms > 1.0 / 20.0) {
        GstBuffer *buffer;
        GdkPixbuf *pb;
        gboolean ok = TRUE;
        buffer = gst_buffer_new ();
        pb = gdk_pixbuf_new (GDK_COLORSPACE_RGB, FALSE, 8, 640, 480);
        gdk_pixbuf_fill (pb, 0xffffffff);
        GST_BUFFER_DATA (buffer) = gdk_pixbuf_get_pixels (pb);
        GST_BUFFER_SIZE (buffer) = 640 * 480 * 3 * sizeof (guchar);
        GST_DEBUG ("feed buffer");
        g_signal_emit_by_name (app -> appsrc, "push-buffer", buffer, & ret);
        gst_buffer_unref (buffer);
        if (ret != GST_FLOW_OK) {
            GST_DEBUG ("some error");
            ok = FALSE;
        }
        g_timer_start (app -> timer);
        return ok;
    }
    return TRUE;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8752373_8752403_1_14
8752373_8752486_1_12
Title: How to read a file in C from a subdirectory 
----------------------------------------

void readFrag (char *fragName) {
    FILE *file;
    int tmp;
    char szWorkingDir [PATH_MAX];
    szWorkingDirectory[0] = '\0';
    getwd (szWorkingDirectory);
    printf ("Attempting to open %s/%s\n", szWorkingDir, fragName);
    file = fopen (fragName, "rt");
    if (file != NULL)
        fscanf (file, "%d", &tmp);
}
----------------------------------------

void readFrag (char *fragName) {
    FILE *file;
    int tmp;
    file = fopen (fragName, "r");
    if (!file) {
        perror ("Error reading fragment file in readFrag");
        return;
    }
    fscanf (file, "%d", & tmp);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8782771_47880244_4_81
8782771_8822522_56_150
Title: Loading PE Headers 
----------------------------------------

int main () {
    LPCSTR fileName = "inputFile.exe";
    HANDLE hFile;
    HANDLE hFileMapping;
    LPVOID lpFileBase;
    PIMAGE_DOS_HEADER dosHeader;
    PIMAGE_NT_HEADERS peHeader;
    PIMAGE_SECTION_HEADER sectionHeader;
    hFile = CreateFileA (fileName, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
    if (hFile == INVALID_HANDLE_VALUE) {
    std :
        : cout << "\n CreateFile failed \n";
        return 1;
    }
    hFileMapping = CreateFileMapping (hFile, NULL, PAGE_READONLY, 0, 0, NULL);
    if (hFileMapping == 0) {
    std :
        : cout << "\n CreateFileMapping failed \n";
        CloseHandle (hFile);
        return 1;
    }
    lpFileBase = MapViewOfFile (hFileMapping, FILE_MAP_READ, 0, 0, 0);
    if (lpFileBase == 0) {
    std :
        : cout << "\n MapViewOfFile failed \n";
        CloseHandle (hFileMapping);
        CloseHandle (hFile);
        return 1;
    }
    dosHeader = (PIMAGE_DOS_HEADER) lpFileBase;
    if (dosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
    std :
        : cout << "\n DOS Signature (MZ) Matched \n";
        peHeader = (PIMAGE_NT_HEADERS) ((u_char *) dosHeader + dosHeader->e_lfanew);
        if (peHeader->Signature == IMAGE_NT_SIGNATURE) {
        std :
            : cout << "\n PE Signature (PE) Matched \n";
            sectionHeader = IMAGE_FIRST_SECTION (peHeader);
            UINT nSectionCount = peHeader->FileHeader.NumberOfSections;
        std :
            : cout << "\n No of Sections : " << nSectionCount << "  \n";
            for (UINT i = 0; i < nSectionCount; ++i, ++sectionHeader) {
            std :
                : cout << "\n-----------------------------------------------\n";
            std :
                : cout << "\n Section Name : " << sectionHeader -> Name << " \n";
            std :
                : cout << "\n Size of section data : " << sectionHeader -> Misc.VirtualSize << " \n";
            std :
                : cout << "\n-----------------------------------------------\n";
            }
        }
        else {
            return 1;
        }
    }
    else {
        return 1;
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc != 2) {
        printf ("Usage : %s filename\n", argv [0]);
        return -1;
    }
    else {
        FILE *fp = fopen (argv[1], "rb");
        IMAGE_DOS_HEADER DosHeader = {0};
        IMAGE_FILE_HEADER FileHeader = {0};
        IMAGE_SECTION_HEADER SectionHeader = {0};
        DWORD Signature = 0;
        DWORD RawPointerToPeHeader = 0, SizeOfFile = 0;
        DWORD SectionCount = 0;
        DWORD ByteCount = 0;
        BYTE *pData = NULL;
        if (!fp) {
            perror ("");
            return -1;
        }
        fseek (fp, 0, SEEK_END);
        SizeOfFile = ftell (fp);
        if (SizeOfFile < sizeof (IMAGE_DOS_HEADER) + sizeof (IMAGE_NT_HEADERS))
            goto not_pe_file;
        fseek (fp, 0, SEEK_SET);
        fread (& DosHeader, 1, sizeof DosHeader, fp);
        if (DosHeader.e_magic != 'M' + 'Z' * 256)
            goto not_pe_file;
        RawPointerToPeHeader = DosHeader.e_lfanew;
        if (SizeOfFile <= RawPointerToPeHeader + sizeof (IMAGE_NT_HEADERS))
            goto not_pe_file;
        fseek (fp, RawPointerToPeHeader, SEEK_SET);
        fread (& Signature, 1, sizeof (DWORD), fp);
        if (Signature != 'P' + 'E' * 256)
            goto not_pe_file;
        fread (& FileHeader, 1, sizeof FileHeader, fp);
        if (FileHeader.SizeOfOptionalHeader != sizeof (IMAGE_OPTIONAL_HEADER))
            goto not_pe_file;
        SectionCount = FileHeader.NumberOfSections;
        if (SectionCount == 0) {
            printf ("No section for this file.\n");
            fclose (fp);
            return -1;
        }
        if (SizeOfFile <= RawPointerToPeHeader + sizeof (IMAGE_NT_HEADERS) + SectionCount * sizeof (IMAGE_SECTION_HEADER))
            goto not_pe_file;
        fseek (fp, RawPointerToPeHeader + sizeof (IMAGE_NT_HEADERS) + (SectionCount - 1) * sizeof (IMAGE_SECTION_HEADER), SEEK_SET);
        fread (& SectionHeader, 1, sizeof SectionHeader, fp);
        ByteCount = SectionHeader.Misc.VirtualSize < SectionHeader.PointerToRawData ? SectionHeader.Misc.VirtualSize : SectionHeader.PointerToRawData;
        if (ByteCount == 0) {
            printf ("No data to read for target section.\n");
            fclose (fp);
            return -1;
        }
        else if (ByteCount + SectionHeader.PointerToRawData > SizeOfFile) {
            printf ("Bad section data.\n");
            fclose (fp);
            return -1;
        }
        fseek (fp, SectionHeader.PointerToRawData, SEEK_SET);
        pData = (BYTE *) malloc (ByteCount);
        fread (pData, 1, ByteCount, fp);
        ShowHexData (pData, ByteCount);
        free (pData);
        fclose (fp);
        return 0;
    not_pe_file :
        printf ("Not a PE file.\n");
        fclose (fp);
        return -1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8815961_8816190_33_62
8815961_8816223_17_35
Title: how to schedule two tasks? 
----------------------------------------

int main () {
    pthread_t tids [NOTHREADS];
    int ids [NOTHREADS] = {1, 2};
    int ret;
    long t;
    int i;
    printf ("Creating fun1 thread \n");
    ret = pthread_create (&tids[0], NULL, fun1, &ids[0]);
    if (ret) {
        printf ("unable to create thread! \n");
        exit (- 1);
    }
    printf ("Creating fun2 thread \n");
    ret = pthread_create (&tids[1], NULL, fun2, &ids[1]);
    if (ret) {
        printf ("unable to create thread! \n");
        exit (- 1);
    }
    for (i = 0; i < NOTHREADS; i++) {
        pthread_join (tids [i], NULL);
    }
    pthread_exit (NULL);
    return 0;
}
----------------------------------------

int main () {
    pid_t pID = fork ();
    if (0 == pID) {
        func1 ();
    }
    else if (pID < 0) {
        printf ("Fork failed 1\n");
    }
    else {
        func2 ();
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8817098_8817269_6_28
8817098_8817536_7_29
Title: How validate user input when the expected value is of type int and the entered value is not of type int? 
----------------------------------------

int main (void) {
    int x;
    char buf [4] = {0};
    scanf ("%s", buf);
    if (isdigit (buf[0])) {
        x = atoi (buf);
        if (x > 9) {
        }
        else {
        }
    }
    else {
    }
    return 0;
}
----------------------------------------

int main () {
    int n, i;
    while (1) {
        errno = 0;
        printf ("Enter a number (%d-%d) :", MIN, MAX);
        if (scanf ("%d", &n) != 1) {
            printf ("Damn you!\n");
            break;
        }
        if (n >= MIN && n <= MAX) {
            printf ("Good\n");
        }
        else {
            printf ("Damn you!\n");
            break;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8831323_40415611_6_16
8831323_8831424_30_42
Title: Find length of string in C (without using strlen) 
----------------------------------------

int main () {
    string leng;
    cout << "Enter String for Count" << endl;
    cin >> leng;
    int a = 0;
    while (leng[a++])
        ;
    {
        cout << a;
    }
}
----------------------------------------

int main () {
    char s [] = "test string";
    char *p = "another string";
    printf ("strlen1(%s) = %d \n", s, strlen1 (s));
    printf ("strlen1(%s) = %d \n", p, strlen1 (p));
    printf ("strlen2(%s) = %d \n", s, strlen2 (s));
    printf ("strlen2(%s) = %d \n", p, strlen2 (p));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877115_33894064_6_20
8877115_8877190_4_22
Title: Recursion and printf in C 
----------------------------------------

int visual (int plus) {
    int i;
    if (plus == 0) {
        return 1;
    }
    else {
        for (i = 1; i <= number; i++)
            printf ("+");
        printf ("\n");
        visual (plus - 1);
    }
}
----------------------------------------

int visual (int plus) {
    for (i = 0; i < plus; i++) {
        for (j = 0; j < plus; j++) {
            printf ("+");
        }
        printf ("\n");
    }
    int main () {int number;
    printf ("Please give the number\n");
    scanf ("%d", & number);
    visual (number);
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877115_33894064_6_20
8877115_8877273_14_27
Title: Recursion and printf in C 
----------------------------------------

int visual (int plus) {
    int i;
    if (plus == 0) {
        return 1;
    }
    else {
        for (i = 1; i <= number; i++)
            printf ("+");
        printf ("\n");
        visual (plus - 1);
    }
}
----------------------------------------

int visual (int plus, int add) {
    if (plus == 0) {
        return 1;
    }
    else {
        space (add);
        printf ("\n");
        visual (plus - 1, add);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877115_8877190_4_22
8877115_8877238_6_20
Title: Recursion and printf in C 
----------------------------------------

int visual (int plus) {
    for (i = 0; i < plus; i++) {
        for (j = 0; j < plus; j++) {
            printf ("+");
        }
        printf ("\n");
    }
    int main () {int number;
    printf ("Please give the number\n");
    scanf ("%d", & number);
    visual (number);
    getch ();
}
----------------------------------------

int visual (int plus) {
    int i;
    if (plus == 0) {
        return 1;
    }
    else {
        for (i = 1; i <= number; i++)
            printf ("+");
        printf ("\n");
        visual (plus - 1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877115_8877190_4_22
8877115_8877273_14_27
Title: Recursion and printf in C 
----------------------------------------

int visual (int plus) {
    for (i = 0; i < plus; i++) {
        for (j = 0; j < plus; j++) {
            printf ("+");
        }
        printf ("\n");
    }
    int main () {int number;
    printf ("Please give the number\n");
    scanf ("%d", & number);
    visual (number);
    getch ();
}
----------------------------------------

int visual (int plus, int add) {
    if (plus == 0) {
        return 1;
    }
    else {
        space (add);
        printf ("\n");
        visual (plus - 1, add);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877115_8877190_4_22
8877115_8877340_4_17
Title: Recursion and printf in C 
----------------------------------------

int visual (int plus) {
    for (i = 0; i < plus; i++) {
        for (j = 0; j < plus; j++) {
            printf ("+");
        }
        printf ("\n");
    }
    int main () {int number;
    printf ("Please give the number\n");
    scanf ("%d", & number);
    visual (number);
    getch ();
}
----------------------------------------

int visual (int plus) {
    if (plus % number == 0 && plus != number * number)
        printf ("\n");
    if (plus == 0) {
        return 1;
    }
    else {
        printf ("+");
        visual (plus - 1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877115_8877238_6_20
8877115_8877273_14_27
Title: Recursion and printf in C 
----------------------------------------

int visual (int plus) {
    int i;
    if (plus == 0) {
        return 1;
    }
    else {
        for (i = 1; i <= number; i++)
            printf ("+");
        printf ("\n");
        visual (plus - 1);
    }
}
----------------------------------------

int visual (int plus, int add) {
    if (plus == 0) {
        return 1;
    }
    else {
        space (add);
        printf ("\n");
        visual (plus - 1, add);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8877115_8877273_14_27
8877115_8877340_4_17
Title: Recursion and printf in C 
----------------------------------------

int visual (int plus, int add) {
    if (plus == 0) {
        return 1;
    }
    else {
        space (add);
        printf ("\n");
        visual (plus - 1, add);
    }
}
----------------------------------------

int visual (int plus) {
    if (plus % number == 0 && plus != number * number)
        printf ("\n");
    if (plus == 0) {
        return 1;
    }
    else {
        printf ("+");
        visual (plus - 1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8915480_8915578_47_71
8915480_8915627_87_106
Title: memory used by a program in bytes in c language under windows 
----------------------------------------

int main (void) {
    DWORD aProcesses [1024], cbNeeded, cProcesses;
    unsigned int i;
    if (!EnumProcesses (aProcesses, sizeof (aProcesses), &cbNeeded)) {
        return 1;
    }
    cProcesses = cbNeeded / sizeof (DWORD);
    for (i = 0; i < cProcesses; i++) {
        PrintMemoryInfo (aProcesses [i]);
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int pid;
    if (argc != 2) {
        fprintf (stderr, "Usage: %s <process ID>", argv [0]);
        return 1;
    }
    sscanf (argv [1], "%i", & pid);
    HANDLE process = OpenProcess (PROCESS_VM_READ | PROCESS_QUERY_INFORMATION, false, pid);
    show_modules (process);
    printf ("Total memory used: %luKB\n", usage / 1024);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
891715_891742_1_14
891715_891756_3_14
Title: Recursive Incrementer 
----------------------------------------

char *inc (char *num, char *p) {
    if (*p >= '0' && *p <= '8') {
        (*p)++;
    }
    else if (*p == '9') {
        *p = '0';
        inc (num, -- p);
    }
    return num;
}
----------------------------------------

char *inc (char *num, char *p) {
    if (p < num)
        return num;
    if ((*p < '0') || (*p > '9'))
        return num;
    if (*p < '9') {
        (*p)++;
        return num;
    }
    *p = '0';
    return inc (num, --p);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8943303_8943466_1_13
8943303_8945115_4_19
Title: Fibonacci! Recursive printf 
----------------------------------------

int fibo (int n) {
    printf ("%d ", n);
    if (n <= 2) {
        return n;
    }
    else {
        return fibo (n -2) + fibo (n -1);
    }
}
----------------------------------------

int fibo (int condition) {
    if (condition < 2) {
        printf ("+\n");
        return 1;
    }
    else {
        int n0, n1;
        printf ("+-");
        n1 = fibo (condition -1);
        n0 = fibo (condition -2);
        return n0 + n1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8957103_8957244_3_17
8957103_8957488_3_26
Title: How exactly does space work with scanf? 
----------------------------------------

int main (void) {
    int a [6];
    printf ("enter components: ");
    int i;
    for (i = 0; i < 6; i++) {
        scanf ("%d", & a [i]);
        if (a[i] == 4) {
            printf (" \n\n4 is not allowed, try again\n\n");
            i--;
        }
    }
    for (i = 0; i < 6; i++) {
        printf ("%d ", a [i]);
    }
}
----------------------------------------

int main (void) {
    int a [6];
    int i;
    bool hasError = false;
    int errorIndex = 0;
    do {
        hasError = false;
        printf ("enter components: ");
        for (i = 0; i < errorIndex; i++)
            printf ("%d ", a[i]);
        for (i = errorIndex; i < 6; i++) {
            scanf ("%d", & a [i]);
            if (a[i] == 4 && hasError == false) {
                printf (" \n\n4 is not allowed, try again\n\n");
                hasError = true;
                errorIndex = i;
            }
        }
    }
    while (hasError == true);
    for (i = 0; i < 6; i++) {
        printf ("%d ", a [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8969748_42760253_5_26
8969748_8969818_4_23
Title: "Set number of threads using omp_set_num_threads() to 2 but omp_get_num_threads() returns 1" 
----------------------------------------

int main () {
    const int maxNumThreads = omp_get_max_threads ();
    printf ("Maximum number of threads for this machine: %i\n", maxNumThreads);
    printf ("Not yet started a parallel Section: the number of threads is %i\n", omp_get_num_threads ());
    printf ("Setting the maximum number of threads...\n");
    omp_set_num_threads (maxNumThreads);
    printf ("Once again, not yet started a parallel Section: the number of threads is still %i\n", omp_get_num_threads ());
    printf ("Starting a parallel Section...\n");
    for (int i = 0; i < maxNumThreads; i++) {
        int tid = omp_get_thread_num ();
        printf ("This is thread %i announcing that the number of launched threads is %i\n", tid, omp_get_num_threads ());
    }
}
----------------------------------------

int main (int argc, const char *argv []) {
    int nProcessors = omp_get_max_threads ();
std :
    : cout << nProcessors << std : : endl;
    omp_set_num_threads (nProcessors);
std :
    : cout << omp_get_num_threads () << std : : endl;
    for (int i = 0; i < 5; i++) {
        int tid = omp_get_thread_num ();
    std :
        : cout << tid << "\t tid" << std : : endl;
        int nThreads = omp_get_num_threads ();
    std :
        : cout << nThreads << "\t nThreads" << std : : endl;
    }
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8970715_18451409_1_18
8970715_34589962_1_14
Title: How do I base58 encode a string? 
----------------------------------------

function base58_encode ($input) {
    $alphabet = '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ';
    $base_count = strval (strlen ($alphabet));
    $encoded = '';
    while (floatval ($input) >= floatval ($base_count)) {
        $div = bcdiv ($input, $base_count);
        $mod = bcmod ($input, $base_count);
        $encoded = substr ($alphabet, intval ($mod), 1).$encoded;
        $input = $div;
    }
    if (floatval ($input) > 0) {
        $encoded = substr ($alphabet, intval ($input), 1).$encoded;
    }
    return ($encoded);
}
----------------------------------------

string base58_encode (Integer num, string vers) {
    string alphabet [58] = {"1", "2", "3", "4", "5", "6", "7", "8", "9", "A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z"};
    int base_count = 58;
    string encoded;
    Integer div;
    Integer mod;
    while (num >= base_count) {
        div = num / base_count;
        mod = (num - (base_count * div));
        encoded = alphabet[mod.ConvertToLong ()] + encoded;
        num = div;
    }
    encoded = vers + alphabet[num.ConvertToLong ()] + encoded;
    return encoded;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9002190_9002522_5_29
9002190_9002579_3_15
Title: "How to multiplying multiple inputs from using while loop in c" 
----------------------------------------

int main () {
    float f1;
    float total = 0;
    printf ("Enter number: ");
    if (scanf ("%f", &total)) {
        for (;;) {
            printf ("Enter number: ");
            if (!scanf ("%f", &f1)) {
                break;
            }
            total *= f1;
        }
    }
    printf ("Multiplication Total = %f\n", total);
    getch ();
    return 0;
}
----------------------------------------

int main () {
    int total = 1, factor = 1, success;
    do {
        total *= factor;
        printf ("Enter integer number to multiply or 'n' to quit: ");
        success = scanf ("%d", &factor);
    }
    while (success);
    printf ("Multiplication Total = %d\n", total);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9018614_10822517_102_139
9018614_9020599_81_93
Title: Algorithm to find Lucky Numbers 
----------------------------------------

int main (int argc, char **argv) {
    gen_primes ();
    gen_table ();
    for (int i = 0; i <= 18; i++)
        for (int j = 0; j <= 163; j++) {
            for (int k = 0; k <= 1458; k++)
                if (dyn_table[i][j][k] != 0ll) {
                    start[i][j] = k;
                    break;
                }
            for (int k = 1460; k >= 0; k--)
                if (dyn_table[i][j][k] != 0ll) {
                    end[i][j] = k;
                    break;
                }
        }
    int cases = 0;
    scanf ("%d", & cases);
    for (int i = 0; i < cases; ++i) {
        unsigned long long a, b;
        scanf ("%lld %lld", & a, & b);
        if (b == 1000000000000000000ll)
            b--;
        printf ("%lld\n", count_lucky (b) - count_lucky (a - 1));
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    gen_primes ();
    gen_table ();
    int cases = 0;
    scanf ("%d", & cases);
    for (int i = 0; i < cases; ++i) {
        long long a, b;
        scanf ("%lld %lld", & a, & b);
        printf ("%lld\n", count_lucky (b) - count_lucky (a - 1));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9018614_10822517_51_100
9018614_9020599_46_79
Title: Algorithm to find Lucky Numbers 
----------------------------------------

unsigned long long count_lucky (unsigned long long maxp) {
    unsigned long long result = 0;
    int len = 0;
    int split_max [MAX_LENGTH];
    while (maxp) {
        split_max[len] = maxp % 10;
        maxp /= 10;
        ++len;
    }
    int sum = 0;
    int sq_sum = 0;
    unsigned long long step_result;
    unsigned long long step_;
    for (int i = len - 1; i >= 0; --i) {
        step_result = 0;
        int x1 = 9 * i;
        for (int l = 0; l < split_max[i]; ++l) {
            step_ = 0;
            if (ans[i][l][sum][sq_sum] != 0) {
                step_result += ans[i][l][sum][sq_sum];
                continue;
            }
            int y = l + sum;
            int x = l * l + sq_sum;
            for (int j = 0; j <= x1; ++j) {
                if (primes[j + y])
                    for (int k = start[i][j]; k <= end[i][j]; ++k) {
                        if (primes[k + x]) {
                            step_result += dyn_table[i][j][k];
                            step_ += dyn_table[i][j][k];
                        }
                    }
            }
            ans[i][l][sum][sq_sum] = step_;
        }
        result += step_result;
        sum += split_max[i];
        sq_sum += split_max[i] * split_max[i];
    }
    if (primes[sum] && primes[sq_sum]) {
        ++result;
    }
    return result;
}
----------------------------------------

long long count_lucky (long long max) {
    long long result = 0;
    int len = 0;
    int split_max [MAX_LENGTH];
    while (max) {
        split_max[len] = max % 10;
        max /= 10;
        ++len;
    }
    int sum = 0;
    int sq_sum = 0;
    for (int i = len - 1; i >= 0; --i) {
        long long step_result = 0;
        for (int l = 0; l < split_max[i]; ++l) {
            for (int j = 0; j <= 9 * i; ++j) {
                for (int k = 0; k <= 9 * 9 * i; ++k) {
                    if (primes[j + l + sum] && primes[k + l * l + sq_sum]) {
                        step_result += dyn_table[i][j][k];
                    }
                }
            }
        }
        result += step_result;
        sum += split_max[i];
        sq_sum += split_max[i] * split_max[i];
    }
    if (primes[sum] && primes[sq_sum]) {
        ++result;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9029284_49175500_4_28
9029284_9029634_6_42
Title: Can Anybody Explain me popen() with write mode 
----------------------------------------

int main (int argc, char *argv []) {
    FILE *fp = popen ("/path/to/yourBinary cmdLineArgs", "w");
    if (fp == NULL) {
        printf ("Failed to open the pipe\n");
    }
    else {
        fputc ('n', fp);
        fputc ('\n', fp);
        fputs ("s\n", fp);
        fputs ("4096M\n", fp);
        pclose (fp);
    }
    return 0;
}
----------------------------------------

void main () {
    char *input = "obex_test -b";
    FILE *fp = NULL;
    char path [512];
    fp = popen (input, "w");
    if (fp == NULL) {
        printf ("\nFailed command\n");
        return;
    }
    else {
        printf ("\nSuccesss command\n");
    }
    fputc ('s', fp);
    fputc ('\n', fp);
    printf ("starting while : %d", fp);
    while (fgets (path, sizeof (path) - 1, fp) != NULL) {
        printf ("\nOutput    :::  %s \n", path);
    }
    printf ("\nEnd\n");
    pclose (fp);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9035848_9035920_14_34
9035848_9055163_11_21
Title: Runtime limit timer in C 
----------------------------------------

int main (int argc, char **argv) {
    time_t start_time;
    time_t now_time;
    pthread_t algo_thread;
    int ret = pthread_create (&algo_thread, NULL, algo, NULL);
    time (& start_time);
    while (1) {
        time (& now_time);
        if (difftime (now_time, start_time) >= 5) {
            break;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    struct sigaction sa = {0};
    sa.sa_handler = timeout_handler;
    sigaction (SIGALRM, & sa, NULL);
    alarm (5);
    for (;;)
        ;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9040216_9040744_1_15
9040216_9043592_1_17
Title: Recursion to Iteration - Scheme to C 
----------------------------------------

int powmod2 (int x, int e, int m) {
    int r = 1;
    while (e != 0) {
        if (e % 2) {
            r = (r * x) % m;
        }
        x = (x * x) % m;
        e /= 2;
    }
    return r;
}
----------------------------------------

int powmod2 (int x, int e, int m) {
    int acc = 1;
    int xsqrm = 0;
    while (e != 0) {
        xsqrm = (x * x) % m;
        if (e % 2 == 0) {
            x = xsqrm;
            e = e / 2;
        }
        else {
            acc = (x * acc) % m;
            x = xsqrm;
            e = (e - 1) / 2;
        }
    }
    return acc;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9044474_9044605_3_14
9044474_9128228_5_31
Title: How do I get the string from a character array in C? 
----------------------------------------

int main () {
    char data [5];
    data[0] = 'c';
    data[1] = 'a';
    data[2] = 't';
    data[3] = '\0';
    data[4] = 'x';
    printf ("%s", data);
    return 0;
}
----------------------------------------

void main () {
    int n, pos = 0;
    char ch;
    cout << "\nEnter number of characters: ";
    cin >> n;
    char * ptr = new char [n];
    while (pos < n) {
        cout << "\nEnter character: ";
        cin >> ch;
        cout << "\nEnter position: ";
        cin >> pos;
        ptr[pos] = ch;
    }
    cout << "\nNumber of Valid characters: ";
    int count = 0;
    for (int i = 0; i < n; i++) {
        if (isalnum (ptr[i]) || ispunct (ptr[i])) {
            count++;
        }
    }
    cout << count << endl;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9052425_9052669_23_33
9052425_9052928_6_26
Title: How to return a struct without using global declaration of struct in C 
----------------------------------------

int main (int argc, char **argv) {
    struct node tmp;
    char sel = argv[1][0];
    if (log_in (sel, &tmp)) {
        printf ("%s, %d, %d\n", tmp.name_log, tmp.passlog, tmp.user_point);
    }
    else {
    }
}
----------------------------------------

int main (void) {
    int sel = '2';
    if (sel == '2') {
        struct node {
            char name_log [20];
            int passlog;
            int user_point;
        } tmp;
        pTmp = &tmp;
        log_in ();
        if (tmp.passlog)
            logged_in (tmp.name_log, tmp.user_point);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9072971_9073008_1_14
9072971_9073108_17_30
Title: c passing pointer to recursive function 
----------------------------------------

void f (int i, int j, int *cnt) {
    if (i > N) {
        printf ("---if --- %d ---- %d \n", i, j);
        return;
    }
    (*cnt)++;
    printf ("---bg --- %d ---- %d \n", i, j);
    if (i < 50 && j < 50) {
        f (i + 1, ++ j, cnt);
        f (i + 1, ++ j, cnt);
    }
}
----------------------------------------

void f (int i, int j, int *cnt) {
    if (i > N) {
        printf ("---if --- %d ---- %d\n", i, j);
        return;
    }
    (*cnt)++;
    printf ("---bg --- %d ---- %d\n", i, j);
    f (i + 1, ++ j, cnt);
    f (i + 1, ++ j, cnt);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9085201_9085612_3_38
9085201_9085673_29_41
Title: C scanning array diagonally 
----------------------------------------

int main (int argc, char *argv []) {
    const int ROWS = 10;
    const int COLS = 15;
    int array [ROWS] [COLS];
    int i, j;
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j <= i && j < COLS; ++j) {
            scanf ("%d", & array [i - j] [j]);
        }
    }
    for (j = 1; j < COLS; ++j) {
        for (i = 0; i < ROWS && j + i < COLS; ++i) {
            scanf ("%d", & array [ROWS - i - 1] [j + i]);
        }
    }
    FILE *fp = fopen ("test.txt", "w");
    for (i = 0; i < ROWS; ++i) {
        for (j = 0; j < COLS; ++j) {
            fprintf (fp, "%d ", array [i] [j]);
        }
        fputc ('\n', fp);
    }
    fclose (fp);
    return 0;
}
----------------------------------------

int main (void) {
    int data [2] [3] = {{1, 2, 3}, {10, 20, 30}};
    scan_array (& data [0] [0], 2, 3, print_elem);
    printf ("\n========\n");
    int data2 [3] [2] = {{1, 2}, {10, 20}, {100, 200}};
    scan_array (& data2 [0] [0], 3, 2, print_elem);
    printf ("\n========\n");
    int square [2] [2] = {{1, 2}, {10, 20}};
    scan_array (& square [0] [0], 2, 2, print_elem);
    printf ("\n========\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
910066_910116_5_21
910066_911399_1_24
Title: Moving data from inline assembly into array in C 
----------------------------------------

int main (int argc, char **argv) {
    int i;
    asm volatile ("xor %eax, %eax \n\t"
    ) asm volatile ("movl $0x020, %edi \n\t"
    ) asm volatile (".rept 32 \n\t"
    ) asm volatile ("mov %edi, _results(,%eax,4) \n\t"
    ) asm volatile ("dec %edi \n\t"
    ) asm volatile ("inc %eax \n\t"
    ) asm volatile (".endr"
    ) for (i = 0; i < 32; i++)
        printf ("%d\n", results[i]);
    return 0;
}
----------------------------------------

int main () {
    int results [32];
    int i;
    __asm__ __volatile__ ("mov  %esi, 32 \n\t");
    __asm__ __volatile__ ("mov  %edi, 32 \n\t");
    __asm__ __volatile__ (".rept 32 \n\t");
    __asm__ __volatile__ ("mov  %eax, %esi \n\t");
    __asm__ __volatile__ ("sub  %eax, %edi \n\t");
    __asm__ __volatile__ ("sub  %edi, 1 \n\t");
    __asm__ (".intel_syntax prefix"
    ) __asm__ __volatile__ ("mov dword ptr results[%edi*4], %eax \n\t");
    __asm__ (".att_syntax prefix"
    ) __asm__ __volatile__ (".endr \n\t");
    for (i = 0; i < 32; i++)
        printf ("%d\n", results[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9106295_9106322_19_29
9106295_9106741_19_28
Title: Palindrome Program 
----------------------------------------

char *backward (char *str) {
    int count = strlen (str);
    char *back = malloc (MAXLINE);
    int i;
    for (i = 0; i < count; i++) {
        back[count - i - 1] = str[i];
    }
    back[count] = 0;
    return back;
}
----------------------------------------

char *backward (char str [], int count) {
    char back [MAXLINE];
    int i;
    for (i = 0; i < count; ++i) {
        back[count - i - 1] = str[i];
    }
    back[i] = '\0';
    return back;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9148543_9148657_8_26
9148543_9148661_1_13
Title: Program to print permutations of given elements 
----------------------------------------

void permute (char *string, int start, int end) {
    if (start == end) {
        printf ("%s\n", string);
        return;
    }
    permute (string, start + 1, end);
    int i;
    for (i = start + 1; i < end; i++) {
        if (string[start] == string[i])
            continue;
        swap (string, start, i);
        permute (string, start + 1, end);
        swap (string, start, i);
    }
}
----------------------------------------

void permute (int *array, int i, int length) {
    if (length == i) {
        printArray (array, length);
        return;
    }
    int j = i;
    for (j = i; j < length; j++) {
        swap (array + i, array + j);
        permute (array, i + 1, length);
        swap (array + i, array + j);
    }
    return;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9167873_9167944_5_27
9167873_9168028_1_17
Title: extracting an unknown substring out of a string 
----------------------------------------

int main () {
    char *s = "<CFData 0x1001219c0 [0x7fff7027aee0]>{length = 20, " "capacity = 20, " "bytes = 0x8deead13b8ae7057f6a629fdaae5e1200bcb8cf5}";
    char *value = 0;
    const char *begin = strstr (s, "bytes = 0x");
    if (begin) {
        begin += 10;
        value = malloc (strlen (begin));
        if (value) {
            memcpy (value, begin, strlen (begin) - 1);
            *(value + strlen (begin) - 1) = 0;
            printf ("%s\n", value);
            free (value);
        }
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char s [] = "<CFData 0x1001219c0 [0x7fff7027aee0]>{length = 20, capacity = 20, bytes = 0x8deead13b8ae7057f6a629fdaae5e1200bcb8cf5}";
    const char *tok = "<>[]{}= ,";
    char *t = strtok (s, tok);
    int take_next = false;
    char *res;
    while (t) {
        if (take_next) {
            res = t + 2;
            break;
        }
        take_next = !strcmp (t, "bytes");
        t = strtok (NULL, tok);
    }
    printf ("%s\n", res);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9180027_9180300_1_35
9180027_9180475_1_24
Title: segmentation fault inside on loop 
----------------------------------------

char **split (char *delimiter, char *input) {
    int size;
    int maxsize;
    char **tokens;
    char *token;
    char *state;
    maxsize = strlen (input) / 2 + 2;
    tokens = (char **) malloc (maxsize * sizeof (char *));
    if (tokens == NULL) {
        printf ("Allocation failed.");
        return NULL;
    }
    size = 0;
    for (token = strtok_r (input, delimiter, &state); token != NULL; token = strtok_r (NULL, delimiter, &state)) {
        tokens[size++] = token;
    }
    assert (size < maxsize);
    tokens[size] = NULL;
    return tokens;
}
----------------------------------------

char **split (char *delimiter, char *input) {
    unsigned size, used;
    char **array = NULL;
    char *token;
    char *state;
    size = used = 0;
    for (token = strtok_r (input, delimiter, &state); token; token = strtok_r (NULL, delimiter, &state)) {
        if (used + 1 >= size) {
            size = size ? 2 * size : 4;
            array = realloc (array, size * sizeof *array);
            if (!array) {
                printf ("Realloc failed.");
                return NULL;
            }
        }
        array[used++] = state;
    }
    if (array)
        array[used] = NULL;
    return array;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9180027_9180300_1_35
9180027_9180605_1_43
Title: segmentation fault inside on loop 
----------------------------------------

char **split (char *delimiter, char *input) {
    int size;
    int maxsize;
    char **tokens;
    char *token;
    char *state;
    maxsize = strlen (input) / 2 + 2;
    tokens = (char **) malloc (maxsize * sizeof (char *));
    if (tokens == NULL) {
        printf ("Allocation failed.");
        return NULL;
    }
    size = 0;
    for (token = strtok_r (input, delimiter, &state); token != NULL; token = strtok_r (NULL, delimiter, &state)) {
        tokens[size++] = token;
    }
    assert (size < maxsize);
    tokens[size] = NULL;
    return tokens;
}
----------------------------------------

char **split (char *delimiter, char *input) {
    int i;
    char **tokens;
    char *token;
    char *state;
    tokens = (char **) malloc (sizeof (char *) * (2));
    if (tokens == NULL) {
        printf ("Allocation failed.");
        return NULL;
    }
    tokens[0] = (char *) 1;
    tokens[1] = NULL;
    for (i = 1, token = strtok_r (input, delimiter, &state); token != NULL; token = strtok_r (NULL, delimiter, &state), i++) {
        {
            char **new = (char **) realloc (tokens, (i + 2) * sizeof (char *));
            if (new == NULL) {
                printf ("Realloc failed.");
                free (tokens);
                return NULL;
            }
            else {
                tokens = new;
                tokens[i + 1] = NULL;
            }
        }
        tokens[i] = token;
        tokens[0] = (char *) i;
    }
    return tokens;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9180027_9180300_1_35
9180027_9181783_1_41
Title: segmentation fault inside on loop 
----------------------------------------

char **split (char *delimiter, char *input) {
    int size;
    int maxsize;
    char **tokens;
    char *token;
    char *state;
    maxsize = strlen (input) / 2 + 2;
    tokens = (char **) malloc (maxsize * sizeof (char *));
    if (tokens == NULL) {
        printf ("Allocation failed.");
        return NULL;
    }
    size = 0;
    for (token = strtok_r (input, delimiter, &state); token != NULL; token = strtok_r (NULL, delimiter, &state)) {
        tokens[size++] = token;
    }
    assert (size < maxsize);
    tokens[size] = NULL;
    return tokens;
}
----------------------------------------

char **split (char *delim, char *input) {
    char *save;
    char **tmp, **res;
    int i, count;
    if (!(res = malloc (sizeof (res[0])))) {
        fprintf (stderr, "split(): malloc() failed\n");
        return NULL;
    }
    res[0] = strtok_r (input, delim, &save);
    if (res[0])
        i = 0;
    count = 1;
    do {
        if (tmp = realloc (res, sizeof (res[0]) * ++count))
            res = tmp;
        else {
            free (res);
            fprintf (stderr, "split(): realloc() failed.\n");
            return NULL;
        }
        res[++i] = strtok_r (NULL, delim, &save);
    }
    while (res[i]);
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9180027_9180475_1_24
9180027_9180605_1_43
Title: segmentation fault inside on loop 
----------------------------------------

char **split (char *delimiter, char *input) {
    unsigned size, used;
    char **array = NULL;
    char *token;
    char *state;
    size = used = 0;
    for (token = strtok_r (input, delimiter, &state); token; token = strtok_r (NULL, delimiter, &state)) {
        if (used + 1 >= size) {
            size = size ? 2 * size : 4;
            array = realloc (array, size * sizeof *array);
            if (!array) {
                printf ("Realloc failed.");
                return NULL;
            }
        }
        array[used++] = state;
    }
    if (array)
        array[used] = NULL;
    return array;
}
----------------------------------------

char **split (char *delimiter, char *input) {
    int i;
    char **tokens;
    char *token;
    char *state;
    tokens = (char **) malloc (sizeof (char *) * (2));
    if (tokens == NULL) {
        printf ("Allocation failed.");
        return NULL;
    }
    tokens[0] = (char *) 1;
    tokens[1] = NULL;
    for (i = 1, token = strtok_r (input, delimiter, &state); token != NULL; token = strtok_r (NULL, delimiter, &state), i++) {
        {
            char **new = (char **) realloc (tokens, (i + 2) * sizeof (char *));
            if (new == NULL) {
                printf ("Realloc failed.");
                free (tokens);
                return NULL;
            }
            else {
                tokens = new;
                tokens[i + 1] = NULL;
            }
        }
        tokens[i] = token;
        tokens[0] = (char *) i;
    }
    return tokens;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
9180027_9180475_1_24
9180027_9181783_1_41
Title: segmentation fault inside on loop 
----------------------------------------

char **split (char *delimiter, char *input) {
    unsigned size, used;
    char **array = NULL;
    char *token;
    char *state;
    size = used = 0;
    for (token = strtok_r (input, delimiter, &state); token; token = strtok_r (NULL, delimiter, &state)) {
        if (used + 1 >= size) {
            size = size ? 2 * size : 4;
            array = realloc (array, size * sizeof *array);
            if (!array) {
                printf ("Realloc failed.");
                return NULL;
            }
        }
        array[used++] = state;
    }
    if (array)
        array[used] = NULL;
    return array;
}
----------------------------------------

char **split (char *delim, char *input) {
    char *save;
    char **tmp, **res;
    int i, count;
    if (!(res = malloc (sizeof (res[0])))) {
        fprintf (stderr, "split(): malloc() failed\n");
        return NULL;
    }
    res[0] = strtok_r (input, delim, &save);
    if (res[0])
        i = 0;
    count = 1;
    do {
        if (tmp = realloc (res, sizeof (res[0]) * ++count))
            res = tmp;
        else {
            free (res);
            fprintf (stderr, "split(): realloc() failed.\n");
            return NULL;
        }
        res[++i] = strtok_r (NULL, delim, &save);
    }
    while (res[i]);
    return res;
}
----------------------------------------
