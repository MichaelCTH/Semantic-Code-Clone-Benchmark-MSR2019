$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6485174_6485387_43_51
6485174_6486096_5_84
Title: "Interview Question... Trying to work it out but couldn't get an efficient solution" 
----------------------------------------

int main (int argc, char **argv) {
    if (!doit (a, b, c, sizeof (a) / sizeof (int))) {
        printf ("no solution");
    }
    else {
        for (size_t i = 0; i < sizeof (a) / sizeof (int); ++i)
            printf ("c[%zu] = %d\n", i, c[i]);
    }
}
----------------------------------------

int main () {
    int a [] = {1, 2, 3};
    int b [] = {1, -1, -1};
    int c [] = {EMPTY, EMPTY, EMPTY};
    int n = sizeof (a) / sizeof (int);
    int l = 0, r = n - 1;
    int i, j;
    for (i = 0, j = n - 1; i < n; ++i, --j) {
        if (b[i] == 0) {
            c[i] = a[i];
            while (l <= i && c[l] != EMPTY)
                ++l;
        }
        else if (b[i] == -1) {
            if (i <= l)
                break;
            c[l] = a[i];
            do
                ++l;
            while (l <= i && c[l] != EMPTY);
        }
        if (b[j] == 0) {
            c[j] = a[j];
            while (r >= j && c[r] != EMPTY)
                --r;
        }
        else if (b[j] == 1) {
            if (j >= r)
                break;
            c[r] = a[j];
            do
                --r;
            while (r >= j && c[r] != EMPTY);
        }
        if (l > r) {
            l = n;
            r = -1;
        }
    }
    if (i < n)
        printf ("Unsolvable");
    else {
        for (i = 0; i < n; ++i)
            printf ("%d ", c[i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
653961_13347013_5_19
653961_874510_2_15
Title: "Factorial in C without conditionals loops and arithmetic operators" 
----------------------------------------

int main (int argc, char **argv) {
    printf ("%d\n", (int) round (exp (lgamma (2))));
    printf ("%d\n", (int) round (exp (lgamma (3))));
    printf ("%d\n", (int) round (exp (lgamma (4))));
    printf ("%d\n", (int) round (exp (lgamma (5))));
    printf ("%d\n", (int) round (exp (lgamma (6))));
    printf ("%d\n", (int) round (exp (lgamma (7))));
    printf ("%d\n", (int) round (exp (lgamma (8))));
    printf ("%d\n", (int) round (exp (lgamma (9))));
    printf ("%d\n", (int) round (exp (lgamma (10))));
    printf ("%d\n", (int) round (exp (lgamma (11))));
    return 0;
}
----------------------------------------

void main () {
    unsigned long int num, fact, counter;
    while (counter <= num) {
        printf ("Enter the number");
        scanf ("%d", & num);
        fact = fact * counter;
        counter++;
        printf ("The factorial of number entered is %lu", fact);
    }
    printf ("press any key to exit...");
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6542491_21545507_5_28
6542491_37125651_24_51
Title: how to create two processes from a single Parent 
----------------------------------------

int main () {
    system ("clear");
    int i;
    pid_t childa, childb, childa1, childa2, childb1, childb2;
    printf ("\n \t \t I am the parent process with ID %d \n", getpid ());
    childa = fork ();
    if (childa == 0) {
        printf ("\nI am a child A with PID %d and my parent ID is %d\n", getpid (), getppid ());
    }
    else {
        childb = fork ();
        if (childb == 0) {
            printf ("\nI am Child B with ID %d and my parent ID is %d\n", getpid (), getppid ());
        }
        else {
            sleep (1);
        }
    }
}
----------------------------------------

int main () {
    const int N = 5;
    pid_t pids [N];
    int i;
    for (i = 0; i < N; i++) {
        pids[i] = fork ();
        sleep (1);
        if (pids[i] == 0)
            start (i +1);
    }
    for (i = 0; i < N; i++)
        wait (NULL);
    printf ("Partent process reached the end\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6542491_21545507_5_28
6542491_43508263_5_32
Title: how to create two processes from a single Parent 
----------------------------------------

int main () {
    system ("clear");
    int i;
    pid_t childa, childb, childa1, childa2, childb1, childb2;
    printf ("\n \t \t I am the parent process with ID %d \n", getpid ());
    childa = fork ();
    if (childa == 0) {
        printf ("\nI am a child A with PID %d and my parent ID is %d\n", getpid (), getppid ());
    }
    else {
        childb = fork ();
        if (childb == 0) {
            printf ("\nI am Child B with ID %d and my parent ID is %d\n", getpid (), getppid ());
        }
        else {
            sleep (1);
        }
    }
}
----------------------------------------

int main () {
    pid_t lazy_child;
    lazy_child = fork ();
    if (lazy_child == 0) {
        printf ("LAZY CHILD:%d\n", getpid ());
    }
    else if (lazy_child > 0) {
        pid_t active_child = fork ();
        if (active_child == 0) {
            printf ("ACTIVE CHILD:%d\n", getpid ());
        }
        else if (active_child > 0) {
            printf ("FATHER:%d\n", getpid ());
        }
        else {
            printf ("fork error\n");
            exit (1);
        }
    }
    else {
        printf ("fork error\n");
        exit (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6542491_21545507_5_28
6542491_47257923_4_20
Title: how to create two processes from a single Parent 
----------------------------------------

int main () {
    system ("clear");
    int i;
    pid_t childa, childb, childa1, childa2, childb1, childb2;
    printf ("\n \t \t I am the parent process with ID %d \n", getpid ());
    childa = fork ();
    if (childa == 0) {
        printf ("\nI am a child A with PID %d and my parent ID is %d\n", getpid (), getppid ());
    }
    else {
        childb = fork ();
        if (childb == 0) {
            printf ("\nI am Child B with ID %d and my parent ID is %d\n", getpid (), getppid ());
        }
        else {
            sleep (1);
        }
    }
}
----------------------------------------

void main () {
    int pi_d;
    int pid;
    pi_d = fork ();
    if (pi_d == 0) {
        printf ("Child Process B:\npid :%d\nppid:%d\n", getpid (), getppid ());
    }
    if (pi_d > 0) {
        pid = fork ();
        if (pid > 0) {
            printf ("\nParent Process:\npid:%d\nppid :%d\n", getpid (), getppid ());
        }
        else if (pid == 0) {
            printf ("Child Process A:\npid :%d\nppid:%d\n", getpid (), getppid ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6542491_37125651_24_51
6542491_43508263_5_32
Title: how to create two processes from a single Parent 
----------------------------------------

int main () {
    const int N = 5;
    pid_t pids [N];
    int i;
    for (i = 0; i < N; i++) {
        pids[i] = fork ();
        sleep (1);
        if (pids[i] == 0)
            start (i +1);
    }
    for (i = 0; i < N; i++)
        wait (NULL);
    printf ("Partent process reached the end\n");
    return 0;
}
----------------------------------------

int main () {
    pid_t lazy_child;
    lazy_child = fork ();
    if (lazy_child == 0) {
        printf ("LAZY CHILD:%d\n", getpid ());
    }
    else if (lazy_child > 0) {
        pid_t active_child = fork ();
        if (active_child == 0) {
            printf ("ACTIVE CHILD:%d\n", getpid ());
        }
        else if (active_child > 0) {
            printf ("FATHER:%d\n", getpid ());
        }
        else {
            printf ("fork error\n");
            exit (1);
        }
    }
    else {
        printf ("fork error\n");
        exit (1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6542491_37125651_24_51
6542491_47257923_4_20
Title: how to create two processes from a single Parent 
----------------------------------------

int main () {
    const int N = 5;
    pid_t pids [N];
    int i;
    for (i = 0; i < N; i++) {
        pids[i] = fork ();
        sleep (1);
        if (pids[i] == 0)
            start (i +1);
    }
    for (i = 0; i < N; i++)
        wait (NULL);
    printf ("Partent process reached the end\n");
    return 0;
}
----------------------------------------

void main () {
    int pi_d;
    int pid;
    pi_d = fork ();
    if (pi_d == 0) {
        printf ("Child Process B:\npid :%d\nppid:%d\n", getpid (), getppid ());
    }
    if (pi_d > 0) {
        pid = fork ();
        if (pid > 0) {
            printf ("\nParent Process:\npid:%d\nppid :%d\n", getpid (), getppid ());
        }
        else if (pid == 0) {
            printf ("Child Process A:\npid :%d\nppid:%d\n", getpid (), getppid ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6542491_43508263_5_32
6542491_47257923_4_20
Title: how to create two processes from a single Parent 
----------------------------------------

int main () {
    pid_t lazy_child;
    lazy_child = fork ();
    if (lazy_child == 0) {
        printf ("LAZY CHILD:%d\n", getpid ());
    }
    else if (lazy_child > 0) {
        pid_t active_child = fork ();
        if (active_child == 0) {
            printf ("ACTIVE CHILD:%d\n", getpid ());
        }
        else if (active_child > 0) {
            printf ("FATHER:%d\n", getpid ());
        }
        else {
            printf ("fork error\n");
            exit (1);
        }
    }
    else {
        printf ("fork error\n");
        exit (1);
    }
    return 0;
}
----------------------------------------

void main () {
    int pi_d;
    int pid;
    pi_d = fork ();
    if (pi_d == 0) {
        printf ("Child Process B:\npid :%d\nppid:%d\n", getpid (), getppid ());
    }
    if (pi_d > 0) {
        pid = fork ();
        if (pid > 0) {
            printf ("\nParent Process:\npid:%d\nppid :%d\n", getpid (), getppid ());
        }
        else if (pid == 0) {
            printf ("Child Process A:\npid :%d\nppid:%d\n", getpid (), getppid ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
656504_656520_3_16
656504_656521_5_14
Title: How to overwrite stdout in C 
----------------------------------------

int main (int argc, char *argv []) {
    while (1) {
        printf ("***********");
        fflush (stdout);
        sleep (1);
        printf ("\r");
        printf ("...........");
        sleep (1);
    }
    return 0;
}
----------------------------------------

int main () {
    int i;
    for (i = 77; i >= 0; i--) {
        printf ("[%s]\r", & bar [i]);
        fflush (stdout);
        sleep (1);
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
656542_20669467_1_12
656542_2620231_2_20
Title: Trim a string in C 
----------------------------------------

char *Trim (char *str) {
    int len = strlen (str);
    char * buff = new char [len];
    int i = 0;
    memset (buff, 0, len * sizeof (char));
    do {
        if (isspace (*str))
            continue;
        buff[i] = *str;
        ++i;
    }
    while (*(++str) != '\0');
    return buff;
}
----------------------------------------

char *Trim (char *szStr, const char ch, int iMode) {
    if (szStr == NULL)
        return NULL;
    char szTmp [1024 * 10] = {0x00};
    strcpy (szTmp, szStr);
    int iLen = strlen (szTmp);
    char *pStart = szTmp;
    char *pEnd = szTmp + iLen;
    int i;
    for (i = 0; i < iLen; i++) {
        if (szTmp[i] == ch && pStart == szTmp + i && iMode != 2)
            ++pStart;
        if (szTmp[iLen - i - 1] == ch && pEnd == szTmp + iLen - i && iMode != 1)
            *(--pEnd) = '\0';
    }
    strcpy (szStr, pStart);
    return szStr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
656542_2531068_1_17
656542_657508_1_10
Title: Trim a string in C 
----------------------------------------

char *trim (char *input) {
    char *start = input;
    while (isSpace (*start)) {
        start++;
    }
    char *ptr = start;
    char *end = start;
    while (*ptr++ != '\0') {
        if (!isSpace (*ptr)) {
            end = ptr;
        }
    }
    *end = '\0';
    return start;
}
----------------------------------------

char *trim (char *s) {
    char *ptr;
    if (!s)
        return NULL;
    if (!*s)
        return s;
    for (ptr = s + strlen (s) - 1; (ptr >= s) && isspace (*ptr); --ptr)
        ;
    ptr[1] = '\0';
    return s;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
656542_4613647_41_53
656542_5333495_23_39
Title: Trim a string in C 
----------------------------------------

char *rtrim (char *s) {
    char *back;
    int len = strlen (s);
    if (len == 0)
        return (s);
    back = s + len;
    while (isspace (*--back))
        ;
    *(back + 1) = '\0';
    return s;
}
----------------------------------------

char *rtrim (char * const s) {
    size_t len;
    char *cur;
    if (s && *s) {
        len = strlen (s);
        cur = s + len - 1;
        while (cur != s && isspace (*cur))
            --cur, --len;
        cur[isspace (*cur) ? 0 : 1] = '\0';
    }
    return s;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6590593_6591093_1_52
6590593_6592851_12_32
Title: changing rows into column and column into rows of that 2d array 
----------------------------------------

int main () {
    int **data;
    int rows = 0, columns = 0;
    char in [256];
    int *irow;
    for (rows = 0; 1; ++rows) {
        scanf ("%255s", in);
        if (strcmp (in, "exit") == 0)
            break;
        for (int icolumn = 0; 1; ++icolumn) {
        }
        if (rows == 0)
            columns = icolumn;
        if (columns != icolumns) {
            printf ("OMG! The user is a hacker!\n");
            break;
        }
        data[rows] = irow;
    }
    for (int i = 0; i < columns; ++i) {
        for (int j = 0; j < rows; ++j) {
            printf ("%d\t", data [j] [i]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int oldar [2] [3] = {{1, 2, 3}, {4, 5, 6}};
    int newar [3] [2];
    transpose (& oldar [0] [0], & newar [0] [0], 2, 3);
    int i, j;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            printf ("%d ", oldar[i][j]);
        printf ("\n");
    }
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 2; j++)
            printf ("%d ", newar[i][j]);
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6590593_6591093_1_52
6590593_6606908_1_48
Title: changing rows into column and column into rows of that 2d array 
----------------------------------------

int main () {
    int **data;
    int rows = 0, columns = 0;
    char in [256];
    int *irow;
    for (rows = 0; 1; ++rows) {
        scanf ("%255s", in);
        if (strcmp (in, "exit") == 0)
            break;
        for (int icolumn = 0; 1; ++icolumn) {
        }
        if (rows == 0)
            columns = icolumn;
        if (columns != icolumns) {
            printf ("OMG! The user is a hacker!\n");
            break;
        }
        data[rows] = irow;
    }
    for (int i = 0; i < columns; ++i) {
        for (int j = 0; j < rows; ++j) {
            printf ("%d\t", data [j] [i]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

void main () {
    clrscr ();
    int in [10] [10];
    int out [10] [10];
    int row, column, i, j;
    printf ("enter row");
    scanf ("%d", & row);
    printf ("Enter column");
    scanf ("%d", & column);
    for (i = 1; i <= row; i++) {
        for (j = 1; j <= column; j++) {
            printf ("Enter (%d,%d)th value", i, j);
            scanf ("%d", & in [i - 1] [j - 1]);
        }
    }
    printf ("\ninput is\n\n");
    for (i = 0; i < row; i++) {
        for (j = 0; j < column; j++) {
            printf ("%d\t", in [i] [j]);
        }
        printf ("\n");
    }
    printf ("\nOutput is\n\n");
    for (i = 0; i < column; i++) {
        for (j = 0; j < row; j++) {
            printf ("%d\t", in [j] [i]);
            out[i][j] = in[j][i];
        }
        printf ("\n");
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6590593_6592851_12_32
6590593_6606908_1_48
Title: changing rows into column and column into rows of that 2d array 
----------------------------------------

int main (void) {
    int oldar [2] [3] = {{1, 2, 3}, {4, 5, 6}};
    int newar [3] [2];
    transpose (& oldar [0] [0], & newar [0] [0], 2, 3);
    int i, j;
    for (i = 0; i < 2; i++) {
        for (j = 0; j < 3; j++)
            printf ("%d ", oldar[i][j]);
        printf ("\n");
    }
    for (i = 0; i < 3; i++) {
        for (j = 0; j < 2; j++)
            printf ("%d ", newar[i][j]);
        printf ("\n");
    }
}
----------------------------------------

void main () {
    clrscr ();
    int in [10] [10];
    int out [10] [10];
    int row, column, i, j;
    printf ("enter row");
    scanf ("%d", & row);
    printf ("Enter column");
    scanf ("%d", & column);
    for (i = 1; i <= row; i++) {
        for (j = 1; j <= column; j++) {
            printf ("Enter (%d,%d)th value", i, j);
            scanf ("%d", & in [i - 1] [j - 1]);
        }
    }
    printf ("\ninput is\n\n");
    for (i = 0; i < row; i++) {
        for (j = 0; j < column; j++) {
            printf ("%d\t", in [i] [j]);
        }
        printf ("\n");
    }
    printf ("\nOutput is\n\n");
    for (i = 0; i < column; i++) {
        for (j = 0; j < row; j++) {
            printf ("%d\t", in [j] [i]);
            out[i][j] = in[j][i];
        }
        printf ("\n");
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
663064_663099_15_23
663064_663109_7_32
Title: copying strings into a buffer 
----------------------------------------

int main (int argc, char **argv) {
    char *a [] = {"rat", "dog", "lion"};
    char *o [sizeof a / sizeof *a];
    p_init ((const char * *) a, sizeof a / sizeof * a, o);
    for (size_t i = 0; i < sizeof a / sizeof *a; ++i)
        printf ("%s\n", o[i]);
    for (size_t i = 0; i < sizeof a / sizeof *a; ++i)
        free (o[i]);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    const char *animals [] = {"rabbit", "horse", "donkey", "pig", 0};
    printf ("sizeof(*animals) = %zd\n", sizeof (* animals));
    printf ("number of elements in animals = %zd\n", sizeof (animals) / sizeof (* animals));
    char *output [sizeof (animals) / sizeof (*animals)];
    for (const char **p = animals; *p; ++p)
        printf ("Animal: %s\n", *p);
    p_init (animals, output);
    for (char **p = output; *p; ++p)
        printf ("Animal: %s\n", *p);
    for (char **p = output; *p; ++p)
        free (*p);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
663064_663099_1_13
663064_663102_1_11
Title: copying strings into a buffer 
----------------------------------------

void p_init (const char **animals, const size_t nanimals, char **output) {
    const char **w = animals;
    size_t len = 0;
    while (w < animals + nanimals) {
        len = strlen (*w);
        *output = malloc (len + sizeof "new animal " + 1);
        sprintf (* output, "new animal %s", * w);
        output++;
        w++;
    }
}
----------------------------------------

void p_init (const char **animals, char **output) {
    while (*animals) {
        size_t stringSize = 42;
        *output = (char *) malloc (stringSize);
        sprintf (* output, "new animal %s", * animals);
        output++;
        animals++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
663064_663099_1_13
663064_663109_34_48
Title: copying strings into a buffer 
----------------------------------------

void p_init (const char **animals, const size_t nanimals, char **output) {
    const char **w = animals;
    size_t len = 0;
    while (w < animals + nanimals) {
        len = strlen (*w);
        *output = malloc (len + sizeof "new animal " + 1);
        sprintf (* output, "new animal %s", * w);
        output++;
        w++;
    }
}
----------------------------------------

void p_init (const char **animals, char **output) {
    while (*animals) {
        size_t len = strlen (*animals);
        char *buf = malloc (len +13);
        snprintf (buf, len + 13, "new animal %s", * animals);
        *output = buf;
        ++animals;
        ++output;
    }
    *output = 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
663064_663102_1_11
663064_663109_34_48
Title: copying strings into a buffer 
----------------------------------------

void p_init (const char **animals, char **output) {
    while (*animals) {
        size_t stringSize = 42;
        *output = (char *) malloc (stringSize);
        sprintf (* output, "new animal %s", * animals);
        output++;
        animals++;
    }
}
----------------------------------------

void p_init (const char **animals, char **output) {
    while (*animals) {
        size_t len = strlen (*animals);
        char *buf = malloc (len +13);
        snprintf (buf, len + 13, "new animal %s", * animals);
        *output = buf;
        ++animals;
        ++output;
    }
    *output = 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6728147_6728219_8_24
6728147_6728225_8_26
Title: FILE IO Trouble 
----------------------------------------

main () {
    FILE *fptr;
    fptr = fopen ("b.db", "r");
    int i;
    int counter = 2;
    for (i = 0; i < counter; i++) {
        char temp1 [LEN];
        char temp2 [RECORDS];
        fscanf (fptr, "%[^\n]%*c%[^\n]%*c", temp1, temp2);
        printf ("%s ---- %s\n", temp1, temp2);
    }
    fclose (fptr);
}
----------------------------------------

main () {
    FILE *fptr;
    fptr = fopen ("db.dat", "r");
    int i;
    int counter = 3;
    for (i = 0; i < counter; i++) {
        char temp1 [LEN];
        char temp2 [LEN + 10];
        fgets (temp1, LEN, fptr);
        fgets (temp2, LEN, fptr);
        printf ("%s%s", temp1, temp2);
    }
    fclose (fptr);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6762766_12878352_47_70
6762766_6792388_9_82
Title: MAC address with getifaddrs 
----------------------------------------

extern int main (int argc, char *argv []) {
    char macaddrstr [18], *ifname;
    if (argc == 2) {
        ifname = argv[1];
        if (!strcmp (ifname, "-l")) {
            return listmacaddrs ();
        }
        else {
            if (macaddr (ifname, macaddrstr)) {
                printf ("%s: %s\n", ifname, macaddrstr);
                return 0;
            }
            else {
                printf ("%s: not found\n", ifname);
                return 1;
            }
        }
    }
    else {
        printf ("list all interfaces: %s -l\n", argv [0]);
        printf ("single interface: %s interface_name\n", argv [0]);
        return 2;
    }
}
----------------------------------------

int main (void) {
    char buf [8192] = {0};
    struct ifconf ifc = {0};
    struct ifreq *ifr = NULL;
    int sck = 0;
    int nInterfaces = 0;
    int i = 0;
    char ip [INET6_ADDRSTRLEN] = {0};
    char macp [19];
    struct ifreq *item;
    struct sockaddr *addr;
    sck = socket (PF_INET, SOCK_DGRAM, 0);
    if (sck < 0) {
        perror ("socket");
        return 1;
    }
    ifc.ifc_len = sizeof (buf);
    ifc.ifc_buf = buf;
    if (ioctl (sck, SIOCGIFCONF, &ifc) < 0) {
        perror ("ioctl(SIOCGIFCONF)");
        return 1;
    }
    ifr = ifc.ifc_req;
    nInterfaces = ifc.ifc_len / sizeof (struct ifreq);
    for (i = 0; i < nInterfaces; i++) {
        item = &ifr[i];
        addr = &(item->ifr_addr);
        if (ioctl (sck, SIOCGIFADDR, item) < 0) {
            perror ("ioctl(OSIOCGIFADDR)");
        }
        if (inet_ntop (AF_INET, &(((struct sockaddr_in *) addr)->sin_addr), ip, sizeof ip) == NULL) {
            perror ("inet_ntop");
            continue;
        }
        if (ioctl (sck, SIOCGIFHWADDR, item) < 0) {
            perror ("ioctl(SIOCGIFHWADDR)");
            return 1;
        }
        sprintf (macp, " %02x:%02x:%02x:%02x:%02x:%02x", (unsigned char) item -> ifr_hwaddr.sa_data [0], (unsigned char) item -> ifr_hwaddr.sa_data [1], (unsigned char) item -> ifr_hwaddr.sa_data [2], (unsigned char) item -> ifr_hwaddr.sa_data [3], (unsigned char) item -> ifr_hwaddr.sa_data [4], (unsigned char) item -> ifr_hwaddr.sa_data [5]);
        printf ("%s %s ", ip, macp);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6762766_51218583_79_102
6762766_6792388_9_82
Title: MAC address with getifaddrs 
----------------------------------------

extern int main (int argc, char *argv []) {
    char macaddrstr [18], *ifname;
    if (argc == 2) {
        ifname = argv[1];
        if (!strcmp (ifname, "-l")) {
            return listmacaddrs ();
        }
        else {
            if (macaddr (ifname, macaddrstr)) {
                printf ("%s: %s\n", ifname, macaddrstr);
                return 0;
            }
            else {
                printf ("%s: not found\n", ifname);
                return 1;
            }
        }
    }
    else {
        printf ("list all interfaces: %s -l\n", argv [0]);
        printf ("single interface: %s interface_name\n", argv [0]);
        return 2;
    }
}
----------------------------------------

int main (void) {
    char buf [8192] = {0};
    struct ifconf ifc = {0};
    struct ifreq *ifr = NULL;
    int sck = 0;
    int nInterfaces = 0;
    int i = 0;
    char ip [INET6_ADDRSTRLEN] = {0};
    char macp [19];
    struct ifreq *item;
    struct sockaddr *addr;
    sck = socket (PF_INET, SOCK_DGRAM, 0);
    if (sck < 0) {
        perror ("socket");
        return 1;
    }
    ifc.ifc_len = sizeof (buf);
    ifc.ifc_buf = buf;
    if (ioctl (sck, SIOCGIFCONF, &ifc) < 0) {
        perror ("ioctl(SIOCGIFCONF)");
        return 1;
    }
    ifr = ifc.ifc_req;
    nInterfaces = ifc.ifc_len / sizeof (struct ifreq);
    for (i = 0; i < nInterfaces; i++) {
        item = &ifr[i];
        addr = &(item->ifr_addr);
        if (ioctl (sck, SIOCGIFADDR, item) < 0) {
            perror ("ioctl(OSIOCGIFADDR)");
        }
        if (inet_ntop (AF_INET, &(((struct sockaddr_in *) addr)->sin_addr), ip, sizeof ip) == NULL) {
            perror ("inet_ntop");
            continue;
        }
        if (ioctl (sck, SIOCGIFHWADDR, item) < 0) {
            perror ("ioctl(SIOCGIFHWADDR)");
            return 1;
        }
        sprintf (macp, " %02x:%02x:%02x:%02x:%02x:%02x", (unsigned char) item -> ifr_hwaddr.sa_data [0], (unsigned char) item -> ifr_hwaddr.sa_data [1], (unsigned char) item -> ifr_hwaddr.sa_data [2], (unsigned char) item -> ifr_hwaddr.sa_data [3], (unsigned char) item -> ifr_hwaddr.sa_data [4], (unsigned char) item -> ifr_hwaddr.sa_data [5]);
        printf ("%s %s ", ip, macp);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6804101_6804399_9_17
6804101_6804914_9_46
Title: Fast method to copy memory with translation - ARGB to BGR 
----------------------------------------

void convert (uint8_t *orig, size_t imagesize, uint8_t *dest) {
    assert ((uintptr_t) orig % 16 == 0);
    assert (imagesize % 4 == 0);
    __m128i mask = _mm_set_epi8 (-128, -128, -128, -128, 13, 14, 15, 9, 10, 11, 5, 6, 7, 1, 2, 3);
    uint8_t *end = orig + imagesize * 4;
    for (; orig != end; orig += 16, dest += 12) {
        _mm_storeu_si128 ((__m128i *) dest, _mm_shuffle_epi8 (_mm_load_si128 ((__m128i *) orig), mask));
    }
}
----------------------------------------

void convert (uint8_t *orig, size_t imagesize, uint8_t *dest) {
    assert ((uintptr_t) orig % 16 == 0);
    assert (imagesize % 16 == 0);
    __m128i shuf0 = _mm_set_epi8 (-128, -128, -128, -128, 13, 14, 15, 9, 10, 11, 5, 6, 7, 1, 2, 3);
    __m128i shuf1 = _mm_set_epi8 (7, 1, 2, 3, -128, -128, -128, -128, 13, 14, 15, 9, 10, 11, 5, 6);
    __m128i shuf2 = _mm_set_epi8 (10, 11, 5, 6, 7, 1, 2, 3, -128, -128, -128, -128, 13, 14, 15, 9);
    __m128i shuf3 = _mm_set_epi8 (13, 14, 15, 9, 10, 11, 5, 6, 7, 1, 2, 3, -128, -128, -128, -128);
    __m128i mask0 = _mm_set_epi32 (0, -1, -1, -1);
    __m128i mask1 = _mm_set_epi32 (0, 0, -1, -1);
    __m128i mask2 = _mm_set_epi32 (0, 0, 0, -1);
    uint8_t *end = orig + imagesize * 4;
    for (; orig != end; orig += 64, dest += 48) {
        __m128i a = _mm_shuffle_epi8 (_mm_load_si128 ((__m128i *) orig), shuf0);
        __m128i b = _mm_shuffle_epi8 (_mm_load_si128 ((__m128i *) orig + 1), shuf1);
        __m128i c = _mm_shuffle_epi8 (_mm_load_si128 ((__m128i *) orig + 2), shuf2);
        __m128i d = _mm_shuffle_epi8 (_mm_load_si128 ((__m128i *) orig + 3), shuf3);
        _mm_stream_si128
        ((__m128i *) dest, _mm_or_si128 (_mm_and_si128 (a, mask0), _mm_andnot_si128 (b, mask0));
        _mm_stream_si128
        ((__m128i *) dest + 1, _mm_or_si128 (_mm_and_si128 (b, mask1), _mm_andnot_si128 (c, mask1));
        _mm_stream_si128
        ((__m128i *) dest + 2, _mm_or_si128 (_mm_and_si128 (c, mask2), _mm_andnot_si128 (d, mask2));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6819361_43815063_8_66
6819361_6819567_4_43
Title: Simple MPI question - receive from any process IF there is a message waiting to be picked up 
----------------------------------------

int main (int argc, char **argv) {
    int myrank, size;
    MPI_Init (& argc, & argv);
    MPI_Comm_rank (MPI_COMM_WORLD, & myrank);
    MPI_Comm_size (MPI_COMM_WORLD, & size);
    vector < int > destination;
    if (myrank == 0) {
        destination.push_back (1);
    }
    else if (myrank == 1) {
        destination.push_back (0);
    }
    for (uint i = 0; i < destination.size (); i++) {
    }
    MPI_Status status;
    MPI_Request request;
    int rcvbuff;
    int sendbuff = myrank + 10;
    for (uint i = 0; i < destination.size (); i++) {
        MPI_Isend (& sendbuff, 1, MPI_INT, destination.at (i), 0, MPI_COMM_WORLD, & request);
    }
    int count;
    int flag = 0;
    while (flag == 0) {
        MPI_Iprobe (MPI_ANY_SOURCE, MPI_ANY_TAG, MPI_COMM_WORLD, & flag, & status);
        cout << "Process " << myrank << ", flag " << flag << endl;
    }
    if (flag) {
        MPI_Get_count (& status, MPI_INT, & count);
        MPI_Irecv (& rcvbuff, count, MPI_INT, destination.at (0), 0, MPI_COMM_WORLD, & request);
    }
    MPI_Wait (& request, & status);
    cout << "The message received by " << myrank << " is '" << rcvbuff << "'" << endl;
    MPI_Finalize ();
}
----------------------------------------

int main (int argc, char *argv []) {
    int rank;
    int sendMsg = 123;
    int recvMsg = 0;
    int flag = 0;
    int count;
    MPI_Status status;
    MPI_Request request;
    int errs = 0;
    MPI_Init (0, 0);
    MPI_Comm_rank (MPI_COMM_WORLD, & rank);
    if (rank == 0) {
        MPI_Isend (& sendMsg, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, & request);
        while (!flag) {
            MPI_Iprobe (0, 0, MPI_COMM_WORLD, & flag, & status);
        }
        MPI_Get_count (& status, MPI_INT, & count);
        if (count != 1) {
            errs++;
        }
        MPI_Recv (& recvMsg, 1, MPI_INT, 0, 0, MPI_COMM_WORLD, & status);
        if (recvMsg != 123) {
            errs++;
        }
        MPI_Wait (& request, & status);
    }
    MPI_Finalize ();
    return errs;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6853548_6853750_43_210
6853548_6884889_1_56
Title: Optimisation for a brainfuck interpreter 
----------------------------------------

int main (int argc, char **argv) {
    unsigned instruction_count = 0;
    long ci = 0, cn = 4096, cw = BF_END_WRAP, ia = 4096, ii = 0, in = 0, la = 4096, ln = 0, va = 0, vb = 255, vw = BF_END_WRAP;
    instruction *im = malloc (sizeof (instruction) * ia);
    long *cm = NULL;
    long *ls = malloc (sizeof (long) * la);
    FILE *fp = NULL;
    int i;
    while ((i = getopt (argc, argv, "a:b:c:f:hv:w:")) != -1) {
        switch (i) {
        case 'a' :
            va = atol (optarg);
            break;
        case 'b' :
            vb = atol (optarg);
            break;
        case 'c' :
            cn = atol (optarg);
            break;
        case 'f' :
            fp = fopen (optarg, "r");
            if (!fp)
                die ("%s: %s", optarg, strerror (errno));
            break;
        case 'h' :
            fputs ("brief: a flexible brainfuck interpreter\n" "usage: brief [options]\n\n" "options:\n" "   -a  set minimum cell value (default 0)\n" "   -b  set maximum cell value (default 255)\n" "   -c  set cells to allocate (default 4096)\n" "   -f  source file name (required)\n" "   -h  this help output\n" "   -v  value over/underflow behaviour\n" "   -w  cell pointer over/underflow behaviour\n\n", stderr);
            fputs ("cells are 'long int' values, so do not use -a with a " "value less than -2^31 or -2^63, and do not use -b with a " "value more than 2^31-1 or 2^63-1, depending on your " "architecture's 'long int' size.\n\n" "over/underflow behaviours can be one of:\n" "   e   throw an error and quit upon over/underflow\n" "   i   do nothing when attempting to over/underflow\n" "   w   wrap-around to other end upon over/underflow\n", stderr);
            exit (1);
            break;
        case 'v' :
            vw = optarg[0];
            break;
        case 'w' :
            cw = optarg[0];
            break;
        default :
            break;
        }
    }
    if (!fp)
        die ("no source file specified; use -f");
    for (ii = 0; (i = getc (fp)) != EOF; ++ii) {
        if (++in > ia) {
            ia *= 2;
            im = realloc (im, sizeof (*im) * ia);
        }
        switch (i) {
        case BF_OP_LSTART :
            if (ln >= la)
                ls = realloc (ls, sizeof (*ls) * (la *= 2));
            ls[ln++] = ii;
            im[in - 1].instruction = C_OP_LSTART;
            break;
        case BF_OP_LEND :
            im[in - 1].loop = ls[--ln];
            im[ls[ln]].loop = ii;
            im[in - 1].instruction = C_OP_LEND;
            break;
        case BF_OP_VINC :
            im[in - 1].instruction = C_OP_VINC;
            break;
        case BF_OP_VDEC :
            im[in - 1].instruction = C_OP_VDEC;
            break;
        case BF_OP_PINC :
            im[in - 1].instruction = C_OP_PINC;
            break;
        case BF_OP_PDEC :
            im[in - 1].instruction = C_OP_PDEC;
            break;
        case BF_OP_IN :
            im[in - 1].instruction = C_OP_IN;
            break;
        case BF_OP_OUT :
            im[in - 1].instruction = C_OP_OUT;
            break;
        }
    }
    cm = memset (malloc (cn * sizeof (long)), 0, cn * sizeof (long));
    for (ii = 0; ii < in; ii++) {
        ++instruction_count;
        switch (im[ii].instruction) {
        case C_OP_VINC :
            if (cm[ci] == vb)
                switch (vw) {
                case BF_END_ERROR :
                    die ("value overflow");
                    break;
                case BF_END_IGNORE :
                    break;
                case BF_END_WRAP :
                    cm[ci] = 0;
                    break;
                }
            else
                ++cm[ci];
            break;
        case C_OP_VDEC :
            if (cm[ci] == 0)
                switch (vw) {
                case BF_END_ERROR :
                    die ("value underflow");
                    break;
                case BF_END_IGNORE :
                    break;
                case BF_END_WRAP :
                    cm[ci] = vb;
                    break;
                }
            else
                --cm[ci];
            break;
        case C_OP_PINC :
            if (ci == cn - 1)
                switch (cw) {
                case BF_END_ERROR :
                    die ("cell index overflow");
                    break;
                case BF_END_IGNORE :
                    break;
                case BF_END_WRAP :
                    ci = 0;
                    break;
                }
            else
                ++ci;
            break;
        case C_OP_PDEC :
            if (ci == 0)
                switch (cw) {
                case BF_END_ERROR :
                    die ("cell index underflow");
                    break;
                case BF_END_IGNORE :
                    break;
                case BF_END_WRAP :
                    ci = cn - 1;
                    break;
                }
            else
                --ci;
            break;
        case C_OP_IN :
            cm[ci] = getchar ();
            break;
        case C_OP_OUT :
            putchar (cm[ci]);
            break;
        case C_OP_LSTART :
            if (!cm[ci])
                ii = im[ii].loop;
            break;
        case C_OP_LEND :
            if (cm[ci])
                ii = im[ii].loop;
            break;
        default :
            break;
        }
    }
    fprintf (stderr, "Executed %d instructions\n", instruction_count);
    free (cm);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    if (!(argc > 1))
        return 1;
    unsigned char *progmem = argv[1];
    unsigned char *cellmem = malloc (sizeof (char) * CELLSPACE);
    if (cellmem == NULL)
        return 1;
    unsigned char **loopdepth = malloc (sizeof (char *) * MAXLOOPDEPTH);
    if (loopdepth == NULL)
        return 1;
    unsigned char *origcellmem = cellmem;
    unsigned char **origloopdepth = loopdepth;
    for (;;) {
        switch (*progmem) {
        case '+' :
            ++*cellmem;
            break;
        case '-' :
            --*cellmem;
            break;
        case '>' :
            cellmem++;
            break;
        case '<' :
            cellmem--;
            break;
        case '[' :
            *loopdepth = progmem - 1;
            loopdepth++;
            break;
        case ']' :
            loopdepth--;
            if (*cellmem) {
                progmem = *loopdepth;
            }
            break;
        case '.' :
            putc (*cellmem, stdout);
            break;
        case ',' :
            *cellmem = getc (stdin);
            break;
        case '\0' :
            free (origcellmem);
            free (origloopdepth);
            return 0;
        }
        progmem++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6853548_6853750_43_210
6853548_6907119_17_82
Title: Optimisation for a brainfuck interpreter 
----------------------------------------

int main (int argc, char **argv) {
    unsigned instruction_count = 0;
    long ci = 0, cn = 4096, cw = BF_END_WRAP, ia = 4096, ii = 0, in = 0, la = 4096, ln = 0, va = 0, vb = 255, vw = BF_END_WRAP;
    instruction *im = malloc (sizeof (instruction) * ia);
    long *cm = NULL;
    long *ls = malloc (sizeof (long) * la);
    FILE *fp = NULL;
    int i;
    while ((i = getopt (argc, argv, "a:b:c:f:hv:w:")) != -1) {
        switch (i) {
        case 'a' :
            va = atol (optarg);
            break;
        case 'b' :
            vb = atol (optarg);
            break;
        case 'c' :
            cn = atol (optarg);
            break;
        case 'f' :
            fp = fopen (optarg, "r");
            if (!fp)
                die ("%s: %s", optarg, strerror (errno));
            break;
        case 'h' :
            fputs ("brief: a flexible brainfuck interpreter\n" "usage: brief [options]\n\n" "options:\n" "   -a  set minimum cell value (default 0)\n" "   -b  set maximum cell value (default 255)\n" "   -c  set cells to allocate (default 4096)\n" "   -f  source file name (required)\n" "   -h  this help output\n" "   -v  value over/underflow behaviour\n" "   -w  cell pointer over/underflow behaviour\n\n", stderr);
            fputs ("cells are 'long int' values, so do not use -a with a " "value less than -2^31 or -2^63, and do not use -b with a " "value more than 2^31-1 or 2^63-1, depending on your " "architecture's 'long int' size.\n\n" "over/underflow behaviours can be one of:\n" "   e   throw an error and quit upon over/underflow\n" "   i   do nothing when attempting to over/underflow\n" "   w   wrap-around to other end upon over/underflow\n", stderr);
            exit (1);
            break;
        case 'v' :
            vw = optarg[0];
            break;
        case 'w' :
            cw = optarg[0];
            break;
        default :
            break;
        }
    }
    if (!fp)
        die ("no source file specified; use -f");
    for (ii = 0; (i = getc (fp)) != EOF; ++ii) {
        if (++in > ia) {
            ia *= 2;
            im = realloc (im, sizeof (*im) * ia);
        }
        switch (i) {
        case BF_OP_LSTART :
            if (ln >= la)
                ls = realloc (ls, sizeof (*ls) * (la *= 2));
            ls[ln++] = ii;
            im[in - 1].instruction = C_OP_LSTART;
            break;
        case BF_OP_LEND :
            im[in - 1].loop = ls[--ln];
            im[ls[ln]].loop = ii;
            im[in - 1].instruction = C_OP_LEND;
            break;
        case BF_OP_VINC :
            im[in - 1].instruction = C_OP_VINC;
            break;
        case BF_OP_VDEC :
            im[in - 1].instruction = C_OP_VDEC;
            break;
        case BF_OP_PINC :
            im[in - 1].instruction = C_OP_PINC;
            break;
        case BF_OP_PDEC :
            im[in - 1].instruction = C_OP_PDEC;
            break;
        case BF_OP_IN :
            im[in - 1].instruction = C_OP_IN;
            break;
        case BF_OP_OUT :
            im[in - 1].instruction = C_OP_OUT;
            break;
        }
    }
    cm = memset (malloc (cn * sizeof (long)), 0, cn * sizeof (long));
    for (ii = 0; ii < in; ii++) {
        ++instruction_count;
        switch (im[ii].instruction) {
        case C_OP_VINC :
            if (cm[ci] == vb)
                switch (vw) {
                case BF_END_ERROR :
                    die ("value overflow");
                    break;
                case BF_END_IGNORE :
                    break;
                case BF_END_WRAP :
                    cm[ci] = 0;
                    break;
                }
            else
                ++cm[ci];
            break;
        case C_OP_VDEC :
            if (cm[ci] == 0)
                switch (vw) {
                case BF_END_ERROR :
                    die ("value underflow");
                    break;
                case BF_END_IGNORE :
                    break;
                case BF_END_WRAP :
                    cm[ci] = vb;
                    break;
                }
            else
                --cm[ci];
            break;
        case C_OP_PINC :
            if (ci == cn - 1)
                switch (cw) {
                case BF_END_ERROR :
                    die ("cell index overflow");
                    break;
                case BF_END_IGNORE :
                    break;
                case BF_END_WRAP :
                    ci = 0;
                    break;
                }
            else
                ++ci;
            break;
        case C_OP_PDEC :
            if (ci == 0)
                switch (cw) {
                case BF_END_ERROR :
                    die ("cell index underflow");
                    break;
                case BF_END_IGNORE :
                    break;
                case BF_END_WRAP :
                    ci = cn - 1;
                    break;
                }
            else
                --ci;
            break;
        case C_OP_IN :
            cm[ci] = getchar ();
            break;
        case C_OP_OUT :
            putchar (cm[ci]);
            break;
        case C_OP_LSTART :
            if (!cm[ci])
                ii = im[ii].loop;
            break;
        case C_OP_LEND :
            if (cm[ci])
                ii = im[ii].loop;
            break;
        default :
            break;
        }
    }
    fprintf (stderr, "Executed %d instructions\n", instruction_count);
    free (cm);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    if (!(argc > 1))
        return 1;
    unsigned char *code = argv[1];
    int nesting = 0;
    printf ("int main(){\n");
    printf ("  #define CELLSPACE 1000\n");
    printf ("  unsigned char *ptr = malloc(sizeof(char)*CELLSPACE);\n");
    printf ("  if(ptr == NULL) return 1;\n")
    printf ("  for(int i=0;i<CELLSPACED;i++) ptr[i]=0; // reset cell space to zeros");
    increments = 0;
    steps = 0;
    for (;;) {
        switch (*code++) {
        case '+' :
            flush_steps ();
            ++increments;
            break;
        case '-' :
            flush_steps ();
            --increments;
            break;
        case '>' :
            flush_increments ();
            ++steps;
            break;
        case '<' :
            flush_increments ();
            --steps;
            break;
        case '[' :
            flush_increments ();
            flush_steps ();
            printf ("while(*ptr){");
            ++nesting;
            break;
        case ']' :
            flush_increments ();
            flush_steps ();
            if (--nesting < 0) {
                printf ("Unmatched ']'\n");
                return 1;
            }
            printf ("}\n";);
            break;
        case '.' :
            flush_increments ();
            flush_steps ();
            printf (" putc(*ptr, stdout);\n");
            break;
        case ',' :
            increments = 0;
            flush_steps ();
            printf ("*ptr = getc(stdin);");
            break;
        case '\0' :
            printf ("}");
            if (nesting > 0) {
                printf ("Unmatched '['\n");
                return 1;
            }
            return 0;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6853548_6884889_1_56
6853548_6907119_17_82
Title: Optimisation for a brainfuck interpreter 
----------------------------------------

int main (int argc, char **argv) {
    if (!(argc > 1))
        return 1;
    unsigned char *progmem = argv[1];
    unsigned char *cellmem = malloc (sizeof (char) * CELLSPACE);
    if (cellmem == NULL)
        return 1;
    unsigned char **loopdepth = malloc (sizeof (char *) * MAXLOOPDEPTH);
    if (loopdepth == NULL)
        return 1;
    unsigned char *origcellmem = cellmem;
    unsigned char **origloopdepth = loopdepth;
    for (;;) {
        switch (*progmem) {
        case '+' :
            ++*cellmem;
            break;
        case '-' :
            --*cellmem;
            break;
        case '>' :
            cellmem++;
            break;
        case '<' :
            cellmem--;
            break;
        case '[' :
            *loopdepth = progmem - 1;
            loopdepth++;
            break;
        case ']' :
            loopdepth--;
            if (*cellmem) {
                progmem = *loopdepth;
            }
            break;
        case '.' :
            putc (*cellmem, stdout);
            break;
        case ',' :
            *cellmem = getc (stdin);
            break;
        case '\0' :
            free (origcellmem);
            free (origloopdepth);
            return 0;
        }
        progmem++;
    }
}
----------------------------------------

int main (int argc, char **argv) {
    if (!(argc > 1))
        return 1;
    unsigned char *code = argv[1];
    int nesting = 0;
    printf ("int main(){\n");
    printf ("  #define CELLSPACE 1000\n");
    printf ("  unsigned char *ptr = malloc(sizeof(char)*CELLSPACE);\n");
    printf ("  if(ptr == NULL) return 1;\n")
    printf ("  for(int i=0;i<CELLSPACED;i++) ptr[i]=0; // reset cell space to zeros");
    increments = 0;
    steps = 0;
    for (;;) {
        switch (*code++) {
        case '+' :
            flush_steps ();
            ++increments;
            break;
        case '-' :
            flush_steps ();
            --increments;
            break;
        case '>' :
            flush_increments ();
            ++steps;
            break;
        case '<' :
            flush_increments ();
            --steps;
            break;
        case '[' :
            flush_increments ();
            flush_steps ();
            printf ("while(*ptr){");
            ++nesting;
            break;
        case ']' :
            flush_increments ();
            flush_steps ();
            if (--nesting < 0) {
                printf ("Unmatched ']'\n");
                return 1;
            }
            printf ("}\n";);
            break;
        case '.' :
            flush_increments ();
            flush_steps ();
            printf (" putc(*ptr, stdout);\n");
            break;
        case ',' :
            increments = 0;
            flush_steps ();
            printf ("*ptr = getc(stdin);");
            break;
        case '\0' :
            printf ("}");
            if (nesting > 0) {
                printf ("Unmatched '['\n");
                return 1;
            }
            return 0;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6867700_6867764_5_18
6867700_6867773_4_28
Title: how to efficiently parse a string in c 
----------------------------------------

int main (int argc, char **argv) {
    char *str = strdup ("abc def  abcdef ghi   xyz");
    char *a = strtok (str, " ");
    char *b = strtok (NULL, " ");
    char *c = strtok (NULL, " ");
    char *d = strtok (NULL, " ");
    char *e = strtok (NULL, " ");
    printf ("a=%s|b=%s|c=%s|d=%s|e=%s\n", a, b, c, d, e);
    free (str);
    return 0;
}
----------------------------------------

int main (void) {
    const char *str = "abc def  abcdef ghi   xyz";
    char *dup = strdup (str);
    char **output = malloc (5 * sizeof (char *));
    char *p = dup;
    char *nextp = NULL;
    int i = 0;
    if (dup == NULL) {
    }
    for (i = 0; i < 5; ++i) {
        output[i] = strtok_r (p, " ", &nextp);
        p = NULL;
    }
    for (i = 0; i < 5; ++i) {
        printf ("output[%d] = %s\n", i, output [i]);
    }
    free (dup);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6867700_6867764_5_18
6867700_6869704_6_28
Title: how to efficiently parse a string in c 
----------------------------------------

int main (int argc, char **argv) {
    char *str = strdup ("abc def  abcdef ghi   xyz");
    char *a = strtok (str, " ");
    char *b = strtok (NULL, " ");
    char *c = strtok (NULL, " ");
    char *d = strtok (NULL, " ");
    char *e = strtok (NULL, " ");
    printf ("a=%s|b=%s|c=%s|d=%s|e=%s\n", a, b, c, d, e);
    free (str);
    return 0;
}
----------------------------------------

int main () {
    char *str = "abc def  abcdef ghi   xyz";
    char *a, *b, *c, *d, *e;
    sscanf (str, " %a[^ ] %a[^ ] %a[^ ] %a[^ ] %a[^ ]", & a, & b, & c, & d, & e);
    enum {NVAR = 5};
    char **list;
    char *fmtx = " %a[^ ]";
    char *fmt;
    int i;
    list = malloc (NVAR * sizeof *list);
    for (i = 0; i < NVAR; i++)
        list[i] = malloc (sizeof **list);
    fmt = malloc (NVAR *strlen (fmtx) + 1);
    fmt[0] = '\0';
    for (i = 0; i < NVAR; i++)
        strcat (fmt, fmtx);
    sscanf (str, fmt, list, list + 1, list + 2, list + 3, list + 4, list + 5);
    for (i = 0; i < NVAR; i++)
        if (list[i])
            puts (list[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6867700_6867773_4_28
6867700_6869704_6_28
Title: how to efficiently parse a string in c 
----------------------------------------

int main (void) {
    const char *str = "abc def  abcdef ghi   xyz";
    char *dup = strdup (str);
    char **output = malloc (5 * sizeof (char *));
    char *p = dup;
    char *nextp = NULL;
    int i = 0;
    if (dup == NULL) {
    }
    for (i = 0; i < 5; ++i) {
        output[i] = strtok_r (p, " ", &nextp);
        p = NULL;
    }
    for (i = 0; i < 5; ++i) {
        printf ("output[%d] = %s\n", i, output [i]);
    }
    free (dup);
    return 0;
}
----------------------------------------

int main () {
    char *str = "abc def  abcdef ghi   xyz";
    char *a, *b, *c, *d, *e;
    sscanf (str, " %a[^ ] %a[^ ] %a[^ ] %a[^ ] %a[^ ]", & a, & b, & c, & d, & e);
    enum {NVAR = 5};
    char **list;
    char *fmtx = " %a[^ ]";
    char *fmt;
    int i;
    list = malloc (NVAR * sizeof *list);
    for (i = 0; i < NVAR; i++)
        list[i] = malloc (sizeof **list);
    fmt = malloc (NVAR *strlen (fmtx) + 1);
    fmt[0] = '\0';
    for (i = 0; i < NVAR; i++)
        strcat (fmt, fmtx);
    sscanf (str, fmt, list, list + 1, list + 2, list + 3, list + 4, list + 5);
    for (i = 0; i < NVAR; i++)
        if (list[i])
            puts (list[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6911688_50996119_4_17
6911688_6911893_1_16
Title: Making a deep copy of a struct...making a shallow copy of a struct 
----------------------------------------

void copy_Student (Student *target, Student *source) {
    if (target != NULL)
        free_Student (target);
    assert (source != NULL);
    target->grade = source->grade;
    target->id = source->id;
    target->last_name = (malloc ((strlen (source->last_name) + 1) * sizeof (char)));
    target->first_name = (malloc ((strlen (source->first_name) + 1) * sizeof (char)));
    strncpy (target -> first_name, source -> first_name, strlen (source -> first_name) + 1);
    strncpy (target -> last_name, source -> last_name, strlen (source -> last_name) + 1);
}
----------------------------------------

void copy_Student (Student *s1, Student *s2) {
    assert ((s1 != NULL) && (s2 != NULL));
    if (s2->first_name != NULL)
        free (s2->first_name);
    if (s2->last_name != NULL)
        free (s2->last_name);
    s2->grade = s1->grade;
    s2->id = s1->id;
    s2->last_name = (malloc ((strlen (s1->last_name) + 1) * sizeof (char)));
    s2->first_name = (malloc ((strlen (s1->first_name) + 1) * sizeof (char)));
    strncpy (s2 -> first_name, s1 -> first_name, strlen (s1 -> first_name) + 1);
    strncpy (s2 -> last_name, s1 -> last_name, strlen (s1 -> last_name) + 1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6932401_6932541_1_18
6932401_6939480_1_46
Title: Elegant error checking 
----------------------------------------

int foo () {
    if (Function1 () == ERROR_CODE)
        goto error;
    ...struct bar * x = acquire_structure;
    ...if (Function2 () == ERROR_CODE) goto error0;
    ...release_structure (x);
    return 0;
error0 :
    release_structure (x);
error :
    return -1;
}
----------------------------------------

int foo () {
    int rv = 0;
    struct bar *x = NULL;
    struct bar *y = NULL;
    rv = Function1 ();
    if (rv != OK) {
        goto error;
    }
    x = acquire_structure ();
    if (x == NULL) {
        rv = ERROR_MEMORY;
        goto error;
    }
    rv = Function2 ();
    if (rv != OK) {
        goto error;
    }
    y = acquire_structure ();
    if (y == NULL) {
        rv = ERROR_MEMORY;
        goto error;
    }
    rv = release_structure (x);
    x = NULL;
    if (rv != OK) {
        goto error;
    }
    rv = release_structure (y);
    y = NULL;
    if (rv != OK) {
        goto error;
    }
    return OK;
error :
    if (x != NULL) {
        release_structure (x);
    }
    return rv;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6951913_39044538_1_72
6951913_6952033_4_50
Title: Algorithm to take a number and output its English word 
----------------------------------------

void print (int num) {
    char digit [21] [10] = {"", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"};
    char tens [11] [10] = {"", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
    char str [1000] = {0};
    int prev = 0, div = 1000;
    strcpy (str, "");
    while (div) {
        if ((num / div) % 10 > 0 || (div == 10 && (num % 100) > 0)) {
            if (prev) {
                strcat (str, " and");
                prev = 0;
            }
            switch (div) {
            case 1000 :
                if (strlen (str) > 0 && str[strlen (str) - 1] != ' ')
                    strcat (str, " ");
                strcat (str, digit [(num / div) % 10]);
                if (((num / div) % 10) > 1)
                    strcat (str, " thousands");
                else
                    strcat (str, " thousand");
                prev = 1;
                break;
            case 100 :
                if (strlen (str) > 0 && str[strlen (str) - 1] != ' ')
                    strcat (str, " ");
                strcat (str, digit [(num / div) % 10]);
                if (((num / div) % 10) > 1)
                    strcat (str, " hundreds");
                else
                    strcat (str, " hundred");
                prev = 1;
                break;
            case 10 :
                if ((num % 100) >= 10 && (num % 100) <= 19) {
                    if (strlen (str) > 0 && str[strlen (str) - 1] != ' ')
                        strcat (str, " ");
                    strcat (str, digit [num % 100]);
                }
                else {
                    if (strlen (str) > 0 && str[strlen (str) - 1] != ' ')
                        strcat (str, " ");
                    strcat (str, tens [(num % 100) / 10]);
                    if (strlen (str) > 0 && str[strlen (str) - 1] != ' ')
                        strcat (str, " ");
                    strcat (str, digit [num % 10]);
                }
                break;
            }
        }
        div /= 10;
    }
    printf ("%d %s\n", num, str);
}
----------------------------------------

void print (int num) {
    char digit [21] [10] = {"", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"};
    char tens [11] [10] = {"", "", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
    char str [1000] = {0};
    int prev = 0, div = 1000;
    strcpy (str, "");
    while (div) {
        if ((num / div) % 10 > 0 || (div == 10 && (num % 100) > 0)) {
            if (prev) {
                strcat (str, "and");
                prev = 0;
            }
            switch (div) {
            case 1000 :
                strcat (str, digit[(num / div) % 10]);
                strcat (str, "thousand");
                prev = 1;
                break;
            case 100 :
                strcat (str, digit[(num / div) % 10]);
                strcat (str, "hundred");
                prev = 1;
                break;
            case 10 :
                if ((num % 100) >= 10 && (num % 100) <= 19)
                    strcat (str, digit[num % 100]);
                else {
                    strcat (str, tens [(num % 100) / 10]);
                    strcat (str, digit [num % 10]);
                }
                break;
            }
        }
        div /= 10;
    }
    printf ("%d %s\n", num, str);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6951913_39541598_33_187
6951913_6951989_1_88
Title: Algorithm to take a number and output its English word 
----------------------------------------

void main (int argc, char *argv []) {
    const int HUNDREDS = 0, THOUSANDS = 1, MILLIONS = 2, BILLIONS = 3;
    int i, count, total, remainder [12] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
    long number = 0, orignum = 0;
    char *ones [] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
    char *teens [] = {"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"};
    char *tens [] = {"ten", "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
    char *places [] = {"hundred", "thousand", "million", "billion"};
    if (argc < 2) {
        printf ("\na number is required as input!\n\n");
        exit (1);
    }
    else if (argc > 3) {
        printf ("\nonly one number and optionally a flag are required as input!\n\n");
        exit (1);
    }
    else
        printf ("\n");
    if (!(number = atol (argv[1]))) {
        printf ("number: %d\n%s\n\n", number, ones [0]);
        exit (0);
    }
    if (argv[2] && (atoi (argv[2]) & 0x01)) {
        for (i = 11; i > -1; i--)
            printf ("%d %d, ", i, remainder[i]);
        printf ("\n\n");
    }
    if (number < 0) {
        orignum = number;
        number *= -1;
    }
    count = 0;
    do {
        remainder[count++] = number % 10;
        number /= 10;
    }
    while (number);
    if (count > 12) {
        printf ("\ntoo many digits; up to 12 digits supported!\n\n");
        exit (1);
    }
    if (argv[2] && (atoi (argv[2]) & 0x02)) {
        for (i = 11; i > -1; i--)
            printf ("%d %d, ", i, remainder[i]);
        printf ("\n\n");
    }
    printf ("number: ");
    if (orignum < 0)
        printf ("-");
    for (i = count - 1; i > -1; i--) {
        if (!(i % 3) && i)
            printf ("%d,", remainder[i]);
        else
            printf ("%d", remainder[i]);
    }
    printf ("\n");
    total = count;
    i = count - 1;
    if (orignum < 0)
        printf ("negative ");
    while (count) {
        if (argv[2] && (atoi (argv[2]) & 0x04))
            printf ("\nC: %d, i: %d and R: %d\n", count, i, remainder[i]);
        switch (count) {
        case 1 :
            if (remainder[i + 1] != 1 && remainder[i])
                printf ("%s ", ones[remainder[i]]);
            break;
        case 2 :
            if (remainder[i] == 1)
                printf ("%s ", teens[remainder[i - 1]]);
            else if (remainder[i])
                printf ("%s ", tens[remainder[i]]);
            break;
        case 3 :
            if (remainder[i]) {
                printf ("%s ", ones [remainder [i]]);
                printf ("%s ", places [count - 3]);
            }
            break;
        case 4 :
            if (remainder[i])
                printf ("%s ", ones[remainder[i]]);
            if (remainder[i] || (total > 4 && total < 7))
                printf ("%s ", places[count - 3]);
            break;
        case 5 :
        case 8 :
        case 11 :
            if (remainder[i]) {
                printf ("%s ", tens [remainder [i]]);
            }
            break;
        case 6 :
        case 9 :
        case 12 :
            if (remainder[i]) {
                printf ("%s ", ones [remainder [i]]);
                printf ("%s ", places [HUNDREDS]);
            }
            break;
        case 7 :
            if (remainder[i])
                printf ("%s ", ones[remainder[i]]);
            if (remainder[i] || (total > 7 && total < 10))
                printf ("%s ", places[MILLIONS]);
            break;
        case 10 :
            if (remainder[i])
                printf ("%s ", ones[remainder[i]]);
            if (remainder[i] || (total > 10 && total < 13))
                printf ("%s ", places[BILLIONS]);
            break;
        default :
            break;
        }
        count--;
        i--;
    }
    printf ("\n\n");
}
----------------------------------------

void main () {
    int n, m, j;
    clrscr ();
    printf ("Enter any number between 1 to 99 : ");
    scanf ("%d", & n);
    printf ("You entered ");
    if (n > 0 && n <= 10)
        goto one;
    else if (n > 10 && n < 20) {
        m = n % 10;
        goto two;
    }
    else if (n > 20 && n < 100) {
        j = n / 10;
        n = n % 10;
        goto three;
    }
two :
    switch (m) {
    case 1 :
        printf ("eleven ");
        break;
    case 2 :
        printf ("twelve ");
        break;
    case 3 :
        printf ("thirteen ");
        break;
    case 4 :
        printf ("fourteen ");
        break;
    case 5 :
        printf ("fifteen ");
        break;
    case 6 :
        printf ("sixteen ");
        break;
    case 7 :
        printf ("seventeen ");
        break;
    case 8 :
        printf ("eighteen ");
        break;
    case 9 :
        printf ("nineteen ");
        break;
    }
three :
    switch (j) {
    case 2 :
        printf ("twenty ");
        goto one;
    case 3 :
        printf ("thirty ");
        goto one;
    case 4 :
        printf ("fourty ");
        goto one;
    case 5 :
        printf ("fifty ");
        goto one;
    case 6 :
        printf ("sixty ");
        goto one;
    case 7 :
        printf ("seventy ");
        goto one;
    case 8 :
        printf ("eighty ");
        goto one;
    case 9 :
        printf ("ninety ");
        goto one;
    }
one :
    switch (n) {
    case 1 :
        printf ("one ");
        break;
    case 2 :
        printf ("two ");
        break;
    case 3 :
        printf ("three ");
        break;
    case 4 :
        printf ("four ");
        break;
    case 5 :
        printf ("five ");
        break;
    case 6 :
        printf ("six ");
        break;
    case 7 :
        printf ("seven ");
        break;
    case 8 :
        printf ("eight ");
        break;
    case 9 :
        printf ("nine ");
        break;
    case 10 :
        printf ("ten ");
        break;
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6951913_39541598_33_187
6951913_6952033_51_64
Title: Algorithm to take a number and output its English word 
----------------------------------------

void main (int argc, char *argv []) {
    const int HUNDREDS = 0, THOUSANDS = 1, MILLIONS = 2, BILLIONS = 3;
    int i, count, total, remainder [12] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
    long number = 0, orignum = 0;
    char *ones [] = {"zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine"};
    char *teens [] = {"ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen"};
    char *tens [] = {"ten", "ten", "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety"};
    char *places [] = {"hundred", "thousand", "million", "billion"};
    if (argc < 2) {
        printf ("\na number is required as input!\n\n");
        exit (1);
    }
    else if (argc > 3) {
        printf ("\nonly one number and optionally a flag are required as input!\n\n");
        exit (1);
    }
    else
        printf ("\n");
    if (!(number = atol (argv[1]))) {
        printf ("number: %d\n%s\n\n", number, ones [0]);
        exit (0);
    }
    if (argv[2] && (atoi (argv[2]) & 0x01)) {
        for (i = 11; i > -1; i--)
            printf ("%d %d, ", i, remainder[i]);
        printf ("\n\n");
    }
    if (number < 0) {
        orignum = number;
        number *= -1;
    }
    count = 0;
    do {
        remainder[count++] = number % 10;
        number /= 10;
    }
    while (number);
    if (count > 12) {
        printf ("\ntoo many digits; up to 12 digits supported!\n\n");
        exit (1);
    }
    if (argv[2] && (atoi (argv[2]) & 0x02)) {
        for (i = 11; i > -1; i--)
            printf ("%d %d, ", i, remainder[i]);
        printf ("\n\n");
    }
    printf ("number: ");
    if (orignum < 0)
        printf ("-");
    for (i = count - 1; i > -1; i--) {
        if (!(i % 3) && i)
            printf ("%d,", remainder[i]);
        else
            printf ("%d", remainder[i]);
    }
    printf ("\n");
    total = count;
    i = count - 1;
    if (orignum < 0)
        printf ("negative ");
    while (count) {
        if (argv[2] && (atoi (argv[2]) & 0x04))
            printf ("\nC: %d, i: %d and R: %d\n", count, i, remainder[i]);
        switch (count) {
        case 1 :
            if (remainder[i + 1] != 1 && remainder[i])
                printf ("%s ", ones[remainder[i]]);
            break;
        case 2 :
            if (remainder[i] == 1)
                printf ("%s ", teens[remainder[i - 1]]);
            else if (remainder[i])
                printf ("%s ", tens[remainder[i]]);
            break;
        case 3 :
            if (remainder[i]) {
                printf ("%s ", ones [remainder [i]]);
                printf ("%s ", places [count - 3]);
            }
            break;
        case 4 :
            if (remainder[i])
                printf ("%s ", ones[remainder[i]]);
            if (remainder[i] || (total > 4 && total < 7))
                printf ("%s ", places[count - 3]);
            break;
        case 5 :
        case 8 :
        case 11 :
            if (remainder[i]) {
                printf ("%s ", tens [remainder [i]]);
            }
            break;
        case 6 :
        case 9 :
        case 12 :
            if (remainder[i]) {
                printf ("%s ", ones [remainder [i]]);
                printf ("%s ", places [HUNDREDS]);
            }
            break;
        case 7 :
            if (remainder[i])
                printf ("%s ", ones[remainder[i]]);
            if (remainder[i] || (total > 7 && total < 10))
                printf ("%s ", places[MILLIONS]);
            break;
        case 10 :
            if (remainder[i])
                printf ("%s ", ones[remainder[i]]);
            if (remainder[i] || (total > 10 && total < 13))
                printf ("%s ", places[BILLIONS]);
            break;
        default :
            break;
        }
        count--;
        i--;
    }
    printf ("\n\n");
}
----------------------------------------

int main (int argc, char **argv) {
    long sum = 0;
    int count = 0;
    if (argc <= 1) {
        fprintf (stderr, "wrong number of arguments\n");
        return -1;
    }
    print (atoi (argv [1]));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6951913_6951989_1_88
6951913_6952033_51_64
Title: Algorithm to take a number and output its English word 
----------------------------------------

void main () {
    int n, m, j;
    clrscr ();
    printf ("Enter any number between 1 to 99 : ");
    scanf ("%d", & n);
    printf ("You entered ");
    if (n > 0 && n <= 10)
        goto one;
    else if (n > 10 && n < 20) {
        m = n % 10;
        goto two;
    }
    else if (n > 20 && n < 100) {
        j = n / 10;
        n = n % 10;
        goto three;
    }
two :
    switch (m) {
    case 1 :
        printf ("eleven ");
        break;
    case 2 :
        printf ("twelve ");
        break;
    case 3 :
        printf ("thirteen ");
        break;
    case 4 :
        printf ("fourteen ");
        break;
    case 5 :
        printf ("fifteen ");
        break;
    case 6 :
        printf ("sixteen ");
        break;
    case 7 :
        printf ("seventeen ");
        break;
    case 8 :
        printf ("eighteen ");
        break;
    case 9 :
        printf ("nineteen ");
        break;
    }
three :
    switch (j) {
    case 2 :
        printf ("twenty ");
        goto one;
    case 3 :
        printf ("thirty ");
        goto one;
    case 4 :
        printf ("fourty ");
        goto one;
    case 5 :
        printf ("fifty ");
        goto one;
    case 6 :
        printf ("sixty ");
        goto one;
    case 7 :
        printf ("seventy ");
        goto one;
    case 8 :
        printf ("eighty ");
        goto one;
    case 9 :
        printf ("ninety ");
        goto one;
    }
one :
    switch (n) {
    case 1 :
        printf ("one ");
        break;
    case 2 :
        printf ("two ");
        break;
    case 3 :
        printf ("three ");
        break;
    case 4 :
        printf ("four ");
        break;
    case 5 :
        printf ("five ");
        break;
    case 6 :
        printf ("six ");
        break;
    case 7 :
        printf ("seven ");
        break;
    case 8 :
        printf ("eight ");
        break;
    case 9 :
        printf ("nine ");
        break;
    case 10 :
        printf ("ten ");
        break;
    }
    getch ();
}
----------------------------------------

int main (int argc, char **argv) {
    long sum = 0;
    int count = 0;
    if (argc <= 1) {
        fprintf (stderr, "wrong number of arguments\n");
        return -1;
    }
    print (atoi (argv [1]));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6958222_6958282_2_15
6958222_6958344_2_12
Title: Why do I get a segmentation fault when I try to modify a string constant? 
----------------------------------------

int main () {
    char buffer [11];
    char *p, *p1;
    strcpy (buffer, "haifriends");
    p = &buffer[0];
    p1 = p;
    while (*p != '\0')
        ++*p++;
    printf ("%s   %s", p, p1);
    return 0;
}
----------------------------------------

int main () {
    char p [11] = "haifriends";
    char *p1;
    p1 = p;
    while (*p1 != '\0')
        ++*p1++;
    printf ("%s   %s", p, p1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
700655_700673_1_18
700655_700915_1_22
Title: Flow controlling macros with 'goto' 
----------------------------------------

void func () {
    char *p1 = malloc (16);
    if (!p1)
        goto cleanup;
    char *p2 = malloc (16);
    if (!p2)
        goto cleanup;
cleanup :
    if (p1)
        free (p1);
    if (p2)
        free (p2);
}
----------------------------------------

void func (void) {
    void *p1 = NULL;
    void *p2 = NULL;
    void *p3 = NULL;
    p1 = malloc (16);
    if (!p1)
        goto cleanup;
    p2 = malloc (16);
    if (!p2)
        goto cleanup;
    p3 = malloc (16);
    if (!p3)
        goto cleanup;
cleanup :
    if (p1)
        free (p1);
    if (p2)
        free (p2);
    if (p3)
        free (p3);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7052369_7052403_1_15
7052369_7052475_8_23
Title: Whats wrong with this linkedlist implementation? 
----------------------------------------

void add (struct node **list, int i) {
    if (*list == NULL)
        *list = tempNode;
    else {
        struct node *p = *list;
        while (p->link)
            p = p->link;
        p->link = tempNode;
    }
}
----------------------------------------

void add (struct node **list, int i) {
    node *tempNode = (node *) malloc (sizeof (node));
    tempNode->data = i;
    tempNode->link = NULL;
    if (*list == NULL)
        *list = tempNode;
    else {
        while ((*list)->link != NULL)
            list = &(*list)->link;
        (*list)->link = tempNode;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7146620_7146668_5_19
7146620_7146673_1_10
Title: How to right use free for data 
----------------------------------------

int main () {
    struct str *buffer;
    buffer = malloca (sizeof (struct str));
    if (buffer == NULL) {
        return 1;
    }
    buffer->data = malloc (sizeof (uin8_t));
    if (buffer->data == NULL) {
        free (buffer);
        return 1;
    }
    free (buffer -> data);
    free (buffer);
    return 0;
}
----------------------------------------

int main () {
    struct str *buffer = (struct str *) malloc (sizeof (struct str));
    if (buffer == NULL) {
        fprintf (stderr, "Error with malloc\n");
        exit (EXIT_FAILURE);
    }
    buffer->data = (uint8_t *) malloc (sizeof uint8_t);
    if (buffer->data == NULL) {
        fprintf (stderr, "Error with malloc\n");
        exit (EXIT_FAILURE);
    }
    free (buffer -> data);
    free (buffer);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7147700_7147733_1_11
7147700_7150017_1_26
Title: Passing a single argument list to two v*printf() calls 
----------------------------------------

void test (const char *fstra, const char *fstrb, ... ) {
    char big_honkin_buff [1024];
    va_list ap;
    strcpy (big_honkin_buff, fstra);
    strcat (big_honkin_buff, fstrb);
    va_start (ap, big_honkin_buff);
    vprintf (big_honkin_buff, ap);
    va_end (ap);
}
----------------------------------------

void test (const char *fstra, const char *fstrb, ... ) {
    char *format, *buf;
    char *a, *b;
    int a_len, buf_len;
    va_list ap;
    va_start (ap, fstrb);
    a_len = vsnprintf (NULL, 0, fstra, ap);
    va_end (ap);
    asprintf (& format, "%s%s", fstra, fstrb);
    va_start (ap, fstrb);
    buf_len = vasprintf (&buf, format, ap);
    va_end (ap);
    free (format);
    a = malloc (a_len +1);
    memcpy (a, buf, a_len);
    a[a_len] = '\0';
    b = malloc (buf_len -a_len + 1);
    memcpy (b, buf + a_len, buf_len - a_len);
    b[buf_len - a_len] = '\0';
    free (buf);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7176737_7288255_9_83
7176737_7825608_13_104
Title: C/C++ program for checking MySQL connectivity and InnoDB plug-ins 
----------------------------------------

int main () {
    MYSQL *connection;
    MYSQL_RES *result;
    MYSQL_ROW row;
    char *server = "localhost";
    char *user = "root";
    char *password = "pass";
    char *database = "blog";
    connection = mysql_init (NULL);
    if (!mysql_real_connect (connection, server, user, password, database, 0, NULL, 0)) {
        fprintf (stderr, "%s\n", mysql_error (connection));
        exit (1);
    }
    if (mysql_query (connection, "show engines")) {
        fprintf (connection, "%s\n", mysql_error (connection));
        exit (1);
    }
    result = mysql_use_result (connection);
    printf ("\n --- Output ---- \n");
    while ((row = mysql_fetch_row (result)) != NULL) {
        if ((strcmp (row[0], "InnoDB") == 0) && strcmp (row[1], "YES") == 0)
            printf ("InnoDB engine is supported\n");
        break;
    }
    mysql_free_result (result);
    if (mysql_query (connection, "show global status")) {
        fprintf (connection, "%s\n", mysql_error (connection));
        exit (1);
    }
    result = mysql_use_result (connection);
    while ((row = mysql_fetch_row (result)) != NULL) {
        if (strcmp (row[0], "Handler_write") == 0)
            printf ("\nTotal Writes : %d\n", row[1]);
    }
    mysql_free_result (result);
    mysql_close (connection);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    MYSQL *connection;
    MYSQL_RES *result;
    MYSQL_ROW *row;
    char *server = "localhost";
    char *user = "root";
    char *password = "pass";
    char *database = "webyog";
    int numfields, Inno_flag = 0, CSV_flag = 0, c;
    char choice;
    do {
        system ("clear");
        printf ("----------------------\nPlug-in checker\n");
        printf ("----------------------\n");
        connection = mysql_init (NULL);
        if (!mysql_real_connect (connection, server, user, password, database, 0, NULL, 0)) {
            printf ("\nConnection error:");
            fprintf (stderr, "%s\n", mysql_error (connection));
        }
        if (mysql_query (connection, "show engines")) {
            printf ("\nQuery execution failed:");
            fprintf (stderr, "%s\n", mysql_error (connection));
        }
        result = mysql_use_result (connection);
        numfields = mysql_num_fields (result);
        printf ("What do you want to check?\nPress 1 for InnoDB\nPress 2 for CSV support\nYour choice: ");
        scanf ("%d", & c);
        while ((row = mysql_fetch_row (result)) != NULL) {
            if ((strcmp (row[0], "InnoDB") == 0) && strcmp (row[1], "YES") == 0)
                Inno_flag = 1;
            if ((strcmp (row[0], "CSV") == 0) && strcmp (row[1], "YES") == 0)
                CSV_flag = 1;
        }
        switch (c) {
        case 1 :
            if (!Inno_flag)
                printf ("InnoDB plug-in is not installed\n");
            else
                printf ("InnoDB plug-in is installed\n");
            mysql_free_result (result);
            if (mysql_query (connection, "show global status")) {
                printf ("\nQuery execution failed:");
                fprintf (connection, "%s\n", mysql_error (connection));
                exit (1);
            }
            result = mysql_use_result (connection);
            while ((row = mysql_fetch_row (result)) != NULL) {
                if (strcmp (row[0], "Handler_write") == 0)
                    printf ("Total number of Disk Writes by MySQL: %d\n", row[1]);
            }
            break;
        case 2 :
            if (!CSV_flag)
                printf ("CSV support is not there.\n");
            else
                printf ("CSV support is there.\n");
            break;
        default :
            printf ("\nInvalid choice\n");
        }
        mysql_free_result (result);
        mysql_close (connection);
        printf ("\nDo you want to continue?(Y/N):");
        scanf ("%s", & choice);
        if (choice != 'Y' || choice != 'y' || choice != 'n' || choice != 'N') {
            printf ("\nInvalid option. Program exits.\n");
            exit (0);
        }
        printf ("\n\n\n");
    }
    while (choice == 'Y' || choice == 'y');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7180293_41949246_4_24
7180293_52378472_4_20
Title: How to extract filename from path 
----------------------------------------

int main (int argc, char *argv []) {
    char *fn;
    char *input;
    if (argc > 1)
        input = argv[1];
    else
        input = argv[0];
    if (input[(strlen (input) - 1)] == '/')
        input[(strlen (input) - 1)] = '\0';
    (fn = strrchr (input, '/')) ? ++fn : (fn = input);
    printf ("%s\n", fn);
    return 0;
}
----------------------------------------

int main (void) {
    char path [] = "C:\\etc\\passwd.c";
    char temp [256];
    char *ch;
    ch = strtok (path, "\\");
    while (ch != NULL) {
        strcpy (temp, ch);
        printf ("%s\n", ch);
        ch = strtok (NULL, "\\");
    }
    printf ("last filename: %s", temp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7213062_7213538_15_56
7213062_7223560_1_18
Title: Bit counting in a contiguous memory chunk 
----------------------------------------

int countSetBits (void *ptr, int start, int end) {
    uint8_t *first;
    uint8_t *last;
    int bits_first;
    int bits_last;
    uint8_t mask_first;
    uint8_t mask_last;
    size_t count = 0;
    first = ((uint8_t *) ptr) + (start / 8);
    bits_first = 8 - start % 8;
    mask_first = (1 << bits_first) - 1;
    mask_first = mask_first << (8 - bits_first);
    last = ((uint8_t *) ptr) + (end / 8);
    bits_last = 1 + (end % 8);
    mask_last = (1 << bits_last) - 1;
    if (first == last) {
        count = bits_in_byte ((*first) & mask_first & mask_last);
    }
    else {
        count += bits_in_byte ((*first) & mask_first);
        count += bits_in_byte ((*last) & mask_last);
        for (first = first + 1; first != last; ++first) {
            count += bits_in_byte (*first);
        }
    }
    return count;
}
----------------------------------------

int countSetBits (void *ptr, int start, int end) {
    assert (start < end);
    unsigned char *s = ((unsigned char *) ptr + start);
    unsigned char *e = ((unsigned char *) ptr + end);
    int r = 0;
    while (s != e) {
        if (*s)
            r += 32 - __builtin_clz (*s);
        s++;
    }
    return r;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7215921_7215986_1_26
7215921_7216709_1_16
Title: possible buffer overflow vulnerability for va_list in C? 
----------------------------------------

int ircsocket_print (char *message, ... ) {
    char buf [512];
    char *buffer;
    int len;
    va_list va;
    buffer = buf;
    va_start (va, message);
    len = vsnprintf (buffer, 512, message, va);
    va_end (va);
    if (len >= 512) {
        buffer = (char *) malloc (len +1);
        va_start (va, message);
        len = vsnprintf (buffer, len +1, message, va);
        va_end (va);
    }
    send (ircsocket_connection, buffer, len, 0);
    if (buffer != buf)
        free (buffer);
    return 1;
}
----------------------------------------

void ircsocket_print (const char *fmt, ... ) {
    va_list args;
    va_start (args, fmt);
    int len = vsnprintf (0, 0, message, args);
    va_end (args);
    char buffer [len + 1];
    va_start (args, fmt);
    int len = vsnprintf (buffer, len +1, message, args);
    va_end (args);
    send (ircsocket_connection, buffer, len, 0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7228873_7229101_2_24
7228873_7235495_1_14
Title: How can I add a new argument to the existing variable argument list? 
----------------------------------------

void t_printf (char *str, ... ) {
    if (file_ptr != NULL) {
        va_list ap;
        va_start (ap, str);
        char msg [MAXLEN];
        vsnprintf (msg, MAXLEN, str, ap);
        fprintf (file_ptr, "thread % 6d: %s", pthread_self (), msg);
        va_end (ap);
        fflush (file_ptr);
    }
}
----------------------------------------

void t_printf (char *str, ... ) {
    if (file_ptr != NULL) {
        va_list ap;
        va_start (ap, str);
        vfprintf (file_ptr, str, ap);
        va_end (ap);
        fflush (file_ptr);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7228873_7229548_1_17
7228873_7235495_1_14
Title: How can I add a new argument to the existing variable argument list? 
----------------------------------------

void t_printf (char *str, ... ) {
    if (file_ptr != NULL) {
        char fmt [MAXLEN];
        va_list ap;
        va_start (ap, str);
        snprintf (fmt, MAXLEN, "thread id: %d: %s", pthread_self (), str);
        vfprintf (file_ptr, fmt, ap);
        va_end (ap);
        fflush (file_ptr);
    }
}
----------------------------------------

void t_printf (char *str, ... ) {
    if (file_ptr != NULL) {
        va_list ap;
        va_start (ap, str);
        vfprintf (file_ptr, str, ap);
        va_end (ap);
        fflush (file_ptr);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7298509_7298530_1_22
7298509_7299351_4_13
Title: c - comparing strings 
----------------------------------------

void blank (char *s, const char *toBlank) {
    int i = 0, j;
    while (s[i] != '\0') {
        j = 0;
        while (toBlank[j] != '\0') {
            if (s[i] == toBlank[j]) {
                s[i] = ' ';
                break;
            }
            else {
                ++j;
            }
        }
        ++i;
    }
    printf ("%s", s);
}
----------------------------------------

void blank (char *str, char *wits) {
    size_t pos, len;
    for (pos = len = 0; str[pos]; pos += len) {
        len = strspn (str +pos, wits);
        if (len)
            memset (str +pos, ' ', len);
        else
            len = strcspn (str +pos, wits);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7303372_7303428_21_43
7303372_7303764_27_56
Title: How to use mutexes in C 
----------------------------------------

int main (int argc, const char *argv []) {
    pthread_t thread;
    char *message = "Thread 1";
    int r;
    sem_init (& sem1, 0, 0);
    sem_init (& sem2, 0, 0);
    r = pthread_create (&thread, NULL, f, (void *) message);
    sem_post (& sem1);
    sem_wait (& sem2);
    printf ("Parent 2\n");
    sem_post (& sem1);
    pthread_join (thread1, NULL);
    printf ("Thread 1 returns: %d\n", r);
    return 0;
}
----------------------------------------

int main () {
    pthread_t thread1;
    char *message1 = "Thread 1";
    int r;
    pthread_barrier_init (& barrier, NULL, 2);
    r = pthread_create (&thread1, NULL, print_message_function, (void *) message1);
    printf ("Parent 1\n");
    pthread_barrier_wait (& barrier);
    pthread_barrier_wait (& barrier);
    printf ("Parent 2\n");
    pthread_barrier_wait (& barrier);
    pthread_join (thread1, NULL);
    printf ("Thread 1 returns: %d\n", r);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7361961_7362007_3_17
7361961_7362054_3_21
Title: Learning C: what's wrong in my pointer code? 
----------------------------------------

void main () {
    int k = 10;
    char string;
    char *sptr;
    sptr = "hello!";
    int *ptr;
    ptr = &k;
    printf ("%s \n", sptr);
    printf ("Sending pointer.\n");
    sendptr (ptr, sptr);
}
----------------------------------------

int main (void) {
    int k = 10;
    char *string;
    char *sptr;
    int *ptr;
    string = "hello!";
    sptr = string;
    ptr = &k;
    printf ("%s \n", sptr);
    printf ("Sending pointer.\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7378574_7378593_1_10
7378574_7378598_1_13
Title: Problem(s) with Linked List 
----------------------------------------

struct Node *returnLastNode (struct LinkedList *ll) {
    struct Node *n = ll->first;
    struct Node *result = n;
    while (n != NULL) {
        result = n;
        n = n->next;
    }
    return result;
}
----------------------------------------

struct Node *returnLastNode (struct LinkedList *ll) {
    struct Node *n = ll->first;
    while (n) {
        if (n->next == NULL)
            return n;
        n = n->next;
    }
    return NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
739589_739641_9_33
739589_739782_4_37
Title: File Handling question on C programming 
----------------------------------------

int main () {
    char line [MAXLINE + 1];
    int n = fscanf (stdin, "%" xstr (MAXLINE) "[^\n]%*[^\n]", line);
    if (!feof (stdin)) {
        getchar ();
    }
    while (n == 1) {
        printf ("[line:] %s\n", line);
        n = fscanf (stdin, "%" xstr (MAXLINE) "[^\n]%*[^\n]", line);
        if (!feof (stdin)) {
            getchar ();
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    FILE *fp;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    fp = fopen ("/etc/motd", "r");
    if (fp == NULL) {
        printf ("File open failed\n");
        return 0;
    }
    while ((read = getline (&line, &len, fp)) != -1) {
        printf ("Line: %s", line);
        const char *delim = " \n";
        char *ptr;
        ptr = (char *) strtok (line, delim);
        while (ptr != NULL) {
            printf ("Word: %s\n", ptr);
            ptr = (char *) strtok (NULL, delim);
        }
    }
    if (line) {
        free (line);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7407810_7407853_15_30
7407810_7407880_15_28
Title: "How to use a union in a struct and typedef each struct with different union type?" 
----------------------------------------

int main () {
    typedef struct node item;
    item one;
    one.data.int_member = 10;
    item two;
    two.data.float_member = 10.f;
    printf ("%d", one.data.int_member);
    printf ("%f", two.data.float_member);
    return 0;
}
----------------------------------------

int main (void) {
    item myItem;
    myItem.data.i = 12;
    myItem.data.f = 12.0;
    printf ("location of myItem.data is %p\n", & myItem.data);
    printf ("location of myItem.data.f is %p\n", & myItem.data.f);
    printf ("myItem.data is %f\n", * (float *) (& myItem.data));
    printf ("myItem.data.f is %f\n", myItem.data.f);
    printf ("sizeof(myItem.data) is %lu\n", sizeof (* (float *) (& myItem.data)));
    printf ("sizeof(myItem.data.f) is %lu\n", sizeof (myItem.data.f));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
744766_23535815_10_21
744766_29829592_26_41
Title: How to compare ends of strings in C? 
----------------------------------------

int main (int argc, char *argv []) {
    char *a = "file1.gz";
    char *b = "1.gz";
    char *c = NULL;
    char *d = "1.gzabc";
    printf ("%s %s = %d\n", a, b, strbcmp (a, b));
    printf ("%s %s = %d\n", a, c, strbcmp (a, c));
    printf ("%s %s = %d\n", d, b, strbcmp (d, b));
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *a = "file1.gz";
    char *b = "1.gz";
    char *c = NULL;
    char *d = "1.gzabc";
    char *e = "1.gzabc1.gz";
    printf ("endsWith:\n");
    printf ("%s %s = %d\n", a, b, endsWith (a, b));
    printf ("%s NULL = %d\n", a, endsWith (a, c));
    printf ("%s %s = %d\n", d, b, endsWith (d, b));
    printf ("%s %s = %d\n", e, b, endsWith (e, b));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
744766_23535815_10_21
744766_31292388_18_62
Title: How to compare ends of strings in C? 
----------------------------------------

int main (int argc, char *argv []) {
    char *a = "file1.gz";
    char *b = "1.gz";
    char *c = NULL;
    char *d = "1.gzabc";
    printf ("%s %s = %d\n", a, b, strbcmp (a, b));
    printf ("%s %s = %d\n", a, c, strbcmp (a, c));
    printf ("%s %s = %d\n", d, b, strbcmp (d, b));
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    assert (string_has_suffix ("", ""));
    assert (! string_has_suffix ("", "a"));
    assert (string_has_suffix ("a", ""));
    assert (string_has_suffix ("a", "a"));
    assert (! string_has_suffix ("a", "b"));
    assert (! string_has_suffix ("a", "ba"));
    assert (string_has_suffix ("abc", "abc"));
    assert (! string_has_suffix ("abc", "eeabc"));
    assert (! string_has_suffix ("abc", "xbc"));
    assert (! string_has_suffix ("abc", "axc"));
    assert (! string_has_suffix ("abcdef", "abcxef"));
    assert (! string_has_suffix ("abcdef", "abxxef"));
    assert (string_has_suffix ("b.a", ""));
    assert (string_has_suffix ("b.a", "a"));
    assert (string_has_suffix ("b.a", ".a"));
    assert (string_has_suffix ("b.a", "b.a"));
    assert (! string_has_suffix ("b.a", "x"));
    assert (string_has_suffix ("abc.foo.bar", ""));
    assert (string_has_suffix ("abc.foo.bar", "r"));
    assert (string_has_suffix ("abc.foo.bar", "ar"));
    assert (string_has_suffix ("abc.foo.bar", "bar"));
    assert (! string_has_suffix ("abc.foo.bar", "xar"));
    assert (string_has_suffix ("abc.foo.bar", ".bar"));
    assert (string_has_suffix ("abc.foo.bar", "foo.bar"));
    assert (! string_has_suffix ("abc.foo.bar", "xoo.bar"));
    assert (! string_has_suffix ("abc.foo.bar", "foo.ba"));
    assert (string_has_suffix ("abc.foo.bar", ".foo.bar"));
    assert (string_has_suffix ("abc.foo.bar", "c.foo.bar"));
    assert (string_has_suffix ("abc.foo.bar", "abc.foo.bar"));
    assert (! string_has_suffix ("abc.foo.bar", "xabc.foo.bar"));
    assert (! string_has_suffix ("abc.foo.bar", "ac.foo.bar"));
    assert (string_has_suffix ("abc.foo.foo", ".foo"));
    assert (string_has_suffix ("abc.foo.foo", ".foo.foo"));
    assert (string_has_suffix ("abcdefgh", ""));
    assert (! string_has_suffix ("abcdefgh", " "));
    assert (string_has_suffix ("abcdefgh", "h"));
    assert (string_has_suffix ("abcdefgh", "gh"));
    assert (string_has_suffix ("abcdefgh", "fgh"));
    assert (! string_has_suffix ("abcdefgh", "agh"));
    assert (string_has_suffix ("abcdefgh", "abcdefgh"));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
744766_25780734_1_13
744766_29829592_5_24
Title: How to compare ends of strings in C? 
----------------------------------------

bool endsWith (const char *filename, const char *ext) {
    const uint len = strlen (filename);
    const uint extLen = strlen (ext);
    if (len < extLen) {
        return false;
    }
    for (uint index = 1; index <= extLen; index++) {
        if (filename[len - index] != ext[extLen - index]) {
            return false;
        }
    }
    return true;
}
----------------------------------------

bool endsWith (const char *haystack, const char *needle) {
    bool rv = false;
    if (haystack && needle) {
        size_t needle_size = strlen (needle);
        const char *act = haystack;
        while (NULL != (act = strstr (act, needle))) {
            if (*(act + needle_size) == '\0') {
                rv = true;
                break;
            }
            act += needle_size;
        }
    }
    return rv;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
744766_25780734_1_13
744766_744853_1_26
Title: How to compare ends of strings in C? 
----------------------------------------

bool endsWith (const char *filename, const char *ext) {
    const uint len = strlen (filename);
    const uint extLen = strlen (ext);
    if (len < extLen) {
        return false;
    }
    for (uint index = 1; index <= extLen; index++) {
        if (filename[len - index] != ext[extLen - index]) {
            return false;
        }
    }
    return true;
}
----------------------------------------

int endsWith (const char *text, const char *extn) {
    int result = 1;
    int len = strlen (text);
    int exprLen = strlen (extn);
    int index = len - exprLen;
    int count = 0;
    if (len > exprLen) {
        for (; count < exprLen; ++count) {
            if (text[index + count] != extn[count]) {
                result = 0;
                break;
            }
        }
    }
    else {
        result = 0;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
744766_29829592_26_41
744766_31292388_18_62
Title: How to compare ends of strings in C? 
----------------------------------------

int main (int argc, char *argv []) {
    char *a = "file1.gz";
    char *b = "1.gz";
    char *c = NULL;
    char *d = "1.gzabc";
    char *e = "1.gzabc1.gz";
    printf ("endsWith:\n");
    printf ("%s %s = %d\n", a, b, endsWith (a, b));
    printf ("%s NULL = %d\n", a, endsWith (a, c));
    printf ("%s %s = %d\n", d, b, endsWith (d, b));
    printf ("%s %s = %d\n", e, b, endsWith (e, b));
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    assert (string_has_suffix ("", ""));
    assert (! string_has_suffix ("", "a"));
    assert (string_has_suffix ("a", ""));
    assert (string_has_suffix ("a", "a"));
    assert (! string_has_suffix ("a", "b"));
    assert (! string_has_suffix ("a", "ba"));
    assert (string_has_suffix ("abc", "abc"));
    assert (! string_has_suffix ("abc", "eeabc"));
    assert (! string_has_suffix ("abc", "xbc"));
    assert (! string_has_suffix ("abc", "axc"));
    assert (! string_has_suffix ("abcdef", "abcxef"));
    assert (! string_has_suffix ("abcdef", "abxxef"));
    assert (string_has_suffix ("b.a", ""));
    assert (string_has_suffix ("b.a", "a"));
    assert (string_has_suffix ("b.a", ".a"));
    assert (string_has_suffix ("b.a", "b.a"));
    assert (! string_has_suffix ("b.a", "x"));
    assert (string_has_suffix ("abc.foo.bar", ""));
    assert (string_has_suffix ("abc.foo.bar", "r"));
    assert (string_has_suffix ("abc.foo.bar", "ar"));
    assert (string_has_suffix ("abc.foo.bar", "bar"));
    assert (! string_has_suffix ("abc.foo.bar", "xar"));
    assert (string_has_suffix ("abc.foo.bar", ".bar"));
    assert (string_has_suffix ("abc.foo.bar", "foo.bar"));
    assert (! string_has_suffix ("abc.foo.bar", "xoo.bar"));
    assert (! string_has_suffix ("abc.foo.bar", "foo.ba"));
    assert (string_has_suffix ("abc.foo.bar", ".foo.bar"));
    assert (string_has_suffix ("abc.foo.bar", "c.foo.bar"));
    assert (string_has_suffix ("abc.foo.bar", "abc.foo.bar"));
    assert (! string_has_suffix ("abc.foo.bar", "xabc.foo.bar"));
    assert (! string_has_suffix ("abc.foo.bar", "ac.foo.bar"));
    assert (string_has_suffix ("abc.foo.foo", ".foo"));
    assert (string_has_suffix ("abc.foo.foo", ".foo.foo"));
    assert (string_has_suffix ("abcdefgh", ""));
    assert (! string_has_suffix ("abcdefgh", " "));
    assert (string_has_suffix ("abcdefgh", "h"));
    assert (string_has_suffix ("abcdefgh", "gh"));
    assert (string_has_suffix ("abcdefgh", "fgh"));
    assert (! string_has_suffix ("abcdefgh", "agh"));
    assert (string_has_suffix ("abcdefgh", "abcdefgh"));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
744766_29829592_5_24
744766_744853_1_26
Title: How to compare ends of strings in C? 
----------------------------------------

bool endsWith (const char *haystack, const char *needle) {
    bool rv = false;
    if (haystack && needle) {
        size_t needle_size = strlen (needle);
        const char *act = haystack;
        while (NULL != (act = strstr (act, needle))) {
            if (*(act + needle_size) == '\0') {
                rv = true;
                break;
            }
            act += needle_size;
        }
    }
    return rv;
}
----------------------------------------

int endsWith (const char *text, const char *extn) {
    int result = 1;
    int len = strlen (text);
    int exprLen = strlen (extn);
    int index = len - exprLen;
    int count = 0;
    if (len > exprLen) {
        for (; count < exprLen; ++count) {
            if (text[index + count] != extn[count]) {
                result = 0;
                break;
            }
        }
    }
    else {
        result = 0;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
744766_744821_14_33
744766_745072_1_14
Title: How to compare ends of strings in C? 
----------------------------------------

int EndsWithFoo (const char *s) {
    int ret = 0;
    if (s != NULL) {
        size_t size = strlen (s);
        if (size >= 4 && s[size - 4] == '.' && s[size - 3] == 'f' && s[size - 2] == 'o' && s[size - 1] == 'o') {
            ret = 1;
        }
    }
    return ret;
}
----------------------------------------

int EndsWithFoo (char *str) {
    int iRetVal = 0;
    char *pchDot = strrchr (str, '.');
    if (pchDot) {
        if (strcmp (pchDot +1, "foo") == 0) {
            iRetVal = 1;
        }
    }
    return iRetVal;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7457163_43422006_6_72
7457163_7457284_52_96
Title: What is the implementation of `strtol`? 
----------------------------------------

long strtol (const char * restrict nptr, char ** restrict endptr, int base) {
    const char *p = nptr, *endp;
    _Bool is_neg = 0, overflow = 0;
    unsigned long n = 0UL, cutoff;
    int cutlim;
    if (base < 0 || base == 1 || base > 36) {
        return 0L;
    }
    endp = nptr;
    while (isspace (*p))
        p++;
    if (*p == '+') {
        p++;
    }
    else if (*p == '-') {
        is_neg = 1, p++;
    }
    if (*p == '0') {
        p++;
        endp = p;
        if (base == 16 && (*p == 'X' || *p == 'x')) {
            p++;
        }
        else if (base == 0) {
            if (*p == 'X' || *p == 'x') {
                base = 16, p++;
            }
            else {
                base = 8;
            }
        }
    }
    else if (base == 0) {
        base = 10;
    }
    cutoff = (is_neg) ? -(LONG_MIN / base) : LONG_MAX / base;
    cutlim = (is_neg) ? -(LONG_MIN % base) : LONG_MAX % base;
    while (1) {
        int c;
        if (*p >= 'A')
            digit = ((*p - 'A') & (~('a' ^ 'A'))) + 10;
        else if (*p <= '9')
            digit = *p - '0';
        else
            break;
        if (c < 0 || c >= base)
            break;
        endp = ++p;
        if (overflow) {
            if (endptr)
                continue;
            break;
        }
        if (n > cutoff || (n == cutoff && c > cutlim)) {
            overflow = 1;
            continue;
        }
        n = n * base + c;
    }
    if (endptr)
        *endptr = (char *) endp;
    if (overflow) {
        errno = ERANGE;
        return ((is_neg) ? LONG_MIN : LONG_MAX);
    }
    return (long) ((is_neg) ? -n : n);
}
----------------------------------------

long int strtol (char *string, char **endPtr, int base) {
    register char *p;
    int result;
    p = string;
    while (isspace (*p)) {
        p += 1;
    }
    if (*p == '-') {
        p += 1;
        result = -1 * (strtoul (p, endPtr, base));
    }
    else {
        if (*p == '+') {
            p += 1;
        }
        result = strtoul (p, endPtr, base);
    }
    if ((result == 0) && (endPtr != 0) && (*endPtr == p)) {
        *endPtr = string;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7469559_7470172_4_25
7469559_7470279_5_27
Title: Wrong Data Output When Generating Word List 
----------------------------------------

int main (void) {
    char str [] = "aaa";
    int len = strlen (str);
    int idx = 0;
    while (idx < len) {
        while (str[idx] <= 'c') {
            printf ("%s\n", str);
            str[idx]++;
        }
        str[idx] = 'a';
        while (++idx < len) {
            str[idx]++;
            if (str[idx] <= 'c') {
                idx = 0;
                break;
            }
            str[idx] = 'a';
        }
    }
    return 0;
}
----------------------------------------

int main () {
    char *str = "abc";
    int len = strlen (str);
    int combinations = len;
    int j = 1;
    while (j++ < len) {
        combinations = combinations * len;
    }
    int i;
    for (i = 0; i < combinations; i++) {
        char arr [len];
        int c = i;
        int j;
        for (j = len - 1; j >= 0; j--) {
            arr[j] = str[c % len];
            c /= len;
        }
        printf ("%s\n", arr);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7498624_7498681_1_22
7498624_7499663_4_15
Title: a better than naive implementation of strcspn() 
----------------------------------------

int contains_bad (const char *str, const char *bad) {
    static unsigned short int table [256];
    static unsigned short int marker = 255;
    char *ch;
    if (marker == 255) {
        memset (table, 0, 256);
        marker = 1;
    }
    else {
        marker++;
    }
    for (ch = bad; *ch != 0; ch++)
        table[*ch] = marker;
    for (ch = str; *ch != 0; ch++)
        if (table[*ch] == marker)
            return -1;
    return 1;
}
----------------------------------------

int contains_bad (const char *str, const char *bad) {
    size_t hint [UCHAR_MAX];
    size_t len_bad;
    for (len_bad = 0; bad[len_bad]; len_bad++) {
        hint[(unsigned char) bad[len_bad] - 1] = len_bad;
    }
    for (; *str; str++) {
        size_t i = hint[(unsigned char) *str - 1];
        if (i < len_bad && *str == bad[i])
            return 1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7595247_46178430_5_28
7595247_50069324_3_12
Title: array increment types in C - array[i]++ vs array[i++] 
----------------------------------------

int main () {
    int array [] = {5, 2, 9, 7, 15};
    int i = 0;
    array[i]++;
    printf ("%d %d\n", i, array [i]);
    array[i]++;
    printf ("%d %d\n", i, array [i]);
    array[i++];
    printf ("%d %d\n", i, array [i]);
    array[i++];
    printf ("%d %d\n", i, array [i]);
    return 0;
}
----------------------------------------

int main () {
    int arr [] = {1, 2, 37, 40, 5, 7};
    int i = 3;
    arr[i]++;
    cout << i << " " << arr[i] << endl;
    arr[i++];
    cout << i << " " << arr[i] << endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7602919_32032473_4_17
7602919_53499077_11_24
Title: How do I generate random numbers without rand() function? 
----------------------------------------

int main () {
    unsigned int x, r, i;
    scanf ("%d", & x);
    scanf ("%d", & r);
    unsigned int *a = (unsigned int *) malloc (sizeof (unsigned int) * x);
    for (i = 0; i < x; i++)
        printf ("%d ", (a[i] % r) + 1);
    free (a);
    getch ();
    return 0;
}
----------------------------------------

int main (void) {
    int r, x;
    for (;;) {
        r = nanorand ();
        do {
            printf ("please type %d (< 50 quits): ", r);
            fflush (stdout);
            if (scanf ("%d", &x) != 1)
                exit (EXIT_FAILURE);
        }
        while (x != r);
        if (r < 50)
            break;
    }
    puts ("");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7611790_20838930_1_17
7611790_7612199_4_36
Title: Counting substrings in C 
----------------------------------------

int main () {
    char *str = "This is demo";
    char *sub = "is";
    int i, j, count;
    i = j = count = 0;
    while (str[i] != '\0') {
        if (str[i] == sub[j] && str[i + 1] == sub[j + 1]) {
            count++;
        }
        i++;
    }
    cout << count;
    return 0;
}
----------------------------------------

int main (void) {
    char s1 [50], s2 [50];
    char *p;
    size_t count = 0;
    size_t len1;
    printf ("Gimme a string: ");
    fflush (stdout);
    fgets (s1, sizeof s1, stdin);
    p = strchr (s1, '\n');
    if (p)
        *p = 0;
    printf ("Gimme another string: ");
    fflush (stdout);
    fgets (s2, sizeof s2, stdin);
    p = strchr (s2, '\n');
    if (p)
        *p = 0;
    p = s2;
    len1 = strlen (s1);
    while ((p = strstr (p, s1)) != NULL && p != s1) {
        count++;
        p += len1;
    }
    printf ("Found %lu occurrences of %s in %s\n", count, s1, s2);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7630890_41519162_18_266
7630890_50236280_13_33
Title: program to store details of an employee in a structure 
----------------------------------------

void main () {
    FILE *outfile, *infile, *temp;
    struct employee input;
    int a, op, o, n;
    char pass [20], uname [30];
    char ch;
    int j, k, i;
    char pass1 [5] = "amit", un [5] = "amit", fnam [20], lnam [20];
    printf ("\n\n\t");
    for (i = 0; i < 11; i++) {
        printf ("*");
        usleep (50000);
    }
    usleep (500000);
    printf (" Welcome");
    usleep (500000);
    printf (" To ");
    usleep (500000);
    printf ("A");
    usleep (500000);
    printf ("X");
    usleep (500000);
    printf ("I");
    usleep (500000);
    printf ("O");
    usleep (500000);
    printf ("M");
    usleep (500000);
    printf (" SOFTECH");
    usleep (500000);
    printf (" PVT.");
    usleep (500000);
    printf (" LTD. ");
    usleep (50000);
    for (i = 0; i < 11; i++) {
        printf ("*");
        usleep (50000);
    }
login :
    printf ("\n\n\t\t\t ~~~~~~~~~~~~~~~~~~~~~");
    printf ("\n\t\t\t |  AUTHORIZE LOGIN  |");
    printf ("\n\t\t\t ~~~~~~~~~~~~~~~~~~~~~");
    printf ("\n\n\t\t*-----------------------------------------*");
    printf ("\n\t\t  User Name :- ");
    gets (uname);
    printf ("\n\t\t  Password(Provided By programmer) :- ");
    for (i = 0; i < 4; i++) {
        ch = getch ();
        pass[i] = ch;
        ch = '*';
        printf ("%c", ch);
    }
    printf ("\n\t\t*-----------------------------------------*");
    pass[i] = '\0';
    getch ();
    if ((strcmp (uname, un) == 0) && (strcmp (pass, pass1) == 0)) {
        printf ("\n\n\n\t\t    @-------- Login Successful --------@");
    menu :
        printf ("\n\n    \t+++++++++++++++++ AMIT BEHERE PVT. LTD. +++++++++++++++++");
        printf ("\n\n\t\t    #```````````````````````````#");
        printf ("\n\t\t    | AB Employee Management |");
        printf ("\n\t\t    #'''''''''''''''''''''''''''#");
        printf ("\n\t\t    *---------------------------*");
        printf ("\t\n\t\t    |\t1. Add Employee \t|\n\t\t    |\t2. Display Employee\t|\n\t\t    |\t3. Search Employee\t|\n\t\t    |\t4. Update Employee\t|\n\t\t    |\t5. Delete Employe\t|");
        printf ("\n\t\t    *---------------------------*");
        printf ("\n\t Enter Option :- ");
        scanf ("%d", & op);
        switch (op) {
        case 1 :
            outfile = fopen ("accounts.dat", "a+");
            if (outfile == NULL) {
                fprintf (stderr, "\n\tError opening accounts.dat\n\n");
            }
            printf ("\n\tEnter Count Of Employee To Add :- ");
            scanf ("%d", & n);
            for (i = 0; i < n; i++) {
                printf ("\n\t Enter First Name  :- ");
                scanf ("%s", input.fname);
                printf ("\n\t Enter Last Name   :- ");
                scanf ("%s", input.lname);
                printf ("\n\t Enter Employee Id :- ");
                scanf ("%d", & input.emp_id);
                printf ("\n\t Enter Salary      :- ");
                scanf ("%f", & input.emp_salary);
                fwrite (& input, sizeof (struct employee), 1, outfile);
            }
            fclose (outfile);
            break;
        case 2 :
            infile = fopen ("accounts.dat", "r");
            if (infile == NULL) {
                fprintf (stderr, "\nError opening accounts.dat\n\n");
            }
            rewind (infile);
            while (fread (&input, sizeof (struct employee), 1, infile) == 1) {
                printf ("\n\t#---------------------------------------#");
                printf ("\n\t| Name Of Employee %d -> %5s %5s \t|\n\t| Employee Id     -> %4d \t\t|\n\t| Salary        -> %8.2f\t\t|\n", i, input.fname, input.lname, input.emp_id, input.emp_salary);
                printf ("\t#---------------------------------------#");
                printf ("\n");
                i++;
            }
            i = 1;
            fclose (infile);
            break;
        case 3 :
            infile = fopen ("accounts.dat", "r");
            if (infile == NULL) {
                fprintf (stderr, "\nError opening accounts.dat\n\n");
            }
            printf ("\n\t Enter First name of Employee :-");
            scanf ("%s", & fnam);
            printf ("\n\t Enter Last name of Employee :-");
            scanf ("%s", & lnam);
            rewind (infile);
            while (fread (&input, sizeof (input), 1, infile) == 1) {
                if ((strcmp (input.fname, fnam) == 0) && (strcmp (input.lname, lnam) == 0)) {
                    printf ("\n\t#-----------------------------------------------#");
                    printf ("\n\t| Name Of Employee  -> %5s %5s \t\t|\n\t| Employee Id     -> %4d \t\t\t|\n\t| Salary        -> %8.2f\t\t\t|\n", input.fname, input.lname, input.emp_id, input.emp_salary);
                    printf ("\t#-----------------------------------------------#");
                }
            }
            fclose (infile);
            break;
        case 4 :
            infile = fopen ("accounts.dat", "rb+");
            if (infile == NULL) {
                fprintf (stderr, "\nError opening accounts.dat\n\n");
            }
            printf ("\n\tEnter the Employee Name to Modify: ");
            scanf ("%s", fnam);
            printf ("\n\tEnter Last Name of Employee :-");
            scanf ("%s", & lnam);
            rewind (infile);
            while (fread (&input, sizeof (input), 1, infile) == 1) {
                if ((strcmp (input.fname, fnam) == 0) && (strcmp (input.lname, lnam) == 0)) {
                update :
                    printf ("\n\t\t  *````````````````````````````*");
                    printf ("\n\t\t  | Employee Details Parameter |");
                    printf ("\n\t\t  *''''''''''''''''''''''''''''*");
                    printf ("\n\t\t    +-------------------+");
                    printf ("\t\n\t\t    |\t1. First Name \t|\n\t\t    |\t2. Last Name\t|\n\t\t    |\t3. Employee Id\t|\n\t\t    |\t4. Salary\t|\n\t\t    ");
                    printf ("+-------------------+");
                    printf ("\n");
                    printf ("\n\t Enter Field Option to Update :- ");
                    scanf ("%d", & o);
                    switch (o) {
                    case 1 :
                        printf ("\n\t Enter First Name  :- ");
                        scanf ("%s", input.fname);
                        break;
                    case 2 :
                        printf ("\n\t Enter Last Name   :- ");
                        scanf ("%s", input.lname);
                        break;
                    case 3 :
                        printf ("\n\t Enter Employee Id :- ");
                        scanf ("%d", & input.emp_id);
                        break;
                    case 4 :
                        printf ("\n\t Enter Salary      :- ");
                        scanf ("%f", & input.emp_salary);
                        break;
                    }
                    printf ("\n Do you Wish to Continue Updation for Given Employee[Y/N]  ");
                    scanf ("%s", & ch);
                    if (ch == 'y' || ch == 'Y') {
                        goto update;
                    }
                    fseek (infile, - sizeof (struct employee), SEEK_CUR);
                    fwrite (& input, sizeof (struct employee), 1, infile);
                    fclose (infile);
                }
            }
            break;
        case 5 :
            outfile = fopen ("accounts.dat", "rb+");
            printf ("\n\tEnter First Name of Employee :-  ");
            scanf ("%s", fnam);
            printf ("\n\tEnter Last Name of Employee :-");
            scanf ("%s", & lnam);
            temp = fopen ("temp.dat", "wb");
            rewind (outfile);
            while (fread (&input, sizeof (struct employee), 1, outfile) == 1) {
                if (strcmp (input.fname, fnam) != 0 && (strcmp (input.lname, lnam) != 0)) {
                    fwrite (& input, sizeof (struct employee), 1, temp);
                }
            }
            fclose (outfile);
            fclose (temp);
            remove ("accounts.dat");
            rename ("temp.dat", "accounts.dat");
            outfile = fopen ("accounts.dat", "rb+");
            printf ("\n\tRecord Deleted Successfully...\n");
            break;
        default :
            printf ("\n\t\t Enter Valid Option");
            goto menu;
        }
        printf ("\n Do you Wish to Continue With Employee Management Service[Y/N]  ");
        scanf ("%s", & ch);
        if (ch == 'y' || ch == 'Y') {
            goto menu;
        }
    }
    else {
        system ("cls");
        printf ("\n\n    \t++++++++++++ Welcome To AMIT BEHERE World. ++++++++++++");
        printf ("\n\n\t\tInvalid UserName or Password");
        printf ("\n\t\tTry Again");
        goto login;
    }
}
----------------------------------------

int main () {
    struct details detail;
    printf ("\nEnter name:\n");
    gets (detail.name);
    printf ("\nEnter age:\n");
    scanf ("%d", & detail.age);
    printf ("\nEnter Address:\n");
    scanf ("%s", & detail.address);
    printf ("\nEnter Salary:\n");
    scanf ("%f", & detail.salary);
    printf ("\n\n\n");
    printf ("Name of the Employee : %s \n", detail.name);
    printf ("Age of the Employee : %d \n", detail.age);
    printf ("Address of the Employee : %s \n", detail.address);
    printf ("Salary of the Employee : %f \n", detail.salary);
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7661856_7662337_3_51
7661856_7664495_8_42
Title: Reading an integer and / or character without an array 
----------------------------------------

int main () {
    int newValue = 0;
    int max;
    int min;
    int firstAcquired = 0;
    int ch;
    for (;;) {
        if (scanf ("%d", &newValue) == 0) {
            ch = getchar ();
            if (ch == '$' || ch == EOF)
                break;
            else {
                puts ("Invalid input, retry.");
                while ((ch = getchar ()) != '\n' && ch != EOF)
                    ;
            }
            if (ch == EOF)
                break;
        }
        else {
            if (!firstAcquired || newValue > max)
                max = newValue;
            if (!firstAcquired || newValue < min)
                min = newValue;
            firstAcquired = 1;
        }
    }
    if (firstAcquired) {
        printf ("The maximum value was %d\n", max);
        printf ("The minimum value was %d\n", min);
    }
    return 0;
}
----------------------------------------

int main () {
    char buff [BUFF_SIZE];
    int data [DATA_MAX_SIZE];
    int i, value, counter = 0;
    char *buffp, *p;
    while (NULL != fgets (buff, BUFF_SIZE, stdin)) {
        buff[BUFF_SIZE - 1] = '\0';
        buffp = buff;
    next :
        while (isspace (*buffp))
            ++buffp;
        if (*buffp == '\0')
            continue;
        value = strtol (buffp, &p, 0);
        if (counter == DATA_MAX_SIZE) {
            printf ("over data max size!\n");
            break;
        }
        else if (p != buffp) {
            data[counter++] = value;
            if (*p == '\0' || *p == '\r' || *p == '\n')
                continue;
            buffp = p;
            goto next;
        }
        else {
            if (*p == '$')
                break;
            printf ("format error\n");
            break;
        }
    }
    for (i = 0; i < counter; ++i) {
        printf ("data[%d]=%d\n", i, data [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7672560_21179176_1_14
7672560_7673832_1_15
Title: Reading in a variable length string user input in C 
----------------------------------------

int main (int argc, char **argv) {
    int s1 [4096], s2 [4096];
    fflush (stdin);
    printf (" enter a string\n");
    scanf ("%s", s1);
    printf (" enter a pattern\n");
    scanf ("%s", s2);
    int m = strlen (s1);
    int n = strlen (s2);
    printf (" text is %s of length %d, pattern is %s of length %d \n", s1, m, s2, n);
    return (EXIT_SUCCESS);
}
----------------------------------------

int main (int argc, char **argv) {
    char text [4096];
    char pattern [4096];
    fflush (stdin);
    printf (" enter a string\n");
    fgets (text, sizeof (text), stdin);
    printf (" enter a pattern\n");
    fgets (pattern, sizeof (pattern), stdin);
    int m = strlen (text);
    int n = strlen (pattern);
    printf (" text is %s %d  pattrn is %s %d \n", text, m, pattern, n);
    return (EXIT_SUCCESS);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7720978_7721048_1_10
7720978_7721067_1_14
Title: "Compiling with gcc c99 not with ideone c99. Integer Overflow" 
----------------------------------------

int rng (int min, int max) {
    int range = max - min + 1;
    int factor = ((unsigned) RAND_MAX + 1) / range;
    int x;
    do {
        x = rand () / factor;
    }
    while (x >= range);
    return x + min;
}
----------------------------------------

int rng (int min, int max) {
    int n = max - min + 1;
    int bits, val;
    if ((n & -n) == n)
        return min + (int) ((n * (uint64_t) rand ()) / ((uint64_t) RAND_MAX + 1));
    do {
        bits = rand ();
        val = bits % n;
    }
    while (bits - val > RAND_MAX - (n - 1));
    return min + val;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7738546_20671085_23_40
7738546_8048123_29_56
Title: How to set a timeout for a function in C? 
----------------------------------------

bool do_or_timeout (apr_pool_t *pool, apr_thread_start_t func, int max_wait_sec) {
    apr_thread_t *thread;
    bool thread_done = false;
    apr_thread_create (& thread, NULL, func, & thread_done, pool);
    apr_time_t now = apr_time_now ();
    for (;;) {
        if (thread_done) {
            apr_thread_join (NULL, thread);
            return true;
        }
        if (apr_time_now () >= now + apr_time_make (max_wait_sec, 0)) {
            return false;
        }
        apr_sleep (10000);
    }
}
----------------------------------------

int do_or_timeout (struct timespec *max_wait) {
    struct timespec abs_time;
    pthread_t tid;
    int err;
    pthread_mutex_lock (& calculating);
    clock_gettime (CLOCK_REALTIME, & abs_time);
    abs_time.tv_sec += max_wait->tv_sec;
    abs_time.tv_nsec += max_wait->tv_nsec;
    pthread_create (& tid, NULL, expensive_call, NULL);
    err = pthread_cond_timedwait (&done, &calculating, &abs_time);
    if (err == ETIMEDOUT)
        fprintf (stderr, "%s: calculation timed out\n", __func__);
    if (!err)
        pthread_mutex_unlock (&calculating);
    return err;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7764027_20801899_8_64
7764027_7764541_7_33
Title: how to find duplicate string in an array of strings 
----------------------------------------

void main () {
    int count = 0, c = 0, i, j = 0, k, space = 0;
    char str [100], p [50] [100], str1 [20], ptr1 [50] [100];
    printf ("Enter the string\n");
    scanf (" %[^\n]s", str);
    printf ("string length is %d\n", strlen (str));
    for (i = 0; i < strlen (str); i++) {
        if ((str[i] == ' ') || (str[i] == ', ') || (str[i] == '.')) {
            space++;
        }
    }
    for (i = 0, j = 0, k = 0; j < strlen (str); j++) {
        if ((str[j] == ' ') || (str[j] == 44) || (str[j] == 46)) {
            p[i][k] = '\0';
            i++;
            k = 0;
        }
        else
            p[i][k++] = str[j];
    }
    k = 0;
    for (i = 0; i <= space; i++) {
        for (j = 0; j <= space; j++) {
            if (i == j) {
                strcpy (ptr1 [k], p [i]);
                k++;
                count++;
                break;
            }
            else {
                if (strcmp (ptr1[j], p[i]) != 0)
                    continue;
                else
                    break;
            }
        }
    }
    for (i = 0; i < count; i++) {
        for (j = 0; j <= space; j++) {
            if (strcmp (ptr1[i], p[j]) == 0)
                c++;
        }
        printf ("%s -> %d times\n", ptr1 [i], c);
        c = 0;
    }
}
----------------------------------------

int main () {
    char x [100] = "Amit Hanish Mahesh Amit";
    size_t sz_result = sizeof (char) * (strlen (x) + 1);
    char *result = (char *) malloc (sz_result);
    result[0] = '\0';
    char *elm = strtok (x, " ");
    if (elm != NULL)
        strcpy (result, elm);
    while ((elm = strtok (NULL, " ")) != NULL) {
        if (strstr (result, elm) == NULL) {
            strcat (result, " ");
            strcat (result, elm);
        }
    }
    strcpy (x, result);
    fprintf (stdout, "Result: %s\n", x);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7764027_20801899_8_64
7764027_7765648_26_42
Title: how to find duplicate string in an array of strings 
----------------------------------------

void main () {
    int count = 0, c = 0, i, j = 0, k, space = 0;
    char str [100], p [50] [100], str1 [20], ptr1 [50] [100];
    printf ("Enter the string\n");
    scanf (" %[^\n]s", str);
    printf ("string length is %d\n", strlen (str));
    for (i = 0; i < strlen (str); i++) {
        if ((str[i] == ' ') || (str[i] == ', ') || (str[i] == '.')) {
            space++;
        }
    }
    for (i = 0, j = 0, k = 0; j < strlen (str); j++) {
        if ((str[j] == ' ') || (str[j] == 44) || (str[j] == 46)) {
            p[i][k] = '\0';
            i++;
            k = 0;
        }
        else
            p[i][k++] = str[j];
    }
    k = 0;
    for (i = 0; i <= space; i++) {
        for (j = 0; j <= space; j++) {
            if (i == j) {
                strcpy (ptr1 [k], p [i]);
                k++;
                count++;
                break;
            }
            else {
                if (strcmp (ptr1[j], p[i]) != 0)
                    continue;
                else
                    break;
            }
        }
    }
    for (i = 0; i < count; i++) {
        for (j = 0; j <= space; j++) {
            if (strcmp (ptr1[i], p[j]) == 0)
                c++;
        }
        printf ("%s -> %d times\n", ptr1 [i], c);
        c = 0;
    }
}
----------------------------------------

int main (int argc, char **argv) {
    if (argc < 3) {
        fprintf (stderr, "Usage: %s haystack dup_size\n", argv [0]);
        return 1;
    }
    char *haystack = argv[1];
    size_t len = atoi (argv[2]);
    char *r;
    while ((r = find_duplicate (haystack, strlen (haystack), len))) {
        strcpy (r, r + len);
    }
    puts (haystack);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7764027_7764541_7_33
7764027_7765648_26_42
Title: how to find duplicate string in an array of strings 
----------------------------------------

int main () {
    char x [100] = "Amit Hanish Mahesh Amit";
    size_t sz_result = sizeof (char) * (strlen (x) + 1);
    char *result = (char *) malloc (sz_result);
    result[0] = '\0';
    char *elm = strtok (x, " ");
    if (elm != NULL)
        strcpy (result, elm);
    while ((elm = strtok (NULL, " ")) != NULL) {
        if (strstr (result, elm) == NULL) {
            strcat (result, " ");
            strcat (result, elm);
        }
    }
    strcpy (x, result);
    fprintf (stdout, "Result: %s\n", x);
}
----------------------------------------

int main (int argc, char **argv) {
    if (argc < 3) {
        fprintf (stderr, "Usage: %s haystack dup_size\n", argv [0]);
        return 1;
    }
    char *haystack = argv[1];
    size_t len = atoi (argv[2]);
    char *r;
    while ((r = find_duplicate (haystack, strlen (haystack), len))) {
        strcpy (r, r + len);
    }
    puts (haystack);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7787671_7787691_1_10
7787671_7787966_1_13
Title: interesting strcmp implementation failure. (C) 
----------------------------------------

int strcmp (const char *str1, const char *str2) {
    while (*str1 || *str2) {
        if (*str1 != *str2)
            return *str1 - *str2;
        ++str1;
        ++str2;
    }
    return 0;
}
----------------------------------------

int strcmp (const char *str1, const char *str2) {
    const unsigned char *s1 = (const unsigned char *) str1;
    const unsigned char *s2 = (const unsigned char *) str2;
    while (*s1 && *s1 == *s2) {
        s1++;
        s2++;
    }
    return *s1 - *s2;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
779875_27605769_1_78
779875_780024_4_48
Title: What is the function to replace string in C? 
----------------------------------------

char *replace (const char *instring, const char *old_part, const char *new_part) {
    if (!instring || !old_part || !new_part) {
        return (char *) NULL;
    }
    size_t instring_len = strlen (instring);
    size_t new_len = strlen (new_part);
    size_t old_len = strlen (old_part);
    if (instring_len < old_len || old_len == 0) {
        return (char *) NULL;
    }
    const char *in = instring;
    const char *found = NULL;
    size_t count = 0;
    size_t out = 0;
    size_t ax = 0;
    char *outstring = NULL;
    if (new_len > old_len) {
        size_t Diff = EXPECTED_REPLACEMENTS * (new_len - old_len);
        size_t outstring_len = instring_len + Diff;
        outstring = (char *) malloc (outstring_len);
        if (!outstring) {
            return (char *) NULL;
        }
        while ((found = strstr (in, old_part)) != NULL) {
            if (count == EXPECTED_REPLACEMENTS) {
                outstring_len += Diff;
                if ((outstring = realloc (outstring, outstring_len)) == NULL) {
                    return (char *) NULL;
                }
                count = 0;
            }
            ax = found - in;
            strncpy (outstring + out, in, ax);
            out += ax;
            strncpy (outstring + out, new_part, new_len);
            out += new_len;
            in = found + old_len;
            count++;
        }
    }
    else {
        outstring = (char *) malloc (instring_len);
        if (!outstring) {
            return (char *) NULL;
        }
        while ((found = strstr (in, old_part)) != NULL) {
            ax = found - in;
            strncpy (outstring + out, in, ax);
            out += ax;
            strncpy (outstring + out, new_part, new_len);
            out += new_len;
            in = found + old_len;
        }
    }
    ax = (instring + instring_len) - in;
    strncpy (outstring + out, in, ax);
    out += ax;
    outstring[out] = '\0';
    return outstring;
}
----------------------------------------

char *replace (char const * const original, char const * const pattern, char const * const replacement) {
    size_t const replen = strlen (replacement);
    size_t const patlen = strlen (pattern);
    size_t const orilen = strlen (original);
    size_t patcnt = 0;
    const char *oriptr;
    const char *patloc;
    for (oriptr = original; patloc = strstr (oriptr, pattern); oriptr = patloc + patlen) {
        patcnt++;
    }
    {
        size_t const retlen = orilen + patcnt * (replen - patlen);
        char * const returned = (char *) malloc (sizeof (char) * (retlen + 1));
        if (returned != NULL) {
            char *retptr = returned;
            for (oriptr = original; patloc = strstr (oriptr, pattern); oriptr = patloc + patlen) {
                size_t const skplen = patloc - oriptr;
                strncpy (retptr, oriptr, skplen);
                retptr += skplen;
                strncpy (retptr, replacement, replen);
                retptr += replen;
            }
            strcpy (retptr, oriptr);
        }
        return returned;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
779875_31775567_3_33
779875_33532951_1_14
Title: What is the function to replace string in C? 
----------------------------------------

int replacestr (char *line, const char *search, const char *replace) {
    int count;
    char *sp;
    if ((sp = strstr (line, search)) == NULL) {
        return (0);
    }
    count = 1;
    int sLen = strlen (search);
    int rLen = strlen (replace);
    if (sLen > rLen) {
        char *src = sp + sLen;
        char *dst = sp + rLen;
        while ((*dst = *src) != '\0') {
            dst++;
            src++;
        }
    }
    else if (sLen < rLen) {
        int tLen = strlen (sp) - sLen;
        char *stop = sp + rLen;
        char *src = sp + sLen + tLen;
        char *dst = sp + rLen + tLen;
        while (dst >= stop) {
            *dst = *src;
            dst--;
            src--;
        }
    }
    memcpy (sp, replace, rLen);
    count += replacestr (sp +rLen, search, replace);
    return (count);
}
----------------------------------------

static void replacestr (char *line, const char *search, const char *replace) {
    char *sp;
    if ((sp = strstr (line, search)) == NULL) {
        return;
    }
    int search_len = strlen (search);
    int replace_len = strlen (replace);
    int tail_len = strlen (sp +search_len);
    memmove (sp + replace_len, sp + search_len, tail_len + 1);
    memcpy (sp, replace, replace_len);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7804768_7804924_1_17
7804768_7805141_1_23
Title: How to optimize this piece of code In c 
----------------------------------------

void removeDuplicates (char *ptr) {
    int exists [256] = {0};
    int end;
    int current = 0;
    int length = strlen (ptr);
    for (end = 0; end < length; end++) {
        if (exists[ptr[end]])
            break;
        exists[ptr[end]] = 1;
        ptr[current++] = ptr[end];
    }
    ptr[current] = '\0';
}
----------------------------------------

void removeDuplicates (char *src) {
    char bitfield [32] = {0};
    char *dest = src;
    while (*src) {
        char ch = *src;
        int pos = ch >> 3;
        int bit = ch & 0x7;
        char mask = 1 << bit;
        if (!(bitfield[pos] & mask)) {
            bitfield[pos] |= mask;
            *dest++ = ch;
        }
        ++src;
    }
    *dest = 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7812044_7812158_1_12
7812044_7813929_1_15
Title: Finding trailing 0s in a binary number 
----------------------------------------

int bitcount (unsigned char x) {
    int b;
    for (b = 0; b < 7; x >>= 1) {
        if (x & 1)
            break;
        else
            b++;
    }
    return b;
}
----------------------------------------

int bitcount (unsigned x) {
    static const unsigned char table [256] = {};
    for (int i = 0; i < sizeof (x); ++i, x >>= 8) {
        unsigned char r = table[x & 0xff];
        if (r)
            return r + i * 8;
    }
    return sizeof (x) * 8;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7857160_7857181_9_26
7857160_7857198_27_42
Title: How to jump between functions and main() in C programming 
----------------------------------------

int main (void) {
    while (1) {
        switch (state) {
        case ff :
            f ();
            break;
        case gg :
            g ();
            break;
        case hh :
            h ();
            break;
        }
    }
}
----------------------------------------

int main (int argc, char *argv []) {
    int choice;
    choice = prompt_for_choice ();
    if (choice == SNAKE) {
        play_snake ();
    }
    else if (choice == PAINTER) {
        play_painter ();
    }
    else {
        printf ("internal error, invalid choice %d\n", choice);
        exit (1);
    }
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7861910_7861918_1_17
7861910_7863527_4_19
Title: "Why does this simple code with printf ""freeze""?" 
----------------------------------------

int main () {
    int co = 0;
    while (co < 10) {
        co = co + 1;
        if (co == 3)
            printf ("The number is now three.");
        if (co == 7)
            printf ("The number is now seven.");
        else
            printf ("%d\n", co);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int co;
    for (co = 0; co < 10; co++) {
        if (co == 3)
            printf ("The number is now three.\n");
        else if (co == 7)
            printf ("The number is now seven.\n");
        else
            printf ("%d\n", co);
    }
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7865480_7865523_4_25
7865480_7865686_4_19
Title: Converting hexdecimal values to int custom hatoi method 
----------------------------------------

int htoi (char s []) {
    int i, n, len;
    n = 0;
    len = strlen (s);
    for (i = 0; i < len; i++) {
        if (s[i] >= '0' && s[i] <= '9') {
            n = 16 * n + (s[i] - '0');
        }
        else if (s[i] >= 'a' && s[i] <= 'f') {
            n = 16 * n + (s[i] - 'a') + 10;
        }
        else if (s[i] >= 'A' && s[i] <= 'F') {
            n = 16 * n + (s[i] - 'A') + 10;
        }
    }
    return n;
}
----------------------------------------

int htoi (char s []) {
    char *p = s;
    char c;
    int val = 0;
    while ((c = *p++)) {
        c = toupper (c);
        val = (val << 4) | ((c >= '0' && c <= '9') ? c - '0' : (c >= 'A' && c <= 'F') ? 10 + c - 'A' : 0);
    }
    return val;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7884807_7884821_4_16
7884807_7884849_4_20
Title: C - Split a string 
----------------------------------------

int main () {
    char str [] = "Command:Context";
    char *pch;
    printf ("Splitting string \"%s\" into tokens:\n", str);
    pch = strtok (str, ":");
    while (pch != NULL) {
        printf ("%s\n", pch);
        pch = strtok (NULL, ":");
    }
    return 0;
}
----------------------------------------

int main (void) {
    char instr [] = "Command:Context";
    char words [2] [10];
    char *chptr;
    int idx = 0;
    chptr = strtok (instr, ":");
    while (chptr != NULL) {
        strcpy (words [idx ++], chptr);
        chptr = strtok (NULL, ":");
    }
    printf ("Word1 = [%s]\n", words [0]);
    printf ("Word2 = [%s]\n", words [1]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7896508_7896636_12_24
7896508_7896840_3_14
Title: Intermediate command-line interfaces 
----------------------------------------

int main () {
    int fd;
    struct termios tio;
    printf ("Enter something: ");
    tcgetattr (fileno (stdin), & tio);
    tio.c_lflag &= ~ECHO;
    tcsetattr (fileno (stdin), TCSANOW, & tio);
    munch_line ();
    putchar ('\n');
}
----------------------------------------

int main (void) {
    printf ("ZZZZZZZZZZ");
    printf ("\x1b[%dD", 10U);
    printf ("YYYYYYYYY");
    printf ("\x1b[%dD", 9U);
    printf ("XXXXXXXX");
    printf ("\x1b[%dD", 2U);
    printf ("\x1b[1K");
    printf ("\r\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7911651_33565169_3_23
7911651_37477342_4_24
Title: Decimal to Binary 
----------------------------------------

void main () {
    int binary [8], number, i;
    do {
        printf ("input a number: ");
        scanf ("%d", & number);
        fflush (stdin);
    }
    while (number > 256 || number < 0);
    for (i = 0; i <= 7; i++) {
        binary[i] = number % 2;
        number = number / 2;
    }
    for (i = 7; i >= 0; i--)
        printf ("%d", binary[i]);
    number = 0;
    for (i = 0; i <= 7; i++) {
        number = number + binary[i] * pow (2, i);
    }
    printf ("\n%c", number);
}
----------------------------------------

int main (int argc, char **argv) {
    int n, t = 0;
    char *bin, b [2] = "";
    scanf ("%d", & n);
    bin = (char *) malloc (sizeof (char) + 2);
    while (n != 0) {
        t = n >> 1;
        t = t << 1;
        t = n - t;
        n = n >> 1;
        itoa (t, b, 10);
        bin = realloc ((char *) bin, sizeof (char) + 1);
        strcat (bin, b);
    }
    strrev (bin);
    printf ("\n%s\n", bin);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7911651_33565169_3_23
7911651_40182736_1_12
Title: Decimal to Binary 
----------------------------------------

void main () {
    int binary [8], number, i;
    do {
        printf ("input a number: ");
        scanf ("%d", & number);
        fflush (stdin);
    }
    while (number > 256 || number < 0);
    for (i = 0; i <= 7; i++) {
        binary[i] = number % 2;
        number = number / 2;
    }
    for (i = 7; i >= 0; i--)
        printf ("%d", binary[i]);
    number = 0;
    for (i = 0; i <= 7; i++) {
        number = number + binary[i] * pow (2, i);
    }
    printf ("\n%c", number);
}
----------------------------------------

int main () {
    int n, c, k;
    printf ("Enter_an_integer_in_decimal_number_system:_");
    scanf ("%d", & n);
    printf ("%d_in_binary_number_system_is:_", n);
    for (c = n; c > 0; c = c / 2) {
        k = c % 2;
        k = (k > 0) ? printf ("1") : printf ("0");
    }
    getch ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7911651_33565169_3_23
7911651_47274137_4_39
Title: Decimal to Binary 
----------------------------------------

void main () {
    int binary [8], number, i;
    do {
        printf ("input a number: ");
        scanf ("%d", & number);
        fflush (stdin);
    }
    while (number > 256 || number < 0);
    for (i = 0; i <= 7; i++) {
        binary[i] = number % 2;
        number = number / 2;
    }
    for (i = 7; i >= 0; i--)
        printf ("%d", binary[i]);
    number = 0;
    for (i = 0; i <= 7; i++) {
        number = number + binary[i] * pow (2, i);
    }
    printf ("\n%c", number);
}
----------------------------------------

int main (void) {
    int i, d, n = 1;
    int store [10];
    printf ("Please enter a number to be converted to binary:\n");
    scanf ("%d", & d);
    for (i = 0; i < 8; i++)
        store[i] = 0;
    i = 0;
    do {
        if (d & n) {
            n <<= 1;
            store[i] = 1;
            i++;
        }
        else {
            n <<= 1;
            store[i] = 0;
            i++;
        }
    }
    while (n <= d);
    printf ("\n");
    for (i = 7; i >= 0; i--) {
        printf ("%d", store [i]);
        if (i == 4)
            printf (" ");
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7911651_37477342_4_24
7911651_40182736_1_12
Title: Decimal to Binary 
----------------------------------------

int main (int argc, char **argv) {
    int n, t = 0;
    char *bin, b [2] = "";
    scanf ("%d", & n);
    bin = (char *) malloc (sizeof (char) + 2);
    while (n != 0) {
        t = n >> 1;
        t = t << 1;
        t = n - t;
        n = n >> 1;
        itoa (t, b, 10);
        bin = realloc ((char *) bin, sizeof (char) + 1);
        strcat (bin, b);
    }
    strrev (bin);
    printf ("\n%s\n", bin);
    return 0;
}
----------------------------------------

int main () {
    int n, c, k;
    printf ("Enter_an_integer_in_decimal_number_system:_");
    scanf ("%d", & n);
    printf ("%d_in_binary_number_system_is:_", n);
    for (c = n; c > 0; c = c / 2) {
        k = c % 2;
        k = (k > 0) ? printf ("1") : printf ("0");
    }
    getch ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7911651_37477342_4_24
7911651_47274137_4_39
Title: Decimal to Binary 
----------------------------------------

int main (int argc, char **argv) {
    int n, t = 0;
    char *bin, b [2] = "";
    scanf ("%d", & n);
    bin = (char *) malloc (sizeof (char) + 2);
    while (n != 0) {
        t = n >> 1;
        t = t << 1;
        t = n - t;
        n = n >> 1;
        itoa (t, b, 10);
        bin = realloc ((char *) bin, sizeof (char) + 1);
        strcat (bin, b);
    }
    strrev (bin);
    printf ("\n%s\n", bin);
    return 0;
}
----------------------------------------

int main (void) {
    int i, d, n = 1;
    int store [10];
    printf ("Please enter a number to be converted to binary:\n");
    scanf ("%d", & d);
    for (i = 0; i < 8; i++)
        store[i] = 0;
    i = 0;
    do {
        if (d & n) {
            n <<= 1;
            store[i] = 1;
            i++;
        }
        else {
            n <<= 1;
            store[i] = 0;
            i++;
        }
    }
    while (n <= d);
    printf ("\n");
    for (i = 7; i >= 0; i--) {
        printf ("%d", store [i]);
        if (i == 4)
            printf (" ");
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7911651_40182736_1_12
7911651_47274137_4_39
Title: Decimal to Binary 
----------------------------------------

int main () {
    int n, c, k;
    printf ("Enter_an_integer_in_decimal_number_system:_");
    scanf ("%d", & n);
    printf ("%d_in_binary_number_system_is:_", n);
    for (c = n; c > 0; c = c / 2) {
        k = c % 2;
        k = (k > 0) ? printf ("1") : printf ("0");
    }
    getch ();
    return 0;
}
----------------------------------------

int main (void) {
    int i, d, n = 1;
    int store [10];
    printf ("Please enter a number to be converted to binary:\n");
    scanf ("%d", & d);
    for (i = 0; i < 8; i++)
        store[i] = 0;
    i = 0;
    do {
        if (d & n) {
            n <<= 1;
            store[i] = 1;
            i++;
        }
        else {
            n <<= 1;
            store[i] = 0;
            i++;
        }
    }
    while (n <= d);
    printf ("\n");
    for (i = 7; i >= 0; i--) {
        printf ("%d", store [i]);
        if (i == 4)
            printf (" ");
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7916411_7916661_4_18
7916411_7916905_29_46
Title: "OpenMP for loop inside section" 
----------------------------------------

int main () {
    omp_set_num_threads (10);
    for (int i = 0; i < 5; i++) {
        printf ("x %d\n", i);
    }
    for (int i = 0; i < 5; i++) {
        printf (". %d\n", i);
    }
}
----------------------------------------

int main () {
    omp_set_num_threads (2);
    omp_set_nested (1);
    {
        int gtid = omp_get_thread_num ();
        {
            doTask1 (gtid);
            doTask2 (gtid);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7936658_7936683_1_13
7936658_7936702_3_18
Title: fgets to read particular size 
----------------------------------------

int main (int argc, char **argv) {
    char buf [40];
    FILE *f;
    if (NULL == (f = fopen (argv[1], "r"))) {
        fprintf (stderr, "Unable to open file\n");
        return EXIT_FAILURE;
    }
    size_t len;
    while (0 < (len = fread (buf, 10, 1, f)))
        printf ("%*.*s\n", len, len, buf);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int i = 0;
    FILE *f;
    char *fileName = argv[1];
    char buf [40];
    f = fopen (fileName, "r");
    while (fgets (buf, 10, f))
        printf ("%s", buf);
    fclose (f);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
7963293_7963431_1_13
7963293_7971276_1_31
Title: Reverse Linked List Recursively 
----------------------------------------

node *reverseLinkedListRecursively (node *rest, node *reversed) {
    node *current;
    if (rest == NULL)
        return reversed;
    current = rest;
    rest = rest->next;
    current->next = reversed;
    return reverseLinkedListRecursively (rest, current);
}
----------------------------------------

node *reverseLinkedListRecursively (node *head) {
    node *current;
    node *rest;
    if (head == NULL)
        return head;
    current = head;
    rest = head->next;
    if (rest == NULL) {
        return current;
    }
    rest = reverseLinkedListRecursively (rest);
    current->next->next = current;
    current->next = NULL;
    return rest;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
799679_801306_8_22
799679_8149380_7_23
Title: Programmatically retrieving the absolute path of an OS X command-line app 
----------------------------------------

int main (argc, argv)
    int argc;
    char **argv;
{
    char actualpath [PATH_MAX + 1];
    if (argc > 1) {
        fprintf (stderr, "Usage: %s\n", argv [0]);
        exit (1);
    }
    realpath (argv [0], actualpath);
    fprintf (stdout, "My real path: %s\n", actualpath);
    exit (0);
}
----------------------------------------

int main (int argc, char *argv []) {
    int ret;
    pid_t pid;
    char pathbuf [PROC_PIDPATHINFO_MAXSIZE];
    pid = getpid ();
    ret = proc_pidpath (pid, pathbuf, sizeof (pathbuf));
    if (ret <= 0) {
        fprintf (stderr, "PID %d: proc_pidpath ();\n", pid);
        fprintf (stderr, "    %s\n", strerror (errno));
    }
    else {
        printf ("proc %d: %s\n", pid, pathbuf);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8007473_8007538_3_12
8007473_8008231_3_14
Title: How to convert decimal number into a hexadecimal number then store the corresponding result in an integer as a decimal value 
----------------------------------------

int main () {
    int i = 0x345;
    int j = 1;
    int result = 0;
    do {
        result += (i & 0xf) * j;
        j *= 10;
    }
    while (i /= (0x10));
    printf ("%i\n", result);
}
----------------------------------------

int main () {
    char x [6];
    'just took 6,you can increase its size as per your int number
                 ' Though it uses only 3 elements in these example int i;
    int a;
    i = 837;
    ' Load the i value with a decimal number say 837
   sprintf(x,"%x",i);  ' pass the hex format value to string x instead of stdout ' x contains x[0] =' 3 ' x[1] =' 4 ' x[2] =' 5 '
   a=atoi(x);          ' Convert the string format to integer printf ("%d", a);
    ' outputs 345
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8017015_8017251_1_74
8017015_8017458_21_98
Title: C Program terminates after if/else or repeats if I use fputs/fgets 
----------------------------------------

int main (int argc, char *argv []) {
    char source_type;
    int NumberofAuthors;
    char AuthorName1 [20];
    char AuthorName2 [20];
    char AuthorName3 [20];
    char title [20];
    char url [100];
    char publishingCity [20];
    char publisher [20];
    char yearPublished [20];
    char pageNumbers [20];
    int valid;
    printf ("Welcome to Jackson's Chicago Manual of Style Auto-Footnoter.\n");
    printf ("Choose source type:\n a.Book");
    scanf ("%c", & source_type);
    if (source_type == 'a') {
        valid = 1;
    }
    else {
        printf ("Invalid source selection");
        valid = 0;
    }
    while (valid == 1 && source_type == 'a') {
        valid = 0;
        printf ("Number of authors [1 or 2]: ");
        scanf ("%d", & NumberofAuthors);
        if (NumberofAuthors > 0 && NumberofAuthors < 3) {
            valid = 1;
            printf ("Got it, %d author(s).\n", NumberofAuthors);
        }
        else {
            printf ("That's not enough people to write a book.\n");
            continue;
        }
        switch (NumberofAuthors) {
        case 1 :
            printf ("Author's name: ");
            scanf ("%19s", AuthorName1);
            break;
        case 2 :
            printf ("First author's name: ");
            scanf ("%19s", AuthorName2);
            printf ("Second author's name: ");
            scanf ("%19s", AuthorName3);
            break;
        default :
            valid = 0;
            break;
        }
        if (valid) {
            printf ("Book title: ");
            scanf ("%19s", title);
            printf ("Publication city: ");
            scanf ("%19s", publishingCity);
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    int source_type;
    int NumberofAuthors;
    char AuthorName1 [20];
    char AuthorName2 [20];
    char title [20];
    char publishingCity [20];
    int valid = 0;
    int c;
    printf ("Welcome to Jackson's Chicago Manual of Style Auto-Footnoter.\n");
    fputs ("Choose source type:\n a.Book\n b.Journal\n c.Article\n d.Website\n ", stdout);
    source_type = getchar ();
    if (source_type == 'a')
        valid = 1;
    else {
        printf ("Invalid source selection");
        return (1);
    }
    while (valid == 1 && source_type == 'a') {
        printf ("Number of authors [1 or 2]");
        scanf ("%d", & NumberofAuthors);
        if (NumberofAuthors > 0 && NumberofAuthors < 3) {
            valid = 1;
            printf ("Got it, %d author(s).\n", NumberofAuthors);
        }
        else {
            printf ("That's not enough (or too many) people to write a book.\n");
            break;
        }
        while ((c = getchar ()) != EOF && c != '\n')
            ;
        if (NumberofAuthors == 1) {
            if (get_string ("Author's name", AuthorName1, sizeof (AuthorName1)) == EOF) {
                valid = 0;
                break;
            }
        }
        else {
            assert (NumberofAuthors == 2);
            if (get_string ("First author's name", AuthorName1, sizeof (AuthorName1)) == EOF || get_string ("Second author's name", AuthorName2, sizeof (AuthorName2)) == EOF) {
                valid = 0;
                break;
            }
        }
        if (get_string ("Book title", title, sizeof (title)) == EOF || get_string ("Publication city", publishingCity, sizeof (publishingCity)) == EOF) {
            valid = 0;
            break;
        }
        printf ("Author 1: %s\n", AuthorName1);
        if (NumberofAuthors == 2)
            printf ("Author 2: %s\n", AuthorName2);
        printf ("Book title: %s\n", title);
        printf ("Publication city: %s\n", publishingCity);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8095858_8096024_1_29
8095858_8096026_1_27
Title: Can't figure out why this trimming function won't work correctly 
----------------------------------------

void trim (const char *orig, char *dest) {
    size_t front = 0;
    size_t end = strlen (orig) - 1;
    size_t counter = 0;
    *dest = '\0';
    if (strlen (orig) > 0) {
        while (front < end && isspace (orig[front])) {
            front++;
        }
        while (front < end && isspace (orig[end])) {
            end--;
        }
        counter = front;
        while (counter <= end) {
            dest[counter - front] = orig[counter];
            counter++;
        }
    }
}
----------------------------------------

void trim (const char *orig, char *dest) {
    size_t front = 0;
    size_t end = strlen (orig) - 1;
    size_t counter = 0;
    char *tmp = NULL;
    if (strlen (orig) > 0) {
        memset (dest, '\0', strlen (dest));
        while (isspace (orig[front])) {
            front++;
        }
        while (isspace (orig[end])) {
            end--;
        }
        tmp = strndup (orig +front, end -front + 1);
        strncpy (dest, tmp, strlen (dest));
        free (tmp);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8097620_26448121_5_28
8097620_39524995_4_18
Title: How to read from input until newline is found using scanf()? 
----------------------------------------

int main (void) {
    int i = 0;
    char *a = (char *) malloc (sizeof (char) * 1024);
    while (1) {
        scanf ("%c", & a [i]);
        if (a[i] == '\n') {
            break;
        }
        else {
            i++;
        }
    }
    a[i] = '\0';
    i = 0;
    printf ("\n");
    while (a[i] != '\0') {
        printf ("%c", a [i]);
        i++;
    }
    free (a);
    getch ();
    return 0;
}
----------------------------------------

int main () {
    int i = 0, j = 0, arr [100];
    char temp;
    while (scanf ("%d%c", &arr[i], &temp)) {
        i++;
        if (temp == '\n') {
            break;
        }
    }
    for (j = 0; j < i; j++) {
        printf ("%d ", arr [j]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
8106765_21156029_1_16
8106765_8106848_7_32
Title: Using strtok in c 
----------------------------------------

int main () {
    char str [] = "test string.";
    char *temp1;
    char *temp2;
    temp1 = strtok (str, " ");
    temp2 = strchr (str, ' ');
    if (temp2 != NULL)
        temp2++;
    printf ("Splitted string :%s, %s\n", temp1, temp2);
    return
}
----------------------------------------

int main () {
    char str [] = "test string.";
    char *names [MAX_NAMES] = {0};
    char *test;
    int i = 0;
    test = strtok (str, " ");
    while (test != NULL && i < MAX_NAMES) {
        names[i] = malloc (strlen (test) +1);
        strcpy (names [i ++], test);
        test = strtok (NULL, " ");
    }
    for (i = 0; i < MAX_NAMES; ++i) {
        if (names[i]) {
            puts (names [i]);
            free (names [i]);
            names[i] = 0;
        }
    }
    return 0;
}
----------------------------------------
