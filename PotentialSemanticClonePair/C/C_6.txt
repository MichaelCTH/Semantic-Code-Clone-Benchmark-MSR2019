$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16443780_16444099_9_21
16443780_16444218_20_30
Title: how to return a char array from a function in C 
----------------------------------------

int main (void) {
    int i = 0, j = 2;
    char s [] = "String";
    char *test;
    test = substring (i, j, s);
    printf ("%s", test);
    free (test);
    return 0;
}
----------------------------------------

int main () {
    int i = 0, j = 2;
    char s [] = "String";
    char *test;
    test = substring (i, j, s);
    printf ("%s", test);
    free (test);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1644446_1654985_2_16
1644446_27463127_1_31
Title: What is Sum of Even Terms In Fibonacci (<4million)? [Large Value Datatype Confusion] 
----------------------------------------

int main () {
    int x = 1, y = 2, sum, limit;
    int evensum = 2;
    printf ("Enter Limit: ");
    scanf ("%d", & limit);
    while ((x + y) < limit) {
        sum = x + y;
        x = y;
        y = sum;
        if (sum % 2 == 0)
            evensum += sum;
    }
    printf ("%d \n", evensum);
    return 0;
}
----------------------------------------

int main () {
    long first = 1, second = 2, next, c;
    int sum = 0;
    for (c = 1; c < 100000000; c++) {
        next = first + second;
        if (next >= 4000000) {
            next = next - second;
            break;
        }
        first = second;
        second = next;
        if (next % 2 == 0) {
            sum = sum + next;
        }
    }
    printf ("the sum of even valued  term is %d\n", sum + 2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16452854_16453348_1_22
16452854_16453500_1_16
Title: Binary Search Tree C implementation 
----------------------------------------

void insertNode (int i, node **n) {
    if (*n == NULL) {
        (*n) = (node *) malloc (sizeof (node));
        (*n)->leftChildNode = NULL;
        (*n)->rightChildNode = NULL;
        (*n)->data = i;
    }
    else {
        if ((*n)->data == i) {
            printf ("\nThis value already exists in the tree!");
        }
        else {
            if (i > (*n)->data)
                insertNode (i, &(*n)->rightChildNode);
            else
                insertNode (i, &(*n)->leftChildNode);
        }
    }
}
----------------------------------------

void insertNode (int i, node **n) {
    if (*n == NULL) {
        *n = (node *) malloc (sizeof (node));
        (*n)->leftChildNode = NULL;
        (*n)->rightChildNode = NULL;
        (*n)->data = i;
    }
    else if ((*n)->data == i)
        printf ("\nThis value already exists in the tree!");
    else if (i > (*n)->data)
        insertNode (i, &((*n)->rightChildNode));
    else
        insertNode (i, &((*n)->leftChildNode));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16470118_16470652_38_48
16470118_16473698_32_45
Title: Is there a Linux equivalent of SetWindowPos? 
----------------------------------------

int main () {
    xcb_connection_t *connection;
    const xcb_setup_t *setup;
    connection = xcb_connect (NULL, NULL);
    setup = xcb_get_setup (connection);
    xcb_screen_iterator_t screen = xcb_setup_roots_iterator (setup);
    handle (connection, screen.data -> root);
    return 0;
}
----------------------------------------

int main (int argc, char * const argv []) {
    Display *display = NULL;
    if ((display = XOpenDisplay (NULL)) == NULL) {
        fprintf (stderr, "error: cannot connect to X server\n");
        return 1;
    }
    EnumWindows (display, DefaultRootWindow (display), 0);
    XCloseDisplay (display);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16518371_16518868_36_57
16518371_16519483_3_33
Title: "(C) Getting the 3 minimum elements of an row in a matrix and choose one randomly" 
----------------------------------------

int main (void) {
    srand (time (NULL));
    int myrow = 3;
    int *sorted_row = NULL;
    int i, j;
    sorted_row = sort_array (piezas[myrow], SIZE_ROW);
    printf ("N mins : \n");
    for (i = 0; i < N_MIN; i++) {
        printf (" %d ", sorted_row [i]);
    }
    printf ("\n");
    printf ("Random Pick : %d \n", random_pick (sorted_row, N_MIN));
}
----------------------------------------

int main (void) {
    int piezas [8] [8] = {0, 2, 2, 5, 3, 2, 1, 1, 0, 4, 5, 2, 4, 3, 0, 0, 0, 4, 2, 2, 1, 2, 3, 2, 0, 3, 1, 5, 1, 2, 3, 4, 2, 5, 6, 5, 3, 1, 2, 7, 8, 2, 0, 0, 0, 2, 1, 1, 1, 2, 2, 1, 1, 6, 3, 4,};
    int myrow = 3;
    int index;
    int min [3] = {99, 99, 99};
    for (index = 0; index < 8; index++) {
        printf ("%d", piezas [myrow] [index]);
        int i, temp = piezas[myrow][index];
        for (i = 0; i < 3; ++i) {
            if (temp <= min[i]) {
                int wk = min[i];
                min[i] = temp;
                temp = wk;
            }
        }
        printf (" ");
    }
    printf ("min:");
    for (index = 0; index < 3; ++index)
        printf (" %d", min[index]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16532586_16533002_14_37
16532586_16534034_3_16
Title: "Sketch that responds to certain commands how is it done?" 
----------------------------------------

void loop () {
    unsigned long currentMillis = millis ();
    if (currentMillis - previousMillis > interval) {
        previousMillis = currentMillis;
        if (ledState == LOW)
            ledState = HIGH;
        else
            ledState = LOW;
        digitalWrite (ledPin, ledState);
    }
}
----------------------------------------

void loop () {
    if (checkForCorrectCommand () == true) {
        if (LED_State == false) {
            open_valve ();
            LED_State = true;
        }
        else {
            close_valve ();
            LED_State = false;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16532586_16533002_14_37
16532586_16537096_47_70
Title: "Sketch that responds to certain commands how is it done?" 
----------------------------------------

void loop () {
    unsigned long currentMillis = millis ();
    if (currentMillis - previousMillis > interval) {
        previousMillis = currentMillis;
        if (ledState == LOW)
            ledState = HIGH;
        else
            ledState = LOW;
        digitalWrite (ledPin, ledState);
    }
}
----------------------------------------

void loop () {
    if (stringComplete) {
        Serial.println (inputString);
        inputString = "";
        stringComplete = false;
    }
    if (inputString == "{blink_Flow_A}") {
        Timer1.attachInterupt (blinkCallback);
    }
    if (inputString == "{stop}") {
        Timer1.detachInterrupt ();
    }
    if (inputString == "{open_valve}") {
        open_valve ();
    }
    if (inputString == "{close_valve}") {
        close_valve ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16532586_16533002_14_37
16532586_19893013_39_48
Title: "Sketch that responds to certain commands how is it done?" 
----------------------------------------

void loop () {
    unsigned long currentMillis = millis ();
    if (currentMillis - previousMillis > interval) {
        previousMillis = currentMillis;
        if (ledState == LOW)
            ledState = HIGH;
        else
            ledState = LOW;
        digitalWrite (ledPin, ledState);
    }
}
----------------------------------------

void loop () {
    if (!stringComplete)
        return;
    if (inputString == "{blink_Flow_A}")
        flow_A_blink_start ();
    if (inputString == "{blink_Flow_B}")
        flow_A_blink_stop ();
    inputString = "";
    stringComplete = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16532586_16534034_3_16
16532586_16537096_47_70
Title: "Sketch that responds to certain commands how is it done?" 
----------------------------------------

void loop () {
    if (checkForCorrectCommand () == true) {
        if (LED_State == false) {
            open_valve ();
            LED_State = true;
        }
        else {
            close_valve ();
            LED_State = false;
        }
    }
}
----------------------------------------

void loop () {
    if (stringComplete) {
        Serial.println (inputString);
        inputString = "";
        stringComplete = false;
    }
    if (inputString == "{blink_Flow_A}") {
        Timer1.attachInterupt (blinkCallback);
    }
    if (inputString == "{stop}") {
        Timer1.detachInterrupt ();
    }
    if (inputString == "{open_valve}") {
        open_valve ();
    }
    if (inputString == "{close_valve}") {
        close_valve ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16532586_16534034_3_16
16532586_19893013_39_48
Title: "Sketch that responds to certain commands how is it done?" 
----------------------------------------

void loop () {
    if (checkForCorrectCommand () == true) {
        if (LED_State == false) {
            open_valve ();
            LED_State = true;
        }
        else {
            close_valve ();
            LED_State = false;
        }
    }
}
----------------------------------------

void loop () {
    if (!stringComplete)
        return;
    if (inputString == "{blink_Flow_A}")
        flow_A_blink_start ();
    if (inputString == "{blink_Flow_B}")
        flow_A_blink_stop ();
    inputString = "";
    stringComplete = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16532586_16537096_37_45
16532586_19893013_87_102
Title: "Sketch that responds to certain commands how is it done?" 
----------------------------------------

void serialEvent () {
    while (Serial.available ()) {
        char inChar = (char) Serial.read ();
        inputString += inChar;
        if (inChar == '\n') {
            stringComplete = true;
        }
    }
}
----------------------------------------

void serialEvent () {
    if (stringComplete)
        return;
    while (Serial.available ()) {
        char inChar = (char) Serial.read ();
        if (inChar != '\n')
            inputString += inChar;
        else {
            stringComplete = true;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16532586_16537096_47_70
16532586_19893013_39_48
Title: "Sketch that responds to certain commands how is it done?" 
----------------------------------------

void loop () {
    if (stringComplete) {
        Serial.println (inputString);
        inputString = "";
        stringComplete = false;
    }
    if (inputString == "{blink_Flow_A}") {
        Timer1.attachInterupt (blinkCallback);
    }
    if (inputString == "{stop}") {
        Timer1.detachInterrupt ();
    }
    if (inputString == "{open_valve}") {
        open_valve ();
    }
    if (inputString == "{close_valve}") {
        close_valve ();
    }
}
----------------------------------------

void loop () {
    if (!stringComplete)
        return;
    if (inputString == "{blink_Flow_A}")
        flow_A_blink_start ();
    if (inputString == "{blink_Flow_B}")
        flow_A_blink_stop ();
    inputString = "";
    stringComplete = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16537354_16537481_4_27
16537354_16537485_2_19
Title: I can't read data into an array 
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    FILE *data;
    if (argc < 2) {
        fprintf (stderr, "Missing arguments: %s\n", usage);
        exit (1);
    }
    data = fopen (argv[1], "r");
    if (data == NULL) {
        fprintf (stderr, " fopen ('%s') failed, errno = % d, argv [1], errno);
        exit (2);
    }
    .......fclose (data);
    return (0);
}
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    int j = 0;
    int aa [100];
    i = 0;
    FILE *data;
    data = fopen (argv[1], "r");
    while (!feof (data)) {
        fscanf (data, "%i", & aa [i]);
        i++;
    }
    i--;
    fclose (data);
    for (j; j < i; j++)
        printf ("%i\n", aa[j]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16540270_16540296_1_16
16540270_16540710_1_32
Title: copying a string to another string in C 
----------------------------------------

char *stringcopywithpointer (const char *source) {
    int ii = 0;
    int len = strlen (source);
    char *copy = malloc (len +1);
    char *dest = copy;
    while (*source != '\0') {
        *dest++ = *source++;
    }
    *dest = '\0';
    printf ("\n copied string = %s", copy);
    return copy;
}
----------------------------------------

char *stringcopywithpointer (const char *source) {
    int ii = 0;
    int len = strlen (source) + 1;
    char *ptr = NULL;
    char *dest = (char *) malloc (sizeof (char) * len);
    if (dest == NULL)
        return NULL;
    ptr = dest;
    while (*source != '\0') {
        *dest++ = *source++;
    }
    *dest = '\0';
    printf ("\n copied string = %s", ptr);
    return ptr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16579605_16579640_1_10
16579605_16585820_1_14
Title: Concatenation with 2 strings 
----------------------------------------

void str_cat_101 (char const input1 [], char const input2 [], char result []) {
    int i = 0, j = 0;
    while (input1[j])
        result[i++] = input1[j++];
    --i;
    j = 0;
    while (input2[j])
        result[i++] = input2[j++];
    result[i] = '\0';
}
----------------------------------------

void str_cat_101 (char const input1 [], char const input2 [], char result []) {
    int i, j;
    for (i = 0; input1[i] != '\0'; i++) {
        result[i] = input1[i];
    }
    for (j = 0; input2[j] != '\0'; j++) {
        result[i + j] = input2[j];
    }
    result[i + j] = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1658530_1658548_1_32
1658530_1658550_7_36
Title: Load numbers from text file in C 
----------------------------------------

int main (int argc, char *argv []) {
    int x = 1;
    char str [] = "this:is:a:test:of:string:tokenizing";
    char *str1;
    printf ("String: %s\n", str);
    str1 = strtok (str, ":");
    printf ("%i: %s\n", x, str1);
    while (1) {
        str1 = strtok (NULL, ":");
        if (str1 == NULL) {printf ("Tokenizing complete\n");
        exit (0);
    }
    printf ("%i: %s\n", x, str1);
    x++;
}
----------------------------------------

int main () {
    FILE *in_file;
    int middle;
    int low, high;
    int search;
    char line [80];
    in_file = fopen (DATA_FILE, "r");
    if (in_file == NULL) {
        fprintf (stderr, "Error:Unable to open %s\n", DATA_FILE);
        exit (8);
    }
    max_count = 0;
    while (1) {
        if (fgets (line, sizeof (line), in_file) == NULL)
            break;
        sscanf (line, "%d", & data [max_count]);
        ++max_count;
        return data;
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1658530_1658548_1_32
1658530_1658568_2_14
Title: Load numbers from text file in C 
----------------------------------------

int main (int argc, char *argv []) {
    int x = 1;
    char str [] = "this:is:a:test:of:string:tokenizing";
    char *str1;
    printf ("String: %s\n", str);
    str1 = strtok (str, ":");
    printf ("%i: %s\n", x, str1);
    while (1) {
        str1 = strtok (NULL, ":");
        if (str1 == NULL) {printf ("Tokenizing complete\n");
        exit (0);
    }
    printf ("%i: %s\n", x, str1);
    x++;
}
----------------------------------------

int main () {
    FILE *f = fopen ("test.txt", "r");
    int number = 0;
    int sum = 0;
    while (fscanf (f, "%d,", &number) > 0) {
        sum += number;
    }
    fclose (f);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1658530_1658548_1_32
1658530_18822514_2_16
Title: Load numbers from text file in C 
----------------------------------------

int main (int argc, char *argv []) {
    int x = 1;
    char str [] = "this:is:a:test:of:string:tokenizing";
    char *str1;
    printf ("String: %s\n", str);
    str1 = strtok (str, ":");
    printf ("%i: %s\n", x, str1);
    while (1) {
        str1 = strtok (NULL, ":");
        if (str1 == NULL) {printf ("Tokenizing complete\n");
        exit (0);
    }
    printf ("%i: %s\n", x, str1);
    x++;
}
----------------------------------------

int main () {
    char a;
    FILE *point;
    int i, b [4];
    point = fopen ("test.txt", "r");
    for (i = 0; i < 4; i++) {
        a = fgetc (point);
        b[i] = atoi (&a);
    }
    fclose (point);
    for (i = 0; i < 4; i++)
        printf ("%d\n", b[i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1658530_1658550_7_36
1658530_1658568_2_14
Title: Load numbers from text file in C 
----------------------------------------

int main () {
    FILE *in_file;
    int middle;
    int low, high;
    int search;
    char line [80];
    in_file = fopen (DATA_FILE, "r");
    if (in_file == NULL) {
        fprintf (stderr, "Error:Unable to open %s\n", DATA_FILE);
        exit (8);
    }
    max_count = 0;
    while (1) {
        if (fgets (line, sizeof (line), in_file) == NULL)
            break;
        sscanf (line, "%d", & data [max_count]);
        ++max_count;
        return data;
    }
    return (0);
}
----------------------------------------

int main () {
    FILE *f = fopen ("test.txt", "r");
    int number = 0;
    int sum = 0;
    while (fscanf (f, "%d,", &number) > 0) {
        sum += number;
    }
    fclose (f);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1658530_1658550_7_36
1658530_18822514_2_16
Title: Load numbers from text file in C 
----------------------------------------

int main () {
    FILE *in_file;
    int middle;
    int low, high;
    int search;
    char line [80];
    in_file = fopen (DATA_FILE, "r");
    if (in_file == NULL) {
        fprintf (stderr, "Error:Unable to open %s\n", DATA_FILE);
        exit (8);
    }
    max_count = 0;
    while (1) {
        if (fgets (line, sizeof (line), in_file) == NULL)
            break;
        sscanf (line, "%d", & data [max_count]);
        ++max_count;
        return data;
    }
    return (0);
}
----------------------------------------

int main () {
    char a;
    FILE *point;
    int i, b [4];
    point = fopen ("test.txt", "r");
    for (i = 0; i < 4; i++) {
        a = fgetc (point);
        b[i] = atoi (&a);
    }
    fclose (point);
    for (i = 0; i < 4; i++)
        printf ("%d\n", b[i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1658530_1658568_2_14
1658530_18822514_2_16
Title: Load numbers from text file in C 
----------------------------------------

int main () {
    FILE *f = fopen ("test.txt", "r");
    int number = 0;
    int sum = 0;
    while (fscanf (f, "%d,", &number) > 0) {
        sum += number;
    }
    fclose (f);
}
----------------------------------------

int main () {
    char a;
    FILE *point;
    int i, b [4];
    point = fopen ("test.txt", "r");
    for (i = 0; i < 4; i++) {
        a = fgetc (point);
        b[i] = atoi (&a);
    }
    fclose (point);
    for (i = 0; i < 4; i++)
        printf ("%d\n", b[i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16600172_16600273_25_62
16600172_16600506_13_30
Title: Seg fault (core dumped) after pthread_join in C 
----------------------------------------

int main (int argc, char *argv []) {
    int i, rc;
    int size = 10;
    pthread_t thread;
    void *res, *end;
    for (i = 0; i < size; i++) {
        array[i] = 0;
    }
    fillArrayData data;
    data.array = array;
    data.size = 10;
    rc = pthread_create (&thread, NULL, fillArray, &data);
    if (rc != 0) {
        perror ("Cannot create thread");
        exit (EXIT_FAILURE);
    }
    for (i = 0; i < size; i++) {
        if (array[i] != -1)
            printf ("%d ", array[i]);
    }
    printf ("\n");
    rc = pthread_join (thread, &end);
    if (rc != 0) {
        perror ("Cannot join thread");
        exit (EXIT_FAILURE);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    pthread_t threads [NUM_THREADS];
    int rc;
    long t;
    for (t = 0; t < NUM_THREADS; t++) {
        printf ("In main: creating thread %ld\n", t);
        rc = pthread_create (&threads[t], NULL, PrintHello, (void *) t);
        if (rc) {
            printf ("ERROR; return code from pthread_create() is %d\n", rc);
            exit (- 1);
        }
    }
    pthread_exit (NULL);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16600347_16602682_1_14
16600347_43852974_3_19
Title: C Binary Search Tree pre-order traversal with recursion 
----------------------------------------

tnode *bst_find_by_name (tnode *ptr, const char *nom) {
    if (ptr == NULL) {
        return NULL;
    }
    if (strcmp (ptr->name, nom) == 0) {
        return ptr;
    }
    return bst_find_by_name (ptr -> left, nom) || bst_find_by_name (ptr -> right, nom)
}
----------------------------------------

tnode *bst_find_by_name (tnode *ptr, const char *nom) {
    if (ptr == NULL) {
        return NULL;
    }
    if (strcmp (ptr->name, nom) == 0) {
        return ptr;
    }
    tnode *ptrtemp = bst_find_by_name (ptr->left, nom);
    if (!ptrtemp) {
        ptrtemp = bst_find_by_name (ptr->right, nom);
    }
    return ptrtemp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16603525_16624070_7_56
16603525_16686541_8_74
Title: I want to make splash screen and now I have two problems? 
----------------------------------------

int main () {
    Imlib_Image m_img;
    Display *m_dpy;
    Pixmap m_pix;
    Window m_root;
    Screen *scn;
    int m_width, m_height;
    const char *filename = "w.png";
    m_img = imlib_load_image (filename);
    if (!m_img) {
        printf ("%s\n", "init m_img faild");
    }
    imlib_context_set_image (m_img);
    m_width = imlib_image_get_width ();
    m_height = imlib_image_get_height ();
    m_dpy = XOpenDisplay (NULL);
    if (!m_dpy) {
        printf ("%s\n", "open display failed");
    }
    scn = DefaultScreenOfDisplay (m_dpy);
    int s = DefaultScreen (m_dpy);
    m_root = XCreateSimpleWindow (m_dpy, RootWindow (m_dpy, s), 10, 10, m_width, m_height, 0, BlackPixel (m_dpy, s), WhitePixel (m_dpy, s));
    m_pix = XCreatePixmap (m_dpy, m_root, m_width, m_height, DefaultDepthOfScreen (scn));
    Atom type = XInternAtom (m_dpy, "_NET_WM_WINDOW_TYPE", False);
    Atom value = XInternAtom (m_dpy, "_NET_WM_WINDOW_TYPE_SPLASH", False);
    XChangeProperty (m_dpy, m_root, type, XA_ATOM, 32, PropModeReplace, reinterpret_cast < unsigned char * > (& value), 1);
    imlib_context_set_display (m_dpy);
    imlib_context_set_visual (DefaultVisualOfScreen (scn));
    imlib_context_set_colormap (DefaultColormapOfScreen (scn));
    imlib_context_set_drawable (m_pix);
    imlib_render_image_on_drawable (0, 0);
    XSetWindowBackgroundPixmap (m_dpy, m_root, m_pix);
    XClearWindow (m_dpy, m_root);
    Atom wmDeleteMessage = XInternAtom (m_dpy, "WM_DELETE_WINDOW", False);
    XSetWMProtocols (m_dpy, m_root, & wmDeleteMessage, 1);
    XMapWindow (m_dpy, m_root);
    XFlush (m_dpy);
    sleep (5);
    XUnmapWindow (m_dpy, m_root);
}
----------------------------------------

int main (void) {
    Display *d;
    Window w;
    XEvent e;
    const char *msg = "Hello, World!";
    int s;
    bool done = false;
    d = XOpenDisplay (NULL);
    if (d == NULL) {
        fprintf (stderr, "Cannot open display\n");
        exit (1);
    }
    s = DefaultScreen (d);
    w = XCreateSimpleWindow (d, RootWindow (d, s), 10, 10, 480, 320, 0, BlackPixel (d, s), WhitePixel (d, s));
    Atom type = XInternAtom (d, "_NET_WM_WINDOW_TYPE", False);
    Atom value = XInternAtom (d, "_NET_WM_WINDOW_TYPE_SPLASH", False);
    XChangeProperty (d, w, type, XA_ATOM, 32, PropModeReplace, reinterpret_cast < unsigned char * > (& value), 1);
    Atom wmDeleteMessage = XInternAtom (d, "WM_DELETE_WINDOW", False);
    XSetWMProtocols (d, w, & wmDeleteMessage, 1);
    XSelectInput (d, w, ExposureMask | KeyPressMask | StructureNotifyMask);
    XMapWindow (d, w);
    while (!done) {
        XNextEvent (d, & e);
        if (e.type == Expose) {
            XDrawString (d, w, DefaultGC (d, s), 50, 50, msg, strlen (msg));
        }
        switch (e.type) {
        case KeyPress :
            XDestroyWindow (d, w);
            break;
        case DestroyNotify :
            done = true;
            break;
        case ClientMessage :
            if (e.xclient.data.l[0] == wmDeleteMessage) {
                done = true;
            }
            break;
        }
    }
    XCloseDisplay (d);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16639970_16640913_1_27
16639970_16641136_1_20
Title: longest common subsequence: why is this wrong? 
----------------------------------------

int lcs (char *A, char *B) {
    int length_a = strlen (A);
    int length_b = strlen (B);
    int longest_found_length = 0;
    char *candidate_substring = malloc (sizeof (char) * length_a + 1);
    for (int start_position = 0; start_position < length_a; start_position++) {
        for (int end_position = start_position; end_position < length_a; end_position++) {
            int substring_length = end_position - start_position + 1;
            strncpy (candidate_substring, & (A [start_position]), substring_length);
            if (strstr (B, candidate_substring) != NULL) {
                longest_found_length = substring_length;
            }
        }
    }
    free (candidate_substring);
    return longest_found_length;
}
----------------------------------------

int lcs (char *A, char *B) {
    int length_a = strlen (A);
    int length_b = strlen (B);
    int longest_length_found = 0;
    for (int a_index = 0; a_index < length_a - longest_length_found; a_index++) {
        for (int b_index = 0; b_index < length_b - longest_length_found; b_index++) {
            for (int offset = 0; A[a_index + offset] != '\0' && B[b_index + offset] != '\0' && A[a_index + offset] == B[b_index + offset]; offset++) {
                longest_length_found = longest_length_found > offset ? longest_length_found : offset;
            }
        }
    }
    return longest_found_length;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1664787_10879352_9_22
1664787_1664918_22_29
Title: Problem forking fork() multiple processes Unix 
----------------------------------------

int main (int argc, char *argv []) {
    if (argc < 2) {
        printf ("Usage: forktest <number_of_children>\n");
        printf ("Example: forktest 5 - spawns 5 children processes\n");
        return -1;
    }
    nChildren = atoi (argv[1]);
    myFork (nChildren - 1);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc < 2) {
        forkChildren (2);
    }
    else {
        forkChildren (atoi (argv [1]));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16675440_16675906_1_21
16675440_16678780_1_14
Title: Printing to output: integer as sum of powers of 2 
----------------------------------------

void powersum (int n) {
    int powers [sizeof (int) << 3];
    int i;
    char *sep = "";
    printf ("%d = ", n);
    powers[0] = 0;
    for (i = 0; n; n >>= 1, ++i)
        powers[i] = n & 1;
    while (--i >= 0) {
        if (powers[i]) {
            printf ("%s2^%d", sep, i);
            sep = " + ";
        }
    }
    printf ("\n");
}
----------------------------------------

void powersum (int n) {
    char *sep = "";
    printf ("%d = ", n);
    while (n) {
        int pos = 31 - __builtin_clz (n);
        printf ("%s2^%d", sep, pos);
        sep = " + ";
        n ^= 1 << pos;
    }
    printf ("\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16684950_16694481_3_33
16684950_16695840_3_16
Title: Print Array in required order 
----------------------------------------

int main () {
    char *str, *p1, *p2;
    int count = 0;
    str = "something";
    p1 = str;
    while (*(str + 1) != '\0')
        str++;
    p2 = str;
    while (*p1 != '\0') {
        if (p1 == p2)
            printf ("%c\n", *p1);
        if (p1 > p2) {
            while (p2 <= p1) {
                printf ("%c", * p2);
                p2++;
                count++;
            }
            p2 = p2 - (count);
            count = 0;
            printf ("\n");
        }
        p1++;
        p2--;
    }
}
----------------------------------------

int main () {
    char array [] = "something";
    char *str = array;
    int size = strlen (str);
    int i = size / 2;
    if (size % 2 == 0)
        i--;
    for (; i >= 0; i--) {
        char c = str[size - i];
        str[size - i] = '\0';
        printf ("%s\n", str + i);
        str[size - i] = c;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16712498_16712684_24_38
16712498_16713451_15_25
Title: strtok_r - get indicate when there is nothing between the delimiters 
----------------------------------------

int main (void) {
    char the_sting [] = "a|b||e|f";
    char *last;
    char *current;
    current = my_strtok_r (the_sting, "|", &last);
    while (current != NULL) {
        printf (current);
        printf ("\n");
        current = my_strtok_r (NULL, "|", &last);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char the_sting [] = "a|b||e|f";
    char *s, *p = the_sting;
    while (p) {
        s = scan (&p, '|');
        printf ("<%s>", s);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16719885_16719935_3_33
16719885_44253745_3_33
Title: Writing a program to find the largest in a series of numbers. 
----------------------------------------

int main (void) {
    float max = 0, a;
    do {
        printf ("Enter number:");
        if (scanf (" %f", &a) == 1) {
            if (a > max) {
                max = a;
            }
        }
    }
    while (a > 0);
    printf ("Largest non negative number: %f", max);
    return 0;
}
----------------------------------------

int main () {
    float enter_num, proc = 0;
    for (;;) {
        printf ("Enter the number:");
        scanf ("%f", & enter_num);
        if (enter_num == 0) {
            break;
        }
        if (enter_num < 0) {
            proc > enter_num;
            proc = enter_num;
        }
        if (proc < enter_num) {
            proc = enter_num;
        }
    }
    printf ("Largest number from the above is:%.1f", proc);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16721591_16724693_5_33
16721591_16746255_5_44
Title: A loop to pass a string to STD in 
----------------------------------------

int main (void) {
    int x;
    char buff [4096];
    FILE *fp;
    fp = fopen ("vectors.lst", "r");
    if (fp == NULL) {
        printf ("Failed to open\n");
        return 1;
    }
    printf ("search value: ");
    scanf ("%d", & x);
    while (fgets (buff, sizeof (buff), fp)) {
        char *p;
        p = strrchr (buff, ' ');
        if (atoi (p +1) == x) {
            *p = '\0';
            printf ("%s\n", buff);
            break;
        }
    }
    fclose (fp);
    return 0;
}
----------------------------------------

int main () {
    FILE *fp;
    fp = fopen ("vectors.lst", "r");
    if (fp == NULL) {
        printf ("Failed to open\n");
        return 1;
    }
    char passedstring [MAX_BUFFER + 1];
    passedstring[MAX_BUFFER] = 0;
    int correctvalue = 0;
    int position;
    position = 0;
    while (fscanf (fp, " (%" STRINGIZE (MAX_BUFFER) "[^)]) %d%n", passedstring, &correctvalue, &position) != EOF && position > 0) {
        printf ("%s, %d\n", passedstring, correctvalue);
        position = 0;
    }
    printf ("End %d", position);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16724368_40794484_1_11
16724368_44427895_1_12
Title: How to pass a 2D array by pointer in C? 
----------------------------------------

void printarray (void *array0, int SIZE) {
    char (*array) [SIZE] = array0;
    int i;
    int j;
    for (j = 0; j < SIZE; j++) {
        for (i = 0; i < SIZE; i++) {
            printf ("%c ", array [j] [i]);
        }
        printf ("\n");
    }
}
----------------------------------------

void printarray (char **array, int n) {
    int i, j;
    for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
            printf ("%c ", array [i] [j]);
        }
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16728680_16728722_1_19
16728680_16728939_1_15
Title: Why do I get - 'function' : not all control paths return a value in C 
----------------------------------------

int getline (char line [], int maxline) {
    int c, i;
    for (i = 0; i < maxline - 1 && (c = getchar ()) != EOF && c != '\n'; i++) {
        line[i] = c;
        if (c == '\n') {
            line[i] = c;
            ++i;
        }
        line[i] = '\0';
        return i;
    }
    return 0;
#return some appropriate value when doesn't enter in for loop.
}
----------------------------------------

int getline (char s [], int lim) {
    int c, i;
    for (i = 0; i < lim - 1 && (c = getchar ()) != EOF && c != '\n'; i++)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16728680_16728722_1_19
16728680_16728991_1_13
Title: Why do I get - 'function' : not all control paths return a value in C 
----------------------------------------

int getline (char line [], int maxline) {
    int c, i;
    for (i = 0; i < maxline - 1 && (c = getchar ()) != EOF && c != '\n'; i++) {
        line[i] = c;
        if (c == '\n') {
            line[i] = c;
            ++i;
        }
        line[i] = '\0';
        return i;
    }
    return 0;
#return some appropriate value when doesn't enter in for loop.
}
----------------------------------------

int getline (char line [], int maxline) {
    int i = 0, c;
    for (; i < maxline - 1 && (c = getchar ()) != EOF && c != '\n'; i++)
        line[i] = c;
    if (c == '\n')
        s[i++] = c;
    line[i] = '\0';
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16728680_16728939_1_15
16728680_16728991_1_13
Title: Why do I get - 'function' : not all control paths return a value in C 
----------------------------------------

int getline (char s [], int lim) {
    int c, i;
    for (i = 0; i < lim - 1 && (c = getchar ()) != EOF && c != '\n'; i++)
        s[i] = c;
    if (c == '\n') {
        s[i] = c;
        ++i;
    }
    s[i] = '\0';
    return i;
}
----------------------------------------

int getline (char line [], int maxline) {
    int i = 0, c;
    for (; i < maxline - 1 && (c = getchar ()) != EOF && c != '\n'; i++)
        line[i] = c;
    if (c == '\n')
        s[i++] = c;
    line[i] = '\0';
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16755028_16755062_7_20
16755028_16755820_7_39
Title: Unix Processes - compile and run c program 
----------------------------------------

int main () {
    pid_t pid = fork ();
    if (pid == 0) {
        static char *argv [] = {"echo", "Foo is my name.", NULL};
        execv ("/bin/echo", argv);
        exit (127);
    }
    else {
        waitpid (pid, 0, 0);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int p;
    if (argc != 6) {
        fprintf (stderr, "Usage: %s source program file1 file2 file3\n", argv [0]);
        return (1);
    }
    if ((p = fork ()) == 0) {
        char com [200];
        snprintf (com, sizeof (com), "gcc -o %s %s", argv [2], argv [1]);
        if (system (com) == 0) {
            printf ("Compilation of %s successful\n", argv [2]);
            fflush (0);
            execl (argv [2], argv [2], argv [3], argv [4], argv [5], (char *) NULL);
            fprintf (stderr, "Failed to execute %s\n", argv [2]);
            return (1);
        }
        fprintf (stderr, "Compilation of %s from %s failed\n", argv [2], argv [1]);
        return (1);
    }
    int status;
    wait (& status);
    printf ("Compilation and execution of %s yielded status %d\n", argv [2], WEXITSTATUS (status));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16770040_16770663_23_41
16770040_16770695_10_57
Title: C - Increment a number within a char 
----------------------------------------

int main (void) {
    char *someString = "A0001";
    char *label_x2, *label_x3;
    label_x2 = strinc (someString, +1, 4);
    printf ("%s\n", label_x2);
    label_x3 = strinc (label_x2, +1, 4);
    printf ("%s\n", label_x3);
    free (label_x2);
    label_x2 = strinc ("A0008", +5, 4);
    printf ("%s\n", label_x2);
    free (label_x3);
    label_x3 = strinc (label_x2, -8, 4);
    printf ("%s\n", label_x3);
    free (label_x2);
    free (label_x3);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char someString [] = "A0001";
    char *start = someString;
    char *end = start + strlen (someString);
    char *endOfParse;
    char c;
    unsigned long num;
    ptrdiff_t numDigits;
    while (true) {
        c = *start;
        if (c == '\0' || isdigit (c))
            break;
        ++start;
    }
    if (c == '\0') {
        printf ("Error: didn't find any numerical characters\n");
        exit (EXIT_FAILURE);
    }
    num = strtoul (start, &endOfParse, 0);
    if (endOfParse < end) {
        printf ("Error: Failed to parse the numerical portion of the string\n");
        exit (EXIT_FAILURE);
    }
    numDigits = end - start;
    num = num + 1;
    snprintf (start, numDigits + 1, "%0*u", numDigits, num);
    printf ("Result is %s\n", someString);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1677827_1677843_3_14
1677827_1677844_6_15
Title: Returning Multiple Values from a Function 
----------------------------------------

ReturnType EndOfTurn (int varTurns, int varFatness) {
    ReturnType foo;
    foo.turns = varTurns - 1;
    if (foo.turns <= 0) {
        foo.fatness = varFatness - 5;
    }
    else {
        foo.fatness = varFatness + 2;
    }
    return foo;
}
----------------------------------------

void EndOfTurn (struct turn_state *state) {
    state->varTurns--;
    if (state->varTurns <= 0) {
        state->varFatness -= 5;
    }
    else {
        state->varFatness += 2;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16790227_16791021_1_24
16790227_33356585_6_23
Title: Replace multiple spaces by single space in C 
----------------------------------------

void main () {
    char input [100];
    int i = 0, j, n = 0;
    while ((input[n] = getchar ()) != '\n') {
        n++;
    }
    input[n] = '\0';
    while (i < n) {
        if (input[i] == ' ' && (input[i + 1] == ' ' || input[i - 1] == ' ')) {
            for (j = i; j < n; j++)
                input[j] = input[j + 1];
            n--;
        }
        else {
            i++;
        }
    }
    printf ("%s\n", input);
    printf ("\n");
}
----------------------------------------

int main (void) {
    char *pch;
    char sentence [1000];
    char without [1000];
    printf ("Sentence: ");
    fgets (sentence, 1000, stdin);
    strtok (sentence, "\n");
    pch = strtok (sentence, " ");
    while (pch != NULL) {
        strcat (without, pch);
        strcat (without, " \0");
        pch = strtok (NULL, " ");
    }
    without[strlen (without) - 1] = '\0';
    printf ("|%s|\n", without);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16790227_16791021_1_24
16790227_36449389_3_14
Title: Replace multiple spaces by single space in C 
----------------------------------------

void main () {
    char input [100];
    int i = 0, j, n = 0;
    while ((input[n] = getchar ()) != '\n') {
        n++;
    }
    input[n] = '\0';
    while (i < n) {
        if (input[i] == ' ' && (input[i + 1] == ' ' || input[i - 1] == ' ')) {
            for (j = i; j < n; j++)
                input[j] = input[j + 1];
            n--;
        }
        else {
            i++;
        }
    }
    printf ("%s\n", input);
    printf ("\n");
}
----------------------------------------

int main (void) {
    char input [1000];
    int i = 0;
    gets (input);
    for (i = 0; input[i] != '\0'; i++) {
        if (input[i] != ' ' || input[i + 1] != ' ')
            printf ("%c", input[i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16790227_16791021_1_24
16790227_46567792_6_26
Title: Replace multiple spaces by single space in C 
----------------------------------------

void main () {
    char input [100];
    int i = 0, j, n = 0;
    while ((input[n] = getchar ()) != '\n') {
        n++;
    }
    input[n] = '\0';
    while (i < n) {
        if (input[i] == ' ' && (input[i + 1] == ' ' || input[i - 1] == ' ')) {
            for (j = i; j < n; j++)
                input[j] = input[j + 1];
            n--;
        }
        else {
            i++;
        }
    }
    printf ("%s\n", input);
    printf ("\n");
}
----------------------------------------

int main () {
    int c, spaces, state;
    spaces = 0;
    state = OUT;
    while ((c = getchar ()) != EOF) {
        if (c == ' ') {
            ++spaces;
            state = OUT;
        }
        else if (state == OUT) {
            state = IN;
            spaces = 0;
        }
        if (c == ' ' && spaces > 1 && state == OUT)
            c = 0;
        putchar (c);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16790227_33356585_6_23
16790227_36449389_3_14
Title: Replace multiple spaces by single space in C 
----------------------------------------

int main (void) {
    char *pch;
    char sentence [1000];
    char without [1000];
    printf ("Sentence: ");
    fgets (sentence, 1000, stdin);
    strtok (sentence, "\n");
    pch = strtok (sentence, " ");
    while (pch != NULL) {
        strcat (without, pch);
        strcat (without, " \0");
        pch = strtok (NULL, " ");
    }
    without[strlen (without) - 1] = '\0';
    printf ("|%s|\n", without);
    return 0;
}
----------------------------------------

int main (void) {
    char input [1000];
    int i = 0;
    gets (input);
    for (i = 0; input[i] != '\0'; i++) {
        if (input[i] != ' ' || input[i + 1] != ' ')
            printf ("%c", input[i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16790227_33356585_6_23
16790227_46567792_6_26
Title: Replace multiple spaces by single space in C 
----------------------------------------

int main (void) {
    char *pch;
    char sentence [1000];
    char without [1000];
    printf ("Sentence: ");
    fgets (sentence, 1000, stdin);
    strtok (sentence, "\n");
    pch = strtok (sentence, " ");
    while (pch != NULL) {
        strcat (without, pch);
        strcat (without, " \0");
        pch = strtok (NULL, " ");
    }
    without[strlen (without) - 1] = '\0';
    printf ("|%s|\n", without);
    return 0;
}
----------------------------------------

int main () {
    int c, spaces, state;
    spaces = 0;
    state = OUT;
    while ((c = getchar ()) != EOF) {
        if (c == ' ') {
            ++spaces;
            state = OUT;
        }
        else if (state == OUT) {
            state = IN;
            spaces = 0;
        }
        if (c == ' ' && spaces > 1 && state == OUT)
            c = 0;
        putchar (c);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16790227_36449389_3_14
16790227_46567792_6_26
Title: Replace multiple spaces by single space in C 
----------------------------------------

int main (void) {
    char input [1000];
    int i = 0;
    gets (input);
    for (i = 0; input[i] != '\0'; i++) {
        if (input[i] != ' ' || input[i + 1] != ' ')
            printf ("%c", input[i]);
    }
    return 0;
}
----------------------------------------

int main () {
    int c, spaces, state;
    spaces = 0;
    state = OUT;
    while ((c = getchar ()) != EOF) {
        if (c == ' ') {
            ++spaces;
            state = OUT;
        }
        else if (state == OUT) {
            state = IN;
            spaces = 0;
        }
        if (c == ' ' && spaces > 1 && state == OUT)
            c = 0;
        putchar (c);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16797489_16798393_3_31
16797489_16798567_3_28
Title: palindrome of number in C 
----------------------------------------

int main (void) {
    int rev = 0, temp = 0, frwd, n, ans = 0;
    int i, j;
    for (i = 100; i <= 999; i++) {
        for (j = 0; j <= 999; j++) {
            rev = 0;
            n = (i * 1000) + j;
            frwd = n;
            while (n != 0) {
                temp = n % 10;
                n = n / 10;
                rev = temp + rev * 10;
            }
            printf ("\n%d", rev);
            if ((rev == frwd) && (ans < frwd)) {
                ans = frwd;
            }
        }
    }
    printf ("\n%d", ans);
    return (0);
}
----------------------------------------

int main (void) {
    int rev = 0, temp = 0, frwd, n, ans = 0;
    int i, j;
    for (i = 100000; i <= 999999; i++) {
        frwd = n = i;
        rev = 0;
        while (n != 0) {
            temp = n % 10;
            n = n / 10;
            rev = temp + rev * 10;
        }
        if ((rev == frwd) && (ans < frwd)) {
            ans = frwd;
        }
    }
    printf ("%d\n", ans);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16797489_16798567_3_28
16797489_33517493_3_31
Title: palindrome of number in C 
----------------------------------------

int main (void) {
    int rev = 0, temp = 0, frwd, n, ans = 0;
    int i, j;
    for (i = 100000; i <= 999999; i++) {
        frwd = n = i;
        rev = 0;
        while (n != 0) {
            temp = n % 10;
            n = n / 10;
            rev = temp + rev * 10;
        }
        if ((rev == frwd) && (ans < frwd)) {
            ans = frwd;
        }
    }
    printf ("%d\n", ans);
    return (0);
}
----------------------------------------

int main (void) {
    int rev = 0, temp = 0, frwd, n, ans = 0;
    int i, j;
    for (i = 100; i <= 999; i++) {
        for (j = 0; j <= 999; j++) {
            rev = 0;
            n = (i * 1000) + j;
            frwd = n;
            while (n != 0) {
                temp = n % 10;
                n = n / 10;
                rev = temp + rev * 10;
            }
            printf ("\n%d", rev);
            if ((rev == frwd) && (ans < frwd)) {
                ans = frwd;
            }
        }
    }
    printf ("\n%d", ans);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16803126_16803756_28_43
16803126_16803829_25_34
Title: Generate Binary Sequence 
----------------------------------------

int main () {
    const int maxLength = 5;
    char buffer [maxLength + 1];
    buffer[maxLength] = 0;
    int ones;
    for (ones = 0; ones <= maxLength; ones++) {
        printf ("Ones: %i\n", ones);
        recurse (buffer, 0, maxLength, ones);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n = 5;
    buf = malloc (n +1);
    for (int m = 0; m <= n; m++) {
        print_combinations (buf, n, m);
        printf ("-----\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16827959_16827998_1_24
16827959_16828632_6_33
Title: "C program Reversing an array" 
----------------------------------------

int main (void) {
    int count;
    int MAX_SIZE = 20;
    int c;
    char arr [MAX_SIZE];
    char revArr [MAX_SIZE];
    c = getchar ();
    count = 0;
    while (c != EOF) {
        if (c != '\n') {
            arr[count++] = c;
            c = getchar ();
            continue;
        }
        arr[count] = '\0';
        getReverse (revArr, arr);
        printf ("'%s' => '%s'\n", arr, revArr);
        count = 0;
        c = getchar ();
    }
    return 0;
}
----------------------------------------

int main () {
    int count = 0;
    const int MaxLen = 20;
    const int MaxSize = MaxLen + 1;
    int c = '\0';
    char arr [MaxSize] = {0};
    char revArr [MaxSize] = {0};
    do {
        c = fgetc (stdin);
        if (c != EOF && (isalpha (c) || isdigit (c))) {
            arr[count++] = (char) c;
        }
    }
    while (c != EOF && c != '\n' && count < MaxLen);
    getReverse (revArr, arr, count);
    printf ("%s\n", revArr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16828134_16828159_1_16
16828134_16831412_1_13
Title: Why does my program not work for counting the words in a string? 
----------------------------------------

int words_in_string (char str []) {
    int spaces = 0, num_words;
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == ' ') {
            spaces = spaces + 1;
        }
    }
    num_words = spaces + 1;
    return num_words;
}
----------------------------------------

int words_in_string (const char *str) {
    int in_word = 0, num_words = 0;
    while (*str) {
        if (isspace (*str++))
            in_word = 0;
        else {
            if (in_word == 0)
                ++num_words;
            in_word = 1;
        }
    }
    return num_words;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1682996_1683007_4_19
1682996_38964913_3_18
Title: Bytes to Binary in C 
----------------------------------------

int main (void) {
    int i;
    char bits [CHAR_BIT + 1];
    unsigned char value = 47;
    for (i = CHAR_BIT - 1; i >= 0; i -= 1) {
        bits[i] = '0' + (value & 0x01);
        value >>= 1;
    }
    bits[CHAR_BIT] = 0;
    puts (bits);
    return 0;
}
----------------------------------------

void main (void) {
    unsigned char byte = 49;
    unsigned char mask = 1;
    unsigned char bits [8];
    int i, j = CHAR_BIT - 1;
    for (i = 0; i < 8; i++, j--, mask = 1) {
        bits[i] = (byte & (mask <<= j)) != NULL;
    }
    for (int i = 0; i < 8; i++) {
        printf ("%d", bits [i]);
    }
    puts ("");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1688034_1688078_1_15
1688034_1688154_4_24
Title: Question regarding de-referencing structure pointers 
----------------------------------------

void main () {
    struct x {
        int xx;
        char *y;
        int *num;
        struct x *next;
    } x;
    struct x *temp;
    int b = 10;
    temp = ((struct x *) malloc (sizeof (struct x)));
    (*temp).num = &b;
    x.next = temp;
    printf ("%d %d\n", * temp -> num, * x.next -> num);
}
----------------------------------------

int main (void) {
    int b = 10;
    typedef struct x_struct {
        int xx;
        char *y;
        int *num;
        struct x_struct *next;
    } x;
    x *temp = malloc (sizeof (*temp));
    if (!temp) {
        return EXIT_FAILURE;
    }
    temp->num = &b;
    temp->next = temp;
    printf ("%d %d\n", * (temp -> num), * (temp -> next -> num));
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16885547_16885576_1_11
16885547_16887865_1_13
Title: pointer/integer type mismatch in a conditional expression 
----------------------------------------

int frequency (const char *s, char c) {
    int i;
    for (i = 0;
    s[i];
    ) if s [i] == c i ++;
    else
        s++;
    return i;
}
----------------------------------------

int frequency (char s [], char c) {
    int count = 0;
    int current = 0;
    while (s[current] != 0) {
        if (s[current] == c) {
            count++;
        }
        current++;
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16891524_16895022_7_30
16891524_17318388_2_16
Title: Sieve of Erastothenes 
----------------------------------------

int main () {
    bool is_prime [max];
    int i, int1, j, n;
    int1 = sqrt (max);
    for (n = 0; n < max; ++n) {
        is_prime[n] = true;
    }
    is_prime[0] = false;
    is_prime[1] = false;
    for (i = 2; i < int1; i++) {
        if (is_prime[i])
            for (j = i + i; j < max; j += i) {
                is_prime[j] = false;
            }
    }
    for (n = 2; n < max; ++n) {
        if (is_prime[n] == true)
            printf ("%d ", n);
    }
    return 0;
}
----------------------------------------

int main () {
    arr[0] = arr[1] = 1;
    for (int i = 4; i < 1000001; i += 2)
        arr[i] = 1;
    for (int i = 3; i < 1000001; i += 2) {
        if (!arr[i])
            for (int j = 2; i * j < 1000001; j++) {
                arr[i * j] = 1;
            }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16912164_16912812_3_21
16912164_16914140_3_23
Title: Return values with sscanf 
----------------------------------------

int main (void) {
    char buff [] = "Parameters: 43 VALUES FROM 0000:0000 (043)\n" "Name_8:(Temp=21.45,Hum=45.65,AR=9.34,Volt=3.46V)";
    int tag;
    float Temp, Hum, AR, Volt;
    int n;
    n = sscanf (buff, "Parameters: %*d VALUES FROM %*d:%*d (%d) " "Name_%*d:(Temp=%f,Hum=%f,AR=%f,Volt=%fV)", &tag, &Temp, &Hum, &AR, &Volt);
    if (n == 5) {
        printf ("tag = %d, Temp = %f, Hum = %f, AR = %f, Volt = %f\n", tag, Temp, Hum, AR, Volt);
    }
    else {
        printf ("Couldn't scan all items (converted %d).\n", n);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char buff [] = "Parameters: 43 VALUES FROM 0000:0000 (043)\n" "Name_8:(Temp=21.45,Hum=45.65,AR=9.34,Volt=3.46V)";
    char dev [25], temp [25], hum [25], ar [25], volt [25];
    int pos = 0, len;
    sscanf (buff, "%*[^(](%[^)])%n", dev, & len);
    pos += len;
    sscanf (buff + pos, "%*[^(](Temp=%[^,],%n", temp, & len);
    pos += len;
    sscanf (buff + pos, "Hum=%[^,],%n", hum, & len);
    pos += len;
    sscanf (buff + pos, "AR=%[^,],%n", ar, & len);
    pos += len;
    sscanf (buff + pos, "Volt=%[^V]V%n", volt, & len);
    printf ("dev:%s\n", dev);
    printf ("temp:%s\n", temp);
    printf ("hum:%s\n", hum);
    printf ("ar:%s\n", ar);
    printf ("volt:%s\n", volt);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16919909_16920038_3_18
16919909_16921280_3_16
Title: replace multiple blanks with one blank in C 
----------------------------------------

int main (void) {
    int c, d;
    d = 0;
    while ((c = getchar ()) != EOF) {
        if (c == ' ') {
            while ((d = getchar ()) == ' ')
                ;
            putchar (c);
            putchar (d);
        }
        else {
            putchar (c);
        }
    }
}
----------------------------------------

int main (void) {
    int lastBlank = 0;
    int c;
    while ((c = fgetc (stdin)) != EOF) {
        if (c != ' ' || !lastBlank)
            fputc (c, stdout);
        lastBlank = (c == ' ');
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16919909_16920038_3_18
16919909_40460028_3_21
Title: replace multiple blanks with one blank in C 
----------------------------------------

int main (void) {
    int c, d;
    d = 0;
    while ((c = getchar ()) != EOF) {
        if (c == ' ') {
            while ((d = getchar ()) == ' ')
                ;
            putchar (c);
            putchar (d);
        }
        else {
            putchar (c);
        }
    }
}
----------------------------------------

int main () {
    int c, n;
    n = 0;
    while ((c = getchar ()) != EOF) {
        if (c == '\t') {
            if (n < 1) {
                putchar ('\t');
                n = n + 1;
            }
        }
        else {
            n = 0;
            putchar (c);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16919909_16921280_3_16
16919909_40460028_3_21
Title: replace multiple blanks with one blank in C 
----------------------------------------

int main (void) {
    int lastBlank = 0;
    int c;
    while ((c = fgetc (stdin)) != EOF) {
        if (c != ' ' || !lastBlank)
            fputc (c, stdout);
        lastBlank = (c == ' ');
    }
    return 0;
}
----------------------------------------

int main () {
    int c, n;
    n = 0;
    while ((c = getchar ()) != EOF) {
        if (c == '\t') {
            if (n < 1) {
                putchar ('\t');
                n = n + 1;
            }
        }
        else {
            n = 0;
            putchar (c);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16922878_16922980_1_12
16922878_16923159_1_12
Title: Refactoring with the ternary operator in C 
----------------------------------------

bool check_bounds (double *score, int size) {
    bool is_valid = false;
    for (int i = 0; i < size; i++) {
        if (score[i] < 0.0 || score[i] > 100.0) {
            is_valid = true;
        }
    }
    return is_valid;
}
----------------------------------------

bool check_bounds (double *score, int size) {
    bool is_valid;
    for (int i = 0; i < size; i++) {
        is_valid = (score[i] < 0.0 || score[i] > 100.0) ? true : false;
        if (!is_valid)
            break;
    }
    return is_valid;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1692814_1692838_18_30
1692814_1692864_10_27
Title: Exception Handling in C - What is the use of setjmp() returning 0? 
----------------------------------------

int main () {
    if (!setjmp (buf)) {
        first ();
    }
    else {
        printf ("main");
    }
    return 0;
}
----------------------------------------

int main () {
    char *data = 0;
    int res = setjmp (env);
    printf ("setjmp returned %d\n", res);
    if (res == 0)
        foo (&data);
    else
        handle (data);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1692814_1692838_18_30
1692814_38957483_10_33
Title: Exception Handling in C - What is the use of setjmp() returning 0? 
----------------------------------------

int main () {
    if (!setjmp (buf)) {
        first ();
    }
    else {
        printf ("main");
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *data = 0;
    switch (setjmp (env)) {
    case 0 :
        {
            printf ("setjmp returned 0\n");
            foo (& data);
            break;
        }
    case 42 :
        {
            printf ("setjmp returned 42\n");
            handle (data);
            break;
        }
    default :
        {
            printf ("setjmp returned something else?\n");
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1692814_1692864_10_27
1692814_38957483_10_33
Title: Exception Handling in C - What is the use of setjmp() returning 0? 
----------------------------------------

int main () {
    char *data = 0;
    int res = setjmp (env);
    printf ("setjmp returned %d\n", res);
    if (res == 0)
        foo (&data);
    else
        handle (data);
    return 0;
}
----------------------------------------

int main (void) {
    char *data = 0;
    switch (setjmp (env)) {
    case 0 :
        {
            printf ("setjmp returned 0\n");
            foo (& data);
            break;
        }
    case 42 :
        {
            printf ("setjmp returned 42\n");
            handle (data);
            break;
        }
    default :
        {
            printf ("setjmp returned something else?\n");
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16936116_16936225_3_20
16936116_16936724_7_18
Title: How to convert a hexadecimal to byte array in C 
----------------------------------------

int main () {
    const char *input = "ff:ff:fe:ff";
    unsigned int array [4];
    int ret;
    ret = sscanf (input, "%02x:%02x:%02x:%02x", &array[0], &array[1], &array[2], &array[3]);
    if (ret != 4) {
        printf ("Match failed.\n");
        return -1;
    }
    printf ("array = { %02x, %02x, %02x, %02x }\n", array [0], array [1], array [2], array [3]);
    return 0;
}
----------------------------------------

int main (void) {
    const char *ptr = "ff:ff:fe:ff";
    size_t size = (strlen (ptr) + 1) / 3;
    unsigned char byte [size];
    int i;
    for (i = 0; i < size; ++i) {
        byte[i] = h2i (ptr[i * 3]) * 16 + h2i (ptr[i * 3 + 1]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16955962_16956139_12_24
16955962_16959956_18_30
Title: incompatible pointer type in c pointers 
----------------------------------------

int main () {
    struct node *head;
    head = NULL;
    insert (& head, 5);
    insert (& head, 4);
    insert (& head, 6);
    print (& head);
    print (& head);
    print (& head);
}
----------------------------------------

int main (void) {
    node_t head = node_init ();
    node_append (head, 5);
    node_append (head, 4);
    node_append (head, 6);
    node_print (head);
    node_drop_last (head);
    node_print (head);
    node_fini (head);
    head = NULL;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16957728_16957795_1_19
16957728_16957849_1_16
Title: linked list program to insert and delete nodes 
----------------------------------------

void insert () {
    struct node *nn = malloc (sizeof (*nn));
    if (nn == NULL) {
    }
    printf ("enter  the data\n");
    scanf ("%d", & nn -> data);
    nn->next = NULL;
    if (first == NULL) {
        first = nn;
    }
    else {
        struct node *temp = first;
        while (temp->next != NULL)
            temp = temp->next;
        temp->next = nn;
    }
}
----------------------------------------

void insert () {
    struct node *temp;
    struct node *nn = (struct node *) malloc (sizeof (struct node));
    printf ("enter  the data\n");
    scanf ("%d", & nn -> data);
    if (first != NULL) {
        temp = first;
        while (temp->next != first)
            temp = temp->next;
        temp->next = nn;
    }
    else {
        first = nn;
    }
    nn->next = NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16975943_16976012_1_20
16975943_16976092_3_17
Title: How do I get rid of the spaces in the string? 
----------------------------------------

void deblank (char str1 [], char str2 []) {
    int i, j;
    for (i = 0, j = 0; str1[i] != '\0'; i++, j++) {
        if (str1[i] == ' ') {
            i++;
            str2[j] = str1[i];
        }
        else {
            str2[j] = str1[i];
        }
    }
    str2[j] = '\0';
}
----------------------------------------

void deblank (char str1 [], char str2 []) {
    int i, j = 0;
    for (i = 0; str1[i] != '\0'; i++) {
        if (str1[i] != ' ') {
            str2[j] = str1[i];
            j++;
        }
    }
    str2[i] = '\0';
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16989689_21850708_6_15
16989689_26286340_14_54
Title: Print all the permutations of a string in C 
----------------------------------------

private static void permutation (String prefix, String str) {
    int n = str.length ();
    if (n == 0) {
        System.out.println (prefix);
    }
    else {
        for (int i = 0; i < n; i++)
            permutation (prefix +str.charAt (i), str.substring (0, i) + str.substring (i +1, n));
    }
}
----------------------------------------

void permutation (int cnum) {
    int mid;
    int flag = 1;
    int giga = 0;
    int dead = 0;
    int array [50];
    for (int i = 0; i < len - 1; i++) {
        array[50] = '\0';
        dead = 0;
        for (int j = cnum; j < len + cnum; j++) {
            mid = j % len;
            if (mid == cnum && flag == 1) {
                cout << str[mid];
                array[dead] = mid;
                dead++;
                flag = 0;
            }
            else {
                giga = (i + j) % len;
                for (int k = 0; k < dead; k++) {
                    if ((array[k] == giga) && flag == 0) {
                        giga = (giga + 1) % len;
                    }
                }
                cout << str[giga];
                array[dead] = giga;
                dead++;
            }
        }
        cout << endl;
        flag = 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16998039_16998149_36_61
16998039_16998280_3_17
Title: How to get range like this in an array using C/C++? 
----------------------------------------

int main () {
    double t [10] = {0.0, 0.01, 0.02, 0.03, 5.04, 6.05, 7.06, 13.07, 20.08, 22.09};
    struct range result [10];
    size_t i;
    size_t size = getRanges (result, t, sizeof t / sizeof *t);
    for (i = 0; i < size; i++) {
        printf ("%.2f\t%.2f\n", t [result [i].start], t [result [i].end]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    float f, a [] = {0.0, 0.01, 0.02, 0.03, 5.04, 6.05, 7.06, 13.07, 20.08, 22.09};
    size_t i;
    for (f = a[0], i = 0; i <= N; i++) {
        if (i == N || a[i] > f + 5.0) {
            printf ("%f %f\n", f, a [i - 1]);
            if (i != N)
                f = a[i];
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17006745_17006834_11_24
17006745_17007651_1_9
Title: prime factorization using sieve method 
----------------------------------------

void prime (void) {
    long i, j;
    pflags[0] = 1;
    pflags[1] = 1;
    for (i = 2; i <= sqrt (SIZE); i++)
        if (pflags[i] == 0)
            for (j = 2; j * i < SIZE; j++)
                pflags[i * j] = 1;
    j = 0;
    for (i = 0; i < SIZE; i++) {
        if (pflags[i] == 0)
            pvalues[j++] = i;
    }
}
----------------------------------------

void prime (void) {
    long i, j;
    p[0] = 1;
    p[1] = 1;
    for (i = 2; i <= (long) sqrt ((double) SIZE); i++)
        if (p[i] == 0)
            for (j = 2; j * i < SIZE; j++)
                p[i * j] = 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17006745_17006834_25_47
17006745_17007651_11_26
Title: prime factorization using sieve method 
----------------------------------------

void primeFactorize (long n) {
    listSize = 0;
    long sqrtN = long (sqrt (n));
    for (long i = 0; pvalues[i] <= sqrtN; i++) {
        if (n % pvalues[i] == 0) {
            while (n % pvalues[i] == 0) {
                n /= pvalues[i];
                List[listSize] = pvalues[i];
                listSize++;
            }
        }
    }
    if (n > 1) {
        List[listSize] = n;
        listSize++;
    }
}
----------------------------------------

void primeFactorize (long n) {
    listSize = 0;
    long sqrtN = (long) sqrt ((double) n);
    for (long i = 2; i <= sqrtN; i++) {
        while (n % i == 0) {
            n /= i;
            List[listSize] = i;
            listSize++;
        }
    }
    if (n > 1) {
        List[listSize] = n;
        listSize++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1701055_1701142_6_15
1701055_1702165_4_21
Title: What is the maximum length in chars needed to represent any double value? 
----------------------------------------

int main () {
    double x = std : : numeric_limits < double > : : max ();
std :
    : stringstream ss;
    ss << std : : setprecision (10) << std : : fixed << x;
std :
    : string double_as_string = ss.str ();
std :
    : cout << double_as_string.length () << std : : endl;
}
----------------------------------------

int main (void) {
    char dummy [1];
    double value = 42.000042;
    int siz;
    char *representation;
    siz = snprintf (dummy, sizeof dummy, "%f", value);
    printf ("exact length needed to represent 'value' " "(without the '\\0' terminator) is %d.\n", siz);
    representation = malloc (siz +1);
    if (representation) {
        sprintf (representation, "%f", value);
        free (representation);
    }
    else {
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17016975_17016989_4_13
17016975_17025007_4_16
Title: Runtime error while doing string concatenation 
----------------------------------------

int main (void) {
    char *str1 = "United";
    char *str2 = "Front";
    char str3 [64];
    strcpy (str3, str1);
    strcat (str3, str2);
    printf ("%s\n", str3);
    return (0);
}
----------------------------------------

int main (void) {
    char *str1 = "Hello,";
    char *str2 = " World";
    char str3 [30];
    strcpy (str3, str1);
    strcat (str3, str2);
    printf ("%s\n", str3);
    printf ("\n\n\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17030870_17031270_6_32
17030870_17031323_21_38
Title: Convert Char* to array of Char* 
----------------------------------------

int main () {
    int size = 10;
    int i = 0;
    char str [] = "echo Hello World";
    char **strings = malloc (size * sizeof (char *));
    char *temp;
    printf ("Splitting string \"%s\" into tokens:\n", str);
    temp = strtok (str, " ");
    while (temp != NULL) {
        strings[i++] = temp;
        temp = strtok (NULL, " ,.-");
        if (i % size == 0)
            strings = realloc (strings, (i + size) * sizeof (char *));
    }
    int j;
    for (j = 0; j < i; j++) {
        printf ("%s\n", strings [j]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char original [] = "echo Hello World";
    size_t i, size = word_count (original);
    char *p, **words = (char **) malloc (sizeof (char *) * size);
    for (i = 0, p = original; NULL != (p = strtok (p, " \t\n")); p = NULL)
        words[i++] = p;
    printf ("{ ");
    for (i = 0; i < size; ++i) {
        printf ("\"%s\"", words [i]);
        if (i < size - 1)
            printf (", ");
    }
    printf (" }\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17040914_17049266_26_53
17040914_17050767_3_59
Title: How do I extract operators from a char array? 
----------------------------------------

int main (void) {
    int vals [] = {12, 3, 4}, vali = 0, opi;
    char ops [] = {'+', '*', 0}, op_hold = 0;
    int stack [3], sp = -1;
    int result = 0;
    stack[++sp] = vals[vali++];
    for (opi = 0; ops[opi]; ++opi) {
        stack[++sp] = vals[vali++];
        if (ops[opi] == '+' || ops[opi] == '-') {
            if (ops[opi + 1] == '*' || ops[opi + 1] == '/') {
                op_hold = ops[opi];
            }
            else {
                calc (ops [opi], stack, & sp);
            }
        }
        else if (ops[opi] == '*' || ops[opi] == '/') {
            calc (ops [opi], stack, & sp);
            if (ops[opi + 1] != '*' && ops[opi + 1] != '/' && op_hold) {
                calc (op_hold, stack, & sp);
                op_hold = 0;
            }
        }
    }
    result = stack[sp--];
    printf ("%d\n", result);
    return 0;
}
----------------------------------------

int main () {
    int nums [8] = {1, 5, 8, 2, 5, 3, 4, 7};
    int cnums = 8;
    char ops [7] = {'+', '-', '/', '*', '+', '-', '*'};
    int cops = 7;
    int flag = 1;
    int i, j;
    while (flag) {
        flag = 0;
        for (i = 0; i < cnums; i++)
            if (ops[i] == '*' || ops[i] == '/') {
                if (ops[i] == '*')
                    nums[i] *= nums[i + 1];
                else
                    nums[i] /= nums[i + 1];
                flag = 1;
                for (j = i; j < cops; j++) {
                    ops[j] = ops[j + 1];
                    nums[j + 1] = nums[j + 2];
                }
                cnums--;
                cops--;
                break;
            }
    }
    flag = 1;
    while (flag) {
        flag = 0;
        for (i = 0; i < cnums; i++)
            if (ops[i] == '+' || ops[i] == '-') {
                if (ops[i] == '+')
                    nums[i] += nums[i + 1];
                else
                    nums[i] -= nums[i + 1];
                flag = 1;
                for (j = i; j < cops; j++) {
                    ops[j] = ops[j + 1];
                    nums[j + 1] = nums[j + 2];
                }
                cnums--;
                cops--;
                break;
            }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17047957_17048756_1_17
17047957_17048766_23_58
Title: How to combine in one loop serial numbers and null? 
----------------------------------------

void insert_after (int pos, int data) {
    node *temp1 = head;
    for (int i = 1; i < pos; i++) {
        if (temp1->next == NULL) {
            if (pos == INT_MAX)
                break;
            else
                return;
        }
        temp1 = temp1->next;
    }
    ...
}
----------------------------------------

void insert_after (int pos, int data) {
    node *walk, *prev;
    int i;
    prev = NULL;
    walk = head;
    for (i = 0; walk != NULL && i != pos; i++) {
        prev = walk;
        walk = walk->next;
    }
    if (i != pos && pos > 0) {
        fprintf (stderr, "Location not found.\n");
        exit (9);
    }
    else {
        walk = new_node ();
        walk->data = data;
        if (prev == NULL) {
            walk->next = head;
            head = walk;
        }
        else {
            walk->next = prev->next;
            prev->next = walk;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1705688_1705702_15_27
1705688_1705735_16_29
Title: Referring to data both by name and by number in C 
----------------------------------------

int main (void) {
    MyCars my_cars = {0};
    unsigned i;
    my_cars.ncars[CART_SAAB] = 2;
    my_cars.ncars[CART_HONDA] = 3;
    for (i = 0; i < CART_COUNT_; ++i)
        printf ("%u\n", my_cars.ncars[i]);
    return 0;
}
----------------------------------------

int main (int argc, char **arg) {
    cars2 my_cars;
    int i;
    my_cars.byname.saabs = 1;
    my_cars.byname.hondas = 5;
    my_cars.byname.porsches = 3;
    for (i = 0; i < 3; i++)
        printf ("%d\n", my_cars.byid[i]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1706551_1706733_45_61
1706551_45328341_42_61
Title: Parse string into argv/argc 
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    char **av;
    int ac;
    char *as = NULL;
    if (argc > 1)
        as = argv[1];
    av = parsedargs (as, &ac);
    printf ("== %d\n", ac);
    for (i = 0; i < ac; i++)
        printf ("[%s]\n", av[i]);
    freeparsedargs (av);
    exit (0);
}
----------------------------------------

int main (void) {
    printf ("# `tokenise_to_argc_argv()` Examples\n");
    {
        printf ("## Case0: Normal\n");
        char buffer [] = "tokenising example";
        demonstrate_tokenise_to_argc_argv (buffer, sizeof (buffer));
    }
    {
        printf ("## Case1: Empty String\n");
        char buffer [] = "";
        demonstrate_tokenise_to_argc_argv (buffer, sizeof (buffer));
    }
    {
        printf ("## Case2: Extra Space\n");
        char buffer [] = "extra  space here";
        demonstrate_tokenise_to_argc_argv (buffer, sizeof (buffer));
    }
    {
        printf ("## Case3: One Word String\n");
        char buffer [] = "one-word";
        demonstrate_tokenise_to_argc_argv (buffer, sizeof (buffer));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17073147_17073468_1_24
17073147_17073477_1_25
Title: Counting a sequence in a string C language 
----------------------------------------

int how_many_times (char *str, char *str2) {
    int result = 0, i = 0, j, k, len = strlen (str);
    while (str2[i]) {
        j = 0;
        k = 0;
        while (1) {
            if (str[j + k] == str2[i + k] && str[j] != 0) {
                if (j + k == len - 1) {
                    result++;
                    break;
                }
            }
            else {
                break;
            }
            k++;
        }
        i++;
    }
    return result;
}
----------------------------------------

int how_many_times (char *str1, char *str2) {
    int result = 0, i, j = 0;
    for (i = 0; i < strlen (str2); i++) {
        if ((str1[j] == str2[i])) {
            while (str1[j] == str2[i]) {
                j++;
                if (j == strlen (str1)) {
                    result++;
                    j = 0;
                }
                i++;
            }
        }
        else {
            i++;
            j = 0;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17074637_17074737_5_16
17074637_17075000_7_17
Title: pointer to function c language basic 
----------------------------------------

double essay (double (*pfunc) (double), double num, ... ) {
    int i;
    double product = 1, result;
    va_list arguments;
    va_start (arguments, num);
    for (i = 0; i < num; i++)
        product *= va_arg (arguments, double);
    va_end (arguments);
    result = pfunc (product);
    return result;
}
----------------------------------------

static double essay (MathFunc1 function, int num, ... ) {
    double product = 1.0;
    va_list arguments;
    va_start (arguments, num);
    for (int i = 0; i < num; i++)
        product *= va_arg (arguments, double);
    va_end (arguments);
    double result = (*function) (product);
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17079366_17079390_1_23
17079366_17079419_1_14
Title: Why is my variable changing values in recursive call in my C program? 
----------------------------------------

int find_largest (int *a, int n) {
    int subproblem;
    if (n == 1) {
        return *a;
    }
    subproblem = find_largest (a +1, n -1);
    if (*a > subproblem)
        return *a;
    else
        return subproblem;
}
----------------------------------------

int find_largest (int *a, int n) {
    static int largest = 0;
    if (!n) {
        int answer = largest;
        largest = 0;
        return answer;
    }
    else {
        n--;
        if (largest <= *(a + n))
            largest = *(a + n);
        find_largest (a, n);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1710265_1710373_28_47
1710265_1710516_4_12
Title: "Search for a string in a text file and parse that line (Linux C)" 
----------------------------------------

int main () {
    FILE *fcfg;
    char line [MAXLINE];
    char *p, *pend;
    int findlen;
    findlen = strlen (findkey);
    fcfg = fopen (FCFG, "r");
    while (p = fgets (line, MAXLINE, fcfg)) {
        printf ("Looking at %s\n", p);
        if (p = findval (line, findkey, findlen)) {
            pend = p + strlen (p) - 1;
            if (*pend == '\n')
                *pend = 0;
            printf ("Found %s\n", p);
        }
    }
    return 0;
}
----------------------------------------

int main () {
    char buffer [17] = "wants_return=yes";
    char *tok;
    tok = strtok (buffer, "=");
    printf ("%s\n", tok);
    tok = strtok (NULL, "=");
    printf ("%s\n", tok);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17120195_17120507_2_19
17120195_17121604_3_19
Title: Is there a way to store a value persistently without using a variable with global or module scope in c? 
----------------------------------------

int add (int a) {
    FILE *state_file;
    int result int prev_result;
    state_file = fopen ("state.txt", "r");
    prev_result = get_value_from_file (state_file);
    fclose (state_file);
    result = a + prev_result;
    state_file = fopen ("state.txt", "w");
    write_value_to_file (state_file, result);
    fclose (state_file);
    return result;
}
----------------------------------------

int add (int value) {
    FILE *fp;
    int pv = 0;
    fp = fopen ("temp.bin", "r+b");
    if (fp == NULL) {
        fp = fopen ("temp.bin", "wb+");
        fwrite (& pv, sizeof (int), 1, fp);
        rewind (fp);
    }
    fread (& pv, sizeof (int), 1, fp);
    pv += value;
    rewind (fp);
    fwrite (& pv, sizeof (int), 1, fp);
    fclose (fp);
    return pv;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17124937_17125086_3_30
17124937_17125198_4_31
Title: Input from a file in C 
----------------------------------------

int main (void) {
    int a [16], b [16], ai, bi;
    int wk, i, *array, *ip;
    char ch;
    FILE *fp;
    fp = fopen ("data.txt", "r");
    array = &a[0];
    ip = &ai;
    ai = bi = 0;
    while (2 == (fscanf (fp, "%d%c", &wk, &ch))) {
        array[(*ip)++] = wk;
        if (ch == ';') {
            array = &b[0];
            ip = &bi;
        }
        else if (ch == '\n')
            break;
    }
    fclose (fp);
    for (i = 0; i < ai; ++i) {
        printf ("%d ", a [i]);
    }
    printf ("\n");
    for (i = 0; i < bi; ++i) {
        printf ("%d ", b [i]);
    }
    return 0;
}
----------------------------------------

int main () {
    int a [8];
    int b [8];
    int i1 = 0, i2 = 0, i;
    while (scanf ("%d,", &a[i1]) == 1)
        i1++;
    if (getchar () != ';') {
        printf ("Bad format!\n");
        exit (0);
    }
    while (scanf ("%d,", &b[i2]) == 1)
        i2++;
    for (i = 0; i < i1; i++)
        printf ("%d ", a[i]);
    printf ("\n");
    for (i = 0; i < i2; i++)
        printf ("%d ", b[i]);
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17124937_17125086_3_30
17124937_17125498_3_47
Title: Input from a file in C 
----------------------------------------

int main (void) {
    int a [16], b [16], ai, bi;
    int wk, i, *array, *ip;
    char ch;
    FILE *fp;
    fp = fopen ("data.txt", "r");
    array = &a[0];
    ip = &ai;
    ai = bi = 0;
    while (2 == (fscanf (fp, "%d%c", &wk, &ch))) {
        array[(*ip)++] = wk;
        if (ch == ';') {
            array = &b[0];
            ip = &bi;
        }
        else if (ch == '\n')
            break;
    }
    fclose (fp);
    for (i = 0; i < ai; ++i) {
        printf ("%d ", a [i]);
    }
    printf ("\n");
    for (i = 0; i < bi; ++i) {
        printf ("%d ", b [i]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char buff [100];
    int a [10], b [10];
    unsigned acnt = 0, bcnt = 0;
    int state = 0, val = 0, cha;
    unsigned idx;
    if (fgets (buff, sizeof buff, stdin))
        for (idx = 0; cha = buff[idx]; idx++) {
            switch (state) {
            case 0 :
                if (cha >= '0' && cha <= '9') {
                    val = val * 10 + cha - '0';
                    continue;
                }
                a[acnt++] = val;
                val = 0;
                state = 1;
            case 1 :
                if (cha == ',') {
                    state = 0;
                    continue;
                }
                if (cha == ';') {
                    state = 2;
                    continue;
                }
                state = 5;
                break;
            case 2 :
                if (cha >= '0' && cha <= '9') {
                    val = val * 10 + cha - '0';
                    continue;
                }
                b[bcnt++] = val;
                val = 0;
                state = 3;
            case 3 :
                if (cha == ',') {
                    state = 2;
                    continue;
                }
                if (cha == '\n') {
                    state = 4;
                    continue;
                }
                state = 5;
            case 5 :
                fprintf (stderr, "Bad character %c at %s\n", cha, buff +idx);
            case 4 :
            default :
                goto done;
            }
        }
done :
    for (idx = 0; idx < acnt; idx++) {
        printf ("%u: %d\n", idx, a [idx]);
    }
    for (idx = 0; idx < bcnt; idx++) {
        printf ("%u: %d\n", idx, b [idx]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17124937_17125198_4_31
17124937_17125498_3_47
Title: Input from a file in C 
----------------------------------------

int main () {
    int a [8];
    int b [8];
    int i1 = 0, i2 = 0, i;
    while (scanf ("%d,", &a[i1]) == 1)
        i1++;
    if (getchar () != ';') {
        printf ("Bad format!\n");
        exit (0);
    }
    while (scanf ("%d,", &b[i2]) == 1)
        i2++;
    for (i = 0; i < i1; i++)
        printf ("%d ", a[i]);
    printf ("\n");
    for (i = 0; i < i2; i++)
        printf ("%d ", b[i]);
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    char buff [100];
    int a [10], b [10];
    unsigned acnt = 0, bcnt = 0;
    int state = 0, val = 0, cha;
    unsigned idx;
    if (fgets (buff, sizeof buff, stdin))
        for (idx = 0; cha = buff[idx]; idx++) {
            switch (state) {
            case 0 :
                if (cha >= '0' && cha <= '9') {
                    val = val * 10 + cha - '0';
                    continue;
                }
                a[acnt++] = val;
                val = 0;
                state = 1;
            case 1 :
                if (cha == ',') {
                    state = 0;
                    continue;
                }
                if (cha == ';') {
                    state = 2;
                    continue;
                }
                state = 5;
                break;
            case 2 :
                if (cha >= '0' && cha <= '9') {
                    val = val * 10 + cha - '0';
                    continue;
                }
                b[bcnt++] = val;
                val = 0;
                state = 3;
            case 3 :
                if (cha == ',') {
                    state = 2;
                    continue;
                }
                if (cha == '\n') {
                    state = 4;
                    continue;
                }
                state = 5;
            case 5 :
                fprintf (stderr, "Bad character %c at %s\n", cha, buff +idx);
            case 4 :
            default :
                goto done;
            }
        }
done :
    for (idx = 0; idx < acnt; idx++) {
        printf ("%u: %d\n", idx, a [idx]);
    }
    for (idx = 0; idx < bcnt; idx++) {
        printf ("%u: %d\n", idx, b [idx]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17128722_17128931_3_28
17128722_17129557_4_33
Title: Average word length for a sentence 
----------------------------------------

int main () {
    char ch;
    float avg;
    int words = 0;
    int letters = 0;
    int in_word = 0;
    printf ("Enter a sentence: ");
    while ((ch = getchar ()) != '\n') {
        if (ch != ' ') {
            if (!in_word) {
                words++;
                in_word = 1;
            }
            letters++;
        }
        else {
            in_word = 0;
        }
    }
    printf ("Average word lenth: %.1f", avg = (float) letters / words);
}
----------------------------------------

int main () {
    char ch;
    float avg;
    int numWords = 0;
    int numLetters = 0;
    bool prevWasASpace = true;
    printf ("Enter a sentence: ");
    while ((ch = getchar ()) != '\n') {
        if (ch != ' ') {
            prevWasASpace = false;
            numLetters++;
        }
        else if (ch == ' ' && !prevWasASpace) {
            numWords++;
            prevWasASpace = true;
        }
    }
    avg = numLetters / (float) (numWords);
    printf ("Average word lenth: %.1f", avg);
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17128722_17128931_3_28
17128722_17130789_4_33
Title: Average word length for a sentence 
----------------------------------------

int main () {
    char ch;
    float avg;
    int words = 0;
    int letters = 0;
    int in_word = 0;
    printf ("Enter a sentence: ");
    while ((ch = getchar ()) != '\n') {
        if (ch != ' ') {
            if (!in_word) {
                words++;
                in_word = 1;
            }
            letters++;
        }
        else {
            in_word = 0;
        }
    }
    printf ("Average word lenth: %.1f", avg = (float) letters / words);
}
----------------------------------------

int main (void) {
    int ch;
    int numWords = 0;
    int numLetters = 0;
    bool prevWasASpace = true;
    printf ("Enter a sentence: ");
    while ((ch = getchar ()) != EOF && ch != '\n') {
        if (ch == ' ')
            prevWasASpace = true;
        else {
            if (prevWasASpace)
                numWords++;
            prevWasASpace = false;
            numLetters++;
        }
    }
    if (numWords > 0) {
        double avg = numLetters / (float) (numWords);
        printf ("Average word length: %.1f (C = %d, N = %d)\n", avg, numLetters, numWords);
    }
    else
        printf ("You didn't enter any words\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17128722_17129557_4_33
17128722_17130789_4_33
Title: Average word length for a sentence 
----------------------------------------

int main () {
    char ch;
    float avg;
    int numWords = 0;
    int numLetters = 0;
    bool prevWasASpace = true;
    printf ("Enter a sentence: ");
    while ((ch = getchar ()) != '\n') {
        if (ch != ' ') {
            prevWasASpace = false;
            numLetters++;
        }
        else if (ch == ' ' && !prevWasASpace) {
            numWords++;
            prevWasASpace = true;
        }
    }
    avg = numLetters / (float) (numWords);
    printf ("Average word lenth: %.1f", avg);
    getch ();
}
----------------------------------------

int main (void) {
    int ch;
    int numWords = 0;
    int numLetters = 0;
    bool prevWasASpace = true;
    printf ("Enter a sentence: ");
    while ((ch = getchar ()) != EOF && ch != '\n') {
        if (ch == ' ')
            prevWasASpace = true;
        else {
            if (prevWasASpace)
                numWords++;
            prevWasASpace = false;
            numLetters++;
        }
    }
    if (numWords > 0) {
        double avg = numLetters / (float) (numWords);
        printf ("Average word length: %.1f (C = %d, N = %d)\n", avg, numLetters, numWords);
    }
    else
        printf ("You didn't enter any words\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17131488_17131644_5_22
17131488_17131683_4_25
Title: "Read a txt file and memorize into int or long in C" 
----------------------------------------

int main () {
    int i, n;
    int *pData;
    printf ("Amount of numbers to be entered: ");
    scanf ("%d", & i);
    pData = (int *) calloc (i, sizeof (int));
    if (pData == NULL)
        exit (1);
    for (n = 0; n < i; n++) {
        printf ("Enter number #%d: ", n + 1);
        scanf ("%d", & pData [n]);
    }
    printf ("You have entered: ");
    for (n = 0; n < i; n++)
        printf ("%d ", pData[n]);
    free (pData);
    return 0;
}
----------------------------------------

int main () {
    FILE *fr;
    int row = 0;
    int i;
    int arr [8] [2];
    fr = fopen ("file.txt", "r");
    if (fr == NULL) {
        printf ("Can't open file\n");
        exit (0);
    }
    while (fscanf (fr, "%d %d\n", &arr[row][0], &arr[row][1]) == 2)
        row++;
    for (i = 0; i < row; i++)
        printf ("(%d) (%d)\n", arr[i][0], arr[i][1]);
    fclose (fr);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1715413_1715483_4_28
1715413_1715546_2_22
Title: longjmp() from signal handler 
----------------------------------------

int t_gets (char *s, int t) {
    char *ret;
    struct sigaction action = {0};
    action.sa_handler = timeout;
    sigaction (SIGALRM, & action, NULL);
    alarm (t);
    ret = fgets (s, 100, stdin);
    int err = errno;
    alarm (0);
    if (ret == NULL) {
        switch (err) {
        case EINTR :
            return -2;
        default :
            return -1;
        }
    }
    return strlen (s);
}
----------------------------------------

int t_gets (char *s, int t) {
    char *ret = NULL;
    signal (SIGALRM, timeout);
    if (setjmp (buffer) != 0) {
        if (ret == NULL) {
            return -2;
        }
        else {
            goto end_of_function;
        }
    }
    alarm (t);
    ret = fgets (s, 100, stdin);
end_of_function :
    alarm (0);
    if (ret == NULL)
        return -1;
    return strlen (s);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17167126_17167276_4_15
17167126_17167374_4_14
Title: Get the datetime in C 
----------------------------------------

int main () {
    struct tm *tp;
    time_t t;
    char s [80];
    t = time (NULL);
    tp = localtime (&t);
    strftime (s, 80, "%Y/%m/%d %H:%M:%S", tp);
    printf ("%s\n", s);
    return 0;
}
----------------------------------------

int main (void) {
    FILE *ft = stdout;
    char outbuff [32];
    struct tm *timeptr;
    time_t now;
    time (& now);
    timeptr = localtime (&now);
    strftime (outbuff, sizeof (outbuff), "%Y/%m/%d %H:%M:%S", timeptr);
    fprintf (ft, "%s", outbuff);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17175009_17175178_10_26
17175009_17175476_13_28
Title: C Function Macro Of Node 
----------------------------------------

int main (int argc, const char *argv []) {
    node (stringIntNode, char *, int);
    stringIntNode *n = malloc (sizeof (*n));
    n->key = "first";
    n->value = 1;
    printf ("the node n has a key of %s and a value of %d.\n", n -> key, n -> value);
    node (charStringNode, char, char *);
    charStringNode *n2 = malloc (sizeof (*n2));
    n2->key = 'a';
    n2->value = "first";
    printf ("the node n2 has a key of %c and value of %s.\n", n2 -> key, n2 -> value);
    return 0;
}
----------------------------------------

int main (void) {
    node *n = malloc (sizeof (node));
    n->key = "first";
    n->value = box (int, 1);
    printf ("the node n has a key of %s and a value of %d.\n", (char *) n -> key, unbox (int, n -> value));
    node *n2 = malloc (sizeof (node));
    n2->key = box (char, 'a');
    n2->value = "first";
    printf ("the node n2 has a key of %c and value of %s.\n", unbox (char, n2 -> key), (char *) n2 -> value);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17195333_17195563_1_15
17195333_17195730_6_53
Title: C- Fix Stack overflow in Recursion 
----------------------------------------

int find (int l, int h) {
    int mid = (l + h) / 2;
    if (mid == l) {
        return (a[l] > a[h]) ? l : h;
    }
    else {
        int y = find (l, mid);
        int z = find (mid +1, h);
        return (a[y] > a[z]) ? y : z;
    }
}
----------------------------------------

int find (int l, int h) {
    int x;
    if (h - l == 0) {
        return h;
    }
    else {
        if (h - l == 1) {
            if (a[l] > a[l + 1]) {
                return l;
            }
            else {
                return l + 1;
            }
        }
        else {
            int mid, z, y;
            mid = (l + h) / 2;
            y = find (0, mid);
            z = find (mid +1, h);
            if (a[y] < a[z]) {
                x = z;
            }
            else {
                x = y;
            }
            return x;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17197843_17198057_1_20
17197843_17198351_9_24
Title: Segmentation fault while getting the size of Linked list 
----------------------------------------

void initializeLinkedList (node **topptr) {
    int i = 0;
    node *headptr = (node *) malloc (sizeof (node));
    headptr->value = i;
    *topptr = headptr;
    for (i = 1; i < 5; i++) {
        headptr->nextPtr = (node *) malloc (sizeof (node));
        headptr->nextPtr->value = i;
        headptr->nextPtr->nextPtr = NULL;
        headptr = headptr->nextPtr;
    }
}
----------------------------------------

void initializeLinkedList (node **top, node **rear) {
    int i = 0;
    node *local;
    *top = (node *) malloc (sizeof (node));
    local = *top;
    local->value = i;
    local->nextPtr = NULL;
    for (i = 1; i < 5; ++i) {
        local->nextPtr = (node *) malloc (sizeof (node));
        local = local->nextPtr;
        local->value = i;
        local->nextPtr = NULL;
    }
    *rear = local;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17206849_17206916_1_23
17206849_17207360_1_30
Title: Remove largest and lowest number from a 2d array without sorting 
----------------------------------------

int main () {
    int foo [5] [5];
    int i, j;
    int a = foo[0][0];
    int b = foo[0][0];
    for (i = 0; i < 5; i++) {
        for (j = 0; j < 5; j++) {
            if (a < foo[i][j])
                a = foo[i][j];
            if (b > foo[i][j])
                b = foo[i][j];
        }
    }
    for (i = 0; i < 5; i++) {
        for (j = 0;
        j < 5;
        j ++) {if (a == foo [i] [j]) foo [i] [j] = 0;
        if (b == foo[i][j])
            foo[i][j] = 0;
    }
}
----------------------------------------

int main () {
    int foo [5] [5];
    int i, j, jmin, jmax;
    for (i = 0; i < 5; i++) {
        int a = foo[i][0];
        int b = foo[i][0];
        for (j = 0; j < 5; j++) {
            if (foo[i][j] > a) {
                a = foo[i][j];
                jmax = j;
            }
            if (foo[i][j] < b) {
                b = foo[i][j];
                jmin = j;
            }
        }
        foo[i][jmax] = 0;
        foo[i][jmin] = 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17229707_17229832_2_24
17229707_17229980_2_16
Title: How to generate Fibonacci series in C 
----------------------------------------

int main () {
    int n, first = 0, second = 1, next, c;
    printf ("Enter the number of terms\n");
    scanf ("%d", & n);
    printf ("First %d terms of Fibonacci series are :-\n", n);
    for (c = 0; c < n; c++) {
        if (c <= 1)
            next = c;
        else {
            next = first + second;
            first = second;
            second = next;
        }
        printf ("%d\n", next);
    }
    return 0;
}
----------------------------------------

void main () {
    int first, second, next, i, n;
    first = 0;
    second = 1;
    n = 5;
    printf ("\n%d\n%d", first, second);
    for (i = 0; i < n; i++) {
        next = first + second;
        first = second;
        second = next;
        printf ("\n%d", next);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17229707_17229832_2_24
17229707_34959665_3_20
Title: How to generate Fibonacci series in C 
----------------------------------------

int main () {
    int n, first = 0, second = 1, next, c;
    printf ("Enter the number of terms\n");
    scanf ("%d", & n);
    printf ("First %d terms of Fibonacci series are :-\n", n);
    for (c = 0; c < n; c++) {
        if (c <= 1)
            next = c;
        else {
            next = first + second;
            first = second;
            second = next;
        }
        printf ("%d\n", next);
    }
    return 0;
}
----------------------------------------

void main () {
    int f1 = 0, f2 = 1, f, n, i;
    printf ("enter the no of terms");
    scanf ("%d", & n);
    printf ("the fibbonacci series:\n");
    printf ("%d\n%d", f1, f2);
    for (i = 2; i < n; i++) {
        f = f1 + f2;
        f1 = f2;
        f2 = f;
        printf ("%d\n", f);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17229707_17229832_2_24
17229707_37210539_1_16
Title: How to generate Fibonacci series in C 
----------------------------------------

int main () {
    int n, first = 0, second = 1, next, c;
    printf ("Enter the number of terms\n");
    scanf ("%d", & n);
    printf ("First %d terms of Fibonacci series are :-\n", n);
    for (c = 0; c < n; c++) {
        if (c <= 1)
            next = c;
        else {
            next = first + second;
            first = second;
            second = next;
        }
        printf ("%d\n", next);
    }
    return 0;
}
----------------------------------------

void main () {
    int a, b, c;
    a = 0;
    b = 1;
    c = a + b;
    printf (" %d ", a);
    printf (" %d ", b);
    while (c <= 100) {
        printf (" %d ", c);
        a = b;
        b = c;
        c = a + b;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17229707_17229980_2_16
17229707_34959665_3_20
Title: How to generate Fibonacci series in C 
----------------------------------------

void main () {
    int first, second, next, i, n;
    first = 0;
    second = 1;
    n = 5;
    printf ("\n%d\n%d", first, second);
    for (i = 0; i < n; i++) {
        next = first + second;
        first = second;
        second = next;
        printf ("\n%d", next);
    }
}
----------------------------------------

void main () {
    int f1 = 0, f2 = 1, f, n, i;
    printf ("enter the no of terms");
    scanf ("%d", & n);
    printf ("the fibbonacci series:\n");
    printf ("%d\n%d", f1, f2);
    for (i = 2; i < n; i++) {
        f = f1 + f2;
        f1 = f2;
        f2 = f;
        printf ("%d\n", f);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
17229707_17229980_2_16
17229707_37210539_1_16
Title: How to generate Fibonacci series in C 
----------------------------------------

void main () {
    int first, second, next, i, n;
    first = 0;
    second = 1;
    n = 5;
    printf ("\n%d\n%d", first, second);
    for (i = 0; i < n; i++) {
        next = first + second;
        first = second;
        second = next;
        printf ("\n%d", next);
    }
}
----------------------------------------

void main () {
    int a, b, c;
    a = 0;
    b = 1;
    c = a + b;
    printf (" %d ", a);
    printf (" %d ", b);
    while (c <= 100) {
        printf (" %d ", c);
        a = b;
        b = c;
        c = a + b;
    }
}
----------------------------------------
