$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20569141_20569884_1_67
20569141_20571706_29_65
Title: Read a string and store each string in the array when newline character is found 
----------------------------------------

int main (int argc, char *argv []) {
    int i = 0;
    int j = 0;
    char str [MAX_TEXT];
    char cpy [MAX_TEXT];
    char *tmp = cpy;
    TB textList = NULL;
    TB list = NULL;
    TB newList = NULL;
    strcpy (str, "hello\nworld\ngood\nbye\n");
    while (str[i] != '\0') {
        if (str[i] == '\n') {
            cpy[j] = '\0';
            newList = newTB (tmp);
            if (textList) {
                textList->next = newList;
                textList = newList;
            }
            else
                list = textList = newList;
            tmp = &cpy[j + 1];
        }
        else
            cpy[j] = str[i];
        j++;
        i++;
    }
    cpy[j] = '\0';
    printList (list);
    for (textList = list; NULL != textList;) {
        list = textList;
        textList = textList->next;
        free (list);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int i = 0;
    int j = 0;
    char str [MAX_TEXT];
    char cpy [MAX_TEXT];
    TB list = NULL;
    TB textlist = NULL;
    fgets (str, MAX_TEXT, stdin);
    while (str[i] != '\n' && str[i] != '\0') {
        if (str[i] == '\\') {
            if (str[i + 1] == 'n') {
                cpy[j] = '\0';
                TB newList = newTB (cpy);
                if (textlist == NULL)
                    textlist = newList;
                else {
                    textlist->next = newList;
                    textlist = textlist->next;
                }
                if (list == NULL)
                    list = newList;
                j = 0;
                i += 2;
            }
            else if (str[i + 1] == '0') {
                break;
            }
        }
        cpy[j++] = str[i++];
    }
    printList (list);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20596930_20597447_16_39
20596930_20597552_5_31
Title: What digit is the most frequent? 
----------------------------------------

int main (void) {
    int values [10] = {0};
    ulli x;
    if (scanf ("%llu", &x) != 1) {
        fprintf (stderr, "Input failed\n");
        return 1;
    }
    printf ("Analyzing: %llu\n", x);
    do {
        int d = x % 10;
        values[d]++;
        x /= 10;
    }
    while (x > 0);
    int n = maxi (values);
    printf ("Digit %d appears %d time%s\n", n, values [n], (values [n] != 1) ? "s" : "");
    return 0;
}
----------------------------------------

int main () {
    ulli x;
    int high = 0;
    int num = scanf ("%lld", &x);
    int arr [10] = {0};
    int index = 0;
    int i;
    if (num == 1) {
        while (x) {
            arr[x % 10]++;
            x /= 10;
        }
        for (i = 0; i < 10; ++i) {
            if (arr[i] > high) {
                index = i;
                high = arr[i];
            }
        }
        printf ("Most frequent digit: %d, count: %d\n", index, high);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20598815_20600216_6_22
20598815_39389561_6_21
Title: Can this C code create zombie processes? 
----------------------------------------

int main (void) {
    pid_t p = fork ();
    if (p != 0) {
        waitpid (p, NULL, 0);
        sleep (1);
        pause ();
    }
    else {
        sleep (3);
    }
    return 0;
}
----------------------------------------

void main () {
    pid_t pid;
    pid = fork ();
    if (pid == 0) {
        exit (0);
    }
    else {
        sleep (15);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20653718_20655097_4_15
20653718_20655206_4_20
Title: Error accured in reading files by using line by line in c 
----------------------------------------

int main () {
    char szLine [512 + 1] = {0};
    FILE *fp = fopen ("log.txt", "r");
    while (!feof (fp)) {
        fgets (szLine, 512, fp);
        puts (szLine);
        getchar ();
    }
    return 0;
}
----------------------------------------

int main () {
    int bla;
    char szLine [512 + 1] = {0};
    FILE *fp = fopen ("log.txt", "r");
    while (!feof (fp)) {
        bla = fscanf (fp, "%512[^\n]", szLine);
        if (bla == 1) {
            printf ("%d\n", bla);
            puts (szLine);
            getchar ();
            fgetc (fp);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20656993_20658275_12_27
20656993_39193505_9_55
Title: plane coordinate point sorting 
----------------------------------------

int main () {
    int x [] = {1, 4, 2, 5, 3, 7, 10};
    int y [] = {5, 2, 4, 3, 8, 9, 99};
    size_t size = sizeof (x) / sizeof (*x);
    int index [size];
    int i;
    for (i = 0; i < size; ++i) {
        index[i] = i;
    }
    X = x;
    qsort (index, size, sizeof (int), cmp);
    for (i = 0; i < size; ++i) {
        printf ("(%d, %d)\n", x [index [i]], y [index [i]]);
    }
    return 0;
}
----------------------------------------

int main () {
    struct point a [100], tmp;
    int i, j, n;
    cin >> n;
    for (i = 1; i <= n; i++) {
        cin >> a[i].x >> a[i].y;
    }
    for (i = 1; i <= n; i++) {
        for (j = i + 1; j <= n; j++) {
            if (a[i].x > a[j].x) {
                tmp = a[i];
                a[i] = a[j];
                a[j] = tmp;
            }
        }
    }
    for (i = 1; i <= n; i++) {
        for (j = i + 1; j <= n; j++) {
            if (a[i].x == a[j].x) {
                if (a[i].y > a[j].y) {
                    tmp = a[i];
                    a[i] = a[j];
                    a[j] = tmp;
                }
            }
        }
    }
    for (i = 1; i <= n; i++) {
        cout << a[i].x << " " << a[i].y << endl;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20670569_20672499_9_34
20670569_20690487_1_12
Title: Merging two unsorted linked lists? 
----------------------------------------

static node *list_merge (node *x, node *y) {
    if (x == 0)
        return y;
    if (y == 0)
        return x;
    node *z = x;
    node *t = x;
    x = x->next;
    while (y != 0 && x != 0) {
        t->next = y;
        y = y->next;
        t = t->next;
        t->next = x;
        x = x->next;
        t = t->next;
    }
    if (y != 0)
        t->next = y;
    else if (x != 0)
        t->next = x;
    else
        t->next = 0;
    return z;
}
----------------------------------------

node *list_merge (node *x, node *y) {
    node *result = NULL, **pp;
    unsigned odd = 0;
    for (pp = &result; x && y; pp = &(*pp)->next) {
        if (odd++ % 2) {
            *pp = y;
            y = y->next;
        }
        else {
            *pp = x;
            x = x->next;
        }
    }
    *pp = (x) ? x : y;
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2068721_2068959_7_17
2068721_51003184_3_14
Title: when to use registers in C? 
----------------------------------------

int main () {
    REG unsigned int a, b, c;
    for (n = 0; n < 10; ++n) {
        c = a + b;
        b = a;
        a = c;
        array[n] = c;
    }
}
----------------------------------------

int main () {
    register int n;
    unsigned int a = 1, b = 2, c;
    for (n = 0; n < 10; ++n) {
        c = a + b;
        b = a;
        a = c;
        array[n] = c;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20716785_20716810_5_58
20716785_20716998_8_55
Title: How do I delete a specific line from text file in C? 
----------------------------------------

int main () {
    FILE *fileptr1, *fileptr2;
    char filename [40];
    char ch;
    int delete_line, temp = 1;
    printf ("Enter file name: ");
    scanf ("%s", filename);
    fileptr1 = fopen (filename, "r");
    ch = getc (fileptr1);
    while (ch != EOF) {
        printf ("%c", ch);
        ch = getc (fileptr1);
    }
    rewind (fileptr1);
    printf (" \n Enter line number of the line to be deleted:");
    scanf ("%d", & delete_line);
    fileptr2 = fopen ("replica.c", "w");
    ch = 'A';
    while (ch != EOF) {
        ch = getc (fileptr1);
        if (temp != delete_line) {
            putc (ch, fileptr2);
        }
        if (ch == '\n') {
            temp++;
        }
    }
    fclose (fileptr1);
    fclose (fileptr2);
    remove (filename);
    rename ("replica.c", filename);
    printf ("\n The contents of file after being modified are as follows:\n");
    fileptr1 = fopen (filename, "r");
    ch = getc (fileptr1);
    while (ch != EOF) {
        printf ("%c", ch);
        ch = getc (fileptr1);
    }
    fclose (fileptr1);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char file [] = "yourfile.txt";
    if (--argc) {
        struct stat st;
        if (stat (file, &st) != -1) {
            FILE *fp = fopen (file, "rb");
            if (fp != NULL) {
                char *buffer = malloc (st.st_size);
                if (fread (buffer, 1, st.st_size, fp) == st.st_size) {
                    fclose (fp);
                    size_t newSize = deleteLine (buffer, st.st_size, argv[1]);
                    fp = fopen (file, "wb");
                    if (fp != NULL) {
                        fwrite (buffer, 1, newSize, fp);
                        fclose (fp);
                    }
                    else {
                        perror (file);
                    }
                }
                free (buffer);
            }
            else {
                perror (file);
            }
        }
        else {
            printf ("did not find %s", file);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20738324_20738479_3_26
20738324_20738774_1_30
Title: How to stop a program based on user's input in C 
----------------------------------------

int main () {
    int a;
    int b;
    char c [5] = {'\0'};
    printf ("Enter the two values you like to compare, type stop to end.\n");
    while (strcmp (c, "stop")) {
        scanf ("%d%d%s", & a, & b, c);
        if (!(a ^ b)) {
            printf ("both are equal\n");
            getchar ();
        }
        else {
            printf ("both are not equal\n");
            getchar ();
        }
    }
    printf ("Thanks for playing.");
    getchar ();
    return 0;
}
----------------------------------------

int main () {
    int a;
    int b;
    char c;
    do {
        printf ("Would you like to play?\nPress 'Y' for 'Yes' or 'N' for 'No'\n");
        scanf ("%c", & c);
        if (c != 'Y' && c != 'y')
            break;
        printf ("Enter the two values you like to compare\n");
        scanf (" %d %d", & a, & b);
        if (!(a ^ b)) {
            printf ("both are equal\n");
            getchar ();
        }
        else {
            printf ("both are not equal\n");
            getchar ();
        }
    }
    while (1);
    printf ("Thanks for playing.");
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20738324_20738774_1_30
20738324_20739382_3_27
Title: How to stop a program based on user's input in C 
----------------------------------------

int main () {
    int a;
    int b;
    char c;
    do {
        printf ("Would you like to play?\nPress 'Y' for 'Yes' or 'N' for 'No'\n");
        scanf ("%c", & c);
        if (c != 'Y' && c != 'y')
            break;
        printf ("Enter the two values you like to compare\n");
        scanf (" %d %d", & a, & b);
        if (!(a ^ b)) {
            printf ("both are equal\n");
            getchar ();
        }
        else {
            printf ("both are not equal\n");
            getchar ();
        }
    }
    while (1);
    printf ("Thanks for playing.");
    getchar ();
    return 0;
}
----------------------------------------

int main () {
    int a;
    int b;
    char c [5] = {'\0'};
    do {
        printf ("Enter the two values you like to compare, type stop to end.\n");
        scanf ("%d%d%s", & a, & b, c);
        if (!(a ^ b)) {
            printf ("both are equal\n");
            getchar ();
        }
        else {
            printf ("both are not equal\n");
            getchar ();
        }
    }
    while (strcmp (c, "stop"));
    printf ("Thanks for playing.");
    getchar ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20740988_20744167_1_14
20740988_20751494_11_30
Title: How to count instances of a word in a list of words 
----------------------------------------

int main (void) {
    char text [] = "foo bar foo bar foo";
    char word [] = "foo";
    char *p;
    int occurences = 0;
    for (p = text; (p = strstr (p, word)) != NULL; p += sizeof (word) - 1) {
        occurences++;
    }
    printf ("Occurences of %s = %d\n", word, occurrences);
}
----------------------------------------

int main () {
    char *namePtr, *newnamePtr;
    char newname [8];
    int i, occurrence = 0;
    printf ("enter the word you want to count : \n");
    scanf ("%s", newname);
    newnamePtr = newname;
    for (i = 0; i < N; i++) {
        namePtr = name[i];
        if (strcmp (namePtr, newnamePtr) == 0)
            occurrence++;
    }
    if (occurrence == 0)
        printf ("this word does not exist in  the list!");
    else
        printf ("the occurrence  of this word is %d", occurrence);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20744309_20744383_15_31
20744309_20746532_31_64
Title: Generic List in C using void pointer 
----------------------------------------

bool is_element_of (Item Item, List *pointertolist) {
    bool isInList = false;
    Node *scan = *pointertolist;
    while (scan != NULL && !isInList) {
        if ((scan->Item.data) == (Item.data)) {
            printf ("Match!\n");
            isInList = true;
        }
        scan = scan->next;
    }
    if (!isInList)
        printf ("No Match!\n");
    return isInList;
}
----------------------------------------

bool is_element_of (Item Item, List *pointertolist) {
    bool isinlist = false;
    Node *scan = *pointertolist;
    while (scan->next != NULL) {
        if (scan->Item.type == Item.type) {
            if (Item.type & (tp_vptr | tp_sptr)) {
                if ((scan->Item.ptr) == (Item.ptr)) {
                    printf ("pointer Match!");
                    isinlist = true;
                    break;
                }
            }
            else if (Item.type == tp_int) {
                if ((void *) (scan->Item.i) == (void *) (Item.i)) {
                    printf ("integer Match!");
                    isinlist = true;
                    break;
                }
            }
            else if (Item.type == tp_short) {
                if ((scan->Item.s) == (Item.s)) {
                    printf ("short Match!");
                    isinlist = true;
                    break;
                }
            }
        }
        scan = scan->next;
    }
    return isinlist;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20769834_20769909_5_78
20769834_20769955_2_45
Title: "Average max and min program in C" 
----------------------------------------

int main (void) {
    float average;
    int n, num, count = 0, sum = 0, squaresum = 0;
    int min = INT_MAX, max = INT_MIN;
    bool gotAnswer = false;
    while (!gotAnswer) {
        printf ("Please enter the number of numbers you wish to evaluate: ");
        if (scanf_s ("%d", &n) != 1) {
            while (getchar () != '\n') {
                continue;
            }
        }
        else {
            gotAnswer = true;
        }
    }
    while (getchar () != '\n')
        continue;
    while (count < n) {
        gotAnswer = false;
        printf ("Enter number %d: ", count + 1);
        if (scanf_s ("%d", &num) != 1) {
            while (getchar () != '\n')
                continue;
            continue;
        }
        else {
            gotAnswer = true;
            while (getchar () != '\n')
                continue;
        }
        if (num > max)
            max = num;
        if (num < min)
            min = num;
        sum += num;
        squaresum += num * num;
        count++;
    }
    average = 1.0 * sum / n;
    printf ("Your average is %.2f\n", average);
    printf ("The sum of your squares is %d\n", squaresum);
    printf ("Your maximum number is %d\n", max);
    printf ("Your minimum number is %d\n", min);
    system ("pause");
    return 0;
}
----------------------------------------

int main () {
    float average;
    int i, n, count = 0, sum = 0, squaresum = 0, num, min, max;
    bool first = true;
    printf ("Please enter the number of numbers you wish to evaluate\n");
    scanf_s ("%d", & n);
    printf ("Please enter %d numbers\n", n);
    min = 0;
    max = 0;
    while (count < n) {
        scanf_s ("%d", & num);
        if (first) {
            first = false;
            min = max = num;
        }
        if (num > max)
            max = num;
        if (num < min)
            min = num;
        sum = sum + num;
        squaresum = squaresum + (num * num);
        count++;
    }
    average = 1.0 * sum / n;
    printf ("Your average is %.2f\n", average);
    printf ("The sum of your squares is %d\n", squaresum);
    printf ("Your maximum number is %d\n", max);
    printf ("Your minimum number is %d\n", min);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20769834_20769909_5_78
20769834_20770038_2_42
Title: "Average max and min program in C" 
----------------------------------------

int main (void) {
    float average;
    int n, num, count = 0, sum = 0, squaresum = 0;
    int min = INT_MAX, max = INT_MIN;
    bool gotAnswer = false;
    while (!gotAnswer) {
        printf ("Please enter the number of numbers you wish to evaluate: ");
        if (scanf_s ("%d", &n) != 1) {
            while (getchar () != '\n') {
                continue;
            }
        }
        else {
            gotAnswer = true;
        }
    }
    while (getchar () != '\n')
        continue;
    while (count < n) {
        gotAnswer = false;
        printf ("Enter number %d: ", count + 1);
        if (scanf_s ("%d", &num) != 1) {
            while (getchar () != '\n')
                continue;
            continue;
        }
        else {
            gotAnswer = true;
            while (getchar () != '\n')
                continue;
        }
        if (num > max)
            max = num;
        if (num < min)
            min = num;
        sum += num;
        squaresum += num * num;
        count++;
    }
    average = 1.0 * sum / n;
    printf ("Your average is %.2f\n", average);
    printf ("The sum of your squares is %d\n", squaresum);
    printf ("Your maximum number is %d\n", max);
    printf ("Your minimum number is %d\n", min);
    system ("pause");
    return 0;
}
----------------------------------------

int main () {
    float average;
    int i, n, count = 0, sum = 0, squaresum = 0, num, min, max;
    printf ("Please enter the number of numbers you wish to evaluate\n");
    scanf_s ("%d", & n);
    printf ("Please enter %d numbers\n", n);
    scanf_s ("%d", & num);
    max = min = num;
    while (1) {
        if (num > max)
            max = num;
        if (num < min)
            min = num;
        sum = sum + num;
        squaresum = squaresum + (num * num);
        count++;
        if (count == n)
            break;
        scanf_s ("%d", & num);
    }
    average = 1.0 * sum / n;
    printf ("Your average is %.2f\n", average);
    printf ("The sum of your squares is %d\n", squaresum);
    printf ("Your maximum number is %d\n", max);
    printf ("Your minimum number is %d\n", min);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20788456_20788654_1_11
20788456_20789432_17_29
Title: Using C Dynamic allocation using malloc and realloc 
----------------------------------------

void ArrayAdd (ASet **arrayStruct, size_t new_size, int x) {
    ASet *pt = realloc (*arrayStruct, new_size * sizeof (ASet));
    if (pt == 0) {
        fprintf (stderr, "Memory allocation failed!\n");
        exit (1);
    }
    pt[new_size - 1].value = x;
    *arrayStruct = pt;
}
----------------------------------------

void ArrayAdd (ASet *arrayStruct, Item x) {
    ASet *ap = arrayStruct;
    Item *p = ap->value;
    p = realloc (p, (ap->size + 1) * sizeof (Item));
    if (p) {
        ap->value = p;
        ap->value[ap->size] = x;
        ap->size += 1;
    }
    else {
        perror ("realloc");
        exit (1);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20790036_20790137_4_34
20790036_20790143_4_40
Title: Beginning program trouble 
----------------------------------------

int main () {
    int coins, pennies, nickels, dimes, quarters;
    int quarter, nickel, dime;
    float money;
    quarter = 25;
    dime = 10;
    nickel = 5;
    printf ("How much money would you like in change?\n");
    scanf ("%f", & money);
    coins = (money * 100) + .5;
    quarters = coins / quarter;
    coins -= quarters * quarter;
    dimes = coins / dime;
    coins -= dimes * dime;
    nickels = coins / nickel;
    coins -= nickels * nickel;
    pennies = coins;
    printf ("The number of quarters is %d\n", quarters);
    printf ("The number of dimes is %d\n", dimes);
    printf ("The number of nickels are %d\n", nickels);
    printf ("The number of pennies is %d\n", pennies);
    return 0;
}
----------------------------------------

int main () {
    int coins, quarter, money3, money2, pennies, nickels, dimes, quarters;
    int penny, nickel, dime, money1;
    float money;
    quarter = 25;
    dime = 10;
    nickel = 5;
    penny = 1;
    printf ("How much money would you like in change?\n");
    scanf ("%f", & money);
    coins = (money * 100) + .5;
    printf ("coins = %d\n", coins);
    quarters = coins / quarter;
    money1 = coins % quarter;
    printf ("money1 = %d\n", money1);
    dimes = money1 / dime;
    money2 = coins % dime;
    printf ("money2 = %d\n", money2);
    nickels = money2 / nickel;
    money3 = coins % nickel;
    printf ("money3 = %d\n", money3);
    pennies = money3 / penny;
    printf ("The number of quarters is %d\n", quarters);
    printf ("The number of dimes is %d\n", dimes);
    printf ("The number of nickels are %d\n", nickels);
    printf ("The number of pennies is %d\n", pennies);
    printf ("%d\n", money1);
    printf ("%d\n", coins);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20816195_20816325_19_27
20816195_20816465_29_56
Title: "How can one change the ""geometry"" of an array?" 
----------------------------------------

int main () {
    unsigned long *data = malloc (sizeof (unsigned long) * 9);
    int i;
    for (i = 0; i < 9; ++i)
        data[i] = i;
    printf ("%lu\n", sumOfColTwo (data));
    free (data);
    return 0;
}
----------------------------------------

int main (void) {
    int data [N_ROWS * N_COLS];
    int i, j;
    for (i = 0; i < N_ROWS * N_COLS; i++)
        data[i] = 'A' + i;
    printf ("By rows\n");
    for (i = 0; i < N_ROWS; i++) {
        for (j = 0; j < N_COLS; j++)
            printf (" %c", data[i * N_COLS + j]);
        putchar ('\n');
    }
    printf ("By cols\n");
    for (i = 0; i < N_COLS; i++) {
        for (j = 0; j < N_ROWS; j++)
            printf (" %c", data[j * N_ROWS + i]);
        putchar ('\n');
    }
    sum_by_cols (data);
    sum_by_rows (data);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20818984_20819069_4_19
20818984_20819111_4_17
Title: How to invent a code for square-root? 
----------------------------------------

int main () {
    int a, I, cnt = 0;
    int sum = 0;
    printf ("enter number");
    scanf ("%d", & a);
    for (I = 1; sum < a; I += 2) {
        sum += I;
        cnt++;
        if (sum > a)
            cnt--;
    }
    printf ("answer is:%d", cnt);
}
----------------------------------------

int main () {
    int a, I, sum = 0, cnt = 0;
    printf ("enter number");
    scanf ("%d", & a);
    for (I = 1; sum < a; I += 2) {
        sum += I;
        cnt++;
    }
    if (sum == a)
        printf ("answer is:%d", cnt);
    else
        printf ("answer is:%d", cnt -1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20818984_20819069_4_19
20818984_27627758_3_12
Title: How to invent a code for square-root? 
----------------------------------------

int main () {
    int a, I, cnt = 0;
    int sum = 0;
    printf ("enter number");
    scanf ("%d", & a);
    for (I = 1; sum < a; I += 2) {
        sum += I;
        cnt++;
        if (sum > a)
            cnt--;
    }
    printf ("answer is:%d", cnt);
}
----------------------------------------

int main () {
    float i, x = 10;
    int lp;
    scanf ("%f", & i);
    for (lp = 0; lp < 5; lp++)
        x = (x - ((((x * x) - i)) / (2 * x)));
    printf ("sqaure root of %f=%f\n", i, x);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20818984_20819111_4_17
20818984_27627758_3_12
Title: How to invent a code for square-root? 
----------------------------------------

int main () {
    int a, I, sum = 0, cnt = 0;
    printf ("enter number");
    scanf ("%d", & a);
    for (I = 1; sum < a; I += 2) {
        sum += I;
        cnt++;
    }
    if (sum == a)
        printf ("answer is:%d", cnt);
    else
        printf ("answer is:%d", cnt -1);
    return 0;
}
----------------------------------------

int main () {
    float i, x = 10;
    int lp;
    scanf ("%f", & i);
    for (lp = 0; lp < 5; lp++)
        x = (x - ((((x * x) - i)) / (2 * x)));
    printf ("sqaure root of %f=%f\n", i, x);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20828491_20828526_6_28
20828491_20828631_4_13
Title: Put value into char 2D array 
----------------------------------------

int main (void) {
    char **links = (char **) calloc (SRTM_SIZE, sizeof (char *));
    if (links) {
        for (int i = 0; i < SRTM_SIZE; i++) {
            links[i] = (char *) calloc (SRTM_SIZE, sizeof (char));
        }
    }
    char temp [5] = "2,3";
    char *x = strtok (temp, ",");
    char *y = strtok (NULL, ",");
    int xx = atoi (x);
    int yy = atoi (y);
    sprintf (links [0], "%d,%d", xx, yy);
    printf ("%s\n", links [0]);
}
----------------------------------------

int main (void) {
    int len;
    int x = 3, y = 5;
    len = snprintf (NULL, 0, "%d,%d", x, y);
    char *link = malloc (len +1);
    sprintf (link, "%d,%d", x, y);
    printf ("%s\n", link);
    free (link);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20835441_20835511_8_29
20835441_20836143_3_13
Title: My partition function for quicksort 
----------------------------------------

int partition (int data [], int l, int h) {
    int i;
    int p;
    int firsthigh;
    p = h;
    firsthigh = l;
    for (i = l; i < h; ++i) {
        if (data[i] < data[p]) {
            swap (& data [i], & data [firsthigh]);
            firsthigh++;
        }
    }
    swap (& data [p], & data [firsthigh]);
    return firsthigh;
}
----------------------------------------

int partition (int *a, int low, int high) {
    int pos = low, i, pivot = a[low], temp;
    for (i = low + 1; i <= high; i++)
        if (a[i] <= pivot) {
            pos++;
            temp = a[pos];
            a[pos] = a[i];
            a[i] = temp;
        }
    return pos;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20835441_20835511_8_29
20835441_20836148_1_16
Title: My partition function for quicksort 
----------------------------------------

int partition (int data [], int l, int h) {
    int i;
    int p;
    int firsthigh;
    p = h;
    firsthigh = l;
    for (i = l; i < h; ++i) {
        if (data[i] < data[p]) {
            swap (& data [i], & data [firsthigh]);
            firsthigh++;
        }
    }
    swap (& data [p], & data [firsthigh]);
    return firsthigh;
}
----------------------------------------

int partition (int arr [], int low, int high) {
    int x = arr[high];
    int i = (low - 1);
    for (int j = l; j <= high - 1; j++) {
        if (arr[j] <= x) {
            i++;
            swap (& arr [i], & arr [j]);
        }
    }
    swap (& arr [i + 1], & arr [high]);
    return (i + 1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20835441_20836143_3_13
20835441_20836148_1_16
Title: My partition function for quicksort 
----------------------------------------

int partition (int *a, int low, int high) {
    int pos = low, i, pivot = a[low], temp;
    for (i = low + 1; i <= high; i++)
        if (a[i] <= pivot) {
            pos++;
            temp = a[pos];
            a[pos] = a[i];
            a[i] = temp;
        }
    return pos;
}
----------------------------------------

int partition (int arr [], int low, int high) {
    int x = arr[high];
    int i = (low - 1);
    for (int j = l; j <= high - 1; j++) {
        if (arr[j] <= x) {
            i++;
            swap (& arr [i], & arr [j]);
        }
    }
    swap (& arr [i + 1], & arr [high]);
    return (i + 1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20838032_20838240_5_27
20838032_20838347_5_30
Title: "How to print from a file transaction type and amount involved  seperated by comma or single space?" 
----------------------------------------

int main () {
    int i;
    char array1 [3];
    int array2 [3];
    FILE *fptr = fopen ("transactions.txt", "r");
    if (fptr == NULL) {
        printf ("error in opening file");
        return -1;
    }
    for (i = 0; i < 3; i++) {
        fscanf (fptr, "%c %d", & array1 [i], & array2 [i]);
    }
    for (i = 0; i < 3; i++) {
        printf ("%c %d\n", array1 [i], array2 [i]);
    }
    fclose (fptr);
    return 0;
}
----------------------------------------

int main () {
    int i;
    char array1 [3];
    int array2 [3];
    FILE *fptr;
    if ((fptr = fopen ("transactions.txt", "r")) == NULL) {
        printf ("error in opening file");
        return 0;
    }
    for (i = 0; i < 3; i++) {
        fscanf (fptr, "%*[^,],");
        fscanf (fptr, " %c", & array1 [i]);
        fscanf (fptr, "%d", & array2 [i]);
    }
    for (i = 0; i < 3; i++) {
        printf ("%c", array1 [i]);
        printf (" %d", array2 [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2084690_2086719_19_29
2084690_52750407_2_19
Title: Inserting spaces between digits in C 
----------------------------------------

int main (int argc, char *argv []) {
    print_number (1);
    print_number (12);
    print_number (123);
    print_number (1234);
    print_number (12345);
    print_number (1234567);
    print_number (12345678);
    print_number (123456789);
    return 0;
}
----------------------------------------

int main () {
    int a, b, c, d, e;
    printf ("Write a number of four figures\n");
    scanf ("%d", & a);
    printf ("Your number is:\n");
    b = (a - (a % 1000)) / 1000;
    c = ((a - (a % 100)) / 100) - b * 10;
    d = ((a - (a % 10)) / 10) - b * 100 - c * 10;
    e = (a - b * 1000 - c * 100 - d * 10);
    printf ("%d\t%d\t", b, c);
    printf ("%d\t", d);
    printf ("%d", e);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20847284_20847462_20_32
20847284_20847567_17_37
Title: calling function on runtime in c 
----------------------------------------

int main (int argc, char *argv []) {
    void *hndl = dlopen (NULL, RTLD_LAZY);
    void (*fn) (void) = dlsym (hndl, argv[1]);
    if (fn) {
        fn ();
    }
    else {
        printf ("Function %s() not found\n", argv [1]);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc < 2) {
        printf ("invalid program arguments\n");
        return 1;
    }
    FILE *fout = fopen ("function_call.c", "w");
    fprintf (fout, "%s", file_includes);
    fprintf (fout, "%s", file_functions);
    fprintf (fout, "%s", file_main_prolog);
    fprintf (fout, "  %s();\n", argv [1]);
    fprintf (fout, "%s", file_main_epilog);
    fclose (fout);
    system ("gcc -o function_call function_call.c");
    system ("./function_call");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20849079_20849696_21_43
20849079_20849989_27_37
Title: Making Multiple Stacks 
----------------------------------------

int pop (struct node **stack) {
    int temp = 0;
    struct node *oldnode;
    if (stack != NULL) {
        if (*stack != NULL) {
            oldnode = *stack;
            temp = oldnode->data;
            (*stack) = oldnode->prev;
            free (oldnode);
        }
        else {
        }
    }
    else {
    }
    return temp;
}
----------------------------------------

Item pop (Stack *st) {
    if (!isEmpty (*st)) {
        struct node *p = *st;
        Item value = p->data;
        *st = p->next;
        free (p);
        return value;
    }
    fprintf (stderr, "Stack is Empty!\n");
    return (Item) 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20859255_20860010_3_26
20859255_20860745_4_46
Title: How to replace every specific character to another in a string C? 
----------------------------------------

int main (int argc, char *argv []) {
    char str [] = "Algorithms Are Funnnn!\0";
    int i = 0;
    int offset = 33;
    int ocurrs [94] = {0};
    int max [2] = {0};
    while (str[i])
        ocurrs[str[i++] - offset]++;
    for (i = 0; i < 94; i++)
        if (ocurrs[i] > ocurrs[max[1]]) {
            max[0] = max[1];
            max[1] = i;
        }
        else if (ocurrs[i] > ocurrs[max[0]])
            max[0] = i;
    printf ("chars '%c'(%d times) and '%c'(%d times) occurred most.\n", offset + max [1], ocurrs [max [1]], offset + max [0], ocurrs [max [0]]);
    return 0;
}
----------------------------------------

int main (void) {
    char szInput [] = "ONE DOES NOT SIMPLY WALK INTO MORDOR!";
    int len = strlen (szInput);
    int MaxCountSoFar_1 = 0;
    int MaxIndexSoFar_1 = -1;
    int MaxCountSoFar_2 = 0;
    int MaxIndexSoFar_2 = -1;
    int i, j, CountThatOne;
    for (i = 0; i < len; ++i) {
        if (szInput[i] == ' ')
            continue;
        CountThatOne = 1;
        for (j = i + 1; j < len; ++j) {
            if (szInput[i] == szInput[j])
                ++CountThatOne;
        }
        if (CountThatOne > MaxCountSoFar_1) {
            MaxCountSoFar_2 = MaxCountSoFar_1;
            MaxIndexSoFar_2 = MaxIndexSoFar_1;
            MaxCountSoFar_1 = CountThatOne;
            MaxIndexSoFar_1 = i;
        }
        else {
            if (CountThatOne > MaxCountSoFar_2 && szInput[i] != szInput[MaxIndexSoFar_1]) {
                MaxCountSoFar_2 = CountThatOne;
                MaxIndexSoFar_2 = i;
            }
        }
    }
    if (MaxIndexSoFar_1 >= 0) {
        printf ("Most seen char is %c, first seen at index %d\n", szInput [MaxIndexSoFar_1], MaxIndexSoFar_1);
        if (MaxIndexSoFar_2 >= 0) {
            printf ("Second Most seen char is %c, first seen at index %d\n", szInput [MaxIndexSoFar_2], MaxIndexSoFar_2);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20868252_20868422_24_46
20868252_20868510_4_24
Title: Using Pointers and strtok() 
----------------------------------------

int main () {
    char input [] = "invest_#_1945_#_TRADE";
    char *array [3];
    char *p;
    int i, size = sizeof (array) / sizeof (char *);
    for (i = 0, p = input; i < size; ++i) {
        if (NULL != (p = strtokByWord (p, "_#_"))) {
            array[i] = p;
            p = NULL;
        }
        else {
            array[i] = NULL;
            break;
        }
    }
    for (i = 0; i < size; ++i)
        printf ("array[%d]=\"%s\"\n", i, array[i]);
    return 0;
}
----------------------------------------

int main () {
    const char *line = "invest_#_1945 _#_TRADE  ";
    char word [40];
    int year;
    char def [40];
    int n;
    n = sscanf (line, "%40[^_]_#_%d_#_%40s", word, &year, def);
    if (n == 3) {
        printf ("word:   %s\n", word);
        printf ("year:   %d\n", year);
        printf ("def'n:  %s\n", def);
    }
    else {
        printf ("Unrecognized line.\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20894531_20894700_37_50
20894531_20897319_1_11
Title: How to move the linked list from the last list to the front list in C? 
----------------------------------------

void moveThesis () {
    currentptr = headptr;
    if (currentptr == NULL || currentptr->ptrnext == NULL)
        return;
    while (currentptr->ptrnext != NULL) {
        previousptr = currentptr;
        currentptr = currentptr->ptrnext;
    }
    struct thesis *lastNode = currentptr;
    previousptr->ptrnext = NULL;
    lastNode->ptrnext = headptr;
    headptr = lastNode;
}
----------------------------------------

void moveThesis () {
    currentptr = headptr;
    if (currentptr == NULL || currentptr->ptr == NULL)
        return;
    while (currentptr->ptrnext->ptrnext != NULL)
        currentptr = currentptr->ptrnext;
    currentptr->ptrnext->ptrnext = headptr;
    headptr = curerntptr->ptrnext;
    curerntptr->ptrnext = NULL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20898609_20899797_12_47
20898609_20899928_16_50
Title: Bitwise array error 
----------------------------------------

int main (int argc, char *argv []) {
    mp3_Header first;
    unsigned int memory_int [4];
    FILE *file = fopen ("song.dat", "rb");
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_int, sizeof (memory_int), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    printf ("This is first.size before sync_safe: %x %x %x %x\n", memory_int [0], memory_int [1], memory_int [2], memory_int [3]);
    memory_int[0] = 0x4212;
    memory_int[1] = 0x4213;
    memory_int[2] = 0x4214;
    memory_int[3] = 0x4215;
    first.size = (memory_int[3] & 0x000F) | ((memory_int[2] & 0x000F) << 8) | ((memory_int[1] & 0x000F) << 16) | ((memory_int[0] & 0x000F) << 24);
    printf ("This is first.size after sync_safe: %x\n", first.size);
    fclose (file);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    unsigned int memory_int [4] = {0};
    mp3_Header first;
    FILE *file = fopen ("song.mp3", "rb");
    if (!file) {
        printf ("Unable to open the file for reading\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_int, sizeof (memory_int), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    printf ("This is first.size before sync_safe: %u %u %u %u\n", memory_int [0], memory_int [1], memory_int [2], memory_int [3]);
    first.size = (memory_int[3] & 0xFF) | ((memory_int[2] & 0xFF) << 7) | ((memory_int[1] & 0xFF) << 14) | ((memory_int[0] & 0xFF) << 21);
    printf ("This is first.size after sync_safe: %u\n", first.size);
    fclose (file);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20898609_20899797_12_47
20898609_20927820_12_113
Title: Bitwise array error 
----------------------------------------

int main (int argc, char *argv []) {
    mp3_Header first;
    unsigned int memory_int [4];
    FILE *file = fopen ("song.dat", "rb");
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_int, sizeof (memory_int), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    printf ("This is first.size before sync_safe: %x %x %x %x\n", memory_int [0], memory_int [1], memory_int [2], memory_int [3]);
    memory_int[0] = 0x4212;
    memory_int[1] = 0x4213;
    memory_int[2] = 0x4214;
    memory_int[3] = 0x4215;
    first.size = (memory_int[3] & 0x000F) | ((memory_int[2] & 0x000F) << 8) | ((memory_int[1] & 0x000F) << 16) | ((memory_int[0] & 0x000F) << 24);
    printf ("This is first.size after sync_safe: %x\n", first.size);
    fclose (file);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    mp3_Header first;
    unsigned int memory_int [4];
    uint32_t memory_int_2 [4];
    char memory [4];
    unsigned char memory_2 [4];
    FILE *file = fopen ("song.mp3", "rb");
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_int, sizeof (memory_int), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (&first.size, sizeof (first.size), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_int_2, sizeof (memory_int_2), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory, sizeof (memory), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_2, sizeof (memory_2), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    printf ("This is memory_int[0] before sync_safe: %u %u %u %u\n", memory_int [0], memory_int [1], memory_int [2], memory_int [3]);
    printf ("This is first.size before sync_safe: %" PRIu32 "\n", first.size);
    printf ("This is memory_int_2[0] before sync_safe with PRIu32: %" PRIu32 " %" PRIu32 " %" PRIu32 " %" PRIu32 "\n", memory_int_2 [0], memory_int_2 [1], memory_int_2 [2], memory_int_2 [3]);
    printf ("This is memory[0] before sync_safe: %d %d %d %d\n", memory [0], memory [1], memory [2], memory [3]);
    printf ("This is memory before sync_safe: %s\n", memory);
    printf ("This is memory_2[0] before sync_safe: %d %d %d %d\n", memory_2 [0], memory_2 [1], memory_2 [2], memory_2 [3]);
    printf ("This is memory_2 before sync_safe: %s\n", memory_2);
    first.size = (memory_int[3] & 0xFF) | ((memory_int[2] & 0xFF) << 7) | ((memory_int[1] & 0xFF) << 14) | ((memory_int[0] & 0xFF) << 21);
    printf ("This is first.size after sync_safe: %" PRIu32 "\n", first.size);
    first.size = (first.size & 0xFF);
    printf ("This is first.size after sync_safe: %" PRIu32 "\n", first.size);
    first.size = (memory[3] & 0xFF) | ((memory[2] & 0xFF) << 7) | ((memory[1] & 0xFF) << 14) | ((memory[0] & 0xFF) << 21);
    printf ("This is first.size after sync_safe: %" PRIu32 "\n", first.size);
    first.size = (memory_2[3] & 0xFF) | ((memory_2[2] & 0xFF) << 7) | ((memory_2[1] & 0xFF) << 14) | ((memory_2[0] & 0xFF) << 21);
    printf ("This is first.size after sync_safe: %" PRIu32 "\n", first.size);
    fclose (file);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20898609_20899928_16_50
20898609_20927820_12_113
Title: Bitwise array error 
----------------------------------------

int main (int argc, char *argv []) {
    unsigned int memory_int [4] = {0};
    mp3_Header first;
    FILE *file = fopen ("song.mp3", "rb");
    if (!file) {
        printf ("Unable to open the file for reading\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_int, sizeof (memory_int), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    printf ("This is first.size before sync_safe: %u %u %u %u\n", memory_int [0], memory_int [1], memory_int [2], memory_int [3]);
    first.size = (memory_int[3] & 0xFF) | ((memory_int[2] & 0xFF) << 7) | ((memory_int[1] & 0xFF) << 14) | ((memory_int[0] & 0xFF) << 21);
    printf ("This is first.size after sync_safe: %u\n", first.size);
    fclose (file);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    mp3_Header first;
    unsigned int memory_int [4];
    uint32_t memory_int_2 [4];
    char memory [4];
    unsigned char memory_2 [4];
    FILE *file = fopen ("song.mp3", "rb");
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_int, sizeof (memory_int), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (&first.size, sizeof (first.size), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_int_2, sizeof (memory_int_2), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory, sizeof (memory), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    if (fseek (file, 6, SEEK_SET) == -1) {
        fprintf (stderr, "Not able to fseek at possition 6");
        return EXIT_FAILURE;
    }
    if (fread (memory_2, sizeof (memory_2), 1, file) != 1) {
        printf ("Could not read first.size\n");
        exit (0);
    }
    printf ("This is memory_int[0] before sync_safe: %u %u %u %u\n", memory_int [0], memory_int [1], memory_int [2], memory_int [3]);
    printf ("This is first.size before sync_safe: %" PRIu32 "\n", first.size);
    printf ("This is memory_int_2[0] before sync_safe with PRIu32: %" PRIu32 " %" PRIu32 " %" PRIu32 " %" PRIu32 "\n", memory_int_2 [0], memory_int_2 [1], memory_int_2 [2], memory_int_2 [3]);
    printf ("This is memory[0] before sync_safe: %d %d %d %d\n", memory [0], memory [1], memory [2], memory [3]);
    printf ("This is memory before sync_safe: %s\n", memory);
    printf ("This is memory_2[0] before sync_safe: %d %d %d %d\n", memory_2 [0], memory_2 [1], memory_2 [2], memory_2 [3]);
    printf ("This is memory_2 before sync_safe: %s\n", memory_2);
    first.size = (memory_int[3] & 0xFF) | ((memory_int[2] & 0xFF) << 7) | ((memory_int[1] & 0xFF) << 14) | ((memory_int[0] & 0xFF) << 21);
    printf ("This is first.size after sync_safe: %" PRIu32 "\n", first.size);
    first.size = (first.size & 0xFF);
    printf ("This is first.size after sync_safe: %" PRIu32 "\n", first.size);
    first.size = (memory[3] & 0xFF) | ((memory[2] & 0xFF) << 7) | ((memory[1] & 0xFF) << 14) | ((memory[0] & 0xFF) << 21);
    printf ("This is first.size after sync_safe: %" PRIu32 "\n", first.size);
    first.size = (memory_2[3] & 0xFF) | ((memory_2[2] & 0xFF) << 7) | ((memory_2[1] & 0xFF) << 14) | ((memory_2[0] & 0xFF) << 21);
    printf ("This is first.size after sync_safe: %" PRIu32 "\n", first.size);
    fclose (file);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20916602_20916736_4_18
20916602_20917482_1_20
Title: Search a String in a string (strings are input by user) 
----------------------------------------

int main () {
    char in1 [10000];
    char in2 [10000];
    int i;
    scanf ("%s", in1);
    scanf ("%s", in2);
    char *result = strstr (in1, in2);
    if (result != NULL)
        printf ("%ld\n", strstr (in1, in2) - in1 + 1);
    else
        printf ("No match\n");
    return 0;
}
----------------------------------------

int main () {
    char in1 [10000];
    char in2 [10000];
    fgets (in1, sizeof (in1), stdin);
    {
        size_t len = strlen (in1);
        if (in1[len - 1] == '\n')
            in1[len - 1] = 0;
    }
    fgets (in2, sizeof (in2), stdin);
    {
        size_t len = strlen (in2);
        if (in2[len - 1] == '\n')
            in2[len - 1] = 0;
    }
    char *match = strstr (in1, in2);
    if (match) {
        printf ("%td\n", match - in1 + 1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20918533_20918580_7_18
20918533_20919811_1_21
Title: "evaluating ""long long int "" in c" 
----------------------------------------

int main () {
    long long int number = 1234567LL;
    char buf [20] = "";
    if (str (buf, number)[1] == '2') {
        printf ("yes");
    }
    else {
        printf ("No");
    }
    printf ("\n");
    return 0;
}
----------------------------------------

please give me comment on the code Thy this code it uses division to find of number of digits and uses division and modulo to digits at different positions void main () {
    long long int i, x = 1234567;
    int n = 0;
    i = x;
    for (; i != 0; i /= 10) {
        n++;
    }
    printf ("number of digits %d\n", n);
    for (; x != 0; x /= 10, n--) {
        printf ("element at %d is %d\n", n, x % 10);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20923165_26781209_2_29
20923165_29509207_2_42
Title: Gray codes addition 
----------------------------------------

unsigned add_gray (unsigned lhs, unsigned rhs) {
    bool e = __builtin_parity (lhs);
    bool f = __builtin_parity (rhs);
    unsigned res = 0u;
    for (unsigned i = 0u; i < CHAR_BIT * sizeof (unsigned); ++i) {
        bool lhs_i = (lhs >> i) & 1u;
        bool rhs_i = (rhs >> i) & 1u;
        bool e_cpy = e;
        bool f_cpy = f;
        unsigned res_i = (e_cpy & f_cpy) ^ lhs_i ^ rhs_i;
        res |= (res_i << i);
        e = (e_cpy & (!f_cpy)) ^ lhs_i;
        f = ((!e_cpy) & f_cpy) ^ rhs_i;
    }
    return res;
}
----------------------------------------

unsigned add_gray (unsigned lhs, unsigned rhs) {
    unsigned lhs_base = hyperfloor (lhs);
    unsigned rhs_base = hyperfloor (rhs);
    if (lhs_base == rhs_base) {
        if (lhs == rhs) {
            return (lhs << 1u) ^ __builtin_parity (lhs);
        }
        return (lhs_base << 1u) ^ add_gray (lhs_base ^ lhs, lhs_base ^ rhs);
    }
    if (lhs_base < rhs_base) {
        swap (& lhs, & rhs);
        swap (& lhs_base, & rhs_base);
    }
    if (lhs == lhs_base) {
        return lhs ^ rhs;
    }
    unsigned tmp = add_gray (lhs ^ lhs_base, rhs);
    if (hyperfloor (tmp) < lhs_base) {
        return lhs_base ^ tmp;
    }
    return (lhs_base << 1u) ^ (lhs_base ^ tmp);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20938782_20938909_1_42
20938782_20949402_29_61
Title: Redirect stdout of one process to two processes 
----------------------------------------

int main (int argc, char *argv []) {
    int fds1 [2], fds2 [2];
    char buffer [120];
    int size;
    pipe (fds1);
    pipe (fds2);
    if (fork () == 0) {
        close (0);
        dup (fds1 [1]);
        close (fds1 [0]);
        close (fds1 [1]);
        close (fds2 [0]);
        close (fds2 [1]);
        execl (argv [1], argv [1], NULL);
    }
    if (fork () == 0) {
        close (0);
        dup (fds2 [1]);
        close (fds1 [0]);
        close (fds1 [1]);
        close (fds2 [0]);
        close (fds2 [1]);
        execl (argv [2], argv [2], NULL);
    }
    close (fds1 [1]);
    close (fds2 [1]);
    while ((size = read (0, buffer, 120)) != 0) {
        printf ("lido: %s\n", buffer);
        write (fds1 [0], buffer, size);
        write (fds2 [0], buffer, size);
    }
    close (fds1 [0]);
    close (fds1 [0]);
    exit (0);
}
----------------------------------------

int main (int argc, char **argv) {
    size_t i, r;
    FILE **pipes;
    char buf [BUFSIZ];
    pipes = malloc (((argc - 1) * sizeof *pipes));
    if (!pipes)
        exit (EXIT_FAILURE);
    for (i = 1; i < argc; i++) {
        pipes[i - 1] = popen (argv[i], "w");
        if (!pipes[i - 1]) {
            fprintf (stderr, "Can not open pipe to '%s\'\n", argv [i]);
            close_pipes (pipes, argc);
            exit (EXIT_FAILURE);
        }
    }
    argc--;
    while (!feof (stdin) && (!ferror (stdin))) {
        r = fread (buf, sizeof (char), BUFSIZ, stdin);
        for (i = 0; i < argc; i++) {
            if (fwrite (buf, sizeof (char), r, pipes[i]) != r) {
                fprintf (stderr, "Write error to `%s\'\n", argv [i + 1]);
                close_pipes (pipes, argc);
                exit (EXIT_FAILURE);
            }
        }
    }
    exit (close_pipes (pipes, argc));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20939225_20939585_5_30
20939225_20939638_5_20
Title: Removing dots in a string in C 
----------------------------------------

int main (int argc, char *argv []) {
    int dotless_length = 30;
    char dotless [dotless_length];
    int k = 0;
    int i = 0;
    while (argv[1][k] != '\0' && i < dotless_length) {
        if (argv[1][k] >= 48 && argv[1][k] <= 57) {
            dotless[i] = argv[1][k];
            i++;
        }
        else if (argv[1][k] != '.') {
            printf ("invalid input:  %c\n", argv [1] [k]);
            return 1;
        }
        k++;
    }
    dotless[i] = '\0';
    printf ("Account number without dots: %s\n", dotless);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char s [30];
    int k = 0;
    printf ("Enter your account number including dots. \n");
    gets (s);
    printf ("Account number without dots:");
    for (k = 0; k < 30; k++) {
        if (s[k] != '.' && s[k] != 0) {
            printf ("%c", s [k]);
        }
        k++;
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20939225_20939585_5_30
20939225_20939690_5_17
Title: Removing dots in a string in C 
----------------------------------------

int main (int argc, char *argv []) {
    int dotless_length = 30;
    char dotless [dotless_length];
    int k = 0;
    int i = 0;
    while (argv[1][k] != '\0' && i < dotless_length) {
        if (argv[1][k] >= 48 && argv[1][k] <= 57) {
            dotless[i] = argv[1][k];
            i++;
        }
        else if (argv[1][k] != '.') {
            printf ("invalid input:  %c\n", argv [1] [k]);
            return 1;
        }
        k++;
    }
    dotless[i] = '\0';
    printf ("Account number without dots: %s\n", dotless);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char s [30];
    int k = 0;
    printf ("Enter your account number including dots. \n");
    gets (s);
    printf ("Account number without dots:");
    while (s [k] != 0) {if (s [k] == '.') s [k] = s [k + 1];
    k++;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20939225_20939638_5_20
20939225_20939690_5_17
Title: Removing dots in a string in C 
----------------------------------------

int main (int argc, char *argv []) {
    char s [30];
    int k = 0;
    printf ("Enter your account number including dots. \n");
    gets (s);
    printf ("Account number without dots:");
    for (k = 0; k < 30; k++) {
        if (s[k] != '.' && s[k] != 0) {
            printf ("%c", s [k]);
        }
        k++;
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char s [30];
    int k = 0;
    printf ("Enter your account number including dots. \n");
    gets (s);
    printf ("Account number without dots:");
    while (s [k] != 0) {if (s [k] == '.') s [k] = s [k + 1];
    k++;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20941547_20941567_1_12
20941547_20941582_16_31
Title: Malloc in a loop causing memory leak 
----------------------------------------

int main (void) {
    int *point;
    int i;
    for (counter = 0; counter < 100; counter++) {
        point = get_point ();
        free (point);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int *point = NULL;
    int i;
    for (counter = 0; counter < 100; counter++) {
        point = get_point (point);
        if (point) {
            free (point);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20942692_20961665_8_26
20942692_20986053_11_41
Title: Only print input lines longer than 10 characters (ANSI C) 
----------------------------------------

int main (void) {
    char input [MAX];
    int i, ch;
    for (i = 0; i < MAX - 1 && (ch = getchar ()) != EOF; ++i)
        input[i] = ch;
    input[i] = '\0';
    for (i = 0; input[i] != '\0'; ++i) {
        if (input[i] == '\n') {
            examine (input, i);
        }
    }
    examine (input, i);
    return 0;
}
----------------------------------------

int main () {
    char input [MAX];
    char line [MAX];
    int i, i2;
    i2 = 0;
    for (i = 0; (input[i] = getchar ()) != EOF; ++i) {
    }
    input[i + 1] = '\0';
    putchar ('\n');
    for (i = 0; input[i] != '\0'; ++i) {
        line[i2] = input[i];
        ++i2;
        if (input[i] == '\n') {
            checkprint (line);
            i2 = 0;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20947003_20947779_9_27
20947003_20947810_8_25
Title: Error in reading a file in c language 
----------------------------------------

int main () {
    FILE *ptr;
    char buf [128];
    struct bank *cl = malloc (sizeof (struct bank));
    if ((ptr = fopen ("banking_r.dat", "rb")) == NULL)
        printf ("file can not be opened");
    else {
        while (fgets (buf, sizeof (buf), ptr)) {
            sscanf (buf, "%d %s %s %lf", & cl -> accn, cl -> last, cl -> first, & cl -> bal);
            printf ("%-4d %-10s %-10s %-4.2f\n", cl -> accn, cl -> last, cl -> first, cl -> bal);
        }
    }
    free (cl);
    return 0;
}
----------------------------------------

int main () {
    FILE *ptr;
    struct bank cl;
    if ((ptr = fopen ("banking_r.dat", "rb")) == NULL)
        printf ("file can not be opened");
    else {
        fread (& cl, sizeof (struct bank), 1, ptr);
        while (!feof (ptr)) {
            printf ("%-4d %-10s %-10s %-4.2f\n", cl.accn, cl.last, cl.first, cl.bal);
            fread (& cl, sizeof (struct bank), 1, ptr);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20950390_20950573_16_30
20950390_20951402_13_28
Title: issues with Signals in operating systems 
----------------------------------------

int main (void) {
    if (signal (SIGINT, sig_handler) == SIG_ERR)
        printf ("Error when setting up SIGINT handler\n");
    while (1) {
        if (current_signal == SIGINT)
            break;
        sleep (1);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    struct sigaction action;
    memset (& action, 0, sizeof (struct sigaction));
    action.sa_handler = sigint_handler;
    sigaction (SIGINT, & action, NULL);
    int line = 0;
    while (!done) {
        sleep (2);
        printf ("Finished line number %d.\n", line ++);
    }
    printf ("done.\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20991097_20996759_10_24
20991097_21015992_17_34
Title: how to make sure that a thread waiting for an event from two different timers will not miss any of the events? 
----------------------------------------

void *imageProcessThread () {
    int status = 0;
    status = pthread_mutex_lock (&imageProcessMutex);
    while (i < 2) {
        status = pthread_cond_wait (&imageProcessCond, &imageProcessMutex);
        printf ("signal received %s\n", __TIME__);
    }
    status = pthread_mutex_unlock (&imageProcessMutex);
}
----------------------------------------

void *imageProcessThread () {
    int status = 0;
    int i = 0;
    status = pthread_mutex_lock (&imageProcessMutex);
    while (i < 2) {
        status = pthread_cond_wait (&imageProcessCond, &imageProcessMutex);
        printf ("signal received %s\n", __TIME__);
        i++;
    }
    status = pthread_mutex_unlock (&imageProcessMutex);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20991097_20996759_26_39
20991097_21015992_36_56
Title: how to make sure that a thread waiting for an event from two different timers will not miss any of the events? 
----------------------------------------

void timerFunc1 () {
    int status = 0;
    status = pthread_mutex_lock (&imageProcessMutex);
    i++;
    printf ("timer1 took lock %s\n", __TIME__);
    status = pthread_cond_signal (&imageProcessCond);
    printf ("timer1 signalled %s\n", __TIME__);
    status = pthread_mutex_unlock (&imageProcessMutex);
    printf ("timer1 released lock %s\n", __TIME__);
}
----------------------------------------

void timerFunc1 () {
    int status = 0;
    status = pthread_mutex_lock (&mainMutex);
    status = pthread_mutex_lock (&imageProcessMutex);
    printf ("timer1 took image process lock %s\n", __TIME__);
    status = pthread_cond_signal (&imageProcessCond);
    printf ("timer1 signalled %s\n", __TIME__);
    status = pthread_mutex_unlock (&imageProcessMutex);
    printf ("timer1 released image process lock %s\n", __TIME__);
    status = pthread_mutex_unlock (&mainMutex);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20991097_20996759_41_54
20991097_21015992_58_78
Title: how to make sure that a thread waiting for an event from two different timers will not miss any of the events? 
----------------------------------------

void timerFunc2 () {
    int status = 0;
    status = pthread_mutex_lock (&imageProcessMutex);
    i++;
    printf ("timer2 took lock %s\n", __TIME__);
    status = pthread_cond_signal (&imageProcessCond);
    printf ("timer2 signalled %s\n", __TIME__);
    status = pthread_mutex_unlock (&imageProcessMutex);
    printf ("timer2 released lock %s\n", __TIME__);
}
----------------------------------------

void timerFunc2 () {
    int status = 0;
    status = pthread_mutex_lock (&mainMutex);
    status = pthread_mutex_lock (&imageProcessMutex);
    printf ("timer2 took image process lock %s\n", __TIME__);
    status = pthread_cond_signal (&imageProcessCond);
    printf ("timer2 signalled %s\n", __TIME__);
    status = pthread_mutex_unlock (&imageProcessMutex);
    printf ("timer2 released image lock %s\n", __TIME__);
    status = pthread_mutex_unlock (&mainMutex);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20999255_21019852_34_109
20999255_21053142_51_93
Title: Get the status of a specific PID 
----------------------------------------

int main (int argc, char *argv []) {
    pid_t cpid;
    char *mstr;
    int rc = -999999;
    int krc = 0;
    uint32_t timeoutWait = 10000;
    int count = 0;
    int loops = 0;
    signal (SIGUSR1, signalHandler);
    if (argc < 2) {
        printf ("usage: ./sigparent sleep-milliseconds [timeout-milliseconds]");
        exit - 1;
    }
    cpid = fork ();
    if (cpid == -1) {
        printf ("%d : failed to start child process.\n", errno);
        perror ("fork");
        exit (- 1);
    }
    if (cpid == 0) {
        execl ("sleeping_child", argv [1], (char *) NULL);
    }
    else {
        if (argc > 2)
            sscanf (argv[2], "%d", &timeoutWait);
        clock_t t1 = clock ();
        clock_t t2;
        do {
            if (count < 100000)
                count++;
            else {
                loops++;
                printf ("loops of 100000 duration = %d \n", loops);
                count = 0;
            }
            t2 = clock ();
            if (clockedMilliseconds (t1, t2) > timeoutWait) {
                krc = kill (cpid, 9);
                rc = 3;
                break;
            }
            if (stopOnSignal == true) {
                rc = 0;
                break;
            }
        }
        while (true);
        if (rc == -999999) {
            printf ("process failed horribly!\n");
        }
        else if (rc == 3) {
            if (krc == 0) {
                printf ("TIMEOUT, waiting %d ms on pid %d\n", timeoutWait, cpid);
            }
            else {
                printf ("%d : attempted TIMEOUT failed.\n", errno);
                perror ("kill");
            }
        }
        else {
            printf ("child process ended normally.\n");
        }
    }
    exit (0);
}
----------------------------------------

int main (int argc, char *argv []) {
    int sleepSecs;
    int timeoutSecs;
    if (argc < 3) {
        printf ("\nusage: %s sleep-seconds timeout-seconds\n\n", argv [0]);
        exit (EXIT_FAILURE);
    }
    sscanf (argv [1], "%d", & sleepSecs);
    sscanf (argv [2], "%d", & timeoutSecs);
    signal (SIGCHLD, childHandler);
    signal (SIGALRM, alarmHandler);
    if ((cpid = fork ()) == -1) {
        printf ("%d : failed to start child process.\n", errno);
        perror ("fork");
        exit (- 1);
    }
    if (cpid == 0) {
        execl ("./sleeping_child", "./sleeping_child", argv [1], (char *) NULL);
        perror ("execl");
        exit (EXIT_FAILURE);
    }
    else {
        alarm (timeoutSecs);
        while (!done) {
            sleep (1);
        }
        exit (0);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21009846_21010225_58_73
21009846_21010885_16_76
Title: Singly linked list c 
----------------------------------------

int main () {
    char **cs = (char **) malloc (sizeof (char *) * 5);
    int i = 0;
    int j = 0;
    for (; i < 5; ++i) {
        cs[i] = (char *) malloc (sizeof (char) * 31);
        for (j = 0; j < 30; ++j) {
            cs[i][j] = 'a';
        }
        cs[i][30] = 0;
    }
    Node n = new_node (NULL, cs, 5);
    printList (n);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    struct client *headcli = NULL, *newclient;
    struct item *it;
    newclient = calloc (1, sizeof (struct client));
    strcpy (newclient -> name, "John");
    newclient->next = headcli;
    headcli = newclient;
    it = calloc (1, sizeof (struct item));
    strcpy (it -> name, "Orange");
    it->next = newclient->headitem;
    newclient->headitem = it;
    it = calloc (1, sizeof (struct item));
    strcpy (it -> name, "Banana");
    it->next = newclient->headitem;
    newclient->headitem = it;
    newclient = calloc (1, sizeof (struct client));
    strcpy (newclient -> name, "Mary");
    newclient->next = headcli;
    headcli = newclient;
    it = calloc (1, sizeof (struct item));
    strcpy (it -> name, "Peach");
    it->next = newclient->headitem;
    newclient->headitem = it;
    for (newclient = headcli; newclient; newclient = newclient->next) {
        printf ("name: %s\n", newclient -> name);
        for (it = newclient->headitem; it; it = it->next) {
            printf ("item name: %s\n", it -> name);
        }
    }
    while (headcli) {
        newclient = headcli->next;
        while (headcli->headitem) {
            it = headcli->headitem->next;
            free (headcli -> headitem);
            headcli->headitem = it;
        }
        free (headcli);
        headcli = newclient;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21022387_21023402_27_40
21022387_21032325_1_19
Title: Pass a C Structure pointer from Python using Ctypes 
----------------------------------------

static PyObject *viapoint (PyObject *self, PyObject *args) {
    struct mec *m;
    if (!PyArg_ParseTuple (args, "l", &m))
        return NULL;
    printf ("viapoint av(c) age nb: %d et %d!\n", m -> age, m -> number);
    m->age = 10;
    m->number = 1;
    printf ("viapoint ap(c) age nb: %d et %d!\n", m -> age, m -> number);
    return Py_BuildValue ("i", m->age + m->number);
}
----------------------------------------

static PyObject *viapoint (PyObject *self, PyObject *args) {
    struct mec *m;
    size_t size;
    if (!PyArg_ParseTuple (args, "w#", &m, &size))
        return NULL;
    if (size != sizeof (struct mec)) {
        PyErr_SetString (PyExc_TypeError, "wrong buffer size");
        return NULL;
    }
    printf ("viapoint av(c) age nb: %d et %d!\n", m -> age, m -> number);
    m->age = 10;
    m->number = 1;
    return Py_BuildValue ("i", m->age + m->number);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21030780_21030829_2_14
21030780_21030883_2_17
Title: a c iterations while skipping given values in a do while loop 
----------------------------------------

main () {
    int i = 10;
    do {
        if (i == 30 || i == 70)
            continue;
        printf ("\n %d", i);
        i++;
    }
    while (i < 100);
    return 0;
}
----------------------------------------

main () {
    int i = 10;
    do {
        if (i != 30 && i != 70)
            printf ("\n %d", i);
        i += 10;
    }
    while (i <= 100);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21056195_21056534_6_22
21056195_21056681_2_20
Title: i'm trying to find the number that is used only once in an array. 
----------------------------------------

void t (int c, int a [] [2]) {
    int i, j;
    for (i = 0; i < c; i++) {
        for (j = 0; j < c; j++) {
            if (a[i][0] == a[j][0] && i != j) {
                a[i][1] = 1;
            }
        }
    }
    for (i = 0; i < c; i++) {
        if (a[i][1] == 0)
            printf ("%d\n", a[i][0]);
    }
}
----------------------------------------

void t (int c, int a []) {
    int i, j, find;
    for (i = 0; i < c; i++) {
        if (a[i] == 0)
            continue;
        find = 0;
        for (j = i + 1; j < c; j++) {
            if (a[i] == a[j]) {
                find = 1;
                a[j] = 0;
            }
        }
        if (find == 0)
            printf ("%d\n", a[i]);
        else
            a[i] = 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21058797_21059371_1_46
21058797_21059917_1_44
Title: How to read bytes until a certain character is encountered in C 
----------------------------------------

short ReadText (char *Path, short Offset) {
    size_t ReadResult;
    FILE *OpenedFile;
    short Position;
    int byte;
    unsigned char CurrentChar;
    char FormattedChar;
    char *FileContents;
    OpenedFile = fopen (Path, "r");
    if (OpenedFile == NULL) {
        printf ("---File not exist----\n");
        return;
    }
    fseek (OpenedFile, Offset, SEEK_SET);
    while (1) {
        unsigned int number;
        byte = fscanf (OpenedFile, "%x", &number);
        printf ("read ::%x\n", number);
        switch (number) {
        case 0x00 :
            FormattedChar = ' ';
            break;
        case 0x01 :
            FormattedChar = 'À';
            break;
        case 0x02 :
            FormattedChar = 'Á';
            break;
        case 0x03 :
            FormattedChar = 'Â';
            break;
            ........................................................................
        }
        if (number == 0xFF)
            break;
    }
    fclose (OpenedFile);
}
----------------------------------------

ssize_t ReadText (const char *Path, char *Dest, size_t DestSize, long *Offset) {
    FILE *OpenedFile;
    char FormattedChar;
    size_t i;
    OpenedFile = fopen (Path, "rb");
    if (OpenedFile == NULL)
        return -1;
    if (fseek (OpenedFile, *Offset, SEEK_SET)) {
        fclose (OpenedFile);
        return -1;
    }
    DestSize--;
    for (i = 0; i < DestSize; i++) {
        int CurrentChar = fgetc (OpenedFile);
        if (CurrentChar == EOF || CurrentChar == 0xFF)
            break;
        switch (CurrentChar) {
        case 0x00 :
            FormattedChar = ' ';
            break;
        case 0x01 :
            FormattedChar = 'À';
            break;
        }
        static const char XLate [256] = {' ', 'À', 'Á', 'Â'};
        FormattedChar = XLate[CurrentChar];
        Dest[i] = FormattedChar;
    }
    fclose (OpenedFile);
    Dest[i] = '\0';
    *Offset += i;
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21067930_21070415_79_100
21067930_21071310_1_13
Title: Linux reading from file strange behaviour 
----------------------------------------

void sig_hand (int sig) {
    char c;
    if (lseek (fd, 0, SEEK_SET) == (off_t) -1)
        errExit ("lseek");
    if (read (fd, &c, sizeof (char)) == -1)
        errExit ("read");
    c++;
    printf ("c = %d\n", c);
    if (lseek (fd, 0, SEEK_SET) == (off_t) -1)
        errExit ("lseek");
    printf ("PID %d is writing\n", getpid ());
    if (write (fd, &c, sizeof (char)) == -1)
        errExit ("write");
}
----------------------------------------

void sig_hand (int sig) {
    int x;
    char c [3];
    read (fd, c, 2);
    x = atoi (c);
    x++;
    printf ("x=%d\n", x);
    snprintf (c, 3, "%d", x);
    lseek (fd, 0, SEEK_SET);
    printf ("PID %d is writing\n", getpid ());
    write (fd, c, 2);
    lseek (fd, 0, SEEK_SET);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21084502_21084559_3_13
21084502_21084588_4_23
Title: Splitting string into strings of certain size in C 
----------------------------------------

int main (void) {
    int i;
    char values [32] = "abcd1234efgh";
    for (i = 0; values[i] != '\0';) {
        if (i % 4 == 0)
            printf ("\n");
        printf ("%c", values [i]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i, j;
    char values [32] = "abcd1234efgh12";
    char temp [10];
    for (i = 0; values[i] != '\0';) {
        for (j = 0; j < 4; j++, i++) {
            temp[j] = values[i];
        }
        while (j < 4) {
            temp[j] = ' ';
        }
        temp[j] = '\0';
        printf ("string temp:%s\n", temp);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21084502_21084559_3_13
21084502_21085647_4_20
Title: Splitting string into strings of certain size in C 
----------------------------------------

int main (void) {
    int i;
    char values [32] = "abcd1234efgh";
    for (i = 0; values[i] != '\0';) {
        if (i % 4 == 0)
            printf ("\n");
        printf ("%c", values [i]);
    }
    return 0;
}
----------------------------------------

int main () {
    char *str = "abcd1234efgh";
    size_t sub_len = 4;
    size_t len = strlen (str);
    size_t n = len / sub_len;
    if (n * sub_len < len)
        n += 1;
    char temp [n] [sub_len + 1];
    int i;
    for (i = 0; i < n; ++i) {
        strncpy (temp [i], str + i * sub_len, sub_len);
        temp[i][sub_len] = '\0';
        printf ("string temp:%s\n", temp [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21084502_21084588_4_23
21084502_21085647_4_20
Title: Splitting string into strings of certain size in C 
----------------------------------------

int main (void) {
    int i, j;
    char values [32] = "abcd1234efgh12";
    char temp [10];
    for (i = 0; values[i] != '\0';) {
        for (j = 0; j < 4; j++, i++) {
            temp[j] = values[i];
        }
        while (j < 4) {
            temp[j] = ' ';
        }
        temp[j] = '\0';
        printf ("string temp:%s\n", temp);
    }
    return 0;
}
----------------------------------------

int main () {
    char *str = "abcd1234efgh";
    size_t sub_len = 4;
    size_t len = strlen (str);
    size_t n = len / sub_len;
    if (n * sub_len < len)
        n += 1;
    char temp [n] [sub_len + 1];
    int i;
    for (i = 0; i < n; ++i) {
        strncpy (temp [i], str + i * sub_len, sub_len);
        temp[i][sub_len] = '\0';
        printf ("string temp:%s\n", temp [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21085160_21086639_8_59
21085160_44169192_1_20
Title: In a matrix put 0 in the row and column of a cell which contains 0 without using extra space 
----------------------------------------

int main () {
    constexpr size_t M = 3;
    constexpr size_t N = 3;
    int matrix [M] [N] = {{1, 2, 3}, {0, 4, 5}, {4, 2, 0}};
    vector < size_t > markedRows;
    vector < size_t > markedColumns;
    for (size_t ii = 0; ii < M; ++ii) {
        for (size_t jj = 0; jj < N; ++jj) {
            if (matrix[ii][jj] == 0) {
                markedRows.push_back (ii);
                markedColumns.push_back (jj);
            }
        }
    }
    sort (markedColumns.begin (), markedColumns.end ());
    markedRows.erase (unique (markedRows.begin (), markedRows.end ()), markedRows.end ());
    markedColumns.erase (unique (markedColumns.begin (), markedColumns.end ()), markedColumns.end ());
    vector < size_t > irow;
    vector < size_t > icol;
    vector < int > val;
    for (size_t ii = 0; ii < M; ++ii) {
        for (size_t jj = 0; jj < N; ++jj) {
            if ((find (markedRows.begin (), markedRows.end (), ii) == markedRows.end ()) && (find (markedColumns.begin (), markedColumns.end (), jj) == markedColumns.end ())) {
                irow.push_back (ii);
                icol.push_back (jj);
                val.push_back (matrix[ii][jj]);
            }
        }
    }
    for (size_t ii = 0; ii < irow.size (); ++ii) {
        cout << "A[" << irow[ii] << "," << icol[ii] << "] = " << val[ii] << endl;
    }
    return 0;
}
----------------------------------------

Int main () {
    int r = 6;
    int c = 3;
    int matrix [r] [c];
    for (int i = 0; i < r; ++i) {
        for (int j = 0; j < c; ++j) {
            if (matrix[i][j] == 0) {
                for (int ii = 0; ii < r; ++ii) {
                    Matrix[ii][j] = 0;
                }
                for (int jj = 0; jj < c; ++jj) {
                    Matrix[i][jj] = 0;
                }
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21094812_21094853_4_17
21094812_21094883_1_16
Title: first 50 positive numbers divisible by 4 
----------------------------------------

int main () {
    unsigned int n = 0;
    unsigned int i = 0;
    while (n < 50) {
        if (i % 4 == 0) {
            printf ("%d\n", i);
            ++n;
        }
        ++i;
    }
    return 0;
}
----------------------------------------

int main () {
    int x = 0;
    int i = 0;
    while (i < 50) {
        if (x % 4 == 0) {
            printf ("(result %d) %d is divisible by 4\n", i, x);
            i++;
        }
        x++;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21094812_21094853_4_17
21094812_21094891_4_16
Title: first 50 positive numbers divisible by 4 
----------------------------------------

int main () {
    unsigned int n = 0;
    unsigned int i = 0;
    while (n < 50) {
        if (i % 4 == 0) {
            printf ("%d\n", i);
            ++n;
        }
        ++i;
    }
    return 0;
}
----------------------------------------

int main () {
    int i = 0, count = 1;
    while (1) {
        if (i % 4 == 0)
            printf ("%d\n", i);
        i++;
        if (count++ == 50)
            break;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21094812_21094853_4_17
21094812_21096148_4_21
Title: first 50 positive numbers divisible by 4 
----------------------------------------

int main () {
    unsigned int n = 0;
    unsigned int i = 0;
    while (n < 50) {
        if (i % 4 == 0) {
            printf ("%d\n", i);
            ++n;
        }
        ++i;
    }
    return 0;
}
----------------------------------------

int main () {
    int x = 0, i;
    for (i = 0; i <= 50; i++) {
        for (;;) {
            if (x % 4 == 0) {
                printf ("\n%d", x);
                x++;
                break;
            }
            x++;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21094812_21094883_1_16
21094812_21094891_4_16
Title: first 50 positive numbers divisible by 4 
----------------------------------------

int main () {
    int x = 0;
    int i = 0;
    while (i < 50) {
        if (x % 4 == 0) {
            printf ("(result %d) %d is divisible by 4\n", i, x);
            i++;
        }
        x++;
    }
    return 0;
}
----------------------------------------

int main () {
    int i = 0, count = 1;
    while (1) {
        if (i % 4 == 0)
            printf ("%d\n", i);
        i++;
        if (count++ == 50)
            break;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21094812_21094883_1_16
21094812_21096148_4_21
Title: first 50 positive numbers divisible by 4 
----------------------------------------

int main () {
    int x = 0;
    int i = 0;
    while (i < 50) {
        if (x % 4 == 0) {
            printf ("(result %d) %d is divisible by 4\n", i, x);
            i++;
        }
        x++;
    }
    return 0;
}
----------------------------------------

int main () {
    int x = 0, i;
    for (i = 0; i <= 50; i++) {
        for (;;) {
            if (x % 4 == 0) {
                printf ("\n%d", x);
                x++;
                break;
            }
            x++;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21094812_21094891_4_16
21094812_21096148_4_21
Title: first 50 positive numbers divisible by 4 
----------------------------------------

int main () {
    int i = 0, count = 1;
    while (1) {
        if (i % 4 == 0)
            printf ("%d\n", i);
        i++;
        if (count++ == 50)
            break;
    }
    return 0;
}
----------------------------------------

int main () {
    int x = 0, i;
    for (i = 0; i <= 50; i++) {
        for (;;) {
            if (x % 4 == 0) {
                printf ("\n%d", x);
                x++;
                break;
            }
            x++;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21128981_21131733_3_12
21128981_21152570_3_16
Title: Finding GCD of Array Code C language 
----------------------------------------

unsigned gcd (unsigned x, unsigned y) {
    unsigned wk;
    if (x < y) {
        wk = x;
        x = y;
        y = wk;
    }
    while (y) {
        wk = x % y;
        x = y;
        y = wk;
    }
    return x;
}
----------------------------------------

static int gcd (int x, int y) {
    int r;
    if (x <= 0 || y <= 0)
        return (0);
    while ((r = x % y) != 0) {
        x = y;
        y = r;
    }
    return (y);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21128981_21131733_3_12
21128981_32711921_4_13
Title: Finding GCD of Array Code C language 
----------------------------------------

unsigned gcd (unsigned x, unsigned y) {
    unsigned wk;
    if (x < y) {
        wk = x;
        x = y;
        y = wk;
    }
    while (y) {
        wk = x % y;
        x = y;
        y = wk;
    }
    return x;
}
----------------------------------------

int gcd (int a, int b) {
    int t;
    while (a) {
        t = a;
        a = b % a;
        b = t;
    }
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21128981_21131733_3_12
21128981_41124096_4_14
Title: Finding GCD of Array Code C language 
----------------------------------------

unsigned gcd (unsigned x, unsigned y) {
    unsigned wk;
    if (x < y) {
        wk = x;
        x = y;
        y = wk;
    }
    while (y) {
        wk = x % y;
        x = y;
        y = wk;
    }
    return x;
}
----------------------------------------

int gcd (int a, int b) {
    int r;
    while (a) {
        r = b % a;
        b = a;
        a = r;
    }
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21128981_21152570_3_16
21128981_32711921_4_13
Title: Finding GCD of Array Code C language 
----------------------------------------

static int gcd (int x, int y) {
    int r;
    if (x <= 0 || y <= 0)
        return (0);
    while ((r = x % y) != 0) {
        x = y;
        y = r;
    }
    return (y);
}
----------------------------------------

int gcd (int a, int b) {
    int t;
    while (a) {
        t = a;
        a = b % a;
        b = t;
    }
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21128981_21152570_3_16
21128981_41124096_4_14
Title: Finding GCD of Array Code C language 
----------------------------------------

static int gcd (int x, int y) {
    int r;
    if (x <= 0 || y <= 0)
        return (0);
    while ((r = x % y) != 0) {
        x = y;
        y = r;
    }
    return (y);
}
----------------------------------------

int gcd (int a, int b) {
    int r;
    while (a) {
        r = b % a;
        b = a;
        a = r;
    }
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21128981_32711921_15_39
21128981_37752911_4_47
Title: Finding GCD of Array Code C language 
----------------------------------------

int main () {
    int n;
    cout << "how many numbers (Max 10): ";
    cin >> n;
    cin.ignore ();
    cout << endl;
    int arr [n - 1];
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    int ans;
    ans = arr[0];
    for (int j = 0; j < n; ++j) {
        ans = gcd (ans, arr[j]);
    }
    cout << "GCD = " << ans;
    return 0;
}
----------------------------------------

int main () {
    int i, j, n, flag = 0, small, *data;
    printf ("Enter the number of inputs:");
    scanf ("%d", & n);
    data = (int *) malloc (sizeof (int) * n);
    for (i = 0; i < n; i++) {
        printf ("Data[%d]: ", i);
        scanf ("%d", & data [i]);
    }
    small = data[0];
    for (i = 1; i < n; i++) {
        if (data[i] < small)
            small = data[i];
    }
    for (i = small; i > 0; i--) {
        for (j = 0; j < n; j++) {
            if (data[j] % i != 0) {
                flag = 1;
            }
        }
        if (!flag) {
            printf ("GCD of given %d numbers is %d\n", n, i);
            break;
        }
        flag = 0;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21128981_32711921_4_13
21128981_41124096_4_14
Title: Finding GCD of Array Code C language 
----------------------------------------

int gcd (int a, int b) {
    int t;
    while (a) {
        t = a;
        a = b % a;
        b = t;
    }
    return b;
}
----------------------------------------

int gcd (int a, int b) {
    int r;
    while (a) {
        r = b % a;
        b = a;
        a = r;
    }
    return b;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21136364_21136436_4_13
21136364_21136536_10_23
Title: Create file with defined size 
----------------------------------------

int main () {
    FILE *pFile;
    pFile = fopen ("example.txt", "wb");
    fputs ("This is an apple.", pFile);
    fseek (pFile, 1024 * 1024, SEEK_SET);
    fputs (" sam", pFile);
    fclose (pFile);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    FILE *f;
    int i;
    memset (chunk, 0, CHUNK);
    f = fopen ("/tmp/myfile", "w");
    if (f == NULL)
        return 1;
    for (i = 0; i < NUMCHUNKS; ++i) {
        fwrite (chunk, CHUNK, 1, f);
    }
    fclose (f);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21145313_21145526_2_29
21145313_21150200_12_24
Title: "If condition on modulo failing logical condition?" 
----------------------------------------

int main () {
    int a, b;
    printf ("\n\nInput integers for fraction:");
    scanf (" %d%d", & a, & b);
    while (a % 2 == 0 && b % 2 == 0) {
        a /= 2;
        b /= 2;
    }
    while (a % 3 == 0 && b % 3 == 0) {
        a /= 3;
        b /= 3;
    }
    while (a % 5 == 0 && b % 5 == 0) {
        a /= 5;
        b /= 5;
    }
    while (a % 7 == 0 && b % 7 == 0) {
        a /= 7;
        b /= 7;
    }
    printf ("Simplified Fraction is %d/%d", a, b);
}
----------------------------------------

int main () {
    int a, b;
    for (;;) {
        printf ("\nInput positive fraction like 12/30: ");
        if (scanf ("%u/%u", &a, &b) != 2)
            break;
        unsigned g = gcd (a, b);
        a /= g;
        b /= g;
        printf ("Simplified Fraction is %u/%u", a, b);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2119061_2119166_4_25
2119061_2119234_10_51
Title: Convert Linux C Char Array to Int 
----------------------------------------

int main (int argc, char **argv) {
    char test1 [5] = "1234A";
    char test2 [5] = "ABCDE";
    uint32_t val = 0;
    if (convertFirstFourChars ((char *) test1, &val) == 0) {
        printf ("conversion of %s succeeded, value = %ld\n", test1, val);
    }
    else {
        printf ("conversion of %s failed!\n", test1);
    }
    if (convertFirstFourChars ((char *) test2, &val) == 0) {
        printf ("conversion succeeded of %s, value = %ld\n", test2, val);
    }
    else {
        printf ("conversion of %s failed!\n", test2);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int i, nRead, fd;
    int source;
    int STATE_OK = 0;
    int STATE_WARNING = 1;
    int STATE_CRITICAL = 2;
    int STATE_UNKNOWN = 3;
    int system_paused = 0;
    char buf [5];
    int testnumber;
    if ((fd = open (argv[1], O_RDONLY)) == -1) {
        printf ("failed open : %s", argv [1]);
        return STATE_UNKNOWN;
    }
    else {
        nRead = read (fd, buf, 5);
    }
    close (source);
    if (buf[4] == 'P') {
        printf ("Software Paused");
        return STATE_WARNING;
    }
    time_t ltime;
    struct tm *Tm;
    ltime = time (NULL);
    Tm = localtime (&ltime);
    int test;
    test = Tm->tm_hour + Tm->tm_min;
    printf ("%d\n", test);
    printf ("%d\n", atoi (buf));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21200118_21200200_3_26
21200118_39077558_2_23
Title: How to check whether a no is factorial or not? 
----------------------------------------

int main (void) {
    unsigned long long last = 1ULL, current = 2ULL, mult = 2ULL;
    size_t szOut;
    puts ("int isFactorial (unsigned long long num) {");
    puts ("    static const unsigned long long arr[] = {");
    szOut = printf ("        %lluULL,", last);
    while (current / mult == last) {
        if (szOut > 50)
            szOut = printf ("\n       ") - 1;
        szOut += printf (" %lluULL,", current);
        last = current;
        current *= ++mult;
    }
    puts ("\n    };");
    puts ("    static const size_t len = sizeof (arr) / sizeof (*arr);");
    puts ("    for (size_t idx = 0; idx < len; idx++)");
    puts ("        if (arr[idx] == num)");
    puts ("            return 1;");
    puts ("    return 0;");
    puts ("}");
    return 0;
}
----------------------------------------

int main () {
    int b [19];
    int i, j = 0;
    int k, l;
    for (i = 0; i <= 19; i++) {
        k = i + 1;
        b[i] = factorial (k);
    }
    printf ("enter a number\n");
    scanf ("%d", & l);
    for (j = 0; j <= 19; j++) {
        if (l == b[j]) {
            printf ("given number is a factorial of %d\n", j + 1);
        }
        if (j == 19 && l != b[j]) {
            printf ("given number is not a factorial number\n");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21222008_21222076_3_16
21222008_35325649_3_14
Title: How to reuse a Array variable in C using pointers 
----------------------------------------

int main () {
    char *sample = "From whence cometh my help?\n";
    char *ptr = sample;
    while (putchar (*sample++))
        ;
    putchar ('\n');
    sample = ptr;
    puts (sample);
    return (0);
}
----------------------------------------

int main () {
    char *sample = "From whence cometh my help?\n";
    char *temp = sample;
    while (putchar (*sample++))
        ;
    sample = temp;
    puts (sample);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21227259_21227289_1_27
21227259_21227315_1_15
Title: "How do Arrays work in the ""for"" loop (C language)" 
----------------------------------------

int main () {
    int input [1];
    int total = 0;
    int n;
    printf ("Please enter the number of elements to add: ");
    scanf ("%d", & n);
    for (int i = 0; i < n; i++) {
        printf ("Please enter integer %d: ", (i + 1));
        scanf ("%d", & input [i]);
    }
    for (int i = 0; i < n; i++) {
        total = total + input[i];
    }
    printf ("The sum is = ", total);
}
----------------------------------------

int main () {
    int input [2];
    for (int i = 0; i < 2; i++) {
        printf ("Please enter an integer: ");
        scanf ("%d", & input [i]);
    }
    int total = input[0] + input[1];
    printf ("%d + %d = %d ", input [0], input [1], total);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21227259_21227289_1_27
21227259_21227361_1_15
Title: "How do Arrays work in the ""for"" loop (C language)" 
----------------------------------------

int main () {
    int input [1];
    int total = 0;
    int n;
    printf ("Please enter the number of elements to add: ");
    scanf ("%d", & n);
    for (int i = 0; i < n; i++) {
        printf ("Please enter integer %d: ", (i + 1));
        scanf ("%d", & input [i]);
    }
    for (int i = 0; i < n; i++) {
        total = total + input[i];
    }
    printf ("The sum is = ", total);
}
----------------------------------------

int main () {
    int input [1];
    for (int i = 0; i <= 2; i++) {
        printf ("Please enter an integer: ");
        scanf ("%d", & input [i]);
    }
    int total = input[0] + input[1];
    printf ("%d + %d = %d ", input [0], input [1], total);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21227259_21227315_1_15
21227259_21227361_1_15
Title: "How do Arrays work in the ""for"" loop (C language)" 
----------------------------------------

int main () {
    int input [2];
    for (int i = 0; i < 2; i++) {
        printf ("Please enter an integer: ");
        scanf ("%d", & input [i]);
    }
    int total = input[0] + input[1];
    printf ("%d + %d = %d ", input [0], input [1], total);
}
----------------------------------------

int main () {
    int input [1];
    for (int i = 0; i <= 2; i++) {
        printf ("Please enter an integer: ");
        scanf ("%d", & input [i]);
    }
    int total = input[0] + input[1];
    printf ("%d + %d = %d ", input [0], input [1], total);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21255180_21255638_11_33
21255180_21256039_4_22
Title: How can I rewrite this to C? 
----------------------------------------

int main () {
    char *prefix = "the ";
    char *str = "not a list";
    char result [32];
    char sub1 [16], sub2 [16];
    int i = 4, len = strlen (str);
    sprintf (result, "%s%c", prefix, str [i]);
    printf ("%s\n", result);
    strncpy (sub1, str, i);
    sub1[i] = '\0';
    strncpy (sub2, str + i + 1, len - (i + 1));
    sub2[len - (i + 1)] = '\0';
    sprintf (result, "%s%s", sub1, sub2);
    printf ("%s\n", result);
    sprintf (result, "%s%s", substring (sub1, str, 0, i), substring (sub2, str, i + 1, len));
    printf ("%s\n", result);
    return 0;
}
----------------------------------------

int main () {
    const char *str = "book keeper";
    const char *prefix = "A nice ";
    char buffer [40];
    int i, n;
    i = 4;
    n = snprintf (buffer, 40, "%.*s%s", i, str, str +i + 1);
    printf ("'%s'\n", buffer);
    i = 3;
    n = snprintf (buffer, 40, "%s%c", prefix, str[i]);
    printf ("'%s'\n", buffer);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21274463_21276590_2_26
21274463_21276643_2_18
Title: Deque implementation based on doubly linked list not working 
----------------------------------------

void addqatbeg (struct queue *q, int item) {
    struct node *temp;
    temp = (struct node *) malloc (sizeof (struct node));
    if (temp == NULL) {
        printf ("queue is full\n");
        return;
    }
    temp->data = item;
    temp->prev = temp->next = NULL;
    if (q->front == NULL) {
        q->rear = q->front = temp;
    }
    else {
        temp->next = q->front;
        q->front->prev = temp;
        q->front = temp;
    }
}
----------------------------------------

void addqatbeg (struct queue *q, int item) {
    struct node *temp;
    temp = (struct node *) malloc (sizeof (struct node));
    if (temp == NULL)
        printf ("queue is full\n");
    if (q->front == NULL) {
        q->rear = q->front = temp;
        q->front->data = item;
        return;
    }
    q->front->next = temp;
    q->front = q->front->next;
    q->front->data = item;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21277307_21277855_1_15
21277307_21279849_10_33
Title: How do I remove SEGFAULT here? 
----------------------------------------

void readFile (char *filename) {
    int c;
    file = fopen (filename, "r");
    if (file == NULL) {
        printf ("Cannot open file '%s' : %s\n", filename, strerror (errno));
        return;
    }
    printf ("The contents of the file are:\n");
    while ((c = fgetc (file)) != EOF) {
        printf ("%c", c);
    }
    return;
}
----------------------------------------

int readFile (char *filename) {
    int c;
    file = fopen (filename, "r");
    if (file == NULL)
        return OPEN_ERROR;
    printf ("The contents of file '%s' are:\n", filename);
    while ((c = fgetc (file)) != EOF)
        printf ("%c", c);
    if (feof (file))
        c = 0;
    else
        c = READ_ERROR;
    return c;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21294012_21295076_12_26
21294012_21295670_14_26
Title: C: I can't display the content of an array [CodeBlocks] 
----------------------------------------

int main () {
    int i;
    set a, temp;
    temp = (set) malloc (maxLength * sizeof (short int));
    for (i = 0; i < maxLength; i++)
        temp[i] = i + 10;
    a = copyarr (temp);
    for (i = 0; i < maxLength; i++)
        printf ("%d ", a[i]);
    free (a);
    free (temp);
    return 0;
}
----------------------------------------

int main () {
    int i;
    set a, temp;
    temp = malloc (maxLength * sizeof (short int));
    for (i = 0; i < maxLength; i++)
        temp[i] = i + 10;
    copyarr (& a, temp);
    for (i = 0; i < maxLength; i++)
        printf ("%d ", a[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21299217_21301025_1_11
21299217_21304055_19_29
Title: Bubble Sort using pointers to function 
----------------------------------------

void bubbleSort (void **base, size_t length, int (*compar) (const void *, const void *)) {
    int i, j;
    int *ptr = &(*base);
    for (i = 0; i < length; i++) {
        for (j = 1; j < length; j++) {
            if ((*compar) (&ptr[i], &ptr[j]) < 0) {
                swap (& ptr [i], & ptr [j]);
            }
        }
    }
}
----------------------------------------

void bubbleSort (void *base, size_t length, size_t type_size, int (*compar) (const void *, const void *)) {
    int i, j;
    for (i = 0; i < length - 1; ++i) {
        for (j = i + 1; j < length; ++j) {
            char *data_i = (char *) base + type_size * i;
            char *data_j = (char *) base + type_size * j;
            if (compar (data_i, data_j) > 0)
                swap (data_i, data_j, type_size);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2130712_2130728_1_18
2130712_2130792_10_70
Title: Sorting digits of an integer 
----------------------------------------

int main () {
    int x = 0;
    cin >> x;
    for (int l = 0; l < 10; ++l) {
        int rem = x % 10;
        int tx = x / 10;
        while (rem || tx) {
            if (rem == l)
                cout << rem;
            rem = tx % 10;
            tx = tx / 10;
        }
    }
    cout << endl;
}
----------------------------------------

int main (int argc, char *argv []) {
    int zeros = 0;
    int ones = 0;
    int twos = 0;
    int threes = 0;
    int fours = 0;
    int fives = 0;
    int sixes = 0;
    int sevens = 0;
    int eights = 0;
    int nines = 0;
    long num = 0;
    if (argc > 1) {
        char *eptr;
        num = strtol (argv[1], &eptr, 0);
        if (*eptr) {
            fprintf (stderr, "Invalid number: '%s', using 0.\n", argv [1]);
            num = 0;
        }
    }
    do {
        switch (num % 10) {
        case 0 :
            ++zeros;
            break;
        case 1 :
            ++ones;
            break;
        case 2 :
            ++twos;
            break;
        case 3 :
            ++threes;
            break;
        case 4 :
            ++fours;
            break;
        case 5 :
            ++fives;
            break;
        case 6 :
            ++sixes;
            break;
        case 7 :
            ++sevens;
            break;
        case 8 :
            ++eights;
            break;
        case 9 :
            ++nines;
            break;
        default :
            break;
        }
    }
    while ((num /= 10));
    pput (zeros, '0');
    pput (ones, '1');
    pput (twos, '2');
    pput (threes, '3');
    pput (fours, '4');
    pput (fives, '5');
    pput (sixes, '6');
    pput (sevens, '7');
    pput (eights, '8');
    pput (nines, '9');
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21331610_21331849_5_35
21331610_21331891_5_34
Title: How to accept password in terminal without showing password 
----------------------------------------

int main (int argc, char **argv) {
    struct termios oflags, nflags;
    char password [128];
    tcgetattr (fileno (stdin), & oflags);
    nflags = oflags;
    nflags.c_lflag &= ~ECHO;
    nflags.c_lflag |= ECHONL;
    if (tcsetattr (fileno (stdin), TCSADRAIN, &nflags) != 0) {
        perror ("tcsetattr");
        return -1;
    }
    printf ("\npassword(Echo Disabled) : ");
    fgets (password, sizeof (password), stdin);
    password[strlen (password) - 1] = 0;
    printf ("Entered password        : %s\n", password);
    if (tcsetattr (fileno (stdin), TCSANOW, &oflags) != 0) {
        perror ("tcsetattr");
        return -1;
    }
    printf ("\npassword(Echo Enabled)  : ");
    fgets (password, sizeof (password), stdin);
    password[strlen (password) - 1] = 0;
    printf ("Entered password        : %s\n", password);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    struct termios oflags, nflags;
    char password [64];
    tcgetattr (fileno (stdin), & oflags);
    nflags = oflags;
    nflags.c_lflag &= ~ECHO;
    nflags.c_lflag |= ECHONL;
    if (tcsetattr (fileno (stdin), TCSANOW, &nflags) != 0) {
        perror ("tcsetattr");
        return EXIT_FAILURE;
    }
    printf ("password: ");
    fgets (password, sizeof (password), stdin);
    password[strlen (password) - 1] = 0;
    printf ("you typed '%s'\n", password);
    if (tcsetattr (fileno (stdin), TCSANOW, &oflags) != 0) {
        perror ("tcsetattr");
        return EXIT_FAILURE;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21338215_21338320_4_15
21338215_21338390_3_18
Title: Library function for finding the larger of two numbers 
----------------------------------------

int main () {
    float a, b, c;
    printf ("Enter three numbers: ");
    scanf ("%f %f %f", & a, & b, & c);
    if (a >= b && a >= c)
        printf ("Largest number = %.2f", a);
    if (b >= a && b >= c)
        printf ("Largest number = %.2f", b);
    if (c >= a && c >= b)
        printf ("Largest number = %.2f", c);
    return 0;
}
----------------------------------------

int main () {
    int a, b;
    scanf ("%d %d", & a, & b);
    if (a < b)
        printf ("%d is less than %d\n", a, b);
    if (a == b)
        printf ("%d is equal to %d\n", a, b);
    if (a > b)
        printf ("%d is greater than %d\n", a, b);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21345631_21345774_10_43
21345631_21348369_5_36
Title: Logic in detecting int in C 
----------------------------------------

unsigned int findInt () {
    char input;
    char buf [100];
    char *temp;
    long num = 0;
    int b = 0;
    printf ("please enter an int:\n");
    fgets (buf, 100, stdin);
    temp = buf;
    do {
        sscanf (temp ++, "%c", & input);
        if (isdigit (input)) {
            num = num * 10 + input - '0';
            b = 1;
        }
        else if (input == '\n') {
            b = 1;
            break;
        }
        else {
            b = 0;
            break;
        }
    }
    while (input != '\n');
    if (b == 1)
        printf ("Great! %d is an integer!\n", num);
    else {
        printf ("Not an int \n");
        findInt ();
    }
    return 0;
}
----------------------------------------

void findInt () {
    int x;
    bool ok;
    do {
        char buff [32], *endp;
        long long num;
        ok = true;
        printf ("Enter a number: ");
        fgets (buff, sizeof (buff), stdin);
        x = (int) (num = strtoll (buff, &endp, 0));
        if (*endp != '\n') {
            if (*endp == '\0') {
                printf ("Too large!\n");
                while ('\n' != getchar ())
                    ;
            }
            else {
                printf ("Character that can't be interpreted as a number has been entered.\n");
                printf ("%s", buff);
                printf ("%*s^\n", (int) (endp - buff), "");
            }
            ok = false;
        }
        else if (num > INT_MAX) {
            printf ("Too large!\n");
            ok = false;
        }
        else if (num < INT_MIN) {
            printf ("Too small!\n");
            ok = false;
        }
    }
    while (!ok);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21359463_21359495_6_22
21359463_21361051_7_19
Title: C Programming: How to write char after malloc? 
----------------------------------------

int main (void) {
    char *charArray = malloc ((SIZECHAR + 1) * sizeof (char));
    int i;
    for (i = 0; i < SIZECHAR; i++) {
        charArray[i] = (char) ('0' + i % 10);
    }
    charArray[SIZECHAR] = '\0';
    printf ("%s\n", charArray);
    return 0;
}
----------------------------------------

int main (void) {
    char *charArray = malloc ((SIZECHAR + 1) * sizeof (char));
    char *p = strcpy (charArray, "helloworld");
    printf ("top of address : %p\n", (void *) charArray);
    while (*p != '\0') {
        printf ("the current pointer is %p(%c)\n", (void *) p, * p);
        ++p;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21376410_21376516_1_12
21376410_21376528_22_33
Title: "How to make a copy of a string and return its address assign that to a pointer and print the new string in C?" 
----------------------------------------

char *make_copy (const char *s) {
    if (s != NULL) {
        const size_t size = strlen (s) + 1;
        char *d = malloc (size);
        if (d != NULL)
            strcpy (d, s);
        return d;
    }
    return NULL;
}
----------------------------------------

char *make_copy (char arr [], int size) {
    char *str_ptr = NULL;
    str_ptr = (char *) malloc (size +1);
    int i = 0;
    for (; i < size; i++)
        str_ptr[i] = arr[i];
    str_ptr[i] = 0;
    return str_ptr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21415502_21415573_3_30
21415502_21444519_7_42
Title: Understanding Arrays and Functions 
----------------------------------------

int main (void) {
    int person, i;
    int pancake [50];
    printf ("Enter Number Of People: ");
    scanf ("%d", & person);
    char name [person] [30];
    for (i = 0; i < person; i++) {
        printf ("Person [%d]: ", i + 1);
        scanf ("%d", & pancake [i]);
        printf ("Person %d name: ", i + 1);
        getchar ();
        fgets (name [i], 30, stdin);
    }
    for (i = 0; i < person - 1; i++) {
        if (pancake[0] < pancake[i + 1]) {
            pancake[0] = pancake[i + 1];
            strcpy (name [0], name [i + 1]);
        }
    }
    printf ("Most pancakes eaten is %d by %s \n", pancake [0], name [0]);
}
----------------------------------------

int main (void) {
    int person, i;
    int pancake [NUM_PANCAKES];
    int best_index = 0;
    int most_pancakes = 0;
    printf ("Enter Number Of People: ");
    scanf ("%d", & person);
    char name [person] [NAME_LENGTH_MAX];
    for (i = 0; i < person; i++) {
        printf ("Person [%d]: ", i + 1);
        scanf ("%d", & pancake [i]);
        printf ("Person %d name: ", i + 1);
        getchar ();
        fgets (name [i], NAME_LENGTH_MAX, stdin);
    }
    for (i = 0; i < person - 1; i++) {
        if (pancake[i] > most_pancakes) {
            most_pancackes = pancake[i];
            best_index = i;
        }
    }
    printf ("Most pancakes eaten is %d by %s \n", pancake [best_index], name [best_index]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21420665_21420838_1_21
21420665_21420913_1_14
Title: Adding node to end of singly linked list 
----------------------------------------

void slist_add_back (struct slist *l, char *str) {
    struct snode *currentNode = l->front;
    if (currentNode != NULL) {
        struct snode *temp = (struct snode *) malloc (sizeof (struct snode));
        while (currentNode->next != NULL) {
            l->counter++;
            currentNode = currentNode->next;
        }
        l->counter++;
        currentNode->next = temp;
        l->back = temp;
        temp->next = NULL;
    }
}
----------------------------------------

void slist_add_back (struct slist *l, char *str) {
    struct snode *temp = malloc (sizeof (struct snode));
    temp->next = NULL;
    if (!l->back) {
        l->front = temp;
    }
    else {
        l->back->next = temp;
    }
    l->back = temp;
    l->counter++;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21439216_21439311_1_14
21439216_21444812_4_16
Title: How to print the sum of even number in c using do-while loop 
----------------------------------------

int main () {
    int counter = 0, sum = 0;
    do {
        if (counter % 2 == 0) {
            sum += counter;
        }
    }
    while (counter <= 30);
    printf ("Sum of even number:=%d", sum);
    getch ();
    return 0;
}
----------------------------------------

int main () {
    int counter = 0, sum = 0;
    do {
        if (counter != 0) {
            printf ("%d\n", counter);
            sum += counter;
        }
    }
    while ((counter += 2) <= 30);
    printf ("sum = %d\n", sum);
    getch ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21442088_21442682_1_35
21442088_26154877_1_41
Title: Computing the floor of log_2(x) using only bitwise operators in C 
----------------------------------------

int ilog2 (int x) {
    int i, j, k, l, m;
    x = x | (x >> 1);
    x = x | (x >> 2);
    x = x | (x >> 4);
    x = x | (x >> 8);
    x = x | (x >> 16);
    i = 0x55 | (0x55 << 8);
    i = i | (i << 16);
    j = 0x33 | (0x33 << 8);
    j = j | (j << 16);
    k = 0x0f | (0x0f << 8);
    k = k | (k << 16);
    l = 0xff | (0xff << 16);
    m = 0xff | (0xff << 8);
    x = (x & i) + ((x >> 1) & i);
    x = (x & j) + ((x >> 2) & j);
    x = (x & k) + ((x >> 4) & k);
    x = (x & l) + ((x >> 8) & l);
    x = (x & m) + ((x >> 16) & m);
    x = x + ~0;
    return x;
}
----------------------------------------

int ilog2 (int x) {
    int byte_count = 0;
    int y = 0;
    y = x >> 0x8;
    byte_count += ((!!y) << 3);
    y = x >> 0x10;
    byte_count += ((!!y) << 3);
    y = (x >> 0x18) & 0xff;
    byte_count += ((!!y) << 3);
    x = (x >> byte_count) & 0xff;
    x = x >> 1;
    byte_count += !!x;
    x = x >> 1;
    byte_count += !!x;
    x = x >> 1;
    byte_count += !!x;
    x = x >> 1;
    byte_count += !!x;
    x = x >> 1;
    byte_count += !!x;
    x = x >> 1;
    byte_count += !!x;
    x = x >> 1;
    byte_count += !!x;
    x = x >> 1;
    byte_count += !!x;
    return byte_count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21447366_21447523_1_38
21447366_21447624_1_28
Title: Print integer as character digits (no arrays/printf/etc...) 
----------------------------------------

void my_int (int x) {
    int n;
    int copy;
    char digit;
    if (!x) {
        my_char ('0');
        return;
    }
    if (x < 0) {
        x = x * -1;
        my_char ('-');
    }
    n = 1;
    copy = x / 10;
    while (copy) {
        n *= 10;
        copy /= 10;
    }
    while (n) {
        digit = x / n;
        my_char (digit + '0');
        x -= digit * n;
        n /= 10;
    }
}
----------------------------------------

void my_int (int x) {
    int temp = 0;
    int divFactor = 10;
    if (x == 0) {
        my_char ('0');
        return;
    }
    if (x < 0) {
        x = x * -1;
        my_char ('-');
    }
    temp = x;
    while ((temp /= 10) > 10) {
        divFactor *= 10;
    }
    for (; divFactor > 0; divFactor /= 10) {
        temp = x;
        temp /= divFactor;
        my_char (temp + '0');
        x -= divFactor * temp;
    }
    printf ("\n done!");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21447366_21447523_1_38
21447366_21447639_1_23
Title: Print integer as character digits (no arrays/printf/etc...) 
----------------------------------------

void my_int (int x) {
    int n;
    int copy;
    char digit;
    if (!x) {
        my_char ('0');
        return;
    }
    if (x < 0) {
        x = x * -1;
        my_char ('-');
    }
    n = 1;
    copy = x / 10;
    while (copy) {
        n *= 10;
        copy /= 10;
    }
    while (n) {
        digit = x / n;
        my_char (digit + '0');
        x -= digit * n;
        n /= 10;
    }
}
----------------------------------------

void my_int (int x) {
    int n = 1000000000;
    if (x == 0) {
        my_char ('0');
        return;
    }
    if (x == INT_MIN) {
        my_char ('-');
        my_char ('2');
        my_char ('1');
        my_char ('4');
        my_char ('7');
        my_char ('4');
        my_char ('8');
        my_char ('3');
        my_char ('6');
        my_char ('4');
        my_char ('8');
        return;
    }
    if (x < 0) {
        x *= -1;
        my_char ('-');
    }
    while (n > x)
        n /= 10;
    while (n != 0) {
        my_char (x / n % 10 + '0');
        n /= 10;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21447366_21447624_1_28
21447366_21447639_1_23
Title: Print integer as character digits (no arrays/printf/etc...) 
----------------------------------------

void my_int (int x) {
    int temp = 0;
    int divFactor = 10;
    if (x == 0) {
        my_char ('0');
        return;
    }
    if (x < 0) {
        x = x * -1;
        my_char ('-');
    }
    temp = x;
    while ((temp /= 10) > 10) {
        divFactor *= 10;
    }
    for (; divFactor > 0; divFactor /= 10) {
        temp = x;
        temp /= divFactor;
        my_char (temp + '0');
        x -= divFactor * temp;
    }
    printf ("\n done!");
}
----------------------------------------

void my_int (int x) {
    int n = 1000000000;
    if (x == 0) {
        my_char ('0');
        return;
    }
    if (x == INT_MIN) {
        my_char ('-');
        my_char ('2');
        my_char ('1');
        my_char ('4');
        my_char ('7');
        my_char ('4');
        my_char ('8');
        my_char ('3');
        my_char ('6');
        my_char ('4');
        my_char ('8');
        return;
    }
    if (x < 0) {
        x *= -1;
        my_char ('-');
    }
    while (n > x)
        n /= 10;
    while (n != 0) {
        my_char (x / n % 10 + '0');
        n /= 10;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
21469156_21469284_1_14
21469156_21469306_1_20
Title: How do I return different strings from each call on a function in C? 
----------------------------------------

char *getStr (int aNumber) {
    char *str = malloc (15);
    if (!str)
        return NULL;
    if (aNumber == 0)
        strcpy (str, "this");
    else if (aNumber == 1)
        strcpy (str, "that");
    else
        strcpy (str, "nope");
    return str;
}
----------------------------------------

char *getStr (int aNumber) {
    char *str = malloc (15);
    if (!str)
        return NULL;
    if (aNumber == 0)
        str = "this";
    else if (aNumber == 1)
        str = "that";
    else
        str = "nope";
    return reg;
}
----------------------------------------
