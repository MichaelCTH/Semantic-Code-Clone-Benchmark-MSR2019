$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47555212_47556090_1_24
47555212_47556525_1_34
Title: Check if my matrix is magic square 
----------------------------------------

void printmatrix (int *mat, int dimension) {
    int i, j;
    int magic = 1;
    int d1 = 0, d2 = 0, refcount = 0;
    for (i = 0; i < dimension; i++) {
        int rowcount = 0;
        int colcount = 0;
        for (j = 0; j < dimension; j++) {
            int num = *(mat + i * dimension + j);
            rowcount += num;
            if (i == j)
                d1 += num;
            if (i == dimension - j - 1)
                d2 += num;
            colcount += *(mat + j * dimension + i);
        }
        if (!i)
            refcount = rowcount;
        else if (refcount != rowcount)
            magic = 0;
        if (refcount != colcount)
            magic = 0;
    }
    if (d1 != refcount || d2 != refcount)
        magic = 0;
    printf ("Is Magic: %s\n", magic ? "Yes" : "No");
}
----------------------------------------

void printmatrix (const int *mat, int dimension) {
    int i, j;
    int ismagicsquare = 1;
    int diagonal1 = 0, diagonal2 = 0;
    for (i = 0; i < dimension; i++) {
        diagonal1 += mat[i * dimension + i];
        diagonal2 += mat[i * dimension + dimension - 1 - i];
    }
    if (diagonal1 != diagonal2) {
        ismagicsquare = 0;
    }
    for (i = 0; i < dimension; i++) {
        int rowscount = 0;
        int colscount = 0;
        for (j = 0; j < dimension; j++) {
            rowscount += mat[i * dimension + j];
            colscount += mat[j * dimension + i];
            printf ("%d\t", mat [i * dimension + j]);
        }
        if (rowscount != diagonal1 || colscount != diagonal1) {
            ismagicsquare = 0;
        }
        printf ("\n\n");
    }
    printf ("ismagicsquare = %i\n", ismagicsquare);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47585218_47585461_12_52
47585218_47585612_11_43
Title: C compiler error: undefined reference to function 
----------------------------------------

int main (void) {
    int i;
    int length;
    printf ("\nEnter the host of students: ");
    while (scanf ("%d", &length) < 1) {
        puts ("Please enter a number");
        int c;
        while ((c = getchar ()) != '\n' && c != EOF) {
            continue;
        }
    }
    struct student list [length];
    for (i = 0; i < length; i++) {
        StudentScan (i, list);
    }
    return 0;
}
----------------------------------------

int main () {
    int i = 0;
    int length;
    struct student *studentp;
    printf ("Enter the host of students:");
    scanf ("%d", & length);
    struct student list [length];
    studentp = malloc (length * sizeof (struct student));
    if (studentp == NULL) {
        printf ("Out of memory!");
        return 0;
    }
    for (i = 0; i < length; i++) {
        printf ("Enter first name :");
        scanf ("%s", list [i].firstName);
        printf ("Enter average number: ");
        scanf ("%1s", list [i].AverageNum);
    }
    for (i = 0; i < length; i++) {
        printf ("number of host is: %d , his/her first name: %s , his/her avg number: %s \n", i, list [i].firstName, list [i].AverageNum);
    }
    free (studentp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47585955_47585976_5_31
47585955_47586017_5_20
Title: Determine maximum value of array using a function in c 
----------------------------------------

int main (void) {
    int i, size;
    printf ("Enter total number of elements (1 to 100): \n");
    if (scanf ("%d", &size) != 1) {
        fprintf (stderr, "Error in input");
        exit (1);
    }
    if (size < 1 && size > 100) {
        fprintf (stderr, "Wrong input.");
        exit (1);
    }
    float num [size];
    for (i = 0; i < size; i++) {
        printf ("Enter Number %d: ", i);
        if (scanf ("%f", &num[i]) != 1) {
            fprintf (stderr, "Error in input");
            exit (1);
        }
    }
    printf ("Largest Number: %f", mymaximum (size, num));
    return 0;
}
----------------------------------------

int main () {
    int i, size;
    printf ("Enter total number of elements (1 to 100): \n");
    scanf ("%d", & size);
    float num [100];
    for (i = 0; i < size; i++) {
        printf ("Enter Number %d: ", i);
        scanf ("%f", & num [i]);
    }
    printf ("Largest Number: %f", maximum (num, size);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47586868_47587676_1_23
47586868_47587807_77_94
Title: Array in the function does not display correctly 
----------------------------------------

int teamscore (int a [NROW] [NCOL]) {
    int x, y, highest, team;
    double sum;
    for (x = 0; x < NROW; x++) {
        sum = 0;
        for (y = 0; y < NCOL; y++) {
            sum = sum + a[x][y];
        }
        a[x][0] = sum;
    }
    highest = a[0][0];
    team = 0;
    for (x = 0;
    x < NROW;
    x ++) if (a [x] [0] > highest) {highest = a [x] [0];
    team = x;
}
----------------------------------------

int teamscore (int a [NROW] [NCOL]) {
    int x, y, highest = 0, hi_index = 0, sum [NROW] = {0};
    for (x = 0; x < NROW; x++) {
        for (y = 0; y < NCOL; y++)
            sum[x] += a[x][y];
        if (sum[x] > highest) {
            highest = sum[x];
            hi_index = x;
        }
    }
    return hi_index;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47587691_47588419_50_64
47587691_47590340_9_88
Title: Read last column of the file and compare the data using c 
----------------------------------------

int main () {
    file1 = fopen ("input.txt", "r");
    if (!file1)
        return 0;
    out1 = fopen ("out.txt", "w");
    if (!out1)
        return 0;
    Extract_Node_value (ELEMENTS, END_ELEMENTS);
    fclose (file1);
    fclose (out1);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int col = 0;
    char buf [MAXC] = "", *val = NULL, *rep = NULL, *delim = " \n";
    FILE *ifp = NULL, *ofp = NULL;
    if (argc < 3) {
        fprintf (stderr, "error: insufficient input\n" "usage: %s infile outfile [find replace]\n", argv [0]);
        return 1;
    }
    ifp = fopen (argv[1], "r");
    ofp = fopen (argv[2], "w");
    if (!ifp || !ofp) {
        fprintf (stderr, "error: file open failed\n");
        return 1;
    }
    errno = 0;
    val = argc > 3 ? argv[3] : "2";
    rep = argc > 4 ? argv[4] : "4";
    col = argc > 4 ? (int) strtol (argv[5], NULL, 10) : -1;
    if (errno) {
        perror ("strtol failure 1");
        exit (EXIT_FAILURE);
    }
    if (strlen (val) != strlen (rep)) {
        fprintf (stderr, "error: length of 'val' & 'rep' differ.\n");
        exit (EXIT_FAILURE);
    }
    while (fgets (buf, MAXC, ifp)) {
        char cpy [MAXC] = "", *p = cpy, *ep = cpy;
        int cidx = 0;
        strcpy (cpy, buf);
        for (p = strtok (p, delim); p; p = strtok (NULL, delim)) {
            if (isdigit (*p) == 0)
                goto labelline;
            if (cidx == col) {
                if (strcmp (p, val) == 0) {
                    char *rp = rep;
                    size_t off = p - cpy;
                    for (; *rp && off + 3 < MAXC; rp++)
                        buf[off++] = *rp;
                }
            }
            ep = p;
            cidx++;
        }
        if (col == -1) {
            p = ep;
            if (strcmp (p, val) == 0) {
                char *rp = rep;
                size_t off = p - cpy;
                for (; *rp && off + 3 < MAXC; rp++)
                    buf[off++] = *rp;
            }
        }
    labelline :
        ;
        fprintf (ofp, "%s", buf);
    }
    fclose (ifp);
    if (fclose (ofp)) {
        fprintf (stderr, "error: stream error after write.\n");
        exit (EXIT_FAILURE);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47607517_47608715_21_46
47607517_47609726_68_83
Title: Sorting an array of integers in alternate fashion using qsort function. 
----------------------------------------

int main () {
    int arr [] = {1, 4, 7, 2, 9, 3, 0, 8, 6, 5};
    enum {size = sizeof arr / sizeof *arr};
    assert (! (size & 1));
    qsort (arr, (size + 1) / 2, 2 * sizeof * arr, (int (*) (const void *, const void *)) & compOdd);
    puts ("Odd elements sorted:");
    printArray (size / 2, arr + 1, 2);
    int arrRes [(size + 1) / 2];
    for (size_t i = 1; i < size; i += 2)
        arrRes[i / 2] = arr[i];
    qsort (arr, (size + 1) / 2, 2 * sizeof * arr, (int (*) (const void *, const void *)) & compEven);
    puts ("Even elements sorted:");
    printArray ((size + 1) / 2, arr, 2);
    for (size_t i = 1; i < size; i += 2)
        arr[i] = arrRes[i / 2];
    puts ("Merged elements:");
    printArray (size, arr, 1);
    return 0;
}
----------------------------------------

int main (void) {
    int arr [] = {1, 4, 7, 2, 9, 3, 0, 8, 6, 5};
    const size_t N = sizeof arr / sizeof *arr;
    print_arr (arr, N);
    PCMPFN compares [] = {descending_cmp_int, untouched_cmp_int, ascending_cmp_int};
    const size_t K = sizeof compares / sizeof *compares;
    alternate_sort (arr, N, compares, K);
    print_arr (arr, N);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47619929_47620153_1_19
47619929_47620284_10_26
Title: Initialization of structure - C 
----------------------------------------

Colas *bucle (int length) {
    Colas *cola = malloc (sizeof *cola);
    if (cola == NULL) {
        fprintf (stderr, "%s\n", "Error in malloc");
        exit (1);
    }
    cola->length = length;
    cola->charge = malloc (cola->length * sizeof *cola->charge);
    if (cola->charge == NULL) {
        fprintf (stderr, "%s\n", "Error in malloc");
        exit (1);
    }
    float seed = 3.5;
    for (int i = 0; i < length; i++) {
        cola->charge[i] = seed / (i + 1);
    }
    return cola;
}
----------------------------------------

Colas *bucle (int length) {
    Colas *cola = malloc (sizeof (Colas));
    cola->charge = malloc (length * sizeof (float));
    cola->length = length;
    for (int i = 0; i < length; i++) {
        cola->charge[i] = (float) i;
        printf ("InBucle: %f\n", cola -> charge [i]);
    }
    return cola;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47638353_47638578_4_20
47638353_47693773_37_61
Title: Strange letter print out from array c programming 
----------------------------------------

int main () {
    char inputString [] = {"hello big panda"};
    int k = 0;
    int i = 0;
    while (isalpha (inputString[i])) {
        i++;
    }
    inputString[i] = '\0';
    printf ("%s", inputString);
    return 0;
}
----------------------------------------

int main (void) {
    char str [] = "hello big panda";
    int nchars = 0;
    nchars = prnword (str, 0);
    nchars += prnword (str +nchars, 0);
    nchars += prnword (str +nchars, 0);
    putchar ('\n');
    nchars = 0;
    nchars += prnword (str, 3);
    putchar ('\n');
    nchars = 0;
    nchars = prnword (str, 1);
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47639448_47640819_8_83
47639448_47640875_84_107
Title: Bubble sort in c linked list 
----------------------------------------

int main (void) {
    FILE *ifp = fopen ("mintaadatok.txt", "r");
    if (!ifp) {
        printf ("file error\n");
        return 0;
    }
    char buffer [1024];
    memset (buffer, 0, 1024);
    while (fgets (buffer, 1024, ifp)) {
        struct node *temp = malloc (sizeof (struct node));
        temp->next = NULL;
        if (sscanf (buffer, "%19[^,], %d", temp->name, &temp->id) != 2) {
            free (temp);
            break;
        }
        if (!head) {
            head = temp;
        }
        else {
            temp->next = head;
            head = temp;
        }
    }
    struct node *loop1 = head;
    while (loop1) {
        int swapped = 0;
        struct node *loop2 = loop1->next;
        while (loop2) {
            if (loop1->id > loop2->id) {
                char name [20];
                strcpy (name, loop1 -> name);
                strcpy (loop1 -> name, loop2 -> name);
                strcpy (loop2 -> name, name);
                int id = loop1->id;
                loop1->id = loop2->id;
                loop2->id = id;
                swapped = 1;
            }
            loop2 = loop2->next;
        }
        if (!swapped)
            break;
        loop1 = loop1->next;
    }
    loop1 = head;
    while (loop1) {
        printf ("%s %d\n", loop1 -> name, loop1 -> id);
        loop1 = loop1->next;
    }
    return 0;
}
----------------------------------------

int main (void) {
    struct node *head = NULL;
    push_back (& head, "NameA", 25);
    push_back (& head, "NameB", 33);
    push_back (& head, "NameC", 23);
    push_back (& head, "NameD", 39);
    display (& head);
    putchar ('\n');
    bubble_sort (& head, cmp_id);
    display (& head);
    putchar ('\n');
    bubble_sort (& head, cmp_name);
    display (& head);
    putchar ('\n');
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47646225_47646322_1_17
47646225_47646805_1_25
Title: why if condition is working in a weird way 
----------------------------------------

int searchBST (int key, node *root) {
    if (!root) {
        return 0;
    }
    if (root->data == key) {
        printf ("The key %d is in the tree.\n", key);
        return 1;
    }
    if (root->left != NULL) {
        return searchBST (key, root->left);
    }
    if (root->right != NULL) {
        return searchBST (key, root->right);
    }
}
----------------------------------------

int searchBST (int key, node *root) {
    int bRet = 1;
    if (root->data == key) {
        printf ("The key %d is in the tree.\n", key);
        bRet = 0;
        return bRet;
    }
    if (root->left != NULL) {
        bRet = searchBST (key, root->left);
        if (!bRet) {
            return bRet;
        }
    }
    if (root->right != NULL) {
        bRet = searchBST (key, root->right);
        if (!bRet) {
            return bRet;
        }
    }
    return bRet;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47653458_47654059_20_45
47653458_47654129_6_26
Title: function remove a word depending of a number - c programming 
----------------------------------------

int main (void) {
    char *ptr1, *ptr2, *ptr3, *ptr4;
    ptr1 = skipWords ("there you go", 1);
    if (ptr1)
        puts (ptr1);
    else
        puts ("NULL");
    ptr2 = skipWords ("there you go", 2);
    if (ptr2)
        puts (ptr2);
    else
        puts ("NULL");
    ptr3 = skipWords ("a string", 0);
    if (ptr3)
        puts (ptr3);
    else
        puts ("NULL");
    ptr4 = skipWords ("a word", 2);
    if (ptr4)
        puts (ptr4);
    else
        puts ("NULL");
    return 0;
}
----------------------------------------

int main () {
    char *p1 = NULL, *p2 = NULL, *p3 = NULL, *p4 = NULL;
    char *crap = "I can not code at all!";
    p1 = skipWords (crap, 3);
    if (p1 != NULL)
        printf ("\nFirst go: %s", p1);
    p2 = skipWords (crap, 2);
    if (p2 != NULL)
        printf ("\nSecond go: %s", p2);
    p3 = skipWords (crap, 1);
    if (p3 != NULL)
        printf ("\nThird go: %s", p3);
    p4 = skipWords (crap, 0);
    if (p4 != NULL)
        printf ("\nFinal go: %s", p4);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47653458_47654059_4_18
47653458_47654129_28_52
Title: function remove a word depending of a number - c programming 
----------------------------------------

char *skipWords (const char *s, size_t n) {
    if (n) {
        while (isblank ((unsigned char) *s))
            ++s;
        do {
            while (*s && !isblank ((unsigned char) *s))
                ++s;
            while (isblank ((unsigned char) *s))
                ++s;
        }
        while (*s && --n);
    }
    return (char *) (*s ? s : NULL);
}
----------------------------------------

char *skipWords (char *pStr, unsigned int uiWordsToSkip) {
    int i = 0;
    char *p = pStr, *pTemp = NULL;
    const char ch = 0x20;
    if (pStr == NULL) {
        return NULL;
    }
    for (i = 0; i < uiWordsToSkip; i++) {
        p = strchr (p, ch);
        if (p == NULL) {
            return pTemp;
        }
        pTemp = p;
        p++;
    }
    return p;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47673717_47673913_10_19
47673717_47673993_16_27
Title: The sum of prime numbers 
----------------------------------------

int main () {
    int sum = 0;
    for (int i = 101; i <= 203; i += 2) {
        if (prime (i) == 1) {
            sum += i;
        }
    }
    printf ("%d \n", sum);
}
----------------------------------------

int main () {
    int sum = 0;
    for (int i = 101; i <= 203; i += 2) {
        if (prime (i) == 1) {
            sum += i;
        }
    }
    printf ("%d \n", sum);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47690102_47692527_3_24
47690102_47702091_2_17
Title: redirecting stdin to file 
----------------------------------------

int main (int argc, char **argv) {
    if (argc < 2) {
        fprintf (stderr, "ERROR: No output file!\n");
        fprintf (stderr, "Usage: mycat FILE\n");
        return 1;
    }
    FILE *fOut = fopen (argv[1], "w");
    if (!fOut) {
        fprintf (stderr, "ERROR: Cannot open file '%s' for writing!", argv [1]);
    }
    int c;
    while ((c = getc (stdin)) >= 0) {
        if (putc (c, fOut) < 0) {
            fprintf (stderr, "ERROR: Cannot write to file '%s'!", argv [1]);
        }
    }
    if (fclose (fOut)) {
        fprintf (stderr, "ERROR: Cannot write to file '%s'!", argv [1]);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    close (1);
    int ad = open (argv[1], O_CREAT | O_APPEND | O_NONBLOCK | O_RDWR, 0644);
    if (ad == -1) {
        perror ("open");
        return 0;
    }
    while (read (0, &c, 1) > 0) {
        write (ad, & c, 1);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47697791_47697835_4_19
47697791_47697986_1_15
Title: Memcpy a str[ ] to str* 
----------------------------------------

char *xor (char *str1, char *str2) {
    char temp [min (strlen (str1), strlen (str2)) + 1];
    char *result = malloc (sizeof temp);
    if (result == NULL) {
        fprintf (stderr, "%s\n", "Error in malloc");
        exit (1);
    }
    size_t i;
    for (i = 0; i <= strlen (str1); i++)
        temp[i] = str1[i] ^ str2[i];
    temp[i] = '\0';
    memcpy (result, temp, sizeof (temp));
    return result;
}
----------------------------------------

char *xor (char *str1, char *str2) {
    int len = strlen (str1) char temp [len];
    if (strlen (str2) != len)
        return 0;
    char *result = malloc (len);
    for (int i = 0; i < len; i++) {
        temp[i] = str1[i] ^ str2[i];
    }
    memcpy (result, temp, len);
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47697791_47697835_4_19
47697791_47698114_4_21
Title: Memcpy a str[ ] to str* 
----------------------------------------

char *xor (char *str1, char *str2) {
    char temp [min (strlen (str1), strlen (str2)) + 1];
    char *result = malloc (sizeof temp);
    if (result == NULL) {
        fprintf (stderr, "%s\n", "Error in malloc");
        exit (1);
    }
    size_t i;
    for (i = 0; i <= strlen (str1); i++)
        temp[i] = str1[i] ^ str2[i];
    temp[i] = '\0';
    memcpy (result, temp, sizeof (temp));
    return result;
}
----------------------------------------

char *xor (char const *a, char const *b) {
    size_t const size = strlen (a);
    if (size != strlen (b)) {
        return NULL;
    }
    char *result = malloc (size +1);
    if (!result) {
        return NULL;
    }
    for (size_t i = 0; i < size; i++) {
        result[i] = a[i] ^ b[i];
    }
    result[size] = '\0';
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47697791_47697986_1_15
47697791_47698114_4_21
Title: Memcpy a str[ ] to str* 
----------------------------------------

char *xor (char *str1, char *str2) {
    int len = strlen (str1) char temp [len];
    if (strlen (str2) != len)
        return 0;
    char *result = malloc (len);
    for (int i = 0; i < len; i++) {
        temp[i] = str1[i] ^ str2[i];
    }
    memcpy (result, temp, len);
    return result;
}
----------------------------------------

char *xor (char const *a, char const *b) {
    size_t const size = strlen (a);
    if (size != strlen (b)) {
        return NULL;
    }
    char *result = malloc (size +1);
    if (!result) {
        return NULL;
    }
    for (size_t i = 0; i < size; i++) {
        result[i] = a[i] ^ b[i];
    }
    result[size] = '\0';
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47707755_47707842_1_16
47707755_47707871_1_17
Title: how to see if value entered is a number and not chars? 
----------------------------------------

int main (void) {
    int i;
    printf ("Enter a number: ");
    scanf ("%d", & i);
    if (isdigit (i)) {
        printf ("It is a digit.");
    }
    else {
        if (test_prime (i))
            printf ("Prime.\n");
        else
            printf ("Not prime.\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i;
    printf ("Enter a number: ");
    if (scanf ("%d", &i) != 1) {
        fprintf (stderr, "%s\n", "Error in input, input is not number");
        exit (1);
    }
    if (test_prime (i))
        printf ("%s\n", "Prime.");
    else
        printf ("%s\n", "Not prime.");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47707755_47707842_1_16
47707755_47707904_1_13
Title: how to see if value entered is a number and not chars? 
----------------------------------------

int main (void) {
    int i;
    printf ("Enter a number: ");
    scanf ("%d", & i);
    if (isdigit (i)) {
        printf ("It is a digit.");
    }
    else {
        if (test_prime (i))
            printf ("Prime.\n");
        else
            printf ("Not prime.\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i;
    int c;
    printf ("Enter a number: ");
    c = scanf ("%d", &i);
    if (c != 1) {
        printf ("Invalid number");
    }
    else {
        printf ("%d", i);
        return 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47707755_47707871_1_17
47707755_47707904_1_13
Title: how to see if value entered is a number and not chars? 
----------------------------------------

int main (void) {
    int i;
    printf ("Enter a number: ");
    if (scanf ("%d", &i) != 1) {
        fprintf (stderr, "%s\n", "Error in input, input is not number");
        exit (1);
    }
    if (test_prime (i))
        printf ("%s\n", "Prime.");
    else
        printf ("%s\n", "Not prime.");
    return 0;
}
----------------------------------------

int main (void) {
    int i;
    int c;
    printf ("Enter a number: ");
    c = scanf ("%d", &i);
    if (c != 1) {
        printf ("Invalid number");
    }
    else {
        printf ("%d", i);
        return 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47711574_47711895_2_19
47711574_47711997_1_28
Title: C: How to add a try again function to this asterisk square printing program 
----------------------------------------

int Loops () {
    int s, e, z;
    printf ("Input number \n");
    scanf ("%d", & s);
    if (s > 0) {
        for (e = 0; e < s; e++) {
            for (z = 0; z < s; z++) {
                if (e == 0 || e == s - 1 || z == 0 || z == s - 1)
                    printf ("*");
                else
                    printf (" ");
            }
            printf ("\n");
        }
    }
    else
        Loops ();
}
----------------------------------------

int Loops () {
    int s, e, z;
    while (1) {
        printf ("Input number \n");
        e = scanf ("%d", &s);
        if ((s <= 0) || (e != 1)) {
            printf ("Please Enter Non-negaitve Number\n");
            getchar ();
        }
        else {
            break;
        }
    }
    for (e = 0; e < s; e++) {
        for (z = 0; z < s; z++) {
            if (e == 0 || e == s - 1 || z == 0 || z == s - 1)
                printf ("*");
            else
                printf (" ");
        }
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47722411_47722531_3_16
47722411_47723888_2_16
Title: Comparing two strings in C in a loop 
----------------------------------------

int main () {
    char passcode [] = "ZZZ";
    char input [50];
    int check;
    do {
        printf ("What is the password?\n");
        fgets (input, sizeof (input), stdin);
        check = strcmp (passcode, input);
    }
    while (check != 0);
    printf ("You crack the pass code!");
    return 0;
}
----------------------------------------

int main () {
    char input [3];
    printf ("\nHit the pass code!\npass code: ");
    while (input != "ZZZ") {
        scanf ("%s", & input);
        if (strcmp (input, "ZZZ") == 0) {
            printf ("\nYou crack the pass code!!\n\n");
            break;
        }
        else {
            printf ("Wroooong!\n pass code: ");
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47733183_47733201_3_18
47733183_47733892_52_80
Title: How can I print an array like a grid? 
----------------------------------------

void display_grid (void) {
    int i;
    int j;
    int cell [16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15};
    for (i = 0; i < 4; i++) {
        printf ("|");
        for (j = 0; j < 4; j++) {
            printf ("%d|", cell [4 * i + j]);
        }
        printf ("\n");
    }
}
----------------------------------------

int display_grid (int *arr, size_t arr_sz, size_t row_sz) {
    int ret_val = arr_sz % row_sz;
    if (ret_val == 0) {
        putchar (' ');
        for (size_t i = 1; i < 3 * row_sz; i++) {
            putchar ('_');
        }
        putchar ('\n');
        for (size_t i = 0; i < arr_sz; i++) {
            printf ("|%-2d", arr [i]);
            if ((i + 1) % row_sz == 0) {
                printf ("|\n");
            }
        }
        for (size_t i = 0; i < 3 * row_sz + 1; i++) {
            putchar ('-');
        }
        putchar ('\n');
    }
    return ret_val;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47742277_47742707_6_34
47742277_47743214_7_40
Title: "File IO: Line by Line Comparison In C Segmentation Fault" 
----------------------------------------

int main (int argc, char *argv []) {
    char *fileN = argv[1];
    FILE *file = fopen (fileN, "r");
    if (file == NULL) {
        perror ("Error: Couldn't open file");
        exit (1);
    }
    else {
        char line [101], comp [101];
        fgets (line, 101, file);
        int bool = 1;
        while (line && bool) {
            if (fgets (comp, 101, file) != NULL) {
                if (strcmp (line, comp) > 0) {
                    printf ("Lines out of order\n");
                    printf ("%s", line);
                    printf ("%s\n", comp);
                    fclose (file);
                    exit (1);
                }
                strncpy (line, comp, 100);
            }
            else {
                bool = 0;
            }
        }
        printf ("Lines are ordered\n");
        fclose (file);
        exit (0);
    }
}
----------------------------------------

int main (int argc, char *argv []) {
    char a [MAX_LINE];
    char b [MAX_LINE];
    FILE *fd = fopen (argv[1], "r");
    if (!fd) {
        puts ("Error: Couldn't open file");
        exit (1);
    }
    fgets (a, MAX_LINE, fd);
    while (fgets (b, MAX_LINE, fd)) {
        if (strcmp (a, b) > 0) {
            puts ("Lines out of order");
            printf ("a = %s", a);
            printf ("b = %s", b);
            fclose (fd);
            exit (1);
        }
        strcpy (a, b);
    }
    puts ("Lines are ordered");
    fclose (fd);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47760701_47760942_1_34
47760701_47761271_4_33
Title: How to let the user decide when to stop a for loop from counting (C programming) 
----------------------------------------

int main () {
    int i;
    char a = '?';
    int aCount = 0;
    int bCount = 0;
    int cCount = 0;
    while (a != 'q' && a != 'Q') {
        scanf ("%c", & a);
        switch (a) {
        case 'A' :
        case 'a' :
            aCount++;
            break;
        case 'B' :
        case 'b' :
            bCount++;
            break;
        case 'C' :
        case 'c' :
            cCount++;
            break;
        default :
            puts ("Mxm choose A, B, C or Q to quit.");
            break;
        }
    }
    printf ("\nA - %d\nB - %d\nC - %d", aCount, bCount, cCount);
}
----------------------------------------

int main () {
    char i = -1;
    int aCount = 0;
    int bCount = 0;
    int cCount = 0;
    puts ("Please choose A, B, C, or Z to exit.");
    for (; i != 'z';) {
        scanf (" %c", & i)
        i = tolower (i);
        switch (i) {
        case 'a' :
            aCount++;
            break;
        case 'b' :
            bCount++;
            break;
        case 'c' :
            cCount++;
            break;
        default :
            puts ("Mxm choose A, B or C, or Z to quit.");
            break;
        }
    }
    printf ("\nA - %d\nB - %d\nC - %d\n", aCount, bCount, cCount);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47760701_47760942_1_34
47760701_47761337_3_25
Title: How to let the user decide when to stop a for loop from counting (C programming) 
----------------------------------------

int main () {
    int i;
    char a = '?';
    int aCount = 0;
    int bCount = 0;
    int cCount = 0;
    while (a != 'q' && a != 'Q') {
        scanf ("%c", & a);
        switch (a) {
        case 'A' :
        case 'a' :
            aCount++;
            break;
        case 'B' :
        case 'b' :
            bCount++;
            break;
        case 'C' :
        case 'c' :
            cCount++;
            break;
        default :
            puts ("Mxm choose A, B, C or Q to quit.");
            break;
        }
    }
    printf ("\nA - %d\nB - %d\nC - %d", aCount, bCount, cCount);
}
----------------------------------------

int main () {
    int aCount = 0;
    int bCount = 0;
    int cCount = 0;
    char ch;
    char temp;
    do {
        scanf (" %c", & temp);
        if (a[i] == 'a' || a[i] == 'A')
            aCount++;
        else if (a[i] == 'b' || a[i] == 'B')
            bCount++;
        else if (a[i] == 'c' || a[i] == 'C')
            cCount++;
        printf ("Continue??");
        scanf (" %c", & ch);
    }
    while (ch != 'z');
    printf ("\nA - %d\nB - %d\nC - %d", aCount, bCount, cCount);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47760701_47761271_4_33
47760701_47761337_3_25
Title: How to let the user decide when to stop a for loop from counting (C programming) 
----------------------------------------

int main () {
    char i = -1;
    int aCount = 0;
    int bCount = 0;
    int cCount = 0;
    puts ("Please choose A, B, C, or Z to exit.");
    for (; i != 'z';) {
        scanf (" %c", & i)
        i = tolower (i);
        switch (i) {
        case 'a' :
            aCount++;
            break;
        case 'b' :
            bCount++;
            break;
        case 'c' :
            cCount++;
            break;
        default :
            puts ("Mxm choose A, B or C, or Z to quit.");
            break;
        }
    }
    printf ("\nA - %d\nB - %d\nC - %d\n", aCount, bCount, cCount);
}
----------------------------------------

int main () {
    int aCount = 0;
    int bCount = 0;
    int cCount = 0;
    char ch;
    char temp;
    do {
        scanf (" %c", & temp);
        if (a[i] == 'a' || a[i] == 'A')
            aCount++;
        else if (a[i] == 'b' || a[i] == 'B')
            bCount++;
        else if (a[i] == 'c' || a[i] == 'C')
            cCount++;
        printf ("Continue??");
        scanf (" %c", & ch);
    }
    while (ch != 'z');
    printf ("\nA - %d\nB - %d\nC - %d", aCount, bCount, cCount);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47772637_47772836_4_32
47772637_47772891_4_29
Title: C programming : Creating substring 
----------------------------------------

int main (void) {
    struct info {
        char *name;
        char *type;
        char *path;
    };
    struct info user1;
    user1.name = malloc (40);
    if (user1.name == NULL) {
        fprintf (stderr, "%s\n", "Error in malloc");
        exit (1);
    }
    const char *a = "/home/users/user1";
    for (int i = strlen (a) - 1; i >= 0; i--) {
        if (a[i] == '/') {
            strncpy (user1.name, a + i + 1, i);
            user1.name[i] = '\0';
            break;
        }
    }
    printf ("%s\n", user1.name);
    free (user1.name);
    return 0;
}
----------------------------------------

int main () {
    struct info {
        char *name;
        char *type;
        char *path;
    };
    struct info user1;
    user1.name = malloc (10);
    char *a = "/home/users/user1";
    int len = strlen (a);
    for (int i = 0; i < len; i++) {
        printf ("%d", i);
        if (a[i] == '/') {
            strncpy (user1.name, a + i + 1, i);
            user1.name[i] = '\0';
            break;
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47828791_47828848_3_16
47828791_47828943_1_11
Title: Who is the winner? 
----------------------------------------

int reverse (int num) {
    int rev = 0, inter = 0;
    while (num) {
        inter = rev * 10;
        if (inter / 10 != rev) {
            fprintf (stderr, "%s\n", "Overflow\n");
            exit (1);
        }
        rev = inter + num % 10;
        num /= 10;
    }
    return rev;
}
----------------------------------------

int reverse (int num1, int num2) {
    int sum = num1 + num2;
    int ans = 0;
    while (sum > 0) {
        ans = ans * 10 + (sum % 10);
        sum /= 10;
    }
    return ans;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47845051_47846887_12_84
47845051_47847466_21_92
Title: How to improve my code to fill an array from a text table? 
----------------------------------------

int main (int argc, char *argv []) {
    int tab [8] [NO_OF_ROW] = {{0}};
    int r_v, r_s, r_bd, r_mr;
    int t_v = 0, t_s = 0, t_bd = 0, t_mr = 0;
    int i;
    FILE *input;
    int no_rows = 0;
    char *line = malloc (EACH_LINE_SIZE);
    input = fopen ("User.txt", "r");
    if (NULL == input) {
        return 0;
    }
    printf ("Subtest A score?\n");
    scanf ("%i", & r_v);
    printf ("Subtest B score?\n");
    scanf ("%i", & r_s);
    printf ("Subtest C score?\n");
    scanf ("%i", & r_bd);
    printf ("Subtest D score?\n");
    scanf ("%i", & r_mr);
    while (fgets (line, EACH_LINE_SIZE, input) != NULL) {
        sscanf (line, "%d,%d,%d,%d,%d,%d,%d,%d", & tab [0] [i], & tab [1] [i], & tab [2] [i], & tab [3] [i], & tab [4] [i], & tab [5] [i], & tab [6] [i], & tab [7] [i]);
        i++;
        if (NO_OF_ROW <= i) {
            printf ("Stop file reading \n");
            break;
        }
    }
    no_rows = i;
    for (i = 0; i < no_rows; i++) {
        if (r_v == tab[SUBTEST_A][i]) {
            t_v = tab[SUBTEST_A - 1][i];
        }
        if (r_s == tab[SUBTEST_B][i]) {
            t_s = tab[SUBTEST_B - 1][i];
        }
        if (r_bd == tab[SUBTEST_C][i]) {
            t_bd = tab[SUBTEST_C - 1][i];
        }
        if (r_mr == tab[SUBTEST_D][i]) {
            t_mr = tab[SUBTEST_D - 1][i];
        }
    }
    printf ("The participant had the following raw scores: %d, %d, %d, and %d.\n", r_v, r_s, r_bd, r_mr);
    printf ("Which corresponds to the following T scores: %d, %d, %d, and %d.\n", t_v, t_s, t_bd, t_mr);
    free (line);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    struct Record table [MAX_ROWS];
    int r_v, r_s, r_bd, r_mr;
    int t_v = -1;
    int t_s = -1;
    int t_bd = -1;
    int t_mr = -1;
    FILE *input;
    if (argc < 2) {
        fprintf (stderr, "Usage: %s filename\n", argv [0]);
        exit (EXIT_FAILURE);
    }
    input = fopen (argv[1], "r");
    if (input == NULL) {
        fprintf (stderr, "Unable to open file: %s\n", argv [1]);
        exit (EXIT_FAILURE);
    }
    int line = 0;
    char buffer [BUF_SZ];
    while (fgets (buffer, sizeof buffer, input) != NULL) {
        if (sscanf (buffer, "%i,%i,%i,%i,%i,%i,%i,%i", &table[line].t_v, &table[line].r_v, &table[line].t_s, &table[line].r_s, &table[line].t_bd, &table[line].r_bd, &table[line].t_mr, &table[line].r_mr) != 8) {
            fprintf (stderr, "Format error in line %d\n", line);
            exit (EXIT_FAILURE);
        }
        ++line;
    }
    fclose (input);
    r_v = get_integer ("Subtest A score?\n");
    r_s = get_integer ("Subtest B score?\n");
    r_bd = get_integer ("Subtest C score?\n");
    r_mr = get_integer ("Subtest D score?\n");
    for (int i = 0; i < line; i++) {
        if (r_v == table[i].r_v) {
            t_v = table[i].t_v;
        }
        if (r_s == table[i].r_s) {
            t_s = table[i].t_s;
        }
        if (r_bd == table[i].r_bd) {
            t_bd = table[i].t_bd;
        }
        if (r_mr == table[i].r_mr) {
            t_mr = table[i].t_mr;
        }
    }
    printf ("The participant had the following raw scores: " "%d, %d, %d, and %d.\n", r_v, r_s, r_bd, r_mr);
    printf ("Which corresponds to the following T scores: " "%d, %d, %d, and %d.\n", t_v, t_s, t_bd, t_mr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47849855_47850155_9_43
47849855_47850716_5_24
Title: Different results when running the function multiple times - C 
----------------------------------------

int SumStr (char *str) {
    int i = 0, j = 0, num = 0, tempnum = 0;
    char temp [MAX_SIZE];
    while (*(str + i) != 0) {
        while (((*(str + i)) >= '0') && ((*(str + i)) <= '9')) {
            *(temp + j) = *(str + i);
            ++j;
            ++i;
        }
        if (j != 0) {
            *(temp + j) = 0;
            tempnum = atoi (temp);
            num = tempnum + num;
            tempnum = 0;
            j = 0;
        }
        if (*(str + i) != 0) {
            ++i;
        }
        else
            break;
    }
    return num;
}
----------------------------------------

static int SumStr (const char *str) {
    int sum = 0;
    str += strcspn (str, "0123456789");
    while (*str >= '0' && *str <= '9') {
        char *eon;
        long val = strtol (str, &eon, 10);
        sum += (int) val;
        str = eon + strcspn (eon, "0123456789");
    }
    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47851781_47851822_1_15
47851781_47851961_11_23
Title: "Trying to sort input by names with a struct but the program crashes on this function" 
----------------------------------------

void sort (struct Employee e [], int n) {
    int i, j;
    struct Employee t;
    for (i = 0; i < n + 1; i++)
        for (j = 0; j < n - 1; j++) {
            if (strcmp (e[i].name, e[j + 1].name) > 0) {
                t = e[j];
                e[j] = e[j + 1];
                e[j + 1] = t;
            }
        }
}
----------------------------------------

void sort (employee_t *e, int n) {
    int i, j;
    employee_t t = {{0}, 0};
    for (i = 0; i < n; i++)
        for (j = 0; j < n - 1 - i; j++)
            if (strcmp (e[i].name, e[j + 1].name) > 0) {
                t = e[j];
                e[j] = e[j + 1];
                e[j + 1] = t;
            }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47858936_47859574_20_81
47858936_47859782_3_32
Title: Programming printing after looping 
----------------------------------------

int main (void) {
    int i, x;
    for (i = 1; i <= 2; i++) {
        for (x = 1; x <= 2; x++) {
            printf ("  %d,%d  ", i, x);
        }
        printf ("\n");
        for (x = 1; x <= 2; x++) {
            printf (" /   \\ ");
        }
        printf ("\n");
        for (x = 1; x <= 2; x++) {
            printf ("|     |");
        }
        printf ("\n");
        for (x = 1; x <= 2; x++) {
            printf ("|     |");
        }
        printf ("\n");
        for (x = 1; x <= 2; x++) {
            printf (" \\   / ");
        }
        printf ("\n");
    }
    printf ("\n");
    printf ("\n");
    printf ("\n");
    for (i = 0; i < ROWS; i++) {
        subrow ("   / \\  ", "");
        subrow ("  /   \\ ", "");
        subrow (" /     \\", "");
        subrow ("|       ", "|");
        subrow ("|       ", "|");
        subrow (" \\     /", "");
        subrow ("  \\   / ", "");
        subrow ("   \\ /  ", "");
        subrow ("    |   ", "");
        subrow ("    |   ", "");
    }
    subrow ("   / \\  ", "");
    subrow ("  /   \\ ", "");
    subrow (" /     \\", "");
    subrow ("|       ", "|");
    subrow ("|       ", "|");
    subrow (" \\     /", "");
    subrow ("  \\   / ", "");
    subrow ("   \\ /  ", "");
    printf ("\n");
    printf ("\n");
    subrow ("  ___     ", "");
    for (i = 0; i < ROWS; i++) {
        subrow (" /   \\    ", " /");
        indexedSubrow ("/ %d,%d \\___", "/", i, 0);
        subrow ("\\     /   ", "\\");
        indexedSubrow (" \\___/ %d,%d", " \\", i, 1);
    }
    return 0;
}
----------------------------------------

int main () {
    int i, x;
    for (i = 1; i <= 2; i++) {
        for (x = 1; x <= 2; x++) {
            printf ("    %d,%d    ", i, x);
        }
        printf ("\n");
        for (x = 1; x <= 2; x++) {
            printf (" /      \\  ");
        }
        printf ("\n");
        for (x = 1; x <= 2; x++) {
            printf ("|        | ");
        }
        printf ("\n");
        for (x = 1; x <= 2; x++) {
            printf ("|        | ");
        }
        printf ("\n");
        for (x = 1; x <= 2; x++) {
            printf (" \\      /  ");
        }
        printf ("\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47893113_47894164_4_19
47893113_47908495_1_29
Title: Runtime Error Message: Line 17: index -3 out of bounds for type 'int [256]' 
----------------------------------------

size_t lengthOfLongestSubstring (const char *s) {
    size_t longest = 0;
    for (; *s; ++s) {
        size_t n = 0;
        unsigned char letters [UCHAR_MAX] = {0};
        for (const char *p = s; *p && !letters[(unsigned char) *p - 1]++; ++p)
            ++n;
        if (longest < n)
            longest = n;
    }
    return longest;
}
----------------------------------------

int lengthOfLongestSubstring (char *s) {
    char *h = s;
    int max = 0;
    int len = strlen (s);
    if (len == 1) {
        return 1;
    }
    for (int i = 0; i < len; i++) {
        int A [256] = {0};
        int length = 0;
        for (int j = i; j < len; j++) {
            if (A[(unsigned char) h[j]] == 1) {
                break;
            }
            else {
                A[(unsigned char) h[j]] = 1;
                length += 1;
            }
        }
        if (max < length) {
            max = length;
        }
    }
    return max;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4789720_43421610_8_42
4789720_4789990_6_27
Title: communicate c program and php 
----------------------------------------

int main () {
    struct sockaddr_un server_address = {AF_UNIX, SOCKET_FILE};
    int sock = socket (AF_UNIX, SOCK_DGRAM, 0);
    if (sock <= 0) {
        perror ("socket creation failed");
        return 1;
    }
    unlink (SOCKET_FILE);
    if (bind (sock, (const struct sockaddr *) &server_address, sizeof (server_address)) < 0) {
        perror ("bind failed");
        close (sock);
        return 1;
    }
    for (;;) {
        struct sockaddr_un client_address;
        int i, numBytes, len = sizeof (struct sockaddr_un);
        char buf [BUF_SIZE];
        numBytes = recvfrom (sock, buf, BUF_SIZE, 0, (struct sockaddr *) &client_address, &len);
        if (numBytes == -1)
            puts ("recvfrom failed");
        printf ("Server received %d bytes from %s\n", numBytes, client_address.sun_path);
        for (i = 0; i < numBytes; i++)
            buf[i] = toupper ((unsigned char) buf[i]);
        if (sendto (sock, buf, numBytes, 0, (struct sockaddr *) &client_address, len) != numBytes)
            puts ("sendto failed");
    }
}
----------------------------------------

int main (void) {
    redisContext *c;
    redisReply *reply;
    c = redisConnect ((char *) "127.0.0.1", 6379);
    if (c->err) {
        printf ("Connection error: %s\n", c -> errstr);
        redisFree (c);
        exit (1);
    }
    reply = redisCommand (c, "BLPOP php 0");
    if (reply->type == REDIS_REPLY_ARRAY) {
        if (reply->elements == 2) {
            printf ("%s\n", reply -> element [1] -> str);
        }
    }
    freeReplyObject (reply);
    redisFree (c);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47906401_47907243_24_32
47906401_47908792_3_15
Title: Generate sine signal in C without using the standard function 
----------------------------------------

int main (void) {
    double pi = 3.1415926535897932384626433832795;
    for (int j = 0; j < 1000; j++) {
        float x = 40 * 0.001 * i;
        float radians = x * 2 * pi / 40;
        printf ("%f %f %f\n", x, sin1 (x) / 32768, sin (radians));
        i = i + 1;
    }
}
----------------------------------------

int main (void) {
    float x = 1, y = 0;
    const float e = .04;
    for (int i = 0; i < 100; ++i) {
        x -= e * y;
        y += e * x;
        printf ("%g\n", y);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47906401_47907243_24_32
47906401_47943771_7_19
Title: Generate sine signal in C without using the standard function 
----------------------------------------

int main (void) {
    double pi = 3.1415926535897932384626433832795;
    for (int j = 0; j < 1000; j++) {
        float x = 40 * 0.001 * i;
        float radians = x * 2 * pi / 40;
        printf ("%f %f %f\n", x, sin1 (x) / 32768, sin (radians));
        i = i + 1;
    }
}
----------------------------------------

int main (void) {
    float a = 0.0f;
    float b = DT * W0;
    float tmp;
    for (int i = 0; i < 400; i++) {
        tmp = (1 / (1 + (DT * DT * W0 * W0))) * (2 * a - b);
        b = a;
        a = tmp;
        printf ("%f\n", tmp);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47906401_47908792_3_15
47906401_47943771_7_19
Title: Generate sine signal in C without using the standard function 
----------------------------------------

int main (void) {
    float x = 1, y = 0;
    const float e = .04;
    for (int i = 0; i < 100; ++i) {
        x -= e * y;
        y += e * x;
        printf ("%g\n", y);
    }
}
----------------------------------------

int main (void) {
    float a = 0.0f;
    float b = DT * W0;
    float tmp;
    for (int i = 0; i < 400; i++) {
        tmp = (1 / (1 + (DT * DT * W0 * W0))) * (2 * a - b);
        b = a;
        a = tmp;
        printf ("%f\n", tmp);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47927885_47928287_10_22
47927885_47928596_10_22
Title: Remove all occurences of an element in a one-way linked list 
----------------------------------------

void insert (struct Node **head, const int a [], size_t n) {
    for (size_t i = 0; i < n; i++) {
        struct Node *current = (struct Node *) malloc (sizeof (struct Node));
        current->value = a[i];
        current->next = *head;
        *head = current;
        head = &(*head)->next;
    }
}
----------------------------------------

void insert (struct Node **head, const int a [], size_t n) {
    for (size_t i = 0; i < n; i++) {
        struct Node *current = (struct Node *) malloc (sizeof (struct Node));
        current->value = a[i];
        current->next = *head;
        *head = current;
        head = &(*head)->next;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47951575_47951651_6_32
47951575_47957339_4_21
Title: C program printing garbage values 
----------------------------------------

int main () {
    int *arr = malloc (sizeof (int) * 5);
    int i = 0;
    for (i = 0; i < 5; i++) {
        arr[i] = initial[i];
        printf ("Value of array: %d\n", arr [i]);
    }
    int *arrPointer = arr;
    for (i = 0; i < 5; i++) {
        printf ("Pushing: %d\n", * arrPointer);
        arrPointer++;
    }
    arrPointer = arr;
    return 0;
}
----------------------------------------

void main () {
    int initial [] = {100, 101, 102, 103, 104};
    void *arr = (void *) (malloc (sizeof (void *) * 5));
    int i = 0;
    for (i = 0; i < 5; i++) {
        printf ("%p\t%p\n", arr + i, ((int *) arr) + i);
    }
    for (i = 0; i < 5; i++) {
        *(((int *) arr) + i) = initial[i];
        printf ("Value of array: %d\n", * (((int *) arr) + i));
    }
    for (i = 0; i < 5; i++) {
        printf ("Pushing: %d\n", * (((int *) arr) + i));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47952423_47952536_1_19
47952423_47953016_1_24
Title: How to write text file faster than fprintf in c? 
----------------------------------------

void save_txt (const graph_t * const graph, const char *fname) {
    int i, count = graph->num_edges;
    f = fopen (fname, "w");
    if (NULL == f) {
        fprintf (stderr, "Error opening %s\n", fname);
        exit (- 1);
    }
    for (i = 0; i < count; i++) {
        my_put_nbr (graph -> edges [i].from);
        my_putchar (' ');
        my_put_nbr (graph -> edges [i].to);
        my_putchar (' ');
        my_put_nbr (graph -> edges [i].cost);
        my_putchar ('\n');
    }
    flushBuffer ();
    fclose (f);
}
----------------------------------------

void save_txt (const graph_t * const graph, const char *fname) {
    int count = graph->num_edges, i = 0;
    char c = '\n';
    char d = ' ';
    char buffer [15];
    FILE *f = fopen (fname, "w");
    while (count > 0) {
        itoa (graph -> edges [i].from, buffer, 10);
        fputs (buffer, f);
        putc (d, f);
        itoa (graph -> edges [i].to, buffer, 10);
        fputs (buffer, f);
        putc (d, f);
        itoa (graph -> edges [i].cost, buffer, 10);
        fputs (buffer, f);
        putc (c, f);
        i++;
        count -= 1;
    }
    if (f) {
        fclose (f);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47959493_47959524_3_24
47959493_47959703_10_34
Title: How to sort array of strings in ascending order in C 
----------------------------------------

void main () {
    char str [100], ch;
    int i, j, l;
    printf ("\n\nSort a string array in ascending order :\n");
    printf ("--------------------------------------------\n");
    printf ("Input the string : ");
    fgets (str, sizeof str, stdin);
    l = strlen (str);
    for (i = 1; i < l; i++)
        for (j = 0; j < l - i; j++)
            if (str[j] > str[j + 1]) {
                ch = str[j];
                str[j] = str[j + 1];
                str[j + 1] = ch;
            }
    printf ("After sorting the string appears like : \n");
    printf ("%s\n\n", str);
}
----------------------------------------

int main () {
    const char *xs [] = {"Korra", "Zhu Li", "Asami", "Mako", "Bolin", "Tenzin", "Varrick",};
    const size_t N = sizeof (xs) / sizeof (xs[0]);
    puts ("(unsorted)");
    for (int n = 0; n < N; n++)
        puts (xs[n]);
    qsort (xs, N, sizeof (xs [0]), pstrcmp);
    puts ("\n(sorted)");
    for (int n = 0; n < N; n++)
        puts (xs[n]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47959493_47959524_3_24
47959493_47959904_3_25
Title: How to sort array of strings in ascending order in C 
----------------------------------------

void main () {
    char str [100], ch;
    int i, j, l;
    printf ("\n\nSort a string array in ascending order :\n");
    printf ("--------------------------------------------\n");
    printf ("Input the string : ");
    fgets (str, sizeof str, stdin);
    l = strlen (str);
    for (i = 1; i < l; i++)
        for (j = 0; j < l - i; j++)
            if (str[j] > str[j + 1]) {
                ch = str[j];
                str[j] = str[j + 1];
                str[j + 1] = ch;
            }
    printf ("After sorting the string appears like : \n");
    printf ("%s\n\n", str);
}
----------------------------------------

int main () {
    int i, j, count;
    char str [25] [25], temp [25];
    puts ("How many strings u are going to enter?: ");
    scanf ("%d", & count);
    puts ("Enter Strings one by one: ");
    for (i = 0; i <= count; i++)
        gets (str[i]);
    for (i = 0; i <= count; i++)
        for (j = i + 1; j <= count; j++) {
            if (strcmp (str[i], str[j]) > 0) {
                strcpy (temp, str [i]);
                strcpy (str [i], str [j]);
                strcpy (str [j], temp);
            }
        }
    printf ("Order of Sorted Strings:");
    for (i = 0; i <= count; i++)
        puts (str[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47959493_47959524_3_24
47959493_53188650_16_47
Title: How to sort array of strings in ascending order in C 
----------------------------------------

void main () {
    char str [100], ch;
    int i, j, l;
    printf ("\n\nSort a string array in ascending order :\n");
    printf ("--------------------------------------------\n");
    printf ("Input the string : ");
    fgets (str, sizeof str, stdin);
    l = strlen (str);
    for (i = 1; i < l; i++)
        for (j = 0; j < l - i; j++)
            if (str[j] > str[j + 1]) {
                ch = str[j];
                str[j] = str[j + 1];
                str[j + 1] = ch;
            }
    printf ("After sorting the string appears like : \n");
    printf ("%s\n\n", str);
}
----------------------------------------

int main (void) {
    int order_type;
    char str [MAX_SIZE] [MAX_SIZE];
    printf ("-----------[Order Type]-----------\n");
    printf ("Sort your strings in ascending or descending order?\n");
    printf ("0 = Ascending | 1 = descending\n");
    scanf ("%d", & order_type);
    if (order_type != ASCENDING && order_type != DESCENDING) {
        printf ("Please enter 0 or 1\n");
        exit (1);
    }
    printf ("---------[Enter Strings]----------\n");
    printf ("Enter Strings one by one.\n");
    printf ("Max Strings: %d | Max String Len: %d\n", MAX_SIZE, MAX_SIZE);
    int i = 0;
    while ((i < MAX_SIZE) && (scanf ("%s", str[i]) == 1))
        i++;
    if (i == MAX_SIZE)
        printf ("You reached the maximum strings allowed\n");
    printf ("---------[Sorted Strings]---------\n");
    sort_strings (str, i, ASCENDING);
    print_2d_array (str, i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47959493_47959703_10_34
47959493_47959904_3_25
Title: How to sort array of strings in ascending order in C 
----------------------------------------

int main () {
    const char *xs [] = {"Korra", "Zhu Li", "Asami", "Mako", "Bolin", "Tenzin", "Varrick",};
    const size_t N = sizeof (xs) / sizeof (xs[0]);
    puts ("(unsorted)");
    for (int n = 0; n < N; n++)
        puts (xs[n]);
    qsort (xs, N, sizeof (xs [0]), pstrcmp);
    puts ("\n(sorted)");
    for (int n = 0; n < N; n++)
        puts (xs[n]);
}
----------------------------------------

int main () {
    int i, j, count;
    char str [25] [25], temp [25];
    puts ("How many strings u are going to enter?: ");
    scanf ("%d", & count);
    puts ("Enter Strings one by one: ");
    for (i = 0; i <= count; i++)
        gets (str[i]);
    for (i = 0; i <= count; i++)
        for (j = i + 1; j <= count; j++) {
            if (strcmp (str[i], str[j]) > 0) {
                strcpy (temp, str [i]);
                strcpy (str [i], str [j]);
                strcpy (str [j], temp);
            }
        }
    printf ("Order of Sorted Strings:");
    for (i = 0; i <= count; i++)
        puts (str[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47959493_47959703_10_34
47959493_53188650_16_47
Title: How to sort array of strings in ascending order in C 
----------------------------------------

int main () {
    const char *xs [] = {"Korra", "Zhu Li", "Asami", "Mako", "Bolin", "Tenzin", "Varrick",};
    const size_t N = sizeof (xs) / sizeof (xs[0]);
    puts ("(unsorted)");
    for (int n = 0; n < N; n++)
        puts (xs[n]);
    qsort (xs, N, sizeof (xs [0]), pstrcmp);
    puts ("\n(sorted)");
    for (int n = 0; n < N; n++)
        puts (xs[n]);
}
----------------------------------------

int main (void) {
    int order_type;
    char str [MAX_SIZE] [MAX_SIZE];
    printf ("-----------[Order Type]-----------\n");
    printf ("Sort your strings in ascending or descending order?\n");
    printf ("0 = Ascending | 1 = descending\n");
    scanf ("%d", & order_type);
    if (order_type != ASCENDING && order_type != DESCENDING) {
        printf ("Please enter 0 or 1\n");
        exit (1);
    }
    printf ("---------[Enter Strings]----------\n");
    printf ("Enter Strings one by one.\n");
    printf ("Max Strings: %d | Max String Len: %d\n", MAX_SIZE, MAX_SIZE);
    int i = 0;
    while ((i < MAX_SIZE) && (scanf ("%s", str[i]) == 1))
        i++;
    if (i == MAX_SIZE)
        printf ("You reached the maximum strings allowed\n");
    printf ("---------[Sorted Strings]---------\n");
    sort_strings (str, i, ASCENDING);
    print_2d_array (str, i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47959493_47959904_3_25
47959493_53188650_16_47
Title: How to sort array of strings in ascending order in C 
----------------------------------------

int main () {
    int i, j, count;
    char str [25] [25], temp [25];
    puts ("How many strings u are going to enter?: ");
    scanf ("%d", & count);
    puts ("Enter Strings one by one: ");
    for (i = 0; i <= count; i++)
        gets (str[i]);
    for (i = 0; i <= count; i++)
        for (j = i + 1; j <= count; j++) {
            if (strcmp (str[i], str[j]) > 0) {
                strcpy (temp, str [i]);
                strcpy (str [i], str [j]);
                strcpy (str [j], temp);
            }
        }
    printf ("Order of Sorted Strings:");
    for (i = 0; i <= count; i++)
        puts (str[i]);
    return 0;
}
----------------------------------------

int main (void) {
    int order_type;
    char str [MAX_SIZE] [MAX_SIZE];
    printf ("-----------[Order Type]-----------\n");
    printf ("Sort your strings in ascending or descending order?\n");
    printf ("0 = Ascending | 1 = descending\n");
    scanf ("%d", & order_type);
    if (order_type != ASCENDING && order_type != DESCENDING) {
        printf ("Please enter 0 or 1\n");
        exit (1);
    }
    printf ("---------[Enter Strings]----------\n");
    printf ("Enter Strings one by one.\n");
    printf ("Max Strings: %d | Max String Len: %d\n", MAX_SIZE, MAX_SIZE);
    int i = 0;
    while ((i < MAX_SIZE) && (scanf ("%s", str[i]) == 1))
        i++;
    if (i == MAX_SIZE)
        printf ("You reached the maximum strings allowed\n");
    printf ("---------[Sorted Strings]---------\n");
    sort_strings (str, i, ASCENDING);
    print_2d_array (str, i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47978025_47978478_19_40
47978025_47978851_4_38
Title: Multiple condition check in C 
----------------------------------------

int main () {
    char choice;
    do {
        printf ("\nSelect any action from the following:\n\
        1. Backup packages\n\
        2. List packages\n\
        3. Restore packages\n\
        4. Exit\
    >>> ");
        scanf (" %c", & choice);
        switch (choice) {
        case '1' :
            backup ();
            break;
        case '2' :
            list ();
            break;
        case '3' :
            restore ();
            break;
        default :
            printf ("\nIllegal choice!");
        }
    }
    while (choice != '4');
    return 0;
}
----------------------------------------

int main () {
    char ans [2];
    char command [100];
    printf ("\nYou are about to backup installed packages. Continue? (Y/N):");
    scanf ("%1s", ans);
    if (ans[0] == 'Y' || ans[0] == 'y') {
        sprintf (command, "sudo pacman -Qqe | grep -vx '$(pacman -Qqm)' > packages");
        system (command);
        printf ("\nBackup done! \n");
    }
    if (ans[0] == 'N' || ans[0] == 'n') {
        printf ("\nOk. Got you, I won't backup \n");
        exit (EXIT_SUCCESS);
    }
    printf ("\nView list? (Y/N):\n");
    scanf ("%1s", ans);
    if (ans[0] == 'Y' || ans[0] == 'y') {
        sprintf (command, "xargs -a packages");
        system (command);
        printf ("\n");
    }
    else {
        printf ("\nPreparing to restore \n");
    }
    printf ("So restore list contents? (Y/N):");
    scanf ("%1s", ans);
    if (ans[0] == 'Y' || ans[0] == 'y') {
        sprintf (command, "sudo xargs -a packages pacman -S --needed");
        system (command);
    }
    else {
        printf ("\nOk. No packages restored!\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47978599_47979411_12_38
47978599_47979474_6_67
Title: "After reading from text file results are displayed incorrectly" 
----------------------------------------

int main (void) {
    char id [MAX_ID_LEN];
    char firstname [MAX_NAME_LEN];
    char lastname [MAX_NAME_LEN];
    char gender;
    char contact [MAX_CONTACT_LEN];
    FILE *text = fopen ("test.txt", "r");
    if (!text) {
        perror ("fopen to read 'test.txt' failed");
        exit (EXIT_FAILURE);
    }
    while (5 == fscanf (text, "%5s %19s %19s %c %12s", id, firstname, lastname, &gender, contact)) {
        printf ("%s %s %s %c %s\n", id, firstname, lastname, gender, contact);
    }
    fclose (text);
    return 0;
}
----------------------------------------

int main (void) {
    FILE *text;
    char id [6], name [101], gender, contact [13];
    char *lookback;
    int result;
    unsigned int line_number = 0;
    text = fopen ("test.txt", "r");
    if (text == NULL) {
        printf ("file not found!\n");
        return EXIT_FAILURE;
    }
    do {
        result = fscanf (text, "%s %[^\n]s\n", id, name);
        line_number++;
        if (result == EOF)
            break;
        if (result != 2) {
            printf ("error in data file on line %u (expected at least 2 items)\n", line_number);
            break;
        }
        lookback = strrchr (name, ' ');
        if (lookback == NULL || strlen (lookback +1) > 12) {
            printf ("error in data file on line %u (expected 'contact')\n", line_number);
            break;
        }
        strcpy (contact, lookback + 1);
        *lookback = 0;
        lookback = strrchr (name, ' ');
        if (lookback == NULL || strlen (lookback +1) != 1) {
            printf ("error in data file on line %u (expected 'gender')\n", line_number);
            break;
        }
        gender = toupper (lookback[1]);
        if (gender != 'F' && gender != 'M') {
            printf ("error in data file on line %u (expected 'M' or 'F')\n", line_number);
            break;
        }
        *lookback = 0;
        printf ("%s %s %c %s\n", id, name, gender, contact);
    }
    while (1);
    fclose (text);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
47999053_48000648_1_18
47999053_48001271_20_70
Title: How to access struct in an array of structs 
----------------------------------------

int main (void) {
    long filesize = 0;
    unsigned char *p = readfile ("d.bin", &filesize);
    if (!p)
        return 0;
    int count = filesize / sizeof (record);
    record *arr = (record *) p;
    qsort (arr, count, sizeof (record), nuvu);
    for (int i = 0; i < count; i++)
        printf ("%s %f\n", arr[i].name, arr[i].value);
    free (p);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    record rec [MAXS] = {{
            .name = ""
        }
    };
    size_t nrec = 0;
    long nbytes = 0;
    char *fn = argc > 1 ? argv[1] : "dat/records.bin";
    FILE *fp = fopen (fn, "rb");
    if (!fp) {
        fprintf (stderr, "error: file open failed '%s'.\n", argv [1]);
        return 1;
    }
    if (fseek (fp, 0, SEEK_END) == -1) {
        perror ("fseek");
        return 1;
    }
    nbytes = ftell (fp);
    if (nbytes == -1) {
        perror ("ftell");
        return 1;
    }
    if (fseek (fp, 0, SEEK_SET) == -1) {
        perror ("fseek");
        return 1;
    }
    if (nbytes % sizeof *rec != 0)
        fprintf (stderr, "warning: file size not multiple of record size.\n");
    nrec = nbytes / sizeof *rec;
    if (fread (rec, sizeof *rec, nrec, fp) != nrec) {
        perror (fn);
        return 1;
    }
    fclose (fp);
    printf ("\n=== unsorted records ===\n\n");
    for (size_t i = 0; i < nrec; i++)
        printf ("%-32s  %g\n", rec[i].name, rec[i].value);
    qsort (rec, nrec, sizeof * rec, reccmpname);
    printf ("\n=== sorted records ===\n\n");
    for (size_t i = 0; i < nrec; i++)
        printf ("%-32s  %g\n", rec[i].name, rec[i].value);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48005819_48006000_5_24
48005819_48006278_31_64
Title: can we use switch-case statement with strings in c? 
----------------------------------------

int main (int argc, char *argv []) {
    if (argc != 4) {
        puts ("Incorrect usage");
        return 1;
    }
    char *op = argv[1];
    int a = atoi (argv[2]);
    int b = atoi (argv[3]);
    if (strcmp (op, "+") == 0)
        printf ("%d + %d = %d\n", a, b, a +b);
    else if (strcmp (op, "-") == 0)
        printf ("%d - %d = %d\n", a, b, a -b);
    return 0;
}
----------------------------------------

int main () {
    enum names {NAMES (ENUM_F) NUM_NAMES};
    const char *names [NUM_NAMES] = {NAMES (STRING_F) NULL
    };
    char s [500];
    printf ("name? ");
    fflush (stdout);
    fgets (s, sizeof (s), stdin);
    zero (strchr (s, '\n'));
    switch (find (names, sizeof (names) / sizeof (*names), strupper (s))) {
    case MARINETTE :
        puts ("Ladybug!");
        break;
    case ADRIAN :
        puts ("Chat Noir!");
        break;
    case ALYA :
    case DINO :
        puts ("Best friend!");
        break;
    default :
        puts ("Who?");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48005819_48006000_5_24
48005819_48008196_35_73
Title: can we use switch-case statement with strings in c? 
----------------------------------------

int main (int argc, char *argv []) {
    if (argc != 4) {
        puts ("Incorrect usage");
        return 1;
    }
    char *op = argv[1];
    int a = atoi (argv[2]);
    int b = atoi (argv[3]);
    if (strcmp (op, "+") == 0)
        printf ("%d + %d = %d\n", a, b, a +b);
    else if (strcmp (op, "-") == 0)
        printf ("%d - %d = %d\n", a, b, a -b);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    size_t s = sizeof operations / sizeof *operations;
    qsort (operations, s, sizeof * operations, cmp);
    {
        struct Operation_Descriptor *pop = bsearch (&(structOperation_Descriptor){argv[1], OP_INVALID}, operations, s, sizeof *operations, cmp);
        switch (pop ? pop->op : OP_INVALID) {
        case OP_ADD :
            break;
        case OP_SUBTRACT :
            break;
        case OP_MULTIPLY :
            break;
        case OP_DIVIDE :
            break;
        case OP_INVALID :
        default :
            fprintf (stderr, "unhandled or invalid operation '%s'\n", argv[1]);
            break;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48005819_48006278_31_64
48005819_48008196_35_73
Title: can we use switch-case statement with strings in c? 
----------------------------------------

int main () {
    enum names {NAMES (ENUM_F) NUM_NAMES};
    const char *names [NUM_NAMES] = {NAMES (STRING_F) NULL
    };
    char s [500];
    printf ("name? ");
    fflush (stdout);
    fgets (s, sizeof (s), stdin);
    zero (strchr (s, '\n'));
    switch (find (names, sizeof (names) / sizeof (*names), strupper (s))) {
    case MARINETTE :
        puts ("Ladybug!");
        break;
    case ADRIAN :
        puts ("Chat Noir!");
        break;
    case ALYA :
    case DINO :
        puts ("Best friend!");
        break;
    default :
        puts ("Who?");
    }
}
----------------------------------------

int main (int argc, char **argv) {
    size_t s = sizeof operations / sizeof *operations;
    qsort (operations, s, sizeof * operations, cmp);
    {
        struct Operation_Descriptor *pop = bsearch (&(structOperation_Descriptor){argv[1], OP_INVALID}, operations, s, sizeof *operations, cmp);
        switch (pop ? pop->op : OP_INVALID) {
        case OP_ADD :
            break;
        case OP_SUBTRACT :
            break;
        case OP_MULTIPLY :
            break;
        case OP_DIVIDE :
            break;
        case OP_INVALID :
        default :
            fprintf (stderr, "unhandled or invalid operation '%s'\n", argv[1]);
            break;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48013629_48015676_76_106
48013629_48018005_6_92
Title: Separate punctuation marks in C from a word 
----------------------------------------

int main (void) {
    char *str = "Hello, Sara! How are You?";
    char **array;
    int i = 0;
    int j = 0;
    int size = 0;
    size = count_word (str, ' ');
    if ((array = malloc (sizeof (char *) * (size + 1))) == NULL)
        return -1;
    while (str[i]) {
        size = count_char (&str[i]);
        if ((array[j] = malloc (sizeof (char) * (size))) == NULL)
            return -1;
        strncpy (array [j], & str [i], size);
        array[j][size] = '\0';
        skip_copied_bytes (& str [i], & i);
        j++;
    }
    array[j] = 0;
    for (i = 0; array[i]; i++) {
        printf ("[%s] \n", array [i]);
    }
}
----------------------------------------

int main (void) {
    char *stnc_org, *stnc_new;
    int size;
    printf ("What is the expected size of the sentence: ");
    scanf ("%d", & size);
    stnc_org = (char *) malloc (size * sizeof (char));
    printf ("Input: \n");
    scanf (" %[^\n]", stnc_org);
    int punct_num = 0;
    int i;
    for (i = 0; *(stnc_org + i) != '\0'; i++) {
        if (ispunct (*(stnc_org + i))) {
            punct_num++;
        }
    }
    char *stnc_backup = (char *) malloc ((size + punct_num * 2) * sizeof (char));
    stnc_new = stnc_backup;
    for (i = 0; *(stnc_org + i) != '\0'; i++) {
        if (ispunct (*(stnc_org + i))) {
            if (i == 0) {
                *(stnc_new + i) = *(stnc_org + i);
                *(stnc_new + i + 1) = ' ';
                stnc_new = stnc_new + (i + 2);
            }
            else if (*(stnc_org + i + 1) == '\0') {
                if (*(stnc_org + i - 1) != ' ') {
                    strncpy (stnc_new, stnc_org, i);
                    *(stnc_new + i) = ' ';
                    *(stnc_new + i + 1) = *(stnc_org + i);
                    *(stnc_new + i + 2) = '\0';
                    stnc_new = stnc_new + (i + 1);
                }
            }
            else if (*(stnc_org + i - 1) != ' ' && *(stnc_org + i + 1) == ' ') {
                strncpy (stnc_new, stnc_org, i);
                *(stnc_new + i) = ' ';
                *(stnc_new + i + 1) = *(stnc_org + i);
                stnc_new = stnc_new + (i + 1);
            }
            else if (*(stnc_org + i - 1) == ' ' && *(stnc_org + i + 1) != ' ') {
                strncpy (stnc_new, stnc_org, i);
                *(stnc_new + i) = *(stnc_org + i);
                *(stnc_new + i + 1) = ' ';
                stnc_new = stnc_new + (i + 2);
            }
            else if (*(stnc_org + i - 1) != ' ' && *(stnc_org + i + 1) != ' ') {
                strncpy (stnc_new, stnc_org, i);
                *(stnc_new + i) = ' ';
                *(stnc_new + i + 1) = *(stnc_org + i);
                *(stnc_new + i + 2) = ' ';
                stnc_new = stnc_new + (i + 3);
            }
            stnc_org = stnc_org + i + 1;
            i = -1;
        }
    }
    printf ("\nOutput:\n");
    char *str;
    str = strtok (stnc_backup, " \n\r");
    while (str != NULL) {
        printf ("%s\n", str);
        str = strtok (NULL, " \n\r");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48020656_48021139_1_39
48020656_48021490_5_38
Title: C program to find growing numbers in an inverval 
----------------------------------------

int main () {
    int n, m, k, digit1, digit2, digit3, p, a = 0;
    do {
        printf ("Enter m and n (m < n):\n");
        scanf ("%d %d", & m, & n);
        if (m < n) {
            break;
        }
        else
            printf ("\Error - m > n! Try again.\n\n");
    }
    while (a == 0);
    printf ("Output:\n");
    k = m;
    while (k++ <= n) {
        int p = k;
        int flag = 0;
        int num;
        while (p > 10) {
            num = p % 10;
            p = p / 10;
            if (num == p % 10 + 1)
                continue;
            flag = 1;
            break;
        }
        if (k > 10 && !flag)
            printf ("%d ", k);
    }
    return 0;
}
----------------------------------------

int main () {
    int m, n, i, j;
    char buf [20], c, last;
    _Bool ascending;
    puts ("Enter m and n (m < n):");
    scanf ("%d %d", & m, & n);
    if (m >= n) {
        fprintf (stderr, "m must be smaller than n");
        exit (EXIT_FAILURE);
    }
    puts ("Output:");
    for (i = m; i < n; i++) {
        sprintf (buf, "%d", i);
        ascending = true;
        last = 0;
        for (j = 0; buf[j] != 0; j++) {
            c = buf[j];
            if (last != 0 && last != c - 1) {
                ascending = false;
                break;
            }
            else {
                last = c;
            }
        }
        if (ascending) {
            printf ("%d ", i);
        }
    }
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48020656_48021139_1_39
48020656_48021681_5_28
Title: C program to find growing numbers in an inverval 
----------------------------------------

int main () {
    int n, m, k, digit1, digit2, digit3, p, a = 0;
    do {
        printf ("Enter m and n (m < n):\n");
        scanf ("%d %d", & m, & n);
        if (m < n) {
            break;
        }
        else
            printf ("\Error - m > n! Try again.\n\n");
    }
    while (a == 0);
    printf ("Output:\n");
    k = m;
    while (k++ <= n) {
        int p = k;
        int flag = 0;
        int num;
        while (p > 10) {
            num = p % 10;
            p = p / 10;
            if (num == p % 10 + 1)
                continue;
            flag = 1;
            break;
        }
        if (k > 10 && !flag)
            printf ("%d ", k);
    }
    return 0;
}
----------------------------------------

int main (void) {
    unsigned int m = 1;
    unsigned int n = 123456789;
    for (unsigned int i = m; i <= n; ++i) {
        unsigned int x = i;
        bool growing = true;
        unsigned int last = x % 10 + 1;
        while (x > 0) {
            unsigned int cur = x % 10;
            x /= 10;
            if (cur != last - 1)
                growing = false;
            last = cur;
        }
        if (growing) {
            printf ("%i ", i);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48020656_48021139_1_39
48020656_48023083_20_40
Title: C program to find growing numbers in an inverval 
----------------------------------------

int main () {
    int n, m, k, digit1, digit2, digit3, p, a = 0;
    do {
        printf ("Enter m and n (m < n):\n");
        scanf ("%d %d", & m, & n);
        if (m < n) {
            break;
        }
        else
            printf ("\Error - m > n! Try again.\n\n");
    }
    while (a == 0);
    printf ("Output:\n");
    k = m;
    while (k++ <= n) {
        int p = k;
        int flag = 0;
        int num;
        while (p > 10) {
            num = p % 10;
            p = p / 10;
            if (num == p % 10 + 1)
                continue;
            flag = 1;
            break;
        }
        if (k > 10 && !flag)
            printf ("%d ", k);
    }
    return 0;
}
----------------------------------------

int main () {
    int m, n, i;
    puts ("Enter m and n (m < n):");
    scanf ("%d %d", & m, & n);
    if (m >= n) {
        fprintf (stderr, "m must be smaller than n");
        exit (EXIT_FAILURE);
    }
    puts ("Output:");
    for (i = m; i < n; i++) {
        if (only_consecutive_figures (i)) {
            printf ("%d ", i);
        }
    }
    putchar ('\n');
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48020656_48021490_5_38
48020656_48021681_5_28
Title: C program to find growing numbers in an inverval 
----------------------------------------

int main () {
    int m, n, i, j;
    char buf [20], c, last;
    _Bool ascending;
    puts ("Enter m and n (m < n):");
    scanf ("%d %d", & m, & n);
    if (m >= n) {
        fprintf (stderr, "m must be smaller than n");
        exit (EXIT_FAILURE);
    }
    puts ("Output:");
    for (i = m; i < n; i++) {
        sprintf (buf, "%d", i);
        ascending = true;
        last = 0;
        for (j = 0; buf[j] != 0; j++) {
            c = buf[j];
            if (last != 0 && last != c - 1) {
                ascending = false;
                break;
            }
            else {
                last = c;
            }
        }
        if (ascending) {
            printf ("%d ", i);
        }
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main (void) {
    unsigned int m = 1;
    unsigned int n = 123456789;
    for (unsigned int i = m; i <= n; ++i) {
        unsigned int x = i;
        bool growing = true;
        unsigned int last = x % 10 + 1;
        while (x > 0) {
            unsigned int cur = x % 10;
            x /= 10;
            if (cur != last - 1)
                growing = false;
            last = cur;
        }
        if (growing) {
            printf ("%i ", i);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48020656_48021490_5_38
48020656_48023083_20_40
Title: C program to find growing numbers in an inverval 
----------------------------------------

int main () {
    int m, n, i, j;
    char buf [20], c, last;
    _Bool ascending;
    puts ("Enter m and n (m < n):");
    scanf ("%d %d", & m, & n);
    if (m >= n) {
        fprintf (stderr, "m must be smaller than n");
        exit (EXIT_FAILURE);
    }
    puts ("Output:");
    for (i = m; i < n; i++) {
        sprintf (buf, "%d", i);
        ascending = true;
        last = 0;
        for (j = 0; buf[j] != 0; j++) {
            c = buf[j];
            if (last != 0 && last != c - 1) {
                ascending = false;
                break;
            }
            else {
                last = c;
            }
        }
        if (ascending) {
            printf ("%d ", i);
        }
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    int m, n, i;
    puts ("Enter m and n (m < n):");
    scanf ("%d %d", & m, & n);
    if (m >= n) {
        fprintf (stderr, "m must be smaller than n");
        exit (EXIT_FAILURE);
    }
    puts ("Output:");
    for (i = m; i < n; i++) {
        if (only_consecutive_figures (i)) {
            printf ("%d ", i);
        }
    }
    putchar ('\n');
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48020656_48021681_5_28
48020656_48023083_20_40
Title: C program to find growing numbers in an inverval 
----------------------------------------

int main (void) {
    unsigned int m = 1;
    unsigned int n = 123456789;
    for (unsigned int i = m; i <= n; ++i) {
        unsigned int x = i;
        bool growing = true;
        unsigned int last = x % 10 + 1;
        while (x > 0) {
            unsigned int cur = x % 10;
            x /= 10;
            if (cur != last - 1)
                growing = false;
            last = cur;
        }
        if (growing) {
            printf ("%i ", i);
        }
    }
}
----------------------------------------

int main () {
    int m, n, i;
    puts ("Enter m and n (m < n):");
    scanf ("%d %d", & m, & n);
    if (m >= n) {
        fprintf (stderr, "m must be smaller than n");
        exit (EXIT_FAILURE);
    }
    puts ("Output:");
    for (i = m; i < n; i++) {
        if (only_consecutive_figures (i)) {
            printf ("%d ", i);
        }
    }
    putchar ('\n');
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48039141_48039386_3_16
48039141_48039735_2_40
Title: "How to find if there is a even or a odd number of ""1"" bit" 
----------------------------------------

int main (int argc, const char *argv []) {
    unsigned x;
    int count;
    scanf ("%u\n", & x);
    for (count = 0; x; x >>= 1)
        if (x & 1)
            ++count;
    puts (count & 1 ? "odd" : "even");
    return (0);
}
----------------------------------------

int main () {
    int *arr = malloc (N * sizeof (*arr));
    int *par = malloc (N * sizeof (*par));
    srand (time (NULL));
    for (int i = 0; i < N; i++)
        arr[i] = rand ();
    for (int i = 0; i < N; i++)
        if (evenNumberOfOnes (arr[i]) != evenNumberOfOnesFast (arr[i])) {
            perror ("Error");
            exit (EXIT_FAILURE);
        }
    clock_t begin, end;
    double time_spent;
    begin = clock ();
    for (int i = 0; i < N; i++)
        par[i] = evenNumberOfOnes (arr[i]);
    end = clock ();
    time_spent = (double) (end - begin) / CLOCKS_PER_SEC;
    printf (" Time: %f\n", time_spent);
    begin = clock ();
    for (int i = 0; i < N; i++)
        par[i] = evenNumberOfOnesFast (arr[i]);
    end = clock ();
    time_spent = (double) (end - begin) / CLOCKS_PER_SEC;
    printf (" Time: %f\n", time_spent);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48051721_48051878_3_15
48051721_48060693_4_29
Title: How to add the first number and last number of a series of number in C? 
----------------------------------------

int main () {
    int first, last, num, x = 0;
    scanf ("%d", & num);
    scanf ("%d", & first);
    last = first;
    for (x = 1; x < num; x++) {
        scanf ("%d", & last);
    }
    int add = first + last;
    printf ("%d\n", add);
    return 0;
}
----------------------------------------

int main () {
    int first, last, num, x = 0;
    int add = 0;
    printf ("What is the num value?\n");
    index value) scanf ("%d", & num);
    printf ("What is the first number?\n");
    scanf ("%d", & first);
    if (num == 1) {
        last = first;
    }
    else {
        for (x = 1; x < num; x++) {
            printf ("Enter number %d in the sequence:\n", x);
            scanf ("%d", & last);
        }
        add = (first + last);
        printf ("Sum of numbers equals:%d\n", add);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48052548_48052918_1_23
48052548_48052959_1_18
Title: Moving elements in an array (checks if 0) 
----------------------------------------

void movement (int a [], int n) {
    int temp, k = 0, i;
    for (i = 0; i < n; i++) {
        if (a[i] != 0) {
            if (a[k] == 0)
                k++;
        }
        else {
            if (a[k] != 0) {
                temp = a[i];
                a[i] = a[k];
                a[k] = temp;
            }
            k++;
        }
    }
}
----------------------------------------

void movement (int a [], int n) {
    int i, k;
    for (k = 0; k < n && a[k] == 0; k++)
        ;
    for (i = n - 1; i > k; i--) {
        if (a[i] == 0) {
            a[i] = a[k];
            a[k++] = 0;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48061567_48071754_66_113
48061567_48092684_18_31
Title: Raising subsequent alarm() 
----------------------------------------

int main (int argc, char **argv) {
    err_setarg0 (argv [0]);
    int opt;
    while ((opt = getopt (argc, argv, optstr)) != -1) {
        switch (opt) {
        case 'h' :
            err_help (usestr, hlpstr);
        case 'j' :
            use_jmpbuf = true;
            break;
        case 'm' :
            use_jmpbuf = true;
            save_mask = 0;
            break;
        default :
            err_usage (usestr);
        }
    }
    if (optind != argc)
        err_usage (usestr);
    signal (SIGINT, handle_sigint);
    err_setlogopts (ERR_MILLI);
    err_stderr (stdout);
    if (use_jmpbuf)
        err_remark ("Config: using sigsetjmp() %s saving signal mask\n", save_mask ? "with" : "without");
    else
        err_remark ("Config: no use of sigsetjmp\n");
    set_sigalrm ();
    unsigned left;
    left = alarm (2);
    err_remark ("Left over from previous alarm: %u\n", left);
    test ();
    err_remark ("In %s() once more\n", __func__);
    set_sigalrm ();
    left = alarm (2);
    err_remark ("Left over from previous alarm: %u\n", left);
    test ();
    err_remark ("Exiting %s() once more\n", __func__);
    return 0;
}
----------------------------------------

int main () {
    printf ("1\n");
    signal (SIGALRM, handle_timeout);
    alarm (2);
    test ();
    sigset_t m;
    sigprocmask (0, NULL, & m);
    printf ("%d\n", m);
    printf ("2\n");
    signal (SIGALRM, handle_timeout);
    alarm (2);
    test ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48065935_48066050_25_45
48065935_48066506_26_56
Title: function for multiple occurrences in linear search using pointer 
----------------------------------------

int main () {
    int n;
    scanf ("%d", & n);
    int a [n];
    int i;
    for (i = 0; i < n; i++) {
        scanf ("%d", & a [i]);
    }
    int x;
    scanf ("%d", & x);
    int count = 0;
    int *b = NULL;
    linearsearch (n, a, x, & count, & b);
    for (i = 0; i < count; i++) {
        printf ("%d", b [i]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n;
    if (scanf ("%d", &n) != 1) {
        fprintf (stderr, "%s\n", "Error in input");
        exit (1);
    }
    if (n <= 0) {
        fprintf (stderr, "%s\n", "Error in input : must be greater than 0");
        exit (1);
    }
    int a [n];
    for (int i = 0; i < n; i++)
        if (scanf ("%d", &a[i]) != 1) {
            fprintf (stderr, "%s\n", "Error in input.");
            exit (1);
        }
    int elmt_to_find;
    if (scanf ("%d", &elmt_to_find) != 1) {
        fprintf (stderr, "%s\n", "Error in input : Element to find(must be integer)");
    }
    int count;
    int *b = linearsearch (n, a, elmt_to_find, &count);
    for (int i = 0; i < count; i++)
        printf ("%d ", b[i]);
    printf ("%s", "\n");
    free (b);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48065935_48066050_3_24
48065935_48066571_1_28
Title: function for multiple occurrences in linear search using pointer 
----------------------------------------

void linearsearch (int n, int a [n], int x, int *count, int **b) {
    count = 0;
    int i;
    for (i = 0; i < n; i++) {
        if (a[i] == x) {
            count += 1;
        }
    }
    int j = 0;
    for (i = 0; i < n; i++) {
        if (a[i] == x) {
            *b = realloc (*b, sizeof (int) * (j + 1));
            (*b)[j] = i;
            j++;
        }
    }
}
----------------------------------------

int linearsearch (int n, int a [n], int x, int count, int *b [count]) {
    int i;
    if (count == 0) {
        for (i = 0; i < n; i++) {
            if (a[i] == x) {
                count += 1;
            }
        }
    }
    if (b == 0) {
        return count;
    }
    int j = 0;
    for (i = 0; i < n; i++) {
        if (a[i] == x) {
            b[j] = i;
            j++;
        }
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48066271_48067049_3_23
48066271_50524865_54_73
Title: How to print a pointer address without printf 
----------------------------------------

void print_memory (const void *addr, size_t size) {
    size_t printed = 0;
    size_t i;
    const unsigned char *pc = addr;
    for (i = 0; i < size; ++i) {
        int g;
        g = (*(pc + i) >> 4) & 0xf;
        g += g >= 10 ? 'a' - 10 : '0';
        putchar (g);
        printed++;
        g = *(pc + i) & 0xf;
        g += g >= 10 ? 'a' - 10 : '0';
        putchar (g);
        printed++;
        if (printed % 32 == 0)
            putchar ('\n');
        else if (printed % 4 == 0)
            putchar (' ');
    }
}
----------------------------------------

void print_memory (const void *addr, size_t size) {
    char *ptr;
    size_t i;
    if (addr && size > 0) {
        ptr = (char *) addr;
        i = 0;
        while (i < size) {
            print_hex (* (ptr + i), 0);
            if (i % 2)
                ft_putchar (' ');
            if ((i + 1) % 16 == 0 || (i + 1) == size)
                print_ascii (addr, i);
            i++;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48069404_48069558_1_23
48069404_48086996_4_16
Title: How to compare long doubles with qsort and with regard to NaN? 
----------------------------------------

int compare (const void *a, const void *b) {
    const long double fa = *(constlongdouble*) a;
    const long double fb = *(constlongdouble*) b;
    if (isnan (fa)) {
        if (isnan (fb)) {
            return 0;
        }
        return 1;
    }
    if (isnan (fb)) {
        return -1;
    }
    if (fa > fb)
        return 1;
    if (fa < fb)
        return -1;
    return 0;
}
----------------------------------------

int compare (const void *a, const void *b) {
    const long double *fa = (const long double *) a;
    const long double *fb = (const long double *) b;
    if (!isunordered (*fa, *fb)) {
        return (*fa > *fb) - (*fa < *fb);
    }
    if (!isnan (*fa)) {
        return -1;
    }
    return isnan (*fb);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4809051_31322918_5_44
4809051_4833217_28_71
Title: Prime Number Algorithm 
----------------------------------------

int main () {
    int a [NUM] = {0};
    int i, j;
    for (i = 2, j = 0; i < NUM + 2, j < NUM; i++, j++) {
        a[j] = i;
    }
    for (i = 0; i < NUM; i++) {
        int num = a[i];
        if (num != 0) {
            for (j = i + 1; j < NUM; j++) {
                if ((a[j] % num == 0)) {
                    a[j] = 0;
                }
            }
        }
    }
    for (i = 0; i < NUM; i++) {
        if (a[i] != 0) {
            printf ("%d \n", a [i]);
        }
    }
}
----------------------------------------

int main () {
    int i;
    printf ("Find primes up to: ");
    scanf ("%i", & i);
    clock_t start, stop;
    double t = 0.0;
    assert ((start = clock ()) != - 1);
    alloc_prime;
    int c1, c2, c3;
    if (!prime) {
        printf ("Can't allocate %zu bytes!\n", i * sizeof (* prime));
        exit (1);
    }
    set_not_prime (0);
    set_not_prime (1);
    for (c2 = 2; c2 <= (int) sqrt (i) + 1; c2++) {
        if (is_prime (c2)) {
            c1 = c2;
            for (c3 = 2 * c1; c3 <= i + 1; c3 += c1) {
                set_not_prime (c3);
            }
        }
    }
    stop = clock ();
    t = (double) (stop - start) / CLOCKS_PER_SEC;
    for (c1 = 0; c1 < i + 1; c1++) {
        if (is_prime (c1))
            printf ("%i\n", c1);
    }
    printf ("Run time: %f\n", t);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48104760_48104803_1_17
48104760_48112462_1_21
Title: SEGV: invalig write of size 8 when adding a node to the end of a linked list 
----------------------------------------

int list_add_elem_at_back (list_t *front_ptr, double elem) {
    list_t item = malloc (sizeof (*list_t));
    int success = item != NULL;
    if (success) {
        item->value = elem;
        item->next = NULL;
        while (*front_ptr != NULL)
            front_ptr = &(*front_ptr)->next;
        *front_ptr = item;
    }
    return success;
}
----------------------------------------

int list_add_elem_at_back (node_t **front_ptr, double elem) {
    node_t *item = malloc (sizeof (node_t));
    node_t *tmp;
    if (item == NULL) {
        return (0);
    }
    item->value = elem;
    item->next = NULL;
    if (*front_ptr == NULL) {
        *front_ptr = item;
    }
    else {
        tmp = *front_ptr;
        while (tmp->next != NULL)
            tmp = tmp->next;
        tmp->next = item;
    }
    return (1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48132803_48133167_2_19
48132803_48133212_49_71
Title: Sorting queues elements in linked list in C 
----------------------------------------

node *sortedInsert (node *root, int x) {
    if (root == NULL) {
        root = (node *) malloc (sizeof (node));
        node *sortedlist (queue *q1, queue *q2) {
            node *root = NULL;
            while (q1 -> counter != 0) {root = sortedInsert (root, dequeue (q1));
        } while (q2 -> counter != 0) {root = sortedInsert (root, dequeue (q2));
    }
    return root;
}
----------------------------------------

node *sortedInsert (node **root, int x) {
    if (*root == NULL) {
        *root = (node *) malloc (sizeof (node *));
        (*root)->x = x;
        (*root)->next = NULL;
        return root;
    }
    if (x < (*root)->x) {
        node *temp = (node *) malloc (sizeof (node));
        temp->next = root;
        temp->x = x;
        return temp;
    }
    node *iter = *root;
    while (iter->next != NULL && iter->next->x < x) {
        iter = iter->next;
    }
    node *temp = (node *) malloc (sizeof (node));
    temp->x = x;
    temp->next = iter->next;
    iter->next = temp;
    return *root;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48151445_48151685_13_30
48151445_48152728_45_77
Title: how to copy a string chars from the end to the beginning in c language 
----------------------------------------

void rotate (char *sa [4], int rotate) {
    int i, j, count;
    char *temp = {0};
    count = sizeof (*sa) / sizeof (*sa[0]);
    for (i = 0; i < rotate; i++) {
        temp = sa[0];
        for (j = 0; j < count - 1; j++) {
            sa[j] = sa[j + 1];
        }
        sa[j] = temp;
    }
}
----------------------------------------

void rotate (char *str, int r) {
    int start, end;
    int words = getStrCount (str);
    r = r % words;
    if (r == 0)
        return;
    char *result = malloc (1024);
    strcpy (result, "{ ");
    char *w [words];
    int i;
    for (i = 0; i < words; ++i) {
        w[i] = malloc (1024);
        getStrN (str, i + 1, & start, & end);
        memcpy (w [i], & str [start], end - start + 1);
        w[i][end - start + 1] = '\0';
    }
    int j = words - r;
    for (i = 0; i < words; ++i) {
        if (i != 0)
            strcat (result, ", ");
        strcat (result, w [j]);
        ++j;
        if (j == words)
            j = 0;
    }
    strcat (result, " }");
    strcpy (str, result);
    free (result);
    for (i = 0; i < words; ++i) {
        free (w [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4816819_29922743_1_35
4816819_30816251_4_28
Title: Strings in C Language 
----------------------------------------

void main () {
    char my_string1 [50], my_string2 [50];
    int ptr;
    ptr = 0;
    printf ("Enter a word : ");
    scanf ("%s", my_string1);
    printf ("enter a word");
    scanf ("%s", my_string2);
    while (my_string1[ptr] != '\0' && my_string2[ptr] != '\0') {
        printf ("%c%c", my_string1 [ptr], my_string2 [ptr]);
        ptr++;
    }
    if (my_string1[ptr] != '\0') {
        while (my_string1[ptr] != '\0') {
            printf ("%c", my_string1 [ptr]);
            ptr++;
        }
    }
    else {
        while (my_string2[ptr] != '\0') {
            printf ("%c", my_string2 [ptr]);
            ptr++;
        }
    }
}
----------------------------------------

void main () {
    char my_string1 [50], my_string2 [50];
    int i, l1 = 1, l2 = 0;
    printf ("Enter a word:");
    scanf ("%s", my_string1);
    printf ("Enter a word:");
    scanf ("%s", my_string2);
    l1 = strlen (my_string1);
    l2 = strlen (my_string2);
    if (l1 == l2) {
        for (i = 0; i < l1; i++) {
            printf ("%c%c", my_string1 [i], my_string2 [i]);
        }
    }
    else {
        printf ("Length of the entered strings do not match");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4816819_29922743_1_35
4816819_4817056_5_30
Title: Strings in C Language 
----------------------------------------

void main () {
    char my_string1 [50], my_string2 [50];
    int ptr;
    ptr = 0;
    printf ("Enter a word : ");
    scanf ("%s", my_string1);
    printf ("enter a word");
    scanf ("%s", my_string2);
    while (my_string1[ptr] != '\0' && my_string2[ptr] != '\0') {
        printf ("%c%c", my_string1 [ptr], my_string2 [ptr]);
        ptr++;
    }
    if (my_string1[ptr] != '\0') {
        while (my_string1[ptr] != '\0') {
            printf ("%c", my_string1 [ptr]);
            ptr++;
        }
    }
    else {
        while (my_string2[ptr] != '\0') {
            printf ("%c", my_string2 [ptr]);
            ptr++;
        }
    }
}
----------------------------------------

int main (int argc, char *argv []) {
    char str1 [] = "abcdefghijklmopq";
    char str2 [] = "jklm";
    int len1 = strlen (str1);
    int len2 = strlen (str2);
    int c1 = 0, c2 = 0;
    int max = (len1 > len2) ? len1 : len2;
    char *result = malloc (len1 +len2);
    for (c1 = 0; c1 <= max; c1++) {
        if (c1 < len1)
            result[c2++] = str1[c1];
        if (c1 < len2)
            result[c2++] = str2[c1];
    }
    result[c2] = 0;
    printf ("\n%s\n", result);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4816819_30816251_4_28
4816819_4817056_5_30
Title: Strings in C Language 
----------------------------------------

void main () {
    char my_string1 [50], my_string2 [50];
    int i, l1 = 1, l2 = 0;
    printf ("Enter a word:");
    scanf ("%s", my_string1);
    printf ("Enter a word:");
    scanf ("%s", my_string2);
    l1 = strlen (my_string1);
    l2 = strlen (my_string2);
    if (l1 == l2) {
        for (i = 0; i < l1; i++) {
            printf ("%c%c", my_string1 [i], my_string2 [i]);
        }
    }
    else {
        printf ("Length of the entered strings do not match");
    }
}
----------------------------------------

int main (int argc, char *argv []) {
    char str1 [] = "abcdefghijklmopq";
    char str2 [] = "jklm";
    int len1 = strlen (str1);
    int len2 = strlen (str2);
    int c1 = 0, c2 = 0;
    int max = (len1 > len2) ? len1 : len2;
    char *result = malloc (len1 +len2);
    for (c1 = 0; c1 <= max; c1++) {
        if (c1 < len1)
            result[c2++] = str1[c1];
        if (c1 < len2)
            result[c2++] = str2[c1];
    }
    result[c2] = 0;
    printf ("\n%s\n", result);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48186152_48186572_8_56
48186152_48188332_8_44
Title: Write numbers from 1 to 100 using fork() and pipe() 
----------------------------------------

int main (void) {
    int parent_to_child [2];
    int child_to_parent [2];
    if (pipe (parent_to_child) == -1 || pipe (child_to_parent) == -1) {
        perror ("pipe");
        return EXIT_FAILURE;
    }
    pid_t cpid = fork ();
    if (cpid == -1) {
        perror ("fork");
        return EXIT_FAILURE;
    }
    if (cpid == 0) {
        close (parent_to_child [1]);
        close (child_to_parent [0]);
        int i = 1;
        bool buf;
        ssize_t ret;
        while ((ret = read (parent_to_child[0], &buf, sizeof buf)) > 0) {
            fprintf (stdout, "%d ", i);
            fflush (stdout);
            if (write (child_to_parent[1], &buf, sizeof buf) != sizeof buf) {
                break;
            }
            i += 2;
        }
        close (parent_to_child [0]);
        close (child_to_parent [1]);
    }
    else {
        close (parent_to_child [0]);
        close (child_to_parent [1]);
        int i = 2;
        bool buf = true;
        ssize_t ret;
        while (i <= 100 && write (parent_to_child[1], &buf, sizeof buf) == sizeof buf && (ret = read (child_to_parent[0], &buf, sizeof buf)) > 0) {
            fprintf (stdout, i != 100 ? "%d " : "%d\n", i);
            fflush (stdout);
            i += 2;
        }
        close (parent_to_child [1]);
        close (child_to_parent [0]);
    }
}
----------------------------------------

int main () {
    pid_t childpid;
    int fd [4];
    FILE *f;
    pipe (fd);
    pipe (fd + 2);
    int start = 0;
    write (fd [0], & start, sizeof (start));
    f = fopen ("output.txt", "w");
    if (f == NULL) {
        perror ("Error opening file");
        return 1;
    }
    setbuf (f, NULL);
    if ((childpid = fork ()) == -1) {
        perror ("fork");
    }
    if (childpid == 0) {
        printf ("run child\n");
        printProc (1, f, fd [1], fd [2]);
    }
    else {
        printf ("run parent\n");
        printProc (2, f, fd [3], fd [0]);
    }
    fclose (f);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48186152_48186572_8_56
48186152_48188979_7_60
Title: Write numbers from 1 to 100 using fork() and pipe() 
----------------------------------------

int main (void) {
    int parent_to_child [2];
    int child_to_parent [2];
    if (pipe (parent_to_child) == -1 || pipe (child_to_parent) == -1) {
        perror ("pipe");
        return EXIT_FAILURE;
    }
    pid_t cpid = fork ();
    if (cpid == -1) {
        perror ("fork");
        return EXIT_FAILURE;
    }
    if (cpid == 0) {
        close (parent_to_child [1]);
        close (child_to_parent [0]);
        int i = 1;
        bool buf;
        ssize_t ret;
        while ((ret = read (parent_to_child[0], &buf, sizeof buf)) > 0) {
            fprintf (stdout, "%d ", i);
            fflush (stdout);
            if (write (child_to_parent[1], &buf, sizeof buf) != sizeof buf) {
                break;
            }
            i += 2;
        }
        close (parent_to_child [0]);
        close (child_to_parent [1]);
    }
    else {
        close (parent_to_child [0]);
        close (child_to_parent [1]);
        int i = 2;
        bool buf = true;
        ssize_t ret;
        while (i <= 100 && write (parent_to_child[1], &buf, sizeof buf) == sizeof buf && (ret = read (child_to_parent[0], &buf, sizeof buf)) > 0) {
            fprintf (stdout, i != 100 ? "%d " : "%d\n", i);
            fflush (stdout);
            i += 2;
        }
        close (parent_to_child [1]);
        close (child_to_parent [0]);
    }
}
----------------------------------------

int main () {
    pthread_mutex_t *pmutex;
    short *even;
    pthread_mutexattr_t attrmutex;
    pthread_mutexattr_init (& attrmutex);
    pthread_mutexattr_setpshared (& attrmutex, PTHREAD_PROCESS_SHARED);
    pmutex = mmap (NULL, sizeof (pthread_mutex_t), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    even = mmap (NULL, sizeof (short), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    pthread_mutex_init (pmutex, & attrmutex);
    pthread_mutex_lock (pmutex);
    *even = 0;
    if (fork () == 0) {
        int a = 2;
        while (a <= 100) {
            pthread_mutex_lock (pmutex);
            if (*even) {
                printf ("%d\n", a);
                *even = 0;
                a = a + 2;
            }
            pthread_mutex_unlock (pmutex);
        }
        return 0;
    }
    else {
        int a = 1;
        printf ("%d\n", a);
        *even = 1;
        pthread_mutex_unlock (pmutex);
        a = a + 2;
        while (a <= 99) {
            pthread_mutex_lock (pmutex);
            if (!*even) {
                printf ("%d\n", a);
                *even = 1;
                a = a + 2;
            }
            pthread_mutex_unlock (pmutex);
        }
    }
    pthread_mutex_destroy (pmutex);
    pthread_mutexattr_destroy (& attrmutex);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48186152_48188332_8_44
48186152_48188979_7_60
Title: Write numbers from 1 to 100 using fork() and pipe() 
----------------------------------------

int main () {
    pid_t childpid;
    int fd [4];
    FILE *f;
    pipe (fd);
    pipe (fd + 2);
    int start = 0;
    write (fd [0], & start, sizeof (start));
    f = fopen ("output.txt", "w");
    if (f == NULL) {
        perror ("Error opening file");
        return 1;
    }
    setbuf (f, NULL);
    if ((childpid = fork ()) == -1) {
        perror ("fork");
    }
    if (childpid == 0) {
        printf ("run child\n");
        printProc (1, f, fd [1], fd [2]);
    }
    else {
        printf ("run parent\n");
        printProc (2, f, fd [3], fd [0]);
    }
    fclose (f);
    return 0;
}
----------------------------------------

int main () {
    pthread_mutex_t *pmutex;
    short *even;
    pthread_mutexattr_t attrmutex;
    pthread_mutexattr_init (& attrmutex);
    pthread_mutexattr_setpshared (& attrmutex, PTHREAD_PROCESS_SHARED);
    pmutex = mmap (NULL, sizeof (pthread_mutex_t), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    even = mmap (NULL, sizeof (short), PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, -1, 0);
    pthread_mutex_init (pmutex, & attrmutex);
    pthread_mutex_lock (pmutex);
    *even = 0;
    if (fork () == 0) {
        int a = 2;
        while (a <= 100) {
            pthread_mutex_lock (pmutex);
            if (*even) {
                printf ("%d\n", a);
                *even = 0;
                a = a + 2;
            }
            pthread_mutex_unlock (pmutex);
        }
        return 0;
    }
    else {
        int a = 1;
        printf ("%d\n", a);
        *even = 1;
        pthread_mutex_unlock (pmutex);
        a = a + 2;
        while (a <= 99) {
            pthread_mutex_lock (pmutex);
            if (!*even) {
                printf ("%d\n", a);
                *even = 1;
                a = a + 2;
            }
            pthread_mutex_unlock (pmutex);
        }
    }
    pthread_mutex_destroy (pmutex);
    pthread_mutexattr_destroy (& attrmutex);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48189625_48189709_1_27
48189625_48190275_15_35
Title: Delete an element from a node list in c 
----------------------------------------

Node *remove_list (Node *list, int index) {
    if (index < 0) {
        fprintf (stderr, "Error in index\n");
        exit (1);
    }
    if (!list) {
        fprintf (stderr, "Empty list\n");
        return list;
    }
    Node *p = list, *st = list;
    for (int i = 0; i <= index - 1; i++) {
        if (list) {
            p = list;
            list = list->next;
        }
        else {
            fprintf (stderr, "Error in index - out of bound access\n");
            exit (1);
        }
    }
    if (index)
        p->next = list->next;
    else
        p = list->next;
    free (list);
    return index == 0 ? p : st;
}
----------------------------------------

Node *remove_list (Node *list, size_t index) {
    Node **current = &list;
    while (*current && index) {
        current = &(*current)->next;
        --index;
    }
    if (*current) {
        Node *tmp = *current;
        *current = (*current)->next;
        free (tmp -> value);
        free (tmp);
    }
    return list;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48198158_48199716_17_26
48198158_48199807_5_17
Title: How to compare elements of a character array with characters in C? 
----------------------------------------

int main () {
    char s [30], c;
    printf ("Enter string :");
    gets (s);
    printf ("Enter character that you want to remove :");
    scanf ("%c", & c);
    func (s, c);
    return 0;
}
----------------------------------------

int main (void) {
    char s [30], c;
    printf ("Enter string: ");
    fflush (stdout);
    gets (s);
    printf ("Enter char: ");
    c = getchar ();
    func (s, c);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48198158_48199716_3_16
48198158_48199807_19_35
Title: How to compare elements of a character array with characters in C? 
----------------------------------------

void func (char a [], char b) {
    int i, j = 0;
    char str1 [30];
    for (i = 0; i < strlen (a); i++) {
        if (a[i] != b) {
            str1[j] = a[i];
            j++;
        }
    }
    str1[j] = '\0';
    printf ("%s", str1);
}
----------------------------------------

void func (char *s, char c) {
    char str1 [30], *dp;
    dp = str1;
    while (*s) {
        if (*s != c)
            *dp++ = *s++;
        else if (*s == c) {
            s++;
            continue;
        }
    }
    *dp = '\0';
    printf ("Filtered string: %s\n", str1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4823177_15713419_1_20
4823177_4823234_15_27
Title: Reading a file character by character in C 
----------------------------------------

char *readFile (char *fileName) {
    FILE *file = fopen (fileName, "r");
    char *code;
    size_t n = 0;
    int c;
    if (file == NULL)
        return NULL;
    fseek (file, 0, SEEK_END);
    long f_size = ftell (file);
    fseek (file, 0, SEEK_SET);
    code = malloc (f_size);
    while ((c = fgetc (file)) != EOF) {
        code[n++] = (char) c;
    }
    code[n] = '\0';
    return code;
}
----------------------------------------

char *readFile (char *fileName) {
    FILE *file;
    int i = 0;
    char *code = malloc (1000 * sizeof (char));
    file = fopen (fileName, "r");
    do {
        code[i++] = (char) fgetc (file);
    }
    while (code[i - 1] != EOF);
    code [i] = '\0' return code;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4823177_15713419_1_20
4823177_4823234_1_13
Title: Reading a file character by character in C 
----------------------------------------

char *readFile (char *fileName) {
    FILE *file = fopen (fileName, "r");
    char *code;
    size_t n = 0;
    int c;
    if (file == NULL)
        return NULL;
    fseek (file, 0, SEEK_END);
    long f_size = ftell (file);
    fseek (file, 0, SEEK_SET);
    code = malloc (f_size);
    while ((c = fgetc (file)) != EOF) {
        code[n++] = (char) c;
    }
    code[n] = '\0';
    return code;
}
----------------------------------------

char *readFile (char *fileName) {
    FILE *file;
    char *code = malloc (1000 * sizeof (char));
    char *p = code;
    file = fopen (fileName, "r");
    do {
        *p++ = (char) fgetc (file);
    }
    while (*p != EOF);
    *p = '\0';
    return code;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4823177_4823209_1_22
4823177_4823234_15_27
Title: Reading a file character by character in C 
----------------------------------------

char *readFile (char *fileName) {
    FILE *file = fopen (fileName, "r");
    char *code;
    size_t n = 0;
    int c;
    if (file == NULL)
        return NULL;
    code = malloc (1000);
    while ((c = fgetc (file)) != EOF) {
        code[n++] = (char) c;
    }
    code[n] = '\0';
    return code;
}
----------------------------------------

char *readFile (char *fileName) {
    FILE *file;
    int i = 0;
    char *code = malloc (1000 * sizeof (char));
    file = fopen (fileName, "r");
    do {
        code[i++] = (char) fgetc (file);
    }
    while (code[i - 1] != EOF);
    code [i] = '\0' return code;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4823177_4823209_1_22
4823177_4823234_1_13
Title: Reading a file character by character in C 
----------------------------------------

char *readFile (char *fileName) {
    FILE *file = fopen (fileName, "r");
    char *code;
    size_t n = 0;
    int c;
    if (file == NULL)
        return NULL;
    code = malloc (1000);
    while ((c = fgetc (file)) != EOF) {
        code[n++] = (char) c;
    }
    code[n] = '\0';
    return code;
}
----------------------------------------

char *readFile (char *fileName) {
    FILE *file;
    char *code = malloc (1000 * sizeof (char));
    char *p = code;
    file = fopen (fileName, "r");
    do {
        *p++ = (char) fgetc (file);
    }
    while (*p != EOF);
    *p = '\0';
    return code;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4823177_4823234_15_27
4823177_4823234_1_13
Title: Reading a file character by character in C 
----------------------------------------

char *readFile (char *fileName) {
    FILE *file;
    int i = 0;
    char *code = malloc (1000 * sizeof (char));
    file = fopen (fileName, "r");
    do {
        code[i++] = (char) fgetc (file);
    }
    while (code[i - 1] != EOF);
    code [i] = '\0' return code;
}
----------------------------------------

char *readFile (char *fileName) {
    FILE *file;
    char *code = malloc (1000 * sizeof (char));
    char *p = code;
    file = fopen (fileName, "r");
    do {
        *p++ = (char) fgetc (file);
    }
    while (*p != EOF);
    *p = '\0';
    return code;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48232531_48233552_4_40
48232531_48237630_1_40
Title: C program to print all numbers with different digits in interval 
----------------------------------------

int main () {
    printf ("Enter two non-negative numbers in ascending order:\n");
    int min, max;
    scanf ("%d %d", & min, & max);
    while (min < 0 || max < 0 || min > max) {
        printf ("Invalid input! Please enter two non-negative numbers in ascending order:\n");
        scanf ("%d %d", & min, & max);
    }
    printf ("The numbers without repeated digits in the interval [%d, %d] are:\n", min, max);
    for (int n = min; n <= max; ++n) {
        char digits [32];
        sprintf (digits, "%d", n);
        int repeated = 0;
        for (int i = 0; digits[i] && !repeated; ++i) {
            for (int j = i + 1; digits[j]; ++j) {
                if (digits[i] == digits[j]) {
                    repeated = 1;
                    break;
                }
            }
        }
        if (!repeated)
            printf ("%d ", n);
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main () {
    int n, m, k = 0, p = 0, flag, i = 0, j, dig [10];
    do {
        printf ("Enter m and n (m < n):\n");
        scanf ("%d %d", & m, & n);
        if (m < n) {
            break;
        }
        else
            printf ("\Error- m > n! Try again.\n\n");
    }
    while (k == 0);
    printf ("Numbers in the interval [%d, %d] are:\n", m, n);
    for (k = m; k <= n; k++) {
        p = k;
        flag = 0;
        dig[i] = 0;
        i = 0;
        if (p < 10) {
            continue;
        }
        while (p > 0) {
            dig[i] = p % 10;
            p = p / 10;
            i++;
        }
        dig[i] = -1;
        for (i = 0; dig[i] > -1; i++) {
            for (j = i + 1; dig[j] > -1; j++) {
                if (dig[i] == dig[j]) {
                    flag = 1;
                }
            }
        }
        if (flag == 0) {
            printf ("%d\t", k);
        }
    }
    getch ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4824045_4824171_21_36
4824045_4824252_1_34
Title: Obtain data from a file dynamically 
----------------------------------------

int main () {
    ifstream emails;
    srand (time (NULL));
    emails.open ("emails.txt");
    string email;
    vector < string > emailVector;
    while (emails >> email) {
        emailVector.push_back (email);
    }
    int index1 = getrand (emailVector.size (), 0);
    int index2 = getrand (emailVector.size (), index1);
    cout << "email 1: " << emailVector[index1 - 1] << endl;
    cout << "email 2: " << emailVector[index2 - 1] << endl;
}
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp = fopen ("emails.txt", "r");
    if (fp != NULL) {
        char line_buffer [256];
        unsigned int lines_read = 0;
        while (fgets (line_buffer, sizeof (line_buffer), fp) != NULL) {
            if ((rand () % ++lines_read) == 0) {
                printf ("%s \n", line_buffer);
            }
        }
        fclose (fp);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4824045_4824171_21_36
4824045_4831588_33_60
Title: Obtain data from a file dynamically 
----------------------------------------

int main () {
    ifstream emails;
    srand (time (NULL));
    emails.open ("emails.txt");
    string email;
    vector < string > emailVector;
    while (emails >> email) {
        emailVector.push_back (email);
    }
    int index1 = getrand (emailVector.size (), 0);
    int index2 = getrand (emailVector.size (), index1);
    cout << "email 1: " << emailVector[index1 - 1] << endl;
    cout << "email 2: " << emailVector[index2 - 1] << endl;
}
----------------------------------------

int main (int argc, const char *argv []) {
    FILE *fp = NULL;
    char buf [BUF_SIZE];
    char name [] = "email.txt";
    if ((fp = fopen (name, "r")) == NULL) {
        printf ("can't open: %s\n\n", name);
        return -1;
    }
    int line_count = count_lines (fp);
    printf ("line count=%i\n", line_count);
    srand ((unsigned int) time (NULL));
    for (int i = 1; i <= line_count; i++) {
        line_num (fp, buf, i);
        printf ("%i = %s", i, buf);
    }
    for (int i = 0; i < RAND_COUNT; i++) {
        int a = (rand () % line_count);
        line_num (fp, buf, a);
        printf ("line %i = %s\n", a, buf);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4824045_4824252_1_34
4824045_4831588_33_60
Title: Obtain data from a file dynamically 
----------------------------------------

int main (int argc, char **argv) {
    FILE *fp = fopen ("emails.txt", "r");
    if (fp != NULL) {
        char line_buffer [256];
        unsigned int lines_read = 0;
        while (fgets (line_buffer, sizeof (line_buffer), fp) != NULL) {
            if ((rand () % ++lines_read) == 0) {
                printf ("%s \n", line_buffer);
            }
        }
        fclose (fp);
    }
    return 0;
}
----------------------------------------

int main (int argc, const char *argv []) {
    FILE *fp = NULL;
    char buf [BUF_SIZE];
    char name [] = "email.txt";
    if ((fp = fopen (name, "r")) == NULL) {
        printf ("can't open: %s\n\n", name);
        return -1;
    }
    int line_count = count_lines (fp);
    printf ("line count=%i\n", line_count);
    srand ((unsigned int) time (NULL));
    for (int i = 1; i <= line_count; i++) {
        line_num (fp, buf, i);
        printf ("%i = %s", i, buf);
    }
    for (int i = 0; i < RAND_COUNT; i++) {
        int a = (rand () % line_count);
        line_num (fp, buf, a);
        printf ("line %i = %s\n", a, buf);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48249482_48249674_17_36
48249482_48249755_38_56
Title: Program can't run on eclipse 
----------------------------------------

int main () {
    struct list *head;
    head = init (head);
    float value_1 = 47.2;
    float value_2 = 13.23;
    float value_3 = 3.4;
    pre_insert (head, value_1);
    pre_insert (head, value_2);
    pre_insert (head, value_3);
    visit (head);
    return 0;
}
----------------------------------------

int main () {
    struct list **ptrptr = malloc (sizeof (struct list));
    init (ptrptr);
    float value_1 = 47.2;
    float value_2 = 13.23;
    float value_3 = 3.4;
    pre_insert (ptrptr, value_1);
    pre_insert (ptrptr, value_2);
    pre_insert (ptrptr, value_3);
    visit (*ptrptr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48250156_48250164_1_15
48250156_48250499_1_16
Title: C the Heap using in Fuctions still not clear 
----------------------------------------

int *arraybuilder (int len) {
    if (len <= 0) {
        fprintf (stderr, "Negative size\n");
        exit (EXIT_FAILURE);
    }
    int *array = malloc (sizeof *array * len);
    if (array == NULL) {
        perror ("malloc failed");
        exit (EXIT_FAILURE);
    }
    for (int i = 0; i < len; i++)
        array[i] = 0;
    return array;
}
----------------------------------------

int *arraybuilder (size_t n) {
    int *array;
    array = (int *) malloc (n * sizeof (int));
    if (array) {
        for (size_t i = 0; i < n; i++) {
            array[i] = 0;
        }
    }
    return array;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48262558_48262747_4_19
48262558_48263185_6_23
Title: How to separate character and number from string in c program 
----------------------------------------

int main () {
    printf ("Input: ");
    scanf ("%s", location);
    for (x = 0; location[x] != '\0'; x++) {
        if (location[x] >= '0' && location[x] <= '9') {
            house = (house * 10) + (location[x] - 48);
        }
    }
    printf ("int part = %d \n", house);
    return 0;
}
----------------------------------------

int main (void) {
    const char str [] = "0013subdivision";
    char number_part [sizeof (str)];
    char letter_part [sizeof (str)];
    size_t i;
    for (i = 0; str[i] != '\0' && isdigit (str[i]); i++) {
    }
    memcpy (number_part, & str [0], i);
    number_part[i] = '\0';
    memcpy (letter_part, & str [i], sizeof (str) - i);
    puts (number_part);
    puts (letter_part);
    printf ("%ld\n", strtol (str, NULL, 10));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48265716_48267266_1_19
48265716_48267287_9_24
Title: Changing buffer size to copy file in C 
----------------------------------------

void copy (int in, int out, char *buffer, size_t bufsize) {
    for (;;) {
        ssize_t bytes_read = read (in, buffer, bufsize);
        if (bytes_read <= 0) {
            break;
        }
        ssize_t bytes_written = write (out, buffer, bytes_read);
        if (bytes_written != bytes_read) {
        }
    }
}
----------------------------------------

size_t copy (int in, int out, char *buffer, size_t taille) {
    ssize_t t;
    ssize_t bytes = 0;
    while ((t = read (in, buffer, taille)) > 0) {
        if (write (out, buffer, t) != t)
            return 0;
        bytes += t;
    }
    if (t < 0)
        perror ("read");
    return bytes;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48277726_48278007_1_24
48277726_48278734_1_30
Title: Deleting a linked list node in a C function doesn't transfer to the calling function 
----------------------------------------

bool findDeleteElement (struct list **ptr, int position, int *value) {
    struct list **temp = ptr;
    if (*ptr != NULL) {
        while ((*ptr)->pos != position) {
            ptr = &(*ptr)->next_ptr;
        }
        temp = ptr;
        *value = (*ptr)->value;
        temp = &(*temp)->next_ptr;
        ptr = temp;
        return 1;
    }
    else {
        return 0;
    }
}
----------------------------------------

bool findDeleteElement (struct list **head, int position, int *value) {
    struct list *temp = *head;
    struct list *prev = NULL;
    while (temp != NULL && temp->pos != position) {
        prev = temp;
        temp = temp->next;
    }
    if (temp == NULL) {
        return false;
    }
    else {
        *value = temp->value;
        if (prev != NULL) {
            prev->next = temp->next;
        }
        else {
            *head = temp->next;
        }
        free (temp);
        return true;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4828812_4828948_23_39
4828812_4829448_19_37
Title: "C How to acess a structure from another structure?" 
----------------------------------------

int main () {
    Node *root;
    int clsf_cnt;
    Class_stud clsf;
    Class_stud *clsf_ptr;
    clsf_ptr = &clsf;
    clsf_cnt = 0;
    root = malloc (sizeof (Node));
    if (root == NULL) {
    }
}
----------------------------------------

int main (void) {
    int clsf_cnt = 0;
    node *root;
    root = malloc (sizeof (node));
    if (root == NULL) {
    }
    printf ("enter source address \n");
    scanf ("%s", & root -> cls [clsf_cnt] -> name);
    printf ("%s", root -> cls [clsf_cnt] -> name);
    printf ("enter key\n");
    scanf ("%d", & root -> cls [clsf_cnt] -> key);
    printf ("%d", root -> cls [clsf_cnt] -> key);
    clsf_cnt++;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48295464_48296767_3_17
48295464_48297793_108_127
Title: Is there a fast way to interpose a character between strings? 
----------------------------------------

int main () {
    char var1 [] = "FileA.txt";
    char var2 [] = "FileB.png";
    char var3 [] = "FileC";
    char result [30];
    sprintf (result, "%s/%s/%s", var1, var2, var3);
    printf ("result: %s\n", result);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    char *path;
    if (argc < 2) {
        fprintf (stderr, "\nUsage: %s PREFIX [ PATHNAME ... ]\n\n", argv [0]);
        return EXIT_FAILURE;
    }
    path = dynamic_path (argv[1], argc -2, (const char **) (argv + 2));
    if (!path) {
        fprintf (stderr, "dynamic_path(): %s.\n", strerror (errno));
        return EXIT_FAILURE;
    }
    printf ("%s\n", path);
    free (path);
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
48329572_48330038_1_42
48329572_48331688_8_82
Title: Split a string on the occurance of a particular character 
----------------------------------------

int main (int argc, char *argv []) {
    const char *source = "(000,P,ray            )," "(100,D,ray            )," "(009,L,art            )," "(0000,C,max            )," "(0000,S,ben            )," "(020,P,kay            )," "(040,L,photography    )," "(001,C,max            )," "(0001,S,ben            )," "(0001,P,kay            )";
    char each [10] [30] = {{0}};
    const char *str = source;
    int i;
    for (i = 0; i < 10; i++) {
        const char *begin = strchr (str, '(');
        if (!begin)
            break;
        const char *end = strchr (begin, ')');
        if (!end)
            break;
        end++;
        ptrdiff_t length = end - begin;
        if (length >= 30)
            break;
        memcpy (each [i], begin, length);
        str = end;
    }
    for (int l = 0; l < i; l++) {
        printf ("%s", each [l]);
        if (l != i - 1)
            printf (",\n");
    }
    putchar ('\n');
}
----------------------------------------

int main (int argc, char **argv) {
    int in = 0;
    char **each = NULL, *buf = NULL;
    size_t rows = ROWS, ndx = 0, n = 0, i = 0;
    ssize_t nchr = 0;
    FILE *fp = argc > 1 ? fopen (argv[1], "r") : stdin;
    if (!fp) {
        fprintf (stderr, "error: file open failed '%s'.\n", argv [1]);
        return 1;
    }
    each = malloc (rows * sizeof *each);
    if (!each) {
        perror ("each - memory exhausted");
        return 1;
    }
    while ((nchr = getline (&buf, &n, fp) != -1)) {
        char *p = buf, rec [MAXR] = "";
        while (*p) {
            if (*p == '(') {
                rec[i++] = *p;
                in = 1;
            }
            else if (*p == ')') {
                rec[i++] = *p;
                rec[i++] = 0;
                each[ndx] = malloc (i);
                if (!each[ndx]) {
                    perror ("each[ndx] - memory exhausted");
                    return 1;
                }
                strcpy (each [ndx], rec);
                i = in = 0;
                ndx++;
                if (ndx == rows) {
                    void *tmp = realloc (each, rows * sizeof *each * 2);
                    if (!tmp) {
                        perror ("realloc each - memory exhausted");
                        goto memfull;
                    }
                    each = tmp;
                    rows *= 2;
                }
            }
            else if (in) {
                rec[i++] = *p;
            }
            if (i + 1 == MAXR) {
                fprintf (stderr, "record exceeds %d chars.\n", MAXR);
                return 1;
            }
            p++;
        }
    }
memfull :
    ;
    free (buf);
    if (fp != stdin)
        fclose (fp);
    for (i = 0; i < ndx; i++) {
        printf ("each[%2zu] : %s\n", i, each [i]);
        free (each [i]);
    }
    free (each);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
4833347_4833425_129_139
4833347_4833446_5_17
Title: Removing substring from a string? 
----------------------------------------

int main (void) {
    const char before [] = "the rain in Spain falls mainly on the plain";
    printf ("before = \"%s\"\n", before);
    test (before, "the", "THEE");
    test (before, "the", "A");
    test (before, "cat", "DOG");
    test (before, "plain", "PLANE");
    test (before, "ain", "AINLY");
    return 0;
}
----------------------------------------

int main () {
    const char *source = "FN;CHARSET=UTF-8:David Celery";
    const char *newBegin = strrchr (source, ':');
    if (!newBegin) {
        puts ("Error!");
        return -1;
    }
    newBegin++;
    puts (newBegin);
    return 0;
}
----------------------------------------
