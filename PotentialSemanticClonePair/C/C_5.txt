$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1550144_1550162_3_21
1550144_1550525_11_22
Title: Enumerating Permutations of a set of subsets 
----------------------------------------

int main (void) {
    int set1 [] = {1, 2, 3};
    int set2 [] = {4, 5, 6};
    int set3 [] = {7, 8, 9};
    for (unsigned i = 0; i < 3; ++i) {
        for (unsigned j = 0; j < 3; ++j) {
            for (unsigned k = 0; k < 3; ++k) {
                printf ("(%d, %d, %d)", set1 [i], set2 [j], set3 [k]);
            }
        }
    }
    return 0;
}
----------------------------------------

int main () {
    int num_cols = sizeof (set[0]) / sizeof (set[0][0]);
    int num_rows = sizeof (set) / sizeof (set[0]);
    int *ndx = malloc (num_rows * sizeof (*ndx));
    int i = 0;
    ndx[i] = -1;
    do {
        ndx[i]++;
        while (++i < num_rows)
            ndx[i] = 0;
        print_set (ndx, num_rows);
        while (--i >= 0 && ndx[i] >= num_cols - 1)
            ;
    }
    while (i >= 0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15501861_19254153_13_105
15501861_27110749_9_125
Title: Bankers algorithm for deadlock avoidance in c 
----------------------------------------

void main () {
    int allocation [10] [5], max [10] [5], need [10] [5], available [3], flag [10], sq [10];
    int n, r, i, j, k, count, count1 = 0;
    clrscr ();
    printf ("\n Input the number of processes running ( <10 )..");
    scanf ("%d", & n);
    for (i = 0; i < 10; i++)
        flag[i] = 0;
    printf ("\n Input the number of resources ( <5 )..");
    scanf ("%d", & r);
    printf ("\n Input the allocation matrix for the processes in row major order..\n");
    for (i = 0; i < n; i++) {
        printf ("\n Process %d\n", i);
        for (j = 0; j < r; j++) {
            printf ("\n Resource %d\n", j);
            scanf ("%d", & allocation [i] [j]);
        }
    }
    printf ("\n Input the no. of resources that a process can maximum have..\n");
    for (i = 0; i < n; i++) {
        printf ("\n Process %d\n", i);
        for (j = 0; j < r; j++) {
            printf ("\n Resource %d\n", j);
            scanf ("%d", & max [i] [j]);
        }
    }
    printf ("\n Input the no. of available instances of each resource..\n");
    for (i = 0; i < r; i++) {
        printf ("\n Resource %d : ", i);
        scanf ("%d", & available [i]);
    }
    printf ("\n The need matrix is as follows : \n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < r; j++) {
            need[i][j] = max[i][j] - allocation[i][j];
            printf ("\t %d", need [i] [j]);
        }
        printf ("\n");
    }
    do {
        for (k = 0; k < n; k++) {
            for (i = 0; i < n; i++) {
                if (flag[i] == 0) {
                    count = 0;
                    for (j = 0; j < r; j++) {
                        if (available[j] >= need[i][j])
                            count++;
                    }
                    if (count == r) {
                        count1++;
                        flag[i] = 1;
                        sq[count1 - 1] = i;
                        for (j = 0; j < r; j++) {
                            available[j] = available[j] + allocation[i][j];
                        }
                        break;
                    }
                }
            }
        }
        if (count1 != n) {
            printf ("\n---------------IT'S AN UNSAFE STATE---------------");
            break;
        }
    }
    while (count1 != n);
    if (count1 == n) {
        printf ("\n *******************IT'S A SAFE STATE*******************");
        printf ("\n The safe sequence is....\n");
        for (i = 0; i < n; i++)
            printf ("\t P%d", sq[i]);
        printf ("\n");
        printf ("\n The available matrix is now : ");
        for (i = 0; i < r; i++)
            printf ("\t %d", available[i]);
    }
    getch ();
}
----------------------------------------

int main () {
    printf ("\nEnter the number of processes: ");
    scanf ("%d", & p);
    for (i = 0; i < p; i++) {
        running[i] = 1;
        count++;
    }
    printf ("\nEnter the number of resources: ");
    scanf ("%d", & r);
    for (i = 0; i < r; i++) {
        printf ("\nEnter the resource for instance %d: ", k ++);
        scanf ("%d", & maxres [i]);
    }
    printf ("\nEnter maximum resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            scanf ("%d", & maxclaim [i] [j]);
        }
    }
    printf ("\nEnter allocated resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            scanf ("%d", & curr [i] [j]);
        }
    }
    printf ("\nThe resource of instances: ");
    for (i = 0; i < r; i++) {
        printf ("\t%d", maxres [i]);
    }
    printf ("\nThe allocated resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            printf ("\t%d", curr [i] [j]);
        }
        printf ("\n");
    }
    printf ("\nThe maximum resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            printf ("\t%d", maxclaim [i] [j]);
        }
        printf ("\n");
    }
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            alloc[j] += curr[i][j];
        }
    }
    printf ("\nAllocated resources:");
    for (i = 0; i < r; i++) {
        printf ("\t%d", alloc [i]);
    }
    for (i = 0; i < r; i++) {
        avl[i] = maxres[i] - alloc[i];
    }
    printf ("\nAvailable resources:");
    for (i = 0; i < r; i++) {
        printf ("\t%d", avl [i]);
    }
    printf ("\n");
    while (count != 0) {
        safe = 0;
        for (i = 0; i < p; i++) {
            if (running[i]) {
                exec = 1;
                for (j = 0; j < r; j++) {
                    if (maxclaim[i][j] - curr[i][j] > avl[j]) {
                        exec = 0;
                        break;
                    }
                }
                if (exec) {
                    printf ("\nProcess%d is executing\n", i + 1);
                    running[i] = 0;
                    count--;
                    safe = 1;
                    for (j = 0; j < r; j++) {
                        avl[j] += curr[i][j];
                    }
                    break;
                }
            }
        }
        if (!safe) {
            printf ("\nThe processes are in unsafe state.\n");
            break;
        }
        else {
            printf ("\nThe process is in safe state");
            printf ("\nSafe sequence is:");
            for (i = 0; i < r; i++) {
                printf ("\t%d", avl [i]);
            }
            printf ("\n");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15501861_19254153_13_105
15501861_29253410_4_87
Title: Bankers algorithm for deadlock avoidance in c 
----------------------------------------

void main () {
    int allocation [10] [5], max [10] [5], need [10] [5], available [3], flag [10], sq [10];
    int n, r, i, j, k, count, count1 = 0;
    clrscr ();
    printf ("\n Input the number of processes running ( <10 )..");
    scanf ("%d", & n);
    for (i = 0; i < 10; i++)
        flag[i] = 0;
    printf ("\n Input the number of resources ( <5 )..");
    scanf ("%d", & r);
    printf ("\n Input the allocation matrix for the processes in row major order..\n");
    for (i = 0; i < n; i++) {
        printf ("\n Process %d\n", i);
        for (j = 0; j < r; j++) {
            printf ("\n Resource %d\n", j);
            scanf ("%d", & allocation [i] [j]);
        }
    }
    printf ("\n Input the no. of resources that a process can maximum have..\n");
    for (i = 0; i < n; i++) {
        printf ("\n Process %d\n", i);
        for (j = 0; j < r; j++) {
            printf ("\n Resource %d\n", j);
            scanf ("%d", & max [i] [j]);
        }
    }
    printf ("\n Input the no. of available instances of each resource..\n");
    for (i = 0; i < r; i++) {
        printf ("\n Resource %d : ", i);
        scanf ("%d", & available [i]);
    }
    printf ("\n The need matrix is as follows : \n");
    for (i = 0; i < n; i++) {
        for (j = 0; j < r; j++) {
            need[i][j] = max[i][j] - allocation[i][j];
            printf ("\t %d", need [i] [j]);
        }
        printf ("\n");
    }
    do {
        for (k = 0; k < n; k++) {
            for (i = 0; i < n; i++) {
                if (flag[i] == 0) {
                    count = 0;
                    for (j = 0; j < r; j++) {
                        if (available[j] >= need[i][j])
                            count++;
                    }
                    if (count == r) {
                        count1++;
                        flag[i] = 1;
                        sq[count1 - 1] = i;
                        for (j = 0; j < r; j++) {
                            available[j] = available[j] + allocation[i][j];
                        }
                        break;
                    }
                }
            }
        }
        if (count1 != n) {
            printf ("\n---------------IT'S AN UNSAFE STATE---------------");
            break;
        }
    }
    while (count1 != n);
    if (count1 == n) {
        printf ("\n *******************IT'S A SAFE STATE*******************");
        printf ("\n The safe sequence is....\n");
        for (i = 0; i < n; i++)
            printf ("\t P%d", sq[i]);
        printf ("\n");
        printf ("\n The available matrix is now : ");
        for (i = 0; i < r; i++)
            printf ("\t %d", available[i]);
    }
    getch ();
}
----------------------------------------

void main () {
    int process, resource, i, j, instanc, k = 0, count1 = 0, count2 = 0;
    printf ("\n\t Enter No. of Process:-\n");
    printf ("\t\t");
    scanf ("%d", & process);
    printf ("\n\tEnter No. of Resources:-\n");
    printf ("\t\t");
    scanf ("%d", & resource);
    int avail [resource], max [process] [resource], allot [process] [resource], need [process] [resource], completed [process];
    for (i = 0; i < process; i++)
        completed[i] = 0;
    printf ("\n\tEnter No. of Available Instances\n");
    for (i = 0; i < resource; i++) {
        printf ("\t\t");
        scanf ("%d", & instanc);
        avail[i] = instanc;
    }
    printf ("\n\tEnter Maximum No. of instances of resources that a Process need:\n");
    for (i = 0; i < process; i++) {
        printf ("\n\t For P[%d]", i);
        for (j = 0; j < resource; j++) {
            printf ("\t");
            scanf ("%d", & instanc);
            max[i][j] = instanc;
        }
    }
    printf ("\n\t Enter no. of instances already allocated to process of a resource:\n");
    for (i = 0; i < process; i++) {
        printf ("\n\t For P[%d]\t", i);
        for (j = 0; j < resource; j++) {
            printf ("\t\t");
            scanf ("%d", & instanc);
            allot[i][j] = instanc;
            need[i][j] = max[i][j] - allot[i][j];
        }
    }
    printf ("\n\t Safe Sequence is:- \t");
    while (count1 != process) {
        count2 = count1;
        for (i = 0; i < process; i++) {
            for (j = 0; j < resource; j++) {
                if (need[i][j] <= avail[j]) {
                    k++;
                }
            }
            if (k == resource && completed[i] == 0) {
                printf ("P[%d]\t", i);
                completed[i] = 1;
                for (j = 0; j < resource; j++) {
                    avail[j] = avail[j] + allot[i][j];
                }
                count1++;
            }
            k = 0;
        }
        if (count1 == count2) {
            printf ("\t\t Stop ..After this.....Deadlock \n");
            break;
        }
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15501861_27110749_9_125
15501861_29253410_4_87
Title: Bankers algorithm for deadlock avoidance in c 
----------------------------------------

int main () {
    printf ("\nEnter the number of processes: ");
    scanf ("%d", & p);
    for (i = 0; i < p; i++) {
        running[i] = 1;
        count++;
    }
    printf ("\nEnter the number of resources: ");
    scanf ("%d", & r);
    for (i = 0; i < r; i++) {
        printf ("\nEnter the resource for instance %d: ", k ++);
        scanf ("%d", & maxres [i]);
    }
    printf ("\nEnter maximum resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            scanf ("%d", & maxclaim [i] [j]);
        }
    }
    printf ("\nEnter allocated resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            scanf ("%d", & curr [i] [j]);
        }
    }
    printf ("\nThe resource of instances: ");
    for (i = 0; i < r; i++) {
        printf ("\t%d", maxres [i]);
    }
    printf ("\nThe allocated resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            printf ("\t%d", curr [i] [j]);
        }
        printf ("\n");
    }
    printf ("\nThe maximum resource table:\n");
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            printf ("\t%d", maxclaim [i] [j]);
        }
        printf ("\n");
    }
    for (i = 0; i < p; i++) {
        for (j = 0; j < r; j++) {
            alloc[j] += curr[i][j];
        }
    }
    printf ("\nAllocated resources:");
    for (i = 0; i < r; i++) {
        printf ("\t%d", alloc [i]);
    }
    for (i = 0; i < r; i++) {
        avl[i] = maxres[i] - alloc[i];
    }
    printf ("\nAvailable resources:");
    for (i = 0; i < r; i++) {
        printf ("\t%d", avl [i]);
    }
    printf ("\n");
    while (count != 0) {
        safe = 0;
        for (i = 0; i < p; i++) {
            if (running[i]) {
                exec = 1;
                for (j = 0; j < r; j++) {
                    if (maxclaim[i][j] - curr[i][j] > avl[j]) {
                        exec = 0;
                        break;
                    }
                }
                if (exec) {
                    printf ("\nProcess%d is executing\n", i + 1);
                    running[i] = 0;
                    count--;
                    safe = 1;
                    for (j = 0; j < r; j++) {
                        avl[j] += curr[i][j];
                    }
                    break;
                }
            }
        }
        if (!safe) {
            printf ("\nThe processes are in unsafe state.\n");
            break;
        }
        else {
            printf ("\nThe process is in safe state");
            printf ("\nSafe sequence is:");
            for (i = 0; i < r; i++) {
                printf ("\t%d", avl [i]);
            }
            printf ("\n");
        }
    }
}
----------------------------------------

void main () {
    int process, resource, i, j, instanc, k = 0, count1 = 0, count2 = 0;
    printf ("\n\t Enter No. of Process:-\n");
    printf ("\t\t");
    scanf ("%d", & process);
    printf ("\n\tEnter No. of Resources:-\n");
    printf ("\t\t");
    scanf ("%d", & resource);
    int avail [resource], max [process] [resource], allot [process] [resource], need [process] [resource], completed [process];
    for (i = 0; i < process; i++)
        completed[i] = 0;
    printf ("\n\tEnter No. of Available Instances\n");
    for (i = 0; i < resource; i++) {
        printf ("\t\t");
        scanf ("%d", & instanc);
        avail[i] = instanc;
    }
    printf ("\n\tEnter Maximum No. of instances of resources that a Process need:\n");
    for (i = 0; i < process; i++) {
        printf ("\n\t For P[%d]", i);
        for (j = 0; j < resource; j++) {
            printf ("\t");
            scanf ("%d", & instanc);
            max[i][j] = instanc;
        }
    }
    printf ("\n\t Enter no. of instances already allocated to process of a resource:\n");
    for (i = 0; i < process; i++) {
        printf ("\n\t For P[%d]\t", i);
        for (j = 0; j < resource; j++) {
            printf ("\t\t");
            scanf ("%d", & instanc);
            allot[i][j] = instanc;
            need[i][j] = max[i][j] - allot[i][j];
        }
    }
    printf ("\n\t Safe Sequence is:- \t");
    while (count1 != process) {
        count2 = count1;
        for (i = 0; i < process; i++) {
            for (j = 0; j < resource; j++) {
                if (need[i][j] <= avail[j]) {
                    k++;
                }
            }
            if (k == resource && completed[i] == 0) {
                printf ("P[%d]\t", i);
                completed[i] = 1;
                for (j = 0; j < resource; j++) {
                    avail[j] = avail[j] + allot[i][j];
                }
                count1++;
            }
            k = 0;
        }
        if (count1 == count2) {
            printf ("\t\t Stop ..After this.....Deadlock \n");
            break;
        }
    }
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15516843_15516947_1_21
15516843_15517756_48_68
Title: Can't create correct linked list in C 
----------------------------------------

void AddEnd (List *item, List *head) {
    List *node;
    node = (List *) malloc (sizeof (List));
    printf ("Enter x and y: ");
    scanf ("%d %d", & node -> x, & node -> y);
    if (head == NULL) {
        head = node;
        head->next = NULL;
    }
    else {
        node->next = head->next;
        head->next = node;
    }
}
----------------------------------------

void AddEnd (List *item, List **head) {
    List *node, *first, *second;
    node = (List *) malloc (sizeof (List));
    printf ("Enter x and y: ");
    scanf ("%d %d", & node -> x, & node -> y);
    if (*head == NULL) {
        node->next = NULL;
        *head = node;
    }
    else {
        for (first = *head; first != NULL; first = first->next)
            second = first;
        node->next = NULL;
        second->next = node;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15517243_15517436_5_14
15517243_15519068_3_13
Title: How to run shell commands in C file and assign a integer in a variable? 
----------------------------------------

int main () {
    char *username;
    username = getenv ("USER");
    if (strcmp (username, "jhamb") == 0) {
        printf ("Yes\n");
    }
    else {
        printf ("No\n");
    }
}
----------------------------------------

int main () {
    int i;
    char *command;
    command = "ls";
    if (system (NULL))
        printf ("ok\n");
    else
        exit (EXIT_FAILURE);
    i = system (command);
    printf (the value returned was : % d \ n ", i);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15539206_15539727_9_28
15539206_15541772_11_24
Title: "Value in C is returning null not sure why" 
----------------------------------------

void insert (char abbreviation, double number, struct Node *head) {
    struct Node *current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    struct Node *ptr = (struct Node *) malloc (sizeof (struct Node));
    ptr->abbreviation = abbreviation;
    ptr->number = number;
    if (head->next == NULL) {
        head = current = ptr;
    }
    else {
        current->next = ptr;
    }
    return;
}
----------------------------------------

void insert (char abbreviation, double number, struct Node *head) {
    struct Node *current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    struct Node *ptr = (struct Node *) malloc (sizeof (struct Node));
    ptr->abbreviation = abbreviation;
    ptr->number = number;
    current->next = ptr;
    return;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15551836_15551989_3_14
15551836_15553098_10_21
Title: How to get the first x (leftmost) digits of a decimal number 
----------------------------------------

int main (void) {
    int num = 12345;
    int n = 3;
    int log10 = 0;
    while (pow10[log10] < num) {
        log10++;
    }
    int divisor = pow10[log10 - n];
    int res = num / divisor;
    printf ("log10(num)+1=%d, divisor=%d, result=%d\n", log10, divisor, res);
    return 0;
}
----------------------------------------

int main (void) {
    int x = 2;
    int n = 1234;
    int max = power10 (x);
    int res = n;
    while (res >= max)
        res = res / 10;
    printf ("%d\n", res);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15599160_15602396_1_15
15599160_15606659_1_47
Title: "Split linked list into two other lists one with odd indices the other one with even indices" 
----------------------------------------

void split (ListNode *head, ListNode **ptrOddList, ListNode **ptrEvenList) {
    for (; head; head = head->next) {
        ListNode *temp;
        temp = malloc (sizeof *temp);
        memcpy (temp, head, sizeof * temp);
        if (temp->item % 2) {
            *ptrOddList = temp;
            ptrOddList = &temp->next;
        }
        else {
            *ptrEvenList = temp;
            ptrEvenList = &temp->next;
        }
    }
    *ptrOddList = NULL;
    *ptrEvenList = NULL;
}
----------------------------------------

void split (ListNode *head, ListNode **ptrOddList, ListNode **ptrEvenList) {
    int remainder;
    int countO = 0;
    int countE = 0;
    ListNode *tempO, *tempE;
    if (head == NULL)
        return;
    else {
        (*ptrOddList) = (struct node *) malloc (sizeof (ListNode));
        (*ptrEvenList) = (struct node *) malloc (sizeof (ListNode));
        while (head != NULL) {
            remainder = head->item % 2;
            if (remainder == 0) {
                if (countE > 0) {
                    tempE->next = head;
                    tempE = tempE->next;
                }
                else
                    tempE = *ptrOddList;
                tempE->item = head->item;
                countE++;
            }
            else {
                if (countO > 0) {
                    tempO->next = head;
                    tempO = tempO->next;
                }
                else
                    tempO = *ptrOddList;
                tempO->item = head->item;
                countO++;
            }
            head = head->next;
        }
        tempE->next = NULL;
        tempO->next = NULL;
        printf ("Even List:");
        printNode ((*ptrEvenList));
        printf ("Odd List:");
        printNode ((*ptrOddList));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15599160_15602396_1_15
15599160_43918198_1_55
Title: "Split linked list into two other lists one with odd indices the other one with even indices" 
----------------------------------------

void split (ListNode *head, ListNode **ptrOddList, ListNode **ptrEvenList) {
    for (; head; head = head->next) {
        ListNode *temp;
        temp = malloc (sizeof *temp);
        memcpy (temp, head, sizeof * temp);
        if (temp->item % 2) {
            *ptrOddList = temp;
            ptrOddList = &temp->next;
        }
        else {
            *ptrEvenList = temp;
            ptrEvenList = &temp->next;
        }
    }
    *ptrOddList = NULL;
    *ptrEvenList = NULL;
}
----------------------------------------

void split (ListNode *head, ListNode **pOddList, ListNode **pEvenList) {
    int remainder;
    ListNode *tmpO = NULL, *tmpE = NULL, *tmp;
    if (head == NULL) {
        *pEvenList = NULL;
        *pOddList = NULL;
    }
    else {
        tmp = head;
        while (tmp != NULL) {
            remainder = tmp->item % 2;
            if (remainder == 0) {
                if (tmpE == NULL) {
                    tmpE = tmp;
                    tmp = tmp->next;
                    *pEvenList = tmpE;
                    tmpE->next = NULL;
                }
                else {
                    tmpE->next = tmp;
                    tmp = tmp->next;
                    tmpE = tmpE->next;
                    tmpE->next = NULL;
                }
            }
            else {
                if (tmpO == NULL) {
                    tmpO = tmp;
                    tmp = tmp->next;
                    *pOddList = tmpO;
                    tmpO->next = NULL;
                }
                else {
                    tmpO->next = tmp;
                    tmp = tmp->next;
                    tmpO = tmpO->next;
                    tmpO->next = NULL;
                }
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15599160_15606659_1_47
15599160_43918198_1_55
Title: "Split linked list into two other lists one with odd indices the other one with even indices" 
----------------------------------------

void split (ListNode *head, ListNode **ptrOddList, ListNode **ptrEvenList) {
    int remainder;
    int countO = 0;
    int countE = 0;
    ListNode *tempO, *tempE;
    if (head == NULL)
        return;
    else {
        (*ptrOddList) = (struct node *) malloc (sizeof (ListNode));
        (*ptrEvenList) = (struct node *) malloc (sizeof (ListNode));
        while (head != NULL) {
            remainder = head->item % 2;
            if (remainder == 0) {
                if (countE > 0) {
                    tempE->next = head;
                    tempE = tempE->next;
                }
                else
                    tempE = *ptrOddList;
                tempE->item = head->item;
                countE++;
            }
            else {
                if (countO > 0) {
                    tempO->next = head;
                    tempO = tempO->next;
                }
                else
                    tempO = *ptrOddList;
                tempO->item = head->item;
                countO++;
            }
            head = head->next;
        }
        tempE->next = NULL;
        tempO->next = NULL;
        printf ("Even List:");
        printNode ((*ptrEvenList));
        printf ("Odd List:");
        printNode ((*ptrOddList));
    }
}
----------------------------------------

void split (ListNode *head, ListNode **pOddList, ListNode **pEvenList) {
    int remainder;
    ListNode *tmpO = NULL, *tmpE = NULL, *tmp;
    if (head == NULL) {
        *pEvenList = NULL;
        *pOddList = NULL;
    }
    else {
        tmp = head;
        while (tmp != NULL) {
            remainder = tmp->item % 2;
            if (remainder == 0) {
                if (tmpE == NULL) {
                    tmpE = tmp;
                    tmp = tmp->next;
                    *pEvenList = tmpE;
                    tmpE->next = NULL;
                }
                else {
                    tmpE->next = tmp;
                    tmp = tmp->next;
                    tmpE = tmpE->next;
                    tmpE->next = NULL;
                }
            }
            else {
                if (tmpO == NULL) {
                    tmpO = tmp;
                    tmp = tmp->next;
                    *pOddList = tmpO;
                    tmpO->next = NULL;
                }
                else {
                    tmpO->next = tmp;
                    tmp = tmp->next;
                    tmpO = tmpO->next;
                    tmpO->next = NULL;
                }
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1563168_1563237_4_14
1563168_1563401_60_96
Title: Example of realpath function (C Programming) 
----------------------------------------

int main (void) {
    char buf [PATH_MAX + 1];
    char *res = realpath ("this_source.c", buf);
    if (res) {
        printf ("This source is at %s.\n", buf);
    }
    else {
        perror ("realpath");
        exit (EXIT_FAILURE);
    }
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int i;
    int rc = EXIT_SUCCESS;
    int opt;
    err_setarg0 (argv [0]);
    while ((opt = getopt (argc, argv, optstr)) != -1) {
        switch (opt) {
        case 'V' :
            err_version ("REALPATH", &"@(#)$Revision: 1.3 $ ($Date: 2007/10/23 20:23:44 $)"[4]);
            break;
        case 'h' :
            err_help (usestr, hlpstr);
            break;
        case 'l' :
            format_type = FMT_LONG;
            break;
        case 's' :
            format_type = FMT_SHORT;
            break;
        default :
            err_usage (usestr);
            break;
        }
    }
    for (i = optind; i < argc; i++) {
        if (eval_realpath (argv[i]) != 0)
            rc = EXIT_FAILURE;
    }
    return (rc);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15633172_15633498_1_17
15633172_15633759_8_24
Title: Initialisation from incompatible pointer type and arrays of structs 
----------------------------------------

int main (void) {
    Pokemon p [3];
    for (int i = 0; i < 3; i++) {
        printf ("Pokemon %i \n", i);
        printf ("Nickname: ");
        scanf ("%s", & (p [i].nickname));
        printf ("Type: ");
        scanf ("%s", & (p [i].type));
        printf ("Level: ");
        scanf ("%i", & (p [i].level));
        printf ("%s, %s, %i", p [i].nickname, p [i].type, p [i].level);
    }
    return 0;
}
----------------------------------------

int main (void) {
    Pokemon p [3];
    for (int i = 0; i < 3; i++) {
        printf ("Pokemon %i \n", i);
        printf ("Nickname: ");
        scanf ("%10s", p [i].nickname);
        printf ("\nType: ");
        scanf ("%10s", p [i].type);
        printf ("\nLevel: ");
        scanf ("%i", & p [i].level);
        printf ("\n%s, %s, %i\n", p [i].nickname, p [i].type, p [i].level);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15638105_15638426_3_11
15638105_15638857_6_30
Title: Accessing Specific Memory Locations in C 
----------------------------------------

int main (int argc, char **argv) {
    int var = 7456;
    printf ("Adress of var = %x, var=%d\n", & var, var);
    int *ptr = (int *) 0x22cd28;
    printf (" ptr points to %x\n", ptr);
    *ptr = 123;
    printf ("New value of var=%d\n", var);
    return 0;
}
----------------------------------------

int main (void) {
    int x = 0;
    char buf [100];
    sprintf (buf, "%" PRIuPTR, (uintptr_t) & x);
    printf ("The address of x is %s.\n", buf);
    uintptr_t u;
    sscanf (buf, "%" SCNuPTR, & u);
    int *p = (int *) u;
    *p = 123;
    printf ("x = %d\n", x);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15638105_15638426_3_11
15638105_41142366_6_34
Title: Accessing Specific Memory Locations in C 
----------------------------------------

int main (int argc, char **argv) {
    int var = 7456;
    printf ("Adress of var = %x, var=%d\n", & var, var);
    int *ptr = (int *) 0x22cd28;
    printf (" ptr points to %x\n", ptr);
    *ptr = 123;
    printf ("New value of var=%d\n", var);
    return 0;
}
----------------------------------------

int main (void) {
    char *map_base_addr;
    int fd;
    int size = 10;
    fd = open ("test_file", O_RDWR);
    map_base_addr = mmap (NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    char *ch = map_base_addr;
    int i;
    for (i = 0; i < size; i++)
        fputc (*(ch + i), stdout);
    printf ("\n");
    *(ch + 1) = 'b';
    *(ch + 4) = 'z';
    *(ch + 7) = 'x';
    for (i = 0; i < size; i++)
        fputc (*(ch + i), stdout);
    printf ("\n");
    munmap (map_base_addr, size);
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15638105_15638857_6_30
15638105_41142366_6_34
Title: Accessing Specific Memory Locations in C 
----------------------------------------

int main (void) {
    int x = 0;
    char buf [100];
    sprintf (buf, "%" PRIuPTR, (uintptr_t) & x);
    printf ("The address of x is %s.\n", buf);
    uintptr_t u;
    sscanf (buf, "%" SCNuPTR, & u);
    int *p = (int *) u;
    *p = 123;
    printf ("x = %d\n", x);
    return 0;
}
----------------------------------------

int main (void) {
    char *map_base_addr;
    int fd;
    int size = 10;
    fd = open ("test_file", O_RDWR);
    map_base_addr = mmap (NULL, size, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
    char *ch = map_base_addr;
    int i;
    for (i = 0; i < size; i++)
        fputc (*(ch + i), stdout);
    printf ("\n");
    *(ch + 1) = 'b';
    *(ch + 4) = 'z';
    *(ch + 7) = 'x';
    for (i = 0; i < size; i++)
        fputc (*(ch + i), stdout);
    printf ("\n");
    munmap (map_base_addr, size);
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1564953_1565492_19_39
1564953_1569034_164_179
Title: C: Looping without using looping statements or recursion 
----------------------------------------

int main (int argc, char **argv) {
    struct itimerval v;
    v.it_value.tv_sec = 0;
    v.it_value.tv_usec = 5000;
    v.it_interval.tv_sec = 0;
    v.it_interval.tv_usec = 5000;
    int pipefds [2];
    char b;
    stop = 10;
    counter = 1;
    pipe (pipefds);
    signal (SIGALRM, alarm_handler);
    setitimer (ITIMER_REAL, & v, NULL);
    read (pipefds [0], & b, 1);
}
----------------------------------------

int main (int argc, char *argv []) {
    int i;
    if (argc > 1) {
        N = strtol (argv[1], NULL, 0);
    }
    if (N >= 1) {
        printf ("listing 1 to %d\n", N);
        print2147483648 (0);
    }
    else {
        printf ("Must enter a postive integer N\n");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15678968_15679005_1_25
15678968_15679060_1_23
Title: c - Pointer of array initialized in a function contains wrong values after returning 
----------------------------------------

int *patternForFirstDigit (int digit) {
    int *pattern = malloc (6 * sizeof (int));
    memcpy (pattern, (int [6]) {1, 1, 1, 1, 1, 1}, 6 * sizeof (int));
    switch (digit) {
    case 0 :
        memcpy (pattern, (int [6]) {1, 1, 1, 1, 1, 1}, 6 * sizeof (int));
        break;
    case 1 :
        memcpy (pattern, (int [6]) {1, 1, 2, 1, 2, 2};, 6 * sizeof (int));
        break;
    default :
        memcpy (pattern, (int [6]) {0, 0, 0, 0, 0, 0}, 6 * sizeof (int));
        break;
    }
    for (int i = 0; i < 6; i++) {
        printf ("%i\n", pattern [i]);
    }
    return pattern;
}
----------------------------------------

int *patternForFirstDigit (int digit, int *pattern) {
    int *pattern1 = (int [6]) {1, 1, 1, 1, 1, 1};
    int i;
    switch (digit) {
    case 0 :
        pattern1 = (int [6]) {1, 1, 1, 1, 1, 1};
        break;
    case 1 :
        pattern1 = (int [6]) {1, 1, 2, 1, 2, 2};
        break;
    default :
        pattern1 = (int [6]) {0, 0, 0, 0, 0, 0};
        break;
    }
    memcpy (pattern, pattern1, 6 * sizeof (int));
    for (i = 0; i < 6; i++) {
        printf ("%i\n", pattern [i]);
    }
    return pattern;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1569826_1569996_18_33
1569826_1570077_12_27
Title: "C semaphores and a ""barrier"" between threads" 
----------------------------------------

int main () {
    pthread_t tid, tid1;
    thread_count.count = 0;
    sem_init (& t_1_sem, 0, 1);
    sem_init (& t_2_sem, 0, 1);
    printf ("Hello from main thread! tid:%ld pid:%d\n", pthread_self (), getpid ());
    pthread_create (& tid, NULL, thread_1, NULL);
    pthread_create (& tid1, NULL, thread_2, NULL);
    pthread_join (tid, NULL);
    pthread_join (tid1, NULL);
    exit (0);
}
----------------------------------------

int main () {
    pthread_t tid0, tid1;
    thread_count.count = 0;
    sem_init (& t_0_sem, 0, SEM_INIT_V);
    sem_init (& t_1_sem, 0, SEM_INIT_V);
    pthread_create (& tid0, NULL, thread, & thread_count.count);
    thread_count.count++;
    pthread_create (& tid1, NULL, thread, & thread_count.count);
    pthread_join (tid0, NULL);
    pthread_join (tid1, NULL);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15702297_15702350_4_18
15702297_15704988_3_44
Title: Dynamic jump to label in C 
----------------------------------------

int main (void) {
    printf (" num is 1 \n");
    printf (" num is 2 \n");
    printf (" num is 3 \n");
    for (;;) {
        printf (" num is 4 \n");
        printf (" num is 5 \n");
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    unsigned char data [] = {1, 2, 3, 4, 5, 4, 5, 0};
    void *jump_table [] = {&&L00, &&L01, &&L02, &&L03, &&L04, &&L05};
    unsigned char *p = data;
begin :
    goto *jump_table[*p];
L00 :
    return 0;
L01 :
    printf ("num %i\n", (int) *p);
    goto next;
L02 :
    printf ("num %i\n", (int) *p);
    goto next;
L03 :
    printf ("num %i\n", (int) *p);
    goto next;
L04 :
    printf ("num %i\n", (int) *p);
    goto next;
L05 :
    printf ("num %i\n", (int) *p);
    goto next;
L06 :
L07 :
LFF :
    goto next;
next :
    ++p;
    goto begin;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15702297_15702350_4_18
15702297_15708064_1_27
Title: Dynamic jump to label in C 
----------------------------------------

int main (void) {
    printf (" num is 1 \n");
    printf (" num is 2 \n");
    printf (" num is 3 \n");
    for (;;) {
        printf (" num is 4 \n");
        printf (" num is 5 \n");
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    int i = 1;
    while (1) {
        switch (i) {
        case 1 :
            printf (" num is 1 \n");
        case 2 :
            printf (" num is 2 \n");
        case 3 :
            printf (" num is 3 \n");
        case 4 :
            printf (" num is 4 \n");
        case 5 :
            printf (" num is 5 \n");
        default :
            break;
        }
        i = 4;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15702297_15704988_3_44
15702297_15708064_1_27
Title: Dynamic jump to label in C 
----------------------------------------

int main () {
    unsigned char data [] = {1, 2, 3, 4, 5, 4, 5, 0};
    void *jump_table [] = {&&L00, &&L01, &&L02, &&L03, &&L04, &&L05};
    unsigned char *p = data;
begin :
    goto *jump_table[*p];
L00 :
    return 0;
L01 :
    printf ("num %i\n", (int) *p);
    goto next;
L02 :
    printf ("num %i\n", (int) *p);
    goto next;
L03 :
    printf ("num %i\n", (int) *p);
    goto next;
L04 :
    printf ("num %i\n", (int) *p);
    goto next;
L05 :
    printf ("num %i\n", (int) *p);
    goto next;
L06 :
L07 :
LFF :
    goto next;
next :
    ++p;
    goto begin;
    return 0;
}
----------------------------------------

int main () {
    int i = 1;
    while (1) {
        switch (i) {
        case 1 :
            printf (" num is 1 \n");
        case 2 :
            printf (" num is 2 \n");
        case 3 :
            printf (" num is 3 \n");
        case 4 :
            printf (" num is 4 \n");
        case 5 :
            printf (" num is 5 \n");
        default :
            break;
        }
        i = 4;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1570511_1570523_9_26
1570511_1598774_9_35
Title: C code to get the IP address 
----------------------------------------

int main () {
    int fd;
    struct ifreq ifr;
    fd = socket (AF_INET, SOCK_DGRAM, 0);
    ifr.ifr_addr.sa_family = AF_INET;
    snprintf (ifr.ifr_name, IFNAMSIZ, "eth0");
    ioctl (fd, SIOCGIFADDR, & ifr);
    printf ("%s\n", inet_ntoa (((struct sockaddr_in *) & ifr.ifr_addr) -> sin_addr));
    close (fd);
}
----------------------------------------

int main (int argc, char *argv []) {
    struct ifaddrs *ifaddr, *ifa;
    int family, s;
    char host [NI_MAXHOST];
    if (getifaddrs (&ifaddr) == -1) {
        perror ("getifaddrs");
        exit (EXIT_FAILURE);
    }
    for (ifa = ifaddr; ifa != NULL; ifa = ifa->ifa_next) {
        family = ifa->ifa_addr->sa_family;
        if (family == AF_INET) {
            s = getnameinfo (ifa->ifa_addr, sizeof (struct sockaddr_in), host, NI_MAXHOST, NULL, 0, NI_NUMERICHOST);
            if (s != 0) {
                printf ("getnameinfo() failed: %s\n", gai_strerror (s));
                exit (EXIT_FAILURE);
            }
            printf ("<Interface>: %s \t <Address> %s\n", ifa -> ifa_name, host);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1572796_1572839_2_13
1572796_1572892_3_15
Title: How can I print a C double bit-by-bit to see the low-level representation? 
----------------------------------------

int main () {
    double decker = 1.0;
    unsigned char *desmond = (unsigned char *) &decker;
    int i;
    for (i = 0; i < sizeof (double); i++) {
        printf ("%02X ", desmond [i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    unsigned char dontdothis [sizeof (double)];
    double x = 62.42;
    printf ("%f\n", x);
    memmove (& dontdothis, & x, sizeof dontdothis);
    dontdothis[sizeof x - 1] ^= 0x80;
    memmove (& x, & dontdothis, sizeof dontdothis);
    printf ("%f\n", x);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15746983_15747197_5_24
15746983_15766554_59_74
Title: How to write int to file using write system call and read them exactly as written? 
----------------------------------------

int main () {
    int fd = open ("float.txt", O_CREAT | O_WRONLY);
    float val = 1.5f;
    if (fd != -1) {
        write (fd, & val, sizeof (val));
        close (fd);
    }
    fd = open ("float.txt", O_RDONLY);
    float new_val;
    if (fd != -1) {
        read (fd, & new_val, sizeof (new_val));
        printf ("new_val = %f\n", new_val);
        close (fd);
    }
    return 0;
}
----------------------------------------

int main (void) {
    Demonstrate (0);
    Demonstrate (1);
    Demonstrate (9);
    Demonstrate (10);
    Demonstrate (INT_MAX - 1);
    Demonstrate (INT_MAX);
    Demonstrate (- 1);
    Demonstrate (- 9);
    Demonstrate (- 10);
    Demonstrate (INT_MIN + 1);
    Demonstrate (INT_MIN);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1575142_1575733_63_82
1575142_1575752_2_75
Title: Comparing arbitrary bit sequences in a byte array in c 
----------------------------------------

int compare_bit_sequence (const uint8_t s1 [], unsigned s1_off, const uint8_t s2 [], unsigned s2_off, unsigned length) {
    if (length == 0)
        return EQUAL;
    s1 += s1_off / 8;
    s1_off %= 8;
    s2 += s2_off / 8;
    s2_off %= 8;
    if (s1_off >= s2_off)
        return do_compare (s1, s1_off, s2, s2_off, length);
    else
        return do_compare (s2, s2_off, s1, s1_off, length);
}
----------------------------------------

int compare_bit_sequence (uint8_t s1 [], unsigned s1_off, uint8_t s2 [], unsigned s2_off, unsigned length) {
    const uint8_t mask_lo_bits [] = {0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff};
    const uint8_t clear_lo_bits [] = {0xff, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80, 0x00};
    uint8_t v1;
    uint8_t *max_s1;
    unsigned end;
    uint8_t lsl;
    uint8_t v1_mask;
    int delta;
    s1 += s1_off >> 3;
    s1_off &= 7;
    s2 += s2_off >> 3;
    s2_off &= 7;
    if (s2_off > s1_off) {
        uint8_t *tmp_s;
        unsigned tmp_off;
        tmp_s = s2;
        s2 = s1;
        s1 = tmp_s;
        tmp_off = s2_off;
        s2_off = s1_off;
        s1_off = tmp_off;
    }
    delta = s1_off;
    if (s2_off > 0) {
        delta = s1_off - s2_off;
        v1 = delta ? (s1[0] >> delta | s1[1] << (8 - delta)) & clear_lo_bits[delta] : s1[0];
        if (length <= 8 - s2_off) {
            if ((v1 ^ *s2) & clear_lo_bits[s2_off] & mask_lo_bits[s2_off + length]) {
                return NOT_EQUAL;
            }
            else {
                return EQUAL;
            }
        }
        else {
            if ((v1 ^ *s2) & clear_lo_bits[s2_off]) {
                return NOT_EQUAL;
            }
            length -= 8 - s2_off;
        }
        s1++;
        s2++;
    }
    max_s1 = s1 + (length >> 3);
    lsl = 8 - delta;
    v1_mask = clear_lo_bits[delta];
    while (s1 < max_s1) {
        if ((*s1 >> delta | (*++s1 << lsl & v1_mask)) ^ *s2++) {
            return NOT_EQUAL;
        }
    }
    end = length & 7;
    if (end && ((* s2 ^ * s1 >> delta) & mask_lo_bits [end])) {return NOT_EQUAL;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1576300_15340456_30_44
1576300_45680828_79_119
Title: Checking if a pointer is allocated memory or not 
----------------------------------------

int main (int argc, char *argv []) {
    int *i, *j;
    i = malloc (1);
    if (memcheck (i))
        printf ("i points to illegal memory\n");
    if (memcheck (j))
        printf ("j points to illegal memory\n");
    free (i);
    return (0);
}
----------------------------------------

int main (void) {
    printf ("\n\n\t *************** Test ******************** \n\n");
    size_t i = 0;
    printf ("\t *************** create tracker ********************\n");
    int *ptr = malloc (sizeof (int) * 10);
    Ptr (& ptr);
    printf ("\t *************** check tracker ********************\n");
    PtrCheck ();
    printf ("\t *************** free pointer ********************\n");
    free (ptr);
    printf ("\t *************** check tracker ********************\n");
    PtrCheck ();
    printf ("\t *************** set pointer NULL *******************\n");
    ptr = NULL;
    printf ("\t *************** check tracker ********************\n");
    PtrCheck ();
    printf ("\t *************** free tracker ********************\n");
    PtrFree ();
    printf ("\n\n\t *************** single check done *********** \n\n");
    printf ("\n\n\t *************** start multiple test *********** \n");
    int *ptrs [10];
    printf ("\t *************** create trackers ********************\n");
    for (; i < 10; i++) {
        ptrs[i] = malloc (sizeof (int) * 10 * i);
        Ptr (& ptrs [i]);
    }
    printf ("\t *************** check trackers ********************\n");
    PtrCheck ();
    printf ("\t *************** free pointers but set not NULL *****\n");
    for (i--; i > 0; i--) {
        free (ptrs [i]);
    }
    printf ("\t *************** check trackers ********************\n");
    PtrCheck ();
    printf ("\t *************** set pointers NULL *****************\n");
    for (i = 0; i < 10; i++) {
        ptrs[i] = NULL;
    }
    printf ("\t *************** check trackers ********************\n");
    PtrCheck ();
    printf ("\t *************** free trackers ********************\n");
    PtrFree ();
    printf ("\tdone");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15846432_15846664_64_85
15846432_15846752_2_19
Title: reading from a file to make an array using C 
----------------------------------------

int main () {
    FILE *finp;
    node *head = NULL;
    finp = fopen ("haha.txt", "r");
    if (NULL == finp) {
        printf ("Unable to open file\n");
        exit (- 1);
    }
    createList (finp, & head);
    printList (& head);
    deleteList (& head);
    fclose (finp);
    return 0;
}
----------------------------------------

int main () {
    FILE *file = fopen ("input.txt", "r");
    int integers [MAX];
    int i = 0;
    if (file != NULL) {
        while (!feof (file) && i < MAX) {
            if (fscanf (file, "%d", &integers[i++]) != -1) {
                printf ("%d ", integers [i - 1]);
            }
        }
        fclose (file);
    }
    else {
        printf ("Unable to open file");
        return EXIT_FAILURE;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15861260_15863624_1_14
15861260_15868079_25_41
Title: Simple Opengl Program doesnt work as it is supposed to 
----------------------------------------

bool getpixelcolor (GLint x, GLint y) {
    unsigned char pick_col [3];
    glReadPixels (x, y, 1, 1, GL_RGB, GL_UNSIGNED_BYTE, pick_col);
    if ((pick_col[0] != 255) && (pick_col[1] != 255) && (pick_col[2] == 255)) {
        return true;
    }
    else {
        return false;
    }
}
----------------------------------------

bool getpixelcolor (GLint x, GLint y) {
    int r, g, b;
    r = pick_col[x][y][0];
    g = pick_col[x][y][1];
    b = pick_col[x][y][2];
    if ((r != 255) && (b != 255) && (g == 255)) {
        return true;
    }
    else {
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15861987_15862125_1_12
15861987_15862278_3_14
Title: How to scan number from n-th position in C 
----------------------------------------

int main (void) {
    char buff [8];
    int nr;
    FILE *theFile = fopen ("/home/mppl/Desktop/file", "r");
    while (fscanf (theFile, "%s\n", buff) != EOF) {
        nr = atoi (&buff[4]);
        printf ("nr=%d\n", nr);
    }
}
----------------------------------------

int main () {
    FILE *fp = fopen ("file", "r");
    char first [5];
    int second;
    while (!feof (fp)) {
        fgets (first, 5, fp);
        fscanf (fp, "%d", & second);
        fgetc (fp);
        printf ("%d\n", second);
    }
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15861987_15862125_1_12
15861987_15862312_1_11
Title: How to scan number from n-th position in C 
----------------------------------------

int main (void) {
    char buff [8];
    int nr;
    FILE *theFile = fopen ("/home/mppl/Desktop/file", "r");
    while (fscanf (theFile, "%s\n", buff) != EOF) {
        nr = atoi (&buff[4]);
        printf ("nr=%d\n", nr);
    }
}
----------------------------------------

int main () {
    FILE *fp = fopen ("file", "r");
    char buf [128];
    int a;
    while (!feof (fp)) {
        fgets (buf, 127, fp);
        sscanf (buf, "%*4d%4d", & a);
        printf ("%d\n", a);
    }
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15861987_15862125_1_12
15861987_15862352_1_20
Title: How to scan number from n-th position in C 
----------------------------------------

int main (void) {
    char buff [8];
    int nr;
    FILE *theFile = fopen ("/home/mppl/Desktop/file", "r");
    while (fscanf (theFile, "%s\n", buff) != EOF) {
        nr = atoi (&buff[4]);
        printf ("nr=%d\n", nr);
    }
}
----------------------------------------

int main () {
    FILE *fp;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    if ((fp = fopen ("sample.txt", "r")) == NULL) {
    }
    while ((read = getline (&line, &len, fp)) != -1) {
        printf ("%s", (line + (read - 5)));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15861987_15862278_3_14
15861987_15862312_1_11
Title: How to scan number from n-th position in C 
----------------------------------------

int main () {
    FILE *fp = fopen ("file", "r");
    char first [5];
    int second;
    while (!feof (fp)) {
        fgets (first, 5, fp);
        fscanf (fp, "%d", & second);
        fgetc (fp);
        printf ("%d\n", second);
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    FILE *fp = fopen ("file", "r");
    char buf [128];
    int a;
    while (!feof (fp)) {
        fgets (buf, 127, fp);
        sscanf (buf, "%*4d%4d", & a);
        printf ("%d\n", a);
    }
    return EXIT_SUCCESS;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15861987_15862278_3_14
15861987_15862352_1_20
Title: How to scan number from n-th position in C 
----------------------------------------

int main () {
    FILE *fp = fopen ("file", "r");
    char first [5];
    int second;
    while (!feof (fp)) {
        fgets (first, 5, fp);
        fscanf (fp, "%d", & second);
        fgetc (fp);
        printf ("%d\n", second);
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    FILE *fp;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    if ((fp = fopen ("sample.txt", "r")) == NULL) {
    }
    while ((read = getline (&line, &len, fp)) != -1) {
        printf ("%s", (line + (read - 5)));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15861987_15862312_1_11
15861987_15862352_1_20
Title: How to scan number from n-th position in C 
----------------------------------------

int main () {
    FILE *fp = fopen ("file", "r");
    char buf [128];
    int a;
    while (!feof (fp)) {
        fgets (buf, 127, fp);
        sscanf (buf, "%*4d%4d", & a);
        printf ("%d\n", a);
    }
    return EXIT_SUCCESS;
}
----------------------------------------

int main () {
    FILE *fp;
    char *line = NULL;
    size_t len = 0;
    ssize_t read;
    if ((fp = fopen ("sample.txt", "r")) == NULL) {
    }
    while ((read = getline (&line, &len, fp)) != -1) {
        printf ("%s", (line + (read - 5)));
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15863611_15863732_5_30
15863611_15863736_5_26
Title: Check if a word is palindrome with string.h 
----------------------------------------

int main () {
    char a [100], b [100];
    int i;
    int stringLen;
    printf ("Type the string \n");
    gets (a);
    stringLen = strlen (a);
    for (i = 0; i < stringLen; i++) {
        b[stringLen - 1 - i] = a[i];
    }
    if (strcmp (a, b) == 0) {
        printf ("palindrome");
    }
    else {
        printf ("not palindrome");
    }
    getch ();
    return 0;
}
----------------------------------------

int main () {
    char a [100], b [100];
    int i, k;
    printf ("Type the string \n");
    gets (a);
    k = strlen (a) - 1;
    for (i = 0; i < strlen (a); i++) {
        b[i] = a[k];
        k--;
    }
    b[strlen (a)] = '\0';
    k = strcmp (a, b);
    if (k == 0) {
        printf ("palindrome");
    }
    else {
        printf ("not palindrome");
    }
    getch ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15867712_15867795_5_19
15867712_15867809_1_11
Title: sprintf(): scaning only the first value in float array 
----------------------------------------

void H (float *suma, int k) {
    int i, j;
    char str [200] = "";
    for (j = 0; j < k; j++) {
        sprintf (str, "%.2f", suma [j]);
        for (i = 0; i < strlen (str); i++) {
            printf ("%c", str [i]);
        }
        printf ("\n");
    }
}
----------------------------------------

void H (float *suma, int k) {
    int i = 0, j;
    char str [200] = "";
    for (j = 0; j < k; j++) {
        sprintf (str, "%.2f", * (suma + j));
        for (i = 0; str[i] != '\0'; i++) {
            printf ("%c\n", str [i]);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15883743_15883979_4_24
15883743_41940973_3_20
Title: read from a file and store it in a variable c 
----------------------------------------

void main () {
    FILE *fp;
    char ch;
    char txt [30];
    int len = 0;
    fp = fopen ("~/hello.txt", "r");
    if (!fp) {
        printf ("Cannot open file!\n");
        return;
    }
    ch = fgetc (fp);
    while (ch != EOF && ch != '\n' && len < 30) {
        txt[len] = ch;
        len++;
        ch = fgetc (fp);
    }
    txt[len] = 0;
    puts (txt);
}
----------------------------------------

int main () {
    FILE *fp;
    int ch;
    char txt [300];
    int len = 0;
    fp = fopen ("tenlines.txt", "r");
    do {
        ch = fgetc (fp);
        txt[len] = ch;
        len++;
    }
    while (ch != EOF && ch != '\n');
    fclose (fp);
    puts (txt);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15884253_15884346_1_21
15884253_15891672_81_103
Title: "Make thread loop for 5 iterations; pthreads mutex and semaphors" 
----------------------------------------

void *producer (void *param) {
    for (int i = 0; i < 5;) {
        if (insert_item (pthreadID)) {
            fprintf (stderr, "Producer error.");
        }
        else {
            i++;
        }
    }
    return 0;
}
----------------------------------------

void *producer (void *param) {
    long index = (long) param;
    for (int x = 0; x < 5; x++) {
        sleep (1);
        sem_wait (& cEmpty);
        pthread_mutex_lock (& mutex);
        if (insert_item (index)) {
            fprintf (stderr, "Producer error.");
        }
        pthread_mutex_unlock (& mutex);
        sem_post (& cFull);
    }
    pthread_exit (NULL);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15884253_15884346_23_42
15884253_15891672_106_128
Title: "Make thread loop for 5 iterations; pthreads mutex and semaphors" 
----------------------------------------

void *consumer (void *param) {
    for (int i = 0; i < 5;) {
        if (remove_item (cthreadID)) {
            fprintf (stderr, "Consumer error.");
        }
        else {
            i++;
        }
    }
    return 0;
}
----------------------------------------

void *consumer (void *param) {
    long index = (long) param;
    for (int x = 0; x < 5; x++) {
        sleep (1);
        sem_wait (& cFull);
        pthread_mutex_lock (& mutex);
        if (remove_item (index)) {
            fprintf (stderr, "Consumer error.");
        }
        pthread_mutex_unlock (& mutex);
        sem_post (& cEmpty);
    }
    pthread_exit (NULL);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15893015_15893438_1_17
15893015_15895666_1_15
Title: Counting duplicates in C 
----------------------------------------

int main () {
    int test [10] = {1, 2, 1, 3, 4, 5, 6, 7, 8, 3, 2};
    int i, j, dupliCount = 0;
    for (i = 0; i < (sizeof (test) / sizeof (int)); i++) {
        for (j = i + 1; j < (sizeof (test) / sizeof (int)); j++) {
            if (test[i] == test[j]) {
                ++dupliCount;
                break;
            }
        }
    }
    printf ("duplicate count %d", dupliCount);
}
----------------------------------------

int main () {
    int test [LEN] = {1, 2, 1, 3, 4, 5, 6, 7, 8, 3, 2};
    int ndup = 0;
    int bucket_array [LEN] = {0};
    for (i = 0; i < LEN; i++) {
        if (bucket_array[test[i]]++) {
            ndup++;
        }
    }
    printf ("%d duplicates\n", ndup);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15960040_15960069_1_31
15960040_15960769_1_15
Title: Insertion sort on linked list in C? 
----------------------------------------

void insert (struct PCB **head, const int reg1, const int reg2) {
    struct PCB *node = malloc (sizeof (struct PCB));
    node->reg1 = reg1;
    node->reg2 = reg2;
    node->next = NULL;
    if (*head == NULL) {
        *head = node;
    }
    else if (reg1 < (*head)->reg1) {
        node->next = *head;
        *head = node;
    }
    else {
        struct PCB *current = *head;
        while (current->next != NULL && reg1 < current->next->reg1)
            current = current->next;
        node->next = current->next;
        current->next = node;
    }
}
----------------------------------------

void insert (struct PCB **head, const int reg1, const int reg2) {
    struct PCB *new;
    for (; *head; head = &(*head)->next) {
        if ((*head)->reg1 > reg1)
            break;
    }
    new = malloc (sizeof *new);
    new->reg1 = reg1;
    new->reg2 = reg2;
    new->next = *head;
    *head = new;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15968732_15969088_3_27
15968732_15970777_39_59
Title: union merge of table that has integers in c 
----------------------------------------

int main () {
    int subtable1 [] = {15, 20, 40, 69, 74, 83, 0};
    int subtable2 [] = {12, 40, 58, 74, 82, 94, 111, 0};
    int subtable3 [] = {19, 30, 69, 0};
    int subtable4 [] = {12, 19, 0};
    int subtable5 [] = {44, 64, 74, 83, 0};
    int *table [] = {subtable1, subtable2, subtable3, subtable4, subtable5};
    int result [128] = {0};
    int temp [128] = {0};
    int i, j, count = 0;
    for (i = 0; i < sizeof (table) / sizeof (int *); ++i)
        for (j = 0; table[i][j]; ++j)
            ++temp[table[i][j]];
    for (i = 1; i < 128; ++i)
        if (temp[i])
            result[count++] = i;
    for (i = 0; i < count; ++i)
        printf ("%d ", result[i]);
    printf ("\n");
    return 0;
}
----------------------------------------

int main () {
    int subtable1 [] = {15, 20, 40, 69, 74, 83, 0};
    int subtable2 [] = {12, 40, 58, 74, 82, 94, 111, 0};
    int subtable3 [] = {19, 30, 69, 0};
    int subtable4 [] = {12, 19, 0};
    int subtable5 [] = {44, 64, 74, 83, 0};
    int *m12, *m34, *m1234, *result;
    int counter = 0;
    m12 = merge (subtable1, subtable2);
    m34 = merge (subtable3, subtable4);
    m1234 = merge (m12, m34);
    result = merge (m1234, subtable5);
    for (counter = 0; result[counter]; ++counter)
        printf ("%d ", result[counter]);
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15987237_15987520_5_33
15987237_15987525_8_40
Title: How can we restrict user to enter characters and also integers greater than specified length in C? 
----------------------------------------

int main () {
    char str [10000], key [10000];
    printf ("Enter the string:- ");
    scanf ("%[^\n]", str);
    int len, isalphabet = 0;
    do {
        printf ("What is the length of the key you are entering?:-");
        scanf ("%d", & len);
        fflush (stdin);
        if (isalpha (len)) {
            isalphabet = 1;
        }
    }
    while (len >= strlen (str) || isalphabet == 1);
    int i;
    for (i = 0; i < len; i++) {
        printf ("%dth digit of Key= ", i + 1);
        scanf ("%d", & key [i]);
    }
    return (0);
}
----------------------------------------

int main () {
    char str [10000];
    char key [10000];
    printf ("Enter the string:- ");
    scanf ("%[^\n]", str);
    int len = 0;
    int isalphabet = TRUE;
    int apply = 1;
    do {
        printf ("What is the length of the key you are entering?:-");
        scanf ("%d", & len);
        isalphabet = isalpha (len);
        apply = (len > (strlen (str) - 1));
    }
    while (!apply || isalphabet);
    int i;
    for (i = 0; i < len; i++) {
        printf ("%dth digit of Key= ", i + 1);
        scanf ("%c\n", & key [i]);
    }
    for (i = 0; i < len; i++) {
        printf ("key[%d] = %c\n", i, key [i]);
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15989982_15990637_4_13
15989982_15990827_1_17
Title: Creating a number of integers by user request 
----------------------------------------

int main () {
    int *arr, number, i;
    printf ("Give number value: ");
    scanf ("%d", & number);
    arr = malloc (sizeof (*arr) * number);
    for (i = 0; i < number; i++) {
        printf ("%d ", i);
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i;
    int totalIntegers int arrayVariableName [100];
    printf ("Enter total amount of variables");
    scanf ("%d", & totalIntegers);
    for (i = 0; i < totalIntegers; i++) {
              printf ("enter a number: ");
        scanf ("%d", & arrayVariableName [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
15996288_15996632_4_34
15996288_15997007_50_62
Title: In-place interleaving of the two halves of a string 
----------------------------------------

int main (void) {
std :
    : string s ("abcdefghij1234567890");
    int N = s.size ();
    int k = N / 2 - 1;
    while (true) {
        for (int j = 0; j < k; ++j) {
            int i = N / 2 - j;
        std :
            : swap (s [i], s [i - 1]);
        }
        --k;
        if (k == 0)
            break;
        for (int j = 0; j < k; ++j) {
            int i = N / 2 + j;
        std :
            : swap (s [i], s [i + 1]);
        }
        --k;
    }
std :
    : cout << s << std : : endl;
    return 0;
}
----------------------------------------

int main (void) {
    unsigned i;
    for (i = 0; i < sizeof (testData) / sizeof (testData[0]); i++) {
        printf ("%s -> ", testData [i]);
        interleave (testData [i], strlen (testData [i]));
        printf ("%s\n", testData [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16022220_16022696_1_33
16022220_16022708_4_33
Title: Reverse words in C Language 
----------------------------------------

int main (int argc, const char *argv []) {
    char sentence [] = "this is a sentence";
    size_t len = strlen (sentence);
    char *newSentence = malloc (len +1);
    char *ptr_src = sentence;
    char *ptr_dst = newSentence;
    while (ptr_src) {
        char *next, *t;
        next = strchr (ptr_src, ' ');
        if (!next)
            next = sentence + len;
        for (t = next; t > ptr_src;) {
            *ptr_dst++ = *--t;
        }
        if (*next) {
            *ptr_dst++ = *next++;
            ptr_src = next;
        }
        else {
            *ptr_dst = 0;
            break;
        }
    }
    printf ("[%s]", newSentence);
    return 0;
}
----------------------------------------

int main (void) {
    char sentence [] = "this is a sentence";
    char *newSentence = (char *) malloc (strlen (sentence) +1);
    int i, j, start, k;
    start = 0;
    for (i = 0;; i++) {
        if (sentence[i] == ' ' || sentence[i] == '\0') {
            char *word = (char *) malloc ((i - start) + 1);
            for (j = i - 1, k = 0; j >= start; j--, k++) {
                word[k] = sentence[j];
            }
            word[k++] = ' ';
            word[k] = '\0';
            strcat (newSentence, word);
            start = i + 1;
        }
        if (sentence[i] == '\0')
            break;
    }
    printf ("%s\n", newSentence);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16022220_16022696_1_33
16022220_16022734_5_34
Title: Reverse words in C Language 
----------------------------------------

int main (int argc, const char *argv []) {
    char sentence [] = "this is a sentence";
    size_t len = strlen (sentence);
    char *newSentence = malloc (len +1);
    char *ptr_src = sentence;
    char *ptr_dst = newSentence;
    while (ptr_src) {
        char *next, *t;
        next = strchr (ptr_src, ' ');
        if (!next)
            next = sentence + len;
        for (t = next; t > ptr_src;) {
            *ptr_dst++ = *--t;
        }
        if (*next) {
            *ptr_dst++ = *next++;
            ptr_src = next;
        }
        else {
            *ptr_dst = 0;
            break;
        }
    }
    printf ("[%s]", newSentence);
    return 0;
}
----------------------------------------

int main (void) {
    char sentence [] = "this is a sentence";
    char *newSentence;
    int i, j, start, len;
    start = 0;
    len = strlen (sentence);
    newSentence = malloc (len +1);
    *newSentence = '\0';
    for (i = 0; i <= len; i++) {
        if (sentence[i] == ' ' || sentence[i] == '\0') {
            char *word = malloc ((i - start) + 1);
            int c = 0;
            for (j = i - 1; j >= start; j--) {
                word[c++] = sentence[j];
            }
            word[c] = '\0';
            strcat (newSentence, word);
            if (sentence[i] == ' ')
                strcat (newSentence, " ");
            start = i + 1;
            free (word);
        }
    }
    printf ("%s", newSentence);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16022220_16022708_4_33
16022220_16022734_5_34
Title: Reverse words in C Language 
----------------------------------------

int main (void) {
    char sentence [] = "this is a sentence";
    char *newSentence = (char *) malloc (strlen (sentence) +1);
    int i, j, start, k;
    start = 0;
    for (i = 0;; i++) {
        if (sentence[i] == ' ' || sentence[i] == '\0') {
            char *word = (char *) malloc ((i - start) + 1);
            for (j = i - 1, k = 0; j >= start; j--, k++) {
                word[k] = sentence[j];
            }
            word[k++] = ' ';
            word[k] = '\0';
            strcat (newSentence, word);
            start = i + 1;
        }
        if (sentence[i] == '\0')
            break;
    }
    printf ("%s\n", newSentence);
    return 0;
}
----------------------------------------

int main (void) {
    char sentence [] = "this is a sentence";
    char *newSentence;
    int i, j, start, len;
    start = 0;
    len = strlen (sentence);
    newSentence = malloc (len +1);
    *newSentence = '\0';
    for (i = 0; i <= len; i++) {
        if (sentence[i] == ' ' || sentence[i] == '\0') {
            char *word = malloc ((i - start) + 1);
            int c = 0;
            for (j = i - 1; j >= start; j--) {
                word[c++] = sentence[j];
            }
            word[c] = '\0';
            strcat (newSentence, word);
            if (sentence[i] == ' ')
                strcat (newSentence, " ");
            start = i + 1;
            free (word);
        }
    }
    printf ("%s", newSentence);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16066885_16067102_1_10
16066885_16067155_1_11
Title: Creating an atoi function 
----------------------------------------

int main (void) {
    char number [MAXSIZE];
    int num;
    printf ("Please enter a number: ");
    scanf ("%s", number);
    num = atoi_me (number);
    printf ("%d\n", num);
    return 0;
}
----------------------------------------

int main () {
    char number [MAXSIZE];
    int num;
    printf ("Please enter a number:\n");
    scanf ("%s", number);
    num = atoi_me (number);
    printf ("%d", num);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16066885_16067102_1_10
16066885_16067203_1_11
Title: Creating an atoi function 
----------------------------------------

int main (void) {
    char number [MAXSIZE];
    int num;
    printf ("Please enter a number: ");
    scanf ("%s", number);
    num = atoi_me (number);
    printf ("%d\n", num);
    return 0;
}
----------------------------------------

int main () {
    char number [MAXSIZE];
    int num;
    printf ("Please enter a number:\n");
    scanf ("%s", number);
    num = atoi_me (number);
    printf ("%d", num);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16066885_16067155_1_11
16066885_16067203_1_11
Title: Creating an atoi function 
----------------------------------------

int main () {
    char number [MAXSIZE];
    int num;
    printf ("Please enter a number:\n");
    scanf ("%s", number);
    num = atoi_me (number);
    printf ("%d", num);
    return 0;
}
----------------------------------------

int main () {
    char number [MAXSIZE];
    int num;
    printf ("Please enter a number:\n");
    scanf ("%s", number);
    num = atoi_me (number);
    printf ("%d", num);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1608181_1608770_11_33
1608181_8062257_5_39
Title: Unique random numbers in an integer array in the C programming language 
----------------------------------------

int main (void) {
    int i;
    srand (time (NULL));
    for (i = 0; i < MAX; i++)
        candidates[i] = i;
    for (i = 0; i < MAX - 1; i++) {
        int c = randrange (MAX -i);
        int t = candidates[i];
        candidates[i] = candidates[i + c];
        candidates[i + c] = t;
    }
    for (i = 0; i < 10; i++)
        vektor[i] = candidates[i] + 1;
    for (i = 0; i < 10; i++)
        printf ("%i\n", vektor[i]);
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int h, i, j, tM, M, N, par = 0, *H, *L, *V, cxc = 0;
    ++par;
    M = 42;
    if (argc > par)
        M = atoi (argv[par]);
    ++par;
    N = 137;
    if (argc > par)
        N = atoi (argv[par]);
    tM = 3 * M + 3;
    H = malloc (tM * sizeof (int));
    printf ("M = %d,  N = %d  %s\n", M, N, H ? "" : "\nmem error");
    if (!H)
        exit (13);
    for (i = 0; i < tM; ++i)
        H[i] = -1;
    L = H + M;
    V = L + M;
    for (i = 0; i < M; ++i) {
        do {
            ++cxc;
            V[-1] = V[i] = random () % N;
            h = V[i] % M;
            j = H[h];
            while (V[j] != V[i])
                j = L[j];
        }
        while (j >= 0);
        L[i] = H[h];
        H[h] = i;
    }
    for (j = i = 0; i < M; ++i) {
        j += printf ("%4d ", V[i]);
        if (j > 66)
            j = printf ("\n");
    }
    printf ("\ncxc %d\n", cxc);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16093424_16093980_3_17
16093424_16112478_3_17
Title: Write an output file with a user defined name in C 
----------------------------------------

int main (int argc, const char * const *argv []) {
    char fname [128];
    char path [] = "/home/abc/test/";
    printf ("Enter the file name\n");
    scanf ("%123s", fname);
    strcat (fname, ".txt");
    strcat (path, fname);
    FILE *fp;
    fp = fopen (path, "a");
    fprintf (fp, "Testing... OK I think it worked\n");
    fclose (fp);
    return 0;
}
----------------------------------------

int main (int argc, const char * const *argv []) {
    char fname [128];
    strcpy (fname, "/Users/user/Desktop/learn/");
    char *input = fname + strlen (fname);
    printf ("Enter the file name\n");
    scanf ("%s", input);
    strncat (fname, ".txt", sizeof fname);
    printf ("The output pathway and file will be called %s\n", fname);
    FILE *fp;
    fp = fopen (fname, "a");
    fprintf (fp, "Testing... OK I think it worked\n");
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16117729_16117743_24_37
16117729_16117848_18_30
Title: C Program Not Compiling 
----------------------------------------

void dobig (double *parr, int *len, double *big) {
    int i;
    double pbig = *parr;
    for (i = 0; i < *len; i++) {
        if (pbig < *(parr + i)) {
            pbig = *(parr + i);
        }
    }
    *big = pbig;
}
----------------------------------------

void dobig (double **parr, int *len, double *big) {
    int i;
    double pbig = **parr;
    for (i = 0; i > *len; i++) {
        if (pbig < **(parr + i)) {
            pbig = **(parr + i);
        }
        *big = pbig;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16117729_16117743_7_22
16117729_16117848_6_16
Title: C Program Not Compiling 
----------------------------------------

int main (int argc, char *argv []) {
    double big;
    double arr [5] = {1.00, 2.321, 6.54337, 4.333333, 5.5555555};
    double *parr = &arr[0];
    int size = sizeof (arr) / sizeof (double);
    int *len = &size;
    dobig (parr, len, & big);
    printf ("the largest number is %f\n", big);
}
----------------------------------------

int main () {
    double *big;
    double arr [5] = {1.00, 2.321, 3.54337, 4.333333, 5.5555555};
    double **parr = &arr[5];
    int size = sizeof (arr) / sizeof (int);
    int *len = &size;
    dobig (parr, len, big);
    printf ("the largest number is %p/n", * big);
    system ("pause");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16122196_16129229_6_50
16122196_39836396_5_29
Title: getting mouseclick coordinates with Xlib 
----------------------------------------

int main () {
    int x = -1, y = -1;
    XEvent event;
    int button;
    Display *display = XOpenDisplay (NULL);
    if (display == NULL) {
        fprintf (stderr, "Cannot connect to X server!\n");
        exit (EXIT_FAILURE);
    }
    Window root = XDefaultRootWindow (display);
    XGrabPointer (display, root, False, ButtonPressMask, GrabModeAsync, GrabModeAsync, None, None, CurrentTime);
    XSelectInput (display, root, ButtonPressMask);
    while (1) {
        XNextEvent (display, & event);
        switch (event.type) {
        case ButtonPress :
            switch (event.xbutton.button) {
            case Button1 :
                x = event.xbutton.x;
                y = event.xbutton.y;
                button = Button1;
                break;
            case Button3 :
                x = event.xbutton.x;
                y = event.xbutton.y;
                button = Button3;
                break;
            default :
                break;
            }
            break;
        default :
            break;
        }
        if (x >= 0 && y >= 0)
            break;
    }
    if (button == Button1)
        printf ("leftclick at %d %d \n", x, y);
    else
        printf ("rightclick at %d %d \n", x, y);
    XCloseDisplay (display);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    Window root_window;
    int root_x, root_y;
    unsigned int mask;
    Display *display = XOpenDisplay (NULL);
    XQueryPointer (display, DefaultRootWindow (display), & root_window, & root_window, & root_x, & root_y, & root_x, & root_y, & mask);
    printf ("Mouse coordinates (X: %d, Y: %d)\n", root_x, root_y);
    XCloseDisplay (display);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16122312_16122563_9_23
16122312_16124301_25_46
Title: Inputting values to structure members using pointers 
----------------------------------------

int main (void) {
    int n, d;
    struct rational *p;
    p = (struct rational *) malloc (sizeof (struct rational));
    printf ("Enter the rational number.\n");
    scanf ("%d/%d", & p -> nu, & p -> de);
    printf ("%d/%d\n", p -> nu, p -> de);
    return 0;
}
----------------------------------------

int main () {
    struct rational p1, p2, p3;
    int a, b, c, d, choice;
    printf ("Enter the first rational number.\n");
    scanf ("%d/%d", & p1.nu, & p1.de);
    printf ("Enter the second rational number.\n");
    scanf ("%d/%d", & p2.nu, & p2.de);
    printf ("1. Addition 2. Multiplication 3. Division: ");
    scanf ("%d", & choice);
    switch (choice) {
    case 1 :
        add (&p1, &p2, &p3);
        break;
    case 2 :
        multiply (&p1, &p2, &p3);
        break;
    case 3 :
        divide (&p1, &p2, &p3);
        break;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16123702_16123759_1_10
16123702_16123764_1_12
Title: Preserving file pointer between function calls 
----------------------------------------

int readBinary (float *binImage, int gelements) {
    static imageFile = NULL;
    if (imageFile == NULL)
        imageFile = fopen ("tmpImageFile", "r");
    if (imageFile == NULL) {
        fprintf (stderr, "Error opening file\n");
        return (1);
    }
    fread (binImage, sizeof (float), gelements, imageFile);
    return 0;
}
----------------------------------------

int readBinary (float *binImage, int gelements) {
    static FILE *imageFile = NULL;
    if (imageFile == NULL) {
        imageFile = fopen ("tmpImageFile", "r");
        if (imageFile == NULL) {
            perror ("Error opening file: ");
            return (1);
        }
    }
    fread (binImage, sizeof (float), gelements, imageFile);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16133435_16133495_1_17
16133435_16133506_1_18
Title: Why does this code go into infinite loop 
----------------------------------------

int main () {
    long i = 0;
    time_t s, e;
    s = time (NULL);
    for (i = 3; i < 2147483647; i++) {
        isPrime1 (i);
        e = time (NULL);
        printf ("\n\t Time for loop %d: %ld secs", i, e - s);
    }
    return 0;
}
----------------------------------------

int main () {
    long i = 0;
    long cnt = 0;
    time_t s, e;
    s = time (NULL);
    for (i = 3; i < 2147483647; i++) {
        if (isPrime1 (i) && (++cnt % 4096) == 0) {
            printf ("#%ld: %ld\n", cnt, i);
            fflush (NULL);
        }
    }
    e = time (NULL);
    printf ("\n\t Time : %ld secs\n", e - s);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16142024_16142063_2_14
16142024_16142074_2_18
Title: C programming language help me? 
----------------------------------------

int main () {
    int s = 0, c = 0, n = 0, i = 1;
    c = getch ();
    printf ("\n Please write n:");
    scanf ("%d", & n);
    for (i = 1; i <= n; i++) {
        s += i * (2 * (i % 2) - 1);
    }
    printf ("\n Sum =%d", s);
    getch ();
}
----------------------------------------

int main () {
    int s = 0, c = 0, n = 0, i = 0;
    c = getch ();
    printf ("\n Please write n:");
    scanf ("%d", & n);
    for (i = 1; i <= n; i++) {
        if (i % 2 == 0)
            s -= i;
        else
            s += i;
    }
    printf ("\n Sum =%d", s);
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16142024_16142063_2_14
16142024_16142305_2_16
Title: C programming language help me? 
----------------------------------------

int main () {
    int s = 0, c = 0, n = 0, i = 1;
    c = getch ();
    printf ("\n Please write n:");
    scanf ("%d", & n);
    for (i = 1; i <= n; i++) {
        s += i * (2 * (i % 2) - 1);
    }
    printf ("\n Sum =%d", s);
    getch ();
}
----------------------------------------

int main () {
    float c, n, i, s;
    c = getch ();
    printf ("\n Please write n:");
    scanf ("%f", & n);
    s = 0.f;
    for (i = 1; i <= (n / 2); i++) {
        s += ((2 * i - 1) - 2 * i);
    }
    printf ("\n Sum =%.2f", s);
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16142024_16142074_2_18
16142024_16142305_2_16
Title: C programming language help me? 
----------------------------------------

int main () {
    int s = 0, c = 0, n = 0, i = 0;
    c = getch ();
    printf ("\n Please write n:");
    scanf ("%d", & n);
    for (i = 1; i <= n; i++) {
        if (i % 2 == 0)
            s -= i;
        else
            s += i;
    }
    printf ("\n Sum =%d", s);
    getch ();
}
----------------------------------------

int main () {
    float c, n, i, s;
    c = getch ();
    printf ("\n Please write n:");
    scanf ("%f", & n);
    s = 0.f;
    for (i = 1; i <= (n / 2); i++) {
        s += ((2 * i - 1) - 2 * i);
    }
    printf ("\n Sum =%.2f", s);
    getch ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16144307_16144369_8_16
16144307_16144642_8_17
Title: Variable array size in c 
----------------------------------------

object *newObject (int ra, int ca) {
    object *o = malloc (sizeof (object));
    o->rowsAmount = ra;
    o->columsAmount = ca;
    o->matrix = malloc (ra *ca * sizeof (int));
    o->rows = malloc (ra * sizeof (int *));
    for (size_t i = 0; i != ra; ++i)
        o->rows[i] = o->matrix + (i * ca);
    return o;
}
----------------------------------------

object *newObject (int ra, int ca) {
    int i;
    object *o = malloc (sizeof (object));
    o->rowsAmount = ra;
    o->columsAmount = ca;
    o->array = malloc (sizeof (int *) * ra);
    for (i = 0;
    i < ra;
    i ++) o - < array [i] = malloc (sizeof (int) * ca);
    return o;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16144307_16144369_8_16
16144307_16144804_11_20
Title: Variable array size in c 
----------------------------------------

object *newObject (int ra, int ca) {
    object *o = malloc (sizeof (object));
    o->rowsAmount = ra;
    o->columsAmount = ca;
    o->matrix = malloc (ra *ca * sizeof (int));
    o->rows = malloc (ra * sizeof (int *));
    for (size_t i = 0; i != ra; ++i)
        o->rows[i] = o->matrix + (i * ca);
    return o;
}
----------------------------------------

object *newObject (int ra, int ca) {
    int r;
    object *o = malloc (sizeof (object));
    o->rowsAmount = ra;
    o->columsAmount = ca;
    o->rows = (int **) malloc (ra * sizeof (int *));
    for (r = 0; r < ra; ++r)
        o->rows[r] = (int *) malloc (ca * sizeof (int));
    return o;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16144307_16144642_8_17
16144307_16144804_11_20
Title: Variable array size in c 
----------------------------------------

object *newObject (int ra, int ca) {
    int i;
    object *o = malloc (sizeof (object));
    o->rowsAmount = ra;
    o->columsAmount = ca;
    o->array = malloc (sizeof (int *) * ra);
    for (i = 0;
    i < ra;
    i ++) o - < array [i] = malloc (sizeof (int) * ca);
    return o;
}
----------------------------------------

object *newObject (int ra, int ca) {
    int r;
    object *o = malloc (sizeof (object));
    o->rowsAmount = ra;
    o->columsAmount = ca;
    o->rows = (int **) malloc (ra * sizeof (int *));
    for (r = 0; r < ra; ++r)
        o->rows[r] = (int *) malloc (ca * sizeof (int));
    return o;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16144954_16145026_6_21
16144954_16145248_6_19
Title: Finding all combinations of a^2 + b^2 in C 
----------------------------------------

int main () {
    int i = 0;
    int poss_n [(MAX + 1) * (MAX + 1)] = {0};
    int result;
    for (int a = 0; a <= MAX; a++) {
        for (int b = 0; b <= MAX; b++) {
            result = a * a + b * b;
            if (result >= 100 && result <= 999) {
                poss_n[i] = result;
                printf ("%i\n", result);
                i++;
            }
        }
    }
}
----------------------------------------

int main () {
    int i = 0;
    int poss_n [301];
    int a, b;
    for (a = 0; a <= MAX; a++) {
        for (b = 0; b <= MAX; b++) {
            if (a * a + b * b >= 100 && a * a + b * b <= 999) {
                poss_n[i] = a * a + b * b;
                printf ("%i\t i = %d , a = %d , b = %d\n", poss_n [i], i, a, b);
                i++;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16158601_16158960_1_24
16158601_16159492_54_72
Title: qsort of multidimensional array in c leading to segfault 
----------------------------------------

int compare (const void *arg1, const void *arg2) {
    point_data *point1 = arg1, *point2 = arg2;
    if (point1->x > point2->x) {
        return 1;
        else if (point1->x < point2->x) {
            return -1;
        }
        else {
            if (point1->y > point2->y) {
                return 1;
                else if (point1->y < point2->y) {
                    return -1;
                }
                else {
                    if (point1 -> z > point2 -> z) {return 1;
                    else if (point1 -> z < point2 -> z) {return - 1;
                }
                else {return 0;
            }
        }
    }
}
----------------------------------------

int compare (const void *arg1, const void *arg2) {
    double (*x) [3] = arg1;
    double (*y) [3] = arg2;
    if ((*x)[0] > (*y)[0])
        return 1;
    else if ((*x)[0] < (*y)[0])
        return -1;
    else if ((*x)[1] > (*y)[1])
        return 1;
    else if ((*x)[1] < (*y)[1])
        return -1;
    else if ((*x)[2] > (*y)[2])
        return 1;
    else if ((*x)[2] < (*y)[2])
        return -1;
    else
        return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16164620_16183024_93_102
16164620_29971007_25_90
Title: How to convert an IEEE 754 single-precision binary floating-point to decimal? 
----------------------------------------

int main (void) {
    printf ("%+g\n", Ieee754SingleDigits2DoubleCheat ("110000101100010010000000000000000"));
    printf ("%+g\n", Ieee754SingleDigits2DoubleNoCheat ("010000101100010010000000000000000"));
    printf ("%+g\n", Ieee754SingleDigits2DoubleCheat ("000000000100000000000000000000000"));
    printf ("%+g\n", Ieee754SingleDigits2DoubleNoCheat ("100000000100000000000000000000000"));
    printf ("%+g\n", Ieee754SingleDigits2DoubleCheat ("000000000000000000000000000000000"));
    printf ("%+g\n", Ieee754SingleDigits2DoubleNoCheat ("000000000000000000000000000000000"));
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    if (argc < 2) {
        fprintf (stderr, "error: insufficient input. Usage: %s float\n", argv [0]);
        return 1;
    }
    char *dp = strchr (argv[1], '.');
    int dec = atoi (argv[1]);
    int frc = (dp) ? atoi (dp +1) : 0;
    printf ("\nString Values:\n");
    printf (" string   : %s\n whole    : %d\n fraction : %d\n\n", argv [1], dec, frc);
    float fvalue = xstrtof (argv[1]);
    float ffrc = fvalue - dec;
    int signbit = (fvalue >= 0) ? 0 : 1;
    printf ("Float Values:\n");
    printf (" decimal  : %d\n fraction : %f\n\n", dec, ffrc);
    char *fstring = fpfrc_bin (fvalue);
    char *bs = binstr ((unsigned long) dec);
    printf ("Binary Values:\n");
    printf (" decimal  : %s\n fraction : %s\n sign bit : %d\n\n", bs, fstring, signbit);
    int bias = (int) strlen (bs) - 1;
    int biasexp = 127 + bias;
    char *binexp = binstr ((unsigned long) biasexp);
    printf ("Normalization for biased exponent:\n");
    printf ("\n %s.%s  =>  %s.%s%s\n\n", bs, fstring, "1", (bs + 1), fstring);
    printf ("     exponent bias: %d\n unbiased exponent: 127\n", bias);
    printf (" __________________+____\n\n");
    printf ("   biased exponent: %3d\n   binary exponent: %s\n\n", biasexp, binexp);
    printf ("Conversion to 'hidden bit' format to form mantissa:\n\n");
    printf (" %s.%s%s  =>  %s%s\n\n", "1", (bs + 1), fstring, (bs + 1), fstring);
    char *ieee754str = form_ieee754SPstr (signbit, binexp, bs, fstring);
    printf ("IEEE-754 Single Precision Floating Point Representation (caclulated value)\n\n");
    show_ieee754str (ieee754str);
    printf ("IEEE-754 Single Precision Floating Point Representation (memory value)\n\n");
    show_ieee754 (fvalue);
    show_fltmem (fvalue);
    if (bs)
        free (bs);
    if (binexp)
        free (binexp);
    if (ieee754str)
        free (ieee754str);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16170545_16174167_1_21
16170545_16177022_1_11
Title: How do I return 0 using bitwise operations? 
----------------------------------------

int sign (int x) {
    int lowBit = x;
    lowBit |= lowBit >> 16;
    lowBit |= lowBit >> 8;
    lowBit |= lowBit >> 4;
    lowBit |= lowBit >> 2;
    lowBit |= lowBit >> 1;
    lowBit &= 1;
    int signBit = x & 0x80000000;
    signBit |= signBit >> 16;
    signBit |= signBit >> 8;
    signBit |= signBit >> 4;
    signBit |= signBit >> 2;
    signBit |= signBit >> 1;
    signBit &= 0xFFFFFFFE;
    return signBit | lowBit;
}
----------------------------------------

int sign (int x) {
    int y = x;
    y |= y >> 16;
    y |= y >> 8;
    y |= y >> 4;
    y &= 0xF;
    int sign = (x >> 31);
    sign = sign | (~(1 << y) & 0x1);
    return sign;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16179963_16180019_3_38
16179963_16180041_3_20
Title: Declaring Unknown Number of User Inputted Variables? 
----------------------------------------

int main () {
    double Num;
    double *a, *b, *c;
    double max, min;
    int i = 0;
    printf ("How many numbers? > ");
    scanf ("%lf", & Num);
    a = malloc (sizeof (double) * Num);
    b = malloc (sizeof (double) * Num);
    c = malloc (sizeof (double) * Num);
    if (!a || !b || !c) {
        printf ("Out of memory\n");
        exit (- 1);
    }
    printf ("OK, now please enter %lf floating point numbers > ", Num);
    while (i <= Num) {
        scanf ("%lf", & a [i]);
        scanf ("%lf", & b [i]);
    }
    free (a);
    free (b);
    free (c);
    exit (0);
}
----------------------------------------

int main () {
    int Num;
    double a, b, c;
    double max, min;
    int i = 0;
    printf ("How many numbers? > ");
    scanf ("%d", & Num);
    printf ("OK, now please enter %d floating point numbers >", Num);
    for (i = 0; i < Num; i++) {
        scanf ("%lf %lf %lf", & a, & b, & c);
        printf ("you entered: a=%lf, b=%lf, c=%lf\n", a, b, c);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
161873_162002_1_31
161873_162329_6_13
Title: "K & R Exercise: My Code Works But Feels Stinky; Advice for Cleanup?" 
----------------------------------------

void trim (char line [], char ret []) {
    int i = 0;
    while ((ret[i] = line[i]) != '\0')
        ++i;
    if (i == 1) {
        ret[0] = '\0';
        return;
    }
    for (; i >= 0; --i) {
        if ((ret[i] == ' ') || (ret[i] == '\t'))
            ret[i] = '\0';
        else if ((ret[i] != '\0') && (ret[i] != '\r') && (ret[i] != '\n'))
            break;
    }
    for (i = 0; i < MAXLINE - 1; ++i) {
        if (ret[i] == '\n')
            break;
        if (ret[i] == '\0') {
            ret[i] = '\n';
            ret[i + 1] = '\0';
            break;
        }
    }
}
----------------------------------------

void trim (char *line) {
    char *end = findEndOfString (line);
    for (end = end - 1; end >= line; end--) {
        if (isWhitespace (*end))
            *end = 0;
        else
            return;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16205588_16205853_7_24
16205588_16213018_5_30
Title: I get a segmentation fault when I try to check for blank lines? 
----------------------------------------

int main () {
    int i;
    char **str = malloc (ROW_SZ * sizeof (char *));
    for (i = 0; i < ROW_SZ; i++)
        str[i] = malloc (COL_SZ * sizeof (char));
    for (i = 0; i < ROW_SZ; i++)
        free (str[i]);
    free (str);
    return 0;
}
----------------------------------------

int main (void) {
    char inputString [200];
    size_t i, numLines = 0;
    FILE *in_file = fopen ("input.txt", "r");
    while (NULL != fgets (inputString, sizeof (inputString), in_file)) {
        if (strcmp (inputString, "\n") == 0) {
            fprintf (stderr, "Blank line.\n");
            exit (- 2);
        }
        ++numLines;
    }
    rewind (in_file);
    char **instruc = malloc (numLines * sizeof (char *));
    for (i = 0; i < numLines; ++i) {
        instruc[i] = malloc (sizeof (inputString));
        fgets (instruc [i], sizeof (inputString), in_file);
    }
    fclose (in_file);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16208198_16208384_2_16
16208198_16208479_5_18
Title: C programming why isnt my code working? 
----------------------------------------

int main () {
    int i, n, j, sum, factorial;
    printf ("Put a number:");
    scanf ("%d", & n);
    sum = 0;
    for (i = 1; i <= n; i++) {
        factorial = 1;
        for (j = 2; j <= i; j++) {
            factorial *= j;
        }
        sum += factorial;
    }
    printf ("\nSum=%d\n", sum);
    return 0;
}
----------------------------------------

int main (void) {
    int i, n, s;
    printf ("Put a number:");
    scanf ("%d", & n);
    s = 0;
    for (i = 1; i <= n; i++) {
        s += factorial (i);
    }
    printf ("\n Sum=%d", s);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16208198_16208384_2_16
16208198_16208497_13_24
Title: C programming why isnt my code working? 
----------------------------------------

int main () {
    int i, n, j, sum, factorial;
    printf ("Put a number:");
    scanf ("%d", & n);
    sum = 0;
    for (i = 1; i <= n; i++) {
        factorial = 1;
        for (j = 2; j <= i; j++) {
            factorial *= j;
        }
        sum += factorial;
    }
    printf ("\nSum=%d\n", sum);
    return 0;
}
----------------------------------------

int main (void) {
    int i, n, s = 0;
    printf ("Put a number:");
    scanf ("%d", & n);
    s = 0;
    for (i = 1; i <= n; i++)
        s += factorial (i);
    printf ("\n Sum=%d\n", s);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16208198_16208479_5_18
16208198_16208497_13_24
Title: C programming why isnt my code working? 
----------------------------------------

int main (void) {
    int i, n, s;
    printf ("Put a number:");
    scanf ("%d", & n);
    s = 0;
    for (i = 1; i <= n; i++) {
        s += factorial (i);
    }
    printf ("\n Sum=%d", s);
}
----------------------------------------

int main (void) {
    int i, n, s = 0;
    printf ("Put a number:");
    scanf ("%d", & n);
    s = 0;
    for (i = 1; i <= n; i++)
        s += factorial (i);
    printf ("\n Sum=%d\n", s);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16221776_16221817_1_12
16221776_16221859_3_13
Title: Why dividing two integers doesn't get a float? 
----------------------------------------

int main () {
    int a;
    float b, c, d;
    a = 750;
    b = a / 350.0;
    c = 750;
    d = c / 350;
    printf ("%.2f %.2f", b, d);
}
----------------------------------------

int main () {
    int a;
    float b, c, d;
    a = 750;
    b = a / 350.0f;
    c = 750;
    d = c / 350;
    printf ("%.2f %.2f", b, d);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16243046_16243290_3_18
16243046_16243384_5_41
Title: An Array of Pointers in C 
----------------------------------------

int main () {
    static int *toInvert [8];
    int i;
    for (i = 0; i < 8; i++) {
        int *intrplated = (int *) calloc (10, sizeof (int));
        toInvert[i] = intrplated;
    }
    int *tmpPtr = toInvert[3];
    printf ("*(TPointer + %d) : %d\n\n", 3, * (tmpPtr + 1));
    return 0;
}
----------------------------------------

int main () {
    int i, j;
    static int *toInvert [LIMIT];
    int *intrplated;
    for (i = 0; i < LIMIT; i++) {
        intrplated = malloc (sizeof (int) * 5);
        intrplated[0] = rand ();
        intrplated[1] = rand ();
        intrplated[2] = rand ();
        intrplated[3] = rand ();
        intrplated[4] = rand ();
        toInvert[i] = intrplated;
    }
    for (i = 0; i < LIMIT; i++) {
        printf ("Tpointer to toInvert[%d] contains::\t [", i);
        for (j = 0; j < 5; j++) {
            printf ("%d ", toInvert [i] [j]);
        }
        printf ("]\n");
    }
    putchar ('\n');
    for (j = 0; j < 5; j++) {
        printf ("%d ", toInvert [1] [j]);
    }
    putchar ('\n');
    for (i = 0; i < LIMIT; i++) {
        free (toInvert [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16270686_16270730_1_13
16270686_16270848_4_15
Title: Argument variables in C 
----------------------------------------

int sumv (int n, ... ) {
    va_list list;
    va_start (list, n);
    int sum = 0;
    while (n > 0) {
        sum += va_arg (list, int);
        n--;
    }
    va_end (list);
    return sum;
}
----------------------------------------

int sumv (int n, ... ) {
    va_list list;
    int sum = 0;
    va_start (list, n);
    while (n-- > 0)
        sum += va_arg (list, int);
    va_end (list);
    return sum;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16272904_16273521_14_51
16272904_16273752_27_40
Title: Finding all primes of a particular sequence 
----------------------------------------

int main (void) {
    int a, b, c, d, e, f;
    for (int i = 10001; i < 99999; i += 2) {
        if (!IsPrime (i))
            continue;
        if (!IsPrime (i +2))
            continue;
        if (!IsPrime (i +6))
            continue;
        if (!IsPrime (i +12))
            continue;
        if (!IsPrime (i +20))
            continue;
        if (!IsPrime (i +30))
            continue;
        if (IsPrime (i +4))
            continue;
        if (IsPrime (i +8))
            continue;
        if (IsPrime (i +10))
            continue;
        if (IsPrime (i +14))
            continue;
        if (IsPrime (i +16))
            continue;
        if (IsPrime (i +18))
            continue;
        if (IsPrime (i +22))
            continue;
        if (IsPrime (i +24))
            continue;
        if (IsPrime (i +26))
            continue;
        if (IsPrime (i +28))
            continue;
        a = i;
        b = i + 2;
        c = i + 6;
        d = i + 12;
        e = i + 20;
        f = i + 30;
        printf ("%i %i %i %i %i %i \n", a, b, c, d, e, f);
    }
}
----------------------------------------

int main (int argc, char **argv) {
    int cp [6] = {0};
    int x = 0;
    for (int i = 10001; i <= 99999; i += 2)
        if (isPrime (i)) {
            cp[x] = i;
            check (cp, x = next (x));
        }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16310326_16310943_4_20
16310326_16311378_50_62
Title: Write a program to find the sum of positive odd numbers and the product of positive even numbers less than or equal to 30 
----------------------------------------

int main (void) {
    int j, sum = 0;
    double product = 1;
    for (j = 1; j <= 30; j = j + 2) {
        sum = sum + j;
    }
    for (j = 2; j <= 30; j = j + 2) {
        product = product * j;
    }
    printf ("The sum of positive odd numbers is: %d\n", sum);
    printf ("The product of positive even numbers is: %e", product);
}
----------------------------------------

int main (void) {
    UNums n;
    UInt16 i;
    assert (sizeof (UInt32) == 4);
    assert (sizeof (UInt16) == 2);
    UNums_init (& n, 1);
    for (i = 2; i <= 30; i += 2)
        UNums_mul (&n, i);
    UNums_print (& n);
    UNum_drop (& n);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16316144_16317060_5_39
16316144_16317639_32_59
Title: Add space to a string 
----------------------------------------

int main (void) {
    int i = 0;
    char ch [40];
    memset (ch, '\0', 40);
    gets (ch);
    int diff = 40 - strlen (ch);
    int spaces = 0;
    while (i < strlen (ch)) {
        if (*(ch + i++) == ' ')
            spaces++;
    }
    char finalt [40];
    memset (finalt, '\0', 40);
    i = 0;
    diff /= spaces;
    i = 0;
    int j = 0;
    int k = 0;
    printf ("%d\n", diff);
    while (i < 40) {
        if (ch[i] == ' ') {
            while (k < diff) {
                finalt[j++] = ' ';
                k++;
            }
            k = 0;
        }
        else {
            finalt[j] = ch[i];
            j++;
        }
        i++;
    }
    printf ("%s\n", finalt);
    return 0;
}
----------------------------------------

int main (void) {
    int column, len, word_count;
    int i, spaces, between, remain;
    size_t count_char;
    char text [WIDTH + 1];
    char *p = text;
    printf ("Enter the width of the column: ");
    scanf ("%d%*c", & column);
    printf ("Enter a line of text: ");
    scanf ("%" str (WIDTH) "[^\n]", text);
    len = strlen (text);
    if (len > column || len > WIDTH) {
        fprintf (stderr, "too long text!\n");
        return -1;
    }
    ruler_print (WIDTH);
    word_count = count_word (text, &count_char);
    spaces = column - count_char;
    between = spaces / (word_count - 1);
    remain = spaces - (word_count - 1) * between;
    strtok (text, " ");
    for (i = 0; i < word_count - 1; ++i) {
        printf ("%s%*s", p, between + (remain ? 1 : 0), " ");
        if (remain)
            --remain;
        p = strtok (NULL, " ");
    }
    printf ("%s\n", p);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16327662_16327901_5_26
16327662_16328113_3_35
Title: How to grab some digits from a number? 
----------------------------------------

int main (void) {
    int64_t number = 2001000200030LL;
    char data [24];
    char digit [5] = {0}, *p;
    int len, r;
    len = sprintf (data, "%lld", number);
    p = data;
    r = len % 4;
    if (r) {
        strncpy (digit, p, r);
        printf ("%s\n", digit);
        len -= r;
        p += r;
    }
    while (len != 0) {
        strncpy (digit, p, 4);
        printf ("%s\n", digit);
        len -= 4;
        p += 4;
    }
    return 0;
}
----------------------------------------

int main (void) {
    long long number = 2001000200030LL;
    long long currentDigit = 1LL;
    while ((currentDigit * 10LL) < number)
        currentDigit *= 10LL;
    printf ("First digit = %lld\n", number / currentDigit);
    number %= currentDigit;
    while (currentDigit >= 10000LL) {
        long long nextFour;
        currentDigit /= 10000LL;
        nextFour = number / currentDigit;
        number %= currentDigit;
        printf ("Next four = %04lld\n", nextFour);
    }
    if (currentDigit > 1LL) {
        printf ("Remaining digits = ");
        for (currentDigit /= 10LL; currentDigit > 1LL; currentDigit /= 10LL) {
            printf ("%lld", (number / currentDigit) % 10LL);
        }
        printf ("%lld\n", number % 10LL);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16345974_16346067_1_12
16345974_16346870_10_33
Title: Displaying digits in forward direction in C? 
----------------------------------------

void print_digits (int n, int islast) {
    if (n >= 10) {
        print_digits (n / 10, 0);
    }
    if (islast) {
        printf ("Last ");
    }
    printf ("Digit: %d\n", n % 10);
}
----------------------------------------

void print_digits (int value) {
    struct digit *top = malloc (sizeof (*top));
    top->value = value % 10;
    top->next = NULL;
    value /= 10;
    while (value) {
        struct digit *p = malloc (sizeof (*p));
        p->value = value % 10;
        p->next = top;
        top = p;
        value /= 10;
    }
    while (top) {
        struct digit *p = top;
        top = top->next;
        printf (top ? "Digit: %d\n" : "Last Digit : %d\n", p -> value);
        free (p);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16350807_16350933_13_53
16350807_16351790_23_58
Title: What is the reason for error while returning a structure in this C program? 
----------------------------------------

int main (void) {
    DATES user [NUM], largerdate;
    int i;
    printf ("You will enter two dates, and the program will return the larger.\n");
    for (i = 0; i < NUM; i++) {
        do {
            printf ("\nPlease enter the month number %d, 1-12:\n ", i);
            scanf ("%d", & user [i].month);
            if (user[i].month < 1 || user[i].month > 12)
                printf ("I told you enter a number between 1-12 JERK!!\n");
        }
        while (user[i].month < 1 || user[i].month > 12);
        do {
            printf ("\nPlease enter the day number %d, 1-31:\n ", i);
            scanf ("%d", & user [i].day);
            if (user[i].day < 1 || user[i].day > 31)
                printf ("I told you enter a number between 1-31 JERK!!\n");
        }
        while (user[i].day < 1 || user[i].day > 31);
        do {
            printf ("\nPlease enter the year number %d,greater than one:\n ", i);
            scanf ("%d", & user [i].year);
            if (user[i].year < 1)
                printf ("I told you enter a number greater than 1 JERK!!\n");
        }
        while (user[i].year < 1);
        printf ("\nDate number %d entered is: %d/%d/%d.\n", i + 1, user [i].month, user [i].day, user [i].year);
    }
    largerdate = *larger (user);
    printf ("\n\nThe larger/later date is %d/%d/%d\n", largerdate.month, largerdate.day, \ largerdate.year);
    system ("pause");
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    DATES user [NUM];
    DATES *result = NULL;
    int i = 0;
    printf ("\nPlease Enter Two Dates, The program will evaluate and return the later date of the two dates passed to it\n\n");
    for (; i < NUM; i++) {
        printf ("For Date %d\n", i + 1);
        do {
            printf ("Please enter the month, 1-12:\t");
            scanf ("%d", & user [i].month);
        }
        while (user[i].month < 1 || user[i].month > 12);
        do {
            printf ("Please enter the day, 1-31:\t");
            scanf ("%d", & user [i].day);
        }
        while (user[i].day < 1 || user[i].day > 31);
        do {
            printf ("Please enter the year: \t");
            scanf ("%d)", & user [i].year);
        }
        while (user[i].year < 1);
        printf ("\nDate %d entered: %d/%d/%d.\n\n", i + 1, user [i].month, user [i].day, user [i].year);
    }
    if ((result = larger (user)) == NULL)
        printf ("The two dates passed, date1: %d/%d/%d and date2: %d/%d/%d are the same.\n", user[0].month, user[0].day, user[0].year, user[1].month, user[1].day, user[1].year);
    else
        printf ("%d/%d/%d is the later date of the two dates passed\n", result->month, result->day, result->year);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16350807_16350933_13_53
16350807_16371915_67_86
Title: What is the reason for error while returning a structure in this C program? 
----------------------------------------

int main (void) {
    DATES user [NUM], largerdate;
    int i;
    printf ("You will enter two dates, and the program will return the larger.\n");
    for (i = 0; i < NUM; i++) {
        do {
            printf ("\nPlease enter the month number %d, 1-12:\n ", i);
            scanf ("%d", & user [i].month);
            if (user[i].month < 1 || user[i].month > 12)
                printf ("I told you enter a number between 1-12 JERK!!\n");
        }
        while (user[i].month < 1 || user[i].month > 12);
        do {
            printf ("\nPlease enter the day number %d, 1-31:\n ", i);
            scanf ("%d", & user [i].day);
            if (user[i].day < 1 || user[i].day > 31)
                printf ("I told you enter a number between 1-31 JERK!!\n");
        }
        while (user[i].day < 1 || user[i].day > 31);
        do {
            printf ("\nPlease enter the year number %d,greater than one:\n ", i);
            scanf ("%d", & user [i].year);
            if (user[i].year < 1)
                printf ("I told you enter a number greater than 1 JERK!!\n");
        }
        while (user[i].year < 1);
        printf ("\nDate number %d entered is: %d/%d/%d.\n", i + 1, user [i].month, user [i].day, user [i].year);
    }
    largerdate = *larger (user);
    printf ("\n\nThe larger/later date is %d/%d/%d\n", largerdate.month, largerdate.day, \ largerdate.year);
    system ("pause");
    return 0;
}
----------------------------------------

int main (void) {
    Date user [NUM];
    printf ("Enter two dates, and the program will return the larger.\n");
    if (read_date (&user[0]) == 0 && read_date (&user[1]) == 0) {
        putchar ('\n');
        printf ("Date 1: %.4d-%.2d-%.2d\n", user [0].year, user [0].month, user [0].day);
        printf ("Date 2: %.4d-%.2d-%.2d\n", user [1].year, user [1].month, user [1].day);
        Date *p_later = larger (user);
        Date v_later = later_date (user[0], user[1]);
        printf ("\nThe later date is the %s (%d/%d/%d)\n", (p_later == & user [0]) ? "first" : "second", p_later -> month, p_later -> day, p_later -> year);
        printf ("Later Date: %.4d-%.2d-%.2d\n", v_later.year, v_later.month, v_later.day);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16350807_16350933_55_67
16350807_16351790_60_73
Title: What is the reason for error while returning a structure in this C program? 
----------------------------------------

DATES *larger (DATES *more) {
    int days0;
    int days1;
    days0 = (more[0].month * 31) + (more[0].day) + (more[0].year * 365);
    days1 = (more[1].month * 31) + (more[1].day) + (more[1].year * 365);
    if (days1 > days0)
        return more + 1;
    else
        return more;
}
----------------------------------------

DATES *larger (DATES more [NUM]) {
    int days0, days1;
    days0 = (more[0].month * 31) + (more[0].day) + (more[0].year * 365);
    days1 = (more[1].month * 31) + (more[1].day) + (more[1].year * 365);
    if (days0 > days1)
        return more;
    else if (days1 > days0)
        return more + 1;
    else
        return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16350807_16351790_23_58
16350807_16371915_67_86
Title: What is the reason for error while returning a structure in this C program? 
----------------------------------------

int main (int argc, char *argv []) {
    DATES user [NUM];
    DATES *result = NULL;
    int i = 0;
    printf ("\nPlease Enter Two Dates, The program will evaluate and return the later date of the two dates passed to it\n\n");
    for (; i < NUM; i++) {
        printf ("For Date %d\n", i + 1);
        do {
            printf ("Please enter the month, 1-12:\t");
            scanf ("%d", & user [i].month);
        }
        while (user[i].month < 1 || user[i].month > 12);
        do {
            printf ("Please enter the day, 1-31:\t");
            scanf ("%d", & user [i].day);
        }
        while (user[i].day < 1 || user[i].day > 31);
        do {
            printf ("Please enter the year: \t");
            scanf ("%d)", & user [i].year);
        }
        while (user[i].year < 1);
        printf ("\nDate %d entered: %d/%d/%d.\n\n", i + 1, user [i].month, user [i].day, user [i].year);
    }
    if ((result = larger (user)) == NULL)
        printf ("The two dates passed, date1: %d/%d/%d and date2: %d/%d/%d are the same.\n", user[0].month, user[0].day, user[0].year, user[1].month, user[1].day, user[1].year);
    else
        printf ("%d/%d/%d is the later date of the two dates passed\n", result->month, result->day, result->year);
    return 0;
}
----------------------------------------

int main (void) {
    Date user [NUM];
    printf ("Enter two dates, and the program will return the larger.\n");
    if (read_date (&user[0]) == 0 && read_date (&user[1]) == 0) {
        putchar ('\n');
        printf ("Date 1: %.4d-%.2d-%.2d\n", user [0].year, user [0].month, user [0].day);
        printf ("Date 2: %.4d-%.2d-%.2d\n", user [1].year, user [1].month, user [1].day);
        Date *p_later = larger (user);
        Date v_later = later_date (user[0], user[1]);
        printf ("\nThe later date is the %s (%d/%d/%d)\n", (p_later == & user [0]) ? "first" : "second", p_later -> month, p_later -> day, p_later -> year);
        printf ("Later Date: %.4d-%.2d-%.2d\n", v_later.year, v_later.month, v_later.day);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16363042_16363788_1_32
16363042_16378017_1_11
Title: Arduino Motor speed LED (Led Bar Graph code) 
----------------------------------------

void LedBar () {
    if (on == 1) {
        if (potValue < M2) {
        }
        else if (potValue > M2 && potValue < M3) {
        }
        else if (potValue > M3 && potValue < M4) {
        }
    }
    else {
        digitalWrite (2, LOW);
        digitalWrite (3, LOW);
        digitalWrite (4, LOW);
        digitalWrite (5, LOW);
        digitalWrite (6, LOW);
        digitalWrite (7, LOW);
        digitalWrite (8, LOW);
        digitalWrite (9, LOW);
        digitalWrite (10, LOW);
    }
}
----------------------------------------

void LedBar () {
    int potValue = analogRead (potPin) / 4;
    if (on == 1)
        for (int i = 0; i <= 8; i++)
            if (potValue > M[i])
                digitalWrite (i +2, HIGH);
            else
                for (int i = 0; i <= 8; i++)
                    digitalWrite (M[i + 2], LOW);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16369861_16369893_1_10
16369861_16369945_1_14
Title: Queue of linked list C programming 
----------------------------------------

void delQueue () {
    while (rear != NULL) {
        struct Node *var = rear->next;
        free (rear);
        count = count + 1;
        rear = var;
    }
    front = NULL;
}
----------------------------------------

int delQueue () {
    int count = 0;
    while (front != NULL) {
        struct Node *temp = front;
        front = front->next;
        free (temp);
        count++;
    }
    rear = NULL;
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16386993_16396567_4_54
16386993_16402547_6_48
Title: MaxMin matrices composition 
----------------------------------------

int main (int argc, char **argv) {
    int i;
    int j;
    float firstMatrix [4] [4] = {{1, 0.6, 0.3, 0.8}, {0.6, 1, 0.1, 0.4}, {0.3, 0.1, 1, 0.5}, {0.8, 0.4, 0.5, 1}};
    float max = 0.0;
    float temp_array_1 [4];
    float temp_array_2 [4];
    float min_array [4];
    for (i = 0; i < 4; i++) {
        temp_array_1[i] = firstMatrix[0][i];
        temp_array_2[i] = firstMatrix[i][0];
    }
    for (i = 0; i < 4; i++) {
        if (temp_array_1[i] <= temp_array_2[i]) {
            min_array[i] = temp_array_1[i];
        }
        else {
            min_array[i] = temp_array_2[i];
        }
        for (i = 0; i < 4; i++) {
            if (min_array[i] > max) {
                max = min_array[i];
            }
        }
    }
    fprintf (stdout, "\nMax element: %.1f\n", max);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    int i;
    int j;
    int k;
    float firstMatrix [4] [4] = {{1, 0.6, 0.3, 0.8}, {0.6, 1, 0.1, 0.4}, {0.3, 0.1, 1, 0.5}, {0.8, 0.4, 0.5, 1}};
    float resultMatrix [4] [4];
    float min_array [4];
    for (i = 0; i < 4; i++) {
        for (j = 0; j < 4; j++) {
            for (k = 0; k < 4; k++) {
                if (firstMatrix[i][k] <= firstMatrix[k][j]) {
                    min_array[k] = firstMatrix[i][k];
                }
                else {
                    min_array[k] = firstMatrix[k][j];
                }
                resultMatrix[i][j] = get_max (min_array, 4);
            }
            fprintf (stdout, "%.1f ", resultMatrix [i] [j]);
        }
        fprintf (stdout, "\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16392894_16392996_3_19
16392894_16394428_3_25
Title: Character Counting in a String - C program 
----------------------------------------

int main (void) {
    char str [] = "ABCAPPPRC";
    int counts [256] = {0};
    puts (str);
    for (char *ptr = str; *ptr != '\0'; ptr++)
        counts[(unsigned char) *ptr]++;
    for (int i = 0; i < 256; i++) {
        if (counts[i] != 0)
            printf ("%c%d", i, counts[i]);
    }
    putchar ('\n');
    return (0);
}
----------------------------------------

int main (void) {
    const char noncountchar = '\x11';
    char str [30] = "ABCAPPPRC";
    char strOutPut [60] = "";
    char *ptr, *ptr2;
    char ch;
    int count = 0, len = 0;
    puts (str);
    for (ptr = str; ch = *ptr; ++ptr) {
        if (ch == noncountchar)
            continue;
        count = 1;
        for (ptr2 = ptr + 1; *ptr2; ++ptr2) {
            if (*ptr2 == ch) {
                *ptr2 = noncountchar;
                ++count;
            }
        }
        len += sprintf (strOutPut +len, "%c%d", *ptr, count);
    }
    printf ("%s", strOutPut);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16398907_16399523_1_29
16398907_16399575_13_46
Title: Performing actions on command line arguments in C 
----------------------------------------

int main (int argc, char *argv []) {
    char *copies [argc - 1];
    for (int i = 1; i < argc; i++) {
        size_t p = strcspn (argv[i], "0123456789");
        int n = argv[i][p] ? argv[i][p] - '0' : i;
        if (n == 0)
            n = 10;
        char *copyee = argv[n];
        size_t l = strlen (copyee);
        copies[i - 1] = malloc (l +1);
        char *copy = copies[i - 1];
        for (; *copyee; copyee++) {
            if (isalpha (*copyee)) {
                *copy++ = *copyee;
            }
        }
        *copy = 0;
    }
    for (int i = 0; i < argc - 1; i++) {
        printf ("%s ", copies [i]);
        free (copies [i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    struct inputcmd icmd [10] = {0};
    char *newargv [10];
    int i;
    char *p, *s;
    if (argc != 11) {
        printf ("You should input 10 commands\n");
        return;
    }
    for (i = 1; i < 11; i++) {
        icmd[i - 1].cmd = calloc (strlen (argv[i]) + 1, sizeof (char));
        p = argv[i];
        s = icmd[i - 1].cmd;
        while (*p) {
            if (isalpha (*p))
                *s++ = *p;
            else if ((*p >= '0' && *p <= '9') && icmd[i - 1].index == 0) {
                if (*p == '0')
                    icmd[i - 1].index = 10;
                else
                    icmd[i - 1].index = *p - '0';
            }
            p++;
        }
    }
    for (i = 0; i < 10; i++) {
        if (icmd[i].index)
            newargv[i] = strdup (icmd[icmd[i].index - 1].cmd);
        else
            newargv[i] = strdup (icmd[i].cmd);
    }
    for (i = 0; i < 10; i++) {
        free (icmd [i].cmd);
    }
    for (i = 0; i < 10; i++) {
        printf ("%s ", newargv [i]);
    }
    printf ("\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16398907_16399523_1_29
16398907_16399598_6_54
Title: Performing actions on command line arguments in C 
----------------------------------------

int main (int argc, char *argv []) {
    char *copies [argc - 1];
    for (int i = 1; i < argc; i++) {
        size_t p = strcspn (argv[i], "0123456789");
        int n = argv[i][p] ? argv[i][p] - '0' : i;
        if (n == 0)
            n = 10;
        char *copyee = argv[n];
        size_t l = strlen (copyee);
        copies[i - 1] = malloc (l +1);
        char *copy = copies[i - 1];
        for (; *copyee; copyee++) {
            if (isalpha (*copyee)) {
                *copy++ = *copyee;
            }
        }
        *copy = 0;
    }
    for (int i = 0; i < argc - 1; i++) {
        printf ("%s ", copies [i]);
        free (copies [i]);
    }
    printf ("\n");
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    char **original = argv + 1;
    char *messages [10] = {0};
    if (argc != 11) {
        printf ("We expect 10 arguments.\n");
        return -1;
    }
    for (int i = 0; i < 10; ++i)
        messages[i] = calloc (sizeof (char), strlen (original[i]) + 1);
    for (int i = 0; i < 10; ++i) {
        int head = 0;
        int tail = 0;
        while (original[i][tail] != '\0') {
            if (isalpha (original[i][tail])) {
                messages[i][head] = original[i][tail];
                head++;
                tail++;
            }
            else {
                tail++;
            }
        }
    }
    for (int i = 0; i < 10; ++i) {
        char *pos = strpbrk (original[i], "0123456789");
        if (pos == NULL) {
            printf ("%s ", messages [i]);
        }
        else {
            int index = *pos - '0';
            if (index == 0)
                index = 10;
            printf ("%s ", messages [index - 1]);
        }
    }
    for (int i = 0; i < 10; ++i)
        free (messages[i]);
    printf ("\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16398907_16399575_13_46
16398907_16399598_6_54
Title: Performing actions on command line arguments in C 
----------------------------------------

int main (int argc, char *argv []) {
    struct inputcmd icmd [10] = {0};
    char *newargv [10];
    int i;
    char *p, *s;
    if (argc != 11) {
        printf ("You should input 10 commands\n");
        return;
    }
    for (i = 1; i < 11; i++) {
        icmd[i - 1].cmd = calloc (strlen (argv[i]) + 1, sizeof (char));
        p = argv[i];
        s = icmd[i - 1].cmd;
        while (*p) {
            if (isalpha (*p))
                *s++ = *p;
            else if ((*p >= '0' && *p <= '9') && icmd[i - 1].index == 0) {
                if (*p == '0')
                    icmd[i - 1].index = 10;
                else
                    icmd[i - 1].index = *p - '0';
            }
            p++;
        }
    }
    for (i = 0; i < 10; i++) {
        if (icmd[i].index)
            newargv[i] = strdup (icmd[icmd[i].index - 1].cmd);
        else
            newargv[i] = strdup (icmd[i].cmd);
    }
    for (i = 0; i < 10; i++) {
        free (icmd [i].cmd);
    }
    for (i = 0; i < 10; i++) {
        printf ("%s ", newargv [i]);
    }
    printf ("\n");
}
----------------------------------------

int main (int argc, char **argv) {
    char **original = argv + 1;
    char *messages [10] = {0};
    if (argc != 11) {
        printf ("We expect 10 arguments.\n");
        return -1;
    }
    for (int i = 0; i < 10; ++i)
        messages[i] = calloc (sizeof (char), strlen (original[i]) + 1);
    for (int i = 0; i < 10; ++i) {
        int head = 0;
        int tail = 0;
        while (original[i][tail] != '\0') {
            if (isalpha (original[i][tail])) {
                messages[i][head] = original[i][tail];
                head++;
                tail++;
            }
            else {
                tail++;
            }
        }
    }
    for (int i = 0; i < 10; ++i) {
        char *pos = strpbrk (original[i], "0123456789");
        if (pos == NULL) {
            printf ("%s ", messages [i]);
        }
        else {
            int index = *pos - '0';
            if (index == 0)
                index = 10;
            printf ("%s ", messages [index - 1]);
        }
    }
    for (int i = 0; i < 10; ++i)
        free (messages[i]);
    printf ("\n");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16411171_16411410_1_20
16411171_16417167_14_26
Title: Function not properly reading data into array 
----------------------------------------

int getData (FILE *fpIn, char nom [] [LEN], float diffFactor [], float scores [] [5]) {
    int i = 0;
    int j;
    int tempCh;
    while (i < MAX && fscanf (fpIn, "%c", &nom[i][0]) != EOF) {
        j = 1;
        while (j < LEN && (tempCh = fgetc (fpIn)) != EOF) {
            if (tempCh != '\n') {
                nom[i][j] = tempCh;
                j++;
            }
            else
                break;
        }
        i++;
    }
    return i;
}
----------------------------------------

int getData (FILE *fpIn, char nom [] [LEN], float diffFactor [], float scores [] [5]) {
    char buff [LEN];
    int i = 0;
    while (i < MAX && EOF != fscanf (fpIn, "%[^0-9]%f %f %f %f %f %f", buff, &diffFactor[i], &scores[i][0], &scores[i][1], &scores[i][2], &scores[i][3], &scores[i][4])) {
        strcpy (nom [i], trimEnd (buff));
        i++;
    }
    return i;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1642211_1642238_5_24
1642211_1642319_8_29
Title: "changing a program in c so it takes an optional command line argument *infile*" 
----------------------------------------

int main (int argc, char *argv []) {
    int fileno;
    if (argc > 1) {
        fileno = open (argv[1], O_RDONLY);
        if (fileno < 0) {
            printf ("Unable to open file, aborting\n");
            return 1;
        }
    }
    else
        fileno = STDIN_FILENO;
}
----------------------------------------

int main (int argc, char *argv []) {
    int file_handle;
    int dup2_res;
    if (argc == 2) {
        file_handle = open (argv[1], O_RDONLY);
        dup2_res = dup2 (file_handle, STDIN_FILENO);
    }
    char buffer [100];
    ssize_t read_bytes = 1;
    while (read_bytes) {
        read_bytes = read (STDIN_FILENO, &buffer, sizeof (buffer));
        buffer[read_bytes] = 0;
        printf ("%s", buffer);
    }
    close (file_handle);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16425148_16425207_3_15
16425148_46996629_4_15
Title: C fopen call with variable name? 
----------------------------------------

int main () {
    char *a = "a";
    char *extension = ".txt";
    char fileSpec [strlen (a) + strlen (extension) + 1];
    FILE *out;
    snprintf (fileSpec, sizeof (fileSpec), "%s%s", a, extension);
    out = fopen (fileSpec, "w");
    fclose (out);
    return 0;
}
----------------------------------------

void main () {
    FILE *fs;
    char c [] = "Dayum.csv";
    fs = fopen (("%s", c), "a");
    if (fs == NULL)
        printf ("Couldn't open file\n");
    for (int i = 0; i < 5; i++)
        for (int j = 0; j < 5; j++)
            fprintf (fs, "%lf,%lf\n", i, j);
    fclose (fs);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
16443780_16444099_24_44
16443780_16444218_4_18
Title: how to return a char array from a function in C 
----------------------------------------

char *substring (int i, int j, char *ch) {
    int k = 0;
    int n = j - i + 1;
    char *ch1;
    ch1 = malloc (n * sizeof (char));
    while (k < n) {
        ch1[k] = ch[i];
        i++;
        k++;
    }
    return ch1;
}
----------------------------------------

char *substring (int i, int j, char *ch) {
    int n, k = 0;
    char *ch1;
    ch1 = (char *) malloc ((j - i + 1) * 1);
    n = j - i + 1;
    while (k < n) {
        ch1[k] = ch[i];
        i++;
        k++;
    }
    return (char *) ch1;
}
----------------------------------------
