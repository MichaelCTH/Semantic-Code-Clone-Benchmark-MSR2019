$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25861963_25862051_1_15
25861963_25862102_2_14
Title: Inputting variables until a negative number is entered 
----------------------------------------

int main (void) {
    int i = 0, sum = 0;
    do {
        sum += i;
        printf ("Please enter a number i. When finished, enter a negative number. ");
        scanf ("%i", & i);
    }
    while (i > -1);
    printf ("Sum = %d", sum);
    return 0;
}
----------------------------------------

int main () {
    int i = 0, sum = 0;
    while (true) {
        scanf ("%d", & i);
        if (i < 0)
            break;
        sum += i;
    }
    printf ("%d\n", sum);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25863184_25863276_4_29
25863184_25865545_4_18
Title: Confused with this C code 
----------------------------------------

int main () {
    int a, b, c, largest, large, small;
    printf ("Enter a b and c: ");
    scanf ("%d%d%d", & a, & b, & c);
    if (a * a + b * b == c * c) {
        printf ("yes");
    }
    else if ((a * a + c * c) == b * b) {
        printf ("yes");
    }
    else if ((c * c + b * b) == a * a) {
        printf ("yes");
    }
    else {
        printf ("no");
    }
}
----------------------------------------

int main () {
    int a, b, c, largest, large, small;
    printf ("Enter a b and c: ");
    scanf ("%d%d%d", & a, & b, & c);
    if (a * a + b * b == c * c)
        printf ("yes");
    else if ((a * a + c * c) == b * b)
        printf ("yes");
    else if ((c * c + b * b) == a * a)
        printf ("yes");
    else
        printf ("no");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25863184_25863311_4_30
25863184_25865545_4_18
Title: Confused with this C code 
----------------------------------------

int main () {
    int a, b, c, largest, large, small;
    printf ("Enter a b and c: ");
    scanf ("%d%d%d", & a, & b, & c);
    if (a * a + b * b == c * c) {
        printf ("yes");
    }
    else if ((a * a + c * c) == b * b) {
        printf ("yes");
    }
    else if ((c * c + b * b) == a * a) {
        printf ("yes");
    }
    else {
        printf ("no");
    }
}
----------------------------------------

int main () {
    int a, b, c, largest, large, small;
    printf ("Enter a b and c: ");
    scanf ("%d%d%d", & a, & b, & c);
    if (a * a + b * b == c * c)
        printf ("yes");
    else if ((a * a + c * c) == b * b)
        printf ("yes");
    else if ((c * c + b * b) == a * a)
        printf ("yes");
    else
        printf ("no");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25874042_25874277_1_13
25874042_25874411_1_13
Title: Using arrays to make a study room reservation program 
----------------------------------------

int search_arr (int room [], int elements, int open) {
    int free = 0;
    int i;
    for (i = 0; i < elements; i++) {
        if (room[i] == open) {
            printf ("Vacant Room number: %d \n", i);
            free++;
        }
    }
    return (free);
}
----------------------------------------

int search_arr (int room [], int elements, int open) {
    int i;
    for (i = 0; i < elements; i++) {
        if (room[i] == 0) {
            printf ("Vacant Room No: %d \n", i);
            open++;
        }
    }
    if (open)
        return (open);
    return (-1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25876325_25876343_2_14
25876325_25878097_2_14
Title: Don't understand how to input/print and compare string in loop in C 
----------------------------------------

int main () {
    char word [80];
    while (1) {
        puts ("Enter a string: ");
        memset (word, 0, sizeof (word));
        fflush (stdout);
        if (scanf ("%79[^\n]", word) <= 0)
            exit (EXIT_FAILURE);
        if (!strcmp (word, "exit"))
            break;
        printf ("You have typed %s\n", word);
    }
    return 0;
}
----------------------------------------

int main () {
    char word [80];
    while (1) {
        puts ("Enter a string: ");
        if (scanf (" %79[^\n]", word) != 1)
            break;
        if (strcmp (word, "exit") == 0)
            break;
        printf ("You have typed %s\n", word);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2587940_2587968_1_11
2587940_2587978_4_13
Title: C String input confusion 
----------------------------------------

int main () {
    char input [10];
    char aData [10];
    char bData [10];
    fgets (input, sizeof input, stdin);
    strcpy (aData, input);
    fgets (input, sizeof input, stdin);
    strcpy (bData, input);
    printf ("%s : %s", aData, bData);
}
----------------------------------------

int main (void) {
    char input [10], a [10], b [10];
    fgets (input, sizeof input, stdin);
    strcpy (a, input);
    fgets (input, sizeof input, stdin);
    strcpy (b, input);
    printf ("%s : %s\n", a, b);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25881638_25882878_5_34
25881638_25896695_2_24
Title: "Finding Twin Primes - Have logic finished but it won't print anything when the program is ran" 
----------------------------------------

int isPrime (int n) {
    int stop = 0;
    int i = 0;
    if (n == 3) {
        return 1;
    }
    stop = (int) (sqrt (n));
    for (i = 3; i <= stop; i += 2) {
        if (n % i == 0) {
            return 0;
        }
    }
    return 1;
}
----------------------------------------

boolean isPrime (int aNumber) {
    int i;
    int limit;
    if (aNumber < 2) {
        return False;
    }
    if (aNumber % 2 == 0) {
        return aNumber == 2;
    }
    limit = (int) (sqrt (aNumber));
    for (i = 3; i <= limit; i += 2) {
        if (aNumber % i == 0) {
            return False;
        }
    }
    return True;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25885086_25885284_2_24
25885086_25886055_3_31
Title: "In nested if-else conditions control of C program not going further" 
----------------------------------------

int main () {
    int i, j, max1 = 0, max2 = 0;
    for (j = 0; j <= 10; j++) {
        scanf ("%d", & i);
        if (i == -1) {
            break;
        }
        else if (i >= max1) {
            max2 = max1;
            max1 = i;
        }
        else if (i > max2) {
            max2 = i;
        }
    }
    printf ("%d\n", max2);
    return 0;
}
----------------------------------------

int main (void) {
    const int N = 10;
    int max1, max2;
    int value;
    int count;
    int i;
    count = 0;
    for (i = 0; i < N && scanf ("%d", &value) > 0 && value != -1; i++, count++) {
        if (count == 0 || max1 < value) {
            if (count != 0)
                max2 = max1;
            max1 = value;
        }
        else if (count == 1 || max2 < value) {
            max2 = value;
        }
    }
    if (count >= 2)
        printf ("The second maximum is equal to %d\n", max2);
    else
        printf ("You have to enter more than one number\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25890798_25891065_1_26
25890798_25891267_1_18
Title: unable to display the entire link list only displays the last element in link list in c 
----------------------------------------

struct node *create (struct node *head, int value) {
    struct node *temp;
    if (head == NULL) {
        head = (struct node *) malloc (sizeof (struct node));
        temp->data = value;
        temp->next = NULL;
    }
    else {
        temp = head;
        while (temp->next != NULL)
            temp = temp->next;
        temp->next = (struct node *) malloc (sizeof (struct node));
        if (temp->next != NULL) {
            temp = temp->link;
            temp->data = value;
            temp->next = NULL;
        }
    }
    return head;
}
----------------------------------------

struct node *create (struct node *element, int data) {
    if (element) {
        while (element->next) {
            element = element->next;
        }
        element->next = malloc (sizeof (struct node));
        element = element->next;
    }
    else {
        element = malloc (sizeof (struct node));
    }
    element->data = data;
    return element;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903493_1_19
25903176_25903944_1_25
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *result;
    if (arrayLength > 0) {
        result = (int *) malloc ((sizeof (int) * arrayLength));
        memcpy (result, array, sizeof (int) * arrayLength);
        reverse (result, - arrayLength);
        return result;
    }
    else if (arrayLength < -1) {
        int end = (-arrayLength) - 1;
        int temp = array[end];
        array[end] = array[0];
        array[0] = temp;
        return reverse (array +1, arrayLength +2);
    }
    return array;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *newArray = NULL;
    if (arrayLength == 1) {
        newArray = (int *) malloc (sizeof (int));
        *newArray = array[0];
    }
    else if (arrayLength == 2) {
        newArray = (int *) malloc (2 * sizeof (int));
        newArray[0] = array[1];
        newArray[1] = array[0];
    }
    else {
        int *first = reverse (array, arrayLength / 2);
        int *second = reverse (array +arrayLength / 2, arrayLength / 2);
        newArray = (int *) malloc (arrayLength * sizeof (int));
        memcpy (newArray, second, arrayLength / 2 * sizeof (int));
        memcpy (newArray + arrayLength / 2, first, arrayLength / 2 * sizeof (int));
        free (first);
        free (second);
    }
    return newArray;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903493_1_19
25903176_25903969_4_44
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *result;
    if (arrayLength > 0) {
        result = (int *) malloc ((sizeof (int) * arrayLength));
        memcpy (result, array, sizeof (int) * arrayLength);
        reverse (result, - arrayLength);
        return result;
    }
    else if (arrayLength < -1) {
        int end = (-arrayLength) - 1;
        int temp = array[end];
        array[end] = array[0];
        array[0] = temp;
        return reverse (array +1, arrayLength +2);
    }
    return array;
}
----------------------------------------

int *reverse (int *arr, int length) {
    if (length == 1) {
        int *result = malloc (sizeof (arr[0]));
        result[0] = arr[0];
        return result;
    }
    int *result = 0;
    if (length == 2) {
        result = malloc (sizeof (arr[0]) * 2);
        result[0] = arr[1];
        result[1] = arr[0];
    }
    else {
        int half_length = length / 2;
        int *right = reverse (arr, half_length);
        int *left = reverse (arr +half_length, half_length);
        result = malloc (sizeof (arr[0]) * length);
        for (int i = 0; i < half_length; ++i) {
            result[i] = left[i];
            result[i + half_length] = right[i];
        }
        free (right);
        free (left);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903493_1_19
25903176_25904483_1_13
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *result;
    if (arrayLength > 0) {
        result = (int *) malloc ((sizeof (int) * arrayLength));
        memcpy (result, array, sizeof (int) * arrayLength);
        reverse (result, - arrayLength);
        return result;
    }
    else if (arrayLength < -1) {
        int end = (-arrayLength) - 1;
        int temp = array[end];
        array[end] = array[0];
        array[0] = temp;
        return reverse (array +1, arrayLength +2);
    }
    return array;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (arrayLength == 1) {
        int *out = (int *) malloc (sizeof (int));
        out[0] = array[0];
        return out;
    }
    int *left = reverse (array +arrayLength / 2, arrayLength -arrayLength / 2);
    int *right = reverse (array, arrayLength / 2);
    int *out = (int *) realloc (left, sizeof (int) * arrayLength);
    memcpy (out + arrayLength / 2, right, sizeof (int) * (arrayLength / 2));
    free (right);
    return out;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903493_1_19
25903176_25915815_1_23
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *result;
    if (arrayLength > 0) {
        result = (int *) malloc ((sizeof (int) * arrayLength));
        memcpy (result, array, sizeof (int) * arrayLength);
        reverse (result, - arrayLength);
        return result;
    }
    else if (arrayLength < -1) {
        int end = (-arrayLength) - 1;
        int temp = array[end];
        array[end] = array[0];
        array[0] = temp;
        return reverse (array +1, arrayLength +2);
    }
    return array;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *a1, *a2;
    int *res;
    if (arrayLength > 1) {
        int l = arrayLength >> 1;
        a1 = reverse (array, l);
        a2 = reverse (array +l, l);
        res = calloc (arrayLength, sizeof (int));
        memcpy (res, a2, l * sizeof (int));
        memcpy (res + l, a1, l * sizeof (int));
        free (a1);
        free (a2);
    }
    else {
        res = malloc (sizeof (int));
        *res = array[0];
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903493_1_19
25903176_25916596_5_34
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *result;
    if (arrayLength > 0) {
        result = (int *) malloc ((sizeof (int) * arrayLength));
        memcpy (result, array, sizeof (int) * arrayLength);
        reverse (result, - arrayLength);
        return result;
    }
    else if (arrayLength < -1) {
        int end = (-arrayLength) - 1;
        int temp = array[end];
        array[end] = array[0];
        array[0] = temp;
        return reverse (array +1, arrayLength +2);
    }
    return array;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (array == NULL || arrayLength < 0) {
    }
    int *y = malloc (arrayLength * sizeof *y);
    if (y == NULL) {
    }
    if (arrayLength <= 1) {
        memcpy (y, array, arrayLength * sizeof * y);
        return y;
    }
    int halflength = arrayLength / 2;
    int *left = reverse (array, halflength);
    int *right = reverse (&array[halflength], halflength);
    memcpy (y, right, halflength * sizeof * y);
    memcpy (& y [halflength], left, halflength * sizeof * y);
    free (right);
    free (left);
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903944_1_25
25903176_25903969_4_44
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *newArray = NULL;
    if (arrayLength == 1) {
        newArray = (int *) malloc (sizeof (int));
        *newArray = array[0];
    }
    else if (arrayLength == 2) {
        newArray = (int *) malloc (2 * sizeof (int));
        newArray[0] = array[1];
        newArray[1] = array[0];
    }
    else {
        int *first = reverse (array, arrayLength / 2);
        int *second = reverse (array +arrayLength / 2, arrayLength / 2);
        newArray = (int *) malloc (arrayLength * sizeof (int));
        memcpy (newArray, second, arrayLength / 2 * sizeof (int));
        memcpy (newArray + arrayLength / 2, first, arrayLength / 2 * sizeof (int));
        free (first);
        free (second);
    }
    return newArray;
}
----------------------------------------

int *reverse (int *arr, int length) {
    if (length == 1) {
        int *result = malloc (sizeof (arr[0]));
        result[0] = arr[0];
        return result;
    }
    int *result = 0;
    if (length == 2) {
        result = malloc (sizeof (arr[0]) * 2);
        result[0] = arr[1];
        result[1] = arr[0];
    }
    else {
        int half_length = length / 2;
        int *right = reverse (arr, half_length);
        int *left = reverse (arr +half_length, half_length);
        result = malloc (sizeof (arr[0]) * length);
        for (int i = 0; i < half_length; ++i) {
            result[i] = left[i];
            result[i + half_length] = right[i];
        }
        free (right);
        free (left);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903944_1_25
25903176_25904483_1_13
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *newArray = NULL;
    if (arrayLength == 1) {
        newArray = (int *) malloc (sizeof (int));
        *newArray = array[0];
    }
    else if (arrayLength == 2) {
        newArray = (int *) malloc (2 * sizeof (int));
        newArray[0] = array[1];
        newArray[1] = array[0];
    }
    else {
        int *first = reverse (array, arrayLength / 2);
        int *second = reverse (array +arrayLength / 2, arrayLength / 2);
        newArray = (int *) malloc (arrayLength * sizeof (int));
        memcpy (newArray, second, arrayLength / 2 * sizeof (int));
        memcpy (newArray + arrayLength / 2, first, arrayLength / 2 * sizeof (int));
        free (first);
        free (second);
    }
    return newArray;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (arrayLength == 1) {
        int *out = (int *) malloc (sizeof (int));
        out[0] = array[0];
        return out;
    }
    int *left = reverse (array +arrayLength / 2, arrayLength -arrayLength / 2);
    int *right = reverse (array, arrayLength / 2);
    int *out = (int *) realloc (left, sizeof (int) * arrayLength);
    memcpy (out + arrayLength / 2, right, sizeof (int) * (arrayLength / 2));
    free (right);
    return out;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903944_1_25
25903176_25915815_1_23
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *newArray = NULL;
    if (arrayLength == 1) {
        newArray = (int *) malloc (sizeof (int));
        *newArray = array[0];
    }
    else if (arrayLength == 2) {
        newArray = (int *) malloc (2 * sizeof (int));
        newArray[0] = array[1];
        newArray[1] = array[0];
    }
    else {
        int *first = reverse (array, arrayLength / 2);
        int *second = reverse (array +arrayLength / 2, arrayLength / 2);
        newArray = (int *) malloc (arrayLength * sizeof (int));
        memcpy (newArray, second, arrayLength / 2 * sizeof (int));
        memcpy (newArray + arrayLength / 2, first, arrayLength / 2 * sizeof (int));
        free (first);
        free (second);
    }
    return newArray;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *a1, *a2;
    int *res;
    if (arrayLength > 1) {
        int l = arrayLength >> 1;
        a1 = reverse (array, l);
        a2 = reverse (array +l, l);
        res = calloc (arrayLength, sizeof (int));
        memcpy (res, a2, l * sizeof (int));
        memcpy (res + l, a1, l * sizeof (int));
        free (a1);
        free (a2);
    }
    else {
        res = malloc (sizeof (int));
        *res = array[0];
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903944_1_25
25903176_25916596_5_34
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *newArray = NULL;
    if (arrayLength == 1) {
        newArray = (int *) malloc (sizeof (int));
        *newArray = array[0];
    }
    else if (arrayLength == 2) {
        newArray = (int *) malloc (2 * sizeof (int));
        newArray[0] = array[1];
        newArray[1] = array[0];
    }
    else {
        int *first = reverse (array, arrayLength / 2);
        int *second = reverse (array +arrayLength / 2, arrayLength / 2);
        newArray = (int *) malloc (arrayLength * sizeof (int));
        memcpy (newArray, second, arrayLength / 2 * sizeof (int));
        memcpy (newArray + arrayLength / 2, first, arrayLength / 2 * sizeof (int));
        free (first);
        free (second);
    }
    return newArray;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (array == NULL || arrayLength < 0) {
    }
    int *y = malloc (arrayLength * sizeof *y);
    if (y == NULL) {
    }
    if (arrayLength <= 1) {
        memcpy (y, array, arrayLength * sizeof * y);
        return y;
    }
    int halflength = arrayLength / 2;
    int *left = reverse (array, halflength);
    int *right = reverse (&array[halflength], halflength);
    memcpy (y, right, halflength * sizeof * y);
    memcpy (& y [halflength], left, halflength * sizeof * y);
    free (right);
    free (left);
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903969_4_44
25903176_25904483_1_13
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *arr, int length) {
    if (length == 1) {
        int *result = malloc (sizeof (arr[0]));
        result[0] = arr[0];
        return result;
    }
    int *result = 0;
    if (length == 2) {
        result = malloc (sizeof (arr[0]) * 2);
        result[0] = arr[1];
        result[1] = arr[0];
    }
    else {
        int half_length = length / 2;
        int *right = reverse (arr, half_length);
        int *left = reverse (arr +half_length, half_length);
        result = malloc (sizeof (arr[0]) * length);
        for (int i = 0; i < half_length; ++i) {
            result[i] = left[i];
            result[i + half_length] = right[i];
        }
        free (right);
        free (left);
    }
    return result;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (arrayLength == 1) {
        int *out = (int *) malloc (sizeof (int));
        out[0] = array[0];
        return out;
    }
    int *left = reverse (array +arrayLength / 2, arrayLength -arrayLength / 2);
    int *right = reverse (array, arrayLength / 2);
    int *out = (int *) realloc (left, sizeof (int) * arrayLength);
    memcpy (out + arrayLength / 2, right, sizeof (int) * (arrayLength / 2));
    free (right);
    return out;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903969_4_44
25903176_25915815_1_23
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *arr, int length) {
    if (length == 1) {
        int *result = malloc (sizeof (arr[0]));
        result[0] = arr[0];
        return result;
    }
    int *result = 0;
    if (length == 2) {
        result = malloc (sizeof (arr[0]) * 2);
        result[0] = arr[1];
        result[1] = arr[0];
    }
    else {
        int half_length = length / 2;
        int *right = reverse (arr, half_length);
        int *left = reverse (arr +half_length, half_length);
        result = malloc (sizeof (arr[0]) * length);
        for (int i = 0; i < half_length; ++i) {
            result[i] = left[i];
            result[i + half_length] = right[i];
        }
        free (right);
        free (left);
    }
    return result;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *a1, *a2;
    int *res;
    if (arrayLength > 1) {
        int l = arrayLength >> 1;
        a1 = reverse (array, l);
        a2 = reverse (array +l, l);
        res = calloc (arrayLength, sizeof (int));
        memcpy (res, a2, l * sizeof (int));
        memcpy (res + l, a1, l * sizeof (int));
        free (a1);
        free (a2);
    }
    else {
        res = malloc (sizeof (int));
        *res = array[0];
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25903969_4_44
25903176_25916596_5_34
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *arr, int length) {
    if (length == 1) {
        int *result = malloc (sizeof (arr[0]));
        result[0] = arr[0];
        return result;
    }
    int *result = 0;
    if (length == 2) {
        result = malloc (sizeof (arr[0]) * 2);
        result[0] = arr[1];
        result[1] = arr[0];
    }
    else {
        int half_length = length / 2;
        int *right = reverse (arr, half_length);
        int *left = reverse (arr +half_length, half_length);
        result = malloc (sizeof (arr[0]) * length);
        for (int i = 0; i < half_length; ++i) {
            result[i] = left[i];
            result[i + half_length] = right[i];
        }
        free (right);
        free (left);
    }
    return result;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (array == NULL || arrayLength < 0) {
    }
    int *y = malloc (arrayLength * sizeof *y);
    if (y == NULL) {
    }
    if (arrayLength <= 1) {
        memcpy (y, array, arrayLength * sizeof * y);
        return y;
    }
    int halflength = arrayLength / 2;
    int *left = reverse (array, halflength);
    int *right = reverse (&array[halflength], halflength);
    memcpy (y, right, halflength * sizeof * y);
    memcpy (& y [halflength], left, halflength * sizeof * y);
    free (right);
    free (left);
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25904483_1_13
25903176_25915815_1_23
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (arrayLength == 1) {
        int *out = (int *) malloc (sizeof (int));
        out[0] = array[0];
        return out;
    }
    int *left = reverse (array +arrayLength / 2, arrayLength -arrayLength / 2);
    int *right = reverse (array, arrayLength / 2);
    int *out = (int *) realloc (left, sizeof (int) * arrayLength);
    memcpy (out + arrayLength / 2, right, sizeof (int) * (arrayLength / 2));
    free (right);
    return out;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *a1, *a2;
    int *res;
    if (arrayLength > 1) {
        int l = arrayLength >> 1;
        a1 = reverse (array, l);
        a2 = reverse (array +l, l);
        res = calloc (arrayLength, sizeof (int));
        memcpy (res, a2, l * sizeof (int));
        memcpy (res + l, a1, l * sizeof (int));
        free (a1);
        free (a2);
    }
    else {
        res = malloc (sizeof (int));
        *res = array[0];
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25904483_1_13
25903176_25916596_5_34
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (arrayLength == 1) {
        int *out = (int *) malloc (sizeof (int));
        out[0] = array[0];
        return out;
    }
    int *left = reverse (array +arrayLength / 2, arrayLength -arrayLength / 2);
    int *right = reverse (array, arrayLength / 2);
    int *out = (int *) realloc (left, sizeof (int) * arrayLength);
    memcpy (out + arrayLength / 2, right, sizeof (int) * (arrayLength / 2));
    free (right);
    return out;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (array == NULL || arrayLength < 0) {
    }
    int *y = malloc (arrayLength * sizeof *y);
    if (y == NULL) {
    }
    if (arrayLength <= 1) {
        memcpy (y, array, arrayLength * sizeof * y);
        return y;
    }
    int halflength = arrayLength / 2;
    int *left = reverse (array, halflength);
    int *right = reverse (&array[halflength], halflength);
    memcpy (y, right, halflength * sizeof * y);
    memcpy (& y [halflength], left, halflength * sizeof * y);
    free (right);
    free (left);
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25903176_25915815_1_23
25903176_25916596_5_34
Title: Reverse an integer array of length 2^n recursively and return a new array without modifying the original 
----------------------------------------

int *reverse (int *array, int arrayLength) {
    int *a1, *a2;
    int *res;
    if (arrayLength > 1) {
        int l = arrayLength >> 1;
        a1 = reverse (array, l);
        a2 = reverse (array +l, l);
        res = calloc (arrayLength, sizeof (int));
        memcpy (res, a2, l * sizeof (int));
        memcpy (res + l, a1, l * sizeof (int));
        free (a1);
        free (a2);
    }
    else {
        res = malloc (sizeof (int));
        *res = array[0];
    }
    return res;
}
----------------------------------------

int *reverse (int *array, int arrayLength) {
    if (array == NULL || arrayLength < 0) {
    }
    int *y = malloc (arrayLength * sizeof *y);
    if (y == NULL) {
    }
    if (arrayLength <= 1) {
        memcpy (y, array, arrayLength * sizeof * y);
        return y;
    }
    int halflength = arrayLength / 2;
    int *left = reverse (array, halflength);
    int *right = reverse (&array[halflength], halflength);
    memcpy (y, right, halflength * sizeof * y);
    memcpy (& y [halflength], left, halflength * sizeof * y);
    free (right);
    free (left);
    return y;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2591373_2591378_3_13
2591373_2596642_2_22
Title: Elapsed time of running a C program 
----------------------------------------

int main () {
    clock_t start;
    clock_t end;
    int function_time;
    start = clock ();
    function_you_want_to_time ();
    end = clock ();
    function_time = (double) (end - start) / (CLOCKS_PER_SEC / 1000.0);
    return 0;
}
----------------------------------------

int main (void) {
    LARGE_INTEGER freq;
    LARGE_INTEGER t0, tF, tDiff;
    double elapsedTime;
    double resolution;
    QueryPerformanceFrequency (& freq);
    QueryPerformanceCounter (& t0);
    {
        Sleep (10);
    }
    QueryPerformanceCounter (& tF);
    tDiff.QuadPart = tF.QuadPart - t0.QuadPart;
    elapsedTime = tDiff.QuadPart / (double) freq.QuadPart;
    resolution = 1.0 / (double) freq.QuadPart;
    printf ("Your performance counter ticks %I64u times per second\n", freq.QuadPart);
    printf ("Resolution is %lf nanoseconds\n", resolution * 1e9);
    printf ("Code under test took %lf sec\n", elapsedTime);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25925250_25927456_3_17
25925250_25927558_3_19
Title: Use cat output in another program with pipe in C 
----------------------------------------

int main () {
    int i, num;
    unsigned char block [2];
    while ((num = fread (block, 1, 2, stdin)) == 2) {
        for (i = 0; i < 2; i++) {
            printf ("%02x", block [i]);
        }
    }
}
----------------------------------------

int main (void) {
    if (!freopen (NULL, "rb", stdin)) {
        return 1;
    }
    if (!freopen (NULL, "wb", stdout)) {
        return 1;
    }
    char buf [4];
    while (!feof (stdin)) {
        size_t numbytes = fread (buf, 1, 4, stdin);
        fwrite (buf, 1, numbytes, stdout);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2592893_2592914_1_18
2592893_2592964_1_12
Title: "Problem with C function of type char pointer can someone explain?" 
----------------------------------------

char *f (int i) {
    char buffer [20];
    switch (i) {
    case 1 :
        strcpy (buffer, "string1");
        break;
    case 2 :
        strcpy (buffer, "string2");
        break;
    case 3 :
        strcpy (buffer, "string3");
        break;
    default :
        strcpy (buffer, "defaultstring");
        break;
    }
    return buffer;
}
----------------------------------------

char *f (int i) {
    switch (i) {
    case 1 :
        return strdup ("string1");
    case 2 :
        return strdup ("string2");
    case 3 :
        return strdup ("string3");
    default :
        return strdup ("defaultstring");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2592893_2592914_1_18
2592893_2593007_1_10
Title: "Problem with C function of type char pointer can someone explain?" 
----------------------------------------

char *f (int i) {
    char buffer [20];
    switch (i) {
    case 1 :
        strcpy (buffer, "string1");
        break;
    case 2 :
        strcpy (buffer, "string2");
        break;
    case 3 :
        strcpy (buffer, "string3");
        break;
    default :
        strcpy (buffer, "defaultstring");
        break;
    }
    return buffer;
}
----------------------------------------

char *f (int i) {
    char buffer [20];
    switch (i) {
    case 1 :
        return "string1";
    case 2 :
        return "string2";
    case 3 :
        return "string3";
    default :
        return "defaultstring";
    }
    return buffer;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2592893_2592964_1_12
2592893_2593007_1_10
Title: "Problem with C function of type char pointer can someone explain?" 
----------------------------------------

char *f (int i) {
    switch (i) {
    case 1 :
        return strdup ("string1");
    case 2 :
        return strdup ("string2");
    case 3 :
        return strdup ("string3");
    default :
        return strdup ("defaultstring");
    }
}
----------------------------------------

char *f (int i) {
    char buffer [20];
    switch (i) {
    case 1 :
        return "string1";
    case 2 :
        return "string2";
    case 3 :
        return "string3";
    default :
        return "defaultstring";
    }
    return buffer;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25956771_25957047_3_27
25956771_25957190_2_17
Title: Loop runs infinite times 
----------------------------------------

int main (void) {
    const int Base = 10;
    int i;
    for (i = 1; i <= 100; i++) {
        int x = i;
        int n = 1;
        while (x / (n * Base) != 0)
            n *= Base;
        do {
            printf ("%d ", x / n);
            x %= n;
            n /= Base;
        }
        while (n != 0);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    int i;
    int j;
    for (i = 1; i <= 100; i++) {
        j = i;
        while (j > 0) {
            printf ("digit=>%d\n", j % 10);
            j /= 10;
        }
    }
    printf ("\n");
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2597608_2597774_1_45
2597608_35658278_15_94
Title: C: socket connection timeout 
----------------------------------------

int main (int argc, char **argv) {
    u_short port;
    char *addr;
    struct sockaddr_in address;
    short int sock = -1;
    fd_set fdset;
    struct timeval tv;
    if (argc != 3) {
        fprintf (stderr, "Usage %s <port_num> <address>\n", argv [0]);
        return EXIT_FAILURE;
    }
    port = atoi (argv[1]);
    addr = argv[2];
    address.sin_family = AF_INET;
    address.sin_addr.s_addr = inet_addr (addr);
    address.sin_port = htons (port);
    sock = socket (AF_INET, SOCK_STREAM, 0);
    fcntl (sock, F_SETFL, O_NONBLOCK);
    connect (sock, (struct sockaddr *) & address, sizeof (address));
    FD_ZERO (& fdset);
    FD_SET (sock, & fdset);
    tv.tv_sec = 10;
    tv.tv_usec = 0;
    if (select (sock +1, NULL, &fdset, NULL, &tv) == 1) {
        int so_error;
        socklen_t len = sizeof so_error;
        getsockopt (sock, SOL_SOCKET, SO_ERROR, & so_error, & len);
        if (so_error == 0) {
            printf ("%s:%d is open\n", addr, port);
        }
    }
    close (sock);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    struct sockaddr_in addr_s;
    char *addr;
    short int fd = -1;
    int port;
    fd_set fdset;
    struct timeval tv;
    int rc;
    int so_error;
    socklen_t len;
    struct timespec tstart = {0, 0}, tend = {0, 0};
    int seconds;
    if (argc != 4) {
        fprintf (stderr, "Usage: %s <ip> <port> <timeout_seconds>\n", argv [0]);
        return 1;
    }
    addr = argv[1];
    port = atoi (argv[2]);
    seconds = atoi (argv[3]);
    addr_s.sin_family = AF_INET;
    addr_s.sin_addr.s_addr = inet_addr (addr);
    addr_s.sin_port = htons (port);
    clock_gettime (CLOCK_MONOTONIC, & tstart);
    fd = socket (AF_INET, SOCK_STREAM, 0);
    fcntl (fd, F_SETFL, O_NONBLOCK);
    rc = connect (fd, (struct sockaddr *) &addr_s, sizeof (addr_s));
    if ((rc == -1) && (errno != EINPROGRESS)) {
        fprintf (stderr, "Error: %s\n", strerror (errno));
        close (fd);
        return 1;
    }
    if (rc == 0) {
        clock_gettime (CLOCK_MONOTONIC, & tend);
        printf ("socket %s:%d connected. It took %.5f seconds\n", addr, port, (((double) tend.tv_sec + 1.0e-9 * tend.tv_nsec) - ((double) tstart.tv_sec + 1.0e-9 * tstart.tv_nsec)));
        close (fd);
        return 0;
    }
    FD_ZERO (& fdset);
    FD_SET (fd, & fdset);
    tv.tv_sec = seconds;
    tv.tv_usec = 0;
    rc = select (fd +1, NULL, &fdset, NULL, &tv);
    switch (rc) {
    case 1 :
        len = sizeof (so_error);
        getsockopt (fd, SOL_SOCKET, SO_ERROR, & so_error, & len);
        if (so_error == 0) {
            clock_gettime (CLOCK_MONOTONIC, & tend);
            printf ("socket %s:%d connected. It took %.5f seconds\n", addr, port, (((double) tend.tv_sec + 1.0e-9 * tend.tv_nsec) - ((double) tstart.tv_sec + 1.0e-9 * tstart.tv_nsec)));
            close (fd);
            return 0;
        }
        else {
            printf ("socket %s:%d NOT connected: %s\n", addr, port, strerror (so_error));
        }
        break;
    case 0 :
        fprintf (stderr, "connection timeout trying to connect to %s:%d\n", addr, port);
        break;
    }
    close (fd);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
25999913_26000031_1_21
25999913_26000135_8_29
Title: Will returning an array from a function cause a memory leak? 
----------------------------------------

int main () {
    int length = 10;
    int * ptrarr = (int *) malloc (length * sizeof (int);
    int *copyarr;
    for (int i = 0; i < length; i++)
        ptrarr[i] = i;
    printf ("Origin ... \n");
    printArray (ptrarr, length);
    copyPassPtrArray (& copyarr, 20);
    printf ("After copyPassPtrArray ... \n");
    printArray (copyarr, 20);
    free (ptrarr);
    free (copyarr);
    return 0;
}
----------------------------------------

int main () {
    int length = 10;
    int doublelength = 2 * length;
    int *ptrarr = (int *) malloc (length * sizeof (int));
    int *newarr = (int *) malloc (doublelength * sizeof (int));
    for (int i = 0; i < length; i++)
        ptrarr[i] = i;
    ...copyPassPtrArray (newarr, doublelength);
    ...free (newarr);
    free (ptrarr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26001852_26001985_2_22
26001852_26002068_3_27
Title: Need help trying to calculate averages based on user input. C 
----------------------------------------

int main () {
    int miles_ran, i;
    float miles_ran_time, avg_time, sum;
    float time = 0;
    printf ("How many miles did you run?\n");
    scanf ("%d", & miles_ran);
    for (i = 1; i <= miles_ran; i++) {
        printf ("\nHow long did it take you to run mile #%d\n", i);
        scanf ("%f", & miles_ran_time);
        time += miles_ran_time;
    }
    printf ("\nYour average time to run a mile is %.3f.\n", time / miles_ran);
    return 0;
}
----------------------------------------

int main () {
    int miles_ran = 0, i = 0;
    int c;
    float miles_ran_time = 0.0, avg_time = 0.0, sum = 0;
    printf ("How many miles did you run?\n");
    scanf ("%d", & miles_ran);
    do {
        c = getchar ();
    }
    while (c != '\n' && c != EOF);
    for (i = 1; i <= miles_ran; i++) {
        printf ("\nHow long did it take you to run mile #%d\n", i);
        scanf ("%f", & miles_ran_time);
        do {
            c = getchar ();
        }
        while (c != '\n' && c != EOF);
        sum += miles_ran_time;
    }
    avg_time = sum / miles_ran;
    printf ("\nYour average time to run a mile is %.3f.\n", avg_time);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26021730_26021922_5_17
26021730_26022035_3_28
Title: arranging the numbers with duplicate entries deleted 
----------------------------------------

int main () {
    int num;
    bool freq [NUM_RANGE + 1] = {0};
    for (int r = 0; r < 9; r++) {
        scanf ("%d", & num);
        freq[num] = 1;
    }
    for (int i = 0; i < NUM_RANGE + 1; i++)
        if (freq[i])
            printf ("%d ", i);
}
----------------------------------------

int main () {
    int a [] = {1, 2, 3, 2, 4, 1, 5, 6, 3};
    int n = sizeof (a) / sizeof (*a);
    int i, j, t;
    for (j = 0; j < n - 1; j++) {
        for (i = j + 1; i < n;) {
            if (a[i] == a[j]) {
                t = a[i];
                a[i] = a[--n];
                a[n] = t;
                continue;
            }
            if (a[i] < a[j]) {
                t = a[i];
                a[i] = a[j];
                a[j] = t;
            }
            ++i;
        }
    }
    for (i = 0; i < n; i++)
        printf ("%d ", a[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26022269_26022315_3_14
26022269_26022445_1_12
Title: Return Character in Function 
----------------------------------------

char printBrowse () {
    char choice;
    printf ("Welcome to Orange Movie Box\n\n");
    printf (" a)Browse by Name\n");
    printf (" b)Browse by Genre\n");
    printf (" c)Browse by Year\n");
    printf (" d)Browse by Age Rating\n");
    printf ("Please choose your browsing method:");
    scanf ("%c", & choice);
    return choice;
}
----------------------------------------

void printBrowse (char *choice) {
    printf ("Welcome to Orange Movie Box\n\n");
    printf (" a)Browse by Name\n");
    printf (" b)Browse by Genre\n");
    printf (" c)Browse by Year\n");
    printf (" d)Browse by Age Rating\n");
    printf ("Please choose your browsing method:");
    scanf ("%c", choice);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26022269_26022323_1_12
26022269_26022445_1_12
Title: Return Character in Function 
----------------------------------------

char printBrowse () {
    char choice;
    printf ("Welcome to Orange Movie Box\n\n");
    printf (" a)Browse by Name\n");
    printf (" b)Browse by Genre\n");
    printf (" c)Browse by Year\n");
    printf (" d)Browse by Age Rating\n");
    printf ("Please choose your browsing method:");
    scanf ("%c", & choice);
    return choice;
}
----------------------------------------

void printBrowse (char *choice) {
    printf ("Welcome to Orange Movie Box\n\n");
    printf (" a)Browse by Name\n");
    printf (" b)Browse by Genre\n");
    printf (" c)Browse by Year\n");
    printf (" d)Browse by Age Rating\n");
    printf ("Please choose your browsing method:");
    scanf ("%c", choice);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26022731_26023753_10_46
26022731_26070542_6_28
Title: C program store file to jagged array and sort it 
----------------------------------------

int main (void) {
    char filename [FILENAME_MAX + 1];
    char line [100];
    int rows, cols;
    printf ("Enter the file name with .txt : ");
    scanf ("%" S (FILENAME_MAX) "[^\n]%*c", filename);
    FILE *filePtr = fopen (filename, "r");
    if (!filePtr)
        return EXIT_FAILURE;
    fscanf (filePtr, "%d ", & rows);
    int **jaggedArr;
    jaggedArr = malloc (rows * sizeof (int *));
    int *sizeArr = malloc (rows * sizeof (int));
    int r = 0, c;
    while (fgets (line, sizeof (line), filePtr) != NULL) {
        sizeArr[r] = cols = atoi (strtok (line, ";"));
        jaggedArr[r] = malloc (cols * sizeof (int));
        for (c = 0; c < cols; ++c) {
            jaggedArr[r][c] = atoi (strtok (NULL, ","));
        }
        SortLists (jaggedArr [r ++], cols);
    }
    fclose (filePtr);
    for (r = 0; r < rows; ++r) {
        for (c = 0; c < sizeArr[r]; ++c)
            printf ("%d ", jaggedArr[r][c]);
        printf ("\n");
        free (jaggedArr [r]);
    }
    free (jaggedArr);
    free (sizeArr);
    return 0;
}
----------------------------------------

int main (void) {
    int row1 [] = {4, 7, 8, 9, 5, 2};
    int row2 [] = {2, 5, 7};
    int *jaggedArr [] = {row1, row2};
    int rows = 2;
    int sizeArr [] = {6, 3};
    int i, r, c;
    for (i = 0; i < rows; ++i)
        SortLists (jaggedArr[i], sizeArr[i]);
    for (r = 0; r < rows; ++r) {
        for (c = 0; c < sizeArr[r]; ++c)
            printf ("%d ", jaggedArr[r][c]);
        printf ("\n");
    }
    printf ("\n");
    SortRows (jaggedArr, rows, sizeArr);
    for (r = 0; r < rows; ++r) {
        for (c = 0; c < sizeArr[r]; ++c)
            printf ("%d ", jaggedArr[r][c]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26046949_26089191_1_54
26046949_51201041_1_34
Title: Find the device or mountpoint of arbitrary files on Linux using C 
----------------------------------------

int getmntpt (char *path, char *mount_point) {
    struct stat cur_stat;
    struct stat last_stat;
    char dir_name [PATH_MAX];
    char *dirname_p = dir_name;
    char cur_cwd [255];
    char *cur_cwd_p = cur_cwd;
    char saved_cwd [PATH_MAX];
    if (getcwd (saved_cwd, PATH_MAX) == NULL) {
        errno = EIO;
        return ERROR;
    }
    if (lstat (path, &cur_stat) < 0) {
        errno = EIO;
        return ERROR;
    }
    if (S_ISDIR (cur_stat.st_mode)) {
        last_stat = cur_stat;
        if (chdir ("..") < 0)
            return ERROR;
        if (getcwd (cur_cwd_p, 255) == NULL) {
            errno = EIO;
            return ERROR;
        }
    }
    else {
        size_t path_len, suffix_len, dir_len;
        path_len = strlen (path);
        suffix_len = strlen (strrchr (path, 47));
        dir_len = path_len - suffix_len;
        dirname_p = strncpy (dirname_p, path, dir_len);
        if (chdir (dirname_p) < 0)
            return ERROR;
        if (lstat (".", &last_stat) < 0)
            return ERROR;
    }
    for (;;) {
        if (lstat ("..", &cur_stat) < 0)
            return ERROR;
        if (cur_stat.st_dev != last_stat.st_dev || cur_stat.st_ino == last_stat.st_ino)
            break;
        if (chdir ("..") < 0)
            return ERROR;
        last_stat = cur_stat;
    }
    if (getcwd (mount_point, PATH_MAX) == NULL)
        return ERROR;
    if (chdir (saved_cwd) < 0)
        return ERROR;
    return SUCCESS;
}
----------------------------------------

int getmntpt (char const *path, char *mount_point) {
    char *test_path = malloc (PATH_MAX), *test_end;
    struct stat cur_stat, prev_stat;
    if (lstat (path, &prev_stat) < 0)
        return ERROR;
    test_end = stpcpy (test_path, path);
    if (!S_ISDIR (prev_stat.st_mode)) {
        test_end = strrchr (test_path, '/');
        if (test_end == NULL)
            test_end = stpcpy (test_path, ".");
        else
            *test_end = '\0';
    }
    for (;;) {
        test_end = stpcpy (test_end, "/..");
        if (lstat (test_path, &cur_stat) < 0)
            return ERROR;
        if (cur_stat.st_dev != prev_stat.st_dev || cur_stat.st_ino == prev_stat.st_ino)
            break;
        prev_stat = cur_stat;
    }
    *(test_end - 3) = '\0';
    if (realpath (test_path, mount_point) == NULL) {
        free (test_path);
        return -1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26052675_26052881_3_15
26052675_26052921_3_19
Title: Whitespace replace in C language 
----------------------------------------

int main () {
    int i = 0;
    unsigned char str [] = "a ";
    while (str[i]) {
        if (isspace (str[i]))
            str[i] = '_';
        i++;
    }
    printf ("%s\n", str);
    return 0;
}
----------------------------------------

int main (void) {
    char passcode [] = "a ";
    char *ptr = passcode;
    while (*ptr) {
        if (*ptr == ' ')
            *ptr = '_';
        ptr++;
    }
    printf ("\n passcode: %s\n\n", passcode);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26064236_26064769_3_23
26064236_26064804_2_26
Title: C programming do while with switch case program 
----------------------------------------

int main () {
    int I;
    do {
        scanf ("%d", & I);
        switch (I) {
        case 1 :
            printf ("67");
            break;
        case 2 :
            printf ("45");
            break;
        default :
            printf ("default");
        }
    }
    while (I > 0);
    return 0;
}
----------------------------------------

int main () {
    int I;
    do {
        puts ("Enter -1 to quit");
        printf ("Enter your choice: ");
        scanf ("%d", & I);
        switch (I) {
        case 1 :
            printf ("67\n");
            break;
        case 2 :
            printf ("45\n");
            break;
        case -1 :
            puts ("Bye");
            break;
        default :
            printf ("default\n");
        }
    }
    while (I != -1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26072322_26072382_3_12
26072322_26072483_5_24
Title: Reading string character by character in C 
----------------------------------------

int main (int argc, char *argv []) {
    int i, j;
    for (i = 0; i < argc; ++i) {
        for (j = 0; argv[i][j] != '\0'; ++j) {
            printf ("(%c)", argv [i] [j]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    if (argc != 2) {
        printf ("Usage: %s argument\n", argv [0]);
        exit (1);
    }
    else {
        int i;
        int length = strlen (argv[1]);
        for (i = 0; i < length; i++) {
            printf ("%c", argv [1] [i]);
        }
        printf ("\n");
        return 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26077874_26077928_3_20
26077874_26077933_3_25
Title: Segmentation fault in scanf 
----------------------------------------

int main () {
    char **a;
    int i, j;
    a = malloc (1000 * sizeof (char *));
    for (i = 0; i < 1000; i++) {
        a[i] = malloc (1000 * sizeof (char));
        for (j = 0; j < 1000; j++) {
        }
    }
    for (i = 0; i < 1000; i++)
        free (a[i]);
    free (a);
    return 0;
}
----------------------------------------

int main () {
    int test;
    char (*a) [COLUMNS] = malloc (ROWS * sizeof *a);
    int (*x) [COLUMNS] = malloc (ROWS * sizeof *x);
    int (*y) [COLUMNS] = malloc (ROWS * sizeof *y);
    a[100][20] = 'X';
    x[4][999] = 666;
    y[500][0] = 42;
    scanf ("%d", & test);
    printf ("%d", test);
    free (a);
    free (x);
    free (y);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2607945_15783415_1_16
2607945_2608066_11_67
Title: Listing directories in Linux from C 
----------------------------------------

int main (int argc, char *argv []) {
    struct dirent *direntp;
    DIR *dirp;
    if (argc != 2) {
        fprintf (stderr, "Usage: %s directory_name\n", argv [0]);
        return 1;
    }
    if ((dirp = opendir (argv [1])) == NULL) {perror ("Failed to open directory");
    return 1;
}
----------------------------------------

int main (int argc, char *argv []) {
    DIR *dirp;
    struct dirent *direntp;
    struct stat stat_buf;
    char *str;
    char fullpath [MAXPATHLEN + 1];
    size_t dirnamelen;
    if (argc != 2) {
        fprintf (stderr, "Usage: %s dir_name\n", argv [0]);
        exit (1);
    }
    strncpy (fullpath, argv [1], MAXPATHLEN - 1);
    fullpath[MAXPATHLEN - 1] = '\0';
    dirnamelen = strlen (fullpath);
    if (strlen (argv[1]) > dirnamelen) {
        fprintf (stderr, "Directory name is too long: %s", argv [1]);
        exit (2);
    }
    fullpath[dirnamelen++] = '/';
    fullpath[dirnamelen] = '\0';
    if ((dirp = opendir (argv[1])) == NULL) {
        perror (argv [1]);
        exit (2);
    }
    while ((direntp = readdir (dirp)) != NULL) {
        fullpath[dirnamelen] = '\0';
        if ((dirnamelen + strlen (direntp->d_name)) > MAXPATHLEN) {
            fprintf (stderr, "File %s + directory %s is too long.", direntp -> d_name, fullpath);
            continue;
        }
        else {
            strncpy (fullpath + dirnamelen, direntp -> d_name, MAXPATHLEN - dirnamelen);
            fullpath[MAXPATHLEN] = '\0';
        }
        if (stat (fullpath, &stat_buf) == -1) {
            perror ("stat ERROR");
            exit (3);
        }
        if (S_ISREG (stat_buf.st_mode))
            str = "regular";
        else if (S_ISDIR (stat_buf.st_mode))
            str = "directory";
        else
            str = "other";
        printf ("%-25s - %s\n", direntp -> d_name, str);
    }
    closedir (dirp);
    exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26085550_26087960_1_13
26085550_26089040_8_21
Title: Can't free memory allocated one and two dimension arrays 
----------------------------------------

double **matrix_alloc (int m, int n) {
    int i;
    double **p = malloc (sizeof (double **) * m);
    if (!p) {
        printf ("matrix_alloc:: Unable to allocate memory!!! \n");
    }
    for (i = 0; i < m; i++) {
        p[i] = malloc (sizeof (double) * n);
        if (!p[i]) {
            printf ("matrix_alloc:: Unable to allocate memory!!! \n");
        }
    }
    return p;
}
----------------------------------------

double **matrix_alloc (size_t m, size_t n) {
    double **result = malloc (m * sizeof *result);
    double *data = malloc (m *n * sizeof *data);
    if (result == NULL || data == NULL) {
        free (result);
        free (data);
        printf ("Error: no memmory available");
        return (NULL);
    }
    for (size_t i = 0; i < m; i++) {
        result[i] = &data[i * n];
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26089308_26089668_5_30
26089308_26090548_5_53
Title: "Read text file save all digits into character string" 
----------------------------------------

int main () {
    char buffer [BUFFER_SIZE];
    char digits [BUFFER_SIZE];
    char *pos;
    size_t i = 0;
    if (!fgets (buffer, BUFFER_SIZE, stdin)) {
        perror ("fgets");
        return 1;
    }
    for (pos = buffer; *pos; ++pos) {
        if (*pos >= '0' && *pos <= '9') {
            digits[i++] = *pos;
        }
    }
    digits[i] = '\0';
    printf ("%s\n", digits);
    return 0;
}
----------------------------------------

int main (int argc, const char **argv) {
    char *buffer = NULL;
    ssize_t read = 0;
    size_t n = 0;
    char *str = NULL;
    char *p = NULL;
    int idx = 0;
    int number = 0;
    FILE *input;
    if (argc < 2) {
        printf ("Error: insufficient input. Usage: %s filename\n", argv [0]);
        return 1;
    }
    input = fopen (argv[1], "r");
    if (!input) {
        printf ("Error: failed to open file '%s\n", argv [1]);
        return 1;
    }
    if ((read = getline (&buffer, &n, input)) != -1) {
        str = malloc (sizeof (char) * read);
        p = buffer;
        while (*p) {
            if (*p > 0x2f && *p < 0x3a) {
                str[idx] = *p;
                idx++;
            }
            p++;
        }
        str[idx] = 0;
        number = atoi (str);
        printf ("\n string : %s number : %d\n\n", buffer, number);
    }
    else {
        printf ("Error: nothing read from file '%s\n", argv [1]);
        return 1;
    }
    if (input)
        fclose (input);
    if (buffer)
        free (buffer);
    if (str)
        free (str);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
260915_260981_60_75
260915_50156730_12_41
Title: How can I create a dynamically sized array of structs? 
----------------------------------------

int main (int argc, char **argv) {
    word_list *myWords = create_word_list (2);
    add_word_to_word_list (myWords, "Hello");
    add_word_to_word_list (myWords, "World");
    add_word_to_word_list (myWords, "Goodbye");
    char **iter;
    for (iter = word_list_start (myWords); iter != word_list_end (myWords); ++iter) {
        printf ("%s ", * iter);
    }
    delete_word_list (myWords);
    return 0;
}
----------------------------------------

int main () {
    int n, i;
    struct book *b;
    scanf ("%d\n", & n);
    b = (struct book *) calloc (n, sizeof (struct book));
    for (i = 0; i < n; i++) {
        scanf ("%s %d\n", (b + i) -> name, & (b + i) -> p);
    }
    for (i = 0; i < n; i++) {
        printf ("%s %d\t", (b + i) -> name, (b + i) -> p);
    }
    scanf ("%d\n", & n);
    b = (struct book *) realloc (b, n * sizeof (struct book));
    printf ("\n");
    for (i = 0; i < n; i++) {
        printf ("%s %d\t", (b + i) -> name, (b + i) -> p);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26110303_26110371_4_32
26110303_26110449_3_32
Title: Scalar by vector multiplication in C 
----------------------------------------

int main (void) {
    int n;
    printf ("\n Enter vector dimension: ");
    scanf ("%d", & n);
    int a [n];
    float b [n];
    for (int i = 0; i < n; i++) {
        printf ("Enter a%d ", i);
        scanf ("%d", & a [i]);
    }
    printf ("\n Enter value of scalar ");
    float k;
    scanf ("%f", & k);
    for (int i = 0; i < n; i++)
        b[i] = k * a[i];
    for (int i = 0; i < n; i++)
        printf ("\n b[%d] = %f", i, b[i]);
    return 0;
}
----------------------------------------

int main () {
    int n;
    printf ("\n Enter vector dimension \n");
    scanf ("%d", & n);
    int i, A [n];
    float k, B [n];
    for (i = 1; i < n + 1; i++) {
        printf ("\n Enter a%d", i);
        scanf ("%d", & A [i]);
    }
    printf ("\n Enter value of scalar \n");
    scanf ("%f", & k);
    for (i = 1; i < n + 1; i++) {
        B[i] = k * A[i];
    }
    for (i = 1; i < n + 1; i++) {
        printf ("\n B[%f]=%f", i, B [i]);
    }
    gets ();
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26122135_26122349_2_23
26122135_26123903_63_87
Title: Swap integers using pointers 
----------------------------------------

int main (int argc, char **argv) {
    int i = 1;
    int j = 2;
    int *p = &i;
    int *q = &j;
    printf ("BEFORE: %d - %d\n", * p, * q);
    if (*p != *q) {
        *p ^= *q;
        *q ^= *p;
        *p ^= *q;
    }
    printf ("AFTER: %d - %d\n", * p, * q);
    return 0;
}
----------------------------------------

int main () {
    int p = 0;
    int q = 0;
    cout << "Enter p : ";
    cin >> p;
    cout << "Enter q : ";
    cin >> q;
    swap (& p, & q);
    cout << "p : " << p << endl;
    cout << "q : " << q << endl;
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26123094_26123299_4_17
26123094_26123904_1_13
Title: I'm trying to convert binary to decimal 
----------------------------------------

int toDecimal (int number, int base) {
    assert (base == 2);
    int result = 0;
    int offset = 1;
    while (number) {
        if (number % 10 == 1)
            result += offset;
        offset *= 2;
        number /= 10;
    }
    return result;
}
----------------------------------------

int toDecimal (int number, int base) {
    if (base == 2) {
        int n = number, dec = 0, d = 0, r;
        while (n != 0) {
            r = n % 10;
            dec += r * 1 << d++;
            n = n / 10;
        }
        return dec;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26131293_26132481_13_25
26131293_26145700_8_29
Title: Max in array and its frequency 
----------------------------------------

void findMax (int *a, int length, maxfreq *mfreq) {
    if (length > 0) {
        if (*a == mfreq->max)
            mfreq->freq++;
        else if (*a > mfreq->max) {
            mfreq->freq = 1;
            mfreq->max = *a;
        }
        findMax (a + 1, length - 1, mfreq);
    }
}
----------------------------------------

value_freq findMax (const int *a, size_t length) {
    value_freq vf;
    if (length <= 1) {
        if (length == 0) {
            vf.value = INT_MIN;
            vf.frequency = 0;
        }
        else {
            vf.value = *a;
            vf.frequency = 1;
        }
    }
    else {
        size_t length1sthalf = length / 2;
        vf = findMax (a, length1sthalf);
        value_freq vf1 = findMax (&a[length1sthalf], length -length1sthalf);
        if (vf1.value > vf.value)
            return vf1;
        if (vf.value == vf1.value)
            vf.frequency += vf1.frequency;
    }
    return vf;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26131293_26132481_13_25
26131293_26147994_1_16
Title: Max in array and its frequency 
----------------------------------------

void findMax (int *a, int length, maxfreq *mfreq) {
    if (length > 0) {
        if (*a == mfreq->max)
            mfreq->freq++;
        else if (*a > mfreq->max) {
            mfreq->freq = 1;
            mfreq->max = *a;
        }
        findMax (a + 1, length - 1, mfreq);
    }
}
----------------------------------------

int findMax (int length, int *array, int *maxCount) {
    int trash;
    if (!maxCount)
        maxCount = &trash;
    *maxCount = 0;
    int result = INT_MIN;
    for (int i = 0; i < length; i++) {
        if (array[i] > result) {
            *maxCount = 1;
            result = array[i];
        }
        else if (array[i] == result) {
            (*maxCount)++;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26131293_26145700_8_29
26131293_26147994_1_16
Title: Max in array and its frequency 
----------------------------------------

value_freq findMax (const int *a, size_t length) {
    value_freq vf;
    if (length <= 1) {
        if (length == 0) {
            vf.value = INT_MIN;
            vf.frequency = 0;
        }
        else {
            vf.value = *a;
            vf.frequency = 1;
        }
    }
    else {
        size_t length1sthalf = length / 2;
        vf = findMax (a, length1sthalf);
        value_freq vf1 = findMax (&a[length1sthalf], length -length1sthalf);
        if (vf1.value > vf.value)
            return vf1;
        if (vf.value == vf1.value)
            vf.frequency += vf1.frequency;
    }
    return vf;
}
----------------------------------------

int findMax (int length, int *array, int *maxCount) {
    int trash;
    if (!maxCount)
        maxCount = &trash;
    *maxCount = 0;
    int result = INT_MIN;
    for (int i = 0; i < length; i++) {
        if (array[i] > result) {
            *maxCount = 1;
            result = array[i];
        }
        else if (array[i] == result) {
            (*maxCount)++;
        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26144962_26146131_8_19
26144962_26180993_7_21
Title: fill character array by blocks 
----------------------------------------

int main (void) {
    foo x;
    int i;
    for (i = 0; i < 8; i++)
        x.as_int[i] = 0;
    for (i = 0; i < 32; i++)
        printf ("%d", x.as_string[i]);
    printf ("\n");
    return 0;
}
----------------------------------------

int main (void) {
    size_t i, align;
    char *ptr, *str;
    align = __alignof__ (int);
    ptr = malloc (MAX +align);
    str = ptr + align - (intptr_t) ptr % align;
    for (i = 0; i < MAX / sizeof (int); i++)
        ((int *) str)[i] = 0;
    for (i = 0; i < MAX; i++)
        printf ("%d\n", str[i]);
    free (ptr);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26173112_26173242_1_20
26173112_26173318_2_20
Title: why code used 2 pointer variables 
----------------------------------------

int main () {
    int s [4] [2] = {{1234, 56}, {1212, 33}, {1434, 80}, {1312, 78},};
    int i;
    for (i = 0; i < 4; i++) {
        int j;
        for (j = 0; j < 2; j++)
            printf ("%d\t", s[i][j]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int s [4] [2] = {{1234, 56}, {1212, 33}, {1434, 80}, {1312, 78},};
    int (*p) [2];
    int i, j;
    p = s;
    for (i = 0; i <= 3; i++) {
        for (j = 0; j <= 1; j++)
            printf ("%d\t", p[i][j]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26173112_26173242_1_20
26173112_26173586_1_19
Title: why code used 2 pointer variables 
----------------------------------------

int main () {
    int s [4] [2] = {{1234, 56}, {1212, 33}, {1434, 80}, {1312, 78},};
    int i;
    for (i = 0; i < 4; i++) {
        int j;
        for (j = 0; j < 2; j++)
            printf ("%d\t", s[i][j]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int s [4] [2] = {{1234, 56}, {1212, 33}, {1434, 80}, {1312, 78},};
    int (*p) [2];
    int i, j;
    p = s;
    for (i = 0; i <= 3; i++) {
        for (j = 0; j <= 1; j++)
            printf ("%d\t", p[i][j]);
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26174604_26174732_1_20
26174604_26176193_15_28
Title: Iterating through a string in C 
----------------------------------------

int main () {
    FILE *ifp;
    char *mode = "r";
    ifp = fopen ("in.csv", mode);
    char string [1024];
    int i, len;
    while (fgets (string, 1024, ifp) != NULL) {
        removeChar (string, ',');
        printf ("%s \n", string);
        len = strlen (string);
        for (i = 0; i < len; i++)
            printf ("%c", string[i]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char line [LINE_MAXLEN];
    FILE *fp;
    if ((fp = fopen ("in.csv", "r")) == NULL)
        perror ("Error opening file");
    while (readline (line, fp))
        printf ("line=%s\n", line);
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26193712_26193846_1_17
26193712_26193869_3_12
Title: Insert an element in end of a singly Linked List 
----------------------------------------

void Insert (int data) {
    struct Node *temp = malloc (sizeof (struct Node));
    temp->data = data;
    temp->next = NULL;
    if (head == NULL) {
        head = temp;
    }
    else {
        struct Node *current = head;
        while (current->next != NULL)
            current = current->next;
        current->next = temp;
    }
}
----------------------------------------

void Insert (int data) {
    struct Node *temp = malloc (sizeof (struct Node));
    temp->data = data;
    temp->next = NULL;
    if (head == NULL)
        curr = head = temp;
    else
        curr = curr->next = temp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2620010_2626476_12_24
2620010_2649601_15_39
Title: Can I make ungetc unblock a blocking fgetc call? 
----------------------------------------

void foo () {
    int key;
    signal (SIGUSR1, handler);
    while ((key = fgetc (stdin)) != EOF) {
        printf ("%c\n", key);
        if (handle) {
            handle = 0;
            ungetc ('A', stdin);
        }
    }
}
----------------------------------------

void foo () {
    int key;
    struct termios terminal_settings;
    signal (SIGUSR1, handler);
    tcgetattr (fileno (stdin), & terminal_settings);
    terminal_settings.c_lflag &= ~(ECHO | ICANON);
    terminal_settings.c_cc[VTIME] = 0;
    terminal_settings.c_cc[VMIN] = 0;
    tcsetattr (fileno (stdin), TCSANOW, & terminal_settings);
    for (;;) {
        wait_for_stdin ();
        key = fgetc (stdin);
        if (key == 0x04) {
            break;
        }
        if (key != EOF) {
            printf ("%c\n", key);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26201895_26202412_8_38
26201895_26202631_7_56
Title: putting a number in a hollow shape 
----------------------------------------

int main () {
    int i, j;
    int column, row;
    int n, cnt;
    printf ("Enter column: ");
    scanf ("%d", & column);
    printf ("Enter row: ");
    scanf ("%d", & row);
    scanf ("%d", & n);
    cnt = digits (n);
    for (i = 0; i < row; i++) {
        for (j = 0; j < column; j++) {
            if (i == 0 || i == (row - 1) || j == 0 || j == (column - 1))
                printf ("*");
            else if ((i == (row / 2)) && (j == ((column - cnt) / 2))) {
                printf ("%d", n);
                j = j + (cnt - 1);
            }
            else
                printf (" ");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main () {
    int number, column, row;
    int columnCount, rowCount;
    int i;
    printf ("Enter column:\n>");
    scanf ("%d", & column);
    printf ("\nEnter row:\n>");
    scanf ("%d", & row);
    printf ("\nEnter number for center:\n>");
    scanf ("%d", & number);
    for (columnCount = 0; columnCount < column; columnCount++) {
        for (rowCount = 0; rowCount < row; rowCount++) {
            if (columnCount == column / 2) {
                printf ("*");
                for (i = 0; i < ((row * 2 - 3) - countNumber (number)) / 2; i++)
                    printf (" ");
                printf ("%d", number);
                for (i = 0; i < ((row * 2 - 3) - countNumber (number)) / 2; i++)
                    printf (" ");
                if (countNumber (number % 2 == 0))
                    printf (" *");
                else
                    printf ("*");
                break;
            }
            if (columnCount == 0 || columnCount == column - 1 || rowCount == 0 || rowCount == row - 1)
                printf ("* ");
            else
                printf ("  ");
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26202730_31122295_4_19
26202730_31154598_55_76
Title: How to find out if the linux kernel will insert a leap second at the end of the month 
----------------------------------------

int main (int argc, char **argv) {
    struct timex buf;
    int res;
    buf.modes = 0;
    res = adjtimex (&buf);
    if (res < 0) {
        perror ("Error calling adjtimex");
        return 1;
    }
    printf ("clock status: %i\n", res);
    return 0;
}
----------------------------------------

int main (int argc, char **argv) {
    time_t post_leap = 1435708800;
    for (;;) {
        time_t now = time (NULL);
        print_current_data ();
        if (now < (post_leap - 60)) {
            sleep (30);
        }
        else if (now < (post_leap - 10)) {
            sleep (5);
        }
        else if (now < (post_leap - 2)) {
            usleep (500000);
        }
        else if (now <= (post_leap + 1)) {
        }
        else if (now > (post_leap + 120)) {
            return 0;
        }
        else if (now > (post_leap + 1)) {
            usleep (500000);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26211159_26211703_5_55
26211159_26211994_5_40
Title: Dynamically Allocated Memory in Structure Array (in C) 
----------------------------------------

int main (void) {
    struct student {
        char initial [21];
        int age;
        float id;
        char grade [3];
    } list [5];
    struct student *tag [5];
    int i;
    for (i = 0; i < 5; i++)
        tag[i] = (struct student *) malloc (sizeof (struct student));
    strcpy (tag [0] -> initial, "KJ");
    tag[0]->age = 21;
    tag[0]->id = 1.0;
    strcpy (tag [0] -> grade, "A");
    strcpy (tag [1] -> initial, "MJ");
    tag[1]->age = 55;
    tag[1]->id = 1.1;
    strcpy (tag [1] -> grade, "B");
    strcpy (tag [2] -> initial, "CJ");
    tag[2]->age = 67;
    tag[2]->id = 1.2;
    strcpy (tag [2] -> grade, "C");
    strcpy (tag [3] -> initial, "SJ");
    tag[3]->age = 24;
    tag[3]->id = 1.3;
    strcpy (tag [3] -> grade, "D");
    strcpy (tag [4] -> initial, "DJ");
    tag[4]->age = 27;
    tag[4]->id = 1.4;
    strcpy (tag [4] -> grade, "F");
    for (i = 0; i < 5; i++) {
        printf ("%s is %d, id is %f, grade is %s\n", tag [i] -> initial, tag [i] -> age, tag [i] -> id, tag [i] -> grade);
    }
    return 0;
}
----------------------------------------

int main (void) {
    struct student {
        char initial [21];
        int age;
        float id;
        char grade [3];
    } list [5];
    struct student *tag = (struct student *) malloc (sizeof (struct student) * 5);
    int i;
    for (i = 0; i < 5; i++) {
        printf ("Enter the student initial\n");
        scanf ("%s", list [i].initial);
        printf ("Enter the student age\n");
        scanf ("%d", & list [i].age);
        printf ("Enter the student id\n");
        scanf ("%f", & list [i].id);
        printf ("Enter the grade\n");
        scanf ("%s", list [i].grade);
        tag++;
    }
    int n;
    for (n = 0; n < 5; n++) {
        printf ("%s is %d, id is %f, grade is %s \n", list [n].initial, list [n].age, list [n].id, list [n].grade);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26214821_3_18
26214428_26214985_2_20
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main () {
    int i;
    char m, X [99];
    printf ("Type the string without spaces\n");
    for (i = 0; i < 98; i++) {
        scanf ("%c", & m);
        if (m != ' ' && m != '\n')
            X[i] = m;
        else
            break;
    }
    X[i] = '\0';
    puts (X);
    return 0;
}
----------------------------------------

int main (void) {
    char m, X [99];
    int i;
    printf ("Type the string without spaces\n");
    for (i = 0; i < 99; i++) {
        m = getch ();
        if (m == ' ' || m == '\n' || m == '\r')
            i = 100;
        else
            X[i] = m;
        printf ("%c", m);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26214821_3_18
26214428_26367561_2_20
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main () {
    int i;
    char m, X [99];
    printf ("Type the string without spaces\n");
    for (i = 0; i < 98; i++) {
        scanf ("%c", & m);
        if (m != ' ' && m != '\n')
            X[i] = m;
        else
            break;
    }
    X[i] = '\0';
    puts (X);
    return 0;
}
----------------------------------------

int main () {
    char X [99];
    char m;
    int i;
    printf ("Type the string without spaces\n");
    for (i = 0; i < 99; i++) {
        scanf ("%c", & m);
        if (m != ' ' && m != '\n') {
            X[i] = m;
            getchar ();
        }
        else
            i = 99;
    }
    printf ("%s", X);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26214821_3_18
26214428_26376011_3_26
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main () {
    int i;
    char m, X [99];
    printf ("Type the string without spaces\n");
    for (i = 0; i < 98; i++) {
        scanf ("%c", & m);
        if (m != ' ' && m != '\n')
            X[i] = m;
        else
            break;
    }
    X[i] = '\0';
    puts (X);
    return 0;
}
----------------------------------------

int main () {
    char x [100] = {0};
    char m;
    int i, j;
    printf ("Type:\n");
    for (i = 0; i < 99; i++) {
        m = getchar ();
        getchar ();
        if ((m != ' ') && (m != '\n')) {
            x[i] = m;
        }
        else {
            printf ("Breaking.");
            break;
        }
    }
    printf ("\n");
    for (j = 0; j < i; j++)
        printf ("%c\n", x[j]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26214821_3_18
26214428_26448922_24_41
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main () {
    int i;
    char m, X [99];
    printf ("Type the string without spaces\n");
    for (i = 0; i < 98; i++) {
        scanf ("%c", & m);
        if (m != ' ' && m != '\n')
            X[i] = m;
        else
            break;
    }
    X[i] = '\0';
    puts (X);
    return 0;
}
----------------------------------------

void main (void) {
    printf ("\nType the string without spaces\n");
    ttySetNoncanonical (0, NULL);
    char X [1000];
    int m, ec = 0;
    int i;
    X[0] = 0;
    for (i = 0; i < 1000; i++) {
        m = getchar ();
        if (m == EOF || m == ' ' || m == '\n') {
            X[i] = 0;
            break;
        }
        X[i] = m;
    }
    printf ("You entered %s. Bye.\n\n", X);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26214985_2_20
26214428_26367561_2_20
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main (void) {
    char m, X [99];
    int i;
    printf ("Type the string without spaces\n");
    for (i = 0; i < 99; i++) {
        m = getch ();
        if (m == ' ' || m == '\n' || m == '\r')
            i = 100;
        else
            X[i] = m;
        printf ("%c", m);
    }
}
----------------------------------------

int main () {
    char X [99];
    char m;
    int i;
    printf ("Type the string without spaces\n");
    for (i = 0; i < 99; i++) {
        scanf ("%c", & m);
        if (m != ' ' && m != '\n') {
            X[i] = m;
            getchar ();
        }
        else
            i = 99;
    }
    printf ("%s", X);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26214985_2_20
26214428_26376011_3_26
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main (void) {
    char m, X [99];
    int i;
    printf ("Type the string without spaces\n");
    for (i = 0; i < 99; i++) {
        m = getch ();
        if (m == ' ' || m == '\n' || m == '\r')
            i = 100;
        else
            X[i] = m;
        printf ("%c", m);
    }
}
----------------------------------------

int main () {
    char x [100] = {0};
    char m;
    int i, j;
    printf ("Type:\n");
    for (i = 0; i < 99; i++) {
        m = getchar ();
        getchar ();
        if ((m != ' ') && (m != '\n')) {
            x[i] = m;
        }
        else {
            printf ("Breaking.");
            break;
        }
    }
    printf ("\n");
    for (j = 0; j < i; j++)
        printf ("%c\n", x[j]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26214985_2_20
26214428_26448922_24_41
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main (void) {
    char m, X [99];
    int i;
    printf ("Type the string without spaces\n");
    for (i = 0; i < 99; i++) {
        m = getch ();
        if (m == ' ' || m == '\n' || m == '\r')
            i = 100;
        else
            X[i] = m;
        printf ("%c", m);
    }
}
----------------------------------------

void main (void) {
    printf ("\nType the string without spaces\n");
    ttySetNoncanonical (0, NULL);
    char X [1000];
    int m, ec = 0;
    int i;
    X[0] = 0;
    for (i = 0; i < 1000; i++) {
        m = getchar ();
        if (m == EOF || m == ' ' || m == '\n') {
            X[i] = 0;
            break;
        }
        X[i] = m;
    }
    printf ("You entered %s. Bye.\n\n", X);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26367561_2_20
26214428_26376011_3_26
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main () {
    char X [99];
    char m;
    int i;
    printf ("Type the string without spaces\n");
    for (i = 0; i < 99; i++) {
        scanf ("%c", & m);
        if (m != ' ' && m != '\n') {
            X[i] = m;
            getchar ();
        }
        else
            i = 99;
    }
    printf ("%s", X);
}
----------------------------------------

int main () {
    char x [100] = {0};
    char m;
    int i, j;
    printf ("Type:\n");
    for (i = 0; i < 99; i++) {
        m = getchar ();
        getchar ();
        if ((m != ' ') && (m != '\n')) {
            x[i] = m;
        }
        else {
            printf ("Breaking.");
            break;
        }
    }
    printf ("\n");
    for (j = 0; j < i; j++)
        printf ("%c\n", x[j]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26367561_2_20
26214428_26448922_24_41
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main () {
    char X [99];
    char m;
    int i;
    printf ("Type the string without spaces\n");
    for (i = 0; i < 99; i++) {
        scanf ("%c", & m);
        if (m != ' ' && m != '\n') {
            X[i] = m;
            getchar ();
        }
        else
            i = 99;
    }
    printf ("%s", X);
}
----------------------------------------

void main (void) {
    printf ("\nType the string without spaces\n");
    ttySetNoncanonical (0, NULL);
    char X [1000];
    int m, ec = 0;
    int i;
    X[0] = 0;
    for (i = 0; i < 1000; i++) {
        m = getchar ();
        if (m == EOF || m == ' ' || m == '\n') {
            X[i] = 0;
            break;
        }
        X[i] = m;
    }
    printf ("You entered %s. Bye.\n\n", X);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26214428_26376011_3_26
26214428_26448922_24_41
Title: "' ' '\n'  scanf() and output screen" 
----------------------------------------

int main () {
    char x [100] = {0};
    char m;
    int i, j;
    printf ("Type:\n");
    for (i = 0; i < 99; i++) {
        m = getchar ();
        getchar ();
        if ((m != ' ') && (m != '\n')) {
            x[i] = m;
        }
        else {
            printf ("Breaking.");
            break;
        }
    }
    printf ("\n");
    for (j = 0; j < i; j++)
        printf ("%c\n", x[j]);
    return 0;
}
----------------------------------------

void main (void) {
    printf ("\nType the string without spaces\n");
    ttySetNoncanonical (0, NULL);
    char X [1000];
    int m, ec = 0;
    int i;
    X[0] = 0;
    for (i = 0; i < 1000; i++) {
        m = getchar ();
        if (m == EOF || m == ' ' || m == '\n') {
            X[i] = 0;
            break;
        }
        X[i] = m;
    }
    printf ("You entered %s. Bye.\n\n", X);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26219368_26219944_15_23
26219368_26220725_20_42
Title: Why is this segfaulting? strtok? 
----------------------------------------

coin *addCoins (char *val) {
    coin *k = malloc (sizeof (coin));
    if (sscanf (val, "%d,%d", &(k->denom), &(k->count)) != 2) {
        fprintf (stderr, "Two int values not found on line '%s' in input.\n", val);
        free (k);
        k = NULL;
    }
    return k;
}
----------------------------------------

static int *addCoins (char *val) {
    const char *deli = ",";
    char *ptr = NULL;
    char *denomination = strtok_r (val, deli, &ptr);
    char *count = strtok_r (NULL, deli, &ptr);
    printf ("D = %s, C = %s", denomination, count);
    int deno = atoi (denomination);
    int cnt = atoi (count);
    printf ("D = %d, C = %d\n", deno, cnt);
    int *k = malloc (sizeof (*k) * 2);
    if (k == 0) {
        fprintf (stderr, "Failed to allocate memory\n");
        exit (1);
    }
    k[0] = deno;
    k[1] = cnt;
    return k;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26219368_26219944_25_48
26219368_26220725_44_86
Title: Why is this segfaulting? strtok? 
----------------------------------------

int main (int argc, char *argv []) {
    coin Coins [100] = {0};
    char *fileNameCoin = argv[1];
    FILE *fileCoin = fopen (fileNameCoin, "r+");
    char bufCoin [256];
    int i = 0;
    coin *j;
    if (fileCoin) {
        while (fgets (bufCoin, sizeof bufCoin, fileCoin) != NULL) {
            j = addCoins (bufCoin);
            if (j) {
                Coins[i] = *j;
                free (j);
                printf ("c: %d, %d\n", Coins [i].denom, Coins [i].count);
                i++;
            }
        }
        fclose (fileCoin);
    }
    else {
        fprintf (stderr, "Unable to open file %s for input.\n", fileNameCoin);
    }
}
----------------------------------------

int main (int argc, char **argv) {
    if (argc != 2) {
        fprintf (stderr, "Usage: %s file\n", argv [0]);
        return 0;
    }
    char *fileNameCoin = argv[1];
    FILE *fileCoin = fopen (fileNameCoin, "r+");
    if (fileCoin == 0) {
        fprintf (stderr, "%s: failed to open file %s\n", argv [0], argv [1]);
        return 0;
    }
    char bufCoin [256];
    int i = 0;
    while (fgets (bufCoin, sizeof bufCoin, fileCoin) != NULL) {
        int *j = addCoins (bufCoin);
        int deno = j[0];
        switch (deno) {
        case 5 :
        case 10 :
        case 20 :
        case 50 :
        case 100 :
        case 200 :
        case 500 :
        case 1000 :
            Coins[i].denom = j[0];
            Coins[i].count = j[1];
            printf ("(%d,%d)\n", Coins [i].denom, Coins [i].count);
            i++;
            break;
        default :
            fprintf (stderr, "Unrecognized coin denomination (%d,%d)\n", j[0], j[1]);
            break;
        }
        free (j);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26226199_26226290_2_51
26226199_26227179_3_51
Title: Switch case program does not give the output 
----------------------------------------

int main () {
    int choice;
    printf ("Enter 1 for Programmers Name and ID\n");
    printf ("Enter 2 to Perform Integer Operation\n");
    printf ("Enter 3 to Perform Floating Point Operation\n");
    scanf ("%d", & choice);
    getchar ();
    if (choice == 1)
        printf ("Connor \n000000000\n");
    else if (choice == 2) {
        char c;
        int num1, num2;
        printf ("Enter operator:");
        scanf ("%c", & c);
        printf ("Enter two integer's :");
        scanf ("%d %d", & num1, & num2);
        switch (c) {
        case '+' :
            printf ("%d + %d = %d", num1, num2, num1 +num2);
            break;
        case '-' :
            printf ("%d - %d = %d", num1, num2, num1 -num2);
            break;
        case '*' :
            printf ("%d * %d = %d", num1, num2, num1 *num2);
            break;
        case '/' :
            printf ("%d / %d = %d", num1, num2, num1 / num2);
            break;
        default :
            printf ("The value of c = '%c'\n", c);
            return (0);
        }
    }
    else if (choice == 3)
        printf ("Enter two \n");
}
----------------------------------------

int main (void) {
    int choice;
    printf ("Enter 1 for Programmers Name and ID\n");
    printf ("Enter 2 to Perform Integer Operation\n");
    printf ("Enter 3 to Perform Floating Point Operation\n");
    scanf ("%d", & choice);
    if (choice == 1) {
        printf ("Connor \n000000000\n");
    }
    else if (choice == 2) {
        char c;
        int num1, num2;
        printf ("Enter operator:");
        scanf (" %c", & c);
        printf ("Enter two integers :");
        scanf ("%d %d", & num1, & num2);
        switch (c) {
        case '+' :
            printf ("%d + %d = %d\n", num1, num2, num1 +num2);
            break;
        case '-' :
            printf ("%d - %d = %d\n", num1, num2, num1 -num2);
            break;
        case '*' :
            printf ("%d * %d = %d\n", num1, num2, num1 *num2);
            break;
        case '/' :
            printf ("%d / %d = %d\n", num1, num2, num1 / num2);
            break;
        default :
            printf ("The value of c = '%c'\n", c);
            break;
        }
    }
    else if (choice == 3) {
        printf ("Enter two \n");
    }
    else {
        printf ("Invalid choice.\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26236060_26236439_5_19
26236060_26240993_4_24
Title: Sscanf reads a line twice? 
----------------------------------------

int main () {
    char line [10];
    int row, column, data;
    fp = fopen ("data.txt", "rt");
    while (fgets (line, 10, fp) != NULL) {
        if (line[0] == '\n')
            continue;
        sscanf (line, "%d,%d,%d\n", & row, & column, & data);
        printf ("[Row: %d Column: %d Data %d]\n", row, column, data);
    }
    fclose (fp);
    return 0;
}
----------------------------------------

int main (void) {
    FILE *fp;
    char line [10];
    int row, column, data;
    fp = fopen ("data.txt", "rt");
    while (fgets (line, sizeof line, fp) != NULL) {
        int n1, n2;
        int cnt = sscanf (line, " %n%d ,%d ,%d %n", &n1, &row, &column, &data, &n2);
        if (n1 > 0 && line[n1] == '\0')
            Handle_Line_Is_Entirely_Whitespace ();
        else if (cnt != 3 || line[n2])
            Handle_IncorrectlyFormattedLine ();
        else
            printf ("[Row: %d Column: %d Data %d]\n", row, column, data);
    }
    fclose (fp);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26263157_26263505_2_24
26263157_26264392_12_39
Title: C Program Returns Unexpected Numbers 
----------------------------------------

int main () {
    const char *str = "this is string to count";
    int counts [256] = {0};
    int i, letters = 0;
    size_t len = strlen (str);
    for (i = 0; i < len; i++) {
        counts[(int) (str[i])]++;
    }
    for (i = 0; i < 256; i++) {
        if (counts[i] > 0) {
            printf ("%c occurs %d times.\n", i, counts [i]);
            if ((char) i != ' ') {
                letters += counts[i];
            }
        }
    }
    printf ("Number of letters : %d", letters);
    getchar ();
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int counter_max = 1 + UCHAR_MAX;
    int *counter = calloc ((size_t) counter_max, sizeof (int));
    unsigned char *buffer = calloc (BUFFER_SIZE, sizeof (*buffer));
    int bufl;
    while ((bufl = fread (buffer, sizeof (*buffer), BUFFER_SIZE, stdin)) > 0) {
        for (unsigned char *p = buffer; p < buffer + bufl; ++p) {
            unsigned char c = tolower (*p);
            ++*(counter + c);
        }
    }
    for (int *p = counter + A; p <= counter + Z; ++p) {
        int n = *p;
        if (n > 0) {
            char c = p - counter;
            printf ("The letter '%c' was found %d times.\n", c, n);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26263157_26263505_2_24
26263157_26267060_4_25
Title: C Program Returns Unexpected Numbers 
----------------------------------------

int main () {
    const char *str = "this is string to count";
    int counts [256] = {0};
    int i, letters = 0;
    size_t len = strlen (str);
    for (i = 0; i < len; i++) {
        counts[(int) (str[i])]++;
    }
    for (i = 0; i < 256; i++) {
        if (counts[i] > 0) {
            printf ("%c occurs %d times.\n", i, counts [i]);
            if ((char) i != ' ') {
                letters += counts[i];
            }
        }
    }
    printf ("Number of letters : %d", letters);
    getchar ();
    return 0;
}
----------------------------------------

int main () {
    char text [10] = "";
    int timesUsed [26] = {0};
    int textLength = 0;
    int inputLength = 0;
    inputLength = fread (&text, sizeof (char), 10, stdin);
    for (int i = 0; i < inputLength; i++) {
        if (isalpha (text[i])) {
            textLength++;
            char c = tolower (text[i]);
            timesUsed[text[i] - 'a']++;
        }
        if (text[i] == '\n')
            break;
    }
    printf ("Number of letters:%20d\n", textLength);
    int i;
    for (i = 0; i < 26; i++) {
        if (timesUsed [i] > 0) {char thechar = (char) 'a' + i;
        printf ("The letter %c was used %5d time(s).\n", thechar, timesUsed [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26263157_26264392_12_39
26263157_26267060_4_25
Title: C Program Returns Unexpected Numbers 
----------------------------------------

int main (int argc, char *argv []) {
    int counter_max = 1 + UCHAR_MAX;
    int *counter = calloc ((size_t) counter_max, sizeof (int));
    unsigned char *buffer = calloc (BUFFER_SIZE, sizeof (*buffer));
    int bufl;
    while ((bufl = fread (buffer, sizeof (*buffer), BUFFER_SIZE, stdin)) > 0) {
        for (unsigned char *p = buffer; p < buffer + bufl; ++p) {
            unsigned char c = tolower (*p);
            ++*(counter + c);
        }
    }
    for (int *p = counter + A; p <= counter + Z; ++p) {
        int n = *p;
        if (n > 0) {
            char c = p - counter;
            printf ("The letter '%c' was found %d times.\n", c, n);
        }
    }
    return 0;
}
----------------------------------------

int main () {
    char text [10] = "";
    int timesUsed [26] = {0};
    int textLength = 0;
    int inputLength = 0;
    inputLength = fread (&text, sizeof (char), 10, stdin);
    for (int i = 0; i < inputLength; i++) {
        if (isalpha (text[i])) {
            textLength++;
            char c = tolower (text[i]);
            timesUsed[text[i] - 'a']++;
        }
        if (text[i] == '\n')
            break;
    }
    printf ("Number of letters:%20d\n", textLength);
    int i;
    for (i = 0; i < 26; i++) {
        if (timesUsed [i] > 0) {char thechar = (char) 'a' + i;
        printf ("The letter %c was used %5d time(s).\n", thechar, timesUsed [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26270610_26270675_1_12
26270610_26270727_3_21
Title: getting error in exchanging the base address of 2d araay using a third variable 
----------------------------------------

int main () {
    char names [5] [20] = {"rrr", "kkkk", "hddj", "dhfjdj", "jjdnfjd"};
    int i;
    char *t = malloc (20 * sizeof (char));
    strcpy (t, names [3]);
    strcpy (names [3], names [4]);
    strcpy (names [4], t);
    for (i = 0;
    i <= 4;
    i ++) {printf ("%s\n", names [i]);
}
----------------------------------------

int main () {
    char names [5] [20] = {"rrr", "kkkk", "hddj", "dhfjdj", "jjdnfjd"};
    int i;
    char t [20];
    strcpy (t, names [3]);
    strcpy (names [3], names [4]);
    strcpy (names [4], t);
    for (i = 0; i <= 4; i++) {
        printf ("%s\n", names [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26274616_26274785_10_33
26274616_26275513_11_31
Title: C reshape 1d to 2d 
----------------------------------------

int main () {
    Array1D *a1 = malloc (sizeof (*a1));
    Array2D *a2 = (Array2D *) a1;
    int i, j;
    for (i = 0; i < M * N; ++i) {
        (*a1)[i] = i;
    }
    for (i = 0; i < M; ++i) {
        for (j = 0; j < N; ++j) {
            printf ("%8d", (* a2) [i] [j]);
        }
        printf ("\n");
    }
    free (a1);
    return 0;
}
----------------------------------------

int main () {
    U u;
    int i, j;
    for (i = 0; i < M * N; ++i) {
        u.a1[i] = i;
    }
    for (i = 0; i < M; ++i) {
        for (j = 0; j < N; ++j) {
            printf ("%8d", u.a2 [i] [j]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26274616_26274785_10_33
26274616_26276195_11_24
Title: C reshape 1d to 2d 
----------------------------------------

int main () {
    Array1D *a1 = malloc (sizeof (*a1));
    Array2D *a2 = (Array2D *) a1;
    int i, j;
    for (i = 0; i < M * N; ++i) {
        (*a1)[i] = i;
    }
    for (i = 0; i < M; ++i) {
        for (j = 0; j < N; ++j) {
            printf ("%8d", (* a2) [i] [j]);
        }
        printf ("\n");
    }
    free (a1);
    return 0;
}
----------------------------------------

int main (void) {
    dim1 = malloc (sizeof (int) * FULL);
    nested = malloc (sizeof (int *) * X);
    for (int i = 0; i < X; i++) {
        nested[i] = &dim1[Y * i];
    }
    dim1[15] = 42;
    printf ("nested[1][5]: %d", nested [1] [5]);
    free (nested);
    free (dim1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26274616_26275513_11_31
26274616_26276195_11_24
Title: C reshape 1d to 2d 
----------------------------------------

int main () {
    U u;
    int i, j;
    for (i = 0; i < M * N; ++i) {
        u.a1[i] = i;
    }
    for (i = 0; i < M; ++i) {
        for (j = 0; j < N; ++j) {
            printf ("%8d", u.a2 [i] [j]);
        }
        printf ("\n");
    }
    return 0;
}
----------------------------------------

int main (void) {
    dim1 = malloc (sizeof (int) * FULL);
    nested = malloc (sizeof (int *) * X);
    for (int i = 0; i < X; i++) {
        nested[i] = &dim1[Y * i];
    }
    dim1[15] = 42;
    printf ("nested[1][5]: %d", nested [1] [5]);
    free (nested);
    free (dim1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26308246_26308293_4_27
26308246_26308517_8_36
Title: Any reason why a loop wouldn't terminate even with an 'i' limiting value of repeats? 
----------------------------------------

int main (void) {
    int i = 0, u = 1000, l = -1000;
    float a, b, c, d, mid, y;
    scanf (" %f %f %f %f", & a, & b, & c, & d);
    while (abs (u -l) > 0.001 && i < 10) {
        mid = (u + l) / 2;
        y = a * pow (mid, 3) + b * pow (mid, 2) + c * mid + d;
        if (y == 0)
            break;
        else if (y < 0)
            l = mid;
        else
            u = mid;
        i++;
    }
    printf ("\nThere is a root at: x = %.3f\n", mid);
}
----------------------------------------

int main (void) {
    int n = 0;
    float fa, fc, b = 1000.0, a = -1000.0;
    float p3, p2, p1, p0, c;
    scanf (" %f %f %f %f", & p3, & p2, & p1, & p0);
    while (n < NMAX) {
        c = (a + b) / 2.0;
        fc = p3 * pow (c, 3) + p2 * pow (c, 2) + p1 * c + p0;
        if (fc == 0.0 || (b - a) / 2.0 < TOL)
            break;
        fa = p3 * pow (a, 3) + p2 * pow (a, 2) + p1 * a + p0;
        if (sign (fc) == sign (fa))
            a = c;
        else
            b = c;
        n++;
    }
    if (n == NMAX) {
        printf ("Method failed.\n");
    }
    else {
        printf ("\nThere is a root at: x = %.3f\n", c);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26311439_26311960_5_26
26311439_26312236_3_32
Title: sieve of Eratosthenes output error 
----------------------------------------

int main () {
    int n;
    printf ("Enter the value of n\n");
    scanf_s ("%d", & n);
    int A [size], i, j;
    A[0] = 1;
    A[1] = 1;
    for (i = 2; i < n + 1; i++)
        A[i] = 0;
    for (i = 2; i < sqrt ((float) n + 1); i++)
        if (A[i] == 0)
            for (j = i * i; j < n + 1; j = j + i)
                A[j] = 1;
    for (i = 0; i < n + 1; i++)
        if (A[i] == 0)
            printf ("%d\n", i);
}
----------------------------------------

int main () {
    int a [20];
    int i, n, j;
    n = 20;
    for (i = 0; i < n; i++)
        a[i] = i + 1;
    for (i = 2; i < n / 2; i++) {
        for (j = 2; j <= (n / i); j++) {
            a[(i * j) - 1] = 0;
        }
    }
    for (i = 0; i < n; i++) {
        if (a[i] != 0)
            printf (" %d", a[i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26318361_26318481_9_34
26318361_26318740_1_50
Title: Extracting an 4 digit int (decimal) into string in C manually 
----------------------------------------

void main (void) {
    char OUT [5];
    memset (OUT, 0, 5);
    int i = 0;
    int j;
    uint16_t IN = 549;
    while (IN != 0) {
        OUT[i++] = '0' + (IN % 10);
        IN /= 10;
    }
    for (j = 0; j < i / 2; j++) {
        char temp = OUT[j];
        OUT[j] = OUT[i - 1 - j];
        OUT[i - 1 - j] = temp;
    }
    printf ("String is -> %s\n", OUT);
}
----------------------------------------

void main (void) {
    char OUT [5];
    OUT[0] = '0';
    OUT[1] = '0';
    OUT[2] = '0';
    OUT[3] = '0';
    OUT[4] = '0';
    uint8_t length = 5;
    uint8_t i = 2;
    uint16_t IN = 4012;
    uint16_t mod = 0;
    while (IN / 10 > 0) {
        mod = IN % 10;
        OUT[length - i] = '0' + mod;
        IN = IN / 10;
        if (IN <= 10) {
            if (IN == 10) {
                OUT[length - (i + 2)] = '1';
                OUT[length - (i + 1)] = '0';
                IN = 0;
            }
            else {
                OUT[length - (i + 1)] = '0' + IN;
                IN = 0;
            }
        }
        i++;
    }
    OUT[length - 1] = '\n';
    printf ("String is -> %s", OUT);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26330952_26331160_1_20
26330952_26331347_8_29
Title: linked list moving node to the end C 
----------------------------------------

struct struct_type *move (struct struct_type *list, struct struct_type *element) {
    struct struct_type *l = list;
    if (l == NULL)
        return l;
    if (l == element)
        list = l->next;
    while (l->next != NULL) {
        if (l->next == element)
            l->next = l->next->next;
        l = l->next;
    }
    l->next = element;
    element->next = NULL;
    return list;
}
----------------------------------------

struct node *move (struct node *list, struct node *element) {
    struct node *head = list;
    struct node *prev = NULL, *curr = head;
    if (list == NULL || list->next == NULL)
        return head;
    while (curr) {
        if (curr == element) {
            if (curr == head) {
                head = curr->next;
            }
            else {
                prev->next = curr->next;
            }
            curr = curr->next;
        }
        else {
            prev = curr;
            curr = curr->next;
        }
    }
    prev->next = element;
    element->next = NULL;
    return head;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26339927_26340421_3_24
26339927_26341854_4_21
Title: character array triangle having characters seperated with spaces in C language 
----------------------------------------

int main () {
    char msg [] = "this is the best way to spend time";
    int i, spc;
    for (spc = 1;; ++spc) {
        int count_spc = 0;
        for (i = 0; msg[i]; ++i) {
            if (msg[i] == ' ') {
                ++count_spc;
                if (count_spc == spc) {
                    printf ("\n");
                    break;
                }
            }
            printf ("%c", msg [i]);
        }
        if (msg[i] == '\0')
            break;
    }
    return 0;
}
----------------------------------------

int main (int _, char **ptr) {
    char msg [198] = "this is the worst way to spend your time";
    ptr[0] = msg, ptr[1] = msg;
    while (*ptr[0]) {
        if (*ptr[0] == ' ') {
            memmove (ptr [0] + 1, ptr [1], strlen (ptr [1]) + 1);
            *ptr[0]++ = 012;
            ptr[2] = ptr[0];
            ptr[0] = ptr[1] + ((ptr[0] - ptr[1]) << 1);
            ptr[1] = ptr[2];
        }
        ptr[0]++;
    }
    return printf ("%s\n", msg);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26343018_26343359_1_10
26343018_26343412_1_14
Title: Practice Exam Questions 
----------------------------------------

void keepname (struct bodytp *onept, const char *last) {
    int len;
    char *tpt;
    for (len = 0; last[len] != '\0'; len++)
        ;
    char *name = malloc (len +1);
    onept->name = name;
    onept->len = len;
    for (; *name++ = *last++;)
        ;
}
----------------------------------------

void keepname (struct bodytp *onept, const char *last) {
    int len = 0;
    char *tpt;
    while (last[len] != '\0')
        len++;
    char *name = malloc (len +1);
    for (tpt = name; *tpt++ = *last++;)
        ;
    onept->name = name;
    onept->len = len;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26343889_45776962_1_22
26343889_45777447_3_32
Title: Star pattern in C 
----------------------------------------

int main (void) {
    int i, j;
    int NumMax = 5;
    for (i = 0; i < NumMax; i++) {
        if ((i % 2) == 0) {
            printf (" ");
            for (j = 0; j < 2; j++) {
                printf ("*");
            }
        }
        else {
            for (j = 0;
            j < 4;
            j ++) {printf ("*");
        }
    }
    printf ("\n");
}
----------------------------------------

int main (void) {
    int i, j, m, k;
    int numMax = 6;
    for (i = 1; i < (numMax * 2) - 4; i++) {
        if (((30 % i) == 0) && (i != 1)) {
            for (k = 1; k < 2; k++) {
                for (m = 1; m <= numMax; m++) {
                    printf ("*");
                }
                printf ("\n");
            }
        }
        else {
            for (j = 1; j < 2; j++) {
                printf ("  **");
            }
            printf ("\n");
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26368697_26369504_1_27
26368697_26373938_1_17
Title: Return to the beginning of an if statement 
----------------------------------------

function main () {
    if (blablabla) {
        printf ("blabla");
        return false;
    }
    if (blablabla) {
        printf ("blabla");
        return false;
    }
    if (blablabla) {
        printf ("blabla");
        return false;
    }
    return true;
}
----------------------------------------

int main () {
    int number1;
    int loop_state = 0;
    do {
        printf ("Please enter a number:");
        scanf ("%d", & number1);
        switch (number1) {
        case 1 :
            break;
        case 2 :
            break;
        default :
            loot_state = 1;
        }
    }
    while (loop_state == 1);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26402045_26402800_1_13
26402045_26403544_3_15
Title: Why output of even integers is not working properly 
----------------------------------------

int main () {
    int i, n, sum = 0;
    scanf ("%d", & n);
    for (i = 0; i <= n; i++) {
        if (i % 2 == 0) {
            printf ("%d ", sum);
            sum += 2;
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n;
    scanf ("%d", & n);
    for (int i = 2; i <= n; i++) {
        if (i % 2 == 0) {
            printf ("%d ", i);
        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26406192_26406536_1_16
26406192_26407067_1_13
Title: Infiny calculator 
----------------------------------------

char *add_inf (char *nb1, char *nb2, char *rslt) {
    if (*nb1 && *nb2) {
        *rslt = (*nb1 - '0' + *nb2 - '0' > 9 ? (*nb1 - '0' + *nb2 - '0') % 10 : *nb1 - '0' + *nb2 - '0') + *rslt - '0' + '0';
        if (*nb1 - '0' + *nb2 - '0' > 9) {
            rslt++;
            *rslt = '1';
            add_inf (nb1 + 1, nb2 + 1, rslt);
        }
        else
            add_inf (nb1 +1, nb2 +1, rslt +1);
    }
    return (rslt);
}
----------------------------------------

char *add_inf (char *nb1, char *nb2, char *rslt) {
    if (*nb1 && *nb2) {
        int sum = (*nb1 - '0' + *nb2 - '0' + *rslt - '0');
        *(rslt + 0) = (sum % 10) + '0';
        if (sum / 10)
            *(rslt + 1) = (sum / 10) + '0';
        add_inf (nb1 + 1, nb2 + 1, rslt + 1);
    }
    return rslt;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26441387_26441703_1_16
26441387_26441815_16_44
Title: How to print values from an input data file from an array? 
----------------------------------------

int main (int argc, char *argv []) {
    soundsource_t soundsource [MAXSOURCES];
    int i, n = 0;
    while (scanf ("%lf %lf %lf", &a.x, &a.y, &b.w) == 3) {
        soundsource[n].point = a;
        soundsource[n].w = b.w;
        n += 1;
    }
    for (i = 0; i < n; i++) {
        printf ("%f,", soundsource [i].point.x);
        printf ("%f ", soundsource [i].point.y);
        printf ("%f\n", soundsource [i].w);
    }
    return 0;
}
----------------------------------------

int main (int argc, char *argv []) {
    int i, n = 0;
    soundsource_t array [MAXSOURCES];
    while (scanf ("%lf %lf %lf", &(array[n].point.x), &(array[n].point.y), &(array[n].w)) == 3) {
        n++;
        if (n == MAXSOURCES)
            break;
    }
    for (i = 0; i < n; ++i) {
        printf ("%lf %lf %lf\n", array [i].point.x, array [i].point.y, array [i].w);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26451209_26451774_9_64
26451209_26452827_10_34
Title: How to take a string and arrange words in alphabetical order using C 
----------------------------------------

int main (int argc, const char *argv []) {
    char *sentence = "The quick brown fox jumps over the lazy dog.";
    char to_ignore [10] = ".,-\"'!?()";
    char words [_NWORDS] [_WLEN];
    int i, j, k = 0, l = 0, word_count, swapped = 0;
    for (i = 0; i < _NWORDS * _WLEN; i++) {
        if (*(sentence + i) == '\0') {
            words[k][l] = '\0';
            word_count = k + 1;
            break;
        }
        for (j = 0; j < 10; j++) {
            if (to_ignore[j] == *(sentence + i))
                goto END_FOR;
        }
        if (*(sentence + i) != ' ') {
            words[k][l] = *(sentence + i);
            l++;
        }
        else {
            words[k][l] = '\0';
            k++;
            l = 0;
        }
    END_FOR :
        ;
    }
    for (i = 0; i < word_count; i++) {
        for (j = 0; j < _WLEN; j++) {
            if (words[i][j] == '\0')
                break;
            if (words[i][j] >= 65 && words[i][j] <= 90)
                words[i][j] += 32;
        }
    }
    do {
        for (i = 0; i < word_count - 1; i++) {
            if (strcmp (words[i], words[i + 1]) > 0) {
                word_swap (& words [i], & words [i + 1]);
                swapped = 1;
                break;
            }
            else
                swapped = 0;
        }
    }
    while (swapped != 0);
    for (i = 0; i < word_count; i++)
        printf ("%s\n", words[i]);
}
----------------------------------------

int main () {
    char str [] = "This is a test String, anything else? lol";
    char *word, *words [strlen (str) / 2 + 1];
    int i, n;
    for (i = 0; str[i]; i++) {
        str[i] = tolower (str[i]);
    }
    i = 0;
    word = strtok (str, " ,.-:;?!");
    while (word != NULL) {
        words[i++] = word;
        word = strtok (NULL, " ,.-:;?!");
    }
    n = i;
    qsort (words, n, sizeof (* words), cmp);
    for (i = 0; i < n; ++i)
        puts (words[i]);
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26451988_26452257_10_28
26451988_26452369_9_24
Title: Array of dynamic string: allocation in external function 
----------------------------------------

int main () {
    char *array [N];
    for (size_t i = 0; i < N; ++i) {
        insert (array, i);
    }
    for (size_t i = 0; i < N; ++i) {
        printf ("String %zu: %s\n", i + 1, array [i]);
        free (array [i]);
    }
    return 0;
}
----------------------------------------

int main (void) {
    char *array [N] = {NULL};
    int i, n;
    for (i = 0; i < N; ++i) {
        insert (array, i);
        if (*array[i] == '\0')
            break;
    }
    n = i;
    for (i = 0; i < n; ++i) {
        puts (array [i]);
        free (array [i]);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26451988_26452257_30_53
26451988_26452369_26_38
Title: Array of dynamic string: allocation in external function 
----------------------------------------

void insert (char **arrayPTR, int i) {
    printf ("Enter the string: ");
    fflush (stdout);
    char str [MAX_BUFFER];
    fgets (str, MAX_BUFFER, stdin);
    const size_t sl = strlen (str);
    if (str[sl - 1] == '\n') {
        str[sl - 1] = 0;
    }
    if (!(arrayPTR[i] = malloc (strlen (str) +1))) {
        perror ("couldn't allocate memory");
        exit (EXIT_FAILURE);
    }
    strcpy (arrayPTR [i], str);
}
----------------------------------------

void insert (char *arrayPTR [N], int i) {
    int ch, count = 0;
    char *string = malloc (1);
    printf ("Enter the string: ");
    while (EOF != (ch = getchar ()) && ch != '\n') {
        string = realloc (string, count +2);
        string[count++] = ch;
    }
    string[count] = '\0';
    arrayPTR[i] = string;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26455599_26455958_7_37
26455599_26456713_1_22
Title: Deleting front node from a Singly Linked List in C 
----------------------------------------

void delete_node (struct node **head_ref, int num) {
    struct node *temp;
    struct node *current = (*head_ref);
    if (current != NULL && current->number == num) {
        temp = current;
        current = current->next;
        free (temp);
        (*head_ref) = current;
    }
    else {
        while (current != NULL) {
            if (current->next != NULL && current->next->number == num) {
                temp = current->next;
                current->next = temp->next;
                free (temp);
                break;
            }
            current = current->next;
        }
    }
}
----------------------------------------

void delete_node (node **head_ref, int num) {
    node *temp;
    node *last = 0;
    node *current = *head_ref;
    while (current) {
        if (current->number == num) {
            temp = current;
            if (current == *head_ref)
                current = (*head_ref) = current->next;
            else
                current = last->next = current->next;
            free (temp);
        }
        else {
            last = current;
            current = current->next;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26460414_26461324_4_43
26460414_26461750_4_37
Title: drawing two consecutive triangle in c 
----------------------------------------

int main (void) {
    while (1) {
        size_t n = 0;
        size_t m = 0;
        printf ("Enter the base length of the first triangle: ");
        scanf ("%zu", & n);
        if (n == 0)
            break;
        printf ("Enter the base length of the second triangle: ");
        scanf ("%zu", & m);
        if (m == 0)
            break;
        puts ("");
        char left [n + 1];
        char right [m + 1];
        memset (left, '*', n);
        memset (right, '*', m);
        left[n] = '\0';
        right[m] = '\0';
        size_t max = n < m ? m : n;
        for (size_t i = 0; i < max; i++) {
            printf ("%-*s %*s\n", n, left, m, right);
            if (i < n)
                left[n - i - 1] = '\0';
            if (i < m)
                right[m - i - 1] = '\0';
        }
    }
    return 0;
}
----------------------------------------

int main (void) {
    int n;
    int small, big;
    printf ("Input length of total: ");
    scanf ("%d", & n);
    small = n / 4;
    big = small * 3;
    int total = small + big;
    int height = (big - 1) / 2 + 1;
    char canvas [height] [total];
    memset (canvas, '0', sizeof (canvas));
    int i, v, h;
    for (i = 0, v = height; i < height; ++i) {
        int len;
        --v;
        len = small - i * 2;
        if (len > 0)
            memset (&canvas[v][i], '*', len);
        len = big - i * 2;
        if (len > 0)
            memset (&canvas[v][small + i], '*', len);
    }
    putchar ('\n');
    for (v = 0; v < height; ++v) {
        for (h = 0; h < total; ++h)
            putchar (canvas[v][h]);
        putchar ('\n');
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
26474263_26475129_23_41
26474263_26475368_21_31
Title: Return a string on C 
----------------------------------------

int main (void) {
    char fileName [256];
    char newFileName [256];
    strcpy (fileName, "foo.bar");
    GetNewFileName (fileName, newFileName);
    printf ("%s %s\n", fileName, newFileName);
    strcpy (fileName, "foo.bar.palz");
    GetNewFileName (fileName, newFileName);
    printf ("%s %s\n", fileName, newFileName);
    strcpy (fileName, "foo.bar.palz.txt");
    GetNewFileName (fileName, newFileName);
    printf ("%s %s\n", fileName, newFileName);
    return 0;
}
----------------------------------------

int main (int ac, char **av) {
    if (ac > 1) {
        const char *p = checkExtension (av[1]);
        puts (p ? p : "NULL");
    }
    else {
        puts ("?");
    }
    return 0;
}
----------------------------------------
