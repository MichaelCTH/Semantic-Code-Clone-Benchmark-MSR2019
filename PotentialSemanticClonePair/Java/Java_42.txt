$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22385467_22385614_204_224
22385467_22408887_101_121
Title: Crockford base32 encoding for large number - Java implementation 
----------------------------------------

public boolean good (String s) {
    boolean good = true;
    for (int i = 0;
    i < s.length () && good; i ++) {
        char c = s.charAt (i);
        if (parseTable != null) {
            if (c < parseTable.length) {
                good = parseTable [c] != Invalid;
            } else {
                good = false;
            }
        } else {
            good = Character.digit (c, radix) != - 1;
        }
    }
    return good;
}
----------------------------------------

public boolean good (String s) {
    boolean good = true;
    for (int i = 0;
    i < s.length () && good; i ++) {
        char c = s.charAt (i);
        if (parseTable != null) {
            if (c < parseTable.length) {
                good = parseTable [c] != Invalid;
            } else {
                good = false;
            }
        } else {
            good = Character.digit (c, radix) != - 1;
        }
    }
    return good;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22385467_22385614_73_118
22385467_22408887_134_179
Title: Crockford base32 encoding for large number - Java implementation 
----------------------------------------

private int [] buildParseTable (String characterSet, String...extras) {
    int [] table = new int ['z' + 1];
    Arrays.fill (table, Invalid);
    String lc = characterSet.toLowerCase ();
    String uc = characterSet.toUpperCase ();
    for (int i = 0;
    i < radix; i ++) {
        char l = lc.charAt (i);
        char u = uc.charAt (i);
        if (table [l] == Invalid && table [u] == Invalid) {
            table [l] = i;
            table [u] = i;
        } else {
            throw new NumberFormatException ("Invalid character set - duplicate found at position " + i);
        }
    }
    for (String pair : extras) {
        if (pair.length () == 2) {
            int f = pair.charAt (1);
            int t = pair.charAt (0);
            if (table [f] != Invalid && table [t] == Invalid) {
                table [t] = table [f];
            } else {
                throw new NumberFormatException ("Invalid character set extra - copying from " + f + " to " + t);
            }
        } else {
            throw new NumberFormatException ("Invalid extra \"" + pair + "\" - should be 2 characters wide.");
        }
    }
    return table;
}
----------------------------------------

private int [] buildParseTable (String characterSet, String...extras) {
    int [] table = new int ['z' + 1];
    Arrays.fill (table, Invalid);
    String lc = characterSet.toLowerCase ();
    String uc = characterSet.toUpperCase ();
    for (int i = 0;
    i < radix; i ++) {
        char l = lc.charAt (i);
        char u = uc.charAt (i);
        if (table [l] == Invalid && table [u] == Invalid) {
            table [l] = i;
            table [u] = i;
        } else {
            throw new NumberFormatException ("Invalid character set - duplicate found at position " + i);
        }
    }
    for (String pair : extras) {
        if (pair.length () == 2) {
            int f = pair.charAt (1);
            int t = pair.charAt (0);
            if (table [f] != Invalid && table [t] == Invalid) {
                table [t] = table [f];
            } else {
                throw new NumberFormatException ("Invalid character set extra - copying from " + f + " to " + t);
            }
        } else {
            throw new NumberFormatException ("Invalid extra \"" + pair + "\" - should be 2 characters wide.");
        }
    }
    return table;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22388434_22389136_33_45
22388434_22389136_4_23
Title: Set a launcher without leaving the current activity 
----------------------------------------

public static void D (Activity paramActivity) {
    PackageManager localPackageManager = paramActivity.getPackageManager ();
    localPackageManager.setComponentEnabledSetting (new ComponentName (paramActivity.getPackageName (), "com.teslacoilsw.launcher.homereset.HomeReset"), 1, 1);
    Intent localIntent = new Intent ("android.intent.action.MAIN", null);
    localIntent.addCategory ("android.intent.category.HOME");
    localIntent.addFlags (270532608);
    localIntent.addFlags (268435456);
    localIntent.putExtra ("homereset_return_to_settings", true);
    paramActivity.startActivity (localIntent);
    localPackageManager.setComponentEnabledSetting (new ComponentName (paramActivity.getPackageName (), "com.teslacoilsw.launcher.homereset.HomeReset"), 2, 1);
    paramActivity.startActivity (localIntent);
}
----------------------------------------

public static ComponentName D (PackageManager paramPackageManager) {
    ComponentName localComponentName = null;
    try {
        Intent localIntent = new Intent ("android.intent.action.MAIN", null);
        localIntent.addCategory ("android.intent.category.HOME");
        localIntent.addFlags (270532608);
        localComponentName = localIntent.resolveActivity (paramPackageManager);
        if (("android".equals (localComponentName.getPackageName ())) && ("com.android.internal.app.ResolverActivity".equals (localComponentName.getClassName ()))) {
            return null;
        }
        return localComponentName;
    } catch (Exception localException) {
        Log.e ("HomeReseter", "Exception when trying to find default home", localException);
    }
    return localComponentName;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22401949_22402531_1_31
22401949_22402582_1_20
Title: Find the range of a set of numbers 
----------------------------------------

public static void main (String [] args) {
    Scanner console = new Scanner (System.in);
    ArrayList < Integer > ints = new ArrayList < Integer > ();
    for (int i = 0;
    i < 100; i ++) {
        ints.add (i);
    }
    System.out.println ("Enter the first range number");
    int first = console.nextInt ();
    System.out.println ("Enter the last range number");
    int last = console.nextInt ();
    ArrayList < Integer > rangedInts = new ArrayList < Integer > ();
    int min = 0;
    for (int i = 0;
    i < ints.size (); i ++) {
        for (int num : ints) {
            if (num >= first && num <= last && num > min && ! rangedInts.contains (num)) {
                min = num;
                rangedInts.add (num);
            }
        }
    }
    for (int integer : rangedInts) {
        System.out.println (integer);
    }
}
----------------------------------------

public static void main (String args []) {
    Scanner num = new Scanner (System.in);
    int n = 0, min = 0, max = 0;
    ArrayList < Integer > a = new ArrayList < Integer > ();
    for (int i = 0;
    i < 10; i ++) {
        System.out.println (" Enter the number" + (i + 1) + " : ");
        n = num.nextInt ();
        if (i == 0) min = max = n;
        else {
            if (n < min) min = n;
            else if (n > max) max = n;

        }
        a.add (n);
    }
    System.out.println ("The range is " + (max - min));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22407538_22407618_1_10
22407538_22407650_1_11
Title: how to stop a boolean return from breaking a loop? 
----------------------------------------

public static boolean isSorted (double [] list) {
    boolean isSorted = true;
    for (int i = 1;
    i < list.length; i ++) {
        if (list [i] > list [i + 1]) {
            System.out.println ("Not Sorted");
            isSorted = false;
        }
    }
    return isSorted;
}
----------------------------------------

public static boolean isSorted (double [] list) {
    for (int i = 0;
    i < list.length - 1; i ++) {
        if (list [i] > list [i + 1]) {
            System.out.println ("Not Sorted");
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22407538_22407618_1_10
22407538_22407671_1_10
Title: how to stop a boolean return from breaking a loop? 
----------------------------------------

public static boolean isSorted (double [] list) {
    boolean isSorted = true;
    for (int i = 1;
    i < list.length; i ++) {
        if (list [i] > list [i + 1]) {
            System.out.println ("Not Sorted");
            isSorted = false;
        }
    }
    return isSorted;
}
----------------------------------------

public static boolean isSorted (double [] list) {
    for (int i = 1;
    i < list.length; i ++) {
        if (list [i - 1] > list [i]) {
            System.out.println ("Not Sorted");
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22407538_22407635_1_15
22407538_22407650_1_11
Title: how to stop a boolean return from breaking a loop? 
----------------------------------------

public static boolean isSorted (double [] list) {
    boolean result = true;
    for (int i = 1;
    i < list.length; i ++) {
        if (list [i - 1] > list [i]) {
            System.out.println ("Not Sorted");
            result = false;
            break;
        }
    }
    return result;
}
----------------------------------------

public static boolean isSorted (double [] list) {
    for (int i = 0;
    i < list.length - 1; i ++) {
        if (list [i] > list [i + 1]) {
            System.out.println ("Not Sorted");
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22407538_22407635_1_15
22407538_22407671_1_10
Title: how to stop a boolean return from breaking a loop? 
----------------------------------------

public static boolean isSorted (double [] list) {
    boolean result = true;
    for (int i = 1;
    i < list.length; i ++) {
        if (list [i - 1] > list [i]) {
            System.out.println ("Not Sorted");
            result = false;
            break;
        }
    }
    return result;
}
----------------------------------------

public static boolean isSorted (double [] list) {
    for (int i = 1;
    i < list.length; i ++) {
        if (list [i - 1] > list [i]) {
            System.out.println ("Not Sorted");
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22412544_22425451_17_26
22412544_22425598_18_28
Title: Swingworker queue and single using 
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            new QueueSWTest ();
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    SwingUtilities.invokeLater (new Runnable () {
        @Override
        public void run () {
            createAndShowGUI ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2241513_12491300_1_26
2241513_12684280_41_63
Title: Java Printing a Binary Tree using Level-Order in a Specific Format 
----------------------------------------

public void printTree (TreeNode tmpRoot) {
    Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ();
    Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ();
    currentLevel.add (tmpRoot);
    while (! currentLevel.isEmpty ()) {
        Iterator < TreeNode > iter = currentLevel.iterator ();
        while (iter.hasNext ()) {
            TreeNode currentNode = iter.next ();
            if (currentNode.left != null) {
                nextLevel.add (currentNode.left);
            }
            if (currentNode.right != null) {
                nextLevel.add (currentNode.right);
            }
            System.out.print (currentNode.value + " ");
        }
        System.out.println ();
        currentLevel = nextLevel;
        nextLevel = new LinkedList < TreeNode > ();
    }
}
----------------------------------------

public void printTree () {
    LinkedBlockingQueue < Tree > q = new LinkedBlockingQueue < Tree > ();
    q.add (this.tree);
    while (true) {
        LinkedBlockingQueue < Tree > subQueue = new LinkedBlockingQueue < Tree > ();
        while (! q.isEmpty ()) {
            Tree aTree = q.remove ();
            System.out.print (aTree.getValue () + ", ");
            if (aTree.getLeft () != null) {
                subQueue.add (aTree.getLeft ());
            }
            if (aTree.getRight () != null) {
                subQueue.add (aTree.getRight ());
            }
        }
        System.out.println ("");
        if (subQueue.isEmpty ()) {
            return;
        } else {
            q = subQueue;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2241513_12491300_1_26
2241513_4321761_6_60
Title: Java Printing a Binary Tree using Level-Order in a Specific Format 
----------------------------------------

public void printTree (TreeNode tmpRoot) {
    Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ();
    Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ();
    currentLevel.add (tmpRoot);
    while (! currentLevel.isEmpty ()) {
        Iterator < TreeNode > iter = currentLevel.iterator ();
        while (iter.hasNext ()) {
            TreeNode currentNode = iter.next ();
            if (currentNode.left != null) {
                nextLevel.add (currentNode.left);
            }
            if (currentNode.right != null) {
                nextLevel.add (currentNode.right);
            }
            System.out.print (currentNode.value + " ");
        }
        System.out.println ();
        currentLevel = nextLevel;
        nextLevel = new LinkedList < TreeNode > ();
    }
}
----------------------------------------

public void printTree (TreeNode tmpRoot) {
    if (tmpRoot != null) {
        Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ();
        Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ();
        int treeHeight = height (tmpRoot);
        int levelTotal = 0;
        currentLevel.add (tmpRoot);
        while (! currentLevel.isEmpty () && (levelTotal < treeHeight)) {
            while (! currentLevel.isEmpty ()) {
                System.out.print (currentLevel.peek ().getValue () + " ");
                tmpRoot = currentLevel.peek ().getLeft ();
                if (tmpRoot != null) nextLevel.add (tmpRoot);
                else nextLevel.add (new TreeNode (null));

                tmpRoot = currentLevel.remove ().getRight ();
                if (tmpRoot != null) nextLevel.add (tmpRoot);
                else nextLevel.add (new TreeNode (null));

            }
            while (! nextLevel.isEmpty ()) {
                currentLevel.add (nextLevel.remove ());
            }
            System.out.println ("");
            levelTotal ++;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2241513_12684280_41_63
2241513_4321761_6_60
Title: Java Printing a Binary Tree using Level-Order in a Specific Format 
----------------------------------------

public void printTree () {
    LinkedBlockingQueue < Tree > q = new LinkedBlockingQueue < Tree > ();
    q.add (this.tree);
    while (true) {
        LinkedBlockingQueue < Tree > subQueue = new LinkedBlockingQueue < Tree > ();
        while (! q.isEmpty ()) {
            Tree aTree = q.remove ();
            System.out.print (aTree.getValue () + ", ");
            if (aTree.getLeft () != null) {
                subQueue.add (aTree.getLeft ());
            }
            if (aTree.getRight () != null) {
                subQueue.add (aTree.getRight ());
            }
        }
        System.out.println ("");
        if (subQueue.isEmpty ()) {
            return;
        } else {
            q = subQueue;
        }
    }
}
----------------------------------------

public void printTree (TreeNode tmpRoot) {
    if (tmpRoot != null) {
        Queue < TreeNode > currentLevel = new LinkedList < TreeNode > ();
        Queue < TreeNode > nextLevel = new LinkedList < TreeNode > ();
        int treeHeight = height (tmpRoot);
        int levelTotal = 0;
        currentLevel.add (tmpRoot);
        while (! currentLevel.isEmpty () && (levelTotal < treeHeight)) {
            while (! currentLevel.isEmpty ()) {
                System.out.print (currentLevel.peek ().getValue () + " ");
                tmpRoot = currentLevel.peek ().getLeft ();
                if (tmpRoot != null) nextLevel.add (tmpRoot);
                else nextLevel.add (new TreeNode (null));

                tmpRoot = currentLevel.remove ().getRight ();
                if (tmpRoot != null) nextLevel.add (tmpRoot);
                else nextLevel.add (new TreeNode (null));

            }
            while (! nextLevel.isEmpty ()) {
                currentLevel.add (nextLevel.remove ());
            }
            System.out.println ("");
            levelTotal ++;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2241513_23468592_1_29
2241513_32393074_1_20
Title: Java Printing a Binary Tree using Level-Order in a Specific Format 
----------------------------------------

public static void printByLevel (Node root) {
    LinkedList < Node > curLevel = new LinkedList < Node > ();
    LinkedList < Node > nextLevel = curLevel;
    StringBuilder sb = new StringBuilder ();
    curLevel.add (root);
    sb.append (root.data + "\n");
    while (nextLevel.size () > 0) {
        nextLevel = new LinkedList < Node > ();
        for (int i = 0;
        i < curLevel.size (); i ++) {
            Node cur = curLevel.get (i);
            if (cur.left != null) {
                nextLevel.add (cur.left);
                sb.append (cur.left.data + " ");
            }
            if (cur.right != null) {
                nextLevel.add (cur.right);
                sb.append (cur.right.data + " ");
            }
        }
        if (nextLevel.size () > 0) {
            sb.append ("\n");
            curLevel = nextLevel;
        }
    }
    System.out.println (sb.toString ());
}
----------------------------------------

public static void printByLevel (Node root) {
    Queue < Node > firstQ = new LinkedList < > ();
    firstQ.add (root);
    Queue < Queue < Node > > mainQ = new LinkedList < > ();
    mainQ.add (firstQ);
    while (! mainQ.isEmpty ()) {
        Queue < Node > levelQ = mainQ.remove ();
        Queue < Node > nextLevelQ = new LinkedList < > ();
        for (Node x : levelQ) {
            System.out.print (x.key + " ");
            if (x.left != null) nextLevelQ.add (x.left);

            if (x.right != null) nextLevelQ.add (x.right);

        }
        if (! nextLevelQ.isEmpty ()) mainQ.add (nextLevelQ);

        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2241513_26111157_1_13
2241513_9321754_9_18
Title: Java Printing a Binary Tree using Level-Order in a Specific Format 
----------------------------------------

void printLevel (ArrayList < Node > n) {
    ArrayList < Node > next = new ArrayList < Node > ();
    for (Node t : n) {
        System.out.print (t.value + " ");
        if (t.left != null) next.add (t.left);

        if (t.right != null) next.add (t.right);

    }
    System.out.println ();
    if (next.size () != 0) printLevel (next);

}
----------------------------------------

public void printLevel (BNode node, int level) {
    if (node == null) return;

    if (level == 1) System.out.print (node.value + " ");
    else if (level > 1) {
        printLevel (node.left, level - 1);
        printLevel (node.right, level - 1);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2241513_27845062_1_31
2241513_9223817_1_12
Title: Java Printing a Binary Tree using Level-Order in a Specific Format 
----------------------------------------

public ArrayList < ArrayList < Integer > > levelOrder (TreeNode root) {
    ArrayList < ArrayList < Integer > > result = new ArrayList < ArrayList < Integer > > ();
    if (root == null) return result;

    Queue q1 = new LinkedList ();
    Queue q2 = new LinkedList ();
    ArrayList < Integer > list = new ArrayList < Integer > ();
    q1.add (root);
    while (! q1.isEmpty () || ! q2.isEmpty ()) {
        while (! q1.isEmpty ()) {
            TreeNode temp = (TreeNode) q1.poll ();
            list.add (temp.val);
            if (temp.left != null) q2.add (temp.left);

            if (temp.right != null) q2.add (temp.right);

        }
        if (list.size () > 0) result.add (new ArrayList < Integer > (list));

        list.clear ();
        while (! q2.isEmpty ()) {
            TreeNode temp = (TreeNode) q2.poll ();
            list.add (temp.val);
            if (temp.left != null) q1.add (temp.left);

            if (temp.right != null) q1.add (temp.right);

        }
        if (list.size () > 0) result.add (new ArrayList < Integer > (list));

        list.clear ();
    }
    return result;
}
----------------------------------------

public void levelOrder (List < TreeNode > n) {
    List < TreeNode > next = new ArrayList < TreeNode > ();
    for (TreeNode t : n) {
        if (t != null) {
            System.out.print (t.getValue ());
            next.add (t.getLeftChild ());
            next.add (t.getRightChild ());
        }
    }
    System.out.println ();
    if (next.size () > 0) levelOrder (next);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22428060_22428136_12_24
22428060_22428142_1_13
Title: Printing Stars in java 
----------------------------------------

public static void drawBar (double value, double max) {
    final int MAX_STARS = 20;
    String BAR_REP = "*";
    double correctRatio = (value / max) * MAX_STARS;
    if (correctRatio <= MAX_STARS) {
        for (int index = 0;
        index < correctRatio; index ++) {
            System.out.print (BAR_REP);
        }
    }
    System.out.println ();
}
----------------------------------------

public static void drawBar (double value, double max) {
    final int MAX_STARS = 20;
    final double ratio = value / max;
    if (Double.compare (ratio, 1.0) > 0) return;

    final int nrElements = (int) (ratio * MAX_STARS);
    final char [] array = new char [nrElements];
    Arrays.fill (array, '*');
    System.out.println (new String (array));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22430181_22430220_13_35
22430181_22430289_1_27
Title: Dice Rolling Program 
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader input = new BufferedReader (new InputStreamReader (System.in));
    int dealerValue = dice ();
    System.out.print ("Dealer rolled a dice and here is your turn.\n" + "Enter a number: ");
    int userValue = Integer.parseInt (input.readLine ());
    int difference = Math.abs (randomValue - userValue);
    int profit = difference == 0 ? 10 : difference == 1 ? 3 : difference == 2 ? 1 : - 3;
    System.out.println ("Dealer's number was " + dealerValue);
    System.out.println ("You " + ((profit >= 0) ? "won" : "lost") + " $" + Math.abs (profit));
}
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    int dealerValue = (int) (Math.random () * 6) + 1;
    System.out.println ("Dealer rolled a dice and here is your turn.");
    System.out.print ("Enter a number : ");
    int inputValue = scanner.nextInt ();
    if (inputValue == dealerValue) {
        System.out.println ("Dealer's number was " + dealerValue);
        System.out.println ("You won $10 ");
    } else if (Math.abs (dealerValue - inputValue) == 1) {
        System.out.println ("Dealer's number was " + dealerValue);
        System.out.println ("You won $3 ");
    } else if (Math.abs (dealerValue - inputValue) == 2) {
        System.out.println ("Dealer's number was " + dealerValue);
        System.out.println ("You won $1 ");
    } else {
        System.out.println ("Dealer's number was " + dealerValue);
        System.out.println ("You lost $3 ");
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22440231_22440379_1_12
22440231_22440531_1_12
Title: Need help diagnosing a NullPointerException 
----------------------------------------

public void add (final T data) {
    if (start == null) {
        start = new Node_ < T > (data, 0);
        end = start;
        ptr = start;
        total ++;
    } else {
        end.setNext (new Node_ < T > (data, total));
        total ++;
        end = end.getNext ();
    }
}
----------------------------------------

public void add (T data) {
    if (start == null) {
        start = new Node_ < T > (data, 0);
        end = start;
        ptr = start;
        total ++;
    } else {
        end.set ((T) data, (int) total);
        total ++;
        end = end.getNext ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22440564_22441752_12_31
22440564_22441752_33_52
Title: Binary Tree implementation for adding nodes level by level 
----------------------------------------

protected void add (int data) {
    System.out.println ("data k: " + data);
    Node t;
    if (root == null) {
        root = new Node (data);
        level ++;
    } else {
        cLevel = 0;
        boolean added = add (data, root);
        if (! added) {
            level ++;
            cLevel = 0;
            add (data, root);
        }
    }
}
----------------------------------------

private boolean add (int data, Node node) {
    cLevel ++;
    boolean added;
    if (cLevel <= level) {
        added = true;
        if (node.left == null) node.left = new Node (data);
        else if (node.right == null) node.right = new Node (data);
        else if (! add (data, node.left)) added = add (data, node.right);

    } else {
        added = false;
    }
    cLevel --;
    return added;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22440564_22441752_12_31
22440564_22466863_1_31
Title: Binary Tree implementation for adding nodes level by level 
----------------------------------------

protected void add (int data) {
    System.out.println ("data k: " + data);
    Node t;
    if (root == null) {
        root = new Node (data);
        level ++;
    } else {
        cLevel = 0;
        boolean added = add (data, root);
        if (! added) {
            level ++;
            cLevel = 0;
            add (data, root);
        }
    }
}
----------------------------------------

protected void add (int data, Tree mytree) {
    if (root == null) {
        root = new Node (data);
        myList.addLast (root);
        root.count ++;
        return;
    }
    Node node = mytree.myList.getFirst ();
    if (root != null) {
        if (node.left == null) {
            node.count ++;
            node.left = new Node (data);
            mytree.myList.add (node.left);
            return;
        } else {
            node.count ++;
            node.right = new Node (data);
            mytree.myList.add (node.right);
        }
        if (node.left != null & node.right != null) {
            mytree.myList.removeFirst ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22440564_22441752_33_52
22440564_22466863_1_31
Title: Binary Tree implementation for adding nodes level by level 
----------------------------------------

private boolean add (int data, Node node) {
    cLevel ++;
    boolean added;
    if (cLevel <= level) {
        added = true;
        if (node.left == null) node.left = new Node (data);
        else if (node.right == null) node.right = new Node (data);
        else if (! add (data, node.left)) added = add (data, node.right);

    } else {
        added = false;
    }
    cLevel --;
    return added;
}
----------------------------------------

protected void add (int data, Tree mytree) {
    if (root == null) {
        root = new Node (data);
        myList.addLast (root);
        root.count ++;
        return;
    }
    Node node = mytree.myList.getFirst ();
    if (root != null) {
        if (node.left == null) {
            node.count ++;
            node.left = new Node (data);
            mytree.myList.add (node.left);
            return;
        } else {
            node.count ++;
            node.right = new Node (data);
            mytree.myList.add (node.right);
        }
        if (node.left != null & node.right != null) {
            mytree.myList.removeFirst ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22446583_22446688_7_24
22446583_22446793_9_24
Title: Writing a program to find Length C of a triangle 
----------------------------------------

public static void main (String [] args) throws java.lang.Exception {
    Scanner scan = new Scanner (System.in);
    double a, b, c;
    System.out.println ("Length of side a?");
    a = scan.nextDouble ();
    System.out.println ("Length of side b?");
    b = scan.nextDouble ();
    c = java.lang.Math.sqrt (java.lang.Math.pow (a, 2) + java.lang.Math.pow (b, 2));
    System.out.print ("The length of side C is ");
    System.out.println (c + "units.");
    scan.close ();
}
----------------------------------------

public static void main (String [] args) {
    double a, b, c;
    Scanner scan = new Scanner (System.in);
    System.out.println ("Length of side a?");
    a = scan.nextDouble ();
    System.out.println ("Length of side b?");
    b = scan.nextDouble ();
    c = Math.sqrt ((a * a + b * b));
    System.out.print ("The length of side C is");
    System.out.println (c + "units.");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22446594_22446666_1_34
22446594_29265582_1_18
Title: Specific Practice-It ArrayList Error 
----------------------------------------

public static void removeShorterStrings (ArrayList < String > shorty) {
    List < String > tmp = new ArrayList < > ();
    if (shorty.size () < 0 || shorty.size () == 1) return;

    if (shorty.size () % 2 == 0) for (int i = 0;
    i < shorty.size (); i += 2) {
        if (shorty.get (i).length () < shorty.get (i + 1).length ()) tmp.add (shorty.get (i + 1));
        else tmp.add (shorty.get (i));

    }
    else {
        int i = 0;
        for (i = 0; i < shorty.size () - 1; i += 2) {
            if (shorty.get (i).length () < shorty.get (i + 1).length ()) tmp.add (shorty.get (i + 1));
            else tmp.add (shorty.get (i));

        }
        tmp.add (shorty.get (shorty.size () - 1));
    }
    shorty.clear ();
    for (String s : tmp) shorty.add (s);

}
----------------------------------------

public void removeShorterStrings (ArrayList < String > list) {
    for (int i = 0;
    i < list.size () - 1; i += 2) {
        if (list.get (i).length () < list.get (i + 1).length ()) list.set (i, "o345ty34fty");
        else if (list.get (i).length () > list.get (i + 1).length ()) list.set (i + 1, "o345ty34fty");
        else if (list.get (i).length () == list.get (i + 1).length ()) list.set (i, "o345ty34fty");

    }
    int index = list.indexOf ("o345ty34fty");
    while (index >= 0) {
        list.remove (index);
        index = list.indexOf ("o345ty34fty");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22455726_22455897_1_15
22455726_22455929_1_18
Title: Comparing items in a stack 
----------------------------------------

public boolean isPalindrome (Stack a, Stack b) {
    if (a.size () != b.size ()) {
        return false;
    }
    while (a.size () > 0) {
        if (! a.pop ().equals (b.pop ())) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isPalindrome (Stack a, Stack b) {
    Object temp1;
    Object temp2;
    boolean answer = true;
    for (int i = 0;
    a.size () > 0; i ++) {
        temp1 = a.pop ();
        temp2 = b.pop ();
        if (temp1 != temp2) {
            answer = false;
            break;
        }
    }
    return answer;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22455726_22455897_1_15
22455726_22455961_1_11
Title: Comparing items in a stack 
----------------------------------------

public boolean isPalindrome (Stack a, Stack b) {
    if (a.size () != b.size ()) {
        return false;
    }
    while (a.size () > 0) {
        if (! a.pop ().equals (b.pop ())) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isPalindrome (Stack a, Stack b) {
    if (a.size () != b.size ()) return false;

    while (a.size () > 0) {
        if (a.pop () != b.pop ()) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22455726_22455929_1_18
22455726_22455961_1_11
Title: Comparing items in a stack 
----------------------------------------

public boolean isPalindrome (Stack a, Stack b) {
    Object temp1;
    Object temp2;
    boolean answer = true;
    for (int i = 0;
    a.size () > 0; i ++) {
        temp1 = a.pop ();
        temp2 = b.pop ();
        if (temp1 != temp2) {
            answer = false;
            break;
        }
    }
    return answer;
}
----------------------------------------

public boolean isPalindrome (Stack a, Stack b) {
    if (a.size () != b.size ()) return false;

    while (a.size () > 0) {
        if (a.pop () != b.pop ()) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2245869_2247067_1_16
2245869_3587861_1_27
Title: Resize JComponent for file export 
----------------------------------------

public void export (File file, int width, int height) throws IOException {
    BufferedImage scaledImage = new BufferedImage (width, height, BufferedImage.TYPE_INT_RGB);
    Graphics2D g2 = scaledImage.createGraphics ();
    g2.scale (((double) width) / ((double) getWidth ()), ((double) height) / ((double) getHeight ()));
    paintComponents (g2);
    try {
        ImageIO.write (scaledImage, "jpg", file);
    } catch (FileNotFoundException e) {
        throw new IOException ("Unable to export chart to (" + file.getAbsolutePath () + "): " + e.getLocalizedMessage ());
    } finally {
        g2.dispose ();
    }
}
----------------------------------------

public void export (File file, final int width, final int height) throws IOException {
    BufferedImage image = new BufferedImage (width, height, BufferedImage.TYPE_INT_ARGB);
    final Graphics2D g2 = image.createGraphics ();
    try {
        SwingUtilities.invokeAndWait (new Runnable () {
            public void run () {
                draw (g2, new Rectangle (0, 0, width, height));
            }}

        );
        ImageIO.write (image, "png", file);
    } catch (Exception e) {
        throw new IOException ("Unable to export chart to (" + file.getAbsolutePath () + "): " + e.getLocalizedMessage ());
    } finally {
        g2.dispose ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2247063_2247163_1_20
2247063_2247212_1_17
Title: Need help in returning from a recursive method 
----------------------------------------

private List trace (Node parent, Node node) {
    List path = null;
    if (null != node) {
        if (node.data == parent.data) {
            path = new ArrayList ();
        } else {
            path = trace (parent.left, node);
            if (null == path) {
                path = trace (parent.right, node);
            }
        }
        if (null != path) {
            path.add (0, parent);
        }
    }
    return path;
}
----------------------------------------

private boolean trace (Node parent, Node node) {
    mainStack.push (parent);
    if (node.data == parent.data) {
        for (Node iNode : mainStack) {
            System.out.println (iNode.data);
        }
        return true;
    }
    if (parent.left != null) {
        if (trace (parent.left, node)) return true;

    }
    if (parent.right != null) {
        if (trace (parent.right, node)) return true;

    }
    mainStack.pop ();
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22483332_23775560_1_13
22483332_30422453_1_12
Title: Codingbat array2 no14 
----------------------------------------

public boolean no14 (int [] nums) {
    int one = 0;
    int four = 0;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 1) one ++;

        if (nums [i] == 4) four ++;

    }
    if (one > 0 && four > 0) return false;
    else return true;

}
----------------------------------------

public boolean no14 (int [] nums) {
    boolean isOne = false;
    boolean isFour = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (! isOne && nums [i] == 1) {
            isOne = true;
        } else if (! isFour && nums [i] == 4) {
            isFour = true;
        }

    }
    return ! (isOne && isFour);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22483332_23775560_1_13
22483332_31441103_1_19
Title: Codingbat array2 no14 
----------------------------------------

public boolean no14 (int [] nums) {
    int one = 0;
    int four = 0;
    for (int i = 0;
    i < nums.length; i ++) {
        if (nums [i] == 1) one ++;

        if (nums [i] == 4) four ++;

    }
    if (one > 0 && four > 0) return false;
    else return true;

}
----------------------------------------

public boolean no14 (int [] nums) {
    boolean containsNoOnes = true, containsNoFours = true;
    for (int i : nums) {
        if (i == 1) containsNoOnes = false;

        if (i == 4) containsNoFours = false;

    }
    return containsNoOnes || containsNoFours;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22483332_30422453_1_12
22483332_31441103_1_19
Title: Codingbat array2 no14 
----------------------------------------

public boolean no14 (int [] nums) {
    boolean isOne = false;
    boolean isFour = false;
    for (int i = 0;
    i < nums.length; i ++) {
        if (! isOne && nums [i] == 1) {
            isOne = true;
        } else if (! isFour && nums [i] == 4) {
            isFour = true;
        }

    }
    return ! (isOne && isFour);
}
----------------------------------------

public boolean no14 (int [] nums) {
    boolean containsNoOnes = true, containsNoFours = true;
    for (int i : nums) {
        if (i == 1) containsNoOnes = false;

        if (i == 4) containsNoFours = false;

    }
    return containsNoOnes || containsNoFours;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22492000_22590964_28_38
22492000_22590964_48_60
Title: Wait for recursive Thread-Producer 
----------------------------------------

public void run () {
    while (! Thread.interrupted ()) {
        System.out.print ("Producer Started");
        try {
            blockingQueue.put (new Message ());
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        System.out.println ("Producer Done");
    }
}
----------------------------------------

public void run () {
    while (! Thread.interrupted ()) {
        System.out.print ("Concumer Started");
        try {
            Message message = blockingQueue.take ();
            System.out.print ("message Id" + message.messageId + " Consumed ");
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        System.out.println ("Concumer Done");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22495997_22496077_1_13
22495997_22496240_11_30
Title: "Reverse sentences lines and words of a file" 
----------------------------------------

public static void main (String [] args) {
    String s = "I want cake today.";
    String [] ss = s.split (" ");
    Stack < String > sss = new Stack < > ();
    for (String ssss : ss) {
        sss.push (ssss);
    }
    while (! sss.isEmpty ()) {
        System.out.print (sss.pop ());
        System.out.print (" ");
    }
}
----------------------------------------

public static void main (String [] args) throws FileNotFoundException {
    ArrayList < String > revFile = new ArrayList < String > ();
    Scanner input = new Scanner (new File ("/reverse.txt"));
    while (input.hasNextLine ()) {
        revFile.add (input.nextLine ());
    }
    for (int i = (revFile.size () - 1);
    i >= 0; i --) {
        String ar [] = revFile.get (i).split (" ");
        for (int j = (ar.length - 1);
        j >= 0; j --) {
            System.out.print (ar [j] + " ");
        }
        System.out.println (" ");
        ar = null;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22508874_22509001_8_32
22508874_37436552_12_46
Title: get prime numbers and total prime numbers in range 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    System.out.println ("Enter the number till which the prime numbers are to be calculated: ");
    int input = scanner.nextInt ();
    List < Integer > primes = new ArrayList < > ();
    for (int i = 2;
    i < input; i ++) {
        boolean isPrimeNumber = true;
        for (int j = 2;
        j < i; j ++) {
            if (i % j == 0) {
                isPrimeNumber = false;
                break;
            }
        }
        if (isPrimeNumber) {
            primes.add (i);
        }
    }
    System.out.println ("The number of prime is: " + primes.size () + ", and they are: " + primes.toString ());
}
----------------------------------------

public static void main (String [] args) throws NumberFormatException, IOException {
    int count = 0;
    int limit;
    System.out.println ("Enter the Limit:");
    InputStreamReader read = new InputStreamReader (System.in);
    BufferedReader in = new BufferedReader (read);
    limit = Integer.parseInt (in.readLine ());
    System.out.println ("Prime numbers From 1 to " + limit);
    for (int i = 1;
    i < limit; i ++) {
        boolean isPrime = true;
        for (int j = 2;
        j < i; j ++) {
            if (i % j == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            System.out.print (i + " ");
            count ++;
        }
    }
    System.out.println ("\nTotal Prime Number in given range: " + count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22508874_22509001_8_32
22508874_42676421_3_28
Title: get prime numbers and total prime numbers in range 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    System.out.println ("Enter the number till which the prime numbers are to be calculated: ");
    int input = scanner.nextInt ();
    List < Integer > primes = new ArrayList < > ();
    for (int i = 2;
    i < input; i ++) {
        boolean isPrimeNumber = true;
        for (int j = 2;
        j < i; j ++) {
            if (i % j == 0) {
                isPrimeNumber = false;
                break;
            }
        }
        if (isPrimeNumber) {
            primes.add (i);
        }
    }
    System.out.println ("The number of prime is: " + primes.size () + ", and they are: " + primes.toString ());
}
----------------------------------------

public static void main (String [] args) {
    int limit = 30;
    System.out.println ("Prime numbers between 1 and " + limit + " (except the number 2) :");
    System.out.println ();
    int amount = 1;
    for (int dividend = 2;
    dividend <= limit; dividend ++) {
        for (int divider = 2;
        divider < dividend; divider ++) {
            int remaining = dividend % divider;
            if (remaining == 0) {
                break;
            }
            if (divider == dividend - 1) {
                System.out.println (dividend + " IS A PRIME NUMBER.");
                amount ++;
            }
        }
    }
    System.out.println ();
    System.out.println ("There are a total of " + amount + " prime numbers between 1 and " + limit + " including the number 2. ");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22508874_22513401_10_36
22508874_37436552_12_46
Title: get prime numbers and total prime numbers in range 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    System.out.print ("Enter the number till which the prime numbers are to be calculated: ");
    int input = scanner.nextInt ();
    scanner.close ();
    List < Integer > primes = new ArrayList < > ();
    for (int i = 2;
    i < input; i ++) {
        boolean isPrimeNumber = true;
        for (int j = 2;
        j < i; j ++) {
            if (i % j == 0) {
                isPrimeNumber = false;
                break;
            }
        }
        if (isPrimeNumber) {
            primes.add (i);
        }
    }
    String s = primes.toString ().replace ("[", "").replace ("]", "");
    System.out.println ("The number of prime is: " + primes.size () + ", and they are: " + s);
}
----------------------------------------

public static void main (String [] args) throws NumberFormatException, IOException {
    int count = 0;
    int limit;
    System.out.println ("Enter the Limit:");
    InputStreamReader read = new InputStreamReader (System.in);
    BufferedReader in = new BufferedReader (read);
    limit = Integer.parseInt (in.readLine ());
    System.out.println ("Prime numbers From 1 to " + limit);
    for (int i = 1;
    i < limit; i ++) {
        boolean isPrime = true;
        for (int j = 2;
        j < i; j ++) {
            if (i % j == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            System.out.print (i + " ");
            count ++;
        }
    }
    System.out.println ("\nTotal Prime Number in given range: " + count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22508874_22513401_10_36
22508874_42676421_3_28
Title: get prime numbers and total prime numbers in range 
----------------------------------------

public static void main (String [] args) {
    Scanner scanner = new Scanner (System.in);
    System.out.print ("Enter the number till which the prime numbers are to be calculated: ");
    int input = scanner.nextInt ();
    scanner.close ();
    List < Integer > primes = new ArrayList < > ();
    for (int i = 2;
    i < input; i ++) {
        boolean isPrimeNumber = true;
        for (int j = 2;
        j < i; j ++) {
            if (i % j == 0) {
                isPrimeNumber = false;
                break;
            }
        }
        if (isPrimeNumber) {
            primes.add (i);
        }
    }
    String s = primes.toString ().replace ("[", "").replace ("]", "");
    System.out.println ("The number of prime is: " + primes.size () + ", and they are: " + s);
}
----------------------------------------

public static void main (String [] args) {
    int limit = 30;
    System.out.println ("Prime numbers between 1 and " + limit + " (except the number 2) :");
    System.out.println ();
    int amount = 1;
    for (int dividend = 2;
    dividend <= limit; dividend ++) {
        for (int divider = 2;
        divider < dividend; divider ++) {
            int remaining = dividend % divider;
            if (remaining == 0) {
                break;
            }
            if (divider == dividend - 1) {
                System.out.println (dividend + " IS A PRIME NUMBER.");
                amount ++;
            }
        }
    }
    System.out.println ();
    System.out.println ("There are a total of " + amount + " prime numbers between 1 and " + limit + " including the number 2. ");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22508874_37436552_12_46
22508874_42676421_3_28
Title: get prime numbers and total prime numbers in range 
----------------------------------------

public static void main (String [] args) throws NumberFormatException, IOException {
    int count = 0;
    int limit;
    System.out.println ("Enter the Limit:");
    InputStreamReader read = new InputStreamReader (System.in);
    BufferedReader in = new BufferedReader (read);
    limit = Integer.parseInt (in.readLine ());
    System.out.println ("Prime numbers From 1 to " + limit);
    for (int i = 1;
    i < limit; i ++) {
        boolean isPrime = true;
        for (int j = 2;
        j < i; j ++) {
            if (i % j == 0) {
                isPrime = false;
                break;
            }
        }
        if (isPrime) {
            System.out.print (i + " ");
            count ++;
        }
    }
    System.out.println ("\nTotal Prime Number in given range: " + count);
}
----------------------------------------

public static void main (String [] args) {
    int limit = 30;
    System.out.println ("Prime numbers between 1 and " + limit + " (except the number 2) :");
    System.out.println ();
    int amount = 1;
    for (int dividend = 2;
    dividend <= limit; dividend ++) {
        for (int divider = 2;
        divider < dividend; divider ++) {
            int remaining = dividend % divider;
            if (remaining == 0) {
                break;
            }
            if (divider == dividend - 1) {
                System.out.println (dividend + " IS A PRIME NUMBER.");
                amount ++;
            }
        }
    }
    System.out.println ();
    System.out.println ("There are a total of " + amount + " prime numbers between 1 and " + limit + " including the number 2. ");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22515360_22515470_2_13
22515360_22516098_4_16
Title: Eclipse finds a bug but I don't see it 
----------------------------------------

public static void main (String [] args) {
    int y = 0;
    while (num >= base) {
        int x = (num % base);
        num = num / base;
        y = (y + (x * (10 ^ i)));
    }
    System.out.println (y);
}
----------------------------------------

public static void main (String [] args) {
    Scanner myscanner = new Scanner (System.in);
    int num = myscanner.nextInt ();
    int base = myscanner.nextInt ();
    int i = 0;
    int y = 0;
    while (num >= base) {
        int x = (num % base);
        num = num / base;
        y = (y + (x * (10 ^ i)));
    }
    System.out.println (y);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22519055_22519251_9_39
22519055_22519725_11_42
Title: Java - add the number or symbol to the text field when pressing a button 
----------------------------------------

public CalcFrame () {
    super ("Calculator");
    setLayout (new FlowLayout ());
    JTextField calcTextField = new JTextField (19);
    add (calcTextField);
    calcTextField.setEditable (false);
    JPanel buttonPanel = new JPanel ();
    buttonPanel.setLayout (new GridLayout (4, 4));
    List < String > buttonNames = Arrays.asList ("7", "8", "9", "/", "4", "5", "6", "*", "1", "2", "3", "-", "0", ".", "=", "+");
    buttonNames.forEach (bt -> {
        JButton button = new JButton (bt);
        button.addActionListener (e -> calcTextField.setText (calcTextField.getText () + ((JButton) e.getSource ()).getText ()));
        buttonPanel.add (button);
    });
    add (buttonPanel);
    this.setDefaultCloseOperation (JFrame.EXIT_ON_CLOSE);
    this.pack ();
    this.setVisible (true);
}
----------------------------------------

public CalcFrame () {
    super ("Calculator");
    setLayout (new FlowLayout ());
    calcTextField = new JTextField (19);
    calcTextField.setPreferredSize (new Dimension (0, 50));
    add (calcTextField);
    calcTextField.setEditable (false);
    JPanel buttonPanel = new JPanel ();
    buttonPanel.setLayout (new GridLayout (5, 4, 10, 10));
    String [] buttonNames = {"7", "8", "9", "/", "4", "5", "6", "*", "1", "2", "3", "-", "0", ".", "=", "+", "C", "(", ")"};
    for (String buttonText : buttonNames) {
        JButton button = new JButton (buttonText);
        buttonPanel.add (button);
        button.addActionListener (this);
    }
    buttonPanel.setPreferredSize (new Dimension (220, 250));
    add (buttonPanel);
    sem = new ScriptEngineManager ();
    scriptEngine = sem.getEngineByName ("JavaScript");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22528225_22528344_8_16
22528225_22528503_1_22
Title: Method that creates new array only from the even numbers in Java 
----------------------------------------

static Integer [] myMethod (int [] inputArray) {
    List < Integer > temp = new ArrayList < Integer > ();
    for (int i = 0;
    i < inputArray.length; i ++) {
        if (inputArray [i] % 2 == 0) {
            temp.add (inputArray [i]);
        }
    }
    return temp.toArray (new Integer [5]);
}
----------------------------------------

public static int [] myMethod (int [] arr) {
    List < Integer > even = new ArrayList < Integer > ();
    for (int i = 0;
    i < arr.length; i ++) {
        if (arr [i] % 2 == 0) {
            even.add (arr [i]);
        }
    }
    int [] result = new int [even.toArray ().length];
    Iterator it = even.iterator ();
    int count = 0;
    while (it.hasNext ()) {
        result [count ++] = (int) it.next ();
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22531710_22531734_1_18
22531710_22531839_10_27
Title: NullPointerException crashes android app 
----------------------------------------

protected void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.create);
    createButton = (Button) findViewById (R.id.apptSave);
    nameTextBox = (EditText) findViewById (R.id.apptName);
    timeTextBox = (EditText) findViewById (R.id.apptTime);
    detailsTextBox = (EditText) findViewById (R.id.apptDetails);
    createButton.setOnClickListener (this);
    String getNewDate = date.toString ();
    String getNewTitle = nameTextBox.getText ().toString ();
    String getNewTime = timeTextBox.getText ().toString ();
    String getNewDetails = detailsTextBox.getText ().toString ();
}
----------------------------------------

protected void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    setContentView (R.layout.create);
    createButton = (Button) findViewById (R.id.apptSave);
    nameTextBox = (EditText) findViewById (R.id.apptName);
    timeTextBox = (EditText) findViewById (R.id.apptTime);
    detailsTextBox = (EditText) findViewById (R.id.apptDetails);
    String getNewDate = date.toString ();
    String getNewTitle = nameTextBox.getText ().toString ();
    String getNewTime = timeTextBox.getText ().toString ();
    String getNewDetails = detailsTextBox.getText ().toString ();
    createButton.setOnClickListener (this);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22543708_22545035_60_77
22543708_22545035_79_98
Title: "Java loop through 2d array in any direction" 
----------------------------------------

private static void shift (int array [] [], int dr, int dc) {
    boolean shifted = true;
    while (shifted) {
        shifted = false;
        for (int r = 0;
        r < array.length; r ++) {
            for (int c = 0;
            c < array [r].length; c ++) {
                if (array [r] [c] != 0) {
                    shifted |= shift (array, r, c, dr, dc);
                }
            }
        }
    }
}
----------------------------------------

private static boolean shift (int [] [] array, int r, int c, int dr, int dc) {
    int value = array [r] [c];
    array [r] [c] = 0;
    int cr = r;
    int cc = c;
    while (isValid (array, cr, cc)) {
        int tr = cr + dr;
        int tc = cc + dc;
        if (! isValid (array, tr, tc) || array [tr] [tc] != 0) {
            break;
        }
        cr = tr;
        cc = tc;
    }
    array [cr] [cc] = value;
    return cr != r || cc != c;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22547864_22548975_8_68
22547864_22549887_1_19
Title: I'm stuck building a line reader with interfaces in Java 
----------------------------------------

public static void main (String [] args) {
    System.out.println ("Welcome to the File Processor");
    Scanner scan = new Scanner (System.in);
    System.out.print ("\nWould you like to begin? (yes or no): ");
    String startProgram = scan.next ();
    if (startProgram.equalsIgnoreCase ("yes")) {
        System.out.println ("\nSelect a file.\n");
        JFileChooser chooser = new JFileChooser ();
        File inputFile = null;
        if (chooser.showOpenDialog (null) == JFileChooser.APPROVE_OPTION) {
            inputFile = new File (chooser.getSelectedFile ().getAbsolutePath ());
            try {
                Scanner file = new Scanner (inputFile);
                file.useDelimiter ("\n");
                String data = "";
                FileProcessor fp = new FileProcessor ();
                while (file.hasNext ()) {
                    String line = file.next ();
                    System.out.println ("Original: " + line);
                    System.out.println ("To Upper Case: " + fp.Upper (line));
                    System.out.println ("Count: " + fp.Count (line));
                    System.out.println ();
                    data += line;
                }
                System.out.println ("\nFile Processing complete!\n");
                System.out.print ("Save copy of file? (yes or no): ");
                String save = scan.next ();
                if (save.equalsIgnoreCase ("yes")) {
                    fp.Save (data, "copy.txt");
                    System.out.println ("\nProgram Ending... Goodbye!");
                } else {
                    System.out.println ("\nProgram Ending... Goodbye!");
                }
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    } else {
        System.out.println ("\nProgram Ending... Goodbye!");
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader in = new BufferedReader (new FileReader (args [0]));
    try (CharacterCountingWriter ccw = new CharacterCountingWriter (new FileWriter (args [1])); UpperCaseFilterWriter ucfw = new UpperCaseFilterWriter (ccw); Writer pipeline = ucfw) {
        String line;
        while (null != (line = in.readLine ())) {
            ccw.resetCharCount ();
            pipeline.write (line);
            System.out.println (ccw.getCharCount ());
            pipeline.write (System.lineSeparator ());
        }
        pipeline.flush ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554459_27_34
22554373_22554500_22_29
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554459_27_34
22554373_22554613_25_32
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554459_27_34
22554373_22554620_26_33
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < (number / 2); i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554459_27_34
22554373_33425906_1_20
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isPrime (long pNo) {
    if (pNo > 9) {
        long unitDigit = pNo % 10;
        if (unitDigit == 0 || unitDigit % 2 == 0 || unitDigit == 5) {
            return false;
        } else {
            for (long i = 3;
            i < pNo / 2; i = i + 2) {
                if (pNo % i == 0) {
                    return false;
                }
            }
            return true;
        }
    } else if (pNo < 0) {
        return false;
    } else {
        return pNo == 2 || pNo == 3 || pNo == 5 || pNo == 7;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554459_4_21
22554373_22554500_1_15
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the amount of prime numbers to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    int count = 1;
    System.out.println ("Printing prime number from 1 to " + limit);
    for (int number = 2;
    count <= limit; number ++) {
        if (isPrime (number)) {
            System.out.println (number);
            count ++;
        }
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.printf ("Printing first %d prime numbers\n", limit);
    for (int number = 2;
    limit > 0; number ++) {
        if (isPrime (number)) {
            System.out.println (number);
            limit --;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554459_4_21
22554373_22554514_1_18
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the amount of prime numbers to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    int count = 1;
    System.out.println ("Printing prime number from 1 to " + limit);
    for (int number = 2;
    count <= limit; number ++) {
        if (isPrime (number)) {
            System.out.println (number);
            count ++;
        }
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.println ("Printing prime number from 1 to " + limit);
    int count = 0;
    for (int number = 2;
    count < limit; number ++) {
        if (isPrime (number)) {
            count ++;
            System.out.println (number);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554459_4_21
22554373_22554613_1_19
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the amount of prime numbers to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    int count = 1;
    System.out.println ("Printing prime number from 1 to " + limit);
    for (int number = 2;
    count <= limit; number ++) {
        if (isPrime (number)) {
            System.out.println (number);
            count ++;
        }
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.println ("Printing prime number from 1 to " + limit);
    int number = 2;
    for (int i = 0;
    i < limit;) {
        if (isPrime (number)) {
            System.out.println (number);
            i ++;
        }
        number = number + 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554459_4_21
22554373_22554620_3_20
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the amount of prime numbers to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    int count = 1;
    System.out.println ("Printing prime number from 1 to " + limit);
    for (int number = 2;
    count <= limit; number ++) {
        if (isPrime (number)) {
            System.out.println (number);
            count ++;
        }
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = 10;
    System.out.println ("Printing prime number from 1 to " + limit);
    int number = 0;
    while (true) {
        if (isPrime (++ number)) {
            System.out.println (number);
            if (-- limit <= 0) break;

        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554500_1_15
22554373_22554514_1_18
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String [] args) throws Exception {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.printf ("Printing first %d prime numbers\n", limit);
    for (int number = 2;
    limit > 0; number ++) {
        if (isPrime (number)) {
            System.out.println (number);
            limit --;
        }
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.println ("Printing prime number from 1 to " + limit);
    int count = 0;
    for (int number = 2;
    count < limit; number ++) {
        if (isPrime (number)) {
            count ++;
            System.out.println (number);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554500_1_15
22554373_22554613_1_19
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String [] args) throws Exception {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.printf ("Printing first %d prime numbers\n", limit);
    for (int number = 2;
    limit > 0; number ++) {
        if (isPrime (number)) {
            System.out.println (number);
            limit --;
        }
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.println ("Printing prime number from 1 to " + limit);
    int number = 2;
    for (int i = 0;
    i < limit;) {
        if (isPrime (number)) {
            System.out.println (number);
            i ++;
        }
        number = number + 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554500_1_15
22554373_22554620_3_20
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String [] args) throws Exception {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.printf ("Printing first %d prime numbers\n", limit);
    for (int number = 2;
    limit > 0; number ++) {
        if (isPrime (number)) {
            System.out.println (number);
            limit --;
        }
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = 10;
    System.out.println ("Printing prime number from 1 to " + limit);
    int number = 0;
    while (true) {
        if (isPrime (++ number)) {
            System.out.println (number);
            if (-- limit <= 0) break;

        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554500_22_29
22554373_22554613_25_32
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554500_22_29
22554373_22554620_26_33
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < (number / 2); i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554500_22_29
22554373_33425906_1_20
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isPrime (long pNo) {
    if (pNo > 9) {
        long unitDigit = pNo % 10;
        if (unitDigit == 0 || unitDigit % 2 == 0 || unitDigit == 5) {
            return false;
        } else {
            for (long i = 3;
            i < pNo / 2; i = i + 2) {
                if (pNo % i == 0) {
                    return false;
                }
            }
            return true;
        }
    } else if (pNo < 0) {
        return false;
    } else {
        return pNo == 2 || pNo == 3 || pNo == 5 || pNo == 7;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554514_1_18
22554373_22554613_1_19
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.println ("Printing prime number from 1 to " + limit);
    int count = 0;
    for (int number = 2;
    count < limit; number ++) {
        if (isPrime (number)) {
            count ++;
            System.out.println (number);
        }
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.println ("Printing prime number from 1 to " + limit);
    int number = 2;
    for (int i = 0;
    i < limit;) {
        if (isPrime (number)) {
            System.out.println (number);
            i ++;
        }
        number = number + 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554514_1_18
22554373_22554620_3_20
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.println ("Printing prime number from 1 to " + limit);
    int count = 0;
    for (int number = 2;
    count < limit; number ++) {
        if (isPrime (number)) {
            count ++;
            System.out.println (number);
        }
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = 10;
    System.out.println ("Printing prime number from 1 to " + limit);
    int number = 0;
    while (true) {
        if (isPrime (++ number)) {
            System.out.println (number);
            if (-- limit <= 0) break;

        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554613_1_19
22554373_22554620_3_20
Title: Java:Counting prime numbers 
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = new Scanner (System.in).nextInt ();
    System.out.println ("Printing prime number from 1 to " + limit);
    int number = 2;
    for (int i = 0;
    i < limit;) {
        if (isPrime (number)) {
            System.out.println (number);
            i ++;
        }
        number = number + 1;
    }
}
----------------------------------------

public static void main (String args []) {
    System.out.println ("Enter the number till which prime number to be printed: ");
    int limit = 10;
    System.out.println ("Printing prime number from 1 to " + limit);
    int number = 0;
    while (true) {
        if (isPrime (++ number)) {
            System.out.println (number);
            if (-- limit <= 0) break;

        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554613_25_32
22554373_22554620_26_33
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < (number / 2); i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554613_25_32
22554373_33425906_1_20
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < number; i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isPrime (long pNo) {
    if (pNo > 9) {
        long unitDigit = pNo % 10;
        if (unitDigit == 0 || unitDigit % 2 == 0 || unitDigit == 5) {
            return false;
        } else {
            for (long i = 3;
            i < pNo / 2; i = i + 2) {
                if (pNo % i == 0) {
                    return false;
                }
            }
            return true;
        }
    } else if (pNo < 0) {
        return false;
    } else {
        return pNo == 2 || pNo == 3 || pNo == 5 || pNo == 7;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22554373_22554620_26_33
22554373_33425906_1_20
Title: Java:Counting prime numbers 
----------------------------------------

public static boolean isPrime (int number) {
    for (int i = 2;
    i < (number / 2); i ++) {
        if (number % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public boolean isPrime (long pNo) {
    if (pNo > 9) {
        long unitDigit = pNo % 10;
        if (unitDigit == 0 || unitDigit % 2 == 0 || unitDigit == 5) {
            return false;
        } else {
            for (long i = 3;
            i < pNo / 2; i = i + 2) {
                if (pNo % i == 0) {
                    return false;
                }
            }
            return true;
        }
    } else if (pNo < 0) {
        return false;
    } else {
        return pNo == 2 || pNo == 3 || pNo == 5 || pNo == 7;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22559994_22560157_3_12
22559994_22560250_7_31
Title: Need help reading files 
----------------------------------------

public static void main (String args []) throws Exception {
    FileReader fr = new FileReader ("FileReaderDemo.java");
    BufferedReader br = new BufferedReader (fr);
    String s;
    while ((s = br.readLine ()) != null) {
        System.out.println (s);
    }
    fr.close ();
}
----------------------------------------

public static void main (String [] args) {
    BufferedReader br = null;
    try {
        String sCurrentLine;
        br = new BufferedReader (new FileReader ("C:\\testing.txt"));
        while ((sCurrentLine = br.readLine ()) != null) {
            System.out.println (sCurrentLine);
        }
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        try {
            if (br != null) br.close ();

        } catch (IOException ex) {
            ex.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22560622_22562977_23_33
22560622_22576792_10_33
Title: Java Recursion compilation error 
----------------------------------------

private static boolean checkGCD (int [] values, int i, int j) {
    boolean result = true;
    if (gcd (values [i], values [j]) != 1) {
        result = false;
    }
    j ++;
    if (j < values.length) {
        result = result && checkGCD (values, i, j);
    }
    return result;
}
----------------------------------------

private static boolean checkGCD (int [] values, int lo, int hi) {
    if ((gcd (values [lo], values [hi])) != 1) return false;

    if (lo < values.length - 1 && hi < values.length - 1) return checkGCD (values, lo, hi + 1);

    if (lo < values.length - 2 && hi == values.length - 1) return checkGCD (values, lo + 1, lo + 2);

    if (lo == values.length - 2 && hi == values.length - 1) return true;

    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22562949_22563601_1_32
22562949_22564722_5_39
Title: Simple Calculator cant get past println 
----------------------------------------

public static void main (String [] args) throws java.lang.Exception {
    System.out.println ("setcaculatorinput");
    Scanner sc = new Scanner (System.in);
    int z = sc.nextInt ();
    System.out.println ("setvalueA");
    int a = sc.nextInt ();
    System.out.println ("setvalueB");
    int b = sc.nextInt ();
    int c, d, e, f;
    c = (a + b);
    d = (a - b);
    e = (a * b);
    f = (a / b);
    if ("+".equals (z));

    if ("-".equals (z));

    if ("*".equals (z));

    if ("/".equals (z));

    {
        System.out.println (c);
        System.out.println (d);
        System.out.println (e);
        System.out.println (f);
    } System.exit (0);
}
----------------------------------------

public static void main (String [] args) throws java.lang.Exception {
    System.out.println ("setcaculatorinput");
    Scanner sc = new Scanner (System.in);
    String z = sc.next ();
    System.out.println ("setvalueA");
    int a = sc.nextInt ();
    System.out.println ("setvalueB");
    int b = sc.nextInt ();
    int c;
    int d;
    int e;
    int f;
    c = (a + b);
    d = (a - b);
    e = (a * b);
    f = (a / b);
    if ("+".equals (z)) {
        System.out.println (c);
    }
    if ("-".equals (z)) {
        System.out.println (d);
    }
    if ("*".equals (z)) {
        System.out.println (e);
    }
    if ("/".equals (z)) {
        System.out.println (f);
    }
    System.exit (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22565684_22566419_7_19
22565684_22566873_5_31
Title: Splitting an array at multiple points using an index point 
----------------------------------------

public static void main (String [] args) {
    int [] array = {10, 1, 2, 3, 10, 4, 5, 10, 6, 7, 10, 8, 10};
    Vector < int [] > result;
    result = split (array, 10);
    for (int i = 0;
    i < result.size (); i ++) {
        int [] split = result.get (i);
        System.out.println ("Array " + i);
        for (int j = 0;
        j < split.length; j ++) {
            System.out.println (split [j]);
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] myarray = {10, 1, 2, 3, 10, 4, 5, 10, 6, 7, 10, 8, 10};
    int splitterInt = 10;
    int j = 0;
    int k = 0;
    ArrayList < Integer > tempArray = new ArrayList < Integer > ();
    ArrayList < ArrayList < Integer > > arrayOfIntList = new ArrayList < ArrayList < Integer > > ();
    for (int i = 0;
    i < myarray.length; i ++) {
        if (myarray [i] != splitterInt) {
            tempArray.add (j, myarray [i]);
            j ++;
        } else {
            if (tempArray.size () > 0) {
                arrayOfIntList.add (k, tempArray);
                k ++;
                tempArray = new ArrayList < Integer > ();
                j = 0;
            }
        }
        if (i == myarray.length - 1 && tempArray.size () > 0) {
            arrayOfIntList.add (k, tempArray);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22566503_47758143_9_35
22566503_48813796_1_36
Title: Count the number of Occurrences of a Word in a String 
----------------------------------------

public static void main (String [] args) {
    String sentence = "Java can run on many different operating " + "systems. This makes Java platform independent.";
    String [] words = sentence.split (" ");
    Map < String, Integer > wordsMap = new HashMap < String, Integer > ();
    for (int i = 0;
    i < words.length; i ++) {
        if (wordsMap.containsKey (words [i])) {
            Integer value = wordsMap.get (words [i]);
            wordsMap.put (words [i], value + 1);
        } else {
            wordsMap.put (words [i], 1);
        }
    }
    Iterator it = wordsMap.entrySet ().iterator ();
    while (it.hasNext ()) {
        Map.Entry < String, Integer > entryKeyValue = (Map.Entry < String, Integer >) it.next ();
        System.out.println ("Word : " + entryKeyValue.getKey () + ", Occurance : " + entryKeyValue.getValue () + " times");
    }
}
----------------------------------------

public static void main (String [] args) {
    String scentence = "This is a treeis isis is is is";
    String word = "is";
    int wordCount = 0;
    for (int i = 0;
    i < scentence.length (); i ++) {
        if (word.charAt (0) == scentence.charAt (i)) {
            if (i > 0) {
                if (scentence.charAt (i - 1) == ' ') {
                    if (i + word.length () < scentence.length ()) {
                        if (scentence.charAt (i + word.length ()) != ' ') {
                            continue;
                        }
                    }
                } else {
                    continue;
                }
            }
            int count = 1;
            for (int j = 1;
            j < word.length (); j ++) {
                i ++;
                if (word.charAt (j) != scentence.charAt (i)) {
                    break;
                } else {
                    count ++;
                }
            }
            if (count == word.length ()) {
                wordCount ++;
            }
        }
    }
    System.out.println ("The word " + word + " was repeated :" + wordCount);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22572090_22572274_1_30
22572090_22572780_7_31
Title: Extracting digits and signs into an array? 
----------------------------------------

public static void main (String [] args) {
    String expression = "1.2+3.4*(3.2+2.3)-12.1/3.4*1.8+5.7";
    String currentDouble = "";
    ArrayList myArray = new ArrayList ();
    for (int i = 0;
    i < expression.length (); i ++) {
        String current = "" + expression.charAt (i);
        if (current.equals ("(")) {
            String subExpression = expression.substring (i, expression.indexOf (")", i + 1) + 1);
            currentDouble += subExpression;
            i += subExpression.length () - 1;
        } else if ("+-*/".contains (current)) {
            myArray.add (currentDouble);
            currentDouble = "";
            myArray.add (current);
        } else {
            currentDouble += current;
        }

    }
    myArray.add (currentDouble);
    System.out.println (myArray.toString ());
}
----------------------------------------

public static void main (String [] args) throws Exception {
    String text = "1.2+3.4*(3.2+2.3)-12.1/3.4*1.8+5.7";
    List < String > list = new LinkedList < String > ();
    StringBuilder buff = new StringBuilder ();
    for (int i = 0;
    i < text.length (); i ++) {
        char c = text.charAt (i);
        if (Character.isDigit (c) || c == '.') {
            buff.append (c);
        } else {
            flushBuffer (list, buff);
            list.add (Character.toString (c));
        }
    }
    flushBuffer (list, buff);
    String [] array = list.toArray (new String [0]);
    System.out.println (Arrays.toString (array));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_22649991_2_20
22579054_30639588_5_22
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    int [] count = new int [A.length];
    for (int i = 0;
    i < A.length; i ++) {
        int x = A [i] - 1;
        if (x >= A.length) return 0;

        int check = count [x];
        if (check > 0) return 0;

        count [x] = 1;
    }
    return 1;
}
----------------------------------------

public int solution (int [] A) {
    final Set perm = new HashSet ();
    final int size = A.length;
    for (int number : A) {
        if (number > size) return 0;

        perm.add (number);
    }
    if (perm.size () == A.length) return 1;
    else return 0;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_22649991_2_20
22579054_31589437_12_31
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    int [] count = new int [A.length];
    for (int i = 0;
    i < A.length; i ++) {
        int x = A [i] - 1;
        if (x >= A.length) return 0;

        int check = count [x];
        if (check > 0) return 0;

        count [x] = 1;
    }
    return 1;
}
----------------------------------------

public int solution (int [] A) {
    int [] mark = new int [A.length + 1];
    int counter = 0;
    for (int i = 0;
    i < A.length; ++ i) {
        int value = A [i];
        if (value >= mark.length) {
            return NOT_PERMUTATION;
        }
        if (mark [value] == 0) {
            mark [value] = 1;
            ++ counter;
        } else {
            return NOT_PERMUTATION;
        }
    }
    return counter == A.length ? PERMUTATION : NOT_PERMUTATION;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_22649991_2_20
22579054_47761775_1_12
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    int [] count = new int [A.length];
    for (int i = 0;
    i < A.length; i ++) {
        int x = A [i] - 1;
        if (x >= A.length) return 0;

        int check = count [x];
        if (check > 0) return 0;

        count [x] = 1;
    }
    return 1;
}
----------------------------------------

public int solution (int...A) {
    Set < Integer > set = new HashSet < > ();
    int sum = A.length * (A.length + 1) / 2;
    for (int i = 0;
    i < A.length; i ++) {
        set.add (A [i]);
        sum -= A [i];
    }
    return ((set.size () == A.length) && sum == 0) ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_22649991_2_20
22579054_50075264_1_12
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    int [] count = new int [A.length];
    for (int i = 0;
    i < A.length; i ++) {
        int x = A [i] - 1;
        if (x >= A.length) return 0;

        int check = count [x];
        if (check > 0) return 0;

        count [x] = 1;
    }
    return 1;
}
----------------------------------------

public int solution (int [] A) {
    Arrays.sort (A);
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] != i + 1) {
            System.out.println ("0");
            return 0;
        }
    }
    System.out.println ("1");
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_30639588_5_22
22579054_31589437_12_31
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    final Set perm = new HashSet ();
    final int size = A.length;
    for (int number : A) {
        if (number > size) return 0;

        perm.add (number);
    }
    if (perm.size () == A.length) return 1;
    else return 0;

}
----------------------------------------

public int solution (int [] A) {
    int [] mark = new int [A.length + 1];
    int counter = 0;
    for (int i = 0;
    i < A.length; ++ i) {
        int value = A [i];
        if (value >= mark.length) {
            return NOT_PERMUTATION;
        }
        if (mark [value] == 0) {
            mark [value] = 1;
            ++ counter;
        } else {
            return NOT_PERMUTATION;
        }
    }
    return counter == A.length ? PERMUTATION : NOT_PERMUTATION;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_30639588_5_22
22579054_47761775_1_12
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    final Set perm = new HashSet ();
    final int size = A.length;
    for (int number : A) {
        if (number > size) return 0;

        perm.add (number);
    }
    if (perm.size () == A.length) return 1;
    else return 0;

}
----------------------------------------

public int solution (int...A) {
    Set < Integer > set = new HashSet < > ();
    int sum = A.length * (A.length + 1) / 2;
    for (int i = 0;
    i < A.length; i ++) {
        set.add (A [i]);
        sum -= A [i];
    }
    return ((set.size () == A.length) && sum == 0) ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_30639588_5_22
22579054_50075264_1_12
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    final Set perm = new HashSet ();
    final int size = A.length;
    for (int number : A) {
        if (number > size) return 0;

        perm.add (number);
    }
    if (perm.size () == A.length) return 1;
    else return 0;

}
----------------------------------------

public int solution (int [] A) {
    Arrays.sort (A);
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] != i + 1) {
            System.out.println ("0");
            return 0;
        }
    }
    System.out.println ("1");
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_31589437_12_31
22579054_47761775_1_12
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    int [] mark = new int [A.length + 1];
    int counter = 0;
    for (int i = 0;
    i < A.length; ++ i) {
        int value = A [i];
        if (value >= mark.length) {
            return NOT_PERMUTATION;
        }
        if (mark [value] == 0) {
            mark [value] = 1;
            ++ counter;
        } else {
            return NOT_PERMUTATION;
        }
    }
    return counter == A.length ? PERMUTATION : NOT_PERMUTATION;
}
----------------------------------------

public int solution (int...A) {
    Set < Integer > set = new HashSet < > ();
    int sum = A.length * (A.length + 1) / 2;
    for (int i = 0;
    i < A.length; i ++) {
        set.add (A [i]);
        sum -= A [i];
    }
    return ((set.size () == A.length) && sum == 0) ? 1 : 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_31589437_12_31
22579054_50075264_1_12
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int [] A) {
    int [] mark = new int [A.length + 1];
    int counter = 0;
    for (int i = 0;
    i < A.length; ++ i) {
        int value = A [i];
        if (value >= mark.length) {
            return NOT_PERMUTATION;
        }
        if (mark [value] == 0) {
            mark [value] = 1;
            ++ counter;
        } else {
            return NOT_PERMUTATION;
        }
    }
    return counter == A.length ? PERMUTATION : NOT_PERMUTATION;
}
----------------------------------------

public int solution (int [] A) {
    Arrays.sort (A);
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] != i + 1) {
            System.out.println ("0");
            return 0;
        }
    }
    System.out.println ("1");
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22579054_47761775_1_12
22579054_50075264_1_12
Title: Counting Element Permutation check 
----------------------------------------

public int solution (int...A) {
    Set < Integer > set = new HashSet < > ();
    int sum = A.length * (A.length + 1) / 2;
    for (int i = 0;
    i < A.length; i ++) {
        set.add (A [i]);
        sum -= A [i];
    }
    return ((set.size () == A.length) && sum == 0) ? 1 : 0;
}
----------------------------------------

public int solution (int [] A) {
    Arrays.sort (A);
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] != i + 1) {
            System.out.println ("0");
            return 0;
        }
    }
    System.out.println ("1");
    return 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22580124_22580148_1_13
22580124_22580151_1_17
Title: Skipping a null array 
----------------------------------------

public static int getTotal (Candidate [] list) {
    int total = 0;
    for (int i = 0;
    i < list.length; i ++) {
        if (list [i] != null) {
            total = list [i].getVotes () + total;
        }
    }
    return total;
}
----------------------------------------

public static int getTotal (Candidate [] list) {
    int total = 0;
    if (list != null) {
        for (int i = 0;
        i < list.length; i ++) {
            if (list [i] != null) {
                total = list [i].getVotes () + total;
            }
        }
    }
    return total;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22587381_22587454_1_12
22587381_22587551_1_16
Title: Java function to find prime number not working 
----------------------------------------

public boolean isPrime (int num) {
    for (int i = 2;
    i < num; ++ i) {
        if (num % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPrime (long n) {
    if (n < 2) {
        return false;
    } else if (n == 2) {
        return true;
    }

    for (int i = 2;
    i < Math.pow (n, 0.5) + 1; i ++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
2259016_2259034_1_33
2259016_2259070_1_16
Title: Traversal of a tree to find a node 
----------------------------------------

private TreeNode searchNodeBeingDeleted (Comparable c, TreeNode node) {
    if (node == null) {
        return null;
    }
    if (c.equals ((Comparable) node.getValue ())) {
        System.out.println ("Here");
        return node;
    } else {
        if (node.getLeft () != null) {
            System.out.println ("left");
            TreeNode n = searchNodeBeingDeleted (c, node.getLeft ());
            if (n != null) {
                return n;
            }
        }
        if (node.getRight () != null) {
            System.out.println ("right");
            TreeNode n = searchNodeBeingDeleted (c, node.getRight ());
            if (n != null) {
                return n;
            }
        }
    }
    return null;
}
----------------------------------------

private TreeNode searchNodeBeingDeleted (Comparable c, TreeNode node) {
    if (nodle == null) return null;

    int diff = c.compareTo ((Comparable) node.getValue ());
    if (diff == 0) {
        System.out.println ("Here");
        return node;
    } else if (diff < 0) {
        System.out.println ("left");
        return searchNodeBeingDeleted (c, node.getLeft ());
    } else {
        System.out.println ("right");
        return searchNodeBeingDeleted (c, node.getRight ());
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22592612_23775386_1_11
22592612_37893793_1_14
Title: PrefixAgain solution in codingbat 
----------------------------------------

public boolean prefixAgain (String str, int n) {
    String pre = str.substring (0, n);
    for (int i = n;
    i < str.length () - n + 1; i ++) {
        if (str.substring (i, i + n).equals (pre)) return true;

    }
    return false;
}
----------------------------------------

public boolean prefixAgain (String str, int n) {
    int l = str.length ();
    String test = str.substring (0, n);
    boolean flag = false;
    str = str.substring (1);
    l = str.length ();
    for (int i = 0;
    i < l; i ++) {
        if ((i + n <= l)) {
            if ((str.substring (i, n + i).equals (test))) return true;

        }
    }
    return flag;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22597108_22598445_8_15
22597108_22632944_49_55
Title: Disable JComboBox arrow button 
----------------------------------------

protected JButton createArrowButton () {
    return new JButton () {
        @Override
        public int getWidth () {
            return 0;
        }}

    ;
}
----------------------------------------

protected JButton createArrowButton () {
    return new JButton () {
        @Override
        public int getWidth () {
            return 0;
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22597108_22632944_46_58
22597108_22632944_65_77
Title: Disable JComboBox arrow button 
----------------------------------------

public void updateUI () {
    super.updateUI ();
    setUI (new BasicComboBoxUI () {
        @Override
        protected JButton createArrowButton () {
            return new JButton () {
                @Override
                public int getWidth () {
                    return 0;
                }}

            ;
        }}

    );
    setBorder (BorderFactory.createLineBorder (Color.GRAY));
}
----------------------------------------

public void updateUI () {
    super.updateUI ();
    UIManager.put ("ComboBox.squareButton", Boolean.FALSE);
    setUI (new BasicComboBoxUI () {
        @Override
        protected JButton createArrowButton () {
            JButton b = new JButton ();
            b.setBorder (BorderFactory.createEmptyBorder ());
            b.setVisible (false);
            return b;
        }}

    );
    setBorder (BorderFactory.createLineBorder (Color.GRAY));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22601106_22601808_1_20
22601106_22602547_30_52
Title: find most occurrences in a string Java 
----------------------------------------

public String getWinner () {
    final Map < String, Integer > votesCount = new HashMap < String, Integer > ();
    String winner = ballots.get (0);
    int winnerVotes = 1;
    for (final String ballot : ballots) {
        if (! votesCount.containsKey (ballot)) votesCount.put (ballot, 0);

        votesCount.put (ballot, votesCount.get (ballot) + 1);
        if (votesCount.get (ballot) > winnerVotes) {
            winner = ballot;
            winnerVotes = votesCount.get (ballot);
        }
    }
    return winner;
}
----------------------------------------

public String getWinner () {
    String winner = "";
    int highestVotes = 0;
    Set < String > uniqueSet = new HashSet < String > (ballots);
    for (String temp : uniqueSet) {
        int count = Collections.frequency (ballots, temp);
        if (count > highestVotes) {
            highestVotes = count;
            winner = temp;
        }
    }
    return winner;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_25945216_1_11
22605050_37882631_18_29
Title: Reverse Singly Linked List Java 
----------------------------------------

public void reverse () {
    Node prev = null;
    Node current = head;
    Node next = current.next;
    while (current.next != null) {
        current.next = prev;
        prev = current;
        current = next;
        next = current.next;
    }
    current.next = prev;
    head = current;
}
----------------------------------------

private void reverse () {
    Node < T > temp = null;
    Node < T > next = null;
    while (head != null) {
        next = head.next;
        head.next = temp;
        temp = head;
        head = next;
    }
    head = temp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_25945216_1_11
22605050_43341555_2_10
Title: Reverse Singly Linked List Java 
----------------------------------------

public void reverse () {
    Node prev = null;
    Node current = head;
    Node next = current.next;
    while (current.next != null) {
        current.next = prev;
        prev = current;
        current = next;
        next = current.next;
    }
    current.next = prev;
    head = current;
}
----------------------------------------

public static void reverse (List < Object > list) {
    int lenght = list.size ();
    for (int i = 0;
    i < lenght / 2; i ++) {
        Object as = list.get (i);
        list.set (i, list.get (lenght - 1 - i));
        list.set (lenght - 1 - i, as);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_26830481_1_16
22605050_36254705_32_48
Title: Reverse Singly Linked List Java 
----------------------------------------

public Node < E > reverseList (Node < E > node) {
    if (node == null || node.next == null) {
        return node;
    }
    Node < E > currentNode = node;
    Node < E > previousNode = null;
    Node < E > nextNode = null;
    while (currentNode != null) {
        nextNode = currentNode.next;
        currentNode.next = previousNode;
        previousNode = currentNode;
        currentNode = nextNode;
    }
    return previousNode;
}
----------------------------------------

public void reverseList () {
    Node < E > curr = head;
    Node < E > pre = null;
    Node < E > incoming = null;
    while (curr != null) {
        incoming = curr.next;
        curr.next = pre;
        pre = curr;
        curr = incoming;
    }
    head = pre;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_26830481_1_16
22605050_49030035_1_11
Title: Reverse Singly Linked List Java 
----------------------------------------

public Node < E > reverseList (Node < E > node) {
    if (node == null || node.next == null) {
        return node;
    }
    Node < E > currentNode = node;
    Node < E > previousNode = null;
    Node < E > nextNode = null;
    while (currentNode != null) {
        nextNode = currentNode.next;
        currentNode.next = previousNode;
        previousNode = currentNode;
        currentNode = nextNode;
    }
    return previousNode;
}
----------------------------------------

public ListNode reverseList (ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_28677281_60_76
22605050_37882631_39_50
Title: Reverse Singly Linked List Java 
----------------------------------------

public static void main (String args []) {
    LinkList objLinkList = new LinkList ();
    objLinkList.insertFirst (1);
    objLinkList.insertFirst (2);
    objLinkList.insertFirst (3);
    objLinkList.insertFirst (4);
    objLinkList.insertFirst (5);
    objLinkList.insertFirst (6);
    objLinkList.insertFirst (7);
    objLinkList.insertFirst (8);
    objLinkList.displayLink ();
    System.out.println ("-----------------------------");
    objLinkList.ReverseLink ();
    objLinkList.displayLink ();
}
----------------------------------------

public static void main (String a []) {
    SinglyLinkedListImpl < Integer > sl = new SinglyLinkedListImpl < Integer > ();
    sl.add (1);
    sl.add (2);
    sl.add (3);
    sl.add (4);
    sl.printList (sl.head);
    sl.reverse ();
    sl.printList (sl.head);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_28677281_60_76
22605050_43341555_11_20
Title: Reverse Singly Linked List Java 
----------------------------------------

public static void main (String args []) {
    LinkList objLinkList = new LinkList ();
    objLinkList.insertFirst (1);
    objLinkList.insertFirst (2);
    objLinkList.insertFirst (3);
    objLinkList.insertFirst (4);
    objLinkList.insertFirst (5);
    objLinkList.insertFirst (6);
    objLinkList.insertFirst (7);
    objLinkList.insertFirst (8);
    objLinkList.displayLink ();
    System.out.println ("-----------------------------");
    objLinkList.ReverseLink ();
    objLinkList.displayLink ();
}
----------------------------------------

public static void main (String [] args) {
    LinkedList < Object > st = new LinkedList < Object > ();
    st.add (1);
    st.add (2);
    st.add (3);
    st.add (4);
    st.add (5);
    Linkedtest.reverse (st);
    System.out.println ("Reverse Value will be:" + st);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_28677281_60_76
22605050_45081131_7_37
Title: Reverse Singly Linked List Java 
----------------------------------------

public static void main (String args []) {
    LinkList objLinkList = new LinkList ();
    objLinkList.insertFirst (1);
    objLinkList.insertFirst (2);
    objLinkList.insertFirst (3);
    objLinkList.insertFirst (4);
    objLinkList.insertFirst (5);
    objLinkList.insertFirst (6);
    objLinkList.insertFirst (7);
    objLinkList.insertFirst (8);
    objLinkList.displayLink ();
    System.out.println ("-----------------------------");
    objLinkList.ReverseLink ();
    objLinkList.displayLink ();
}
----------------------------------------

public static void main (String args []) {
    Scanner sc = new Scanner (System.in);
    Node head = null;
    Node temp = null;
    int choice = 0;
    boolean flage = true;
    do {
        Node node = new Node ();
        System.out.println ("Enter Node");
        node.data = sc.nextInt ();
        if (flage) {
            head = node;
            flage = false;
        }
        if (temp != null) temp.next = node;

        temp = node;
        System.out.println ("Enter 0 to exit.");
        choice = sc.nextInt ();
    } while (choice != 0);
    Help.getAll (head);
    Node reverse = Help.reverse (head, null);
    Help.getAll (reverse);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_28677281_60_76
22605050_50199109_63_72
Title: Reverse Singly Linked List Java 
----------------------------------------

public static void main (String args []) {
    LinkList objLinkList = new LinkList ();
    objLinkList.insertFirst (1);
    objLinkList.insertFirst (2);
    objLinkList.insertFirst (3);
    objLinkList.insertFirst (4);
    objLinkList.insertFirst (5);
    objLinkList.insertFirst (6);
    objLinkList.insertFirst (7);
    objLinkList.insertFirst (8);
    objLinkList.displayLink ();
    System.out.println ("-----------------------------");
    objLinkList.ReverseLink ();
    objLinkList.displayLink ();
}
----------------------------------------

public static void main (String [] args) {
    ReverseLinkedList r = new ReverseLinkedList ();
    r.insert (10);
    r.insert (20);
    r.insert (30);
    r.display (root);
    Node t = r.reverseLinkedList (root);
    r.display (t);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_36254705_19_30
22605050_37882631_5_16
Title: Reverse Singly Linked List Java 
----------------------------------------

public void add (E e) {
    if (head == null) head = new Node < E > (e);
    else {
        Node < E > temp = head;
        while (temp.next != null) temp = temp.next;

        temp.next = new Node < E > (e);
    }
}
----------------------------------------

public void add (T element) {
    Node < T > item = new Node < T > (element);
    if (head == null) {
        head = item;
    } else {
        Node < T > temp = head;
        while (temp.next != null) {
            temp = temp.next;
        }
        temp.next = item;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_36254705_32_48
22605050_49030035_1_11
Title: Reverse Singly Linked List Java 
----------------------------------------

public void reverseList () {
    Node < E > curr = head;
    Node < E > pre = null;
    Node < E > incoming = null;
    while (curr != null) {
        incoming = curr.next;
        curr.next = pre;
        pre = curr;
        curr = incoming;
    }
    head = pre;
}
----------------------------------------

public ListNode reverseList (ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_37882631_18_29
22605050_43341555_2_10
Title: Reverse Singly Linked List Java 
----------------------------------------

private void reverse () {
    Node < T > temp = null;
    Node < T > next = null;
    while (head != null) {
        next = head.next;
        head.next = temp;
        temp = head;
        head = next;
    }
    head = temp;
}
----------------------------------------

public static void reverse (List < Object > list) {
    int lenght = list.size ();
    for (int i = 0;
    i < lenght / 2; i ++) {
        Object as = list.get (i);
        list.set (i, list.get (lenght - 1 - i));
        list.set (lenght - 1 - i, as);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
22605050_37882631_39_50
22605050_43341555_11_20
Title: Reverse Singly Linked List Java 
----------------------------------------

public static void main (String a []) {
    SinglyLinkedListImpl < Integer > sl = new SinglyLinkedListImpl < Integer > ();
    sl.add (1);
    sl.add (2);
    sl.add (3);
    sl.add (4);
    sl.printList (sl.head);
    sl.reverse ();
    sl.printList (sl.head);
}
----------------------------------------

public static void main (String [] args) {
    LinkedList < Object > st = new LinkedList < Object > ();
    st.add (1);
    st.add (2);
    st.add (3);
    st.add (4);
    st.add (5);
    Linkedtest.reverse (st);
    System.out.println ("Reverse Value will be:" + st);
}
----------------------------------------
