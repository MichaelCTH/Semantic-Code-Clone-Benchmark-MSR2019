$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19780442_19780776_54_65
19780442_19781618_86_95
Title: Suggestions on my implementation of Producer Consumer 
----------------------------------------

public void run () {
    try {
        while (! thread.isInterrupted ()) {
            SomeMessage message = take ();
            doSomethingWithMessage (message);
        }
    } catch (InterruptedException ex) {
        System.out.println ("Stop processing - consumer per request.");
    } finally {
        thread = null;
    }
}
----------------------------------------

public void run () {
    for (Integer i = 0;
    i < size; i ++) {
        try {
            sleep ((int) Math.random () * 100);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        System.out.println ("Consumed:" + syncQueue.get ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19784365_19784528_22_39
19784365_19784528_43_60
Title: Java Eclipse android syntax errors with anonymous inner class 
----------------------------------------

public void onClick (View arg0) {
    Thread play = new Thread () {
        @Override
        public void run () {
            try {
                Intent play = new Intent ("android.intent.action.PLAY");
                startActivity (play);
            } catch (Exception e) {
                e.printStackTrace ();
            } finally {
                finish ();
            }
        }}

    ;
}
----------------------------------------

public void onClick (View arg0) {
    Thread help = new Thread () {
        @Override
        public void run () {
            try {
                Intent help = new Intent ("android.intent.action.HELP");
                startActivity (help);
            } catch (Exception e) {
                e.printStackTrace ();
            } finally {
                finish ();
            }
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19784365_19784528_22_39
19784365_19784528_65_82
Title: Java Eclipse android syntax errors with anonymous inner class 
----------------------------------------

public void onClick (View arg0) {
    Thread play = new Thread () {
        @Override
        public void run () {
            try {
                Intent play = new Intent ("android.intent.action.PLAY");
                startActivity (play);
            } catch (Exception e) {
                e.printStackTrace ();
            } finally {
                finish ();
            }
        }}

    ;
}
----------------------------------------

public void onClick (View arg0) {
    Thread credits = new Thread () {
        @Override
        public void run () {
            try {
                Intent credits = new Intent ("android.intent.action.CREDITS");
                startActivity (credits);
            } catch (Exception e) {
                e.printStackTrace ();
            } finally {
                finish ();
            }
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19784365_19784528_26_37
19784365_19784528_47_58
Title: Java Eclipse android syntax errors with anonymous inner class 
----------------------------------------

public void run () {
    try {
        Intent play = new Intent ("android.intent.action.PLAY");
        startActivity (play);
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        finish ();
    }
}
----------------------------------------

public void run () {
    try {
        Intent help = new Intent ("android.intent.action.HELP");
        startActivity (help);
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        finish ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19784365_19784528_26_37
19784365_19784528_69_80
Title: Java Eclipse android syntax errors with anonymous inner class 
----------------------------------------

public void run () {
    try {
        Intent play = new Intent ("android.intent.action.PLAY");
        startActivity (play);
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        finish ();
    }
}
----------------------------------------

public void run () {
    try {
        Intent credits = new Intent ("android.intent.action.CREDITS");
        startActivity (credits);
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        finish ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19784365_19784528_43_60
19784365_19784528_65_82
Title: Java Eclipse android syntax errors with anonymous inner class 
----------------------------------------

public void onClick (View arg0) {
    Thread help = new Thread () {
        @Override
        public void run () {
            try {
                Intent help = new Intent ("android.intent.action.HELP");
                startActivity (help);
            } catch (Exception e) {
                e.printStackTrace ();
            } finally {
                finish ();
            }
        }}

    ;
}
----------------------------------------

public void onClick (View arg0) {
    Thread credits = new Thread () {
        @Override
        public void run () {
            try {
                Intent credits = new Intent ("android.intent.action.CREDITS");
                startActivity (credits);
            } catch (Exception e) {
                e.printStackTrace ();
            } finally {
                finish ();
            }
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19784365_19784528_47_58
19784365_19784528_69_80
Title: Java Eclipse android syntax errors with anonymous inner class 
----------------------------------------

public void run () {
    try {
        Intent help = new Intent ("android.intent.action.HELP");
        startActivity (help);
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        finish ();
    }
}
----------------------------------------

public void run () {
    try {
        Intent credits = new Intent ("android.intent.action.CREDITS");
        startActivity (credits);
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        finish ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1978933_13878279_1_32
1978933_23939390_1_12
Title: A quick and easy way to join array elements with a separator (the opposite of split) in Java 
----------------------------------------

public static String join (String separator, String...values) {
    if (values.length == 0) return "";

    char [] sep = separator.toCharArray ();
    int totalSize = (values.length - 1) * sep.length;
    for (int i = 0;
    i < values.length; i ++) {
        if (values [i] == null) values [i] = "";
        else totalSize += values [i].length ();

    }
    char [] joined = new char [totalSize];
    int pos = 0;
    for (int i = 0, end = values.length - 1;
    i < end; i ++) {
        System.arraycopy (values [i].toCharArray (), 0, joined, pos, values [i].length ());
        pos += values [i].length ();
        System.arraycopy (sep, 0, joined, pos, sep.length);
        pos += sep.length;
    }
    System.arraycopy (values [values.length - 1].toCharArray (), 0, joined, pos, values [values.length - 1].length ());
    return new String (joined);
}
----------------------------------------

public static String join (String separator, String...values) {
    StringBuilder sb = new StringBuilder (128);
    int end = 0;
    for (String s : values) {
        if (s != null) {
            sb.append (s);
            end = sb.length ();
            sb.append (separator);
        }
    }
    return sb.substring (0, end);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1978933_13878279_1_32
1978933_30836368_27_45
Title: A quick and easy way to join array elements with a separator (the opposite of split) in Java 
----------------------------------------

public static String join (String separator, String...values) {
    if (values.length == 0) return "";

    char [] sep = separator.toCharArray ();
    int totalSize = (values.length - 1) * sep.length;
    for (int i = 0;
    i < values.length; i ++) {
        if (values [i] == null) values [i] = "";
        else totalSize += values [i].length ();

    }
    char [] joined = new char [totalSize];
    int pos = 0;
    for (int i = 0, end = values.length - 1;
    i < end; i ++) {
        System.arraycopy (values [i].toCharArray (), 0, joined, pos, values [i].length ());
        pos += values [i].length ();
        System.arraycopy (sep, 0, joined, pos, sep.length);
        pos += sep.length;
    }
    System.arraycopy (values [values.length - 1].toCharArray (), 0, joined, pos, values [values.length - 1].length ());
    return new String (joined);
}
----------------------------------------

public static String join (Collection < ? > values, String delimiter) {
    if (values == null) {
        return new String ();
    }
    StringBuffer strbuf = new StringBuffer ();
    boolean first = true;
    for (Object value : values) {
        if (! first) {
            strbuf.append (delimiter);
        } else {
            first = false;
        }
        strbuf.append (value.toString ());
    }
    return strbuf.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1978933_23939390_1_12
1978933_30836368_27_45
Title: A quick and easy way to join array elements with a separator (the opposite of split) in Java 
----------------------------------------

public static String join (String separator, String...values) {
    StringBuilder sb = new StringBuilder (128);
    int end = 0;
    for (String s : values) {
        if (s != null) {
            sb.append (s);
            end = sb.length ();
            sb.append (separator);
        }
    }
    return sb.substring (0, end);
}
----------------------------------------

public static String join (Collection < ? > values, String delimiter) {
    if (values == null) {
        return new String ();
    }
    StringBuffer strbuf = new StringBuffer ();
    boolean first = true;
    for (Object value : values) {
        if (! first) {
            strbuf.append (delimiter);
        } else {
            first = false;
        }
        strbuf.append (value.toString ());
    }
    return strbuf.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19802979_19803036_5_77
19802979_19803071_5_76
Title: i need to allow the user to continually run the program until they enter 0 
----------------------------------------

public static void main (String [] args) {
    while (true) {
        System.out.println ("please enter the number of change 1-99");
        System.out.println ("enter 0 to exit the program");
        Scanner Userinput = new Scanner (System.in);
        int cntrquart = 0;
        int cntrdimes = 0;
        int cntrpennies = 0;
        int cntrnickels = 0;
        int chaaching = Userinput.nextInt ();
        if (chaaching == 0) {
            break;
        }
        int quarters = chaaching;
        while (quarters >= 25) {
            quarters = quarters - 25;
            cntrquart = cntrquart + 1;
        }
        int dimes = quarters;
        while (dimes >= 10) {
            dimes = dimes - 10;
            cntrdimes = cntrdimes + 1;
        }
        int nickels = dimes;
        while (nickels >= 5) {
            nickels = nickels - 5;
            cntrnickels = cntrnickels + 1;
        }
        int pennies = nickels;
        while (pennies >= 1) {
            pennies = pennies - 1;
            cntrpennies = cntrpennies + 1;
        }
        System.out.println ("mumber of quarters:" + cntrquart);
        System.out.println ("number of dimes:" + cntrdimes);
        System.out.println ("number of nickels:" + cntrnickels);
        System.out.println ("number of pennies:" + cntrpennies);
    }
    System.out.println ("Thank you for using Dark Alley Development");
}
----------------------------------------

public static void main (String [] args) {
    int chaaching = 1;
    do {
        System.out.println ("please enter the number of change 1-99");
        System.out.println ("enter 0 to exit the program");
        Scanner Userinput = new Scanner (System.in);
        int cntrquart = 0;
        int cntrdimes = 0;
        int cntrpennies = 0;
        int cntrnickels = 0;
        chaaching = Userinput.nextInt ();
        int quarters = chaaching;
        while (quarters >= 25) {
            quarters = quarters - 25;
            cntrquart = cntrquart + 1;
        }
        int dimes = quarters;
        while (dimes >= 10) {
            dimes = dimes - 10;
            cntrdimes = cntrdimes + 1;
        }
        int nickels = dimes;
        while (nickels >= 5) {
            nickels = nickels - 5;
            cntrnickels = cntrnickels + 1;
        }
        int pennies = nickels;
        while (pennies >= 1) {
            pennies = pennies - 1;
            cntrpennies = cntrpennies + 1;
        }
        System.out.println ("mumber of quarters:" + cntrquart);
        System.out.println ("number of dimes:" + cntrdimes);
        System.out.println ("number of nickels:" + cntrnickels);
        System.out.println ("numberof pennies:" + cntrpennies);
    } while (chaaching != 0);
    System.out.println ("Thank you for using Dark Alley Development");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19803297_19803326_2_30
19803297_19803344_3_29
Title: Not able to put required names on Java 
----------------------------------------

public static void main (String [] args) throws IOException {
    Scanner reader = new Scanner (new File ("C:/textLocation.txt"));
    String filename = "";
    String name = "";
    String brief = "";
    boolean lookingForName = false;
    boolean lookingForBrief = false;
    String line = "";
    while (reader.hasNextLine ()) {
        line = reader.nextLine ();
        if (line.startsWith ("Filename:") && (line.contains ("apple"))) {
            filename = line.substring (10, line.length ());
            lookingForName = true;
            lookingForBrief = true;
        } else if (line.startsWith ("Name:") && lookingForName) {
            name = line.substring (6, line.length ());
            lookingForName = false;
        } else if (line.startsWith ("Brief:") && lookingForBrief) {
            brief = line.substring (7, line.length ());
            lookingForBrief = false;
        }

    }
    System.out.println (filename);
    System.out.println (name);
    System.out.println (brief);
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Scanner reader = new Scanner (new File ("C:/textLocation.txt"));
    String filename = "";
    String name = "";
    String brief = "";
    String line = "";
    while (reader.hasNextLine ()) {
        line = reader.nextLine ();
        if (line.startsWith ("Filename:") && (line.contains ("apple"))) {
            filename = line.substring (10, line.length ());
        } else if (line.startsWith ("Name:")) {
            name = line.substring (6, line.length ());
        } else if (line.startsWith ("Brief:")) {
            brief = line.substring (7, line.length ());
        }

    }
    if (filename.equals ("apple.jpg")) {
        System.out.println (filename);
        System.out.println (name);
        System.out.println (brief);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19804825_19804922_1_10
19804825_19804940_1_11
Title: BookOrder class isn't rendering results in Test 
----------------------------------------

public BookOrder (String author, String title, int quanitity, double costPerBook, String orderDate, double weight, char type) {
    this.author = author;
    this.title = title;
    this.quantity = quanitity;
    this.costPerBook = costPerBook;
    this.orderDate = orderDate;
    this.weight = weight;
    this.type = type;
}
----------------------------------------

public BookOrder (String author, String title, int quanitity, double costPerBook, String orderDate, double weight, char type) {
    this.author = author;
    this.title = title;
    this.quantity = quantity;
    this.costPerBook = costPerBook;
    this.orderDate = orderDate;
    this.weight = weight;
    this.type = type;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19805957_19806023_1_14
19805957_19806026_1_11
Title: Java recursion; how can I simplify what I have? 
----------------------------------------

public static int countA (String s) {
    int count = 0;
    if (s == null) return 0;

    if (s.length () == 0) return 0;

    if (s.charAt (0) == 'A') count ++;

    return count + countA (s.substring (1));
}
----------------------------------------

public static int countA (String s) {
    if (s == null) return 0;

    if (s.length () == 0) return 0;

    if (s.charAt (0) == 'A') {
        return 1 + countA (s.substring (1));
    } else {
        return countA (s.substring (1));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19806517_19806626_3_10
19806517_19806642_121_135
Title: File Filter does not appear on JFileChooser in Java swing 
----------------------------------------

public boolean accept (File f) {
    if (f.getName ().toLowerCase ().endsWith (".jpeg")) return true;

    if (f.getName ().toLowerCase ().endsWith (".jpg")) return true;

    if (f.getName ().toLowerCase ().endsWith (".avi")) return true;

    if (f.getName ().toLowerCase ().endsWith (".mpeg")) return true;

    return false;
}
----------------------------------------

public boolean accept (File f) {
    if (f.isDirectory ()) return true;

    final String fileName = f.getName ();
    int lastIndexOfDot = fileName.lastIndexOf ('.');
    if (lastIndexOfDot == - 1) return false;

    int fileNameLength = fileName.length ();
    final String extension = fileName.substring (lastIndexOfDot + 1, fileNameLength);
    return fileNameExtensionList.contains (extension);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19809159_19811059_1_34
19809159_19838988_1_28
Title: Method to remove nodes 
----------------------------------------

public Student remove (Integer studentId) {
    LinearNode previous = null;
    LinearNode current = head;
    while (current != null) {
        if (current.items == null) {
        } else if (current.items.getId () == null) {
        } else if (studentId.compareTo (curent.items.getId ()) == 0) {
            if (previous == null) {
                head = head.next;
                return curent.items;
            } else {
                previous.next = current.next;
                return curent.items;
            }
        } else {
            previous = current;
            current = current.next;
        }

    }
    return null;
}
----------------------------------------

public Student remove (Student items) {
    LinearNode previous = null, current = head;
    while (current != null && current.items.compareTo (items) != 0) {
        previous = current;
        current = current.next;
    }
    if (current == null) {
        return null;
    }
    if (previous == null) {
        head = current.next;
    } else {
        previous.next = current.next
    }
    return current.items;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19810676_19810857_4_24
19810676_19810875_1_19
Title: Output wanted on another place 
----------------------------------------

public static void main (String args []) throws IOException {
    InputStreamReader read = new InputStreamReader (System.in);
    BufferedReader in = new BufferedReader (read);
    double [] numMass = new double [10];
    int count = 0;
    for (int a = 0;
    a < 10; a ++) {
        System.out.println ("Enter your number");
        double b = Double.parseDouble (in.readLine ());
        if (b < 0) {
            numMass [count] = b;
            count ++;
        }
    }
    for (int i = 0;
    i < count; i ++) {
        System.out.println (numMass [i]);
    }
}
----------------------------------------

public static void main (String args []) throws IOException {
    double a, b;
    List < Double > numbers = new ArrayList < > ();
    InputStreamReader read = new InputStreamReader (System.in);
    BufferedReader in = new BufferedReader (read);
    for (a = 1; a <= 10; a ++) {
        System.out.println ("Enter your number");
        b = Double.parseDouble (in.readLine ());
        if (b < 0) {
            numbers.add (b);
        }
    }
    for (Double d : numbers) {
        System.out.println (d + " ");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19814774_19829781_23_36
19814774_19829781_4_18
Title: Executors Factory method newScheduledThreadPool always returns the same Thread pool 
----------------------------------------

public void run () {
    Date startTime = new Date ();
    System.out.println ("Thread B started at - " + startTime);
    try {
        Thread.sleep (60000);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    Date endTime = new Date ();
    System.out.println ("Thread B ended at - " + endTime);
    System.out.println ("Time taken by Thread B - " + (endTime.getTime () - startTime.getTime ()) + "ms");
}
----------------------------------------

public void run () {
    Date startTime = new Date ();
    System.out.println ("Thread A started at - " + startTime);
    try {
        Thread.sleep (4000);
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    Date endTime = new Date ();
    System.out.println ("Thread A ended at - " + endTime);
    System.out.println ("Time taken by Thread A - " + (endTime.getTime () - startTime.getTime ()) + "ms");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19815221_19815882_1_35
19815221_19816384_1_32
Title: inserting asterisks and parentheses into a string 
----------------------------------------

public static String modify (String expression) {
    StringBuilder finalString = new StringBuilder ();
    String [] subExpressions = expression.split ("\\+");
    List < String > formattedSubExpressions = new ArrayList < String > ();
    for (String subExpression : subExpressions) {
        if (subExpression.length () > 1) {
            StringBuilder formattedSubExpression = new StringBuilder ();
            formattedSubExpression.append ("(");
            for (int i = 0;
            i < subExpression.length (); i ++) {
                formattedSubExpression.append (subExpression.charAt (i));
                if (i != subExpression.length () - 1) {
                    formattedSubExpression.append ("*");
                }
            }
            formattedSubExpression.append (")");
            formattedSubExpressions.add (formattedSubExpression.toString ());
        } else {
            formattedSubExpressions.add (subExpression);
        }
    }
    for (String subExpression : formattedSubExpressions) {
        finalString.append (subExpression);
        finalString.append ("+");
    }
    if (finalString.charAt (finalString.length () - 1) == '+') {
        finalString.deleteCharAt (finalString.length () - 1);
    }
    return finalString.toString ();
}
----------------------------------------

public static String modify (String expression) {
    String temp = expression;
    StringBuilder validated = new StringBuilder ();
    boolean inBrackets = false;
    for (int idx = 0;
    idx < temp.length () - 1; idx ++) {
        if ((Character.isLetter (temp.charAt (idx))) && (Character.isLetter (temp.charAt (idx + 1)))) {
            if (! inBrackets) {
                inBrackets = true;
                validated.append ("(");
            }
            validated.append (temp.substring (idx, idx + 1));
            validated.append ("*");
        } else {
            validated.append (temp.substring (idx, idx + 1));
            if (inBrackets) {
                validated.append (")");
                inBrackets = false;
            }
        }
    }
    validated.append (temp.substring (temp.length () - 1));
    if (inBrackets) {
        validated.append (")");
        inBrackets = false;
    }
    return validated.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19818494_19818826_1_19
19818494_19818960_1_13
Title: How to find minimum value( doesn't work ) The Reason? 
----------------------------------------

public static int getMinValue (int [] ary) throws Exception {
    int Minvalue = 0;
    if (ary.length > 0) {
        Arrays.sort (ary);
        Minvalue = ary [0];
        return Minvalue;
    } else {
        throw new Exception ("Empty array");
    }
}
----------------------------------------

public static int getMinValue (int [] ary) {
    random (ary);
    if (ary.length > 0) {
        int minValue = ary [0];
        for (int i = 1;
        i < ary.length; i ++) {
            if (ary [i] < minValue) minValue = ary [i];

        }
        System.out.printf ("Minvalue:%d", minValue);
        return minValue;
    }
    throw new RuntimeException ("The array must contain at least one element");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19825563_19833921_1_11
19825563_53216614_1_11
Title: Custom validator message: Throwing exception in implementation of ConstraintValidator cause UnexpectedException 
----------------------------------------

@Override
public boolean isValid (String userName, ConstraintValidatorContext context) {
    if (userService.findByUserName (userName) != null) {
        context.disableDefaultConstraintViolation ();
        context.buildConstraintViolationWithTemplate ("User " + userName + "already exists!").addConstraintViolation ();
        return false;
    }
    return true;
}
----------------------------------------

@Override
public boolean isValid (String userName, ConstraintValidatorContext context) {
    if (userService != null && userService.findByUserName (userName) != null) {
        context.disableDefaultConstraintViolation ();
        context.buildConstraintViolationWithTemplate ("User " + userName + "already exists!").addConstraintViolation ();
        return false;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19825946_43744163_16_25
19825946_45833337_13_24
Title: How to add a filter class in Spring Boot? 
----------------------------------------

public void doFilter (ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest req = (HttpServletRequest) request;
    if (req.getHeader ("x-dawson-nonce") == null || req.getHeader ("x-dawson-signature") == null) {
        HttpServletResponse httpResponse = (HttpServletResponse) response;
        httpResponse.setContentType ("application/json");
        httpResponse.sendError (HttpServletResponse.SC_BAD_REQUEST, "Required headers not specified in the request");
        return;
    }
    chain.doFilter (request, response);
}
----------------------------------------

public void doFilter (ServletRequest arg0, ServletResponse response, FilterChain chain) throws IOException, ServletException {
    logger.info ("checking client id in filter");
    HttpServletRequest request = (HttpServletRequest) arg0;
    String clientId = request.getHeader ("clientId");
    if (StringUtils.isNotEmpty (clientId)) {
        chain.doFilter (request, response);
    } else {
        logger.error ("client id missing.");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19827983_19828243_1_60
19827983_19831774_22_35
Title: I want to open the android camera without saving the picture to gallery 
----------------------------------------

public void onActivityResult (int requestCode, int resultCode, Intent data) {
    super.onActivityResult (requestCode, resultCode, data);
    if (requestCode == CAMERA_RESULT) {
        if (resultCode == Activity.RESULT_OK) {
            String galleryImatePath = SD_CARD_TEMP_DIR;
            File f = new File (galleryImatePath);
            try {
                Bitmap cameraBitmap = null;
                BitmapFactory.Options bmOptions = new BitmapFactory.Options ();
                bmOptions.inJustDecodeBounds = false;
                bmOptions.inPurgeable = true;
                bmOptions.inBitmap = cameraBitmap;
                bmOptions.inMutable = true;
                cameraBitmap = BitmapFactory.decodeFile (galleryImatePath, bmOptions);
                ByteArrayOutputStream bos = new ByteArrayOutputStream ();
                cameraBitmap.compress (Bitmap.CompressFormat.JPEG, 50, bos);
                ExifInterface exif = new ExifInterface (galleryImatePath);
                float rotation = exif.getAttributeInt (ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);
                System.out.println (rotation);
                float rotationInDegrees = exifToDegrees (rotation);
                System.out.println (rotationInDegrees);
                Matrix matrix = new Matrix ();
                matrix.postRotate (rotationInDegrees);
                final Bitmap rotatedBitmap = Bitmap.createBitmap (cameraBitmap, 0, 0, cameraBitmap.getWidth (), cameraBitmap.getHeight (), matrix, true);
                FileOutputStream fos = new FileOutputStream (galleryImatePath);
                rotatedBitmap.compress (Bitmap.CompressFormat.JPEG, 50, fos);
                fos.write (bos.toByteArray ());
                cameraBitmap.recycle ();
                System.gc ();
                fos.flush ();
                fos.close ();
                Capdialog = new Dialog (AddToDo.this, android.R.style.Theme_NoTitleBar_Fullscreen);
                Capdialog.setContentView (R.layout.captiondialog);
                Capdialog.setCancelable (false);
                TextView cancel = (TextView) Capdialog.findViewById (R.id.cancel);
                TextView done = (TextView) Capdialog.findViewById (R.id.done);
                Capdialog.getWindow ().setSoftInputMode (WindowManager.LayoutParams.SOFT_INPUT_STATE_ALWAYS_HIDDEN);
                ImageView img = (ImageView) Capdialog.findViewById (R.id.image);
                img.setImageBitmap (rotatedBitmap);
            } catch (Exception e) {
            }
        }
    }
}
----------------------------------------

protected void onActivityResult (int requestCode, int resultCode, Intent data) {
    super.onActivityResult (requestCode, resultCode, data);
    if (requestCode == 0) {
        try {
            Bitmap cameraBitmap;
            cameraBitmap = BitmapFactory.decodeFile (myFilesDir + "/temp.jpg");
            Bitmap.createBitmap (cameraBitmap);
            ivPhoto.setImageBitmap (cameraBitmap);
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19831598_19831917_1_23
19831598_19831957_1_19
Title: processing list of objects in Java 
----------------------------------------

void gluetitles (List < String > title) {
    Map < String, String > map = new HashMap < String, String > ();
    for (int i = 0;
    i < title.size (); i ++) {
        String names = (String) title.get (i);
        String [] titlename = names.split ("\\|");
        String tle = titlename [0];
        String name = titlename [1];
        if (map.containsKey (name)) {
            String savedTitle = map.get (name);
            if (isBetterTitle (tle, savedTitle)) {
                map.put (name, tle);
            }
        } else {
            map.put (name, tle);
        }
    }
    for (Iterator < String > it = map.keySet ().iterator ();
    it.hasNext ();) {
        String name = it.next ();
        System.out.println (map.get (name) + name);
    }
}
----------------------------------------

void gluetitles (List title) {
    Map < String, String > titleNamesMap = new TreeMap < String, String > ();
    for (int i = 0;
    i < title.size (); i ++) {
        String names = (String) title.get (i);
        String [] titlename = names.split ("\\|");
        String tle = titlename [0];
        String name = titlename [1];
        if (titleNamesMap.containsKey (name)) {
            String oldTitle = titleNamesMap.get (name);
            if (! oldTitle.contains (tle)) {
                String newTle = (tle + ".").concat (oldTitle);
                titleNamesMap.put (name, newTle);
            }
        } else {
            titleNamesMap.put (name, tle);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19834874_19835298_34_45
19834874_19835405_3_18
Title: Sorting Duplicate Keys with respective values in java 
----------------------------------------

public int compare (HouseNo o1, HouseNo o2) {
    Integer first = Integer.valueOf (o1.getHouseno ());
    Integer second = Integer.valueOf (o2.getHouseno ());
    Integer f1 = Integer.valueOf (o1.getBlockno ());
    Integer f2 = Integer.valueOf (o2.getBlockno ());
    if (first.compareTo (second) == 0) {
        return f1.compareTo (f2);
    }
    return first.compareTo (second);
}
----------------------------------------

public int compare (String o1, String o2) {
    String [] o1sub = o1.split ("-");
    String [] o2sub = o2.split ("-");
    int value1 = Integer.parseInt (o1sub [0]);
    int value2 = Integer.parseInt (o2sub [0]);
    if (value1 != value2) {
        return new Integer (value1).compareTo (value2);
    }
    int value3 = Integer.parseInt (o1sub [1]);
    int value4 = Integer.parseInt (o2sub [1]);
    if (value3 != value4) {
        return new Integer (value3).compareTo (value4);
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19835657_19836070_7_16
19835657_19836295_17_34
Title: Synchronization in Java 
----------------------------------------

public void run () {
    try {
        for (int i = 1;
        i <= 5; i ++) {
            System.out.println (i);
            barrier.await ();
        }
    } catch (InterruptedException | BrokenBarrierException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public void run () {
    int i;
    for (i = 1; i <= 5; i ++) {
        System.out.println (i);
        synchronized (obj) {
            obj.val = ! obj.val;
            while (obj.val) {
                try {
                    wait ();
                } catch (InterruptedException e) {
                    System.out.println ("Interrupted");
                }
            }
            notify ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19840582_19841325_1_19
19840582_19841620_1_26
Title: "Method to check higher precendence of operators Is there a smarter way to do this?" 
----------------------------------------

static boolean hasHigherPrecendence (char top, char current) {
    Map < Character, Integer > map = new HashMap < > ();
    map.put ('+', new Integer (1));
    map.put ('-', new Integer (1));
    map.put ('*', new Integer (2));
    map.put ('/', new Integer (2));
    map.put ('%', new Integer (3));
    if (map.get (top) == null) {
        throw new IllegalArgumentException ("Operator unknown: " + top);
    }
    if (map.get (current) == null) {
        throw new IllegalArgumentException ("Operator unknown: " + current);
    }
    if (map.get (t) >= map.get (c)) {
        return true;
    } else {
        return false;
    }
}
----------------------------------------

static boolean hasHigherPrecendence (char top, char current) {
    String t = String.valueOf (top);
    String c = String.valueOf (current);
    System.out.println (t);
    System.out.println (c);
    switch (t) {
        case "-" :
        case "+" :
            if (c.equals ("-") || c.equals ("+")) return false;

            break;
        case "/" :
        case "*" :
        case "%" :
            if (c.equals ("%") || c.equals ("*") || c.equals ("/")) return false;

            break;
        default :
            throw new IllegalArgumentException ("Operator unknown: " + t);
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19853659_19854024_5_38
19853659_19854166_1_38
Title: returning a count of the number of slots in the array that contain a value that is equal to the index of the slot 
----------------------------------------

public static void main (String [] args) {
    int k;
    int [] arrayOfValues;
    ArrayList < Integer > answer;
    answer = new ArrayList < Integer > ();
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter the array size: ");
    k = in.nextInt ();
    arrayOfValues = new int [k];
    for (int i = 0;
    i < arrayOfValues.length; ++ i) arrayOfValues [i] = (int) (Math.random () * arrayOfValues.length);

    for (int i = 0;
    i < arrayOfValues.length; i ++) {
        if (arrayOfValues [i] == i) {
            answer.add (i);
        }
    }
    System.out.println ("Your answer is:");
    for (int i : answer) {
        System.out.println (i);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int inputSize;
    System.out.println ("Enter the array size: ");
    inputSize = in.nextInt ();
    if (inputSize > 0) {
        Random random = new Random ();
        int randomNumber;
        int count = 0;
        for (int i = 0;
        i < inputSize; i ++) {
            randomNumber = random.nextInt () % inputSize;
            System.out.print ("a[" + i + "] = " + randomNumber);
            if (randomNumber == i) {
                System.out.println (" *");
                count ++;
            } else {
                System.out.println ();
            }
        }
        System.out.println ("There are " + count + " slots where the index is the same as the value.");
    } else {
        System.out.println ("Invalid Input");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19853863_19853911_33_49
19853863_19853940_33_51
Title: Java error: cannot find symbol 
----------------------------------------

public static void main (String [] args) {
    Lamp lamp1 = new Lamp ();
    Lamp lamp2 = new Lamp ();
    lamp1.setBrightness (3);
    lamp2.setBrightness (10);
    lamp1.getBrightness ();
    System.out.println ("Lamp1" + lamp1.message);
    lamp2.getBrightness ();
    System.out.println ("Lamp2" + lamp2.message);
}
----------------------------------------

public static void main (String [] args) {
    Lamp lamp1, lamp2, lamp3;
    lamp1 = new Lamp ();
    lamp2 = new Lamp ();
    lamp1.setBrightness (3);
    lamp2.setBrightness (10);
    lamp1.getBrightness ();
    System.out.println ("Lamp1" + lamp1.getBrightness ());
    lamp2.getBrightness ();
    System.out.println ("Lamp2" + lamp2.getBrightness ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19853863_19853911_33_49
19853863_34497432_3_21
Title: Java error: cannot find symbol 
----------------------------------------

public static void main (String [] args) {
    Lamp lamp1 = new Lamp ();
    Lamp lamp2 = new Lamp ();
    lamp1.setBrightness (3);
    lamp2.setBrightness (10);
    lamp1.getBrightness ();
    System.out.println ("Lamp1" + lamp1.message);
    lamp2.getBrightness ();
    System.out.println ("Lamp2" + lamp2.message);
}
----------------------------------------

public static void main (String [] args) {
    Lamp lamp1, lamp2, lamp3;
    lamp1 = new Lamp ();
    lamp2 = new Lamp ();
    lamp3 = new Lamp ();
    lamp1.setBrightness (3);
    lamp2.setBrightness (10);
    lamp1.getBrightness ();
    System.out.println ("Lamp1" + lamp1.message);
    lamp2.getBrightness ();
    System.out.println ("Lamp2" + lamp2.message);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19861286_19861471_1_15
19861286_19861485_1_16
Title: Words with vowels in alphabetical order 
----------------------------------------

public static boolean containsVowels (String word) {
    String vowels = "aeiouy";
    if (word == null || word.length () < vowels.length ()) return false;

    int counter = 0;
    int vowelCounter = 0;
    while (counter < word.length () && vowelCounter < vowels.length ()) {
        if (word.charAt (counter) == vowels.charAt (vowelCounter)) {
            vowelCounter ++;
        }
        counter ++;
    }
    return vowelCounter == vowels.length ();
}
----------------------------------------

public static boolean containsVowels (String word) throws NullPointerException {
    List < String > vowels = new ArrayList < String > (Arrays.asList ("a", "e", "i", "o", "u", "y"));
    String lastVowel = vowels.get (vowels.size () - 1);
    for (String c : vowels) {
        if (! word.contains (c)) {
            return false;
        }
        if (c.equals (lastVowel)) {
            return true;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19872826_19872863_5_19
19872826_19872882_1_13
Title: My program will not display any output 
----------------------------------------

public static void main (String [] args) {
    double radius;
    double height;
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter radius: ");
    radius = in.nextDouble ();
    System.out.print ("Enter height: ");
    height = in.nextDouble ();
    System.out.println ("surfacearea " + Calculations (radius, height));
    System.out.println ("volume " + calculations (radius, height));
    System.out.println ("output " + output (radius, height));
}
----------------------------------------

public static void main (String [] args) {
    double radius;
    double height;
    Scanner in = new Scanner (System.in);
    System.out.print ("Enter radius: ");
    radius = in.nextDouble ();
    System.out.print ("Enter height: ");
    height = in.nextDouble ();
    System.out.println ("area " + output (Calculations (radius, height)));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19876564_19876615_3_12
19876564_19876631_3_14
Title: Issue with user input and .equals() in Java 
----------------------------------------

public static void main (String [] args) {
    Scanner user_input = new Scanner (System.in);
    System.out.println ("What is 5 times 4? ");
    String question;
    question = user_input.next ();
    if (question.equals ("20")) System.out.println ("Correct!");

    if (! "20".equals (question)) System.out.println ("Incorrect!");

}
----------------------------------------

public static void main (String [] args) {
    Scanner user_input = new Scanner (System.in);
    System.out.println ("What is 5 times 4? ");
    String question;
    question = user_input.next ();
    if (question.equals ("20")) {
        System.out.println ("Correct!");
    }
    if (! "20".equals (question)) {
        System.out.println ("Incorrect!");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19876564_19876615_3_12
19876564_19876767_1_11
Title: Issue with user input and .equals() in Java 
----------------------------------------

public static void main (String [] args) {
    Scanner user_input = new Scanner (System.in);
    System.out.println ("What is 5 times 4? ");
    String question;
    question = user_input.next ();
    if (question.equals ("20")) System.out.println ("Correct!");

    if (! "20".equals (question)) System.out.println ("Incorrect!");

}
----------------------------------------

public static void main (String [] args) {
    Scanner user_input = new Scanner (System.in);
    System.out.println ("What is 5 times 4? ");
    String question;
    question = user_input.next ();
    if (question.equals ("20")) {
        System.out.println ("Correct!");
    } else {
        System.out.println ("Incorrect!");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19876596_19876745_10_28
19876596_19877256_43_62
Title: Java can't add my total_value's to a new array with 100 slots 
----------------------------------------

public static void main (String [] args) {
    HashMap < Integer, Integer > totals = new HashMap < > ();
    for (int i = - NBR_STEPS;
    i <= NBR_STEPS; i ++) {
        totals.put (i, 0);
    }
    for (int i = 0;
    i < NBR_WALKS; i ++) {
        int total_value = 0;
        for (int j = 0;
        j < NBR_STEPS; j ++) {
            int L = (int) (Math.random () * 2);
            total_value += (L == 0) ? - 1 : 1;
        }
        System.out.println ("For run number " + i + " the total is " + total_value);
        totals.put (total_value, totals.get (total_value) + 1);
    }
    System.out.println ("Number of times you ended on -5 " + totals.get (- 5));
}
----------------------------------------

public static void main (String [] args) throws ExecutionException, InterruptedException {
    final AtomicInteger counter = new AtomicInteger (NUMBER_WALKS);
    final ConcurrentSkipListMap < Integer, Integer > totals = new ConcurrentSkipListMap < > ();
    final int numCPUs = Runtime.getRuntime ().availableProcessors ();
    final ExecutorService executor = Executors.newFixedThreadPool (numCPUs);
    for (int i = 0;
    i < numCPUs; ++ i) {
        executor.submit (new Counter (counter, totals));
    }
    executor.shutdown ();
    if (executor.awaitTermination (10, TimeUnit.SECONDS)) {
        for (Integer key : totals.keySet ()) {
            System.out.println (String.format ("%3d was called %3d times.", key, totals.get (key)));
        }
    } else {
        executor.shutdownNow ();
        System.err.println ("Executor did not terminate as expected.");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19883769_19883895_1_10
19883769_19883997_1_12
Title: Java count function not working. Console application array of numbers 
----------------------------------------

public int count (int item, int [] bag) {
    int count = 0;
    for (int i = 0;
    i < length; i ++) {
        if (bag [i] == item) {
            count ++;
        }
    }
    return count;
}
----------------------------------------

public int count (int item) {
    int count = 0;
    Node current = first.getNext ();
    while (current != null) {
        if (current.getInfo () == item) {
            count ++;
        }
        current = current.getNext ();
    }
    return count;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19886038_19917848_100_112
19886038_19917848_68_83
Title: Unable to add make JTextArea show multiplie lines insidea JScrollPane 
----------------------------------------

private GridBagConstraints makeGbc (int y, int x, int gridheight, int gridwidth) {
    GridBagConstraints gbc = new GridBagConstraints ();
    gbc.gridwidth = gridwidth;
    gbc.gridheight = gridheight;
    gbc.gridx = x;
    gbc.gridy = y;
    gbc.insets = new Insets (2, 2, 2, 2);
    gbc.anchor = (y == 0) ? GridBagConstraints.LINE_START : GridBagConstraints.LINE_END;
    gbc.fill = GridBagConstraints.BOTH;
    return gbc;
}
----------------------------------------

private GridBagConstraints makeGbc (int y, int x) {
    GridBagConstraints gbc = new GridBagConstraints ();
    gbc.gridx = x;
    gbc.gridy = y;
    gbc.weightx = 1.0;
    gbc.weighty = 1.0;
    gbc.insets = new Insets (2, 2, 2, 2);
    gbc.anchor = (y == 0) ? GridBagConstraints.LINE_START : GridBagConstraints.LINE_END;
    gbc.fill = GridBagConstraints.BOTH;
    System.out.printf ("gridwidth, gridheight: [%d, %d]%n", gbc.gridwidth, gbc.gridheight);
    return gbc;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19889827_19889851_7_22
19889827_19889896_3_18
Title: """The method is not defined for the type"" error in simple program in java" 
----------------------------------------

public Fetch () {
    System.out.println ("Fetched!");
    int a = 1;
    int b = 2;
    int c;
    while (a < 100 && b < 200) {
        a ++;
        b ++;
        c = a + b;
        System.out.println (c);
    }
}
----------------------------------------

public Fetch () {
    System.out.println ("Fetched!");
    int a = 1;
    int b = 2;
    int c;
    while (a < 100 && b < 200) {
        a ++;
        b ++;
        c = a + b;
        System.out.println (c);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19895610_19895788_5_22
19895610_19896557_5_21
Title: How do I loop my guessing game? 
----------------------------------------

public static void main (String [] args) {
    boolean rightanswer = false;
    while (! rightanswer) {
        String inputText = JOptionPane.showInputDialog ("What is the magic word?");
        String outputText = null;
        if (inputText.equalsIgnoreCase ("themagicword")) {
            outputText = "Well done!";
            rightanswer = true;
        }
        if (! (inputText.equalsIgnoreCase ("themagicword"))) {
            outputText = "Wrong!";
        }
        JOptionPane.showMessageDialog (null, outputText);
    }
}
----------------------------------------

public static void main (String [] args) {
    while (true) {
        String inputText = JOptionPane.showInputDialog ("What is the magic word?");
        if (! (inputText.equalsIgnoreCase ("themagicword"))) {
            JOptionPane.showMessageDialog (null, "Wrong!");
        }
        if (inputText.equalsIgnoreCase ("themagicword")) {
            JOptionPane.showMessageDialog (null, "Well done!");
            break;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19898533_19898617_1_17
19898533_19898655_1_27
Title: "What is Wrong With This Code I It Just Doesnt Complie and it is Due on Tuesday Please Advise Me" 
----------------------------------------

private String GetMessage (Quarter quarter, int departmentNumber) {
    String result = null;
    switch (quarter) {
        case FIRST :
            result = "Enter The First Quarterly Sales For Department [ " + departmentNumber + " ]. . . . . $ ";
        case SECOND :
            result = "Enter a The Second Quarterly Sales For Department [ " + departmentNumber + " ]. . . . . $ ";
        case THIRD :
            result = "Enter a The Third Quarterly Sales For Department [ " + departmentNumber + " ]. . . . . $ ";
        case FORTH :
            result = "Enter a The Forth Quarterly Sales For Department [ " + departmentNumber + " ]. . . . . $ ";
    }
    return result;
}
----------------------------------------

private String GetMessage (int quarter, int departmentNumber) {
    String msg = null;
    switch (quarter) {
        case FIRST :
            msg = "Enter The First Quarterly Sales For Department [ " + departmentNumber + " ]. . . . . $ ";
            break;
        case SECOND :
            msg = "Enter a The Second Quarterly Sales For Department [ " + departmentNumber + " ]. . . . . $ ";
            break;
        case THIRD :
            msg = "Enter a The Third Quarterly Sales For Department [ " + departmentNumber + " ]. . . . . $ ";
            break;
        case FORTH :
            msg = "Enter a The Forth Quarterly Sales For Department [ " + departmentNumber + " ]. . . . . $ ";
            break;
        default :
            msg = "no choice.";
    }
    return msg;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19910875_19910951_3_17
19910875_19910983_1_12
Title: Nested loop pattern not working 
----------------------------------------

public void method () {
    int row = 1;
    int col = 1;
    for (row = 1; row <= 5; row ++) {
        for (col = 1; col <= row; ++ col) {
            System.out.print (col * row);
        }
        System.out.println ();
    }
}
----------------------------------------

public void method () {
    for (int row = 1;
    row <= 5; row ++) {
        for (int val = 1;
        val <= row; val ++) {
            System.out.print (val * row);
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19910875_19910951_3_17
19910875_19911029_3_13
Title: Nested loop pattern not working 
----------------------------------------

public void method () {
    int row = 1;
    int col = 1;
    for (row = 1; row <= 5; row ++) {
        for (col = 1; col <= row; ++ col) {
            System.out.print (col * row);
        }
        System.out.println ();
    }
}
----------------------------------------

public void method () {
    for (int row = 1;
    row <= 5; row ++) {
        for (int column = 1;
        column <= row; column ++) {
            System.out.print (row * column);
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19910875_19910983_1_12
19910875_19911029_3_13
Title: Nested loop pattern not working 
----------------------------------------

public void method () {
    for (int row = 1;
    row <= 5; row ++) {
        for (int val = 1;
        val <= row; val ++) {
            System.out.print (val * row);
        }
        System.out.println ();
    }
}
----------------------------------------

public void method () {
    for (int row = 1;
    row <= 5; row ++) {
        for (int column = 1;
        column <= row; column ++) {
            System.out.print (row * column);
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19910875_19910983_1_12
19910875_19911086_1_11
Title: Nested loop pattern not working 
----------------------------------------

public void method () {
    for (int row = 1;
    row <= 5; row ++) {
        for (int val = 1;
        val <= row; val ++) {
            System.out.print (val * row);
        }
        System.out.println ();
    }
}
----------------------------------------

public void method () {
    int row = 1;
    int val = 0;
    for (row = 1; row <= 5; row ++) {
        for (val = 1; val <= row; val ++) {
            System.out.printf ("%2d ", row * val);
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19910875_19911029_3_13
19910875_19911086_1_11
Title: Nested loop pattern not working 
----------------------------------------

public void method () {
    for (int row = 1;
    row <= 5; row ++) {
        for (int column = 1;
        column <= row; column ++) {
            System.out.print (row * column);
        }
        System.out.println ();
    }
}
----------------------------------------

public void method () {
    int row = 1;
    int val = 0;
    for (row = 1; row <= 5; row ++) {
        for (val = 1; val <= row; val ++) {
            System.out.printf ("%2d ", row * val);
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19914476_19914865_36_75
19914476_19915172_35_76
Title: Plot the sine and cosine functions 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    g.drawLine (10, 100, 380, 100);
    g.drawLine (200, 30, 200, 190);
    g.drawLine (380, 100, 370, 90);
    g.drawLine (380, 100, 370, 110);
    g.drawLine (200, 30, 190, 40);
    g.drawLine (200, 30, 210, 40);
    g.drawString ("X", 360, 80);
    g.drawString ("Y", 220, 40);
    Polygon p = new Polygon ();
    Polygon p2 = new Polygon ();
    for (int x = - 170;
    x <= 170; x ++) {
        p.addPoint (x + 200, 100 - (int) (50 * f ((x / 100.0) * 2 * Math.PI)));
    }
    for (int x = - 170;
    x <= 170; x ++) {
        p2.addPoint (x + 200, 100 - (int) (50 * gCos ((x / 100.0) * 2 * Math.PI)));
    }
    g.setColor (Color.red);
    g.drawPolyline (p.xpoints, p.ypoints, p.npoints);
    g.drawString ("-2\u03c0", 95, 115);
    g.drawString ("2\u03c0", 305, 115);
    g.drawString ("0", 200, 115);
    g.setColor (Color.blue);
    g.drawPolyline (p2.xpoints, p2.ypoints, p2.npoints);
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    g.drawLine (10, 100, 380, 100);
    g.drawLine (200, 30, 200, 190);
    g.drawLine (380, 100, 370, 90);
    g.drawLine (380, 100, 370, 110);
    g.drawLine (200, 30, 190, 40);
    g.drawLine (200, 30, 210, 40);
    g.drawString ("X", 360, 80);
    g.drawString ("Y", 220, 40);
    Polygon p = new Polygon ();
    Polygon p2 = new Polygon ();
    for (int x = - 170;
    x <= 170; x ++) {
        p.addPoint (x + 200, 100 - (int) (50 * f ((x / 100.0) * 2 * Math.PI)));
    }
    for (int x = - 170;
    x <= 170; x ++) {
        p2.addPoint (x + 200, 100 - (int) (50 * gCos ((x / 100.0) * 2 * Math.PI)));
    }
    g.setColor (Color.red);
    g.drawPolyline (p.xpoints, p.ypoints, p.npoints);
    g.drawString ("-2\u03c0", 95, 115);
    g.drawString ("-\u03c0", 147, 115);
    g.drawString ("\u03c0", 253, 115);
    g.drawString ("2\u03c0", 305, 115);
    g.drawString ("0", 200, 115);
    g.setColor (Color.blue);
    g.drawPolyline (p2.xpoints, p2.ypoints, p2.npoints);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19922333_19922444_1_14
19922333_19922494_1_10
Title: Possible to use iteration to produce a string in Java? 
----------------------------------------

public String toString () {
    int len = coeffs.length;
    String result = "";
    int j = coeffs.length - 1;
    for (int i = 0;
    i < len; ++ i) {
        result += coeffs [i] + "x^(" + j + ")+";
        j --;
    }
    return result.substring (0, result.length - 1);
}
----------------------------------------

public String toString () {
    int len = coeffs.length;
    String equation = '';
    String power = '';
    for (int i = len - 1;
    i > 0; i --) {
        power = (i > 1 ? 'x^' + i : 'x');
        equation += (coeffs [len - 1 - i] + variable + " ");
    }
    equation += coeffs [0];
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19922333_19922444_1_14
19922333_19922701_12_29
Title: Possible to use iteration to produce a string in Java? 
----------------------------------------

public String toString () {
    int len = coeffs.length;
    String result = "";
    int j = coeffs.length - 1;
    for (int i = 0;
    i < len; ++ i) {
        result += coeffs [i] + "x^(" + j + ")+";
        j --;
    }
    return result.substring (0, result.length - 1);
}
----------------------------------------

public String toString () {
    int valuesLen = values.length;
    int exponent;
    StringBuffer result = new StringBuffer ();
    for (int i = 0;
    i < valuesLen; i ++) {
        if (result.length () > 0) result.append (" + ");

        result.append (((Double) values [i]).toString ());
        exponent = valuesLen - i - 1;
        if (exponent > 0) result.append ("x");

        if (exponent > 1) {
            result.append ("^");
            result.append (((Integer) exponent).toString ());
        }
    }
    return new String (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19922333_19922494_1_10
19922333_19922701_12_29
Title: Possible to use iteration to produce a string in Java? 
----------------------------------------

public String toString () {
    int len = coeffs.length;
    String equation = '';
    String power = '';
    for (int i = len - 1;
    i > 0; i --) {
        power = (i > 1 ? 'x^' + i : 'x');
        equation += (coeffs [len - 1 - i] + variable + " ");
    }
    equation += coeffs [0];
}
----------------------------------------

public String toString () {
    int valuesLen = values.length;
    int exponent;
    StringBuffer result = new StringBuffer ();
    for (int i = 0;
    i < valuesLen; i ++) {
        if (result.length () > 0) result.append (" + ");

        result.append (((Double) values [i]).toString ());
        exponent = valuesLen - i - 1;
        if (exponent > 0) result.append ("x");

        if (exponent > 1) {
            result.append ("^");
            result.append (((Integer) exponent).toString ());
        }
    }
    return new String (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19922596_19922626_1_28
19922596_19922635_1_30
Title: How to return 2 ResultSet? 
----------------------------------------

public ResultSet [] getdata (String query, boolean test, List < CartEntry > items) {
    int k;
    try {
        Connection conn;
        Statement st;
        ResultSet [] rs = new ResultSet [2];
        List < Product > prodList = new ArrayList < Product > ();
        for (CartEntry ce : items) {
            prodList.add (new Product ("p" + ce.getpId (), "test", "prod" + ce.getpId (), (int) ce.getpId (), ce.getpId () + 0.12f, ce.getQuantity ()));
            rs [1] = new DummyResultSet (prodList);
            k = ce.getQuantity ();
            System.out.println (k);
        }
        st = conn.createStatement ();
        rs [0] = st.executeQuery (query);
        querystatus = true;
    } catch (Exception e) {
        querystatus = false;
    }
    return rs;
}
----------------------------------------

public ArrayList getdata (String query, boolean test, List < CartEntry > items) {
    ArrayList arr = new ArrayList ();
    int k;
    try {
        Connection conn;
        Statement st;
        public ResultSet rs, result;
        List < Product > prodList = new ArrayList < Product > ();
        for (CartEntry ce : items) {
            prodList.add (new Product ("p" + ce.getpId (), "test", "prod" + ce.getpId (), (int) ce.getpId (), ce.getpId () + 0.12f, ce.getQuantity ()));
            result = new DummyResultSet (prodList);
            k = ce.getQuantity ();
            System.out.println (k);
        }
        st = conn.createStatement ();
        rs = st.executeQuery (query);
        querystatus = true;
        arr.add (rs);
        arr.add (result);
        return arr;
    } catch (Exception e) {
        querystatus = false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19925820_19926282_19_30
19925820_19926292_13_27
Title: Fork/Join: Collecting results 
----------------------------------------

protected void compute () {
    if (serialThresholdMet ()) {
        Arrays.sort (a, left, right + 1);
    } else {
        int pivotIndex = partition (a, left, right);
        ForkJoinQuicksortTask t1 = new ForkJoinQuicksortTask (a, left, pivotIndex - 1);
        ForkJoinQuicksortTask t2 = new ForkJoinQuicksortTask (a, pivotIndex + 1, right);
        t1.fork ();
        t2.compute ();
        t1.join ();
    }
}
----------------------------------------

protected Integer compute () {
    if (end - start > 10) {
        final int half = (end + start) / 2;
        final MyTask firstHalf = new MyTask (list, start, half);
        final MyTask secondHalf = new MyTask (list, half + 1, end);
        invokeAll (firstHalf, secondHalf);
        return firstHalf.get () + secondHalf.get ();
    } else {
        int result = 0;
        for (int i = start;
        i <= end; i ++) {
            result += list.get (i);
        }
        return result;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19925820_19926282_19_30
19925820_19926423_23_41
Title: Fork/Join: Collecting results 
----------------------------------------

protected void compute () {
    if (serialThresholdMet ()) {
        Arrays.sort (a, left, right + 1);
    } else {
        int pivotIndex = partition (a, left, right);
        ForkJoinQuicksortTask t1 = new ForkJoinQuicksortTask (a, left, pivotIndex - 1);
        ForkJoinQuicksortTask t2 = new ForkJoinQuicksortTask (a, pivotIndex + 1, right);
        t1.fork ();
        t2.compute ();
        t1.join ();
    }
}
----------------------------------------

protected Long compute () {
    final int size = end - begin;
    if (size < THRESHOLD) {
        long sum = 0;
        for (int i = begin;
        i < end; i ++) sum += list.get (i);

        return sum;
    } else {
        final int middle = begin + ((end - begin) / 2);
        RecursiveSum sum1 = new RecursiveSum (list, begin, middle);
        sum1.fork ();
        RecursiveSum sum2 = new RecursiveSum (list, middle, end);
        return sum2.compute () + sum1.join ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19925820_19926282_54_65
19925820_19926423_44_60
Title: Fork/Join: Collecting results 
----------------------------------------

public static void main (String [] args) {
    ForkJoinPool fjPool = new ForkJoinPool ();
    int [] a = new int [3333344];
    for (int i = 0;
    i < a.length; i ++) {
        int k = (int) (Math.random () * 22222);
        a [i] = k;
    }
    ForkJoinQuicksortTask forkJoinQuicksortTask = new ForkJoinQuicksortTask (a, 0, a.length - 1);
    long start = System.nanoTime ();
    fjPool.invoke (forkJoinQuicksortTask);
    System.out.println ("Time: " + (System.nanoTime () - start));
}
----------------------------------------

public static void main (String [] args) {
    List < Integer > list = new ArrayList < > ();
    long expectedSum = 0;
    for (int i = 0;
    i < 10000; i ++) {
        int random = 1 + (int) (Math.random () * ((100 - 1) + 1));
        list.add (random);
        expectedSum += random;
    }
    System.out.println ("expected sum: " + expectedSum);
    final ForkJoinPool forkJoinPool = new ForkJoinPool (Runtime.getRuntime ().availableProcessors ());
    final RecursiveSum recursiveSum = new RecursiveSum (list, 0, list.size ());
    long recSum = forkJoinPool.invoke (recursiveSum);
    System.out.println ("recursive-sum: " + recSum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19925820_19926292_13_27
19925820_19926423_23_41
Title: Fork/Join: Collecting results 
----------------------------------------

protected Integer compute () {
    if (end - start > 10) {
        final int half = (end + start) / 2;
        final MyTask firstHalf = new MyTask (list, start, half);
        final MyTask secondHalf = new MyTask (list, half + 1, end);
        invokeAll (firstHalf, secondHalf);
        return firstHalf.get () + secondHalf.get ();
    } else {
        int result = 0;
        for (int i = start;
        i <= end; i ++) {
            result += list.get (i);
        }
        return result;
    }
}
----------------------------------------

protected Long compute () {
    final int size = end - begin;
    if (size < THRESHOLD) {
        long sum = 0;
        for (int i = begin;
        i < end; i ++) sum += list.get (i);

        return sum;
    } else {
        final int middle = begin + ((end - begin) / 2);
        RecursiveSum sum1 = new RecursiveSum (list, begin, middle);
        sum1.fork ();
        RecursiveSum sum2 = new RecursiveSum (list, middle, end);
        return sum2.compute () + sum1.join ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19925988_19926295_1_16
19925988_19928766_1_10
Title: Android SQLite: How to retrieve auto-incremented userId? 
----------------------------------------

public int getUserId (String userName) {
    int userId;
    SQLiteDatabase db = this.getReadableDatabase ();
    Cursor cursor = db.query (tableName, new String [] {userId}, userName + "=?", new String [] {userName}, null, null, null, null);
    while (cursor.moveToNext ()) {
        userId = cursor.getInt (cursor.getColumnIndex ("userId"));
    }
    cursor.close ();
    return userId;
}
----------------------------------------

public int getUserId (String userName) {
    SQLiteDatabase db = getReadableDatabase ();
    String query = "SELECT userId FROM users WHERE userName = ?";
    String [] parameters = new String [] {userName};
    Cursor cursor = db.rawQuery (query, parameters);
    if (cursor.moveToFirst ()) return cursor.getInt (0);
    else return - 1;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19926071_19926133_1_15
19926071_19926578_1_14
Title: Check with what object the method is triggered 
----------------------------------------

public String getDisplayValue (Boolean isMinute) {
    if (isMinute) {
        if (value < 10) {
            return "0" + value;
        } else {
            return "" + value;
        }
    } else {
    }
}
----------------------------------------

public String getDisplayValue (char c) {
    if (c == 'h') {
        if (value < 10) {
            return "0" + value;
        } else {
            return "" + value;
        }
    } else if (c == 'm') {
        return value * 60;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1992638_1992648_8_26
1992638_32462327_10_23
Title: Java inverse matrix calculation 
----------------------------------------

public static void main (String [] args) {
    double [] [] values = {{1, 1, 2}, {2, 4, - 3}, {3, 6, - 5}};
    double [] rhs = {9, 1, 0};
    double [] answer = {1, 2, 3};
    Matrix a = new Matrix (values);
    a.print (10, 2);
    LUDecomposition luDecomposition = new LUDecomposition (a);
    luDecomposition.getL ().print (10, 2);
    luDecomposition.getU ().print (10, 2);
    Matrix b = new Matrix (rhs, rhs.length);
    Matrix x = luDecomposition.solve (b);
    x.print (10, 2);
    Matrix residual = a.times (x).minus (b);
    double rnorm = residual.normInf ();
    System.out.println ("residual: " + rnorm);
}
----------------------------------------

public static void main (String [] args) {
    double [] [] values = {{1, 1, 2}, {2, 4, - 3}, {3, 6, - 5}};
    double [] [] rhs = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
    RealMatrix A = new Array2DRowRealMatrix (values);
    System.out.println ("Input A: " + A);
    DecompositionSolver solver = new LUDecomposition (A).getSolver ();
    RealMatrix I = new Array2DRowRealMatrix (rhs);
    RealMatrix B = solver.solve (I);
    System.out.println ("Inverse B: " + B);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1992638_1992648_8_26
1992638_49251497_111_137
Title: Java inverse matrix calculation 
----------------------------------------

public static void main (String [] args) {
    double [] [] values = {{1, 1, 2}, {2, 4, - 3}, {3, 6, - 5}};
    double [] rhs = {9, 1, 0};
    double [] answer = {1, 2, 3};
    Matrix a = new Matrix (values);
    a.print (10, 2);
    LUDecomposition luDecomposition = new LUDecomposition (a);
    luDecomposition.getL ().print (10, 2);
    luDecomposition.getU ().print (10, 2);
    Matrix b = new Matrix (rhs, rhs.length);
    Matrix x = luDecomposition.solve (b);
    x.print (10, 2);
    Matrix residual = a.times (x).minus (b);
    double rnorm = residual.normInf ();
    System.out.println ("residual: " + rnorm);
}
----------------------------------------

public static void main (String [] args) {
    double [] [] a = {{1, 1, 1}, {0, 2, 5}, {2, 5, - 1}};
    double [] [] b = {{6}, {- 4}, {27}};
    double [] [] matrix = multiply (inverse (a), b);
    for (double [] i : matrix) System.out.println (Arrays.toString (i));

    System.out.println ();
    a = new double [] [] {{1, 1, 1, 6}, {0, 2, 5, - 4}, {2, 5, - 1, 27}};
    matrix = rref (a);
    for (double [] i : matrix) System.out.println (Arrays.toString (i));

    System.out.println ();
    double [] [] x = {{2104, 5, 1, 45}, {1416, 3, 2, 40}, {1534, 3, 2, 30}, {852, 2, 1, 36}};
    double [] [] y = {{460}, {232}, {315}, {178}};
    matrix = multiply (multiply (inverse (multiply (transpose (x), x)), transpose (x)), y);
    for (double [] i : matrix) System.out.println (Arrays.toString (i));

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1992638_32462327_10_23
1992638_49251497_111_137
Title: Java inverse matrix calculation 
----------------------------------------

public static void main (String [] args) {
    double [] [] values = {{1, 1, 2}, {2, 4, - 3}, {3, 6, - 5}};
    double [] [] rhs = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};
    RealMatrix A = new Array2DRowRealMatrix (values);
    System.out.println ("Input A: " + A);
    DecompositionSolver solver = new LUDecomposition (A).getSolver ();
    RealMatrix I = new Array2DRowRealMatrix (rhs);
    RealMatrix B = solver.solve (I);
    System.out.println ("Inverse B: " + B);
}
----------------------------------------

public static void main (String [] args) {
    double [] [] a = {{1, 1, 1}, {0, 2, 5}, {2, 5, - 1}};
    double [] [] b = {{6}, {- 4}, {27}};
    double [] [] matrix = multiply (inverse (a), b);
    for (double [] i : matrix) System.out.println (Arrays.toString (i));

    System.out.println ();
    a = new double [] [] {{1, 1, 1, 6}, {0, 2, 5, - 4}, {2, 5, - 1, 27}};
    matrix = rref (a);
    for (double [] i : matrix) System.out.println (Arrays.toString (i));

    System.out.println ();
    double [] [] x = {{2104, 5, 1, 45}, {1416, 3, 2, 40}, {1534, 3, 2, 30}, {852, 2, 1, 36}};
    double [] [] y = {{460}, {232}, {315}, {178}};
    matrix = multiply (multiply (inverse (multiply (transpose (x), x)), transpose (x)), y);
    for (double [] i : matrix) System.out.println (Arrays.toString (i));

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19927388_19927428_28_45
19927388_19927607_25_40
Title: GUI in java swings 
----------------------------------------

public void mouseClicked (MouseEvent e) {
    if (SwingUtilities.isLeftMouseButton (e) && e.getClickCount () == 1) {
        try {
            InetAddress locIP = InetAddress.getByName (x);
            InetAddress.getByName ("14.139.60.104");
            Socket soc = new Socket (locIP, 7681);
            BufferedReader in = new BufferedReader (new InputStreamReader (soc.getInputStream ()));
            String y = null;
            while ((y = in.readLine ()) != null) {
                output.setText (y);
            }
        } catch (Exception e1) {
        }
    }
}
----------------------------------------

public void mouseClicked (MouseEvent e) {
    if (SwingUtilities.isLeftMouseButton (e) && e.getClickCount () == 1) {
        try {
            InetAddress locIP = InetAddress.getByName (x);
            Socket soc = new Socket (locIP, 7681);
            BufferedReader in = new BufferedReader (new InputStreamReader (soc.getInputStream ()));
            String y = null;
            while ((y = in.readLine ()) != null) {
                list.add (y);
            }
        } catch (Exception e1) {
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19935323_19935561_5_26
19935323_19935733_4_18
Title: Using the while loop to ask user their input in JAVA 
----------------------------------------

public static void main (String args []) {
    Scanner kb = new Scanner (System.in);
    int input = 0;
    int total = 0;
    System.out.println ("How Many Numbers You Want To Enter");
    int totalNumberOfInputs = kb.nextInt ();
    while (input < totalNumberOfInputs) {
        input ++;
        total += kb.nextInt ();
    }
    System.out.println ("Total: " + total);
}
----------------------------------------

public static void main (String args []) {
    Scanner kb = new Scanner (System.in);
    System.out.println ("How Many Numbers You Want To Enter: ");
    int total = kb.nextInt ();
    int input = 0;
    int sum = 0;
    while (input < total) {
        input ++;
        System.out.println ("Enter " + input + ". Operand: ");
        sum += kb.nextInt ();
    }
    System.out.println ("The sum is " + sum + ".");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19937173_19937603_31_39
19937173_19937603_43_53
Title: Increment/decrement with GUI(Java) 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    valueInt = Integer.parseInt (showLbl.getText ());
    valueInt ++;
    if (valueInt >= 10) {
        showLbl.setText (String.valueOf (valueInt));
    } else {
        showLbl.setText ("0" + String.valueOf (valueInt));
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    valueInt = Integer.parseInt (showLbl.getText ());
    if (valueInt > 0) {
        valueInt --;
    }
    if (valueInt >= 10) {
        showLbl.setText (String.valueOf (valueInt));
    } else {
        showLbl.setText ("0" + String.valueOf (valueInt));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19938346_19938438_1_25
19938346_19938637_1_18
Title: adding elements to a singly linked list 
----------------------------------------

public void add (int newEntry) {
    Node newNode = new Node (newEntry, null);
    if (start == null) {
        start = newNode;
    } else if (newEntry <= start.data) {
        newNode.next = start;
        start = newNode;
    } else {
        Node ptr = start;
        Node prv = null;
        while (ptr != null && newEntry > ptr.data) {
            prv = ptr;
            ptr = ptr.next;
        }
        prv.next = newNode;
        newNode.next = ptr;
    }

}
----------------------------------------

public void add (int newEntry) {
    Node ptr = start;
    Node insert = null;
    while (ptr != null && newEntry >= ptr.data) {
        insert = ptr;
        ptr = ptr.next;
    }
    Node newNode = new Node (newEntry, ptr);
    if (insert == null) start = newNode;
    else insert.next = newNode;

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19940740_19940947_1_42
19940740_30534647_1_52
Title: Gaussian Elimination Java 
----------------------------------------

public static double [] [] rref (double [] [] mat) {
    double [] [] rref = new double [mat.length] [mat [0].length];
    for (int r = 0;
    r < rref.length; ++ r) {
        for (int c = 0;
        c < rref [r].length; ++ c) {
            rref [r] [c] = mat [r] [c];
        }
    }
    for (int p = 0;
    p < rref.length; ++ p) {
        double pv = rref [p] [p];
        if (pv != 0) {
            double pvInv = 1.0 / pv;
            for (int i = 0;
            i < rref [p].length; ++ i) {
                rref [p] [i] *= pvInv;
            }
        }
        for (int r = 0;
        r < rref.length; ++ r) {
            if (r != p) {
                double f = rref [r] [p];
                for (int i = 0;
                i < rref [r].length; ++ i) {
                    rref [r] [i] -= f * rref [p] [i];
                }
            }
        }
    }
    return rref;
}
----------------------------------------

static public void rref (double [] [] m) {
    int lead = 0;
    int rowCount = m.length;
    int colCount = m [0].length;
    int i;
    boolean quit = false;
    for (int row = 0;
    row < rowCount && ! quit; row ++) {
        print (m);
        println ();
        if (colCount <= lead) {
            quit = true;
            break;
        }
        i = row;
        while (! quit && m [i] [lead] == 0) {
            i ++;
            if (rowCount == i) {
                i = row;
                lead ++;
                if (colCount == lead) {
                    quit = true;
                    break;
                }
            }
        }
        if (! quit) {
            swapRows (m, i, row);
            if (m [row] [lead] != 0) multiplyRow (m, row, 1.0f / m [row] [lead]);

            for (i = 0; i < rowCount; i ++) {
                if (i != row) subtractRows (m, m [i] [lead], row, i);

            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19941598_19941710_1_11
19941598_19941838_1_13
Title: How to print a cross shape in command line in Java? 
----------------------------------------

public static void drawCross (int num) {
    if (num % 2 != 0) {
        for (int line = 0;
        line < num; line ++) {
            for (int col = 0;
            col < num; col ++) {
                if (line == num / 2 || col == num / 2) System.out.print ("*");
                else System.out.print (" ");

            }
            System.out.println ("");
        }
    }
}
----------------------------------------

public static void drawCross (int num) {
    if (num % 2 != 0) {
        for (int i = 0;
        i < num; i ++) {
            for (int j = 0;
            j < num; j ++) {
                if ((i == num / 2) || (j == num / 2)) System.out.print ("*");
                else System.out.print (" ");

            }
            System.out.println ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19941598_19941710_1_11
19941598_19941898_1_23
Title: How to print a cross shape in command line in Java? 
----------------------------------------

public static void drawCross (int num) {
    if (num % 2 != 0) {
        for (int line = 0;
        line < num; line ++) {
            for (int col = 0;
            col < num; col ++) {
                if (line == num / 2 || col == num / 2) System.out.print ("*");
                else System.out.print (" ");

            }
            System.out.println ("");
        }
    }
}
----------------------------------------

public static void drawCross (int num) {
    if (num % 2 != 0) {
        for (int y = 0;
        y < num; y ++) {
            for (int x = 0;
            x < num; x ++) {
                if (x == (int) (num / 2) || y == (int) (num / 2)) {
                    System.out.print ("*");
                } else {
                    System.out.print (" ");
                }
            }
            System.out.println ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19941598_19941838_1_13
19941598_19941898_1_23
Title: How to print a cross shape in command line in Java? 
----------------------------------------

public static void drawCross (int num) {
    if (num % 2 != 0) {
        for (int i = 0;
        i < num; i ++) {
            for (int j = 0;
            j < num; j ++) {
                if ((i == num / 2) || (j == num / 2)) System.out.print ("*");
                else System.out.print (" ");

            }
            System.out.println ();
        }
    }
}
----------------------------------------

public static void drawCross (int num) {
    if (num % 2 != 0) {
        for (int y = 0;
        y < num; y ++) {
            for (int x = 0;
            x < num; x ++) {
                if (x == (int) (num / 2) || y == (int) (num / 2)) {
                    System.out.print ("*");
                } else {
                    System.out.print (" ");
                }
            }
            System.out.println ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1994255_37579977_1_30
1994255_6745127_1_20
Title: How to write console output to a txt file 
----------------------------------------

public static void main (String [] args) {
    int i;
    List < String > ls = new ArrayList < String > ();
    for (i = 1; i <= 100; i ++) {
        String str = null;
        str = + i + ":- HOW TO WRITE A CONSOLE OUTPUT IN A PDF";
        ls.add (str);
    }
    String listString = "";
    for (String s : ls) {
        listString += s + "\n";
    }
    Document document = new Document ();
    try {
        PdfWriter writer1 = PdfWriter.getInstance (document, new FileOutputStream ("final_pdf.pdf"));
        document.open ();
        document.add (new Paragraph (listString));
        document.close ();
        writer1.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (DocumentException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    BufferedReader in = new BufferedReader (new InputStreamReader (System.in));
    BufferedWriter out = new BufferedWriter (new FileWriter ("c://output.txt"));
    try {
        String inputLine = null;
        do {
            inputLine = in.readLine ();
            out.write (inputLine);
            out.newLine ();
        } while (! inputLine.equalsIgnoreCase ("eof"));
        System.out.print ("Write Successful");
    } catch (IOException e1) {
        System.out.println ("Error during reading/writing");
    } finally {
        out.close ();
        in.close ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19970775_19970906_5_38
19970775_19971024_1_19
Title: Combining two ArrayLists 
----------------------------------------

public static void interLeave (ArrayList < String > list1, ArrayList < String > list2) {
    ArrayList < String > tempList = new ArrayList < > ();
    int count = 1;
    int length = list1.size () + list2.size ();
    String temp1 = "";
    String temp2 = "";
    boolean test = true;
    if (list1.size () >= list2.size ()) {
        for (int j = 0;
        j < list2.size (); j ++) {
            for (int i = 0;
            i < list2.size (); i ++) {
                tempList.add (2 * i, list1.get (i));
                tempList.add (2 * i + 1, list2.get (i));
                count ++;
                if (count == list2.size ()) {
                    break;
                }
            }
        }
        list1.clear ();
        list1.addAll (tempList);
    } else {
        for (int i = 0;
        i < length; i ++) {
            list1.add (2 * i + 1, list2.get (i));
            count ++;
            if (count == list1.size ()) {
                break;
            }
        }
    }
}
----------------------------------------

public static void interLeave (ArrayList < String > list1, ArrayList < String > list2) {
    ArrayList < String > tempList = new ArrayList < String > ();
    int length = Math.max (list1.size (), list2.size ());
    for (int j = 0;
    j < length; j ++) {
        if (j < list1.size ()) {
            tempList.add (2 * j, list1.get (j));
        }
        if (j < list2.size ()) {
            tempList.add (2 * j + 1, list2.get (j));
        }
    }
    list1.clear ();
    list1.addAll (tempList);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19980736_19980923_1_14
19980736_19981097_1_13
Title: Returning different JSON objects from different requests 
----------------------------------------

private void writeResponse (Object objectToWrite, ResourceResponse response) {
    try {
        ObjectMapper mapper = new ObjectMapper ();
        response.getWriter ().write (mapper.writeValueAsString (objectToWrite));
    } catch (final JsonGenerationException e) {
        log.error (e.getMessage ());
    } catch (final JsonMappingException e) {
        log.error (e.getMessage ());
    } catch (final IOException e) {
        log.error (e.getMessage ());
    }
}
----------------------------------------

private void writeResponse (HasDto hasDto, ResourceResponse response) {
    try {
        ObjectMapper mapper = new ObjectMapper ();
        response.getWriter ().write (mapper.writeValueAsString (hasDto.getDto ()));
    } catch (final JsonGenerationException e) {
        log.error (e.getMessage ());
    } catch (final JsonMappingException e) {
        log.error (e.getMessage ());
    } catch (final IOException e) {
        log.error (e.getMessage ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19986654_19986787_2_24
19986654_31286328_3_23
Title: "How do I find vowels in a string and print the word with the most vowels on the screen?" 
----------------------------------------

public static void main (String [] args) {
    String sentence = "This is a loooooooooong sentence";
    int maxVowelCount = 0;
    String wordsWithMostVowels = null;
    String [] words = sentence.split (" ");
    for (String word : words) {
        int vowelCount = 0;
        word = word.toLowerCase ();
        for (int i = 0;
        i < word.length (); i ++) {
            char x = word.charAt (i);
            if (x == 'a' || x == 'e' || x == 'i' || x == 'o' || x == 'u') {
                vowelCount ++;
            }
        }
        if (vowelCount > maxVowelCount) {
            maxVowelCount = vowelCount;
            wordsWithMostVowels = word;
        }
    }
    System.out.println ("Word with most vowels is: " + wordsWithMostVowels);
}
----------------------------------------

public static void main (String args []) {
    String s1 = new String ("The Ghost of The Arabean Sea");
    char c1 [] = new char [30];
    char c2 [] = {'a', 'e', 'i', 'o', 'u'};
    s1.getChars (0, 28, c1, 0);
    int pf = 0, pl = 0;
    for (int i = 0;
    i < s1.length (); i ++) {
        for (int j = 0;
        j < 5; j ++) {
            if (c1 [i] == c2 [j]) {
                System.out.println ("vowel found at:-> " + (i + 1) + " which is " + c2 [j]);
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19987371_19987603_6_16
19987371_19988892_16_45
Title: Simulating Thread failure in Java 
----------------------------------------

public void run () {
    while (! doFail && ! Thread.interrupted ()) {
        try {
            Thread.sleep (1000);
        } catch (InterruptedException e) {
            Thread.currentThread ().interrupt ();
        }
    }
    throw new RuntimeException ("failed");
}
----------------------------------------

public void run () {
    final boolean isWriter = number % 2 == 0;
    int index = random.nextInt (objects.length);
    try {
        while (Thread.interrupted () == false) {
            synchronized (objects) {
                if (isWriter) {
                    while (objects [index] == null) {
                        System.out.println (number + ": Index " + index + " is null, waiting...");
                        objects.wait ();
                    }
                    for (int copyIndex = 0;
                    copyIndex < objects.length; ++ copyIndex) {
                        if (objects [copyIndex] == null) {
                            objects [copyIndex] = this.objects [index];
                        }
                    }
                    objects.notifyAll ();
                } else {
                    objects [index] = null;
                }
            }
            ++ index;
            if (index >= objects.length) {
                index = 0;
            }
        }
    } catch (InterruptedException e) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19991975_19992037_77_85
19991975_19992037_89_97
Title: pictures not refreshing when clicking arrow keys (keylistener) 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    if (listOfFiles != null && listOfFiles.length > 0) {
        i --;
        if (i < 0) {
            i = listOfFiles.length - 1;
        }
        loadCurrent ();
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    if (listOfFiles != null && listOfFiles.length > 0) {
        i ++;
        if (i >= listOfFiles.length) {
            i = 0;
        }
        loadCurrent ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19993751_19993822_3_14
19993751_19993842_7_46
Title: Stack overflow error 
----------------------------------------

public static void main (String [] args) {
    queueCollection d1 = new queueCollection ("QUEUE_A1", "QUEUE_A2", false);
    queueCollection d2 = new queueCollection ("QUEUE_B1", "QUEUE_B2", false);
    queueCollection d3 = new queueCollection ("QUEUE_C1", "QUEUE_C1", true);
    queueCollection d4 = new queueCollection ("QUEUE_D1", "QUEUE_D2", true);
    List < queueCollection > list = new ArrayList < queueCollection > ();
    list.add (d1);
    list.add (d2);
    list.add (d3);
    list.add (d4);
    System.out.println (list.toString ());
}
----------------------------------------

public static void main (String [] args) {
    QueueSelection selection = new QueueSelection ();
    List < queueCollection > queueList = selection.initQueueCollection ();
    selection.printQueueCollection (queueList);
    Map < String, List < queueCollection > > map = new HashMap < String, List < queueCollection > > ();
    map.put ("QUEUE", queueList);
    queueCollection particularCollection = null;
    for (queueCollection collection : map.get ("QUEUE")) {
        if ("QUEUE_A1".equals (collection.getQueueName1 ()) && "QUEUE_A2".equals (collection.getQueueName2 ())) {
            particularCollection = collection;
        }
    }
    if (null == particularCollection) {
        System.out.println ("No Particular collection is found!");
    } else {
        System.out.println ("\n Particular collection is found from entire collection, its value is as follows:!");
        System.out.printf ("[Name1]=>%s , [Name2]=>%s", particularCollection.getQueueName1 (), particularCollection.getQueueName2 ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20014213_20014305_5_32
20014213_20014472_7_39
Title: In & Out Cannot be Resolved to a Type (Java Socket) 
----------------------------------------

public static void main (String [] args) throws IOException {
    if (args.length != 1) {
        System.err.println ("Usage: java EchoServer <port number>");
        System.exit (1);
    }
    int portNumber = Integer.parseInt (args [0]);
    try (ServerSocket serverSocket = new ServerSocket (Integer.parseInt (args [0])); Socket clientSocket = serverSocket.accept (); PrintWriter out = new PrintWriter (clientSocket.getOutputStream (), true); BufferedReader in = new BufferedReader (new InputStreamReader (clientSocket.getInputStream ()))) {
        String inputLine;
        while ((inputLine = in.readLine ()) != null) {
            out.println (inputLine);
        }
    } catch (IOException e) {
        System.out.println ("Exception caught when trying to listen on port " + portNumber + " or listening for a connection");
        System.out.println (e.getMessage ());
    }
}
----------------------------------------

public static void main (String...args) throws IOException {
    String host;
    int port;
    if (args.length != 2) {
        System.out.println ("binding to port localhost:9999");
        host = "localhost";
        port = 9999;
    } else {
        host = args [0];
        port = Integer.parseInt (args [1]);
    }
    try (Socket echoSocket = new Socket (host, port); PrintWriter out = new PrintWriter (echoSocket.getOutputStream (), true); BufferedReader in = new BufferedReader (new InputStreamReader (echoSocket.getInputStream ())); BufferedReader stdIn = new BufferedReader (new InputStreamReader (System.in))) {
        System.out.println ("Type in some text please.");
        String userInput;
        while ((userInput = stdIn.readLine ()) != null) {
            out.println (userInput);
            System.out.println ("echo: " + in.readLine ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20014213_20014305_5_32
20014213_20034343_9_42
Title: In & Out Cannot be Resolved to a Type (Java Socket) 
----------------------------------------

public static void main (String [] args) throws IOException {
    if (args.length != 1) {
        System.err.println ("Usage: java EchoServer <port number>");
        System.exit (1);
    }
    int portNumber = Integer.parseInt (args [0]);
    try (ServerSocket serverSocket = new ServerSocket (Integer.parseInt (args [0])); Socket clientSocket = serverSocket.accept (); PrintWriter out = new PrintWriter (clientSocket.getOutputStream (), true); BufferedReader in = new BufferedReader (new InputStreamReader (clientSocket.getInputStream ()))) {
        String inputLine;
        while ((inputLine = in.readLine ()) != null) {
            out.println (inputLine);
        }
    } catch (IOException e) {
        System.out.println ("Exception caught when trying to listen on port " + portNumber + " or listening for a connection");
        System.out.println (e.getMessage ());
    }
}
----------------------------------------

public static void main (String...args) throws IOException {
    String host;
    int port;
    if (args.length != 2) {
        System.out.println ("binding to port localhost:9999");
        host = "localhost";
        port = 9999;
    } else {
        host = args [0];
        port = Integer.parseInt (args [1]);
    }
    try (Socket echoSocket = new Socket (host, port); PrintWriter socketOut = new PrintWriter (echoSocket.getOutputStream (), true); Scanner socketIn = new Scanner (echoSocket.getInputStream ()); Scanner console = new Scanner (System.in)) {
        System.out.println ("Type in some text please.");
        while (console.hasNextLine ()) {
            String userInput = console.nextLine ();
            socketOut.println (userInput);
            System.out.println ("echo: " + socketIn.nextLine ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20014213_20014472_7_39
20014213_20034343_9_42
Title: In & Out Cannot be Resolved to a Type (Java Socket) 
----------------------------------------

public static void main (String...args) throws IOException {
    String host;
    int port;
    if (args.length != 2) {
        System.out.println ("binding to port localhost:9999");
        host = "localhost";
        port = 9999;
    } else {
        host = args [0];
        port = Integer.parseInt (args [1]);
    }
    try (Socket echoSocket = new Socket (host, port); PrintWriter out = new PrintWriter (echoSocket.getOutputStream (), true); BufferedReader in = new BufferedReader (new InputStreamReader (echoSocket.getInputStream ())); BufferedReader stdIn = new BufferedReader (new InputStreamReader (System.in))) {
        System.out.println ("Type in some text please.");
        String userInput;
        while ((userInput = stdIn.readLine ()) != null) {
            out.println (userInput);
            System.out.println ("echo: " + in.readLine ());
        }
    }
}
----------------------------------------

public static void main (String...args) throws IOException {
    String host;
    int port;
    if (args.length != 2) {
        System.out.println ("binding to port localhost:9999");
        host = "localhost";
        port = 9999;
    } else {
        host = args [0];
        port = Integer.parseInt (args [1]);
    }
    try (Socket echoSocket = new Socket (host, port); PrintWriter socketOut = new PrintWriter (echoSocket.getOutputStream (), true); Scanner socketIn = new Scanner (echoSocket.getInputStream ()); Scanner console = new Scanner (System.in)) {
        System.out.println ("Type in some text please.");
        while (console.hasNextLine ()) {
            String userInput = console.nextLine ();
            socketOut.println (userInput);
            System.out.println ("echo: " + socketIn.nextLine ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20014309_20014335_1_14
20014309_20014361_1_17
Title: Multidimensional Array (Grid Displayed) IF conditions 
----------------------------------------

public void tGridPrint () {
    for (int row = 0;
    row < page.length; row ++) {
        for (int column = 0;
        column < page [row].length; column ++) {
            if (page [row] [column] == letter) {
                System.out.print ((char) page [row] [column] + " ");
            } else {
                System.out.print (page [row] [column] + " ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------

public void tGridPrint () {
    for (int row = 0;
    row < page.length; row ++) {
        for (int column = 0;
        column < page [row].length; column ++) if (page [row] [column] == letter) System.out.print ((char) page [row] [column] + " ");
        else System.out.print (page [row] [column] + " ");

        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20014309_20014361_1_17
20014309_20014396_1_20
Title: Multidimensional Array (Grid Displayed) IF conditions 
----------------------------------------

public void tGridPrint () {
    for (int row = 0;
    row < page.length; row ++) {
        for (int column = 0;
        column < page [row].length; column ++) if (page [row] [column] == letter) System.out.print ((char) page [row] [column] + " ");
        else System.out.print (page [row] [column] + " ");

        System.out.println ();
    }
}
----------------------------------------

public void tGridPrint () {
    for (int row = 0;
    row < page.length; row ++) {
        for (int column = 0;
        column < page [row].length; column ++) {
            if (page [row] [column] == 'x') {
                System.out.print ((char) page [row] [column] + " ");
            } else {
                System.out.print (page [row] [column] + " ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20022439_20063373_16_34
20022439_20755585_17_40
Title: Throwing null pointer exception in Android 
----------------------------------------

public ArrayList < HashMap < String, String > > getPlayList () {
    System.out.println (MEDIA_PATH);
    if (MEDIA_PATH != null) {
        File home = new File (MEDIA_PATH);
        File [] listFiles = home.listFiles ();
        if (listFiles != null && listFiles.length > 0) {
            for (File file : listFiles) {
                System.out.println (file.getAbsolutePath ());
                if (file.isDirectory ()) {
                    scanDirectory (file);
                } else {
                    addSongToList (file);
                }
            }
        }
    }
    return songsList;
}
----------------------------------------

public ArrayList < HashMap < String, String > > getPlayList () {
    Log.d ("testsd", MEDIA_PATH);
    File home = new File (MEDIA_PATH);
    if (home.listFiles (new FileExtensionFilter ()) != null) {
        for (File file : home.listFiles (new FileExtensionFilter ())) {
            HashMap < String, String > song = new HashMap < String, String > ();
            song.put ("songTitle", file.getName ().substring (0, (file.getName ().length () - 4)));
            song.put ("songPath", file.getPath ());
            songsList.add (song);
        }
    }
    return songsList;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20026383_20026434_1_17
20026383_20026511_3_15
Title: Problems with this code (Sorry I can't be specific) 
----------------------------------------

public static void main (String [] args) {
    char ch [] = new char [26];
    for (int x = 0;
    x < ch.length; x ++) {
        ch [x] = (char) (x + 'A');
    }
    boolean first = true;
    for (char c : ch) {
        if (! first) {
            System.out.print (", ");
        }
        System.out.print (c);
        first = false;
    }
    System.out.println ();
    System.out.flush ();
}
----------------------------------------

public static void main (String [] args) {
    char ch [] = new char [26];
    for (int x = 0;
    x < ch.length; x ++) {
        ch [x] = (char) (x + 65);
    }
    for (int i = 0;
    i < ch.length - 1; i ++) System.out.print (ch [i] + ", ");

    System.out.print (ch [ch.length - 1]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20027944_20028007_4_16
20027944_36294419_4_27
Title: Printing values entered by user and stored to an array in Java 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int [] numbers = new int [10];
    System.out.print ("Please enter " + numbers.length + " values:");
    for (int index = 0;
    index < numbers.length; index ++) {
        numbers [index] = input.nextInt ();
    }
    input.close ();
    System.out.print ("Values in array: ");
    for (int n : numbers) {
        System.out.print (n + "\t");
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] values = new int [3];
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter the values in array");
    for (int i = 0;
    i < values.length; i ++) {
        values [i] = input.nextInt ();
    }
    input.close ();
    System.out.println ("values in array");
    System.out.println ("From the first method of printing array");
    for (int j : values) {
        System.out.println (j);
    }
    System.out.println ("From the second method of printing array");
    for (int n = 0;
    n < values.length; n ++) {
        System.out.println (values [n]);
    }
    System.out.println ("From the third method of printing array");
    System.out.println (Arrays.toString (values));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20027944_20028007_4_16
20027944_44908340_3_16
Title: Printing values entered by user and stored to an array in Java 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int [] numbers = new int [10];
    System.out.print ("Please enter " + numbers.length + " values:");
    for (int index = 0;
    index < numbers.length; index ++) {
        numbers [index] = input.nextInt ();
    }
    input.close ();
    System.out.print ("Values in array: ");
    for (int n : numbers) {
        System.out.print (n + "\t");
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    String [] a = new String [10];
    System.out.println ("Enter a String");
    for (int i = 0;
    i < a.length; i ++) {
        a [i] = s.nextLine ();
    }
    System.out.println ("String entered was");
    for (String j : a) {
        System.out.print (j);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20027944_36294419_4_27
20027944_44908340_3_16
Title: Printing values entered by user and stored to an array in Java 
----------------------------------------

public static void main (String [] args) {
    int [] values = new int [3];
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter the values in array");
    for (int i = 0;
    i < values.length; i ++) {
        values [i] = input.nextInt ();
    }
    input.close ();
    System.out.println ("values in array");
    System.out.println ("From the first method of printing array");
    for (int j : values) {
        System.out.println (j);
    }
    System.out.println ("From the second method of printing array");
    for (int n = 0;
    n < values.length; n ++) {
        System.out.println (values [n]);
    }
    System.out.println ("From the third method of printing array");
    System.out.println (Arrays.toString (values));
}
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    String [] a = new String [10];
    System.out.println ("Enter a String");
    for (int i = 0;
    i < a.length; i ++) {
        a [i] = s.nextLine ();
    }
    System.out.println ("String entered was");
    for (String j : a) {
        System.out.print (j);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20028834_20029071_3_21
20028834_20029485_3_166
Title: Java: How to sum the elements of two arrays with different lengths 
----------------------------------------

public static void main (String [] args) {
    int [] num1 = {1, 9, 9, 9};
    int [] num2 = {7, 9, 9, 9, 9, 9, 9};
    int [] biggerArray = num1.length > num2.length ? num1 : num2;
    int [] smallerArray = num1.length <= num2.length ? num1 : num2;
    int [] summedArray = new int [biggerArray.length];
    System.arraycopy (biggerArray, 0, summedArray, 0, biggerArray.length);
    for (int i = 0;
    i < smallerArray.length; i ++) {
        summedArray [i] += smallerArray [i];
    }
    for (int i = 0;
    i < summedArray.length; i ++) {
        System.out.println (summedArray [i]);
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] num1 = {1, 9, 9, 9};
    int [] num2 = {9, 9, 9, 9};
    int capacity = Math.max (num1.length, num2.length);
    int [] arraySum = new int [capacity + 1];
    int len2 = num2.length;
    int len1 = num1.length;
    if (len1 < len2) {
        int lengthDiff = len2 - len1;
        boolean needCarry = false;
        for (int i = len1 - 1;
        i >= 0; i --) {
            int sumPerPosition = 0;
            if (needCarry) {
                sumPerPosition = num1 [i] + num2 [i + lengthDiff] + 1;
                needCarry = false;
            } else {
                sumPerPosition = num1 [i] + num2 [i + lengthDiff];
            }
            if (sumPerPosition > 9) {
                arraySum [i + lengthDiff + 1] = sumPerPosition % 10;
                needCarry = true;
            } else {
                arraySum [i + lengthDiff + 1] = sumPerPosition % 10;
            }
        }
        for (int i = lengthDiff - 1;
        i >= 0; i --) {
            if (needCarry) {
                arraySum [i + 1] = num2 [i] + 1;
            } else {
                arraySum [i + 1] = num1 [i];
            }
            if (arraySum [i + 1] > 9) {
                arraySum [i + 1] = arraySum [i + 1] % 10;
                needCarry = true;
            } else {
                needCarry = false;
            }
        }
        if (needCarry) {
            arraySum [0] = 1;
        } else {
            arraySum [0] = 0;
        }
    } else {
        int lengthDiff = len1 - len2;
        boolean needCarry = false;
        for (int i = len2 - 1;
        i >= 0; i --) {
            int sumPerPosition = 0;
            if (needCarry) {
                sumPerPosition = num2 [i] + num1 [i + lengthDiff] + 1;
                needCarry = false;
            } else {
                sumPerPosition = num2 [i] + num1 [i + lengthDiff];
            }
            if (sumPerPosition > 9) {
                arraySum [i + lengthDiff + 1] = sumPerPosition % 10;
                needCarry = true;
            } else {
                arraySum [i + lengthDiff + 1] = sumPerPosition % 10;
            }
        }
        for (int i = lengthDiff - 1;
        i >= 0; i --) {
            if (needCarry) {
                arraySum [i + 1] = num1 [i] + 1;
            } else {
                arraySum [i + 1] = num1 [i];
            }
            if (arraySum [i + 1] > 9) {
                arraySum [i + 1] = arraySum [i + 1] % 10;
                needCarry = true;
            } else {
                needCarry = false;
            }
        }
        if (needCarry) {
            arraySum [0] = 1;
        } else {
            arraySum [0] = 0;
        }
    }
    if (arraySum [0] == 1) {
        System.out.print (1);
    }
    for (int i = 1;
    i < arraySum.length; i ++) {
        System.out.print (arraySum [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20034470_37076508_105_125
20034470_37076508_135_151
Title: JSSC serial connection set write timeout 
----------------------------------------

public void run () {
    IOException exception;
    try {
        if (onlyOneByte) {
            byteWriter.write (oneByte);
        } else {
            byteWriter.write (bytes);
        }
        exception = null;
    } catch (IOException e) {
        exception = e;
    }
    lock.lock ();
    try {
        result.writeException = exception;
        result.writeDone = exception == null;
        condition.signalAll ();
    } finally {
        lock.unlock ();
    }
}
----------------------------------------

public void run () {
    boolean interrupted;
    try {
        TimeUnit.MILLISECONDS.sleep (timeout);
        interrupted = false;
    } catch (InterruptedException e) {
        interrupted = true;
    }
    lock.lock ();
    try {
        result.timedout = ! interrupted;
        condition.signalAll ();
    } finally {
        lock.unlock ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20034470_37076508_28_37
20034470_37076508_39_48
Title: JSSC serial connection set write timeout 
----------------------------------------

TimedOutByteWriting (ByteWriter byteWriter, byte oneByte, long timeout) {
    if (timeout <= 0) {
        throw new IllegalArgumentException ("Invalid time out value : " + timeout + ". Must be greater than 0");
    }
    this.byteWriter = Objects.requireNonNull (byteWriter, "byteWriter");
    this.bytes = null;
    this.oneByte = oneByte;
    this.timeout = timeout;
    this.onlyOneByte = true;
}
----------------------------------------

TimedOutByteWriting (ByteWriter byteWriter, byte [] bytes, long timeout) {
    if (timeout <= 0) {
        throw new IllegalArgumentException ("Invalid time out value : " + timeout + ". Must be greater than 0");
    }
    this.byteWriter = Objects.requireNonNull (byteWriter, "byteWriter");
    this.bytes = Objects.requireNonNull (bytes, "bytes");
    this.timeout = timeout;
    this.oneByte = 0;
    this.onlyOneByte = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20036335_20070900_1_28
20036335_20071432_1_18
Title: Repeating drawLine() to draw vertical bars Java 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    int totalWidth, totalHeight, barHeight, barWidth, totalBarsRequired;
    barWidth = 5;
    totalWidth = getWidth ();
    totalHeight = getHeight ();
    totalBarsRequired = (int) totalWidth / barWidth;
    for (int barNumber = 0;
    barNumber < totalBarsRequired; barNumber ++) {
        barHeight = rd.nextInt (totalHeight);
        for (int barLineNumber = 0;
        barLineNumber < barWidth; barLineNumber ++) {
            g.drawLine ((barNumber * barWidth) + barLineNumber, barHeight, (barNumber * barWidth) + barLineNumber, barHeight);
        }
    }
}
----------------------------------------

@Override
protected void paintComponent (Graphics g) {
    Dimension size = getSize ();
    g.setColor (Color.white);
    g.fillRect (0, 0, size.width, size.height);
    g.setColor (new Color (0x445566));
    Graphics2D g2 = (Graphics2D) g;
    g2.setStroke (new BasicStroke (5, BasicStroke.CAP_SQUARE, BasicStroke.JOIN_MITER));
    for (int i = 0;
    i < barValues.length; i ++) {
        int h = (int) Math.round (barValues [i] * size.height);
        int x = (i * (BAR_WIDTH + BAR_GAP)) + BAR_WIDTH / 2;
        int y = size.height - 1 - h;
        g.drawLine (x, y, x, y + h);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20037036_20037128_4_14
20037036_20037317_3_18
Title: Simplifying Multiple Line Array 
----------------------------------------

public static void main (String args []) {
    final int ARRAY_LENGTH = 25;
    int array [] = new int [ARRAY_LENGTH];
    for (int counter = 0;
    counter < array.length; counter ++) {
        System.out.printf ("%d, ", counter);
        if (counter % 5 == 4) {
            System.out.printf ("\n");
        }
    }
}
----------------------------------------

public static void main (String args []) {
    final int ARRAY_LENGTH = 25;
    int array [] = new int [ARRAY_LENGTH];
    for (int counter = 0;
    counter < ARRAY_LENGTH; counter ++) {
        array [counter] = counter;
        System.out.printf ("%d, ", counter);
        if (counter > 0 && counter % 5 == 0) System.out.println ();

    }
    System.out.println (ARRAY_LENGTH);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20039214_20039299_1_16
20039214_20039572_12_23
Title: Removing the minimum value in a binary search tree? 
----------------------------------------

public Node removeMin (Node root) {
    if (root == NULL) return NULL;

    if (root.left != NULL) {
        return removeMin (root.left);
    }
    if (insertNode.right == NULL) {
        Node temp = root;
        root = NULL;
        return temp;
    } else {
        return removeMin (root.right);
    }
}
----------------------------------------

public Node removeMin () {
    if (root == null) {
        return null;
    } else if (root.left != null) {
        return removeMin (root);
    } else {
        Node minNode = root;
        root = root.right;
        minNode.right = null;
        return minNode;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20039214_20039299_1_16
20039214_20039572_1_10
Title: Removing the minimum value in a binary search tree? 
----------------------------------------

public Node removeMin (Node root) {
    if (root == NULL) return NULL;

    if (root.left != NULL) {
        return removeMin (root.left);
    }
    if (insertNode.right == NULL) {
        Node temp = root;
        root = NULL;
        return temp;
    } else {
        return removeMin (root.right);
    }
}
----------------------------------------

private Node removeMin (Node node) {
    if (node.left.left == null) {
        Node minNode = node.left;
        node.left = node.left.right;
        minNode.right = null;
        return minNode;
    } else {
        return removeMin (node.left);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20039214_20039572_12_23
20039214_20039572_1_10
Title: Removing the minimum value in a binary search tree? 
----------------------------------------

public Node removeMin () {
    if (root == null) {
        return null;
    } else if (root.left != null) {
        return removeMin (root);
    } else {
        Node minNode = root;
        root = root.right;
        minNode.right = null;
        return minNode;
    }

}
----------------------------------------

private Node removeMin (Node node) {
    if (node.left.left == null) {
        Node minNode = node.left;
        node.left = node.left.right;
        minNode.right = null;
        return minNode;
    } else {
        return removeMin (node.left);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20039949_20040171_5_17
20039949_20040195_5_24
Title: Timer and TimerTask Java 
----------------------------------------

public void run () {
    i ++;
    if (i == 1) System.out.println ("Hello User");

    if (i == 10) {
        System.out.println ("Ten Seconds Have Gone By");
    }
    if (i == 13) {
        System.out.println ("Goodbye User");
        cancel ();
    }
}
----------------------------------------

public void run () {
    System.out.println ("Hello User");
    try {
        Thread.sleep (10000);
        System.out.println ("Ten Seconds Have Gone By");
        Thread.sleep (5000);
        System.out.println ("Goodbye User");
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20042808_25796103_80_91
20042808_25796103_93_104
Title: How to validate a DateField correctly in Vaadin? 
----------------------------------------

private boolean isValid (String s) {
    s = StringUtils.trimToNull (s);
    if (s == null) {
        convertedDate = null;
        return true;
    }
    try {
        return isValid (DTF.parseDateTime (s).toDate ());
    } catch (Exception e) {
        return false;
    }
}
----------------------------------------

private boolean isValid (Date d) {
    if (d == null || DateUtils.truncatedEquals (original, d, Calendar.DAY_OF_MONTH)) {
        convertedDate = d;
        return true;
    }
    if (DateUtils.truncatedCompareTo (minDay, d, Calendar.DAY_OF_MONTH) <= 0 && DateUtils.truncatedCompareTo (maxDay, d, Calendar.DAY_OF_MONTH) >= 0) {
        convertedDate = d;
        return true;
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20048609_20049325_41_54
20048609_20049512_15_29
Title: Print BST to a text area in java 
----------------------------------------

private void printTree (Node t, StringBuilder sb) {
    if (t.left != null) {
        sb.append ("Phone Number:" + t.phone_number.toString () + "  Contact Name : " + t.contact_name.toString ());
        printTree (t.left, sb);
    }
    if (t.right != null) {
        printTree (t.right, sb);
        sb.append ("name:" + t.phone_number.toString () + "  Number : " + t.contact_name.toString ());
    }
}
----------------------------------------

private String printTree (Node t) {
    String str = "";
    if (t.left != null) {
        str += "Phone Number:" + t.phone_number + "  Contact Name : " + t.contact_name + "\n";
        str += printTree (t.left);
    }
    if (t.right != null) {
        str += printTree (t.right);
        str += "name:" + t.phone_number + "  Number : " + t.contact_name + "\n";
    }
    return str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20049795_20050222_1_13
20049795_20050349_1_26
Title: return string of odd elements in a linked list 
----------------------------------------

public String toString (Node < E > node) {
    if (node == null) {
        return "";
    } else {
        Node < E > next = node.next ();
        if (next == null) {
            return node.element ().toString ();
        }
        return node.element () + "\n" + toString (next.next ());
    }
}
----------------------------------------

public String toString (Node < E > node) {
    if (node == null) {
        return "";
    }
    String elements = "";
    int counter = 0;
    elements = node.element;
    node = node.next ();
    counter ++;
    while (node != null) {
        if (counter % 2 == 0) {
            elements = elements + "\n" + node.element;
        }
        node = node.next ();
        counter ++;
    }
    return elements;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20054926_20056054_1_16
20054926_20057301_1_21
Title: Game of life neighbor issue. array index out of bounds exception 
----------------------------------------

public int neighbours (int x, int y) {
    int result = 0;
    for (int i = x - 1;
    i <= x + 1; i ++) {
        if (i < life.length && i > 0) {
            for (int j = y - 1;
            j <= y + 1; j ++) {
                if (j < life [i].length && j > 0) {
                    if (life [i] [j] == '*') {
                        result ++;
                    }
                }
            }
        }
    }
    return result;
}
----------------------------------------

public int neighbours (int x, int y) {
    int result = 0;
    for (int i = x - 1;
    i <= x + 1; i ++) {
        if (i < life.length && i >= 0) {
            for (int j = y - 1;
            j <= y + 1; j ++) {
                if (j < life [i].length && j >= 0) {
                    if (life [i] [j].equals ("*")) {
                        result ++;
                    }
                }
            }
        }
    }
    return result - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20059106_20060077_34_54
20059106_20060077_60_77
Title: IPv6 Multicast example 
----------------------------------------

public void run () {
    MulticastSocket multicastSocket = null;
    try {
        multicastSocket = new MulticastSocket (PORT);
        multicastSocket.joinGroup (GROUP);
        while (true) {
            try {
                byte [] receiveData = new byte [256];
                DatagramPacket receivePacket = new DatagramPacket (receiveData, receiveData.length);
                multicastSocket.receive (receivePacket);
                LOGGER.info ("Client received from : " + receivePacket.getAddress () + ", " + new String (receivePacket.getData ()));
            } catch (Exception e) {
                LOGGER.error (null, e);
            }
        }
    } catch (Exception e) {
        LOGGER.error (null, e);
    } finally {
        multicastSocket.close ();
    }
}
----------------------------------------

public void run () {
    DatagramSocket serverSocket = null;
    try {
        serverSocket = new DatagramSocket ();
        try {
            while (true) {
                byte [] sendData = new byte [256];
                DatagramPacket sendPacket = new DatagramPacket (sendData, sendData.length, GROUP, PORT);
                serverSocket.send (sendPacket);
                ThreadUtilities.sleep (1000);
            }
        } catch (Exception e) {
            LOGGER.error (null, e);
        }
    } catch (Exception e) {
        LOGGER.error (null, e);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
20063713_20063772_1_14
20063713_20063786_1_14
Title: 2D Java Arrays. Turning Negative numbers to zeros 
----------------------------------------

public static int [] [] zeroNegatives (int [] [] arr) {
    for (int r = 0;
    r < arr.length; r ++) {
        for (int c = 0;
        c < arr [r].length; c ++) {
            if (arr [r] [c] < 0) {
                arr [r] [c] *= - 1;
            }
        }
    }
    return arr;
}
----------------------------------------

public static int [] [] zeroNegatives (int [] [] arr) {
    for (int r = 0;
    r < arr.length; r ++) {
        for (int c = 0;
        c < arr [r].length; c ++) {
            if (arr [r] [c] < 0) {
                arr [r] [c] *= - 1;
            }
        }
    }
    return arr;
}
----------------------------------------
