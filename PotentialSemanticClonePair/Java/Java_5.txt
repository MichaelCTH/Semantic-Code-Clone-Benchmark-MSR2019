$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11740013_11740146_24_36
11740013_11740146_65_75
Title: Fastest way to recreate the ArrayList in a for loop 
----------------------------------------

public void run (int [] data, int initialSize, int n) {
    List < Integer > values = new ArrayList < Integer > ();
    for (int iter = 0;
    iter < n; iter ++) {
        values.clear ();
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.contains (x)) continue;

            values.add (x);
        }
    }
}
----------------------------------------

public void run (int [] data, int initialSize, int n) {
    HashSet < Integer > values = new HashSet < > ((int) Math.ceil (initialSize / loadFactor), loadFactor);
    for (int iter = 0;
    iter < n; iter ++) {
        values.clear ();
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.contains (x)) continue;

            values.add (x);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11740013_11740146_24_36
11740013_11740146_81_91
Title: Fastest way to recreate the ArrayList in a for loop 
----------------------------------------

public void run (int [] data, int initialSize, int n) {
    List < Integer > values = new ArrayList < Integer > ();
    for (int iter = 0;
    iter < n; iter ++) {
        values.clear ();
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.contains (x)) continue;

            values.add (x);
        }
    }
}
----------------------------------------

public void run (int [] data, int distributionSize, int n) {
    BitSet values = new BitSet (distributionSize);
    for (int iter = 0;
    iter < n; iter ++) {
        values.clear ();
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.get (x)) continue;

            values.set (x);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11740013_11740146_42_51
11740013_11740146_65_75
Title: Fastest way to recreate the ArrayList in a for loop 
----------------------------------------

public void run (int [] data, int initialSize, int n) {
    for (int iter = 0;
    iter < n; iter ++) {
        Set < Integer > values = new HashSet < > (initialSize, 1.0f);
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.contains (x)) continue;

            values.add (x);
        }
    }
}
----------------------------------------

public void run (int [] data, int initialSize, int n) {
    HashSet < Integer > values = new HashSet < > ((int) Math.ceil (initialSize / loadFactor), loadFactor);
    for (int iter = 0;
    iter < n; iter ++) {
        values.clear ();
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.contains (x)) continue;

            values.add (x);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11740013_11740146_42_51
11740013_11740146_81_91
Title: Fastest way to recreate the ArrayList in a for loop 
----------------------------------------

public void run (int [] data, int initialSize, int n) {
    for (int iter = 0;
    iter < n; iter ++) {
        Set < Integer > values = new HashSet < > (initialSize, 1.0f);
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.contains (x)) continue;

            values.add (x);
        }
    }
}
----------------------------------------

public void run (int [] data, int distributionSize, int n) {
    BitSet values = new BitSet (distributionSize);
    for (int iter = 0;
    iter < n; iter ++) {
        values.clear ();
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.get (x)) continue;

            values.set (x);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11740013_11740146_65_75
11740013_11740146_81_91
Title: Fastest way to recreate the ArrayList in a for loop 
----------------------------------------

public void run (int [] data, int initialSize, int n) {
    HashSet < Integer > values = new HashSet < > ((int) Math.ceil (initialSize / loadFactor), loadFactor);
    for (int iter = 0;
    iter < n; iter ++) {
        values.clear ();
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.contains (x)) continue;

            values.add (x);
        }
    }
}
----------------------------------------

public void run (int [] data, int distributionSize, int n) {
    BitSet values = new BitSet (distributionSize);
    for (int iter = 0;
    iter < n; iter ++) {
        values.clear ();
        for (int i = 0;
        i < data.length; i ++) {
            int x = data [i];
            if (values.get (x)) continue;

            values.set (x);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11741343_11741791_1_13
11741343_11750487_1_16
Title: A particular type of hash on a String concatenation 
----------------------------------------

public static long hashStringConcatenation (String str1, String str2) {
    int h1 = str1.hashCode ();
    int h2 = str2.hashCode ();
    if (h1 < h2) {
        return ((long) h1) << 32 & h2;
    } else {
        return ((long) h2) << 32 & h1;
    }
}
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    if (str1 == null || str1.isEmpty () || str2 == null || str2.isEmpty ()) {
        return null;
    }
    BigInteger bA, bB;
    String codeA = "", codeB = "";
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA += str1.codePointAt (i);
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB += str2.codePointAt (i);
    }
    bA = new BigInteger (codeA);
    bB = new BigInteger (codeB);
    return bA.add (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11741343_11741791_1_13
11741343_11755810_1_16
Title: A particular type of hash on a String concatenation 
----------------------------------------

public static long hashStringConcatenation (String str1, String str2) {
    int h1 = str1.hashCode ();
    int h2 = str2.hashCode ();
    if (h1 < h2) {
        return ((long) h1) << 32 & h2;
    } else {
        return ((long) h2) << 32 & h1;
    }
}
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    if (str1 == null || str1.isEmpty () || str2 == null || str2.isEmpty ()) {
        return null;
    }
    BigInteger bA, bB;
    String codeA = "", codeB = "";
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA += str1.codePointAt (i);
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB += str2.codePointAt (i);
    }
    bA = new BigInteger (codeA);
    bB = new BigInteger (codeB);
    return bA.add (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11741343_11741791_1_13
11741343_11770791_1_13
Title: A particular type of hash on a String concatenation 
----------------------------------------

public static long hashStringConcatenation (String str1, String str2) {
    int h1 = str1.hashCode ();
    int h2 = str2.hashCode ();
    if (h1 < h2) {
        return ((long) h1) << 32 & h2;
    } else {
        return ((long) h2) << 32 & h1;
    }
}
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    BigInteger bA = BigInteger.ZERO, bB = BigInteger.ZERO;
    StringBuffer codeA = new StringBuffer (), codeB = new StringBuffer ();
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA.append (str1.codePointAt (i));
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB.append (str2.codePointAt (i));
    }
    bA = new BigInteger (codeA.toString ());
    bB = new BigInteger (codeB.toString ());
    return bA.multiply (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11741343_11741791_1_13
11741343_11771596_1_13
Title: A particular type of hash on a String concatenation 
----------------------------------------

public static long hashStringConcatenation (String str1, String str2) {
    int h1 = str1.hashCode ();
    int h2 = str2.hashCode ();
    if (h1 < h2) {
        return ((long) h1) << 32 & h2;
    } else {
        return ((long) h2) << 32 & h1;
    }
}
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    BigInteger bA = BigInteger.ZERO, bB = BigInteger.ZERO;
    StringBuffer codeA = new StringBuffer (), codeB = new StringBuffer ();
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA.append (str1.codePointAt (i)).append ("0");
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB.append (str2.codePointAt (i)).append ("0");
    }
    bA = new BigInteger (codeA.toString ());
    bB = new BigInteger (codeB.toString ());
    return bA.multiply (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11741343_11750487_1_16
11741343_11770791_1_13
Title: A particular type of hash on a String concatenation 
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    if (str1 == null || str1.isEmpty () || str2 == null || str2.isEmpty ()) {
        return null;
    }
    BigInteger bA, bB;
    String codeA = "", codeB = "";
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA += str1.codePointAt (i);
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB += str2.codePointAt (i);
    }
    bA = new BigInteger (codeA);
    bB = new BigInteger (codeB);
    return bA.add (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    BigInteger bA = BigInteger.ZERO, bB = BigInteger.ZERO;
    StringBuffer codeA = new StringBuffer (), codeB = new StringBuffer ();
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA.append (str1.codePointAt (i));
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB.append (str2.codePointAt (i));
    }
    bA = new BigInteger (codeA.toString ());
    bB = new BigInteger (codeB.toString ());
    return bA.multiply (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11741343_11750487_1_16
11741343_11771596_1_13
Title: A particular type of hash on a String concatenation 
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    if (str1 == null || str1.isEmpty () || str2 == null || str2.isEmpty ()) {
        return null;
    }
    BigInteger bA, bB;
    String codeA = "", codeB = "";
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA += str1.codePointAt (i);
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB += str2.codePointAt (i);
    }
    bA = new BigInteger (codeA);
    bB = new BigInteger (codeB);
    return bA.add (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    BigInteger bA = BigInteger.ZERO, bB = BigInteger.ZERO;
    StringBuffer codeA = new StringBuffer (), codeB = new StringBuffer ();
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA.append (str1.codePointAt (i)).append ("0");
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB.append (str2.codePointAt (i)).append ("0");
    }
    bA = new BigInteger (codeA.toString ());
    bB = new BigInteger (codeB.toString ());
    return bA.multiply (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11741343_11755810_1_16
11741343_11770791_1_13
Title: A particular type of hash on a String concatenation 
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    if (str1 == null || str1.isEmpty () || str2 == null || str2.isEmpty ()) {
        return null;
    }
    BigInteger bA, bB;
    String codeA = "", codeB = "";
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA += str1.codePointAt (i);
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB += str2.codePointAt (i);
    }
    bA = new BigInteger (codeA);
    bB = new BigInteger (codeB);
    return bA.add (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    BigInteger bA = BigInteger.ZERO, bB = BigInteger.ZERO;
    StringBuffer codeA = new StringBuffer (), codeB = new StringBuffer ();
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA.append (str1.codePointAt (i));
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB.append (str2.codePointAt (i));
    }
    bA = new BigInteger (codeA.toString ());
    bB = new BigInteger (codeB.toString ());
    return bA.multiply (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11741343_11755810_1_16
11741343_11771596_1_13
Title: A particular type of hash on a String concatenation 
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    if (str1 == null || str1.isEmpty () || str2 == null || str2.isEmpty ()) {
        return null;
    }
    BigInteger bA, bB;
    String codeA = "", codeB = "";
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA += str1.codePointAt (i);
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB += str2.codePointAt (i);
    }
    bA = new BigInteger (codeA);
    bB = new BigInteger (codeB);
    return bA.add (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------

public static BigInteger hashStringConcatenation (String str1, String str2) {
    BigInteger bA = BigInteger.ZERO, bB = BigInteger.ZERO;
    StringBuffer codeA = new StringBuffer (), codeB = new StringBuffer ();
    for (int i = 0;
    i < str1.length (); i ++) {
        codeA.append (str1.codePointAt (i)).append ("0");
    }
    for (int i = 0;
    i < str2.length (); i ++) {
        codeB.append (str2.codePointAt (i)).append ("0");
    }
    bA = new BigInteger (codeA.toString ());
    bB = new BigInteger (codeB.toString ());
    return bA.multiply (bB).mod (BigInteger.valueOf (2).pow (1024));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11745301_11745338_1_15
11745301_11745415_1_12
Title: Why can't I cast an object inside of an if statement? 
----------------------------------------

public int compareTo (Object o) {
    if (this.order < ((Category) o).order) {
        return - 1;
    } else if (this.order > ((Category) o).order) {
        return 1;
    } else {
        return 0;
    }

}
----------------------------------------

public int compareTo (Object o) {
    if (this.order < ((Category) o).order) {
        return - 1;
    }
    if (this.order > ((Category) o).order) {
        return 1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11754660_11754734_2_13
11754660_11754799_2_17
Title: Unable to run Thread programme 
----------------------------------------

public void run () {
    int val = 65;
    try {
        for (int i = 0;
        i < 26; i ++) {
            System.out.println ((char) val);
            val ++;
            sleep (500);
        }
    } catch (InterruptedException e) {
        System.out.println (e);
    }
}
----------------------------------------

public void run () {
    int val = 65;
    try {
        for (int i = 0;
        i < 26; i ++) {
            System.out.println ((char) val);
            val ++;
            sleep (500);
        }
    } catch (InterruptedException e) {
        System.out.println (e);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
117690_118158_4_39
117690_423759_29_62
Title: Wait until any of Future<T> is done 
----------------------------------------

public static void main (String [] args) {
    Lock lock = new Lock ();
    Worker worker1 = new Worker (lock, "worker1", 15000);
    Worker worker2 = new Worker (lock, "worker2", 10000);
    Worker worker3 = new Worker (lock, "worker3", 5000);
    Worker worker4 = new Worker (lock, "worker4", 20000);
    boolean started = false;
    int numNotifies = 0;
    while (true) {
        synchronized (lock) {
            try {
                if (! started) {
                    worker1.start ();
                    worker2.start ();
                    worker3.start ();
                    worker4.start ();
                    started = true;
                }
                lock.wait ();
            } catch (InterruptedException e) {
                break;
            }
            numNotifies ++;
            if (numNotifies == 4) {
                break;
            }
            System.out.println ("Notified!");
        }
    }
    System.out.println ("Everyone has notified me... I'm done");
}
----------------------------------------

static public void main (String [] args) throws InterruptedException, ExecutionException {
    final List < Integer > integers = new ArrayList < Integer > ();
    for (int i = 0;
    i < POOL_SIZE; i ++) {
        integers.add (i);
    }
    (new Thread () {
        public void run () {
            Integer notified = null;
            try {
                notified = waitForAny (integers);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            } catch (ExecutionException e) {
                e.printStackTrace ();
            }
            System.out.println ("notified=" + notified);
        }}

    ).start ();
    synchronized (integers) {
        integers.wait (3000);
    }
    Integer randomInt = integers.get ((new Random ()).nextInt (POOL_SIZE));
    System.out.println ("Waking up " + randomInt);
    synchronized (randomInt) {
        randomInt.notify ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11777230_11777324_1_21
11777230_11777342_1_82
Title: Java application terminates at getOutputStream() 
----------------------------------------

public void postData () {
    HttpClient httpclient = new DefaultHttpClient ();
    HttpPost httppost = new HttpPost ("http://www.yoursite.com/script.php");
    try {
        List < NameValuePair > nameValuePairs = new ArrayList < NameValuePair > (2);
        nameValuePairs.add (new BasicNameValuePair ("id", "12345"));
        nameValuePairs.add (new BasicNameValuePair ("stringdata", "AndDev is Cool!"));
        httppost.setEntity (new UrlEncodedFormEntity (nameValuePairs));
        HttpResponse response = httpclient.execute (httppost);
    } catch (ClientProtocolException e) {
    } catch (IOException e) {
    }
}
----------------------------------------

public String postData (String url, String xmlQuery) {
    final String urlStr = url;
    final String xmlStr = xmlQuery;
    final StringBuilder sb = new StringBuilder ();
    Thread t1 = new Thread (new Runnable () {
        public void run () {
            HttpClient httpclient = new DefaultHttpClient ();
            HttpPost httppost = new HttpPost (urlStr);
            try {
                List < NameValuePair > nameValuePairs = new ArrayList < NameValuePair > (1);
                nameValuePairs.add (new BasicNameValuePair ("xml", xmlStr));
                httppost.setEntity (new UrlEncodedFormEntity (nameValuePairs));
                HttpResponse response = httpclient.execute (httppost);
                Log.d ("Vivek", response.toString ());
                HttpEntity entity = response.getEntity ();
                InputStream i = entity.getContent ();
                Log.d ("Vivek", i.toString ());
                InputStreamReader isr = new InputStreamReader (i);
                BufferedReader br = new BufferedReader (isr);
                String s = null;
                while ((s = br.readLine ()) != null) {
                    Log.d ("YumZing", s);
                    sb.append (s);
                }
                Log.d ("Check Now", sb + "");
            } catch (ClientProtocolException e) {
                e.printStackTrace ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }}

    );
    t1.start ();
    try {
        t1.join ();
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    System.out.println ("Getting from Post Data Method " + sb.toString ());
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1178093_1178315_1_12
1178093_1178347_1_28
Title: java graphics - a shape with two colours 
----------------------------------------

public void paint (Graphics g) {
    super.paint (g);
    Graphics2D g2d = (Graphics2D) g.create ();
    g2d.setColor (Color.RED);
    g2d.fillOval (10, 10, 200, 100);
    g2d.setColor (Color.GREEN);
    g2d.setClip (10, 10, 200, 50);
    g2d.fillOval (10, 10, 200, 100);
}
----------------------------------------

public void paint (Graphics graphics) {
    super.paint (graphics);
    Rectangle originalClipBounds = graphics.getClipBounds ();
    try {
        graphics.clipRect (100, 100, 100, 25);
        graphics.setColor (Color.RED);
        graphics.fillOval (100, 100, 100, 100);
    } finally {
        graphics.setClip (originalClipBounds);
    }
    try {
        graphics.clipRect (100, 125, 100, 75);
        graphics.setColor (Color.BLUE);
        graphics.fillOval (100, 100, 100, 100);
    } finally {
        graphics.setClip (originalClipBounds);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11792534_11792803_1_10
11792534_11793011_24_28
Title: how to edit my compare method 
----------------------------------------

private static void write (ArrayList < String > out, String fname) throws IOException {
    FileWriter writer = new FileWriter (new File ("D:\\Denemeler\\deneme3.txt"));
    for (int i = 0;
    i < out.size (); i ++) {
        writer.write (out.get (i) + "\n");
    }
    writer.flush ();
    writer.close ();
}
----------------------------------------

private static void write (Collection < String > out, String fname) throws IOException {
    FileWriter writer = new FileWriter (new File (fname));
    try {
        for (String s : out) writer.write (s + "\n");

    } finally {
        writer.close ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1180110_12584054_23_58
1180110_47361403_1_22
Title: Apache POI xls column Remove 
----------------------------------------

public static void deleteColumn (Sheet sheet, int columnToDelete) {
    int maxColumn = 0;
    for (int r = 0;
    r < sheet.getLastRowNum () + 1; r ++) {
        Row row = sheet.getRow (r);
        if (row == null) continue;

        int lastColumn = row.getLastCellNum ();
        if (lastColumn > maxColumn) maxColumn = lastColumn;

        if (lastColumn < columnToDelete) continue;

        for (int x = columnToDelete + 1;
        x < lastColumn + 1; x ++) {
            Cell oldCell = row.getCell (x - 1);
            if (oldCell != null) row.removeCell (oldCell);

            Cell nextCell = row.getCell (x);
            if (nextCell != null) {
                Cell newCell = row.createCell (x - 1, nextCell.getCellType ());
                cloneCell (newCell, nextCell);
            }
        }
    }
    for (int c = 0;
    c < maxColumn; c ++) {
        sheet.setColumnWidth (c, sheet.getColumnWidth (c + 1));
    }
}
----------------------------------------

private void deleteColumn (Sheet sheet, int columnToDelete) {
    for (int rId = 0;
    rId < sheet.getLastRowNum (); rId ++) {
        Row row = sheet.getRow (rId);
        for (int cID = columnToDelete;
        cID < row.getLastCellNum (); cID ++) {
            Cell cOld = row.getCell (cID);
            if (cOld != null) {
                row.removeCell (cOld);
            }
            Cell cNext = row.getCell (cID + 1);
            if (cNext != null) {
                Cell cNew = row.createCell (cID, cNext.getCellTypeEnum ());
                cloneCell (cNew, cNext);
                if (rId == 0) {
                    sheet.setColumnWidth (cID, sheet.getColumnWidth (cID + 1));
                }
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1180110_12584054_65_92
1180110_43682208_1_28
Title: Apache POI xls column Remove 
----------------------------------------

private static void cloneCell (Cell cNew, Cell cOld) {
    cNew.setCellComment (cOld.getCellComment ());
    cNew.setCellStyle (cOld.getCellStyle ());
    switch (cNew.getCellType ()) {
        case Cell.CELL_TYPE_BOOLEAN :
            {
                cNew.setCellValue (cOld.getBooleanCellValue ());
                break;
            } case Cell.CELL_TYPE_NUMERIC :
            {
                cNew.setCellValue (cOld.getNumericCellValue ());
                break;
            } case Cell.CELL_TYPE_STRING :
            {
                cNew.setCellValue (cOld.getStringCellValue ());
                break;
            } case Cell.CELL_TYPE_ERROR :
            {
                cNew.setCellValue (cOld.getErrorCellValue ());
                break;
            } case Cell.CELL_TYPE_FORMULA :
            {
                cNew.setCellFormula (cOld.getCellFormula ());
                break;
            }}
}
----------------------------------------

private static void cloneCell (Cell cNew, Cell cOld) {
    cNew.setCellComment (cOld.getCellComment ());
    cNew.setCellStyle (cOld.getCellStyle ());
    switch (cNew.getCellType ()) {
        case Cell.CELL_TYPE_BOOLEAN :
            {
                cNew.setCellValue (cOld.getBooleanCellValue ());
                break;
            } case Cell.CELL_TYPE_NUMERIC :
            {
                cNew.setCellValue (cOld.getNumericCellValue ());
                break;
            } case Cell.CELL_TYPE_STRING :
            {
                cNew.setCellValue (cOld.getStringCellValue ());
                break;
            } case Cell.CELL_TYPE_ERROR :
            {
                cNew.setCellValue (cOld.getErrorCellValue ());
                break;
            } case Cell.CELL_TYPE_FORMULA :
            {
                cNew.setCellFormula (cOld.getCellFormula ());
                break;
            }}
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1180110_12584054_65_92
1180110_47361403_24_39
Title: Apache POI xls column Remove 
----------------------------------------

private static void cloneCell (Cell cNew, Cell cOld) {
    cNew.setCellComment (cOld.getCellComment ());
    cNew.setCellStyle (cOld.getCellStyle ());
    switch (cNew.getCellType ()) {
        case Cell.CELL_TYPE_BOOLEAN :
            {
                cNew.setCellValue (cOld.getBooleanCellValue ());
                break;
            } case Cell.CELL_TYPE_NUMERIC :
            {
                cNew.setCellValue (cOld.getNumericCellValue ());
                break;
            } case Cell.CELL_TYPE_STRING :
            {
                cNew.setCellValue (cOld.getStringCellValue ());
                break;
            } case Cell.CELL_TYPE_ERROR :
            {
                cNew.setCellValue (cOld.getErrorCellValue ());
                break;
            } case Cell.CELL_TYPE_FORMULA :
            {
                cNew.setCellFormula (cOld.getCellFormula ());
                break;
            }}
}
----------------------------------------

private void cloneCell (Cell cNew, Cell cOld) {
    cNew.setCellComment (cOld.getCellComment ());
    cNew.setCellStyle (cOld.getCellStyle ());
    if (CellType.BOOLEAN == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getBooleanCellValue ());
    } else if (CellType.NUMERIC == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getNumericCellValue ());
    } else if (CellType.STRING == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getStringCellValue ());
    } else if (CellType.ERROR == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getErrorCellValue ());
    } else if (CellType.FORMULA == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getCellFormula ());
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1180110_43682208_1_28
1180110_47361403_24_39
Title: Apache POI xls column Remove 
----------------------------------------

private static void cloneCell (Cell cNew, Cell cOld) {
    cNew.setCellComment (cOld.getCellComment ());
    cNew.setCellStyle (cOld.getCellStyle ());
    switch (cNew.getCellType ()) {
        case Cell.CELL_TYPE_BOOLEAN :
            {
                cNew.setCellValue (cOld.getBooleanCellValue ());
                break;
            } case Cell.CELL_TYPE_NUMERIC :
            {
                cNew.setCellValue (cOld.getNumericCellValue ());
                break;
            } case Cell.CELL_TYPE_STRING :
            {
                cNew.setCellValue (cOld.getStringCellValue ());
                break;
            } case Cell.CELL_TYPE_ERROR :
            {
                cNew.setCellValue (cOld.getErrorCellValue ());
                break;
            } case Cell.CELL_TYPE_FORMULA :
            {
                cNew.setCellFormula (cOld.getCellFormula ());
                break;
            }}
}
----------------------------------------

private void cloneCell (Cell cNew, Cell cOld) {
    cNew.setCellComment (cOld.getCellComment ());
    cNew.setCellStyle (cOld.getCellStyle ());
    if (CellType.BOOLEAN == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getBooleanCellValue ());
    } else if (CellType.NUMERIC == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getNumericCellValue ());
    } else if (CellType.STRING == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getStringCellValue ());
    } else if (CellType.ERROR == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getErrorCellValue ());
    } else if (CellType.FORMULA == cNew.getCellTypeEnum ()) {
        cNew.setCellValue (cOld.getCellFormula ());
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11804733_11804763_2_13
11804733_19839590_36_45
Title: Java get String CompareTo as a comparator object 
----------------------------------------

public int compare (String obj1, String obj2) {
    if (obj1 == obj2) {
        return 0;
    }
    if (obj1 == null) {
        return - 1;
    }
    if (obj2 == null) {
        return 1;
    }
    return obj1.compareTo (obj2);
}
----------------------------------------

public int compare (E o1, E o2) {
    if (o1 == o2) return 0;

    if (o1 == null) return 1;

    if (o2 == null) return - 1;

    return o1.compareTo (o2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11806376_11807464_26_42
11806376_11807464_5_23
Title: checking for the correct number of characters in a java string 
----------------------------------------

public int count (String hand) {
    char [] delims = {'/', ' ', '-'};
    int result = 0;
    for (char delim : delims) {
        for (int i = 0;
        i < hand.length (); i ++) {
            if (hand.charAt (i) == delim) {
                ++ result;
            }
        }
    }
    if (result == 0) {
        throw new RuntimeException ("Incorrect format!");
    }
    return result;
}
----------------------------------------

public int count (String hand) {
    String [] cards = hand.split (hand);
    if (hand.contains ("/")) {
        cards = hand.split ("/");
    } else if (hand.contains ("-")) {
        cards = hand.split ("-");
    } else if (hand.contains (" ")) {
        cards = hand.split (" ");
    } else {
        throw new RuntimeException ("Incorrect format!");
    }

    if (hand.endsWith ("-") || hand.endsWith ("/") || hand.endsWith (" ")) {
        return cards.length;
    }
    return cards.length - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11806523_11806540_5_19
11806523_31659019_5_18
Title: How to get host name based on IP address? 
----------------------------------------

public static void main (String args []) {
    try {
        InetAddress host;
        if (args.length == 0) {
            host = InetAddress.getLocalHost ();
        } else {
            host = InetAddress.getByName (args [0]);
        }
        System.out.println ("Host:'" + host.getHostName () + "' has address: " + host.getHostAddress ());
    } catch (UnknownHostException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        InetAddress inetAddr = InetAddress.getByName ("163.53.76.55");
        String hostname = inetAddr.getHostName ();
        String canonicalHostname = inetAddr.getCanonicalHostName ();
        System.out.println ("Hostname: " + hostname);
        System.out.println ("Canonical Hostname: " + canonicalHostname);
    } catch (UnknownHostException e) {
        System.out.println ("Host not found: " + e.getMessage ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11806711_11825432_1_32
11806711_28631244_1_24
Title: How to Set Image height and width in j2me(java) 
----------------------------------------

public Image resizeImage (Image src, int screenHeight, int screenWidth) {
    int srcWidth = src.getWidth ();
    int srcHeight = src.getHeight ();
    Image tmp = Image.createImage (screenWidth, srcHeight);
    Graphics g = tmp.getGraphics ();
    int ratio = (srcWidth << 16) / screenWidth;
    int pos = ratio / 2;
    for (int index = 0;
    index < screenWidth; index ++) {
        g.setClip (index, 0, 1, srcHeight);
        g.drawImage (src, index - (pos>> 16), 0);
        pos += ratio;
    }
    Image resizedImage = Image.createImage (screenWidth, screenHeight);
    g = resizedImage.getGraphics ();
    ratio = (srcHeight << 16) / screenHeight;
    pos = ratio / 2;
    for (int index = 0;
    index < screenHeight; index ++) {
        g.setClip (0, index, screenWidth, 1);
        g.drawImage (tmp, 0, index - (pos>> 16));
        pos += ratio;
    }
    return resizedImage;
}
----------------------------------------

protected static Image resizeImage (Image image, int resizedWidth, int resizedHeight) {
    int width = image.getWidth ();
    int height = image.getHeight ();
    int [] in = new int [width];
    int [] out = new int [resizedWidth * resizedHeight];
    int dy, dx;
    for (int y = 0;
    y < resizedHeight; y ++) {
        dy = y * height / resizedHeight;
        image.getRGB (in, 0, width, 0, dy, width, 1);
        for (int x = 0;
        x < resizedWidth; x ++) {
            dx = x * width / resizedWidth;
            out [(resizedWidth * y) + x] = in [dx];
        }
    }
    return Image.createRGBImage (out, resizedWidth, resizedHeight, true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11808815_18458792_18_26
11808815_29159228_10_27
Title: How to get the the single images of an mp4-Movie in Java 
----------------------------------------

public static void main (String [] args) throws IOException, JCodecException {
    long time = System.currentTimeMillis ();
    for (int i = 50;
    i < 57; i ++) {
        BufferedImage frame = FrameGrab.getFrame (new File ("/Users/jovi/Movies/test.mp4"), i);
        ImageIO.write (frame, "bmp", new File ("/Users/jovi/Desktop/frames/frame_" + i + ".bmp"));
    }
    System.out.println ("Time Used:" + (System.currentTimeMillis () - time) + " Milliseconds");
}
----------------------------------------

public static void main (String [] args) throws IOException, Exception {
    FFmpegFrameGrabber frameGrabber = new FFmpegFrameGrabber ("C:/Users/Digilog/Downloads/Test.mp4");
    frameGrabber.start ();
    IplImage i;
    try {
        i = frameGrabber.grab ();
        BufferedImage bi = i.getBufferedImage ();
        ImageIO.write (bi, "png", new File ("D:/Img.png"));
        frameGrabber.stop ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11809547_11809626_3_17
11809547_11809748_2_14
Title: JButton not working [capture network traffic] 
----------------------------------------

public void actionPerformed (ActionEvent Event) {
    class Print implements PacketReceiver {
        public void receivePacket (Packet packet) {
            String info = packet.toString ();
            textarea.append (info);
        }}

    final Print myPrint = new Print ();
}
----------------------------------------

public void actionPerformed (ActionEvent Event) {
    class Print implements PacketReceiver {
        public void receivePacket (Packet packet) {
            String info = packet.toString ();
            textarea.append (info);
        }}

    JPCAP.processPacket (10, new Print ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11822552_11822570_36_46
11822552_11822598_2_34
Title: Chaining in HashMap 
----------------------------------------

public static void main (String [] args) {
    Map < StringKey, String > map = new HashMap < StringKey, String > ();
    StringKey key1 = new StringKey ("a");
    StringKey key2 = new StringKey ("b");
    map.put (key1, "s");
    map.put (key2, "v");
    System.out.println (map.get (key1));
    System.out.println (key1.hashCode () + " " + key2.hashCode () + " " + key1.equals (key2));
}
----------------------------------------

public static void main (String...args) {
    Multimap < String, String > myMultimap = ArrayListMultimap.create ();
    myMultimap.put ("Fruits", "Bannana");
    myMultimap.put ("Fruits", "Apple");
    myMultimap.put ("Fruits", "Pear");
    myMultimap.put ("Vegetables", "Carrot");
    int size = myMultimap.size ();
    System.out.println (size);
    Collection < string > fruits = myMultimap.get ("Fruits");
    System.out.println (fruits);
    Collection < string > vegetables = myMultimap.get ("Vegetables");
    System.out.println (vegetables);
    for (String value : myMultimap.values ()) {
        System.out.println (value);
    }
    myMultimap.remove ("Fruits", "Pear");
    System.out.println (myMultimap.get ("Fruits"));
    myMultimap.removeAll ("Fruits");
    System.out.println (myMultimap.get ("Fruits"));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11822552_11822570_36_46
11822552_11822602_1_14
Title: Chaining in HashMap 
----------------------------------------

public static void main (String [] args) {
    Map < StringKey, String > map = new HashMap < StringKey, String > ();
    StringKey key1 = new StringKey ("a");
    StringKey key2 = new StringKey ("b");
    map.put (key1, "s");
    map.put (key2, "v");
    System.out.println (map.get (key1));
    System.out.println (key1.hashCode () + " " + key2.hashCode () + " " + key1.equals (key2));
}
----------------------------------------

public static void main (String [] args) {
    HashMap < String, ArrayList < String > > map = new HashMap < String, ArrayList < String > > ();
    if (map.get ("a") == null) {
        map.put ("a", new ArrayList < String > ());
    }
    ArrayList < String > innerList = map.get ("a");
    innerList.add ("s");
    innerList.add ("v");
    map.put ("a", innerList);
    System.out.println (map.get ("a"));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11822552_11822598_2_34
11822552_11822602_1_14
Title: Chaining in HashMap 
----------------------------------------

public static void main (String...args) {
    Multimap < String, String > myMultimap = ArrayListMultimap.create ();
    myMultimap.put ("Fruits", "Bannana");
    myMultimap.put ("Fruits", "Apple");
    myMultimap.put ("Fruits", "Pear");
    myMultimap.put ("Vegetables", "Carrot");
    int size = myMultimap.size ();
    System.out.println (size);
    Collection < string > fruits = myMultimap.get ("Fruits");
    System.out.println (fruits);
    Collection < string > vegetables = myMultimap.get ("Vegetables");
    System.out.println (vegetables);
    for (String value : myMultimap.values ()) {
        System.out.println (value);
    }
    myMultimap.remove ("Fruits", "Pear");
    System.out.println (myMultimap.get ("Fruits"));
    myMultimap.removeAll ("Fruits");
    System.out.println (myMultimap.get ("Fruits"));
}
----------------------------------------

public static void main (String [] args) {
    HashMap < String, ArrayList < String > > map = new HashMap < String, ArrayList < String > > ();
    if (map.get ("a") == null) {
        map.put ("a", new ArrayList < String > ());
    }
    ArrayList < String > innerList = map.get ("a");
    innerList.add ("s");
    innerList.add ("v");
    map.put ("a", innerList);
    System.out.println (map.get ("a"));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11841789_11853270_1_13
11841789_38122991_1_11
Title: Children of org.eclipse.jdt.core.dom.ASTNode 
----------------------------------------

public Object [] getChildren (ASTNode node) {
    List list = node.structuralPropertiesForType ();
    for (int i = 0;
    i < list.size (); i ++) {
        StructuralPropertyDescriptor curr = (StructuralPropertyDescriptor) list.get (i);
        Object child = node.getStructuralProperty (curr);
        if (child instanceof List) {
            return ((List) child).toArray ();
        } else if (child instanceof ASTNode) {
            return new Object [] {child};
        }

        return new Object [0];
    }
}
----------------------------------------

public static List < ASTNode > getChildren (ASTNode node) {
    List < ASTNode > children = new ArrayList < ASTNode > ();
    List list = node.structuralPropertiesForType ();
    for (int i = 0;
    i < list.size (); i ++) {
        Object child = node.getStructuralProperty ((StructuralPropertyDescriptor) list.get (i));
        if (child instanceof ASTNode) {
            children.add ((ASTNode) child);
        }
    }
    return children;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_11843100_1_9
11842984_36694779_7_47
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int unsortedArray [] = {0, 0, 0, 1, 3, 3, 2, 1, 3, 5, 6, 0};
    System.out.println ("After sorting, the list elements are: ");
    bubbleSoprt (unsortedArray, unsortedArray.length);
    for (int i = 0;
    i < unsortedArray.length; i ++) {
        System.out.print (unsortedArray [i] + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [] {5, 2, 8, 8, 5, 5, 8, 1, 9, 0, 1, 1, 0, 1};
    Map < Integer, Integer > numbers = new HashMap < > ();
    for (int number : ar) {
        if (numbers.containsKey (number)) {
            Integer count = numbers.get (number);
            numbers.put (number, ++ count);
        } else {
            numbers.put (number, 1);
        }
    }
    final class FrequencyComparator implements Comparator < Integer > {
        Map < Integer, Integer > refMap;
        public FrequencyComparator (Map < Integer, Integer > base) {
            this.refMap = base;
        }@Override
        public int compare (Integer k1, Integer k2) {
            Integer val1 = refMap.get (k1);
            Integer val2 = refMap.get (k2);
            int num = val1.compareTo (val2);
            return num == 0 ? k1.compareTo (k2) : num;
        }}

    FrequencyComparator comp = new FrequencyComparator (numbers);
    TreeMap < Integer, Integer > sortedMap = new TreeMap < Integer, Integer > (comp);
    sortedMap.putAll (numbers);
    for (Integer i : sortedMap.keySet ()) {
        int frequencey = sortedMap.get (i);
        for (int count = 1;
        count <= frequencey; count ++) {
            System.out.print (i + " ");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_11843100_1_9
11842984_40938382_15_60
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int unsortedArray [] = {0, 0, 0, 1, 3, 3, 2, 1, 3, 5, 6, 0};
    System.out.println ("After sorting, the list elements are: ");
    bubbleSoprt (unsortedArray, unsortedArray.length);
    for (int i = 0;
    i < unsortedArray.length; i ++) {
        System.out.print (unsortedArray [i] + " ");
    }
}
----------------------------------------

public static void main (String args []) throws Exception {
    int i, j, temp, temp1, count;
    int [] a = new int [10];
    int [] freq = new int [10];
    Scanner s = new Scanner (System.in);
    for (i = 0; i < 5; i ++) {
        a [i] = s.nextInt ();
        freq [i] = - 1;
    }
    for (i = 0; i < 5; i ++) {
        count = 1;
        for (j = i + 1; j < 5; j ++) {
            if (a [i] == a [j]) {
                count ++;
                freq [j] = 0;
            }
        }
        if (freq [i] != 0) {
            freq [i] = count;
        }
    }
    Map map = new HashMap ();
    for (i = 0; i < 5; i ++) {
        if (freq [i] != 0) {
            map.put (a [i], freq [i]);
            System.out.println ("map elt" + map);
            System.out.println ("a" + a [i] + "fr" + freq [i]);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    List < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Map.Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " ==== " + entry.getValue ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_11843100_1_9
11842984_41378487_10_34
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int unsortedArray [] = {0, 0, 0, 1, 3, 3, 2, 1, 3, 5, 6, 0};
    System.out.println ("After sorting, the list elements are: ");
    bubbleSoprt (unsortedArray, unsortedArray.length);
    for (int i = 0;
    i < unsortedArray.length; i ++) {
        System.out.print (unsortedArray [i] + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    int array [] = {5, 2, 8, 8, 5, 5, 8, 1, 1, 2};
    HashMap < Integer, Integer > data = new HashMap < Integer, Integer > ();
    for (int i = 0;
    i < array.length; i ++) {
        if (data.containsKey (array [i])) {
            Integer count = data.get (array [i]) + 1;
            data.put (array [i], count);
        } else {
            data.put (array [i], 1);
        }
    }
    Set < Entry < Integer, Integer > > set = data.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " <-> " + entry.getValue ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_11843100_1_9
11842984_44746334_12_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int unsortedArray [] = {0, 0, 0, 1, 3, 3, 2, 1, 3, 5, 6, 0};
    System.out.println ("After sorting, the list elements are: ");
    bubbleSoprt (unsortedArray, unsortedArray.length);
    for (int i = 0;
    i < unsortedArray.length; i ++) {
        System.out.print (unsortedArray [i] + " ");
    }
}
----------------------------------------

public static void main (String args []) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > map = new HashMap < Integer, Integer > ();
    int len = arr.length;
    for (int j = 0;
    j < len; j ++) {
        if (map.get (arr [j]) == null) {
            map.put (arr [j], 1);
        } else {
            map.put (arr [j], (Integer) map.get (arr [j]) + 1);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    list.sort (new Comparator < Entry < Integer, Integer > > () {
        @Override
        public int compare (Entry < Integer, Integer > o1, Entry < Integer, Integer > o2) {
            if (o1.getValue () < o2.getValue ()) {
                return 1;
            } else if (o1.getValue () > o2.getValue ()) {
                return - 1;
            } else if (o1.getValue () == o2.getValue ()) {
                if (o1.getKey () < o2.getKey ()) {
                    return 1;
                } else {
                    return - 1;
                }
            }

            return 0;
        }}

    );
    for (Map.Entry < Integer, Integer > en : list) {
        int val = en.getValue ();
        while (val != 0) {
            System.out.println (en.getKey ());
            val --;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_11843100_1_9
11842984_51862367_5_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int unsortedArray [] = {0, 0, 0, 1, 3, 3, 2, 1, 3, 5, 6, 0};
    System.out.println ("After sorting, the list elements are: ");
    bubbleSoprt (unsortedArray, unsortedArray.length);
    for (int i = 0;
    i < unsortedArray.length; i ++) {
        System.out.print (unsortedArray [i] + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    int arrTemp [] = {2, 2, 2, 1, 1, 4, 5, 6, 6, 7, 7, 7, 7};
    Arrays.sort (arrTemp);
    Integer [] [] sortedArray = new Integer [6] [2];
    int count = 0;
    sortedArray [count] [0] = arrTemp [0];
    sortedArray [count] [1] = 1;
    for (int i = 0;
    i < arrTemp.length - 1; i ++) {
        for (int j = 1;
        j < arrTemp.length; j ++) {
            if (arrTemp [i] == arrTemp [j]) {
                sortedArray [count] [1] = sortedArray [count] [1] + 1;
                i = j;
            } else {
                ++ count;
                sortedArray [count] [0] = arrTemp [j];
                sortedArray [count] [1] = 1;
                i = j;
            }
        }
    }
    Arrays.sort (sortedArray, new Comparator < Integer [] > () {
        @Override
        public int compare (Integer [] o1, Integer [] o2) {
            return o1 [1].compareTo (o2 [1]);
        }}

    );
    for (int row = 0;
    row < 6; row ++) {
        for (int col = 0;
        col < sortedArray [row] [1]; col ++) {
            System.out.print (sortedArray [row] [0] + " ");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_11843100_1_9
11842984_52580911_3_42
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int unsortedArray [] = {0, 0, 0, 1, 3, 3, 2, 1, 3, 5, 6, 0};
    System.out.println ("After sorting, the list elements are: ");
    bubbleSoprt (unsortedArray, unsortedArray.length);
    for (int i = 0;
    i < unsortedArray.length; i ++) {
        System.out.print (unsortedArray [i] + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    int r;
    int b [] = {1, 1, 1, 2, 1, 2, 3, 6, 6, 5};
    int i;
    int n = b.length;
    int k = 0;
    Arrays.sort (b);
    int [] a = new int [n + 1];
    for (r = 0; r < n; r ++) {
        a [r] = b [r];
    }
    a [r] = 1882737378;
    int c = 1;
    int in [] = new int [10];
    int [] e = new int [10];
    for (i = 0; i < n; i ++) {
        if (a [i] == a [i + 1]) c ++;
        else {
            e [k] = a [i];
            in [k] = c;
            k ++;
            c = 1;
        }
    }
    for (int f = 0;
    f < k; f ++) {
        for (int g = 0;
        g < k - f - 1; g ++) {
            if (in [g] > in [g + 1]) {
                int [] ans = swap (in [g], in [g + 1]);
                in [g] = ans [0];
                in [g + 1] = ans [1];
                int [] an = swap (e [g], e [g + 1]);
                e [g] = an [0];
                e [g + 1] = an [1];
            }
        }
    }
    int d = 0;
    for (int x = 0;
    x < k; x ++) {
        for (int y = 0;
        y < in [x]; y ++) {
            System.out.print (e [d]);
        }
        d ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_11843100_1_9
11842984_53325860_4_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int unsortedArray [] = {0, 0, 0, 1, 3, 3, 2, 1, 3, 5, 6, 0};
    System.out.println ("After sorting, the list elements are: ");
    bubbleSoprt (unsortedArray, unsortedArray.length);
    for (int i = 0;
    i < unsortedArray.length; i ++) {
        System.out.print (unsortedArray [i] + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    Integer [] nums = {7, 3, 4, 3, 4, 3, 4, 3, 6, 5, 7};
    Map < Integer, Integer > m1;
    ArrayList < Integer > numbers = new ArrayList < Integer > (Arrays.asList (nums));
    List < Integer > values = new ArrayList < Integer > ();
    List < Integer > output = new ArrayList < Integer > ();
    m1 = new LinkedHashMap < Integer, Integer > ();
    for (int a : numbers) {
        if (m1.containsKey (a)) {
            int value = m1.get (a);
            m1.put (a, ++ value);
        } else {
            m1.put (a, 1);
        }
    }
    System.out.println (m1);
    for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
        values.add (entry.getValue ());
    }
    Collections.sort (values, Collections.reverseOrder ());
    System.out.println (values.toString ());
    for (int m = 0;
    m < values.size (); m ++) {
        for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
            if (entry.getValue ().equals (values.get (m))) {
                key = entry.getKey ();
                System.out.println ("Key is" + key);
                for (int k = values.get (m);
                k > 0; k --) {
                    output.add (key);
                }
                break;
            }
        }
        m1.remove (key);
    }
    System.out.println (output.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_11843100_1_9
11842984_53497463_1_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int unsortedArray [] = {0, 0, 0, 1, 3, 3, 2, 1, 3, 5, 6, 0};
    System.out.println ("After sorting, the list elements are: ");
    bubbleSoprt (unsortedArray, unsortedArray.length);
    for (int i = 0;
    i < unsortedArray.length; i ++) {
        System.out.print (unsortedArray [i] + " ");
    }
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > mp = new LinkedHashMap < > ();
    List < Integer > res = new ArrayList < > ();
    int count = 1;
    for (int i = 0;
    i < arr.length; i ++) {
        if (! mp.containsKey (arr [i])) {
            mp.put (arr [i], count);
        } else {
            mp.put (arr [i], mp.get (arr [i]) + 1);
        }
    }
    if (! mp.containsValue (2)) {
        for (Integer ab : arr) res.add (ab);

        Collections.sort (res);
        Collections.reverse (res);
        System.out.println (res);
    } else {
        Set < Entry < Integer, Integer > > set = mp.entrySet ();
        List < Entry < Integer, Integer > > list = new ArrayList < > (set);
        Collections.sort (list, new Comparator < Entry < Integer, Integer > > () {
            @Override
            public int compare (Entry < Integer, Integer > obj1, Entry < Integer, Integer > obj2) {
                if (obj2.getValue () > obj1.getValue ()) return 1;

                if (obj2.getValue () < obj1.getValue ()) return - 1;
                else return 0;

            }}

        );
        for (Map.Entry < Integer, Integer > e : list) {
            for (int i = 1;
            i <= e.getValue (); i ++) res.add (e.getKey ());

        }
        System.out.println (res);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_36694779_7_47
11842984_40938382_15_60
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [] {5, 2, 8, 8, 5, 5, 8, 1, 9, 0, 1, 1, 0, 1};
    Map < Integer, Integer > numbers = new HashMap < > ();
    for (int number : ar) {
        if (numbers.containsKey (number)) {
            Integer count = numbers.get (number);
            numbers.put (number, ++ count);
        } else {
            numbers.put (number, 1);
        }
    }
    final class FrequencyComparator implements Comparator < Integer > {
        Map < Integer, Integer > refMap;
        public FrequencyComparator (Map < Integer, Integer > base) {
            this.refMap = base;
        }@Override
        public int compare (Integer k1, Integer k2) {
            Integer val1 = refMap.get (k1);
            Integer val2 = refMap.get (k2);
            int num = val1.compareTo (val2);
            return num == 0 ? k1.compareTo (k2) : num;
        }}

    FrequencyComparator comp = new FrequencyComparator (numbers);
    TreeMap < Integer, Integer > sortedMap = new TreeMap < Integer, Integer > (comp);
    sortedMap.putAll (numbers);
    for (Integer i : sortedMap.keySet ()) {
        int frequencey = sortedMap.get (i);
        for (int count = 1;
        count <= frequencey; count ++) {
            System.out.print (i + " ");
        }
    }
}
----------------------------------------

public static void main (String args []) throws Exception {
    int i, j, temp, temp1, count;
    int [] a = new int [10];
    int [] freq = new int [10];
    Scanner s = new Scanner (System.in);
    for (i = 0; i < 5; i ++) {
        a [i] = s.nextInt ();
        freq [i] = - 1;
    }
    for (i = 0; i < 5; i ++) {
        count = 1;
        for (j = i + 1; j < 5; j ++) {
            if (a [i] == a [j]) {
                count ++;
                freq [j] = 0;
            }
        }
        if (freq [i] != 0) {
            freq [i] = count;
        }
    }
    Map map = new HashMap ();
    for (i = 0; i < 5; i ++) {
        if (freq [i] != 0) {
            map.put (a [i], freq [i]);
            System.out.println ("map elt" + map);
            System.out.println ("a" + a [i] + "fr" + freq [i]);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    List < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Map.Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " ==== " + entry.getValue ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_36694779_7_47
11842984_41378487_10_34
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [] {5, 2, 8, 8, 5, 5, 8, 1, 9, 0, 1, 1, 0, 1};
    Map < Integer, Integer > numbers = new HashMap < > ();
    for (int number : ar) {
        if (numbers.containsKey (number)) {
            Integer count = numbers.get (number);
            numbers.put (number, ++ count);
        } else {
            numbers.put (number, 1);
        }
    }
    final class FrequencyComparator implements Comparator < Integer > {
        Map < Integer, Integer > refMap;
        public FrequencyComparator (Map < Integer, Integer > base) {
            this.refMap = base;
        }@Override
        public int compare (Integer k1, Integer k2) {
            Integer val1 = refMap.get (k1);
            Integer val2 = refMap.get (k2);
            int num = val1.compareTo (val2);
            return num == 0 ? k1.compareTo (k2) : num;
        }}

    FrequencyComparator comp = new FrequencyComparator (numbers);
    TreeMap < Integer, Integer > sortedMap = new TreeMap < Integer, Integer > (comp);
    sortedMap.putAll (numbers);
    for (Integer i : sortedMap.keySet ()) {
        int frequencey = sortedMap.get (i);
        for (int count = 1;
        count <= frequencey; count ++) {
            System.out.print (i + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int array [] = {5, 2, 8, 8, 5, 5, 8, 1, 1, 2};
    HashMap < Integer, Integer > data = new HashMap < Integer, Integer > ();
    for (int i = 0;
    i < array.length; i ++) {
        if (data.containsKey (array [i])) {
            Integer count = data.get (array [i]) + 1;
            data.put (array [i], count);
        } else {
            data.put (array [i], 1);
        }
    }
    Set < Entry < Integer, Integer > > set = data.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " <-> " + entry.getValue ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_36694779_7_47
11842984_44746334_12_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [] {5, 2, 8, 8, 5, 5, 8, 1, 9, 0, 1, 1, 0, 1};
    Map < Integer, Integer > numbers = new HashMap < > ();
    for (int number : ar) {
        if (numbers.containsKey (number)) {
            Integer count = numbers.get (number);
            numbers.put (number, ++ count);
        } else {
            numbers.put (number, 1);
        }
    }
    final class FrequencyComparator implements Comparator < Integer > {
        Map < Integer, Integer > refMap;
        public FrequencyComparator (Map < Integer, Integer > base) {
            this.refMap = base;
        }@Override
        public int compare (Integer k1, Integer k2) {
            Integer val1 = refMap.get (k1);
            Integer val2 = refMap.get (k2);
            int num = val1.compareTo (val2);
            return num == 0 ? k1.compareTo (k2) : num;
        }}

    FrequencyComparator comp = new FrequencyComparator (numbers);
    TreeMap < Integer, Integer > sortedMap = new TreeMap < Integer, Integer > (comp);
    sortedMap.putAll (numbers);
    for (Integer i : sortedMap.keySet ()) {
        int frequencey = sortedMap.get (i);
        for (int count = 1;
        count <= frequencey; count ++) {
            System.out.print (i + " ");
        }
    }
}
----------------------------------------

public static void main (String args []) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > map = new HashMap < Integer, Integer > ();
    int len = arr.length;
    for (int j = 0;
    j < len; j ++) {
        if (map.get (arr [j]) == null) {
            map.put (arr [j], 1);
        } else {
            map.put (arr [j], (Integer) map.get (arr [j]) + 1);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    list.sort (new Comparator < Entry < Integer, Integer > > () {
        @Override
        public int compare (Entry < Integer, Integer > o1, Entry < Integer, Integer > o2) {
            if (o1.getValue () < o2.getValue ()) {
                return 1;
            } else if (o1.getValue () > o2.getValue ()) {
                return - 1;
            } else if (o1.getValue () == o2.getValue ()) {
                if (o1.getKey () < o2.getKey ()) {
                    return 1;
                } else {
                    return - 1;
                }
            }

            return 0;
        }}

    );
    for (Map.Entry < Integer, Integer > en : list) {
        int val = en.getValue ();
        while (val != 0) {
            System.out.println (en.getKey ());
            val --;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_36694779_7_47
11842984_51862367_5_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [] {5, 2, 8, 8, 5, 5, 8, 1, 9, 0, 1, 1, 0, 1};
    Map < Integer, Integer > numbers = new HashMap < > ();
    for (int number : ar) {
        if (numbers.containsKey (number)) {
            Integer count = numbers.get (number);
            numbers.put (number, ++ count);
        } else {
            numbers.put (number, 1);
        }
    }
    final class FrequencyComparator implements Comparator < Integer > {
        Map < Integer, Integer > refMap;
        public FrequencyComparator (Map < Integer, Integer > base) {
            this.refMap = base;
        }@Override
        public int compare (Integer k1, Integer k2) {
            Integer val1 = refMap.get (k1);
            Integer val2 = refMap.get (k2);
            int num = val1.compareTo (val2);
            return num == 0 ? k1.compareTo (k2) : num;
        }}

    FrequencyComparator comp = new FrequencyComparator (numbers);
    TreeMap < Integer, Integer > sortedMap = new TreeMap < Integer, Integer > (comp);
    sortedMap.putAll (numbers);
    for (Integer i : sortedMap.keySet ()) {
        int frequencey = sortedMap.get (i);
        for (int count = 1;
        count <= frequencey; count ++) {
            System.out.print (i + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int arrTemp [] = {2, 2, 2, 1, 1, 4, 5, 6, 6, 7, 7, 7, 7};
    Arrays.sort (arrTemp);
    Integer [] [] sortedArray = new Integer [6] [2];
    int count = 0;
    sortedArray [count] [0] = arrTemp [0];
    sortedArray [count] [1] = 1;
    for (int i = 0;
    i < arrTemp.length - 1; i ++) {
        for (int j = 1;
        j < arrTemp.length; j ++) {
            if (arrTemp [i] == arrTemp [j]) {
                sortedArray [count] [1] = sortedArray [count] [1] + 1;
                i = j;
            } else {
                ++ count;
                sortedArray [count] [0] = arrTemp [j];
                sortedArray [count] [1] = 1;
                i = j;
            }
        }
    }
    Arrays.sort (sortedArray, new Comparator < Integer [] > () {
        @Override
        public int compare (Integer [] o1, Integer [] o2) {
            return o1 [1].compareTo (o2 [1]);
        }}

    );
    for (int row = 0;
    row < 6; row ++) {
        for (int col = 0;
        col < sortedArray [row] [1]; col ++) {
            System.out.print (sortedArray [row] [0] + " ");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_36694779_7_47
11842984_52580911_3_42
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [] {5, 2, 8, 8, 5, 5, 8, 1, 9, 0, 1, 1, 0, 1};
    Map < Integer, Integer > numbers = new HashMap < > ();
    for (int number : ar) {
        if (numbers.containsKey (number)) {
            Integer count = numbers.get (number);
            numbers.put (number, ++ count);
        } else {
            numbers.put (number, 1);
        }
    }
    final class FrequencyComparator implements Comparator < Integer > {
        Map < Integer, Integer > refMap;
        public FrequencyComparator (Map < Integer, Integer > base) {
            this.refMap = base;
        }@Override
        public int compare (Integer k1, Integer k2) {
            Integer val1 = refMap.get (k1);
            Integer val2 = refMap.get (k2);
            int num = val1.compareTo (val2);
            return num == 0 ? k1.compareTo (k2) : num;
        }}

    FrequencyComparator comp = new FrequencyComparator (numbers);
    TreeMap < Integer, Integer > sortedMap = new TreeMap < Integer, Integer > (comp);
    sortedMap.putAll (numbers);
    for (Integer i : sortedMap.keySet ()) {
        int frequencey = sortedMap.get (i);
        for (int count = 1;
        count <= frequencey; count ++) {
            System.out.print (i + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int r;
    int b [] = {1, 1, 1, 2, 1, 2, 3, 6, 6, 5};
    int i;
    int n = b.length;
    int k = 0;
    Arrays.sort (b);
    int [] a = new int [n + 1];
    for (r = 0; r < n; r ++) {
        a [r] = b [r];
    }
    a [r] = 1882737378;
    int c = 1;
    int in [] = new int [10];
    int [] e = new int [10];
    for (i = 0; i < n; i ++) {
        if (a [i] == a [i + 1]) c ++;
        else {
            e [k] = a [i];
            in [k] = c;
            k ++;
            c = 1;
        }
    }
    for (int f = 0;
    f < k; f ++) {
        for (int g = 0;
        g < k - f - 1; g ++) {
            if (in [g] > in [g + 1]) {
                int [] ans = swap (in [g], in [g + 1]);
                in [g] = ans [0];
                in [g + 1] = ans [1];
                int [] an = swap (e [g], e [g + 1]);
                e [g] = an [0];
                e [g + 1] = an [1];
            }
        }
    }
    int d = 0;
    for (int x = 0;
    x < k; x ++) {
        for (int y = 0;
        y < in [x]; y ++) {
            System.out.print (e [d]);
        }
        d ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_36694779_7_47
11842984_53325860_4_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [] {5, 2, 8, 8, 5, 5, 8, 1, 9, 0, 1, 1, 0, 1};
    Map < Integer, Integer > numbers = new HashMap < > ();
    for (int number : ar) {
        if (numbers.containsKey (number)) {
            Integer count = numbers.get (number);
            numbers.put (number, ++ count);
        } else {
            numbers.put (number, 1);
        }
    }
    final class FrequencyComparator implements Comparator < Integer > {
        Map < Integer, Integer > refMap;
        public FrequencyComparator (Map < Integer, Integer > base) {
            this.refMap = base;
        }@Override
        public int compare (Integer k1, Integer k2) {
            Integer val1 = refMap.get (k1);
            Integer val2 = refMap.get (k2);
            int num = val1.compareTo (val2);
            return num == 0 ? k1.compareTo (k2) : num;
        }}

    FrequencyComparator comp = new FrequencyComparator (numbers);
    TreeMap < Integer, Integer > sortedMap = new TreeMap < Integer, Integer > (comp);
    sortedMap.putAll (numbers);
    for (Integer i : sortedMap.keySet ()) {
        int frequencey = sortedMap.get (i);
        for (int count = 1;
        count <= frequencey; count ++) {
            System.out.print (i + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Integer [] nums = {7, 3, 4, 3, 4, 3, 4, 3, 6, 5, 7};
    Map < Integer, Integer > m1;
    ArrayList < Integer > numbers = new ArrayList < Integer > (Arrays.asList (nums));
    List < Integer > values = new ArrayList < Integer > ();
    List < Integer > output = new ArrayList < Integer > ();
    m1 = new LinkedHashMap < Integer, Integer > ();
    for (int a : numbers) {
        if (m1.containsKey (a)) {
            int value = m1.get (a);
            m1.put (a, ++ value);
        } else {
            m1.put (a, 1);
        }
    }
    System.out.println (m1);
    for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
        values.add (entry.getValue ());
    }
    Collections.sort (values, Collections.reverseOrder ());
    System.out.println (values.toString ());
    for (int m = 0;
    m < values.size (); m ++) {
        for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
            if (entry.getValue ().equals (values.get (m))) {
                key = entry.getKey ();
                System.out.println ("Key is" + key);
                for (int k = values.get (m);
                k > 0; k --) {
                    output.add (key);
                }
                break;
            }
        }
        m1.remove (key);
    }
    System.out.println (output.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_36694779_7_47
11842984_53497463_1_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int [] ar = new int [] {5, 2, 8, 8, 5, 5, 8, 1, 9, 0, 1, 1, 0, 1};
    Map < Integer, Integer > numbers = new HashMap < > ();
    for (int number : ar) {
        if (numbers.containsKey (number)) {
            Integer count = numbers.get (number);
            numbers.put (number, ++ count);
        } else {
            numbers.put (number, 1);
        }
    }
    final class FrequencyComparator implements Comparator < Integer > {
        Map < Integer, Integer > refMap;
        public FrequencyComparator (Map < Integer, Integer > base) {
            this.refMap = base;
        }@Override
        public int compare (Integer k1, Integer k2) {
            Integer val1 = refMap.get (k1);
            Integer val2 = refMap.get (k2);
            int num = val1.compareTo (val2);
            return num == 0 ? k1.compareTo (k2) : num;
        }}

    FrequencyComparator comp = new FrequencyComparator (numbers);
    TreeMap < Integer, Integer > sortedMap = new TreeMap < Integer, Integer > (comp);
    sortedMap.putAll (numbers);
    for (Integer i : sortedMap.keySet ()) {
        int frequencey = sortedMap.get (i);
        for (int count = 1;
        count <= frequencey; count ++) {
            System.out.print (i + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > mp = new LinkedHashMap < > ();
    List < Integer > res = new ArrayList < > ();
    int count = 1;
    for (int i = 0;
    i < arr.length; i ++) {
        if (! mp.containsKey (arr [i])) {
            mp.put (arr [i], count);
        } else {
            mp.put (arr [i], mp.get (arr [i]) + 1);
        }
    }
    if (! mp.containsValue (2)) {
        for (Integer ab : arr) res.add (ab);

        Collections.sort (res);
        Collections.reverse (res);
        System.out.println (res);
    } else {
        Set < Entry < Integer, Integer > > set = mp.entrySet ();
        List < Entry < Integer, Integer > > list = new ArrayList < > (set);
        Collections.sort (list, new Comparator < Entry < Integer, Integer > > () {
            @Override
            public int compare (Entry < Integer, Integer > obj1, Entry < Integer, Integer > obj2) {
                if (obj2.getValue () > obj1.getValue ()) return 1;

                if (obj2.getValue () < obj1.getValue ()) return - 1;
                else return 0;

            }}

        );
        for (Map.Entry < Integer, Integer > e : list) {
            for (int i = 1;
            i <= e.getValue (); i ++) res.add (e.getKey ());

        }
        System.out.println (res);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_40938382_15_60
11842984_41378487_10_34
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) throws Exception {
    int i, j, temp, temp1, count;
    int [] a = new int [10];
    int [] freq = new int [10];
    Scanner s = new Scanner (System.in);
    for (i = 0; i < 5; i ++) {
        a [i] = s.nextInt ();
        freq [i] = - 1;
    }
    for (i = 0; i < 5; i ++) {
        count = 1;
        for (j = i + 1; j < 5; j ++) {
            if (a [i] == a [j]) {
                count ++;
                freq [j] = 0;
            }
        }
        if (freq [i] != 0) {
            freq [i] = count;
        }
    }
    Map map = new HashMap ();
    for (i = 0; i < 5; i ++) {
        if (freq [i] != 0) {
            map.put (a [i], freq [i]);
            System.out.println ("map elt" + map);
            System.out.println ("a" + a [i] + "fr" + freq [i]);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    List < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Map.Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " ==== " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    int array [] = {5, 2, 8, 8, 5, 5, 8, 1, 1, 2};
    HashMap < Integer, Integer > data = new HashMap < Integer, Integer > ();
    for (int i = 0;
    i < array.length; i ++) {
        if (data.containsKey (array [i])) {
            Integer count = data.get (array [i]) + 1;
            data.put (array [i], count);
        } else {
            data.put (array [i], 1);
        }
    }
    Set < Entry < Integer, Integer > > set = data.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " <-> " + entry.getValue ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_40938382_15_60
11842984_44746334_12_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) throws Exception {
    int i, j, temp, temp1, count;
    int [] a = new int [10];
    int [] freq = new int [10];
    Scanner s = new Scanner (System.in);
    for (i = 0; i < 5; i ++) {
        a [i] = s.nextInt ();
        freq [i] = - 1;
    }
    for (i = 0; i < 5; i ++) {
        count = 1;
        for (j = i + 1; j < 5; j ++) {
            if (a [i] == a [j]) {
                count ++;
                freq [j] = 0;
            }
        }
        if (freq [i] != 0) {
            freq [i] = count;
        }
    }
    Map map = new HashMap ();
    for (i = 0; i < 5; i ++) {
        if (freq [i] != 0) {
            map.put (a [i], freq [i]);
            System.out.println ("map elt" + map);
            System.out.println ("a" + a [i] + "fr" + freq [i]);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    List < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Map.Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " ==== " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String args []) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > map = new HashMap < Integer, Integer > ();
    int len = arr.length;
    for (int j = 0;
    j < len; j ++) {
        if (map.get (arr [j]) == null) {
            map.put (arr [j], 1);
        } else {
            map.put (arr [j], (Integer) map.get (arr [j]) + 1);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    list.sort (new Comparator < Entry < Integer, Integer > > () {
        @Override
        public int compare (Entry < Integer, Integer > o1, Entry < Integer, Integer > o2) {
            if (o1.getValue () < o2.getValue ()) {
                return 1;
            } else if (o1.getValue () > o2.getValue ()) {
                return - 1;
            } else if (o1.getValue () == o2.getValue ()) {
                if (o1.getKey () < o2.getKey ()) {
                    return 1;
                } else {
                    return - 1;
                }
            }

            return 0;
        }}

    );
    for (Map.Entry < Integer, Integer > en : list) {
        int val = en.getValue ();
        while (val != 0) {
            System.out.println (en.getKey ());
            val --;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_40938382_15_60
11842984_51862367_5_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) throws Exception {
    int i, j, temp, temp1, count;
    int [] a = new int [10];
    int [] freq = new int [10];
    Scanner s = new Scanner (System.in);
    for (i = 0; i < 5; i ++) {
        a [i] = s.nextInt ();
        freq [i] = - 1;
    }
    for (i = 0; i < 5; i ++) {
        count = 1;
        for (j = i + 1; j < 5; j ++) {
            if (a [i] == a [j]) {
                count ++;
                freq [j] = 0;
            }
        }
        if (freq [i] != 0) {
            freq [i] = count;
        }
    }
    Map map = new HashMap ();
    for (i = 0; i < 5; i ++) {
        if (freq [i] != 0) {
            map.put (a [i], freq [i]);
            System.out.println ("map elt" + map);
            System.out.println ("a" + a [i] + "fr" + freq [i]);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    List < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Map.Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " ==== " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    int arrTemp [] = {2, 2, 2, 1, 1, 4, 5, 6, 6, 7, 7, 7, 7};
    Arrays.sort (arrTemp);
    Integer [] [] sortedArray = new Integer [6] [2];
    int count = 0;
    sortedArray [count] [0] = arrTemp [0];
    sortedArray [count] [1] = 1;
    for (int i = 0;
    i < arrTemp.length - 1; i ++) {
        for (int j = 1;
        j < arrTemp.length; j ++) {
            if (arrTemp [i] == arrTemp [j]) {
                sortedArray [count] [1] = sortedArray [count] [1] + 1;
                i = j;
            } else {
                ++ count;
                sortedArray [count] [0] = arrTemp [j];
                sortedArray [count] [1] = 1;
                i = j;
            }
        }
    }
    Arrays.sort (sortedArray, new Comparator < Integer [] > () {
        @Override
        public int compare (Integer [] o1, Integer [] o2) {
            return o1 [1].compareTo (o2 [1]);
        }}

    );
    for (int row = 0;
    row < 6; row ++) {
        for (int col = 0;
        col < sortedArray [row] [1]; col ++) {
            System.out.print (sortedArray [row] [0] + " ");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_40938382_15_60
11842984_52580911_3_42
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) throws Exception {
    int i, j, temp, temp1, count;
    int [] a = new int [10];
    int [] freq = new int [10];
    Scanner s = new Scanner (System.in);
    for (i = 0; i < 5; i ++) {
        a [i] = s.nextInt ();
        freq [i] = - 1;
    }
    for (i = 0; i < 5; i ++) {
        count = 1;
        for (j = i + 1; j < 5; j ++) {
            if (a [i] == a [j]) {
                count ++;
                freq [j] = 0;
            }
        }
        if (freq [i] != 0) {
            freq [i] = count;
        }
    }
    Map map = new HashMap ();
    for (i = 0; i < 5; i ++) {
        if (freq [i] != 0) {
            map.put (a [i], freq [i]);
            System.out.println ("map elt" + map);
            System.out.println ("a" + a [i] + "fr" + freq [i]);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    List < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Map.Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " ==== " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    int r;
    int b [] = {1, 1, 1, 2, 1, 2, 3, 6, 6, 5};
    int i;
    int n = b.length;
    int k = 0;
    Arrays.sort (b);
    int [] a = new int [n + 1];
    for (r = 0; r < n; r ++) {
        a [r] = b [r];
    }
    a [r] = 1882737378;
    int c = 1;
    int in [] = new int [10];
    int [] e = new int [10];
    for (i = 0; i < n; i ++) {
        if (a [i] == a [i + 1]) c ++;
        else {
            e [k] = a [i];
            in [k] = c;
            k ++;
            c = 1;
        }
    }
    for (int f = 0;
    f < k; f ++) {
        for (int g = 0;
        g < k - f - 1; g ++) {
            if (in [g] > in [g + 1]) {
                int [] ans = swap (in [g], in [g + 1]);
                in [g] = ans [0];
                in [g + 1] = ans [1];
                int [] an = swap (e [g], e [g + 1]);
                e [g] = an [0];
                e [g + 1] = an [1];
            }
        }
    }
    int d = 0;
    for (int x = 0;
    x < k; x ++) {
        for (int y = 0;
        y < in [x]; y ++) {
            System.out.print (e [d]);
        }
        d ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_40938382_15_60
11842984_53325860_4_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) throws Exception {
    int i, j, temp, temp1, count;
    int [] a = new int [10];
    int [] freq = new int [10];
    Scanner s = new Scanner (System.in);
    for (i = 0; i < 5; i ++) {
        a [i] = s.nextInt ();
        freq [i] = - 1;
    }
    for (i = 0; i < 5; i ++) {
        count = 1;
        for (j = i + 1; j < 5; j ++) {
            if (a [i] == a [j]) {
                count ++;
                freq [j] = 0;
            }
        }
        if (freq [i] != 0) {
            freq [i] = count;
        }
    }
    Map map = new HashMap ();
    for (i = 0; i < 5; i ++) {
        if (freq [i] != 0) {
            map.put (a [i], freq [i]);
            System.out.println ("map elt" + map);
            System.out.println ("a" + a [i] + "fr" + freq [i]);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    List < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Map.Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " ==== " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    Integer [] nums = {7, 3, 4, 3, 4, 3, 4, 3, 6, 5, 7};
    Map < Integer, Integer > m1;
    ArrayList < Integer > numbers = new ArrayList < Integer > (Arrays.asList (nums));
    List < Integer > values = new ArrayList < Integer > ();
    List < Integer > output = new ArrayList < Integer > ();
    m1 = new LinkedHashMap < Integer, Integer > ();
    for (int a : numbers) {
        if (m1.containsKey (a)) {
            int value = m1.get (a);
            m1.put (a, ++ value);
        } else {
            m1.put (a, 1);
        }
    }
    System.out.println (m1);
    for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
        values.add (entry.getValue ());
    }
    Collections.sort (values, Collections.reverseOrder ());
    System.out.println (values.toString ());
    for (int m = 0;
    m < values.size (); m ++) {
        for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
            if (entry.getValue ().equals (values.get (m))) {
                key = entry.getKey ();
                System.out.println ("Key is" + key);
                for (int k = values.get (m);
                k > 0; k --) {
                    output.add (key);
                }
                break;
            }
        }
        m1.remove (key);
    }
    System.out.println (output.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_40938382_15_60
11842984_53497463_1_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) throws Exception {
    int i, j, temp, temp1, count;
    int [] a = new int [10];
    int [] freq = new int [10];
    Scanner s = new Scanner (System.in);
    for (i = 0; i < 5; i ++) {
        a [i] = s.nextInt ();
        freq [i] = - 1;
    }
    for (i = 0; i < 5; i ++) {
        count = 1;
        for (j = i + 1; j < 5; j ++) {
            if (a [i] == a [j]) {
                count ++;
                freq [j] = 0;
            }
        }
        if (freq [i] != 0) {
            freq [i] = count;
        }
    }
    Map map = new HashMap ();
    for (i = 0; i < 5; i ++) {
        if (freq [i] != 0) {
            map.put (a [i], freq [i]);
            System.out.println ("map elt" + map);
            System.out.println ("a" + a [i] + "fr" + freq [i]);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    List < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Map.Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " ==== " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > mp = new LinkedHashMap < > ();
    List < Integer > res = new ArrayList < > ();
    int count = 1;
    for (int i = 0;
    i < arr.length; i ++) {
        if (! mp.containsKey (arr [i])) {
            mp.put (arr [i], count);
        } else {
            mp.put (arr [i], mp.get (arr [i]) + 1);
        }
    }
    if (! mp.containsValue (2)) {
        for (Integer ab : arr) res.add (ab);

        Collections.sort (res);
        Collections.reverse (res);
        System.out.println (res);
    } else {
        Set < Entry < Integer, Integer > > set = mp.entrySet ();
        List < Entry < Integer, Integer > > list = new ArrayList < > (set);
        Collections.sort (list, new Comparator < Entry < Integer, Integer > > () {
            @Override
            public int compare (Entry < Integer, Integer > obj1, Entry < Integer, Integer > obj2) {
                if (obj2.getValue () > obj1.getValue ()) return 1;

                if (obj2.getValue () < obj1.getValue ()) return - 1;
                else return 0;

            }}

        );
        for (Map.Entry < Integer, Integer > e : list) {
            for (int i = 1;
            i <= e.getValue (); i ++) res.add (e.getKey ());

        }
        System.out.println (res);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_41378487_10_34
11842984_44746334_12_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int array [] = {5, 2, 8, 8, 5, 5, 8, 1, 1, 2};
    HashMap < Integer, Integer > data = new HashMap < Integer, Integer > ();
    for (int i = 0;
    i < array.length; i ++) {
        if (data.containsKey (array [i])) {
            Integer count = data.get (array [i]) + 1;
            data.put (array [i], count);
        } else {
            data.put (array [i], 1);
        }
    }
    Set < Entry < Integer, Integer > > set = data.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " <-> " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String args []) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > map = new HashMap < Integer, Integer > ();
    int len = arr.length;
    for (int j = 0;
    j < len; j ++) {
        if (map.get (arr [j]) == null) {
            map.put (arr [j], 1);
        } else {
            map.put (arr [j], (Integer) map.get (arr [j]) + 1);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    list.sort (new Comparator < Entry < Integer, Integer > > () {
        @Override
        public int compare (Entry < Integer, Integer > o1, Entry < Integer, Integer > o2) {
            if (o1.getValue () < o2.getValue ()) {
                return 1;
            } else if (o1.getValue () > o2.getValue ()) {
                return - 1;
            } else if (o1.getValue () == o2.getValue ()) {
                if (o1.getKey () < o2.getKey ()) {
                    return 1;
                } else {
                    return - 1;
                }
            }

            return 0;
        }}

    );
    for (Map.Entry < Integer, Integer > en : list) {
        int val = en.getValue ();
        while (val != 0) {
            System.out.println (en.getKey ());
            val --;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_41378487_10_34
11842984_51862367_5_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int array [] = {5, 2, 8, 8, 5, 5, 8, 1, 1, 2};
    HashMap < Integer, Integer > data = new HashMap < Integer, Integer > ();
    for (int i = 0;
    i < array.length; i ++) {
        if (data.containsKey (array [i])) {
            Integer count = data.get (array [i]) + 1;
            data.put (array [i], count);
        } else {
            data.put (array [i], 1);
        }
    }
    Set < Entry < Integer, Integer > > set = data.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " <-> " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    int arrTemp [] = {2, 2, 2, 1, 1, 4, 5, 6, 6, 7, 7, 7, 7};
    Arrays.sort (arrTemp);
    Integer [] [] sortedArray = new Integer [6] [2];
    int count = 0;
    sortedArray [count] [0] = arrTemp [0];
    sortedArray [count] [1] = 1;
    for (int i = 0;
    i < arrTemp.length - 1; i ++) {
        for (int j = 1;
        j < arrTemp.length; j ++) {
            if (arrTemp [i] == arrTemp [j]) {
                sortedArray [count] [1] = sortedArray [count] [1] + 1;
                i = j;
            } else {
                ++ count;
                sortedArray [count] [0] = arrTemp [j];
                sortedArray [count] [1] = 1;
                i = j;
            }
        }
    }
    Arrays.sort (sortedArray, new Comparator < Integer [] > () {
        @Override
        public int compare (Integer [] o1, Integer [] o2) {
            return o1 [1].compareTo (o2 [1]);
        }}

    );
    for (int row = 0;
    row < 6; row ++) {
        for (int col = 0;
        col < sortedArray [row] [1]; col ++) {
            System.out.print (sortedArray [row] [0] + " ");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_41378487_10_34
11842984_52580911_3_42
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int array [] = {5, 2, 8, 8, 5, 5, 8, 1, 1, 2};
    HashMap < Integer, Integer > data = new HashMap < Integer, Integer > ();
    for (int i = 0;
    i < array.length; i ++) {
        if (data.containsKey (array [i])) {
            Integer count = data.get (array [i]) + 1;
            data.put (array [i], count);
        } else {
            data.put (array [i], 1);
        }
    }
    Set < Entry < Integer, Integer > > set = data.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " <-> " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    int r;
    int b [] = {1, 1, 1, 2, 1, 2, 3, 6, 6, 5};
    int i;
    int n = b.length;
    int k = 0;
    Arrays.sort (b);
    int [] a = new int [n + 1];
    for (r = 0; r < n; r ++) {
        a [r] = b [r];
    }
    a [r] = 1882737378;
    int c = 1;
    int in [] = new int [10];
    int [] e = new int [10];
    for (i = 0; i < n; i ++) {
        if (a [i] == a [i + 1]) c ++;
        else {
            e [k] = a [i];
            in [k] = c;
            k ++;
            c = 1;
        }
    }
    for (int f = 0;
    f < k; f ++) {
        for (int g = 0;
        g < k - f - 1; g ++) {
            if (in [g] > in [g + 1]) {
                int [] ans = swap (in [g], in [g + 1]);
                in [g] = ans [0];
                in [g + 1] = ans [1];
                int [] an = swap (e [g], e [g + 1]);
                e [g] = an [0];
                e [g + 1] = an [1];
            }
        }
    }
    int d = 0;
    for (int x = 0;
    x < k; x ++) {
        for (int y = 0;
        y < in [x]; y ++) {
            System.out.print (e [d]);
        }
        d ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_41378487_10_34
11842984_53325860_4_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int array [] = {5, 2, 8, 8, 5, 5, 8, 1, 1, 2};
    HashMap < Integer, Integer > data = new HashMap < Integer, Integer > ();
    for (int i = 0;
    i < array.length; i ++) {
        if (data.containsKey (array [i])) {
            Integer count = data.get (array [i]) + 1;
            data.put (array [i], count);
        } else {
            data.put (array [i], 1);
        }
    }
    Set < Entry < Integer, Integer > > set = data.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " <-> " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    Integer [] nums = {7, 3, 4, 3, 4, 3, 4, 3, 6, 5, 7};
    Map < Integer, Integer > m1;
    ArrayList < Integer > numbers = new ArrayList < Integer > (Arrays.asList (nums));
    List < Integer > values = new ArrayList < Integer > ();
    List < Integer > output = new ArrayList < Integer > ();
    m1 = new LinkedHashMap < Integer, Integer > ();
    for (int a : numbers) {
        if (m1.containsKey (a)) {
            int value = m1.get (a);
            m1.put (a, ++ value);
        } else {
            m1.put (a, 1);
        }
    }
    System.out.println (m1);
    for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
        values.add (entry.getValue ());
    }
    Collections.sort (values, Collections.reverseOrder ());
    System.out.println (values.toString ());
    for (int m = 0;
    m < values.size (); m ++) {
        for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
            if (entry.getValue ().equals (values.get (m))) {
                key = entry.getKey ();
                System.out.println ("Key is" + key);
                for (int k = values.get (m);
                k > 0; k --) {
                    output.add (key);
                }
                break;
            }
        }
        m1.remove (key);
    }
    System.out.println (output.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_41378487_10_34
11842984_53497463_1_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int array [] = {5, 2, 8, 8, 5, 5, 8, 1, 1, 2};
    HashMap < Integer, Integer > data = new HashMap < Integer, Integer > ();
    for (int i = 0;
    i < array.length; i ++) {
        if (data.containsKey (array [i])) {
            Integer count = data.get (array [i]) + 1;
            data.put (array [i], count);
        } else {
            data.put (array [i], 1);
        }
    }
    Set < Entry < Integer, Integer > > set = data.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    Collections.sort (list, new Comparator < Map.Entry < Integer, Integer > > () {
        public int compare (Map.Entry < Integer, Integer > o1, Map.Entry < Integer, Integer > o2) {
            return (o2.getValue ()).compareTo (o1.getValue ());
        }}

    );
    for (Entry < Integer, Integer > entry : list) {
        System.out.println (entry.getKey () + " <-> " + entry.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > mp = new LinkedHashMap < > ();
    List < Integer > res = new ArrayList < > ();
    int count = 1;
    for (int i = 0;
    i < arr.length; i ++) {
        if (! mp.containsKey (arr [i])) {
            mp.put (arr [i], count);
        } else {
            mp.put (arr [i], mp.get (arr [i]) + 1);
        }
    }
    if (! mp.containsValue (2)) {
        for (Integer ab : arr) res.add (ab);

        Collections.sort (res);
        Collections.reverse (res);
        System.out.println (res);
    } else {
        Set < Entry < Integer, Integer > > set = mp.entrySet ();
        List < Entry < Integer, Integer > > list = new ArrayList < > (set);
        Collections.sort (list, new Comparator < Entry < Integer, Integer > > () {
            @Override
            public int compare (Entry < Integer, Integer > obj1, Entry < Integer, Integer > obj2) {
                if (obj2.getValue () > obj1.getValue ()) return 1;

                if (obj2.getValue () < obj1.getValue ()) return - 1;
                else return 0;

            }}

        );
        for (Map.Entry < Integer, Integer > e : list) {
            for (int i = 1;
            i <= e.getValue (); i ++) res.add (e.getKey ());

        }
        System.out.println (res);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_44746334_12_50
11842984_51862367_5_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > map = new HashMap < Integer, Integer > ();
    int len = arr.length;
    for (int j = 0;
    j < len; j ++) {
        if (map.get (arr [j]) == null) {
            map.put (arr [j], 1);
        } else {
            map.put (arr [j], (Integer) map.get (arr [j]) + 1);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    list.sort (new Comparator < Entry < Integer, Integer > > () {
        @Override
        public int compare (Entry < Integer, Integer > o1, Entry < Integer, Integer > o2) {
            if (o1.getValue () < o2.getValue ()) {
                return 1;
            } else if (o1.getValue () > o2.getValue ()) {
                return - 1;
            } else if (o1.getValue () == o2.getValue ()) {
                if (o1.getKey () < o2.getKey ()) {
                    return 1;
                } else {
                    return - 1;
                }
            }

            return 0;
        }}

    );
    for (Map.Entry < Integer, Integer > en : list) {
        int val = en.getValue ();
        while (val != 0) {
            System.out.println (en.getKey ());
            val --;
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int arrTemp [] = {2, 2, 2, 1, 1, 4, 5, 6, 6, 7, 7, 7, 7};
    Arrays.sort (arrTemp);
    Integer [] [] sortedArray = new Integer [6] [2];
    int count = 0;
    sortedArray [count] [0] = arrTemp [0];
    sortedArray [count] [1] = 1;
    for (int i = 0;
    i < arrTemp.length - 1; i ++) {
        for (int j = 1;
        j < arrTemp.length; j ++) {
            if (arrTemp [i] == arrTemp [j]) {
                sortedArray [count] [1] = sortedArray [count] [1] + 1;
                i = j;
            } else {
                ++ count;
                sortedArray [count] [0] = arrTemp [j];
                sortedArray [count] [1] = 1;
                i = j;
            }
        }
    }
    Arrays.sort (sortedArray, new Comparator < Integer [] > () {
        @Override
        public int compare (Integer [] o1, Integer [] o2) {
            return o1 [1].compareTo (o2 [1]);
        }}

    );
    for (int row = 0;
    row < 6; row ++) {
        for (int col = 0;
        col < sortedArray [row] [1]; col ++) {
            System.out.print (sortedArray [row] [0] + " ");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_44746334_12_50
11842984_52580911_3_42
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > map = new HashMap < Integer, Integer > ();
    int len = arr.length;
    for (int j = 0;
    j < len; j ++) {
        if (map.get (arr [j]) == null) {
            map.put (arr [j], 1);
        } else {
            map.put (arr [j], (Integer) map.get (arr [j]) + 1);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    list.sort (new Comparator < Entry < Integer, Integer > > () {
        @Override
        public int compare (Entry < Integer, Integer > o1, Entry < Integer, Integer > o2) {
            if (o1.getValue () < o2.getValue ()) {
                return 1;
            } else if (o1.getValue () > o2.getValue ()) {
                return - 1;
            } else if (o1.getValue () == o2.getValue ()) {
                if (o1.getKey () < o2.getKey ()) {
                    return 1;
                } else {
                    return - 1;
                }
            }

            return 0;
        }}

    );
    for (Map.Entry < Integer, Integer > en : list) {
        int val = en.getValue ();
        while (val != 0) {
            System.out.println (en.getKey ());
            val --;
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int r;
    int b [] = {1, 1, 1, 2, 1, 2, 3, 6, 6, 5};
    int i;
    int n = b.length;
    int k = 0;
    Arrays.sort (b);
    int [] a = new int [n + 1];
    for (r = 0; r < n; r ++) {
        a [r] = b [r];
    }
    a [r] = 1882737378;
    int c = 1;
    int in [] = new int [10];
    int [] e = new int [10];
    for (i = 0; i < n; i ++) {
        if (a [i] == a [i + 1]) c ++;
        else {
            e [k] = a [i];
            in [k] = c;
            k ++;
            c = 1;
        }
    }
    for (int f = 0;
    f < k; f ++) {
        for (int g = 0;
        g < k - f - 1; g ++) {
            if (in [g] > in [g + 1]) {
                int [] ans = swap (in [g], in [g + 1]);
                in [g] = ans [0];
                in [g + 1] = ans [1];
                int [] an = swap (e [g], e [g + 1]);
                e [g] = an [0];
                e [g + 1] = an [1];
            }
        }
    }
    int d = 0;
    for (int x = 0;
    x < k; x ++) {
        for (int y = 0;
        y < in [x]; y ++) {
            System.out.print (e [d]);
        }
        d ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_44746334_12_50
11842984_53325860_4_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > map = new HashMap < Integer, Integer > ();
    int len = arr.length;
    for (int j = 0;
    j < len; j ++) {
        if (map.get (arr [j]) == null) {
            map.put (arr [j], 1);
        } else {
            map.put (arr [j], (Integer) map.get (arr [j]) + 1);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    list.sort (new Comparator < Entry < Integer, Integer > > () {
        @Override
        public int compare (Entry < Integer, Integer > o1, Entry < Integer, Integer > o2) {
            if (o1.getValue () < o2.getValue ()) {
                return 1;
            } else if (o1.getValue () > o2.getValue ()) {
                return - 1;
            } else if (o1.getValue () == o2.getValue ()) {
                if (o1.getKey () < o2.getKey ()) {
                    return 1;
                } else {
                    return - 1;
                }
            }

            return 0;
        }}

    );
    for (Map.Entry < Integer, Integer > en : list) {
        int val = en.getValue ();
        while (val != 0) {
            System.out.println (en.getKey ());
            val --;
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Integer [] nums = {7, 3, 4, 3, 4, 3, 4, 3, 6, 5, 7};
    Map < Integer, Integer > m1;
    ArrayList < Integer > numbers = new ArrayList < Integer > (Arrays.asList (nums));
    List < Integer > values = new ArrayList < Integer > ();
    List < Integer > output = new ArrayList < Integer > ();
    m1 = new LinkedHashMap < Integer, Integer > ();
    for (int a : numbers) {
        if (m1.containsKey (a)) {
            int value = m1.get (a);
            m1.put (a, ++ value);
        } else {
            m1.put (a, 1);
        }
    }
    System.out.println (m1);
    for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
        values.add (entry.getValue ());
    }
    Collections.sort (values, Collections.reverseOrder ());
    System.out.println (values.toString ());
    for (int m = 0;
    m < values.size (); m ++) {
        for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
            if (entry.getValue ().equals (values.get (m))) {
                key = entry.getKey ();
                System.out.println ("Key is" + key);
                for (int k = values.get (m);
                k > 0; k --) {
                    output.add (key);
                }
                break;
            }
        }
        m1.remove (key);
    }
    System.out.println (output.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_44746334_12_50
11842984_53497463_1_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String args []) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > map = new HashMap < Integer, Integer > ();
    int len = arr.length;
    for (int j = 0;
    j < len; j ++) {
        if (map.get (arr [j]) == null) {
            map.put (arr [j], 1);
        } else {
            map.put (arr [j], (Integer) map.get (arr [j]) + 1);
        }
    }
    Set < Entry < Integer, Integer > > set = map.entrySet ();
    ArrayList < Entry < Integer, Integer > > list = new ArrayList < Entry < Integer, Integer > > (set);
    list.sort (new Comparator < Entry < Integer, Integer > > () {
        @Override
        public int compare (Entry < Integer, Integer > o1, Entry < Integer, Integer > o2) {
            if (o1.getValue () < o2.getValue ()) {
                return 1;
            } else if (o1.getValue () > o2.getValue ()) {
                return - 1;
            } else if (o1.getValue () == o2.getValue ()) {
                if (o1.getKey () < o2.getKey ()) {
                    return 1;
                } else {
                    return - 1;
                }
            }

            return 0;
        }}

    );
    for (Map.Entry < Integer, Integer > en : list) {
        int val = en.getValue ();
        while (val != 0) {
            System.out.println (en.getKey ());
            val --;
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > mp = new LinkedHashMap < > ();
    List < Integer > res = new ArrayList < > ();
    int count = 1;
    for (int i = 0;
    i < arr.length; i ++) {
        if (! mp.containsKey (arr [i])) {
            mp.put (arr [i], count);
        } else {
            mp.put (arr [i], mp.get (arr [i]) + 1);
        }
    }
    if (! mp.containsValue (2)) {
        for (Integer ab : arr) res.add (ab);

        Collections.sort (res);
        Collections.reverse (res);
        System.out.println (res);
    } else {
        Set < Entry < Integer, Integer > > set = mp.entrySet ();
        List < Entry < Integer, Integer > > list = new ArrayList < > (set);
        Collections.sort (list, new Comparator < Entry < Integer, Integer > > () {
            @Override
            public int compare (Entry < Integer, Integer > obj1, Entry < Integer, Integer > obj2) {
                if (obj2.getValue () > obj1.getValue ()) return 1;

                if (obj2.getValue () < obj1.getValue ()) return - 1;
                else return 0;

            }}

        );
        for (Map.Entry < Integer, Integer > e : list) {
            for (int i = 1;
            i <= e.getValue (); i ++) res.add (e.getKey ());

        }
        System.out.println (res);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_51862367_5_40
11842984_52580911_3_42
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int arrTemp [] = {2, 2, 2, 1, 1, 4, 5, 6, 6, 7, 7, 7, 7};
    Arrays.sort (arrTemp);
    Integer [] [] sortedArray = new Integer [6] [2];
    int count = 0;
    sortedArray [count] [0] = arrTemp [0];
    sortedArray [count] [1] = 1;
    for (int i = 0;
    i < arrTemp.length - 1; i ++) {
        for (int j = 1;
        j < arrTemp.length; j ++) {
            if (arrTemp [i] == arrTemp [j]) {
                sortedArray [count] [1] = sortedArray [count] [1] + 1;
                i = j;
            } else {
                ++ count;
                sortedArray [count] [0] = arrTemp [j];
                sortedArray [count] [1] = 1;
                i = j;
            }
        }
    }
    Arrays.sort (sortedArray, new Comparator < Integer [] > () {
        @Override
        public int compare (Integer [] o1, Integer [] o2) {
            return o1 [1].compareTo (o2 [1]);
        }}

    );
    for (int row = 0;
    row < 6; row ++) {
        for (int col = 0;
        col < sortedArray [row] [1]; col ++) {
            System.out.print (sortedArray [row] [0] + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int r;
    int b [] = {1, 1, 1, 2, 1, 2, 3, 6, 6, 5};
    int i;
    int n = b.length;
    int k = 0;
    Arrays.sort (b);
    int [] a = new int [n + 1];
    for (r = 0; r < n; r ++) {
        a [r] = b [r];
    }
    a [r] = 1882737378;
    int c = 1;
    int in [] = new int [10];
    int [] e = new int [10];
    for (i = 0; i < n; i ++) {
        if (a [i] == a [i + 1]) c ++;
        else {
            e [k] = a [i];
            in [k] = c;
            k ++;
            c = 1;
        }
    }
    for (int f = 0;
    f < k; f ++) {
        for (int g = 0;
        g < k - f - 1; g ++) {
            if (in [g] > in [g + 1]) {
                int [] ans = swap (in [g], in [g + 1]);
                in [g] = ans [0];
                in [g + 1] = ans [1];
                int [] an = swap (e [g], e [g + 1]);
                e [g] = an [0];
                e [g + 1] = an [1];
            }
        }
    }
    int d = 0;
    for (int x = 0;
    x < k; x ++) {
        for (int y = 0;
        y < in [x]; y ++) {
            System.out.print (e [d]);
        }
        d ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_51862367_5_40
11842984_53325860_4_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int arrTemp [] = {2, 2, 2, 1, 1, 4, 5, 6, 6, 7, 7, 7, 7};
    Arrays.sort (arrTemp);
    Integer [] [] sortedArray = new Integer [6] [2];
    int count = 0;
    sortedArray [count] [0] = arrTemp [0];
    sortedArray [count] [1] = 1;
    for (int i = 0;
    i < arrTemp.length - 1; i ++) {
        for (int j = 1;
        j < arrTemp.length; j ++) {
            if (arrTemp [i] == arrTemp [j]) {
                sortedArray [count] [1] = sortedArray [count] [1] + 1;
                i = j;
            } else {
                ++ count;
                sortedArray [count] [0] = arrTemp [j];
                sortedArray [count] [1] = 1;
                i = j;
            }
        }
    }
    Arrays.sort (sortedArray, new Comparator < Integer [] > () {
        @Override
        public int compare (Integer [] o1, Integer [] o2) {
            return o1 [1].compareTo (o2 [1]);
        }}

    );
    for (int row = 0;
    row < 6; row ++) {
        for (int col = 0;
        col < sortedArray [row] [1]; col ++) {
            System.out.print (sortedArray [row] [0] + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Integer [] nums = {7, 3, 4, 3, 4, 3, 4, 3, 6, 5, 7};
    Map < Integer, Integer > m1;
    ArrayList < Integer > numbers = new ArrayList < Integer > (Arrays.asList (nums));
    List < Integer > values = new ArrayList < Integer > ();
    List < Integer > output = new ArrayList < Integer > ();
    m1 = new LinkedHashMap < Integer, Integer > ();
    for (int a : numbers) {
        if (m1.containsKey (a)) {
            int value = m1.get (a);
            m1.put (a, ++ value);
        } else {
            m1.put (a, 1);
        }
    }
    System.out.println (m1);
    for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
        values.add (entry.getValue ());
    }
    Collections.sort (values, Collections.reverseOrder ());
    System.out.println (values.toString ());
    for (int m = 0;
    m < values.size (); m ++) {
        for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
            if (entry.getValue ().equals (values.get (m))) {
                key = entry.getKey ();
                System.out.println ("Key is" + key);
                for (int k = values.get (m);
                k > 0; k --) {
                    output.add (key);
                }
                break;
            }
        }
        m1.remove (key);
    }
    System.out.println (output.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_51862367_5_40
11842984_53497463_1_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int arrTemp [] = {2, 2, 2, 1, 1, 4, 5, 6, 6, 7, 7, 7, 7};
    Arrays.sort (arrTemp);
    Integer [] [] sortedArray = new Integer [6] [2];
    int count = 0;
    sortedArray [count] [0] = arrTemp [0];
    sortedArray [count] [1] = 1;
    for (int i = 0;
    i < arrTemp.length - 1; i ++) {
        for (int j = 1;
        j < arrTemp.length; j ++) {
            if (arrTemp [i] == arrTemp [j]) {
                sortedArray [count] [1] = sortedArray [count] [1] + 1;
                i = j;
            } else {
                ++ count;
                sortedArray [count] [0] = arrTemp [j];
                sortedArray [count] [1] = 1;
                i = j;
            }
        }
    }
    Arrays.sort (sortedArray, new Comparator < Integer [] > () {
        @Override
        public int compare (Integer [] o1, Integer [] o2) {
            return o1 [1].compareTo (o2 [1]);
        }}

    );
    for (int row = 0;
    row < 6; row ++) {
        for (int col = 0;
        col < sortedArray [row] [1]; col ++) {
            System.out.print (sortedArray [row] [0] + " ");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > mp = new LinkedHashMap < > ();
    List < Integer > res = new ArrayList < > ();
    int count = 1;
    for (int i = 0;
    i < arr.length; i ++) {
        if (! mp.containsKey (arr [i])) {
            mp.put (arr [i], count);
        } else {
            mp.put (arr [i], mp.get (arr [i]) + 1);
        }
    }
    if (! mp.containsValue (2)) {
        for (Integer ab : arr) res.add (ab);

        Collections.sort (res);
        Collections.reverse (res);
        System.out.println (res);
    } else {
        Set < Entry < Integer, Integer > > set = mp.entrySet ();
        List < Entry < Integer, Integer > > list = new ArrayList < > (set);
        Collections.sort (list, new Comparator < Entry < Integer, Integer > > () {
            @Override
            public int compare (Entry < Integer, Integer > obj1, Entry < Integer, Integer > obj2) {
                if (obj2.getValue () > obj1.getValue ()) return 1;

                if (obj2.getValue () < obj1.getValue ()) return - 1;
                else return 0;

            }}

        );
        for (Map.Entry < Integer, Integer > e : list) {
            for (int i = 1;
            i <= e.getValue (); i ++) res.add (e.getKey ());

        }
        System.out.println (res);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_52580911_3_42
11842984_53325860_4_50
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int r;
    int b [] = {1, 1, 1, 2, 1, 2, 3, 6, 6, 5};
    int i;
    int n = b.length;
    int k = 0;
    Arrays.sort (b);
    int [] a = new int [n + 1];
    for (r = 0; r < n; r ++) {
        a [r] = b [r];
    }
    a [r] = 1882737378;
    int c = 1;
    int in [] = new int [10];
    int [] e = new int [10];
    for (i = 0; i < n; i ++) {
        if (a [i] == a [i + 1]) c ++;
        else {
            e [k] = a [i];
            in [k] = c;
            k ++;
            c = 1;
        }
    }
    for (int f = 0;
    f < k; f ++) {
        for (int g = 0;
        g < k - f - 1; g ++) {
            if (in [g] > in [g + 1]) {
                int [] ans = swap (in [g], in [g + 1]);
                in [g] = ans [0];
                in [g + 1] = ans [1];
                int [] an = swap (e [g], e [g + 1]);
                e [g] = an [0];
                e [g + 1] = an [1];
            }
        }
    }
    int d = 0;
    for (int x = 0;
    x < k; x ++) {
        for (int y = 0;
        y < in [x]; y ++) {
            System.out.print (e [d]);
        }
        d ++;
    }
}
----------------------------------------

public static void main (String [] args) {
    Integer [] nums = {7, 3, 4, 3, 4, 3, 4, 3, 6, 5, 7};
    Map < Integer, Integer > m1;
    ArrayList < Integer > numbers = new ArrayList < Integer > (Arrays.asList (nums));
    List < Integer > values = new ArrayList < Integer > ();
    List < Integer > output = new ArrayList < Integer > ();
    m1 = new LinkedHashMap < Integer, Integer > ();
    for (int a : numbers) {
        if (m1.containsKey (a)) {
            int value = m1.get (a);
            m1.put (a, ++ value);
        } else {
            m1.put (a, 1);
        }
    }
    System.out.println (m1);
    for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
        values.add (entry.getValue ());
    }
    Collections.sort (values, Collections.reverseOrder ());
    System.out.println (values.toString ());
    for (int m = 0;
    m < values.size (); m ++) {
        for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
            if (entry.getValue ().equals (values.get (m))) {
                key = entry.getKey ();
                System.out.println ("Key is" + key);
                for (int k = values.get (m);
                k > 0; k --) {
                    output.add (key);
                }
                break;
            }
        }
        m1.remove (key);
    }
    System.out.println (output.toString ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_52580911_3_42
11842984_53497463_1_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    int r;
    int b [] = {1, 1, 1, 2, 1, 2, 3, 6, 6, 5};
    int i;
    int n = b.length;
    int k = 0;
    Arrays.sort (b);
    int [] a = new int [n + 1];
    for (r = 0; r < n; r ++) {
        a [r] = b [r];
    }
    a [r] = 1882737378;
    int c = 1;
    int in [] = new int [10];
    int [] e = new int [10];
    for (i = 0; i < n; i ++) {
        if (a [i] == a [i + 1]) c ++;
        else {
            e [k] = a [i];
            in [k] = c;
            k ++;
            c = 1;
        }
    }
    for (int f = 0;
    f < k; f ++) {
        for (int g = 0;
        g < k - f - 1; g ++) {
            if (in [g] > in [g + 1]) {
                int [] ans = swap (in [g], in [g + 1]);
                in [g] = ans [0];
                in [g + 1] = ans [1];
                int [] an = swap (e [g], e [g + 1]);
                e [g] = an [0];
                e [g + 1] = an [1];
            }
        }
    }
    int d = 0;
    for (int x = 0;
    x < k; x ++) {
        for (int y = 0;
        y < in [x]; y ++) {
            System.out.print (e [d]);
        }
        d ++;
    }
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > mp = new LinkedHashMap < > ();
    List < Integer > res = new ArrayList < > ();
    int count = 1;
    for (int i = 0;
    i < arr.length; i ++) {
        if (! mp.containsKey (arr [i])) {
            mp.put (arr [i], count);
        } else {
            mp.put (arr [i], mp.get (arr [i]) + 1);
        }
    }
    if (! mp.containsValue (2)) {
        for (Integer ab : arr) res.add (ab);

        Collections.sort (res);
        Collections.reverse (res);
        System.out.println (res);
    } else {
        Set < Entry < Integer, Integer > > set = mp.entrySet ();
        List < Entry < Integer, Integer > > list = new ArrayList < > (set);
        Collections.sort (list, new Comparator < Entry < Integer, Integer > > () {
            @Override
            public int compare (Entry < Integer, Integer > obj1, Entry < Integer, Integer > obj2) {
                if (obj2.getValue () > obj1.getValue ()) return 1;

                if (obj2.getValue () < obj1.getValue ()) return - 1;
                else return 0;

            }}

        );
        for (Map.Entry < Integer, Integer > e : list) {
            for (int i = 1;
            i <= e.getValue (); i ++) res.add (e.getKey ());

        }
        System.out.println (res);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11842984_53325860_4_50
11842984_53497463_1_40
Title: Sort array based on count of occurrences in ascending order 
----------------------------------------

public static void main (String [] args) {
    Integer [] nums = {7, 3, 4, 3, 4, 3, 4, 3, 6, 5, 7};
    Map < Integer, Integer > m1;
    ArrayList < Integer > numbers = new ArrayList < Integer > (Arrays.asList (nums));
    List < Integer > values = new ArrayList < Integer > ();
    List < Integer > output = new ArrayList < Integer > ();
    m1 = new LinkedHashMap < Integer, Integer > ();
    for (int a : numbers) {
        if (m1.containsKey (a)) {
            int value = m1.get (a);
            m1.put (a, ++ value);
        } else {
            m1.put (a, 1);
        }
    }
    System.out.println (m1);
    for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
        values.add (entry.getValue ());
    }
    Collections.sort (values, Collections.reverseOrder ());
    System.out.println (values.toString ());
    for (int m = 0;
    m < values.size (); m ++) {
        for (Map.Entry < Integer, Integer > entry : m1.entrySet ()) {
            if (entry.getValue ().equals (values.get (m))) {
                key = entry.getKey ();
                System.out.println ("Key is" + key);
                for (int k = values.get (m);
                k > 0; k --) {
                    output.add (key);
                }
                break;
            }
        }
        m1.remove (key);
    }
    System.out.println (output.toString ());
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {2, 5, 2, 6, - 1, 9999999, 5, 8, 8, 8};
    Map < Integer, Integer > mp = new LinkedHashMap < > ();
    List < Integer > res = new ArrayList < > ();
    int count = 1;
    for (int i = 0;
    i < arr.length; i ++) {
        if (! mp.containsKey (arr [i])) {
            mp.put (arr [i], count);
        } else {
            mp.put (arr [i], mp.get (arr [i]) + 1);
        }
    }
    if (! mp.containsValue (2)) {
        for (Integer ab : arr) res.add (ab);

        Collections.sort (res);
        Collections.reverse (res);
        System.out.println (res);
    } else {
        Set < Entry < Integer, Integer > > set = mp.entrySet ();
        List < Entry < Integer, Integer > > list = new ArrayList < > (set);
        Collections.sort (list, new Comparator < Entry < Integer, Integer > > () {
            @Override
            public int compare (Entry < Integer, Integer > obj1, Entry < Integer, Integer > obj2) {
                if (obj2.getValue () > obj1.getValue ()) return 1;

                if (obj2.getValue () < obj1.getValue ()) return - 1;
                else return 0;

            }}

        );
        for (Map.Entry < Integer, Integer > e : list) {
            for (int i = 1;
            i <= e.getValue (); i ++) res.add (e.getKey ());

        }
        System.out.println (res);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11858348_11858629_59_74
11858348_11859572_31_42
Title: Repainting a JPanel in a JScrollPane 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Rectangle clip = g.getClipBounds ();
    int startX = clip.x - (clip.x % TILE_SIZE);
    int startY = clip.y - (clip.y % TILE_SIZE);
    for (int x = startX;
    x < clip.x + clip.width; x += TILE_SIZE) {
        for (int y = startY;
        y < clip.y + clip.height; y += TILE_SIZE) {
            if (getTile (x / TILE_SIZE, y / TILE_SIZE)) {
                g.setColor (Color.GREEN);
            } else {
                g.setColor (Color.RED);
            }
            g.fillRect (x, y, TILE_SIZE - 1, TILE_SIZE - 1);
        }
    }
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    for (int i = 0;
    i < across; i ++) {
        for (int j = 0;
        j < down; j ++) {
            g.setColor (color);
            for (int k = 0;
            k < 5; k ++) {
                g.drawRect (tiles [i] [j].x + k, tiles [i] [j].y + k, tiles [i] [j].side - k * 2, tiles [i] [j].side - 2 * k);
            }
        }
    }
    updateScrollPane ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11870416_11870558_26_89
11870416_11895709_24_32
Title: CombinedDomainXYPlot not rescaling domain axis 
----------------------------------------

public static void main (String [] args) {
    XYSeriesCollection data = new XYSeriesCollection ();
    int max = rand.nextInt (2) + 2;
    for (int i = 0;
    i < max; i ++) {
        data.addSeries (generateSeries ("Series" + (i + 1)));
    }
    final XYItemRenderer renderer1 = new StandardXYItemRenderer ();
    final XYPlot plot1 = new XYPlot (data, null, new DateAxis ("Dates"), renderer1);
    data = new XYSeriesCollection ();
    for (int i = 0;
    i < max; i ++) {
        data.addSeries (generateSeries ("Series" + (i + 1)));
    }
    final XYPlot plot2 = new XYPlot (data, null, new NumberAxis ("Numbers"), renderer1);
    final CombinedDomainXYPlot plot = new CombinedDomainXYPlot (new NumberAxis ("Domain"));
    plot.setGap (10.0);
    plot.add (plot1, 1);
    plot.add (plot2, 1);
    plot.setOrientation (PlotOrientation.VERTICAL);
    final JFreeChart chart = new JFreeChart ("CombinedDomainXYPlot Demo", JFreeChart.DEFAULT_TITLE_FONT, plot, true);
    chart.getLegend ().setPosition (RectangleEdge.RIGHT);
    chart.addChangeListener (new ChartChangeListener () {
        boolean changed = false;
        @Override
        public void chartChanged (ChartChangeEvent event) {
            if (! changed) {
            } else {
                changed = false;
            }
        }}

    );
    ChartPanel panel = new ChartPanel (chart);
    JPanel panel2 = new JPanel (new BorderLayout (0, 10));
    panel2.add (panel, BorderLayout.CENTER);
    JButton b = new JButton ("Click");
    b.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent e) {
            CombinedDomainXYPlot plot = (CombinedDomainXYPlot) chart.getXYPlot ();
            List l = plot.getSubplots ();
            int index = rand.nextInt (plot1.getSeriesCount () + plot2.getSeriesCount ());
            boolean b = renderer1.isSeriesVisible (index);
            renderer1.setSeriesVisible (index, false);
        }}

    );
    panel2.add (b, BorderLayout.NORTH);
    panel2.setVisible (true);
    JFrame frame = new JFrame ("dsadsa");
    frame.add (panel2);
    frame.setSize (800, 600);
    frame.setVisible (true);
}
----------------------------------------

public static void main (String [] args) {
    EventQueue.invokeLater (new Runnable () {
        @Override
        public void run () {
            init ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11883788_11884176_12_21
11883788_11884429_1_17
Title: Memory issues with String.split() 
----------------------------------------

public static void main (String [] args) {
    while (true) {
        String a = constructLongString ();
        head.add (a.split (" ") [0]);
        if (i % 1000 == 0) System.out.println ("" + i);

        System.gc ();
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    StringBuilder sb = new StringBuilder ();
    for (int i = 0;
    i < 99999; i ++) {
        sb.append (Math.random ());
    }
    long begin = System.currentTimeMillis ();
    String string = sb.toString ();
    sb = null;
    System.gc ();
    long startFreeMem = Runtime.getRuntime ().freeMemory ();
    String [] strings = string.split ("(?=[0-5])");
    long endFreeMem = Runtime.getRuntime ().freeMemory ();
    long execution = System.currentTimeMillis () - begin;
    System.out.println ("input length = " + string.length () + "\nnumber of strings after split = " + strings.length + "\nmemory consumed due to split = " + (startFreeMem - endFreeMem) + "\nexecution time = " + execution + "ms");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11890128_11894517_41_50
11890128_11894517_59_87
Title: Re-firing a consumed event in JavaFX 
----------------------------------------

public void handle (KeyEvent event) {
    if (event.getTarget () instanceof Node) {
        if (! processedEventQueue.contains (event)) {
            unprocessedEventQueue.add ((KeyEvent) event.clone ());
            event.consume ();
        } else {
            processedEventQueue.remove (event);
        }
    }
}
----------------------------------------

public void handle (Event timeEvent) {
    final Iterator < KeyEvent > uei = unprocessedEventQueue.iterator ();
    final List < KeyEvent > refireEvents = new ArrayList ();
    while (uei.hasNext ()) {
        KeyEvent event = uei.next ();
        String keychar = event.getCharacter ();
        if ("barcode".contains (keychar)) {
            forBarCode.setText (forBarCode.getText () + keychar);
        } else {
            forTextField.setText (forTextField.getText () + keychar);
            refireEvents.add (event);
        }
    }
    unprocessedEventQueue.clear ();
    final Iterator < KeyEvent > rei = refireEvents.iterator ();
    while (rei.hasNext ()) {
        KeyEvent event = rei.next ();
        processedEventQueue.add (event);
        if (event.getTarget () instanceof Node) {
            ((Node) event.getTarget ()).fireEvent (event);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11893462_11895551_2_17
11893462_11908259_7_35
Title: How to input data into MySQL from Eclipse 
----------------------------------------

public static void main (String [] args) throws Exception {
    Class.forName ("com.mysql.jdbc.Driver");
    try {
        Connection con = DriverManager.getConnection ("jdbc:mysql://localhost:3306/database", "root", "root");
        PreparedStatement stmt = con.prepareStatement ("INSERT INTO 'database'.'Table'(Account_ID,First_Name,Last_Name) VALUES (?,?,?)");
        stmt.setString (1, "hello12");
        stmt.setString (2, "Ed");
        stmt.setString (3, "Lee");
        stmt.executeUpdate ();
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        stmt.close ();
        con.close ();
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    Class.forName ("com.mysql.jdbc.Driver");
    Connection con = null;
    PreparedStatement stmt = null;
    try {
        con = DriverManager.getConnection ("jdbc:mysql://localhost:3306/database", "root", "root");
        stmt = con.prepareStatement ("INSERT INTO 'database'.'Table'(Account_ID,First_Name,Last_Name) VALUES (?,?,?)");
        stmt.setString (1, "hello12");
        stmt.setString (2, "Ed");
        stmt.setString (3, "Lee");
        stmt.executeUpdate ();
        conn.commit ();
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        if (stmt != null) {
            try {
                stmt.close ();
            } catch (SQLException ex) {
            }
        }
        if (con != null) {
            try {
                con.close ();
            } catch (SQLException ex) {
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11897593_12241408_35_43
11897593_12241408_65_73
Title: HashMap saving with ObjectOutputStream 
----------------------------------------

public SerializableLocation (Location l) {
    this.world = l.getWorld ().getName ();
    this.uuid = l.getWorld ().getUID ().toString ();
    this.x = l.getX ();
    this.y = l.getY ();
    this.z = l.getZ ();
    this.yaw = l.getYaw ();
    this.pitch = l.getPitch ();
}
----------------------------------------

public SerializableLocation (Map < String, Object > map) {
    this.world = (String) map.get ("world");
    this.uuid = (String) map.get ("uuid");
    this.x = (Double) map.get ("x");
    this.y = (Double) map.get ("y");
    this.z = (Double) map.get ("z");
    this.yaw = ((Float) map.get ("yaw")).floatValue ();
    this.pitch = ((Float) map.get ("pitch")).floatValue ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11899395_11899397_1_16
11899395_11899798_1_15
Title: Synchronize on Lazy Load Getter 
----------------------------------------

public DB getDB () {
    synchronized (_db) {
        if (_db == null) {
            _db = getDBConnection ();
        } else if (! _db.isConnectionValid ()) {
            _db.close ();
            _db = getDBConnection ();
        }

    }
    return _db;
}
----------------------------------------

public DB getDB () {
    synchronized (this) {
        if (_db == null) {
            _db = getDBConnection ();
        } else if (! _db.isConnectionValid ()) {
            _db.close ();
            _db = getDBConnection ();
        }

        return _db;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11917938_11919726_1_46
11917938_12158151_9_40
Title: JPanel repaint from another class 
----------------------------------------

public void paintComponent (Graphics g) {
    super.paintComponent (g);
    System.out.println ("in paint component");
    Graphics2D graphics = (Graphics2D) g.create ();
    try {
        Rectangle back_rect = new Rectangle (0, 0, getWidth (), getHeight ());
        graphics.setColor (Color.GREEN);
        graphics.fill (back_rect);
        graphics.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
        for (int pos = 0;
        pos < triangles.size (); pos ++) {
            Point [] current = triangles.get (pos);
            ArrayList < Point > current_triangle = new ArrayList < Point > (3);
            current_triangle.add (current [0]);
            current_triangle.add (current [1]);
            current_triangle.add (current [2]);
            drawRegion (graphics, current_triangle);
        }
    } finally {
        graphics.dispose ();
    }
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    int x = (getWidth () - image.getWidth ()) / 2;
    int y = (getHeight () - image.getHeight ()) / 2;
    g.drawImage (image, x, y, this);
    Stroke drawingStroke = new BasicStroke (2);
    Graphics2D graph = (Graphics2D) g;
    graph.setStroke (drawingStroke);
    graph.setPaint (Color.black);
    for (int p = 0;
    p < triangles.size (); p ++) {
        Point [] current_triangles = triangles.get (p);
        for (int triangle = 0;
        triangle < current_triangles.length; triangle ++) {
            Point current = current_triangles [triangle];
            Point next;
            if (triangle == current_triangles.length - 1) next = current_triangles [0];
            else next = current_triangles [triangle + 1];

            Line2D line = new Line2D.Double (current.x, current.y, next.x, next.y);
            graph.draw (line);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11921616_11921749_11_19
11921616_22222404_9_54
Title: Grid walking algorithm code correction 
----------------------------------------

public static void main (String [] args) {
    try {
        calculate (pos, totake);
        System.out.println (count % 1000000007);
    } catch (Exception e) {
        System.out.println (e);
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws FileNotFoundException {
    String filename = "src/testcases.txt";
    File file = new File (filename);
    Scanner in = new Scanner (file);
    int T = in.nextInt ();
    for (int t = 0;
    t < 1; t ++) {
        int N = in.nextInt ();
        int M = in.nextInt ();
        System.out.println ("M=" + M);
        int [] X = new int [N];
        long max = 1000000007;
        int [] D = new int [N];
        for (int i = 0;
        i < N; i ++) X [i] = in.nextInt ();

        for (int i = 0;
        i < N; i ++) D [i] = in.nextInt ();

        int Dmax = D [0];
        int Dtotal = 1;
        for (int i = 0;
        i < N; i ++) if (Dmax < D [i]) Dmax = D [i];

        for (int i = 0;
        i < N; i ++) X [i] --;

        for (int i = 0;
        i < N; i ++) Dtotal *= D [i];

        long [] mainarray = new long [Dtotal];
        long [] mainarraynext = new long [Dtotal];
        int [] [] ways = new int [N] [Dmax];
        set (X, mainarray, D, 1);
        int temp [] = new int [N];
        for (int h = 0;
        h < 10; h ++) {
            for (int j = 0;
            j < Dtotal; j ++) {
                mainarraynext [j] = getsum (inverse (j, D), mainarray, D);
            }
            for (int j = 0;
            j < Dtotal; j ++) {
                mainarray [j] = mainarraynext [j];
                mainarray [j] %= max;
            }
            System.out.println (Arrays.toString (mainarray));
        }
        long finalsum = 0;
        for (int j = 0;
        j < Dtotal; j ++) {
            finalsum += mainarray [j];
        }
        System.out.println (finalsum);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11934045_11939798_12_29
11934045_32308669_12_38
Title: How to add empty row in GridPane in JavaFx? 
----------------------------------------

public void start (final Stage stage) throws Exception {
    final Label label1 = new Label ("Label 1");
    final Label label2 = new Label ("Label 2");
    final Label label3 = new Label ("Label 3");
    final Pane spring = new Pane ();
    spring.minHeightProperty ().bind (label1.heightProperty ());
    final GridPane layout = new GridPane ();
    layout.add (label1, 0, 0);
    layout.add (spring, 0, 1);
    layout.add (label2, 0, 2);
    layout.add (label3, 0, 3);
    layout.setPrefHeight (100);
    stage.setScene (new Scene (layout));
    stage.show ();
}
----------------------------------------

public void start (Stage stage) {
    VBox root = new VBox ();
    GridPane gridPane = new GridPane ();
    gridPane.add (new Label ("First"), 0, 0);
    gridPane.add (new Label ("Second"), 0, 2);
    gridPane.add (new Label ("Third"), 0, 3);
    for (int i = 0;
    i <= 3; i ++) {
        RowConstraints con = new RowConstraints ();
        con.setPrefHeight (20);
        gridPane.getRowConstraints ().add (con);
    }
    root.getChildren ().add (gridPane);
    Scene scene = new Scene (root);
    stage.setScene (scene);
    stage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11942118_17089654_3_15
11942118_43911010_3_11
Title: How do you get GSON to omit null or empty objects and empty arrays and lists? 
----------------------------------------

public JsonElement serialize (List < ? > src, Type typeOfSrc, JsonSerializationContext context) {
    if (src == null || src.isEmpty ()) return null;

    JsonArray array = new JsonArray ();
    for (Object child : src) {
        JsonElement element = context.serialize (child);
        array.add (element);
    }
    return array;
}
----------------------------------------

public JsonElement serialize (Map < ?, ? > src, Type typeOfSrc, JsonSerializationContext context) {
    if (src == null || src.isEmpty ()) return null;

    JsonObject obj = new JsonObject ();
    for (Map.Entry < ?, ? > entry : src.entrySet ()) {
        obj.add (entry.getKey ().toString (), context.serialize (entry.getValue ()));
    }
    return obj;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11948258_11948833_1_10
11948258_11948869_1_10
Title: Clearing data from one JTable is also deleting the another JTable 
----------------------------------------

public void copyAll () {
    TableModel tableAModel = tableA.getModel (), tableModelB;
    Vector tableModelBDataVector = ((DefaultTableModel) tableAModel).getDataVector ();
    int tableModelAColumnCount = tableAModel.getColumnCount ();
    Vector < String > tableModelAColumnVector = new Vector < String > (tableModelAColumnCount);
    for (int i = 0;
    i < tableModelAColumnCount; i ++) tableModelAColumnVector.add (tableAModel.getColumnName (i));

    tableModelB = new DefaultTableModel ((Vector) tableModelBDataVector.clone (), (Vector) tableModelAColumnVector.clone ());
    tableB.setModel (tableModelB);
}
----------------------------------------

public void copyAll () {
    final TableModel tableAModel = tableA.getModel ();
    final DefaultTableModel copy = new DefaultTableModel (tableAModel.getRowCount (), 0);
    for (int column = 0;
    column < tableAModel.getColumnCount (); column ++) {
        copy.addColumn (tableAModel.getColumnName (column));
        for (int row = 0;
        row < tableAModel.getRowCount (); row ++) copy.setValueAt (tableAModel.getValueAt (row, column), row, column);

    }
    tableB.setModel (copy);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11958132_11958307_295_307
11958132_11958307_309_333
Title: Hadoop Writable for Date/Calendar 
----------------------------------------

public static MyCustomWritable fromJson (String source) {
    MyCustomWritable obj = null;
    try {
        JSONObject jsonObj = new JSONObject (source);
        obj = fromJson (jsonObj);
    } catch (JSONException e) {
        System.out.println (e.toString ());
    }
    return obj;
}
----------------------------------------

public static MyCustomWritable fromJson (JSONObject jsonObj) {
    MyCustomWritable obj = new MyCustomWritable ();
    try {
        if (jsonObj.has ("date")) {
            obj.setDate (new Date (jsonObj.getLong ("date")));
        }
        if (jsonObj.has ("count")) {
            obj.setCount (jsonObj.getInt ("count"));
        }
        if (jsonObj.has ("name")) {
            obj.setName (jsonObj.getString ("name"));
        }
    } catch (JSONException e) {
        System.out.println (e.toString ());
        obj = null;
    }
    return obj;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11959758_11959928_35_55
11959758_21778764_1_21
Title: Java: maintaining aspect ratio of JPanel background image 
----------------------------------------

@Override
protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    double scaleFactor = Math.min (1d, getScaleFactorToFit (new Dimension (image.getWidth (), image.getHeight ()), getSize ()));
    int scaleWidth = (int) Math.round (image.getWidth () * scaleFactor);
    int scaleHeight = (int) Math.round (image.getHeight () * scaleFactor);
    Image scaled = image.getScaledInstance (scaleWidth, scaleHeight, Image.SCALE_SMOOTH);
    int width = getWidth () - 1;
    int height = getHeight () - 1;
    int x = (width - scaled.getWidth (this)) / 2;
    int y = (height - scaled.getHeight (this)) / 2;
    g.drawImage (scaled, x, y, this);
}
----------------------------------------

@Override
protected void paintComponent (Graphics g) {
    Graphics2D g2d = (Graphics2D) g;
    super.paintComponent (g);
    double scaleFactor = Math.min (1d, getScaleFactorToFit (new Dimension (image.getWidth (), image.getHeight ()), getSize ()));
    int scaleWidth = (int) Math.round (image.getWidth () * scaleFactor);
    int scaleHeight = (int) Math.round (image.getHeight () * scaleFactor);
    int width = getWidth () - 1;
    int height = getHeight () - 1;
    int x = (width - scaleWidth) / 2;
    int y = (height - scaleHeight) / 2;
    g2d.drawImage (image, x, y, scaleWidth, scaleHeight, this);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11959758_11959928_35_55
11959758_30606036_11_37
Title: Java: maintaining aspect ratio of JPanel background image 
----------------------------------------

@Override
protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    double scaleFactor = Math.min (1d, getScaleFactorToFit (new Dimension (image.getWidth (), image.getHeight ()), getSize ()));
    int scaleWidth = (int) Math.round (image.getWidth () * scaleFactor);
    int scaleHeight = (int) Math.round (image.getHeight () * scaleFactor);
    Image scaled = image.getScaledInstance (scaleWidth, scaleHeight, Image.SCALE_SMOOTH);
    int width = getWidth () - 1;
    int height = getHeight () - 1;
    int x = (width - scaled.getWidth (this)) / 2;
    int y = (height - scaled.getHeight (this)) / 2;
    g.drawImage (scaled, x, y, this);
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    if (image != null) {
        int imgWidth, imgHeight;
        double contRatio = (double) getWidth () / (double) getHeight ();
        double imgRatio = (double) image.getWidth (this) / (double) image.getHeight (this);
        if (contRatio < imgRatio) {
            imgWidth = getWidth ();
            imgHeight = (int) (getWidth () / imgRatio);
        } else {
            imgWidth = (int) (getHeight () * imgRatio);
            imgHeight = getHeight ();
        }
        int x = (int) (((double) getWidth () / 2) - ((double) imgWidth / 2));
        int y = (int) (((double) getHeight () / 2) - ((double) imgHeight / 2));
        g.drawImage (image, x, y, imgWidth, imgHeight, this);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11959758_21778764_1_21
11959758_30606036_11_37
Title: Java: maintaining aspect ratio of JPanel background image 
----------------------------------------

@Override
protected void paintComponent (Graphics g) {
    Graphics2D g2d = (Graphics2D) g;
    super.paintComponent (g);
    double scaleFactor = Math.min (1d, getScaleFactorToFit (new Dimension (image.getWidth (), image.getHeight ()), getSize ()));
    int scaleWidth = (int) Math.round (image.getWidth () * scaleFactor);
    int scaleHeight = (int) Math.round (image.getHeight () * scaleFactor);
    int width = getWidth () - 1;
    int height = getHeight () - 1;
    int x = (width - scaleWidth) / 2;
    int y = (height - scaleHeight) / 2;
    g2d.drawImage (image, x, y, scaleWidth, scaleHeight, this);
}
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    if (image != null) {
        int imgWidth, imgHeight;
        double contRatio = (double) getWidth () / (double) getHeight ();
        double imgRatio = (double) image.getWidth (this) / (double) image.getHeight (this);
        if (contRatio < imgRatio) {
            imgWidth = getWidth ();
            imgHeight = (int) (getWidth () / imgRatio);
        } else {
            imgWidth = (int) (getHeight () * imgRatio);
            imgHeight = getHeight ();
        }
        int x = (int) (((double) getWidth () / 2) - ((double) imgWidth / 2));
        int y = (int) (((double) getHeight () / 2) - ((double) imgHeight / 2));
        g.drawImage (image, x, y, imgWidth, imgHeight, this);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11979978_11980077_10_23
11979978_12023979_1_19
Title: HTML table id and class id 
----------------------------------------

public static void main (String args []) {
    Document doc;
    try {
        doc = Jsoup.connect ("http://en.wikipedia.org/wiki/States_and_territories_of_India").get ();
        Elements newsHeadlines = doc.select ("table.wikitable").get (0).select ("td:eq(0) a");
        System.out.println (newsHeadlines.html ());
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Document doc = Jsoup.connect ("http://en.wikipedia.org/wiki/States_and_territories_of_India").get ();
    Elements tables = doc.select ("table");
    for (Element table : tables) {
        Element tableCaption = table.getElementsByTag ("big").first ();
        if (tableCaption != null && tableCaption.text ().equals ("States of India")) {
            Document statesDoc = Jsoup.parse (table.toString ());
            Elements states = statesDoc.select ("tr td:eq(0)");
            for (Element state : states) {
                System.out.println (state.text ().replaceAll ("\\[\\d\\]", ""));
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
11997326_11998743_3_10
11997326_12005034_4_13
Title: How to find the permutation of a sort in Java 
----------------------------------------

public static void main (String [] args) {
    int [] arr = {3, 2, 4, 6, 5};
    TreeMap map = new TreeMap ();
    for (int i = 0;
    i < arr.length; i ++) {
        map.put (arr [i], i);
    }
    System.out.println (Arrays.toString (map.values ().toArray ()));
}
----------------------------------------

public static void main (String [] args) {
    int [] data = {0, 3, 2, 4, 6, 5, 10};
    int i, rangeHigh = 10;
    int [] rank = new int [rangeHigh + 1];
    for (i = 0; i < data.length; ++ i) ++ rank [data [i]];

    for (i = 1; i < rank.length; ++ i) rank [i] += rank [i - 1];

    for (i = 0; i < data.length; ++ i) System.out.print ((rank [data [i]] - 1) + " ");

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12011832_12011915_2_29
12011832_12012715_2_35
Title: filling multidimensional array with nested for loops 
----------------------------------------

public static void main (String [] args) {
    String [] AA = {"DDDD", "HHHH", "ZZZZ"};
    String [] BB = {"DDDD", "HHHH", "ZZZZ"};
    String [] CC = {"DDDD", "HHHH", "ZZZZ"};
    String [] DD = {"DDDD", "HHHH", "ZZZZ"};
    String [] [] x2Darray = new String [AA.length * BB.length * CC.length * DD.length] [4];
    for (int i = 0;
    i < AA.length; i ++) {
        for (int j = 0;
        j < BB.length; j ++) {
            for (int k = 0;
            k < CC.length; k ++) {
                for (int L = 0;
                L < DD.length; L ++) {
                    String [] temp = {AA [i], BB [j], CC [k], DD [L]};
                    x2Darray [((i * BB.length + j) * CC.length + k) * DD.length + L] = temp;
                }
            }
        }
    }
    StringBuilder s = new StringBuilder ();
    for (String [] row : x2Darray) {
        for (String x : row) {
            s.append (x);
            s.append (' ');
        }
        s.append ("\n");
    }
    System.out.println (s);
}
----------------------------------------

public static void main (String [] args) {
    String [] AA = {"1", "2", "3"};
    String [] BB = {"4", "5", "6"};
    String [] CC = {"7", "8", "9"};
    String [] DD = {"10", "11", "12"};
    String [] [] combinations = new String [AA.length * BB.length * CC.length * DD.length] [4];
    int currentRow = 0;
    for (int i = 0;
    i < AA.length; i ++) {
        for (int j = 0;
        j < BB.length; j ++) {
            for (int k = 0;
            k < CC.length; k ++) {
                for (int l = 0;
                l < DD.length; l ++) {
                    combinations [currentRow] [0] = AA [i];
                    combinations [currentRow] [1] = BB [j];
                    combinations [currentRow] [2] = CC [k];
                    combinations [currentRow] [3] = DD [l];
                    currentRow ++;
                }
            }
        }
    }
    for (int i = 0;
    i < AA.length * BB.length * CC.length * DD.length; i ++) {
        System.out.println ();
        for (int j = 0;
        j < 4; j ++) {
            System.out.print (combinations [i] [j] + " ");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12017710_12017785_1_29
12017710_12017880_9_30
Title: VERY simple user login system in Java 
----------------------------------------

public static void main (String [] args) {
    BufferedReader rdr = null;
    try {
        rdr = new BufferedReader (new FileReader ("passwords.txt"));
        String name = rdr.readLine ();
        String password = rdr.readLine ();
        while (name != null && password != null) {
            System.out.println (name);
            System.out.println (password);
            name = rdr.readLine ();
            password = rdr.readLine ();
        }
    } catch (FileNotFoundException e) {
        System.out.println ("Failed to open file.");
        e.printStackTrace ();
    } catch (IOException e) {
        System.out.println ("Failed to correctly read file.");
        e.printStackTrace ();
    } finally {
        if (rdr != null) {
            try {
                rdr.close ();
            } catch (IOException e) {
                System.out.println ("Failed to close file.");
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Scanner s1, s2;
    s1 = new Scanner (new FileInputStream ("d:\\log.txt"));
    s2 = new Scanner (System.in);
    boolean flag = false;
    String name, pword, n, p;
    System.out.println ("Enter name:");
    n = s2.next ();
    System.out.println ("Enter password:");
    p = s2.next ();
    while (s1.hasNext ()) {
        name = s1.next ();
        pword = s1.next ();
        if (n.equals (name) && p.equals (pword)) {
            System.out.println ("You are logged in.");
            flag = true;
            break;
        }
    }
    if (! flag) System.out.println ("Incorrect password.");

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12021938_12021989_7_20
12021938_12022558_19_49
Title: Java have thread return something to main thread 
----------------------------------------

public ResultSet perform () {
    Connection conn = null;
    try {
        Class.forName ("com.mysql.jdbc.Driver").newInstance ();
        conn = DriverManager.getConnection ("jdbc:mysql://localhost/lob/?user=root&password=");
        Statement s = conn.createStatement ();
        ResultSet rs = s.executeQuery (Utils.selectQuery);
        return rs;
    } catch (SQLException | InstantiationException | IllegalAccessException | ClassNotFoundException e) {
        e.printStackTrace ();
        return null;
    }
}
----------------------------------------

public ResultSet perform () throws InstantiationException, IllegalAccessException, SQLException {
    Connection conn = null;
    try {
        Class.forName ("org.sqlite.JDBC");
        try {
            conn = DriverManager.getConnection ("jdbc:sqlite:C:\\SqlLite\\EMPLOYEE.db");
        } catch (Exception e) {
            e.printStackTrace ();
        }
        Statement s = null;
        try {
            s = conn.createStatement ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
        ResultSet rs = null;
        try {
            rs = s.executeQuery (Utils.selectQuery);
        } catch (Exception e) {
            e.printStackTrace ();
        }
        return rs;
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
        return null;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12021938_12022558_19_49
12021938_12022616_22_34
Title: Java have thread return something to main thread 
----------------------------------------

public ResultSet perform () throws InstantiationException, IllegalAccessException, SQLException {
    Connection conn = null;
    try {
        Class.forName ("org.sqlite.JDBC");
        try {
            conn = DriverManager.getConnection ("jdbc:sqlite:C:\\SqlLite\\EMPLOYEE.db");
        } catch (Exception e) {
            e.printStackTrace ();
        }
        Statement s = null;
        try {
            s = conn.createStatement ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
        ResultSet rs = null;
        try {
            rs = s.executeQuery (Utils.selectQuery);
        } catch (Exception e) {
            e.printStackTrace ();
        }
        return rs;
    } catch (ClassNotFoundException e) {
        e.printStackTrace ();
        return null;
    }
}
----------------------------------------

public ResultSet perform () {
    Connection conn = null;
    try {
        Class.forName ("com.mysql.jdbc.Driver").newInstance ();
        conn = DriverManager.getConnection ("jdbc:mysql://localhost/lob/?user=root&password=");
        Statement s = conn.createStatement ();
        return s.executeQuery (Utils.selectQuery);
    } catch (SQLException | InstantiationException | IllegalAccessException | ClassNotFoundException e) {
        e.printStackTrace ();
        return null;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12025055_14621950_110_121
12025055_14621950_472_495
Title: How should I time highlighting of text with audio for a karaoke like application in javaFx 
----------------------------------------

public void actionPerformed (ActionEvent ae) {
    try {
        ColoredTextTest.start ();
    } catch (InterruptedException ex) {
        Logger.getLogger (newh.class.getName ()).log (Level.SEVERE, null, ex);
    } catch (InvocationTargetException ex) {
        Logger.getLogger (newh.class.getName ()).log (Level.SEVERE, null, ex);
    }
    setVisible (false);
    jar.setVisible (false);
}
----------------------------------------

public void actionPerformed (ActionEvent actionEvent) {
    System.out.println ("index" + stringIndex);
    doc.setCharacterAttributes (stringIndex, 1, jTextPane1.getStyle ("Red"), true);
    stringIndex ++;
    try {
        if (stringIndex >= doc.getLength () || doc.getText (stringIndex, 1).equals (" ") || doc.getText (stringIndex, 1).equals ("\n")) {
            index ++;
        }
    } catch (BadLocationException ex) {
        Logger.getLogger (ColoredTextTest.class.getName ()).log (Level.SEVERE, null, ex);
    }
    if (index < 600) {
        double delay = newh.arry [index];
        timer.setDelay ((int) (delay / words [index].length ()));
    } else {
        timer.stop ();
        System.err.println ("Timer stopped");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12025055_14621950_278_292
12025055_14621950_513_537
Title: How should I time highlighting of text with audio for a karaoke like application in javaFx 
----------------------------------------

public static void start () {
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            UIManager.put ("swing.boldMetal", Boolean.FALSE);
            try {
                new newh ().setVisible (true);
            } catch (FileNotFoundException ex) {
                Logger.getLogger (newh.class.getName ()).log (Level.SEVERE, null, ex);
            }
        }}

    );
}
----------------------------------------

public static void start () throws InterruptedException, InvocationTargetException {
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            try {
                new ColoredTextTest ().setVisible (true);
            } catch (FileNotFoundException ex) {
                Logger.getLogger (ColoredTextTest.class.getName ()).log (Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger (ColoredTextTest.class.getName ()).log (Level.SEVERE, null, ex);
            }
            ColoredTextTest y = null;
            try {
                y = new ColoredTextTest ();
            } catch (FileNotFoundException ex) {
                Logger.getLogger (ColoredTextTest.class.getName ()).log (Level.SEVERE, null, ex);
            } catch (IOException ex) {
                Logger.getLogger (ColoredTextTest.class.getName ()).log (Level.SEVERE, null, ex);
            }
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12025055_14621950_341_446
12025055_14621950_84_184
Title: How should I time highlighting of text with audio for a karaoke like application in javaFx 
----------------------------------------

private void initComponents () {
    jPanel1 = new javax.swing.JPanel ();
    jButton1 = new javax.swing.JButton ();
    jButton2 = new javax.swing.JButton ();
    jButton3 = new javax.swing.JButton ();
    jButton4 = new javax.swing.JButton ();
    jSeparator1 = new javax.swing.JSeparator ();
    jScrollPane1 = new javax.swing.JScrollPane ();
    jTextPane1 = new javax.swing.JTextPane ();
    setDefaultCloseOperation (javax.swing.WindowConstants.EXIT_ON_CLOSE);
    setBackground (new java.awt.Color (0, 0, 0));
    setUndecorated (true);
    jPanel1.setBackground (new java.awt.Color (0, 0, 0));
    jPanel1.setBorder (javax.swing.BorderFactory.createMatteBorder (3, 3, 3, 3, new java.awt.Color (0, 204, 204)));
    jPanel1.setInheritsPopupMenu (true);
    jButton1.setBackground (new java.awt.Color (255, 255, 0));
    jButton1.setFont (new java.awt.Font ("Virtual DJ", 0, 14));
    jButton1.setForeground (new java.awt.Color (0, 255, 255));
    jButton1.setText ("Back");
    jButton1.setOpaque (false);
    jButton2.setBackground (new java.awt.Color (255, 255, 0));
    jButton2.setFont (new java.awt.Font ("Virtual DJ", 0, 14));
    jButton2.setForeground (new java.awt.Color (0, 255, 255));
    jButton2.setText ("Pause");
    jButton2.setOpaque (false);
    jButton3.setBackground (new java.awt.Color (255, 255, 0));
    jButton3.setFont (new java.awt.Font ("Virtual DJ", 1, 14));
    jButton3.setForeground (new java.awt.Color (0, 255, 255));
    jButton3.setText ("Play");
    jButton3.setOpaque (false);
    jButton3.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            jButton3ActionPerformed (evt);
        }}

    );
    jButton4.setBackground (new java.awt.Color (255, 255, 0));
    jButton4.setFont (new java.awt.Font ("Virtual DJ", 0, 14));
    jButton4.setForeground (new java.awt.Color (0, 255, 255));
    jButton4.setText ("close");
    jButton4.setOpaque (false);
    jButton4.addActionListener (new java.awt.event.ActionListener () {
        public void actionPerformed (java.awt.event.ActionEvent evt) {
            jButton4ActionPerformed (evt);
        }}

    );
    jSeparator1.setBackground (new java.awt.Color (51, 255, 255));
    jTextPane1.setBackground (new java.awt.Color (0, 0, 0));
    jTextPane1.setFont (new java.awt.Font ("Tahoma", 0, 36));
    jTextPane1.setForeground (new java.awt.Color (0, 255, 255));
    jTextPane1.setVerifyInputWhenFocusTarget (false);
    jScrollPane1.setViewportView (jTextPane1);
    javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout (jPanel1);
    jPanel1.setLayout (jPanel1Layout);
    jPanel1Layout.setHorizontalGroup (jPanel1Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (jPanel1Layout.createSequentialGroup ().addContainerGap ().addComponent (jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 93, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent (jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 101, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent (jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 114, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.UNRELATED).addComponent (jButton4, javax.swing.GroupLayout.DEFAULT_SIZE, 611, Short.MAX_VALUE).addGap (23, 23, 23)).addComponent (jSeparator1, javax.swing.GroupLayout.DEFAULT_SIZE, 982, Short.MAX_VALUE).addComponent (jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 982, Short.MAX_VALUE));
    jPanel1Layout.setVerticalGroup (jPanel1Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addGroup (javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup ().addComponent (jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 645, Short.MAX_VALUE).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addComponent (jSeparator1, javax.swing.GroupLayout.PREFERRED_SIZE, 10, javax.swing.GroupLayout.PREFERRED_SIZE).addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED).addGroup (jPanel1Layout.createParallelGroup (javax.swing.GroupLayout.Alignment.BASELINE).addComponent (jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent (jButton2, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent (jButton4, javax.swing.GroupLayout.PREFERRED_SIZE, 37, javax.swing.GroupLayout.PREFERRED_SIZE).addComponent (jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 36, javax.swing.GroupLayout.PREFERRED_SIZE))));
    javax.swing.GroupLayout layout = new javax.swing.GroupLayout (getContentPane ());
    getContentPane ().setLayout (layout);
    layout.setHorizontalGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addComponent (jPanel1, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));
    layout.setVerticalGroup (layout.createParallelGroup (javax.swing.GroupLayout.Alignment.LEADING).addComponent (jPanel1, javax.swing.GroupLayout.Alignment.TRAILING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));
    java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit ().getScreenSize ();
    setBounds ((screenSize.width - 988) / 2, (screenSize.height - 710) / 2, 988, 710);
}
----------------------------------------

private void initComponents () {
    entry = new JTextField ();
    textArea = new JTextArea ();
    textArea.setBackground (Color.ORANGE);
    status = new JLabel ();
    jLabel1 = new JLabel ();
    frame = new JFrame ();
    setDefaultCloseOperation (WindowConstants.EXIT_ON_CLOSE);
    setTitle ("TextFieldDemo");
    textArea.setColumns (20);
    textArea.setLineWrap (true);
    textArea.setRows (5);
    textArea.setWrapStyleWord (true);
    textArea.setEditable (false);
    jScrollPane1 = new JScrollPane (textArea);
    final JFrame jar = new JFrame ();
    jLabel1.setText ("Enter text to search:");
    startButton = new JButton ("Start");
    jar.add (startButton);
    jar.setVisible (true);
    jar.pack ();
    startButton.addActionListener (new ActionListener () {
        @Override
        public void actionPerformed (ActionEvent ae) {
            try {
                ColoredTextTest.start ();
            } catch (InterruptedException ex) {
                Logger.getLogger (newh.class.getName ()).log (Level.SEVERE, null, ex);
            } catch (InvocationTargetException ex) {
                Logger.getLogger (newh.class.getName ()).log (Level.SEVERE, null, ex);
            }
            setVisible (false);
            jar.setVisible (false);
        }}

    );
    GroupLayout layout = new GroupLayout (getContentPane ());
    getContentPane ().setLayout (layout);
    ParallelGroup hGroup = layout.createParallelGroup (GroupLayout.Alignment.LEADING);
    SequentialGroup h1 = layout.createSequentialGroup ();
    ParallelGroup h2 = layout.createParallelGroup (GroupLayout.Alignment.CENTER);
    h1.addContainerGap ();
    h2.addComponent (jScrollPane1, GroupLayout.Alignment.LEADING, GroupLayout.DEFAULT_SIZE, 600, Short.MAX_VALUE);
    h2.addComponent (status, GroupLayout.Alignment.LEADING, GroupLayout.DEFAULT_SIZE, 900, Short.MAX_VALUE);
    SequentialGroup h3 = layout.createSequentialGroup ();
    h3.addComponent (jLabel1);
    h3.addPreferredGap (LayoutStyle.ComponentPlacement.RELATED);
    h3.addComponent (entry, GroupLayout.DEFAULT_SIZE, 900, Short.MAX_VALUE);
    h2.addGroup (h3);
    h1.addGroup (h2);
    h1.addContainerGap ();
    hGroup.addGroup (GroupLayout.Alignment.TRAILING, h1);
    layout.setHorizontalGroup (hGroup);
    ParallelGroup vGroup = layout.createParallelGroup (GroupLayout.Alignment.LEADING);
    SequentialGroup v1 = layout.createSequentialGroup ();
    v1.addContainerGap ();
    ParallelGroup v2 = layout.createParallelGroup (GroupLayout.Alignment.BASELINE);
    v2.addComponent (jLabel1);
    v2.addComponent (entry, GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE, GroupLayout.PREFERRED_SIZE);
    v1.addGroup (v2);
    v1.addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED);
    v1.addComponent (jScrollPane1, GroupLayout.DEFAULT_SIZE, 900, Short.MAX_VALUE);
    v1.addPreferredGap (javax.swing.LayoutStyle.ComponentPlacement.RELATED);
    v1.addComponent (status);
    v1.addContainerGap ();
    vGroup.addGroup (v1);
    layout.setVerticalGroup (vGroup);
    pack ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12025378_12046123_3_25
12025378_47981319_1_13
Title: Project Euler #3 takes forever in Java 
----------------------------------------

public static void main (String [] args) {
    long start, end, totalTime;
    long num = 600851475143L;
    long pFactor = 1L;
    start = System.currentTimeMillis ();
    for (long i = 3L;
    i <= num / i;) {
        if (num % i == 0) {
            pFactor = i;
            num = num / i;
        } else {
            i += 2;
        }
    }
    if (pFactor < num) {
        pFactor = num;
    }
    end = System.currentTimeMillis ();
    totalTime = end - start;
    System.out.println (pFactor + " Time: " + totalTime);
}
----------------------------------------

public static void main (String [] args) {
    long number = 600851475143L;
    int rootOfNumber = (int) Math.sqrt (number) + 10;
    for (int i = rootOfNumber;
    i > 2; i --) {
        if (number % i == 0) {
            if (psudoprime (i)) {
                System.out.println (i);
                break;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12025378_23589365_2_9
12025378_23589975_8_15
Title: Project Euler #3 takes forever in Java 
----------------------------------------

static boolean isPrime (long n) {
    for (long i = 2;
    i <= n / 2; i ++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean isPrime (long n) {
    if (n < 2) return false;
    else if (n == 2) return true;

    for (int i = 2;
    i < Math.pow (n, 0.5) + 1; i ++) if (n % i == 0) return false;

    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1203734_1204658_178_187
1203734_1204658_72_84
Title: hyperlinks in JEditorPane in a JTable 
----------------------------------------

public T getComponent (TableCell key) {
    T component = components.get (key);
    if (component == null && factory != null) {
        component = factory.build ();
        initialiseComponent (component);
        components.put (key, component);
    }
    return component;
}
----------------------------------------

private JComponent getComponent (TableCell cell) {
    if (rowOrColumnInvalid (cell)) {
        return null;
    }
    TableCellRenderer renderer = table.getCellRenderer (cell.row, cell.column);
    if (! (renderer instanceof ActiveJComponentTableCellRenderer)) {
        return null;
    }
    ActiveJComponentTableCellRenderer activeComponentRenderer = (ActiveJComponentTableCellRenderer) renderer;
    return activeComponentRenderer.getComponent (cell);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12042976_12043075_29_41
12042976_12043369_26_35
Title: Access thread and run a method inside Thread class 
----------------------------------------

public void run () {
    System.out.println ("Thread started, threadName=" + this.threadName + ", hashCode=" + this.hashCode ());
    while (! this.isStopped.get ()) {
        try {
            Thread.sleep (3000);
        } catch (InterruptedException e) {
        }
        System.out.println ("Thread looping, threadName=" + this.threadName + ", hashCode=" + this.hashCode ());
    }
}
----------------------------------------

public void run () {
    while (running.get ()) {
        System.out.println ("Playing Music");
        try {
            sleep (1000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
12051198_12051296_7_16
12051198_12051337_2_13
Title: JAVA - Return list of interface 
----------------------------------------

public List < ? extends Lotto > getLotto (Integer number) {
    List < ? extends Lotto > listaLotto;
    if (number == 1) {
        listaLotto = new ArrayList < LottoImplFirst > ();
    } else if (number == 2) {
        listaLotto = new ArrayList < LottoImplSecond > ();
    }

    return listaLotto;
}
----------------------------------------

public List < ? extends Lotto > getLotto (Integer number) {
    List < ? extends Lotto > listaLotto = null;
    if (number == 1) {
        listaLotto = new ArrayList < LottoImplFirst > ();
    } else if (number == 1) {
        listaLotto = new ArrayList < LottoImplSecond > ();
    }

    return listaLotto;
}
----------------------------------------
