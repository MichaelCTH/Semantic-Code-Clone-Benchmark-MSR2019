$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19465965_42920463_1_30
19465965_49631227_3_35
Title: java codility Max-Counters 
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] counters = new int [N];
    int maxAIs = 0;
    int minAShouldBe = 0;
    for (int x : A) {
        if (x >= 1 && x <= N) {
            if (counters [x - 1] < minAShouldBe) {
                counters [x - 1] = minAShouldBe;
            }
            counters [x - 1] ++;
            if (counters [x - 1] > maxAIs) {
                maxAIs = counters [x - 1];
            }
        } else if (x == N + 1) {
            minAShouldBe = maxAIs;
        }

    }
    for (int i = 0;
    i < N; i ++) {
        if (counters [i] < minAShouldBe) {
            counters [i] = minAShouldBe;
        }
    }
    return counters;
}
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] counters = new int [N];
    int [] countersLastMaxIndexes = new int [N];
    int maxValue = 0;
    int fixedMaxValue = 0;
    int maxIndex = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] <= N) {
            if (countersLastMaxIndexes [A [i] - 1] != maxIndex) {
                counters [A [i] - 1] = fixedMaxValue;
                countersLastMaxIndexes [A [i] - 1] = maxIndex;
            }
            counters [A [i] - 1] ++;
            if (counters [A [i] - 1] > maxValue) {
                maxValue = counters [A [i] - 1];
            }
        } else {
            maxIndex = i;
            fixedMaxValue = maxValue;
        }
    }
    for (int i = 0;
    i < countersLastMaxIndexes.length; i ++) {
        if (countersLastMaxIndexes [i] != maxIndex) {
            counters [i] = fixedMaxValue;
            countersLastMaxIndexes [i] = maxIndex;
        }
    }
    return counters;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19465965_42920463_1_30
19465965_50180750_1_23
Title: java codility Max-Counters 
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] counters = new int [N];
    int maxAIs = 0;
    int minAShouldBe = 0;
    for (int x : A) {
        if (x >= 1 && x <= N) {
            if (counters [x - 1] < minAShouldBe) {
                counters [x - 1] = minAShouldBe;
            }
            counters [x - 1] ++;
            if (counters [x - 1] > maxAIs) {
                maxAIs = counters [x - 1];
            }
        } else if (x == N + 1) {
            minAShouldBe = maxAIs;
        }

    }
    for (int i = 0;
    i < N; i ++) {
        if (counters [i] < minAShouldBe) {
            counters [i] = minAShouldBe;
        }
    }
    return counters;
}
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] solution = new int [N];
    int maxCounter = 0;
    int maxCountersSum = 0;
    for (int a : A) {
        if (a >= 1 && a <= N) {
            if (solution [a - 1] < maxCountersSum) solution [a - 1] = maxCountersSum;

            solution [a - 1] ++;
            if (solution [a - 1] > maxCounter) maxCounter = solution [a - 1];

        }
        if (a == N + 1) {
            maxCountersSum = maxCounter;
        }
    }
    for (int i = 0;
    i < N; i ++) {
        if (solution [i] < maxCountersSum) solution [i] = maxCountersSum;

    }
    return solution;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19465965_48645313_5_32
19465965_49631227_3_35
Title: java codility Max-Counters 
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] res = new int [N];
    int max = 0;
    int minValue = 0;
    for (int i = 0;
    i < A.length; i ++) {
        int value = A [i];
        int pos = value - 1;
        if (isToSum (value, N)) {
            if (res [pos] < minValue) {
                res [pos] = minValue;
            }
            res [pos] += 1;
            if (max < res [pos]) {
                max = res [pos];
            }
        } else {
            minValue = max;
        }
    }
    for (int i = 0;
    i < res.length; i ++) {
        if (res [i] < minValue) {
            res [i] = minValue;
        }
    }
    return res;
}
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] counters = new int [N];
    int [] countersLastMaxIndexes = new int [N];
    int maxValue = 0;
    int fixedMaxValue = 0;
    int maxIndex = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] <= N) {
            if (countersLastMaxIndexes [A [i] - 1] != maxIndex) {
                counters [A [i] - 1] = fixedMaxValue;
                countersLastMaxIndexes [A [i] - 1] = maxIndex;
            }
            counters [A [i] - 1] ++;
            if (counters [A [i] - 1] > maxValue) {
                maxValue = counters [A [i] - 1];
            }
        } else {
            maxIndex = i;
            fixedMaxValue = maxValue;
        }
    }
    for (int i = 0;
    i < countersLastMaxIndexes.length; i ++) {
        if (countersLastMaxIndexes [i] != maxIndex) {
            counters [i] = fixedMaxValue;
            countersLastMaxIndexes [i] = maxIndex;
        }
    }
    return counters;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19465965_48645313_5_32
19465965_50180750_1_23
Title: java codility Max-Counters 
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] res = new int [N];
    int max = 0;
    int minValue = 0;
    for (int i = 0;
    i < A.length; i ++) {
        int value = A [i];
        int pos = value - 1;
        if (isToSum (value, N)) {
            if (res [pos] < minValue) {
                res [pos] = minValue;
            }
            res [pos] += 1;
            if (max < res [pos]) {
                max = res [pos];
            }
        } else {
            minValue = max;
        }
    }
    for (int i = 0;
    i < res.length; i ++) {
        if (res [i] < minValue) {
            res [i] = minValue;
        }
    }
    return res;
}
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] solution = new int [N];
    int maxCounter = 0;
    int maxCountersSum = 0;
    for (int a : A) {
        if (a >= 1 && a <= N) {
            if (solution [a - 1] < maxCountersSum) solution [a - 1] = maxCountersSum;

            solution [a - 1] ++;
            if (solution [a - 1] > maxCounter) maxCounter = solution [a - 1];

        }
        if (a == N + 1) {
            maxCountersSum = maxCounter;
        }
    }
    for (int i = 0;
    i < N; i ++) {
        if (solution [i] < maxCountersSum) solution [i] = maxCountersSum;

    }
    return solution;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19465965_49631227_3_35
19465965_50180750_1_23
Title: java codility Max-Counters 
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] counters = new int [N];
    int [] countersLastMaxIndexes = new int [N];
    int maxValue = 0;
    int fixedMaxValue = 0;
    int maxIndex = 0;
    for (int i = 0;
    i < A.length; i ++) {
        if (A [i] <= N) {
            if (countersLastMaxIndexes [A [i] - 1] != maxIndex) {
                counters [A [i] - 1] = fixedMaxValue;
                countersLastMaxIndexes [A [i] - 1] = maxIndex;
            }
            counters [A [i] - 1] ++;
            if (counters [A [i] - 1] > maxValue) {
                maxValue = counters [A [i] - 1];
            }
        } else {
            maxIndex = i;
            fixedMaxValue = maxValue;
        }
    }
    for (int i = 0;
    i < countersLastMaxIndexes.length; i ++) {
        if (countersLastMaxIndexes [i] != maxIndex) {
            counters [i] = fixedMaxValue;
            countersLastMaxIndexes [i] = maxIndex;
        }
    }
    return counters;
}
----------------------------------------

public int [] solution (int N, int [] A) {
    int [] solution = new int [N];
    int maxCounter = 0;
    int maxCountersSum = 0;
    for (int a : A) {
        if (a >= 1 && a <= N) {
            if (solution [a - 1] < maxCountersSum) solution [a - 1] = maxCountersSum;

            solution [a - 1] ++;
            if (solution [a - 1] > maxCounter) maxCounter = solution [a - 1];

        }
        if (a == N + 1) {
            maxCountersSum = maxCounter;
        }
    }
    for (int i = 0;
    i < N; i ++) {
        if (solution [i] < maxCountersSum) solution [i] = maxCountersSum;

    }
    return solution;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1946668_1946753_33_46
1946668_1947527_62_94
Title: Sorting using Comparator- Descending order (User defined classes) 
----------------------------------------

public static void main (String [] args) {
    Person [] arr = new Person [4];
    arr [0] = new Person (50);
    arr [1] = new Person (20);
    arr [2] = new Person (10);
    arr [3] = new Person (90);
    Arrays.sort (arr);
    for (int i = 0;
    i < arr.length; i ++) {
        System.out.println (arr [i].age);
    }
}
----------------------------------------

public static void main (String [] args) {
    List < Person > people = new ArrayList < Person > ();
    people.add (new Person ("Homer", 38));
    people.add (new Person ("Marge", 35));
    people.add (new Person ("Bart", 15));
    people.add (new Person ("Lisa", 13));
    Collections.sort (people);
    System.out.println ("Sort by Natural order");
    System.out.println ("\t" + people);
    Collections.sort (people, Collections.reverseOrder ());
    System.out.println ("Sort by reverse natural order");
    System.out.println ("\t" + people);
    Collections.sort (people, new Person.AgeComparator ());
    System.out.println ("Sort using Age Comparator");
    System.out.println ("\t" + people);
    Collections.sort (people, Collections.reverseOrder (new Person.AgeComparator ()));
    System.out.println ("Sort using Reverse Age Comparator");
    System.out.println ("\t" + people);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19468160_19468265_1_15
19468160_19468405_1_31
Title: Java program that does simple string manipulation is not working correctly 
----------------------------------------

public static void main (String [] args) {
    Scanner console = new Scanner (System.in);
    String input = console.nextLine ();
    String [] words = input.split (" ");
    StringBuilder output = new StringBuilder ();
    for (String s : words) {
        if (startsWithVowel (s)) {
            output.append (s);
        } else {
            output.append (getPunc (s));
        }
    }
    System.out.println (output.toString ());
}
----------------------------------------

public static void main (String [] args) {
    Scanner console = new Scanner (System.in);
    System.out.print ("Input: ");
    String str = console.next ();
    String [] input = str.split (" ");
    StringBuilder s = new StringBuilder ();
    String test;
    for (int i = 0;
    i < input.length; i ++) {
        test = input [i];
        if (test.charAt (0) == 'U' || test.charAt (0) == 'O' || test.charAt (0) == 'I' || test.charAt (0) == 'E' || test.charAt (0) == 'A' || test.charAt (0) == 'a' || test.charAt (0) == 'e' || test.charAt (0) == 'i' || test.charAt (0) == 'o' || test.charAt (0) == 'u') {
            s.append (input [i]);
        }
    }
    System.out.println (s);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19469599_19470694_1_16
19469599_19482034_1_20
Title: finding greater numbers in a java array 
----------------------------------------

public static int [] higherNumbers (int [] array, int numbers) {
    int tempArr [] = Arrays.copyOf (array, array.length);
    Arrays.sort (tempArr);
    int retArr [] = new int [numbers];
    int j = 0;
    for (int i = array.length - numbers;
    i < array.length; i ++) {
        for (int x = 0;
        x < array.length; x ++) {
            if (array [x] == tempArr [i]) {
                retArr [j] = x;
                break;
            }
        }
        j ++;
    }
    return retArr;
}
----------------------------------------

public static int [] higherNumbers (int [] array, int numbers) {
    int tempArr [] = Arrays.copyOf (array, array.length);
    Arrays.sort (tempArr);
    int retArr [] = new int [numbers];
    int j = 0;
    for (int i = array.length - numbers;
    i < array.length; i ++) {
        for (int x = 0;
        x < array.length; x ++) {
            if (array [x] == tempArr [i]) {
                if (checkIndex (retArr, x)) {
                    continue;
                } else {
                    retArr [j] = x;
                    break;
                }
            }
        }
        j ++;
    }
    return retArr;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19472181_19472209_1_9
19472181_19472320_1_9
Title: Exception order 
----------------------------------------

public static void main (String [] args) {
    try {
        System.out.println ("Starting");
        bar ();
        System.out.println ("passed bar");
    } catch (Exception e) {
        System.out.println ("foo exception");
    }
}
----------------------------------------

public static void main (String [] args) {
    try {
        System.out.println ("Starting");
        bar ();
        System.out.println ("passed bar");
    } catch (Exception e) {
        System.out.println ("foo exception");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19473268_19473492_114_127
19473268_19473492_76_93
Title: Issue Passing Parameters in binarySearch 
----------------------------------------

public String toString () {
    NumberFormat fmt = NumberFormat.getCurrencyInstance ();
    String description;
    description = fmt.format (cost) + "\t" + year + "\t";
    description += title + "\t" + director;
    if (bluray) description += "\t" + "Blu-Ray";

    return description;
}
----------------------------------------

public String toString () {
    NumberFormat fmt = NumberFormat.getCurrencyInstance ();
    String report = "~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n";
    report += "My DVD Collection\n\n";
    report += "Number of DVDs: " + count + "\n";
    report += "Total cost: " + fmt.format (totalCost) + "\n";
    report += "Average cost: " + fmt.format (totalCost / count);
    report += "\n\nDVD List:\n\n";
    for (int dvd = 0;
    dvd < count; dvd ++) report += list [dvd].toString () + "\n";

    return report;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19480813_23935966_32_72
19480813_23953263_34_47
Title: Java 7 watchservice get file change offset 
----------------------------------------

public void run () throws InterruptedException, IOException {
    prepareShadowDir ();
    watchDir.register (watchService, ENTRY_CREATE, ENTRY_MODIFY, ENTRY_DELETE);
    while (true) {
        WatchKey watchKey = watchService.take ();
        for (WatchEvent < ? > event : watchKey.pollEvents ()) {
            Path oldFile = shadowDir.resolve ((Path) event.context ());
            Path newFile = watchDir.resolve ((Path) event.context ());
            List < String > oldContent;
            List < String > newContent;
            WatchEvent.Kind < ? > eventType = event.kind ();
            if (! (Files.isDirectory (newFile) || Files.isDirectory (oldFile))) {
                if (eventType == ENTRY_CREATE) {
                    if (! Files.isDirectory (newFile)) Files.createFile (oldFile);

                } else if (eventType == ENTRY_MODIFY) {
                    Thread.sleep (200);
                    oldContent = fileToLines (oldFile);
                    newContent = fileToLines (newFile);
                    printUnifiedDiff (newFile, oldFile, oldContent, newContent);
                    try {
                        Files.copy (newFile, oldFile, StandardCopyOption.REPLACE_EXISTING);
                    } catch (Exception e) {
                        e.printStackTrace ();
                    }
                } else if (eventType == ENTRY_DELETE) {
                    try {
                        oldContent = fileToLines (oldFile);
                        newContent = new LinkedList < > ();
                        printUnifiedDiff (newFile, oldFile, oldContent, newContent);
                        Files.deleteIfExists (oldFile);
                    } catch (Exception e) {
                        e.printStackTrace ();
                    }
                }

            }
        }
        watchKey.reset ();
        Thread.sleep (1000 * watchInterval);
    }
}
----------------------------------------

public void run () throws InterruptedException, IOException {
    try (DirectoryStream < Path > dirEntries = Files.newDirectoryStream (watchDir)) {
        for (Path file : dirEntries) createTailer (file);

    }
    watchDir.register (watchService, ENTRY_CREATE);
    while (true) {
        WatchKey watchKey = watchService.take ();
        for (WatchEvent < ? > event : watchKey.pollEvents ()) createTailer (watchDir.resolve ((Path) event.context ()));

        watchKey.reset ();
        Thread.sleep (1000 * watchInterval);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19482102_19482233_21_35
19482102_19482252_11_106
Title: How to access variable from a different class 
----------------------------------------

public void Start (int diff) {
    String words [] = new String [26];
    switch (diff) {
    }
    int i = words.length;
    Random rng = new Random ();
    int choice = rng.nextInt (words.length);
    wordSelection = words [choice];
}
----------------------------------------

public void Start (int diff) {
    String words [] = new String [26];
    switch (diff) {
        case 1 :
            words [0] = "cat";
            words [1] = "dog";
            words [2] = "book";
            words [3] = "breakfeast";
            words [4] = "telephone";
            words [5] = "mixture";
            words [6] = "music";
            words [7] = "animal";
            words [8] = "school";
            words [9] = "plant";
            words [10] = "pen";
            words [11] = "pencil";
            words [12] = "paper";
            words [13] = "note";
            words [14] = "fog";
            words [15] = "smoke";
            words [16] = "bake";
            words [17] = "alone";
            words [18] = "drive";
            words [19] = "town";
            words [20] = "city";
            words [21] = "sunny";
            words [22] = "shine";
            words [23] = "polish";
            words [24] = "cap";
            words [25] = "hat";
            break;
        case 2 :
            words [0] = "president";
            words [1] = "exclamation";
            words [2] = "statement";
            words [3] = "television";
            words [4] = "physics";
            words [5] = "algebra";
            words [6] = "geometry";
            words [7] = "difficult";
            words [8] = "extreme";
            words [9] = "procedure";
            words [10] = "ship";
            words [11] = "soldier";
            words [12] = "lunch";
            words [13] = "hockey";
            words [14] = "tennis";
            words [15] = "soccer";
            words [16] = "football";
            words [17] = "basketball";
            words [18] = "bias";
            words [19] = "magazine";
            words [20] = "computer";
            words [21] = "internet";
            words [22] = "allegedly";
            words [23] = "system";
            words [24] = "unison";
            words [25] = "excited";
            break;
        case 3 :
            words [0] = "amalgamation";
            words [1] = "proclomation";
            words [2] = "establishment";
            words [3] = "rehabilitation";
            words [4] = "rhinoceros";
            words [5] = "velociraptor";
            words [6] = "declaration";
            words [7] = "announcement";
            words [8] = "binomial";
            words [9] = "polynomial";
            words [10] = "congregation";
            words [11] = "obligation";
            words [12] = "structure";
            words [13] = "description";
            words [14] = "perscription";
            words [15] = "subscribe";
            words [16] = "address";
            words [17] = "township";
            words [18] = "mischievous";
            words [19] = "bewildered";
            words [20] = "accusation";
            words [21] = "designation";
            words [22] = "disgusting";
            words [23] = "prolonged";
            words [24] = "restoration";
            words [25] = "regeneration";
    }
    int i = words.length;
    Random rng = new Random ();
    int choice = rng.nextInt (words.length);
    this.wd = words [choice];
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19484406_19484495_1_12
19484406_46105690_8_154
Title: "Detecting if a string has unique characters: comparing my solution to ""Cracking the Coding Interview?""" 
----------------------------------------

public static boolean isUniqueChars (String str) {
    if (str.length () > 256) {
        return false;
    }
    int checker = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        int val = str.charAt (i) - 'a';
        if ((checker & (1 << val)) > 0) return false;

        checker |= (1 << val);
    }
    return true;
}
----------------------------------------

public static boolean isUniqueChars (String str) {
    int checker = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        char c = str.charAt (i);
        int val = c - 'a';
        int leftShift = 1 << val;
        int bitWiseAND = checker & leftShift;
        String leftShiftBinaryString = Integer.toBinaryString (leftShift);
        String checkerBinaryString = leftPad (Integer.toBinaryString (checker), leftShiftBinaryString.length ());
        String leftShiftBinaryStringWithPad = leftPad (leftShiftBinaryString, checkerBinaryString.length ());
        if (bitWiseAND > 0) {
            return false;
        }
        checker = checker | leftShift;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19484406_19484495_1_12
19484406_51523812_1_14
Title: "Detecting if a string has unique characters: comparing my solution to ""Cracking the Coding Interview?""" 
----------------------------------------

public static boolean isUniqueChars (String str) {
    if (str.length () > 256) {
        return false;
    }
    int checker = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        int val = str.charAt (i) - 'a';
        if ((checker & (1 << val)) > 0) return false;

        checker |= (1 << val);
    }
    return true;
}
----------------------------------------

boolean isUniqueChars (String str) {
    if (str.length () > 128) return false;

    boolean [] char_set = new boolean [128];
    for (int i = 0;
    i < str.length (); i ++) {
        int val = str.charAt (i);
        if (char_set [val]) {
            return false;
        }
        char_set [val] = true;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19484406_19484559_1_28
19484406_46105690_8_154
Title: "Detecting if a string has unique characters: comparing my solution to ""Cracking the Coding Interview?""" 
----------------------------------------

public static boolean isUniqueChars (String str) {
    if (str.length () > 256) {
        return false;
    }
    int checker = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        int val = str.charAt (i) - 'a';
        if ((checker & (1 << val)) > 0) return false;

        checker |= (1 << val);
    }
    return true;
}
----------------------------------------

public static boolean isUniqueChars (String str) {
    int checker = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        char c = str.charAt (i);
        int val = c - 'a';
        int leftShift = 1 << val;
        int bitWiseAND = checker & leftShift;
        String leftShiftBinaryString = Integer.toBinaryString (leftShift);
        String checkerBinaryString = leftPad (Integer.toBinaryString (checker), leftShiftBinaryString.length ());
        String leftShiftBinaryStringWithPad = leftPad (leftShiftBinaryString, checkerBinaryString.length ());
        if (bitWiseAND > 0) {
            return false;
        }
        checker = checker | leftShift;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19484406_19484559_1_28
19484406_51523812_1_14
Title: "Detecting if a string has unique characters: comparing my solution to ""Cracking the Coding Interview?""" 
----------------------------------------

public static boolean isUniqueChars (String str) {
    if (str.length () > 256) {
        return false;
    }
    int checker = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        int val = str.charAt (i) - 'a';
        if ((checker & (1 << val)) > 0) return false;

        checker |= (1 << val);
    }
    return true;
}
----------------------------------------

boolean isUniqueChars (String str) {
    if (str.length () > 128) return false;

    boolean [] char_set = new boolean [128];
    for (int i = 0;
    i < str.length (); i ++) {
        int val = str.charAt (i);
        if (char_set [val]) {
            return false;
        }
        char_set [val] = true;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19484406_46105690_8_154
19484406_51523812_1_14
Title: "Detecting if a string has unique characters: comparing my solution to ""Cracking the Coding Interview?""" 
----------------------------------------

public static boolean isUniqueChars (String str) {
    int checker = 0;
    for (int i = 0;
    i < str.length (); i ++) {
        char c = str.charAt (i);
        int val = c - 'a';
        int leftShift = 1 << val;
        int bitWiseAND = checker & leftShift;
        String leftShiftBinaryString = Integer.toBinaryString (leftShift);
        String checkerBinaryString = leftPad (Integer.toBinaryString (checker), leftShiftBinaryString.length ());
        String leftShiftBinaryStringWithPad = leftPad (leftShiftBinaryString, checkerBinaryString.length ());
        if (bitWiseAND > 0) {
            return false;
        }
        checker = checker | leftShift;
    }
    return true;
}
----------------------------------------

boolean isUniqueChars (String str) {
    if (str.length () > 128) return false;

    boolean [] char_set = new boolean [128];
    for (int i = 0;
    i < str.length (); i ++) {
        int val = str.charAt (i);
        if (char_set [val]) {
            return false;
        }
        char_set [val] = true;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19486276_19486294_1_23
19486276_19486388_1_10
Title: Writting a java file 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    BufferedReader br = null;
    try {
        br = new BufferedReader (instream);
        System.out.println ("Enter your annual sales");
        String annual = br.readLine ();
        int salary = 7550281;
        int com = 3828;
        int compensation = Integer.parseInt (annual) * com + salary;
    } catch (IOException exp) {
        exp.printStackTrace ();
    } finally {
        try {
            br.close ();
        } catch (Exception exp) {
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter your annual sales");
    int annual = Integer.parseInt (input.nextLine ());
    int salary = 75_502_81;
    int com = 38_28;
    int compensation = annual * com + salary;
    System.out.println (compensation);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19486276_19486294_1_23
19486276_19486494_3_12
Title: Writting a java file 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    BufferedReader br = null;
    try {
        br = new BufferedReader (instream);
        System.out.println ("Enter your annual sales");
        String annual = br.readLine ();
        int salary = 7550281;
        int com = 3828;
        int compensation = Integer.parseInt (annual) * com + salary;
    } catch (IOException exp) {
        exp.printStackTrace ();
    } finally {
        try {
            br.close ();
        } catch (Exception exp) {
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter your annual sales");
    String annual = input.nextLine ();
    int salary = 75_502_81;
    int com = 38_28;
    int compensation = Integer.parseInt (annual) * com + salary;
    System.out.println ("compensation is: " + compensation);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19486276_19486388_1_10
19486276_19486494_3_12
Title: Writting a java file 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter your annual sales");
    int annual = Integer.parseInt (input.nextLine ());
    int salary = 75_502_81;
    int com = 38_28;
    int compensation = annual * com + salary;
    System.out.println (compensation);
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Enter your annual sales");
    String annual = input.nextLine ();
    int salary = 75_502_81;
    int com = 38_28;
    int compensation = Integer.parseInt (annual) * com + salary;
    System.out.println ("compensation is: " + compensation);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19492910_19493048_1_35
19492910_19493517_6_50
Title: Suggestions with java largest and smallest input 
----------------------------------------

public static void temperatures () {
    double temperature;
    double biggest = 0;
    double smallest = 0;
    double totalNum = 0;
    double counter = 1;
    int numberAmount = 0;
    double average = totalNum / numberAmount;
    Scanner input = new Scanner (System.in);
    System.out.println ("Please enter the temperature(s) - end the program with -100");
    System.out.print ("-> ");
    while ((temperature = input.nextDouble ()) != - 100) {
        numberAmount ++;
        totalNum = totalNum + temperature;
        average = totalNum / numberAmount;
        if (temperature > biggest) {
            biggest = temperature;
        }
        if (temperature < smallest) {
            smallest = temperature;
        }
        System.out.print ("-> ");
    }
    System.out.println ();
    System.out.println ("Highest temperature: " + biggest);
    System.out.println ("Lowest temperature: " + smallest);
    System.out.println ("Average temprature: " + average);
    System.out.println ("Total registered tempratures: " + totalNum);
}
----------------------------------------

public static void temperatures () {
    int counter = 0;
    double temperature;
    double totalNum = 0;
    int numberAmount = 0;
    double max = - Double.MAX_VALUE;
    double min = Double.MAX_VALUE;
    double average = 0;
    Scanner input = new Scanner (System.in);
    System.out.println ("Please enter the temperature(s) - end the program with -100");
    System.out.print ("-> ");
    while ((temperature = input.nextDouble ()) != - 100) {
        counter ++;
        numberAmount ++;
        totalNum = totalNum + temperature;
        System.out.print ("-> ");
        if (temperature > max) {
            max = temperature;
        }
        if (temperature < min) {
            min = temperature;
        }
    }
    average = totalNum / numberAmount;
    System.out.println ();
    System.out.println ("Highest temperature: " + max);
    System.out.println ("Lowest temperature: " + min);
    System.out.println ("Average temprature: " + average);
    System.out.println ("Total registered tempratures: " + counter);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19510345_19510554_1_20
19510345_28442687_1_12
Title: Your method must return a value. If your method has multiple paths of execution 
----------------------------------------

public static String season (int month, int day) {
    if (month > 9 && month < 12) {
        if (month == 9 && day >= 16 || month == 12 && day <= 15 || ! (month == 9 || month == 12)) {
            return "Fall";
        }
    } else if (month > 6 && month < 9) {
        if (month == 6 && day >= 16 || month == 9 && day <= 15 || ! (month == 6 || month == 9)) {
            return "Summer";
        }
    } else if (month > 3 && month < 6) {
        if (month == 3 && day >= 16 || month == 6 && day <= 15 || ! (month == 3 || month == 6)) {
            return "Sprint";
        }
    } else {
        return "Winter";
    }

}
----------------------------------------

public static String season (int month, int day) {
    if (month == 9 && day >= 16 || month == 12 && day <= 15 || month == 10 || month == 11) {
        return "Fall";
    } else if (month == 6 && day >= 16 || month == 9 && day <= 15 || month == 7 || month == 8) {
        return "Summer";
    } else if (month == 3 && day >= 16 || month == 6 && day <= 15 || month == 4 || month == 5) {
        return "Spring";
    } else {
        return "Winter";
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19510345_19510795_1_30
19510345_28442687_1_12
Title: Your method must return a value. If your method has multiple paths of execution 
----------------------------------------

public static String season (int month, int day) {
    if (month > 9 && month < 12) {
        if (month == 9 && day >= 16 || month == 12 && day <= 15) {
            return "Fall";
        }
    } else if (month > 6 && month < 9) {
        if (month == 6 && day >= 16 || month == 9 && day <= 15) {
            return "Summer";
        }
    } else if (month > 3 && month < 6) {
        if (month == 3 && day >= 16 || month == 6 && day <= 15) {
            return "Sprint";
        }
    } else {
        return "Winter";
    }

    throw new InvalidParameterException ("no matching season found");
}
----------------------------------------

public static String season (int month, int day) {
    if (month == 9 && day >= 16 || month == 12 && day <= 15 || month == 10 || month == 11) {
        return "Fall";
    } else if (month == 6 && day >= 16 || month == 9 && day <= 15 || month == 7 || month == 8) {
        return "Summer";
    } else if (month == 3 && day >= 16 || month == 6 && day <= 15 || month == 4 || month == 5) {
        return "Spring";
    } else {
        return "Winter";
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19510656_19842732_28_86
19510656_22421213_2_38
Title: How to upload files on server folder using jsp 
----------------------------------------

protected void doPost (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    boolean isMultipart = ServletFileUpload.isMultipartContent (request);
    if (! isMultipart) {
        return;
    }
    DiskFileItemFactory factory = new DiskFileItemFactory ();
    factory.setSizeThreshold (MAX_MEMORY_SIZE);
    factory.setRepository (new File (System.getProperty ("java.io.tmpdir")));
    String uploadFolder = getServletContext ().getRealPath ("") + File.separator + DATA_DIRECTORY;
    ServletFileUpload upload = new ServletFileUpload (factory);
    upload.setSizeMax (MAX_REQUEST_SIZE);
    try {
        List items = upload.parseRequest (request);
        Iterator iter = items.iterator ();
        while (iter.hasNext ()) {
            FileItem item = (FileItem) iter.next ();
            if (! item.isFormField ()) {
                String fileName = new File (item.getName ()).getName ();
                String filePath = uploadFolder + File.separator + fileName;
                File uploadedFile = new File (filePath);
                System.out.println (filePath);
                item.write (uploadedFile);
            }
        }
        getServletContext ().getRequestDispatcher ("/done.jsp").forward (request, response);
    } catch (FileUploadException ex) {
        throw new ServletException (ex);
    } catch (Exception ex) {
        throw new ServletException (ex);
    }
}
----------------------------------------

protected void doPost (HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
    boolean isMultipart = ServletFileUpload.isMultipartContent (request);
    if (isMultipart) {
        FileItemFactory factory = new DiskFileItemFactory ();
        ServletFileUpload upload = new ServletFileUpload (factory);
        try {
            List items = upload.parseRequest (request);
            Iterator iterator = items.iterator ();
            while (iterator.hasNext ()) {
                FileItem item = (FileItem) iterator.next ();
                if (! item.isFormField ()) {
                    String fileName = item.getName ();
                    String root = getServletContext ().getRealPath ("/");
                    File path = new File (root + "/uploads");
                    if (! path.exists ()) {
                        boolean status = path.mkdirs ();
                    }
                    File uploadedFile = new File (path + "/" + fileName);
                    System.out.println (uploadedFile.getAbsolutePath ());
                    item.write (uploadedFile);
                }
            }
        } catch (FileUploadException e) {
            e.printStackTrace ();
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1951622_10927695_2_20
1951622_1952364_1_16
Title: Creating a File in a new Directory 
----------------------------------------

public static void main (String [] args) throws Exception {
    String path = null;
    String destination = "/myfolder/test/" + createRandomPath (path);
    try {
        boolean status;
        status = new File (destination).mkdirs ();
    } catch (Exception e) {
        System.out.println ("Fehler: " + e.getMessage ());
    }
    File document = new File (destination + "/temp.docx");
    document.createNewFile ();
}
----------------------------------------

public static void main (String [] args) throws Exception {
    String path = null;
    String destination = "c:\\myfolder\\test" + createRandomPath (path);
    try {
        boolean status;
        status = new File (destination).mkdir ();
    } catch (Exception e) {
        System.out.println ("Fehler: " + e.getMessage ());
    }
    File document = new File (destination + "temp.doc");
    document.createNewFile ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19520037_19521102_1_11
19520037_37568454_1_14
Title: SimpleExpandableListAdapter and expandedGroupLayout 
----------------------------------------

public View getGroupView (int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {
    View v;
    if (convertView == null) {
        v = newGroupView (isExpanded, parent);
    } else {
        v = convertView;
    }
    bindView (v, mGroupData.get (groupPosition), mGroupFrom, mGroupTo);
    return v;
}
----------------------------------------

public View getGroupView (int groupPosition, boolean isExpanded, View convertView, ViewGroup parent) {
    View v;
    if (convertView != null && ((Boolean) convertView.getTag ()) == isExpanded) {
        v = super.getGroupView (groupPosition, isExpanded, convertView, parent);
    } else {
        v = super.getGroupView (groupPosition, isExpanded, null, parent);
        v.setTag (isExpanded);
    }
    return v;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19520273_19520337_8_19
19520273_19520510_9_18
Title: Java thread not sleeping 
----------------------------------------

public void run () {
    int i;
    try {
        Thread.sleep (1000);
        for (i = 0; i <= 5; i ++) {
            System.out.println (i);
        }
    } catch (InterruptedException e) {
    }
}
----------------------------------------

public void run () {
    try {
        for (i = 0; i <= 5; i ++) {
            System.out.println (i);
            Thread.sleep (1000);
        }
    } catch (InterruptedException e) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19525429_19614383_158_169
19525429_19614383_26_50
Title: JFrame coloration should like to this picture 
----------------------------------------

protected void paintComponent (Graphics g) {
    super.paintComponent (g);
    Graphics2D g2d = (Graphics2D) g.create ();
    if (gradientImage == null || gradientImage.getHeight () != getHeight ()) {
        gradientImage = createGradientImg ();
    }
    g2d.drawImage (gradientImage, 0, 0, getWidth (), getHeight (), this);
    g2d.dispose ();
}
----------------------------------------

protected void paintComponent (Graphics g) {
    Graphics2D g2d = (Graphics2D) g.create ();
    g2d.setColor (new Color (0xFFAA00));
    g2d.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g2d.setStroke (basicStroke);
    int archH = (getHeight () - 4) / 2;
    g2d.drawRoundRect (3, 3, getWidth () - 4, getHeight () - 4, archH, archH);
    if (getModel ().isRollover ()) {
        g2d.fillRoundRect (3, 3, getWidth () - 4, getHeight () - 4, archH, archH);
        setForeground (Color.black);
    } else {
        setForeground (Color.white);
    }
    g2d.dispose ();
    super.paintComponent (g);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19531065_19531097_1_16
19531065_19531127_1_12
Title: can anyone help me find what wrong with this code 
----------------------------------------

public static int findSecondToLast (int [] a, int target) {
    int [] b = new int [countOfTarget (a, target)];
    int k = 0;
    for (int i = 0;
    i < a.length; i ++) {
        if (a [i] == target) {
            b [k] = i;
            k ++;
            return b [countOfTarget (a, target) - 1];
        }
    }
    return - 1;
}
----------------------------------------

public static int findSecondToLast (int [] a, int target) {
    int prev = - 1;
    int last = - 1;
    for (int i = 0;
    i < a.length; i ++) if (a [i] == target) {
        prev = last;
        last = i;
    }

    return prev;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19531065_19531097_1_16
19531065_19531134_1_12
Title: can anyone help me find what wrong with this code 
----------------------------------------

public static int findSecondToLast (int [] a, int target) {
    int [] b = new int [countOfTarget (a, target)];
    int k = 0;
    for (int i = 0;
    i < a.length; i ++) {
        if (a [i] == target) {
            b [k] = i;
            k ++;
            return b [countOfTarget (a, target) - 1];
        }
    }
    return - 1;
}
----------------------------------------

public static int findSecondToLast (int [] a, int terget) {
    int firstFound = false;
    for (int i = a.length - 1;
    i >= 0; -- i) {
        if (a [i] == target) {
            if (firstFound) {
                return i;
            }
            firsrFound = true;
        }
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19531065_19531127_1_12
19531065_19531134_1_12
Title: can anyone help me find what wrong with this code 
----------------------------------------

public static int findSecondToLast (int [] a, int target) {
    int prev = - 1;
    int last = - 1;
    for (int i = 0;
    i < a.length; i ++) if (a [i] == target) {
        prev = last;
        last = i;
    }

    return prev;
}
----------------------------------------

public static int findSecondToLast (int [] a, int terget) {
    int firstFound = false;
    for (int i = a.length - 1;
    i >= 0; -- i) {
        if (a [i] == target) {
            if (firstFound) {
                return i;
            }
            firsrFound = true;
        }
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19531319_19540979_1_47
19531319_19541247_15_43
Title: Proper way of sorting Java beans by multiple fields 
----------------------------------------

public int compare (TemplateBean b1, TemplateBean b2) {
    if (b1 == null && b2 == null) return 0;

    if (b1 == null) return 1;

    if (b2 == null) return - 1;

    int cmp = 0;
    if ("UNATTACHED".equals (b1.getStatusCode ()) && ! "UNATTACHED".equals (b2.getStatusCode ())) {
        cmp = 1;
    }
    if (! "UNATTACHED".equals (b1.getStatusCode ()) && "UNATTACHED".equals (b2.getStatusCode ())) {
        cmp = - 1;
    }
    if (shouldBeComparenByGroupCode (b1) != shouldBeComparedByGroupCode (b2)) {
        if (! shouldBeComparenByGroupCode (b1)) {
            return - 1;
        } else {
            return 1;
        }
    }
    if (shouldBeComparenByGroupCode (b1) && shouldBeComparenByGroupCode (b2)) {
        String parent1 = b1.getGroupCode () == null ? "" : b1.getGroupCode ().toUpperCase ();
        String parent2 = b2.getGroupCode () == null ? "" : b2.getGroupCode ().toUpperCase ();
        cmp = parent1.compareTo (parent2);
    }
    if (cmp == 0) {
        Integer i1 = b1.getSortOrder () == null ? Const.ZERO : b1.getSortOrder ();
        Integer i2 = b2.getSortOrder () == null ? Const.ZERO : b2.getSortOrder ();
        cmp = i1.compareTo (i2);
    }
    if (cmp == 0) {
        String s1 = b1.getShortDescription ();
        if (s1 == null) s1 = "";

        String s2 = b2.getShortDescription ();
        if (s2 == null) s2 = "";

        cmp = s1.compareToIgnoreCase (s2);
    }
    return cmp;
}
----------------------------------------

public int compare (TemplateBean b1, TemplateBean b2) {
    if (b1 == b2) return 0;

    if (b1 == null) return 1;

    if (b2 == null) return - 1;

    int cmp = objectCompare ("UNATTACHED", b1.getStatusCode (), b2.getStatusCode ());
    if (cmp == 0) {
        cmp = objectCompare ("FIELDSIMPLE", b1.getRefRltshpTypeCode (), b2.getRefRltshpTypeCode ());
        if (cmp == 0) {
            cmp = objectCompare ("CUSTOM", b1.getRefRltshpTypeCode (), b2.getRefRltshpTypeCode ());
            if (cmp == 0) {
                cmp = objectCompare ("FUNCTION", b1.getRefRltshpTypeCode (), b2.getRefRltshpTypeCode ());
                if (cmp == 0) {
                    cmp = objectCompare (b1.getGroupCode (), b2.getGroupCode ());
                    if (cmp == 0) {
                        cmp = objectCompare (b1.getSortOrder (), b2.getSortOrder ());
                        if (cmp == 0) {
                            cmp = objectCompare (b1.getShortDescription (), b2.getShortDescription ());
                        }
                    }
                }
            }
        }
    }
    return cmp;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19531319_19541247_1_8
19531319_19541247_9_14
Title: Proper way of sorting Java beans by multiple fields 
----------------------------------------

private int objectCompare (String allowed, Comparable v1, Comparable v2) {
    if (v1 == v2) return 0;

    if (v1 == null) return 1;

    if (v2 == null) return - 1;

    boolean c1 = v1.equals (allowed);
    boolean c2 = v2.equals (allowed);
    return c1 ? c2 ? 0 : 1 : c2 ? - 1 : 0;
}
----------------------------------------

private int objectCompare (Comparable v1, Comparable v2) {
    if (v1 == v2) return 0;

    if (v1 == null) return 1;

    if (v2 == null) return - 1;

    return v1.compare (v2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19533350_19533692_1_11
19533350_19533874_22_30
Title: JavaAdding List to TreeMap and Display out key and list 
----------------------------------------

public void Add (int item, String fruit) {
    if (tMap.containsKey (item) == false) {
        fList.clear ();
        fList.add (fruit);
        tMap.put (item, fList);
        System.out.println ("Fruits added " + item);
    } else {
        tMap.get (item).add (fruit);
    }
}
----------------------------------------

public void Add (int item, String fruit) {
    if (tMap.containsKey (item)) {
        fList = tMap.get (item);
    } else {
        fList = new ArrayList < String > ();
    }
    fList.add (fruit);
    tMap.put (item, fList);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19533498_19533796_6_39
19533498_19533924_3_28
Title: Creating a table from a loop (java) 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Input the number of students");
    int numofstu = input.nextInt ();
    double totalchange = 0;
    Student [] students = new Student [numofstu];
    for (int count = 0;
    count < numofstu; count ++) {
        System.out.println ("--------------------------------");
        Student student = new Student ();
        System.out.print ("Enter student name[ " + (count + 1) + "]: ");
        student.setName (input.next ());
        System.out.print ("Input start weight[ " + (count + 1) + "]: ");
        student.setStart (input.nextDouble ());
        System.out.print ("Enter end weight[ " + (count + 1) + "]: ");
        student.setEnd (input.nextDouble ());
        totalchange += student.getChange ();
        students [count] = student;
        System.out.println ("--------------------------------");
    }
    System.out.println ("Last Name\t\tStartWeight\t\tEnd Weight\t\tWeight Change");
    for (int i = 0;
    i < students.length; i ++) {
        System.out.println (students [i].getName () + "\t\t" + students [i].getStart () + "\t\t\t" + students [i].getEnd () + "\t\t\t" + students [i].getChange ());
    }
    double avg = totalchange / numofstu;
    System.out.println ("Average weight change: " + avg);
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    System.out.println ("Input the number of students");
    int numofstu = input.nextInt ();
    student [] std = new student [numofstu];
    double totalchange = 0;
    for (int count = numofstu;
    count != 0; count --) {
        std [count] = new student ();
        System.out.print ("Enter student name: ");
        std [count].name = input.next ();
        System.out.print ("Input start weight: ");
        std [count].startWeight = input.nextDouble ();
        System.out.print ("Enter end weight: ");
        std [count].endWeight = input.nextDouble ();
    }
    for (int count = numofstu;
    count != 0; count --) {
        if (count == numofstu) System.out.println (name + "\t\t" + start + "\t\t\t" + end + "\t\t\t" + change);

        System.out.println (std [count].name + "\t\t" + std [count].startWeight + "\t\t\t" + std [count].endWeight + "\t\t\t" + std [count].change ());
        totalchange += std [count].change ();
    }
    double avg = totalchange / numofstu;
    System.out.println ("Average weight change: " + avg);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19534038_41492253_4_46
19534038_47430042_8_39
Title: WAP in Java to print the sequence 1 32 456 10987 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    int n = sc.nextInt ();
    sc.nextLine ();
    int k = 1, l = 1, m = 1, x = 1;
    for (int i = 1;
    i <= n; i ++) {
        System.out.println ();
        if (i % 2 != 0) {
            for (int j = 1;
            j <= i; j ++) {
                System.out.print (l ++);
                int a = 1;
                if (a <= j && j != i) {
                    System.out.print ("*");
                }
            }
            k = l + m * 2;
            m ++;
            l --;
        } else {
            l = k + 1;
            x = k;
            for (int j = 1;
            j <= i; j ++) {
                System.out.print (-- x);
                int a = 1;
                if (a <= j && j != i) {
                    System.out.print ("*");
                }
            }
            l --;
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    int b = 0, a;
    System.out.println ("Enter the limit:");
    int n = s.nextInt ();
    for (int i = 1;
    i <= n; i ++) {
        if (i % 2 == 0) {
            for (int j = 1;
            j <= i; j ++) {
                b = b + 1;
            }
            a = b;
            for (int j = 1;
            j <= i; j ++) {
                System.out.print (a --);
                if (j != i) {
                    System.out.print ("*");
                }
            }
            System.out.println ("");
        } else {
            for (int k = 1;
            k <= i; k ++) {
                b = b + 1;
                System.out.print (b);
                if (k != i) {
                    System.out.print ("*");
                }
            }
            System.out.println ("");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19534038_41492253_4_46
19534038_51574575_1_27
Title: WAP in Java to print the sequence 1 32 456 10987 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    int n = sc.nextInt ();
    sc.nextLine ();
    int k = 1, l = 1, m = 1, x = 1;
    for (int i = 1;
    i <= n; i ++) {
        System.out.println ();
        if (i % 2 != 0) {
            for (int j = 1;
            j <= i; j ++) {
                System.out.print (l ++);
                int a = 1;
                if (a <= j && j != i) {
                    System.out.print ("*");
                }
            }
            k = l + m * 2;
            m ++;
            l --;
        } else {
            l = k + 1;
            x = k;
            for (int j = 1;
            j <= i; j ++) {
                System.out.print (-- x);
                int a = 1;
                if (a <= j && j != i) {
                    System.out.print ("*");
                }
            }
            l --;
        }
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Scanner sc = new Scanner (System.in);
    int n, k = 0;
    n = sc.nextInt ();
    for (int i = 0;
    i < n; i ++) {
        if (i % 2 == 0) {
            for (int y = 0;
            y < i; y ++) {
                System.out.print (++ k + "*");
            }
            System.out.print (++ k);
        } else {
            int t = k + i + 1;
            for (int x = 0;
            x < i; x ++) {
                System.out.print ((t --) + "*");
            }
            System.out.print (t --);
            k = k + i + 1;
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19534038_47430042_8_39
19534038_51574575_1_27
Title: WAP in Java to print the sequence 1 32 456 10987 
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    int b = 0, a;
    System.out.println ("Enter the limit:");
    int n = s.nextInt ();
    for (int i = 1;
    i <= n; i ++) {
        if (i % 2 == 0) {
            for (int j = 1;
            j <= i; j ++) {
                b = b + 1;
            }
            a = b;
            for (int j = 1;
            j <= i; j ++) {
                System.out.print (a --);
                if (j != i) {
                    System.out.print ("*");
                }
            }
            System.out.println ("");
        } else {
            for (int k = 1;
            k <= i; k ++) {
                b = b + 1;
                System.out.print (b);
                if (k != i) {
                    System.out.print ("*");
                }
            }
            System.out.println ("");
        }
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Scanner sc = new Scanner (System.in);
    int n, k = 0;
    n = sc.nextInt ();
    for (int i = 0;
    i < n; i ++) {
        if (i % 2 == 0) {
            for (int y = 0;
            y < i; y ++) {
                System.out.print (++ k + "*");
            }
            System.out.print (++ k);
        } else {
            int t = k + i + 1;
            for (int x = 0;
            x < i; x ++) {
                System.out.print ((t --) + "*");
            }
            System.out.print (t --);
            k = k + i + 1;
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19535462_19535494_1_25
19535462_19535608_1_12
Title: Why isn't this excluding vowels? 
----------------------------------------

public static boolean noVowel (String word) {
    for (int i = 0;
    i < word.length (); i ++) {
        if (word.charAt (i) == 'a') {
            return false;
        }
        if (word.charAt (i) == 'e') {
            return false;
        }
        if (word.charAt (i) == 'i') {
            return false;
        }
        if (word.charAt (i) == 'o') {
            return false;
        }
        if (word.charAt (i) == 'u') {
            return false;
        }
        if (word.charAt (i) == 'y') {
            return false;
        }
    }
    return true;
}
----------------------------------------

public static boolean noVowel (String word) {
    boolean noVowel = true;
    for (int i = 0;
    i < word.length (); i ++) {
        char ch = word.charAt (i);
        if (ch == 'a' || ch == 'e' || ch == 'i' || ch == 'o' || ch == 'u' || ch == 'y') {
            noVowel = false;
            break;
        }
    }
    return noVowel;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19537636_19538284_19_27
19537636_19538499_21_29
Title: Java notify() run before wait()? 
----------------------------------------

public void run () {
    for (int i = 0;
    i < 100; i ++) {
        total += i;
    }
    try {
        ThreadA.barrier.await ();
    } catch (InterruptedException | BrokenBarrierException ex) {
    }
}
----------------------------------------

public void run () {
    for (int i = 0;
    i < 100; i ++) {
        total += i;
    }
    synchronized (ThreadA.latch) {
        ThreadA.done = true;
        ThreadA.latch.notify ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19537636_19538284_4_12
19537636_19538499_4_14
Title: Java notify() run before wait()? 
----------------------------------------

public static void main (String [] args) {
    ThreadB b = new ThreadB ();
    b.start ();
    try {
        barrier.await ();
        System.out.println ("Total is: " + b.total);
    } catch (InterruptedException | BrokenBarrierException ex) {
    }
}
----------------------------------------

public static void main (String [] args) {
    ThreadB b = new ThreadB ();
    b.start ();
    synchronized (latch) {
        while (! done) {
            latch.wait ();
        }
    }
    System.out.println ("Total is: " + b.total);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19538999_19539045_1_14
19538999_19539055_1_14
Title: how the Try catch finally block is executed by JVM 
----------------------------------------

public static int TestTryFinallyBlock () {
    int i = 0;
    try {
        i = 10;
    } finally {
        i = 40;
        return i;
    }
}
----------------------------------------

public static int TestTryFinallyBlock () {
    int i = 0;
    try {
        i = 10;
        return i;
    } finally {
        i = 40;
        System.out.println ("local: " + i);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19538999_19539045_1_14
19538999_19541306_1_17
Title: how the Try catch finally block is executed by JVM 
----------------------------------------

public static int TestTryFinallyBlock () {
    int i = 0;
    try {
        i = 10;
    } finally {
        i = 40;
        return i;
    }
}
----------------------------------------

public static int TestTryFinallyBlock () {
    int returnValue;
    try {
        int i = 0;
        i = 10;
        returnValue = i;
        i = 40;
        return returnValue;
    } catch (RuntimeException e) {
        i = 40;
        throw e;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19538999_19539055_1_14
19538999_19541306_1_17
Title: how the Try catch finally block is executed by JVM 
----------------------------------------

public static int TestTryFinallyBlock () {
    int i = 0;
    try {
        i = 10;
        return i;
    } finally {
        i = 40;
        System.out.println ("local: " + i);
    }
}
----------------------------------------

public static int TestTryFinallyBlock () {
    int returnValue;
    try {
        int i = 0;
        i = 10;
        returnValue = i;
        i = 40;
        return returnValue;
    } catch (RuntimeException e) {
        i = 40;
        throw e;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19543209_19561805_1_15
19543209_36056418_1_21
Title: How to set the connection and read timeout with Jersey 2.x? 
----------------------------------------

public static void main (String [] args) {
    Client client = ClientBuilder.newClient ();
    client.property (ClientProperties.CONNECT_TIMEOUT, 1000);
    client.property (ClientProperties.READ_TIMEOUT, 1000);
    WebTarget target = client.target ("http://1.2.3.4:8080");
    try {
        String responseMsg = target.path ("application.wadl").request ().get (String.class);
        System.out.println ("responseMsg: " + responseMsg);
    } catch (ProcessingException pe) {
        pe.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    Client client = ClientBuilder.newClient ();
    WebTarget target = client.target ("http://1.2.3.4:8080");
    client.property (ClientProperties.CONNECT_TIMEOUT, 1000);
    client.property (ClientProperties.READ_TIMEOUT, 1000);
    try {
        Invocation.Builder request = target.request ();
        request.property (ClientProperties.CONNECT_TIMEOUT, 500);
        request.property (ClientProperties.READ_TIMEOUT, 500);
        String responseMsg = request.get (String.class);
        System.out.println ("responseMsg: " + responseMsg);
    } catch (ProcessingException pe) {
        pe.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19549961_19549986_1_11
19549961_19550155_1_11
Title: For loop with substrings 
----------------------------------------

void printSubstring () {
    int len = s.length ();
    for (int i = 1;
    i < len + 1; i ++) {
        for (int k = 0;
        k < len - i; k ++) System.out.print (s.substring (k, k + i) + ", ");

    }
    System.out.println ();
}
----------------------------------------

void printSubstring (String s) {
    if (s == null) {
        return;
    }
    for (int lenghtSubstring = 1;
    lenghtSubstring <= s.length (); lenghtSubstring ++) {
        for (int index = 0;
        index <= s.length () - lenghtSubstring; index ++) {
            System.out.print (s.substring (index, index + lenghtSubstring) + ",");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19550984_19551087_1_15
19550984_19551119_1_15
Title: View if a word's letters are in ascending order 
----------------------------------------

public static boolean ascending (String word) {
    if (word == null || word.length < 2) return false;

    int i = 0;
    boolean ascend = false;
    while (i < word.length () - 1) {
        if (word.charAt (i) <= word.charAt (i + 1)) ascend = true;
        else {
            ascend = false;
            break;
        }
        i ++;
    }
    return (ascend);
}
----------------------------------------

public static boolean ascending (String word) {
    int i = 0;
    boolean ascend;
    while (i < word.length () - 1) {
        if (word.charAt (i) <= word.charAt (i + 1)) ascend = false;
        else ascend = true;

        i ++;
    }
    i = 0;
    return (ascend);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_21432777_23_45
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_21988067_13_51
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_26011529_5_47
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_26907338_2_40
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_28059496_53_80
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_31912947_5_22
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_35662562_1_42
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_46255600_1_49
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_19577808_2_42
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] answer = new int [P.length];
    char [] chars = S.toCharArray ();
    int [] [] cumulativeAnswers = new int [4] [chars.length + 1];
    for (int iii = 0;
    iii < chars.length; iii ++) {
        if (iii > 0) {
            for (int zzz = 0;
            zzz < 4; zzz ++) {
                cumulativeAnswers [zzz] [iii + 1] = cumulativeAnswers [zzz] [iii];
            }
        }
        switch (chars [iii]) {
            case 'A' :
                cumulativeAnswers [0] [iii + 1] ++;
                break;
            case 'C' :
                cumulativeAnswers [1] [iii + 1] ++;
                break;
            case 'G' :
                cumulativeAnswers [2] [iii + 1] ++;
                break;
            case 'T' :
                cumulativeAnswers [3] [iii + 1] ++;
                break;
        }
    }
    for (int iii = 0;
    iii < P.length; iii ++) {
        for (int zzz = 0;
        zzz < 4; zzz ++) {
            if ((cumulativeAnswers [zzz] [Q [iii] + 1] - cumulativeAnswers [zzz] [P [iii]]) > 0) {
                answer [iii] = zzz + 1;
                break;
            }
        }
    }
    return answer;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21432777_23_45
19552754_21988067_13_51
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21432777_23_45
19552754_26011529_5_47
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21432777_23_45
19552754_26907338_2_40
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21432777_23_45
19552754_28059496_53_80
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21432777_23_45
19552754_31912947_5_22
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21432777_23_45
19552754_35662562_1_42
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21432777_23_45
19552754_46255600_1_49
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21432777_23_45
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    final char [] characterInput = S.toCharArray ();
    final int [] integerInput = new int [characterInput.length];
    for (int counter = 0;
    counter < characterInput.length; counter ++) {
        integerInput [counter] = characterMapping.get (characterInput [counter]);
    }
    int [] result = new int [P.length];
    for (int index = 0;
    index < P.length; index ++) {
        if (P [index] == Q [index]) {
            result [index] = integerInput [P [index]];
            break;
        }
        final int [] subArray = Arrays.copyOfRange (integerInput, P [index], Q [index] + 1);
        final int minimumValue = minimum (subArray);
        result [index] = minimumValue;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21988067_13_51
19552754_26011529_5_47
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21988067_13_51
19552754_26907338_2_40
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21988067_13_51
19552754_28059496_53_80
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21988067_13_51
19552754_31912947_5_22
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21988067_13_51
19552754_35662562_1_42
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21988067_13_51
19552754_46255600_1_49
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_21988067_13_51
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] M = new int [P.length];
    char [] charArr = S.toCharArray ();
    int [] [] occCount = new int [3] [S.length () + 1];
    int charInd = getChar (charArr [0]);
    if (charInd != 3) {
        occCount [charInd] [1] ++;
    }
    for (int sInd = 1;
    sInd < S.length (); sInd ++) {
        charInd = getChar (charArr [sInd]);
        if (charInd != 3) occCount [charInd] [sInd + 1] ++;

        occCount [Index_A] [sInd + 1] += occCount [Index_A] [sInd];
        occCount [Index_C] [sInd + 1] += occCount [Index_C] [sInd];
        occCount [Index_G] [sInd + 1] += occCount [Index_G] [sInd];
    }
    for (int i = 0;
    i < P.length; i ++) {
        int a, c, g;
        if (Q [i] + 1 >= occCount [0].length) continue;

        a = occCount [Index_A] [Q [i] + 1] - occCount [Index_A] [P [i]];
        c = occCount [Index_C] [Q [i] + 1] - occCount [Index_C] [P [i]];
        g = occCount [Index_G] [Q [i] + 1] - occCount [Index_G] [P [i]];
        M [i] = a > 0 ? A : c > 0 ? C : g > 0 ? G : T;
    }
    return M;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26011529_5_47
19552754_26907338_2_40
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26011529_5_47
19552754_28059496_53_80
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26011529_5_47
19552754_31912947_5_22
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26011529_5_47
19552754_35662562_1_42
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26011529_5_47
19552754_46255600_1_49
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26011529_5_47
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int N = S.length ();
    int M = P.length;
    int [] result = new int [M];
    lastOccurrencesMap = new int [3] [N];
    int lastA = - 1;
    int lastC = - 1;
    int lastG = - 1;
    for (int i = 0;
    i < N; i ++) {
        char c = S.charAt (i);
        if (c == 'A') {
            lastA = i;
        } else if (c == 'C') {
            lastC = i;
        } else if (c == 'G') {
            lastG = i;
        }

        lastOccurrencesMap [0] [i] = lastA;
        lastOccurrencesMap [1] [i] = lastC;
        lastOccurrencesMap [2] [i] = lastG;
    }
    for (int i = 0;
    i < M; i ++) {
        int startIndex = P [i];
        int endIndex = Q [i];
        int minimum = 4;
        for (int n = 0;
        n < 3; n ++) {
            int lastOccurence = getLastNucleotideOccurrence (startIndex, endIndex, n);
            if (lastOccurence != 0) {
                minimum = n + 1;
                break;
            }
        }
        result [i] = minimum;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26907338_2_40
19552754_28059496_53_80
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26907338_2_40
19552754_31912947_5_22
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26907338_2_40
19552754_35662562_1_42
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26907338_2_40
19552754_46255600_1_49
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_26907338_2_40
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int qSize = Q.length;
    int [] answers = new int [qSize];
    char [] sequence = S.toCharArray ();
    int [] [] occCount = new int [3] [sequence.length + 1];
    int [] geneImpactMap = new int ['G' + 1];
    geneImpactMap ['A'] = 0;
    geneImpactMap ['C'] = 1;
    geneImpactMap ['G'] = 2;
    if (sequence [0] != 'T') {
        occCount [geneImpactMap [sequence [0]]] [0] ++;
    }
    for (int i = 0;
    i < sequence.length; i ++) {
        occCount [0] [i + 1] = occCount [0] [i];
        occCount [1] [i + 1] = occCount [1] [i];
        occCount [2] [i + 1] = occCount [2] [i];
        if (sequence [i] != 'T') {
            occCount [geneImpactMap [sequence [i]]] [i + 1] ++;
        }
    }
    for (int j = 0;
    j < qSize; j ++) {
        for (int k = 0;
        k < 3; k ++) {
            if (occCount [k] [Q [j] + 1] - occCount [k] [P [j]] > 0) {
                answers [j] = k + 1;
                break;
            }
            answers [j] = 4;
        }
    }
    return answers;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_28059496_53_80
19552754_31912947_5_22
Title: java codility training Genomic-range-query 
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_28059496_53_80
19552754_35662562_1_42
Title: java codility training Genomic-range-query 
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_28059496_53_80
19552754_46255600_1_49
Title: java codility training Genomic-range-query 
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_28059496_53_80
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

public static int [] solution (String S, int [] P, int [] Q) {
    int [] arr = new int [S.length ()];
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                arr [i] = 1;
                break;
            case 'C' :
                arr [i] = 2;
                break;
            case 'G' :
                arr [i] = 3;
                break;
            case 'T' :
                arr [i] = 4;
                break;
            default :
                break;
        }
    }
    segmentNode root = buildTree (arr, 0, S.length () - 1);
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        result [i] = getMin (root, P [i], Q [i]);
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_31912947_5_22
19552754_35662562_1_42
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_31912947_5_22
19552754_46255600_1_49
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_31912947_5_22
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    mHolder = createImpactHolderArray (S);
    int queriesLength = P.length;
    int [] result = new int [queriesLength];
    for (int i = 0;
    i < queriesLength; ++ i) {
        int value = 0;
        if (P [i] == Q [i]) {
            value = lookupValueForIndex (S.charAt (P [i])) + 1;
        } else {
            value = calculateMinImpactFactor (P [i], Q [i]);
        }
        result [i] = value;
    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_35662562_1_42
19552754_46255600_1_49
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_35662562_1_42
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

public int [] solution (String S, int [] P, int [] K) {
    char [] sc = S.toCharArray ();
    int [] A = new int [sc.length];
    int [] G = new int [sc.length];
    int [] C = new int [sc.length];
    int prevA = - 1, prevG = - 1, prevC = - 1;
    for (int i = 0;
    i < sc.length; i ++) {
        if (sc [i] == 'A') prevA = i;
        else if (sc [i] == 'G') prevG = i;
        else if (sc [i] == 'C') prevC = i;

        A [i] = prevA;
        G [i] = prevG;
        C [i] = prevC;
    }
    int [] result = new int [P.length];
    for (int i = 0;
    i < P.length; i ++) {
        if (A [K [i]] >= P [i] && A [K [i]] <= K [i]) {
            result [i] = 1;
        } else if (C [K [i]] >= P [i] && C [K [i]] <= K [i]) {
            result [i] = 2;
        } else if (G [K [i]] >= P [i] && G [K [i]] <= K [i]) {
            result [i] = 3;
        } else {
            result [i] = 4;
        }

    }
    return result;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19552754_46255600_1_49
19552754_47864388_1_68
Title: java codility training Genomic-range-query 
----------------------------------------

static public int [] solution (String S, int [] P, int [] Q) {
    int A [] = new int [S.length () + 1], C [] = new int [S.length () + 1], G [] = new int [S.length () + 1];
    int last_a = 0, last_c = 0, last_g = 0;
    int results [] = new int [P.length];
    int p = 0, q = 0;
    for (int i = S.length () - 1;
    i >= 0; i -= 1) {
        switch (S.charAt (i)) {
            case 'A' :
                {
                    last_a += 1;
                    break;
                } case 'C' :
                {
                    last_c += 1;
                    break;
                } case 'G' :
                {
                    last_g += 1;
                    break;
                }}
        A [i] = last_a;
        G [i] = last_g;
        C [i] = last_c;
    }
    for (int i = 0;
    i < P.length; i ++) {
        p = P [i];
        q = Q [i];
        if (A [p] - A [q + 1] > 0) {
            results [i] = 1;
        } else if (C [p] - C [q + 1] > 0) {
            results [i] = 2;
        } else if (G [p] - G [q + 1] > 0) {
            results [i] = 3;
        } else {
            results [i] = 4;
        }

    }
    return results;
}
----------------------------------------

public int [] solution (String S, int [] P, int [] Q) {
    int [] result = new int [P.length];
    int [] factor1 = new int [S.length ()];
    int [] factor2 = new int [S.length ()];
    int [] factor3 = new int [S.length ()];
    int [] factor4 = new int [S.length ()];
    int factor1Sum = 0;
    int factor2Sum = 0;
    int factor3Sum = 0;
    int factor4Sum = 0;
    for (int i = 0;
    i < S.length (); i ++) {
        switch (S.charAt (i)) {
            case 'A' :
                factor1Sum ++;
                break;
            case 'C' :
                factor2Sum ++;
                break;
            case 'G' :
                factor3Sum ++;
                break;
            case 'T' :
                factor4Sum ++;
                break;
            default :
                break;
        }
        factor1 [i] = factor1Sum;
        factor2 [i] = factor2Sum;
        factor3 [i] = factor3Sum;
        factor4 [i] = factor4Sum;
    }
    for (int i = 0;
    i < P.length; i ++) {
        int start = P [i];
        int end = Q [i];
        if (start == 0) {
            if (factor1 [end] > 0) {
                result [i] = 1;
            } else if (factor2 [end] > 0) {
                result [i] = 2;
            } else if (factor3 [end] > 0) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        } else {
            if (factor1 [end] > factor1 [start - 1]) {
                result [i] = 1;
            } else if (factor2 [end] > factor2 [start - 1]) {
                result [i] = 2;
            } else if (factor3 [end] > factor3 [start - 1]) {
                result [i] = 3;
            } else {
                result [i] = 4;
            }

        }
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
1955322_1984519_123_137
1955322_1984519_96_109
Title: At what point is it worth reusing arrays in Java? 
----------------------------------------

public int doRun () {
    final int size;
    size = length;
    array = new int [size];
    for (int i = 0;
    i < size; i ++) {
        array [i] = random.nextInt ();
    }
    return (array [size - 1]);
}
----------------------------------------

public int doRun () {
    final int size;
    size = array.length;
    for (int i = 0;
    i < size; i ++) {
        array [i] = random.nextInt ();
    }
    return (array [size - 1]);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19553731_19553775_1_13
19553731_19553781_1_14
Title: Java Strings empty string handling 
----------------------------------------

public static void printLetters (String text) {
    if (text != null && text.length () != 0) {
        System.out.print (text.charAt (0));
        for (int i = 1;
        i < text.length (); i ++) {
            System.out.print ("-" + text.charAt (i));
        }
    }
    System.out.println ();
}
----------------------------------------

public static void printLetters (String text) {
    if (text == null) {
        return;
    }
    for (int i = 0;
    i < text.length (); i ++) {
        System.out.print (text.charAt (i) + ",");
    }
    System.out.println ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19555606_19555738_1_20
19555606_19555946_1_26
Title: Creating new List dynamically from successive elements of another list 
----------------------------------------

public static List < Integer > parseList (List < Integer > input, int difference) {
    List < Integer > output = new ArrayList < Integer > ();
    boolean isSeq = false;
    for (int i = 0;
    i < input.size () - 1; i ++) {
        if ((input.get (i + 1) - input.get (i)) == difference) {
            if (! isSeq) {
                output.add (input.get (i));
                isSeq = true;
            }
        } else {
            isSeq = false;
            output.add (input.get (i));
        }
    }
    output.add (input.get (input.size () - 1));
    return output;
}
----------------------------------------

public static List < Integer > parseList (List < Integer > input, int difference) {
    List < Integer > output = new ArrayList < Integer > ();
    if (input.size () > 0) {
        int indexToAdd = - 1;
        output.add (input.get (0));
        for (int i = 1;
        i < input.size (); i ++) {
            if ((input.get (i) - input.get (i - 1)) == difference) {
                if (i == input.size () - 1) {
                    output.add (input.get (i));
                } else {
                    indexToAdd = i;
                }
            } else {
                if (indexToAdd != - 1) {
                    output.add (input.get (indexToAdd));
                    indexToAdd = - 1;
                }
                output.add (input.get (i));
            }
        }
    }
    return output;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19557655_19557716_1_28
19557655_19557985_1_28
Title: Tic Tac Toe Java Almost Done except for slight display error 
----------------------------------------

public static void getMove (int theSeed) {
    int row = 0;
    int col = 0;
    boolean validInput = false;
    do {
        if (theSeed == EX) {
            System.out.println ("Enter a row (0,1,2) for player X: ");
            row = in.nextInt ();
            System.out.println ("Enter a column (0,1,2) for player X: ");
            col = in.nextInt ();
        } else {
            System.out.println ("Enter a row (0,1,2) for player O: ");
            row = in.nextInt ();
            System.out.println ("Enter a column (0,1,2) for player O: ");
            col = in.nextInt ();
        }
        if (row >= 0 && row < SIZE && col >= 0 && col < SIZE && board [row] [col] == BLANK) {
            currentRow = row;
            currentCol = col;
            board [currentRow] [currentCol] = theSeed;
            validInput = true;
        } else {
            System.out.println ("This move at (" + (row) + "," + (col) + ") is not valid. Try again...");
        }
    } while (! validInput);
}
----------------------------------------

public static void getMove (int theSeed) {
    boolean validInput = false;
    int row = 0;
    int col = 0;
    do {
        if (theSeed == EX) {
            System.out.println ("Enter a row (1,2,3) for player X: ");
            row = in.nextInt () - 1;
            System.out.println ("Enter a column (1,2,3) for player X: ");
            col = in.nextInt () - 1;
        } else {
            System.out.println ("Enter a row (1,2,3) for player O: ");
            row = in.nextInt () - 1;
            System.out.println ("Enter a column (1,2,3) for player O: ");
            col = in.nextInt () - 1;
        }
        if (row >= 0 && row < SIZE && col >= 0 && col < SIZE && board [row] [col] == BLANK) {
            currentRow = row;
            currentCol = col;
            board [currentRow] [currentCol] = theSeed;
            validInput = true;
        } else {
            System.out.println ("This move at (" + (row) + "," + (col) + ") is not valid. Try again...");
        }
    } while (! validInput);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19557655_19557757_71_99
19557655_19557985_1_28
Title: Tic Tac Toe Java Almost Done except for slight display error 
----------------------------------------

public static void getMove (int theSeed) {
    boolean validInput = false;
    do {
        int row = 0;
        int col = 0;
        if (theSeed == EX) {
            System.out.println ("Enter a row (0,1,2) for player X: ");
            row = in.nextInt ();
            System.out.println ("Enter a column (0,1,2) for player X: ");
            col = in.nextInt ();
        } else {
            System.out.println ("Enter a row (0,1,2) for player O: ");
            row = in.nextInt ();
            System.out.println ("Enter a column (0,1,2) for player O: ");
            col = in.nextInt ();
        }
        if (row >= 0 && row < SIZE && col >= 0 && col < SIZE && board [row] [col] == BLANK) {
            currentRow = row;
            currentCol = col;
            board [currentRow] [currentCol] = theSeed;
            validInput = true;
        } else {
            System.out.println ("This move at (" + (row) + "," + (col) + ") is not valid. Try again...");
        }
    } while (! validInput);
}
----------------------------------------

public static void getMove (int theSeed) {
    boolean validInput = false;
    int row = 0;
    int col = 0;
    do {
        if (theSeed == EX) {
            System.out.println ("Enter a row (1,2,3) for player X: ");
            row = in.nextInt () - 1;
            System.out.println ("Enter a column (1,2,3) for player X: ");
            col = in.nextInt () - 1;
        } else {
            System.out.println ("Enter a row (1,2,3) for player O: ");
            row = in.nextInt () - 1;
            System.out.println ("Enter a column (1,2,3) for player O: ");
            col = in.nextInt () - 1;
        }
        if (row >= 0 && row < SIZE && col >= 0 && col < SIZE && board [row] [col] == BLANK) {
            currentRow = row;
            currentCol = col;
            board [currentRow] [currentCol] = theSeed;
            validInput = true;
        } else {
            System.out.println ("This move at (" + (row) + "," + (col) + ") is not valid. Try again...");
        }
    } while (! validInput);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19558027_19558470_1_28
19558027_19558482_7_46
Title: 10 element Array will only accept 5 integers during Selection sort project 
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int j = 1;
    List < Integer > list = new ArrayList < > ();
    System.out.println ("Enter 10 integers - one at a time...");
    for (int i = 0;
    i < 10; i ++) {
        System.out.print ("Enter integer #" + j + ": ");
        list.add (input.nextInt ());
        j ++;
        Collections.sort (list);
        System.out.print ("Sorted numbers: ");
        for (int p = 0;
        p < list.size (); p ++) {
            if (list.get (p) != 0) System.out.print (list.get (p) + " ");

        }
        System.out.print ("\n");
    }
    System.out.println ("Done!");
}
----------------------------------------

public static void main (String [] args) {
    Scanner input = new Scanner (System.in);
    int j = 1;
    int [] list = new int [11];
    System.out.println ("Enter 10 integers - one at a time...");
    for (int i = 0;
    i < list.length - 1; i ++) {
        System.out.print ("Enter integer #" + j + ": ");
        int temp = input.nextInt ();
        for (int p = 0;
        p < list.length; p ++) {
            if (list [p] == 0) {
                list [p] = temp;
                break;
            }
        }
        j ++;
        SelectionSort.sort (list);
        System.out.print ("Sorted numbers: ");
        for (int p = 1;
        p < list.length; p ++) {
            if (list [p] != 0) System.out.print (list [p] + " ");

        }
        System.out.print ("\n");
    }
    System.out.println ("Done!");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
19559882_19559972_1_12
19559882_19560138_1_12
Title: Checking an array list against another array list 
----------------------------------------

public boolean allKnown (ArrayList < String > wordList) {
    boolean result = true;
    for (int index = 0;
    index < wordList.size () && result; index ++) {
        if (! words.contains (wordList.get (index))) {
            result = false;
        }
    }
    return result;
}
----------------------------------------

public boolean allKnown (ArrayList < String > wordList) {
    boolean result = true;
    for (String word : wordList) {
        if (! words.contains (word)) {
            result = false;
        }
    }
    return result;
}
----------------------------------------
