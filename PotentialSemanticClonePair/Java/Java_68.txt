$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30190377_30190476_2_21
30190377_30190499_4_22
Title: Asking for multiple user inputs then printing them below separetely 
----------------------------------------

public static void main (String [] args) {
    Scanner read = new Scanner (System.in);
    System.out.println ("How many inputs?");
    int inp = read.nextInt ();
    int [] answers = new int [inp];
    for (int i = 1;
    i <= inp; i ++) {
        System.out.print ("What was " + i + ". input? ");
        int print = read.nextInt ();
        System.out.println (print);
        answers [i] = print;
    }
    int index = 0;
    for (int a : answers) {
        System.out.println (index + ")" + " " + a);
        index ++;
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner read = new Scanner (System.in);
    System.out.println ("How many inputs?");
    int inp = read.nextInt ();
    int [] keepInputsHere = new int [inp];
    for (int i = 0;
    i < inp; i ++) {
        System.out.print ("What was " + i + ". input? ");
        int readInt = read.nextInt ();
        keepInputsHere [i] = readInt;
    }
    System.out.print ("Print results: ");
    for (int i = 0;
    i < inp; i ++) {
        System.out.print (keepInputsHere [i]);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30190377_30190476_2_21
30190377_30190534_2_19
Title: Asking for multiple user inputs then printing them below separetely 
----------------------------------------

public static void main (String [] args) {
    Scanner read = new Scanner (System.in);
    System.out.println ("How many inputs?");
    int inp = read.nextInt ();
    int [] answers = new int [inp];
    for (int i = 1;
    i <= inp; i ++) {
        System.out.print ("What was " + i + ". input? ");
        int print = read.nextInt ();
        System.out.println (print);
        answers [i] = print;
    }
    int index = 0;
    for (int a : answers) {
        System.out.println (index + ")" + " " + a);
        index ++;
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner read = new Scanner (System.in);
    System.out.println ("How many inputs?");
    int inp = read.nextInt ();
    List < Integer > numbers = new ArrayList < Integer > ();
    for (int i = 1;
    i <= inp; i ++) {
        System.out.print ("What was " + i + ". input? ");
        int print = read.nextInt ();
        numbers.add (print);
        System.out.println (print);
    }
    System.out.println ("Inputs are :");
    for (Integer integer : numbers) {
        System.out.println (integer);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30190377_30190499_4_22
30190377_30190534_2_19
Title: Asking for multiple user inputs then printing them below separetely 
----------------------------------------

public static void main (String [] args) {
    Scanner read = new Scanner (System.in);
    System.out.println ("How many inputs?");
    int inp = read.nextInt ();
    int [] keepInputsHere = new int [inp];
    for (int i = 0;
    i < inp; i ++) {
        System.out.print ("What was " + i + ". input? ");
        int readInt = read.nextInt ();
        keepInputsHere [i] = readInt;
    }
    System.out.print ("Print results: ");
    for (int i = 0;
    i < inp; i ++) {
        System.out.print (keepInputsHere [i]);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner read = new Scanner (System.in);
    System.out.println ("How many inputs?");
    int inp = read.nextInt ();
    List < Integer > numbers = new ArrayList < Integer > ();
    for (int i = 1;
    i <= inp; i ++) {
        System.out.print ("What was " + i + ". input? ");
        int print = read.nextInt ();
        numbers.add (print);
        System.out.println (print);
    }
    System.out.println ("Inputs are :");
    for (Integer integer : numbers) {
        System.out.println (integer);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30200538_30200651_10_18
30200538_30200666_8_17
Title: What is wrong with my Java recursive fibonacci function? 
----------------------------------------

public static int fibonacci (int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci (n - 1) + fibonacci (n - 2);
    }

}
----------------------------------------

public static int fibonacci (int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        int result = fibonacci (n - 1) + fibonacci (n - 2);
        return result;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30200538_30200651_10_18
30200538_30200789_9_17
Title: What is wrong with my Java recursive fibonacci function? 
----------------------------------------

public static int fibonacci (int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci (n - 1) + fibonacci (n - 2);
    }

}
----------------------------------------

public static int fibonacci (int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci (n - 1) + fibonacci (n - 2);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30200538_30200666_8_17
30200538_30200789_9_17
Title: What is wrong with my Java recursive fibonacci function? 
----------------------------------------

public static int fibonacci (int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        int result = fibonacci (n - 1) + fibonacci (n - 2);
        return result;
    }

}
----------------------------------------

public static int fibonacci (int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci (n - 1) + fibonacci (n - 2);
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30202582_30204510_19_42
30202582_30208433_27_96
Title: Wait for and then receive textfield input without freezing GUI 
----------------------------------------

public void start (Stage primaryStage) {
    BorderPane root = new BorderPane ();
    progressBar = new ProgressBar ();
    progressBar.progressProperty ().bindBidirectional (percentOfTimeUsed);
    root.setTop (progressBar);
    Button answer = new Button ("Answer");
    answer.setOnAction (ae -> restart ());
    Button skip = new Button ("Skip");
    skip.setOnAction (ae -> restart ());
    HBox mainContent = new HBox (15, new Label ("Your Question"), new TextField ("The answer"), answer, skip);
    root.setCenter (mainContent);
    timer.setOnFinished (ae -> restart ());
    primaryStage.setScene (new Scene (root));
    primaryStage.show ();
    restart ();
}
----------------------------------------

public void start (Stage stage) {
    VBox box = new VBox (10);
    box.setPadding (new Insets (10));
    Scene scene = new Scene (new ScrollPane (box), 500, 200);
    ObservableList < String > questions = FXCollections.observableArrayList ("1) Whats your (full) name?", "2) How old are you?", "3) Whats your Birthday?", "4) What starsign does that make it?", "5) Whats your favourite colour?", "6) Whats your lucky number?", "7) Do you have any pets?", "8) Where are you from?", "9) How tall are you?", "10) What shoe size are you?");
    ObservableList < String > answers = FXCollections.observableArrayList ();
    final PauseTransition pt = new PauseTransition (Duration.millis (5000));
    Label questionLabel = new Label (questions.get (questionIndex));
    Label timerLabel = new Label ("Time Remaining : ");
    Label time = new Label ();
    time.setStyle ("-fx-text-fill: RED");
    TextField answerField = new TextField ();
    Button nextQuestion = new Button ("Next");
    pt.currentTimeProperty ().addListener (new ChangeListener < Duration > () {
        @Override
        public void changed (ObservableValue < ? extends Duration > observable, Duration oldValue, Duration newValue) {
            time.setText (String.valueOf (5 - (int) newValue.toSeconds ()));
        }}

    );
    box.getChildren ().addAll (questionLabel, answerField, new HBox (timerLabel, time), nextQuestion);
    nextQuestion.setOnAction ((ActionEvent event) -> {
        answers.add (questionIndex, answerField.getText ());
        if (questionIndex == noOfQuestions - 1) {
            pt.stop ();
            box.getChildren ().clear ();
            IntStream.range (0, noOfQuestions).forEach (i -> {
                Label question = new Label ("Question : " + questions.get (i));
                question.setStyle ("-fx-text-fill: RED");
                Label answer = new Label ("Answer : " + answers.get (i));
                answer.setStyle ("-fx-text-fill: GREEN");
                box.getChildren ().addAll (question, answer);
            });
        } else {
            questionLabel.setText (questions.get (++ questionIndex));
            answerField.clear ();
            pt.playFromStart ();
        }
    });
    pt.setOnFinished ((ActionEvent event) -> {
        nextQuestion.fire ();
    });
    pt.play ();
    stage.setScene (scene);
    stage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30204036_30204108_1_18
30204036_30204115_1_24
Title: Equilateral triangle in Java using for loop 
----------------------------------------

public static void main (String [] args) {
    int number_of_stars = getHeight ();
    for (int rows = 1;
    rows <= getHeight (); rows ++) {
        for (int spaces = 1;
        spaces <= number_of_stars; spaces ++) {
            System.out.print (" ");
        }
        for (int star = 1;
        star <= rows; star ++) {
            if (rows == getRowNum ()) {
                System.out.print ("x");
            } else {
                System.out.print ("*");
            }
            System.out.print (" ");
        }
        System.out.println ("");
        number_of_stars = number_of_stars - 1;
    }
}
----------------------------------------

public static void main (String [] args) {
    int userRowNumber = 5;
    int height = 10;
    int number_of_stars = height;
    String charToPrint;
    for (int rows = 1;
    rows <= height; rows ++) {
        charToPrint = "*";
        if (rows == userRowNumber) {
            charToPrint = "x";
        }
        for (int spaces = 1;
        spaces <= number_of_stars; spaces ++) {
            System.out.print (" ");
        }
        for (int star = 1;
        star <= rows; star ++) {
            System.out.print (charToPrint);
            System.out.print (" ");
        }
        System.out.println ("");
        number_of_stars = number_of_stars - 1;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30204203_30204307_25_46
30204203_30204307_84_129
Title: How can I break an infinite loop at runtime? 
----------------------------------------

public void run () {
    while (appRunning) {
        System.out.println ("App running...");
        try {
            Thread.sleep (1000);
        } catch (InterruptedException e) {
        }
        if (pause > 0) {
            System.out.println ("App pausing for " + pause + " ms");
            try {
                Thread.sleep (pause);
            } catch (InterruptedException e) {
            }
            pause = 0;
        }
    }
}
----------------------------------------

public void run () {
    {
        System.out.println ("New Communication Thread Started");
        try {
            PrintWriter out = new PrintWriter (clientSocket.getOutputStream (), true);
            BufferedReader in = new BufferedReader (new InputStreamReader (clientSocket.getInputStream ()));
            String inputLine;
            while ((inputLine = in.readLine ()) != null) {
                System.out.println ("Received: " + inputLine);
                try {
                    long pauseCommand = Long.parseLong (inputLine);
                    pause = pauseCommand;
                    out.println ("OK, pausing for " + inputLine + " ms");
                } catch (NumberFormatException e) {
                }
                if (inputLine.equals ("BYE")) {
                    out.println ("OK, bye!");
                    break;
                }
                if (inputLine.equals ("STOP")) {
                    out.println ("OK, stopping!");
                    System.exit (1);
                }
            }
            out.close ();
            in.close ();
            clientSocket.close ();
        } catch (IOException e) {
            System.err.println ("Problem with Communication Server");
            System.exit (1);
        }
    }}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30205595_30205855_7_26
30205595_30205937_1_14
Title: Finding strings with a specific pattern but not already found in a list (Java regex) 
----------------------------------------

public static void main (String [] args) {
    HashSet < String > unseenLabels = new HashSet < String > ();
    String line = "9.99\t8.29\tAB=0.0;CD=0.0;EF=0.0;GH=0.0;LI=0.0;JK=0.0";
    String [] labels = new String [] {".AB=", ".EF=", ".LI=", ".JK="};
    Pattern p = Pattern.compile ("\\b[a-zA-Z]+=");
    Matcher m = p.matcher (line);
    while (m.find ()) {
        for (int i = 0;
        i < labels.length; i ++) {
            if (! Arrays.asList (labels).contains (("." + m.group ()))) unseenLabels.add (m.group ());

        }
    }
    for (String unseenLabel : unseenLabels) {
        System.out.println (unseenLabel.substring (0, unseenLabel.length () - 1));
    }
}
----------------------------------------

public static void main (String [] args) {
    String line = "9.99\t8.29\tAB=0.0;CD=0.0;EF=0.0;GH=0.0;LI=0.0;JK=0.0";
    String [] labels = new String [] {"AB", "EF", "LI", "JK"};
    Pattern p = Pattern.compile ("\\b[a-zA-Z]+=");
    Matcher m = p.matcher (line);
    while (m.find ()) {
        String groupName = m.group (0).substring (0, m.group (0).length () - 1);
        if (Arrays.asList (labels).contains (groupName)) {
            continue;
        } else {
            System.out.println (groupName);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30206076_30206151_1_17
30206076_30206249_1_14
Title: Recursively search binary tree 
----------------------------------------

public AlbumNode getAlbum (AlbumNode node, String name) {
    if (node == null) {
        return null;
    } else {
        if (node.getName ().equals (name)) {
            return node;
        } else {
            AlbumNode result = getAlbum (node.left, name);
            if (result != null) {
                return result;
            }
            result = getAlbum (node.right, name);
            return result;
        }
    }
}
----------------------------------------

public AlbumNode getAlbum (AlbumNode root, String name) {
    AlbumNode result;
    if (root.getName ().equals (name)) {
        return root;
    }
    if (root != null) {
        if (root.left != null) result = getAlbum (root.left, name);

        if (result != null) {
            return result;
        }
        if (root.right != null) result = getAlbum (root.right, name);

    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30209138_30209197_1_12
30209138_30209224_1_15
Title: JAVA adding total 
----------------------------------------

private int addTotal (ClientList clientList, String name) {
    int total = 0;
    for (int i = 0;
    i < clientList.getClientList ().size (); i ++) {
        if (name.compareTo (clientList.getClientList ().get (i).getName ()) == 0) {
            for (int j = 0;
            j < clientList.getClientList ().get (i).getBankAccList ().size (); j ++) {
                total += clientList.getClientList ().get (i).getBankAccList ().get (j).showBalance ();
            }
        }
    }
    return total;
}
----------------------------------------

private int addTotal (ClientList clientList, String name) {
    int total = 0;
    for (int i = 0;
    i < clientList.getClientList ().size (); i ++) {
        if (name.compareTo (clientList.getClientList ().get (i).getName ()) == 0) {
            for (int j = 0;
            j < clientList.getClientList ().get (i).getBankAccList ().size (); j ++) {
                total += clientList.getClientList ().get (i).getBankAccList ().get (j).showBalance ();
                suggesti
            }
        }
    }
    return total;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30227373_30233654_10_17
30227373_30233654_4_29
Title: Delay items emission until item is emitted from another observable 
----------------------------------------

public Observable < T > call (final L valueLeft) {
    return cached.map (new Func1 < R, T > () {
        @Override
        public T call (final R valueRight) {
            return function.call (valueLeft, valueRight);
        }}

    );
}
----------------------------------------

public Observable < T > call () {
    final SerialSubscription subscription = new SerialSubscription ();
    final ConnectableObservable < ? extends R > cached = right.replay ();
    return left.flatMap (new Func1 < L, Observable < T > > () {
        @Override
        public Observable < T > call (final L valueLeft) {
            return cached.map (new Func1 < R, T > () {
                @Override
                public T call (final R valueRight) {
                    return function.call (valueLeft, valueRight);
                }}

            );
        }}

    ).doOnSubscribe (new Action0 () {
        @Override
        public void call () {
            subscription.set (cached.connect ());
        }}

    ).doOnUnsubscribe (new Action0 () {
        @Override
        public void call () {
            subscription.unsubscribe ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30228993_30229040_1_18
30228993_30231232_1_11
Title: Check if character `'a'` is separated from `'b'` by three places 
----------------------------------------

public static void main (String [] args) {
    Scanner kbd = new Scanner (System.in);
    System.out.println ("Please enter any String: ");
    String myString = kbd.nextLine ();
    char [] myArray = myString.toCharArray ();
    boolean result = false;
    for (int i = 0;
    i < myArray.length; i ++) {
        if (myArray [i] == 'a' && myArray [i + 4] == 'b') {
            result = true;
            break;
        }
    }
    System.out.println (result);
}
----------------------------------------

public static void main (String [] args) {
    Scanner kbd = new Scanner (System.in);
    System.out.println ("Please enter any String: ");
    String myString = kbd.nextLine ();
    boolean result = false;
    if (myString.matches ("^(.)*(a)(.){3}(b)(.)*$")) {
        result = true;
    }
    System.out.println (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30229633_30229781_1_36
30229633_30230249_13_69
Title: Read streamfile in java 
----------------------------------------

public static void main (String [] args) {
    String csvFile = "src/files/text/simple.csv";
    BufferedReader br = null;
    String line = "";
    String cvsSplitBy = ",";
    boolean readingHeader = true;
    String integerValues = "";
    try {
        br = new BufferedReader (new FileReader (csvFile));
        while ((line = br.readLine ()) != null) {
            if (readingHeader) {
                readingHeader = false;
                continue;
            }
            String [] values = line.split (cvsSplitBy);
            integerValues = integerValues + values [0] + ",";
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } finally {
        if (br != null) {
            try {
                br.close ();
            } catch (IOException e) {
                e.printStackTrace ();
            }
        }
    }
    System.out.println (integerValues);
}
----------------------------------------

public static void main (String [] args) throws IOException {
    String filename = "bank-full2.csv";
    File file = new File (filename);
    BufferedWriter writer = null;
    try {
        writer = new BufferedWriter (new FileWriter ("bank2test1.csv"));
        Scanner inputStreamm = new Scanner (file);
        inputStreamm.nextLine ();
        while (inputStreamm.hasNext ()) {
            String data = inputStreamm.nextLine ();
            String [] values = data.split (",");
            int first = Integer.parseInt (values [1]);
            first = first + 2;
            values [1] = String.valueOf (first);
            StringBuilder sb = new StringBuilder ();
            for (int i = 0;
            i < values.length; i ++) {
                sb.append (values [i]);
                if (i < values.length - 1) {
                    sb.append (",");
                }
            }
            if (inputStreamm.hasNext ()) {
                String data1 = inputStreamm.nextLine ();
                String [] values1 = data1.split (",");
                int second = Integer.parseInt (values1 [1]);
                second = second + 1;
                values1 [1] = String.valueOf (second);
                sb.append ("\n");
                for (int i = 0;
                i < values1.length; i ++) {
                    sb.append (values1 [i]);
                    if (i < values.length - 1) {
                        sb.append (",");
                    }
                }
            }
            writer.write (sb.toString () + "\n");
        }
        writer.close ();
        inputStreamm.close ();
    } catch (FileNotFoundException ex) {
        Logger.getLogger (Rotation45.class.getName ()).log (Level.SEVERE, null, ex);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30233273_30233601_20_36
30233273_30233698_6_14
Title: Prime factors using recursion in Java 
----------------------------------------

private static List < Integer > primesRecursive (ArrayList < Integer > factors, int n, int f) {
    if (f <= n) {
        if (n % f == 0) {
            factors.add (f);
            n /= f;
        } else {
            f ++;
        }
        primesRecursive (factors, n, f);
    }
    return factors;
}
----------------------------------------

private static List < Integer > primesRecursive (int n, int f) {
    if (n == 1) return new ArrayList < Integer > ();

    if (n % f == 0) {
        List < Integer > factors = primesRecursive (n / f, f);
        factors.add (f);
        return factors;
    } else return primesRecursive (n, f + 1);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30234690_30235117_89_120
30234690_30235810_1_13
Title: How to open different Activities with my listView items? 
----------------------------------------

public void onItemClick (AdapterView < ? > parent, View view, int position, long id) {
    if (position == 0) {
        startActivity (new Intent ((Activity) context, A.class));
    }
    if (position == 1) {
        startActivity (new Intent ((Activity) context, B.class));
    }
    if (position == 2) {
        startActivity (new Intent ((Activity) context, C.class));
    }
    if (position == 3) {
        startActivity (new Intent ((Activity) context, D.class));
    }
    if (position == 4) {
        startActivity (new Intent ((Activity) context, E.class));
    }
    if (position == 5) {
        startActivity (new Intent ((Activity) context, F.class));
    }
    if (position == 6) {
        startActivity (new Intent ((Activity) context, G.class));
    }
    if (position == 7) {
        startActivity (new Intent ((Activity) context, H.class));
    }
    if (position == 8) {
        startActivity (new Intent ((Activity) context, I.class));
    }
}
----------------------------------------

@Override
public void onItemClick (View view, int position) {
    switch (position) {
        case 0 :
            startActivity (new Intent (MainActivity.this, A.class));
            break;
        case 1 :
            startActivity (new Intent (MainActivity.this, B.class));
            break;
        default :
            break;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
302371_10431954_15_54
302371_302439_3_22
Title: Which data structure would you use: TreeMap or HashMap? (Java) 
----------------------------------------

public static void main (String args []) {
    Map < String, Integer > tm = new TreeMap < String, Integer > ();
    try {
        FileInputStream fis = new FileInputStream ("Test.txt");
        DataInputStream in = new DataInputStream (fis);
        BufferedReader br = new BufferedReader (new InputStreamReader (in));
        String line;
        int countValue = 1;
        while ((line = br.readLine ()) != null) {
            line = line.replaceAll ("[-+.^:;,()\"\\[\\]]", "");
            StringTokenizer st = new StringTokenizer (line, " ");
            while (st.hasMoreTokens ()) {
                String nextElement = (String) st.nextElement ();
                if (tm.size () > 0 && tm.containsKey (nextElement)) {
                    int val = 0;
                    if (tm.get (nextElement) != null) {
                        val = (Integer) tm.get (nextElement);
                        val = val + 1;
                    }
                    tm.put (nextElement, val);
                } else {
                    tm.put (nextElement, 1);
                }
            }
        }
        for (Map.Entry < String, Integer > entry : tm.entrySet ()) {
            System.out.println (entry.getKey () + " : " + entry.getValue ());
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String...argv) throws Exception {
    FileChannel fc = new FileInputStream (argv [0]).getChannel ();
    ByteBuffer bb = fc.map (FileChannel.MapMode.READ_ONLY, 0, fc.size ());
    CharBuffer cb = Charset.defaultCharset ().decode (bb);
    Pattern p = Pattern.compile ("[^ \t\r\n\f.,!?:;\"()']+");
    Map < String, Integer > counts = new TreeMap < String, Integer > ();
    Matcher m = p.matcher (cb);
    while (m.find ()) {
        String word = m.group ();
        Integer count = counts.get (word);
        count = (count == null) ? 1 : count + 1;
        counts.put (word, count);
    }
    fc.close ();
    for (Map.Entry < String, Integer > e : counts.entrySet ()) {
        System.out.printf ("%s: %d%n", e.getKey (), e.getValue ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
302371_10431954_15_54
302371_31100032_3_33
Title: Which data structure would you use: TreeMap or HashMap? (Java) 
----------------------------------------

public static void main (String args []) {
    Map < String, Integer > tm = new TreeMap < String, Integer > ();
    try {
        FileInputStream fis = new FileInputStream ("Test.txt");
        DataInputStream in = new DataInputStream (fis);
        BufferedReader br = new BufferedReader (new InputStreamReader (in));
        String line;
        int countValue = 1;
        while ((line = br.readLine ()) != null) {
            line = line.replaceAll ("[-+.^:;,()\"\\[\\]]", "");
            StringTokenizer st = new StringTokenizer (line, " ");
            while (st.hasMoreTokens ()) {
                String nextElement = (String) st.nextElement ();
                if (tm.size () > 0 && tm.containsKey (nextElement)) {
                    int val = 0;
                    if (tm.get (nextElement) != null) {
                        val = (Integer) tm.get (nextElement);
                        val = val + 1;
                    }
                    tm.put (nextElement, val);
                } else {
                    tm.put (nextElement, 1);
                }
            }
        }
        for (Map.Entry < String, Integer > entry : tm.entrySet ()) {
            System.out.println (entry.getKey () + " : " + entry.getValue ());
        }
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    HashMap < String, Integer > map = new HashMap < String, Integer > ();
    ValueCompare vc = new ValueCompare (map);
    TreeMap < String, Integer > sorted_map = new TreeMap < String, Integer > (map);
    List < String > list = new ArrayList < > ();
    Scanner sc;
    try {
        sc = new Scanner (new File ("c:\\ReadMe1.txt"));
        while (sc.hasNext ()) {
            list.add (sc.next ());
        }
        sc.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    }
    for (String s : list) {
        if (map.containsKey (s)) {
            map.put (s, map.get (s) + 1);
        } else map.put (s, 1);

    }
    System.out.println ("Unsorted map: " + map);
    sorted_map.putAll (map);
    System.out.println ("Sorted map on keys: " + sorted_map);
    TreeMap < String, Integer > sorted_value_map = new TreeMap < > (vc);
    sorted_value_map.putAll (map);
    System.out.println ("Sorted map on values: " + sorted_value_map);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
302371_302439_3_22
302371_31100032_3_33
Title: Which data structure would you use: TreeMap or HashMap? (Java) 
----------------------------------------

public static void main (String...argv) throws Exception {
    FileChannel fc = new FileInputStream (argv [0]).getChannel ();
    ByteBuffer bb = fc.map (FileChannel.MapMode.READ_ONLY, 0, fc.size ());
    CharBuffer cb = Charset.defaultCharset ().decode (bb);
    Pattern p = Pattern.compile ("[^ \t\r\n\f.,!?:;\"()']+");
    Map < String, Integer > counts = new TreeMap < String, Integer > ();
    Matcher m = p.matcher (cb);
    while (m.find ()) {
        String word = m.group ();
        Integer count = counts.get (word);
        count = (count == null) ? 1 : count + 1;
        counts.put (word, count);
    }
    fc.close ();
    for (Map.Entry < String, Integer > e : counts.entrySet ()) {
        System.out.printf ("%s: %d%n", e.getKey (), e.getValue ());
    }
}
----------------------------------------

public static void main (String [] args) {
    HashMap < String, Integer > map = new HashMap < String, Integer > ();
    ValueCompare vc = new ValueCompare (map);
    TreeMap < String, Integer > sorted_map = new TreeMap < String, Integer > (map);
    List < String > list = new ArrayList < > ();
    Scanner sc;
    try {
        sc = new Scanner (new File ("c:\\ReadMe1.txt"));
        while (sc.hasNext ()) {
            list.add (sc.next ());
        }
        sc.close ();
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    }
    for (String s : list) {
        if (map.containsKey (s)) {
            map.put (s, map.get (s) + 1);
        } else map.put (s, 1);

    }
    System.out.println ("Unsorted map: " + map);
    sorted_map.putAll (map);
    System.out.println ("Sorted map on keys: " + sorted_map);
    TreeMap < String, Integer > sorted_value_map = new TreeMap < > (vc);
    sorted_value_map.putAll (map);
    System.out.println ("Sorted map on values: " + sorted_value_map);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30259098_30259336_1_22
30259098_30259390_1_15
Title: Date Parsing using SimpleDateFormat and parsePosition 
----------------------------------------

public static void main (String [] args) {
    String formatStr = "M/dd/yyyy h:m:s";
    SimpleDateFormat sd = new SimpleDateFormat (formatStr, Locale.getDefault ());
    String str = "04/01/2004 2:00:00 abcd";
    String [] strDate = str.split (" .[a-zA-Z]");
    ParsePosition pp1 = new ParsePosition (0);
    Date retDate = sd.parse (strDate [0], pp1);
    if (retDate == null || pp1.getIndex () != strDate [0].length ()) {
        System.out.println ("I have a invalid Date");
    } else {
        System.out.println ("I have a valid Date");
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    String formatStr = "MM/dd/yyyy";
    SimpleDateFormat sd = new SimpleDateFormat (formatStr, Locale.getDefault ());
    String str = "4/1/2004 2:00:00 AM";
    ParsePosition pp1 = new ParsePosition (0);
    String justDate = str.substring (0, str.indexOf (" "));
    Date retDate = sd.parse (justDate, pp1);
    if (retDate == null || pp1.getIndex () != justDate.length ()) {
        System.out.println ("I have a invalid Date");
    } else {
        System.out.println ("I have a valid Date");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30270866_30270951_1_13
30270866_30271140_1_21
Title: Inserting dashes between two odd numbers 
----------------------------------------

public static void main (String [] args) {
    String str = "9933444";
    List < String > lst = Arrays.asList (str.split (""));
    String res = lst.stream ().reduce ((a, b) -> {
        if (isOdd (a) && isOdd (b)) {
            return a + "-" + b;
        } else {
            return a + b;
        }
    }).get ();
    System.out.println (res);
}
----------------------------------------

public static void main (String [] args) throws Exception {
    Scanner kbd = new Scanner (System.in);
    System.out.println ("Enter the numbers: ");
    String myString = kbd.nextLine ();
    char [] numbers = myString.toCharArray ();
    String result = "";
    for (int i = 0;
    i < numbers.length; i ++) {
        int value1 = Character.getNumericValue (numbers [i]);
        int value2 = i + 1 < numbers.length ? Character.getNumericValue (numbers [i + 1]) : 0;
        if (value1 % 2 != 0 && value2 % 2 != 0) {
            result += numbers [i] + "-";
        } else {
            result += numbers [i];
        }
    }
    System.out.println (result);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30278491_30279964_12_23
30278491_30280265_27_53
Title: How to make a color digital clock that updates the background color by using the time as the rgb values? 
----------------------------------------

public void run () {
    LocalTime time = LocalTime.now ();
    int hour = time.getHour ();
    int min = time.getMinute ();
    int sec = time.getSecond ();
    hours.setText (String.valueOf (hour));
    minutes.setText (":" + String.valueOf (min + ":"));
    seconds.setText (String.valueOf (sec));
    Color color = new Color (hour * 256 / 24, min * 256 / 60, sec * 256 / 60);
    getContentPane ().setBackground (color);
}
----------------------------------------

public void run () {
    frame = new JFrame ("Clock");
    frame.setDefaultCloseOperation (JFrame.DO_NOTHING_ON_CLOSE);
    frame.addWindowListener (new WindowAdapter () {
        @Override
        public void windowClosing (WindowEvent event) {
            exitProcedure ();
        }}

    );
    panel = new JPanel ();
    panel.setBorder (BorderFactory.createLineBorder (Color.BLACK, 6));
    clockDisplay = new JTextField (12);
    clockDisplay.setEditable (false);
    clockDisplay.setHorizontalAlignment (JTextField.CENTER);
    panel.add (clockDisplay);
    frame.add (panel);
    frame.pack ();
    frame.setLocationByPlatform (true);
    frame.setVisible (true);
    timer = new Timer (this);
    new Thread (timer).start ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30291047_30352630_10_19
30291047_30352630_22_33
Title: How to determine size of data added in one second in ArrayList? 
----------------------------------------

public void run () {
    while (! stop.get ()) {
        queue.add (Math.random ());
        try {
            Thread.sleep (Math.round (Math.random () * 10));
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------

public void run () {
    while (! stop.get ()) {
        int startingSize = queue.size ();
        long startingTime = System.currentTimeMillis ();
        try {
            Thread.sleep (1000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
        System.out.println ("Added " + (queue.size () - startingSize) + " items in " + (System.currentTimeMillis () - startingTime) + " ms");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30294029_30294134_2_14
30294029_30294190_1_17
Title: print until end of line in java 
----------------------------------------

public static void main (String [] args) {
    String name = "TEST";
    int i = 0;
    while (i < 100) {
        System.out.print (name + " ");
        i ++;
    }
    System.out.println ();
}
----------------------------------------

public static void main (String [] args) throws Exception {
    final int CHARACTERS_PER_LINE = 72;
    String name = "TEST";
    StringBuilder sb = new StringBuilder ();
    for (int i = 0;
    i < 100; i ++) {
        sb.append (name).append (" ");
        if (sb.length () + name.length () + 1 > CHARACTERS_PER_LINE) {
            System.out.println (sb);
            sb.setLength (0);
        }
    }
    System.out.println (sb);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30304918_30397518_31_63
30304918_31184762_40_77
Title: How to add a document to the Alfresco Repository with Java code? 
----------------------------------------

protected Map < String, Object > executeImpl (WebScriptRequest arg0, Status status, Cache cache) {
    Map < String, Object > model = new HashMap < String, Object > ();
    try {
        String URL = "http://localhost:8080/alfresco/service/upload/fileupload?alf_ticket=" + getAlfticket ();
        File file = new File (UPLOAD_FILE_PATH);
        String filetype = "text/plain";
        String filename = file.getName ();
        HttpClient client = new HttpClient ();
        PostMethod post = new PostMethod (URL);
        Part [] parts = {new FilePart ("filedata", filename, file, filetype, null), new StringPart ("filename", filename), new StringPart ("description", "This is test description"), new StringPart ("destination", "workspace://SpacesStore/bb424b1d-0418-4954-8591-b8c807264df0")};
        post.setRequestEntity (new MultipartRequestEntity (parts, post.getParams ()));
        statusCode = client.executeMethod (post);
        System.out.println (post.getResponseBodyAsString ());
        post.releaseConnection ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    if (statusCode == 200) {
        model.put ("result", "File uploaded successfully.");
        return model;
    } else {
        model.put ("result", "There was an error while uploading document.");
        return model;
    }
}
----------------------------------------

protected Map < String, Object > executeImpl (WebScriptRequest req, Status status, Cache cache) {
    File file = new File (UPLOAD_FILE_PATH);
    NodeRef parent = new NodeRef (UPLOAD_DESTINATION);
    String name = "name of file in Repository " + System.currentTimeMillis ();
    Map < QName, Serializable > props = new HashMap < QName, Serializable > (1);
    props.put (ContentModel.PROP_NAME, name);
    NodeRef node = serviceRegistry.getNodeService ().createNode (parent, ContentModel.ASSOC_CONTAINS, QName.createQName (NamespaceService.CONTENT_MODEL_1_0_URI, name), ContentModel.TYPE_CONTENT, props).getChildRef ();
    ContentWriter writer = serviceRegistry.getContentService ().getWriter (node, ContentModel.PROP_CONTENT, true);
    writer.setMimetype (MimetypeMap.MIMETYPE_TEXT_PLAIN);
    writer.setEncoding ("UTF-8");
    String text = "";
    try {
        text = FileUtils.readFileToString (file);
    } catch (IOException e) {
        e.printStackTrace ();
    }
    writer.putContent (text);
    Map < String, Object > model = new HashMap < String, Object > ();
    if (status.getCode () == Status.STATUS_OK) {
        model.put ("resultRepoWS", "File \"" + file.getName () + "\" uploaded successfully to the repository. Status: " + status.getCode ());
        return model;
    } else {
        model.put ("resultRepoWS", "There was an error while uploading document \"" + file.getName () + "\" - Status: " + status.getCode ());
        return model;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
303098_303485_7_24
303098_49718983_20_37
Title: How to backup ArrayList in Java? 
----------------------------------------

public static void main (String [] args) {
    ArrayList < String > al = new ArrayList < String > (20);
    for (int i = 0;
    i < 10; i ++) {
        al.add (GetRandomString (7));
    }
    ArrayList < String > cloneArray = new ArrayList < String > (al);
    Collections.copy (cloneArray, al);
    System.out.println (al);
    System.out.println (cloneArray);
    for (int i = 9;
    i >= 0; i -= 2) {
        al.remove (i);
    }
    System.out.println (al);
    System.out.println (cloneArray);
}
----------------------------------------

public static void main (String [] args) {
    ArrayList < Integer > list = new ArrayList < Integer > ();
    list.add (1);
    list.add (2);
    Snapshot snap = new Snapshot (list);
    list.set (0, 3);
    list = snap.restore ();
    System.out.println (list);
    list.add (4);
    list = snap.restore ();
    System.out.println (list);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30319713_30319869_1_25
30319713_30475786_9_30
Title: "I dont know why the output will repeat multiple times and I dont know how to format output." 
----------------------------------------

public static void main (String [] args) {
    String address;
    Scanner scn = new Scanner (System.in);
    address = scn.next ();
    address = address.trim ();
    String postcode = "";
    if (address.length () < 4) {
        System.out.println ("The address is less that four characters long.");
    } else {
        postcode = address.substring (address.length () - 4);
        try {
            int code = Integer.parseInt (postcode);
            System.out.println ("The post code is :" + code);
        } catch (NumberFormatException ex) {
            System.out.println ("ERROR");
        }
    }
}
----------------------------------------

public static void main (String [] args) {
    String postcode;
    String address;
    Scanner scn = new Scanner (System.in);
    address = scn.next ();
    address = address.trim ();
    if (address.length () > 3) {
        String testPostCode = address.substring (address.length () - 4, address.length ());
        if (isIntegerParseInt (testPostCode)) {
            postcode = testPostCode;
            System.out.println ("postcode:" + postcode);
        } else {
            System.out.println ("there is not valide address.");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30321945_30323096_7_27
30321945_30324620_13_65
Title: HashMap Keys and Value comparison 
----------------------------------------

public static void main (String [] args) {
    Map < Integer, IntArrayNode > map = new TreeMap < Integer, IntArrayNode > ();
    map.put (0, new IntArrayNode (new int [] {1, 2, 4, 8, 16}));
    map.put (3, new IntArrayNode (new int [] {4, 5, 7, 11, 19}));
    map.put (7, new IntArrayNode (new int [] {8, 9, 11, 15, 23}));
    System.out.println ("Before update:");
    for (Map.Entry < Integer, IntArrayNode > e : map.entrySet ()) {
        System.out.println (e);
    }
    update (map);
    System.out.println ("After update:");
    for (Map.Entry < Integer, IntArrayNode > e : map.entrySet ()) {
        System.out.println (e);
    }
}
----------------------------------------

public static void main (String [] args) {
    Map < Integer, List < Integer > > hash = new HashMap < Integer, List < Integer > > ();
    List < Integer > list1 = new ArrayList < Integer > ();
    list1.add (1);
    list1.add (2);
    list1.add (4);
    list1.add (8);
    list1.add (16);
    List < Integer > list2 = new ArrayList < Integer > ();
    list2.add (4);
    list2.add (5);
    list2.add (7);
    list2.add (11);
    list2.add (19);
    List < Integer > list3 = new ArrayList < Integer > ();
    list3.add (8);
    list3.add (9);
    list3.add (11);
    list3.add (15);
    list3.add (23);
    hash.put (0, list1);
    hash.put (3, list2);
    hash.put (7, list3);
    System.out.println ("Input:");
    for (Map.Entry < Integer, List < Integer > > m1 : hash.entrySet ()) {
        System.out.println ("Successor i: " + m1.getValue ());
        System.out.println ("Key: " + m1.getKey ());
    }
    Map < Integer, List < Integer > > out = hash;
    List < Integer > list = new ArrayList < Integer > ();
    int keyValue = 0;
    int count = 0;
    for (Entry < Integer, List < Integer > > m : hash.entrySet ()) {
        if (count == 0) {
            list = m.getValue ();
            keyValue = m.getKey ();
            count ++;
            continue;
        } else {
            for (int i = 0;
            i < list.size (); i ++) {
                if (m.getKey () > list.get (i)) {
                    list.set (i, m.getKey ());
                }
            }
            out.put (keyValue, list);
            list = m.getValue ();
            keyValue = m.getKey ();
        }
    }
    System.out.println ("Output:----------------");
    for (Map.Entry < Integer, List < Integer > > m1 : out.entrySet ()) {
        System.out.println ("Successor i: " + m1.getValue ());
        System.out.println ("Key: " + m1.getKey ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30334876_30350805_13_39
30334876_30365222_5_11
Title: Why is my transparent icon not getting rendered as transparent? 
----------------------------------------

public static void main (String [] args) {
    Runnable r = new Runnable () {
        @Override
        public void run () {
            try {
                JPanel ui = new JPanel (new BorderLayout ());
                URL url = new URL ("http://i.stack.imgur.com/AnvwU.png");
                ui.add (new JLabel (new ImageIcon (url)), BorderLayout.PAGE_START);
                StringBuilder sb = new StringBuilder ();
                sb.append (getPropertyString ("java.version"));
                sb.append (getPropertyString ("java.runtime.version"));
                sb.append (getPropertyString ("java.vm.version"));
                sb.append (getPropertyString ("java.specification.vendor"));
                JTextArea output = new JTextArea (sb.toString ().trim (), 4, 27);
                ui.add (new JScrollPane (output));
                int result = JOptionPane.showConfirmDialog (null, ui);
                System.out.println (sb.toString ());
                System.out.println ("OK? " + (result == JOptionPane.YES_OPTION));
            } catch (Exception ex) {
                ex.printStackTrace ();
            }
        }}

    ;
    SwingUtilities.invokeLater (r);
}
----------------------------------------

public static void main (String [] args) {
    EventQueue.invokeLater (new Runnable () {
        @Override
        public void run () {
            createAndShowGUI ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30338598_30338692_17_55
30338598_30345420_12_42
Title: "TranslateTransition does not change (XY) co-ordinates" 
----------------------------------------

public void start (Stage stage) {
    VBox vb = new VBox ();
    Rectangle rect = new Rectangle (100, 100, 100, 100);
    rect.setManaged (false);
    rect.setArcHeight (50);
    rect.setArcWidth (50);
    rect.setFill (Color.VIOLET);
    final Duration SEC_2 = Duration.millis (2000);
    System.out.println ("Location before relocation = " + rect.getX () + "," + rect.getY () + ")");
    Timeline timeline = new Timeline ();
    KeyFrame end = new KeyFrame (SEC_2, new KeyValue (rect.xProperty (), 200), new KeyValue (rect.yProperty (), 200));
    timeline.getKeyFrames ().add (end);
    timeline.setOnFinished (new EventHandler < ActionEvent > () {
        @Override
        public void handle (ActionEvent event) {
            System.out.println ("Location after relocation = " + rect.getX () + "," + rect.getY () + ")");
        }}

    );
    timeline.play ();
    vb.getChildren ().add (rect);
    Scene scene = new Scene (vb, 500, 500);
    stage.setScene (scene);
    stage.show ();
}
----------------------------------------

public void start (Stage stage) {
    Rectangle rect = new Rectangle (100, 100, 100, 100);
    rect.setArcHeight (50);
    rect.setArcWidth (50);
    rect.setFill (Color.VIOLET);
    System.out.println ("Location before relocation = " + rect.getX () + "," + rect.getY () + ")");
    TranslateTransition tt = new TranslateTransition (Duration.seconds (2), rect);
    tt.setByX (100f);
    tt.setByY (100f);
    tt.setOnFinished (event -> {
        rect.setX (rect.getX () + rect.getTranslateX ());
        rect.setY (rect.getY () + rect.getTranslateY ());
        rect.setTranslateX (0);
        rect.setTranslateY (0);
        System.out.println ("Location after relocation = " + rect.getX () + "," + rect.getY () + ")");
    });
    tt.play ();
    Scene scene = new Scene (new Group (rect), 500, 500);
    stage.setScene (scene);
    stage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30339503_30344189_16_32
30339503_30344253_10_23
Title: How to sort an arraylist based on a bean? 
----------------------------------------

public List < Bean > getList (int size) {
    List < Bean > beanList = new ArrayList < Bean > ();
    int i = 0;
    while (i < size) {
        Bean bean = new Bean ();
        listing (bean, beanList);
        i ++;
    }
    Comparator < Bean > c = new Comparator < Bean > () {
        @Override
        public int compare (Bean bean1, Bean bean2) {
            return bean1.getAge () - bean2.getAge ();
        }}

    ;
    Collections.sort (beanList, c);
    return beanList;
}
----------------------------------------

public List < Bean > getList (int size) {
    List < Bean > beanList = new ArrayList < Bean > ();
    int i = 0;
    while (i < size) {
        Bean bean = new Bean ();
        listing (bean, beanList);
        i ++;
    }
    Collections.sort (beanList);
    return beanList;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30340716_30340996_17_43
30340716_30342201_32_47
Title: Java - Stumped with threading puzzle 
----------------------------------------

public void run () {
    int i = 0;
    while (true) {
        if (i % 100 == 0) {
            two.startRunning ();
            while (two.pending ()) {
                try {
                    Thread.sleep (200);
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
        }
        lock.lock ();
        try {
            i ++;
        } catch (Exception e) {
            e.printStackTrace ();
        } finally {
            lock.unlock ();
        }
    }
}
----------------------------------------

public void run () {
    String task = "taskA";
    while (! allTasksDone (task)) {
        task = performTask (task);
        try {
            System.out.println ("Tasker : Await on barrier ");
            barrier.await ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        } catch (BrokenBarrierException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30340716_30340996_17_43
30340716_30342201_58_74
Title: Java - Stumped with threading puzzle 
----------------------------------------

public void run () {
    int i = 0;
    while (true) {
        if (i % 100 == 0) {
            two.startRunning ();
            while (two.pending ()) {
                try {
                    Thread.sleep (200);
                } catch (InterruptedException e) {
                    e.printStackTrace ();
                }
            }
        }
        lock.lock ();
        try {
            i ++;
        } catch (Exception e) {
            e.printStackTrace ();
        } finally {
            lock.unlock ();
        }
    }
}
----------------------------------------

public void run () {
    int counter = 0;
    while (! isCountingDone (counter)) {
        counter = performCounting (counter);
        if (checkBarrierCondition (counter)) {
            try {
                System.out.println ("Counter : Await on barrier ");
                barrier.await ();
            } catch (InterruptedException e) {
                e.printStackTrace ();
            } catch (BrokenBarrierException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30344935_30345010_1_22
30344935_30345284_1_20
Title: java switch case can not resolve to variable 
----------------------------------------

public static int setMapTile () {
    int a = getArmadaLength ();
    int b;
    switch (a) {
        case 4 :
            System.out.println (" recommended MapSize : 10 x 10");
            b = setSize ();
            break;
        case 5 :
            System.out.println (" recommended MapSize : 11 x 11");
            b = setSize ();
            break;
        case 6 :
            System.out.println (" recommended MapSize : 12 x 12");
            b = setSize ();
            break;
        default :
            throw new IllegalStateException ("Armada length is " + a + "?!?");
            break;
    }
    return b;
}
----------------------------------------

public static int setMapTile () {
    int a = getArmadaLength ();
    switch (a) {
        case 4 :
            System.out.println (" recommended MapSize : 10 x 10");
            return setSize ();
        case 5 :
            System.out.println (" recommended MapSize : 11 x 11");
            return setSize ();
        case 6 :
            System.out.println (" recommended MapSize : 12 x 12");
            return setSize ();
        default :
            System.out.println ("wrong");
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3034575_8224043_125_154
3034575_8224043_157_169
Title: Passing binary blob through a content provider 
----------------------------------------

public void addRow (Iterable < ? > columnValues) {
    int start = rowCount * columnCount;
    int end = start + columnCount;
    ensureCapacity (end);
    if (columnValues instanceof ArrayList < ? >) {
        addRow ((ArrayList < ? >) columnValues, start);
        return;
    }
    int current = start;
    Object [] localData = data;
    for (Object columnValue : columnValues) {
        if (current == end) {
            throw new IllegalArgumentException ("columnValues.size() > columnNames.length");
        }
        localData [current ++] = columnValue;
    }
    if (current != end) {
        throw new IllegalArgumentException ("columnValues.size() < columnNames.length");
    }
    rowCount ++;
}
----------------------------------------

private void addRow (ArrayList < ? > columnValues, int start) {
    int size = columnValues.size ();
    if (size != columnCount) {
        throw new IllegalArgumentException ("columnNames.length = " + columnCount + ", columnValues.size() = " + size);
    }
    rowCount ++;
    Object [] localData = data;
    for (int i = 0;
    i < size; i ++) {
        localData [start + i] = columnValues.get (i);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30346380_30362162_32_43
30346380_30362162_45_56
Title: Manipulating trie implementation to get the found items in an array 
----------------------------------------

public AutoComplete (Collection < String > items) {
    root = new Node ('r');
    size = 0;
    for (String item : items) {
        if (! isEntry (item)) {
            add (item);
        }
    }
}
----------------------------------------

public AutoComplete (String [] items) {
    root = new Node ('r');
    size = 0;
    for (String item : items) {
        if (! isEntry (item)) {
            add (item);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30346380_30362162_58_75
30346380_30362162_90_133
Title: Manipulating trie implementation to get the found items in an array 
----------------------------------------

public boolean add (String item) {
    if (isEntry (item)) {
        return false;
    } else if (add (root, item + DELIMITER, 0)) {
        size ++;
        int n = item.length ();
        if (n > maxDepth) {
            maxDepth = n;
        }
        return true;
    }

    return false;
}
----------------------------------------

private boolean add (Node root, String word, int offset) {
    if (offset == word.length ()) {
        return false;
    }
    int c = word.charAt (offset);
    Node last = null, next = root.firstChild;
    while (next != null) {
        if (next.value < c) {
            last = next;
            next = next.nextSibling;
        } else if (next.value == c) {
            return add (next, word, offset + 1);
        } else {
            break;
        }

    }
    Node node = new Node (c);
    if (last == null) {
        root.firstChild = node;
        node.nextSibling = next;
    } else {
        last.nextSibling = node;
        node.nextSibling = next;
    }
    for (int i = offset + 1;
    i < word.length (); i ++) {
        node.firstChild = new Node (word.charAt (i));
        node = node.firstChild;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30353064_30354570_6_37
30353064_30356534_5_27
Title: "Searching through an array and outputting the element number" 
----------------------------------------

public static void main (String [] args) throws IOException {
    String [] menu = {"apples", "bananas", "pears", "milk", "cookies", "bread", "lemons"};
    Scanner keyboard = new Scanner (System.in);
    System.out.print ("Enater a value to search : ");
    String user_input = keyboard.next ();
    boolean found = false;
    int location = 0;
    for (int i = 0;
    i < menu.length; i ++) {
        if (menu [i].equalsIgnoreCase (user_input)) {
            found = true;
            location = i;
        } else {
            continue;
        }
    }
    if (found) {
        System.out.println ("String found at location : " + location);
    } else {
        System.out.println ("String not found!");
    }
}
----------------------------------------

public static void main (String [] args) {
    String [] menu = {"apples", "apples", "bananas", "pears", "milk", "cookies", "bread", "lemons"};
    int count = 0;
    Scanner user_input = new Scanner (System.in);
    System.out.println (" type any item to check in menu");
    String item;
    item = user_input.next ();
    for (String s : menu) {
        if (s.equalsIgnoreCase (item)) {
            count ++;
        }
    }
    System.out.println ("no. of item is " + count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30353064_30354570_6_37
30353064_30366829_6_20
Title: "Searching through an array and outputting the element number" 
----------------------------------------

public static void main (String [] args) throws IOException {
    String [] menu = {"apples", "bananas", "pears", "milk", "cookies", "bread", "lemons"};
    Scanner keyboard = new Scanner (System.in);
    System.out.print ("Enater a value to search : ");
    String user_input = keyboard.next ();
    boolean found = false;
    int location = 0;
    for (int i = 0;
    i < menu.length; i ++) {
        if (menu [i].equalsIgnoreCase (user_input)) {
            found = true;
            location = i;
        } else {
            continue;
        }
    }
    if (found) {
        System.out.println ("String found at location : " + location);
    } else {
        System.out.println ("String not found!");
    }
}
----------------------------------------

public static void main (String [] args) {
    String [] menu = {"apples", "apples", "bananas", "pears", "milk", "cookies", "bread", "lemons"};
    Scanner user_input = new Scanner (System.in);
    System.out.println (" type any item to check in menu");
    String item;
    item = user_input.next ();
    int count = Arrays.asList (menu).indexOf (item.toLowerCase ());
    if (count < 0) System.out.println ("Item not found");
    else System.out.println ("no. of item is " + count);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30353064_30356534_5_27
30353064_30366829_6_20
Title: "Searching through an array and outputting the element number" 
----------------------------------------

public static void main (String [] args) {
    String [] menu = {"apples", "apples", "bananas", "pears", "milk", "cookies", "bread", "lemons"};
    int count = 0;
    Scanner user_input = new Scanner (System.in);
    System.out.println (" type any item to check in menu");
    String item;
    item = user_input.next ();
    for (String s : menu) {
        if (s.equalsIgnoreCase (item)) {
            count ++;
        }
    }
    System.out.println ("no. of item is " + count);
}
----------------------------------------

public static void main (String [] args) {
    String [] menu = {"apples", "apples", "bananas", "pears", "milk", "cookies", "bread", "lemons"};
    Scanner user_input = new Scanner (System.in);
    System.out.println (" type any item to check in menu");
    String item;
    item = user_input.next ();
    int count = Arrays.asList (menu).indexOf (item.toLowerCase ());
    if (count < 0) System.out.println ("Item not found");
    else System.out.println ("no. of item is " + count);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30356385_44343671_10_38
30356385_44344713_15_53
Title: JavaFX Adding multiple XYChart.Series to LineChart without explicating declaring each series 
----------------------------------------

public void start (Stage stage) {
    stage.setTitle ("Stock Market");
    final CategoryAxis xAxis = new CategoryAxis ();
    final NumberAxis yAxis = new NumberAxis ();
    xAxis.setLabel ("Time of Day");
    yAxis.setLabel ("Price Per Stock");
    LineChart < String, Number > lineChart = new LineChart < String, Number > (xAxis, yAxis);
    Scene scene = new Scene (lineChart, 800, 600);
    lineChart.setTitle ("Stock Exchange");
    String [] timeOfDay = {"8:00AM", "9:00AM", "10:00AM", "161:00AM", "12:00PM", "1:00PM", "2:00PM", "3:00PM", "4:00PM"};
    String [] stockCompany = {"AAPL", "ORCL", "MSFT", "GOOG", "AMZN", "FB", "HPQ", "YHOO", "ADSK", "ATVI"};
    for (int i = 0;
    i < stockCompany.length; i ++) {
        CompanyStockData tmpCompany = new CompanyStockData (lineChart, timeOfDay, stockCompany [i], i + 3);
        lineChart.getData ().add (tmpCompany.generateStock ());
    }
    stage.setScene (scene);
    stage.show ();
}
----------------------------------------

public void start (Stage stage) {
    stage.setTitle ("Stock Market");
    final CategoryAxis xAxis = new CategoryAxis ();
    final NumberAxis yAxis = new NumberAxis ();
    xAxis.setLabel ("Time of Day");
    yAxis.setLabel ("Price Per Stock");
    LineChart < String, Number > lineChart = new LineChart < String, Number > (xAxis, yAxis);
    ArrayList < CompanyStockData > companysLines = new ArrayList < CompanyStockData > ();
    Scene scene = new Scene (lineChart, 800, 600);
    scene.setOnMousePressed (new javafx.event.EventHandler < MouseEvent > () {
        @Override
        public void handle (MouseEvent event) {
            companysLines.get (companysNumber).changeStock ();
        }}

    );
    lineChart.setTitle ("Stock Exchange");
    String [] timeOfDay = {"8:00AM", "9:00AM", "10:00AM", "161:00AM", "12:00PM", "1:00PM", "2:00PM", "3:00PM", "4:00PM"};
    String [] stockCompany = {"AAPL", "ORCL", "MSFT", "GOOG", "AMZN", "FB", "HPQ", "YHOO", "ADSK", "ATVI"};
    for (int i = 0;
    i < stockCompany.length; i ++) {
        companysLines.add (new CompanyStockData (lineChart, timeOfDay, stockCompany [i], i + 3));
        lineChart.getData ().add (companysLines.get (i).generateStock ());
    }
    stage.setScene (scene);
    stage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30364547_30364655_1_32
30364547_30364713_1_32
Title: Completing a multiplication table with asterisks 
----------------------------------------

public static void main (String [] args) {
    System.out.print ("  |");
    for (int a = 1;
    a < 10; a ++) {
        int ans = a;
        if (ans < 10) {
            System.out.print ("  " + ans + "  ");
        } else {
            System.out.print (" " + ans + "  ");
        }
    }
    System.out.println ();
    for (int u = 1;
    u < 47; u ++) {
        System.out.print ("-");
    }
    System.out.println ();
    for (int i = 9;
    i > 0; i --) {
        System.out.print (i + " |");
        for (int c = 1;
        c < 10; c ++) {
            int ans2 = i * c;
            if (c < (11 - i)) {
                if (ans2 < 10) {
                    System.out.print ("  " + ans2 + "  ");
                } else {
                    System.out.print (" " + ans2 + "  ");
                }
            } else {
                System.out.print ("  *  ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    System.out.print ("  |");
    for (int a = 1;
    a < 10; a ++) {
        int ans = a;
        if (ans < 10) {
            System.out.print ("  " + ans + "  ");
        } else {
            System.out.print (" " + ans + "  ");
        }
    }
    System.out.println ();
    for (int u = 1;
    u < 47; u ++) {
        System.out.print ("-");
    }
    System.out.println ();
    for (int i = 9;
    i > 0; i --) {
        System.out.print (i + " |");
        for (int c = 1;
        c < 10; c ++) {
            int ans2 = i * c;
            if (c <= 10 - i) {
                if (ans2 < 10) {
                    System.out.print ("  " + ans2 + "  ");
                } else {
                    System.out.print (" " + ans2 + "  ");
                }
            } else {
                System.out.print (" * ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30367195_30367463_1_29
30367195_30367598_3_18
Title: Moving files to other folder based on the actual file name 
----------------------------------------

public static void main (String [] args) {
    try {
        String pathname = "Tango";
        File f1 = new File (pathname);
        String [] allFiles = f1.list ();
        InputStream inStream = null;
        OutputStream outStream = null;
        byte [] buffer = new byte [1024];
        for (String file : allFiles) {
            if (file.contains ("john1")) {
                File source = new File (pathname + "\\" + file);
                File dest = new File ("D:\\john1\\" + file);
                inStream = new FileInputStream (source);
                outStream = new FileOutputStream (dest);
                int length;
                while ((length = inStream.read (buffer)) > 0) {
                    outStream.write (buffer, 0, length);
                }
                inStream.close ();
                outStream.close ();
                source.delete ();
            }
        }
    } catch (Exception ex) {
        ex.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    File folder = new File ("Tango");
    File [] files = folder.listFiles ();
    for (Files file : files) {
        String filename = file.getName ().substring (0, file.getName ().indexOf ("."));
        File yourDir = new File (filename);
        if (! yourDir.exists ()) {
            yourDir.mkDir ();
        }
        file.renameTo (new File (yourDir.getAbsolutePath () + file.getName ()));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3037765_3037898_1_25
3037765_3079823_1_11
Title: How to clean up my code 
----------------------------------------

public long fibb () {
    List < Integer > list = new LinkedList < Integer > ();
    list.add (1);
    list.add (1);
    while (list.get (0) + list.get (1) < 4000000) {
        list.add (0, list.get (0) + list.get (1));
    }
    long value = 0;
    for (Integer n : list) {
        if (n % 2 == 0) {
            value += n;
        }
    }
    return value;
}
----------------------------------------

public static long fibb () {
    int a = 1, b = 1;
    long total = 0;
    while (true) {
        int c = a + b;
        if (c >= 4000000) return total;

        total += c;
        a = b + c;
        b = c + a;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30391343_30391555_10_46
30391343_30391773_1_41
Title: Creating file using Properties and issue in logic 
----------------------------------------

public static void main (String args []) {
    int i;
    for (i = 1; i <= 9999; i ++) {
        if (transID != 9999) {
            Properties properties = new Properties ();
            File propertiesfile = new File ("Sequence.properties");
            try {
                propertiesfile.createNewFile ();
                properties.load (new FileInputStream (propertiesfile));
            } catch (IOException e) {
                e.printStackTrace ();
                System.out.println ("Error:File not read");
            }
            if (transID != 97) {
                transID ++;
                System.out.println (transID);
            } else {
                transID = 98;
            }
        } else {
            if (regId != 1 && regId != 8) {
                regId ++;
                System.out.println (regId);
            } else if (regId == 1) {
                regId = 3;
                System.out.println (regId);
            } else {
                regId = 10;
            }

        }
    }
}
----------------------------------------

public static void main (String args []) {
    int regId = 1;
    int transID = 1;
    int i = 0;
    while (i < 9999) {
        i ++;
        transID ++;
        regId ++;
        if (transID == 9999) {
            transID = 1;
            regId = 3;
        } else {
            Properties properties = new Properties ();
            File propertiesfile = new File ("Sequence.properties");
            try {
                propertiesfile.createNewFile ();
                properties.load (new FileInputStream (propertiesfile));
            } catch (IOException e) {
                e.printStackTrace ();
                System.out.println ("Error:File not read");
            }
            if (transID == 98) {
                transID ++;
                System.out.println (transID);
            }
            System.out.println ("transID: " + transID + ", regID: " + regId);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30401313_30452193_323_340
30401313_30452193_346_364
Title: Javafx canvas not clearing correctly. 
----------------------------------------

public void handle (MouseEvent event) {
    if (event.getSource () instanceof Circle) {
        Circle circle = ((Circle) (event.getSource ()));
        dragContext.x = circle.getCenterX () - event.getSceneX ();
        dragContext.y = circle.getCenterY () - event.getSceneY ();
    } else {
        Node node = ((Node) (event.getSource ()));
        dragContext.x = node.getTranslateX () - event.getSceneX ();
        dragContext.y = node.getTranslateY () - event.getSceneY ();
    }
}
----------------------------------------

public void handle (MouseEvent event) {
    if (event.getSource () instanceof Circle) {
        Circle circle = ((Circle) (event.getSource ()));
        circle.setCenterX (dragContext.x + event.getSceneX ());
        circle.setCenterY (dragContext.y + event.getSceneY ());
    } else {
        Node node = ((Node) (event.getSource ()));
        node.setTranslateX (dragContext.x + event.getSceneX ());
        node.setTranslateY (dragContext.y + event.getSceneY ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30407241_30407406_1_14
30407241_30407539_1_19
Title: Error in binary String to Integer converter 
----------------------------------------

public static long binaryStringToInteger (String binaryString) {
    char [] digits = binaryString.toCharArray ();
    long binaryInteger = 0;
    long count = 0;
    for (int i = digits.length - 1;
    i >= 0; i --) {
        if (digits [i] == '1') {
            binaryInteger += (long) Math.pow (2, count);
        }
        count ++;
    }
    return binaryInteger;
}
----------------------------------------

public static int binaryStringToInteger (String binaryString) {
    char [] digits = binaryString.toCharArray ();
    int binaryInteger = 0;
    int count = 0;
    for (int i = digits.length - 2;
    i >= 0; i --) {
        if (digits [i] == '1') {
            binaryInteger += (int) Math.pow (2, count);
        }
        count ++;
    }
    if (digits [digits.length - 1] == '1') {
        binaryInteger *= - 1;
    }
    return binaryInteger;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30407241_30407409_1_14
30407241_30407539_1_19
Title: Error in binary String to Integer converter 
----------------------------------------

public static long binaryStringToInteger (String binaryString) {
    char [] digits = binaryString.toCharArray ();
    long binaryInteger = 0;
    int count = 0;
    for (int i = digits.length - 1;
    i >= 0; i --) {
        if (digits [i] == '1') {
            binaryInteger += (long) Math.pow (2, count);
        }
        count ++;
    }
    return binaryInteger;
}
----------------------------------------

public static int binaryStringToInteger (String binaryString) {
    char [] digits = binaryString.toCharArray ();
    int binaryInteger = 0;
    int count = 0;
    for (int i = digits.length - 2;
    i >= 0; i --) {
        if (digits [i] == '1') {
            binaryInteger += (int) Math.pow (2, count);
        }
        count ++;
    }
    if (digits [digits.length - 1] == '1') {
        binaryInteger *= - 1;
    }
    return binaryInteger;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30409443_30409557_1_12
30409443_35024321_1_16
Title: Find string matching position? 
----------------------------------------

private static int getStringMatchNumber (String input) {
    char [] str = input.toCharArray ();
    for (int i = str.length - 1;
    i > 0; i --) {
        Character c = str [i];
        Character p = str [i - 1];
        if (Character.isLowerCase (c) && Character.isUpperCase (p)) {
            if (p == Character.toUpperCase (c)) return i;

        }
    }
    return 0;
}
----------------------------------------

private static int getStringMatchNumber (String input) {
    char [] str = input.toCharArray ();
    int last = findMatches (str, 0);
    System.out.println ("Last unmatched index: " + (last - 1));
    for (int i = str.length - 1;
    i > 0; i --) {
        Character c = str [i];
        Character p = str [i - 1];
        if (Character.isLowerCase (c) && Character.isUpperCase (p)) {
            if (p == Character.toUpperCase (c)) return i;

        }
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30410520_30412434_1_26
30410520_30414192_1_12
Title: Printing elements from array in specific format 
----------------------------------------

public static void main (String [] args) {
    int [] a = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int [] b = {4, 2, 3};
    int nextIndex = 0;
    for (int i = 0;
    i < b.length; i ++) {
        for (int j = nextIndex;
        j < nextIndex + b [i]; j ++) {
            if (j == (nextIndex + b [i] - 1)) {
                System.out.print (a [j]);
            } else {
                System.out.print (a [j] + ",");
            }
        }
        nextIndex += (b [i]);
        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    int a [] = {1, 2, 3, 4, 5, 6, 7, 8, 9};
    int b [] = {4, 2, 3};
    int aIndex = 0;
    int bIndex = 0;
    for (int i = 0;
    i < b.length; i ++) {
        bIndex += b [i];
        System.out.println (Arrays.toString (Arrays.copyOfRange (a, aIndex, bIndex)));
        aIndex += b [i];
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30421301_30421480_51_60
30421301_30421480_67_76
Title: Maximazing JInternalFrame in JMenuBar 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    JInternalFrame iFrame = dp.getSelectedFrame ();
    if (iFrame != null) {
        try {
            iFrame.setMaximum (true);
        } catch (PropertyVetoException ex) {
            ex.printStackTrace ();
        }
    }
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    JInternalFrame iFrame = dp.getSelectedFrame ();
    if (iFrame != null) {
        try {
            iFrame.setMaximum (false);
        } catch (PropertyVetoException ex) {
            ex.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30427857_30428006_1_22
30427857_41913377_1_35
Title: Finding the second smallest integer in array 
----------------------------------------

public static void main (String [] args) {
    int [] elements = {- 4, 2, 10, - 2, - 3};
    int smallest = Integer.MAX_VALUE;
    int secondSmallest = Integer.MAX_VALUE;
    for (int i = 0;
    i < elements.length; i ++) {
        if (smallest > elements [i]) smallest = elements [i];

    }
    for (int i = 0;
    i < elements.length; i ++) {
        if (secondSmallest > elements [i] && elements [i] > smallest) secondSmallest = elements [i];

    }
    System.out.println ("The smallest element is: " + smallest + "\n" + "The second smallest element is: " + secondSmallest);
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter array size = ");
    int size = in.nextInt ();
    int [] n = new int [size];
    System.out.println ("Enter " + size + " values ");
    for (int i = 0;
    i < n.length; i ++) n [i] = in.nextInt ();

    int small = n [0], ssmall = n [0];
    for (int i = 0;
    i < n.length; i ++) {
        if (small > n [i]) {
            ssmall = small;
            small = n [i];
        } else if (ssmall > n [i]) ssmall = n [i];

    }
    if (small == n [0]) {
        ssmall = n [1];
        for (int i = 1;
        i < n.length; i ++) {
            if (ssmall > n [i]) {
                ssmall = n [i];
            }
        }
    }
    System.out.println ("Small " + small + " sSmall " + ssmall);
    in.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30427857_30428006_1_22
30427857_44225882_1_18
Title: Finding the second smallest integer in array 
----------------------------------------

public static void main (String [] args) {
    int [] elements = {- 4, 2, 10, - 2, - 3};
    int smallest = Integer.MAX_VALUE;
    int secondSmallest = Integer.MAX_VALUE;
    for (int i = 0;
    i < elements.length; i ++) {
        if (smallest > elements [i]) smallest = elements [i];

    }
    for (int i = 0;
    i < elements.length; i ++) {
        if (secondSmallest > elements [i] && elements [i] > smallest) secondSmallest = elements [i];

    }
    System.out.println ("The smallest element is: " + smallest + "\n" + "The second smallest element is: " + secondSmallest);
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {6, 1, 37, - 4, 12, 46, 5, 64, 21, 2, - 4, - 3};
    int lowest = arr [0];
    int sec_lowest = arr [0];
    for (int n : arr) {
        if (lowest > n) {
            sec_lowest = lowest;
            lowest = n;
        } else if (sec_lowest > n && lowest != n) sec_lowest = n;

    }
    System.out.println (lowest + "   " + sec_lowest);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30427857_30428006_1_22
30427857_47120220_1_25
Title: Finding the second smallest integer in array 
----------------------------------------

public static void main (String [] args) {
    int [] elements = {- 4, 2, 10, - 2, - 3};
    int smallest = Integer.MAX_VALUE;
    int secondSmallest = Integer.MAX_VALUE;
    for (int i = 0;
    i < elements.length; i ++) {
        if (smallest > elements [i]) smallest = elements [i];

    }
    for (int i = 0;
    i < elements.length; i ++) {
        if (secondSmallest > elements [i] && elements [i] > smallest) secondSmallest = elements [i];

    }
    System.out.println ("The smallest element is: " + smallest + "\n" + "The second smallest element is: " + secondSmallest);
}
----------------------------------------

public static void main (String args []) {
    int [] array = new int [] {10, 30, 15, 8, 20, 4};
    int min, secondMin;
    if (array [0] > array [1]) {
        min = array [1];
        secondMin = array [0];
    } else {
        min = array [0];
        secondMin = array [1];
    }
    for (int i = 2;
    i < array.length; i ++) {
        if (array [i] < min) {
            secondMin = min;
            min = array [i];
        } else if ((array [i] > min) && (array [i] < secondMin)) {
            secondMin = array [i];
        }

    }
    System.out.println (secondMin);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30427857_41913377_1_35
30427857_44225882_1_18
Title: Finding the second smallest integer in array 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter array size = ");
    int size = in.nextInt ();
    int [] n = new int [size];
    System.out.println ("Enter " + size + " values ");
    for (int i = 0;
    i < n.length; i ++) n [i] = in.nextInt ();

    int small = n [0], ssmall = n [0];
    for (int i = 0;
    i < n.length; i ++) {
        if (small > n [i]) {
            ssmall = small;
            small = n [i];
        } else if (ssmall > n [i]) ssmall = n [i];

    }
    if (small == n [0]) {
        ssmall = n [1];
        for (int i = 1;
        i < n.length; i ++) {
            if (ssmall > n [i]) {
                ssmall = n [i];
            }
        }
    }
    System.out.println ("Small " + small + " sSmall " + ssmall);
    in.close ();
}
----------------------------------------

public static void main (String [] args) {
    int arr [] = {6, 1, 37, - 4, 12, 46, 5, 64, 21, 2, - 4, - 3};
    int lowest = arr [0];
    int sec_lowest = arr [0];
    for (int n : arr) {
        if (lowest > n) {
            sec_lowest = lowest;
            lowest = n;
        } else if (sec_lowest > n && lowest != n) sec_lowest = n;

    }
    System.out.println (lowest + "   " + sec_lowest);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30427857_41913377_1_35
30427857_47120220_1_25
Title: Finding the second smallest integer in array 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    System.out.println ("Enter array size = ");
    int size = in.nextInt ();
    int [] n = new int [size];
    System.out.println ("Enter " + size + " values ");
    for (int i = 0;
    i < n.length; i ++) n [i] = in.nextInt ();

    int small = n [0], ssmall = n [0];
    for (int i = 0;
    i < n.length; i ++) {
        if (small > n [i]) {
            ssmall = small;
            small = n [i];
        } else if (ssmall > n [i]) ssmall = n [i];

    }
    if (small == n [0]) {
        ssmall = n [1];
        for (int i = 1;
        i < n.length; i ++) {
            if (ssmall > n [i]) {
                ssmall = n [i];
            }
        }
    }
    System.out.println ("Small " + small + " sSmall " + ssmall);
    in.close ();
}
----------------------------------------

public static void main (String args []) {
    int [] array = new int [] {10, 30, 15, 8, 20, 4};
    int min, secondMin;
    if (array [0] > array [1]) {
        min = array [1];
        secondMin = array [0];
    } else {
        min = array [0];
        secondMin = array [1];
    }
    for (int i = 2;
    i < array.length; i ++) {
        if (array [i] < min) {
            secondMin = min;
            min = array [i];
        } else if ((array [i] > min) && (array [i] < secondMin)) {
            secondMin = array [i];
        }

    }
    System.out.println (secondMin);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30427857_44225882_1_18
30427857_47120220_1_25
Title: Finding the second smallest integer in array 
----------------------------------------

public static void main (String [] args) {
    int arr [] = {6, 1, 37, - 4, 12, 46, 5, 64, 21, 2, - 4, - 3};
    int lowest = arr [0];
    int sec_lowest = arr [0];
    for (int n : arr) {
        if (lowest > n) {
            sec_lowest = lowest;
            lowest = n;
        } else if (sec_lowest > n && lowest != n) sec_lowest = n;

    }
    System.out.println (lowest + "   " + sec_lowest);
}
----------------------------------------

public static void main (String args []) {
    int [] array = new int [] {10, 30, 15, 8, 20, 4};
    int min, secondMin;
    if (array [0] > array [1]) {
        min = array [1];
        secondMin = array [0];
    } else {
        min = array [0];
        secondMin = array [1];
    }
    for (int i = 2;
    i < array.length; i ++) {
        if (array [i] < min) {
            secondMin = min;
            min = array [i];
        } else if ((array [i] > min) && (array [i] < secondMin)) {
            secondMin = array [i];
        }

    }
    System.out.println (secondMin);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30428660_30430086_32_75
30428660_30430086_93_130
Title: NIO SocketChannel saying there is no data when there is (or selector is not informing me) 
----------------------------------------

public void run () {
    try {
        sc = SocketChannel.open ();
        sc.socket ().setTcpNoDelay (true);
        sc.configureBlocking (false);
        SelectionKey k = sc.register (selector, SelectionKey.OP_CONNECT);
        boolean firstConnect = sc.connect (new InetSocketAddress ("localhost", Test.PORT));
        if (firstConnect) {
            System.out.println ("Connected on first connect, de-registering OP_CONNECT");
            k.interestOps (SelectionKey.OP_READ);
        }
        while (true) {
            int keys = selector.selectNow ();
            if (keys > 0) {
                for (SelectionKey key : selector.selectedKeys ()) {
                    if (key.isConnectable ()) {
                        boolean finishConnectResult = sc.finishConnect ();
                        key.interestOps (SelectionKey.OP_READ);
                        System.out.println ("Finished connection: " + finishConnectResult);
                    }
                    if (key.isReadable ()) {
                        ByteBuffer bb = ByteBuffer.allocate (2);
                        int bytesRead = 0;
                        while ((bytesRead = sc.read (bb)) > 0) {
                            bb.flip ();
                            System.out.println (bytesRead + " bytes read");
                            System.out.println (bb.get () + ", " + bb.get ());
                        }
                        System.out.println ("Last bytes read value = " + bytesRead);
                        System.exit (0);
                    }
                }
            }
            Thread.sleep (5);
        }
    } catch (Exception e) {
        e.printStackTrace ();
        throw new RuntimeException ();
    }
}
----------------------------------------

public void run () {
    boolean notSentData = true;
    try {
        while (true) {
            int keys = selector.selectNow ();
            if (keys > 0) {
                for (SelectionKey key : selector.selectedKeys ()) {
                    if (key.isAcceptable ()) {
                        ServerSocketChannel ssc = (ServerSocketChannel) key.channel ();
                        sc = ssc.accept ();
                        if (sc != null) {
                            sc.configureBlocking (false);
                            sc.socket ().setTcpNoDelay (true);
                            sc.register (selector, SelectionKey.OP_WRITE);
                            System.out.println ("Server accepted connection");
                        } else {
                            System.out.println ("Got null connection");
                        }
                    }
                }
            }
            if (sc != null && notSentData) {
                ByteBuffer bb = ByteBuffer.allocate (4);
                bb.put (new byte [] {1, 2, 3, - 1});
                bb.flip ();
                int wrote = sc.write (bb);
                System.out.println ("Wrote " + wrote + " bytes");
                notSentData = false;
            }
            Thread.sleep (5);
        }
    } catch (Exception e) {
        e.printStackTrace ();
        throw new RuntimeException ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30433830_30434073_5_37
30433830_30434087_1_34
Title: Adding corresponding elements of two arrays into third array 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    System.out.print ("Input the length ");
    int len = in.nextInt ();
    int [] arrA = new int [len];
    int [] arrB = new int [len];
    int [] sum = new int [len];
    for (int i = 0;
    i < len; i ++) {
        System.out.print ("Enter a value for first array, position " + i + ": ");
        arrA [i] = in.nextInt ();
    }
    for (int i = 0;
    i < len; i ++) {
        System.out.print ("Enter a value for second array, position " + i + ": ");
        arrB [i] = in.nextInt ();
    }
    for (int i = 0;
    i < arrA.length; i ++) {
        for (int j = 0;
        i < arrB.length; i ++) {
            sum [i] = arrA [i] + arrB [i];
        }
    }
    System.out.println ("sum: " + sum [0] + "," + sum [1] + "," + sum [2] + "," + sum [3]);
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("Length of arrays: ");
    try {
        int length = sc.nextInt ();
        int [] arrA = new int [length];
        int [] arrB = new int [length];
        int [] arrSum = new int [length];
        for (int i = 0;
        i < arrA.length; i ++) {
            System.out.println ("Values for arrA at index: " + i);
            int value = sc.nextInt ();
            arrA [i] = value;
        }
        for (int i = 0;
        i < arrB.length; i ++) {
            System.out.println ("Values for arrB at index: " + i);
            int value = sc.nextInt ();
            arrB [i] = value;
        }
        arrSum = makeSum (arrA, arrB, length);
        System.out.println (Arrays.toString (arrSum));
    } catch (Exception e) {
        e.printStackTrace ();
    } finally {
        sc.close ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30444398_30459581_40_57
30444398_30474855_19_31
Title: Deadlock with wait and notifyAll in Java - Threads don't wake up when notifyAll is called 
----------------------------------------

public synchronized void run () {
    while (curr != prev && curr - prev != 1) {
        try {
            Thread.sleep (1000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
    System.out.println (curr);
    prev = curr;
    Set < Thread > threadSet = Thread.getAllStackTraces ().keySet ();
    for (Thread str : threadSet) {
        System.out.println ("Thread name:" + str.getName () + " ; State:" + str.getState ().toString ());
    }
}
----------------------------------------

public void run () {
    synchronized (nextToPrint) {
        while (nextToPrint.get () != curr) {
            try {
                nextToPrint.wait ();
            } catch (InterruptedException e) {
            }
        }
        System.out.println (curr);
        nextToPrint.incrementAndGet ();
        nextToPrint.notifyAll ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30446996_30459021_6_37
30446996_43901889_5_178
Title: JavaFX begginer's simple calculator event handling 
----------------------------------------

public void start (Stage primaryStage) {
    List < String > buttons = Arrays.asList ("7", "8", "9", "+", "4", "5", "6", "-", "1", "2", "3", "*", "0", "=", "/", "EE");
    FlowPane pane = new FlowPane ();
    pane.setAlignment (Pos.CENTER);
    pane.setPadding (new Insets (30, 20, 30, 20));
    pane.setHgap (5);
    pane.setVgap (5);
    pane.setMinWidth (400);
    pane.setPrefWidth (400);
    pane.setMaxWidth (400);
    textField.setEditable (false);
    textField.setAlignment (Pos.CENTER);
    textField.setMinSize (336, 40);
    pane.getChildren ().add (textField);
    for (String button : buttons) {
        Button b = new Button (button);
        b.setMinSize (80, 80);
        pane.getChildren ().add (b);
        b.setOnAction ((e) -> doSomething (b.getText ()));
    }
    Scene scene = new Scene (pane);
    primaryStage.setTitle ("Calculator");
    primaryStage.setScene (scene);
    primaryStage.show ();
}
----------------------------------------

public void start (Stage primaryStage) {
    primaryStage.setTitle ("Calculator");
    GridPane root = new GridPane ();
    Label textBox1 = new Label ("Text1");
    root.add (textBox1, 0, 0, 5, 1);
    Label textBox2 = new Label ("Text2");
    root.add (textBox2, 0, 1, 5, 1);
    textBox1.setId ("lblTextBox1");
    textBox2.setId ("lblTextBox2");
    Button btn0 = new Button ("0");
    Button btn1 = new Button ("1");
    Button btn2 = new Button ("2");
    Button btn3 = new Button ("3");
    Button btn4 = new Button ("4");
    Button btn5 = new Button ("5");
    Button btn6 = new Button ("6");
    Button btn7 = new Button ("7");
    Button btn8 = new Button ("8");
    Button btn9 = new Button ("9");
    btn0.setId ("btn0");
    btn1.setId ("btn1");
    btn2.setId ("btn2");
    btn3.setId ("btn3");
    btn4.setId ("btn4");
    btn5.setId ("btn5");
    btn6.setId ("btn6");
    btn7.setId ("btn7");
    btn8.setId ("btn8");
    btn9.setId ("btn9");
    Button btnDot = new Button (".");
    Button btnPlus = new Button ("+");
    Button btnMinus = new Button ("-");
    Button btnTimes = new Button ("*");
    Button btnDivide = new Button ("/");
    Button btnEquals = new Button ("=");
    Button btnMC = new Button ("MC");
    Button btnMR = new Button ("MR");
    Button btnMS = new Button ("MS");
    Button btnMPlus = new Button ("M+");
    Button btnMMinus = new Button ("M-");
    Button btnBack = new Button ("<=");
    Button btnCE = new Button ("CE");
    Button btnC = new Button ("C");
    Button btnPlusOrMinus = new Button ("+/-");
    Button btnSqrt = new Button ("sqrt");
    Button btnPercentage = new Button ("%");
    Button btn1OverX = new Button ("1/x");
    btnPlus.setId ("btnPlus");
    btnTimes.setId ("btnTimes");
    btnDot.setId ("btnDot");
    btnEquals.setId ("btnEquals");
    btnC.setId ("btnClear");
    btn0.setMaxHeight (Double.MAX_VALUE);
    btn0.setMaxWidth (Double.MAX_VALUE);
    btn1.setMaxHeight (Double.MAX_VALUE);
    btn1.setMaxWidth (Double.MAX_VALUE);
    btn2.setMaxHeight (Double.MAX_VALUE);
    btn2.setMaxWidth (Double.MAX_VALUE);
    btn3.setMaxHeight (Double.MAX_VALUE);
    btn3.setMaxWidth (Double.MAX_VALUE);
    btn4.setMaxHeight (Double.MAX_VALUE);
    btn4.setMaxWidth (Double.MAX_VALUE);
    btn5.setMaxHeight (Double.MAX_VALUE);
    btn5.setMaxWidth (Double.MAX_VALUE);
    btn6.setMaxHeight (Double.MAX_VALUE);
    btn6.setMaxWidth (Double.MAX_VALUE);
    btn7.setMaxHeight (Double.MAX_VALUE);
    btn7.setMaxWidth (Double.MAX_VALUE);
    btn8.setMaxHeight (Double.MAX_VALUE);
    btn8.setMaxWidth (Double.MAX_VALUE);
    btn9.setMaxHeight (Double.MAX_VALUE);
    btn9.setMaxWidth (Double.MAX_VALUE);
    btnEquals.setMaxHeight (Double.MAX_VALUE);
    btnEquals.setMaxWidth (Double.MAX_VALUE);
    btnMC.setMaxHeight (Double.MAX_VALUE);
    btnMC.setMaxWidth (Double.MAX_VALUE);
    btnMMinus.setMaxHeight (Double.MAX_VALUE);
    btnMMinus.setMaxWidth (Double.MAX_VALUE);
    btnPlusOrMinus.setMaxHeight (Double.MAX_VALUE);
    btnPlusOrMinus.setMaxWidth (Double.MAX_VALUE);
    btnPercentage.setMaxHeight (Double.MAX_VALUE);
    btnPercentage.setMaxWidth (Double.MAX_VALUE);
    btnSqrt.setMaxHeight (Double.MAX_VALUE);
    btnSqrt.setMaxWidth (Double.MAX_VALUE);
    btn1OverX.setMaxHeight (Double.MAX_VALUE);
    btn1OverX.setMaxWidth (Double.MAX_VALUE);
    btnPlus.setMaxHeight (Double.MAX_VALUE);
    btnPlus.setMaxWidth (Double.MAX_VALUE);
    btnMinus.setMaxHeight (Double.MAX_VALUE);
    btnMinus.setMaxWidth (Double.MAX_VALUE);
    btnTimes.setMaxHeight (Double.MAX_VALUE);
    btnTimes.setMaxWidth (Double.MAX_VALUE);
    btnDivide.setMaxHeight (Double.MAX_VALUE);
    btnDivide.setMaxWidth (Double.MAX_VALUE);
    btnCE.setMaxHeight (Double.MAX_VALUE);
    btnCE.setMaxWidth (Double.MAX_VALUE);
    btnC.setMaxHeight (Double.MAX_VALUE);
    btnC.setMaxWidth (Double.MAX_VALUE);
    btnDot.setMaxHeight (Double.MAX_VALUE);
    btnDot.setMaxWidth (Double.MAX_VALUE);
    root.add (btnMC, 0, 1);
    root.add (btnMR, 1, 1);
    root.add (btnMS, 2, 1);
    root.add (btnMPlus, 3, 1);
    root.add (btnMMinus, 4, 1);
    root.add (btnBack, 0, 2);
    root.add (btnCE, 1, 2);
    root.add (btnC, 2, 2);
    root.add (btnPlusOrMinus, 3, 2);
    root.add (btnSqrt, 4, 2);
    root.add (btn7, 0, 3);
    root.add (btn8, 1, 3);
    root.add (btn9, 2, 3);
    root.add (btnDivide, 3, 3);
    root.add (btnPercentage, 4, 3);
    root.add (btn4, 0, 4);
    root.add (btn5, 1, 4);
    root.add (btn6, 2, 4);
    root.add (btnTimes, 3, 4);
    root.add (btn1OverX, 4, 4);
    root.add (btn1, 0, 5);
    root.add (btn2, 1, 5);
    root.add (btn3, 2, 5);
    root.add (btnMinus, 3, 5);
    root.add (btnEquals, 4, 5, 1, 2);
    root.add (btn0, 0, 6, 2, 1);
    root.add (btnDot, 2, 6);
    root.add (btnPlus, 3, 6);
    root.setVgap (5);
    root.setHgap (5);
    root.setPadding (new Insets (5, 5, 5, 5));
    primaryStage.setScene (new Scene (root));
    primaryStage.show ();
    Controller controller = new Controller (primaryStage.getScene ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30447230_30447596_17_29
30447230_30447596_33_45
Title: Remove List Item without Iterator.remove() in Java 
----------------------------------------

public void run () {
    while (true) {
        for (String l : stringList) {
            System.out.println (l);
            try {
                Thread.sleep (10);
            } catch (InterruptedException e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        stringList.remove (0);
        stringList.add ("string item");
        try {
            Thread.sleep (1000);
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30447469_30447700_1_25
30447469_30447712_1_10
Title: Capitalize various letters in a string 
----------------------------------------

public static String capitalize (String s, int [] array) {
    char [] stringChars = new char [s.length];
    for (int x = 0;
    x < stringChars.length; x ++) {
        stringChars [x] = s.charAt (x);
    }
    String finalString;
    boolean matches;
    for (int x = 0;
    x < stringChars.length; x ++) {
        for (int y = 0;
        y < array.length; y ++) {
            if (array [y] == x) {
                matches = true;
                break;
            }
            if (matches == true) stringChars [x] = Character.toUppercase (stringChars [x]);

            finalString += stringChars [x];
        }
    }
    return finalString;
}
----------------------------------------

public static String capitalize (String string, int [] caps) {
    if (caps [caps.length - 1] > string.length ()) {
        return "String not long enough.";
    }
    StringBuilder sb = new StringBuilder (string);
    for (int i : caps) {
        sb.setCharAt (i - 1, Character.toUpperCase (sb.charAt (i - 1)));
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30449694_30449979_1_45
30449694_30450149_1_20
Title: how to find upside down of a 2digit number 
----------------------------------------

public static void main (String [] args) {
    List < String > al = new ArrayList < String > ();
    al.add ("0");
    al.add ("1");
    al.add ("6");
    al.add ("8");
    al.add ("9");
    Scanner s = new Scanner (System.in);
    Integer n = s.nextInt ();
    String num = n + "";
    if (num.length () == 2) {
        if (al.contains (num.charAt (0) + "") && al.contains (num.charAt (1) + "")) {
            System.out.println ("Yes");
            String upSideDownNumber = "";
            if (num.charAt (1) == 6) {
                upSideDownNumber += 9;
            } else if (num.charAt (1) == 9) {
                upSideDownNumber += 6;
            } else {
                upSideDownNumber += num.charAt (1);
            }

            if (num.charAt (0) == 6) {
                upSideDownNumber += 9;
            } else if (num.charAt (0) == 9) {
                upSideDownNumber += 6;
            } else {
                upSideDownNumber += num.charAt (0);
            }

            System.out.println ("The up side down number is " + upSideDownNumber);
        } else {
            System.out.println ("No");
        }
    } else {
        System.out.println ("No");
    }
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Set < Integer > upsideDownProperDigits = new TreeSet < > (Arrays.asList (0, 1, 8, 9, 6));
    Scanner s = new Scanner (System.in);
    Integer n = s.nextInt ();
    boolean found = true;
    while (n != 0) {
        int digit = n % 10;
        if (! upsideDownProperDigits.contains (digit)) {
            found = false;
            break;
        }
        n = n / 10;
    }
    if (found) {
        System.out.println ("yes");
    } else {
        System.out.println ("no");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30449980_30450046_1_10
30449980_30450803_1_14
Title: "Create List [x-n x-n+1...xx+1x+2...x+n] in Java" 
----------------------------------------

public List < Integer > getList (int x, int n) {
    int lower = x - n;
    int upper = x + n;
    List < Integer > ls = new ArrayList < Integer > ();
    for (int i = lower;
    i <= upper; i ++) {
        ls.add (i);
    }
    return ls;
}
----------------------------------------

public List < Integer > getList (int x, int n) {
    ArrayList < Integer > returnVal = new ArrayList < Integer > ();
    if (n < 0) {
        for (int i = n;
        i <= - n; i ++) {
            returnVal.add (i + x);
        }
    } else {
        for (int i = - n;
        i <= n; i ++) {
            returnVal.add (i + x);
        }
    }
    return returnVal;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30453355_30457222_4_24
30453355_30474681_3_18
Title: Compare date time in SQL Timestamp with XMLGregorianCalendar and ignoring seconds in JAVA 
----------------------------------------

public static void main (String [] args) {
    GregorianCalendar gc = new GregorianCalendar ();
    gc.setTime (new Date ());
    try {
        XMLGregorianCalendar xmlGregorianCalendar = DatatypeFactory.newInstance ().newXMLGregorianCalendar (gc);
        Timestamp timeStamp = new Timestamp (System.currentTimeMillis ());
        System.out.println ("Are dates equal using manual check : " + manualDateCheck (timeStamp, xmlGregorianCalendar));
        Calendar timeStampCalendar = Calendar.getInstance ();
        timeStampCalendar.setTime (timeStamp);
        System.out.println ("Are dates equal using calendar check : " + calendarCheck (timeStampCalendar, xmlGregorianCalendar.toGregorianCalendar ()));
    } catch (DatatypeConfigurationException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) throws DatatypeConfigurationException {
    SimpleDateFormat dateFormat = new SimpleDateFormat ("yyyy-MM-dd HH:mm");
    GregorianCalendar gc = new GregorianCalendar ();
    gc.setTime (new Date ());
    XMLGregorianCalendar xmlGregorianCalendar = DatatypeFactory.newInstance ().newXMLGregorianCalendar (gc);
    Timestamp timeStamp = new Timestamp (System.currentTimeMillis ());
    String sqlTimestamp = dateFormat.format (timeStamp);
    Timestamp xmlToSqlTimestamp = new Timestamp (xmlGregorianCalendar.toGregorianCalendar ().getTimeInMillis ());
    String xmlTimestamp = dateFormat.format (xmlToSqlTimestamp);
    System.out.println (timeStamp + " : " + xmlGregorianCalendar);
    System.out.println (sqlTimestamp + " : " + xmlTimestamp);
    System.out.println ("Time stamps are equal : " + sqlTimestamp.equalsIgnoreCase (xmlTimestamp));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30455276_30455673_1_20
30455276_30455711_1_23
Title: JsonObject JsonArray : get value and make to json 
----------------------------------------

public String getList () throws JSONException {
    User dataUser = memberO.getMember (1);
    JSONObject jsonObject = new JSONObject ();
    jsonObject.put ("name", dataUser.getUserName ());
    jsonObject.put ("account", dataUser.getAccount ());
    jsonObject.put ("edit", dataUser.getUserId ());
    jsonObject.put ("delete", dataUser.getUserId ());
    JSONArray jsonArray = new JSONArray ();
    jsonArray.add (jsonObject);
    JSONObject responseJson = new JSONObject ();
    responseJson.put ("data", jsonArray);
    return responseJson.toString ();
}
----------------------------------------

public String getList () throws JSONException {
    User dataUser = memberO.getMember (1);
    JSONObject jsonObject = new JSONObject ();
    jsonObject.put ("name", dataUser.getUserName ());
    jsonObject.put ("account", dataUser.getAccount ());
    jsonObject.put ("edit", dataUser.getUserId ());
    jsonObject.put ("delete", dataUser.getUserId ());
    JSONArray jsonArray = new JSONArray ();
    jsonArray.put (0, jsonObject);
    JSONObject topObject = new JSONObject ();
    topObject.put ("data", jsonArray);
    System.out.println (topObject.toJSONString);
    System.out.println (jsonArray);
    String str = "{\"data\": [{\"name\": \"" + dataUser.getUserName () + "\",\"account\": \"" + dataUser.getAccount () + "\",\"edit\": \"" + dataUser.getUserId () + "\",\"delete\": \"" + dataUser.getUserId () + "\"}]}";
    return str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30458633_30458778_1_24
30458633_30458831_1_23
Title: Why does my compare methd throw IllegalArgumentException sometimes? 
----------------------------------------

public int compare (FileItem o1, FileItem o2) {
    if (o1 == null) {
        if (o2 == null) {
            return 0;
        } else {
            return 1;
        }
    } else if (o2 == null) {
        return - 1;
    }

    String n1 = o1.getFileName ();
    String n2 = o2.getFileName ();
    if (n1 == null) {
        if (n2 == null) {
            return 0;
        } else {
            return 1;
        }
    } else if (n2 == null) {
        return - 1;
    }

    return n1.compareTo (n2);
}
----------------------------------------

public int compare (FileItem o1, FileItem o2) {
    if (o1 == null && o2 == null) {
        return 0;
    }
    if (o1 == null || o2 == null) {
        return o1 == null ? - 1 : 1;
    }
    String n1 = o1.getFileName ();
    String n2 = o2.getFileName ();
    if (n1 == null && n2 == null) {
        return 0;
    }
    if (n1 == null || n2 == null) {
        return n1 == null ? - 1 : 1;
    }
    return n1.compareTo (n2);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3047051_3047151_1_12
3047051_3047160_1_16
Title: How to determine if a List is sorted in Java? 
----------------------------------------

public static < T extends Comparable < ? super T > > boolean isSorted (List < T > list) {
    if (list.size () != 0) {
        ListIterator < T > it = list.listIterator ();
        for (T item = it.next ();
        it.hasNext (); item = it.next ()) {
            if (it.hasPrevious () && it.previous ().compareTo (it.next ()) > 0) {
                return false;
            }
        }
    }
    return true;
}
----------------------------------------

public static < T extends Comparable < ? super T > > boolean isSorted (Iterable < T > iterable) {
    Iterator < T > iter = iterable.iterator ();
    if (! iter.hasNext ()) {
        return true;
    }
    T t = iter.next ();
    while (iter.hasNext ()) {
        T t2 = iter.next ();
        if (t.compareTo (t2) > 0) {
            return false;
        }
        t = t2;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3047051_3047151_1_12
3047051_3047191_1_13
Title: How to determine if a List is sorted in Java? 
----------------------------------------

public static < T extends Comparable < ? super T > > boolean isSorted (List < T > list) {
    if (list.size () != 0) {
        ListIterator < T > it = list.listIterator ();
        for (T item = it.next ();
        it.hasNext (); item = it.next ()) {
            if (it.hasPrevious () && it.previous ().compareTo (it.next ()) > 0) {
                return false;
            }
        }
    }
    return true;
}
----------------------------------------

public static < T extends Comparable < ? super T > > boolean isSorted (List < T > a) {
    int length = a.size ();
    if (length <= 1) return true;

    int i = 1;
    T previous = a.get (0);
    while (i < length) {
        T current = a.get (i ++);
        if (previous.compareTo (current) > 0) return false;

        previous = current;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3047051_3047160_1_16
3047051_3047191_1_13
Title: How to determine if a List is sorted in Java? 
----------------------------------------

public static < T extends Comparable < ? super T > > boolean isSorted (Iterable < T > iterable) {
    Iterator < T > iter = iterable.iterator ();
    if (! iter.hasNext ()) {
        return true;
    }
    T t = iter.next ();
    while (iter.hasNext ()) {
        T t2 = iter.next ();
        if (t.compareTo (t2) > 0) {
            return false;
        }
        t = t2;
    }
    return true;
}
----------------------------------------

public static < T extends Comparable < ? super T > > boolean isSorted (List < T > a) {
    int length = a.size ();
    if (length <= 1) return true;

    int i = 1;
    T previous = a.get (0);
    while (i < length) {
        T current = a.get (i ++);
        if (previous.compareTo (current) > 0) return false;

        previous = current;
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30471643_30471724_1_12
30471643_30471755_1_15
Title: java unreachable code error (Render class game development) 
----------------------------------------

public void setPixel (int x, int y, float a, float r, float g, float b) {
    if ((x < 0 || x >= width || y < 0 || y >= height) || a == 0) {
        int index = (x + y * width) * 4;
        pixels [index] = (byte) ((a * 255f) + 0.5f);
        pixels [index + 1] = (byte) ((b * 255f) + 0.5f);
        pixels [index + 2] = (byte) ((g * 255f) + 0.5f);
        pixels [index + 3] = (byte) ((r * 255f) + 0.5f);
    }
}
----------------------------------------

public void setPixel (int x, int y, float a, float r, float g, float b) {
    if ((x < 0 || x >= width || y < 0 || y >= height) || a == 0) {
        return;
    }
    int index = (x + y * width) * 4;
    pixels [index] = (byte) ((a * 255f) + 0.5f);
    pixels [index + 1] = (byte) ((b * 255f) + 0.5f);
    pixels [index + 2] = (byte) ((g * 255f) + 0.5f);
    pixels [index + 3] = (byte) ((r * 255f) + 0.5f);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30472931_30473852_1_20
30472931_30474195_1_22
Title: how i could fix this wrong in algoritimo quicksort 
----------------------------------------

private int partition (int left, int right, String [] array) {
    int pointL = left - 1;
    int pointR = right;
    String [] a = array;
    String pivot = a [left + (left + right) / 2];
    while (pointL < pointR) {
        while (a [++ pointL].compareTo (pivot) < 0);

        while (pointR > 0 && a [-- pointR].compareTo (pivot) > 0);

        if (pointL >= pointR) {
            break;
        } else {
            a = swap (pointL, pointR, a);
        }
    }
    a = swap (pointL, right, a);
    return pointL;
}
----------------------------------------

private int partition (String [] array, int inicio, int fim) {
    String pivo = array [(inicio + fim) / 2];
    int i = inicio;
    int j = fim;
    while (true) {
        while (array [i].compareTo (pivo) < 0) {
            i ++;
        }
        while (array [j].compareTo (pivo) > 0) {
            j --;
        }
        if (i < j) {
            swap (array, i, j);
            i ++;
            j --;
        } else {
            return i;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30473512_30473612_1_14
30473512_30473633_9_17
Title: Adding a sentence word by word into a set using Recursion 
----------------------------------------

public static TreeSet < String > getWordSet (String words) {
    TreeSet < String > result = new TreeSet < String > ();
    int index = words.indexOf (" ");
    if (index < 0 && words.length () == 0) {
        return result;
    } else if (index < 0 && words.length () > 0) {
        result.add (words);
    } else {
        result = getWordSet (words.substring (index + 1));
        result.add (words.substring (0, index));
    }

    return result;
}
----------------------------------------

public static void getWordSet (String words, Set set) {
    int index = words.indexOf (" ");
    if (index < 0) {
        if (words.length () > 0) set.add (words);

    } else {
        set.add (words.substring (0, index));
        getWordSet (words.substring (index + 1), set);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30473512_30473612_1_14
30473512_30473807_5_17
Title: Adding a sentence word by word into a set using Recursion 
----------------------------------------

public static TreeSet < String > getWordSet (String words) {
    TreeSet < String > result = new TreeSet < String > ();
    int index = words.indexOf (" ");
    if (index < 0 && words.length () == 0) {
        return result;
    } else if (index < 0 && words.length () > 0) {
        result.add (words);
    } else {
        result = getWordSet (words.substring (index + 1));
        result.add (words.substring (0, index));
    }

    return result;
}
----------------------------------------

public static TreeSet < String > getWordSet (String sentence, TreeSet < String > mySet) {
    int index = sentence.indexOf (" ");
    if (index < 0) if (sentence.length () > 0) index = sentence.length () - 1;
    else return mySet;

    mySet.add (sentence.substring (0, index));
    getWordSet (sentence.substring (index + 1), mySet);
    return mySet;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30473512_30473633_9_17
30473512_30473807_5_17
Title: Adding a sentence word by word into a set using Recursion 
----------------------------------------

public static void getWordSet (String words, Set set) {
    int index = words.indexOf (" ");
    if (index < 0) {
        if (words.length () > 0) set.add (words);

    } else {
        set.add (words.substring (0, index));
        getWordSet (words.substring (index + 1), set);
    }
}
----------------------------------------

public static TreeSet < String > getWordSet (String sentence, TreeSet < String > mySet) {
    int index = sentence.indexOf (" ");
    if (index < 0) if (sentence.length () > 0) index = sentence.length () - 1;
    else return mySet;

    mySet.add (sentence.substring (0, index));
    getWordSet (sentence.substring (index + 1), mySet);
    return mySet;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_144_166
30481363_30491805_189_203
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (event.isControlDown () || event.isShiftDown ()) return;

    Node node = (Node) event.getSource ();
    dragContext.x = node.getTranslateX () - event.getSceneX ();
    dragContext.y = node.getTranslateY () - event.getSceneY ();
    if (! selectionModel.contains (node)) {
        selectionModel.clear ();
        selectionModel.add (node);
    }
    enabled = true;
    event.consume ();
}
----------------------------------------

public void handle (MouseEvent event) {
    if (enabled) {
        for (Node node : selectionModel.selection) {
            fixPosition (node);
        }
        enabled = false;
        event.consume ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_144_166
30481363_30491805_258_278
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (event.isControlDown () || event.isShiftDown ()) return;

    Node node = (Node) event.getSource ();
    dragContext.x = node.getTranslateX () - event.getSceneX ();
    dragContext.y = node.getTranslateY () - event.getSceneY ();
    if (! selectionModel.contains (node)) {
        selectionModel.clear ();
        selectionModel.add (node);
    }
    enabled = true;
    event.consume ();
}
----------------------------------------

public void handle (MouseEvent event) {
    if (enabled) return;

    dragContext.mouseAnchorX = event.getSceneX ();
    dragContext.mouseAnchorY = event.getSceneY ();
    rect.setX (dragContext.mouseAnchorX);
    rect.setY (dragContext.mouseAnchorY);
    rect.setWidth (0);
    rect.setHeight (0);
    group.getChildren ().add (rect);
    event.consume ();
    enabled = true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_144_166
30481363_30491805_284_327
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (event.isControlDown () || event.isShiftDown ()) return;

    Node node = (Node) event.getSource ();
    dragContext.x = node.getTranslateX () - event.getSceneX ();
    dragContext.y = node.getTranslateY () - event.getSceneY ();
    if (! selectionModel.contains (node)) {
        selectionModel.clear ();
        selectionModel.add (node);
    }
    enabled = true;
    event.consume ();
}
----------------------------------------

public void handle (MouseEvent event) {
    if (! event.isShiftDown () && ! event.isControlDown ()) {
        selectionModel.clear ();
    }
    for (Node node : group.getChildren ()) {
        if (node instanceof Selectable) {
            if (node.getBoundsInParent ().intersects (rect.getBoundsInParent ())) {
                if (event.isShiftDown ()) {
                    selectionModel.add (node);
                } else if (event.isControlDown ()) {
                    if (selectionModel.contains (node)) {
                        selectionModel.remove (node);
                    } else {
                        selectionModel.add (node);
                    }
                } else {
                    selectionModel.add (node);
                }

            }
        }
    }
    selectionModel.log ();
    rect.setX (0);
    rect.setY (0);
    rect.setWidth (0);
    rect.setHeight (0);
    group.getChildren ().remove (rect);
    event.consume ();
    enabled = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_144_166
30481363_30491805_333_354
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (event.isControlDown () || event.isShiftDown ()) return;

    Node node = (Node) event.getSource ();
    dragContext.x = node.getTranslateX () - event.getSceneX ();
    dragContext.y = node.getTranslateY () - event.getSceneY ();
    if (! selectionModel.contains (node)) {
        selectionModel.clear ();
        selectionModel.add (node);
    }
    enabled = true;
    event.consume ();
}
----------------------------------------

public void handle (MouseEvent event) {
    double offsetX = event.getSceneX () - dragContext.mouseAnchorX;
    double offsetY = event.getSceneY () - dragContext.mouseAnchorY;
    if (offsetX > 0) rect.setWidth (offsetX);
    else {
        rect.setX (event.getSceneX ());
        rect.setWidth (dragContext.mouseAnchorX - rect.getX ());
    }
    if (offsetY > 0) {
        rect.setHeight (offsetY);
    } else {
        rect.setY (event.getSceneY ());
        rect.setHeight (dragContext.mouseAnchorY - rect.getY ());
    }
    event.consume ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_189_203
30481363_30491805_258_278
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (enabled) {
        for (Node node : selectionModel.selection) {
            fixPosition (node);
        }
        enabled = false;
        event.consume ();
    }
}
----------------------------------------

public void handle (MouseEvent event) {
    if (enabled) return;

    dragContext.mouseAnchorX = event.getSceneX ();
    dragContext.mouseAnchorY = event.getSceneY ();
    rect.setX (dragContext.mouseAnchorX);
    rect.setY (dragContext.mouseAnchorY);
    rect.setWidth (0);
    rect.setHeight (0);
    group.getChildren ().add (rect);
    event.consume ();
    enabled = true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_189_203
30481363_30491805_284_327
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (enabled) {
        for (Node node : selectionModel.selection) {
            fixPosition (node);
        }
        enabled = false;
        event.consume ();
    }
}
----------------------------------------

public void handle (MouseEvent event) {
    if (! event.isShiftDown () && ! event.isControlDown ()) {
        selectionModel.clear ();
    }
    for (Node node : group.getChildren ()) {
        if (node instanceof Selectable) {
            if (node.getBoundsInParent ().intersects (rect.getBoundsInParent ())) {
                if (event.isShiftDown ()) {
                    selectionModel.add (node);
                } else if (event.isControlDown ()) {
                    if (selectionModel.contains (node)) {
                        selectionModel.remove (node);
                    } else {
                        selectionModel.add (node);
                    }
                } else {
                    selectionModel.add (node);
                }

            }
        }
    }
    selectionModel.log ();
    rect.setX (0);
    rect.setY (0);
    rect.setWidth (0);
    rect.setHeight (0);
    group.getChildren ().remove (rect);
    event.consume ();
    enabled = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_189_203
30481363_30491805_333_354
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (enabled) {
        for (Node node : selectionModel.selection) {
            fixPosition (node);
        }
        enabled = false;
        event.consume ();
    }
}
----------------------------------------

public void handle (MouseEvent event) {
    double offsetX = event.getSceneX () - dragContext.mouseAnchorX;
    double offsetY = event.getSceneY () - dragContext.mouseAnchorY;
    if (offsetX > 0) rect.setWidth (offsetX);
    else {
        rect.setX (event.getSceneX ());
        rect.setWidth (dragContext.mouseAnchorX - rect.getX ());
    }
    if (offsetY > 0) {
        rect.setHeight (offsetY);
    } else {
        rect.setY (event.getSceneY ());
        rect.setHeight (dragContext.mouseAnchorY - rect.getY ());
    }
    event.consume ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_258_278
30481363_30491805_284_327
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (enabled) return;

    dragContext.mouseAnchorX = event.getSceneX ();
    dragContext.mouseAnchorY = event.getSceneY ();
    rect.setX (dragContext.mouseAnchorX);
    rect.setY (dragContext.mouseAnchorY);
    rect.setWidth (0);
    rect.setHeight (0);
    group.getChildren ().add (rect);
    event.consume ();
    enabled = true;
}
----------------------------------------

public void handle (MouseEvent event) {
    if (! event.isShiftDown () && ! event.isControlDown ()) {
        selectionModel.clear ();
    }
    for (Node node : group.getChildren ()) {
        if (node instanceof Selectable) {
            if (node.getBoundsInParent ().intersects (rect.getBoundsInParent ())) {
                if (event.isShiftDown ()) {
                    selectionModel.add (node);
                } else if (event.isControlDown ()) {
                    if (selectionModel.contains (node)) {
                        selectionModel.remove (node);
                    } else {
                        selectionModel.add (node);
                    }
                } else {
                    selectionModel.add (node);
                }

            }
        }
    }
    selectionModel.log ();
    rect.setX (0);
    rect.setY (0);
    rect.setWidth (0);
    rect.setHeight (0);
    group.getChildren ().remove (rect);
    event.consume ();
    enabled = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_258_278
30481363_30491805_333_354
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (enabled) return;

    dragContext.mouseAnchorX = event.getSceneX ();
    dragContext.mouseAnchorY = event.getSceneY ();
    rect.setX (dragContext.mouseAnchorX);
    rect.setY (dragContext.mouseAnchorY);
    rect.setWidth (0);
    rect.setHeight (0);
    group.getChildren ().add (rect);
    event.consume ();
    enabled = true;
}
----------------------------------------

public void handle (MouseEvent event) {
    double offsetX = event.getSceneX () - dragContext.mouseAnchorX;
    double offsetY = event.getSceneY () - dragContext.mouseAnchorY;
    if (offsetX > 0) rect.setWidth (offsetX);
    else {
        rect.setX (event.getSceneX ());
        rect.setWidth (dragContext.mouseAnchorX - rect.getX ());
    }
    if (offsetY > 0) {
        rect.setHeight (offsetY);
    } else {
        rect.setY (event.getSceneY ());
        rect.setHeight (dragContext.mouseAnchorY - rect.getY ());
    }
    event.consume ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30481363_30491805_284_327
30481363_30491805_333_354
Title: Implement dragging multiple selected nodes 
----------------------------------------

public void handle (MouseEvent event) {
    if (! event.isShiftDown () && ! event.isControlDown ()) {
        selectionModel.clear ();
    }
    for (Node node : group.getChildren ()) {
        if (node instanceof Selectable) {
            if (node.getBoundsInParent ().intersects (rect.getBoundsInParent ())) {
                if (event.isShiftDown ()) {
                    selectionModel.add (node);
                } else if (event.isControlDown ()) {
                    if (selectionModel.contains (node)) {
                        selectionModel.remove (node);
                    } else {
                        selectionModel.add (node);
                    }
                } else {
                    selectionModel.add (node);
                }

            }
        }
    }
    selectionModel.log ();
    rect.setX (0);
    rect.setY (0);
    rect.setWidth (0);
    rect.setHeight (0);
    group.getChildren ().remove (rect);
    event.consume ();
    enabled = false;
}
----------------------------------------

public void handle (MouseEvent event) {
    double offsetX = event.getSceneX () - dragContext.mouseAnchorX;
    double offsetY = event.getSceneY () - dragContext.mouseAnchorY;
    if (offsetX > 0) rect.setWidth (offsetX);
    else {
        rect.setX (event.getSceneX ());
        rect.setWidth (dragContext.mouseAnchorX - rect.getX ());
    }
    if (offsetY > 0) {
        rect.setHeight (offsetY);
    } else {
        rect.setY (event.getSceneY ());
        rect.setHeight (dragContext.mouseAnchorY - rect.getY ());
    }
    event.consume ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3048489_19762257_1_26
3048489_3048508_1_18
Title: What is the Java 1.4.2 equivalent of Pattern.quote() 
----------------------------------------

public static String quote (String str) {
    int eInd = str.indexOf ("\\E");
    if (eInd < 0) {
        return "\\Q" + str + "\\E";
    }
    StringBuilder sb = new StringBuilder (str.length () + 16);
    sb.append ("\\Q");
    int pos = 0;
    do {
        sb.append (str.substring (pos, eInd)).append ("\\E" + "\\\\" + "E" + "\\Q");
        pos = eInd + 2;
    } while ((eInd = str.indexOf ("\\E", pos)) >= 0);
    sb.append (str.substring (pos, str.length ())).append ("\\E");
    return sb.toString ();
}
----------------------------------------

public static String quote (String s) {
    int slashEIndex = s.indexOf ("\\E");
    if (slashEIndex == - 1) return "\\Q" + s + "\\E";

    StringBuilder sb = new StringBuilder (s.length () * 2);
    sb.append ("\\Q");
    slashEIndex = 0;
    int current = 0;
    while ((slashEIndex = s.indexOf ("\\E", current)) != - 1) {
        sb.append (s.substring (current, slashEIndex));
        current = slashEIndex + 2;
        sb.append ("\\E\\\\E\\Q");
    }
    sb.append (s.substring (current, s.length ()));
    sb.append ("\\E");
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3048489_19762257_1_26
3048489_3048522_1_18
Title: What is the Java 1.4.2 equivalent of Pattern.quote() 
----------------------------------------

public static String quote (String str) {
    int eInd = str.indexOf ("\\E");
    if (eInd < 0) {
        return "\\Q" + str + "\\E";
    }
    StringBuilder sb = new StringBuilder (str.length () + 16);
    sb.append ("\\Q");
    int pos = 0;
    do {
        sb.append (str.substring (pos, eInd)).append ("\\E" + "\\\\" + "E" + "\\Q");
        pos = eInd + 2;
    } while ((eInd = str.indexOf ("\\E", pos)) >= 0);
    sb.append (str.substring (pos, str.length ())).append ("\\E");
    return sb.toString ();
}
----------------------------------------

public static String quote (String s) {
    int slashEIndex = s.indexOf ("\\E");
    if (slashEIndex == - 1) return "\\Q" + s + "\\E";

    StringBuilder sb = new StringBuilder (s.length () * 2);
    sb.append ("\\Q");
    slashEIndex = 0;
    int current = 0;
    while ((slashEIndex = s.indexOf ("\\E", current)) != - 1) {
        sb.append (s.substring (current, slashEIndex));
        current = slashEIndex + 2;
        sb.append ("\\E\\\\E\\Q");
    }
    sb.append (s.substring (current, s.length ()));
    sb.append ("\\E");
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3048489_3048508_1_18
3048489_3048522_1_18
Title: What is the Java 1.4.2 equivalent of Pattern.quote() 
----------------------------------------

public static String quote (String s) {
    int slashEIndex = s.indexOf ("\\E");
    if (slashEIndex == - 1) return "\\Q" + s + "\\E";

    StringBuilder sb = new StringBuilder (s.length () * 2);
    sb.append ("\\Q");
    slashEIndex = 0;
    int current = 0;
    while ((slashEIndex = s.indexOf ("\\E", current)) != - 1) {
        sb.append (s.substring (current, slashEIndex));
        current = slashEIndex + 2;
        sb.append ("\\E\\\\E\\Q");
    }
    sb.append (s.substring (current, s.length ()));
    sb.append ("\\E");
    return sb.toString ();
}
----------------------------------------

public static String quote (String s) {
    int slashEIndex = s.indexOf ("\\E");
    if (slashEIndex == - 1) return "\\Q" + s + "\\E";

    StringBuilder sb = new StringBuilder (s.length () * 2);
    sb.append ("\\Q");
    slashEIndex = 0;
    int current = 0;
    while ((slashEIndex = s.indexOf ("\\E", current)) != - 1) {
        sb.append (s.substring (current, slashEIndex));
        current = slashEIndex + 2;
        sb.append ("\\E\\\\E\\Q");
    }
    sb.append (s.substring (current, s.length ()));
    sb.append ("\\E");
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30490751_30490836_26_35
30490751_30490872_31_44
Title: "Java error Syntax error on token ""("" ; expected ub Java function" 
----------------------------------------

final int countWord (String codigo, File archivo) {
    int count = 0;
    Scanner scanner = new Scanner ("C:\\Users\\HernanEi\\Desktop\\contadoresInternet.txt");
    while (scanner.hasNextLine ()) {
        String nextToken = scanner.next ();
        if (nextToken.equalsIgnoreCase (codigo)) count ++;

    }
    return count;
}
----------------------------------------

final int countWord (String codigo, File archivo) {
    int count = 0;
    Scanner scanner = new Scanner ("C:\\Users\\HernanEi\\Desktop\\contadoresInternet.txt");
    while (scanner.hasNextLine ()) {
        String nextToken = scanner.next ();
        if (nextToken.equalsIgnoreCase (codigo)) {
            count ++;
        }
    }
    return (count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30491614_30491806_1_17
30491614_30491854_1_15
Title: How to find the index of the Object(that has its own parameters) in arraylist with using indexOf method 
----------------------------------------

public int [] findSong (String title) {
    List < Integer > indexesList = new ArrayList < > ();
    for (Song song : songs) {
        if (song.getTitle ().equals (title)) indexesList.add (songs.indexOf (song));

    }
    if (indexesList.size () == 0) return new int [0];

    int [] indexes = new int [indexesList.size ()];
    for (int i = 0;
    i < indexes.length; i ++) {
        Integer integer = indexesList.get (i);
        if (integer != null) indexes [i] = integer.intValue ();
        else indexes [i] = - 1;

    }
    return indexes;
}
----------------------------------------

public int findSong (String title, List < Song > songs) {
    for (Song song : songs) {
        if (song == null || song.getTitle () == null) {
            continue;
        }
        if (song.getTitle ().equals (title)) {
            int index = songs.indexOf (song);
            System.out.println (index);
            return index;
        }
    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30499776_30535000_13_41
30499776_30535000_1_11
Title: Recursion and/or getBackground() not working as intended 
----------------------------------------

private boolean findWord (String word, int row, int col, JButton [] [] buttons) {
    if (word.equals ("")) {
        return true;
    }
    if (row < 0 || row >= length || col < 0 || col >= length || ! (this.buttons [row] [col].getText ().equals (word.substring (0, 1))) || buttons [row] [col].getBackground ().equals (orange)) {
        return false;
    }
    String rest = word.substring (1, word.length ());
    boolean letter = findWord (rest, row - 1, col - 1, buttons) || findWord (rest, row - 1, col, buttons) || findWord (rest, row - 1, col + 1, buttons) || findWord (rest, row, col - 1, buttons) || findWord (rest, row, col + 1, buttons) || findWord (rest, row + 1, col - 1, buttons) || findWord (rest, row + 1, col, buttons) || findWord (rest, row + 1, col + 1, buttons);
    if (! letter) {
        this.buttons [row] [col].setBackground (white);
    }
    return letter;
}
----------------------------------------

public boolean findWord (String word) {
    clearButtons ();
    for (int row = 0;
    row < length; row ++) {
        for (int col = 0;
        col < length; col ++) {
            if (findWord (word, row, col, buttons)) {
                return true;
            }
        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30500016_30500110_3_12
30500016_30500143_3_14
Title: My program is not printing the string without 'g' and/or 'n'. Why is it so? 
----------------------------------------

public static void main (String y) {
    int l = y.length ();
    for (int i = 0;
    i <= l - 1; i ++) {
        if (y.charAt (i) != 'g' && y.charAt (i) != 'n') System.out.print (y.charAt (i));
        else continue;

    }
}
----------------------------------------

public static void main (String y) {
    int l = y.length ();
    for (int i = 0;
    i <= l - 1; i ++) {
        if (y.charAt (i) == 'g' || y.charAt (i) == 'n') {
            continue;
        } else {
            System.out.print (y.charAt (i));
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30521906_30521978_4_14
30521906_30522078_4_16
Title: Count of a particular string in given line using regex java 
----------------------------------------

public static void main (String [] args) {
    String hello = "HelloxyzxyzxyzHello";
    Pattern pattern = Pattern.compile ("xyz");
    Matcher matcher = pattern.matcher (hello);
    int count = 0;
    while (matcher.find ()) count ++;

    System.out.println (count);
}
----------------------------------------

public static void main (String [] args) {
    String hello = "HelloxyzxyzxyzHello";
    Pattern pattern = Pattern.compile ("(?:Hello|(?<!^)\\G)(?:(?!Hello).)*?(xyz)(?=.*?Hello)");
    Matcher matcher = pattern.matcher (hello);
    int count = 0;
    while (matcher.find ()) {
        if (matcher.group (1)) {
            count ++;
        }
    }
    System.out.println (count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3052345_3054209_14_58
3052345_3054263_31_43
Title: question on reverse array 
----------------------------------------

public static void main (String...args) {
    if (args.length == 0 || "xor".equals (args [0])) runTest ("xor", new Runnable () {
        @Override
        public void run () {
            for (int i = 0, max = array.length / 2, j = array.length - 1;
            i < max; ++ i, -- j) {
                array [i] ^= array [j];
                array [j] ^= array [i];
                array [i] ^= array [j];
            }
        }}

    );
    else if ("tmp".equals (args [0])) runTest ("tmp", new Runnable () {
        @Override
        public void run () {
            for (int i = 0, max = array.length / 2, j = array.length - 1;
            i < max; ++ i, -- j) {
                int tmp = array [i];
                array [i] = array [j];
                array [j] = tmp;
            }
        }}

    );
    else if ("xor+tmp".equals (args [0])) runTest ("xor+tmp", new Runnable () {
        @Override
        public void run () {
            for (int i = 0, max = array.length / 2, j = array.length - 1;
            i < max; ++ i, -- j) {
                int a = array [i];
                int b = array [j];
                a ^= b;
                b ^= a;
                a ^= b;
                array [i] = a;
                array [j] = b;
            }
        }}

    );

}
----------------------------------------

public static void main (String [] args) {
    int a [] = new int [102400];
    for (int i = 0;
    i < a.length; i ++) {
        a [i] = i;
    }
    System.out.println (Arrays.toString (Arrays.copyOf (a, 10)) + "..." + Arrays.toString (Arrays.copyOfRange (a, a.length - 10, a.length)));
    swap1 (a);
    System.out.println (Arrays.toString (Arrays.copyOf (a, 10)) + "..." + Arrays.toString (Arrays.copyOfRange (a, a.length - 10, a.length)));
    swap2 (a);
    System.out.println (Arrays.toString (Arrays.copyOf (a, 10)) + "..." + Arrays.toString (Arrays.copyOfRange (a, a.length - 10, a.length)));
    swap1 (a);
    swap2 (a);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3052345_3054209_14_58
3052345_38590850_6_34
Title: question on reverse array 
----------------------------------------

public static void main (String...args) {
    if (args.length == 0 || "xor".equals (args [0])) runTest ("xor", new Runnable () {
        @Override
        public void run () {
            for (int i = 0, max = array.length / 2, j = array.length - 1;
            i < max; ++ i, -- j) {
                array [i] ^= array [j];
                array [j] ^= array [i];
                array [i] ^= array [j];
            }
        }}

    );
    else if ("tmp".equals (args [0])) runTest ("tmp", new Runnable () {
        @Override
        public void run () {
            for (int i = 0, max = array.length / 2, j = array.length - 1;
            i < max; ++ i, -- j) {
                int tmp = array [i];
                array [i] = array [j];
                array [j] = tmp;
            }
        }}

    );
    else if ("xor+tmp".equals (args [0])) runTest ("xor+tmp", new Runnable () {
        @Override
        public void run () {
            for (int i = 0, max = array.length / 2, j = array.length - 1;
            i < max; ++ i, -- j) {
                int a = array [i];
                int b = array [j];
                a ^= b;
                b ^= a;
                a ^= b;
                array [i] = a;
                array [j] = b;
            }
        }}

    );

}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.print ("Enter total number of elemets: ");
    int total = sc.nextInt ();
    int [] arr1 = new int [total];
    int [] arr2 = new int [total];
    System.out.print ("Enter elemets: ");
    for (int i = 0;
    i < total; i ++) {
        arr1 [i] = sc.nextInt ();
    }
    System.out.print ("Original Array: " + Arrays.toString (arr1));
    System.out.println ();
    for (int a = 0;
    a < total; a ++) {
        for (int j = total - a - 1;
        j >= 0; j --) {
            arr2 [a] = arr1 [j];
            break;
        }
    }
    System.out.print ("Reversed Array: " + Arrays.toString (arr2));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
3052345_3054263_31_43
3052345_38590850_6_34
Title: question on reverse array 
----------------------------------------

public static void main (String [] args) {
    int a [] = new int [102400];
    for (int i = 0;
    i < a.length; i ++) {
        a [i] = i;
    }
    System.out.println (Arrays.toString (Arrays.copyOf (a, 10)) + "..." + Arrays.toString (Arrays.copyOfRange (a, a.length - 10, a.length)));
    swap1 (a);
    System.out.println (Arrays.toString (Arrays.copyOf (a, 10)) + "..." + Arrays.toString (Arrays.copyOfRange (a, a.length - 10, a.length)));
    swap2 (a);
    System.out.println (Arrays.toString (Arrays.copyOf (a, 10)) + "..." + Arrays.toString (Arrays.copyOfRange (a, a.length - 10, a.length)));
    swap1 (a);
    swap2 (a);
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    System.out.print ("Enter total number of elemets: ");
    int total = sc.nextInt ();
    int [] arr1 = new int [total];
    int [] arr2 = new int [total];
    System.out.print ("Enter elemets: ");
    for (int i = 0;
    i < total; i ++) {
        arr1 [i] = sc.nextInt ();
    }
    System.out.print ("Original Array: " + Arrays.toString (arr1));
    System.out.println ();
    for (int a = 0;
    a < total; a ++) {
        for (int j = total - a - 1;
        j >= 0; j --) {
            arr2 [a] = arr1 [j];
            break;
        }
    }
    System.out.print ("Reversed Array: " + Arrays.toString (arr2));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
30526806_30526985_14_25
30526806_30528836_13_24
Title: Hindi font is not proper rendering on webview browser using javafx 
----------------------------------------

public void start (Stage primaryStage) {
    Browser browser = new Browser ();
    BrowserView browserView = new BrowserView (browser);
    StackPane pane = new StackPane ();
    pane.getChildren ().add (browserView);
    Scene scene = new Scene (pane, 700, 500);
    primaryStage.setScene (scene);
    primaryStage.show ();
    browser.loadURL ("http://www.google.com");
}
----------------------------------------

public void start (Stage stage) throws Exception {
    StackPane root = new StackPane ();
    WebView view = new WebView ();
    WebEngine engine = view.getEngine ();
    engine.load ("http://www.jagran.com/");
    root.getChildren ().add (view);
    Scene scene = new Scene (root, 800, 600);
    stage.setScene (scene);
    stage.show ();
}
----------------------------------------
