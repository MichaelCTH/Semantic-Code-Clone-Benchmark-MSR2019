$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_167_201
625420_846439_246_275
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        int soFar;
        int sum;
        final int fileSize;
        stream = new FileInputStream (file);
        fileSize = (int) file.length ();
        soFar = 0;
        do {
            soFar += stream.read (StaticData, soFar, fileSize - soFar);
        } while (soFar != fileSize);
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticData [i];
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_167_201
625420_846439_372_411
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        int soFar;
        int sum;
        final int fileSize;
        stream = new FileInputStream (file);
        fileSize = (int) file.length ();
        soFar = 0;
        do {
            soFar += stream.read (StaticData, soFar, fileSize - soFar);
        } while (soFar != fileSize);
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticData [i];
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        buffer = ByteBuffer.wrap (data);
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_210_238
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += stream.readByte ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_246_275
625420_846439_283_322
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int size;
        final int fileSize;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        fileSize = (int) file.length ();
        data = new byte [512];
        size = 0;
        sum = 0;
        do {
            size += stream.read (data);
            sum = 0;
            for (int i = 0;
            i < size; i ++) {
                sum += data [i];
            }
        } while (size != fileSize);
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_246_275
625420_846439_330_363
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final FileChannel channel;
        final MappedByteBuffer buffer;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        channel = stream.getChannel ();
        buffer = channel.map (MapMode.READ_ONLY, 0, file.length ());
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_246_275
625420_846439_372_411
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        buffer = ByteBuffer.wrap (data);
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_246_275
625420_846439_420_459
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocate ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_246_275
625420_846439_468_507
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocateDirect ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_246_275
625420_846439_516_554
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticBuffer.clear ();
        StaticBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticBuffer);
        StaticBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_246_275
625420_846439_563_601
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    DataInputStream stream;
    stream = null;
    try {
        final byte [] data;
        int sum;
        stream = new DataInputStream (new BufferedInputStream (new FileInputStream (file)));
        data = new byte [(int) file.length ()];
        stream.readFully (data);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticDirectBuffer.clear ();
        StaticDirectBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticDirectBuffer);
        StaticDirectBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticDirectBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_330_363
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final FileChannel channel;
        final MappedByteBuffer buffer;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        channel = stream.getChannel ();
        buffer = channel.map (MapMode.READ_ONLY, 0, file.length ());
        fileSize = (int) file.length ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_372_411
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        data = new byte [(int) file.length ()];
        buffer = ByteBuffer.wrap (data);
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_420_459
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocate ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_468_507
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        final ByteBuffer buffer;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        buffer = ByteBuffer.allocateDirect ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (buffer);
        buffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += buffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_516_554
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticBuffer.clear ();
        StaticBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticBuffer);
        StaticBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625420_846439_563_601
625420_846439_78_112
Title: What is the fastest way to read a large number of small files into memory? 
----------------------------------------

protected long readFile (final File file) {
    FileInputStream stream;
    stream = null;
    try {
        final byte [] data;
        final FileChannel channel;
        int nRead = 0;
        final int fileSize;
        int sum;
        stream = new FileInputStream (file);
        StaticDirectBuffer.clear ();
        StaticDirectBuffer.limit ((int) file.length ());
        channel = stream.getChannel ();
        fileSize = (int) file.length ();
        nRead += channel.read (StaticDirectBuffer);
        StaticDirectBuffer.rewind ();
        sum = 0;
        for (int i = 0;
        i < fileSize; i ++) {
            sum += StaticDirectBuffer.get ();
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------

protected long readFile (final File file) {
    InputStream stream;
    stream = null;
    try {
        final byte [] data;
        int soFar;
        int sum;
        stream = new BufferedInputStream (new FileInputStream (file));
        data = new byte [(int) file.length ()];
        soFar = 0;
        do {
            soFar += stream.read (data, soFar, data.length - soFar);
        } while (soFar != data.length);
        sum = 0;
        for (final byte b : data) {
            sum += b;
        }
        return (sum);
    } catch (final IOException ex) {
        ex.printStackTrace ();
    } finally {
        if (stream != null) {
            try {
                stream.close ();
            } catch (final IOException ex) {
                ex.printStackTrace ();
            }
        }
    }
    return (0);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
625838_625846_7_22
625838_625949_5_15
Title: (Java) Specify number of bits (length) when converting binary number to string? 
----------------------------------------

public static void main (String [] args) {
    String value = "1010";
    BigInteger bi = new BigInteger (value, 2);
    System.out.println ("Output: " + bi.toString (2));
    bi = bi.add (bi);
    System.out.println ("Output: " + bi.toString (2));
    bi = bi.multiply (bi);
    System.out.println ("Output: " + bi.toString (2));
    System.out.println ("Padded Output: " + pad (bi.toString (2), bi.bitLength () + bi.bitLength () % 2));
}
----------------------------------------

public static void main (String [] args) {
    byte myByte = (byte) 0x00;
    int length = 2;
    System.out.println ("myByte: 0x" + String.valueOf (myByte));
    System.out.println ("bitString: " + stringifyByte (myByte, length));
    myByte = (byte) 0x0a;
    length = 6;
    System.out.println ("myByte: 0x" + String.valueOf (myByte));
    System.out.println ("bitString: " + stringifyByte (myByte, length));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6294033_6294099_1_14
6294033_6294111_1_11
Title: problem with a palindrome method 
----------------------------------------

public static boolean isPalindrome (String word) {
    int left = 0;
    int right = word.length () - 1;
    while (left < right) {
        if (word.charAt (left) != word.charAt (right)) {
            return false;
        }
        left ++;
        right --;
    }
    return true;
}
----------------------------------------

public static boolean isPalindrome (String input) {
    char [] array = input.toCharArray ();
    for (int i = 0;
    i < (array.length) / 2; i ++) {
        if (! (array [i] == array [array.length - 1 - i])) {
            return false;
        }
    }
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6295084_19892256_2_15
6295084_6296381_11_41
Title: Cut out image in shape of text 
----------------------------------------

public static void main (String [] args) {
    MarvinImage catImage = MarvinImageIO.loadImage ("./res/catImage.jpg");
    MarvinImage catText = MarvinImageIO.loadImage ("./res/catText.png");
    MarvinImagePlugin combine = MarvinPluginLoader.loadImagePlugin ("org.marvinproject.image.combine.combineByMask");
    combine.setAttribute ("combinationImage", catImage);
    combine.setAttribute ("colorMask", Color.black);
    combine.process (catText.clone (), catText);
    MarvinImageIO.saveImage (catText, "./res/catOut.jpg");
}
----------------------------------------

public static void main (String [] args) throws Exception {
    URL url = new URL ("http://i.stack.imgur.com/Nqf3H.jpg");
    BufferedImage originalImage = ImageIO.read (url);
    final BufferedImage textImage = new BufferedImage (originalImage.getWidth (), originalImage.getHeight (), BufferedImage.TYPE_INT_ARGB);
    Graphics2D g = textImage.createGraphics ();
    FontRenderContext frc = g.getFontRenderContext ();
    Font font = new Font (Font.SANS_SERIF, Font.BOLD, 250);
    GlyphVector gv = font.createGlyphVector (frc, "Cat");
    Rectangle2D box = gv.getVisualBounds ();
    int xOff = 25 + (int) - box.getX ();
    int yOff = 80 + (int) - box.getY ();
    Shape shape = gv.getOutline (xOff, yOff);
    g.setClip (shape);
    g.drawImage (originalImage, 0, 0, null);
    g.setClip (null);
    g.setStroke (new BasicStroke (2f));
    g.setColor (Color.BLACK);
    g.setRenderingHint (RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);
    g.draw (shape);
    g.dispose ();
    File file = new File ("cat-text.png");
    ImageIO.write (textImage, "png", file);
    Desktop.getDesktop ().open (file);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6296051_6296314_13_21
6296051_6296314_28_36
Title: How to remove a weakReference from a list? 
----------------------------------------

public boolean equals (Object other) {
    if (other instanceof HardReference) {
        return get () == ((HardReference) other).get ();
    }
    if (other instanceof Reference) {
        return get () == ((Reference) other).get ();
    }
    return get () == other;
}
----------------------------------------

public boolean equals (Object other) {
    if (other instanceof HardReference) {
        return get () == ((HardReference) other).get ();
    }
    if (other instanceof Reference) {
        return get () == ((Reference) other).get ();
    }
    return get () == other;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_22659416_7_16
63150_29135746_1_14
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

private static final String join (String delim, String...parts) {
    StringBuilder builder = new StringBuilder ();
    for (int i = 0;
    i < parts.length - 1; i ++) {
        builder.append (parts [i]).append (delim);
    }
    if (parts.length > 0) {
        builder.append (parts [parts.length - 1]);
    }
    return builder.toString ();
}
----------------------------------------

public static String join (String delimiter, String...values) {
    StringBuilder stringBuilder = new StringBuilder ();
    for (String value : values) {
        stringBuilder.append (value);
        stringBuilder.append (delimiter);
    }
    String result = stringBuilder.toString ();
    return result.isEmpty () ? result : result.substring (0, result.length () - 1);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_22659416_7_16
63150_3338199_1_22
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

private static final String join (String delim, String...parts) {
    StringBuilder builder = new StringBuilder ();
    for (int i = 0;
    i < parts.length - 1; i ++) {
        builder.append (parts [i]).append (delim);
    }
    if (parts.length > 0) {
        builder.append (parts [parts.length - 1]);
    }
    return builder.toString ();
}
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuilder sb = new StringBuilder ();
    int len = strings.length;
    if (len > 1) {
        len -= 1;
    } else {
        return strings [0];
    }
    for (int i = 0;
    i < len; i ++) {
        sb.append (strings [i]).append (del);
    }
    sb.append (strings [i]);
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_22659416_7_16
63150_63218_1_16
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

private static final String join (String delim, String...parts) {
    StringBuilder builder = new StringBuilder ();
    for (int i = 0;
    i < parts.length - 1; i ++) {
        builder.append (parts [i]).append (delim);
    }
    if (parts.length > 0) {
        builder.append (parts [parts.length - 1]);
    }
    return builder.toString ();
}
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuffer sb = new StringBuffer ();
    int len = strings.length;
    boolean appended = false;
    for (int i = 0;
    i < len; i ++) {
        if (appended) {
            sb.append (del);
        }
        sb.append ("" + strings [i]);
        appended = true;
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_22659416_7_16
63150_63274_1_16
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

private static final String join (String delim, String...parts) {
    StringBuilder builder = new StringBuilder ();
    for (int i = 0;
    i < parts.length - 1; i ++) {
        builder.append (parts [i]).append (delim);
    }
    if (parts.length > 0) {
        builder.append (parts [parts.length - 1]);
    }
    return builder.toString ();
}
----------------------------------------

public static String join (List < String > list, String delim) {
    StringBuilder sb = new StringBuilder ();
    String loopDelim = "";
    for (String s : list) {
        sb.append (loopDelim);
        sb.append (s);
        loopDelim = delim;
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_22659416_7_16
63150_63351_10_21
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

private static final String join (String delim, String...parts) {
    StringBuilder builder = new StringBuilder ();
    for (int i = 0;
    i < parts.length - 1; i ++) {
        builder.append (parts [i]).append (delim);
    }
    if (parts.length > 0) {
        builder.append (parts [parts.length - 1]);
    }
    return builder.toString ();
}
----------------------------------------

public static String join (String delimiter, Iterable < ? extends Object > objs) {
    if (objs.isEmpty ()) {
        return "";
    }
    Iterator < ? extends Object > iter = objs.iterator ();
    StringBuilder buffer = new StringBuilder ();
    buffer.append (iter.next ());
    while (iter.hasNext ()) {
        buffer.append (delimiter).append (iter.next ());
    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_29135746_1_14
63150_3338199_1_22
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String delimiter, String...values) {
    StringBuilder stringBuilder = new StringBuilder ();
    for (String value : values) {
        stringBuilder.append (value);
        stringBuilder.append (delimiter);
    }
    String result = stringBuilder.toString ();
    return result.isEmpty () ? result : result.substring (0, result.length () - 1);
}
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuilder sb = new StringBuilder ();
    int len = strings.length;
    if (len > 1) {
        len -= 1;
    } else {
        return strings [0];
    }
    for (int i = 0;
    i < len; i ++) {
        sb.append (strings [i]).append (del);
    }
    sb.append (strings [i]);
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_29135746_1_14
63150_63218_1_16
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String delimiter, String...values) {
    StringBuilder stringBuilder = new StringBuilder ();
    for (String value : values) {
        stringBuilder.append (value);
        stringBuilder.append (delimiter);
    }
    String result = stringBuilder.toString ();
    return result.isEmpty () ? result : result.substring (0, result.length () - 1);
}
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuffer sb = new StringBuffer ();
    int len = strings.length;
    boolean appended = false;
    for (int i = 0;
    i < len; i ++) {
        if (appended) {
            sb.append (del);
        }
        sb.append ("" + strings [i]);
        appended = true;
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_29135746_1_14
63150_63274_1_16
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String delimiter, String...values) {
    StringBuilder stringBuilder = new StringBuilder ();
    for (String value : values) {
        stringBuilder.append (value);
        stringBuilder.append (delimiter);
    }
    String result = stringBuilder.toString ();
    return result.isEmpty () ? result : result.substring (0, result.length () - 1);
}
----------------------------------------

public static String join (List < String > list, String delim) {
    StringBuilder sb = new StringBuilder ();
    String loopDelim = "";
    for (String s : list) {
        sb.append (loopDelim);
        sb.append (s);
        loopDelim = delim;
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_29135746_1_14
63150_63351_10_21
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String delimiter, String...values) {
    StringBuilder stringBuilder = new StringBuilder ();
    for (String value : values) {
        stringBuilder.append (value);
        stringBuilder.append (delimiter);
    }
    String result = stringBuilder.toString ();
    return result.isEmpty () ? result : result.substring (0, result.length () - 1);
}
----------------------------------------

public static String join (String delimiter, Iterable < ? extends Object > objs) {
    if (objs.isEmpty ()) {
        return "";
    }
    Iterator < ? extends Object > iter = objs.iterator ();
    StringBuilder buffer = new StringBuilder ();
    buffer.append (iter.next ());
    while (iter.hasNext ()) {
        buffer.append (delimiter).append (iter.next ());
    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_3338199_1_22
63150_63218_1_16
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuilder sb = new StringBuilder ();
    int len = strings.length;
    if (len > 1) {
        len -= 1;
    } else {
        return strings [0];
    }
    for (int i = 0;
    i < len; i ++) {
        sb.append (strings [i]).append (del);
    }
    sb.append (strings [i]);
    return sb.toString ();
}
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuffer sb = new StringBuffer ();
    int len = strings.length;
    boolean appended = false;
    for (int i = 0;
    i < len; i ++) {
        if (appended) {
            sb.append (del);
        }
        sb.append ("" + strings [i]);
        appended = true;
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_3338199_1_22
63150_63274_1_16
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuilder sb = new StringBuilder ();
    int len = strings.length;
    if (len > 1) {
        len -= 1;
    } else {
        return strings [0];
    }
    for (int i = 0;
    i < len; i ++) {
        sb.append (strings [i]).append (del);
    }
    sb.append (strings [i]);
    return sb.toString ();
}
----------------------------------------

public static String join (List < String > list, String delim) {
    StringBuilder sb = new StringBuilder ();
    String loopDelim = "";
    for (String s : list) {
        sb.append (loopDelim);
        sb.append (s);
        loopDelim = delim;
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_3338199_1_22
63150_63351_10_21
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuilder sb = new StringBuilder ();
    int len = strings.length;
    if (len > 1) {
        len -= 1;
    } else {
        return strings [0];
    }
    for (int i = 0;
    i < len; i ++) {
        sb.append (strings [i]).append (del);
    }
    sb.append (strings [i]);
    return sb.toString ();
}
----------------------------------------

public static String join (String delimiter, Iterable < ? extends Object > objs) {
    if (objs.isEmpty ()) {
        return "";
    }
    Iterator < ? extends Object > iter = objs.iterator ();
    StringBuilder buffer = new StringBuilder ();
    buffer.append (iter.next ());
    while (iter.hasNext ()) {
        buffer.append (delimiter).append (iter.next ());
    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_63218_1_16
63150_63274_1_16
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuffer sb = new StringBuffer ();
    int len = strings.length;
    boolean appended = false;
    for (int i = 0;
    i < len; i ++) {
        if (appended) {
            sb.append (del);
        }
        sb.append ("" + strings [i]);
        appended = true;
    }
    return sb.toString ();
}
----------------------------------------

public static String join (List < String > list, String delim) {
    StringBuilder sb = new StringBuilder ();
    String loopDelim = "";
    for (String s : list) {
        sb.append (loopDelim);
        sb.append (s);
        loopDelim = delim;
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_63218_1_16
63150_63351_10_21
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (String [] strings, char del) {
    StringBuffer sb = new StringBuffer ();
    int len = strings.length;
    boolean appended = false;
    for (int i = 0;
    i < len; i ++) {
        if (appended) {
            sb.append (del);
        }
        sb.append ("" + strings [i]);
        appended = true;
    }
    return sb.toString ();
}
----------------------------------------

public static String join (String delimiter, Iterable < ? extends Object > objs) {
    if (objs.isEmpty ()) {
        return "";
    }
    Iterator < ? extends Object > iter = objs.iterator ();
    StringBuilder buffer = new StringBuilder ();
    buffer.append (iter.next ());
    while (iter.hasNext ()) {
        buffer.append (delimiter).append (iter.next ());
    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_63274_1_16
63150_63351_10_21
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String join (List < String > list, String delim) {
    StringBuilder sb = new StringBuilder ();
    String loopDelim = "";
    for (String s : list) {
        sb.append (loopDelim);
        sb.append (s);
        loopDelim = delim;
    }
    return sb.toString ();
}
----------------------------------------

public static String join (String delimiter, Iterable < ? extends Object > objs) {
    if (objs.isEmpty ()) {
        return "";
    }
    Iterator < ? extends Object > iter = objs.iterator ();
    StringBuilder buffer = new StringBuilder ();
    buffer.append (iter.next ());
    while (iter.hasNext ()) {
        buffer.append (delimiter).append (iter.next ());
    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
63150_63282_1_12
63150_63324_1_11
Title: What's the best way to build a string of delimited items in Java? 
----------------------------------------

public static String appendWithDelimiter (String original, String addition, String delimiter) {
    if (original.equals ("")) {
        return addition;
    } else {
        StringBuilder sb = new StringBuilder (original.length () + addition.length () + delimiter.length ());
        sb.append (original);
        sb.append (delimiter);
        sb.append (addition);
        return sb.toString ();
    }
}
----------------------------------------

public StringBuffer appendWithDelimiter (StringBuffer original, String addition, String delimiter) {
    if (original == null) {
        StringBuffer buffer = new StringBuffer ();
        buffer.append (addition);
        return buffer;
    } else {
        buffer.append (delimiter);
        buffer.append (addition);
        return original;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6351082_14403399_25_49
6351082_6353250_16_24
Title: Using java annotation to inject logger dependency 
----------------------------------------

public Object postProcessBeforeInitialization (Object bean, String beanName) throws BeansException {
    List < Field > fields = Arrays.asList (bean.getClass ().getDeclaredFields ());
    for (Field field : fields) {
        if (Logger.class.isAssignableFrom (field.getType ()) && field.getAnnotation (InjectLogger.class) != null) {
            logger.debug ("Attempting to inject a SLF4J logger on bean: " + bean.getClass ());
            if (field != null && (field.getModifiers () & Modifier.STATIC) == 0) {
                field.setAccessible (true);
                try {
                    field.set (bean, LoggerFactory.getLogger (bean.getClass ()));
                    logger.debug ("Successfully injected a SLF4J logger on bean: " + bean.getClass ());
                } catch (IllegalArgumentException e) {
                    logger.warn ("Could not inject logger for class: " + bean.getClass (), e);
                } catch (IllegalAccessException e) {
                    logger.warn ("Could not inject logger for class: " + bean.getClass (), e);
                }
            }
        }
    }
    return bean;
}
----------------------------------------

public Object postProcessBeforeInitialization (Object bean, String beanName) throws BeansException {
    List < Field > fields = new Mirror ().on (bean.getClass ()).reflectAll ().fields ();
    for (Field field : fields) {
        if (Logger.class.isAssignableFrom (field.getType ()) && new Mirror ().on (field).reflect ().annotation (InjectLogger.class) != null) {
            new Mirror ().on (bean).set ().field (field).withValue (LoggerFactory.getLogger (bean.getClass ()));
        }
    }
    return bean;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6352627_6352673_1_12
6352627_6352683_1_12
Title: Java Recursive problem with distance? 
----------------------------------------

public static double totalDistance (int [] x, int [] y, int i) {
    double distance = 0;
    if (i == 1) {
        double cordX = x [i] - x [i - 1];
        double cordY = y [i] - y [i - 1];
        distance = Math.pow (cordX, 2) + Math.pow (cordY, 2);
        return distance;
    } else {
        return Math.round (Math.sqrt (distance) + totalDistance (x, y, i - 1));
    }
}
----------------------------------------

public static double totalDistance (int [] x, int [] y, int i) {
    double distance = 0;
    if (i == 1) {
        double cordX = x [i] - x [i - 1];
        double cordY = y [i] - y [i - 1];
        distance = Math.pow (cordX, 2) + Math.pow (cordY, 2);
        return distance;
    } else {
        return Math.round (Math.sqrt (distance) + totalDistance (x, y, i - 1));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6352627_6352673_1_12
6352627_6352815_1_19
Title: Java Recursive problem with distance? 
----------------------------------------

public static double totalDistance (int [] x, int [] y, int i) {
    double distance = 0;
    if (i == 1) {
        double cordX = x [i] - x [i - 1];
        double cordY = y [i] - y [i - 1];
        distance = Math.pow (cordX, 2) + Math.pow (cordY, 2);
        return distance;
    } else {
        return Math.round (Math.sqrt (distance) + totalDistance (x, y, i - 1));
    }
}
----------------------------------------

public static double totalDistance (int [] x, int [] y, int i) {
    double distance = 0;
    if (i == 0) {
        return 0;
    } else {
        double cordX = x [i] - x [i - 1];
        double cordY = y [i] - y [i - 1];
        distance = Math.pow (cordX, 2) + Math.pow (cordY, 2);
        distance = Math.round (Math.sqrt (distance));
        System.out.println (cordX + "  " + cordY + "   " + distance);
        return (distance + totalDistance (x, y, i - 1));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6352627_6352683_1_12
6352627_6352815_1_19
Title: Java Recursive problem with distance? 
----------------------------------------

public static double totalDistance (int [] x, int [] y, int i) {
    double distance = 0;
    if (i == 1) {
        double cordX = x [i] - x [i - 1];
        double cordY = y [i] - y [i - 1];
        distance = Math.pow (cordX, 2) + Math.pow (cordY, 2);
        return distance;
    } else {
        return Math.round (Math.sqrt (distance) + totalDistance (x, y, i - 1));
    }
}
----------------------------------------

public static double totalDistance (int [] x, int [] y, int i) {
    double distance = 0;
    if (i == 0) {
        return 0;
    } else {
        double cordX = x [i] - x [i - 1];
        double cordY = y [i] - y [i - 1];
        distance = Math.pow (cordX, 2) + Math.pow (cordY, 2);
        distance = Math.round (Math.sqrt (distance));
        System.out.println (cordX + "  " + cordY + "   " + distance);
        return (distance + totalDistance (x, y, i - 1));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6360801_17119440_29_60
6360801_6361091_1_17
Title: Is there a server agnostic way to implement BASIC Authentication? 
----------------------------------------

public void doFilter (ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {
    HttpServletRequest httpReq = (HttpServletRequest) req;
    HttpServletResponse httpRes = (HttpServletResponse) res;
    String authHeader = httpReq.getHeader (AUTHORIZATION_HEADER_NAME);
    if (authHeader == null) {
        this.requestAuthentication (httpRes);
        return;
    }
    authHeader = authHeader.replaceFirst (BASIC_AUTHENTICATION_REGEX, EMPTY_STRING);
    authHeader = new String (DECODER.decodeBuffer (authHeader));
    if (StringUtils.countMatches (authHeader, USERNAME_PASSWORD_SEPARATOR) != 1) {
        this.requestAuthentication (httpRes);
        return;
    }
    String [] creds = authHeader.split (USERNAME_PASSWORD_SEPARATOR);
    String username = creds [0];
    String password = creds [1];
    if (! authenticatedUser (username, password)) {
        this.requestAuthentication (httpRes);
        return;
    }
    chain.doFilter (req, res);
}
----------------------------------------

public void doFilter (ServletRequest req, ServletResponse res, FilterChain chain) {
    if (request instanceof HttpServletRequest) {
        HttpServletRequest request = (HttpServletRequest) req;
        String authHeader = Base64.decode (request.getHeader ("Authorization"));
        String creds [] = authHeader.split (":");
        String username = creds [0], password = creds [1];
        if (authorized) {
            chain.doFilter (req, res, chain);
        } else {
        }
    }
    doFilter (req, res, chain);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
637618_3868720_44_61
637618_3868720_69_78
Title: How to reschedule a task using a ScheduledExecutorService? 
----------------------------------------

public void run () {
    while (true) {
        IdentifiableRunnable r = null;
        System.out.println ("");
        System.out.println ("Supervisor will wait for a new runnable in order to resubmit it...");
        try {
            System.out.println ();
            r = deadRunnablesQueue.take ();
        } catch (InterruptedException e) {
        }
        if (r != null) {
            System.out.println ("Supervisor got runnable [" + r.getId () + "] to resubmit ");
            pool.submit (r);
        }
    }
}
----------------------------------------

public void run () {
    while (true) {
        System.out.println ("R1 " + (l ++));
        try {
            Thread.currentThread ().sleep (5000);
        } catch (InterruptedException e) {
            System.err.println ("R1 InterruptedException:");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
637618_3868720_44_61
637618_3868720_90_108
Title: How to reschedule a task using a ScheduledExecutorService? 
----------------------------------------

public void run () {
    while (true) {
        IdentifiableRunnable r = null;
        System.out.println ("");
        System.out.println ("Supervisor will wait for a new runnable in order to resubmit it...");
        try {
            System.out.println ();
            r = deadRunnablesQueue.take ();
        } catch (InterruptedException e) {
        }
        if (r != null) {
            System.out.println ("Supervisor got runnable [" + r.getId () + "] to resubmit ");
            pool.submit (r);
        }
    }
}
----------------------------------------

public void run () {
    try {
        while (true) {
            System.out.println ("R2 " + (l ++));
            try {
                Thread.currentThread ().sleep (5000);
            } catch (InterruptedException e) {
                System.err.println ("R2 InterruptedException:");
            }
            if (l == 3) {
                throw new RuntimeException ("R2 error.. Should I continue to process ? ");
            }
        }
    } catch (final Throwable t) {
        t.printStackTrace ();
        Test2.reSubmit (this);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
637618_3868720_44_61
637618_637632_1_27
Title: How to reschedule a task using a ScheduledExecutorService? 
----------------------------------------

public void run () {
    while (true) {
        IdentifiableRunnable r = null;
        System.out.println ("");
        System.out.println ("Supervisor will wait for a new runnable in order to resubmit it...");
        try {
            System.out.println ();
            r = deadRunnablesQueue.take ();
        } catch (InterruptedException e) {
        }
        if (r != null) {
            System.out.println ("Supervisor got runnable [" + r.getId () + "] to resubmit ");
            pool.submit (r);
        }
    }
}
----------------------------------------

public void run () {
    try {
    } catch (final IOException ex) {
    } catch (final RuntimeException ex) {
    } catch (final Exception ex) {
    } catch (final Error ex) {
    } catch (final Throwable ex) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
637618_3868720_69_78
637618_3868720_90_108
Title: How to reschedule a task using a ScheduledExecutorService? 
----------------------------------------

public void run () {
    while (true) {
        System.out.println ("R1 " + (l ++));
        try {
            Thread.currentThread ().sleep (5000);
        } catch (InterruptedException e) {
            System.err.println ("R1 InterruptedException:");
        }
    }
}
----------------------------------------

public void run () {
    try {
        while (true) {
            System.out.println ("R2 " + (l ++));
            try {
                Thread.currentThread ().sleep (5000);
            } catch (InterruptedException e) {
                System.err.println ("R2 InterruptedException:");
            }
            if (l == 3) {
                throw new RuntimeException ("R2 error.. Should I continue to process ? ");
            }
        }
    } catch (final Throwable t) {
        t.printStackTrace ();
        Test2.reSubmit (this);
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
637618_3868720_69_78
637618_637632_1_27
Title: How to reschedule a task using a ScheduledExecutorService? 
----------------------------------------

public void run () {
    while (true) {
        System.out.println ("R1 " + (l ++));
        try {
            Thread.currentThread ().sleep (5000);
        } catch (InterruptedException e) {
            System.err.println ("R1 InterruptedException:");
        }
    }
}
----------------------------------------

public void run () {
    try {
    } catch (final IOException ex) {
    } catch (final RuntimeException ex) {
    } catch (final Exception ex) {
    } catch (final Error ex) {
    } catch (final Throwable ex) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
637618_3868720_90_108
637618_637632_1_27
Title: How to reschedule a task using a ScheduledExecutorService? 
----------------------------------------

public void run () {
    try {
        while (true) {
            System.out.println ("R2 " + (l ++));
            try {
                Thread.currentThread ().sleep (5000);
            } catch (InterruptedException e) {
                System.err.println ("R2 InterruptedException:");
            }
            if (l == 3) {
                throw new RuntimeException ("R2 error.. Should I continue to process ? ");
            }
        }
    } catch (final Throwable t) {
        t.printStackTrace ();
        Test2.reSubmit (this);
    }
}
----------------------------------------

public void run () {
    try {
    } catch (final IOException ex) {
    } catch (final RuntimeException ex) {
    } catch (final Exception ex) {
    } catch (final Error ex) {
    } catch (final Throwable ex) {
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6391439_26024224_11_19
6391439_6393901_12_22
Title: Getting active window information in Java 
----------------------------------------

public static void main (String [] args) throws Exception {
    char [] buffer = new char [MAX_TITLE_LENGTH * 2];
    HWND hwnd = User32.INSTANCE.GetForegroundWindow ();
    User32.INSTANCE.GetWindowText (hwnd, buffer, MAX_TITLE_LENGTH);
    System.out.println ("Active window title: " + Native.toString (buffer));
    RECT rect = new RECT ();
    User32.INSTANCE.GetWindowRect (hwnd, rect);
    System.out.println ("rect = " + rect);
}
----------------------------------------

public static void main (String [] args) throws Exception {
    char [] buffer = new char [MAX_TITLE_LENGTH * 2];
    GetWindowTextW (GetForegroundWindow (), buffer, MAX_TITLE_LENGTH);
    System.out.println ("Active window title: " + Native.toString (buffer));
    PointerByReference pointer = new PointerByReference ();
    GetWindowThreadProcessId (GetForegroundWindow (), pointer);
    Pointer process = OpenProcess (PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, false, pointer.getValue ());
    GetModuleBaseNameW (process, null, buffer, MAX_TITLE_LENGTH);
    System.out.println ("Active window process: " + Native.toString (buffer));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6412314_6412675_39_50
6412314_6412675_59_69
Title: Simple GUI animation using JFrame 
----------------------------------------

public void actionPerformed (ActionEvent e) {
    float newAlpha = softButton1.getAlpha () + incrementer;
    if (newAlpha < 0) {
        newAlpha = 0;
        incrementer = - incrementer;
    } else if (newAlpha > 1f) {
        newAlpha = 1f;
        incrementer = - incrementer;
    }

    softButton1.setAlpha (newAlpha);
    softButton2.setAlpha (newAlpha);
}
----------------------------------------

public void actionPerformed (ActionEvent e) {
    try {
        UIManager.setLookAndFeel (laf [index].getClassName ());
        SwingUtilities.updateComponentTreeUI (frame);
        opaqueButton1.setText (laf [index].getClassName ());
        softButton1.setText (laf [index].getClassName ());
    } catch (Exception exc) {
        exc.printStackTrace ();
    }
    index = (index + 1) % laf.length;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6414601_6414666_21_30
6414601_6414666_33_55
Title: What's the best way to perform DFS on a very large tree? 
----------------------------------------

public static void method (int maxLevels) throws InterruptedException {
    ExecutorService service = Executors.newFixedThreadPool (Runtime.getRuntime ().availableProcessors ());
    try {
        int result = method (service, 0, maxLevels - 1, new int [maxLevels]).call ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
    service.shutdown ();
    service.awaitTermination (10, TimeUnit.MINUTES);
}
----------------------------------------

private static Callable < Integer > method (final ExecutorService service, final int level, final int maxLevel, final int [] options) {
    int choices = level % 2 == 0 ? 3 : 4;
    final List < Callable < Integer > > callables = new ArrayList < Callable < Integer > > (choices);
    for (int i = 0;
    i < choices; i ++) {
        options [level] = i;
        Callable < Integer > callable = level < TOP_LEVELS ? method (service, level + 1, maxLevel, options) : method1 (service, level + 1, maxLevel, options);
        callables.add (callable);
    }
    return new Callable < Integer > () {
        @Override
        public Integer call () throws Exception {
            Integer min = Integer.MAX_VALUE;
            for (Callable < Integer > result : callables) {
                Integer num = result.call ();
                if (min > num) min = num;

            }
            return min;
        }}

    ;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6414601_6414666_45_53
6414601_6414666_74_82
Title: What's the best way to perform DFS on a very large tree? 
----------------------------------------

public Integer call () throws Exception {
    Integer min = Integer.MAX_VALUE;
    for (Callable < Integer > result : callables) {
        Integer num = result.call ();
        if (min > num) min = num;

    }
    return min;
}
----------------------------------------

public Integer call () throws Exception {
    Integer min = Integer.MAX_VALUE;
    for (Future < Integer > result : futures) {
        Integer num = result.get ();
        if (min > num) min = num;

    }
    return min;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6416346_6416934_1_12
6416346_6417001_1_25
Title: Adding generics to ArrayUtils.toMap 
----------------------------------------

public static < K, V > Map < K, V > toMap (Map.Entry < K, V > [] array) {
    if (array == null) {
        return null;
    }
    final Map < K, V > map = new HashMap < K, V > ((int) (array.length * 1.5));
    for (int i = 0;
    i < array.length; i ++) {
        Map.Entry < K, V > entry = array [i];
        map.put (entry.getKey (), entry.getValue ());
    }
    return map;
}
----------------------------------------

public static < K, V > Map < K, V > toMap (Object [] array) {
    if (array == null) {
        return null;
    }
    final Map < K, V > map = new HashMap < K, V > ((int) (array.length * 1.5));
    for (int i = 0;
    i < array.length; i ++) {
        Object object = array [i];
        if (object instanceof Map.Entry) {
            Map.Entry < K, V > entry = (Map.Entry < K, V >) object;
            map.put (entry.getKey (), entry.getValue ());
        } else if (object instanceof Object []) {
            Object [] entry = (Object []) object;
            if (entry.length < 2) {
                throw new IllegalArgumentException ("Array element " + i + ", '" + object + "', has a length less than 2");
            }
            map.put ((K) entry [0], (V) entry [1]);
        } else {
            throw new IllegalArgumentException ("Array element " + i + ", '" + object + "', is neither of type Map.Entry nor an Array");
        }

    }
    return map;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6419597_6419654_1_15
6419597_6419773_4_12
Title: Convert this FileOutputStream Groovy method into pure Java? 
----------------------------------------

public void wget (String urlstring, File destFile) throws IOException {
    BufferedInputStream bis = new URL (urlstring).openStream ();
    BufferedOutputStream fos = new BufferedOutputStream (new FileOutputStream (destFile));
    try {
        byte [] buffer = new byte [8192];
        int cnt = 0;
        while ((cnt = bis.read (buffer, 0, 8192)) > - 1) {
            fos.write (buffer, 0, 8192);
        }
    } finally {
        bis.close ();
        fos.close ();
    }
}
----------------------------------------

public void wget (String urlstring, File destfile) throws Exception {
    URL url = new URL (urlstring);
    InputStream is = url.openStream ();
    OutputStream os = new FileOutputStream (destfile);
    for (int i = is.read ();
    i != - 1; i = is.read ()) os.write (i);

    is.close ();
    os.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6438061_24228016_3_14
6438061_27416807_5_13
Title: Can I scroll a ScrollView programmatically in Android? 
----------------------------------------

public void run () {
    connectionLog.setText (connectionLog.getText () + "\n" + s);
    final ScrollView sv = (ScrollView) connectLayout.findViewById (R.id.scrollView);
    sv.post (new Runnable () {
        public void run () {
            sv.fullScroll (sv.FOCUS_DOWN);
        }}

    );
}
----------------------------------------

public void run () {
    try {
        Thread.sleep (100);
    } catch (InterruptedException e) {
    }
    handler.post (new Runnable () {
        @Override
        public void run () {
            scrollView.fullScroll (View.FOCUS_DOWN);
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6449494_6449570_45_56
6449494_6449645_7_29
Title: References doesn' t getUpdated After passed to a class? 
----------------------------------------

public static void main (String [] args) {
    Student one = new Student ("Matt");
    StudentCollection students = new StudentCollection ();
    students.add (one);
    one.setName ("Kyle");
    for (Student stud : students) {
        System.out.println (stud);
    }
}
----------------------------------------

public static void main (String arg []) {
    Student one = new Student ();
    one.setName ("firstname");
    AllStudent all = new AllStudent ();
    all.add (one);
    one.setName ("secondname");
    Collection < Student > cs = all.getAll ();
    java.util.Iterator < Student > itr = cs.iterator ();
    while (itr.hasNext ()) {
        Student rgc = itr.next ();
        System.out.println (rgc.getName ());
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6470888_6471109_12_22
6470888_6471109_6_35
Title: Reentrant lock and deadlock with Java 
----------------------------------------

public void run () {
    System.out.println ("B Trying to lock...");
    l1.lock ();
    System.out.println ("B Must not print");
    try {
    } finally {
        System.out.println ("B Trying to unlock...");
        l1.unlock ();
        System.out.println ("B Unlocked...");
    }
}
----------------------------------------

public void run () {
    System.out.println ("A Trying to lock...");
    l1.lock ();
    System.out.println ("A Locked...");
    try {
        Thread t = new Thread (new Runnable () {
            public void run () {
                System.out.println ("B Trying to lock...");
                l1.lock ();
                System.out.println ("B Must not print");
                try {
                } finally {
                    System.out.println ("B Trying to unlock...");
                    l1.unlock ();
                    System.out.println ("B Unlocked...");
                }
            }}

        );
        t.start ();
        try {
            t.join ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }
    } finally {
        System.out.println ("A Trying to unlock...");
        l1.unlock ();
        System.out.println ("A Unlocked...");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6475320_6475350_9_33
6475320_6475412_37_45
Title: How to set the orientation of JTextArea from right to left (inside JOptionPane) 
----------------------------------------

public static void main (String args []) throws Exception {
    SwingUtilities.invokeLater (new Runnable () {
        public void run () {
            JTextArea textArea = new JTextArea (4, 20);
            JScrollPane scrollPane = new JScrollPane (textArea);
            JPanel panel = new JPanel ();
            panel.add (scrollPane);
            scrollPane.addAncestorListener (new AncestorListener () {
                public void ancestorAdded (AncestorEvent e) {
                    JScrollPane scrollPane = (JScrollPane) e.getComponent ();
                    scrollPane.applyComponentOrientation (ComponentOrientation.RIGHT_TO_LEFT);
                } public void ancestorMoved (AncestorEvent e) {
                } public void ancestorRemoved (AncestorEvent e) {
                }}

            );
            JOptionPane.showMessageDialog (null, panel);
        }}

    );
}
----------------------------------------

public static void main (String [] args) {
    EventQueue.invokeLater (new Runnable () {
        @Override
        public void run () {
            new RTLTextArea ().display ();
        }}

    );
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6476600_20774708_2_23
6476600_36399584_2_11
Title: Difference between String#equals and String#contentEquals methods 
----------------------------------------

public static void main (String [] args) {
    String str1 = "hello";
    String str2 = "hello";
    StringBuffer sb1 = new StringBuffer ("hello");
    StringBuffer sb2 = new StringBuffer ("world");
    boolean result1 = str1.equals (str2);
    System.out.println (" str1.equals(str2) - " + result1);
    boolean result2 = str1.equals (sb1);
    System.out.println (" str1.equals(sb1) - " + result2);
    boolean result3 = str1.contentEquals (sb1);
    System.out.println (" str1.contentEquals(sb1) - " + result3);
    boolean result4 = str1.contentEquals (sb2);
    System.out.println (" str1.contentEquals(sb2) - " + result4);
    boolean result5 = str1.contentEquals (str2);
    System.out.println (" str1.contentEquals(str2) - " + result5);
}
----------------------------------------

public static void main (String [] args) {
    String str1 = "Hello";
    String str2 = new String ("Hello");
    StringBuilder str3 = new StringBuilder (str1);
    System.out.println ("str1.equals(str2): " + (str1.equals (str2)));
    System.out.println ("str1.contentEquals(str2): " + (str1.contentEquals (str2)));
    System.out.println ("str1.equals(str3): " + (str1.equals (str3)));
    System.out.println ("str1.contentEquals(str3): " + (str1.contentEquals (str3)));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6480212_6483000_31_47
6480212_6490637_1_19
Title: Read in N Lines of an Input Stream and print in reverse order without using array or list type structure? 
----------------------------------------

public void reversePrint (BufferedReader reader, int lines) throws IOException {
    CountDownLatch initialLatch = new CountDownLatch (1);
    CountDownLatch triggerLatch = initialLatch;
    int count = 0;
    String line;
    while (count ++ < lines && (line = reader.readLine ()) != null) {
        Worker worker = new Worker (line, triggerLatch);
        triggerLatch = worker.getTriggerLatch ();
        new Thread (worker).start ();
    }
    triggerLatch.countDown ();
    try {
        initialLatch.await ();
    } catch (InterruptedException iex) {
    }
}
----------------------------------------

public void reversePrint (BufferedReader bufReader, int lines) throws IOException {
    BufferedReader resultBufferReader = null;
    {
        String line;
        StringBuilder sb = new StringBuilder ();
        int count = 0;
        while (count ++ < lines && (line = bufReader.readLine ()) != null) {
            sb.append ('\n');
            sb.append (new StringBuilder (line).reverse ());
        }
        resultBufferReader = new BufferedReader (new StringReader (sb.reverse ().toString ()));
    } {
        String line;
        while ((line = resultBufferReader.readLine ()) != null) {
            System.out.println (line);
        }
    }}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6484428_17761761_1_19
6484428_6484475_1_14
Title: Java read object input stream into arraylist? 
----------------------------------------

private static void Load () {
    try {
        ObjectInputStream objIn = new ObjectInputStream (new FileInputStream ("/file.bin"));
        boolean check = true;
        while (check) {
            try {
                object = objIn.readObject ();
                libraryFromDisk.add ((MediaLibrary) object);
            } catch (EOFException ex) {
                check = false;
            }
        }
        objIn.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------

private static void Load () {
    try {
        ObjectInputStream objIn = new ObjectInputStream (new FileInputStream ("/file.bin"));
        Object object = objIn.readObject ();
        while (object != null) {
            libraryFromDisk.add ((MediaLibrary) object);
            object = objIn.readObject ();
        }
        objIn.close ();
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6546193_32218955_15_25
6546193_6546442_3_13
Title: How to catch an Exception from a thread 
----------------------------------------

public static void main (String [] args) {
    FirstThread t1 = new FirstThread ();
    t1.setUncaughtExceptionHandler (new UncaughtExceptionHandler () {
        public void uncaughtException (Thread t, Throwable e) {
            System.out.printf ("Exception thrown by %s with id : %d", t.getName (), t.getId ());
            System.out.println ("\n" + e.getClass ());
        }}

    );
    t1.start ();
}
----------------------------------------

public static void main (String [] args) {
    Test t = new Test ();
    try {
        new Thread (t).start ();
    } catch (RuntimeException e) {
        System.out.println ("** RuntimeException from main");
    }
    System.out.println ("Main stoped");
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
655620_52406388_1_42
655620_655688_1_18
Title: How can I execute a PHP script from Java? 
----------------------------------------

public static void execPHP () {
    Process process = null;
    try {
        process = Runtime.getRuntime ().exec (new String [] {"php", "-r", "require '/var/www/html/demo/demo.php'; callToThisFunction();"});
        process.waitFor ();
        String line;
        BufferedReader errorReader = new BufferedReader (new InputStreamReader (process.getErrorStream ()));
        while ((line = errorReader.readLine ()) != null) {
            System.out.println (line);
        }
        errorReader.close ();
        BufferedReader outputReader = new BufferedReader (new InputStreamReader (process.getInputStream ()));
        while ((line = outputReader.readLine ()) != null) {
            System.out.println (line);
        }
        outputReader.close ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (InterruptedException e) {
        e.printStackTrace ();
    }
    OutputStream outputStream = process.getOutputStream ();
    PrintStream printStream = new PrintStream (outputStream);
    printStream.println ();
    printStream.flush ();
    printStream.close ();
}
----------------------------------------

public String execPHP (String scriptName, String param) {
    try {
        String line;
        StringBuilder output = new StringBuilder ();
        Process p = Runtime.getRuntime ().exec ("php " + scriptName + " " + param);
        BufferedReader input = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        while ((line = input.readLine ()) != null) {
            output.append (line);
        }
        input.close ();
    } catch (Exception err) {
        err.printStackTrace ();
    }
    return output.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6565862_37737720_5_37
6565862_38419180_9_30
Title: Adding the diagonal values in a 2d array 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int n = in.nextInt ();
    int leftStartDiagnol = 0;
    int rightStartDiagnol = n;
    int leftTotal = 0;
    int rightTotal = 0;
    int a [] [] = new int [n] [n];
    for (int a_i = 0;
    a_i < n; a_i ++) {
        for (int a_j = 0;
        a_j < n; a_j ++) {
            a [a_i] [a_j] = in.nextInt ();
        }
    }
    for (int a_i = 0;
    a_i < n; a_i ++) {
        boolean leftNotFound = true;
        boolean rightNotFound = true;
        rightStartDiagnol = -- rightStartDiagnol;
        for (int a_j = 0;
        a_j < n; a_j ++) {
            if (leftStartDiagnol == a_j && leftNotFound) {
                leftTotal = leftTotal + a [a_i] [a_j];
                leftNotFound = false;
            }
            if (rightStartDiagnol == a_j && rightNotFound) {
                rightTotal = rightTotal + a [a_i] [a_j];
                rightNotFound = false;
            }
        }
        leftStartDiagnol = ++ leftStartDiagnol;
    }
    int data = leftTotal - rightTotal;
    System.out.println (Math.abs (data));
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int n = in.nextInt ();
    int a [] [] = new int [n] [n];
    for (int a_i = 0;
    a_i < n; a_i ++) {
        for (int a_j = 0;
        a_j < n; a_j ++) {
            a [a_i] [a_j] = in.nextInt ();
        }
    }
    int l_sum = 0;
    for (int i = 0;
    i < n; i ++) {
        l_sum += a [i] [i];
    }
    int r_sum = 0;
    for (int j = 0;
    j < n; j ++) {
        r_sum += a [j] [n - 1 - j];
    }
    int sum = l_sum + r_sum;
    System.out.println (sum);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6565862_37737720_5_37
6565862_40530762_4_28
Title: Adding the diagonal values in a 2d array 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int n = in.nextInt ();
    int leftStartDiagnol = 0;
    int rightStartDiagnol = n;
    int leftTotal = 0;
    int rightTotal = 0;
    int a [] [] = new int [n] [n];
    for (int a_i = 0;
    a_i < n; a_i ++) {
        for (int a_j = 0;
        a_j < n; a_j ++) {
            a [a_i] [a_j] = in.nextInt ();
        }
    }
    for (int a_i = 0;
    a_i < n; a_i ++) {
        boolean leftNotFound = true;
        boolean rightNotFound = true;
        rightStartDiagnol = -- rightStartDiagnol;
        for (int a_j = 0;
        a_j < n; a_j ++) {
            if (leftStartDiagnol == a_j && leftNotFound) {
                leftTotal = leftTotal + a [a_i] [a_j];
                leftNotFound = false;
            }
            if (rightStartDiagnol == a_j && rightNotFound) {
                rightTotal = rightTotal + a [a_i] [a_j];
                rightNotFound = false;
            }
        }
        leftStartDiagnol = ++ leftStartDiagnol;
    }
    int data = leftTotal - rightTotal;
    System.out.println (Math.abs (data));
}
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    int n = Integer.parseInt (s.nextLine ());
    int [] [] a = new int [n] [n];
    for (int i = 0;
    i < n; i ++) {
        String str = s.nextLine ();
        String [] tempArray = str.split (" ");
        for (int j = 0;
        j < n; j ++) {
            a [i] [j] = Integer.parseInt (tempArray [j]);
        }
    }
    int x = 0;
    int y = 0;
    int sum = 0;
    for (int i = 0;
    i < n; i ++) {
        x += a [i] [i];
    }
    for (int p = 0;
    p < n; p ++) {
        int k = a.length - p - 1;
        y += a [p] [a.length - p - 1];
        k += - 1;
    }
    sum = x - y;
    System.out.println (Math.abs (sum));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6565862_38419180_9_30
6565862_40530762_4_28
Title: Adding the diagonal values in a 2d array 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int n = in.nextInt ();
    int a [] [] = new int [n] [n];
    for (int a_i = 0;
    a_i < n; a_i ++) {
        for (int a_j = 0;
        a_j < n; a_j ++) {
            a [a_i] [a_j] = in.nextInt ();
        }
    }
    int l_sum = 0;
    for (int i = 0;
    i < n; i ++) {
        l_sum += a [i] [i];
    }
    int r_sum = 0;
    for (int j = 0;
    j < n; j ++) {
        r_sum += a [j] [n - 1 - j];
    }
    int sum = l_sum + r_sum;
    System.out.println (sum);
}
----------------------------------------

public static void main (String [] args) {
    Scanner s = new Scanner (System.in);
    int n = Integer.parseInt (s.nextLine ());
    int [] [] a = new int [n] [n];
    for (int i = 0;
    i < n; i ++) {
        String str = s.nextLine ();
        String [] tempArray = str.split (" ");
        for (int j = 0;
        j < n; j ++) {
            a [i] [j] = Integer.parseInt (tempArray [j]);
        }
    }
    int x = 0;
    int y = 0;
    int sum = 0;
    for (int i = 0;
    i < n; i ++) {
        x += a [i] [i];
    }
    for (int p = 0;
    p < n; p ++) {
        int k = a.length - p - 1;
        y += a [p] [a.length - p - 1];
        k += - 1;
    }
    sum = x - y;
    System.out.println (Math.abs (sum));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6571955_6572025_1_22
6571955_6572041_1_19
Title: Interleave - in java doesn't properly work 
----------------------------------------

public static List < String > interleave (List < String > list1, List < String > list2) {
    List < String > result = new ArrayList < String > ();
    if (list1.size () < list2.size ()) {
        for (int i = 0;
        i < list1.size (); i ++) {
            result.add (list1.get (i));
            result.add (list2.get (i));
        }
        for (int i = list1.size ();
        i < list2.size (); i ++) {
            result.add (list2.get (i));
        }
    } else {
        for (int i = 0;
        i < list2.size (); i ++) {
            result.add (list1.get (i));
            result.add (list2.get (i));
        }
        for (int i = list2.size ();
        i < list1.size (); i ++) {
            result.add (list1.get (i));
        }
    }
    return result;
}
----------------------------------------

public static List < String > interleave (List < String > list1, List < String > list2) {
    List < String > result = new ArrayList < String > ();
    List < String > minList = list1.size () <= list2.size () ? list1 : list2;
    List < String > maxList = list1.size () <= list2.size () ? list2 : list1;
    for (int i = 0;
    i < minList.size (); i ++) {
        result.add (list1.get (i));
        result.add (list2.get (i));
    }
    for (int i = minList.size ();
    i < maxList.size (); i ++) {
        result.add (maxList.get (i));
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6571955_6572025_1_22
6571955_6572066_1_16
Title: Interleave - in java doesn't properly work 
----------------------------------------

public static List < String > interleave (List < String > list1, List < String > list2) {
    List < String > result = new ArrayList < String > ();
    if (list1.size () < list2.size ()) {
        for (int i = 0;
        i < list1.size (); i ++) {
            result.add (list1.get (i));
            result.add (list2.get (i));
        }
        for (int i = list1.size ();
        i < list2.size (); i ++) {
            result.add (list2.get (i));
        }
    } else {
        for (int i = 0;
        i < list2.size (); i ++) {
            result.add (list1.get (i));
            result.add (list2.get (i));
        }
        for (int i = list2.size ();
        i < list1.size (); i ++) {
            result.add (list1.get (i));
        }
    }
    return result;
}
----------------------------------------

public static List < String > interleave (List < String > list1, List < String > list2) {
    List < String > result = new ArrayList < String > ();
    int common = Math.min (list1.size (), list2.size ());
    for (int i = 0;
    i < common; i ++) {
        result.add (list1.get (i));
        result.add (list2.get (i));
    }
    for (int i = common;
    i < list1.size (); i ++) {
        result.add (list1.get (i));
    }
    for (int i = common;
    i < list2.size (); i ++) {
        result.add (list2.get (i));
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6571955_6572041_1_19
6571955_6572066_1_16
Title: Interleave - in java doesn't properly work 
----------------------------------------

public static List < String > interleave (List < String > list1, List < String > list2) {
    List < String > result = new ArrayList < String > ();
    List < String > minList = list1.size () <= list2.size () ? list1 : list2;
    List < String > maxList = list1.size () <= list2.size () ? list2 : list1;
    for (int i = 0;
    i < minList.size (); i ++) {
        result.add (list1.get (i));
        result.add (list2.get (i));
    }
    for (int i = minList.size ();
    i < maxList.size (); i ++) {
        result.add (maxList.get (i));
    }
    return result;
}
----------------------------------------

public static List < String > interleave (List < String > list1, List < String > list2) {
    List < String > result = new ArrayList < String > ();
    int common = Math.min (list1.size (), list2.size ());
    for (int i = 0;
    i < common; i ++) {
        result.add (list1.get (i));
        result.add (list2.get (i));
    }
    for (int i = common;
    i < list1.size (); i ++) {
        result.add (list1.get (i));
    }
    for (int i = common;
    i < list2.size (); i ++) {
        result.add (list2.get (i));
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6574218_42266712_37_54
6574218_6574368_35_56
Title: How can I get a specific thread to be the next one to enter a synchronized block? 
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    ThreadSequenceTest threadSequenceTest = new ThreadSequenceTest ();
    Thread t1 = new Thread (threadSequenceTest);
    t1.setName ("t1");
    Thread t2 = new Thread (threadSequenceTest);
    t2.setName ("t2");
    Thread t3 = new Thread (threadSequenceTest);
    t3.setName ("t3");
    Thread t4 = new Thread (threadSequenceTest);
    t4.setName ("t4");
    t1.start ();
    Thread.sleep (500);
    t2.start ();
    t3.start ();
    t4.start ();
}
----------------------------------------

public static void main (String [] args) {
    Lock l = new ReentrantLock ();
    Condition start = l.newCondition ();
    Condition t3AfterT1 = l.newCondition ();
    Condition allOthers = l.newCondition ();
    Thread t1 = new Thread (new SequencedRunnable ("t1", l, start, t3AfterT1));
    Thread t2 = new Thread (new SequencedRunnable ("t2", l, allOthers, allOthers));
    Thread t3 = new Thread (new SequencedRunnable ("t3", l, t3AfterT1, allOthers));
    Thread t4 = new Thread (new SequencedRunnable ("t4", l, allOthers, allOthers));
    t1.start ();
    t2.start ();
    t3.start ();
    t4.start ();
    l.lock ();
    try {
        start.signalAll ();
    } finally {
        l.unlock ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6574218_42266712_5_31
6574218_6574368_16_32
Title: How can I get a specific thread to be the next one to enter a synchronized block? 
----------------------------------------

public void run () {
    synchronized (o) {
        if (Thread.currentThread ().getName ().equals ("t1")) {
            doSomething ();
            t3Only = true;
        } else {
            if (t3Only) {
                if (Thread.currentThread ().getName ().equals ("t3")) {
                    doSomething ();
                    t3Only = false;
                    o.notifyAll ();
                } else {
                    try {
                        System.out.println ("going to sleep " + Thread.currentThread ().getName ());
                        o.wait ();
                        doSomething ();
                    } catch (InterruptedException e) {
                        e.printStackTrace ();
                    }
                }
            } else {
                doSomething ();
            }
        }
    }
}
----------------------------------------

public void run () {
    sync.lock ();
    try {
        if (toWaitFor != null) try {
            System.out.println (name + ": waiting for event");
            toWaitFor.await ();
        } catch (InterruptedException e) {
            e.printStackTrace ();
        }

        System.out.println (name + ": doing useful stuff...");
        if (toSignalOn != null) toSignalOn.signalAll ();

    } finally {
        sync.unlock ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6575114_41137749_50_77
6575114_41137749_86_96
Title: How do I determine whether a path is a local file or not 
----------------------------------------

private static String getProtocol (final String source) {
    assert source != null;
    String protocol = null;
    try {
        final URI uri = new URI (source);
        if (uri.isAbsolute ()) {
            protocol = uri.getScheme ();
        } else {
            final URL url = new URL (source);
            protocol = url.getProtocol ();
        }
    } catch (final Exception e) {
        if (source.startsWith ("//")) {
            throw new IllegalArgumentException ("Relative context: " + source);
        } else {
            final File file = new File (source);
            protocol = getProtocol (file);
        }
    }
    return protocol;
}
----------------------------------------

private static String getProtocol (final File file) {
    String result;
    try {
        result = file.toURI ().toURL ().getProtocol ();
    } catch (Exception e) {
        result = "unknown";
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6575299_6575431_5_39
6575299_6575432_3_16
Title: Fetch and store output from a subprocess in Java 
----------------------------------------

public static void main (String args []) {
    String s = null;
    try {
        Process p = Runtime.getRuntime ().exec ("ps -ef");
        BufferedReader stdInput = new BufferedReader (new InputStreamReader (p.getInputStream ()));
        BufferedReader stdError = new BufferedReader (new InputStreamReader (p.getErrorStream ()));
        System.out.println ("Here is the standard output of the command:\n");
        while ((s = stdInput.readLine ()) != null) {
            System.out.println (s);
        }
        System.out.println ("Here is the standard error of the command (if any):\n");
        while ((s = stdError.readLine ()) != null) {
            System.out.println (s);
        }
        System.exit (0);
    } catch (IOException e) {
        System.out.println ("exception happened - here's what I know: ");
        e.printStackTrace ();
        System.exit (- 1);
    }
}
----------------------------------------

public static void main (String args []) throws Exception {
    Runtime RT = Runtime.getRuntime ();
    String command = "javap java.lang.String";
    File file = new File ("write.txt");
    Writer output = new BufferedWriter (new FileWriter (file));
    BufferedReader br = new BufferedReader (new InputStreamReader (RT.exec (command).getInputStream ()));
    String temp = br.readLine ();
    while (temp != null) {
        output.write (temp);
        temp = br.readLine ();
    }
    output.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6586042_6588497_159_167
6586042_6588497_173_184
Title: Algorithm for generating a three dimensional random number space 
----------------------------------------

public int getNumber (Range r, byte [] input) {
    byte [] dig;
    synchronized (md) {
        md.reset ();
        md.update (input);
        dig = md.digest ();
    }
    return calculate (r, new BigInteger (1, dig));
}
----------------------------------------

public int getNumber (Range r, int...input) {
    byte [] dig;
    synchronized (md) {
        md.reset ();
        for (int i : input) {
            md.update (new byte [] {(byte) (i>> 24), (byte) (i>> 16), (byte) (i>> 8), (byte) (i>> 0)});
        }
        dig = md.digest ();
    }
    return calculate (r, new BigInteger (1, dig));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6587921_6588193_25_33
6587921_6588193_38_47
Title: How can i get two of the same ImageButton methods to work? 
----------------------------------------

public void onClick (View v) {
    if (isClicked == 0) {
        select.setImageResource (R.drawable.select_pressed);
        isClicked = 1;
    } else {
        select.setImageResource (R.drawable.select);
        isClicked = 0;
    }
}
----------------------------------------

public void onClick (View v) {
    if (isClicked1 == 0) {
        audio.setImageResource (R.drawable.audio_pressed);
        isClicked1 = 1;
    } else {
        audio.setImageResource (R.drawable.audio);
        isClicked1 = 0;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6589287_6589426_1_13
6589287_6609641_1_16
Title: What can we do with generics in Java to make them look better: 
----------------------------------------

< D extends Diagnostic < ? > > Map < String, List < D > > toMap (List < D > diagnostics) {
    Map < String, List < D > > result = new HashMap < > ();
    for (D d : diagnostics) {
        List < D > list = result.get (d.getCode ());
        if (list == null) result.put (d.getCode (), list = new ArrayList < > ());

        list.add (d);
    }
    return result;
}
----------------------------------------

private < T extends Diagnostic < ? extends JavaFileObject > > Map < String, List < T > > toMap (List < T > diagnostics) {
    Map < String, List < T > > result = new HashMap < String, List < T > > ();
    for (T d : diagnostics) {
        List < T > list = null;
        if (! result.containsKey (d.getCode ())) {
            list = new ArrayList < T > ();
            result.put (d.getCode (), list);
        } else {
            list = result.get (d.getCode ());
        }
        assert list != null;
        list.add (d);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6589287_6589426_1_13
6589287_6613159_1_15
Title: What can we do with generics in Java to make them look better: 
----------------------------------------

< D extends Diagnostic < ? > > Map < String, List < D > > toMap (List < D > diagnostics) {
    Map < String, List < D > > result = new HashMap < > ();
    for (D d : diagnostics) {
        List < D > list = result.get (d.getCode ());
        if (list == null) result.put (d.getCode (), list = new ArrayList < > ());

        list.add (d);
    }
    return result;
}
----------------------------------------

private Map < String, List < Diagnostic < ? extends JavaFileObject > > > toMap (List < Diagnostic < ? extends JavaFileObject > > diagnostics) {
    Map < String, List < Diagnostic < ? extends JavaFileObject > > > result = newHashMap ();
    for (Diagnostic < ? extends JavaFileObject > d : diagnostics) {
        List < Diagnostic < ? extends JavaFileObject > > list = null;
        if (! result.containsKey (d.getCode ())) {
            list = newArrayList ();
            result.put (d.getCode (), list);
        } else {
            list = result.get (d.getCode ());
        }
        assert list != null;
        list.add (d);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6589287_6589426_1_13
6589287_6613950_1_11
Title: What can we do with generics in Java to make them look better: 
----------------------------------------

< D extends Diagnostic < ? > > Map < String, List < D > > toMap (List < D > diagnostics) {
    Map < String, List < D > > result = new HashMap < > ();
    for (D d : diagnostics) {
        List < D > list = result.get (d.getCode ());
        if (list == null) result.put (d.getCode (), list = new ArrayList < > ());

        list.add (d);
    }
    return result;
}
----------------------------------------

private Map < String, DiagnosticList > toMap (DiagnosticList diagnostics) {
    Map < String, DiagnosticList > result = new HashMap < String, DiagnosticList > ();
    for (Diagnostic < ? extends JavaFileObject > d : diagnostics) {
        DiagnosticList list = result.get (d.getCode ());
        if (list == null) {
            result.put (d.getCode (), (list = new DiagnosticList ()));
        }
        list.add (d);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6589287_6609641_1_16
6589287_6613159_1_15
Title: What can we do with generics in Java to make them look better: 
----------------------------------------

private < T extends Diagnostic < ? extends JavaFileObject > > Map < String, List < T > > toMap (List < T > diagnostics) {
    Map < String, List < T > > result = new HashMap < String, List < T > > ();
    for (T d : diagnostics) {
        List < T > list = null;
        if (! result.containsKey (d.getCode ())) {
            list = new ArrayList < T > ();
            result.put (d.getCode (), list);
        } else {
            list = result.get (d.getCode ());
        }
        assert list != null;
        list.add (d);
    }
    return result;
}
----------------------------------------

private Map < String, List < Diagnostic < ? extends JavaFileObject > > > toMap (List < Diagnostic < ? extends JavaFileObject > > diagnostics) {
    Map < String, List < Diagnostic < ? extends JavaFileObject > > > result = newHashMap ();
    for (Diagnostic < ? extends JavaFileObject > d : diagnostics) {
        List < Diagnostic < ? extends JavaFileObject > > list = null;
        if (! result.containsKey (d.getCode ())) {
            list = newArrayList ();
            result.put (d.getCode (), list);
        } else {
            list = result.get (d.getCode ());
        }
        assert list != null;
        list.add (d);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6589287_6609641_1_16
6589287_6613950_1_11
Title: What can we do with generics in Java to make them look better: 
----------------------------------------

private < T extends Diagnostic < ? extends JavaFileObject > > Map < String, List < T > > toMap (List < T > diagnostics) {
    Map < String, List < T > > result = new HashMap < String, List < T > > ();
    for (T d : diagnostics) {
        List < T > list = null;
        if (! result.containsKey (d.getCode ())) {
            list = new ArrayList < T > ();
            result.put (d.getCode (), list);
        } else {
            list = result.get (d.getCode ());
        }
        assert list != null;
        list.add (d);
    }
    return result;
}
----------------------------------------

private Map < String, DiagnosticList > toMap (DiagnosticList diagnostics) {
    Map < String, DiagnosticList > result = new HashMap < String, DiagnosticList > ();
    for (Diagnostic < ? extends JavaFileObject > d : diagnostics) {
        DiagnosticList list = result.get (d.getCode ());
        if (list == null) {
            result.put (d.getCode (), (list = new DiagnosticList ()));
        }
        list.add (d);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6589287_6613159_1_15
6589287_6613950_1_11
Title: What can we do with generics in Java to make them look better: 
----------------------------------------

private Map < String, List < Diagnostic < ? extends JavaFileObject > > > toMap (List < Diagnostic < ? extends JavaFileObject > > diagnostics) {
    Map < String, List < Diagnostic < ? extends JavaFileObject > > > result = newHashMap ();
    for (Diagnostic < ? extends JavaFileObject > d : diagnostics) {
        List < Diagnostic < ? extends JavaFileObject > > list = null;
        if (! result.containsKey (d.getCode ())) {
            list = newArrayList ();
            result.put (d.getCode (), list);
        } else {
            list = result.get (d.getCode ());
        }
        assert list != null;
        list.add (d);
    }
    return result;
}
----------------------------------------

private Map < String, DiagnosticList > toMap (DiagnosticList diagnostics) {
    Map < String, DiagnosticList > result = new HashMap < String, DiagnosticList > ();
    for (Diagnostic < ? extends JavaFileObject > d : diagnostics) {
        DiagnosticList list = result.get (d.getCode ());
        if (list == null) {
            result.put (d.getCode (), (list = new DiagnosticList ()));
        }
        list.add (d);
    }
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6591665_10433069_1_38
6591665_7526414_1_26
Title: Merging two objects in Java 
----------------------------------------

public boolean merge (Object obj) {
    if (this.equals (obj)) {
        return false;
    }
    if (! obj.getClass ().isAssignableFrom (this.getClass ())) {
        return false;
    }
    Method [] methods = obj.getClass ().getMethods ();
    for (Method fromMethod : methods) {
        if (fromMethod.getDeclaringClass ().equals (obj.getClass ()) && (fromMethod.getName ().matches ("^get[A-Z].*$") || fromMethod.getName ().matches ("^is[A-Z].*$"))) {
            String fromName = fromMethod.getName ();
            String toName;
            if (fromName.matches ("^get[A-Z].*")) {
                toName = fromName.replace ("get", "set");
            } else {
                toName = fromName.replace ("is", "set");
            }
            try {
                Method toMetod = obj.getClass ().getMethod (toName, fromMethod.getReturnType ());
                Object value = fromMethod.invoke (this, (Object []) null);
                if (value != null) {
                    toMetod.invoke (obj, value);
                }
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
    return true;
}
----------------------------------------

public void merge (Object obj, Object update) {
    if (! obj.getClass ().isAssignableFrom (update.getClass ())) {
        return;
    }
    Method [] methods = obj.getClass ().getMethods ();
    for (Method fromMethod : methods) {
        if (fromMethod.getDeclaringClass ().equals (obj.getClass ()) && fromMethod.getName ().startsWith ("get")) {
            String fromName = fromMethod.getName ();
            String toName = fromName.replace ("get", "set");
            try {
                Method toMetod = obj.getClass ().getMethod (toName, fromMethod.getReturnType ());
                Object value = fromMethod.invoke (update, (Object []) null);
                if (value != null) {
                    toMetod.invoke (obj, value);
                }
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6596778_16706752_17_26
6596778_39527123_1_12
Title: ArrayList not using the overridden equals 
----------------------------------------

public boolean equals (Object in1) {
    System.out.println ("reached here");
    if (in1 == null) {
        return false;
    } else if (in1 instanceof InnerClass) {
        return ((InnerClass) this).testKey == null ? false : ((InnerClass) this).testKey.equals (((InnerClass) in1).testKey);
    } else {
        return false;
    }

}
----------------------------------------

@Override
public boolean equals (Object in) {
    System.out.println ("reached here");
    if (in == null) {
        return false;
    } else if (in instanceof InnerClass) {
        String inString = ((InnerClass) in).testKey;
        return testKey == null ? false : testKey.equals (inString);
    } else {
        return false;
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6601994_6602721_271_279
6601994_6602721_297_305
Title: JTable - Boolean Cell Type - Background 
----------------------------------------

public Component getTableCellEditorComponent (JTable table, Object value, boolean isSelected, int row, int column) {
    theSpinner.setValue (value);
    if (isSelected) {
        theSpinner.setBackground (table.getSelectionBackground ());
    } else {
        theSpinner.setBackground (table.getBackground ());
    }
    return theSpinner;
}
----------------------------------------

public Component getTableCellEditorComponent (JTable table, Object value, boolean isSelected, int row, int column) {
    theStatusPanel.setStatus ((Status) value);
    if (isSelected) {
        theStatusPanel.setBackground (table.getSelectionBackground ());
    } else {
        theStatusPanel.setBackground (table.getBackground ());
    }
    return theStatusPanel;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6629160_6630504_14_52
6629160_9128840_115_234
Title: SWT on Windows: scroll control at cursor (not focused one) 
----------------------------------------

public void handleEvent (Event event) {
    Control cursorControl = Display.getCurrent ().getCursorControl ();
    if (event.widget == cursorControl || cursorControl == null) {
        return;
    }
    event.doit = false;
    int msg = WM_VSCROLL;
    int style = cursorControl.getStyle ();
    if ((style & SWT.V_SCROLL) != 0 && cursorControl instanceof Scrollable) {
        ScrollBar verticalBar = ((Scrollable) cursorControl).getVerticalBar ();
        if (verticalBar != null && ((verticalBar.getMinimum () == 0 && verticalBar.getMaximum () == 0 && verticalBar.getSelection () == 0) || ! verticalBar.isEnabled () || ! verticalBar.isVisible ())) {
            msg = WM_HSCROLL;
        }
    } else if ((style & SWT.H_SCROLL) == 0) {
        return;
    } else {
        msg = WM_HSCROLL;
    }

    int count = event.count;
    int wParam = SB_LINEUP;
    if (event.count < 0) {
        count = - count;
        wParam = SB_LINEDOWN;
    }
    for (int i = 0;
    i < count; i ++) {
        OS.SendMessage (cursorControl.handle, msg, wParam, 0);
    }
}
----------------------------------------

public final void handleEvent (Event event) {
    Control cursorControl = event.display.getCursorControl ();
    if (event.widget == cursorControl || cursorControl == null) return;

    if (event.widget instanceof Control) {
        Control control = (Control) event.widget;
        Rectangle bounds = control.getBounds ();
        bounds.x = 0;
        bounds.y = 0;
        Point cursorPos = control.toControl (display.getCursorLocation ());
        if (bounds.contains (cursorPos)) return;

    }
    Control wheelControl = cursorControl;
    int scrollStyle = SWT.H_SCROLL | SWT.V_SCROLL;
    while (wheelControl != null && (wheelControl.getStyle () & scrollStyle) == 0 && wheelControl.getListeners (SWT.MouseWheel).length == 0) {
        wheelControl = wheelControl.getParent ();
    }
    if (wheelControl == null) {
        return;
    }
    int style = wheelControl.getStyle ();
    if ((style & scrollStyle) != 0 && wheelControl instanceof Scrollable) {
        int msg;
        if ((style & SWT.V_SCROLL) != 0) {
            ScrollBar vBar = ((Scrollable) wheelControl).getVerticalBar ();
            if (vBar == null || ((vBar.getMinimum () == 0 && vBar.getMaximum () == 0 && vBar.getSelection () == 0) || ! vBar.isEnabled () || ! vBar.isVisible ())) {
                msg = WM_HSCROLL;
            } else msg = WM_VSCROLL;

        } else {
            msg = WM_HSCROLL;
        }
        int count = event.count;
        int wParam = SB_LINEUP;
        if (event.count < 0) {
            count = - count;
            wParam = SB_LINEDOWN;
        }
        try {
            if (fSendEventMethod32 != null) {
                int handle = org.eclipse.swt.widgets.Control.class.getDeclaredField ("handle").getInt (wheelControl);
                for (int i = 0;
                i < count; i ++) fSendEventMethod32.invoke (null, handle, msg, wParam, 0);

            } else {
                long handle = org.eclipse.swt.widgets.Control.class.getDeclaredField ("handle").getLong (wheelControl);
                for (int i = 0;
                i < count; i ++) fSendEventMethod64.invoke (null, handle, msg, wParam, 0);

            }
        } catch (IllegalArgumentException e) {
            e.printStackTrace ();
        } catch (IllegalAccessException e) {
            e.printStackTrace ();
        } catch (InvocationTargetException e) {
            e.printStackTrace ();
        } catch (SecurityException e) {
            e.printStackTrace ();
        } catch (NoSuchFieldException e) {
            e.printStackTrace ();
        }
    } else {
        Point cursorPos = wheelControl.toControl (event.display.getCursorLocation ());
        event.x = cursorPos.x;
        event.y = cursorPos.y;
        event.widget = wheelControl;
        wheelControl.notifyListeners (event.type, event);
    }
    event.type = SWT.None;
    event.doit = false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6641977_6643326_10_42
6641977_6647996_93_163
Title: How to create a curve between 2 points in 2D and get back Points that makes that curve every d distance? 
----------------------------------------

private static ArrayList < Point2D > generateCurve (Point2D pFrom, Point2D pTo, float pRadius, float pMinDistance) {
    ArrayList < Point2D > pOutPut = new ArrayList < Point2D > ();
    double dist = pFrom.distance (pTo);
    double h = Math.sqrt (pRadius * pRadius - (dist * dist / 4.0));
    double angleStep = pMinDistance / pRadius;
    if (2 * pRadius <= dist) throw new Error ("Radius is too small");

    double x1 = pFrom.getX (), x2 = pFrom.getY ();
    double y1 = pTo.getX (), y2 = pTo.getY ();
    double m1 = (x1 + y1) / 2, m2 = (x2 + y2) / 2;
    double u1 = - (y2 - x2) / dist, u2 = (y1 - x1) / dist;
    double o1 = m1 + h * u1, o2 = m2 + h * u2;
    Point2D o = new Point2D.Double (o1, o2);
    double startAngle = GetAngle (pFrom, o, pRadius);
    double endAngle = GetAngle (pTo, o, pRadius);
    if (endAngle < startAngle) endAngle += 2 * Math.PI;

    for (double a = startAngle;
    a < endAngle; a += angleStep) {
        pOutPut.add (new Point2D.Double (o1 + pRadius * Math.cos (a), o2 + pRadius * Math.sin (a)));
    }
    pOutPut.add (pTo);
    return pOutPut;
}
----------------------------------------

private static List < PointF > generateCurve (PointF pFrom, PointF pTo, float pRadius, float pMinDistance, boolean shortest, boolean side) {
    List < PointF > pOutPut = new ArrayList < PointF > ();
    PointF mPoint = new PointF (pFrom.x + pTo.x, pFrom.y + pTo.y);
    mPoint.x /= 2.0f;
    mPoint.y /= 2.0f;
    System.out.println ("Middle Between From and To = " + mPoint);
    float xDiff = pTo.x - pFrom.x;
    float yDiff = pTo.y - pFrom.y;
    float distance = (float) Math.sqrt (xDiff * xDiff + yDiff * yDiff);
    System.out.println ("Distance between From and To = " + distance);
    if (pRadius * 2.0f < distance) {
        throw new IllegalArgumentException ("The radius is too small! The given points wont fall on the circle.");
    }
    float factor = (float) Math.sqrt ((pRadius * pRadius) / ((pTo.x - pFrom.x) * (pTo.x - pFrom.x) + (pTo.y - pFrom.y) * (pTo.y - pFrom.y)) - 0.25f);
    PointF circleMiddlePoint = new PointF (0, 0);
    if (side) {
        circleMiddlePoint.x = 0.5f * (pFrom.x + pTo.x) + factor * (pTo.y - pFrom.y);
        circleMiddlePoint.y = 0.5f * (pFrom.y + pTo.y) + factor * (pFrom.x - pTo.x);
    } else {
        circleMiddlePoint.x = 0.5f * (pFrom.x + pTo.x) - factor * (pTo.y - pFrom.y);
        circleMiddlePoint.y = 0.5f * (pFrom.y + pTo.y) - factor * (pFrom.x - pTo.x);
    }
    System.out.println ("Middle = " + circleMiddlePoint);
    float angle1 = (float) Math.atan2 (pFrom.y - circleMiddlePoint.y, pFrom.x - circleMiddlePoint.x);
    float angle2 = (float) Math.atan2 (pTo.y - circleMiddlePoint.y, pTo.x - circleMiddlePoint.x);
    float step = pMinDistance / pRadius;
    System.out.println ("Step = " + step);
    if (angle1 > angle2) {
        float temp = angle1;
        angle1 = angle2;
        angle2 = temp;
    }
    boolean flipped = false;
    if (! shortest) {
        if (angle2 - angle1 < Math.PI) {
            float temp = angle1;
            angle1 = angle2;
            angle2 = temp;
            angle2 += Math.PI * 2.0f;
            flipped = true;
        }
    }
    for (float f = angle1;
    f < angle2; f += step) {
        PointF p = new PointF ((float) Math.cos (f) * pRadius + circleMiddlePoint.x, (float) Math.sin (f) * pRadius + circleMiddlePoint.y);
        pOutPut.add (p);
    }
    if (flipped ^ side) {
        pOutPut.add (pFrom);
    } else {
        pOutPut.add (pTo);
    }
    return pOutPut;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
664389_19476769_58_94
664389_19476769_97_137
Title: Byte array of unknown length in java 
----------------------------------------

public static byte [] insert (final byte [] array, final int idx, final byte v) {
    Objects.requireNonNull (array);
    if (idx >= array.length) {
        return add (array, v);
    }
    final int index = calculateIndex (array, idx);
    byte [] newArray = new byte [array.length + 1];
    if (index != 0) {
        System.arraycopy (array, 0, newArray, 0, index);
    }
    boolean lastIndex = index == array.length - 1;
    int remainingIndex = array.length - index;
    if (lastIndex) {
        System.arraycopy (array, index, newArray, index + 1, remainingIndex);
    } else {
        System.arraycopy (array, index, newArray, index + 1, remainingIndex);
    }
    newArray [index] = v;
    return newArray;
}
----------------------------------------

public static byte [] insert (final byte [] array, final int fromIndex, final byte [] values) {
    Objects.requireNonNull (array);
    if (fromIndex >= array.length) {
        return add (array, values);
    }
    final int index = calculateIndex (array, fromIndex);
    byte [] newArray = new byte [array.length + values.length];
    if (index != 0) {
        System.arraycopy (array, 0, newArray, 0, index);
    }
    boolean lastIndex = index == array.length - 1;
    int toIndex = index + values.length;
    int remainingIndex = newArray.length - toIndex;
    if (lastIndex) {
        System.arraycopy (array, index, newArray, index + values.length, remainingIndex);
    } else {
        System.arraycopy (array, index, newArray, index + values.length, remainingIndex);
    }
    for (int i = index, j = 0;
    i < toIndex; i ++, j ++) {
        newArray [i] = values [j];
    }
    return newArray;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6645365_6645422_1_11
6645365_6650090_1_17
Title: Android ListView: Do Not Show TextView When Null 
----------------------------------------

@Override
public View getView (int position, View convertView, ViewGroup parent) {
    View v = super.getView (position, convertView, parent);
    if (list.get (position).get ("alert") == "") {
        v.findViewById (R.id.ListViewItem).setVisibility (View.GONE);
        v.findViewById (R.id.ListViewItemSub).setVisibility (View.GONE);
    }
    return convertView;
}
----------------------------------------

@Override
public View getView (int position, View convertView, ViewGroup parent) {
    View v = convertView;
    if (v == null) {
        LayoutInflater vi = (LayoutInflater) context.getSystemService (Context.LAYOUT_INFLATER_SERVICE);
        v = vi.inflate (R.layout.alarm_list_item, null);
    }
    if (list.get (position).get ("alert") == "") {
        v.findViewById (R.id.ListViewItemSub).setVisibility (View.GONE);
    }
    return convertView;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6645365_6645422_1_11
6645365_6650983_1_17
Title: Android ListView: Do Not Show TextView When Null 
----------------------------------------

@Override
public View getView (int position, View convertView, ViewGroup parent) {
    View v = super.getView (position, convertView, parent);
    if (list.get (position).get ("alert") == "") {
        v.findViewById (R.id.ListViewItem).setVisibility (View.GONE);
        v.findViewById (R.id.ListViewItemSub).setVisibility (View.GONE);
    }
    return convertView;
}
----------------------------------------

@Override
public View getView (int position, View convertView, ViewGroup parent) {
    View v = convertView;
    if (v == null) {
        LayoutInflater vi = (LayoutInflater) context.getSystemService (Context.LAYOUT_INFLATER_SERVICE);
        v = vi.inflate (R.layout.alarm_list_item, null);
    }
    if (list.get (position).get ("alert") == null) {
        v.findViewById (R.id.ListViewItemSub).setVisibility (View.GONE);
    }
    return super.getView (position, convertView, parent);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6660933_6661062_1_15
6660933_6661338_1_16
Title: Sorting algorithm which does not allow counting of elements 
----------------------------------------

public static void main (String [] args) {
    int [] array = {2, 0, 1, 2, 1, 2, 1, 0, 2, 0};
    int [] counts = new int [3];
    for (int i : array) counts [i] ++;

    for (int i = 0, start = 0;
    i < counts.length; start += counts [i ++]) Arrays.fill (array, start, start + counts [i], i);

    System.out.println (Arrays.toString (array));
}
----------------------------------------

public static void main (String [] args) throws Exception {
    Integer [] array = {2, 0, 1, 2, 1, 2, 1, 0, 2, 0};
    List < Integer > [] elements = new ArrayList [3];
    for (int i = 0;
    i < elements.length; i ++) elements [i] = new ArrayList < Integer > ();

    for (int i : array) elements [i].add (i);

    for (int i = 0, start = 0;
    i < elements.length; start += elements [i ++].size ()) System.arraycopy (elements [i].toArray (), 0, array, start, elements [i].size ());

    System.out.println (Arrays.toString (array));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6672597_6672632_7_25
6672597_6672635_1_14
Title: Help with Java Arrays: Saving to output file 
----------------------------------------

public char [] calculateGrade (int [] scores) {
    char [] grades = new char [scores.length];
    for (int r = 0;
    r < scores.length; r ++) {
        if (scores [r] > 90) grades [r] = 'A';
        else if (scores [r] > 80) grades [r] = 'B';
        else if (scores [r] > 70) grades [r] = 'C';
        else if (scores [r] > 60) grades [r] = 'D';
        else grades [r] = 'F';

    }
    return grades;
}
----------------------------------------

public void calculateGrade (int [] scores, char [] grades) {
    for (int r = 0;
    r < scores.length; r ++) {
        if (scores [r] > 90) grades [r] = 'A';
        else if (scores [r] > 80) grades [r] = 'B';
        else if (scores [r] > 70) grades [r] = 'C';
        else if (scores [r] > 60) grades [r] = 'D';
        else grades [r] = 'F';

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6677136_17413324_14_30
6677136_7160253_1_14
Title: Member variables vs setArguments in Fragments 
----------------------------------------

@Override
public void onCreate (Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    Bundle args = getArguments ();
    if (args != null) {
        record_id = args.getLong ("record_id");
        Log.d ("MyFragment", "found record_id of " + String.valueOf (record_id));
    }
    if (savedInstanceState != null) {
    }
}
----------------------------------------

@Override
protected void onCreate (final Bundle savedInstanceState) {
    super.onCreate (savedInstanceState);
    if (savedInstanceState == null) {
        final Bundle args = new Bundle (getIntent ().getExtras ());
        args.putInt (CoverImageFragment.BACKGROUND_RESOURCE, android.R.color.black);
        final Fragment fragment = CoverImageFragment.newInstance (args);
        getSupportFragmentManager ().beginTransaction ().add (android.R.id.content, fragment).commit ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6680157_29020219_19_36
6680157_36806739_38_53
Title: How to remove duplicate objects in a List<MyObject> without equals/hashcode? 
----------------------------------------

public boolean equals (Object obj) {
    if (obj instanceof Person) {
        Person pp = (Person) obj;
        boolean flag = (pp.name.equals (this.name) && pp.age == this.age);
        System.out.println (pp);
        System.out.println (pp.name + "    " + this.name);
        System.out.println (pp.age + "    " + this.age);
        System.out.println ("In equals : " + flag);
        return flag;
    } else {
        System.out.println ("In equals : false");
        return false;
    }
}
----------------------------------------

public boolean equals (Object obj) {
    Blog blog = (Blog) obj;
    if (title.equals (blog.title) && author.equals (blog.author) && url.equals (blog.url) && description.equals (blog.description)) {
        hashCode = blog.hashCode;
        return true;
    } else {
        hashCode = super.hashCode ();
        return false;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6684389_6693843_28_56
6684389_6693843_7_20
Title: "JEditorPane JScrollPane and accessibility" 
----------------------------------------

public AccessibleContext getAccessibleContext () {
    return new AccessibleContextWrapper (super.getAccessibleContext ()) {
        public Accessible getAccessibleParent () {
            Accessible parent = super.getAccessibleParent ();
            while (parent != null && (parent instanceof JScrollPane || parent instanceof JViewport)) {
                parent = parent.getAccessibleContext ().getAccessibleParent ();
            }
            return parent;
        } public int getAccessibleIndexInParent () {
            int res = super.getAccessibleIndexInParent ();
            Accessible parent = super.getAccessibleParent ();
            while (parent != null && (parent instanceof JScrollPane || parent instanceof JViewport)) {
                res = parent.getAccessibleContext ().getAccessibleIndexInParent ();
                parent = parent.getAccessibleContext ().getAccessibleParent ();
            }
            return res;
        } public void addPropertyChangeListener (PropertyChangeListener listener) {
        } public void removePropertyChangeListener (PropertyChangeListener listener) {
        }}

    ;
}
----------------------------------------

public AccessibleContext getAccessibleContext () {
    if (accessibleContext == null) {
        accessibleContext = new AccessibleContextWrapper (super.getAccessibleContext ()) {
            public Accessible getAccessibleChild (int i) {
                Accessible accessibleChild = super.getAccessibleChild (i);
                while (accessibleChild != null && (accessibleChild instanceof JScrollPane || accessibleChild instanceof JViewport)) {
                    accessibleChild = accessibleChild.getAccessibleContext ().getAccessibleChild (0);
                }
                return accessibleChild;
            }}

        ;
    }
    return accessibleContext;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6700266_6702420_28_39
6700266_6713898_1_10
Title: How to catch a CTRL + mouseWheel event with InputMap 
----------------------------------------

public void mouseWheelMoved (MouseWheelEvent e) {
    if (e.isControlDown ()) {
        if (e.getWheelRotation () < 0) {
            JComponent component = (JComponent) e.getComponent ();
            Action action = component.getActionMap ().get (SOME_ACTION);
            if (action != null) action.actionPerformed (null);

        } else {
            System.out.println ("scrolled down");
        }
    }
}
----------------------------------------

@Override
public void mouseWheelMoved (MouseWheelEvent e) {
    if (e.isControlDown ()) {
        if (e.getWheelRotation () < 0) {
            System.out.println ("Zoom-in when scrolling up");
        } else {
            System.out.println ("Zoom-out when scrolling down");
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6701948_6702000_1_12
6701948_6702175_1_34
Title: Efficient way to compare version strings in Java 
----------------------------------------

public static int compareVersions (String v1, String v2) {
    String [] components1 = v1.split ("\\.");
    String [] components2 = v2.split ("\\.");
    int length = Math.min (components1.length, components2.length);
    for (int i = 0;
    i < length; i ++) {
        int result = new Integer (components1 [i]).compareTo (Integer.parseInt (components2 [i]));
        if (result != 0) {
            return result;
        }
    }
    return Integer.compare (components1.length, components2.length);
}
----------------------------------------

int compareVersions (String str1, String str2) {
    if (str1.equals (str2)) return 0;

    String [] vals1 = str1.split ("\\.");
    String [] vals2 = str2.split ("\\.");
    int i = 0;
    while (i < vals1.length && i < val2.length && vals [i].equals (vals [i])) i ++;

    if (i < vals1.length && i < val2.length) return Integer.valueOf (vals1 [i]).compareTo (Integer.valueOf (vals2 [i]));

    if (i < vals1.length) {
        boolean allZeros = true;
        for (int j = i;
        allZeros & (j < vals1.length); j ++) allZeros &= (Integer.parseInt (vals1 [j]) == 0);

        return allZeros ? 0 : - 1;
    }
    if (i < vals2.length) {
        boolean allZeros = true;
        for (int j = i;
        allZeros & (j < vals2.length); j ++) allZeros &= (Integer.parseInt (vals2 [j]) == 0);

        return allZeros ? 0 : 1;
    }
    return 0;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6702534_6702633_3_24
6702534_6703282_5_23
Title: String fullname Split java 
----------------------------------------

public static void main (String [] args) {
    String name = "John King IV. Cena";
    int start = name.indexOf (' ');
    int end = name.lastIndexOf (' ');
    String firstName = "";
    String middleName = "";
    String lastName = "";
    if (start >= 0) {
        firstName = name.substring (0, start);
        if (end > start) middleName = name.substring (start + 1, end);

        lastName = name.substring (end + 1, name.length ());
    }
    System.out.println (firstName);
    System.out.println (middleName);
    System.out.println (lastName);
}
----------------------------------------

public static void main (String [] args) {
    String fullName = "John King IV. Cena";
    StringTokenizer stok = new StringTokenizer (fullName);
    String firstName = stok.nextToken ();
    StringBuilder middleName = new StringBuilder ();
    String lastName = stok.nextToken ();
    while (stok.hasMoreTokens ()) {
        middleName.append (lastName + " ");
        lastName = stok.nextToken ();
    }
    System.out.println (firstName);
    System.out.println (middleName.toString ().trim ());
    System.out.println (lastName);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6709913_16263683_139_164
6709913_6710017_41_56
Title: Random Number Generator: mainly how to stop repetition of numbers. Java 
----------------------------------------

public synchronized int next (int iRange) {
    int iResult = iRange;
    int iBase = 1;
    for (; iBase < iRange; iBase <<= 1) {
    }
    if ((iKey == null) || (iUniqueSeed >= iBase)) {
        reset (iBase);
    }
    int iBaseMask = iBase - 1;
    for (int i = 0;
    (i < iBase) && (iResult >= iRange); ++ i) {
        iUniqueSeed = (++ iUniqueSeed) % iBase;
        iResult = iUniqueSeed;
        for (int i1 = 0;
        i1 < iKey.length; ++ i1) {
            iResult = XOR (iResult, iKey [i1], iBaseMask);
            for (int i2 = iKey [i1] | iBase;
            i2 > 1; i2>>>= 1) {
                if ((i2 & 1) == 1) {
                    iResult = incdec (iResult, iSet, iBaseMask);
                } else {
                    iResult = rolror (iResult, iSet, iBaseMask);
                }
            }
        }
    }
    return iResult;
}
----------------------------------------

public int next () {
    if (isFinished ()) {
        return - 1;
    }
    while (true) {
        int r = random.nextInt (max);
        if (! used.get (r)) {
            used.set (r);
            return r;
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6712587_24631699_5_29
6712587_34460635_4_28
Title: How to count frequency of characters in a string? 
----------------------------------------

public static void main (String args []) throws Exception {
    HashSet hs = new HashSet ();
    String str = "hey how are you?";
    char arr [] = new char [str.length ()];
    for (int i = 0;
    i < str.length (); i ++) {
        arr [i] = str.charAt (i);
    }
    for (int j = 0;
    j < str.length (); j ++) {
        int c = 0;
        for (int k = 0;
        k < str.length (); k ++) {
            if (arr [j] == arr [k]) c ++;

        }
        hs.add (arr [j] + "=" + c + ",");
    }
    Iterator it = hs.iterator ();
    while (it.hasNext ()) {
        System.out.print (it.next ());
    }
}
----------------------------------------

public static void main (String a []) {
    Scanner sc = new Scanner (System.in);
    System.out.println ("Enter Your String :");
    String s1 = sc.nextLine ();
    int count, j = 1;
    char var = 'a';
    char ch [] = s1.toCharArray ();
    while (j <= 26) {
        count = 0;
        for (int i = 0;
        i < s1.length (); i ++) {
            if (ch [i] == var || ch [i] == var - 32) {
                count ++;
            }
        }
        if (count > 0) {
            System.out.println ("Frequency of " + var + " is " + count);
        }
        var ++;
        j ++;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
6712587_24631699_5_29
6712587_36262287_8_29
Title: How to count frequency of characters in a string? 
----------------------------------------

public static void main (String args []) throws Exception {
    HashSet hs = new HashSet ();
    String str = "hey how are you?";
    char arr [] = new char [str.length ()];
    for (int i = 0;
    i < str.length (); i ++) {
        arr [i] = str.charAt (i);
    }
    for (int j = 0;
    j < str.length (); j ++) {
        int c = 0;
        for (int k = 0;
        k < str.length (); k ++) {
            if (arr [j] == arr [k]) c ++;

        }
        hs.add (arr [j] + "=" + c + ",");
    }
    Iterator it = hs.iterator ();
    while (it.hasNext ()) {
        System.out.print (it.next ());
    }
}
----------------------------------------

public static void main (String arg []) {
    String input = "aaaajjjgggtttssvvkkllaaiiikk";
    int len = input.length ();
    Map < Character, Integer > zip = new HashMap < Character, Integer > ();
    for (int j = 0;
    len > j; j ++) {
        int count = 0;
        for (int i = 0;
        len > i; i ++) {
            if (input.charAt (j) == input.charAt (i)) {
                count ++;
            }
        }
        zip.put (input.charAt (j), count);
    }
    StringBuffer myValue = new StringBuffer ();
    String myMapKeyValue = "";
    for (Entry < Character, Integer > entry : zip.entrySet ()) {
        myMapKeyValue = Character.toString (entry.getKey ()).concat (Integer.toString (entry.getValue ()));
        myValue.append (myMapKeyValue);
    }
    System.out.println (myValue);
}
----------------------------------------
