$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53374153_53374245_1_11
53374153_53374538_1_11
Title: Convert uppercase string to lowercase using charAt 
----------------------------------------

private static String toLowerCase (String str) {
    StringBuffer lower = new StringBuffer ();
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isUpperCase (str.charAt (i))) {
            lower.append (Character.toLowerCase (str.charAt (i)));
        } else {
            lower.append (str.charAt (i));
        }
    }
    return lower.toString ();
}
----------------------------------------

private static String toLowerCase (String str) {
    String returning_Str = "";
    for (int i = 0;
    i < str.length (); i ++) {
        char test_char = str.charAt (i);
        if (Character.isUpperCase (test_char)) {
            test_char = Character.toLowerCase (test_char);
        }
        returning_Str += test_char;
    }
    return returning_Str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53374153_53374245_1_11
53374153_53374567_7_14
Title: Convert uppercase string to lowercase using charAt 
----------------------------------------

private static String toLowerCase (String str) {
    StringBuffer lower = new StringBuffer ();
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isUpperCase (str.charAt (i))) {
            lower.append (Character.toLowerCase (str.charAt (i)));
        } else {
            lower.append (str.charAt (i));
        }
    }
    return lower.toString ();
}
----------------------------------------

private static String toLowerCase (String str) {
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isUpperCase (str.charAt (i))) {
            str = new String (str.replace (str.charAt (i), Character.toLowerCase (str.charAt (i))));
        }
    }
    return str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53374153_53374245_1_11
53374153_53374976_7_19
Title: Convert uppercase string to lowercase using charAt 
----------------------------------------

private static String toLowerCase (String str) {
    StringBuffer lower = new StringBuffer ();
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isUpperCase (str.charAt (i))) {
            lower.append (Character.toLowerCase (str.charAt (i)));
        } else {
            lower.append (str.charAt (i));
        }
    }
    return lower.toString ();
}
----------------------------------------

private static StringBuffer toLowerCase (String str) {
    StringBuffer buf = new StringBuffer ();
    for (int i = 0;
    i < str.length (); i ++) {
        char c = str.charAt (i);
        if (Character.isUpperCase (str.charAt (i))) {
            c = Character.toLowerCase (str.charAt (i));
            buf.append (c);
        } else {
            buf.append (c);
        }
    }
    return buf;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53374153_53374538_1_11
53374153_53374567_7_14
Title: Convert uppercase string to lowercase using charAt 
----------------------------------------

private static String toLowerCase (String str) {
    String returning_Str = "";
    for (int i = 0;
    i < str.length (); i ++) {
        char test_char = str.charAt (i);
        if (Character.isUpperCase (test_char)) {
            test_char = Character.toLowerCase (test_char);
        }
        returning_Str += test_char;
    }
    return returning_Str;
}
----------------------------------------

private static String toLowerCase (String str) {
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isUpperCase (str.charAt (i))) {
            str = new String (str.replace (str.charAt (i), Character.toLowerCase (str.charAt (i))));
        }
    }
    return str;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53374153_53374538_1_11
53374153_53374976_7_19
Title: Convert uppercase string to lowercase using charAt 
----------------------------------------

private static String toLowerCase (String str) {
    String returning_Str = "";
    for (int i = 0;
    i < str.length (); i ++) {
        char test_char = str.charAt (i);
        if (Character.isUpperCase (test_char)) {
            test_char = Character.toLowerCase (test_char);
        }
        returning_Str += test_char;
    }
    return returning_Str;
}
----------------------------------------

private static StringBuffer toLowerCase (String str) {
    StringBuffer buf = new StringBuffer ();
    for (int i = 0;
    i < str.length (); i ++) {
        char c = str.charAt (i);
        if (Character.isUpperCase (str.charAt (i))) {
            c = Character.toLowerCase (str.charAt (i));
            buf.append (c);
        } else {
            buf.append (c);
        }
    }
    return buf;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53374153_53374567_7_14
53374153_53374976_7_19
Title: Convert uppercase string to lowercase using charAt 
----------------------------------------

private static String toLowerCase (String str) {
    for (int i = 0;
    i < str.length (); i ++) {
        if (Character.isUpperCase (str.charAt (i))) {
            str = new String (str.replace (str.charAt (i), Character.toLowerCase (str.charAt (i))));
        }
    }
    return str;
}
----------------------------------------

private static StringBuffer toLowerCase (String str) {
    StringBuffer buf = new StringBuffer ();
    for (int i = 0;
    i < str.length (); i ++) {
        char c = str.charAt (i);
        if (Character.isUpperCase (str.charAt (i))) {
            c = Character.toLowerCase (str.charAt (i));
            buf.append (c);
        } else {
            buf.append (c);
        }
    }
    return buf;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53379398_53379473_1_13
53379398_53379517_1_18
Title: Remove every 8th char from a string 
----------------------------------------

public static void main (String [] args) throws IOException {
    String str = "1100110001011011000000000000000000000000000000000000000000000000";
    StringBuilder newSb = new StringBuilder ();
    System.out.println (str + " " + str.length ());
    for (int i = 0;
    i < str.length (); i ++) {
        if (i == 0 || ((i + 1) % 8 != 0)) {
            newSb.append (str.charAt (i));
        }
    }
    System.out.println (newSb + " " + newSb.length ());
}
----------------------------------------

public static void main (String [] args) {
    String str = "1100110001011011000000000000000000000000000000000000000000000000";
    StringBuilder sb = new StringBuilder ();
    System.out.println (str + " " + str.length ());
    for (int i = 1;
    i <= str.length (); i ++) {
        if (i % 8 == 0) {
        } else {
            sb.append (str.charAt (i - 1));
        }
    }
    System.out.println (sb.toString () + " " + sb.length ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53379398_53379473_1_13
53379398_53379569_1_21
Title: Remove every 8th char from a string 
----------------------------------------

public static void main (String [] args) throws IOException {
    String str = "1100110001011011000000000000000000000000000000000000000000000000";
    StringBuilder newSb = new StringBuilder ();
    System.out.println (str + " " + str.length ());
    for (int i = 0;
    i < str.length (); i ++) {
        if (i == 0 || ((i + 1) % 8 != 0)) {
            newSb.append (str.charAt (i));
        }
    }
    System.out.println (newSb + " " + newSb.length ());
}
----------------------------------------

public static void main (String [] args) {
    String str = "1100110001011011000000000000000000000000000000000000000000000000";
    System.out.println (str + " " + str.length ());
    int idx = 0;
    StringBuilder sb = new StringBuilder ();
    for (int i = 0;
    i < str.length (); i ++) {
        idx ++;
        if (idx == 8) {
            idx = 0;
            continue;
        }
        sb.append (str.charAt (i));
    }
    System.out.println (sb.toString () + " " + sb.length ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53379398_53379517_1_18
53379398_53379569_1_21
Title: Remove every 8th char from a string 
----------------------------------------

public static void main (String [] args) {
    String str = "1100110001011011000000000000000000000000000000000000000000000000";
    StringBuilder sb = new StringBuilder ();
    System.out.println (str + " " + str.length ());
    for (int i = 1;
    i <= str.length (); i ++) {
        if (i % 8 == 0) {
        } else {
            sb.append (str.charAt (i - 1));
        }
    }
    System.out.println (sb.toString () + " " + sb.length ());
}
----------------------------------------

public static void main (String [] args) {
    String str = "1100110001011011000000000000000000000000000000000000000000000000";
    System.out.println (str + " " + str.length ());
    int idx = 0;
    StringBuilder sb = new StringBuilder ();
    for (int i = 0;
    i < str.length (); i ++) {
        idx ++;
        if (idx == 8) {
            idx = 0;
            continue;
        }
        sb.append (str.charAt (i));
    }
    System.out.println (sb.toString () + " " + sb.length ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53383866_53384488_1_12
53383866_53441530_8_26
Title: How to speed up first unique character lookup 
----------------------------------------

public int firstUniqChar (String s) {
    int count [] = new int [122 - 96];
    final char [] chars = s.toCharArray ();
    for (int i = 0;
    i < chars.length; i ++) {
        count [chars [i] - 97] ++;
    }
    for (int i = 0;
    i < chars.length; i ++) {
        if (count [chars [i] - 97] == 1) return i;

    }
    return - 1;
}
----------------------------------------

public int firstUniqChar (String s) {
    int len = s.length ();
    if ((len & 0xff) == len) {
        Arrays.fill (bCounter, 0x60, 0x80, (byte) - 1);
        for (int i = 0;
        i < len; i ++) bCounter [s.charAt (i)] ++;

        for (int i = 0;
        i < len; i ++) if (bCounter [s.charAt (i)] == 0) return i;

    } else {
        Arrays.fill (iCounter, 0x60, 0x80, - 1);
        for (int i = 0;
        i < len; i ++) iCounter [s.charAt (i)] ++;

        for (int i = 0;
        i < len; i ++) if (iCounter [s.charAt (i)] == 0) return i;

    }
    return - 1;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53390833_53411677_100_123
53390833_53411677_51_66
Title: Fetch HTML part in java 
----------------------------------------

public String next () {
    if (buffer.size () > 0) {
        return buffer.remove ();
    }
    if (! isValid) {
        return null;
    }
    StringBuilder sb = new StringBuilder ();
    Character currentChar = charPointer.next ();
    if (currentChar == null) {
        return null;
    }
    while (currentChar.equals ('\n') || currentChar.equals ('\r')) {
        currentChar = charPointer.next ();
        if (currentChar == null) {
            return null;
        }
    }
    while (currentChar != Character.valueOf ('\n') && currentChar != Character.valueOf ('\r')) {
        sb.append (currentChar);
        currentChar = charPointer.next ();
    }
    return sb.toString ();
}
----------------------------------------

public Character next () {
    if (! isValid) {
        return null;
    }
    char c;
    try {
        if (buffer.size () > 0) {
            return buffer.remove ();
        }
        c = (char) urlStream.read ();
    } catch (IOException ex) {
        markInvalid ();
        return null;
    }
    return (c != (char) - 1) ? c : null;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53390833_53411677_38_48
53390833_53411677_88_97
Title: Fetch HTML part in java 
----------------------------------------

public boolean hasNext () {
    char c;
    try {
        c = (char) urlStream.read ();
        buffer.add (c);
    } catch (IOException ex) {
        markInvalid ();
        return false;
    }
    return c != (char) - 1;
}
----------------------------------------

public boolean hasNext () {
    String value = next ();
    try {
        buffer.add (value);
    } catch (NullPointerException ex) {
        markInvalid ();
        return false;
    }
    return isValid;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53398835_53403827_26_45
53398835_53403885_1_21
Title: Stale element reference: element is not attached to the page document for Java-Selenium 
----------------------------------------

public void selectEachPropertyAndSeachJob () throws Throwable {
    WebDriverWait wait = new WebDriverWait (driver, 30);
    List < WebElement > dropdownoptions = driver.findElements (By.xpath ("//select[@id = 'property_id']//option"));
    for (int i = 0;
    i < dropdownoptions.size (); i ++) {
        String propertyDropdown = "//*[contains(@id,'property_id')]";
        String dateRange = "//*[contains(@name,'date_range')]";
        String last7days = "(//*[contains(text(),'Last 7 Days')])[2]";
        String searchJobs = "//*[contains(@name,'layout')]";
        Select dropdown = new Select (waitMethod (propertyDropdown));
        WebElement option = dropdown.getOptions ().get (i);
        wait.until (ExpectedConditions.not (ExpectedConditions.stalenessOf (option)));
        dropdown.selectByVisibleText (option.getText ());
        System.out.println (option.getText ());
        waitMethod (dateRange).click ();
        waitMethod (last7days).click ();
        waitMethod (searchJobs).click ();
        driver.navigate ().refresh ();
    }
}
----------------------------------------

public void selectEachPropertyAndSeachJob () {
    Select dropdown = new Select (driver.findElement (By.xpath ("//*[contains(@id,'property_id')]")));
    List < WebElement > optionsInPropertyDropdown = dropdown.getOptions ();
    for (int i = 0;
    i < optionsInPropertyDropdown.size (); i ++) {
        if (driver.findElement (By.xpath ("//*[contains(@id,'property_id')]")).isDisplayed ()) {
            dropdown.selectByVisibleText (optionsInPropertyDropdown.get (i).getText ());
            driver.findElement (By.xpath ("//*[contains(@name,'date_range')]")).click ();
            driver.findElement (By.xpath ("(//*[contains(text(),'Last 7 Days')])[2]")).click ();
            driver.findElement (By.xpath ("//*[contains(@name,'layout')]")).click ();
            dropdown = new Select (driver.findElement (By.xpath ("//*[contains(@id,'property_id')]")));
            optionsInPropertyDropdown = dropdown.getOptions ();
            System.out.println ("Option Search is " + optionsInPropertyDropdown.get (i).getText ());
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53401366_53402741_21_78
53401366_53404336_23_126
Title: how to generate button(picture) based on checkboxes selection in javafx 
----------------------------------------

public void start (Stage primaryStage) {
    VBox root = new VBox (5);
    root.setPadding (new Insets (10));
    root.setAlignment (Pos.CENTER);
    ObservableList < Car > carsList = FXCollections.observableArrayList ();
    FlowPane flowPane = new FlowPane ();
    flowPane.setHgap (10);
    flowPane.setVgap (5);
    flowPane.setAlignment (Pos.TOP_CENTER);
    carsList.addListener (new ListChangeListener < Car > () {
        @Override
        public void onChanged (Change < ? extends Car > c) {
            System.out.println (carsList.size ());
            c.next ();
            if (c.wasAdded ()) {
                Button button = new Button (c.getAddedSubList ().get (0).getName ());
                button.setGraphic (c.getAddedSubList ().get (0).getIcon ());
                button.setOnAction (event -> {
                });
                flowPane.getChildren ().add (button);
            }
        }}

    );
    Button button = new Button ("Add Car");
    button.setOnAction (event -> {
        carsList.add (new Car ("Car #" + (carsList.size () + 1), new ImageView ("icon.png")));
    });
    root.getChildren ().addAll (button, flowPane);
    primaryStage.setScene (new Scene (root, 550, 250));
    primaryStage.show ();
}
----------------------------------------

public void start (Stage primaryStage) {
    List < Car > cars = new ArrayList ();
    cars.add (new Car ("Honda", "2004"));
    cars.add (new Car ("Ford", "2005"));
    cars.add (new Car ("Ford", "2004"));
    cars.add (new Car ("Honda", "2005"));
    cars.add (new Car ("Toyota", "2004"));
    cars.add (new Car ("Cadillac", "2005"));
    ListView < Car > view = new ListView ();
    view.setCellFactory ((ListView < Car > param) -> {
        ListCell < Car > cell = new ListCell < Car > () {
            CarView carView = new CarView ();
            @Override
            protected void updateItem (Car item, boolean empty) {
                super.updateItem (item, empty);
                if (item != null) {
                    setText ("");
                    carView.setMake (item.getMake ());
                    carView.setModel (item.getModel ());
                    carView.setImageView (item.getUrl ());
                    setGraphic (carView);
                } else {
                    setText ("");
                    setGraphic (null);
                }
            }}

        ;
        return cell;
    });
    ObservableList < Car > data = FXCollections.observableArrayList (cars);
    FilteredList < Car > filteredList = new FilteredList (data);
    view.setItems (filteredList);
    HBox.setHgrow (view, Priority.ALWAYS);
    CheckBox checkBox = new CheckBox ("Honda");
    checkBox.selectedProperty ().addListener ((observable, oldValue, newValue) -> {
        if (newValue) {
            filteredList.setPredicate ((item) -> {
                return item.getMake ().equals ("Honda");
            });
        } else {
            filteredList.setPredicate ((item) -> {
                return true;
            });
        }
    });
    CheckBox checkBox2 = new CheckBox ("Ford");
    checkBox2.selectedProperty ().addListener ((observable, oldValue, newValue) -> {
        if (newValue) {
            filteredList.setPredicate ((item) -> {
                return item.getMake ().equals ("Ford");
            });
        } else {
            filteredList.setPredicate ((item) -> {
                return true;
            });
        }
    });
    CheckBox checkBox3 = new CheckBox ("2004");
    checkBox3.selectedProperty ().addListener ((observable, oldValue, newValue) -> {
        if (newValue) {
            filteredList.setPredicate ((item) -> {
                return item.getModel ().equals ("2004");
            });
        } else {
            filteredList.setPredicate ((item) -> {
                return true;
            });
        }
    });
    CheckBox checkBox4 = new CheckBox ("2005");
    checkBox4.selectedProperty ().addListener ((observable, oldValue, newValue) -> {
        if (newValue) {
            filteredList.setPredicate ((item) -> {
                return item.getModel ().equals ("2005");
            });
        } else {
            filteredList.setPredicate ((item) -> {
                return true;
            });
        }
    });
    VBox leftPanel = new VBox (checkBox, checkBox2, checkBox3, checkBox4);
    HBox root = new HBox (leftPanel, view);
    Scene scene = new Scene (root, 625, 500);
    primaryStage.setTitle ("Hello World!");
    primaryStage.setScene (scene);
    primaryStage.show ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53408044_53408300_19_28
53408044_53408300_30_39
Title: How to recognize the last page of viewpager and automatically redirect to first page when swiped 
----------------------------------------

public int getItemPosition (Object object) {
    int position;
    if (tList != null && tList.size () > 1) {
        position = super.getItemPosition (object) % tList.size ();
        return position;
    } else {
        return super.getItemPosition (object);
    }
}
----------------------------------------

public int getItemPosition (int index) {
    int position;
    if (tList != null && tList.size () > 1) {
        position = index % tList.size ();
        return position;
    } else {
        return index;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53408054_53409245_1_15
53408054_53409886_1_21
Title: "How to pass ""By"" and String for it in Selenium test method?" 
----------------------------------------

public static WebElement getElement (String string) {
    By by = null;
    String locator = properties.getProperty (string);
    switch (string) {
        case "class" :
            by = By.className (locator);
            break;
        case "id" :
            by = By.id (locator);
            break;
    }
    return driver.findElement (by);
}
----------------------------------------

private < T extends By > WebElement getElement (Class < T > byType, String prop) {
    if (byType.equals (ByClassName.class)) return getDriver ().findElement (By.className (prop));
    else if (byType.equals (ByCssSelector.class)) return getDriver ().findElement (By.cssSelector (prop));
    else if (byType.equals (ById.class)) return getDriver ().findElement (By.id (prop));
    else if (byType.equals (ByLinkText.class)) return getDriver ().findElement (By.linkText (prop));
    else if (byType.equals (ByName.class)) return getDriver ().findElement (By.name (prop));
    else if (byType.equals (ByPartialLinkText.class)) return getDriver ().findElement (By.partialLinkText (prop));
    else if (byType.equals (ByTagName.class)) return getDriver ().findElement (By.tagName (prop));
    else if (byType.equals (ByXPath.class)) return getDriver ().findElement (By.xpath (prop));
    else throw new UnsupportedOperationException ();

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53418610_53419046_1_20
53418610_53419057_26_42
Title: Binary Search tree won't add new nodes? 
----------------------------------------

private void add (int data, Node < Integer > node) {
    if (data < node.data) {
        if (node.left != null) {
            add (data, node.left);
        } else {
            node.left = new Node < > (data);
        }
    } else if (data > node.data) {
        if (node.right != null) {
            add (data, node.right);
        } else {
            node.right = new Node < > (data);
        }
        add (data, node.right);
    } else if (data == node.data) {
        System.out.println ("Duplicate. This value cannot be added to the tree.");
    }

}
----------------------------------------

Node add (Node root, int data) {
    if (root == null) {
        root = new Node (data);
        return root;
    }
    if (data < root.key) root.left = add (root.left, data);
    else if (data > root.key) root.right = add (root.right, data);
    else if (data == root.key) {
        System.out.println ("Duplicate. This value cannot be added to the tree.");
    }

    return root;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53420031_53420472_1_12
53420031_53438012_1_17
Title: I need help renaming an element in an array 
----------------------------------------

public int rename (String currentName, String newName) {
    int index = - 1;
    for (int i = 0;
    i < SheetsNames.length; i ++) {
        if (SheetsNames [i].equals (newName)) return - 1;

        if (SheetsNames [i].equals (currentName)) index = i;

    }
    if (index != - 1) SheetNames [index] = newName;

    return index;
}
----------------------------------------

public int rename (String currentName, String newName) {
    int currentNameindex = - 1;
    for (int i = 0;
    i < SheetsNames.length; i ++) {
        if (currentNameindex < 0) if (SheetsNames [i].equals (currentName)) currentNameindex = i;

        if (SheetsNames [i].equals (newName)) return - 1;

    }
    if (currentNameindex > 0) SheetsNames [currentNameindex] = newName;

    return currentNameindex;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53423002_53423095_2_17
53423002_53423234_1_27
Title: Sorting an array in ascending order in java 
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    int input = sc.nextInt ();
    int [] numbers = new int [input];
    for (int i = 0;
    i < numbers.length; i ++) {
        int a = sc.nextInt ();
        numbers [i] = a;
    }
    numbers = Main.bubbleSort (numbers);
    for (int i = 0;
    i < numbers.length; i ++) {
        System.out.println (numbers [i]);
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner sc = new Scanner (System.in);
    int input = sc.nextInt ();
    int [] numbers = new int [input];
    for (int i = 0;
    i < numbers.length; i ++) {
        int a = sc.nextInt ();
        numbers [i] = a;
    }
    sc.close ();
    Arrays.sort (numbers);
    int temp = numbers [0];
    int count = 1;
    for (int i = 1;
    i < numbers.length; i ++) {
        if (numbers [i] == temp) {
            count ++;
        } else {
            System.out.println (temp + " " + count);
            count = 1;
            temp = numbers [i];
        }
    }
    System.out.println (temp + " " + count);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53423132_53424597_1_10
53423132_53424825_1_27
Title: java regex to retrieve link from text 
----------------------------------------

public static void main (String args []) {
    String text = "Some content which contains link as &lt;A HREF=\"/relative-path/fruit.cgi?param1=abc&amp;param2=xyz\"&gt;URL Label&lt;/A&gt; and some text after it and another link &lt;A HREF=\"/relative-path/vegetables.cgi?param1=abc&amp;param2=xyz\"&gt;URL2 Label&lt;/A&gt; and some more text";
    text = StringEscapeUtils.unescapeHtml4 (text);
    Pattern p = Pattern.compile ("<a href=\"(.*?)\"><![CDATA[(.*?)</a>", Pattern.CASE_INSENSITIVE);
    Matcher m = p.matcher (text);
    while (m.find ()) {
        text = text.replace (m.group (0), cleanUrlPart (m.group (1), m.group (2)));
    }
    System.out.println (text);
}
----------------------------------------

public static void main (String [] args) throws URISyntaxException {
    String text = "Some content which contains link as &lt;A HREF=\"/relative-path/fruit.cgi?param1=abc&amp;param2=xyz\"&gt;URL Label&lt;/A&gt; and some text after it and another link &lt;A HREF=\"/relative-path/vegetables.cgi?param1=abc&amp;param2=xyz\"&gt;URL2 Label&lt;/A&gt; and some more text";
    text = StringEscapeUtils.unescapeHtml4 (text);
    System.out.println (text);
    System.out.println ("**************************************");
    Pattern patternTag = Pattern.compile ("<a([^>]+)>(.+?)</a>", Pattern.CASE_INSENSITIVE);
    Pattern patternLink = Pattern.compile ("href=\"(.*?)\"", Pattern.CASE_INSENSITIVE);
    Matcher matcherTag = patternTag.matcher (text);
    while (matcherTag.find ()) {
        String href = matcherTag.group (1);
        String linkText = matcherTag.group (2);
        System.out.println ("Href: " + href);
        System.out.println ("Label: " + linkText);
        Matcher matcherLink = patternLink.matcher (href);
        String finalText = null;
        while (matcherLink.find ()) {
            String link = matcherLink.group (1);
            System.out.println ("Link: " + link);
            finalText = getFinalText (link, linkText);
            break;
        }
        System.out.println ("***************************************");
    }
    System.out.println (text);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53424790_53424869_1_98
53424790_53424891_1_94
Title: How To Return Object of Array List at the end of if condition? 
----------------------------------------

private ArrayList < Team > getData () {
    Intent localIntent = getIntent ();
    localIntent.getIntExtra ("det", 0);
    ArrayList < Team > allTeams = new ArrayList < Team > ();
    if (localIntent.hasExtra ("beg")) {
        Team t1 = new Team ("Day 1: Chest, Back, Shoulders, Legs, Biceps, Triceps");
        t1.players.add ("Chest – Barbell Bench Press – 4 sets of 8 reps");
        t1.players.add ("Back – Lat-pulldowns – 4 sets of 10 reps");
        t1.players.add ("Shoulders – Seated Dumbbell Press – 4 sets of 10 reps");
        t1.players.add ("Legs – Leg Extensions – 4 sets of 10 reps");
        t1.players.add ("Biceps – Barbell Bbicep Curls – 3 sets of 10 reps");
        t1.players.add ("Triceps – Triceps Rope Pushdowns – 3 sets of 15 reps");
        Team t2 = new Team ("Day 2: Legs, Triceps, Biceps, Chest, Back, Shoulder");
        t2.players.add ("Legs – Leg Press Machine – 4 sets of 8 reps");
        t2.players.add ("Triceps – Overhead Bar Extensions – 3 sets of 20 reps");
        t2.players.add ("Biceps – EZ Bar Curls – 4 sets of 10 reps");
        t2.players.add ("Chest – Machine Chest Press – 4 sets of 10 reps");
        t2.players.add ("Back – T-Bar Row – 4 sets of 10 reps");
        t2.players.add ("Shoulders – Lateral Raises – 3 sets of 20 reps");
        Team t3 = new Team ("Day 3: Shoulders, Back, Chest, Legs, Triceps, Biceps");
        t3.players.add ("Shoulders – Upright Rows – 3 sets of 15 reps");
        t3.players.add ("Back – Close-Grip Pulldowns – 4 sets of 12 reps");
        t3.players.add ("Chest – Fly – 4 sets of 10 reps");
        t3.players.add ("Legs – Lunges – 3 sets of 10 reps per leg");
        t3.players.add ("Triceps – Skullcrushers – 3 sets of 15 reps");
        t3.players.add ("Biceps – Hammer Curls – 3 sets of 12 reps");
        allTeams.add (t1);
        allTeams.add (t2);
        allTeams.add (t3);
        return allTeams;
    } else if (localIntent.hasExtra ("inter")) {
        Team t1 = new Team ("Day 1: Chest, Shoulders and Triceps");
        t1.players.add ("Bench Press – 3 sets of 10, 10, 8 (adding weight) reps");
        t1.players.add ("Incline Dumbbell Bench Press – 3 sets of 10 reps");
        t1.players.add ("Chest Dip – 3 sets of MAX reps");
        t1.players.add ("Skullcrushers – 3 sets of 8-10 Reps");
        t1.players.add ("One Arm Dumbbell Extension – 3 sets of 10 reps");
        t1.players.add ("Tricep Extension – 3 sets of 10 reps");
        t1.players.add ("Barbell Front Raise – 4 sets of 12 reps");
        t1.players.add ("Dumbbell Lateral Raise – 4 sets of 15, 12, 8, 8 (adding weight) reps");
        Team t2 = new Team ("Day 2: Back and Biceps");
        t2.players.add ("Wide Grip Pull Up 3 sets of MAX reps");
        t2.players.add ("Lat Pull Down – 3 sets of 10 reps");
        t2.players.add ("Straight Arm Lat Pull Down – 3 sets of 10 reps");
        t2.players.add ("Standing Barbell Curl – 3 sets of 8-10 reps");
        t2.players.add ("Preacher Curl – 3 sets of 10 reps");
        t2.players.add ("Incline Dumbbell Curl – 3 sets of 10 reps");
        Team t3 = new Team ("Day 3: Legs");
        t3.players.add ("Squat – 4 sets of 10,10,8,8 reps");
        t3.players.add ("Dumbbell Lunge – 3 sets of 8 on each leg");
        t3.players.add ("Leg Press – 3 sets of 12 reps");
        t3.players.add ("Leg Curl – 3 sets of 15 reps");
        t3.players.add ("Leg Extension – 3 sets of 15 reps");
        t3.players.add ("Standing Calf Raise – 5 sets of 10,8,8,8,6 (heavy)reps");
        t3.players.add ("Seated Calf Raise – 5 sets of 15 (light) reps");
        Team t4 = new Team ("Day 4:  Shoulders, chest, and Triceps");
        t4.players.add ("Barbell Bench Press – 3 sets of 10, 10, 8 reps");
        t4.players.add ("Dumbbell Flys – 3 sets of 10 reps");
        t4.players.add ("Cable Crossovers – 3 sets of 10 reps");
        t4.players.add ("Close Grip Bench Press – 4 sets of 10, 10, 8, 6 reps");
        t4.players.add ("Lying Dumbbell Extension – 3 sets of 10 reps");
        t4.players.add ("Tricep Kickback – 3 sets of 10 reps");
        t4.players.add ("Seated Dumbbell Press – 4 sets of 10, 10, 8, 8 reps");
        t4.players.add ("One Arm Cable Lateral Raise – 3 sets of 12 reps");
        Team t5 = new Team ("Day 5: Back and Biceps");
        t5.players.add ("Seated Row – 4 sets of 10 reps");
        t5.players.add ("Bent Over Barbell Row – 3 sets of 10 reps");
        t5.players.add ("Bent Over Row – 3 sets of 12 reps");
        t5.players.add ("Smith Machine Upright Row – 3 sets of 8-10 reps");
        t5.players.add ("Cable Curl – 4 sets of 8-10 reps");
        t5.players.add ("Concentration Curl – 3 sets of 10 reps");
        t5.players.add ("Reverse Barbell Curl – 3 sets of 10 reps");
        allTeams.add (t1);
        allTeams.add (t2);
        allTeams.add (t3);
        allTeams.add (t4);
        allTeams.add (t5);
        return allTeams;
    }

    return allTeams;
}
----------------------------------------

private ArrayList < Team > getData () {
    Intent localIntent = getIntent ();
    localIntent.getIntExtra ("det", 0);
    ArrayList < Team > allTeams = new ArrayList < Team > ();
    if (localIntent.hasExtra ("beg")) {
        Team t1 = new Team ("Day 1: Chest, Back, Shoulders, Legs, Biceps, Triceps");
        t1.players.add ("Chest – Barbell Bench Press – 4 sets of 8 reps");
        t1.players.add ("Back – Lat-pulldowns – 4 sets of 10 reps");
        t1.players.add ("Shoulders – Seated Dumbbell Press – 4 sets of 10 reps");
        t1.players.add ("Legs – Leg Extensions – 4 sets of 10 reps");
        t1.players.add ("Biceps – Barbell Bbicep Curls – 3 sets of 10 reps");
        t1.players.add ("Triceps – Triceps Rope Pushdowns – 3 sets of 15 reps");
        Team t2 = new Team ("Day 2: Legs, Triceps, Biceps, Chest, Back, Shoulder");
        t2.players.add ("Legs – Leg Press Machine – 4 sets of 8 reps");
        t2.players.add ("Triceps – Overhead Bar Extensions – 3 sets of 20 reps");
        t2.players.add ("Biceps – EZ Bar Curls – 4 sets of 10 reps");
        t2.players.add ("Chest – Machine Chest Press – 4 sets of 10 reps");
        t2.players.add ("Back – T-Bar Row – 4 sets of 10 reps");
        t2.players.add ("Shoulders – Lateral Raises – 3 sets of 20 reps");
        Team t3 = new Team ("Day 3: Shoulders, Back, Chest, Legs, Triceps, Biceps");
        t3.players.add ("Shoulders – Upright Rows – 3 sets of 15 reps");
        t3.players.add ("Back – Close-Grip Pulldowns – 4 sets of 12 reps");
        t3.players.add ("Chest – Fly – 4 sets of 10 reps");
        t3.players.add ("Legs – Lunges – 3 sets of 10 reps per leg");
        t3.players.add ("Triceps – Skullcrushers – 3 sets of 15 reps");
        t3.players.add ("Biceps – Hammer Curls – 3 sets of 12 reps");
        allTeams.add (t1);
        allTeams.add (t2);
        allTeams.add (t3);
    } else if (localIntent.hasExtra ("inter")) {
        Team t1 = new Team ("Day 1: Chest, Shoulders and Triceps");
        t1.players.add ("Bench Press – 3 sets of 10, 10, 8 (adding weight) reps");
        t1.players.add ("Incline Dumbbell Bench Press – 3 sets of 10 reps");
        t1.players.add ("Chest Dip – 3 sets of MAX reps");
        t1.players.add ("Skullcrushers – 3 sets of 8-10 Reps");
        t1.players.add ("One Arm Dumbbell Extension – 3 sets of 10 reps");
        t1.players.add ("Tricep Extension – 3 sets of 10 reps");
        t1.players.add ("Barbell Front Raise – 4 sets of 12 reps");
        t1.players.add ("Dumbbell Lateral Raise – 4 sets of 15, 12, 8, 8 (adding weight) reps");
        Team t2 = new Team ("Day 2: Back and Biceps");
        t2.players.add ("Wide Grip Pull Up 3 sets of MAX reps");
        t2.players.add ("Lat Pull Down – 3 sets of 10 reps");
        t2.players.add ("Straight Arm Lat Pull Down – 3 sets of 10 reps");
        t2.players.add ("Standing Barbell Curl – 3 sets of 8-10 reps");
        t2.players.add ("Preacher Curl – 3 sets of 10 reps");
        t2.players.add ("Incline Dumbbell Curl – 3 sets of 10 reps");
        Team t3 = new Team ("Day 3: Legs");
        t3.players.add ("Squat – 4 sets of 10,10,8,8 reps");
        t3.players.add ("Dumbbell Lunge – 3 sets of 8 on each leg");
        t3.players.add ("Leg Press – 3 sets of 12 reps");
        t3.players.add ("Leg Curl – 3 sets of 15 reps");
        t3.players.add ("Leg Extension – 3 sets of 15 reps");
        t3.players.add ("Standing Calf Raise – 5 sets of 10,8,8,8,6 (heavy)reps");
        t3.players.add ("Seated Calf Raise – 5 sets of 15 (light) reps");
        Team t4 = new Team ("Day 4:  Shoulders, chest, and Triceps");
        t4.players.add ("Barbell Bench Press – 3 sets of 10, 10, 8 reps");
        t4.players.add ("Dumbbell Flys – 3 sets of 10 reps");
        t4.players.add ("Cable Crossovers – 3 sets of 10 reps");
        t4.players.add ("Close Grip Bench Press – 4 sets of 10, 10, 8, 6 reps");
        t4.players.add ("Lying Dumbbell Extension – 3 sets of 10 reps");
        t4.players.add ("Tricep Kickback – 3 sets of 10 reps");
        t4.players.add ("Seated Dumbbell Press – 4 sets of 10, 10, 8, 8 reps");
        t4.players.add ("One Arm Cable Lateral Raise – 3 sets of 12 reps");
        Team t5 = new Team ("Day 5: Back and Biceps");
        t5.players.add ("Seated Row – 4 sets of 10 reps");
        t5.players.add ("Bent Over Barbell Row – 3 sets of 10 reps");
        t5.players.add ("Bent Over Row – 3 sets of 12 reps");
        t5.players.add ("Smith Machine Upright Row – 3 sets of 8-10 reps");
        t5.players.add ("Cable Curl – 4 sets of 8-10 reps");
        t5.players.add ("Concentration Curl – 3 sets of 10 reps");
        t5.players.add ("Reverse Barbell Curl – 3 sets of 10 reps");
        allTeams.add (t1);
        allTeams.add (t2);
        allTeams.add (t3);
        allTeams.add (t4);
        allTeams.add (t5);
    }

    return allTeams;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53427651_53439836_12_46
53427651_53439836_48_77
Title: "Code design: How to ensure that DTO objects refer to the same object avoid stackoverflow in circular references in Java?" 
----------------------------------------

private static CompanyDTO convertToDTO (Company dao, Person original, PersonDTO converted) {
    List < SoftReference < Object > > c = cache.get (CompanyDTO.class);
    Optional < Object > cachedDTO = (c == null) ? Optional.empty () : c.stream ().filter (ref -> ref.get () != null && ref.get ().getPrimaryKey () == dao.getPrimaryKey ()).findAny ();
    if (cachedDTO.isPresent ()) {
        return (CompanyDTO) cachedDTO.get ();
    }
    CompanyDTO dto = new CompanyDTO ();
    BeanUtils.copyProperties (dao, dto, "persons");
    dto.setPersons (new ArrayList < > ());
    for (Person person : dao.getPersons ()) {
        if (person.equals (original)) {
            dto.getPersons ().add (converted);
            continue;
        }
        PersonDTO personDTO = convertToDTO (person, dto);
        dto.getPersons ().add (personDTO);
    }
    if (c == null) {
        c = new ArrayList < > ();
        cache.put (CompanyDTO.class, c);
    }
    c.add (new SoftReference < > (dto));
    return dto;
}
----------------------------------------

private static PersonDTO convertToDTO (Person dao, Company converted) {
    List < SoftReference < Object > > c = cache.get (PersonDTO.class);
    Optional < Object > cachedDTO = (c == null) ? Optional.empty () : c.stream ().filter (ref -> ref.get () != null && ref.get ().getPrimaryKey () == dao.getPrimaryKey ()).findAny ();
    if (cachedDTO.isPresent ()) {
        return (PersonDTO) cachedDTO.get ();
    }
    PersonDTO dto = new PersonDTO ();
    BeanUtils.copyProperties (dao, dto, "company");
    if (converted == null) {
        converted = convertToDTO (dao.getCompany (), dao, dto);
    }
    dto.setCompany (converted);
    if (c == null) {
        c = new ArrayList < > ();
        cache.put (PersonDTO.class, c);
    }
    c.add (new SoftReference < > (dto));
    return dto;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53428224_53428427_1_18
53428224_53428891_1_29
Title: Select one checkBox in item from recyclerView and deselect previously selected checkBox 
----------------------------------------

@Override
public void onBindViewHolder (final Main_Page_Payment_Cash_Adapter.ViewHolder holder, final int position) {
    holder.itemView.setOnClickListener (new View.OnClickListener () {
        @Override
        public void onClick (View v) {
            row_index = position;
            notifyDataSetChanged ();
        }}

    );
    if (row_index == position) {
    } else {
    }
}
----------------------------------------

@Override
public void onBindViewHolder (MyViewHolder holder, final int position) {
    AnimalObject animalObject = list.get (position);
    holder.title.setText (animalObject.name);
    holder.itemView.setOnClickListener (new View.OnClickListener () {
        @Override
        public void onClick (View v) {
            AnimalObject animalObject = list.get (position);
            int currentCheckedStatus = animalObject.ischecked ();
            for (int i = 0;
            i < list.size (); i ++) {
                if (i == position) {
                    animalObject.setIschecked (! currentCheckedStatus);
                } else {
                    animalObject.setIschecked (false);
                }
            }
            notifyDataSetChanged ();
        }}

    );
    holder.checkBox.setChecked (animalObject.ischecked ());
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53428589_53429421_31_44
53428589_53451490_16_24
Title: Java concurrency: resettable enabled/disabled wait condition 
----------------------------------------

public void await () {
    try {
        lock.lock ();
        while (! state) {
            try {
                off.await ();
            } catch (InterruptedException e) {
                throw new RuntimeException ("waiting interrupted.");
            }
        }
    } finally {
        lock.unlock ();
    }
}
----------------------------------------

public void await () throws InterruptedException {
    if (state.get ()) {
        synchronized (state) {
            while (state.get ()) {
                state.wait ();
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53437341_53438152_1_20
53437341_53438180_7_38
Title: java.lang.IllegalArgumentException in QuickSort method 
----------------------------------------

public static void quickSort (int [] array, int from, int to) {
    if (array.length <= 1) return;

    int pivot = array [to];
    int left = from;
    int right = to;
    while (left <= right) {
        while (array [left] < pivot) left ++;

        while (array [right] > pivot) right --;

        if (left <= right) {
            swap (array [left], array [right]);
            right --;
            left ++;
        }
        quickSort (array, from, right);
        quickSort (array, left, to);
    }
}
----------------------------------------

public static void quickSort (int [] array, int beginIndex, int endIndex) {
    int arrayLength = endIndex - beginIndex + 1;
    int pivot = array [endIndex];
    if (arrayLength > 1) {
        int left = beginIndex;
        int right = endIndex - 1;
        while (left <= right) {
            while (left <= endIndex && array [left] < pivot) {
                left ++;
            }
            while (right >= beginIndex && array [right] > pivot) {
                right --;
            }
            if (left <= right) {
                swap (array, left, right);
                right --;
                left ++;
            }
        }
        swap (array, left, endIndex);
        if (beginIndex < right) {
            quickSort (array, beginIndex, right);
        }
        if (left + 1 < endIndex) {
            quickSort (array, left + 1, endIndex);
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53445088_53445321_1_14
53445088_53455331_1_22
Title: How to perform mathematical operation on numbers in java having comma instead of decimal? 
----------------------------------------

public static void main (String [] args) throws ParseException {
    String text1 = "123,21";
    String text2 = "22,41";
    NumberFormat nf_in = new DecimalFormat ("###,##");
    int number1 = nf_in.parse (text1).intValue ();
    System.out.println ("Number 1 " + number1);
    int number2 = nf_in.parse (text2).intValue ();
    System.out.println ("Number2 " + number2);
    System.out.println ("Subtract Number2 from number 1" + (number1 - number2));
}
----------------------------------------

public static void main (String [] args) throws ParseException {
    String text1 = "123,21";
    String text2 = "22,41";
    DecimalFormatSymbols decimalFormatSymbols = new DecimalFormatSymbols ();
    decimalFormatSymbols.setDecimalSeparator (',');
    NumberFormat nf_in = new DecimalFormat ("##,##", decimalFormatSymbols);
    double number1 = nf_in.parse (text1).doubleValue ();
    System.out.println ("Number 1 " + number1 * 1);
    double number2 = nf_in.parse (text2).doubleValue ();
    System.out.println ("Number2 " + number2 * 1);
    double outputvalue = number1 - number2;
    System.out.println (outputvalue);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53470768_53471241_1_21
53470768_53471361_1_32
Title: IndexOutOfBoundsException without accessing array 
----------------------------------------

private static int [] merge (int [] a, int [] b) {
    int [] res = new int [a.length + b.length];
    int ia = 0;
    int ib = 0;
    for (int i = 0;
    i < res.length; i ++) {
        if (ia < a.length && ib < b.length) {
            if (a [ia] < b [ib]) {
                res [i] = a [ia ++];
            } else {
                res [i] = b [ib ++];
            }
        } else if (ia < a.length) {
            res [i] = a [ia ++];
        } else {
            res [i] = b [ib ++];
        }

    }
    return res;
}
----------------------------------------

private static int [] merge (int [] a, int [] b) {
    int [] res = new int [a.length + b.length];
    int ia = 0;
    int ib = 0;
    int i = 0;
    while (ia < a.length && ib < b.length) {
        if (a [ia] < b [ib]) {
            res [i] = a [ia];
            ia ++;
            i ++;
        } else {
            res [i] = b [ib];
            ib ++;
            i ++;
        }
    }
    if (ia < a.length) {
        for (int k = ia;
        k < a.length; k ++) {
            res [i] = a [k];
            i ++;
        }
    }
    if (ib < b.length) {
        for (int k = ib;
        k < b.length; k ++) {
            res [i] = b [k];
            i ++;
        }
    }
    return res;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53474859_53474977_22_34
53474859_53475181_16_28
Title: Confused on how to implement an ArrayList 
----------------------------------------

public static void main (String [] args) {
    People person1 = new People ("Bob", 41);
    People person2 = new People ("Arthur", 32);
    People person3 = new People ("Tom", 18);
    System.out.println (people.size ());
    for (People p : people) {
        System.out.println (p.name);
    }
}
----------------------------------------

public static void main (String [] args) {
    ArrayList < People > people = new ArrayList < People > ();
    People person1 = new People ("Bob", 41);
    People person2 = new People ("Arthur", 32);
    People person3 = new People ("Tom", 18);
    people.add (person1);
    people.add (person2);
    people.add (person3);
    people.forEach (System.out :: println);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53481452_53481542_1_12
53481452_53483017_3_27
Title: Java check if next digit of an int is equal to current one 
----------------------------------------

public boolean isNextDigitSame (int valueToCheck) {
    int previousDigit = - 1;
    while (valueToCheck > 0) {
        int currentDigit = valueToCheck % 10;
        if (currentDigit == previousDigit) return true;

        previousDigit = currentDigit;
        valueToCheck /= 10;
    }
    return false;
}
----------------------------------------

public boolean isNextDigitSame (int valueToCheck) {
    String number = String.valueOf (valueToCheck);
    int [] numberAsArray = new int [number.length ()];
    for (int i = 0;
    i < number.length (); i ++) {
        int j = Character.digit (number.charAt (i), 10);
        numberAsArray [i] = j;
    }
    for (int i = 0;
    i < number.length (); i ++) {
        int digit = numberAsArray [i];
        for (int j = 0;
        j < number.length (); j ++) {
            if (digit == numberAsArray [j] && (i == j - 1 || i == j + 1)) return true;

        }
    }
    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53483761_53484410_1_12
53483761_53484531_1_12
Title: Binary search tree Searching troubleshooting 
----------------------------------------

public boolean search (int value) {
    BSTree.CompareSet ();
    if (data == value) return true;

    if (data > value && left != null) return left.search (value);
    else if (data < value && right != null) return right.search (value);

    return false;
}
----------------------------------------

public boolean search (int value) {
    Test.CompareSet ();
    if (data == value) return true;

    if (data < value && right != null) return right.search (value);
    else if (data > value && left != null) return left.search (value);

    return false;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53504712_53505729_16_37
53504712_53505861_1_30
Title: How to equal two 2d arrays together in java? 
----------------------------------------

private static void create2d () {
    String line;
    try {
        FileReader fr = new FileReader ("data.txt");
        BufferedReader br = new BufferedReader (fr);
        ArrayList < String [] > arrayL = new ArrayList < > ();
        while ((line = br.readLine ()) != null) {
            String [] splitter = line.split (" ");
            arrayL.add (splitter);
        }
        main2dArray = new String [arrayL.size ()] [arrayL.get (0).length];
        for (int i = 0;
        i < main2dArray.length; i ++) {
            for (int j = 0;
            j < main2dArray [0].length; j ++) main2dArray [i] [j] = arrayL.get (i) [j];

        }
        br.close ();
    } catch (IOException e) {
        System.out.println ("error");
    }
}
----------------------------------------

private void create2d () {
    String line;
    try {
        FileReader fr = new FileReader ("data.txt");
        BufferedReader br = new BufferedReader (fr);
        ArrayList < String [] > arrayL = new ArrayList < > ();
        String [] [] dataarray = null;
        while ((line = br.readLine ()) != null) {
            String [] splitter = line.split (" ");
            arrayL.add (splitter);
            dataarray = new String [arrayL.size ()] [];
            for (int i = 0;
            i < dataarray.length; i ++) {
                dataarray [i] = arrayL.get (i);
            }
        }
        System.out.println (Arrays.deepToString (dataarray));
        mainArray = new String [arrayL.size ()] [];
        mainArray = Arrays.copyOf (dataarray, dataarray.length);
        br.close ();
    } catch (IOException e) {
        System.out.println ("error");
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53512142_53512220_2_16
53512142_53513550_2_20
Title: Can't figure out For Loop 
----------------------------------------

public static void main (String [] args) {
    int i, j, k;
    for (i = 1; i <= 3; i ++) {
        for (j = 2; j >= i; j --) {
            System.out.print ("_");
        }
        for (k = 1; k <= (2 * i - 1); k ++) {
            System.out.print (i * 2 - 1);
        }
        for (j = 2; j >= i; j --) {
            System.out.print ("_");
        }
        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    int number = 1;
    int row = 3;
    int column = 5;
    char space = '_';
    for (int i = 1;
    i <= row; i ++) {
        for (int j = 1;
        j <= column; j ++) {
            int offset = (column - number) / 2;
            if (j <= offset || j > (number + offset)) {
                System.out.print (space);
            } else {
                System.out.print (number);
            }
        }
        System.out.println ();
        number += 2;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53513508_53513696_3_18
53513508_53513714_1_22
Title: Palindrome with even numbers 
----------------------------------------

public static void main (String args []) {
    System.out.print ("\f");
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ();
    StringBuilder originalStr = new StringBuilder (word);
    String revString = originalStr.reverse ().toString ();
    if (word.equalsIgnoreCase (revString)) System.out.print (word + " is a palindrome");
    else System.out.print (word + " is not a palindrome");

}
----------------------------------------

public static void main (String args []) {
    System.out.printf ("\f");
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ().toLowerCase ();
    int size = word.length ();
    boolean isPalindrome = true;
    for (int count = 0;
    count < size; count ++) {
        int start = (word.charAt (count));
        int end = (word.charAt (size - count - 1));
        if (start != end) {
            isPalindrome = false;
            break;
        }
    }
    if (isPalindrome) System.out.printf ("%s is a palindrome", word);
    else System.out.printf ("%s is not a palindrome", word);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53513508_53513696_3_18
53513508_53513724_1_23
Title: Palindrome with even numbers 
----------------------------------------

public static void main (String args []) {
    System.out.print ("\f");
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ();
    StringBuilder originalStr = new StringBuilder (word);
    String revString = originalStr.reverse ().toString ();
    if (word.equalsIgnoreCase (revString)) System.out.print (word + " is a palindrome");
    else System.out.print (word + " is not a palindrome");

}
----------------------------------------

public static void main (String args []) {
    System.out.printf ("\f");
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ().toLowerCase ();
    int size = word.length ();
    int correct = 0;
    int incorrect = 0;
    for (int count = 0;
    count < size; count ++) {
        int start = (word.charAt (count));
        int end = (word.charAt (size - count - 1));
        if (start == end) correct ++;
        else incorrect ++;

        System.out.println (start + " " + end);
    }
    if (incorrect == 0) System.out.printf ("%s is a palindrome", word);
    else System.out.printf ("%s is not a palindrome", word);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53513508_53513696_3_18
53513508_53513782_1_23
Title: Palindrome with even numbers 
----------------------------------------

public static void main (String args []) {
    System.out.print ("\f");
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ();
    StringBuilder originalStr = new StringBuilder (word);
    String revString = originalStr.reverse ().toString ();
    if (word.equalsIgnoreCase (revString)) System.out.print (word + " is a palindrome");
    else System.out.print (word + " is not a palindrome");

}
----------------------------------------

public static void main (String args []) {
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ();
    int size = word.length ();
    boolean isPalindrome = true;
    int maxIndex = size - 1;
    for (int count = 0;
    count < size / 2; count ++) {
        char start = word.charAt (count);
        char end = word.charAt (maxIndex - count);
        if (start != end) {
            isPalindrome = false;
            break;
        }
    }
    if (isPalindrome) System.out.printf ("%s is a palindrome", word);
    else System.out.printf ("%s is not a palindrome", word);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53513508_53513714_1_22
53513508_53513724_1_23
Title: Palindrome with even numbers 
----------------------------------------

public static void main (String args []) {
    System.out.printf ("\f");
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ().toLowerCase ();
    int size = word.length ();
    boolean isPalindrome = true;
    for (int count = 0;
    count < size; count ++) {
        int start = (word.charAt (count));
        int end = (word.charAt (size - count - 1));
        if (start != end) {
            isPalindrome = false;
            break;
        }
    }
    if (isPalindrome) System.out.printf ("%s is a palindrome", word);
    else System.out.printf ("%s is not a palindrome", word);

}
----------------------------------------

public static void main (String args []) {
    System.out.printf ("\f");
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ().toLowerCase ();
    int size = word.length ();
    int correct = 0;
    int incorrect = 0;
    for (int count = 0;
    count < size; count ++) {
        int start = (word.charAt (count));
        int end = (word.charAt (size - count - 1));
        if (start == end) correct ++;
        else incorrect ++;

        System.out.println (start + " " + end);
    }
    if (incorrect == 0) System.out.printf ("%s is a palindrome", word);
    else System.out.printf ("%s is not a palindrome", word);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53513508_53513724_1_23
53513508_53513782_1_23
Title: Palindrome with even numbers 
----------------------------------------

public static void main (String args []) {
    System.out.printf ("\f");
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ().toLowerCase ();
    int size = word.length ();
    int correct = 0;
    int incorrect = 0;
    for (int count = 0;
    count < size; count ++) {
        int start = (word.charAt (count));
        int end = (word.charAt (size - count - 1));
        if (start == end) correct ++;
        else incorrect ++;

        System.out.println (start + " " + end);
    }
    if (incorrect == 0) System.out.printf ("%s is a palindrome", word);
    else System.out.printf ("%s is not a palindrome", word);

}
----------------------------------------

public static void main (String args []) {
    Scanner input = new Scanner (System.in);
    System.out.println ("enter a word");
    String word = input.nextLine ();
    int size = word.length ();
    boolean isPalindrome = true;
    int maxIndex = size - 1;
    for (int count = 0;
    count < size / 2; count ++) {
        char start = word.charAt (count);
        char end = word.charAt (maxIndex - count);
        if (start != end) {
            isPalindrome = false;
            break;
        }
    }
    if (isPalindrome) System.out.printf ("%s is a palindrome", word);
    else System.out.printf ("%s is not a palindrome", word);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5351483_26407830_7_20
5351483_5351676_41_74
Title: Calculate date/time difference in java 
----------------------------------------

public static int getTimeDifference (Date d2, Date d1, int timeUnit) {
    Date diff = new Date (d2.getTime () - d1.getTime ());
    Calendar calendar = Calendar.getInstance ();
    calendar.setTime (diff);
    int hours = calendar.get (Calendar.HOUR_OF_DAY);
    int minutes = calendar.get (Calendar.MINUTE);
    int seconds = calendar.get (Calendar.SECOND);
    if (timeUnit == Calendar.HOUR_OF_DAY) return hours;

    if (timeUnit == Calendar.MINUTE) return minutes;

    return seconds;
}
----------------------------------------

public static long [] getTimeDifference (Date d1, Date d2) {
    long [] result = new long [5];
    Calendar cal = Calendar.getInstance ();
    cal.setTimeZone (TimeZone.getTimeZone ("UTC"));
    cal.setTime (d1);
    long t1 = cal.getTimeInMillis ();
    cal.setTime (d2);
    long diff = Math.abs (cal.getTimeInMillis () - t1);
    final int ONE_DAY = 1000 * 60 * 60 * 24;
    final int ONE_HOUR = ONE_DAY / 24;
    final int ONE_MINUTE = ONE_HOUR / 60;
    final int ONE_SECOND = ONE_MINUTE / 60;
    long d = diff / ONE_DAY;
    diff %= ONE_DAY;
    long h = diff / ONE_HOUR;
    diff %= ONE_HOUR;
    long m = diff / ONE_MINUTE;
    diff %= ONE_MINUTE;
    long s = diff / ONE_SECOND;
    long ms = diff % ONE_SECOND;
    result [0] = d;
    result [1] = h;
    result [2] = m;
    result [3] = s;
    result [4] = ms;
    return result;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5351483_35712255_2_30
5351483_5351676_6_16
Title: Calculate date/time difference in java 
----------------------------------------

public static void main (String [] args) {
    String dateStart = "11/03/14 09:29:58";
    String dateStop = "11/03/14 09:33:43";
    SimpleDateFormat format = new SimpleDateFormat ("yy/MM/dd HH:mm:ss");
    Date d1 = null;
    Date d2 = null;
    try {
        d1 = format.parse (dateStart);
        d2 = format.parse (dateStop);
    } catch (ParseException e) {
        e.printStackTrace ();
    }
    long diff = d2.getTime () - d1.getTime ();
    long days = TimeUnit.MILLISECONDS.toDays (diff);
    long remainingHoursInMillis = diff - TimeUnit.DAYS.toMillis (days);
    long hours = TimeUnit.MILLISECONDS.toHours (remainingHoursInMillis);
    long remainingMinutesInMillis = remainingHoursInMillis - TimeUnit.HOURS.toMillis (hours);
    long minutes = TimeUnit.MILLISECONDS.toMinutes (remainingMinutesInMillis);
    long remainingSecondsInMillis = remainingMinutesInMillis - TimeUnit.MINUTES.toMillis (minutes);
    long seconds = TimeUnit.MILLISECONDS.toSeconds (remainingSecondsInMillis);
    System.out.println ("Days: " + days + ", hours: " + hours + ", minutes: " + minutes + ", seconds: " + seconds);
}
----------------------------------------

public static void main (String [] args) {
    Date d1 = new Date ();
    try {
        Thread.sleep (750);
    } catch (InterruptedException e) {
    }
    Date d0 = new Date (System.currentTimeMillis () - (1000 * 60 * 60 * 24 * 3));
    long [] diff = TimeDiff.getTimeDifference (d0, d1);
    System.out.printf ("Time difference is %d day(s), %d hour(s), %d minute(s), %d second(s) and %d millisecond(s)\n", diff [0], diff [1], diff [2], diff [3], diff [4]);
    System.out.printf ("Just the number of days = %d\n", TimeDiff.getTimeDifference (d0, d1, TimeDiff.TimeField.DAY));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5353136_29090686_7_48
5353136_5353399_7_37
Title: "How do I create a Java Swing JTable with header as first column not as first row?" 
----------------------------------------

public static void main (String [] argv) throws Exception {
    DefaultTableModel model = new DefaultTableModel ();
    JTable table = new JTable (model);
    model.addColumn ("Header");
    String [] headers = {"Header 1", "Header 2", "Header 3"};
    String [] [] columnData = new String [] [] {{"Column 1.1", "Column 1.2", "Column 1.3"}, {"Column 2.1", "Column 2.2", "Column 2.3"}, {"Column 3.1", "Column 3.2", "Column 3.3"}};
    for (int col = 1;
    col < (columnData.length + 1); col ++) {
        model.addColumn ("Col" + col);
    }
    for (int i = 0;
    i < headers.length; i ++) {
        model.addRow (new Object [] {headers [i]});
    }
    for (int r = 0;
    r < columnData.length; r ++) {
        for (int c = 0;
        c < columnData [0].length; c ++) {
            model.setValueAt (columnData [r] [c], c, r + 1);
        }
    }
    JFrame f = new JFrame ();
    f.setSize (500, 300);
    f.add (new JScrollPane (table));
    f.setVisible (true);
}
----------------------------------------

public static void main (String [] args) {
    Test test = new Test ();
    String [] columnNames = {"First Name", "Last Name", "Sport", "# of Years", "Vegetarian"};
    Object [] [] data = {{"Kathy", "Smith", "Snowboarding", new Integer (5), new Boolean (false)}, {"John", "Doe", "Rowing", new Integer (3), new Boolean (true)}, {"Sue", "Black", "Knitting", new Integer (2), new Boolean (false)}, {"Jane", "White", "Speed reading", new Integer (20), new Boolean (true)}, {"Joe", "Brown", "Pool", new Integer (10), new Boolean (false)}};
    JTable table = new JTable (data, columnNames) {
        @Override
        public Object getValueAt (int row, int column) {
            return super.getValueAt (column, row);
        }}

    ;
    test.add (table);
    test.pack ();
    test.setVisible (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53544212_53545468_1_41
53544212_53545713_17_36
Title: How to read from file and store the information in a Linked List (Java)? 
----------------------------------------

public static void processFile (Scanner sc1, CellList cl1) {
    String S = null;
    while (sc1.hasNext ()) {
        if (cl1.getSize () == 0) {
            S = sc1.next ();
            serialNum = Long.parseLong (S);
            S = sc1.next ();
            brand = S;
            S = sc1.next ();
            price = Double.parseDouble (S);
            S = sc1.next ();
            year = Integer.parseInt (S);
            CellPhone c1 = new CellPhone (serialNum, brand, year, price);
            cl1.addToStart (c1);
        } else {
            serialNum = Long.parseLong (S);
            S = sc1.next ();
            brand = S;
            S = sc1.next ();
            price = Double.parseDouble (S);
            S = sc1.next ();
            year = Integer.parseInt (S);
            if (! (cl1.contains (serialNum))) {
                CellPhone c2 = new CellPhone (serialNum, brand, year, price);
                cl1.addToStart (c2);
            }
        }
        if (sc1.hasNext ()) {
            S = sc1.next ();
        }
    }
}
----------------------------------------

public static void processFile (Scanner sc1, LinkedList < CellPhone > cl1) {
    String S = null;
    while (sc1.hasNext ()) {
        S = sc1.next ();
        Long serialNum = Long.parseLong (S.trim ());
        S = sc1.next ();
        String brand = S.trim ();
        S = sc1.next ();
        double price = Double.parseDouble (S.trim ());
        S = sc1.next ();
        int year = Integer.parseInt (S.trim ());
        CellPhone c1 = new CellPhone (serialNum, brand, year, price);
        if (! cl1.contains (c1)) cl1.add (c1);

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53544946_53546296_5_16
53544946_53547598_1_26
Title: How to work with json object and jsonarray 
----------------------------------------

public static void main (String [] args) {
    try {
        JSONObject jsonObject = new JSONObject (new String (Files.readAllBytes (Paths.get ("test.json"))));
        findValues (jsonObject);
        values.forEach (System.out :: println);
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String [] args) {
    JSONParser parser = new JSONParser ();
    JSONObject jobj = null;
    try {
        BufferedReader reader = new BufferedReader (new InputStreamReader (new FileInputStream (".json"), "UTF-8"));
        jobj = (JSONObject) parser.parse (reader);
    } catch (FileNotFoundException e) {
        e.printStackTrace ();
    } catch (IOException e) {
        e.printStackTrace ();
    } catch (ParseException e) {
        e.printStackTrace ();
    }
    JSONObject jobj2 = (JSONObject) jobj.get ("object");
    JSONObject jobj3 = (JSONObject) jobj2.get ("17");
    JSONObject jobj4 = (JSONObject) jobj3.get ("381");
    JSONObject jobj5 = (JSONObject) jobj4.get ("19");
    System.out.println (jobj5.get ("pieceLabel"));
    JSONArray jsarry = (JSONArray) jobj.get ("5");
    JSONArray jsarry2 = (JSONArray) jsarry.get (0);
    JSONObject nestedjsobj = (JSONObject) jsarry2.get (0);
    System.out.println (nestedjsobj.get ("pieceLabel"));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53546852_53547025_1_11
53546852_53547387_1_21
Title: Java 2D Array Placing Value if Adjacent value is the same 
----------------------------------------

public void move (int client, int x, int y) {
    int [] coords = clientCoords.get (client);
    int old_x = coords [0], old_y = coords [1];
    if (Math.abs (x - old_x) <= 1 && Math.abs (y - old_y) <= 1) {
        clientCoords.set (client, new int [2] {x, y});
        int count = totals.containsKey (client) ? totals.get (client) : 1;
        totals.put (client, count + 1);
    }
}
----------------------------------------

public static move (int client, int x, int y) {
    if (storeArray [x] [y] == client) return;

    int startPosX = Math.max (x - 1, 0), startPosY = Math.max (y - 1, 0);
    int endPosX = Math.min (x + 1, storeArray.length - 1), endPosY = Math.min (y + 1, storeArray [0].length - 1);
    outerloop : for (int rowNum = startPosX;
    rowNum <= endPosX; rowNum ++) {
        for (int colNum = startPosY;
        colNum <= endPosY; colNum ++) {
            if (storeArray [rowNum] [colNum] == client) {
                storeArray [x] [y] = client;
                System.out.println ("Successful move");
                int count = totals.getOrDefault (client, 1);
                totals.put (client, count + 1);
                break outerloop;
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53548173_53548792_35_56
53548173_53548792_37_54
Title: Error populating Jlist with data from ArrayList 
----------------------------------------

public void run () {
    EventQueue.invokeLater (new Runnable () {
        public void run () {
            try {
                Window frame = Window.this;
                frame.setVisible (true);
                frame.getContentPane ().setSize (800, 400);
                frame.setBounds (200, 50, 630, 500);
            } catch (Exception e) {
                e.printStackTrace ();
            }
        }}

    );
}
----------------------------------------

public void run () {
    try {
        Window frame = Window.this;
        frame.setVisible (true);
        frame.getContentPane ().setSize (800, 400);
        frame.setBounds (200, 50, 630, 500);
    } catch (Exception e) {
        e.printStackTrace ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53548962_53549034_1_12
53548962_53549368_12_39
Title: Reduction of duplicate words prior to uppercase or lowercase 
----------------------------------------

public static String Eliminate (String input) {
    char [] chrArray = input.toCharArray ();
    String letter = "";
    for (char value : chrArray) {
        if (letter.indexOf (value.toLowerCase ()) == - 1 && letter.indexOf (value.toUpperCase ()) == - 1) {
            letter += value;
        }
    }
    return letter;
}
----------------------------------------

public static String Eliminate (String input) {
    char [] chrArray = input.toCharArray ();
    String letter = "";
    for (int index = 0;
    index < chrArray.length; index ++) {
        int j = 0;
        boolean flag = true;
        while (j < letter.length ()) {
            if ((int) chrArray [index] == letter.charAt (j) || (int) chrArray [index] == ((int) letter.charAt (j) + 32)) {
                flag = false;
                break;
            } else j ++;

        }
        if (flag == true) {
            letter += chrArray [index];
        }
    }
    return letter;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53550759_53550947_37_51
53550759_53550986_1_12
Title: How can I make sure that the entered input matches the array index in order to output the right solution? 
----------------------------------------

private static Films getTopFilm (Films [] f, int yearEntered, double total) {
    Films topFilm = null;
    double max = 0;
    for (int i = 0;
    i < f.length; i ++) {
        if (f [i].getPremiereYear () != yearEntered) {
            continue;
        }
        if (f [i].getFilmIncome () == total) {
            topFilm = f [i];
            break;
        }
    }
    return topFilm;
}
----------------------------------------

private static Films getTopFilm (Films [] f, int yearEntered) {
    Films topFilm = null;
    double max = 0;
    for (int i = 0;
    i < f.length; i ++) {
        if (f [i].getFilmIncome () > max) {
            topFilm = f [i];
            max = f [i].getFilmIncome ();
        }
    }
    return topFilm;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5355262_5355390_1_14
5355262_5358236_9_19
Title: java string-manipulations 
----------------------------------------

public static String notReplace (final String str) {
    final StringBuilder sb = new StringBuilder ().append (' ').append (str).append (" ");
    for (int i = 0;
    i < sb.length () - 2; i ++) {
        if (! Character.isLetter (sb.charAt (i)) && sb.charAt (i + 1) == 'i' && sb.charAt (i + 2) == 's' && ! Character.isLetter (sb.charAt (i + 3))) {
            sb.insert (i + 3, " not");
            i += 5;
        }
    }
    return sb.substring (1, sb.length () - 1);
}
----------------------------------------

public static void notReplace (String str, StringBuilder buffer) {
    if (str.length () < 3) {
        buffer.append (str).toString ();
    } else if (str.startsWith ("is ")) {
        notReplace (str.substring (3), buffer.append ("is not "));
    } else {
        notReplace (str.substring (1), buffer.append (str.charAt (0)));
    }

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53555417_53555516_1_10
53555417_53555658_1_18
Title: Java code to print the list of factors of a number with return type int 
----------------------------------------

public static List < Integer > printFactorsInt (int number) {
    List < Integer > listOfFactors = new ArrayList < > ();
    for (int i = 1;
    i <= number; i ++) {
        if ((number % i) == 0) {
            listOfFactors.add (i);
        }
    }
    return listOfFactors;
}
----------------------------------------

public static int printFactorsInt (int number) {
    if (number < 1) {
        return - 1;
    }
    int factor = 0;
    for (int i = 1;
    i <= number; i ++) {
        if ((number % i) == 0) {
            factor = i;
            System.out.print (factor + " ");
        }
    }
    return factor;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53560410_53560552_1_20
53560410_53560731_1_16
Title: Array of strings to a formatted string 
----------------------------------------

public static String formatWords (String [] words) {
    if (words == null || words.length) {
        return "";
    }
    StringBuilder sb = new StringBuilder (words [0]);
    for (int i = 1;
    i < words.lengh - 1; ++ i) {
        sb.append (", ").append (word [i]);
    }
    if (words.length > 1) {
        sb.append (" and ").append (words [1])
    }
}
----------------------------------------

public static String formatWords (String [] words) {
    if (words == null) return "";

    StringBuilder out = new StringBuilder ();
    for (int i = 0;
    i < words.length; i ++) {
        out.append (words [i]);
        if (i == len - 2) out.append (" and ");
        else if (i < len - 2) out.append (",");

    }
    return out.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53560410_53560552_1_20
53560410_53562128_1_32
Title: Array of strings to a formatted string 
----------------------------------------

public static String formatWords (String [] words) {
    if (words == null || words.length) {
        return "";
    }
    StringBuilder sb = new StringBuilder (words [0]);
    for (int i = 1;
    i < words.lengh - 1; ++ i) {
        sb.append (", ").append (word [i]);
    }
    if (words.length > 1) {
        sb.append (" and ").append (words [1])
    }
}
----------------------------------------

public static String formatWords (String [] words) {
    StringBuilder sb = new StringBuilder ();
    for (int i = 0;
    i < words.length; i ++) {
        sb.append (words [i]);
        if (i == words.length - 2 && words.length >= 2) {
            sb.append (" and ");
        } else if (i < words.length - 1) {
            sb.append (", ");
        }

    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53560410_53560731_1_16
53560410_53562128_1_32
Title: Array of strings to a formatted string 
----------------------------------------

public static String formatWords (String [] words) {
    if (words == null) return "";

    StringBuilder out = new StringBuilder ();
    for (int i = 0;
    i < words.length; i ++) {
        out.append (words [i]);
        if (i == len - 2) out.append (" and ");
        else if (i < len - 2) out.append (",");

    }
    return out.toString ();
}
----------------------------------------

public static String formatWords (String [] words) {
    StringBuilder sb = new StringBuilder ();
    for (int i = 0;
    i < words.length; i ++) {
        sb.append (words [i]);
        if (i == words.length - 2 && words.length >= 2) {
            sb.append (" and ");
        } else if (i < words.length - 1) {
            sb.append (", ");
        }

    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53562551_53562573_1_16
53562551_53562650_1_19
Title: What can I do to my code to skip the first line of my input text file? 
----------------------------------------

public static double columnSum (String filename, int column) {
    double sum = 0;
    try (Scanner scan = new Scanner (new File (filename))) {
        if (scan.hasNextLine ()) {
            scan.nextLine ();
        }
        while (scan.hasNextLine ()) {
            String s = scan.nextLine ();
            sum = sum + Double.parseDouble (s.split (",") [1]);
        }
    } catch (FileNotFoundException e) {
        System.out.println ("Inout file " + filename + " does not exist");
    }
    return sum;
}
----------------------------------------

public static double columnSum (String filename, int column) {
    double sum = 0;
    Scanner scan = null;
    try {
        scan = new Scanner (new File (filename));
        while (scan.hasNextLine ()) {
            String s = scan.nextLine ();
            try {
                sum = sum + Double.parseDouble (s.split (",") [1]);
            } catch (NumberFormatException n) {
            }
        }
    } catch (FileNotFoundException e) {
        System.out.println ("Inout file " + filename + " does not exist");
    } finally {
        scan.close ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53567525_53567544_1_14
53567525_53567982_23_73
Title: Constructor and Array Lists 
----------------------------------------

public Presidents [] PresidentList () {
    Presidents [] president = new Presidents [45];
    president [0] = Presidents (1, "George Washington", 1789, 1797);
    president [1] = Presidents (2, "John Adams", 1797, 1801);
    president [2] = Presidents (3, "Thomas Jefferson", 1801, 1809);
    president [3] = Presidents (4, "James Madison", 1809, 1817);
    president [4] = Presidents (5, "James Monroe", 1817, 1825);
    return president;
}
----------------------------------------

public Presidents [] PresidentList () {
    president = new Presidents [45];
    president [0] = new Presidents (1, "George Washington", 1789, 1797);
    president [1] = new Presidents (2, "John Adams", 1797, 1801);
    president [2] = new Presidents (3, "Thomas Jefferson", 1801, 1809);
    president [3] = new Presidents (4, "James Madison", 1809, 1817);
    president [4] = new Presidents (5, "James Monroe", 1817, 1825);
    president [5] = new Presidents (6, "John Quincy Adams", 1825, 1829);
    president [6] = new Presidents (7, "Andrew Jackson", 1829, 1837);
    president [7] = new Presidents (8, "Martin Van Buren", 1837, 1841);
    president [8] = new Presidents (9, "William Henry Harrison", 1841, 1841);
    president [9] = new Presidents (10, "John Tyler", 1841, 1845);
    president [10] = new Presidents (11, "James K. Polk", 1845, 1849);
    president [11] = new Presidents (12, "Zachary Taylor", 1849, 1850);
    president [12] = new Presidents (13, "Millard Fillmore", 1850, 1853);
    president [13] = new Presidents (14, "Franklin Pierce", 1853, 1857);
    president [14] = new Presidents (15, "James Buchanan", 1857, 1861);
    president [15] = new Presidents (16, "Abraham Lincoln", 1861, 1865);
    president [16] = new Presidents (17, "Andrew Johnson", 1865, 1869);
    president [17] = new Presidents (18, "Ulysses S. Grant", 1869, 1877);
    president [18] = new Presidents (19, "Rutherford B. Hayes", 1877, 1881);
    president [19] = new Presidents (20, "James A. Garfield", 1881, 1881);
    president [20] = new Presidents (21, "Chester A. Arthur", 1881, 1885);
    president [21] = new Presidents (22, "Grover Cleveland", 1885, 1889);
    president [22] = new Presidents (23, "Benjamin Harrison", 1889, 1893);
    president [23] = new Presidents (24, "Grover Cleveland", 1893, 1897);
    president [24] = new Presidents (25, "William McKinley", 1897, 1901);
    president [25] = new Presidents (26, "Theodore Roosevelt", 1901, 1909);
    president [26] = new Presidents (27, "William Howard Taft", 1909, 1913);
    president [27] = new Presidents (28, "Woodrow Wilson", 1913, 1921);
    president [28] = new Presidents (29, "Warren G. Harding", 1921, 1923);
    president [29] = new Presidents (30, "Calvin Coolidge", 1923, 1929);
    president [30] = new Presidents (31, "Herbert Hoover", 1929, 1933);
    president [31] = new Presidents (32, "Franklin D. Roosevelt", 1933, 1945);
    president [32] = new Presidents (33, "Harry S. Truman", 1945, 1953);
    president [33] = new Presidents (34, "Dwight D. Eisenhower", 1953, 1961);
    president [34] = new Presidents (35, "John F. Kennedy", 1961, 1963);
    president [35] = new Presidents (36, "Lyndon B. Johnson", 1963, 1969);
    president [36] = new Presidents (37, "Richard Nixon", 1969, 1974);
    president [37] = new Presidents (38, "Gerald Ford", 1974, 1977);
    president [38] = new Presidents (39, "Jimmy Carter", 1977, 1981);
    president [39] = new Presidents (40, "Ronald Reagan", 1981, 1989);
    president [40] = new Presidents (41, "George H. W. Bush", 1989, 1993);
    president [41] = new Presidents (42, "Bill Clinton", 1993, 2001);
    president [42] = new Presidents (43, "George W. Bush", 2001, 2009);
    president [43] = new Presidents (44, "Barack Obama", 2009, 2017);
    president [44] = new Presidents (45, "Donald Trump", 2017, 2018);
    return president;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53570831_53571037_28_56
53570831_53571162_34_60
Title: Sorting an ArrayList of Names using a Comparator that sorts by length 
----------------------------------------

public static void main (String [] args) throws Exception {
    ArrayList < Name > N = new ArrayList < > (5);
    BufferedReader keyIn = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Please Enter Name: ");
    String n = keyIn.readLine ();
    N.add (new Name (n));
    for (int i = 0;
    i < 5; i ++) {
        String name = keyIn.readLine ();
        N.add (new Name (name));
    }
    System.out.println ();
    System.out.println ("Compare by Length");
    N.sort (new StringLengthComparator ());
    for (int i = 0;
    i < N.size (); i ++) {
        System.out.println (N.get (i).name);
    }
    System.out.println ();
    System.out.println ("Compare by String");
    N.sort (new StringCommonComparator ());
    for (int i = 0;
    i < N.size (); i ++) {
        System.out.println (N.get (i).name);
    }
}
----------------------------------------

public static void main (String [] args) throws Exception {
    ArrayList < Name > N = new ArrayList < > (5);
    BufferedReader keyIn = new BufferedReader (new InputStreamReader (System.in));
    System.out.println ("Please Enter Name: ");
    for (int i = 0;
    i < 5; i ++) {
        String n = keyIn.readLine ();
        N.add (new Name (n));
    }
    System.out.print ("\n");
    Collections.sort (N);
    for (Name name : N) {
        System.out.println (name.getName ());
    }
    System.out.print ("\n");
    Collections.sort (N, new StringLengthComparator ());
    for (int i = 0;
    i < N.size (); i ++) {
        System.out.println (N.get (i));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53571308_53571412_3_24
53571308_53571442_1_33
Title: How can I print a pyramid of * 
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int num = 4;
    while (num % 2 == 0) {
        System.out.println ("Introduce un numero impar:");
        num = in.nextInt ();
        if (num % 2 == 0) {
            System.out.println ("Has introducido un numero par");
        }
    }
    for (int numFila = 0;
    numFila < num; numFila ++) {
        for (int numColumna = 0;
        numColumna < num * 2 - 1; numColumna ++) {
            if (numFila <= numColumna && numColumna <= num - numFila - 1) {
                System.out.print (" * ");
            } else {
                System.out.print ("   ");
            }
        }
        System.out.println ();
    }
}
----------------------------------------

public static void main (String [] args) {
    Scanner in = new Scanner (System.in);
    int num = 4;
    while (num % 2 == 0) {
        System.out.println ("Introduce un numero impar:");
        num = in.nextInt ();
        if (num % 2 == 0) {
            System.out.println ("Has introducido un numero par");
        }
    }
    int rows = (num + 1) / 2;
    for (int i = rows;
    i >= 1; i --) {
        for (int j = 1;
        j <= rows - i; j ++) {
            System.out.print ("   ");
        }
        for (int j = i;
        j <= 2 * i - 1; j ++) {
            System.out.print (" * ");
        }
        for (int j = 0;
        j < i - 1; j ++) {
            System.out.print (" * ");
        }
        System.out.println ();
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
53573252_53574050_11_36
53573252_53574119_25_40
Title: Move files from one folder to another based on file extension 
----------------------------------------

public static void main (String a []) {
    try {
        File source = new File ("C:\\Users\\sh370472\\Downloads");
        File dest = new File ("E:\\Query\\");
        FileUtils.copyDirectory (source, dest, new FileFilter () {
            @Override
            public boolean accept (File pathname) {
                boolean source = pathname.getName ().toLowerCase ().endsWith (".csv");
                if (source) {
                    pathname.deleteOnExit ();
                    return true;
                }
                return false;
            }}

        );
    } catch (IOException e) {
        e.printStackTrace ();
    }
}
----------------------------------------

public static void main (String...args) {
    {
        MoveFile moveFile = new MoveFile ();
        String sourcePath = "C:\\\\Users\\\\sh370472\\\\Downloads";
        String destPath = "E:\\Query\\";
        String extension = ".csv";
        try {
            File [] files = moveFile.getTheFilesWithExtension (sourcePath, extension);
            for (File file : files) {
                moveFile.moveFile (file.getPath (), destPath + file.getName ());
            }
        } catch (IOException e) {
            e.printStackTrace ();
        }
    }}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5366606_5366720_9_30
5366606_5366833_1_31
Title: How can I flag duplicates in an array? 
----------------------------------------

public static void main (String [] args) {
    List < Object > myArray = new ArrayList < Object > ();
    myArray.add (MyJsonObject.parse ("{\"lon\": 0.001, \"lat\": 0.001, \"desc\": \"test\"}"));
    myArray.add (MyJsonObject.parse ("{\"lon\": 0.001, \"lat\": 0.001, \"desc\": \"test2\"}"));
    List seenObjects = new ArrayList < Object > ();
    for (Object obj : myArray) {
        if (! seenObjects.contains (obj)) {
            seenObjects.add (obj);
        } else {
            MyJsonObject original = (MyJsonObject) seenObjects.get (seenObjects.indexOf (obj));
            MyJsonObject update = (MyJsonObject) obj;
            original.put ("desc", original.get ("desc") + ", " + update.get ("desc"));
        }
    }
    for (MyJsonObject obj : (List < MyJsonObject >) seenObjects) {
        System.out.println (obj.toJSONString ());
    }
}
----------------------------------------

public static void main (String [] args) {
    String s = "[" + " {\"lon\": 0.001, \"lat\": 0.001, \"desc\": \"test\"}," + " {\"lon\": 0.002, \"lat\": 0.001, \"desc\": \"test3\"}," + " {\"lon\": 0.002, \"lat\": 0.005, \"desc\": \"test4\"}," + " {\"lon\": 0.002, \"lat\": 0.001, \"desc\": \"test5\"}," + " {\"lon\": 0.001, \"lat\": 0.001, \"desc\": \"test2\"}]";
    Gson gson = new Gson ();
    Location [] al = gson.fromJson (s, Location [].class);
    List < Location > tl = Arrays.asList (al);
    Collections.sort (tl);
    List < Location > fl = new ArrayList < Location > ();
    Location current = null;
    for (Iterator < Location > it = tl.iterator ();
    it.hasNext ();) {
        current = current == null ? it.next () : current;
        Location ltmp = null;
        while (it.hasNext () && (ltmp = it.next ()).equals (current)) current.desc = current.desc + "," + ltmp.desc;

        fl.add (current);
        current = ltmp;
    }
    System.out.println (gson.toJson (fl));
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
536811_536825_1_16
536811_536922_1_26
Title: Doubt in exception handling and finally block in java 
----------------------------------------

public void main (String [] args) {
    try {
    } catch (SomeException se) {
        se.printStackTrace ();
    } finally {
        try {
        } catch (SomeException1 se1) {
            se.printStackTrace ();
        }
    }
    System.out.println ("End Program");
}
----------------------------------------

public void main (String [] args) {
    boolean exceptionOccured = false;
    try {
        exceptionOccured = true;
        exceptionOccured = false;
    } catch (SomeException se) {
        se.printStackTrace ();
    } finally {
        Exception e = null;
        try {
        } catch (SomeException1 se1) {
            exceptionOccured = true;
            se.printStackTrace ();
        }
        if (exceptionOccured) System.out.println ("End Program");

    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5368490_5368845_12_34
5368490_5368858_1_17
Title: Select random string from given list 
----------------------------------------

static public void main (String [] args) throws InterruptedException {
    List < String > list = new ArrayList < String > ();
    list.add ("hi");
    list.add ("hello");
    list.add ("booya!");
    Random rg = new Random ();
    String randomElement;
    int listSize = list.size ();
    if (listSize < 2) return;

    while (true) {
        randomElement = list.get (rg.nextInt (listSize));
        System.out.println (randomElement);
        Thread.sleep (SLEEP_TIME);
    }
}
----------------------------------------

public static void main (String [] args) throws InterruptedException {
    List < String > my_words = new LinkedList < String > ();
    my_words.add ("1153 3494 9509 2 0 0 0 0");
    my_words.add ("1153 3487 9509 2 0 0 0 0");
    my_words.add ("1153 3491 9525 2 0 0 0 0");
    my_words.add ("1153 3464 9513 2 0 0 0 0");
    Random rand = new Random ();
    while (true) {
        int choice = rand.nextInt (my_words.size ());
        System.out.println ("Choice = " + my_words.get (choice));
        Thread.sleep (1000);
        int replaceTo = rand.nextInt (my_words.size ());
        System.out.println ("Replace to = " + my_words.get (replaceTo));
        my_words.set (choice, my_words.get (replaceTo));
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5371943_5372104_2_16
5371943_5372166_17_33
Title: Reading from a URL Connection Java 
----------------------------------------

public static void main (String [] args) throws MalformedURLException, IOException {
    URL pageUrl = new URL ("http://www.google.com");
    URLConnection getConn = pageUrl.openConnection ();
    getConn.connect ();
    BufferedReader dis = new BufferedReader (new InputStreamReader (getConn.getInputStream ()));
    String myString;
    while ((myString = dis.readLine ()) != null) {
        System.out.println (myString);
    }
}
----------------------------------------

public static void main (String [] args) {
    UrlReader urlReader = new UrlReader ();
    for (String url : args) {
        try {
            String contents = urlReader.readContents (url);
            System.out.printf ("url: %s contents: %s\n", url, contents);
        } catch (Exception e) {
            e.printStackTrace ();
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5374077_5374211_11_19
5374077_5379490_39_48
Title: What is LinkedListNode in Java 
----------------------------------------

static < E > E deleteNode (LinkedListNode < E > node) {
    if (node == null || node.next == null) return null;

    E retval = node.data;
    LinkedListNode < E > next = node.next;
    node.data = next.data;
    node.next = next.next;
    return retval;
}
----------------------------------------

public static boolean deleteNode (LinkedListNode n) {
    if (n == null || n.next == null) {
        return false;
    }
    LinkedListNode next = n.next;
    n.data = next.data;
    n.next = next.next;
    return true;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5374077_5374211_73_86
5374077_5379490_13_37
Title: What is LinkedListNode in Java 
----------------------------------------

public static void main (String [] args) {
    LinkedList < String > list = new LinkedList < String > ();
    list.addLast ("Apple");
    list.addLast ("Bear");
    list.addLast ("Chair");
    list.addLast ("Dirt");
    LinkedListNode < String > bear = list.findFirst ("Bear");
    deleteNode (bear);
    list.print ();
}
----------------------------------------

public static void main (String [] args) {
    LinkedListNode node_1 = new LinkedListNode ("first");
    LinkedListNode node_2 = new LinkedListNode ("second");
    node_1.next = node_2;
    LinkedListNode node_3 = new LinkedListNode ("third");
    node_2.next = node_3;
    System.out.println ("*** Print contents of linked list");
    LinkedListNode current = node_1;
    while (current != null) {
        System.out.println (current.data);
        current = current.next;
    }
    System.out.println ("*** Now delete second node");
    deleteNode (node_2);
    System.out.println ("*** Print after deleting second node");
    current = node_1;
    while (current != null) {
        System.out.println (current.data);
        current = current.next;
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5374510_5374547_7_20
5374510_5480829_17_28
Title: I/O operations on file 
----------------------------------------

public static void main (String [] args) throws IOException {
    File inputFile = new File ("farrago.txt");
    File outputFile = new File ("outagain.txt");
    FileReader in = new FileReader (inputFile);
    FileWriter out = new FileWriter (outputFile);
    int c;
    while ((c = in.read ()) != - 1) out.write (c);

    in.close ();
    out.close ();
}
----------------------------------------

public static void main (String [] args) throws IOException {
    Writer w = new TimeBoxedWriter (new File ("."), "test");
    for (int i = 0;
    i < 500; i ++) {
        w.write ("testing " + i + "\n");
        try {
            Thread.sleep (1000);
        } catch (InterruptedException ie) {
        }
    }
    w.close ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5377118_12203051_18_36
5377118_5382286_1_26
Title: How to convert .txt file to Hadoop's sequence file format 
----------------------------------------

public static void main (String [] args) throws IOException {
    String uri = args [0];
    Configuration conf = new Configuration ();
    FileSystem fs = FileSystem.get (URI.create (uri), conf);
    Path path = new Path (uri);
    IntWritable key = new IntWritable ();
    Text value = new Text ();
    SequenceFile.Writer writer = null;
    try {
        writer = SequenceFile.createWriter (fs, conf, path, key.getClass (), value.getClass ());
        for (int i = 0;
        i < 100; i ++) {
            key.set (100 - i);
            value.set (DATA [i % DATA.length]);
            System.out.printf ("[% s]\t% s\t% s\n", writer.getLength (), key, value);
            writer.append (key, value);
        }
    } finally {
        IOUtils.closeStream (writer);
    }
}
----------------------------------------

public static void main (String [] args) throws IOException, InterruptedException, ClassNotFoundException {
    Configuration conf = new Configuration ();
    Job job = new Job (conf);
    job.setJobName ("Convert Text");
    job.setJarByClass (Mapper.class);
    job.setMapperClass (Mapper.class);
    job.setReducerClass (Reducer.class);
    job.setNumReduceTasks (0);
    job.setOutputKeyClass (LongWritable.class);
    job.setOutputValueClass (Text.class);
    job.setOutputFormatClass (SequenceFileOutputFormat.class);
    job.setInputFormatClass (TextInputFormat.class);
    TextInputFormat.addInputPath (job, new Path ("/lol"));
    SequenceFileOutputFormat.setOutputPath (job, new Path ("/lolz"));
    job.waitForCompletion (true);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5381631_5381652_1_14
5381631_5381683_1_13
Title: Counting left-child nodes in a Tree 
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node.left != null) {
        c += 1 + countLeftNodes (node.left);
    }
    if (node.right != null) {
        c += countLeftNodes (node.right);
    }
    return c;
}
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node != null) {
        if (node.left != null) {
            c = 1 + countLeftNodes (node.left);
        }
        if (node.right != null) {
            c += countLeftNodes (node.right);
        }
    }
    return c;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5381631_5381652_1_14
5381631_5381688_1_19
Title: Counting left-child nodes in a Tree 
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node.left != null) {
        c += 1 + countLeftNodes (node.left);
    }
    if (node.right != null) {
        c += countLeftNodes (node.right);
    }
    return c;
}
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    if (node == null) {
        return 0;
    }
    int c = 0;
    if (node.left != null) {
        c = 1;
    }
    return c + countLeftNodes (node.left) + countLeftNodes (node.right);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5381631_5381652_1_14
5381631_5381739_1_15
Title: Counting left-child nodes in a Tree 
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node.left != null) {
        c += 1 + countLeftNodes (node.left);
    }
    if (node.right != null) {
        c += countLeftNodes (node.right);
    }
    return c;
}
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node.left != null) {
        c ++;
        c += countLeftNodes (node.left)
    }
    if (node.right != null) {
        c += countLeftNodes (node.right);
    }
    return c;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5381631_5381683_1_13
5381631_5381688_1_19
Title: Counting left-child nodes in a Tree 
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node != null) {
        if (node.left != null) {
            c = 1 + countLeftNodes (node.left);
        }
        if (node.right != null) {
            c += countLeftNodes (node.right);
        }
    }
    return c;
}
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    if (node == null) {
        return 0;
    }
    int c = 0;
    if (node.left != null) {
        c = 1;
    }
    return c + countLeftNodes (node.left) + countLeftNodes (node.right);
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5381631_5381683_1_13
5381631_5381739_1_15
Title: Counting left-child nodes in a Tree 
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node != null) {
        if (node.left != null) {
            c = 1 + countLeftNodes (node.left);
        }
        if (node.right != null) {
            c += countLeftNodes (node.right);
        }
    }
    return c;
}
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node.left != null) {
        c ++;
        c += countLeftNodes (node.left)
    }
    if (node.right != null) {
        c += countLeftNodes (node.right);
    }
    return c;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5381631_5381688_1_19
5381631_5381739_1_15
Title: Counting left-child nodes in a Tree 
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    if (node == null) {
        return 0;
    }
    int c = 0;
    if (node.left != null) {
        c = 1;
    }
    return c + countLeftNodes (node.left) + countLeftNodes (node.right);
}
----------------------------------------

private int countLeftNodes (IntTreeNode node) {
    int c = 0;
    if (node.left != null) {
        c ++;
        c += countLeftNodes (node.left)
    }
    if (node.right != null) {
        c += countLeftNodes (node.right);
    }
    return c;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5383596_5383762_5_21
5383596_5383777_7_20
Title: "how to destroy a thread  pause/suspend a thread  resume/runAgain a thread?" 
----------------------------------------

public void run () {
    keepRunning = true;
    try {
        while (keepRunning) {
            if (isPaused) {
                synchronized (this) {
                    wait ();
                    isPaused = false;
                }
            }
        }
    } catch (Exception ex) {
    }
}
----------------------------------------

public void run () {
    while (! finished) {
        updateProgressBar ();
        while (paused && ! finished) {
            try {
                Thread.sleep (1000);
            } catch (InterruptedException e) {
            }
        }
    }
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_16369423_1_14
5388878_5388971_1_17
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public String stringClean (String str) {
    if (str.length () <= 1) return str;

    String adj1 = str.substring (0, 1);
    String adj2 = str.substring (1, 2);
    String rest = str.substring (1);
    if (adj1.equals (adj2)) {
        return stringClean (rest);
    } else return adj1 + stringClean (rest);

}
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) {
        return str;
    }
    char lastChar = str.charAt (0);
    StringBuilder resultBuilder = new StringBuilder ();
    resultBuilder.append (lastChar);
    for (int index = 1;
    index < str.length (); index ++) {
        char next = str.charAt (index);
        if (lastChar != next) {
            resultBuilder.append (next);
            lastChar = next;
        }
    }
    return resultBuilder.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_16369423_1_14
5388878_5388988_1_14
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public String stringClean (String str) {
    if (str.length () <= 1) return str;

    String adj1 = str.substring (0, 1);
    String adj2 = str.substring (1, 2);
    String rest = str.substring (1);
    if (adj1.equals (adj2)) {
        return stringClean (rest);
    } else return adj1 + stringClean (rest);

}
----------------------------------------

public static String stringClean (String str) {
    final StringBuilder sb = new StringBuilder ();
    char lastAppendedChar = '\u0000';
    for (int index = 0;
    index < str.length (); index += 1) {
        char actualChar = str.charAt (index);
        if (actualChar != lastAppendedChar) {
            sb.append (actualChar);
            lastAppendedChar = actualChar;
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_16369423_1_14
5388878_5388995_1_12
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public String stringClean (String str) {
    if (str.length () <= 1) return str;

    String adj1 = str.substring (0, 1);
    String adj2 = str.substring (1, 2);
    String rest = str.substring (1);
    if (adj1.equals (adj2)) {
        return stringClean (rest);
    } else return adj1 + stringClean (rest);

}
----------------------------------------

public static String stringClean (String input) {
    Set < Character > result = new LinkedHashSet < Character > ();
    for (char c : input.toCharArray ()) {
        result.add (c);
    }
    StringBuilder sb = new StringBuilder ();
    for (char c : result) sb.append (c);

    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_16369423_1_14
5388878_5389006_1_12
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public String stringClean (String str) {
    if (str.length () <= 1) return str;

    String adj1 = str.substring (0, 1);
    String adj2 = str.substring (1, 2);
    String rest = str.substring (1);
    if (adj1.equals (adj2)) {
        return stringClean (rest);
    } else return adj1 + stringClean (rest);

}
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) return str;

    StringBuffer buffer = new StringBuffer ();
    char [] chars = str.toCharArray ();
    buffer.append (chars [0]);
    for (int i = 1;
    i < chars.length; i ++) {
        if (chars [i] != chars [i - 1]) buffer.append (chars [i]);

    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_16369423_1_14
5388878_5389222_1_47
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public String stringClean (String str) {
    if (str.length () <= 1) return str;

    String adj1 = str.substring (0, 1);
    String adj2 = str.substring (1, 2);
    String rest = str.substring (1);
    if (adj1.equals (adj2)) {
        return stringClean (rest);
    } else return adj1 + stringClean (rest);

}
----------------------------------------

public static String stringClean (String str) {
    int startIndex = str.indexOf (str);
    char startChar = '\u0000';
    char adjacentChar = '\u0000';
    boolean flag = false;
    System.out.println ("startIndex-->" + startIndex);
    final StringBuilder sb = new StringBuilder ();
    for (startIndex = 0; startIndex < str.length (); startIndex ++) {
        startChar = str.charAt (startIndex);
        System.out.println ("startIndex ::" + startIndex);
        System.out.println ("startChar ::" + startChar);
        final int adjacentPosition = startIndex + 1;
        System.out.println ("adjacentPosition ::" + adjacentPosition);
        if (adjacentPosition != str.length ()) {
            adjacentChar = str.charAt (adjacentPosition);
            System.out.println ("adjacentChar ::" + adjacentChar);
        } else {
            flag = true;
        }
        if (startChar == adjacentChar) {
            System.out.println ("startChar ::" + startChar);
            System.out.println ("adjacentChar::" + adjacentChar);
            System.out.println ("Before Substring string --->" + str);
            str = str.substring (1);
            startIndex --;
            System.out.println ("After Substring string --->" + str);
            System.out.println ("IndexOf check ---->" + sb.toString ().indexOf (startChar));
            if (sb.toString ().indexOf (startChar) != - 1) {
                sb.append (adjacentChar);
                System.out.println ("Appended String in if part-->" + sb.toString ());
            } else if (flag) {
                sb.append (adjacentChar);
            }

        } else {
            str = str.substring (1);
            startIndex --;
            sb.append (startChar);
            System.out.println ("Appended String --->" + sb.toString ());
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_16369423_1_14
5388878_5463004_1_11
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public String stringClean (String str) {
    if (str.length () <= 1) return str;

    String adj1 = str.substring (0, 1);
    String adj2 = str.substring (1, 2);
    String rest = str.substring (1);
    if (adj1.equals (adj2)) {
        return stringClean (rest);
    } else return adj1 + stringClean (rest);

}
----------------------------------------

public String stringClean (String str) {
    if (str.length () < 2) return str;

    String nextStr = str.substring (1);
    if (str.charAt (0) == str.charAt (1)) {
        return stringClean (nextStr);
    } else return str.substring (0, 1) + stringClean (nextStr);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_16369423_1_14
5388878_6353651_1_15
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public String stringClean (String str) {
    if (str.length () <= 1) return str;

    String adj1 = str.substring (0, 1);
    String adj2 = str.substring (1, 2);
    String rest = str.substring (1);
    if (adj1.equals (adj2)) {
        return stringClean (rest);
    } else return adj1 + stringClean (rest);

}
----------------------------------------

public String stringClean (String string) {
    char sc [] = string.toCharArray ();
    for (int i = 0;
    i < sc.length; i ++) {
        if (i != sc.length - 1) {
            if (sc [i] != (sc [i + 1])) {
                output += sc [i];
            }
        } else {
            output += sc [i];
        }
    }
    return output;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388971_1_17
5388878_5388988_1_14
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) {
        return str;
    }
    char lastChar = str.charAt (0);
    StringBuilder resultBuilder = new StringBuilder ();
    resultBuilder.append (lastChar);
    for (int index = 1;
    index < str.length (); index ++) {
        char next = str.charAt (index);
        if (lastChar != next) {
            resultBuilder.append (next);
            lastChar = next;
        }
    }
    return resultBuilder.toString ();
}
----------------------------------------

public static String stringClean (String str) {
    final StringBuilder sb = new StringBuilder ();
    char lastAppendedChar = '\u0000';
    for (int index = 0;
    index < str.length (); index += 1) {
        char actualChar = str.charAt (index);
        if (actualChar != lastAppendedChar) {
            sb.append (actualChar);
            lastAppendedChar = actualChar;
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388971_1_17
5388878_5388995_1_12
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) {
        return str;
    }
    char lastChar = str.charAt (0);
    StringBuilder resultBuilder = new StringBuilder ();
    resultBuilder.append (lastChar);
    for (int index = 1;
    index < str.length (); index ++) {
        char next = str.charAt (index);
        if (lastChar != next) {
            resultBuilder.append (next);
            lastChar = next;
        }
    }
    return resultBuilder.toString ();
}
----------------------------------------

public static String stringClean (String input) {
    Set < Character > result = new LinkedHashSet < Character > ();
    for (char c : input.toCharArray ()) {
        result.add (c);
    }
    StringBuilder sb = new StringBuilder ();
    for (char c : result) sb.append (c);

    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388971_1_17
5388878_5389006_1_12
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) {
        return str;
    }
    char lastChar = str.charAt (0);
    StringBuilder resultBuilder = new StringBuilder ();
    resultBuilder.append (lastChar);
    for (int index = 1;
    index < str.length (); index ++) {
        char next = str.charAt (index);
        if (lastChar != next) {
            resultBuilder.append (next);
            lastChar = next;
        }
    }
    return resultBuilder.toString ();
}
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) return str;

    StringBuffer buffer = new StringBuffer ();
    char [] chars = str.toCharArray ();
    buffer.append (chars [0]);
    for (int i = 1;
    i < chars.length; i ++) {
        if (chars [i] != chars [i - 1]) buffer.append (chars [i]);

    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388971_1_17
5388878_5389222_1_47
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) {
        return str;
    }
    char lastChar = str.charAt (0);
    StringBuilder resultBuilder = new StringBuilder ();
    resultBuilder.append (lastChar);
    for (int index = 1;
    index < str.length (); index ++) {
        char next = str.charAt (index);
        if (lastChar != next) {
            resultBuilder.append (next);
            lastChar = next;
        }
    }
    return resultBuilder.toString ();
}
----------------------------------------

public static String stringClean (String str) {
    int startIndex = str.indexOf (str);
    char startChar = '\u0000';
    char adjacentChar = '\u0000';
    boolean flag = false;
    System.out.println ("startIndex-->" + startIndex);
    final StringBuilder sb = new StringBuilder ();
    for (startIndex = 0; startIndex < str.length (); startIndex ++) {
        startChar = str.charAt (startIndex);
        System.out.println ("startIndex ::" + startIndex);
        System.out.println ("startChar ::" + startChar);
        final int adjacentPosition = startIndex + 1;
        System.out.println ("adjacentPosition ::" + adjacentPosition);
        if (adjacentPosition != str.length ()) {
            adjacentChar = str.charAt (adjacentPosition);
            System.out.println ("adjacentChar ::" + adjacentChar);
        } else {
            flag = true;
        }
        if (startChar == adjacentChar) {
            System.out.println ("startChar ::" + startChar);
            System.out.println ("adjacentChar::" + adjacentChar);
            System.out.println ("Before Substring string --->" + str);
            str = str.substring (1);
            startIndex --;
            System.out.println ("After Substring string --->" + str);
            System.out.println ("IndexOf check ---->" + sb.toString ().indexOf (startChar));
            if (sb.toString ().indexOf (startChar) != - 1) {
                sb.append (adjacentChar);
                System.out.println ("Appended String in if part-->" + sb.toString ());
            } else if (flag) {
                sb.append (adjacentChar);
            }

        } else {
            str = str.substring (1);
            startIndex --;
            sb.append (startChar);
            System.out.println ("Appended String --->" + sb.toString ());
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388971_1_17
5388878_5463004_1_11
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) {
        return str;
    }
    char lastChar = str.charAt (0);
    StringBuilder resultBuilder = new StringBuilder ();
    resultBuilder.append (lastChar);
    for (int index = 1;
    index < str.length (); index ++) {
        char next = str.charAt (index);
        if (lastChar != next) {
            resultBuilder.append (next);
            lastChar = next;
        }
    }
    return resultBuilder.toString ();
}
----------------------------------------

public String stringClean (String str) {
    if (str.length () < 2) return str;

    String nextStr = str.substring (1);
    if (str.charAt (0) == str.charAt (1)) {
        return stringClean (nextStr);
    } else return str.substring (0, 1) + stringClean (nextStr);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388971_1_17
5388878_6353651_1_15
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) {
        return str;
    }
    char lastChar = str.charAt (0);
    StringBuilder resultBuilder = new StringBuilder ();
    resultBuilder.append (lastChar);
    for (int index = 1;
    index < str.length (); index ++) {
        char next = str.charAt (index);
        if (lastChar != next) {
            resultBuilder.append (next);
            lastChar = next;
        }
    }
    return resultBuilder.toString ();
}
----------------------------------------

public String stringClean (String string) {
    char sc [] = string.toCharArray ();
    for (int i = 0;
    i < sc.length; i ++) {
        if (i != sc.length - 1) {
            if (sc [i] != (sc [i + 1])) {
                output += sc [i];
            }
        } else {
            output += sc [i];
        }
    }
    return output;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388988_1_14
5388878_5388995_1_12
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    final StringBuilder sb = new StringBuilder ();
    char lastAppendedChar = '\u0000';
    for (int index = 0;
    index < str.length (); index += 1) {
        char actualChar = str.charAt (index);
        if (actualChar != lastAppendedChar) {
            sb.append (actualChar);
            lastAppendedChar = actualChar;
        }
    }
    return sb.toString ();
}
----------------------------------------

public static String stringClean (String input) {
    Set < Character > result = new LinkedHashSet < Character > ();
    for (char c : input.toCharArray ()) {
        result.add (c);
    }
    StringBuilder sb = new StringBuilder ();
    for (char c : result) sb.append (c);

    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388988_1_14
5388878_5389006_1_12
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    final StringBuilder sb = new StringBuilder ();
    char lastAppendedChar = '\u0000';
    for (int index = 0;
    index < str.length (); index += 1) {
        char actualChar = str.charAt (index);
        if (actualChar != lastAppendedChar) {
            sb.append (actualChar);
            lastAppendedChar = actualChar;
        }
    }
    return sb.toString ();
}
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) return str;

    StringBuffer buffer = new StringBuffer ();
    char [] chars = str.toCharArray ();
    buffer.append (chars [0]);
    for (int i = 1;
    i < chars.length; i ++) {
        if (chars [i] != chars [i - 1]) buffer.append (chars [i]);

    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388988_1_14
5388878_5389222_1_47
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    final StringBuilder sb = new StringBuilder ();
    char lastAppendedChar = '\u0000';
    for (int index = 0;
    index < str.length (); index += 1) {
        char actualChar = str.charAt (index);
        if (actualChar != lastAppendedChar) {
            sb.append (actualChar);
            lastAppendedChar = actualChar;
        }
    }
    return sb.toString ();
}
----------------------------------------

public static String stringClean (String str) {
    int startIndex = str.indexOf (str);
    char startChar = '\u0000';
    char adjacentChar = '\u0000';
    boolean flag = false;
    System.out.println ("startIndex-->" + startIndex);
    final StringBuilder sb = new StringBuilder ();
    for (startIndex = 0; startIndex < str.length (); startIndex ++) {
        startChar = str.charAt (startIndex);
        System.out.println ("startIndex ::" + startIndex);
        System.out.println ("startChar ::" + startChar);
        final int adjacentPosition = startIndex + 1;
        System.out.println ("adjacentPosition ::" + adjacentPosition);
        if (adjacentPosition != str.length ()) {
            adjacentChar = str.charAt (adjacentPosition);
            System.out.println ("adjacentChar ::" + adjacentChar);
        } else {
            flag = true;
        }
        if (startChar == adjacentChar) {
            System.out.println ("startChar ::" + startChar);
            System.out.println ("adjacentChar::" + adjacentChar);
            System.out.println ("Before Substring string --->" + str);
            str = str.substring (1);
            startIndex --;
            System.out.println ("After Substring string --->" + str);
            System.out.println ("IndexOf check ---->" + sb.toString ().indexOf (startChar));
            if (sb.toString ().indexOf (startChar) != - 1) {
                sb.append (adjacentChar);
                System.out.println ("Appended String in if part-->" + sb.toString ());
            } else if (flag) {
                sb.append (adjacentChar);
            }

        } else {
            str = str.substring (1);
            startIndex --;
            sb.append (startChar);
            System.out.println ("Appended String --->" + sb.toString ());
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388988_1_14
5388878_5463004_1_11
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    final StringBuilder sb = new StringBuilder ();
    char lastAppendedChar = '\u0000';
    for (int index = 0;
    index < str.length (); index += 1) {
        char actualChar = str.charAt (index);
        if (actualChar != lastAppendedChar) {
            sb.append (actualChar);
            lastAppendedChar = actualChar;
        }
    }
    return sb.toString ();
}
----------------------------------------

public String stringClean (String str) {
    if (str.length () < 2) return str;

    String nextStr = str.substring (1);
    if (str.charAt (0) == str.charAt (1)) {
        return stringClean (nextStr);
    } else return str.substring (0, 1) + stringClean (nextStr);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388988_1_14
5388878_6353651_1_15
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    final StringBuilder sb = new StringBuilder ();
    char lastAppendedChar = '\u0000';
    for (int index = 0;
    index < str.length (); index += 1) {
        char actualChar = str.charAt (index);
        if (actualChar != lastAppendedChar) {
            sb.append (actualChar);
            lastAppendedChar = actualChar;
        }
    }
    return sb.toString ();
}
----------------------------------------

public String stringClean (String string) {
    char sc [] = string.toCharArray ();
    for (int i = 0;
    i < sc.length; i ++) {
        if (i != sc.length - 1) {
            if (sc [i] != (sc [i + 1])) {
                output += sc [i];
            }
        } else {
            output += sc [i];
        }
    }
    return output;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388995_1_12
5388878_5389006_1_12
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String input) {
    Set < Character > result = new LinkedHashSet < Character > ();
    for (char c : input.toCharArray ()) {
        result.add (c);
    }
    StringBuilder sb = new StringBuilder ();
    for (char c : result) sb.append (c);

    return sb.toString ();
}
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) return str;

    StringBuffer buffer = new StringBuffer ();
    char [] chars = str.toCharArray ();
    buffer.append (chars [0]);
    for (int i = 1;
    i < chars.length; i ++) {
        if (chars [i] != chars [i - 1]) buffer.append (chars [i]);

    }
    return buffer.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388995_1_12
5388878_5389222_1_47
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String input) {
    Set < Character > result = new LinkedHashSet < Character > ();
    for (char c : input.toCharArray ()) {
        result.add (c);
    }
    StringBuilder sb = new StringBuilder ();
    for (char c : result) sb.append (c);

    return sb.toString ();
}
----------------------------------------

public static String stringClean (String str) {
    int startIndex = str.indexOf (str);
    char startChar = '\u0000';
    char adjacentChar = '\u0000';
    boolean flag = false;
    System.out.println ("startIndex-->" + startIndex);
    final StringBuilder sb = new StringBuilder ();
    for (startIndex = 0; startIndex < str.length (); startIndex ++) {
        startChar = str.charAt (startIndex);
        System.out.println ("startIndex ::" + startIndex);
        System.out.println ("startChar ::" + startChar);
        final int adjacentPosition = startIndex + 1;
        System.out.println ("adjacentPosition ::" + adjacentPosition);
        if (adjacentPosition != str.length ()) {
            adjacentChar = str.charAt (adjacentPosition);
            System.out.println ("adjacentChar ::" + adjacentChar);
        } else {
            flag = true;
        }
        if (startChar == adjacentChar) {
            System.out.println ("startChar ::" + startChar);
            System.out.println ("adjacentChar::" + adjacentChar);
            System.out.println ("Before Substring string --->" + str);
            str = str.substring (1);
            startIndex --;
            System.out.println ("After Substring string --->" + str);
            System.out.println ("IndexOf check ---->" + sb.toString ().indexOf (startChar));
            if (sb.toString ().indexOf (startChar) != - 1) {
                sb.append (adjacentChar);
                System.out.println ("Appended String in if part-->" + sb.toString ());
            } else if (flag) {
                sb.append (adjacentChar);
            }

        } else {
            str = str.substring (1);
            startIndex --;
            sb.append (startChar);
            System.out.println ("Appended String --->" + sb.toString ());
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388995_1_12
5388878_5463004_1_11
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String input) {
    Set < Character > result = new LinkedHashSet < Character > ();
    for (char c : input.toCharArray ()) {
        result.add (c);
    }
    StringBuilder sb = new StringBuilder ();
    for (char c : result) sb.append (c);

    return sb.toString ();
}
----------------------------------------

public String stringClean (String str) {
    if (str.length () < 2) return str;

    String nextStr = str.substring (1);
    if (str.charAt (0) == str.charAt (1)) {
        return stringClean (nextStr);
    } else return str.substring (0, 1) + stringClean (nextStr);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5388995_1_12
5388878_6353651_1_15
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String input) {
    Set < Character > result = new LinkedHashSet < Character > ();
    for (char c : input.toCharArray ()) {
        result.add (c);
    }
    StringBuilder sb = new StringBuilder ();
    for (char c : result) sb.append (c);

    return sb.toString ();
}
----------------------------------------

public String stringClean (String string) {
    char sc [] = string.toCharArray ();
    for (int i = 0;
    i < sc.length; i ++) {
        if (i != sc.length - 1) {
            if (sc [i] != (sc [i + 1])) {
                output += sc [i];
            }
        } else {
            output += sc [i];
        }
    }
    return output;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5389006_1_12
5388878_5389222_1_47
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) return str;

    StringBuffer buffer = new StringBuffer ();
    char [] chars = str.toCharArray ();
    buffer.append (chars [0]);
    for (int i = 1;
    i < chars.length; i ++) {
        if (chars [i] != chars [i - 1]) buffer.append (chars [i]);

    }
    return buffer.toString ();
}
----------------------------------------

public static String stringClean (String str) {
    int startIndex = str.indexOf (str);
    char startChar = '\u0000';
    char adjacentChar = '\u0000';
    boolean flag = false;
    System.out.println ("startIndex-->" + startIndex);
    final StringBuilder sb = new StringBuilder ();
    for (startIndex = 0; startIndex < str.length (); startIndex ++) {
        startChar = str.charAt (startIndex);
        System.out.println ("startIndex ::" + startIndex);
        System.out.println ("startChar ::" + startChar);
        final int adjacentPosition = startIndex + 1;
        System.out.println ("adjacentPosition ::" + adjacentPosition);
        if (adjacentPosition != str.length ()) {
            adjacentChar = str.charAt (adjacentPosition);
            System.out.println ("adjacentChar ::" + adjacentChar);
        } else {
            flag = true;
        }
        if (startChar == adjacentChar) {
            System.out.println ("startChar ::" + startChar);
            System.out.println ("adjacentChar::" + adjacentChar);
            System.out.println ("Before Substring string --->" + str);
            str = str.substring (1);
            startIndex --;
            System.out.println ("After Substring string --->" + str);
            System.out.println ("IndexOf check ---->" + sb.toString ().indexOf (startChar));
            if (sb.toString ().indexOf (startChar) != - 1) {
                sb.append (adjacentChar);
                System.out.println ("Appended String in if part-->" + sb.toString ());
            } else if (flag) {
                sb.append (adjacentChar);
            }

        } else {
            str = str.substring (1);
            startIndex --;
            sb.append (startChar);
            System.out.println ("Appended String --->" + sb.toString ());
        }
    }
    return sb.toString ();
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5389006_1_12
5388878_5463004_1_11
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) return str;

    StringBuffer buffer = new StringBuffer ();
    char [] chars = str.toCharArray ();
    buffer.append (chars [0]);
    for (int i = 1;
    i < chars.length; i ++) {
        if (chars [i] != chars [i - 1]) buffer.append (chars [i]);

    }
    return buffer.toString ();
}
----------------------------------------

public String stringClean (String str) {
    if (str.length () < 2) return str;

    String nextStr = str.substring (1);
    if (str.charAt (0) == str.charAt (1)) {
        return stringClean (nextStr);
    } else return str.substring (0, 1) + stringClean (nextStr);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5389006_1_12
5388878_6353651_1_15
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    if (str == null || "".equals (str)) return str;

    StringBuffer buffer = new StringBuffer ();
    char [] chars = str.toCharArray ();
    buffer.append (chars [0]);
    for (int i = 1;
    i < chars.length; i ++) {
        if (chars [i] != chars [i - 1]) buffer.append (chars [i]);

    }
    return buffer.toString ();
}
----------------------------------------

public String stringClean (String string) {
    char sc [] = string.toCharArray ();
    for (int i = 0;
    i < sc.length; i ++) {
        if (i != sc.length - 1) {
            if (sc [i] != (sc [i + 1])) {
                output += sc [i];
            }
        } else {
            output += sc [i];
        }
    }
    return output;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5389222_1_47
5388878_5463004_1_11
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    int startIndex = str.indexOf (str);
    char startChar = '\u0000';
    char adjacentChar = '\u0000';
    boolean flag = false;
    System.out.println ("startIndex-->" + startIndex);
    final StringBuilder sb = new StringBuilder ();
    for (startIndex = 0; startIndex < str.length (); startIndex ++) {
        startChar = str.charAt (startIndex);
        System.out.println ("startIndex ::" + startIndex);
        System.out.println ("startChar ::" + startChar);
        final int adjacentPosition = startIndex + 1;
        System.out.println ("adjacentPosition ::" + adjacentPosition);
        if (adjacentPosition != str.length ()) {
            adjacentChar = str.charAt (adjacentPosition);
            System.out.println ("adjacentChar ::" + adjacentChar);
        } else {
            flag = true;
        }
        if (startChar == adjacentChar) {
            System.out.println ("startChar ::" + startChar);
            System.out.println ("adjacentChar::" + adjacentChar);
            System.out.println ("Before Substring string --->" + str);
            str = str.substring (1);
            startIndex --;
            System.out.println ("After Substring string --->" + str);
            System.out.println ("IndexOf check ---->" + sb.toString ().indexOf (startChar));
            if (sb.toString ().indexOf (startChar) != - 1) {
                sb.append (adjacentChar);
                System.out.println ("Appended String in if part-->" + sb.toString ());
            } else if (flag) {
                sb.append (adjacentChar);
            }

        } else {
            str = str.substring (1);
            startIndex --;
            sb.append (startChar);
            System.out.println ("Appended String --->" + sb.toString ());
        }
    }
    return sb.toString ();
}
----------------------------------------

public String stringClean (String str) {
    if (str.length () < 2) return str;

    String nextStr = str.substring (1);
    if (str.charAt (0) == str.charAt (1)) {
        return stringClean (nextStr);
    } else return str.substring (0, 1) + stringClean (nextStr);

}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5389222_1_47
5388878_6353651_1_15
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public static String stringClean (String str) {
    int startIndex = str.indexOf (str);
    char startChar = '\u0000';
    char adjacentChar = '\u0000';
    boolean flag = false;
    System.out.println ("startIndex-->" + startIndex);
    final StringBuilder sb = new StringBuilder ();
    for (startIndex = 0; startIndex < str.length (); startIndex ++) {
        startChar = str.charAt (startIndex);
        System.out.println ("startIndex ::" + startIndex);
        System.out.println ("startChar ::" + startChar);
        final int adjacentPosition = startIndex + 1;
        System.out.println ("adjacentPosition ::" + adjacentPosition);
        if (adjacentPosition != str.length ()) {
            adjacentChar = str.charAt (adjacentPosition);
            System.out.println ("adjacentChar ::" + adjacentChar);
        } else {
            flag = true;
        }
        if (startChar == adjacentChar) {
            System.out.println ("startChar ::" + startChar);
            System.out.println ("adjacentChar::" + adjacentChar);
            System.out.println ("Before Substring string --->" + str);
            str = str.substring (1);
            startIndex --;
            System.out.println ("After Substring string --->" + str);
            System.out.println ("IndexOf check ---->" + sb.toString ().indexOf (startChar));
            if (sb.toString ().indexOf (startChar) != - 1) {
                sb.append (adjacentChar);
                System.out.println ("Appended String in if part-->" + sb.toString ());
            } else if (flag) {
                sb.append (adjacentChar);
            }

        } else {
            str = str.substring (1);
            startIndex --;
            sb.append (startChar);
            System.out.println ("Appended String --->" + sb.toString ());
        }
    }
    return sb.toString ();
}
----------------------------------------

public String stringClean (String string) {
    char sc [] = string.toCharArray ();
    for (int i = 0;
    i < sc.length; i ++) {
        if (i != sc.length - 1) {
            if (sc [i] != (sc [i + 1])) {
                output += sc [i];
            }
        } else {
            output += sc [i];
        }
    }
    return output;
}
----------------------------------------
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
0
0
0
5388878_5463004_1_11
5388878_6353651_1_15
Title: Java String Manipulation : Comparing adjacent Characters in Java 
----------------------------------------

public String stringClean (String str) {
    if (str.length () < 2) return str;

    String nextStr = str.substring (1);
    if (str.charAt (0) == str.charAt (1)) {
        return stringClean (nextStr);
    } else return str.substring (0, 1) + stringClean (nextStr);

}
----------------------------------------

public String stringClean (String string) {
    char sc [] = string.toCharArray ();
    for (int i = 0;
    i < sc.length; i ++) {
        if (i != sc.length - 1) {
            if (sc [i] != (sc [i + 1])) {
                output += sc [i];
            }
        } else {
            output += sc [i];
        }
    }
    return output;
}
----------------------------------------
